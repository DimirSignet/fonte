{"sha": "b1686009b5494119575d43525b0829162ab79853", "log": "Move main source to src/main/java  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/ArrayUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3;\n+\n+import java.lang.reflect.Array;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.lang3.builder.EqualsBuilder;\n+import org.apache.commons.lang3.builder.ToStringBuilder;\n+import org.apache.commons.lang3.builder.ToStringStyle;\n+\n+/**\n+ * <p>Operations on arrays, primitive arrays (like <code>int[]</code>) and\n+ * primitive wrapper arrays (like <code>Integer[]</code>).</p>\n+ *\n+ * <p>This class tries to handle <code>null</code> input gracefully.\n+ * An exception will not be thrown for a <code>null</code>\n+ * array input. However, an Object array that contains a <code>null</code>\n+ * element may throw an exception. Each method documents its behaviour.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author Moritz Petersen\n+ * @author <a href=\"mailto:fredrik@westermarck.com\">Fredrik Westermarck</a>\n+ * @author Nikolay Metchev\n+ * @author Matthew Hawthorne\n+ * @author Tim O'Brien\n+ * @author Pete Gieser\n+ * @author Gary Gregory\n+ * @author <a href=\"mailto:equinus100@hotmail.com\">Ashwin S</a>\n+ * @author Maarten Coene\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class ArrayUtils {\n+\n+    /**\n+     * An empty immutable <code>Object</code> array.\n+     */\n+    public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\n+    /**\n+     * An empty immutable <code>Class</code> array.\n+     */\n+    public static final Class<?>[] EMPTY_CLASS_ARRAY = new Class[0];\n+    /**\n+     * An empty immutable <code>String</code> array.\n+     */\n+    public static final String[] EMPTY_STRING_ARRAY = new String[0];\n+    /**\n+     * An empty immutable <code>long</code> array.\n+     */\n+    public static final long[] EMPTY_LONG_ARRAY = new long[0];\n+    /**\n+     * An empty immutable <code>Long</code> array.\n+     */\n+    public static final Long[] EMPTY_LONG_OBJECT_ARRAY = new Long[0];\n+    /**\n+     * An empty immutable <code>int</code> array.\n+     */\n+    public static final int[] EMPTY_INT_ARRAY = new int[0];\n+    /**\n+     * An empty immutable <code>Integer</code> array.\n+     */\n+    public static final Integer[] EMPTY_INTEGER_OBJECT_ARRAY = new Integer[0];\n+    /**\n+     * An empty immutable <code>short</code> array.\n+     */\n+    public static final short[] EMPTY_SHORT_ARRAY = new short[0];\n+    /**\n+     * An empty immutable <code>Short</code> array.\n+     */\n+    public static final Short[] EMPTY_SHORT_OBJECT_ARRAY = new Short[0];\n+    /**\n+     * An empty immutable <code>byte</code> array.\n+     */\n+    public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n+    /**\n+     * An empty immutable <code>Byte</code> array.\n+     */\n+    public static final Byte[] EMPTY_BYTE_OBJECT_ARRAY = new Byte[0];\n+    /**\n+     * An empty immutable <code>double</code> array.\n+     */\n+    public static final double[] EMPTY_DOUBLE_ARRAY = new double[0];\n+    /**\n+     * An empty immutable <code>Double</code> array.\n+     */\n+    public static final Double[] EMPTY_DOUBLE_OBJECT_ARRAY = new Double[0];\n+    /**\n+     * An empty immutable <code>float</code> array.\n+     */\n+    public static final float[] EMPTY_FLOAT_ARRAY = new float[0];\n+    /**\n+     * An empty immutable <code>Float</code> array.\n+     */\n+    public static final Float[] EMPTY_FLOAT_OBJECT_ARRAY = new Float[0];\n+    /**\n+     * An empty immutable <code>boolean</code> array.\n+     */\n+    public static final boolean[] EMPTY_BOOLEAN_ARRAY = new boolean[0];\n+    /**\n+     * An empty immutable <code>Boolean</code> array.\n+     */\n+    public static final Boolean[] EMPTY_BOOLEAN_OBJECT_ARRAY = new Boolean[0];\n+    /**\n+     * An empty immutable <code>char</code> array.\n+     */\n+    public static final char[] EMPTY_CHAR_ARRAY = new char[0];\n+    /**\n+     * An empty immutable <code>Character</code> array.\n+     */\n+    public static final Character[] EMPTY_CHARACTER_OBJECT_ARRAY = new Character[0];\n+\n+    /**\n+     * The index value when an element is not found in a list or array: <code>-1</code>.\n+     * This value is returned by methods in this class and can also be used in comparisons with values returned by\n+     * various method from {@link java.util.List}.\n+     */\n+    public static final int INDEX_NOT_FOUND = -1;\n+\n+    /**\n+     * <p>ArrayUtils instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as <code>ArrayUtils.clone(new int[] {2})</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n+     */\n+    public ArrayUtils() {\n+      super();\n+    }\n+\n+    // Basic methods handling multi-dimensional arrays\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Outputs an array as a String, treating <code>null</code> as an empty array.</p>\n+     *\n+     * <p>Multi-dimensional arrays are handled correctly, including\n+     * multi-dimensional primitive arrays.</p>\n+     *\n+     * <p>The format is that of Java source code, for example <code>{a,b}</code>.</p>\n+     *\n+     * @param array  the array to get a toString for, may be <code>null</code>\n+     * @return a String representation of the array, '{}' if null array input\n+     */\n+    public static String toString(Object array) {\n+        return toString(array, \"{}\");\n+    }\n+\n+    /**\n+     * <p>Outputs an array as a String handling <code>null</code>s.</p>\n+     *\n+     * <p>Multi-dimensional arrays are handled correctly, including\n+     * multi-dimensional primitive arrays.</p>\n+     *\n+     * <p>The format is that of Java source code, for example <code>{a,b}</code>.</p>\n+     *\n+     * @param array  the array to get a toString for, may be <code>null</code>\n+     * @param stringIfNull  the String to return if the array is <code>null</code>\n+     * @return a String representation of the array\n+     */\n+    public static String toString(Object array, String stringIfNull) {\n+        if (array == null) {\n+            return stringIfNull;\n+        }\n+        return new ToStringBuilder(array, ToStringStyle.SIMPLE_STYLE).append(array).toString();\n+    }\n+\n+    /**\n+     * <p>Compares two arrays, using equals(), handling multi-dimensional arrays\n+     * correctly.</p>\n+     *\n+     * <p>Multi-dimensional primitive arrays are also handled correctly by this method.</p>\n+     *\n+     * @param array1  the left hand array to compare, may be <code>null</code>\n+     * @param array2  the right hand array to compare, may be <code>null</code>\n+     * @return <code>true</code> if the arrays are equal\n+     */\n+    public static boolean isEquals(Object array1, Object array2) {\n+        return new EqualsBuilder().append(array1, array2).isEquals();\n+    }\n+\n+    // To map\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts the given array into a {@link java.util.Map}. Each element of the array\n+     * must be either a {@link java.util.Map.Entry} or an Array, containing at least two\n+     * elements, where the first element is used as key and the second as\n+     * value.</p>\n+     *\n+     * <p>This method can be used to initialize:</p>\n+     * <pre>\n+     * // Create a Map mapping colors.\n+     * Map colorMap = MapUtils.toMap(new String[][] {{\n+     *     {\"RED\", \"#FF0000\"},\n+     *     {\"GREEN\", \"#00FF00\"},\n+     *     {\"BLUE\", \"#0000FF\"}});\n+     * </pre>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  an array whose elements are either a {@link java.util.Map.Entry} or\n+     *  an Array containing at least two elements, may be <code>null</code>\n+     * @return a <code>Map</code> that was created from the array\n+     * @throws IllegalArgumentException  if one element of this Array is\n+     *  itself an Array containing less then two elements\n+     * @throws IllegalArgumentException  if the array contains elements other\n+     *  than {@link java.util.Map.Entry} and an Array\n+     */\n+    public static Map<Object, Object> toMap(Object[] array) {\n+        if (array == null) {\n+            return null;\n+        }\n+        final Map<Object, Object> map = new HashMap<Object, Object>((int) (array.length * 1.5));\n+        for (int i = 0; i < array.length; i++) {\n+            Object object = array[i];\n+            if (object instanceof Map.Entry<?, ?>) {\n+                Map.Entry<?,?> entry = (Map.Entry<?,?>) object;\n+                map.put(entry.getKey(), entry.getValue());\n+            } else if (object instanceof Object[]) {\n+                Object[] entry = (Object[]) object;\n+                if (entry.length < 2) {\n+                    throw new IllegalArgumentException(\"Array element \" + i + \", '\"\n+                        + object\n+                        + \"', has a length less than 2\");\n+                }\n+                map.put(entry[0], entry[1]);\n+            } else {\n+                throw new IllegalArgumentException(\"Array element \" + i + \", '\"\n+                        + object\n+                        + \"', is neither of type Map.Entry nor an Array\");\n+            }\n+        }\n+        return map;\n+    }\n+\n+    // Generic array\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Create a type-safe generic array.\n+     *\n+     * <p>Arrays are covariant i.e. they cannot be created from a generic type:</p>\n+     *\n+     * <pre>\n+    public static &lt;T&gt; T[] createAnArray(int size)\n+    {\n+        return T[size]; // compiler error here\n+    }\n+    public static &lt;T&gt; T[] createAnArray(int size)\n+    {\n+        return (T[])Object[size]; // ClassCastException at runtime\n+    }\n+     * </pre>\n+     *\n+     * <p>Therefore new arrays of generic types can be created with this method, e.g. an arrays\n+     * of Strings:</p>\n+     *\n+     * <pre>\n+    String[] array = ArrayUtils.toArray(\"1\", \"2\");\n+    String[] emptyArray = ArrayUtils.&lt;String&gt;toArray();\n+     * </pre>\n+     * \n+     * The method is typically used in scenarios, where the caller itself uses generic types\n+     * that have to be combined into an array.\n+     * \n+     * Note, this method makes only sense to provide arguments of the same type so that the\n+     * compiler can deduce the type of the array itself. While it is possible to select the\n+     * type explicitly like in <code>Number[] array = ArrayUtils.<Number>toArray(new\n+     * Integer(42), new Double(Math.PI))</code>, there is no real advantage to <code>new\n+     * Number[] {new Integer(42), new Double(Math.PI)}</code> anymore.\n+     *\n+     * @param  <T>   the array's element type\n+     * @param  items the items of the array\n+     * @return the array\n+     * @since  3.0\n+     */\n+    public static <T> T[] toArray(final T... items)\n+    {\n+        return items;\n+    }\n+    \n+    // Clone\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Shallow clones an array returning a typecast result and handling\n+     * <code>null</code>.</p>\n+     *\n+     * <p>The objects in the array are not cloned, thus there is no special\n+     * handling for multi-dimensional arrays.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to shallow clone, may be <code>null</code>\n+     * @return the cloned array, <code>null</code> if <code>null</code> input\n+     */\n+    public static <T> T[] clone(T[] array) {\n+        if (array == null) {\n+            return null;\n+        }\n+        return array.clone();\n+    }\n+\n+    /**\n+     * <p>Clones an array returning a typecast result and handling\n+     * <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to clone, may be <code>null</code>\n+     * @return the cloned array, <code>null</code> if <code>null</code> input\n+     */\n+    public static long[] clone(long[] array) {\n+        if (array == null) {\n+            return null;\n+        }\n+        return array.clone();\n+    }\n+\n+    /**\n+     * <p>Clones an array returning a typecast result and handling\n+     * <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to clone, may be <code>null</code>\n+     * @return the cloned array, <code>null</code> if <code>null</code> input\n+     */\n+    public static int[] clone(int[] array) {\n+        if (array == null) {\n+            return null;\n+        }\n+        return array.clone();\n+    }\n+\n+    /**\n+     * <p>Clones an array returning a typecast result and handling\n+     * <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to clone, may be <code>null</code>\n+     * @return the cloned array, <code>null</code> if <code>null</code> input\n+     */\n+    public static short[] clone(short[] array) {\n+        if (array == null) {\n+            return null;\n+        }\n+        return array.clone();\n+    }\n+\n+    /**\n+     * <p>Clones an array returning a typecast result and handling\n+     * <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to clone, may be <code>null</code>\n+     * @return the cloned array, <code>null</code> if <code>null</code> input\n+     */\n+    public static char[] clone(char[] array) {\n+        if (array == null) {\n+            return null;\n+        }\n+        return array.clone();\n+    }\n+\n+    /**\n+     * <p>Clones an array returning a typecast result and handling\n+     * <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to clone, may be <code>null</code>\n+     * @return the cloned array, <code>null</code> if <code>null</code> input\n+     */\n+    public static byte[] clone(byte[] array) {\n+        if (array == null) {\n+            return null;\n+        }\n+        return array.clone();\n+    }\n+\n+    /**\n+     * <p>Clones an array returning a typecast result and handling\n+     * <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to clone, may be <code>null</code>\n+     * @return the cloned array, <code>null</code> if <code>null</code> input\n+     */\n+    public static double[] clone(double[] array) {\n+        if (array == null) {\n+            return null;\n+        }\n+        return array.clone();\n+    }\n+\n+    /**\n+     * <p>Clones an array returning a typecast result and handling\n+     * <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to clone, may be <code>null</code>\n+     * @return the cloned array, <code>null</code> if <code>null</code> input\n+     */\n+    public static float[] clone(float[] array) {\n+        if (array == null) {\n+            return null;\n+        }\n+        return array.clone();\n+    }\n+\n+    /**\n+     * <p>Clones an array returning a typecast result and handling\n+     * <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to clone, may be <code>null</code>\n+     * @return the cloned array, <code>null</code> if <code>null</code> input\n+     */\n+    public static boolean[] clone(boolean[] array) {\n+        if (array == null) {\n+            return null;\n+        }\n+        return array.clone();\n+    }\n+\n+    // Subarrays\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Produces a new array containing the elements between\n+     * the start and end indices.</p>\n+     *\n+     * <p>The start index is inclusive, the end index exclusive.\n+     * Null array input produces null output.</p>\n+     *\n+     * <p>The component type of the subarray is always the same as\n+     * that of the input array. Thus, if the input is an array of type\n+     * <code>Date</code>, the following usage is envisaged:</p>\n+     *\n+     * <pre>\n+     * Date[] someDates = (Date[])ArrayUtils.subarray(allDates, 2, 5);\n+     * </pre>\n+     *\n+     * @param array  the array\n+     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n+     *      is promoted to 0, overvalue (&gt;array.length) results\n+     *      in an empty array.\n+     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n+     *      returned subarray. Undervalue (&lt; startIndex) produces\n+     *      empty array, overvalue (&gt;array.length) is demoted to\n+     *      array length.\n+     * @return a new array containing the elements between\n+     *      the start and end indices.\n+     * @since 2.1\n+     */\n+    public static <T> T[] subarray(T[] array, int startIndexInclusive, int endIndexExclusive) {\n+        if (array == null) {\n+            return null;\n+        }\n+        if (startIndexInclusive < 0) {\n+            startIndexInclusive = 0;\n+        }\n+        if (endIndexExclusive > array.length) {\n+            endIndexExclusive = array.length;\n+        }\n+        int newSize = endIndexExclusive - startIndexInclusive;\n+        Class<?> type = array.getClass().getComponentType();\n+        if (newSize <= 0) {\n+            @SuppressWarnings(\"unchecked\") // OK, because array is of type T\n+            final T[] emptyArray = (T[]) Array.newInstance(type, 0);\n+            return emptyArray;\n+        }\n+        @SuppressWarnings(\"unchecked\") // OK, because array is of type T\n+        T[] subarray = (T[]) Array.newInstance(type, newSize);\n+        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n+        return subarray;\n+    }\n+\n+    /**\n+     * <p>Produces a new <code>long</code> array containing the elements\n+     * between the start and end indices.</p>\n+     *\n+     * <p>The start index is inclusive, the end index exclusive.\n+     * Null array input produces null output.</p>\n+     *\n+     * @param array  the array\n+     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n+     *      is promoted to 0, overvalue (&gt;array.length) results\n+     *      in an empty array.\n+     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n+     *      returned subarray. Undervalue (&lt; startIndex) produces\n+     *      empty array, overvalue (&gt;array.length) is demoted to\n+     *      array length.\n+     * @return a new array containing the elements between\n+     *      the start and end indices.\n+     * @since 2.1\n+     */\n+    public static long[] subarray(long[] array, int startIndexInclusive, int endIndexExclusive) {\n+        if (array == null) {\n+            return null;\n+        }\n+        if (startIndexInclusive < 0) {\n+            startIndexInclusive = 0;\n+        }\n+        if (endIndexExclusive > array.length) {\n+            endIndexExclusive = array.length;\n+        }\n+        int newSize = endIndexExclusive - startIndexInclusive;\n+        if (newSize <= 0) {\n+            return EMPTY_LONG_ARRAY;\n+        }\n+\n+        long[] subarray = new long[newSize];\n+        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n+        return subarray;\n+    }\n+\n+    /**\n+     * <p>Produces a new <code>int</code> array containing the elements\n+     * between the start and end indices.</p>\n+     *\n+     * <p>The start index is inclusive, the end index exclusive.\n+     * Null array input produces null output.</p>\n+     *\n+     * @param array  the array\n+     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n+     *      is promoted to 0, overvalue (&gt;array.length) results\n+     *      in an empty array.\n+     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n+     *      returned subarray. Undervalue (&lt; startIndex) produces\n+     *      empty array, overvalue (&gt;array.length) is demoted to\n+     *      array length.\n+     * @return a new array containing the elements between\n+     *      the start and end indices.\n+     * @since 2.1\n+     */\n+    public static int[] subarray(int[] array, int startIndexInclusive, int endIndexExclusive) {\n+        if (array == null) {\n+            return null;\n+        }\n+        if (startIndexInclusive < 0) {\n+            startIndexInclusive = 0;\n+        }\n+        if (endIndexExclusive > array.length) {\n+            endIndexExclusive = array.length;\n+        }\n+        int newSize = endIndexExclusive - startIndexInclusive;\n+        if (newSize <= 0) {\n+            return EMPTY_INT_ARRAY;\n+        }\n+\n+        int[] subarray = new int[newSize];\n+        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n+        return subarray;\n+    }\n+\n+    /**\n+     * <p>Produces a new <code>short</code> array containing the elements\n+     * between the start and end indices.</p>\n+     *\n+     * <p>The start index is inclusive, the end index exclusive.\n+     * Null array input produces null output.</p>\n+     *\n+     * @param array  the array\n+     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n+     *      is promoted to 0, overvalue (&gt;array.length) results\n+     *      in an empty array.\n+     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n+     *      returned subarray. Undervalue (&lt; startIndex) produces\n+     *      empty array, overvalue (&gt;array.length) is demoted to\n+     *      array length.\n+     * @return a new array containing the elements between\n+     *      the start and end indices.\n+     * @since 2.1\n+     */\n+    public static short[] subarray(short[] array, int startIndexInclusive, int endIndexExclusive) {\n+        if (array == null) {\n+            return null;\n+        }\n+        if (startIndexInclusive < 0) {\n+            startIndexInclusive = 0;\n+        }\n+        if (endIndexExclusive > array.length) {\n+            endIndexExclusive = array.length;\n+        }\n+        int newSize = endIndexExclusive - startIndexInclusive;\n+        if (newSize <= 0) {\n+            return EMPTY_SHORT_ARRAY;\n+        }\n+\n+        short[] subarray = new short[newSize];\n+        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n+        return subarray;\n+    }\n+\n+    /**\n+     * <p>Produces a new <code>char</code> array containing the elements\n+     * between the start and end indices.</p>\n+     *\n+     * <p>The start index is inclusive, the end index exclusive.\n+     * Null array input produces null output.</p>\n+     *\n+     * @param array  the array\n+     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n+     *      is promoted to 0, overvalue (&gt;array.length) results\n+     *      in an empty array.\n+     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n+     *      returned subarray. Undervalue (&lt; startIndex) produces\n+     *      empty array, overvalue (&gt;array.length) is demoted to\n+     *      array length.\n+     * @return a new array containing the elements between\n+     *      the start and end indices.\n+     * @since 2.1\n+     */\n+    public static char[] subarray(char[] array, int startIndexInclusive, int endIndexExclusive) {\n+        if (array == null) {\n+            return null;\n+        }\n+        if (startIndexInclusive < 0) {\n+            startIndexInclusive = 0;\n+        }\n+        if (endIndexExclusive > array.length) {\n+            endIndexExclusive = array.length;\n+        }\n+        int newSize = endIndexExclusive - startIndexInclusive;\n+        if (newSize <= 0) {\n+            return EMPTY_CHAR_ARRAY;\n+        }\n+\n+        char[] subarray = new char[newSize];\n+        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n+        return subarray;\n+    }\n+\n+    /**\n+     * <p>Produces a new <code>byte</code> array containing the elements\n+     * between the start and end indices.</p>\n+     *\n+     * <p>The start index is inclusive, the end index exclusive.\n+     * Null array input produces null output.</p>\n+     *\n+     * @param array  the array\n+     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n+     *      is promoted to 0, overvalue (&gt;array.length) results\n+     *      in an empty array.\n+     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n+     *      returned subarray. Undervalue (&lt; startIndex) produces\n+     *      empty array, overvalue (&gt;array.length) is demoted to\n+     *      array length.\n+     * @return a new array containing the elements between\n+     *      the start and end indices.\n+     * @since 2.1\n+     */\n+    public static byte[] subarray(byte[] array, int startIndexInclusive, int endIndexExclusive) {\n+        if (array == null) {\n+            return null;\n+        }\n+        if (startIndexInclusive < 0) {\n+            startIndexInclusive = 0;\n+        }\n+        if (endIndexExclusive > array.length) {\n+            endIndexExclusive = array.length;\n+        }\n+        int newSize = endIndexExclusive - startIndexInclusive;\n+        if (newSize <= 0) {\n+            return EMPTY_BYTE_ARRAY;\n+        }\n+\n+        byte[] subarray = new byte[newSize];\n+        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n+        return subarray;\n+    }\n+\n+    /**\n+     * <p>Produces a new <code>double</code> array containing the elements\n+     * between the start and end indices.</p>\n+     *\n+     * <p>The start index is inclusive, the end index exclusive.\n+     * Null array input produces null output.</p>\n+     *\n+     * @param array  the array\n+     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n+     *      is promoted to 0, overvalue (&gt;array.length) results\n+     *      in an empty array.\n+     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n+     *      returned subarray. Undervalue (&lt; startIndex) produces\n+     *      empty array, overvalue (&gt;array.length) is demoted to\n+     *      array length.\n+     * @return a new array containing the elements between\n+     *      the start and end indices.\n+     * @since 2.1\n+     */\n+    public static double[] subarray(double[] array, int startIndexInclusive, int endIndexExclusive) {\n+        if (array == null) {\n+            return null;\n+        }\n+        if (startIndexInclusive < 0) {\n+            startIndexInclusive = 0;\n+        }\n+        if (endIndexExclusive > array.length) {\n+            endIndexExclusive = array.length;\n+        }\n+        int newSize = endIndexExclusive - startIndexInclusive;\n+        if (newSize <= 0) {\n+            return EMPTY_DOUBLE_ARRAY;\n+        }\n+\n+        double[] subarray = new double[newSize];\n+        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n+        return subarray;\n+    }\n+\n+    /**\n+     * <p>Produces a new <code>float</code> array containing the elements\n+     * between the start and end indices.</p>\n+     *\n+     * <p>The start index is inclusive, the end index exclusive.\n+     * Null array input produces null output.</p>\n+     *\n+     * @param array  the array\n+     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n+     *      is promoted to 0, overvalue (&gt;array.length) results\n+     *      in an empty array.\n+     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n+     *      returned subarray. Undervalue (&lt; startIndex) produces\n+     *      empty array, overvalue (&gt;array.length) is demoted to\n+     *      array length.\n+     * @return a new array containing the elements between\n+     *      the start and end indices.\n+     * @since 2.1\n+     */\n+    public static float[] subarray(float[] array, int startIndexInclusive, int endIndexExclusive) {\n+        if (array == null) {\n+            return null;\n+        }\n+        if (startIndexInclusive < 0) {\n+            startIndexInclusive = 0;\n+        }\n+        if (endIndexExclusive > array.length) {\n+            endIndexExclusive = array.length;\n+        }\n+        int newSize = endIndexExclusive - startIndexInclusive;\n+        if (newSize <= 0) {\n+            return EMPTY_FLOAT_ARRAY;\n+        }\n+\n+        float[] subarray = new float[newSize];\n+        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n+        return subarray;\n+    }\n+\n+    /**\n+     * <p>Produces a new <code>boolean</code> array containing the elements\n+     * between the start and end indices.</p>\n+     *\n+     * <p>The start index is inclusive, the end index exclusive.\n+     * Null array input produces null output.</p>\n+     *\n+     * @param array  the array\n+     * @param startIndexInclusive  the starting index. Undervalue (&lt;0)\n+     *      is promoted to 0, overvalue (&gt;array.length) results\n+     *      in an empty array.\n+     * @param endIndexExclusive  elements up to endIndex-1 are present in the\n+     *      returned subarray. Undervalue (&lt; startIndex) produces\n+     *      empty array, overvalue (&gt;array.length) is demoted to\n+     *      array length.\n+     * @return a new array containing the elements between\n+     *      the start and end indices.\n+     * @since 2.1\n+     */\n+    public static boolean[] subarray(boolean[] array, int startIndexInclusive, int endIndexExclusive) {\n+        if (array == null) {\n+            return null;\n+        }\n+        if (startIndexInclusive < 0) {\n+            startIndexInclusive = 0;\n+        }\n+        if (endIndexExclusive > array.length) {\n+            endIndexExclusive = array.length;\n+        }\n+        int newSize = endIndexExclusive - startIndexInclusive;\n+        if (newSize <= 0) {\n+            return EMPTY_BOOLEAN_ARRAY;\n+        }\n+\n+        boolean[] subarray = new boolean[newSize];\n+        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n+        return subarray;\n+    }\n+\n+    // Is same length\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks whether two arrays are the same length, treating\n+     * <code>null</code> arrays as length <code>0</code>.\n+     *\n+     * <p>Any multi-dimensional aspects of the arrays are ignored.</p>\n+     *\n+     * @param array1 the first array, may be <code>null</code>\n+     * @param array2 the second array, may be <code>null</code>\n+     * @return <code>true</code> if length of arrays matches, treating\n+     *  <code>null</code> as an empty array\n+     */\n+    public static boolean isSameLength(Object[] array1, Object[] array2) {\n+        if ((array1 == null && array2 != null && array2.length > 0) ||\n+            (array2 == null && array1 != null && array1.length > 0) ||\n+            (array1 != null && array2 != null && array1.length != array2.length)) {\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks whether two arrays are the same length, treating\n+     * <code>null</code> arrays as length <code>0</code>.</p>\n+     *\n+     * @param array1 the first array, may be <code>null</code>\n+     * @param array2 the second array, may be <code>null</code>\n+     * @return <code>true</code> if length of arrays matches, treating\n+     *  <code>null</code> as an empty array\n+     */\n+    public static boolean isSameLength(long[] array1, long[] array2) {\n+        if ((array1 == null && array2 != null && array2.length > 0) ||\n+            (array2 == null && array1 != null && array1.length > 0) ||\n+            (array1 != null && array2 != null && array1.length != array2.length)) {\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks whether two arrays are the same length, treating\n+     * <code>null</code> arrays as length <code>0</code>.</p>\n+     *\n+     * @param array1 the first array, may be <code>null</code>\n+     * @param array2 the second array, may be <code>null</code>\n+     * @return <code>true</code> if length of arrays matches, treating\n+     *  <code>null</code> as an empty array\n+     */\n+    public static boolean isSameLength(int[] array1, int[] array2) {\n+        if ((array1 == null && array2 != null && array2.length > 0) ||\n+            (array2 == null && array1 != null && array1.length > 0) ||\n+            (array1 != null && array2 != null && array1.length != array2.length)) {\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks whether two arrays are the same length, treating\n+     * <code>null</code> arrays as length <code>0</code>.</p>\n+     *\n+     * @param array1 the first array, may be <code>null</code>\n+     * @param array2 the second array, may be <code>null</code>\n+     * @return <code>true</code> if length of arrays matches, treating\n+     *  <code>null</code> as an empty array\n+     */\n+    public static boolean isSameLength(short[] array1, short[] array2) {\n+        if ((array1 == null && array2 != null && array2.length > 0) ||\n+            (array2 == null && array1 != null && array1.length > 0) ||\n+            (array1 != null && array2 != null && array1.length != array2.length)) {\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks whether two arrays are the same length, treating\n+     * <code>null</code> arrays as length <code>0</code>.</p>\n+     *\n+     * @param array1 the first array, may be <code>null</code>\n+     * @param array2 the second array, may be <code>null</code>\n+     * @return <code>true</code> if length of arrays matches, treating\n+     *  <code>null</code> as an empty array\n+     */\n+    public static boolean isSameLength(char[] array1, char[] array2) {\n+        if ((array1 == null && array2 != null && array2.length > 0) ||\n+            (array2 == null && array1 != null && array1.length > 0) ||\n+            (array1 != null && array2 != null && array1.length != array2.length)) {\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks whether two arrays are the same length, treating\n+     * <code>null</code> arrays as length <code>0</code>.</p>\n+     *\n+     * @param array1 the first array, may be <code>null</code>\n+     * @param array2 the second array, may be <code>null</code>\n+     * @return <code>true</code> if length of arrays matches, treating\n+     *  <code>null</code> as an empty array\n+     */\n+    public static boolean isSameLength(byte[] array1, byte[] array2) {\n+        if ((array1 == null && array2 != null && array2.length > 0) ||\n+            (array2 == null && array1 != null && array1.length > 0) ||\n+            (array1 != null && array2 != null && array1.length != array2.length)) {\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks whether two arrays are the same length, treating\n+     * <code>null</code> arrays as length <code>0</code>.</p>\n+     *\n+     * @param array1 the first array, may be <code>null</code>\n+     * @param array2 the second array, may be <code>null</code>\n+     * @return <code>true</code> if length of arrays matches, treating\n+     *  <code>null</code> as an empty array\n+     */\n+    public static boolean isSameLength(double[] array1, double[] array2) {\n+        if ((array1 == null && array2 != null && array2.length > 0) ||\n+            (array2 == null && array1 != null && array1.length > 0) ||\n+            (array1 != null && array2 != null && array1.length != array2.length)) {\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks whether two arrays are the same length, treating\n+     * <code>null</code> arrays as length <code>0</code>.</p>\n+     *\n+     * @param array1 the first array, may be <code>null</code>\n+     * @param array2 the second array, may be <code>null</code>\n+     * @return <code>true</code> if length of arrays matches, treating\n+     *  <code>null</code> as an empty array\n+     */\n+    public static boolean isSameLength(float[] array1, float[] array2) {\n+        if ((array1 == null && array2 != null && array2.length > 0) ||\n+            (array2 == null && array1 != null && array1.length > 0) ||\n+            (array1 != null && array2 != null && array1.length != array2.length)) {\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks whether two arrays are the same length, treating\n+     * <code>null</code> arrays as length <code>0</code>.</p>\n+     *\n+     * @param array1 the first array, may be <code>null</code>\n+     * @param array2 the second array, may be <code>null</code>\n+     * @return <code>true</code> if length of arrays matches, treating\n+     *  <code>null</code> as an empty array\n+     */\n+    public static boolean isSameLength(boolean[] array1, boolean[] array2) {\n+        if ((array1 == null && array2 != null && array2.length > 0) ||\n+            (array2 == null && array1 != null && array1.length > 0) ||\n+            (array1 != null && array2 != null && array1.length != array2.length)) {\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Returns the length of the specified array.\n+     * This method can deal with <code>Object</code> arrays and with primitive arrays.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, <code>0</code> is returned.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.getLength(null)            = 0\n+     * ArrayUtils.getLength([])              = 0\n+     * ArrayUtils.getLength([null])          = 1\n+     * ArrayUtils.getLength([true, false])   = 2\n+     * ArrayUtils.getLength([1, 2, 3])       = 3\n+     * ArrayUtils.getLength([\"a\", \"b\", \"c\"]) = 3\n+     * </pre>\n+     *\n+     * @param array  the array to retrieve the length from, may be null\n+     * @return The length of the array, or <code>0</code> if the array is <code>null</code>\n+     * @throws IllegalArgumentException if the object arguement is not an array.\n+     * @since 2.1\n+     */\n+    public static int getLength(Object array) {\n+        if (array == null) {\n+            return 0;\n+        }\n+        return Array.getLength(array);\n+    }\n+\n+    /**\n+     * <p>Checks whether two arrays are the same type taking into account\n+     * multi-dimensional arrays.</p>\n+     *\n+     * @param array1 the first array, must not be <code>null</code>\n+     * @param array2 the second array, must not be <code>null</code>\n+     * @return <code>true</code> if type of arrays matches\n+     * @throws IllegalArgumentException if either array is <code>null</code>\n+     */\n+    public static boolean isSameType(Object array1, Object array2) {\n+        if (array1 == null || array2 == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        }\n+        return array1.getClass().getName().equals(array2.getClass().getName());\n+    }\n+\n+    // Reverse\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Reverses the order of the given array.</p>\n+     *\n+     * <p>There is no special handling for multi-dimensional arrays.</p>\n+     *\n+     * <p>This method does nothing for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to reverse, may be <code>null</code>\n+     */\n+    public static void reverse(Object[] array) {\n+        if (array == null) {\n+            return;\n+        }\n+        int i = 0;\n+        int j = array.length - 1;\n+        Object tmp;\n+        while (j > i) {\n+            tmp = array[j];\n+            array[j] = array[i];\n+            array[i] = tmp;\n+            j--;\n+            i++;\n+        }\n+    }\n+\n+    /**\n+     * <p>Reverses the order of the given array.</p>\n+     *\n+     * <p>This method does nothing for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to reverse, may be <code>null</code>\n+     */\n+    public static void reverse(long[] array) {\n+        if (array == null) {\n+            return;\n+        }\n+        int i = 0;\n+        int j = array.length - 1;\n+        long tmp;\n+        while (j > i) {\n+            tmp = array[j];\n+            array[j] = array[i];\n+            array[i] = tmp;\n+            j--;\n+            i++;\n+        }\n+    }\n+\n+    /**\n+     * <p>Reverses the order of the given array.</p>\n+     *\n+     * <p>This method does nothing for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to reverse, may be <code>null</code>\n+     */\n+    public static void reverse(int[] array) {\n+        if (array == null) {\n+            return;\n+        }\n+        int i = 0;\n+        int j = array.length - 1;\n+        int tmp;\n+        while (j > i) {\n+            tmp = array[j];\n+            array[j] = array[i];\n+            array[i] = tmp;\n+            j--;\n+            i++;\n+        }\n+    }\n+\n+    /**\n+     * <p>Reverses the order of the given array.</p>\n+     *\n+     * <p>This method does nothing for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to reverse, may be <code>null</code>\n+     */\n+    public static void reverse(short[] array) {\n+        if (array == null) {\n+            return;\n+        }\n+        int i = 0;\n+        int j = array.length - 1;\n+        short tmp;\n+        while (j > i) {\n+            tmp = array[j];\n+            array[j] = array[i];\n+            array[i] = tmp;\n+            j--;\n+            i++;\n+        }\n+    }\n+\n+    /**\n+     * <p>Reverses the order of the given array.</p>\n+     *\n+     * <p>This method does nothing for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to reverse, may be <code>null</code>\n+     */\n+    public static void reverse(char[] array) {\n+        if (array == null) {\n+            return;\n+        }\n+        int i = 0;\n+        int j = array.length - 1;\n+        char tmp;\n+        while (j > i) {\n+            tmp = array[j];\n+            array[j] = array[i];\n+            array[i] = tmp;\n+            j--;\n+            i++;\n+        }\n+    }\n+\n+    /**\n+     * <p>Reverses the order of the given array.</p>\n+     *\n+     * <p>This method does nothing for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to reverse, may be <code>null</code>\n+     */\n+    public static void reverse(byte[] array) {\n+        if (array == null) {\n+            return;\n+        }\n+        int i = 0;\n+        int j = array.length - 1;\n+        byte tmp;\n+        while (j > i) {\n+            tmp = array[j];\n+            array[j] = array[i];\n+            array[i] = tmp;\n+            j--;\n+            i++;\n+        }\n+    }\n+\n+    /**\n+     * <p>Reverses the order of the given array.</p>\n+     *\n+     * <p>This method does nothing for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to reverse, may be <code>null</code>\n+     */\n+    public static void reverse(double[] array) {\n+        if (array == null) {\n+            return;\n+        }\n+        int i = 0;\n+        int j = array.length - 1;\n+        double tmp;\n+        while (j > i) {\n+            tmp = array[j];\n+            array[j] = array[i];\n+            array[i] = tmp;\n+            j--;\n+            i++;\n+        }\n+    }\n+\n+    /**\n+     * <p>Reverses the order of the given array.</p>\n+     *\n+     * <p>This method does nothing for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to reverse, may be <code>null</code>\n+     */\n+    public static void reverse(float[] array) {\n+        if (array == null) {\n+            return;\n+        }\n+        int i = 0;\n+        int j = array.length - 1;\n+        float tmp;\n+        while (j > i) {\n+            tmp = array[j];\n+            array[j] = array[i];\n+            array[i] = tmp;\n+            j--;\n+            i++;\n+        }\n+    }\n+\n+    /**\n+     * <p>Reverses the order of the given array.</p>\n+     *\n+     * <p>This method does nothing for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to reverse, may be <code>null</code>\n+     */\n+    public static void reverse(boolean[] array) {\n+        if (array == null) {\n+            return;\n+        }\n+        int i = 0;\n+        int j = array.length - 1;\n+        boolean tmp;\n+        while (j > i) {\n+            tmp = array[j];\n+            array[j] = array[i];\n+            array[i] = tmp;\n+            j--;\n+            i++;\n+        }\n+    }\n+\n+    // IndexOf search\n+    // ----------------------------------------------------------------------\n+\n+    // Object IndexOf\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Finds the index of the given object in the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param objectToFind  the object to find, may be <code>null</code>\n+     * @return the index of the object within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(Object[] array, Object objectToFind) {\n+        return indexOf(array, objectToFind, 0);\n+    }\n+\n+    /**\n+     * <p>Finds the index of the given object in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n+     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param objectToFind  the object to find, may be <code>null</code>\n+     * @param startIndex  the index to start searching at\n+     * @return the index of the object within the array starting at the index,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(Object[] array, Object objectToFind, int startIndex) {\n+        if (array == null) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            startIndex = 0;\n+        }\n+        if (objectToFind == null) {\n+            for (int i = startIndex; i < array.length; i++) {\n+                if (array[i] == null) {\n+                    return i;\n+                }\n+            }\n+        } else if (array.getClass().getComponentType().isInstance(objectToFind)) {\n+            for (int i = startIndex; i < array.length; i++) {\n+                if (objectToFind.equals(array[i])) {\n+                    return i;\n+                }\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given object within the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n+     * @param objectToFind  the object to find, may be <code>null</code>\n+     * @return the last index of the object within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(Object[] array, Object objectToFind) {\n+        return lastIndexOf(array, objectToFind, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given object in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than\n+     * the array length will search from the end of the array.</p>\n+     *\n+     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n+     * @param objectToFind  the object to find, may be <code>null</code>\n+     * @param startIndex  the start index to travers backwards from\n+     * @return the last index of the object within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(Object[] array, Object objectToFind, int startIndex) {\n+        if (array == null) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            return INDEX_NOT_FOUND;\n+        } else if (startIndex >= array.length) {\n+            startIndex = array.length - 1;\n+        }\n+        if (objectToFind == null) {\n+            for (int i = startIndex; i >= 0; i--) {\n+                if (array[i] == null) {\n+                    return i;\n+                }\n+            }\n+        } else if (array.getClass().getComponentType().isInstance(objectToFind)) {\n+            for (int i = startIndex; i >= 0; i--) {\n+                if (objectToFind.equals(array[i])) {\n+                    return i;\n+                }\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Checks if the object is in the given array.</p>\n+     *\n+     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n+     *\n+     * @param array  the array to search through\n+     * @param objectToFind  the object to find\n+     * @return <code>true</code> if the array contains the object\n+     */\n+    public static boolean contains(Object[] array, Object objectToFind) {\n+        return indexOf(array, objectToFind) != INDEX_NOT_FOUND;\n+    }\n+\n+    // long IndexOf\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Finds the index of the given value in the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(long[] array, long valueToFind) {\n+        return indexOf(array, valueToFind, 0);\n+    }\n+\n+    /**\n+     * <p>Finds the index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n+     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the index to start searching at\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(long[] array, long valueToFind, int startIndex) {\n+        if (array == null) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            startIndex = 0;\n+        }\n+        for (int i = startIndex; i < array.length; i++) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value within the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n+     * @param valueToFind  the object to find\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(long[] array, long valueToFind) {\n+        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n+     * array length will search from the end of the array.</p>\n+     *\n+     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the start index to travers backwards from\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(long[] array, long valueToFind, int startIndex) {\n+        if (array == null) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            return INDEX_NOT_FOUND;\n+        } else if (startIndex >= array.length) {\n+            startIndex = array.length - 1;\n+        }\n+        for (int i = startIndex; i >= 0; i--) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Checks if the value is in the given array.</p>\n+     *\n+     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n+     *\n+     * @param array  the array to search through\n+     * @param valueToFind  the value to find\n+     * @return <code>true</code> if the array contains the object\n+     */\n+    public static boolean contains(long[] array, long valueToFind) {\n+        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n+    }\n+\n+    // int IndexOf\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Finds the index of the given value in the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(int[] array, int valueToFind) {\n+        return indexOf(array, valueToFind, 0);\n+    }\n+\n+    /**\n+     * <p>Finds the index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n+     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the index to start searching at\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(int[] array, int valueToFind, int startIndex) {\n+        if (array == null) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            startIndex = 0;\n+        }\n+        for (int i = startIndex; i < array.length; i++) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value within the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n+     * @param valueToFind  the object to find\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(int[] array, int valueToFind) {\n+        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n+     * array length will search from the end of the array.</p>\n+     *\n+     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the start index to travers backwards from\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(int[] array, int valueToFind, int startIndex) {\n+        if (array == null) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            return INDEX_NOT_FOUND;\n+        } else if (startIndex >= array.length) {\n+            startIndex = array.length - 1;\n+        }\n+        for (int i = startIndex; i >= 0; i--) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Checks if the value is in the given array.</p>\n+     *\n+     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n+     *\n+     * @param array  the array to search through\n+     * @param valueToFind  the value to find\n+     * @return <code>true</code> if the array contains the object\n+     */\n+    public static boolean contains(int[] array, int valueToFind) {\n+        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n+    }\n+\n+    // short IndexOf\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Finds the index of the given value in the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(short[] array, short valueToFind) {\n+        return indexOf(array, valueToFind, 0);\n+    }\n+\n+    /**\n+     * <p>Finds the index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n+     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the index to start searching at\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(short[] array, short valueToFind, int startIndex) {\n+        if (array == null) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            startIndex = 0;\n+        }\n+        for (int i = startIndex; i < array.length; i++) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value within the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n+     * @param valueToFind  the object to find\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(short[] array, short valueToFind) {\n+        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n+     * array length will search from the end of the array.</p>\n+     *\n+     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the start index to travers backwards from\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(short[] array, short valueToFind, int startIndex) {\n+        if (array == null) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            return INDEX_NOT_FOUND;\n+        } else if (startIndex >= array.length) {\n+            startIndex = array.length - 1;\n+        }\n+        for (int i = startIndex; i >= 0; i--) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Checks if the value is in the given array.</p>\n+     *\n+     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n+     *\n+     * @param array  the array to search through\n+     * @param valueToFind  the value to find\n+     * @return <code>true</code> if the array contains the object\n+     */\n+    public static boolean contains(short[] array, short valueToFind) {\n+        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n+    }\n+\n+    // char IndexOf\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Finds the index of the given value in the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     * @since 2.1\n+     */\n+    public static int indexOf(char[] array, char valueToFind) {\n+        return indexOf(array, valueToFind, 0);\n+    }\n+\n+    /**\n+     * <p>Finds the index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n+     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the index to start searching at\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     * @since 2.1\n+     */\n+    public static int indexOf(char[] array, char valueToFind, int startIndex) {\n+        if (array == null) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            startIndex = 0;\n+        }\n+        for (int i = startIndex; i < array.length; i++) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value within the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n+     * @param valueToFind  the object to find\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     * @since 2.1\n+     */\n+    public static int lastIndexOf(char[] array, char valueToFind) {\n+        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n+     * array length will search from the end of the array.</p>\n+     *\n+     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the start index to travers backwards from\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     * @since 2.1\n+     */\n+    public static int lastIndexOf(char[] array, char valueToFind, int startIndex) {\n+        if (array == null) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            return INDEX_NOT_FOUND;\n+        } else if (startIndex >= array.length) {\n+            startIndex = array.length - 1;\n+        }\n+        for (int i = startIndex; i >= 0; i--) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Checks if the value is in the given array.</p>\n+     *\n+     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n+     *\n+     * @param array  the array to search through\n+     * @param valueToFind  the value to find\n+     * @return <code>true</code> if the array contains the object\n+     * @since 2.1\n+     */\n+    public static boolean contains(char[] array, char valueToFind) {\n+        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n+    }\n+\n+    // byte IndexOf\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Finds the index of the given value in the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(byte[] array, byte valueToFind) {\n+        return indexOf(array, valueToFind, 0);\n+    }\n+\n+    /**\n+     * <p>Finds the index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n+     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the index to start searching at\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(byte[] array, byte valueToFind, int startIndex) {\n+        if (array == null) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            startIndex = 0;\n+        }\n+        for (int i = startIndex; i < array.length; i++) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value within the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n+     * @param valueToFind  the object to find\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(byte[] array, byte valueToFind) {\n+        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n+     * array length will search from the end of the array.</p>\n+     *\n+     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the start index to travers backwards from\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(byte[] array, byte valueToFind, int startIndex) {\n+        if (array == null) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            return INDEX_NOT_FOUND;\n+        } else if (startIndex >= array.length) {\n+            startIndex = array.length - 1;\n+        }\n+        for (int i = startIndex; i >= 0; i--) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Checks if the value is in the given array.</p>\n+     *\n+     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n+     *\n+     * @param array  the array to search through\n+     * @param valueToFind  the value to find\n+     * @return <code>true</code> if the array contains the object\n+     */\n+    public static boolean contains(byte[] array, byte valueToFind) {\n+        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n+    }\n+\n+    // double IndexOf\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Finds the index of the given value in the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(double[] array, double valueToFind) {\n+        return indexOf(array, valueToFind, 0);\n+    }\n+\n+    /**\n+     * <p>Finds the index of the given value within a given tolerance in the array.\n+     * This method will return the index of the first value which falls between the region\n+     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param tolerance tolerance of the search\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(double[] array, double valueToFind, double tolerance) {\n+        return indexOf(array, valueToFind, 0, tolerance);\n+    }\n+\n+    /**\n+     * <p>Finds the index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n+     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the index to start searching at\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(double[] array, double valueToFind, int startIndex) {\n+        if (ArrayUtils.isEmpty(array)) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            startIndex = 0;\n+        }\n+        for (int i = startIndex; i < array.length; i++) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Finds the index of the given value in the array starting at the given index.\n+     * This method will return the index of the first value which falls between the region\n+     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n+     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the index to start searching at\n+     * @param tolerance tolerance of the search\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(double[] array, double valueToFind, int startIndex, double tolerance) {\n+        if (ArrayUtils.isEmpty(array)) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            startIndex = 0;\n+        }\n+        double min = valueToFind - tolerance;\n+        double max = valueToFind + tolerance;\n+        for (int i = startIndex; i < array.length; i++) {\n+            if (array[i] >= min && array[i] <= max) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value within the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n+     * @param valueToFind  the object to find\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(double[] array, double valueToFind) {\n+        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value within a given tolerance in the array.\n+     * This method will return the index of the last value which falls between the region\n+     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param tolerance tolerance of the search\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(double[] array, double valueToFind, double tolerance) {\n+        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE, tolerance);\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n+     * array length will search from the end of the array.</p>\n+     *\n+     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the start index to travers backwards from\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(double[] array, double valueToFind, int startIndex) {\n+        if (ArrayUtils.isEmpty(array)) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            return INDEX_NOT_FOUND;\n+        } else if (startIndex >= array.length) {\n+            startIndex = array.length - 1;\n+        }\n+        for (int i = startIndex; i >= 0; i--) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value in the array starting at the given index.\n+     * This method will return the index of the last value which falls between the region\n+     * defined by valueToFind - tolerance and valueToFind + tolerance.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n+     * array length will search from the end of the array.</p>\n+     *\n+     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the start index to travers backwards from\n+     * @param tolerance  search for value within plus/minus this amount\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(double[] array, double valueToFind, int startIndex, double tolerance) {\n+        if (ArrayUtils.isEmpty(array)) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            return INDEX_NOT_FOUND;\n+        } else if (startIndex >= array.length) {\n+            startIndex = array.length - 1;\n+        }\n+        double min = valueToFind - tolerance;\n+        double max = valueToFind + tolerance;\n+        for (int i = startIndex; i >= 0; i--) {\n+            if (array[i] >= min && array[i] <= max) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Checks if the value is in the given array.</p>\n+     *\n+     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n+     *\n+     * @param array  the array to search through\n+     * @param valueToFind  the value to find\n+     * @return <code>true</code> if the array contains the object\n+     */\n+    public static boolean contains(double[] array, double valueToFind) {\n+        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Checks if a value falling within the given tolerance is in the\n+     * given array.  If the array contains a value within the inclusive range\n+     * defined by (value - tolerance) to (value + tolerance).</p>\n+     *\n+     * <p>The method returns <code>false</code> if a <code>null</code> array\n+     * is passed in.</p>\n+     *\n+     * @param array  the array to search\n+     * @param valueToFind  the value to find\n+     * @param tolerance  the array contains the tolerance of the search\n+     * @return true if value falling within tolerance is in array\n+     */\n+    public static boolean contains(double[] array, double valueToFind, double tolerance) {\n+        return indexOf(array, valueToFind, 0, tolerance) != INDEX_NOT_FOUND;\n+    }\n+\n+    // float IndexOf\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Finds the index of the given value in the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(float[] array, float valueToFind) {\n+        return indexOf(array, valueToFind, 0);\n+    }\n+\n+    /**\n+     * <p>Finds the index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n+     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the index to start searching at\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(float[] array, float valueToFind, int startIndex) {\n+        if (ArrayUtils.isEmpty(array)) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            startIndex = 0;\n+        }\n+        for (int i = startIndex; i < array.length; i++) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value within the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n+     * @param valueToFind  the object to find\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(float[] array, float valueToFind) {\n+        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the\n+     * array length will search from the end of the array.</p>\n+     *\n+     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the start index to travers backwards from\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(float[] array, float valueToFind, int startIndex) {\n+        if (ArrayUtils.isEmpty(array)) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            return INDEX_NOT_FOUND;\n+        } else if (startIndex >= array.length) {\n+            startIndex = array.length - 1;\n+        }\n+        for (int i = startIndex; i >= 0; i--) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Checks if the value is in the given array.</p>\n+     *\n+     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n+     *\n+     * @param array  the array to search through\n+     * @param valueToFind  the value to find\n+     * @return <code>true</code> if the array contains the object\n+     */\n+    public static boolean contains(float[] array, float valueToFind) {\n+        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n+    }\n+\n+    // boolean IndexOf\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Finds the index of the given value in the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int indexOf(boolean[] array, boolean valueToFind) {\n+        return indexOf(array, valueToFind, 0);\n+    }\n+\n+    /**\n+     * <p>Finds the index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex is treated as zero. A startIndex larger than the array\n+     * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>\n+     *\n+     * @param array  the array to search through for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the index to start searching at\n+     * @return the index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code>\n+     *  array input\n+     */\n+    public static int indexOf(boolean[] array, boolean valueToFind, int startIndex) {\n+        if (ArrayUtils.isEmpty(array)) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            startIndex = 0;\n+        }\n+        for (int i = startIndex; i < array.length; i++) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value within the array.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) if\n+     * <code>null</code> array input.</p>\n+     *\n+     * @param array  the array to travers backwords looking for the object, may be <code>null</code>\n+     * @param valueToFind  the object to find\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(boolean[] array, boolean valueToFind) {\n+        return lastIndexOf(array, valueToFind, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * <p>Finds the last index of the given value in the array starting at the given index.</p>\n+     *\n+     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n+     *\n+     * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than\n+     * the array length will search from the end of the array.</p>\n+     *\n+     * @param array  the array to traverse for looking for the object, may be <code>null</code>\n+     * @param valueToFind  the value to find\n+     * @param startIndex  the start index to travers backwards from\n+     * @return the last index of the value within the array,\n+     *  {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input\n+     */\n+    public static int lastIndexOf(boolean[] array, boolean valueToFind, int startIndex) {\n+        if (ArrayUtils.isEmpty(array)) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (startIndex < 0) {\n+            return INDEX_NOT_FOUND;\n+        } else if (startIndex >= array.length) {\n+            startIndex = array.length - 1;\n+        }\n+        for (int i = startIndex; i >= 0; i--) {\n+            if (valueToFind == array[i]) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * <p>Checks if the value is in the given array.</p>\n+     *\n+     * <p>The method returns <code>false</code> if a <code>null</code> array is passed in.</p>\n+     *\n+     * @param array  the array to search through\n+     * @param valueToFind  the value to find\n+     * @return <code>true</code> if the array contains the object\n+     */\n+    public static boolean contains(boolean[] array, boolean valueToFind) {\n+        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n+    }\n+\n+    // Primitive/Object array converters\n+    // ----------------------------------------------------------------------\n+\n+    // Character array converters\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Converts an array of object Characters to primitives.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>Character</code> array, may be <code>null</code>\n+     * @return a <code>char</code> array, <code>null</code> if null array input\n+     * @throws NullPointerException if array content is <code>null</code>\n+     */\n+    public static char[] toPrimitive(Character[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_CHAR_ARRAY;\n+        }\n+        final char[] result = new char[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = array[i].charValue();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of object Character to primitives handling <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>Character</code> array, may be <code>null</code>\n+     * @param valueForNull  the value to insert if <code>null</code> found\n+     * @return a <code>char</code> array, <code>null</code> if null array input\n+     */\n+    public static char[] toPrimitive(Character[] array, char valueForNull) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_CHAR_ARRAY;\n+        }\n+        final char[] result = new char[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            Character b = array[i];\n+            result[i] = (b == null ? valueForNull : b.charValue());\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of primitive chars to objects.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array a <code>char</code> array\n+     * @return a <code>Character</code> array, <code>null</code> if null array input\n+     */\n+    public static Character[] toObject(char[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_CHARACTER_OBJECT_ARRAY;\n+        }\n+        final Character[] result = new Character[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = Character.valueOf(array[i]);\n+        }\n+        return result;\n+     }\n+\n+    // Long array converters\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Converts an array of object Longs to primitives.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>Long</code> array, may be <code>null</code>\n+     * @return a <code>long</code> array, <code>null</code> if null array input\n+     * @throws NullPointerException if array content is <code>null</code>\n+     */\n+    public static long[] toPrimitive(Long[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_LONG_ARRAY;\n+        }\n+        final long[] result = new long[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = array[i].longValue();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of object Long to primitives handling <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>Long</code> array, may be <code>null</code>\n+     * @param valueForNull  the value to insert if <code>null</code> found\n+     * @return a <code>long</code> array, <code>null</code> if null array input\n+     */\n+    public static long[] toPrimitive(Long[] array, long valueForNull) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_LONG_ARRAY;\n+        }\n+        final long[] result = new long[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            Long b = array[i];\n+            result[i] = (b == null ? valueForNull : b.longValue());\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of primitive longs to objects.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>long</code> array\n+     * @return a <code>Long</code> array, <code>null</code> if null array input\n+     */\n+    public static Long[] toObject(long[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_LONG_OBJECT_ARRAY;\n+        }\n+        final Long[] result = new Long[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = Long.valueOf(array[i]);\n+        }\n+        return result;\n+    }\n+\n+    // Int array converters\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Converts an array of object Integers to primitives.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>Integer</code> array, may be <code>null</code>\n+     * @return an <code>int</code> array, <code>null</code> if null array input\n+     * @throws NullPointerException if array content is <code>null</code>\n+     */\n+    public static int[] toPrimitive(Integer[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_INT_ARRAY;\n+        }\n+        final int[] result = new int[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = array[i].intValue();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of object Integer to primitives handling <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>Integer</code> array, may be <code>null</code>\n+     * @param valueForNull  the value to insert if <code>null</code> found\n+     * @return an <code>int</code> array, <code>null</code> if null array input\n+     */\n+    public static int[] toPrimitive(Integer[] array, int valueForNull) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_INT_ARRAY;\n+        }\n+        final int[] result = new int[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            Integer b = array[i];\n+            result[i] = (b == null ? valueForNull : b.intValue());\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of primitive ints to objects.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  an <code>int</code> array\n+     * @return an <code>Integer</code> array, <code>null</code> if null array input\n+     */\n+    public static Integer[] toObject(int[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_INTEGER_OBJECT_ARRAY;\n+        }\n+        final Integer[] result = new Integer[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = Integer.valueOf(array[i]);\n+        }\n+        return result;\n+    }\n+\n+    // Short array converters\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Converts an array of object Shorts to primitives.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>Short</code> array, may be <code>null</code>\n+     * @return a <code>byte</code> array, <code>null</code> if null array input\n+     * @throws NullPointerException if array content is <code>null</code>\n+     */\n+    public static short[] toPrimitive(Short[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_SHORT_ARRAY;\n+        }\n+        final short[] result = new short[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = array[i].shortValue();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of object Short to primitives handling <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>Short</code> array, may be <code>null</code>\n+     * @param valueForNull  the value to insert if <code>null</code> found\n+     * @return a <code>byte</code> array, <code>null</code> if null array input\n+     */\n+    public static short[] toPrimitive(Short[] array, short valueForNull) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_SHORT_ARRAY;\n+        }\n+        final short[] result = new short[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            Short b = array[i];\n+            result[i] = (b == null ? valueForNull : b.shortValue());\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of primitive shorts to objects.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>short</code> array\n+     * @return a <code>Short</code> array, <code>null</code> if null array input\n+     */\n+    public static Short[] toObject(short[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_SHORT_OBJECT_ARRAY;\n+        }\n+        final Short[] result = new Short[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = Short.valueOf(array[i]);\n+        }\n+        return result;\n+    }\n+\n+    // Byte array converters\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Converts an array of object Bytes to primitives.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>Byte</code> array, may be <code>null</code>\n+     * @return a <code>byte</code> array, <code>null</code> if null array input\n+     * @throws NullPointerException if array content is <code>null</code>\n+     */\n+    public static byte[] toPrimitive(Byte[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_BYTE_ARRAY;\n+        }\n+        final byte[] result = new byte[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = array[i].byteValue();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of object Bytes to primitives handling <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>Byte</code> array, may be <code>null</code>\n+     * @param valueForNull  the value to insert if <code>null</code> found\n+     * @return a <code>byte</code> array, <code>null</code> if null array input\n+     */\n+    public static byte[] toPrimitive(Byte[] array, byte valueForNull) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_BYTE_ARRAY;\n+        }\n+        final byte[] result = new byte[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            Byte b = array[i];\n+            result[i] = (b == null ? valueForNull : b.byteValue());\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of primitive bytes to objects.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>byte</code> array\n+     * @return a <code>Byte</code> array, <code>null</code> if null array input\n+     */\n+    public static Byte[] toObject(byte[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_BYTE_OBJECT_ARRAY;\n+        }\n+        final Byte[] result = new Byte[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = Byte.valueOf(array[i]);\n+        }\n+        return result;\n+    }\n+\n+    // Double array converters\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Converts an array of object Doubles to primitives.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>Double</code> array, may be <code>null</code>\n+     * @return a <code>double</code> array, <code>null</code> if null array input\n+     * @throws NullPointerException if array content is <code>null</code>\n+     */\n+    public static double[] toPrimitive(Double[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_DOUBLE_ARRAY;\n+        }\n+        final double[] result = new double[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = array[i].doubleValue();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of object Doubles to primitives handling <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>Double</code> array, may be <code>null</code>\n+     * @param valueForNull  the value to insert if <code>null</code> found\n+     * @return a <code>double</code> array, <code>null</code> if null array input\n+     */\n+    public static double[] toPrimitive(Double[] array, double valueForNull) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_DOUBLE_ARRAY;\n+        }\n+        final double[] result = new double[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            Double b = array[i];\n+            result[i] = (b == null ? valueForNull : b.doubleValue());\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of primitive doubles to objects.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>double</code> array\n+     * @return a <code>Double</code> array, <code>null</code> if null array input\n+     */\n+    public static Double[] toObject(double[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_DOUBLE_OBJECT_ARRAY;\n+        }\n+        final Double[] result = new Double[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = Double.valueOf(array[i]);\n+        }\n+        return result;\n+    }\n+\n+    //   Float array converters\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Converts an array of object Floats to primitives.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>Float</code> array, may be <code>null</code>\n+     * @return a <code>float</code> array, <code>null</code> if null array input\n+     * @throws NullPointerException if array content is <code>null</code>\n+     */\n+    public static float[] toPrimitive(Float[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_FLOAT_ARRAY;\n+        }\n+        final float[] result = new float[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = array[i].floatValue();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of object Floats to primitives handling <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>Float</code> array, may be <code>null</code>\n+     * @param valueForNull  the value to insert if <code>null</code> found\n+     * @return a <code>float</code> array, <code>null</code> if null array input\n+     */\n+    public static float[] toPrimitive(Float[] array, float valueForNull) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_FLOAT_ARRAY;\n+        }\n+        final float[] result = new float[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            Float b = array[i];\n+            result[i] = (b == null ? valueForNull : b.floatValue());\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of primitive floats to objects.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>float</code> array\n+     * @return a <code>Float</code> array, <code>null</code> if null array input\n+     */\n+    public static Float[] toObject(float[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_FLOAT_OBJECT_ARRAY;\n+        }\n+        final Float[] result = new Float[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = Float.valueOf(array[i]);\n+        }\n+        return result;\n+    }\n+\n+    // Boolean array converters\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Converts an array of object Booleans to primitives.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>Boolean</code> array, may be <code>null</code>\n+     * @return a <code>boolean</code> array, <code>null</code> if null array input\n+     * @throws NullPointerException if array content is <code>null</code>\n+     */\n+    public static boolean[] toPrimitive(Boolean[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_BOOLEAN_ARRAY;\n+        }\n+        final boolean[] result = new boolean[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = array[i].booleanValue();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of object Booleans to primitives handling <code>null</code>.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>Boolean</code> array, may be <code>null</code>\n+     * @param valueForNull  the value to insert if <code>null</code> found\n+     * @return a <code>boolean</code> array, <code>null</code> if null array input\n+     */\n+    public static boolean[] toPrimitive(Boolean[] array, boolean valueForNull) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_BOOLEAN_ARRAY;\n+        }\n+        final boolean[] result = new boolean[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            Boolean b = array[i];\n+            result[i] = (b == null ? valueForNull : b.booleanValue());\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Converts an array of primitive booleans to objects.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array  a <code>boolean</code> array\n+     * @return a <code>Boolean</code> array, <code>null</code> if null array input\n+     */\n+    public static Boolean[] toObject(boolean[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return EMPTY_BOOLEAN_OBJECT_ARRAY;\n+        }\n+        final Boolean[] result = new Boolean[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            result[i] = (array[i] ? Boolean.TRUE : Boolean.FALSE);\n+        }\n+        return result;\n+    }\n+\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if an array of Objects is empty or <code>null</code>.</p>\n+     *\n+     * @param array  the array to test\n+     * @return <code>true</code> if the array is empty or <code>null</code>\n+     * @since 2.1\n+     */\n+    public static <T> boolean isEmpty(T[] array) {\n+        if (array == null || array.length == 0) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * <p>Checks if an array of primitive longs is empty or <code>null</code>.</p>\n+     *\n+     * @param array  the array to test\n+     * @return <code>true</code> if the array is empty or <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isEmpty(long[] array) {\n+        if (array == null || array.length == 0) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * <p>Checks if an array of primitive ints is empty or <code>null</code>.</p>\n+     *\n+     * @param array  the array to test\n+     * @return <code>true</code> if the array is empty or <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isEmpty(int[] array) {\n+        if (array == null || array.length == 0) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * <p>Checks if an array of primitive shorts is empty or <code>null</code>.</p>\n+     *\n+     * @param array  the array to test\n+     * @return <code>true</code> if the array is empty or <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isEmpty(short[] array) {\n+        if (array == null || array.length == 0) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * <p>Checks if an array of primitive chars is empty or <code>null</code>.</p>\n+     *\n+     * @param array  the array to test\n+     * @return <code>true</code> if the array is empty or <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isEmpty(char[] array) {\n+        if (array == null || array.length == 0) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * <p>Checks if an array of primitive bytes is empty or <code>null</code>.</p>\n+     *\n+     * @param array  the array to test\n+     * @return <code>true</code> if the array is empty or <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isEmpty(byte[] array) {\n+        if (array == null || array.length == 0) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * <p>Checks if an array of primitive doubles is empty or <code>null</code>.</p>\n+     *\n+     * @param array  the array to test\n+     * @return <code>true</code> if the array is empty or <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isEmpty(double[] array) {\n+        if (array == null || array.length == 0) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * <p>Checks if an array of primitive floats is empty or <code>null</code>.</p>\n+     *\n+     * @param array  the array to test\n+     * @return <code>true</code> if the array is empty or <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isEmpty(float[] array) {\n+        if (array == null || array.length == 0) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * <p>Checks if an array of primitive booleans is empty or <code>null</code>.</p>\n+     *\n+     * @param array  the array to test\n+     * @return <code>true</code> if the array is empty or <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isEmpty(boolean[] array) {\n+        if (array == null || array.length == 0) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * <p>Adds all the elements of the given arrays into a new array.</p>\n+     * <p>The new array contains all of the element of <code>array1</code> followed\n+     * by all of the elements <code>array2</code>. When an array is returned, it is always\n+     * a new array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.addAll(null, null)     = null\n+     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n+     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n+     * ArrayUtils.addAll([], [])         = []\n+     * ArrayUtils.addAll([null], [null]) = [null, null]\n+     * ArrayUtils.addAll([\"a\", \"b\", \"c\"], [\"1\", \"2\", \"3\"]) = [\"a\", \"b\", \"c\", \"1\", \"2\", \"3\"]\n+     * </pre>\n+     *\n+     * @param array1  the first array whose elements are added to the new array, may be <code>null</code>\n+     * @param array2  the second array whose elements are added to the new array, may be <code>null</code>\n+     * @return The new array, <code>null</code> if both arrays are <code>null</code>.\n+     *      The type of the new array is the type of the first array,\n+     *      unless the first array is null, in which case the type is the same as the second array.\n+     * @since 2.1\n+     * @throws IllegalArgumentException if the array types are incompatible\n+     */\n+    public static <T> T[] addAll(T[] array1, T... array2) {\n+        if (array1 == null) {\n+            return clone(array2);\n+        } else if (array2 == null) {\n+            return clone(array1);\n+        }\n+        final Class<?> type1 = array1.getClass().getComponentType();\n+        @SuppressWarnings(\"unchecked\") // OK, because array is of type T\n+        T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n+        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n+        try {\n+            System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n+        } catch (ArrayStoreException ase) {\n+            // Check if problem was due to incompatible types\n+            /*\n+             * We do this here, rather than before the copy because:\n+             * - it would be a wasted check most of the time\n+             * - safer, in case check turns out to be too strict\n+             */\n+            final Class<?> type2 = array2.getClass().getComponentType();\n+            if (!type1.isAssignableFrom(type2)){\n+                throw new IllegalArgumentException(\"Cannot store \"+type2.getName()+\" in an array of \"+type1.getName(), ase);\n+            }\n+            throw ase; // No, so rethrow original\n+        }\n+        return joinedArray;\n+    }\n+\n+    /**\n+     * <p>Adds all the elements of the given arrays into a new array.</p>\n+     * <p>The new array contains all of the element of <code>array1</code> followed\n+     * by all of the elements <code>array2</code>. When an array is returned, it is always\n+     * a new array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n+     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n+     * ArrayUtils.addAll([], [])         = []\n+     * </pre>\n+     *\n+     * @param array1  the first array whose elements are added to the new array.\n+     * @param array2  the second array whose elements are added to the new array.\n+     * @return The new boolean[] array.\n+     * @since 2.1\n+     */\n+    public static boolean[] addAll(boolean[] array1, boolean... array2) {\n+        if (array1 == null) {\n+            return clone(array2);\n+        } else if (array2 == null) {\n+            return clone(array1);\n+        }\n+        boolean[] joinedArray = new boolean[array1.length + array2.length];\n+        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n+        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n+        return joinedArray;\n+    }\n+\n+    /**\n+     * <p>Adds all the elements of the given arrays into a new array.</p>\n+     * <p>The new array contains all of the element of <code>array1</code> followed\n+     * by all of the elements <code>array2</code>. When an array is returned, it is always\n+     * a new array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n+     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n+     * ArrayUtils.addAll([], [])         = []\n+     * </pre>\n+     *\n+     * @param array1  the first array whose elements are added to the new array.\n+     * @param array2  the second array whose elements are added to the new array.\n+     * @return The new char[] array.\n+     * @since 2.1\n+     */\n+    public static char[] addAll(char[] array1, char... array2) {\n+        if (array1 == null) {\n+            return clone(array2);\n+        } else if (array2 == null) {\n+            return clone(array1);\n+        }\n+        char[] joinedArray = new char[array1.length + array2.length];\n+        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n+        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n+        return joinedArray;\n+    }\n+\n+    /**\n+     * <p>Adds all the elements of the given arrays into a new array.</p>\n+     * <p>The new array contains all of the element of <code>array1</code> followed\n+     * by all of the elements <code>array2</code>. When an array is returned, it is always\n+     * a new array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n+     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n+     * ArrayUtils.addAll([], [])         = []\n+     * </pre>\n+     *\n+     * @param array1  the first array whose elements are added to the new array.\n+     * @param array2  the second array whose elements are added to the new array.\n+     * @return The new byte[] array.\n+     * @since 2.1\n+     */\n+    public static byte[] addAll(byte[] array1, byte... array2) {\n+        if (array1 == null) {\n+            return clone(array2);\n+        } else if (array2 == null) {\n+            return clone(array1);\n+        }\n+        byte[] joinedArray = new byte[array1.length + array2.length];\n+        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n+        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n+        return joinedArray;\n+    }\n+\n+    /**\n+     * <p>Adds all the elements of the given arrays into a new array.</p>\n+     * <p>The new array contains all of the element of <code>array1</code> followed\n+     * by all of the elements <code>array2</code>. When an array is returned, it is always\n+     * a new array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n+     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n+     * ArrayUtils.addAll([], [])         = []\n+     * </pre>\n+     *\n+     * @param array1  the first array whose elements are added to the new array.\n+     * @param array2  the second array whose elements are added to the new array.\n+     * @return The new short[] array.\n+     * @since 2.1\n+     */\n+    public static short[] addAll(short[] array1, short... array2) {\n+        if (array1 == null) {\n+            return clone(array2);\n+        } else if (array2 == null) {\n+            return clone(array1);\n+        }\n+        short[] joinedArray = new short[array1.length + array2.length];\n+        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n+        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n+        return joinedArray;\n+    }\n+\n+    /**\n+     * <p>Adds all the elements of the given arrays into a new array.</p>\n+     * <p>The new array contains all of the element of <code>array1</code> followed\n+     * by all of the elements <code>array2</code>. When an array is returned, it is always\n+     * a new array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n+     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n+     * ArrayUtils.addAll([], [])         = []\n+     * </pre>\n+     *\n+     * @param array1  the first array whose elements are added to the new array.\n+     * @param array2  the second array whose elements are added to the new array.\n+     * @return The new int[] array.\n+     * @since 2.1\n+     */\n+    public static int[] addAll(int[] array1, int... array2) {\n+        if (array1 == null) {\n+            return clone(array2);\n+        } else if (array2 == null) {\n+            return clone(array1);\n+        }\n+        int[] joinedArray = new int[array1.length + array2.length];\n+        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n+        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n+        return joinedArray;\n+    }\n+\n+    /**\n+     * <p>Adds all the elements of the given arrays into a new array.</p>\n+     * <p>The new array contains all of the element of <code>array1</code> followed\n+     * by all of the elements <code>array2</code>. When an array is returned, it is always\n+     * a new array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n+     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n+     * ArrayUtils.addAll([], [])         = []\n+     * </pre>\n+     *\n+     * @param array1  the first array whose elements are added to the new array.\n+     * @param array2  the second array whose elements are added to the new array.\n+     * @return The new long[] array.\n+     * @since 2.1\n+     */\n+    public static long[] addAll(long[] array1, long... array2) {\n+        if (array1 == null) {\n+            return clone(array2);\n+        } else if (array2 == null) {\n+            return clone(array1);\n+        }\n+        long[] joinedArray = new long[array1.length + array2.length];\n+        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n+        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n+        return joinedArray;\n+    }\n+\n+    /**\n+     * <p>Adds all the elements of the given arrays into a new array.</p>\n+     * <p>The new array contains all of the element of <code>array1</code> followed\n+     * by all of the elements <code>array2</code>. When an array is returned, it is always\n+     * a new array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n+     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n+     * ArrayUtils.addAll([], [])         = []\n+     * </pre>\n+     *\n+     * @param array1  the first array whose elements are added to the new array.\n+     * @param array2  the second array whose elements are added to the new array.\n+     * @return The new float[] array.\n+     * @since 2.1\n+     */\n+    public static float[] addAll(float[] array1, float... array2) {\n+        if (array1 == null) {\n+            return clone(array2);\n+        } else if (array2 == null) {\n+            return clone(array1);\n+        }\n+        float[] joinedArray = new float[array1.length + array2.length];\n+        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n+        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n+        return joinedArray;\n+    }\n+\n+    /**\n+     * <p>Adds all the elements of the given arrays into a new array.</p>\n+     * <p>The new array contains all of the element of <code>array1</code> followed\n+     * by all of the elements <code>array2</code>. When an array is returned, it is always\n+     * a new array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.addAll(array1, null)   = cloned copy of array1\n+     * ArrayUtils.addAll(null, array2)   = cloned copy of array2\n+     * ArrayUtils.addAll([], [])         = []\n+     * </pre>\n+     *\n+     * @param array1  the first array whose elements are added to the new array.\n+     * @param array2  the second array whose elements are added to the new array.\n+     * @return The new double[] array.\n+     * @since 2.1\n+     */\n+    public static double[] addAll(double[] array1, double... array2) {\n+        if (array1 == null) {\n+            return clone(array2);\n+        } else if (array2 == null) {\n+            return clone(array1);\n+        }\n+        double[] joinedArray = new double[array1.length + array2.length];\n+        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n+        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n+        return joinedArray;\n+    }\n+\n+    /**\n+     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n+     *\n+     * <p>The new array contains the same elements of the input\n+     * array plus the given element in the last position. The component type of\n+     * the new array is the same as that of the input array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element, unless the element itself is null,\n+     *  in which case the return type is Object[]</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.add(null, null)      = [null]\n+     * ArrayUtils.add(null, \"a\")       = [\"a\"]\n+     * ArrayUtils.add([\"a\"], null)     = [\"a\", null]\n+     * ArrayUtils.add([\"a\"], \"b\")      = [\"a\", \"b\"]\n+     * ArrayUtils.add([\"a\", \"b\"], \"c\") = [\"a\", \"b\", \"c\"]\n+     * </pre>\n+     *\n+     * @param array  the array to \"add\" the element to, may be <code>null</code>\n+     * @param element  the object to add, may be <code>null</code>\n+     * @return A new array containing the existing elements plus the new element\n+     * The returned array type will be that of the input array (unless null),\n+     * in which case it will have the same type as the element (unless that is also null)\n+     * in which case the returned type will be Object[].\n+     * @since 2.1\n+     */\n+    public static <T> T[] add(T[] array, T element) {\n+        Class<?> type = array != null ? array.getClass() : (element != null ? element.getClass() : Object.class);\n+        // TODO - this is NOT safe to ignore - see LANG-571\n+        T[] newArray = (T[]) copyArrayGrow1(array, type);\n+        newArray[newArray.length - 1] = element;\n+        return newArray;\n+    }\n+\n+    /**\n+     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n+     *\n+     * <p>The new array contains the same elements of the input\n+     * array plus the given element in the last position. The component type of\n+     * the new array is the same as that of the input array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.add(null, true)          = [true]\n+     * ArrayUtils.add([true], false)       = [true, false]\n+     * ArrayUtils.add([true, false], true) = [true, false, true]\n+     * </pre>\n+     *\n+     * @param array  the array to copy and add the element to, may be <code>null</code>\n+     * @param element  the object to add at the last index of the new array\n+     * @return A new array containing the existing elements plus the new element\n+     * @since 2.1\n+     */\n+    public static boolean[] add(boolean[] array, boolean element) {\n+        boolean[] newArray = (boolean[])copyArrayGrow1(array, Boolean.TYPE);\n+        newArray[newArray.length - 1] = element;\n+        return newArray;\n+    }\n+\n+    /**\n+     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n+     *\n+     * <p>The new array contains the same elements of the input\n+     * array plus the given element in the last position. The component type of\n+     * the new array is the same as that of the input array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.add(null, 0)   = [0]\n+     * ArrayUtils.add([1], 0)    = [1, 0]\n+     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n+     * </pre>\n+     *\n+     * @param array  the array to copy and add the element to, may be <code>null</code>\n+     * @param element  the object to add at the last index of the new array\n+     * @return A new array containing the existing elements plus the new element\n+     * @since 2.1\n+     */\n+    public static byte[] add(byte[] array, byte element) {\n+        byte[] newArray = (byte[])copyArrayGrow1(array, Byte.TYPE);\n+        newArray[newArray.length - 1] = element;\n+        return newArray;\n+    }\n+\n+    /**\n+     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n+     *\n+     * <p>The new array contains the same elements of the input\n+     * array plus the given element in the last position. The component type of\n+     * the new array is the same as that of the input array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.add(null, '0')       = ['0']\n+     * ArrayUtils.add(['1'], '0')      = ['1', '0']\n+     * ArrayUtils.add(['1', '0'], '1') = ['1', '0', '1']\n+     * </pre>\n+     *\n+     * @param array  the array to copy and add the element to, may be <code>null</code>\n+     * @param element  the object to add at the last index of the new array\n+     * @return A new array containing the existing elements plus the new element\n+     * @since 2.1\n+     */\n+    public static char[] add(char[] array, char element) {\n+        char[] newArray = (char[])copyArrayGrow1(array, Character.TYPE);\n+        newArray[newArray.length - 1] = element;\n+        return newArray;\n+    }\n+\n+    /**\n+     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n+     *\n+     * <p>The new array contains the same elements of the input\n+     * array plus the given element in the last position. The component type of\n+     * the new array is the same as that of the input array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.add(null, 0)   = [0]\n+     * ArrayUtils.add([1], 0)    = [1, 0]\n+     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n+     * </pre>\n+     *\n+     * @param array  the array to copy and add the element to, may be <code>null</code>\n+     * @param element  the object to add at the last index of the new array\n+     * @return A new array containing the existing elements plus the new element\n+     * @since 2.1\n+     */\n+    public static double[] add(double[] array, double element) {\n+        double[] newArray = (double[])copyArrayGrow1(array, Double.TYPE);\n+        newArray[newArray.length - 1] = element;\n+        return newArray;\n+    }\n+\n+    /**\n+     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n+     *\n+     * <p>The new array contains the same elements of the input\n+     * array plus the given element in the last position. The component type of\n+     * the new array is the same as that of the input array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.add(null, 0)   = [0]\n+     * ArrayUtils.add([1], 0)    = [1, 0]\n+     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n+     * </pre>\n+     *\n+     * @param array  the array to copy and add the element to, may be <code>null</code>\n+     * @param element  the object to add at the last index of the new array\n+     * @return A new array containing the existing elements plus the new element\n+     * @since 2.1\n+     */\n+    public static float[] add(float[] array, float element) {\n+        float[] newArray = (float[])copyArrayGrow1(array, Float.TYPE);\n+        newArray[newArray.length - 1] = element;\n+        return newArray;\n+    }\n+\n+    /**\n+     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n+     *\n+     * <p>The new array contains the same elements of the input\n+     * array plus the given element in the last position. The component type of\n+     * the new array is the same as that of the input array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.add(null, 0)   = [0]\n+     * ArrayUtils.add([1], 0)    = [1, 0]\n+     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n+     * </pre>\n+     *\n+     * @param array  the array to copy and add the element to, may be <code>null</code>\n+     * @param element  the object to add at the last index of the new array\n+     * @return A new array containing the existing elements plus the new element\n+     * @since 2.1\n+     */\n+    public static int[] add(int[] array, int element) {\n+        int[] newArray = (int[])copyArrayGrow1(array, Integer.TYPE);\n+        newArray[newArray.length - 1] = element;\n+        return newArray;\n+    }\n+\n+    /**\n+     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n+     *\n+     * <p>The new array contains the same elements of the input\n+     * array plus the given element in the last position. The component type of\n+     * the new array is the same as that of the input array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.add(null, 0)   = [0]\n+     * ArrayUtils.add([1], 0)    = [1, 0]\n+     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n+     * </pre>\n+     *\n+     * @param array  the array to copy and add the element to, may be <code>null</code>\n+     * @param element  the object to add at the last index of the new array\n+     * @return A new array containing the existing elements plus the new element\n+     * @since 2.1\n+     */\n+    public static long[] add(long[] array, long element) {\n+        long[] newArray = (long[])copyArrayGrow1(array, Long.TYPE);\n+        newArray[newArray.length - 1] = element;\n+        return newArray;\n+    }\n+\n+    /**\n+     * <p>Copies the given array and adds the given element at the end of the new array.</p>\n+     *\n+     * <p>The new array contains the same elements of the input\n+     * array plus the given element in the last position. The component type of\n+     * the new array is the same as that of the input array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.add(null, 0)   = [0]\n+     * ArrayUtils.add([1], 0)    = [1, 0]\n+     * ArrayUtils.add([1, 0], 1) = [1, 0, 1]\n+     * </pre>\n+     *\n+     * @param array  the array to copy and add the element to, may be <code>null</code>\n+     * @param element  the object to add at the last index of the new array\n+     * @return A new array containing the existing elements plus the new element\n+     * @since 2.1\n+     */\n+    public static short[] add(short[] array, short element) {\n+        short[] newArray = (short[])copyArrayGrow1(array, Short.TYPE);\n+        newArray[newArray.length - 1] = element;\n+        return newArray;\n+    }\n+\n+    /**\n+     * Returns a copy of the given array of size 1 greater than the argument.\n+     * The last value of the array is left to the default value.\n+     *\n+     * @param array The array to copy, must not be <code>null</code>.\n+     * @param newArrayComponentType If <code>array</code> is <code>null</code>, create a\n+     * size 1 array of this type.\n+     * @return A new copy of the array of size 1 greater than the input.\n+     */\n+    private static Object copyArrayGrow1(Object array, Class<?> newArrayComponentType) {\n+        if (array != null) {\n+            int arrayLength = Array.getLength(array);\n+            Object newArray = Array.newInstance(array.getClass().getComponentType(), arrayLength + 1);\n+            System.arraycopy(array, 0, newArray, 0, arrayLength);\n+            return newArray;\n+        }\n+        return Array.newInstance(newArrayComponentType, 1);\n+    }\n+\n+    /**\n+     * <p>Inserts the specified element at the specified position in the array.\n+     * Shifts the element currently at that position (if any) and any subsequent\n+     * elements to the right (adds one to their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array plus the given element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.add(null, 0, null)      = [null]\n+     * ArrayUtils.add(null, 0, \"a\")       = [\"a\"]\n+     * ArrayUtils.add([\"a\"], 1, null)     = [\"a\", null]\n+     * ArrayUtils.add([\"a\"], 1, \"b\")      = [\"a\", \"b\"]\n+     * ArrayUtils.add([\"a\", \"b\"], 3, \"c\") = [\"a\", \"b\", \"c\"]\n+     * </pre>\n+     *\n+     * @param array  the array to add the element to, may be <code>null</code>\n+     * @param index  the position of the new object\n+     * @param element  the object to add\n+     * @return A new array containing the existing elements and the new element\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index > array.length).\n+     */\n+    public static <T> T[] add(T[] array, int index, T element) {\n+        Class<?> clss = null;\n+        if (array != null) {\n+            clss = array.getClass().getComponentType();\n+        } else if (element != null) {\n+            clss = element.getClass();\n+        } else {\n+            // TODO this is not type-safe - see LANG-571\n+            final T[] emptyArray = (T[]) new Object[] { null };\n+            return emptyArray;\n+        }\n+        @SuppressWarnings(\"unchecked\") // the add method creates an array of type clss, which is type T\n+        final T[] newArray = (T[]) add(array, index, element, clss);\n+        return newArray;\n+    }\n+\n+    /**\n+     * <p>Inserts the specified element at the specified position in the array.\n+     * Shifts the element currently at that position (if any) and any subsequent\n+     * elements to the right (adds one to their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array plus the given element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.add(null, 0, true)          = [true]\n+     * ArrayUtils.add([true], 0, false)       = [false, true]\n+     * ArrayUtils.add([false], 1, true)       = [false, true]\n+     * ArrayUtils.add([true, false], 1, true) = [true, true, false]\n+     * </pre>\n+     *\n+     * @param array  the array to add the element to, may be <code>null</code>\n+     * @param index  the position of the new object\n+     * @param element  the object to add\n+     * @return A new array containing the existing elements and the new element\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index > array.length).\n+     */\n+    public static boolean[] add(boolean[] array, int index, boolean element) {\n+        return (boolean[]) add(array, index, Boolean.valueOf(element), Boolean.TYPE);\n+    }\n+\n+    /**\n+     * <p>Inserts the specified element at the specified position in the array.\n+     * Shifts the element currently at that position (if any) and any subsequent\n+     * elements to the right (adds one to their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array plus the given element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.add(null, 0, 'a')            = ['a']\n+     * ArrayUtils.add(['a'], 0, 'b')           = ['b', 'a']\n+     * ArrayUtils.add(['a', 'b'], 0, 'c')      = ['c', 'a', 'b']\n+     * ArrayUtils.add(['a', 'b'], 1, 'k')      = ['a', 'k', 'b']\n+     * ArrayUtils.add(['a', 'b', 'c'], 1, 't') = ['a', 't', 'b', 'c']\n+     * </pre>\n+     *\n+     * @param array  the array to add the element to, may be <code>null</code>\n+     * @param index  the position of the new object\n+     * @param element  the object to add\n+     * @return A new array containing the existing elements and the new element\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index > array.length).\n+     */\n+    public static char[] add(char[] array, int index, char element) {\n+        return (char[]) add(array, index, Character.valueOf(element), Character.TYPE);\n+    }\n+\n+    /**\n+     * <p>Inserts the specified element at the specified position in the array.\n+     * Shifts the element currently at that position (if any) and any subsequent\n+     * elements to the right (adds one to their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array plus the given element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.add([1], 0, 2)         = [2, 1]\n+     * ArrayUtils.add([2, 6], 2, 3)      = [2, 6, 3]\n+     * ArrayUtils.add([2, 6], 0, 1)      = [1, 2, 6]\n+     * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]\n+     * </pre>\n+     *\n+     * @param array  the array to add the element to, may be <code>null</code>\n+     * @param index  the position of the new object\n+     * @param element  the object to add\n+     * @return A new array containing the existing elements and the new element\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index > array.length).\n+     */\n+    public static byte[] add(byte[] array, int index, byte element) {\n+        return (byte[]) add(array, index, Byte.valueOf(element), Byte.TYPE);\n+    }\n+\n+    /**\n+     * <p>Inserts the specified element at the specified position in the array.\n+     * Shifts the element currently at that position (if any) and any subsequent\n+     * elements to the right (adds one to their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array plus the given element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.add([1], 0, 2)         = [2, 1]\n+     * ArrayUtils.add([2, 6], 2, 10)     = [2, 6, 10]\n+     * ArrayUtils.add([2, 6], 0, -4)     = [-4, 2, 6]\n+     * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]\n+     * </pre>\n+     *\n+     * @param array  the array to add the element to, may be <code>null</code>\n+     * @param index  the position of the new object\n+     * @param element  the object to add\n+     * @return A new array containing the existing elements and the new element\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index > array.length).\n+     */\n+    public static short[] add(short[] array, int index, short element) {\n+        return (short[]) add(array, index, Short.valueOf(element), Short.TYPE);\n+    }\n+\n+    /**\n+     * <p>Inserts the specified element at the specified position in the array.\n+     * Shifts the element currently at that position (if any) and any subsequent\n+     * elements to the right (adds one to their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array plus the given element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.add([1], 0, 2)         = [2, 1]\n+     * ArrayUtils.add([2, 6], 2, 10)     = [2, 6, 10]\n+     * ArrayUtils.add([2, 6], 0, -4)     = [-4, 2, 6]\n+     * ArrayUtils.add([2, 6, 3], 2, 1)   = [2, 6, 1, 3]\n+     * </pre>\n+     *\n+     * @param array  the array to add the element to, may be <code>null</code>\n+     * @param index  the position of the new object\n+     * @param element  the object to add\n+     * @return A new array containing the existing elements and the new element\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index > array.length).\n+     */\n+    public static int[] add(int[] array, int index, int element) {\n+        return (int[]) add(array, index, Integer.valueOf(element), Integer.TYPE);\n+    }\n+\n+    /**\n+     * <p>Inserts the specified element at the specified position in the array.\n+     * Shifts the element currently at that position (if any) and any subsequent\n+     * elements to the right (adds one to their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array plus the given element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.add([1L], 0, 2L)           = [2L, 1L]\n+     * ArrayUtils.add([2L, 6L], 2, 10L)      = [2L, 6L, 10L]\n+     * ArrayUtils.add([2L, 6L], 0, -4L)      = [-4L, 2L, 6L]\n+     * ArrayUtils.add([2L, 6L, 3L], 2, 1L)   = [2L, 6L, 1L, 3L]\n+     * </pre>\n+     *\n+     * @param array  the array to add the element to, may be <code>null</code>\n+     * @param index  the position of the new object\n+     * @param element  the object to add\n+     * @return A new array containing the existing elements and the new element\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index > array.length).\n+     */\n+    public static long[] add(long[] array, int index, long element) {\n+        return (long[]) add(array, index, Long.valueOf(element), Long.TYPE);\n+    }\n+\n+    /**\n+     * <p>Inserts the specified element at the specified position in the array.\n+     * Shifts the element currently at that position (if any) and any subsequent\n+     * elements to the right (adds one to their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array plus the given element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.add([1.1f], 0, 2.2f)               = [2.2f, 1.1f]\n+     * ArrayUtils.add([2.3f, 6.4f], 2, 10.5f)        = [2.3f, 6.4f, 10.5f]\n+     * ArrayUtils.add([2.6f, 6.7f], 0, -4.8f)        = [-4.8f, 2.6f, 6.7f]\n+     * ArrayUtils.add([2.9f, 6.0f, 0.3f], 2, 1.0f)   = [2.9f, 6.0f, 1.0f, 0.3f]\n+     * </pre>\n+     *\n+     * @param array  the array to add the element to, may be <code>null</code>\n+     * @param index  the position of the new object\n+     * @param element  the object to add\n+     * @return A new array containing the existing elements and the new element\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index > array.length).\n+     */\n+    public static float[] add(float[] array, int index, float element) {\n+        return (float[]) add(array, index, Float.valueOf(element), Float.TYPE);\n+    }\n+\n+    /**\n+     * <p>Inserts the specified element at the specified position in the array.\n+     * Shifts the element currently at that position (if any) and any subsequent\n+     * elements to the right (adds one to their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array plus the given element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, a new one element array is returned\n+     *  whose component type is the same as the element.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.add([1.1], 0, 2.2)              = [2.2, 1.1]\n+     * ArrayUtils.add([2.3, 6.4], 2, 10.5)        = [2.3, 6.4, 10.5]\n+     * ArrayUtils.add([2.6, 6.7], 0, -4.8)        = [-4.8, 2.6, 6.7]\n+     * ArrayUtils.add([2.9, 6.0, 0.3], 2, 1.0)    = [2.9, 6.0, 1.0, 0.3]\n+     * </pre>\n+     *\n+     * @param array  the array to add the element to, may be <code>null</code>\n+     * @param index  the position of the new object\n+     * @param element  the object to add\n+     * @return A new array containing the existing elements and the new element\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index > array.length).\n+     */\n+    public static double[] add(double[] array, int index, double element) {\n+        return (double[]) add(array, index, Double.valueOf(element), Double.TYPE);\n+    }\n+\n+    /**\n+     * Underlying implementation of add(array, index, element) methods.\n+     * The last parameter is the class, which may not equal element.getClass\n+     * for primitives.\n+     *\n+     * @param array  the array to add the element to, may be <code>null</code>\n+     * @param index  the position of the new object\n+     * @param element  the object to add\n+     * @param clss the type of the element being added\n+     * @return A new array containing the existing elements and the new element\n+     */\n+    private static Object add(Object array, int index, Object element, Class<?> clss) {\n+        if (array == null) {\n+            if (index != 0) {\n+                throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: 0\");\n+            }\n+            Object joinedArray = Array.newInstance(clss, 1);\n+            Array.set(joinedArray, 0, element);\n+            return joinedArray;\n+        }\n+        int length = Array.getLength(array);\n+        if (index > length || index < 0) {\n+            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + length);\n+        }\n+        Object result = Array.newInstance(clss, length + 1);\n+        System.arraycopy(array, 0, result, 0, index);\n+        Array.set(result, index, element);\n+        if (index < length) {\n+            System.arraycopy(array, index, result, index + 1, length - index);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.remove([\"a\"], 0)           = []\n+     * ArrayUtils.remove([\"a\", \"b\"], 0)      = [\"b\"]\n+     * ArrayUtils.remove([\"a\", \"b\"], 1)      = [\"a\"]\n+     * ArrayUtils.remove([\"a\", \"b\", \"c\"], 1) = [\"a\", \"c\"]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    @SuppressWarnings(\"unchecked\") // remove() always creates an array of the same type as its input\n+    public static <T> T[] remove(T[] array, int index) {\n+        return (T[]) remove((Object) array, index);\n+    }\n+\n+    /**\n+     * <p>Removes the first occurrence of the specified element from the\n+     * specified array. All subsequent elements are shifted to the left\n+     * (substracts one from their indices). If the array doesn't contains\n+     * such an element, no elements are removed from the array.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the first occurrence of the specified element. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElement(null, \"a\")            = null\n+     * ArrayUtils.removeElement([], \"a\")              = []\n+     * ArrayUtils.removeElement([\"a\"], \"b\")           = [\"a\"]\n+     * ArrayUtils.removeElement([\"a\", \"b\"], \"a\")      = [\"b\"]\n+     * ArrayUtils.removeElement([\"a\", \"b\", \"a\"], \"a\") = [\"b\", \"a\"]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may be <code>null</code>\n+     * @param element  the element to be removed\n+     * @return A new array containing the existing elements except the first\n+     *         occurrence of the specified element.\n+     * @since 2.1\n+     */\n+    public static <T> T[] removeElement(T[] array, Object element) {\n+        int index = indexOf(array, element);\n+        if (index == INDEX_NOT_FOUND) {\n+            return clone(array);\n+        }\n+        return remove(array, index);\n+    }\n+\n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.remove([true], 0)              = []\n+     * ArrayUtils.remove([true, false], 0)       = [false]\n+     * ArrayUtils.remove([true, false], 1)       = [true]\n+     * ArrayUtils.remove([true, true, false], 1) = [true, false]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    public static boolean[] remove(boolean[] array, int index) {\n+        return (boolean[]) remove((Object) array, index);\n+    }\n+\n+    /**\n+     * <p>Removes the first occurrence of the specified element from the\n+     * specified array. All subsequent elements are shifted to the left\n+     * (substracts one from their indices). If the array doesn't contains\n+     * such an element, no elements are removed from the array.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the first occurrence of the specified element. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElement(null, true)                = null\n+     * ArrayUtils.removeElement([], true)                  = []\n+     * ArrayUtils.removeElement([true], false)             = [true]\n+     * ArrayUtils.removeElement([true, false], false)      = [true]\n+     * ArrayUtils.removeElement([true, false, true], true) = [false, true]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may be <code>null</code>\n+     * @param element  the element to be removed\n+     * @return A new array containing the existing elements except the first\n+     *         occurrence of the specified element.\n+     * @since 2.1\n+     */\n+    public static boolean[] removeElement(boolean[] array, boolean element) {\n+        int index = indexOf(array, element);\n+        if (index == INDEX_NOT_FOUND) {\n+            return clone(array);\n+        }\n+        return remove(array, index);\n+    }\n+\n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.remove([1], 0)          = []\n+     * ArrayUtils.remove([1, 0], 0)       = [0]\n+     * ArrayUtils.remove([1, 0], 1)       = [1]\n+     * ArrayUtils.remove([1, 0, 1], 1)    = [1, 1]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    public static byte[] remove(byte[] array, int index) {\n+        return (byte[]) remove((Object) array, index);\n+    }\n+\n+    /**\n+     * <p>Removes the first occurrence of the specified element from the\n+     * specified array. All subsequent elements are shifted to the left\n+     * (substracts one from their indices). If the array doesn't contains\n+     * such an element, no elements are removed from the array.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the first occurrence of the specified element. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElement(null, 1)        = null\n+     * ArrayUtils.removeElement([], 1)          = []\n+     * ArrayUtils.removeElement([1], 0)         = [1]\n+     * ArrayUtils.removeElement([1, 0], 0)      = [1]\n+     * ArrayUtils.removeElement([1, 0, 1], 1)   = [0, 1]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may be <code>null</code>\n+     * @param element  the element to be removed\n+     * @return A new array containing the existing elements except the first\n+     *         occurrence of the specified element.\n+     * @since 2.1\n+     */\n+    public static byte[] removeElement(byte[] array, byte element) {\n+        int index = indexOf(array, element);\n+        if (index == INDEX_NOT_FOUND) {\n+            return clone(array);\n+        }\n+        return remove(array, index);\n+    }\n+\n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.remove(['a'], 0)           = []\n+     * ArrayUtils.remove(['a', 'b'], 0)      = ['b']\n+     * ArrayUtils.remove(['a', 'b'], 1)      = ['a']\n+     * ArrayUtils.remove(['a', 'b', 'c'], 1) = ['a', 'c']\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    public static char[] remove(char[] array, int index) {\n+        return (char[]) remove((Object) array, index);\n+    }\n+\n+    /**\n+     * <p>Removes the first occurrence of the specified element from the\n+     * specified array. All subsequent elements are shifted to the left\n+     * (substracts one from their indices). If the array doesn't contains\n+     * such an element, no elements are removed from the array.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the first occurrence of the specified element. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElement(null, 'a')            = null\n+     * ArrayUtils.removeElement([], 'a')              = []\n+     * ArrayUtils.removeElement(['a'], 'b')           = ['a']\n+     * ArrayUtils.removeElement(['a', 'b'], 'a')      = ['b']\n+     * ArrayUtils.removeElement(['a', 'b', 'a'], 'a') = ['b', 'a']\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may be <code>null</code>\n+     * @param element  the element to be removed\n+     * @return A new array containing the existing elements except the first\n+     *         occurrence of the specified element.\n+     * @since 2.1\n+     */\n+    public static char[] removeElement(char[] array, char element) {\n+        int index = indexOf(array, element);\n+        if (index == INDEX_NOT_FOUND) {\n+            return clone(array);\n+        }\n+        return remove(array, index);\n+    }\n+\n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.remove([1.1], 0)           = []\n+     * ArrayUtils.remove([2.5, 6.0], 0)      = [6.0]\n+     * ArrayUtils.remove([2.5, 6.0], 1)      = [2.5]\n+     * ArrayUtils.remove([2.5, 6.0, 3.8], 1) = [2.5, 3.8]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    public static double[] remove(double[] array, int index) {\n+        return (double[]) remove((Object) array, index);\n+    }\n+\n+    /**\n+     * <p>Removes the first occurrence of the specified element from the\n+     * specified array. All subsequent elements are shifted to the left\n+     * (substracts one from their indices). If the array doesn't contains\n+     * such an element, no elements are removed from the array.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the first occurrence of the specified element. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElement(null, 1.1)            = null\n+     * ArrayUtils.removeElement([], 1.1)              = []\n+     * ArrayUtils.removeElement([1.1], 1.2)           = [1.1]\n+     * ArrayUtils.removeElement([1.1, 2.3], 1.1)      = [2.3]\n+     * ArrayUtils.removeElement([1.1, 2.3, 1.1], 1.1) = [2.3, 1.1]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may be <code>null</code>\n+     * @param element  the element to be removed\n+     * @return A new array containing the existing elements except the first\n+     *         occurrence of the specified element.\n+     * @since 2.1\n+     */\n+    public static double[] removeElement(double[] array, double element) {\n+        int index = indexOf(array, element);\n+        if (index == INDEX_NOT_FOUND) {\n+            return clone(array);\n+        }\n+        return remove(array, index);\n+    }\n+\n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.remove([1.1], 0)           = []\n+     * ArrayUtils.remove([2.5, 6.0], 0)      = [6.0]\n+     * ArrayUtils.remove([2.5, 6.0], 1)      = [2.5]\n+     * ArrayUtils.remove([2.5, 6.0, 3.8], 1) = [2.5, 3.8]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    public static float[] remove(float[] array, int index) {\n+        return (float[]) remove((Object) array, index);\n+    }\n+\n+    /**\n+     * <p>Removes the first occurrence of the specified element from the\n+     * specified array. All subsequent elements are shifted to the left\n+     * (substracts one from their indices). If the array doesn't contains\n+     * such an element, no elements are removed from the array.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the first occurrence of the specified element. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElement(null, 1.1)            = null\n+     * ArrayUtils.removeElement([], 1.1)              = []\n+     * ArrayUtils.removeElement([1.1], 1.2)           = [1.1]\n+     * ArrayUtils.removeElement([1.1, 2.3], 1.1)      = [2.3]\n+     * ArrayUtils.removeElement([1.1, 2.3, 1.1], 1.1) = [2.3, 1.1]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may be <code>null</code>\n+     * @param element  the element to be removed\n+     * @return A new array containing the existing elements except the first\n+     *         occurrence of the specified element.\n+     * @since 2.1\n+     */\n+    public static float[] removeElement(float[] array, float element) {\n+        int index = indexOf(array, element);\n+        if (index == INDEX_NOT_FOUND) {\n+            return clone(array);\n+        }\n+        return remove(array, index);\n+    }\n+\n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.remove([1], 0)         = []\n+     * ArrayUtils.remove([2, 6], 0)      = [6]\n+     * ArrayUtils.remove([2, 6], 1)      = [2]\n+     * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    public static int[] remove(int[] array, int index) {\n+        return (int[]) remove((Object) array, index);\n+    }\n+\n+    /**\n+     * <p>Removes the first occurrence of the specified element from the\n+     * specified array. All subsequent elements are shifted to the left\n+     * (substracts one from their indices). If the array doesn't contains\n+     * such an element, no elements are removed from the array.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the first occurrence of the specified element. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElement(null, 1)      = null\n+     * ArrayUtils.removeElement([], 1)        = []\n+     * ArrayUtils.removeElement([1], 2)       = [1]\n+     * ArrayUtils.removeElement([1, 3], 1)    = [3]\n+     * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may be <code>null</code>\n+     * @param element  the element to be removed\n+     * @return A new array containing the existing elements except the first\n+     *         occurrence of the specified element.\n+     * @since 2.1\n+     */\n+    public static int[] removeElement(int[] array, int element) {\n+        int index = indexOf(array, element);\n+        if (index == INDEX_NOT_FOUND) {\n+            return clone(array);\n+        }\n+        return remove(array, index);\n+    }\n+\n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.remove([1], 0)         = []\n+     * ArrayUtils.remove([2, 6], 0)      = [6]\n+     * ArrayUtils.remove([2, 6], 1)      = [2]\n+     * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    public static long[] remove(long[] array, int index) {\n+        return (long[]) remove((Object) array, index);\n+    }\n+\n+    /**\n+     * <p>Removes the first occurrence of the specified element from the\n+     * specified array. All subsequent elements are shifted to the left\n+     * (substracts one from their indices). If the array doesn't contains\n+     * such an element, no elements are removed from the array.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the first occurrence of the specified element. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElement(null, 1)      = null\n+     * ArrayUtils.removeElement([], 1)        = []\n+     * ArrayUtils.removeElement([1], 2)       = [1]\n+     * ArrayUtils.removeElement([1, 3], 1)    = [3]\n+     * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may be <code>null</code>\n+     * @param element  the element to be removed\n+     * @return A new array containing the existing elements except the first\n+     *         occurrence of the specified element.\n+     * @since 2.1\n+     */\n+    public static long[] removeElement(long[] array, long element) {\n+        int index = indexOf(array, element);\n+        if (index == INDEX_NOT_FOUND) {\n+            return clone(array);\n+        }\n+        return remove(array, index);\n+    }\n+\n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.remove([1], 0)         = []\n+     * ArrayUtils.remove([2, 6], 0)      = [6]\n+     * ArrayUtils.remove([2, 6], 1)      = [2]\n+     * ArrayUtils.remove([2, 6, 3], 1)   = [2, 3]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    public static short[] remove(short[] array, int index) {\n+        return (short[]) remove((Object) array, index);\n+    }\n+\n+    /**\n+     * <p>Removes the first occurrence of the specified element from the\n+     * specified array. All subsequent elements are shifted to the left\n+     * (substracts one from their indices). If the array doesn't contains\n+     * such an element, no elements are removed from the array.</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the first occurrence of the specified element. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <pre>\n+     * ArrayUtils.removeElement(null, 1)      = null\n+     * ArrayUtils.removeElement([], 1)        = []\n+     * ArrayUtils.removeElement([1], 2)       = [1]\n+     * ArrayUtils.removeElement([1, 3], 1)    = [3]\n+     * ArrayUtils.removeElement([1, 3, 1], 1) = [3, 1]\n+     * </pre>\n+     *\n+     * @param array  the array to remove the element from, may be <code>null</code>\n+     * @param element  the element to be removed\n+     * @return A new array containing the existing elements except the first\n+     *         occurrence of the specified element.\n+     * @since 2.1\n+     */\n+    public static short[] removeElement(short[] array, short element) {\n+        int index = indexOf(array, element);\n+        if (index == INDEX_NOT_FOUND) {\n+            return clone(array);\n+        }\n+        return remove(array, index);\n+    }\n+\n+    /**\n+     * <p>Removes the element at the specified position from the specified array.\n+     * All subsequent elements are shifted to the left (substracts one from\n+     * their indices).</p>\n+     *\n+     * <p>This method returns a new array with the same elements of the input\n+     * array except the element on the specified position. The component\n+     * type of the returned array is always the same as that of the input\n+     * array.</p>\n+     *\n+     * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException\n+     * will be thrown, because in that case no valid index can be specified.</p>\n+     *\n+     * @param array  the array to remove the element from, may not be <code>null</code>\n+     * @param index  the position of the element to be removed\n+     * @return A new array containing the existing elements except the element\n+     *         at the specified position.\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * (index < 0 || index >= array.length), or if the array is <code>null</code>.\n+     * @since 2.1\n+     */\n+    private static Object remove(Object array, int index) {\n+        int length = getLength(array);\n+        if (index < 0 || index >= length) {\n+            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Length: \" + length);\n+        }\n+\n+        Object result = Array.newInstance(array.getClass().getComponentType(), length - 1);\n+        System.arraycopy(array, 0, result, 0, index);\n+        if (index < length - 1) {\n+            System.arraycopy(array, index + 1, result, index, length - index - 1);\n+        }\n+\n+        return result;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/BitField.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3;\n+\n+/**\n+ * <p>Operations on bit-mapped fields.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author Apache Jakarta POI\n+ * @author Scott Sanders (sanders at apache dot org)\n+ * @author Marc Johnson (mjohnson at apache dot org)\n+ * @author Andrew C. Oliver (acoliver at apache dot org)\n+ * @author Pete Gieser\n+ * @author Gary Gregory\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class BitField {\n+    \n+    private final int _mask;\n+    private final int _shift_count;\n+\n+    /**\n+     * <p>Creates a BitField instance.</p>\n+     *\n+     * @param mask the mask specifying which bits apply to this\n+     *  BitField. Bits that are set in this mask are the bits\n+     *  that this BitField operates on\n+     */\n+    public BitField(int mask) {\n+        _mask = mask;\n+        int count = 0;\n+        int bit_pattern = mask;\n+\n+        if (bit_pattern != 0) {\n+            while ((bit_pattern & 1) == 0) {\n+                count++;\n+                bit_pattern >>= 1;\n+            }\n+        }\n+        _shift_count = count;\n+    }\n+\n+    /**\n+     * <p>Obtains the value for the specified BitField, appropriately\n+     * shifted right.</p>\n+     *\n+     * <p>Many users of a BitField will want to treat the specified\n+     * bits as an int value, and will not want to be aware that the\n+     * value is stored as a BitField (and so shifted left so many\n+     * bits).</p>\n+     *\n+     * @see #setValue(int,int)\n+     * @param holder the int data containing the bits we're interested\n+     *  in\n+     * @return the selected bits, shifted right appropriately\n+     */\n+    public int getValue(int holder) {\n+        return getRawValue(holder) >> _shift_count;\n+    }\n+\n+    /**\n+     * <p>Obtains the value for the specified BitField, appropriately\n+     * shifted right, as a short.</p>\n+     *\n+     * <p>Many users of a BitField will want to treat the specified\n+     * bits as an int value, and will not want to be aware that the\n+     * value is stored as a BitField (and so shifted left so many\n+     * bits).</p>\n+     *\n+     * @see #setShortValue(short,short)\n+     * @param holder the short data containing the bits we're\n+     *  interested in\n+     * @return the selected bits, shifted right appropriately\n+     */\n+    public short getShortValue(short holder) {\n+        return (short) getValue(holder);\n+    }\n+\n+    /**\n+     * <p>Obtains the value for the specified BitField, unshifted.</p>\n+     *\n+     * @param holder the int data containing the bits we're\n+     *  interested in\n+     * @return the selected bits\n+     */\n+    public int getRawValue(int holder) {\n+        return holder & _mask;\n+    }\n+\n+    /**\n+     * <p>Obtains the value for the specified BitField, unshifted.</p>\n+     *\n+     * @param holder the short data containing the bits we're\n+     *  interested in\n+     * @return the selected bits\n+     */\n+    public short getShortRawValue(short holder) {\n+        return (short) getRawValue(holder);\n+    }\n+\n+    /**\n+     * <p>Returns whether the field is set or not.</p>\n+     *\n+     * <p>This is most commonly used for a single-bit field, which is\n+     * often used to represent a boolean value; the results of using\n+     * it for a multi-bit field is to determine whether *any* of its\n+     * bits are set.</p>\n+     *\n+     * @param holder the int data containing the bits we're interested\n+     *  in\n+     * @return <code>true</code> if any of the bits are set,\n+     *  else <code>false</code>\n+     */\n+    public boolean isSet(int holder) {\n+        return (holder & _mask) != 0;\n+    }\n+\n+    /**\n+     * <p>Returns whether all of the bits are set or not.</p>\n+     *\n+     * <p>This is a stricter test than {@link #isSet(int)},\n+     * in that all of the bits in a multi-bit set must be set\n+     * for this method to return <code>true</code>.</p>\n+     *\n+     * @param holder the int data containing the bits we're\n+     *  interested in\n+     * @return <code>true</code> if all of the bits are set,\n+     *  else <code>false</code>\n+     */\n+    public boolean isAllSet(int holder) {\n+        return (holder & _mask) == _mask;\n+    }\n+\n+    /**\n+     * <p>Replaces the bits with new values.</p>\n+     *\n+     * @see #getValue(int)\n+     * @param holder the int data containing the bits we're\n+     *  interested in\n+     * @param value the new value for the specified bits\n+     * @return the value of holder with the bits from the value\n+     *  parameter replacing the old bits\n+     */\n+    public int setValue(int holder, int value) {\n+        return (holder & ~_mask) | ((value << _shift_count) & _mask);\n+    }\n+\n+    /**\n+     * <p>Replaces the bits with new values.</p>\n+     *\n+     * @see #getShortValue(short)\n+     * @param holder the short data containing the bits we're\n+     *  interested in\n+     * @param value the new value for the specified bits\n+     * @return the value of holder with the bits from the value\n+     *  parameter replacing the old bits\n+     */\n+    public short setShortValue(short holder, short value) {\n+        return (short) setValue(holder, value);\n+    }\n+\n+    /**\n+     * <p>Clears the bits.</p>\n+     *\n+     * @param holder the int data containing the bits we're\n+     *  interested in\n+     * @return the value of holder with the specified bits cleared\n+     *  (set to <code>0</code>)\n+     */\n+    public int clear(int holder) {\n+        return holder & ~_mask;\n+    }\n+\n+    /**\n+     * <p>Clears the bits.</p>\n+     *\n+     * @param holder the short data containing the bits we're\n+     *  interested in\n+     * @return the value of holder with the specified bits cleared\n+     *  (set to <code>0</code>)\n+     */\n+    public short clearShort(short holder) {\n+        return (short) clear(holder);\n+    }\n+\n+    /**\n+     * <p>Clears the bits.</p>\n+     *\n+     * @param holder the byte data containing the bits we're\n+     *  interested in\n+     *\n+     * @return the value of holder with the specified bits cleared\n+     *  (set to <code>0</code>)\n+     */\n+    public byte clearByte(byte holder) {\n+        return (byte) clear(holder);\n+    }\n+\n+    /**\n+     * <p>Sets the bits.</p>\n+     *\n+     * @param holder the int data containing the bits we're\n+     *  interested in\n+     * @return the value of holder with the specified bits set\n+     *  to <code>1</code>\n+     */\n+    public int set(int holder) {\n+        return holder | _mask;\n+    }\n+\n+    /**\n+     * <p>Sets the bits.</p>\n+     *\n+     * @param holder the short data containing the bits we're\n+     *  interested in\n+     * @return the value of holder with the specified bits set\n+     *  to <code>1</code>\n+     */\n+    public short setShort(short holder) {\n+        return (short) set(holder);\n+    }\n+\n+    /**\n+     * <p>Sets the bits.</p>\n+     *\n+     * @param holder the byte data containing the bits we're\n+     *  interested in\n+     *\n+     * @return the value of holder with the specified bits set\n+     *  to <code>1</code>\n+     */\n+    public byte setByte(byte holder) {\n+        return (byte) set(holder);\n+    }\n+\n+    /**\n+     * <p>Sets a boolean BitField.</p>\n+     *\n+     * @param holder the int data containing the bits we're\n+     *  interested in\n+     * @param flag indicating whether to set or clear the bits\n+     * @return the value of holder with the specified bits set or\n+     *         cleared\n+     */\n+    public int setBoolean(int holder, boolean flag) {\n+        return flag ? set(holder) : clear(holder);\n+    }\n+\n+    /**\n+     * <p>Sets a boolean BitField.</p>\n+     *\n+     * @param holder the short data containing the bits we're\n+     *  interested in\n+     * @param flag indicating whether to set or clear the bits\n+     * @return the value of holder with the specified bits set or\n+     *  cleared\n+     */\n+    public short setShortBoolean(short holder, boolean flag) {\n+        return flag ? setShort(holder) : clearShort(holder);\n+    }\n+\n+    /**\n+     * <p>Sets a boolean BitField.</p>\n+     *\n+     * @param holder the byte data containing the bits we're\n+     *  interested in\n+     * @param flag indicating whether to set or clear the bits\n+     * @return the value of holder with the specified bits set or\n+     *  cleared\n+     */\n+    public byte setByteBoolean(byte holder, boolean flag) {\n+        return flag ? setByte(holder) : clearByte(holder);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/BooleanUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3;\n+\n+import org.apache.commons.lang3.math.NumberUtils;\n+\n+/**\n+ * <p>Operations on boolean primitives and Boolean objects.</p>\n+ *\n+ * <p>This class tries to handle <code>null</code> input gracefully.\n+ * An exception will not be thrown for a <code>null</code> input.\n+ * Each method documents its behaviour in more detail.</p>\n+ * \n+ * @author Apache Software Foundation\n+ * @author Matthew Hawthorne\n+ * @author Gary Gregory\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class BooleanUtils {\n+\n+    /**\n+     * <p><code>BooleanUtils</code> instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as <code>BooleanUtils.negate(true);</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n+     */\n+    public BooleanUtils() {\n+      super();\n+    }\n+\n+    // Boolean utilities\n+    //--------------------------------------------------------------------------\n+    /**\n+     * <p>Negates the specified boolean.</p>\n+     * \n+     * <p>If <code>null</code> is passed in, <code>null</code> will be returned.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.negate(Boolean.TRUE)  = Boolean.FALSE;\n+     *   BooleanUtils.negate(Boolean.FALSE) = Boolean.TRUE;\n+     *   BooleanUtils.negate(null)          = null;\n+     * </pre>\n+     * \n+     * @param bool  the Boolean to negate, may be null\n+     * @return the negated Boolean, or <code>null</code> if <code>null</code> input\n+     */\n+    public static Boolean negate(Boolean bool) {\n+        if (bool == null) {\n+            return null;\n+        }\n+        return (bool.booleanValue() ? Boolean.FALSE : Boolean.TRUE);\n+    }\n+    \n+    // boolean Boolean methods\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if a <code>Boolean</code> value is <code>true</code>,\n+     * handling <code>null</code> by returning <code>false</code>.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.isTrue(Boolean.TRUE)  = true\n+     *   BooleanUtils.isTrue(Boolean.FALSE) = false\n+     *   BooleanUtils.isTrue(null)          = false\n+     * </pre>\n+     *\n+     * @param bool  the boolean to check, null returns <code>false</code>\n+     * @return <code>true</code> only if the input is non-null and true\n+     * @since 2.1\n+     */\n+    public static boolean isTrue(Boolean bool) {\n+        if (bool == null) {\n+            return false;\n+        }\n+        return bool.booleanValue() ? true : false;\n+    }\n+\n+    /**\n+     * <p>Checks if a <code>Boolean</code> value is <i>not</i> <code>true</code>,\n+     * handling <code>null</code> by returning <code>true</code>.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.isNotTrue(Boolean.TRUE)  = false\n+     *   BooleanUtils.isNotTrue(Boolean.FALSE) = true\n+     *   BooleanUtils.isNotTrue(null)          = true\n+     * </pre>\n+     *\n+     * @param bool  the boolean to check, null returns <code>true</code>\n+     * @return <code>true</code> if the input is null or false\n+     * @since 2.3\n+     */\n+    public static boolean isNotTrue(Boolean bool) {\n+        return !isTrue(bool);\n+    }\n+\n+    /**\n+     * <p>Checks if a <code>Boolean</code> value is <code>false</code>,\n+     * handling <code>null</code> by returning <code>false</code>.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.isFalse(Boolean.TRUE)  = false\n+     *   BooleanUtils.isFalse(Boolean.FALSE) = true\n+     *   BooleanUtils.isFalse(null)          = false\n+     * </pre>\n+     *\n+     * @param bool  the boolean to check, null returns <code>false</code>\n+     * @return <code>true</code> only if the input is non-null and false\n+     * @since 2.1\n+     */\n+    public static boolean isFalse(Boolean bool) {\n+        if (bool == null) {\n+            return false;\n+        }\n+        return bool.booleanValue() ? false : true;\n+    }\n+\n+    /**\n+     * <p>Checks if a <code>Boolean</code> value is <i>not</i> <code>false</code>,\n+     * handling <code>null</code> by returning <code>true</code>.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.isNotFalse(Boolean.TRUE)  = true\n+     *   BooleanUtils.isNotFalse(Boolean.FALSE) = false\n+     *   BooleanUtils.isNotFalse(null)          = true\n+     * </pre>\n+     *\n+     * @param bool  the boolean to check, null returns <code>true</code>\n+     * @return <code>true</code> if the input is null or true\n+     * @since 2.3\n+     */\n+    public static boolean isNotFalse(Boolean bool) {\n+        return !isFalse(bool);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts a Boolean to a boolean handling <code>null</code>\n+     * by returning <code>false</code>.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.toBoolean(Boolean.TRUE)  = true\n+     *   BooleanUtils.toBoolean(Boolean.FALSE) = false\n+     *   BooleanUtils.toBoolean(null)          = false\n+     * </pre>\n+     *\n+     * @param bool  the boolean to convert\n+     * @return <code>true</code> or <code>false</code>, \n+     *  <code>null</code> returns <code>false</code>\n+     */\n+    public static boolean toBoolean(Boolean bool) {\n+        if (bool == null) {\n+            return false;\n+        }\n+        return bool.booleanValue() ? true : false;\n+    }\n+    \n+    /**\n+     * <p>Converts a Boolean to a boolean handling <code>null</code>.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toBooleanDefaultIfNull(Boolean.TRUE, false) = true\n+     *   BooleanUtils.toBooleanDefaultIfNull(Boolean.FALSE, true) = false\n+     *   BooleanUtils.toBooleanDefaultIfNull(null, true)          = true\n+     * </pre>\n+     *\n+     * @param bool  the boolean to convert\n+     * @param valueIfNull  the boolean value to return if <code>null</code>\n+     * @return <code>true</code> or <code>false</code>\n+     */\n+    public static boolean toBooleanDefaultIfNull(Boolean bool, boolean valueIfNull) {\n+        if (bool == null) {\n+            return valueIfNull;\n+        }\n+        return bool.booleanValue() ? true : false;\n+    }\n+    \n+    // Integer to Boolean methods\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts an int to a boolean using the convention that <code>zero</code>\n+     * is <code>false</code>.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toBoolean(0) = false\n+     *   BooleanUtils.toBoolean(1) = true\n+     *   BooleanUtils.toBoolean(2) = true\n+     * </pre>\n+     *\n+     * @param value  the int to convert\n+     * @return <code>true</code> if non-zero, <code>false</code>\n+     *  if zero\n+     */\n+    public static boolean toBoolean(int value) {\n+        return value == 0 ? false : true;\n+    }\n+    \n+    /**\n+     * <p>Converts an int to a Boolean using the convention that <code>zero</code>\n+     * is <code>false</code>.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toBoolean(0) = Boolean.FALSE\n+     *   BooleanUtils.toBoolean(1) = Boolean.TRUE\n+     *   BooleanUtils.toBoolean(2) = Boolean.TRUE\n+     * </pre>\n+     *\n+     * @param value  the int to convert\n+     * @return Boolean.TRUE if non-zero, Boolean.FALSE if zero,\n+     *  <code>null</code> if <code>null</code>\n+     */\n+    public static Boolean toBooleanObject(int value) {\n+        return value == 0 ? Boolean.FALSE : Boolean.TRUE;\n+    }\n+    \n+    /**\n+     * <p>Converts an Integer to a Boolean using the convention that <code>zero</code>\n+     * is <code>false</code>.</p>\n+     * \n+     * <p><code>null</code> will be converted to <code>null</code>.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.toBoolean(new Integer(0))    = Boolean.FALSE\n+     *   BooleanUtils.toBoolean(new Integer(1))    = Boolean.TRUE\n+     *   BooleanUtils.toBoolean(new Integer(null)) = null\n+     * </pre>\n+     *\n+     * @param value  the Integer to convert\n+     * @return Boolean.TRUE if non-zero, Boolean.FALSE if zero,\n+     *  <code>null</code> if <code>null</code> input\n+     */\n+    public static Boolean toBooleanObject(Integer value) {\n+        if (value == null) {\n+            return null;\n+        }\n+        return value.intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;\n+    }\n+    \n+    /**\n+     * <p>Converts an int to a boolean specifying the conversion values.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toBoolean(0, 1, 0) = false\n+     *   BooleanUtils.toBoolean(1, 1, 0) = true\n+     *   BooleanUtils.toBoolean(2, 1, 2) = false\n+     *   BooleanUtils.toBoolean(2, 2, 0) = true\n+     * </pre>\n+     *\n+     * @param value  the Integer to convert\n+     * @param trueValue  the value to match for <code>true</code>\n+     * @param falseValue  the value to match for <code>false</code>\n+     * @return <code>true</code> or <code>false</code>\n+     * @throws IllegalArgumentException if no match\n+     */\n+    public static boolean toBoolean(int value, int trueValue, int falseValue) {\n+        if (value == trueValue) {\n+            return true;\n+        } else if (value == falseValue) {\n+            return false;\n+        }\n+        // no match\n+        throw new IllegalArgumentException(\"The Integer did not match either specified value\");\n+    }\n+    \n+    /**\n+     * <p>Converts an Integer to a boolean specifying the conversion values.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toBoolean(new Integer(0), new Integer(1), new Integer(0)) = false\n+     *   BooleanUtils.toBoolean(new Integer(1), new Integer(1), new Integer(0)) = true\n+     *   BooleanUtils.toBoolean(new Integer(2), new Integer(1), new Integer(2)) = false\n+     *   BooleanUtils.toBoolean(new Integer(2), new Integer(2), new Integer(0)) = true\n+     *   BooleanUtils.toBoolean(null, null, new Integer(0))                     = true\n+     * </pre>\n+     *\n+     * @param value  the Integer to convert\n+     * @param trueValue  the value to match for <code>true</code>,\n+     *  may be <code>null</code>\n+     * @param falseValue  the value to match for <code>false</code>,\n+     *  may be <code>null</code>\n+     * @return <code>true</code> or <code>false</code>\n+     * @throws IllegalArgumentException if no match\n+     */\n+    public static boolean toBoolean(Integer value, Integer trueValue, Integer falseValue) {\n+        if (value == null) {\n+            if (trueValue == null) {\n+                return true;\n+            } else if (falseValue == null) {\n+                return false;\n+            }\n+        } else if (value.equals(trueValue)) {\n+            return true;\n+        } else if (value.equals(falseValue)) {\n+            return false;\n+        }\n+        // no match\n+        throw new IllegalArgumentException(\"The Integer did not match either specified value\");\n+    }\n+    \n+    /**\n+     * <p>Converts an int to a Boolean specifying the conversion values.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toBooleanObject(0, 0, 2, 3) = Boolean.TRUE\n+     *   BooleanUtils.toBooleanObject(2, 1, 2, 3) = Boolean.FALSE\n+     *   BooleanUtils.toBooleanObject(3, 1, 2, 3) = null\n+     * </pre>\n+     *\n+     * @param value  the Integer to convert\n+     * @param trueValue  the value to match for <code>true</code>\n+     * @param falseValue  the value to match for <code>false</code>\n+     * @param nullValue  the value to to match for <code>null</code>\n+     * @return Boolean.TRUE, Boolean.FALSE, or <code>null</code>\n+     * @throws IllegalArgumentException if no match\n+     */\n+    public static Boolean toBooleanObject(int value, int trueValue, int falseValue, int nullValue) {\n+        if (value == trueValue) {\n+            return Boolean.TRUE;\n+        } else if (value == falseValue) {\n+            return Boolean.FALSE;\n+        } else if (value == nullValue) {\n+            return null;\n+        }\n+        // no match\n+        throw new IllegalArgumentException(\"The Integer did not match any specified value\");\n+    }\n+    \n+    /**\n+     * <p>Converts an Integer to a Boolean specifying the conversion values.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toBooleanObject(new Integer(0), new Integer(0), new Integer(2), new Integer(3)) = Boolean.TRUE\n+     *   BooleanUtils.toBooleanObject(new Integer(2), new Integer(1), new Integer(2), new Integer(3)) = Boolean.FALSE\n+     *   BooleanUtils.toBooleanObject(new Integer(3), new Integer(1), new Integer(2), new Integer(3)) = null\n+     * </pre>\n+     *\n+     * @param value  the Integer to convert\n+     * @param trueValue  the value to match for <code>true</code>,\n+     *  may be <code>null</code>\n+     * @param falseValue  the value to match for <code>false</code>,\n+     *  may be <code>null</code>\n+     * @param nullValue  the value to to match for <code>null</code>,\n+     *  may be <code>null</code>\n+     * @return Boolean.TRUE, Boolean.FALSE, or <code>null</code>\n+     * @throws IllegalArgumentException if no match\n+     */\n+    public static Boolean toBooleanObject(Integer value, Integer trueValue, Integer falseValue, Integer nullValue) {\n+        if (value == null) {\n+            if (trueValue == null) {\n+                return Boolean.TRUE;\n+            } else if (falseValue == null) {\n+                return Boolean.FALSE;\n+            } else if (nullValue == null) {\n+                return null;\n+            }\n+        } else if (value.equals(trueValue)) {\n+            return Boolean.TRUE;\n+        } else if (value.equals(falseValue)) {\n+            return Boolean.FALSE;\n+        } else if (value.equals(nullValue)) {\n+            return null;\n+        }\n+        // no match\n+        throw new IllegalArgumentException(\"The Integer did not match any specified value\");\n+    }\n+    \n+    // Boolean to Integer methods\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts a boolean to an int using the convention that\n+     * <code>zero</code> is <code>false</code>.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.toInteger(true)  = 1\n+     *   BooleanUtils.toInteger(false) = 0\n+     * </pre>\n+     *\n+     * @param bool  the boolean to convert\n+     * @return one if <code>true</code>, zero if <code>false</code>\n+     */\n+    public static int toInteger(boolean bool) {\n+        return bool ? 1 : 0;\n+    }\n+    \n+    /**\n+     * <p>Converts a boolean to an Integer using the convention that\n+     * <code>zero</code> is <code>false</code>.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toIntegerObject(true)  = new Integer(1)\n+     *   BooleanUtils.toIntegerObject(false) = new Integer(0)\n+     * </pre>\n+     *\n+     * @param bool  the boolean to convert\n+     * @return one if <code>true</code>, zero if <code>false</code>\n+     */\n+    public static Integer toIntegerObject(boolean bool) {\n+        return bool ? NumberUtils.INTEGER_ONE : NumberUtils.INTEGER_ZERO;\n+    }\n+    \n+    /**\n+     * <p>Converts a Boolean to a Integer using the convention that\n+     * <code>zero</code> is <code>false</code>.</p>\n+     *\n+     * <p><code>null</code> will be converted to <code>null</code>.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.toIntegerObject(Boolean.TRUE)  = new Integer(1)\n+     *   BooleanUtils.toIntegerObject(Boolean.FALSE) = new Integer(0)\n+     * </pre>\n+     *\n+     * @param bool  the Boolean to convert\n+     * @return one if Boolean.TRUE, zero if Boolean.FALSE, <code>null</code> if <code>null</code>\n+     */\n+    public static Integer toIntegerObject(Boolean bool) {\n+        if (bool == null) {\n+            return null;\n+        }\n+        return bool.booleanValue() ? NumberUtils.INTEGER_ONE : NumberUtils.INTEGER_ZERO;\n+    }\n+    \n+    /**\n+     * <p>Converts a boolean to an int specifying the conversion values.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toInteger(true, 1, 0)  = 1\n+     *   BooleanUtils.toInteger(false, 1, 0) = 0\n+     * </pre>\n+     *\n+     * @param bool  the to convert\n+     * @param trueValue  the value to return if <code>true</code>\n+     * @param falseValue  the value to return if <code>false</code>\n+     * @return the appropriate value\n+     */\n+    public static int toInteger(boolean bool, int trueValue, int falseValue) {\n+        return bool ? trueValue : falseValue;\n+    }\n+    \n+    /**\n+     * <p>Converts a Boolean to an int specifying the conversion values.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toInteger(Boolean.TRUE, 1, 0, 2)  = 1\n+     *   BooleanUtils.toInteger(Boolean.FALSE, 1, 0, 2) = 0\n+     *   BooleanUtils.toInteger(null, 1, 0, 2)          = 2\n+     * </pre>\n+     *\n+     * @param bool  the Boolean to convert\n+     * @param trueValue  the value to return if <code>true</code>\n+     * @param falseValue  the value to return if <code>false</code>\n+     * @param nullValue  the value to return if <code>null</code>\n+     * @return the appropriate value\n+     */\n+    public static int toInteger(Boolean bool, int trueValue, int falseValue, int nullValue) {\n+        if (bool == null) {\n+            return nullValue;\n+        }\n+        return bool.booleanValue() ? trueValue : falseValue;\n+    }\n+    \n+    /**\n+     * <p>Converts a boolean to an Integer specifying the conversion values.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toIntegerObject(true, new Integer(1), new Integer(0))  = new Integer(1)\n+     *   BooleanUtils.toIntegerObject(false, new Integer(1), new Integer(0)) = new Integer(0)\n+     * </pre>\n+     *\n+     * @param bool  the to convert\n+     * @param trueValue  the value to return if <code>true</code>,\n+     *  may be <code>null</code>\n+     * @param falseValue  the value to return if <code>false</code>,\n+     *  may be <code>null</code>\n+     * @return the appropriate value\n+     */\n+    public static Integer toIntegerObject(boolean bool, Integer trueValue, Integer falseValue) {\n+        return bool ? trueValue : falseValue;\n+    }\n+    \n+    /**\n+     * <p>Converts a Boolean to an Integer specifying the conversion values.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toIntegerObject(Boolean.TRUE, new Integer(1), new Integer(0), new Integer(2))  = new Integer(1)\n+     *   BooleanUtils.toIntegerObject(Boolean.FALSE, new Integer(1), new Integer(0), new Integer(2)) = new Integer(0)\n+     *   BooleanUtils.toIntegerObject(null, new Integer(1), new Integer(0), new Integer(2))          = new Integer(2)\n+     * </pre>\n+     *\n+     * @param bool  the Boolean to convert\n+     * @param trueValue  the value to return if <code>true</code>,\n+     *  may be <code>null</code>\n+     * @param falseValue  the value to return if <code>false</code>,\n+     *  may be <code>null</code>\n+     * @param nullValue  the value to return if <code>null</code>,\n+     *  may be <code>null</code>\n+     * @return the appropriate value\n+     */\n+    public static Integer toIntegerObject(Boolean bool, Integer trueValue, Integer falseValue, Integer nullValue) {\n+        if (bool == null) {\n+            return nullValue;\n+        }\n+        return bool.booleanValue() ? trueValue : falseValue;\n+    }\n+    \n+    // String to Boolean methods\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts a String to a Boolean.</p>\n+     * \n+     * <p><code>'true'</code>, <code>'on'</code> or <code>'yes'</code>\n+     * (case insensitive) will return <code>true</code>.\n+     * <code>'false'</code>, <code>'off'</code> or <code>'no'</code>\n+     * (case insensitive) will return <code>false</code>.\n+     * Otherwise, <code>null</code> is returned.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.toBooleanObject(null)    = null\n+     *   BooleanUtils.toBooleanObject(\"true\")  = Boolean.TRUE\n+     *   BooleanUtils.toBooleanObject(\"false\") = Boolean.FALSE\n+     *   BooleanUtils.toBooleanObject(\"on\")    = Boolean.TRUE\n+     *   BooleanUtils.toBooleanObject(\"ON\")    = Boolean.TRUE\n+     *   BooleanUtils.toBooleanObject(\"off\")   = Boolean.FALSE\n+     *   BooleanUtils.toBooleanObject(\"oFf\")   = Boolean.FALSE\n+     *   BooleanUtils.toBooleanObject(\"blue\")  = null\n+     * </pre>\n+     *\n+     * @param str  the String to check\n+     * @return the Boolean value of the string,\n+     *  <code>null</code> if no match or <code>null</code> input\n+     */\n+    public static Boolean toBooleanObject(String str) {\n+        if (\"true\".equalsIgnoreCase(str)) {\n+            return Boolean.TRUE;\n+        } else if (\"false\".equalsIgnoreCase(str)) {\n+            return Boolean.FALSE;\n+        } else if (\"on\".equalsIgnoreCase(str)) {\n+            return Boolean.TRUE;\n+        } else if (\"off\".equalsIgnoreCase(str)) {\n+            return Boolean.FALSE;\n+        } else if (\"yes\".equalsIgnoreCase(str)) {\n+            return Boolean.TRUE;\n+        } else if (\"no\".equalsIgnoreCase(str)) {\n+            return Boolean.FALSE;\n+        }\n+        // no match\n+        return null;\n+    }\n+\n+    /**\n+     * <p>Converts a String to a Boolean throwing an exception if no match.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.toBooleanObject(\"true\", \"true\", \"false\", \"null\")  = Boolean.TRUE\n+     *   BooleanUtils.toBooleanObject(\"false\", \"true\", \"false\", \"null\") = Boolean.FALSE\n+     *   BooleanUtils.toBooleanObject(\"null\", \"true\", \"false\", \"null\")  = null\n+     * </pre>\n+     *\n+     * @param str  the String to check\n+     * @param trueString  the String to match for <code>true</code>\n+     *  (case sensitive), may be <code>null</code>\n+     * @param falseString  the String to match for <code>false</code>\n+     *  (case sensitive), may be <code>null</code>\n+     * @param nullString  the String to match for <code>null</code>\n+     *  (case sensitive), may be <code>null</code>\n+     * @return the Boolean value of the string,\n+     *  <code>null</code> if either the String matches <code>nullString</code>\n+     *  or if <code>null</code> input and <code>nullString</code> is\n+     *  <code>null</code>\n+     * @throws IllegalArgumentException if the String doesn't match\n+     */\n+    public static Boolean toBooleanObject(String str, String trueString, String falseString, String nullString) {\n+        if (str == null) {\n+            if (trueString == null) {\n+                return Boolean.TRUE;\n+            } else if (falseString == null) {\n+                return Boolean.FALSE;\n+            } else if (nullString == null) {\n+                return null;\n+            }\n+        } else if (str.equals(trueString)) {\n+            return Boolean.TRUE;\n+        } else if (str.equals(falseString)) {\n+            return Boolean.FALSE;\n+        } else if (str.equals(nullString)) {\n+            return null;\n+        }\n+        // no match\n+        throw new IllegalArgumentException(\"The String did not match any specified value\");\n+    }\n+\n+    // String to boolean methods\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts a String to a boolean (optimised for performance).</p>\n+     * \n+     * <p><code>'true'</code>, <code>'on'</code> or <code>'yes'</code>\n+     * (case insensitive) will return <code>true</code>. Otherwise,\n+     * <code>false</code> is returned.</p>\n+     * \n+     * <p>This method performs 4 times faster (JDK1.4) than\n+     * <code>Boolean.valueOf(String)</code>. However, this method accepts\n+     * 'on' and 'yes' as true values.\n+     *\n+     * <pre>\n+     *   BooleanUtils.toBoolean(null)    = false\n+     *   BooleanUtils.toBoolean(\"true\")  = true\n+     *   BooleanUtils.toBoolean(\"TRUE\")  = true\n+     *   BooleanUtils.toBoolean(\"tRUe\")  = true\n+     *   BooleanUtils.toBoolean(\"on\")    = true\n+     *   BooleanUtils.toBoolean(\"yes\")   = true\n+     *   BooleanUtils.toBoolean(\"false\") = false\n+     *   BooleanUtils.toBoolean(\"x gti\") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check\n+     * @return the boolean value of the string, <code>false</code> if no match\n+     */\n+    public static boolean toBoolean(String str) {\n+        // Previously used equalsIgnoreCase, which was fast for interned 'true'.\n+        // Non interned 'true' matched 15 times slower.\n+        // \n+        // Optimisation provides same performance as before for interned 'true'.\n+        // Similar performance for null, 'false', and other strings not length 2/3/4.\n+        // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.\n+        if (str == \"true\") {\n+            return true;\n+        }\n+        if (str == null) {\n+            return false;\n+        }\n+        switch (str.length()) {\n+            case 2: {\n+                char ch0 = str.charAt(0);\n+                char ch1 = str.charAt(1);\n+                return \n+                    (ch0 == 'o' || ch0 == 'O') &&\n+                    (ch1 == 'n' || ch1 == 'N');\n+            }\n+            case 3: {\n+                char ch = str.charAt(0);\n+                if (ch == 'y') {\n+                    return \n+                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n+                        (str.charAt(2) == 's' || str.charAt(2) == 'S');\n+                }\n+                if (ch == 'Y') {\n+                    return \n+                        (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n+                        (str.charAt(2) == 'S' || str.charAt(2) == 's');\n+                }\n+                return false;\n+            }\n+            case 4: {\n+                char ch = str.charAt(0);\n+                if (ch == 't') {\n+                    return \n+                        (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n+                        (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n+                        (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n+                }\n+                if (ch == 'T') {\n+                    return \n+                        (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n+                        (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n+                        (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+    \n+    /**\n+     * <p>Converts a String to a Boolean throwing an exception if no match found.</p>\n+     * \n+     * <p>null is returned if there is no match.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.toBoolean(\"true\", \"true\", \"false\")  = true\n+     *   BooleanUtils.toBoolean(\"false\", \"true\", \"false\") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check\n+     * @param trueString  the String to match for <code>true</code>\n+     *  (case sensitive), may be <code>null</code>\n+     * @param falseString  the String to match for <code>false</code>\n+     *  (case sensitive), may be <code>null</code>\n+     * @return the boolean value of the string\n+     * @throws IllegalArgumentException if the String doesn't match\n+     */\n+    public static boolean toBoolean(String str, String trueString, String falseString) {\n+        if (str == null) {\n+            if (trueString == null) {\n+                return true;\n+            } else if (falseString == null) {\n+                return false;\n+            }\n+        } else if (str.equals(trueString)) {\n+            return true;\n+        } else if (str.equals(falseString)) {\n+            return false;\n+        }\n+        // no match\n+        throw new IllegalArgumentException(\"The String did not match either specified value\");\n+    }\n+\n+    // Boolean to String methods\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts a Boolean to a String returning <code>'true'</code>,\n+     * <code>'false'</code>, or <code>null</code>.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toStringTrueFalse(Boolean.TRUE)  = \"true\"\n+     *   BooleanUtils.toStringTrueFalse(Boolean.FALSE) = \"false\"\n+     *   BooleanUtils.toStringTrueFalse(null)          = null;\n+     * </pre>\n+     *\n+     * @param bool  the Boolean to check\n+     * @return <code>'true'</code>, <code>'false'</code>,\n+     *  or <code>null</code>\n+     */\n+    public static String toStringTrueFalse(Boolean bool) {\n+        return toString(bool, \"true\", \"false\", null);\n+    }\n+    \n+    /**\n+     * <p>Converts a Boolean to a String returning <code>'on'</code>,\n+     * <code>'off'</code>, or <code>null</code>.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toStringOnOff(Boolean.TRUE)  = \"on\"\n+     *   BooleanUtils.toStringOnOff(Boolean.FALSE) = \"off\"\n+     *   BooleanUtils.toStringOnOff(null)          = null;\n+     * </pre>\n+     *\n+     * @param bool  the Boolean to check\n+     * @return <code>'on'</code>, <code>'off'</code>,\n+     *  or <code>null</code>\n+     */\n+    public static String toStringOnOff(Boolean bool) {\n+        return toString(bool, \"on\", \"off\", null);\n+    }\n+    \n+    /**\n+     * <p>Converts a Boolean to a String returning <code>'yes'</code>,\n+     * <code>'no'</code>, or <code>null</code>.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toStringYesNo(Boolean.TRUE)  = \"yes\"\n+     *   BooleanUtils.toStringYesNo(Boolean.FALSE) = \"no\"\n+     *   BooleanUtils.toStringYesNo(null)          = null;\n+     * </pre>\n+     *\n+     * @param bool  the Boolean to check\n+     * @return <code>'yes'</code>, <code>'no'</code>,\n+     *  or <code>null</code>\n+     */\n+    public static String toStringYesNo(Boolean bool) {\n+        return toString(bool, \"yes\", \"no\", null);\n+    }\n+    \n+    /**\n+     * <p>Converts a Boolean to a String returning one of the input Strings.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toString(Boolean.TRUE, \"true\", \"false\", null)   = \"true\"\n+     *   BooleanUtils.toString(Boolean.FALSE, \"true\", \"false\", null)  = \"false\"\n+     *   BooleanUtils.toString(null, \"true\", \"false\", null)           = null;\n+     * </pre>\n+     *\n+     * @param bool  the Boolean to check\n+     * @param trueString  the String to return if <code>true</code>,\n+     *  may be <code>null</code>\n+     * @param falseString  the String to return if <code>false</code>,\n+     *  may be <code>null</code>\n+     * @param nullString  the String to return if <code>null</code>,\n+     *  may be <code>null</code>\n+     * @return one of the three input Strings\n+     */\n+    public static String toString(Boolean bool, String trueString, String falseString, String nullString) {\n+        if (bool == null) {\n+            return nullString;\n+        }\n+        return bool.booleanValue() ? trueString : falseString;\n+    }\n+    \n+    // boolean to String methods\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts a boolean to a String returning <code>'true'</code>\n+     * or <code>'false'</code>.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toStringTrueFalse(true)   = \"true\"\n+     *   BooleanUtils.toStringTrueFalse(false)  = \"false\"\n+     * </pre>\n+     *\n+     * @param bool  the Boolean to check\n+     * @return <code>'true'</code>, <code>'false'</code>,\n+     *  or <code>null</code>\n+     */\n+    public static String toStringTrueFalse(boolean bool) {\n+        return toString(bool, \"true\", \"false\");\n+    }\n+    \n+    /**\n+     * <p>Converts a boolean to a String returning <code>'on'</code>\n+     * or <code>'off'</code>.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toStringOnOff(true)   = \"on\"\n+     *   BooleanUtils.toStringOnOff(false)  = \"off\"\n+     * </pre>\n+     *\n+     * @param bool  the Boolean to check\n+     * @return <code>'on'</code>, <code>'off'</code>,\n+     *  or <code>null</code>\n+     */\n+    public static String toStringOnOff(boolean bool) {\n+        return toString(bool, \"on\", \"off\");\n+    }\n+    \n+    /**\n+     * <p>Converts a boolean to a String returning <code>'yes'</code>\n+     * or <code>'no'</code>.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toStringYesNo(true)   = \"yes\"\n+     *   BooleanUtils.toStringYesNo(false)  = \"no\"\n+     * </pre>\n+     *\n+     * @param bool  the Boolean to check\n+     * @return <code>'yes'</code>, <code>'no'</code>,\n+     *  or <code>null</code>\n+     */\n+    public static String toStringYesNo(boolean bool) {\n+        return toString(bool, \"yes\", \"no\");\n+    }\n+    \n+    /**\n+     * <p>Converts a boolean to a String returning one of the input Strings.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.toString(true, \"true\", \"false\")   = \"true\"\n+     *   BooleanUtils.toString(false, \"true\", \"false\")  = \"false\"\n+     * </pre>\n+     *\n+     * @param bool  the Boolean to check\n+     * @param trueString  the String to return if <code>true</code>,\n+     *  may be <code>null</code>\n+     * @param falseString  the String to return if <code>false</code>,\n+     *  may be <code>null</code>\n+     * @return one of the two input Strings\n+     */\n+    public static String toString(boolean bool, String trueString, String falseString) {\n+        return bool ? trueString : falseString;\n+    }\n+    \n+    // xor methods\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Performs an xor on a set of booleans.</p>\n+     *\n+     * <pre>\n+     *   BooleanUtils.xor(new boolean[] { true, true })   = false\n+     *   BooleanUtils.xor(new boolean[] { false, false }) = false\n+     *   BooleanUtils.xor(new boolean[] { true, false })  = true\n+     * </pre>\n+     *\n+     * @param array  an array of <code>boolean<code>s\n+     * @return <code>true</code> if the xor is successful.\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty.\n+     */\n+    public static boolean xor(boolean[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array is empty\");\n+        }\n+\n+        // Loops through array, comparing each item\n+        int trueCount = 0;\n+        for (boolean element : array) {\n+            // If item is true, and trueCount is < 1, increments count\n+            // Else, xor fails\n+            if (element) {\n+                if (trueCount < 1) {\n+                    trueCount++;\n+                } else {\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        // Returns true if there was exactly 1 true item\n+        return trueCount == 1;\n+    }\n+\n+    /**\n+     * <p>Performs an xor on an array of Booleans.</p>\n+     * \n+     * <pre>\n+     *   BooleanUtils.xor(new Boolean[] { Boolean.TRUE, Boolean.TRUE })   = Boolean.FALSE\n+     *   BooleanUtils.xor(new Boolean[] { Boolean.FALSE, Boolean.FALSE }) = Boolean.FALSE\n+     *   BooleanUtils.xor(new Boolean[] { Boolean.TRUE, Boolean.FALSE })  = Boolean.TRUE\n+     * </pre>\n+     *\n+     * @param array  an array of <code>Boolean<code>s\n+     * @return <code>true</code> if the xor is successful.\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty.\n+     * @throws IllegalArgumentException if <code>array</code> contains a <code>null</code>\n+     */\n+    public static Boolean xor(Boolean[] array) {\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array is empty\");\n+        }\n+        boolean[] primitive = null;\n+        try {\n+            primitive = ArrayUtils.toPrimitive(array);\n+        } catch (NullPointerException ex) {\n+            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n+        }\n+        return xor(primitive) ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/CharEncoding.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang3;\n+\n+import java.io.UnsupportedEncodingException;\n+\n+/**\n+ * <p>\n+ * Character encoding names required of every implementation of the Java platform.\n+ * </p>\n+ * \n+ * <p>\n+ * According to <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+ * encoding names</a>:\n+ * <p>\n+ * <cite>Every implementation of the Java platform is required to support the following character encodings. Consult the\n+ * release documentation for your implementation to see if any other encodings are supported.</cite>\n+ * </p>\n+ * </p>\n+ * \n+ * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character encoding\n+ *      names</a>\n+ * @author Apache Software Foundation\n+ * @since 2.1\n+ * @version $Id$\n+ */\n+public class CharEncoding {\n+\n+    /**\n+     * <p>\n+     * ISO Latin Alphabet #1, also known as ISO-LATIN-1.\n+     * </p>\n+     * <p>\n+     * Every implementation of the Java platform is required to support this character encoding.\n+     * </p>\n+     * \n+     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+     *      encoding names</a>\n+     */\n+    public static final String ISO_8859_1 = \"ISO-8859-1\";\n+\n+    /**\n+     * <p>\n+     * Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.\n+     * </p>\n+     * <p>\n+     * Every implementation of the Java platform is required to support this character encoding.\n+     * </p>\n+     * \n+     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+     *      encoding names</a>\n+     */\n+    public static final String US_ASCII = \"US-ASCII\";\n+\n+    /**\n+     * <p>\n+     * Sixteen-bit Unicode Transformation Format, byte order specified by a mandatory initial byte-order mark (either\n+     * order accepted on input, big-endian used on output).\n+     * </p>\n+     * <p>\n+     * Every implementation of the Java platform is required to support this character encoding.\n+     * </p>\n+     * \n+     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+     *      encoding names</a>\n+     */\n+    public static final String UTF_16 = \"UTF-16\";\n+\n+    /**\n+     * <p>\n+     * Sixteen-bit Unicode Transformation Format, big-endian byte order.\n+     * </p>\n+     * <p>\n+     * Every implementation of the Java platform is required to support this character encoding.\n+     * </p>\n+     * \n+     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+     *      encoding names</a>\n+     */\n+    public static final String UTF_16BE = \"UTF-16BE\";\n+\n+    /**\n+     * <p>\n+     * Sixteen-bit Unicode Transformation Format, little-endian byte order.\n+     * </p>\n+     * <p>\n+     * Every implementation of the Java platform is required to support this character encoding.\n+     * </p>\n+     * \n+     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+     *      encoding names</a>\n+     */\n+    public static final String UTF_16LE = \"UTF-16LE\";\n+\n+    /**\n+     * <p>\n+     * Eight-bit Unicode Transformation Format.\n+     * </p>\n+     * <p>\n+     * Every implementation of the Java platform is required to support this character encoding.\n+     * </p>\n+     * \n+     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+     *      encoding names</a>\n+     */\n+    public static final String UTF_8 = \"UTF-8\";\n+\n+    /**\n+     * <p>\n+     * Returns whether the named charset is supported.\n+     * </p>\n+     * <p>\n+     * This is similar to <a\n+     * href=\"http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html#isSupported(java.lang.String)\">\n+     * java.nio.charset.Charset.isSupported(String)</a>\n+     * </p>\n+     * \n+     * @param name\n+     *            the name of the requested charset; may be either a canonical name or an alias\n+     * @return <code>true</code> if, and only if, support for the named charset is available in the current Java\n+     *         virtual machine\n+     * \n+     * @see <a href=\"http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc\">JRE character\n+     *      encoding names</a>\n+     */\n+    public static boolean isSupported(String name) {\n+        if (name == null) {\n+            return false;\n+        }\n+        try {\n+            new String(ArrayUtils.EMPTY_BYTE_ARRAY, name);\n+        } catch (UnsupportedEncodingException e) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/CharRange.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * <p>A contiguous range of characters, optionally negated.</p>\n+ * \n+ * <p>Instances are immutable.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author Chris Feldhacker\n+ * @author Gary Gregory\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public final class CharRange implements Serializable {\n+\n+    /**\n+     * Required for serialization support. Lang version 2.0. \n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 8270183163158333422L;\n+    \n+    /** The first character, inclusive, in the range. */\n+    private final char start;\n+    /** The last character, inclusive, in the range. */\n+    private final char end;\n+    /** True if the range is everything except the characters specified. */\n+    private final boolean negated;\n+    \n+    /** Cached toString. */\n+    private transient String iToString;\n+\n+    /**\n+     * <p>Constructs a <code>CharRange</code> over a set of characters,\n+     * optionally negating the range.</p>\n+     *\n+     * <p>A negated range includes everything except that defined by the\n+     * start and end characters.</p>\n+     * \n+     * <p>If start and end are in the wrong order, they are reversed.\n+     * Thus <code>a-e</code> is the same as <code>e-a</code>.</p>\n+     *\n+     * @param start  first character, inclusive, in this range\n+     * @param end  last character, inclusive, in this range\n+     * @param negated  true to express everything except the range\n+     */\n+    private CharRange(char start, char end, boolean negated) {\n+        super();\n+        if (start > end) {\n+            char temp = start;\n+            start = end;\n+            end = temp;\n+        }\n+        \n+        this.start = start;\n+        this.end = end;\n+        this.negated = negated;\n+    }\n+\n+    /**\n+     * <p>Constructs a <code>CharRange</code> over a single character.</p>\n+     *\n+     * @param ch  only character in this range\n+     * @see CharRange#CharRange(char, char, boolean)\n+     */\n+    public static CharRange is(char ch) {\n+        return new CharRange(ch, ch, false);\n+    }\n+\n+    /**\n+     * <p>Constructs a negated <code>CharRange</code> over a single character.</p>\n+     *\n+     * @param ch  only character in this range\n+     * @see CharRange#CharRange(char, char, boolean)\n+     */\n+    public static CharRange isNot(char ch) {\n+        return new CharRange(ch, ch, true);\n+    }\n+\n+    /**\n+     * <p>Constructs a <code>CharRange</code> over a set of characters.</p>\n+     *\n+     * @param start  first character, inclusive, in this range\n+     * @param end  last character, inclusive, in this range\n+     * @see CharRange#CharRange(char, char, boolean)\n+     */\n+    public static CharRange isIn(char start, char end) {\n+        return new CharRange(start, end, false);\n+    }\n+\n+    /**\n+     * <p>Constructs a negated <code>CharRange</code> over a set of characters.</p>\n+     *\n+     * @param start  first character, inclusive, in this range\n+     * @param end  last character, inclusive, in this range\n+     * @see CharRange#CharRange(char, char, boolean)\n+     */\n+    public static CharRange isNotIn(char start, char end) {\n+        return new CharRange(start, end, true);\n+    }\n+\n+    // Accessors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the start character for this character range.</p>\n+     * \n+     * @return the start char (inclusive)\n+     */\n+    public char getStart() {\n+        return this.start;\n+    }\n+\n+    /**\n+     * <p>Gets the end character for this character range.</p>\n+     * \n+     * @return the end char (inclusive)\n+     */\n+    public char getEnd() {\n+        return this.end;\n+    }\n+\n+    /**\n+     * <p>Is this <code>CharRange</code> negated.</p>\n+     * \n+     * <p>A negated range includes everything except that defined by the\n+     * start and end characters.</p>\n+     *\n+     * @return <code>true</code> is negated\n+     */\n+    public boolean isNegated() {\n+        return negated;\n+    }\n+\n+    // Contains\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Is the character specified contained in this range.</p>\n+     *\n+     * @param ch  the character to check\n+     * @return <code>true</code> if this range contains the input character\n+     */\n+    public boolean contains(char ch) {\n+        return (ch >= start && ch <= end) != negated;\n+    }\n+\n+    /**\n+     * <p>Are all the characters of the passed in range contained in\n+     * this range.</p>\n+     *\n+     * @param range  the range to check against\n+     * @return <code>true</code> if this range entirely contains the input range\n+     * @throws IllegalArgumentException if <code>null</code> input\n+     */\n+    public boolean contains(CharRange range) {\n+        if (range == null) {\n+            throw new IllegalArgumentException(\"The Range must not be null\");\n+        }\n+        if (negated) {\n+            if (range.negated) {\n+                return start >= range.start && end <= range.end;\n+            }\n+            return range.end < start || range.start > end;\n+        }\n+        if (range.negated) {\n+            return start == 0 && end == Character.MAX_VALUE;\n+        }\n+        return start <= range.start && end >= range.end;\n+    }\n+\n+    // Basics\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Compares two CharRange objects, returning true if they represent\n+     * exactly the same range of characters defined in the same way.</p>\n+     * \n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof CharRange == false) {\n+            return false;\n+        }\n+        CharRange other = (CharRange) obj;\n+        return start == other.start && end == other.end && negated == other.negated;\n+    }\n+\n+    /**\n+     * <p>Gets a hashCode compatible with the equals method.</p>\n+     * \n+     * @return a suitable hashCode\n+     */\n+    @Override\n+    public int hashCode() {\n+        return 83 + start + 7 * end + (negated ? 1 : 0);\n+    }\n+    \n+    /**\n+     * <p>Gets a string representation of the character range.</p>\n+     * \n+     * @return string representation of this range\n+     */\n+    @Override\n+    public String toString() {\n+        if (iToString == null) {\n+            StringBuilder buf = new StringBuilder(4);\n+            if (isNegated()) {\n+                buf.append('^');\n+            }\n+            buf.append(start);\n+            if (start != end) {\n+                buf.append('-');\n+                buf.append(end);\n+            }\n+            iToString = buf.toString();\n+        }\n+        return iToString;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/CharSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * <p>A set of characters.</p>\n+ *\n+ * <p>Instances are immutable, but instances of subclasses may not be.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author Phil Steitz\n+ * @author Pete Gieser\n+ * @author Gary Gregory\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class CharSet implements Serializable {\n+\n+    /**\n+     * Required for serialization support. Lang version 2.0. \n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 5947847346149275958L;\n+\n+    /** \n+     * A CharSet defining no characters. \n+     * @since 2.0\n+     */\n+    public static final CharSet EMPTY = new CharSet((String) null);\n+\n+    /** \n+     * A CharSet defining ASCII alphabetic characters \"a-zA-Z\".\n+     * @since 2.0\n+     */\n+    public static final CharSet ASCII_ALPHA = new CharSet(\"a-zA-Z\");\n+\n+    /** \n+     * A CharSet defining ASCII alphabetic characters \"a-z\".\n+     * @since 2.0\n+     */\n+    public static final CharSet ASCII_ALPHA_LOWER = new CharSet(\"a-z\");\n+\n+    /** \n+     * A CharSet defining ASCII alphabetic characters \"A-Z\".\n+     * @since 2.0\n+     */\n+    public static final CharSet ASCII_ALPHA_UPPER = new CharSet(\"A-Z\");\n+\n+    /** \n+     * A CharSet defining ASCII alphabetic characters \"0-9\".\n+     * @since 2.0\n+     */\n+    public static final CharSet ASCII_NUMERIC = new CharSet(\"0-9\");\n+\n+    /**\n+     * A Map of the common cases used in the factory.\n+     * Subclasses can add more common patterns if desired.\n+     * @since 2.0\n+     */\n+    protected static final Map<String, CharSet> COMMON = new HashMap<String, CharSet>();\n+    \n+    static {\n+        COMMON.put(null, EMPTY);\n+        COMMON.put(\"\", EMPTY);\n+        COMMON.put(\"a-zA-Z\", ASCII_ALPHA);\n+        COMMON.put(\"A-Za-z\", ASCII_ALPHA);\n+        COMMON.put(\"a-z\", ASCII_ALPHA_LOWER);\n+        COMMON.put(\"A-Z\", ASCII_ALPHA_UPPER);\n+        COMMON.put(\"0-9\", ASCII_NUMERIC);\n+    }\n+\n+    /** The set of CharRange objects. */\n+    private final Set<CharRange> set = new HashSet<CharRange>();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Factory method to create a new CharSet using a special syntax.</p>\n+     *\n+     * <ul>\n+     *  <li><code>null</code> or empty string (\"\")\n+     * - set containing no characters</li>\n+     *  <li>Single character, such as \"a\"\n+     *  - set containing just that character</li>\n+     *  <li>Multi character, such as \"a-e\"\n+     *  - set containing characters from one character to the other</li>\n+     *  <li>Negated, such as \"^a\" or \"^a-e\"\n+     *  - set containing all characters except those defined</li>\n+     *  <li>Combinations, such as \"abe-g\"\n+     *  - set containing all the characters from the individual sets</li>\n+     * </ul>\n+     *\n+     * <p>The matching order is:</p>\n+     * <ol>\n+     *  <li>Negated multi character range, such as \"^a-e\"\n+     *  <li>Ordinary multi character range, such as \"a-e\"\n+     *  <li>Negated single character, such as \"^a\"\n+     *  <li>Ordinary single character, such as \"a\"\n+     * </ol>\n+     * <p>Matching works left to right. Once a match is found the\n+     * search starts again from the next character.</p>\n+     *\n+     * <p>If the same range is defined twice using the same syntax, only\n+     * one range will be kept.\n+     * Thus, \"a-ca-c\" creates only one range of \"a-c\".</p>\n+     *\n+     * <p>If the start and end of a range are in the wrong order,\n+     * they are reversed. Thus \"a-e\" is the same as \"e-a\".\n+     * As a result, \"a-ee-a\" would create only one range,\n+     * as the \"a-e\" and \"e-a\" are the same.</p>\n+     *\n+     * <p>The set of characters represented is the union of the specified ranges.</p>\n+     *\n+     * <p>All CharSet objects returned by this method will be immutable.</p>\n+     *\n+     * @param setStr  the String describing the set, may be null\n+     * @return a CharSet instance\n+     * @since 2.0\n+     */\n+    public static CharSet getInstance(String setStr) {\n+        Object set = COMMON.get(setStr);\n+        if (set != null) {\n+            return (CharSet) set;\n+        }\n+        return new CharSet(setStr);\n+    }\n+\n+    /**\n+     * <p>Constructs a new CharSet using the set syntax.\n+     * Each string is merged in with the set.</p>\n+     *\n+     * @param setStrs  Strings to merge into the initial set, may be null\n+     * @return a CharSet instance\n+     * @since 2.4\n+     */\n+    public static CharSet getInstance(String[] setStrs) {\n+        if (setStrs == null) {\n+            return null;\n+        }\n+        return new CharSet(setStrs); \n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Constructs a new CharSet using the set syntax.</p>\n+     *\n+     * @param setStr  the String describing the set, may be null\n+     * @since 2.0\n+     */\n+    protected CharSet(String setStr) {\n+        super();\n+        add(setStr);\n+    }\n+\n+    /**\n+     * <p>Constructs a new CharSet using the set syntax.\n+     * Each string is merged in with the set.</p>\n+     *\n+     * @param set  Strings to merge into the initial set\n+     * @throws NullPointerException if set is <code>null</code>\n+     */\n+    protected CharSet(String[] set) {\n+        super();\n+        int sz = set.length;\n+        for (int i = 0; i < sz; i++) {\n+            add(set[i]);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Add a set definition string to the <code>CharSet</code>.</p>\n+     *\n+     * @param str  set definition string\n+     */\n+    protected void add(String str) {\n+        if (str == null) {\n+            return;\n+        }\n+\n+        int len = str.length();\n+        int pos = 0;\n+        while (pos < len) {\n+            int remainder = (len - pos);\n+            if (remainder >= 4 && str.charAt(pos) == '^' && str.charAt(pos + 2) == '-') {\n+                // negated range\n+                set.add(CharRange.isNotIn(str.charAt(pos + 1), str.charAt(pos + 3)));\n+                pos += 4;\n+            } else if (remainder >= 3 && str.charAt(pos + 1) == '-') {\n+                // range\n+                set.add(CharRange.isIn(str.charAt(pos), str.charAt(pos + 2)));\n+                pos += 3;\n+            } else if (remainder >= 2 && str.charAt(pos) == '^') {\n+                // negated char\n+                set.add(CharRange.isNot(str.charAt(pos + 1)));\n+                pos += 2;\n+            } else {\n+                // char\n+                set.add(CharRange.is(str.charAt(pos)));\n+                pos += 1;\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the internal set as an array of CharRange objects.</p>\n+     *\n+     * @return an array of immutable CharRange objects\n+     * @since 2.0\n+     */\n+    public CharRange[] getCharRanges() {\n+        return set.toArray(new CharRange[set.size()]);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Does the <code>CharSet</code> contain the specified\n+     * character <code>ch</code>.</p>\n+     *\n+     * @param ch  the character to check for\n+     * @return <code>true</code> if the set contains the characters\n+     */\n+    public boolean contains(char ch) {\n+        for (CharRange range : set) {\n+            if (range.contains(ch)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    // Basics\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Compares two CharSet objects, returning true if they represent\n+     * exactly the same set of characters defined in the same way.</p>\n+     *\n+     * <p>The two sets <code>abc</code> and <code>a-c</code> are <i>not</i>\n+     * equal according to this method.</p>\n+     *\n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     * @since 2.0\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof CharSet == false) {\n+            return false;\n+        }\n+        CharSet other = (CharSet) obj;\n+        return set.equals(other.set);\n+    }\n+\n+    /**\n+     * <p>Gets a hashCode compatible with the equals method.</p>\n+     *\n+     * @return a suitable hashCode\n+     * @since 2.0\n+     */\n+    @Override\n+    public int hashCode() {\n+        return 89 + set.hashCode();\n+    }\n+\n+    /**\n+     * <p>Gets a string representation of the set.</p>\n+     *\n+     * @return string representation of the set\n+     */\n+    @Override\n+    public String toString() {\n+        return set.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/CharSetUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3;\n+\n+/**\n+ * <p>Operations on <code>CharSet</code>s.</p>\n+ *\n+ * <p>This class handles <code>null</code> input gracefully.\n+ * An exception will not be thrown for a <code>null</code> input.\n+ * Each method documents its behaviour in more detail.</p>\n+ * \n+ * @see CharSet\n+ * @author Apache Software Foundation\n+ * @author Phil Steitz\n+ * @author Gary Gregory\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class CharSetUtils {\n+\n+    /**\n+     * <p>CharSetUtils instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as <code>CharSetUtils.evaluateSet(null);</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n+     */\n+    public CharSetUtils() {\n+      super();\n+    }\n+\n+    // Squeeze\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Squeezes any repetitions of a character that is mentioned in the\n+     * supplied set.</p>\n+     *\n+     * <pre>\n+     * CharSetUtils.squeeze(null, *)        = null\n+     * CharSetUtils.squeeze(\"\", *)          = \"\"\n+     * CharSetUtils.squeeze(*, null)        = *\n+     * CharSetUtils.squeeze(*, \"\")          = *\n+     * CharSetUtils.squeeze(\"hello\", \"k-p\") = \"helo\"\n+     * CharSetUtils.squeeze(\"hello\", \"a-e\") = \"hello\"\n+     * </pre>\n+     *\n+     * @see CharSet#getInstance(java.lang.String) for set-syntax.\n+     * @param str  the string to squeeze, may be null\n+     * @param set  the character set to use for manipulation, may be null\n+     * @return modified String, <code>null</code> if null string input\n+     */\n+    public static String squeeze(String str, String set) {\n+        if (StringUtils.isEmpty(str) || StringUtils.isEmpty(set)) {\n+            return str;\n+        }\n+        String[] strs = new String[1];\n+        strs[0] = set;\n+        return squeeze(str, strs);\n+    }\n+\n+    /**\n+     * <p>Squeezes any repetitions of a character that is mentioned in the\n+     * supplied set.</p>\n+     *\n+     * <p>An example is:</p>\n+     * <ul>\n+     *   <li>squeeze(&quot;hello&quot;, {&quot;el&quot;}) => &quot;helo&quot;</li>\n+     * </ul>\n+     * \n+     * @see CharSet#getInstance(java.lang.String) for set-syntax.\n+     * @param str  the string to squeeze, may be null\n+     * @param set  the character set to use for manipulation, may be null\n+     * @return modified String, <code>null</code> if null string input\n+     */\n+    public static String squeeze(String str, String[] set) {\n+        if (StringUtils.isEmpty(str) || ArrayUtils.isEmpty(set)) {\n+            return str;\n+        }\n+        CharSet chars = CharSet.getInstance(set);\n+        StringBuilder buffer = new StringBuilder(str.length());\n+        char[] chrs = str.toCharArray();\n+        int sz = chrs.length;\n+        char lastChar = ' ';\n+        char ch = ' ';\n+        for (int i = 0; i < sz; i++) {\n+            ch = chrs[i];\n+            if (chars.contains(ch)) {\n+                if ((ch == lastChar) && (i != 0)) {\n+                    continue;\n+                }\n+            }\n+            buffer.append(ch);\n+            lastChar = ch;\n+        }\n+        return buffer.toString();\n+    }\n+\n+    // Count\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Takes an argument in set-syntax, see evaluateSet,\n+     * and returns the number of characters present in the specified string.</p>\n+     *\n+     * <pre>\n+     * CharSetUtils.count(null, *)        = 0\n+     * CharSetUtils.count(\"\", *)          = 0\n+     * CharSetUtils.count(*, null)        = 0\n+     * CharSetUtils.count(*, \"\")          = 0\n+     * CharSetUtils.count(\"hello\", \"k-p\") = 3\n+     * CharSetUtils.count(\"hello\", \"a-e\") = 1\n+     * </pre>\n+     *\n+     * @see CharSet#getInstance(java.lang.String) for set-syntax.\n+     * @param str  String to count characters in, may be null\n+     * @param set  String set of characters to count, may be null\n+     * @return character count, zero if null string input\n+     */\n+    public static int count(String str, String set) {\n+        if (StringUtils.isEmpty(str) || StringUtils.isEmpty(set)) {\n+            return 0;\n+        }\n+        String[] strs = new String[1];\n+        strs[0] = set;\n+        return count(str, strs);\n+    }\n+    \n+    /**\n+     * <p>Takes an argument in set-syntax, see evaluateSet,\n+     * and returns the number of characters present in the specified string.</p>\n+     *\n+     * <p>An example would be:</p>\n+     * <ul>\n+     *  <li>count(&quot;hello&quot;, {&quot;c-f&quot;, &quot;o&quot;}) returns 2.</li>\n+     * </ul>\n+     *\n+     * @see CharSet#getInstance(java.lang.String) for set-syntax.\n+     * @param str  String to count characters in, may be null\n+     * @param set  String[] set of characters to count, may be null\n+     * @return character count, zero if null string input\n+     */\n+    public static int count(String str, String[] set) {\n+        if (StringUtils.isEmpty(str) || ArrayUtils.isEmpty(set)) {\n+            return 0;\n+        }\n+        CharSet chars = CharSet.getInstance(set);\n+        int count = 0;\n+        char[] chrs = str.toCharArray();\n+        int sz = chrs.length;\n+        for(int i=0; i<sz; i++) {\n+            if(chars.contains(chrs[i])) {\n+                count++;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    // Keep\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Takes an argument in set-syntax, see evaluateSet,\n+     * and keeps any of characters present in the specified string.</p>\n+     *\n+     * <pre>\n+     * CharSetUtils.keep(null, *)        = null\n+     * CharSetUtils.keep(\"\", *)          = \"\"\n+     * CharSetUtils.keep(*, null)        = \"\"\n+     * CharSetUtils.keep(*, \"\")          = \"\"\n+     * CharSetUtils.keep(\"hello\", \"hl\")  = \"hll\"\n+     * CharSetUtils.keep(\"hello\", \"le\")  = \"ell\"\n+     * </pre>\n+     *\n+     * @see CharSet#getInstance(java.lang.String) for set-syntax.\n+     * @param str  String to keep characters from, may be null\n+     * @param set  String set of characters to keep, may be null\n+     * @return modified String, <code>null</code> if null string input\n+     * @since 2.0\n+     */\n+    public static String keep(String str, String set) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (str.length() == 0 || StringUtils.isEmpty(set)) {\n+            return \"\";\n+        }\n+        String[] strs = new String[1];\n+        strs[0] = set;\n+        return keep(str, strs);\n+    }\n+    \n+    /**\n+     * <p>Takes an argument in set-syntax, see evaluateSet,\n+     * and keeps any of characters present in the specified string.</p>\n+     *\n+     * <p>An example would be:</p>\n+     * <ul>\n+     *  <li>keep(&quot;hello&quot;, {&quot;c-f&quot;, &quot;o&quot;})\n+     *   returns &quot;eo&quot;</li>\n+     * </ul>\n+     *\n+     * @see CharSet#getInstance(java.lang.String) for set-syntax.\n+     * @param str  String to keep characters from, may be null\n+     * @param set  String[] set of characters to keep, may be null\n+     * @return modified String, <code>null</code> if null string input\n+     * @since 2.0\n+     */\n+    public static String keep(String str, String[] set) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (str.length() == 0 || ArrayUtils.isEmpty(set)) {\n+            return \"\";\n+        }\n+        return modify(str, set, true);\n+    }\n+\n+    // Delete\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Takes an argument in set-syntax, see evaluateSet,\n+     * and deletes any of characters present in the specified string.</p>\n+     *\n+     * <pre>\n+     * CharSetUtils.delete(null, *)        = null\n+     * CharSetUtils.delete(\"\", *)          = \"\"\n+     * CharSetUtils.delete(*, null)        = *\n+     * CharSetUtils.delete(*, \"\")          = *\n+     * CharSetUtils.delete(\"hello\", \"hl\")  = \"eo\"\n+     * CharSetUtils.delete(\"hello\", \"le\")  = \"ho\"\n+     * </pre>\n+     *\n+     * @see CharSet#getInstance(java.lang.String) for set-syntax.\n+     * @param str  String to delete characters from, may be null\n+     * @param set  String set of characters to delete, may be null\n+     * @return modified String, <code>null</code> if null string input\n+     */\n+    public static String delete(String str, String set) {\n+        if (StringUtils.isEmpty(str) || StringUtils.isEmpty(set)) {\n+            return str;\n+        }\n+        String[] strs = new String[1];\n+        strs[0] = set;\n+        return delete(str, strs);\n+    }\n+    \n+    /**\n+     * <p>Takes an argument in set-syntax, see evaluateSet,\n+     * and deletes any of characters present in the specified string.</p>\n+     *\n+     * <p>An example would be:</p>\n+     * <ul>\n+     *  <li>delete(&quot;hello&quot;, {&quot;c-f&quot;, &quot;o&quot;}) returns\n+     *   &quot;hll&quot;</li>\n+     * </ul>\n+     *\n+     * @see CharSet#getInstance(java.lang.String) for set-syntax.\n+     * @param str  String to delete characters from, may be null\n+     * @param set  String[] set of characters to delete, may be null\n+     * @return modified String, <code>null</code> if null string input\n+     */\n+    public static String delete(String str, String[] set) {\n+        if (StringUtils.isEmpty(str) || ArrayUtils.isEmpty(set)) {\n+            return str;\n+        }\n+        return modify(str, set, false);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implementation of delete and keep\n+     *\n+     * @param str String to modify characters within\n+     * @param set String[] set of characters to modify\n+     * @param expect whether to evaluate on match, or non-match\n+     * @return modified String\n+     */\n+    private static String modify(String str, String[] set, boolean expect) {\n+        CharSet chars = CharSet.getInstance(set);\n+        StringBuilder buffer = new StringBuilder(str.length());\n+        char[] chrs = str.toCharArray();\n+        int sz = chrs.length;\n+        for(int i=0; i<sz; i++) {\n+            if(chars.contains(chrs[i]) == expect) {\n+                buffer.append(chrs[i]);\n+            }\n+        }\n+        return buffer.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/CharUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3;\n+\n+/**\n+ * <p>Operations on char primitives and Character objects.</p>\n+ *\n+ * <p>This class tries to handle <code>null</code> input gracefully.\n+ * An exception will not be thrown for a <code>null</code> input.\n+ * Each method documents its behaviour in more detail.</p>\n+ * \n+ * @author Apache Software Foundation\n+ * @since 2.1\n+ * @version $Id$\n+ */\n+public class CharUtils {\n+    \n+    private static final String CHAR_STRING = \n+        \"\\u0000\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\" +\n+        \"\\b\\t\\n\\u000b\\f\\r\\u000e\\u000f\" +\n+        \"\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\" +\n+        \"\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f\" +\n+        \"\\u0020\\u0021\\\"\\u0023\\u0024\\u0025\\u0026\\u0027\" +\n+        \"\\u0028\\u0029\\u002a\\u002b\\u002c\\u002d\\u002e\\u002f\" +\n+        \"\\u0030\\u0031\\u0032\\u0033\\u0034\\u0035\\u0036\\u0037\" +\n+        \"\\u0038\\u0039\\u003a\\u003b\\u003c\\u003d\\u003e\\u003f\" +\n+        \"\\u0040\\u0041\\u0042\\u0043\\u0044\\u0045\\u0046\\u0047\" +\n+        \"\\u0048\\u0049\\u004a\\u004b\\u004c\\u004d\\u004e\\u004f\" +\n+        \"\\u0050\\u0051\\u0052\\u0053\\u0054\\u0055\\u0056\\u0057\" +\n+        \"\\u0058\\u0059\\u005a\\u005b\\\\\\u005d\\u005e\\u005f\" +\n+        \"\\u0060\\u0061\\u0062\\u0063\\u0064\\u0065\\u0066\\u0067\" +\n+        \"\\u0068\\u0069\\u006a\\u006b\\u006c\\u006d\\u006e\\u006f\" +\n+        \"\\u0070\\u0071\\u0072\\u0073\\u0074\\u0075\\u0076\\u0077\" +\n+        \"\\u0078\\u0079\\u007a\\u007b\\u007c\\u007d\\u007e\\u007f\";\n+    \n+    private static final String[] CHAR_STRING_ARRAY = new String[128];\n+    private static final Character[] CHAR_ARRAY = new Character[128];\n+    \n+    /**\n+     * <code>\\u000a</code> linefeed LF ('\\n').\n+     * \n+     * @see <a href=\"http://java.sun.com/docs/books/jls/third_edition/html/lexical.html#101089\">JLF: Escape Sequences\n+     *      for Character and String Literals</a>\n+     * @since 2.2\n+     */\n+    public static final char LF = '\\n';\n+\n+    /**\n+     * <code>\\u000d</code> carriage return CR ('\\r').\n+     * \n+     * @see <a href=\"http://java.sun.com/docs/books/jls/third_edition/html/lexical.html#101089\">JLF: Escape Sequences\n+     *      for Character and String Literals</a>\n+     * @since 2.2\n+     */\n+    public static final char CR = '\\r';\n+    \n+\n+    static {\n+        for (int i = 127; i >= 0; i--) {\n+            CHAR_STRING_ARRAY[i] = CHAR_STRING.substring(i, i + 1);\n+            CHAR_ARRAY[i] = new Character((char) i);\n+        }\n+    }\n+\n+    /**\n+     * <p><code>CharUtils</code> instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as <code>CharUtils.toString('c');</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n+     */\n+    public CharUtils() {\n+      super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts the character to a Character.</p>\n+     * \n+     * <p>For ASCII 7 bit characters, this uses a cache that will return the\n+     * same Character object each time.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.toCharacterObject(' ')  = ' '\n+     *   CharUtils.toCharacterObject('A')  = 'A'\n+     * </pre>\n+     *\n+     * @param ch  the character to convert\n+     * @return a Character of the specified character\n+     */\n+    public static Character toCharacterObject(char ch) {\n+        if (ch < CHAR_ARRAY.length) {\n+            return CHAR_ARRAY[ch];\n+        }\n+        return new Character(ch);\n+    }\n+    \n+    /**\n+     * <p>Converts the String to a Character using the first character, returning\n+     * null for empty Strings.</p>\n+     * \n+     * <p>For ASCII 7 bit characters, this uses a cache that will return the\n+     * same Character object each time.</p>\n+     * \n+     * <pre>\n+     *   CharUtils.toCharacterObject(null) = null\n+     *   CharUtils.toCharacterObject(\"\")   = null\n+     *   CharUtils.toCharacterObject(\"A\")  = 'A'\n+     *   CharUtils.toCharacterObject(\"BA\") = 'B'\n+     * </pre>\n+     *\n+     * @param str  the character to convert\n+     * @return the Character value of the first letter of the String\n+     */\n+    public static Character toCharacterObject(String str) {\n+        if (StringUtils.isEmpty(str)) {\n+            return null;\n+        }\n+        return toCharacterObject(str.charAt(0));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts the Character to a char throwing an exception for <code>null</code>.</p>\n+     * \n+     * <pre>\n+     *   CharUtils.toChar(null) = IllegalArgumentException\n+     *   CharUtils.toChar(' ')  = ' '\n+     *   CharUtils.toChar('A')  = 'A'\n+     * </pre>\n+     *\n+     * @param ch  the character to convert\n+     * @return the char value of the Character\n+     * @throws IllegalArgumentException if the Character is null\n+     */\n+    public static char toChar(Character ch) {\n+        if (ch == null) {\n+            throw new IllegalArgumentException(\"The Character must not be null\");\n+        }\n+        return ch.charValue();\n+    }\n+    \n+    /**\n+     * <p>Converts the Character to a char handling <code>null</code>.</p>\n+     * \n+     * <pre>\n+     *   CharUtils.toChar(null, 'X') = 'X'\n+     *   CharUtils.toChar(' ', 'X')  = ' '\n+     *   CharUtils.toChar('A', 'X')  = 'A'\n+     * </pre>\n+     *\n+     * @param ch  the character to convert\n+     * @param defaultValue  the value to use if the  Character is null\n+     * @return the char value of the Character or the default if null\n+     */\n+    public static char toChar(Character ch, char defaultValue) {\n+        if (ch == null) {\n+            return defaultValue;\n+        }\n+        return ch.charValue();\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts the String to a char using the first character, throwing\n+     * an exception on empty Strings.</p>\n+     * \n+     * <pre>\n+     *   CharUtils.toChar(null) = IllegalArgumentException\n+     *   CharUtils.toChar(\"\")   = IllegalArgumentException\n+     *   CharUtils.toChar(\"A\")  = 'A'\n+     *   CharUtils.toChar(\"BA\") = 'B'\n+     * </pre>\n+     *\n+     * @param str  the character to convert\n+     * @return the char value of the first letter of the String\n+     * @throws IllegalArgumentException if the String is empty\n+     */\n+    public static char toChar(String str) {\n+        if (StringUtils.isEmpty(str)) {\n+            throw new IllegalArgumentException(\"The String must not be empty\");\n+        }\n+        return str.charAt(0);\n+    }\n+    \n+    /**\n+     * <p>Converts the String to a char using the first character, defaulting\n+     * the value on empty Strings.</p>\n+     * \n+     * <pre>\n+     *   CharUtils.toChar(null, 'X') = 'X'\n+     *   CharUtils.toChar(\"\", 'X')   = 'X'\n+     *   CharUtils.toChar(\"A\", 'X')  = 'A'\n+     *   CharUtils.toChar(\"BA\", 'X') = 'B'\n+     * </pre>\n+     *\n+     * @param str  the character to convert\n+     * @param defaultValue  the value to use if the  Character is null\n+     * @return the char value of the first letter of the String or the default if null\n+     */\n+    public static char toChar(String str, char defaultValue) {\n+        if (StringUtils.isEmpty(str)) {\n+            return defaultValue;\n+        }\n+        return str.charAt(0);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts the character to the Integer it represents, throwing an\n+     * exception if the character is not numeric.</p>\n+     * \n+     * <p>This method coverts the char '1' to the int 1 and so on.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.toIntValue('3')  = 3\n+     *   CharUtils.toIntValue('A')  = IllegalArgumentException\n+     * </pre>\n+     *\n+     * @param ch  the character to convert\n+     * @return the int value of the character\n+     * @throws IllegalArgumentException if the character is not ASCII numeric\n+     */\n+    public static int toIntValue(char ch) {\n+        if (isAsciiNumeric(ch) == false) {\n+            throw new IllegalArgumentException(\"The character \" + ch + \" is not in the range '0' - '9'\");\n+        }\n+        return ch - 48;\n+    }\n+    \n+    /**\n+     * <p>Converts the character to the Integer it represents, throwing an\n+     * exception if the character is not numeric.</p>\n+     * \n+     * <p>This method coverts the char '1' to the int 1 and so on.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.toIntValue('3', -1)  = 3\n+     *   CharUtils.toIntValue('A', -1)  = -1\n+     * </pre>\n+     *\n+     * @param ch  the character to convert\n+     * @param defaultValue  the default value to use if the character is not numeric\n+     * @return the int value of the character\n+     */\n+    public static int toIntValue(char ch, int defaultValue) {\n+        if (isAsciiNumeric(ch) == false) {\n+            return defaultValue;\n+        }\n+        return ch - 48;\n+    }\n+    \n+    /**\n+     * <p>Converts the character to the Integer it represents, throwing an\n+     * exception if the character is not numeric.</p>\n+     * \n+     * <p>This method coverts the char '1' to the int 1 and so on.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.toIntValue(null) = IllegalArgumentException\n+     *   CharUtils.toIntValue('3')  = 3\n+     *   CharUtils.toIntValue('A')  = IllegalArgumentException\n+     * </pre>\n+     *\n+     * @param ch  the character to convert, not null\n+     * @return the int value of the character\n+     * @throws IllegalArgumentException if the Character is not ASCII numeric or is null\n+     */\n+    public static int toIntValue(Character ch) {\n+        if (ch == null) {\n+            throw new IllegalArgumentException(\"The character must not be null\");\n+        }\n+        return toIntValue(ch.charValue());\n+    }\n+    \n+    /**\n+     * <p>Converts the character to the Integer it represents, throwing an\n+     * exception if the character is not numeric.</p>\n+     * \n+     * <p>This method coverts the char '1' to the int 1 and so on.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.toIntValue(null, -1) = -1\n+     *   CharUtils.toIntValue('3', -1)  = 3\n+     *   CharUtils.toIntValue('A', -1)  = -1\n+     * </pre>\n+     *\n+     * @param ch  the character to convert\n+     * @param defaultValue  the default value to use if the character is not numeric\n+     * @return the int value of the character\n+     */\n+    public static int toIntValue(Character ch, int defaultValue) {\n+        if (ch == null) {\n+            return defaultValue;\n+        }\n+        return toIntValue(ch.charValue(), defaultValue);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts the character to a String that contains the one character.</p>\n+     * \n+     * <p>For ASCII 7 bit characters, this uses a cache that will return the\n+     * same String object each time.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.toString(' ')  = \" \"\n+     *   CharUtils.toString('A')  = \"A\"\n+     * </pre>\n+     *\n+     * @param ch  the character to convert\n+     * @return a String containing the one specified character\n+     */\n+    public static String toString(char ch) {\n+        if (ch < 128) {\n+            return CHAR_STRING_ARRAY[ch];\n+        }\n+        return new String(new char[] {ch});\n+    }\n+    \n+    /**\n+     * <p>Converts the character to a String that contains the one character.</p>\n+     * \n+     * <p>For ASCII 7 bit characters, this uses a cache that will return the\n+     * same String object each time.</p>\n+     * \n+     * <p>If <code>null</code> is passed in, <code>null</code> will be returned.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.toString(null) = null\n+     *   CharUtils.toString(' ')  = \" \"\n+     *   CharUtils.toString('A')  = \"A\"\n+     * </pre>\n+     *\n+     * @param ch  the character to convert\n+     * @return a String containing the one specified character\n+     */\n+    public static String toString(Character ch) {\n+        if (ch == null) {\n+            return null;\n+        }\n+        return toString(ch.charValue());\n+    }\n+    \n+    //--------------------------------------------------------------------------\n+    /**\n+     * <p>Converts the string to the unicode format '\\u0020'.</p>\n+     * \n+     * <p>This format is the Java source code format.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.unicodeEscaped(' ') = \"\\u0020\"\n+     *   CharUtils.unicodeEscaped('A') = \"\\u0041\"\n+     * </pre>\n+     * \n+     * @param ch  the character to convert\n+     * @return the escaped unicode string\n+     */\n+    public static String unicodeEscaped(char ch) {\n+        if (ch < 0x10) {\n+            return \"\\\\u000\" + Integer.toHexString(ch);\n+        } else if (ch < 0x100) {\n+            return \"\\\\u00\" + Integer.toHexString(ch);\n+        } else if (ch < 0x1000) {\n+            return \"\\\\u0\" + Integer.toHexString(ch);\n+        }\n+        return \"\\\\u\" + Integer.toHexString(ch);\n+    }\n+    \n+    /**\n+     * <p>Converts the string to the unicode format '\\u0020'.</p>\n+     * \n+     * <p>This format is the Java source code format.</p>\n+     * \n+     * <p>If <code>null</code> is passed in, <code>null</code> will be returned.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.unicodeEscaped(null) = null\n+     *   CharUtils.unicodeEscaped(' ')  = \"\\u0020\"\n+     *   CharUtils.unicodeEscaped('A')  = \"\\u0041\"\n+     * </pre>\n+     * \n+     * @param ch  the character to convert, may be null\n+     * @return the escaped unicode string, null if null input\n+     */\n+    public static String unicodeEscaped(Character ch) {\n+        if (ch == null) {\n+            return null;\n+        }\n+        return unicodeEscaped(ch.charValue());\n+    }\n+    \n+    //--------------------------------------------------------------------------\n+    /**\n+     * <p>Checks whether the character is ASCII 7 bit.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.isAscii('a')  = true\n+     *   CharUtils.isAscii('A')  = true\n+     *   CharUtils.isAscii('3')  = true\n+     *   CharUtils.isAscii('-')  = true\n+     *   CharUtils.isAscii('\\n') = true\n+     *   CharUtils.isAscii('&copy;') = false\n+     * </pre>\n+     * \n+     * @param ch  the character to check\n+     * @return true if less than 128\n+     */\n+    public static boolean isAscii(char ch) {\n+        return ch < 128;\n+    }\n+    \n+    /**\n+     * <p>Checks whether the character is ASCII 7 bit printable.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.isAsciiPrintable('a')  = true\n+     *   CharUtils.isAsciiPrintable('A')  = true\n+     *   CharUtils.isAsciiPrintable('3')  = true\n+     *   CharUtils.isAsciiPrintable('-')  = true\n+     *   CharUtils.isAsciiPrintable('\\n') = false\n+     *   CharUtils.isAsciiPrintable('&copy;') = false\n+     * </pre>\n+     * \n+     * @param ch  the character to check\n+     * @return true if between 32 and 126 inclusive\n+     */\n+    public static boolean isAsciiPrintable(char ch) {\n+        return ch >= 32 && ch < 127;\n+    }\n+    \n+    /**\n+     * <p>Checks whether the character is ASCII 7 bit control.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.isAsciiControl('a')  = false\n+     *   CharUtils.isAsciiControl('A')  = false\n+     *   CharUtils.isAsciiControl('3')  = false\n+     *   CharUtils.isAsciiControl('-')  = false\n+     *   CharUtils.isAsciiControl('\\n') = true\n+     *   CharUtils.isAsciiControl('&copy;') = false\n+     * </pre>\n+     * \n+     * @param ch  the character to check\n+     * @return true if less than 32 or equals 127\n+     */\n+    public static boolean isAsciiControl(char ch) {\n+        return ch < 32 || ch == 127;\n+    }\n+    \n+    /**\n+     * <p>Checks whether the character is ASCII 7 bit alphabetic.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.isAsciiAlpha('a')  = true\n+     *   CharUtils.isAsciiAlpha('A')  = true\n+     *   CharUtils.isAsciiAlpha('3')  = false\n+     *   CharUtils.isAsciiAlpha('-')  = false\n+     *   CharUtils.isAsciiAlpha('\\n') = false\n+     *   CharUtils.isAsciiAlpha('&copy;') = false\n+     * </pre>\n+     * \n+     * @param ch  the character to check\n+     * @return true if between 65 and 90 or 97 and 122 inclusive\n+     */\n+    public static boolean isAsciiAlpha(char ch) {\n+        return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z');\n+    }\n+    \n+    /**\n+     * <p>Checks whether the character is ASCII 7 bit alphabetic upper case.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.isAsciiAlphaUpper('a')  = false\n+     *   CharUtils.isAsciiAlphaUpper('A')  = true\n+     *   CharUtils.isAsciiAlphaUpper('3')  = false\n+     *   CharUtils.isAsciiAlphaUpper('-')  = false\n+     *   CharUtils.isAsciiAlphaUpper('\\n') = false\n+     *   CharUtils.isAsciiAlphaUpper('&copy;') = false\n+     * </pre>\n+     * \n+     * @param ch  the character to check\n+     * @return true if between 65 and 90 inclusive\n+     */\n+    public static boolean isAsciiAlphaUpper(char ch) {\n+        return ch >= 'A' && ch <= 'Z';\n+    }\n+    \n+    /**\n+     * <p>Checks whether the character is ASCII 7 bit alphabetic lower case.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.isAsciiAlphaLower('a')  = true\n+     *   CharUtils.isAsciiAlphaLower('A')  = false\n+     *   CharUtils.isAsciiAlphaLower('3')  = false\n+     *   CharUtils.isAsciiAlphaLower('-')  = false\n+     *   CharUtils.isAsciiAlphaLower('\\n') = false\n+     *   CharUtils.isAsciiAlphaLower('&copy;') = false\n+     * </pre>\n+     * \n+     * @param ch  the character to check\n+     * @return true if between 97 and 122 inclusive\n+     */\n+    public static boolean isAsciiAlphaLower(char ch) {\n+        return ch >= 'a' && ch <= 'z';\n+    }\n+    \n+    /**\n+     * <p>Checks whether the character is ASCII 7 bit numeric.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.isAsciiNumeric('a')  = false\n+     *   CharUtils.isAsciiNumeric('A')  = false\n+     *   CharUtils.isAsciiNumeric('3')  = true\n+     *   CharUtils.isAsciiNumeric('-')  = false\n+     *   CharUtils.isAsciiNumeric('\\n') = false\n+     *   CharUtils.isAsciiNumeric('&copy;') = false\n+     * </pre>\n+     * \n+     * @param ch  the character to check\n+     * @return true if between 48 and 57 inclusive\n+     */\n+    public static boolean isAsciiNumeric(char ch) {\n+        return ch >= '0' && ch <= '9';\n+    }\n+    \n+    /**\n+     * <p>Checks whether the character is ASCII 7 bit numeric.</p>\n+     *\n+     * <pre>\n+     *   CharUtils.isAsciiAlphanumeric('a')  = true\n+     *   CharUtils.isAsciiAlphanumeric('A')  = true\n+     *   CharUtils.isAsciiAlphanumeric('3')  = true\n+     *   CharUtils.isAsciiAlphanumeric('-')  = false\n+     *   CharUtils.isAsciiAlphanumeric('\\n') = false\n+     *   CharUtils.isAsciiAlphanumeric('&copy;') = false\n+     * </pre>\n+     * \n+     * @param ch  the character to check\n+     * @return true if between 48 and 57 or 65 and 90 or 97 and 122 inclusive\n+     */\n+    public static boolean isAsciiAlphanumeric(char ch) {\n+        return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9');\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/ClassUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * <p>Operates on classes without using reflection.</p>\n+ *\n+ * <p>This class handles invalid <code>null</code> inputs as best it can.\n+ * Each method documents its behaviour in more detail.</p>\n+ *\n+ * <p>The notion of a <code>canonical name</code> includes the human\n+ * readable name for the type, for example <code>int[]</code>. The\n+ * non-canonical method variants work with the JVM names, such as\n+ * <code>[I</code>. </p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author Gary Gregory\n+ * @author Norm Deane\n+ * @author Alban Peignier\n+ * @author Tomasz Blachowicz\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class ClassUtils {\n+\n+    /**\n+     * <p>The package separator character: <code>'&#x2e;' == {@value}</code>.</p>\n+     */\n+    public static final char PACKAGE_SEPARATOR_CHAR = '.';\n+\n+    /**\n+     * <p>The package separator String: <code>\"&#x2e;\"</code>.</p>\n+     */\n+    public static final String PACKAGE_SEPARATOR = String.valueOf(PACKAGE_SEPARATOR_CHAR);\n+\n+    /**\n+     * <p>The inner class separator character: <code>'$' == {@value}</code>.</p>\n+     */\n+    public static final char INNER_CLASS_SEPARATOR_CHAR = '$';\n+\n+    /**\n+     * <p>The inner class separator String: <code>\"$\"</code>.</p>\n+     */\n+    public static final String INNER_CLASS_SEPARATOR = String.valueOf(INNER_CLASS_SEPARATOR_CHAR);\n+\n+    /**\n+     * Maps primitive <code>Class</code>es to their corresponding wrapper <code>Class</code>.\n+     */\n+    private static final Map<Class<?>, Class<?>> primitiveWrapperMap = new HashMap<Class<?>, Class<?>>();\n+    static {\n+         primitiveWrapperMap.put(Boolean.TYPE, Boolean.class);\n+         primitiveWrapperMap.put(Byte.TYPE, Byte.class);\n+         primitiveWrapperMap.put(Character.TYPE, Character.class);\n+         primitiveWrapperMap.put(Short.TYPE, Short.class);\n+         primitiveWrapperMap.put(Integer.TYPE, Integer.class);\n+         primitiveWrapperMap.put(Long.TYPE, Long.class);\n+         primitiveWrapperMap.put(Double.TYPE, Double.class);\n+         primitiveWrapperMap.put(Float.TYPE, Float.class);\n+         primitiveWrapperMap.put(Void.TYPE, Void.TYPE);\n+    }\n+\n+    /**\n+     * Maps wrapper <code>Class</code>es to their corresponding primitive types.\n+     */\n+    private static final Map<Class<?>, Class<?>> wrapperPrimitiveMap = new HashMap<Class<?>, Class<?>>();\n+    static {\n+        for (Class<?> primitiveClass : primitiveWrapperMap.keySet()) {\n+            Class<?> wrapperClass = primitiveWrapperMap.get(primitiveClass);\n+            if (!primitiveClass.equals(wrapperClass)) {\n+                wrapperPrimitiveMap.put(wrapperClass, primitiveClass);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Maps a primitive class name to its corresponding abbreviation used in array class names.\n+     */\n+    private static final Map<String, String> abbreviationMap = new HashMap<String, String>();\n+\n+    /**\n+     * Maps an abbreviation used in array class names to corresponding primitive class name.\n+     */\n+    private static final Map<String, String> reverseAbbreviationMap = new HashMap<String, String>();\n+\n+    /**\n+     * Add primitive type abbreviation to maps of abbreviations.\n+     *\n+     * @param primitive Canonical name of primitive type\n+     * @param abbreviation Corresponding abbreviation of primitive type\n+     */\n+    private static void addAbbreviation(String primitive, String abbreviation) {\n+        abbreviationMap.put(primitive, abbreviation);\n+        reverseAbbreviationMap.put(abbreviation, primitive);\n+    }\n+\n+    /**\n+     * Feed abbreviation maps\n+     */\n+    static {\n+        addAbbreviation(\"int\", \"I\");\n+        addAbbreviation(\"boolean\", \"Z\");\n+        addAbbreviation(\"float\", \"F\");\n+        addAbbreviation(\"long\", \"J\");\n+        addAbbreviation(\"short\", \"S\");\n+        addAbbreviation(\"byte\", \"B\");\n+        addAbbreviation(\"double\", \"D\");\n+        addAbbreviation(\"char\", \"C\");\n+    }\n+\n+    /**\n+     * <p>ClassUtils instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as\n+     * <code>ClassUtils.getShortClassName(cls)</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean\n+     * instance to operate.</p>\n+     */\n+    public ClassUtils() {\n+      super();\n+    }\n+\n+    // Short class name\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the class name minus the package name for an <code>Object</code>.</p>\n+     *\n+     * @param object  the class to get the short name for, may be null\n+     * @param valueIfNull  the value to return if null\n+     * @return the class name of the object without the package name, or the null value\n+     */\n+    public static String getShortClassName(Object object, String valueIfNull) {\n+        if (object == null) {\n+            return valueIfNull;\n+        }\n+        return getShortClassName(object.getClass());\n+    }\n+\n+    /**\n+     * <p>Gets the class name minus the package name from a <code>Class</code>.</p>\n+     *\n+     * @param cls  the class to get the short name for.\n+     * @return the class name without the package name or an empty string\n+     */\n+    public static String getShortClassName(Class<?> cls) {\n+        if (cls == null) {\n+            return StringUtils.EMPTY;\n+        }\n+        return getShortClassName(cls.getName());\n+    }\n+\n+    /**\n+     * <p>Gets the class name minus the package name from a String.</p>\n+     *\n+     * <p>The string passed in is assumed to be a class name - it is not checked.</p>\n+     *\n+     * @param className  the className to get the short name for\n+     * @return the class name of the class without the package name or an empty string\n+     */\n+    public static String getShortClassName(String className) {\n+        if (className == null) {\n+            return StringUtils.EMPTY;\n+        }\n+        if (className.length() == 0) {\n+            return StringUtils.EMPTY;\n+        }\n+\n+        StringBuilder arrayPrefix = new StringBuilder();\n+\n+        // Handle array encoding\n+        if (className.startsWith(\"[\")) {\n+            while (className.charAt(0) == '[') {\n+                className = className.substring(1);\n+                arrayPrefix.append(\"[]\");\n+            }\n+            // Strip Object type encoding\n+            if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {\n+                className = className.substring(1, className.length() - 1);\n+            }\n+        }\n+\n+        if (reverseAbbreviationMap.containsKey(className)) {\n+            className = reverseAbbreviationMap.get(className);\n+        }\n+\n+        int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n+        int innerIdx = className.indexOf(\n+                INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);\n+        String out = className.substring(lastDotIdx + 1);\n+        if (innerIdx != -1) {\n+            out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);\n+        }\n+        return out + arrayPrefix;\n+    }\n+\n+    // Package name\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the package name of an <code>Object</code>.</p>\n+     *\n+     * @param object  the class to get the package name for, may be null\n+     * @param valueIfNull  the value to return if null\n+     * @return the package name of the object, or the null value\n+     */\n+    public static String getPackageName(Object object, String valueIfNull) {\n+        if (object == null) {\n+            return valueIfNull;\n+        }\n+        return getPackageName(object.getClass());\n+    }\n+\n+    /**\n+     * <p>Gets the package name of a <code>Class</code>.</p>\n+     *\n+     * @param cls  the class to get the package name for, may be <code>null</code>.\n+     * @return the package name or an empty string\n+     */\n+    public static String getPackageName(Class<?> cls) {\n+        if (cls == null) {\n+            return StringUtils.EMPTY;\n+        }\n+        return getPackageName(cls.getName());\n+    }\n+\n+    /**\n+     * <p>Gets the package name from a <code>String</code>.</p>\n+     *\n+     * <p>The string passed in is assumed to be a class name - it is not checked.</p>\n+     * <p>If the class is unpackaged, return an empty string.</p>\n+     *\n+     * @param className  the className to get the package name for, may be <code>null</code>\n+     * @return the package name or an empty string\n+     */\n+    public static String getPackageName(String className) {\n+        if (className == null || className.length() == 0) {\n+            return StringUtils.EMPTY;\n+        }\n+\n+        // Strip array encoding\n+        while (className.charAt(0) == '[') {\n+            className = className.substring(1);\n+        }\n+        // Strip Object type encoding\n+        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {\n+            className = className.substring(1);\n+        }\n+\n+        int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n+        if (i == -1) {\n+            return StringUtils.EMPTY;\n+        }\n+        return className.substring(0, i);\n+    }\n+\n+    // Superclasses/Superinterfaces\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Gets a <code>List</code> of superclasses for the given class.</p>\n+     *\n+     * @param cls  the class to look up, may be <code>null</code>\n+     * @return the <code>List</code> of superclasses in order going up from this one\n+     *  <code>null</code> if null input\n+     */\n+    public static List<Class<?>> getAllSuperclasses(Class<?> cls) {\n+        if (cls == null) {\n+            return null;\n+        }\n+        List<Class<?>> classes = new ArrayList<Class<?>>();\n+        Class<?> superclass = cls.getSuperclass();\n+        while (superclass != null) {\n+            classes.add(superclass);\n+            superclass = superclass.getSuperclass();\n+        }\n+        return classes;\n+    }\n+\n+    /**\n+     * <p>Gets a <code>List</code> of all interfaces implemented by the given\n+     * class and its superclasses.</p>\n+     *\n+     * <p>The order is determined by looking through each interface in turn as\n+     * declared in the source file and following its hierarchy up. Then each\n+     * superclass is considered in the same way. Later duplicates are ignored,\n+     * so the order is maintained.</p>\n+     *\n+     * @param cls  the class to look up, may be <code>null</code>\n+     * @return the <code>List</code> of interfaces in order,\n+     *  <code>null</code> if null input\n+     */\n+    public static List<Class<?>> getAllInterfaces(Class<?> cls) {\n+        if (cls == null) {\n+            return null;\n+        }\n+\n+        LinkedHashSet<Class<?>> interfacesFound = new LinkedHashSet<Class<?>>();\n+        getAllInterfaces(cls, interfacesFound);\n+\n+        return new ArrayList<Class<?>>(interfacesFound);\n+    }\n+\n+    private static void getAllInterfaces(Class<?> cls, HashSet<Class<?>> interfacesFound) {\n+        while (cls != null) {\n+            Class<?>[] interfaces = cls.getInterfaces();\n+\n+            for (Class<?> i : interfaces) {\n+                if (interfacesFound.add(i)) {\n+                    getAllInterfaces(i, interfacesFound);\n+                }\n+            }\n+\n+            cls = cls.getSuperclass();\n+         }\n+     }\n+\n+    // Convert list\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Given a <code>List</code> of class names, this method converts them into classes.</p>\n+     *\n+     * <p>A new <code>List</code> is returned. If the class name cannot be found, <code>null</code>\n+     * is stored in the <code>List</code>. If the class name in the <code>List</code> is\n+     * <code>null</code>, <code>null</code> is stored in the output <code>List</code>.</p>\n+     *\n+     * @param classNames  the classNames to change\n+     * @return a <code>List</code> of Class objects corresponding to the class names,\n+     *  <code>null</code> if null input\n+     * @throws ClassCastException if classNames contains a non String entry\n+     */\n+    public static List<Class<?>> convertClassNamesToClasses(List<String> classNames) {\n+        if (classNames == null) {\n+            return null;\n+        }\n+        List<Class<?>> classes = new ArrayList<Class<?>>(classNames.size());\n+        for (String className : classNames) {\n+            try {\n+                classes.add(Class.forName(className));\n+            } catch (Exception ex) {\n+                classes.add(null);\n+            }\n+        }\n+        return classes;\n+    }\n+\n+    /**\n+     * <p>Given a <code>List</code> of <code>Class</code> objects, this method converts\n+     * them into class names.</p>\n+     *\n+     * <p>A new <code>List</code> is returned. <code>null</code> objects will be copied into\n+     * the returned list as <code>null</code>.</p>\n+     *\n+     * @param classes  the classes to change\n+     * @return a <code>List</code> of class names corresponding to the Class objects,\n+     *  <code>null</code> if null input\n+     * @throws ClassCastException if <code>classes</code> contains a non-<code>Class</code> entry\n+     */\n+    public static List<String> convertClassesToClassNames(List<Class<?>> classes) {\n+        if (classes == null) {\n+            return null;\n+        }\n+        List<String> classNames = new ArrayList<String>(classes.size());\n+        for (Class<?> cls : classes) {\n+            if (cls == null) {\n+                classNames.add(null);\n+            } else {\n+                classNames.add(cls.getName());\n+            }\n+        }\n+        return classNames;\n+    }\n+\n+    // Is assignable\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if an array of Classes can be assigned to another array of Classes.</p>\n+     *\n+     * <p>This method calls {@link #isAssignable(Class, Class) isAssignable} for each\n+     * Class pair in the input arrays. It can be used to check if a set of arguments\n+     * (the first parameter) are suitably compatible with a set of method parameter types\n+     * (the second parameter).</p>\n+     *\n+     * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this\n+     * method takes into account widenings of primitive classes and\n+     * <code>null</code>s.</p>\n+     *\n+     * <p>Primitive widenings allow an int to be assigned to a <code>long</code>,\n+     * <code>float</code> or <code>double</code>. This method returns the correct\n+     * result for these cases.</p>\n+     *\n+     * <p><code>Null</code> may be assigned to any reference type. This method will\n+     * return <code>true</code> if <code>null</code> is passed in and the toClass is\n+     * non-primitive.</p>\n+     *\n+     * <p>Specifically, this method tests whether the type represented by the\n+     * specified <code>Class</code> parameter can be converted to the type\n+     * represented by this <code>Class</code> object via an identity conversion\n+     * widening primitive or widening reference conversion. See\n+     * <em><a href=\"http://java.sun.com/docs/books/jls/\">The Java Language Specification</a></em>,\n+     * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>\n+     *\n+     * @param classArray  the array of Classes to check, may be <code>null</code>\n+     * @param toClassArray  the array of Classes to try to assign into, may be <code>null</code>\n+     * @return <code>true</code> if assignment possible\n+     */\n+    //TODO when we bump the major version we should default autoboxing to true on platforms >= 1.5\n+    public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray) {\n+        return isAssignable(classArray, toClassArray, false);\n+    }\n+\n+    /**\n+     * <p>Checks if an array of Classes can be assigned to another array of Classes.</p>\n+     *\n+     * <p>This method calls {@link #isAssignable(Class, Class) isAssignable} for each\n+     * Class pair in the input arrays. It can be used to check if a set of arguments\n+     * (the first parameter) are suitably compatible with a set of method parameter types\n+     * (the second parameter).</p>\n+     *\n+     * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this\n+     * method takes into account widenings of primitive classes and\n+     * <code>null</code>s.</p>\n+     *\n+     * <p>Primitive widenings allow an int to be assigned to a <code>long</code>,\n+     * <code>float</code> or <code>double</code>. This method returns the correct\n+     * result for these cases.</p>\n+     *\n+     * <p><code>Null</code> may be assigned to any reference type. This method will\n+     * return <code>true</code> if <code>null</code> is passed in and the toClass is\n+     * non-primitive.</p>\n+     *\n+     * <p>Specifically, this method tests whether the type represented by the\n+     * specified <code>Class</code> parameter can be converted to the type\n+     * represented by this <code>Class</code> object via an identity conversion\n+     * widening primitive or widening reference conversion. See\n+     * <em><a href=\"http://java.sun.com/docs/books/jls/\">The Java Language Specification</a></em>,\n+     * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>\n+     *\n+     * @param classArray  the array of Classes to check, may be <code>null</code>\n+     * @param toClassArray  the array of Classes to try to assign into, may be <code>null</code>\n+     * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers\n+     * @return <code>true</code> if assignment possible\n+     */\n+    public static boolean isAssignable(Class<?>[] classArray, Class<?>[] toClassArray, boolean autoboxing) {\n+        if (ArrayUtils.isSameLength(classArray, toClassArray) == false) {\n+            return false;\n+        }\n+        if (classArray == null) {\n+            classArray = ArrayUtils.EMPTY_CLASS_ARRAY;\n+        }\n+        if (toClassArray == null) {\n+            toClassArray = ArrayUtils.EMPTY_CLASS_ARRAY;\n+        }\n+        for (int i = 0; i < classArray.length; i++) {\n+            if (isAssignable(classArray[i], toClassArray[i], autoboxing) == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks if one <code>Class</code> can be assigned to a variable of\n+     * another <code>Class</code>.</p>\n+     *\n+     * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method,\n+     * this method takes into account widenings of primitive classes and\n+     * <code>null</code>s.</p>\n+     *\n+     * <p>Primitive widenings allow an int to be assigned to a long, float or\n+     * double. This method returns the correct result for these cases.</p>\n+     *\n+     * <p><code>Null</code> may be assigned to any reference type. This method\n+     * will return <code>true</code> if <code>null</code> is passed in and the\n+     * toClass is non-primitive.</p>\n+     *\n+     * <p>Specifically, this method tests whether the type represented by the\n+     * specified <code>Class</code> parameter can be converted to the type\n+     * represented by this <code>Class</code> object via an identity conversion\n+     * widening primitive or widening reference conversion. See\n+     * <em><a href=\"http://java.sun.com/docs/books/jls/\">The Java Language Specification</a></em>,\n+     * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>\n+     *\n+     * @param cls  the Class to check, may be null\n+     * @param toClass  the Class to try to assign into, returns false if null\n+     * @return <code>true</code> if assignment possible\n+     */\n+    //TODO when we bump the major version we should default autoboxing to true on platforms >= 1.5\n+    public static boolean isAssignable(Class<?> cls, Class<?> toClass) {\n+        return isAssignable(cls, toClass, false);\n+    }\n+\n+    /**\n+     * <p>Checks if one <code>Class</code> can be assigned to a variable of\n+     * another <code>Class</code>.</p>\n+     *\n+     * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method,\n+     * this method takes into account widenings of primitive classes and\n+     * <code>null</code>s.</p>\n+     *\n+     * <p>Primitive widenings allow an int to be assigned to a long, float or\n+     * double. This method returns the correct result for these cases.</p>\n+     *\n+     * <p><code>Null</code> may be assigned to any reference type. This method\n+     * will return <code>true</code> if <code>null</code> is passed in and the\n+     * toClass is non-primitive.</p>\n+     *\n+     * <p>Specifically, this method tests whether the type represented by the\n+     * specified <code>Class</code> parameter can be converted to the type\n+     * represented by this <code>Class</code> object via an identity conversion\n+     * widening primitive or widening reference conversion. See\n+     * <em><a href=\"http://java.sun.com/docs/books/jls/\">The Java Language Specification</a></em>,\n+     * sections 5.1.1, 5.1.2 and 5.1.4 for details.</p>\n+     *\n+     * @param cls  the Class to check, may be null\n+     * @param toClass  the Class to try to assign into, returns false if null\n+     * @param autoboxing  whether to use implicit autoboxing/unboxing between primitives and wrappers\n+     * @return <code>true</code> if assignment possible\n+     */\n+    public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing) {\n+        if (toClass == null) {\n+            return false;\n+        }\n+        // have to check for null, as isAssignableFrom doesn't\n+        if (cls == null) {\n+            return !(toClass.isPrimitive());\n+        }\n+        //autoboxing:\n+        if (autoboxing) {\n+            if (cls.isPrimitive() && !toClass.isPrimitive()) {\n+                cls = primitiveToWrapper(cls);\n+                if (cls == null) {\n+                    return false;\n+                }\n+            }\n+            if (toClass.isPrimitive() && !cls.isPrimitive()) {\n+                cls = wrapperToPrimitive(cls);\n+                if (cls == null) {\n+                    return false;\n+                }\n+            }\n+        }\n+        if (cls.equals(toClass)) {\n+            return true;\n+        }\n+        if (cls.isPrimitive()) {\n+            if (toClass.isPrimitive() == false) {\n+                return false;\n+            }\n+            if (Integer.TYPE.equals(cls)) {\n+                return Long.TYPE.equals(toClass)\n+                    || Float.TYPE.equals(toClass)\n+                    || Double.TYPE.equals(toClass);\n+            }\n+            if (Long.TYPE.equals(cls)) {\n+                return Float.TYPE.equals(toClass)\n+                    || Double.TYPE.equals(toClass);\n+            }\n+            if (Boolean.TYPE.equals(cls)) {\n+                return false;\n+            }\n+            if (Double.TYPE.equals(cls)) {\n+                return false;\n+            }\n+            if (Float.TYPE.equals(cls)) {\n+                return Double.TYPE.equals(toClass);\n+            }\n+            if (Character.TYPE.equals(cls)) {\n+                return Integer.TYPE.equals(toClass)\n+                    || Long.TYPE.equals(toClass)\n+                    || Float.TYPE.equals(toClass)\n+                    || Double.TYPE.equals(toClass);\n+            }\n+            if (Short.TYPE.equals(cls)) {\n+                return Integer.TYPE.equals(toClass)\n+                    || Long.TYPE.equals(toClass)\n+                    || Float.TYPE.equals(toClass)\n+                    || Double.TYPE.equals(toClass);\n+            }\n+            if (Byte.TYPE.equals(cls)) {\n+                return Short.TYPE.equals(toClass)\n+                    || Integer.TYPE.equals(toClass)\n+                    || Long.TYPE.equals(toClass)\n+                    || Float.TYPE.equals(toClass)\n+                    || Double.TYPE.equals(toClass);\n+            }\n+            // should never get here\n+            return false;\n+        }\n+        return toClass.isAssignableFrom(cls);\n+    }\n+\n+    /**\n+     * <p>Converts the specified primitive Class object to its corresponding\n+     * wrapper Class object.</p>\n+     *\n+     * <p>NOTE: From v2.2, this method handles <code>Void.TYPE</code>,\n+     * returning <code>Void.TYPE</code>.</p>\n+     *\n+     * @param cls  the class to convert, may be null\n+     * @return the wrapper class for <code>cls</code> or <code>cls</code> if\n+     * <code>cls</code> is not a primitive. <code>null</code> if null input.\n+     * @since 2.1\n+     */\n+    public static Class<?> primitiveToWrapper(Class<?> cls) {\n+        Class<?> convertedClass = cls;\n+        if (cls != null && cls.isPrimitive()) {\n+            convertedClass = primitiveWrapperMap.get(cls);\n+        }\n+        return convertedClass;\n+    }\n+\n+    /**\n+     * <p>Converts the specified array of primitive Class objects to an array of\n+     * its corresponding wrapper Class objects.</p>\n+     *\n+     * @param classes  the class array to convert, may be null or empty\n+     * @return an array which contains for each given class, the wrapper class or\n+     * the original class if class is not a primitive. <code>null</code> if null input.\n+     * Empty array if an empty array passed in.\n+     * @since 2.1\n+     */\n+    public static Class<?>[] primitivesToWrappers(Class<?>[] classes) {\n+        if (classes == null) {\n+            return null;\n+        }\n+\n+        if (classes.length == 0) {\n+            return classes;\n+        }\n+\n+        Class<?>[] convertedClasses = new Class[classes.length];\n+        for (int i = 0; i < classes.length; i++) {\n+            convertedClasses[i] = primitiveToWrapper(classes[i]);\n+        }\n+        return convertedClasses;\n+    }\n+\n+    /**\n+     * <p>Converts the specified wrapper class to its corresponding primitive\n+     * class.</p>\n+     *\n+     * <p>This method is the counter part of <code>primitiveToWrapper()</code>.\n+     * If the passed in class is a wrapper class for a primitive type, this\n+     * primitive type will be returned (e.g. <code>Integer.TYPE</code> for\n+     * <code>Integer.class</code>). For other classes, or if the parameter is\n+     * <b>null</b>, the return value is <b>null</b>.</p>\n+     *\n+     * @param cls the class to convert, may be <b>null</b>\n+     * @return the corresponding primitive type if <code>cls</code> is a\n+     * wrapper class, <b>null</b> otherwise\n+     * @see #primitiveToWrapper(Class)\n+     * @since 2.4\n+     */\n+    public static Class<?> wrapperToPrimitive(Class<?> cls) {\n+        return wrapperPrimitiveMap.get(cls);\n+    }\n+\n+    /**\n+     * <p>Converts the specified array of wrapper Class objects to an array of\n+     * its corresponding primitive Class objects.</p>\n+     *\n+     * <p>This method invokes <code>wrapperToPrimitive()</code> for each element\n+     * of the passed in array.</p>\n+     *\n+     * @param classes  the class array to convert, may be null or empty\n+     * @return an array which contains for each given class, the primitive class or\n+     * <b>null</b> if the original class is not a wrapper class. <code>null</code> if null input.\n+     * Empty array if an empty array passed in.\n+     * @see #wrapperToPrimitive(Class)\n+     * @since 2.4\n+     */\n+    public static Class<?>[] wrappersToPrimitives(Class<?>[] classes) {\n+        if (classes == null) {\n+            return null;\n+        }\n+\n+        if (classes.length == 0) {\n+            return classes;\n+        }\n+\n+        Class<?>[] convertedClasses = new Class[classes.length];\n+        for (int i = 0; i < classes.length; i++) {\n+            convertedClasses[i] = wrapperToPrimitive(classes[i]);\n+        }\n+        return convertedClasses;\n+    }\n+\n+    // Inner class\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Is the specified class an inner class or static nested class.</p>\n+     *\n+     * @param cls  the class to check, may be null\n+     * @return <code>true</code> if the class is an inner or static nested class,\n+     *  false if not or <code>null</code>\n+     */\n+    public static boolean isInnerClass(Class<?> cls) {\n+        if (cls == null) {\n+            return false;\n+        }\n+        return cls.getName().indexOf(INNER_CLASS_SEPARATOR_CHAR) >= 0;\n+    }\n+\n+    // Class loading\n+    // ----------------------------------------------------------------------\n+    /**\n+     * Returns the class represented by <code>className</code> using the\n+     * <code>classLoader</code>.  This implementation supports names like\n+     * \"<code>java.lang.String[]</code>\" as well as \"<code>[Ljava.lang.String;</code>\".\n+     *\n+     * @param classLoader  the class loader to use to load the class\n+     * @param className  the class name\n+     * @param initialize  whether the class must be initialized\n+     * @return the class represented by <code>className</code> using the <code>classLoader</code>\n+     * @throws ClassNotFoundException if the class is not found\n+     */\n+    public static Class<?> getClass(\n+            ClassLoader classLoader, String className, boolean initialize) throws ClassNotFoundException {\n+        Class<?> clazz;\n+        if (abbreviationMap.containsKey(className)) {\n+            String clsName = \"[\" + abbreviationMap.get(className);\n+            clazz = Class.forName(clsName, initialize, classLoader).getComponentType();\n+        } else {\n+            clazz = Class.forName(toCanonicalName(className), initialize, classLoader);\n+        }\n+        return clazz;\n+    }\n+\n+    /**\n+     * Returns the (initialized) class represented by <code>className</code>\n+     * using the <code>classLoader</code>.  This implementation supports names\n+     * like \"<code>java.lang.String[]</code>\" as well as\n+     * \"<code>[Ljava.lang.String;</code>\".\n+     *\n+     * @param classLoader  the class loader to use to load the class\n+     * @param className  the class name\n+     * @return the class represented by <code>className</code> using the <code>classLoader</code>\n+     * @throws ClassNotFoundException if the class is not found\n+     */\n+    public static Class<?> getClass(ClassLoader classLoader, String className) throws ClassNotFoundException {\n+        return getClass(classLoader, className, true);\n+    }\n+\n+    /**\n+     * Returns the (initialized) class represented by <code>className</code>\n+     * using the current thread's context class loader. This implementation\n+     * supports names like \"<code>java.lang.String[]</code>\" as well as\n+     * \"<code>[Ljava.lang.String;</code>\".\n+     *\n+     * @param className  the class name\n+     * @return the class represented by <code>className</code> using the current thread's context class loader\n+     * @throws ClassNotFoundException if the class is not found\n+     */\n+    public static Class<?> getClass(String className) throws ClassNotFoundException {\n+        return getClass(className, true);\n+    }\n+\n+    /**\n+     * Returns the class represented by <code>className</code> using the\n+     * current thread's context class loader. This implementation supports\n+     * names like \"<code>java.lang.String[]</code>\" as well as\n+     * \"<code>[Ljava.lang.String;</code>\".\n+     *\n+     * @param className  the class name\n+     * @param initialize  whether the class must be initialized\n+     * @return the class represented by <code>className</code> using the current thread's context class loader\n+     * @throws ClassNotFoundException if the class is not found\n+     */\n+    public static Class<?> getClass(String className, boolean initialize) throws ClassNotFoundException {\n+        ClassLoader contextCL = Thread.currentThread().getContextClassLoader();\n+        ClassLoader loader = contextCL == null ? ClassUtils.class.getClassLoader() : contextCL;\n+        return getClass(loader, className, initialize );\n+    }\n+\n+    // Public method\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Returns the desired Method much like <code>Class.getMethod</code>, however\n+     * it ensures that the returned Method is from a public class or interface and not\n+     * from an anonymous inner class. This means that the Method is invokable and\n+     * doesn't fall foul of Java bug\n+     * <a href=\"http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4071957\">4071957</a>).\n+     *\n+     *  <code><pre>Set set = Collections.unmodifiableSet(...);\n+     *  Method method = ClassUtils.getPublicMethod(set.getClass(), \"isEmpty\",  new Class[0]);\n+     *  Object result = method.invoke(set, new Object[]);</pre></code>\n+     * </p>\n+     *\n+     * @param cls  the class to check, not null\n+     * @param methodName  the name of the method\n+     * @param parameterTypes  the list of parameters\n+     * @return the method\n+     * @throws NullPointerException if the class is null\n+     * @throws SecurityException if a a security violation occured\n+     * @throws NoSuchMethodException if the method is not found in the given class\n+     *  or if the metothod doen't conform with the requirements\n+     */\n+    public static Method getPublicMethod(Class<?> cls, String methodName, Class<?> parameterTypes[])\n+            throws SecurityException, NoSuchMethodException {\n+\n+        Method declaredMethod = cls.getMethod(methodName, parameterTypes);\n+        if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) {\n+            return declaredMethod;\n+        }\n+\n+        List<Class<?>> candidateClasses = new ArrayList<Class<?>>();\n+        candidateClasses.addAll(getAllInterfaces(cls));\n+        candidateClasses.addAll(getAllSuperclasses(cls));\n+\n+        for (Class<?> candidateClass : candidateClasses) {\n+            if (!Modifier.isPublic(candidateClass.getModifiers())) {\n+                continue;\n+            }\n+            Method candidateMethod;\n+            try {\n+                candidateMethod = candidateClass.getMethod(methodName, parameterTypes);\n+            } catch (NoSuchMethodException ex) {\n+                continue;\n+            }\n+            if (Modifier.isPublic(candidateMethod.getDeclaringClass().getModifiers())) {\n+                return candidateMethod;\n+            }\n+        }\n+\n+        throw new NoSuchMethodException(\"Can't find a public method for \" +\n+                methodName + \" \" + ArrayUtils.toString(parameterTypes));\n+    }\n+\n+    // ----------------------------------------------------------------------\n+    /**\n+     * Converts a class name to a JLS style class name.\n+     *\n+     * @param className  the class name\n+     * @return the converted name\n+     */\n+    private static String toCanonicalName(String className) {\n+        className = StringUtils.deleteWhitespace(className);\n+        if (className == null) {\n+            throw new NullPointerException(\"className must not be null.\");\n+        } else if (className.endsWith(\"[]\")) {\n+            StringBuilder classNameBuffer = new StringBuilder();\n+            while (className.endsWith(\"[]\")) {\n+                className = className.substring(0, className.length() - 2);\n+                classNameBuffer.append(\"[\");\n+            }\n+            String abbreviation = abbreviationMap.get(className);\n+            if (abbreviation != null) {\n+                classNameBuffer.append(abbreviation);\n+            } else {\n+                classNameBuffer.append(\"L\").append(className).append(\";\");\n+            }\n+            className = classNameBuffer.toString();\n+        }\n+        return className;\n+    }\n+\n+    /**\n+     * <p>Converts an array of <code>Object</code> in to an array of <code>Class</code> objects.</p>\n+     *\n+     * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>\n+     *\n+     * @param array an <code>Object</code> array\n+     * @return a <code>Class</code> array, <code>null</code> if null array input\n+     * @since 2.4\n+     */\n+    public static Class<?>[] toClass(Object[] array) {\n+        if (array == null) {\n+            return null;\n+        } else if (array.length == 0) {\n+            return ArrayUtils.EMPTY_CLASS_ARRAY;\n+        }\n+        Class<?>[] classes = new Class[array.length];\n+        for (int i = 0; i < array.length; i++) {\n+            classes[i] = array[i].getClass();\n+        }\n+        return classes;\n+    }\n+\n+    // Short canonical name\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the canonical name minus the package name for an <code>Object</code>.</p>\n+     *\n+     * @param object  the class to get the short name for, may be null\n+     * @param valueIfNull  the value to return if null\n+     * @return the canonical name of the object without the package name, or the null value\n+     * @since 2.4\n+     */\n+    public static String getShortCanonicalName(Object object, String valueIfNull) {\n+        if (object == null) {\n+            return valueIfNull;\n+        }\n+        return getShortCanonicalName(object.getClass().getName());\n+    }\n+\n+    /**\n+     * <p>Gets the canonical name minus the package name from a <code>Class</code>.</p>\n+     *\n+     * @param cls  the class to get the short name for.\n+     * @return the canonical name without the package name or an empty string\n+     * @since 2.4\n+     */\n+    public static String getShortCanonicalName(Class<?> cls) {\n+        if (cls == null) {\n+            return StringUtils.EMPTY;\n+        }\n+        return getShortCanonicalName(cls.getName());\n+    }\n+\n+    /**\n+     * <p>Gets the canonical name minus the package name from a String.</p>\n+     *\n+     * <p>The string passed in is assumed to be a canonical name - it is not checked.</p>\n+     *\n+     * @param canonicalName  the class name to get the short name for\n+     * @return the canonical name of the class without the package name or an empty string\n+     * @since 2.4\n+     */\n+    public static String getShortCanonicalName(String canonicalName) {\n+        return ClassUtils.getShortClassName(getCanonicalName(canonicalName));\n+    }\n+\n+    // Package name\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the package name from the canonical name of an <code>Object</code>.</p>\n+     *\n+     * @param object  the class to get the package name for, may be null\n+     * @param valueIfNull  the value to return if null\n+     * @return the package name of the object, or the null value\n+     * @since 2.4\n+     */\n+    public static String getPackageCanonicalName(Object object, String valueIfNull) {\n+        if (object == null) {\n+            return valueIfNull;\n+        }\n+        return getPackageCanonicalName(object.getClass().getName());\n+    }\n+\n+    /**\n+     * <p>Gets the package name from the canonical name of a <code>Class</code>.</p>\n+     *\n+     * @param cls  the class to get the package name for, may be <code>null</code>.\n+     * @return the package name or an empty string\n+     * @since 2.4\n+     */\n+    public static String getPackageCanonicalName(Class<?> cls) {\n+        if (cls == null) {\n+            return StringUtils.EMPTY;\n+        }\n+        return getPackageCanonicalName(cls.getName());\n+    }\n+\n+    /**\n+     * <p>Gets the package name from the canonical name. </p>\n+     *\n+     * <p>The string passed in is assumed to be a canonical name - it is not checked.</p>\n+     * <p>If the class is unpackaged, return an empty string.</p>\n+     *\n+     * @param canonicalName  the canonical name to get the package name for, may be <code>null</code>\n+     * @return the package name or an empty string\n+     * @since 2.4\n+     */\n+    public static String getPackageCanonicalName(String canonicalName) {\n+        return ClassUtils.getPackageName(getCanonicalName(canonicalName));\n+    }\n+\n+    /**\n+     * <p>Converts a given name of class into canonical format.\n+     * If name of class is not a name of array class it returns\n+     * unchanged name.</p>\n+     * <p>Example:\n+     * <ul>\n+     * <li><code>getCanonicalName(\"[I\") = \"int[]\"</code></li>\n+     * <li><code>getCanonicalName(\"[Ljava.lang.String;\") = \"java.lang.String[]\"</code></li>\n+     * <li><code>getCanonicalName(\"java.lang.String\") = \"java.lang.String\"</code></li>\n+     * </ul>\n+     * </p>\n+     *\n+     * @param className the name of class\n+     * @return canonical form of class name\n+     * @since 2.4\n+     */\n+    private static String getCanonicalName(String className) {\n+        className = StringUtils.deleteWhitespace(className);\n+        if (className == null) {\n+            return null;\n+        } else {\n+            int dim = 0;\n+            while (className.startsWith(\"[\")) {\n+                dim++;\n+                className = className.substring(1);\n+            }\n+            if (dim < 1) {\n+                return className;\n+            } else {\n+                if (className.startsWith(\"L\")) {\n+                    className = className.substring(\n+                        1,\n+                        className.endsWith(\";\")\n+                            ? className.length() - 1\n+                            : className.length());\n+                } else {\n+                    if (className.length() > 0) {\n+                        className = reverseAbbreviationMap.get(className.substring(0, 1));\n+                    }\n+                }\n+                StringBuilder canonicalClassNameBuffer = new StringBuilder(className);\n+                for (int i = 0; i < dim; i++) {\n+                    canonicalClassNameBuffer.append(\"[]\");\n+                }\n+                return canonicalClassNameBuffer.toString();\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/EnumUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Utility library to provide helper methods for Java enums.\n+ * \n+ * @author Apache Software Foundation\n+ */\n+public class EnumUtils {\n+\n+    /**\n+     * This constructor is public to permit tools that require a JavaBean\n+     * instance to operate.\n+     */\n+    public EnumUtils() {\n+    }\n+\n+    /**\n+     * Gets the <code>Map</code> of <code>enums</code> by name.\n+     * <p>\n+     * This method is useful when you need a map of enums by name.\n+     *\n+     * @param enumClass  the class of the <code>enum</code> to get, not null\n+     * @return the modifiable map of enum names to enums, never null\n+     */\n+    public static <E extends Enum<E>> Map<String, E> getEnumMap(Class<E> enumClass) {\n+        Map<String, E> map = new LinkedHashMap<String, E>();\n+        for (E e: enumClass.getEnumConstants()) {\n+            map.put(e.name(), e);\n+        }\n+        return map;\n+    }\n+\n+    /**\n+     * Gets the <code>List</code> of <code>enums</code>.\n+     * <p>\n+     * This method is useful when you need a list of enums rather than an array.\n+     *\n+     * @param enumClass  the class of the <code>enum</code> to get, not null\n+     * @return the modifiable list of enums, never null\n+     */\n+    public static <E extends Enum<E>> List<E> getEnumList(Class<E> enumClass) {\n+        return new ArrayList<E>(Arrays.asList(enumClass.getEnumConstants()));\n+    }\n+\n+    /**\n+     * Checks if the specified name is a valid <code>enum</code> for the class.\n+     * <p>\n+     * This method differs from {@link Enum#valueOf} in that checks if the name is\n+     * a valid enum without needing to catch the exception.\n+     *\n+     * @param enumClass  the class of the <code>enum</code> to get, not null\n+     * @return the map of enum names to enums, never null\n+     */\n+    public static <E extends Enum<E>> boolean isValidEnum(Class<E> enumClass, String enumName) {\n+        try {\n+            Enum.valueOf(enumClass, enumName);\n+            return true;\n+        } catch (IllegalArgumentException ex) {\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Gets the <code>enum</code> for the class, returning <code>null</code> if not found.\n+     * <p>\n+     * This method differs from {@link Enum#valueOf} in that it does not throw an exception\n+     * for an invalid enum name.\n+     *\n+     * @param enumClass  the class of the <code>enum</code> to get, not null\n+     * @return the map of enum names to enums, never null\n+     */\n+    public static <E extends Enum<E>> E getEnum(Class<E> enumClass, String enumName) {\n+        try {\n+            return Enum.valueOf(enumClass, enumName);\n+        } catch (IllegalArgumentException ex) {\n+            return null;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/LocaleUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * <p>Operations to assist when working with a {@link Locale}.</p>\n+ *\n+ * <p>This class tries to handle <code>null</code> input gracefully.\n+ * An exception will not be thrown for a <code>null</code> input.\n+ * Each method documents its behaviour in more detail.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @since 2.2\n+ * @version $Id$\n+ */\n+public class LocaleUtils {\n+\n+    /** Unmodifiable list of available locales. */\n+    //@GuardedBy(\"this\")\n+    private static List<Locale> cAvailableLocaleList; // lazily created by availableLocaleList()\n+\n+    /** Unmodifiable set of available locales. */\n+    //@GuardedBy(\"this\")\n+    private static Set<Locale> cAvailableLocaleSet;   // lazily created by availableLocaleSet()\n+\n+    /** Unmodifiable map of language locales by country. */\n+    private static final Map<String, List<Locale>> cLanguagesByCountry = Collections.synchronizedMap(new HashMap<String, List<Locale>>());\n+\n+    /** Unmodifiable map of country locales by language. */\n+    private static final Map<String, List<Locale>> cCountriesByLanguage = Collections.synchronizedMap(new HashMap<String, List<Locale>>());\n+\n+    /**\n+     * <p><code>LocaleUtils</code> instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as <code>LocaleUtils.toLocale(\"en_GB\");</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n+     */\n+    public LocaleUtils() {\n+      super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts a String to a Locale.</p>\n+     *\n+     * <p>This method takes the string format of a locale and creates the\n+     * locale object from it.</p>\n+     *\n+     * <pre>\n+     *   LocaleUtils.toLocale(\"en\")         = new Locale(\"en\", \"\")\n+     *   LocaleUtils.toLocale(\"en_GB\")      = new Locale(\"en\", \"GB\")\n+     *   LocaleUtils.toLocale(\"en_GB_xxx\")  = new Locale(\"en\", \"GB\", \"xxx\")   (#)\n+     * </pre>\n+     *\n+     * <p>(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4.\n+     * In JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn't.\n+     * Thus, the result from getVariant() may vary depending on your JDK.</p>\n+     *\n+     * <p>This method validates the input strictly.\n+     * The language code must be lowercase.\n+     * The country code must be uppercase.\n+     * The separator must be an underscore.\n+     * The length must be correct.\n+     * </p>\n+     *\n+     * @param str  the locale String to convert, null returns null\n+     * @return a Locale, null if null input\n+     * @throws IllegalArgumentException if the string is an invalid format\n+     */\n+    public static Locale toLocale(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        int len = str.length();\n+        if (len != 2 && len != 5 && len < 7) {\n+            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+        }\n+        char ch0 = str.charAt(0);\n+        char ch1 = str.charAt(1);\n+        if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {\n+            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+        }\n+        if (len == 2) {\n+            return new Locale(str, \"\");\n+        } else {\n+            if (str.charAt(2) != '_') {\n+                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+            }\n+            char ch3 = str.charAt(3);\n+            if (ch3 == '_') {\n+                return new Locale(str.substring(0, 2), \"\", str.substring(4));\n+            }\n+            char ch4 = str.charAt(4);\n+            if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {\n+                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+            }\n+            if (len == 5) {\n+                return new Locale(str.substring(0, 2), str.substring(3, 5));\n+            } else {\n+                if (str.charAt(5) != '_') {\n+                    throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n+                }\n+                return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Obtains the list of locales to search through when performing\n+     * a locale search.</p>\n+     *\n+     * <pre>\n+     * localeLookupList(Locale(\"fr\",\"CA\",\"xxx\"))\n+     *   = [Locale(\"fr\",\"CA\",\"xxx\"), Locale(\"fr\",\"CA\"), Locale(\"fr\")]\n+     * </pre>\n+     *\n+     * @param locale  the locale to start from\n+     * @return the unmodifiable list of Locale objects, 0 being locale, never null\n+     */\n+    public static List<Locale> localeLookupList(Locale locale) {\n+        return localeLookupList(locale, locale);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Obtains the list of locales to search through when performing\n+     * a locale search.</p>\n+     *\n+     * <pre>\n+     * localeLookupList(Locale(\"fr\", \"CA\", \"xxx\"), Locale(\"en\"))\n+     *   = [Locale(\"fr\",\"CA\",\"xxx\"), Locale(\"fr\",\"CA\"), Locale(\"fr\"), Locale(\"en\"]\n+     * </pre>\n+     *\n+     * <p>The result list begins with the most specific locale, then the\n+     * next more general and so on, finishing with the default locale.\n+     * The list will never contain the same locale twice.</p>\n+     *\n+     * @param locale  the locale to start from, null returns empty list\n+     * @param defaultLocale  the default locale to use if no other is found\n+     * @return the unmodifiable list of Locale objects, 0 being locale, never null\n+     */\n+    public static List<Locale> localeLookupList(Locale locale, Locale defaultLocale) {\n+        List<Locale> list = new ArrayList<Locale>(4);\n+        if (locale != null) {\n+            list.add(locale);\n+            if (locale.getVariant().length() > 0) {\n+                list.add(new Locale(locale.getLanguage(), locale.getCountry()));\n+            }\n+            if (locale.getCountry().length() > 0) {\n+                list.add(new Locale(locale.getLanguage(), \"\"));\n+            }\n+            if (list.contains(defaultLocale) == false) {\n+                list.add(defaultLocale);\n+            }\n+        }\n+        return Collections.unmodifiableList(list);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Obtains an unmodifiable list of installed locales.</p>\n+     * \n+     * <p>This method is a wrapper around {@link Locale#getAvailableLocales()}.\n+     * It is more efficient, as the JDK method must create a new array each\n+     * time it is called.</p>\n+     *\n+     * @return the unmodifiable list of available locales\n+     */\n+    public static List<Locale> availableLocaleList() {\n+        if(cAvailableLocaleList == null) { \n+            initAvailableLocaleList(); \n+        }\n+        return cAvailableLocaleList;\n+    }\n+\n+    /**\n+     * Initializes the availableLocaleList. It is separate from availableLocaleList() \n+     * to avoid the synchronized block affecting normal use, yet synchronized and \n+     * lazy loading to avoid a static block affecting other methods in this class. \n+     */\n+    private static synchronized void initAvailableLocaleList() {\n+        if(cAvailableLocaleList == null) {\n+            List<Locale> list = Arrays.asList(Locale.getAvailableLocales());\n+            cAvailableLocaleList = Collections.unmodifiableList(list);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Obtains an unmodifiable set of installed locales.</p>\n+     * \n+     * <p>This method is a wrapper around {@link Locale#getAvailableLocales()}.\n+     * It is more efficient, as the JDK method must create a new array each\n+     * time it is called.</p>\n+     *\n+     * @return the unmodifiable set of available locales\n+     */\n+    public static Set<Locale> availableLocaleSet() {\n+        if(cAvailableLocaleSet == null) { \n+            initAvailableLocaleSet(); \n+        }\n+        return cAvailableLocaleSet;\n+    }\n+\n+    /**\n+     * Initializes the availableLocaleSet. It is separate from availableLocaleSet() \n+     * to avoid the synchronized block affecting normal use, yet synchronized and \n+     * lazy loading to avoid a static block affecting other methods in this class. \n+     */\n+    private static synchronized void initAvailableLocaleSet() {\n+        if(cAvailableLocaleSet == null) {\n+            cAvailableLocaleSet = Collections.unmodifiableSet( new HashSet<Locale>(availableLocaleList()) );\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if the locale specified is in the list of available locales.</p>\n+     *\n+     * @param locale the Locale object to check if it is available\n+     * @return true if the locale is a known locale\n+     */\n+    public static boolean isAvailableLocale(Locale locale) {\n+        return availableLocaleList().contains(locale);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Obtains the list of languages supported for a given country.</p>\n+     *\n+     * <p>This method takes a country code and searches to find the\n+     * languages available for that country. Variant locales are removed.</p>\n+     *\n+     * @param countryCode  the 2 letter country code, null returns empty\n+     * @return an unmodifiable List of Locale objects, never null\n+     */\n+    public static List<Locale> languagesByCountry(String countryCode) {\n+        List<Locale> langs = cLanguagesByCountry.get(countryCode);  //syncd\n+        if (langs == null) {\n+            if (countryCode != null) {\n+                langs = new ArrayList<Locale>();\n+                List<Locale> locales = availableLocaleList();\n+                for (int i = 0; i < locales.size(); i++) {\n+                    Locale locale = locales.get(i);\n+                    if (countryCode.equals(locale.getCountry()) &&\n+                            locale.getVariant().length() == 0) {\n+                        langs.add(locale);\n+                    }\n+                }\n+                langs = Collections.unmodifiableList(langs);\n+            } else {\n+                langs = Collections.emptyList();\n+            }\n+            cLanguagesByCountry.put(countryCode, langs);  //syncd\n+        }\n+        return langs;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Obtains the list of countries supported for a given language.</p>\n+     * \n+     * <p>This method takes a language code and searches to find the\n+     * countries available for that language. Variant locales are removed.</p>\n+     *\n+     * @param languageCode  the 2 letter language code, null returns empty\n+     * @return an unmodifiable List of Locale objects, never null\n+     */\n+    public static List<Locale> countriesByLanguage(String languageCode) {\n+        List<Locale> countries = cCountriesByLanguage.get(languageCode);  //syncd\n+        if (countries == null) {\n+            if (languageCode != null) {\n+                countries = new ArrayList<Locale>();\n+                List<Locale> locales = availableLocaleList();\n+                for (int i = 0; i < locales.size(); i++) {\n+                    Locale locale = locales.get(i);\n+                    if (languageCode.equals(locale.getLanguage()) &&\n+                            locale.getCountry().length() != 0 &&\n+                            locale.getVariant().length() == 0) {\n+                        countries.add(locale);\n+                    }\n+                }\n+                countries = Collections.unmodifiableList(countries);\n+            } else {\n+                countries = Collections.emptyList();\n+            }\n+            cCountriesByLanguage.put(languageCode, countries);  //syncd\n+        }\n+        return countries;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/ObjectUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * <p>Operations on <code>Object</code>.</p>\n+ * \n+ * <p>This class tries to handle <code>null</code> input gracefully.\n+ * An exception will generally not be thrown for a <code>null</code> input.\n+ * Each method documents its behaviour in more detail.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author <a href=\"mailto:nissim@nksystems.com\">Nissim Karpenstein</a>\n+ * @author <a href=\"mailto:janekdb@yahoo.co.uk\">Janek Bogucki</a>\n+ * @author Daniel L. Rall\n+ * @author Gary Gregory\n+ * @author Mario Winterer\n+ * @author <a href=\"mailto:david@davidkarlsen.com\">David J. M. Karlsen</a>\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+//@Immutable\n+public class ObjectUtils {\n+\n+    /**\n+     * <p>Singleton used as a <code>null</code> placeholder where\n+     * <code>null</code> has another meaning.</p>\n+     *\n+     * <p>For example, in a <code>HashMap</code> the\n+     * {@link java.util.HashMap#get(java.lang.Object)} method returns\n+     * <code>null</code> if the <code>Map</code> contains\n+     * <code>null</code> or if there is no matching key. The\n+     * <code>Null</code> placeholder can be used to distinguish between\n+     * these two cases.</p>\n+     *\n+     * <p>Another example is <code>Hashtable</code>, where <code>null</code>\n+     * cannot be stored.</p>\n+     *\n+     * <p>This instance is Serializable.</p>\n+     */\n+    public static final Null NULL = new Null();\n+    \n+    /**\n+     * <p><code>ObjectUtils</code> instances should NOT be constructed in\n+     * standard programming. Instead, the class should be used as\n+     * <code>ObjectUtils.defaultIfNull(\"a\",\"b\");</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n+     */\n+    public ObjectUtils() {\n+        super();\n+    }\n+\n+    // Defaulting\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Returns a default value if the object passed is\n+     * <code>null</code>.</p>\n+     * \n+     * <pre>\n+     * ObjectUtils.defaultIfNull(null, null)      = null\n+     * ObjectUtils.defaultIfNull(null, \"\")        = \"\"\n+     * ObjectUtils.defaultIfNull(null, \"zz\")      = \"zz\"\n+     * ObjectUtils.defaultIfNull(\"abc\", *)        = \"abc\"\n+     * ObjectUtils.defaultIfNull(Boolean.TRUE, *) = Boolean.TRUE\n+     * </pre>\n+     *\n+     * @param object  the <code>Object</code> to test, may be <code>null</code>\n+     * @param defaultValue  the default value to return, may be <code>null</code>\n+     * @return <code>object</code> if it is not <code>null</code>, defaultValue otherwise\n+     */\n+    public static Object defaultIfNull(Object object, Object defaultValue) {\n+        return object != null ? object : defaultValue;\n+    }\n+\n+    /**\n+     * <p>Returns the first value in the array which is not <code>null</code>.\n+     * If all the values are <code>null</code> or the array is <code>null</code>\n+     * or empty then <code>null</code> is returned.</p>\n+     * \n+     * <pre>\n+     * ObjectUtils.firstNonNull(null, null)      = null\n+     * ObjectUtils.firstNonNull(null, \"\")        = \"\"\n+     * ObjectUtils.firstNonNull(null, null, \"\")  = \"\"\n+     * ObjectUtils.firstNonNull(null, \"zz\")      = \"zz\"\n+     * ObjectUtils.firstNonNull(\"abc\", *)        = \"abc\"\n+     * ObjectUtils.firstNonNull(null, \"xyz\", *)  = \"xyz\"\n+     * ObjectUtils.firstNonNull(Boolean.TRUE, *) = Boolean.TRUE\n+     * ObjectUtils.firstNonNull()                = null\n+     * </pre>\n+     *\n+     * @param values  the values to test, may be <code>null</code> or empty\n+     * @return the first value from <code>values</code> which is not <code>null</code>,\n+     *  or <code>null</code> if there are no non-null values\n+     */\n+    public static <T> T firstNonNull(T... values) {\n+        if (values != null) {\n+            for (T val : values) {\n+                if (val != null) {\n+                    return val;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    // Null-safe equals/hashCode\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Compares two objects for equality, where either one or both\n+     * objects may be <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * ObjectUtils.equals(null, null)                  = true\n+     * ObjectUtils.equals(null, \"\")                    = false\n+     * ObjectUtils.equals(\"\", null)                    = false\n+     * ObjectUtils.equals(\"\", \"\")                      = true\n+     * ObjectUtils.equals(Boolean.TRUE, null)          = false\n+     * ObjectUtils.equals(Boolean.TRUE, \"true\")        = false\n+     * ObjectUtils.equals(Boolean.TRUE, Boolean.TRUE)  = true\n+     * ObjectUtils.equals(Boolean.TRUE, Boolean.FALSE) = false\n+     * </pre>\n+     *\n+     * @param object1  the first object, may be <code>null</code>\n+     * @param object2  the second object, may be <code>null</code>\n+     * @return <code>true</code> if the values of both objects are the same\n+     */\n+    public static boolean equals(Object object1, Object object2) {\n+        if (object1 == object2) {\n+            return true;\n+        }\n+        if ((object1 == null) || (object2 == null)) {\n+            return false;\n+        }\n+        return object1.equals(object2);\n+    }\n+\n+    /**\n+     * <p>Gets the hash code of an object returning zero when the\n+     * object is <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * ObjectUtils.hashCode(null)   = 0\n+     * ObjectUtils.hashCode(obj)    = obj.hashCode()\n+     * </pre>\n+     *\n+     * @param obj  the object to obtain the hash code of, may be <code>null</code>\n+     * @return the hash code of the object, or zero if null\n+     * @since 2.1\n+     */\n+    public static int hashCode(Object obj) {\n+        return (obj == null) ? 0 : obj.hashCode();\n+    }\n+\n+    // Identity ToString\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the toString that would be produced by <code>Object</code>\n+     * if a class did not override toString itself. <code>null</code>\n+     * will return <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * ObjectUtils.identityToString(null)         = null\n+     * ObjectUtils.identityToString(\"\")           = \"java.lang.String@1e23\"\n+     * ObjectUtils.identityToString(Boolean.TRUE) = \"java.lang.Boolean@7fa\"\n+     * </pre>\n+     *\n+     * @param object  the object to create a toString for, may be\n+     *  <code>null</code>\n+     * @return the default toString text, or <code>null</code> if\n+     *  <code>null</code> passed in\n+     */\n+    public static String identityToString(Object object) {\n+        if (object == null) {\n+            return null;\n+        }\n+        StringBuffer buffer = new StringBuffer();\n+        identityToString(buffer, object);\n+        return buffer.toString();\n+    }\n+\n+    /**\n+     * <p>Appends the toString that would be produced by <code>Object</code>\n+     * if a class did not override toString itself. <code>null</code>\n+     * will throw a NullPointerException for either of the two parameters. </p>\n+     *\n+     * <pre>\n+     * ObjectUtils.identityToString(buf, \"\")            = buf.append(\"java.lang.String@1e23\"\n+     * ObjectUtils.identityToString(buf, Boolean.TRUE)  = buf.append(\"java.lang.Boolean@7fa\"\n+     * ObjectUtils.identityToString(buf, Boolean.TRUE)  = buf.append(\"java.lang.Boolean@7fa\")\n+     * </pre>\n+     *\n+     * @param buffer  the buffer to append to\n+     * @param object  the object to create a toString for\n+     * @since 2.4\n+     */\n+    public static void identityToString(StringBuffer buffer, Object object) {\n+        if (object == null) {\n+            throw new NullPointerException(\"Cannot get the toString of a null identity\");\n+        }\n+        buffer.append(object.getClass().getName())\n+              .append('@')\n+              .append(Integer.toHexString(System.identityHashCode(object)));\n+    }\n+\n+    // ToString\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the <code>toString</code> of an <code>Object</code> returning\n+     * an empty string (\"\") if <code>null</code> input.</p>\n+     * \n+     * <pre>\n+     * ObjectUtils.toString(null)         = \"\"\n+     * ObjectUtils.toString(\"\")           = \"\"\n+     * ObjectUtils.toString(\"bat\")        = \"bat\"\n+     * ObjectUtils.toString(Boolean.TRUE) = \"true\"\n+     * </pre>\n+     * \n+     * @see StringUtils#defaultString(String)\n+     * @see String#valueOf(Object)\n+     * @param obj  the Object to <code>toString</code>, may be null\n+     * @return the passed in Object's toString, or nullStr if <code>null</code> input\n+     * @since 2.0\n+     */\n+    public static String toString(Object obj) {\n+        return obj == null ? \"\" : obj.toString();\n+    }\n+\n+    /**\n+     * <p>Gets the <code>toString</code> of an <code>Object</code> returning\n+     * a specified text if <code>null</code> input.</p>\n+     * \n+     * <pre>\n+     * ObjectUtils.toString(null, null)           = null\n+     * ObjectUtils.toString(null, \"null\")         = \"null\"\n+     * ObjectUtils.toString(\"\", \"null\")           = \"\"\n+     * ObjectUtils.toString(\"bat\", \"null\")        = \"bat\"\n+     * ObjectUtils.toString(Boolean.TRUE, \"null\") = \"true\"\n+     * </pre>\n+     * \n+     * @see StringUtils#defaultString(String,String)\n+     * @see String#valueOf(Object)\n+     * @param obj  the Object to <code>toString</code>, may be null\n+     * @param nullStr  the String to return if <code>null</code> input, may be null\n+     * @return the passed in Object's toString, or nullStr if <code>null</code> input\n+     * @since 2.0\n+     */\n+    public static String toString(Object obj, String nullStr) {\n+        return obj == null ? nullStr : obj.toString();\n+    }\n+\n+    // Min/Max\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Null safe comparison of Comparables.\n+     * \n+     * @param c1  the first comparable, may be null\n+     * @param c2  the second comparable, may be null\n+     * @return\n+     *  <ul>\n+     *   <li>If both objects are non-null and unequal, the lesser object.\n+     *   <li>If both objects are non-null and equal, c1.\n+     *   <li>If one of the comparables is null, the non-null object.\n+     *   <li>If both the comparables are null, null is returned.\n+     *  </ul>\n+     */\n+    public static <T extends Comparable<? super T>> T min(T c1, T c2) {\n+        if (c1 != null && c2 != null) {\n+            return c1.compareTo(c2) < 1 ? c1 : c2;\n+        } else {\n+            return c1 != null ? c1 : c2;\n+        }                              \n+    }\n+\n+    /**\n+     * Null safe comparison of Comparables.\n+     * \n+     * @param c1  the first comparable, may be null\n+     * @param c2  the second comparable, may be null\n+     * @return\n+     *  <ul>\n+     *   <li>If both objects are non-null and unequal, the greater object.\n+     *   <li>If both objects are non-null and equal, c1.\n+     *   <li>If one of the comparables is null, the non-null object.\n+     *   <li>If both the comparables are null, null is returned.\n+     *  </ul>\n+     */\n+    public static <T extends Comparable<? super T>> T max(T c1, T c2) {\n+        if (c1 != null && c2 != null) {\n+            return c1.compareTo(c2) >= 0 ? c1 : c2;\n+        } else {\n+            return c1 != null ? c1 : c2;\n+        }\n+    }\n+\n+    // Null\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Class used as a null placeholder where <code>null</code>\n+     * has another meaning.</p>\n+     *\n+     * <p>For example, in a <code>HashMap</code> the\n+     * {@link java.util.HashMap#get(java.lang.Object)} method returns\n+     * <code>null</code> if the <code>Map</code> contains\n+     * <code>null</code> or if there is no matching key. The\n+     * <code>Null</code> placeholder can be used to distinguish between\n+     * these two cases.</p>\n+     *\n+     * <p>Another example is <code>Hashtable</code>, where <code>null</code>\n+     * cannot be stored.</p>\n+     */\n+    public static class Null implements Serializable {\n+        /**\n+         * Required for serialization support. Declare serialization compatibility with Commons Lang 1.0\n+         * \n+         * @see java.io.Serializable\n+         */\n+        private static final long serialVersionUID = 7092611880189329093L;\n+        \n+        /**\n+         * Restricted constructor - singleton.\n+         */\n+        Null() {\n+            super();\n+        }\n+        \n+        /**\n+         * <p>Ensure singleton.</p>\n+         * \n+         * @return the singleton value\n+         */\n+        private Object readResolve() {\n+            return ObjectUtils.NULL;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/RandomStringUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3;\n+\n+import java.util.Random;\n+/**\n+ * <p>Operations for random <code>String</code>s.</p>\n+ * <p>Currently <em>private high surrogate</em> characters are ignored. \n+ * These are unicode characters that fall between the values 56192 (db80)\n+ * and 56319 (dbff) as we don't know how to handle them. \n+ * High and low surrogates are correctly dealt with - that is if a \n+ * high surrogate is randomly chosen, 55296 (d800) to 56191 (db7f) \n+ * then it is followed by a low surrogate. If a low surrogate is chosen, \n+ * 56320 (dc00) to 57343 (dfff) then it is placed after a randomly \n+ * chosen high surrogate. </p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author <a href=\"mailto:steven@caswell.name\">Steven Caswell</a>\n+ * @author Gary Gregory\n+ * @author Phil Steitz\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class RandomStringUtils {\n+\n+    /**\n+     * <p>Random object used by random method. This has to be not local\n+     * to the random method so as to not return the same value in the \n+     * same millisecond.</p>\n+     */\n+    private static final Random RANDOM = new Random();\n+\n+    /**\n+     * <p><code>RandomStringUtils</code> instances should NOT be constructed in\n+     * standard programming. Instead, the class should be used as\n+     * <code>RandomStringUtils.random(5);</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n+     */\n+    public RandomStringUtils() {\n+      super();\n+    }\n+\n+    // Random\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Creates a random string whose length is the number of characters\n+     * specified.</p>\n+     *\n+     * <p>Characters will be chosen from the set of all characters.</p>\n+     *\n+     * @param count  the length of random string to create\n+     * @return the random string\n+     */\n+    public static String random(int count) {\n+        return random(count, false, false);\n+    }\n+\n+    /**\n+     * <p>Creates a random string whose length is the number of characters\n+     * specified.</p>\n+     *\n+     * <p>Characters will be chosen from the set of characters whose\n+     * ASCII value is between <code>32</code> and <code>126</code> (inclusive).</p>\n+     *\n+     * @param count  the length of random string to create\n+     * @return the random string\n+     */\n+    public static String randomAscii(int count) {\n+        return random(count, 32, 127, false, false);\n+    }\n+    \n+    /**\n+     * <p>Creates a random string whose length is the number of characters\n+     * specified.</p>\n+     *\n+     * <p>Characters will be chosen from the set of alphabetic\n+     * characters.</p>\n+     *\n+     * @param count  the length of random string to create\n+     * @return the random string\n+     */\n+    public static String randomAlphabetic(int count) {\n+        return random(count, true, false);\n+    }\n+    \n+    /**\n+     * <p>Creates a random string whose length is the number of characters\n+     * specified.</p>\n+     *\n+     * <p>Characters will be chosen from the set of alpha-numeric\n+     * characters.</p>\n+     *\n+     * @param count  the length of random string to create\n+     * @return the random string\n+     */\n+    public static String randomAlphanumeric(int count) {\n+        return random(count, true, true);\n+    }\n+    \n+    /**\n+     * <p>Creates a random string whose length is the number of characters\n+     * specified.</p>\n+     *\n+     * <p>Characters will be chosen from the set of numeric\n+     * characters.</p>\n+     *\n+     * @param count  the length of random string to create\n+     * @return the random string\n+     */\n+    public static String randomNumeric(int count) {\n+        return random(count, false, true);\n+    }\n+\n+    /**\n+     * <p>Creates a random string whose length is the number of characters\n+     * specified.</p>\n+     *\n+     * <p>Characters will be chosen from the set of alpha-numeric\n+     * characters as indicated by the arguments.</p>\n+     *\n+     * @param count  the length of random string to create\n+     * @param letters  if <code>true</code>, generated string will include\n+     *  alphabetic characters\n+     * @param numbers  if <code>true</code>, generated string will include\n+     *  numeric characters\n+     * @return the random string\n+     */\n+    public static String random(int count, boolean letters, boolean numbers) {\n+        return random(count, 0, 0, letters, numbers);\n+    }\n+    \n+    /**\n+     * <p>Creates a random string whose length is the number of characters\n+     * specified.</p>\n+     *\n+     * <p>Characters will be chosen from the set of alpha-numeric\n+     * characters as indicated by the arguments.</p>\n+     *\n+     * @param count  the length of random string to create\n+     * @param start  the position in set of chars to start at\n+     * @param end  the position in set of chars to end before\n+     * @param letters  if <code>true</code>, generated string will include\n+     *  alphabetic characters\n+     * @param numbers  if <code>true</code>, generated string will include\n+     *  numeric characters\n+     * @return the random string\n+     */\n+    public static String random(int count, int start, int end, boolean letters, boolean numbers) {\n+        return random(count, start, end, letters, numbers, null, RANDOM);\n+    }\n+\n+    /**\n+     * <p>Creates a random string based on a variety of options, using\n+     * default source of randomness.</p>\n+     *\n+     * <p>This method has exactly the same semantics as\n+     * {@link #random(int,int,int,boolean,boolean,char[],Random)}, but\n+     * instead of using an externally supplied source of randomness, it uses\n+     * the internal static {@link Random} instance.</p>\n+     *\n+     * @param count  the length of random string to create\n+     * @param start  the position in set of chars to start at\n+     * @param end  the position in set of chars to end before\n+     * @param letters  only allow letters?\n+     * @param numbers  only allow numbers?\n+     * @param chars  the set of chars to choose randoms from.\n+     *  If <code>null</code>, then it will use the set of all chars.\n+     * @return the random string\n+     * @throws ArrayIndexOutOfBoundsException if there are not\n+     *  <code>(end - start) + 1</code> characters in the set array.\n+     */\n+    public static String random(int count, int start, int end, boolean letters, boolean numbers, char[] chars) {\n+        return random(count, start, end, letters, numbers, chars, RANDOM);\n+    }\n+\n+    /**\n+     * <p>Creates a random string based on a variety of options, using\n+     * supplied source of randomness.</p>\n+     *\n+     * <p>If start and end are both <code>0</code>, start and end are set\n+     * to <code>' '</code> and <code>'z'</code>, the ASCII printable\n+     * characters, will be used, unless letters and numbers are both\n+     * <code>false</code>, in which case, start and end are set to\n+     * <code>0</code> and <code>Integer.MAX_VALUE</code>.\n+     *\n+     * <p>If set is not <code>null</code>, characters between start and\n+     * end are chosen.</p>\n+     *\n+     * <p>This method accepts a user-supplied {@link Random}\n+     * instance to use as a source of randomness. By seeding a single \n+     * {@link Random} instance with a fixed seed and using it for each call,\n+     * the same random sequence of strings can be generated repeatedly\n+     * and predictably.</p>\n+     *\n+     * @param count  the length of random string to create\n+     * @param start  the position in set of chars to start at\n+     * @param end  the position in set of chars to end before\n+     * @param letters  only allow letters?\n+     * @param numbers  only allow numbers?\n+     * @param chars  the set of chars to choose randoms from.\n+     *  If <code>null</code>, then it will use the set of all chars.\n+     * @param random  a source of randomness.\n+     * @return the random string\n+     * @throws ArrayIndexOutOfBoundsException if there are not\n+     *  <code>(end - start) + 1</code> characters in the set array.\n+     * @throws IllegalArgumentException if <code>count</code> &lt; 0.\n+     * @since 2.0\n+     */\n+    public static String random(int count, int start, int end, boolean letters, boolean numbers,\n+                                char[] chars, Random random) {\n+        if (count == 0) {\n+            return \"\";\n+        } else if (count < 0) {\n+            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n+        }\n+        if ((start == 0) && (end == 0)) {\n+            end = 'z' + 1;\n+            start = ' ';\n+            if (!letters && !numbers) {\n+                start = 0;\n+                end = Integer.MAX_VALUE;\n+            }\n+        }\n+\n+        char[] buffer = new char[count];\n+        int gap = end - start;\n+\n+        while (count-- != 0) {\n+            char ch;\n+            if (chars == null) {\n+                ch = (char) (random.nextInt(gap) + start);\n+            } else {\n+                ch = chars[random.nextInt(gap) + start];\n+            }\n+            if ((letters && Character.isLetter(ch))\n+                || (numbers && Character.isDigit(ch))\n+                || (!letters && !numbers)) \n+            {\n+                if(ch >= 56320 && ch <= 57343) {\n+                    if(count == 0) {\n+                        count++;\n+                    } else {\n+                        // low surrogate, insert high surrogate after putting it in\n+                        buffer[count] = ch;\n+                        count--;\n+                        buffer[count] = (char) (55296 + random.nextInt(128));\n+                    }\n+                } else if(ch >= 55296 && ch <= 56191) {\n+                    if(count == 0) {\n+                        count++;\n+                    } else {\n+                        // high surrogate, insert low surrogate before putting it in\n+                        buffer[count] = (char) (56320 + random.nextInt(128));\n+                        count--;\n+                        buffer[count] = ch;\n+                    }\n+                } else if(ch >= 56192 && ch <= 56319) {\n+                    // private high surrogate, no effing clue, so skip it\n+                    count++;\n+                } else {\n+                    buffer[count] = ch;\n+                }\n+            } else {\n+                count++;\n+            }\n+        }\n+        return new String(buffer);\n+    }\n+\n+    /**\n+     * <p>Creates a random string whose length is the number of characters\n+     * specified.</p>\n+     *\n+     * <p>Characters will be chosen from the set of characters\n+     * specified.</p>\n+     *\n+     * @param count  the length of random string to create\n+     * @param chars  the String containing the set of characters to use,\n+     *  may be null\n+     * @return the random string\n+     * @throws IllegalArgumentException if <code>count</code> &lt; 0.\n+     */\n+    public static String random(int count, String chars) {\n+        if (chars == null) {\n+            return random(count, 0, 0, false, false, null, RANDOM);\n+        }\n+        return random(count, chars.toCharArray());\n+    }\n+\n+    /**\n+     * <p>Creates a random string whose length is the number of characters\n+     * specified.</p>\n+     *\n+     * <p>Characters will be chosen from the set of characters specified.</p>\n+     *\n+     * @param count  the length of random string to create\n+     * @param chars  the character array containing the set of characters to use,\n+     *  may be null\n+     * @return the random string\n+     * @throws IllegalArgumentException if <code>count</code> &lt; 0.\n+     */\n+    public static String random(int count, char[] chars) {\n+        if (chars == null) {\n+            return random(count, 0, 0, false, false, null, RANDOM);\n+        }\n+        return random(count, 0, chars.length, false, false, chars, RANDOM);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/Range.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3;\n+\n+import java.io.Serializable;\n+import java.util.Comparator;\n+\n+/**\n+ * <p><code>Range</code> represents a range of numbers of the same type.</p>\n+ * \n+ * @author Apache Software Foundation\n+ * @since 3.0\n+ * @version $Id: Range.java 830032 2009-10-27 00:15:00Z scolebourne $\n+ */\n+public final class Range<T> implements Serializable {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private final Comparator<T> comparator;\n+    private final T minimum;\n+    private final T maximum;\n+\n+    /**\n+     * <p>Constructs a new <code>Range</code> using the specified\n+     * element as both the minimum and maximum in this range.</p>\n+     * <p>The range uses the natural ordering of the elements to \n+     * determine where values lie in the range.</p>\n+     *\n+     * @param element  the value to use for this range, must not be <code>null</code>\n+     * @throws IllegalArgumentException if the value is <code>null</code>\n+     * @throws ClassCastException if the value is not Comparable\n+     */\n+    public static <T extends Comparable<T>> Range<T> is(T element) {\n+        return new Range<T>(element, element, ComparableComparator.<T>getInstance());\n+    }\n+\n+    /**\n+     * <p>Constructs a new <code>Range</code> with the specified\n+     * minimum and maximum values (both inclusive).</p>\n+     * <p>The range uses the natural ordering of the elements to \n+     * determine where values lie in the range.</p>\n+     *\n+     * <p>The arguments may be passed in the order (min,max) or (max,min). The\n+     * getMinimum and getMaximum methods will return the correct values.</p>\n+     *\n+     * @param element1  first value that defines the edge of the range, inclusive\n+     * @param element2  second value that defines the edge of the range, inclusive\n+     * @throws IllegalArgumentException if either value is <code>null</code>\n+     * @throws ClassCastException if either value is not Comparable\n+     */\n+    public static <T extends Comparable<T>> Range<T> between(T element1, T element2) {\n+        return new Range<T>( element1, element2, ComparableComparator.<T>getInstance());\n+    }\n+\n+    /**\n+     * <p>Constructs a new <code>Range</code> using the specified\n+     * element as both the minimum and maximum in this range.</p>\n+     * <p>The range uses the passed in <code>Comparator</code> to \n+     * determine where values lie in the range.</p>\n+     *\n+     * @param element  the value to use for this range, must not be <code>null</code>\n+     * @param c comparator to be used\n+     * @throws IllegalArgumentException if the value is <code>null</code>\n+     */\n+    public static <T> Range<T> is(T element, Comparator<T> c) {\n+        return new Range<T>(element, element, c);\n+    }\n+\n+    /**\n+     * <p>Constructs a new <code>Range</code> with the specified\n+     * minimum and maximum values (both inclusive).</p>\n+     * <p>The range uses the passed in <code>Comparator</code> to \n+     * determine where values lie in the range.</p>\n+     *\n+     * <p>The arguments may be passed in the order (min,max) or (max,min). The\n+     * getMinimum and getMaximum methods will return the correct values.</p>\n+     *\n+     * @param element1  first value that defines the edge of the range, inclusive\n+     * @param element2  second value that defines the edge of the range, inclusive\n+     * @param c comparator to be used\n+     * @throws IllegalArgumentException if either value is <code>null</code>\n+     */\n+    public static <T> Range<T> between(T element1, T element2, Comparator<T> c) {\n+        return new Range<T>(element1, element2, c);\n+    }\n+\n+    private Range(T element1, T element2, Comparator<T> c) {\n+        if(element1 == null || element2 == null) {\n+            throw new IllegalArgumentException(\"Elements in a range must not be null: element1=\" + \n+                                               element1 + \", element2=\" + element2);\n+        }\n+\n+        if(c == null) {\n+            throw new IllegalArgumentException(\"Comparator must not be null\");\n+        }\n+\n+        if(c.compare(element1, element2) < 1) {\n+            this.minimum = element1;\n+            this.maximum = element2;\n+        } else {\n+            this.minimum = element2;\n+            this.maximum = element1;\n+        }\n+        this.comparator = c;\n+    }\n+\n+    // Accessors\n+    //--------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the minimum value in this range.</p>\n+     *\n+     * @return the minimum value in this range\n+     */\n+    public T getMinimum() {\n+        return this.minimum;\n+    }\n+\n+    /**\n+     * <p>Gets the maximum value in this range.</p>\n+     *\n+     * @return the maximum value in this range\n+     */\n+    public T getMaximum() {\n+        return this.maximum;\n+    }\n+\n+    /**\n+     * <p>Gets the comparator being used to determine if objects are within the range. </p>\n+     *\n+     * @return the comparator being used\n+     */\n+    public Comparator<T> getComparator() {\n+        return this.comparator;\n+    }\n+\n+    /**\n+     * <p>Whether or not the Range is using the default natural comparison method \n+     * to compare elements. </p>\n+     *\n+     * @return whether or not the default Comparator is in use\n+     */\n+    public boolean isDefaultNaturalOrdering() {\n+        return this.comparator == ComparableComparator.INSTANCE;\n+    }\n+\n+    // Include tests\n+    //--------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Tests whether the specified element occurs within this range.</p>\n+     * \n+     * <p><code>null</code> is handled and returns <code>false</code>.</p>\n+     *\n+     * @param element  the element to test, may be <code>null</code>\n+     * @return <code>true</code> if the specified element occurs within this range\n+     */\n+    public boolean contains(T element) {\n+        if(element == null) {\n+            return false;\n+        }\n+        return (comparator.compare(element, this.minimum) > -1) && (comparator.compare(element, this.maximum) < 1);\n+    }\n+\n+    /**\n+     * <p>Tests whether the specified element occurs before this range.</p>\n+     *\n+     * <p><code>null</code> is handled and returns <code>false</code>.</p>\n+     *\n+     * @param element  the element to test, may be <code>null</code>\n+     * @return <code>true</code> if the specified element occurs before this range\n+     */\n+    public boolean elementBefore(T element) {\n+        if (element == null) {\n+            return false;\n+        }\n+        \n+        return this.comparator.compare(element, this.minimum) < 0;\n+    }\n+\n+    /**\n+     * <p>Tests whether the specified element occurs after this range.</p>\n+     *\n+     * <p><code>null</code> is handled and returns <code>false</code>.</p>\n+     *\n+     * @param element  the element to test, may be <code>null</code>\n+     * @return <code>true</code> if the specified element occurs after this range\n+     */\n+    public boolean elementAfter(T element) {\n+        if (element == null) {\n+            return false;\n+        }\n+        \n+        return this.comparator.compare(element, this.maximum) > 0;\n+    }\n+\n+    /**\n+     * <p>Tests where the specified element occurs relative to this range.</p>\n+     * <p>The API is reminiscent of the Comparable interface returning <code>-1</code> if \n+     * the element is before the range, <code>0</code> if contained within the range and \n+     * <code>1</code> if the element is after the range. </p>\n+     *\n+     * @param element  the element to test\n+     * @return -1, 0 or +1 depending on the element's location relative to the range\n+     */\n+    public int elementCompareTo(T element) {\n+        if(element == null) {\n+            // Comparable API says throw NPE on null\n+            throw new NullPointerException(\"Element is null\");\n+        }\n+        if(elementBefore(element)) {\n+            return -1;\n+        } else\n+        if(elementAfter(element)) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    // Range tests\n+    //--------------------------------------------------------------------\n+\n+    /**\n+     * <p>Tests whether the specified range occurs entirely within this range.</p>\n+     * \n+     * <p><code>null</code> is handled and returns <code>false</code>.</p>\n+     * \n+     * @param range  the range to test, may be <code>null</code>\n+     * @return <code>true</code> if the specified range occurs entirely within\n+     *  this range; otherwise, <code>false</code>\n+     * @throws IllegalArgumentException if the <code>Range</code> cannot be compared\n+     */\n+    public boolean containsRange(Range<T> range) {\n+        if (range == null) {\n+            return false;\n+        }\n+        return contains(range.getMinimum()) \n+            && contains(range.getMaximum());\n+    }\n+\n+    /**\n+     * <p>Tests whether the specified range overlaps with this range.</p>\n+     * \n+     * <p><code>null</code> is handled and returns <code>false</code>.</p>\n+     * \n+     * @param range  the range to test, may be <code>null</code>\n+     * @return <code>true</code> if the specified range overlaps with this\n+     *  range; otherwise, <code>false</code>\n+     * @throws IllegalArgumentException if the <code>Range</code> cannot be compared\n+     */\n+    public boolean overlapsRange(Range<T> range) {\n+        if (range == null) {\n+            return false;\n+        }\n+        return range.contains(this.minimum)\n+            || range.contains(this.maximum)\n+            || contains(range.getMinimum());\n+    }\n+\n+    // Basics\n+    //--------------------------------------------------------------------\n+\n+    /**\n+     * <p>Compares this range to another object to test if they are equal.</p>.\n+     * \n+     * <p>To be equal, the class, minimum and maximum must be equal.</p>\n+     * \n+     * @param obj the reference object with which to compare\n+     * @return <code>true</code> if this object is equal\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == this) {\n+            return true;\n+        } else if (obj == null || obj.getClass() != getClass()) {\n+            return false;\n+        } else {\n+            @SuppressWarnings(\"unchecked\") // OK because we checked the class above\n+            Range<T> range = (Range<T>) obj;\n+            return getMinimum().equals(range.getMinimum()) &&\n+                   getMaximum().equals(range.getMaximum());\n+        }\n+    }\n+\n+    /**\n+     * <p>Gets a hashCode for the range.</p>\n+     * \n+     * @return a hash code value for this object\n+     */\n+    @Override\n+    public int hashCode() {\n+        int result = 17;\n+        result = 37 * result + getClass().hashCode();\n+        result = 37 * result + this.minimum.hashCode();\n+        result = 37 * result + this.maximum.hashCode();\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Gets the range as a <code>String</code>.</p>\n+     *\n+     * <p>The format of the String is 'Range[<i>min</i>,<i>max</i>]'.</p>\n+     * \n+     * @return the <code>String</code> representation of this range\n+     */\n+    @Override\n+    public String toString() {\n+        StringBuilder buf = new StringBuilder(32);\n+        buf.append(\"Range[\");\n+        buf.append(this.minimum);\n+        buf.append(',');\n+        buf.append(this.maximum);\n+        buf.append(']');\n+        return buf.toString();\n+    }\n+\n+\n+    // Taken from Commons Collections - documentation removed as not a public class\n+    private static class ComparableComparator<E extends Comparable<? super E>> implements Comparator<E>, Serializable {\n+\n+        private static final long serialVersionUID = 1L;\n+\n+        @SuppressWarnings(\"unchecked\") // Comparator works for all types\n+        public static final ComparableComparator<?> INSTANCE = new ComparableComparator();\n+\n+        @SuppressWarnings(\"unchecked\") // OK to cast, because comparator works for all types\n+        public static <E extends Comparable<? super E>> ComparableComparator<E> getInstance() {\n+            return (ComparableComparator<E>) INSTANCE;\n+        }\n+\n+        public ComparableComparator() {\n+            super();\n+        }\n+\n+        public int compare(E obj1, E obj2) {\n+            return obj1.compareTo(obj2);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return \"ComparableComparator\".hashCode();\n+        }\n+\n+        @Override\n+        public boolean equals(Object object) {\n+            return (this == object) || \n+                   ((null != object) && (object.getClass().equals(this.getClass())));\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/SerializationException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3;\n+\n+/**\n+ * <p>Exception thrown when the Serialization process fails.</p>\n+ *\n+ * <p>The original error is wrapped within this one.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class SerializationException extends RuntimeException {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 4029025366392702726L;\n+\n+    /**\n+     * <p>Constructs a new <code>SerializationException</code> without specified\n+     * detail message.</p>\n+     */\n+    public SerializationException() {\n+        super();\n+    }\n+\n+    /**\n+     * <p>Constructs a new <code>SerializationException</code> with specified\n+     * detail message.</p>\n+     *\n+     * @param msg  The error message.\n+     */\n+    public SerializationException(String msg) {\n+        super(msg);\n+    }\n+\n+    /**\n+     * <p>Constructs a new <code>SerializationException</code> with specified\n+     * nested <code>Throwable</code>.</p>\n+     *\n+     * @param cause  The <code>Exception</code> or <code>Error</code>\n+     *  that caused this exception to be thrown.\n+     */\n+    public SerializationException(Throwable cause) {\n+        super(cause);\n+    }\n+\n+    /**\n+     * <p>Constructs a new <code>SerializationException</code> with specified\n+     * detail message and nested <code>Throwable</code>.</p>\n+     *\n+     * @param msg    The error message.\n+     * @param cause  The <code>Exception</code> or <code>Error</code>\n+     *  that caused this exception to be thrown.\n+     */\n+    public SerializationException(String msg, Throwable cause) {\n+        super(msg, cause);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/SerializationUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+\n+/**\n+ * <p>Assists with the serialization process and performs additional functionality based \n+ * on serialization.</p>\n+ * <p>\n+ * <ul>\n+ * <li>Deep clone using serialization\n+ * <li>Serialize managing finally and IOException\n+ * <li>Deserialize managing finally and IOException\n+ * </ul>\n+ *\n+ * <p>This class throws exceptions for invalid <code>null</code> inputs.\n+ * Each method documents its behaviour in more detail.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author <a href=\"mailto:nissim@nksystems.com\">Nissim Karpenstein</a>\n+ * @author <a href=\"mailto:janekdb@yahoo.co.uk\">Janek Bogucki</a>\n+ * @author Daniel L. Rall\n+ * @author Jeff Varszegi\n+ * @author Gary Gregory\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class SerializationUtils {\n+    \n+    /**\n+     * <p>SerializationUtils instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as <code>SerializationUtils.clone(object)</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n+     * @since 2.0\n+     */\n+    public SerializationUtils() {\n+        super();\n+    }\n+\n+    // Clone\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Deep clone an <code>Object</code> using serialization.</p>\n+     *\n+     * <p>This is many times slower than writing clone methods by hand\n+     * on all objects in your object graph. However, for complex object\n+     * graphs, or for those that don't support deep cloning this can\n+     * be a simple alternative implementation. Of course all the objects\n+     * must be <code>Serializable</code>.</p>\n+     * \n+     * @param object  the <code>Serializable</code> object to clone\n+     * @return the cloned object\n+     * @throws SerializationException (runtime) if the serialization fails\n+     */\n+    public static Object clone(Serializable object) {\n+        return deserialize(serialize(object));\n+    }\n+    \n+    // Serialize\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Serializes an <code>Object</code> to the specified stream.</p>\n+     *\n+     * <p>The stream will be closed once the object is written.\n+     * This avoids the need for a finally clause, and maybe also exception\n+     * handling, in the application code.</p>\n+     * \n+     * <p>The stream passed in is not buffered internally within this method.\n+     * This is the responsibility of your application if desired.</p>\n+     *\n+     * @param obj  the object to serialize to bytes, may be null\n+     * @param outputStream  the stream to write to, must not be null\n+     * @throws IllegalArgumentException if <code>outputStream</code> is <code>null</code>\n+     * @throws SerializationException (runtime) if the serialization fails\n+     */\n+    public static void serialize(Serializable obj, OutputStream outputStream) {\n+        if (outputStream == null) {\n+            throw new IllegalArgumentException(\"The OutputStream must not be null\");\n+        }\n+        ObjectOutputStream out = null;\n+        try {\n+            // stream closed in the finally\n+            out = new ObjectOutputStream(outputStream);\n+            out.writeObject(obj);\n+            \n+        } catch (IOException ex) {\n+            throw new SerializationException(ex);\n+        } finally {\n+            try {\n+                if (out != null) {\n+                    out.close();\n+                }\n+            } catch (IOException ex) {\n+                // ignore close exception\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Serializes an <code>Object</code> to a byte array for\n+     * storage/serialization.</p>\n+     *\n+     * @param obj  the object to serialize to bytes\n+     * @return a byte[] with the converted Serializable\n+     * @throws SerializationException (runtime) if the serialization fails\n+     */\n+    public static byte[] serialize(Serializable obj) {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream(512);\n+        serialize(obj, baos);\n+        return baos.toByteArray();\n+    }\n+\n+    // Deserialize\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Deserializes an <code>Object</code> from the specified stream.</p>\n+     *\n+     * <p>The stream will be closed once the object is written. This\n+     * avoids the need for a finally clause, and maybe also exception\n+     * handling, in the application code.</p>\n+     * \n+     * <p>The stream passed in is not buffered internally within this method.\n+     * This is the responsibility of your application if desired.</p>\n+     *\n+     * @param inputStream  the serialized object input stream, must not be null\n+     * @return the deserialized object\n+     * @throws IllegalArgumentException if <code>inputStream</code> is <code>null</code>\n+     * @throws SerializationException (runtime) if the serialization fails\n+     */\n+    public static Object deserialize(InputStream inputStream) {\n+        if (inputStream == null) {\n+            throw new IllegalArgumentException(\"The InputStream must not be null\");\n+        }\n+        ObjectInputStream in = null;\n+        try {\n+            // stream closed in the finally\n+            in = new ObjectInputStream(inputStream);\n+            return in.readObject();\n+            \n+        } catch (ClassNotFoundException ex) {\n+            throw new SerializationException(ex);\n+        } catch (IOException ex) {\n+            throw new SerializationException(ex);\n+        } finally {\n+            try {\n+                if (in != null) {\n+                    in.close();\n+                }\n+            } catch (IOException ex) {\n+                // ignore close exception\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Deserializes a single <code>Object</code> from an array of bytes.</p>\n+     *\n+     * @param objectData  the serialized object, must not be null\n+     * @return the deserialized object\n+     * @throws IllegalArgumentException if <code>objectData</code> is <code>null</code>\n+     * @throws SerializationException (runtime) if the serialization fails\n+     */\n+    public static Object deserialize(byte[] objectData) {\n+        if (objectData == null) {\n+            throw new IllegalArgumentException(\"The byte[] must not be null\");\n+        }\n+        ByteArrayInputStream bais = new ByteArrayInputStream(objectData);\n+        return deserialize(bais);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/StringEscapeUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+import org.apache.commons.lang3.text.translate.*;\n+\n+/**\n+ * <p>Escapes and unescapes <code>String</code>s for\n+ * Java, Java Script, HTML and XML.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author Apache Jakarta Turbine\n+ * @author Purple Technology\n+ * @author <a href=\"mailto:alex@purpletech.com\">Alexander Day Chaffee</a>\n+ * @author Antony Riley\n+ * @author Helge Tesgaard\n+ * @author <a href=\"sean@boohai.com\">Sean Brown</a>\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @author Phil Steitz\n+ * @author Pete Gieser\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class StringEscapeUtils {\n+\n+    /* ESCAPE TRANSLATORS */\n+\n+    public static final CharSequenceTranslator ESCAPE_JAVA = \n+          new LookupTranslator(\n+            new String[][] { \n+              {\"\\\"\", \"\\\\\\\"\"},\n+              {\"\\\\\", \"\\\\\\\\\"},\n+          }).with(\n+            new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE())\n+          ).with(\n+            UnicodeEscaper.outsideOf(32, 0x7f) \n+        );\n+\n+    public static final CharSequenceTranslator ESCAPE_ECMASCRIPT = \n+        new AggregateTranslator(\n+            new LookupTranslator(\n+                      new String[][] { \n+                            {\"'\", \"\\\\'\"},\n+                            {\"\\\"\", \"\\\\\\\"\"},\n+                            {\"\\\\\", \"\\\\\\\\\"},\n+                            {\"/\", \"\\\\/\"}\n+                      }),\n+            new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()),\n+            UnicodeEscaper.outsideOf(32, 0x7f) \n+        );\n+            \n+    public static final CharSequenceTranslator ESCAPE_XML = \n+        new AggregateTranslator(\n+            new LookupTranslator(EntityArrays.BASIC_ESCAPE()),\n+            new LookupTranslator(EntityArrays.APOS_ESCAPE())\n+        );\n+\n+    public static final CharSequenceTranslator ESCAPE_HTML3 = \n+        new AggregateTranslator(\n+            new LookupTranslator(EntityArrays.BASIC_ESCAPE()),\n+            new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE())\n+        );\n+\n+    public static final CharSequenceTranslator ESCAPE_HTML4 = \n+        new AggregateTranslator(\n+            new LookupTranslator(EntityArrays.BASIC_ESCAPE()),\n+            new LookupTranslator(EntityArrays.ISO8859_1_ESCAPE()),\n+            new LookupTranslator(EntityArrays.HTML40_EXTENDED_ESCAPE())\n+        );\n+\n+    public static final CharSequenceTranslator ESCAPE_CSV = new CsvEscaper();\n+\n+    // TODO: Create a parent class - 'SinglePassTranslator' ?\n+    // TODO: It would handle the index checking, and length returning, and \n+    // TODO: could also have an optimization check method.\n+    static class CsvEscaper extends CharSequenceTranslator {\n+\n+        private static final char CSV_DELIMITER = ',';\n+        private static final char CSV_QUOTE = '\"';\n+        private static final String CSV_QUOTE_STR = String.valueOf(CSV_QUOTE);\n+        private static final char[] CSV_SEARCH_CHARS = new char[] {CSV_DELIMITER, CSV_QUOTE, CharUtils.CR, CharUtils.LF};\n+\n+        // TODO: Replace with a RegexTranslator. That should consume the number of characters the regex uses up?\n+        @Override\n+        public int translate(CharSequence input, int index, Writer out) throws IOException {\n+\n+            if(index != 0) {\n+                throw new IllegalStateException(\"CsvEscaper should never reach the [1] index\");\n+            }\n+\n+            if (StringUtils.containsNone(input.toString(), CSV_SEARCH_CHARS)) {\n+                out.write(input.toString());\n+            } else {\n+                out.write(CSV_QUOTE);\n+                out.write(StringUtils.replace(input.toString(), CSV_QUOTE_STR, CSV_QUOTE_STR + CSV_QUOTE_STR));\n+                out.write(CSV_QUOTE);\n+            }\n+            return input.length();\n+        }\n+    }\n+\n+    /* UNESCAPE TRANSLATORS */\n+\n+    // TODO: throw \"illegal character: \\92\" as an Exception if a \\ on the end of the Java (as per the compiler)?\n+    public static final CharSequenceTranslator UNESCAPE_JAVA = \n+        new AggregateTranslator(\n+            new UnicodeUnescaper(),\n+            new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_UNESCAPE()),\n+            new LookupTranslator(\n+                      new String[][] { \n+                            {\"\\\\\\\\\", \"\\\\\"},\n+                            {\"\\\\\\\"\", \"\\\"\"},\n+                            {\"\\\\'\", \"'\"},\n+                            {\"\\\\\", \"\"}\n+                      })\n+        );\n+\n+    public static final CharSequenceTranslator UNESCAPE_ECMASCRIPT = UNESCAPE_JAVA;\n+\n+    public static final CharSequenceTranslator UNESCAPE_HTML3 = \n+        new AggregateTranslator(\n+            new LookupTranslator(EntityArrays.BASIC_UNESCAPE()),\n+            new LookupTranslator(EntityArrays.ISO8859_1_UNESCAPE()),\n+            new NumericEntityUnescaper()\n+        );\n+\n+    public static final CharSequenceTranslator UNESCAPE_HTML4 = \n+        new AggregateTranslator(\n+            new LookupTranslator(EntityArrays.BASIC_UNESCAPE()),\n+            new LookupTranslator(EntityArrays.ISO8859_1_UNESCAPE()),\n+            new LookupTranslator(EntityArrays.HTML40_EXTENDED_UNESCAPE()),\n+            new NumericEntityUnescaper()\n+        );\n+\n+    public static final CharSequenceTranslator UNESCAPE_XML = \n+        new AggregateTranslator(\n+            new LookupTranslator(EntityArrays.BASIC_UNESCAPE()),\n+            new LookupTranslator(EntityArrays.APOS_UNESCAPE()),\n+            new NumericEntityUnescaper()\n+        );\n+\n+    public static final CharSequenceTranslator UNESCAPE_CSV = new CsvUnescaper();\n+\n+    static class CsvUnescaper extends CharSequenceTranslator {\n+\n+        private static final char CSV_DELIMITER = ',';\n+        private static final char CSV_QUOTE = '\"';\n+        private static final String CSV_QUOTE_STR = String.valueOf(CSV_QUOTE);\n+        private static final char[] CSV_SEARCH_CHARS = new char[] {CSV_DELIMITER, CSV_QUOTE, CharUtils.CR, CharUtils.LF};\n+\n+        // TODO: Replace with a RegexTranslator. That should consume the number of characters the regex uses up?\n+        @Override\n+        public int translate(CharSequence input, int index, Writer out) throws IOException {\n+\n+            if(index != 0) {\n+                throw new IllegalStateException(\"CsvUnescaper should never reach the [1] index\");\n+            }\n+\n+            if ( input.charAt(0) != CSV_QUOTE || input.charAt(input.length() - 1) != CSV_QUOTE ) {\n+                out.write(input.toString());\n+                return input.length();\n+            }\n+\n+            // strip quotes\n+            String quoteless = input.subSequence(1, input.length() - 1).toString();\n+\n+            if ( StringUtils.containsAny(quoteless, CSV_SEARCH_CHARS) ) {\n+                // deal with escaped quotes; ie) \"\"\n+                out.write(StringUtils.replace(quoteless, CSV_QUOTE_STR + CSV_QUOTE_STR, CSV_QUOTE_STR));\n+            } else {\n+                out.write(input.toString());\n+            }\n+            return input.length();\n+        }\n+    }\n+\n+    /* Helper functions */\n+\n+    /**\n+     * <p><code>StringEscapeUtils</code> instances should NOT be constructed in\n+     * standard programming.</p>\n+     *\n+     * <p>Instead, the class should be used as:\n+     * <pre>StringEscapeUtils.escapeJava(\"foo\");</pre></p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean\n+     * instance to operate.</p>\n+     */\n+    public StringEscapeUtils() {\n+      super();\n+    }\n+\n+    // Java and JavaScript\n+    //--------------------------------------------------------------------------\n+    /**\n+     * <p>Escapes the characters in a <code>String</code> using Java String rules.</p>\n+     *\n+     * <p>Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n+     *\n+     * <p>So a tab becomes the characters <code>'\\\\'</code> and\n+     * <code>'t'</code>.</p>\n+     *\n+     * <p>The only difference between Java strings and JavaScript strings\n+     * is that in JavaScript, a single quote and forward-slash (/) are escaped.</p>\n+     *\n+     * <p>Example:\n+     * <pre>\n+     * input string: He didn't say, \"Stop!\"\n+     * output string: He didn't say, \\\"Stop!\\\"\n+     * </pre>\n+     * </p>\n+     *\n+     * @param input  String to escape values in, may be null\n+     * @return String with escaped values, <code>null</code> if null string input\n+     */\n+    public static final String escapeJava(String input) {\n+        return ESCAPE_JAVA.translate(input);\n+    }\n+\n+    /**\n+     * <p>Escapes the characters in a <code>String</code> using EcmaScript String rules.</p>\n+     * <p>Escapes any values it finds into their EcmaScript String form.\n+     * Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) </p>\n+     *\n+     * <p>So a tab becomes the characters <code>'\\\\'</code> and\n+     * <code>'t'</code>.</p>\n+     *\n+     * <p>The only difference between Java strings and EcmaScript strings\n+     * is that in EcmaScript, a single quote and forward-slash (/) are escaped.</p>\n+     *\n+     * <p>Note that EcmaScript is best known by the JavaScript and ActionScript dialects. </p>\n+     *\n+     * <p>Example:\n+     * <pre>\n+     * input string: He didn't say, \"Stop!\"\n+     * output string: He didn\\'t say, \\\"Stop!\\\"\n+     * </pre>\n+     * </p>\n+     *\n+     * @param input  String to escape values in, may be null\n+     * @return String with escaped values, <code>null</code> if null string input\n+     */\n+    public static final String escapeEcmaScript(String input) {\n+        return ESCAPE_ECMASCRIPT.translate(input);\n+    }\n+\n+    /**\n+     * <p>Unescapes any Java literals found in the <code>String</code>.\n+     * For example, it will turn a sequence of <code>'\\'</code> and\n+     * <code>'n'</code> into a newline character, unless the <code>'\\'</code>\n+     * is preceded by another <code>'\\'</code>.</p>\n+     * \n+     * @param input  the <code>String</code> to unescape, may be null\n+     * @return a new unescaped <code>String</code>, <code>null</code> if null string input\n+     */\n+    public static final String unescapeJava(String input) {\n+        return UNESCAPE_JAVA.translate(input);\n+    }\n+\n+    /**\n+     * <p>Unescapes any EcmaScript literals found in the <code>String</code>.</p>\n+     *\n+     * <p>For example, it will turn a sequence of <code>'\\'</code> and <code>'n'</code>\n+     * into a newline character, unless the <code>'\\'</code> is preceded by another\n+     * <code>'\\'</code>.</p>\n+     *\n+     * @see #unescapeJava(String)\n+     * @param input  the <code>String</code> to unescape, may be null\n+     * @return A new unescaped <code>String</code>, <code>null</code> if null string input\n+     */\n+    public static final String unescapeEcmaScript(String input) {\n+        return UNESCAPE_ECMASCRIPT.translate(input);\n+    }\n+\n+    // HTML and XML\n+    //--------------------------------------------------------------------------\n+    /**\n+     * <p>Escapes the characters in a <code>String</code> using HTML entities.</p>\n+     *\n+     * <p>\n+     * For example:\n+     * </p> \n+     * <p><code>\"bread\" & \"butter\"</code></p>\n+     * becomes:\n+     * <p>\n+     * <code>&amp;quot;bread&amp;quot; &amp;amp; &amp;quot;butter&amp;quot;</code>.\n+     * </p>\n+     *\n+     * <p>Supports all known HTML 4.0 entities, including funky accents.\n+     * Note that the commonly used apostrophe escape character (&amp;apos;)\n+     * is not a legal entity and so is not supported). </p>\n+     *\n+     * @param input  the <code>String</code> to escape, may be null\n+     * @return a new escaped <code>String</code>, <code>null</code> if null string input\n+     * \n+     * @see <a href=\"http://hotwired.lycos.com/webmonkey/reference/special_characters/\">ISO Entities</a>\n+     * @see <a href=\"http://www.w3.org/TR/REC-html32#latin1\">HTML 3.2 Character Entities for ISO Latin-1</a>\n+     * @see <a href=\"http://www.w3.org/TR/REC-html40/sgml/entities.html\">HTML 4.0 Character entity references</a>\n+     * @see <a href=\"http://www.w3.org/TR/html401/charset.html#h-5.3\">HTML 4.01 Character References</a>\n+     * @see <a href=\"http://www.w3.org/TR/html401/charset.html#code-position\">HTML 4.01 Code positions</a>\n+     */\n+    public static final String escapeHtml4(String input) {\n+        return ESCAPE_HTML4.translate(input);\n+    }\n+\n+    public static final String escapeHtml3(String input) {\n+        return ESCAPE_HTML3.translate(input);\n+    }\n+                \n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Unescapes a string containing entity escapes to a string\n+     * containing the actual Unicode characters corresponding to the\n+     * escapes. Supports HTML 4.0 entities.</p>\n+     *\n+     * <p>For example, the string \"&amp;lt;Fran&amp;ccedil;ais&amp;gt;\"\n+     * will become \"&lt;Fran&ccedil;ais&gt;\"</p>\n+     *\n+     * <p>If an entity is unrecognized, it is left alone, and inserted\n+     * verbatim into the result string. e.g. \"&amp;gt;&amp;zzzz;x\" will\n+     * become \"&gt;&amp;zzzz;x\".</p>\n+     *\n+     * @param input  the <code>String</code> to unescape, may be null\n+     * @return a new unescaped <code>String</code>, <code>null</code> if null string input\n+     */\n+    public static final String unescapeHtml4(String input) {\n+        return UNESCAPE_HTML4.translate(input);\n+    }\n+\n+    public static final String unescapeHtml3(String input) {\n+        return UNESCAPE_HTML3.translate(input);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Escapes the characters in a <code>String</code> using XML entities.</p>\n+     *\n+     * <p>For example: <tt>\"bread\" & \"butter\"</tt> =>\n+     * <tt>&amp;quot;bread&amp;quot; &amp;amp; &amp;quot;butter&amp;quot;</tt>.\n+     * </p>\n+     *\n+     * <p>Supports only the five basic XML entities (gt, lt, quot, amp, apos).\n+     * Does not support DTDs or external entities.</p>\n+     *\n+     * <p>Note that unicode characters greater than 0x7f are as of 3.0, no longer \n+     *    escaped. </p>\n+     *\n+     * @param input  the <code>String</code> to escape, may be null\n+     * @return a new escaped <code>String</code>, <code>null</code> if null string input\n+     * @see #unescapeXml(java.lang.String)\n+     */\n+    public static final String escapeXml(String input) {\n+        return ESCAPE_XML.translate(input);\n+    }\n+                \n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Unescapes a string containing XML entity escapes to a string\n+     * containing the actual Unicode characters corresponding to the\n+     * escapes.</p>\n+     *\n+     * <p>Supports only the five basic XML entities (gt, lt, quot, amp, apos).\n+     * Does not support DTDs or external entities.</p>\n+     *\n+     * <p>Note that numerical \\\\u unicode codes are unescaped to their respective \n+     *    unicode characters. This may change in future releases. </p>\n+     *\n+     * @param input  the <code>String</code> to unescape, may be null\n+     * @return a new unescaped <code>String</code>, <code>null</code> if null string input\n+     * @see #escapeXml(String)\n+     */\n+    public static final String unescapeXml(String input) {\n+        return UNESCAPE_XML.translate(input);\n+    }\n+                \n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * <p>Returns a <code>String</code> value for a CSV column enclosed in double quotes,\n+     * if required.</p>\n+     *\n+     * <p>If the value contains a comma, newline or double quote, then the\n+     *    String value is returned enclosed in double quotes.</p>\n+     * </p>\n+     *\n+     * <p>Any double quote characters in the value are escaped with another double quote.</p>\n+     *\n+     * <p>If the value does not contain a comma, newline or double quote, then the\n+     *    String value is returned unchanged.</p>\n+     * </p>\n+     *\n+     * see <a href=\"http://en.wikipedia.org/wiki/Comma-separated_values\">Wikipedia</a> and\n+     * <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n+     *\n+     * @param input the input CSV column String, may be null\n+     * @return the input String, enclosed in double quotes if the value contains a comma,\n+     * newline or double quote, <code>null</code> if null string input\n+     * @since 2.4\n+     */\n+    public static final String escapeCsv(String input) {\n+        return ESCAPE_CSV.translate(input);\n+    }\n+\n+    /**\n+     * <p>Returns a <code>String</code> value for an unescaped CSV column. </p>\n+     *\n+     * <p>If the value is enclosed in double quotes, and contains a comma, newline \n+     *    or double quote, then quotes are removed. \n+     * </p>\n+     *\n+     * <p>Any double quote escaped characters (a pair of double quotes) are unescaped \n+     *    to just one double quote. </p>\n+     *\n+     * <p>If the value is not enclosed in double quotes, or is and does not contain a \n+     *    comma, newline or double quote, then the String value is returned unchanged.</p>\n+     * </p>\n+     *\n+     * see <a href=\"http://en.wikipedia.org/wiki/Comma-separated_values\">Wikipedia</a> and\n+     * <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n+     *\n+     * @param input the input CSV column String, may be null\n+     * @return the input String, with enclosing double quotes removed and embedded double \n+     * quotes unescaped, <code>null</code> if null string input\n+     * @since 2.4\n+     */\n+    public static final String unescapeCsv(String input) {\n+        return UNESCAPE_CSV.translate(input);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+\n+/**\n+ * <p>Operations on {@link java.lang.String} that are\n+ * <code>null</code> safe.</p>\n+ *\n+ * <ul>\n+ *  <li><b>IsEmpty/IsBlank</b>\n+ *      - checks if a String contains text</li>\n+ *  <li><b>Trim/Strip</b>\n+ *      - removes leading and trailing whitespace</li>\n+ *  <li><b>Equals</b>\n+ *      - compares two strings null-safe</li>\n+ *  <li><b>startsWith</b>\n+ *      - check if a String starts with a prefix null-safe</li>\n+ *  <li><b>endsWith</b>\n+ *      - check if a String ends with a suffix null-safe</li>\n+ *  <li><b>IndexOf/LastIndexOf/Contains</b>\n+ *      - null-safe index-of checks\n+ *  <li><b>IndexOfAny/LastIndexOfAny/IndexOfAnyBut/LastIndexOfAnyBut</b>\n+ *      - index-of any of a set of Strings</li>\n+ *  <li><b>ContainsOnly/ContainsNone/ContainsAny</b>\n+ *      - does String contains only/none/any of these characters</li>\n+ *  <li><b>Substring/Left/Right/Mid</b>\n+ *      - null-safe substring extractions</li>\n+ *  <li><b>SubstringBefore/SubstringAfter/SubstringBetween</b>\n+ *      - substring extraction relative to other strings</li>\n+ *  <li><b>Split/Join</b>\n+ *      - splits a String into an array of substrings and vice versa</li>\n+ *  <li><b>Remove/Delete</b>\n+ *      - removes part of a String</li>\n+ *  <li><b>Replace/Overlay</b>\n+ *      - Searches a String and replaces one String with another</li>\n+ *  <li><b>Chomp/Chop</b>\n+ *      - removes the last part of a String</li>\n+ *  <li><b>LeftPad/RightPad/Center/Repeat</b>\n+ *      - pads a String</li>\n+ *  <li><b>UpperCase/LowerCase/SwapCase/Capitalize/Uncapitalize</b>\n+ *      - changes the case of a String</li>\n+ *  <li><b>CountMatches</b>\n+ *      - counts the number of occurrences of one String in another</li>\n+ *  <li><b>IsAlpha/IsNumeric/IsWhitespace/IsAsciiPrintable</b>\n+ *      - checks the characters in a String</li>\n+ *  <li><b>DefaultString</b>\n+ *      - protects against a null input String</li>\n+ *  <li><b>Reverse/ReverseDelimited</b>\n+ *      - reverses a String</li>\n+ *  <li><b>Abbreviate</b>\n+ *      - abbreviates a string using ellipsis</li>\n+ *  <li><b>Difference</b>\n+ *      - compares Strings and reports on their differences</li>\n+ *  <li><b>LevensteinDistance</b>\n+ *      - the number of changes needed to change one String into another</li>\n+ * </ul>\n+ *\n+ * <p>The <code>StringUtils</code> class defines certain words related to\n+ * String handling.</p>\n+ *\n+ * <ul>\n+ *  <li>null - <code>null</code></li>\n+ *  <li>empty - a zero-length string (<code>\"\"</code>)</li>\n+ *  <li>space - the space character (<code>' '</code>, char 32)</li>\n+ *  <li>whitespace - the characters defined by {@link Character#isWhitespace(char)}</li>\n+ *  <li>trim - the characters &lt;= 32 as in {@link String#trim()}</li>\n+ * </ul>\n+ *\n+ * <p><code>StringUtils</code> handles <code>null</code> input Strings quietly.\n+ * That is to say that a <code>null</code> input will return <code>null</code>.\n+ * Where a <code>boolean</code> or <code>int</code> is being returned\n+ * details vary by method.</p>\n+ *\n+ * <p>A side effect of the <code>null</code> handling is that a\n+ * <code>NullPointerException</code> should be considered a bug in\n+ * <code>StringUtils</code>.</p>\n+ *\n+ * <p>Methods in this class give sample code to explain their operation.\n+ * The symbol <code>*</code> is used to indicate any input including <code>null</code>.</p>\n+ *\n+ * @see java.lang.String\n+ * @author Apache Software Foundation\n+ * @author <a href=\"http://jakarta.apache.org/turbine/\">Apache Jakarta Turbine</a>\n+ * @author <a href=\"mailto:jon@latchkey.com\">Jon S. Stevens</a>\n+ * @author Daniel L. Rall\n+ * @author <a href=\"mailto:gcoladonato@yahoo.com\">Greg Coladonato</a>\n+ * @author <a href=\"mailto:ed@apache.org\">Ed Korthof</a>\n+ * @author <a href=\"mailto:rand_mcneely@yahoo.com\">Rand McNeely</a>\n+ * @author <a href=\"mailto:fredrik@westermarck.com\">Fredrik Westermarck</a>\n+ * @author Holger Krauth\n+ * @author <a href=\"mailto:alex@purpletech.com\">Alexander Day Chaffee</a>\n+ * @author <a href=\"mailto:hps@intermeta.de\">Henning P. Schmiedehausen</a>\n+ * @author Arun Mammen Thomas\n+ * @author Gary Gregory\n+ * @author Phil Steitz\n+ * @author Al Chou\n+ * @author Michael Davey\n+ * @author Reuben Sivan\n+ * @author Chris Hyzer\n+ * @author Scott Johnson\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+//@Immutable\n+public class StringUtils {\n+    // Performance testing notes (JDK 1.4, Jul03, scolebourne)\n+    // Whitespace:\n+    // Character.isWhitespace() is faster than WHITESPACE.indexOf()\n+    // where WHITESPACE is a string of all whitespace characters\n+    //\n+    // Character access:\n+    // String.charAt(n) versus toCharArray(), then array[n]\n+    // String.charAt(n) is about 15% worse for a 10K string\n+    // They are about equal for a length 50 string\n+    // String.charAt(n) is about 4 times better for a length 3 string\n+    // String.charAt(n) is best bet overall\n+    //\n+    // Append:\n+    // String.concat about twice as fast as StringBuffer.append\n+    // (not sure who tested this)\n+\n+    /**\n+     * The empty String <code>\"\"</code>.\n+     * @since 2.0\n+     */\n+    public static final String EMPTY = \"\";\n+\n+    /**\n+     * Represents a failed index search.\n+     * @since 2.1\n+     */\n+    public static final int INDEX_NOT_FOUND = -1;\n+\n+    /**\n+     * <p>The maximum size to which the padding constant(s) can expand.</p>\n+     */\n+    private static final int PAD_LIMIT = 8192;\n+\n+    /**\n+     * <p><code>StringUtils</code> instances should NOT be constructed in\n+     * standard programming. Instead, the class should be used as\n+     * <code>StringUtils.trim(\" foo \");</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean\n+     * instance to operate.</p>\n+     */\n+    public StringUtils() {\n+        super();\n+    }\n+\n+    // Empty checks\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if a String is empty (\"\") or null.</p>\n+     *\n+     * <pre>\n+     * StringUtils.isEmpty(null)      = true\n+     * StringUtils.isEmpty(\"\")        = true\n+     * StringUtils.isEmpty(\" \")       = false\n+     * StringUtils.isEmpty(\"bob\")     = false\n+     * StringUtils.isEmpty(\"  bob  \") = false\n+     * </pre>\n+     *\n+     * <p>NOTE: This method changed in Lang version 2.0.\n+     * It no longer trims the String.\n+     * That functionality is available in isBlank().</p>\n+     *\n+     * @param str  the String to check, may be null\n+     * @return <code>true</code> if the String is empty or null\n+     */\n+    public static boolean isEmpty(CharSequence str) {\n+        return str == null || str.length() == 0;\n+    }\n+\n+    /**\n+     * <p>Checks if a String is not empty (\"\") and not null.</p>\n+     *\n+     * <pre>\n+     * StringUtils.isNotEmpty(null)      = false\n+     * StringUtils.isNotEmpty(\"\")        = false\n+     * StringUtils.isNotEmpty(\" \")       = true\n+     * StringUtils.isNotEmpty(\"bob\")     = true\n+     * StringUtils.isNotEmpty(\"  bob  \") = true\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @return <code>true</code> if the String is not empty and not null\n+     */\n+    public static boolean isNotEmpty(CharSequence str) {\n+        return !StringUtils.isEmpty(str);\n+    }\n+\n+    /**\n+     * <p>Checks if a String is whitespace, empty (\"\") or null.</p>\n+     *\n+     * <pre>\n+     * StringUtils.isBlank(null)      = true\n+     * StringUtils.isBlank(\"\")        = true\n+     * StringUtils.isBlank(\" \")       = true\n+     * StringUtils.isBlank(\"bob\")     = false\n+     * StringUtils.isBlank(\"  bob  \") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @return <code>true</code> if the String is null, empty or whitespace\n+     * @since 2.0\n+     */\n+    public static boolean isBlank(CharSequence str) {\n+        int strLen;\n+        if (str == null || (strLen = str.length()) == 0) {\n+            return true;\n+        }\n+        for (int i = 0; i < strLen; i++) {\n+            if ((Character.isWhitespace(str.charAt(i)) == false)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks if a String is not empty (\"\"), not null and not whitespace only.</p>\n+     *\n+     * <pre>\n+     * StringUtils.isNotBlank(null)      = false\n+     * StringUtils.isNotBlank(\"\")        = false\n+     * StringUtils.isNotBlank(\" \")       = false\n+     * StringUtils.isNotBlank(\"bob\")     = true\n+     * StringUtils.isNotBlank(\"  bob  \") = true\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @return <code>true</code> if the String is\n+     *  not empty and not null and not whitespace\n+     * @since 2.0\n+     */\n+    public static boolean isNotBlank(CharSequence str) {\n+        return !StringUtils.isBlank(str);\n+    }\n+\n+    // Trim\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Removes control characters (char &lt;= 32) from both\n+     * ends of this String, handling <code>null</code> by returning\n+     * <code>null</code>.</p>\n+     *\n+     * <p>The String is trimmed using {@link String#trim()}.\n+     * Trim removes start and end characters &lt;= 32.\n+     * To strip whitespace use {@link #strip(String)}.</p>\n+     *\n+     * <p>To trim your choice of characters, use the\n+     * {@link #strip(String, String)} methods.</p>\n+     *\n+     * <pre>\n+     * StringUtils.trim(null)          = null\n+     * StringUtils.trim(\"\")            = \"\"\n+     * StringUtils.trim(\"     \")       = \"\"\n+     * StringUtils.trim(\"abc\")         = \"abc\"\n+     * StringUtils.trim(\"    abc    \") = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String to be trimmed, may be null\n+     * @return the trimmed string, <code>null</code> if null String input\n+     */\n+    public static String trim(String str) {\n+        return str == null ? null : str.trim();\n+    }\n+\n+    /**\n+     * <p>Removes control characters (char &lt;= 32) from both\n+     * ends of this String returning <code>null</code> if the String is\n+     * empty (\"\") after the trim or if it is <code>null</code>.\n+     *\n+     * <p>The String is trimmed using {@link String#trim()}.\n+     * Trim removes start and end characters &lt;= 32.\n+     * To strip whitespace use {@link #stripToNull(String)}.</p>\n+     *\n+     * <pre>\n+     * StringUtils.trimToNull(null)          = null\n+     * StringUtils.trimToNull(\"\")            = null\n+     * StringUtils.trimToNull(\"     \")       = null\n+     * StringUtils.trimToNull(\"abc\")         = \"abc\"\n+     * StringUtils.trimToNull(\"    abc    \") = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String to be trimmed, may be null\n+     * @return the trimmed String,\n+     *  <code>null</code> if only chars &lt;= 32, empty or null String input\n+     * @since 2.0\n+     */\n+    public static String trimToNull(String str) {\n+        String ts = trim(str);\n+        return isEmpty(ts) ? null : ts;\n+    }\n+\n+    /**\n+     * <p>Removes control characters (char &lt;= 32) from both\n+     * ends of this String returning an empty String (\"\") if the String\n+     * is empty (\"\") after the trim or if it is <code>null</code>.\n+     *\n+     * <p>The String is trimmed using {@link String#trim()}.\n+     * Trim removes start and end characters &lt;= 32.\n+     * To strip whitespace use {@link #stripToEmpty(String)}.</p>\n+     *\n+     * <pre>\n+     * StringUtils.trimToEmpty(null)          = \"\"\n+     * StringUtils.trimToEmpty(\"\")            = \"\"\n+     * StringUtils.trimToEmpty(\"     \")       = \"\"\n+     * StringUtils.trimToEmpty(\"abc\")         = \"abc\"\n+     * StringUtils.trimToEmpty(\"    abc    \") = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String to be trimmed, may be null\n+     * @return the trimmed String, or an empty String if <code>null</code> input\n+     * @since 2.0\n+     */\n+    public static String trimToEmpty(String str) {\n+        return str == null ? EMPTY : str.trim();\n+    }\n+\n+    // Stripping\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Strips whitespace from the start and end of a String.</p>\n+     *\n+     * <p>This is similar to {@link #trim(String)} but removes whitespace.\n+     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.strip(null)     = null\n+     * StringUtils.strip(\"\")       = \"\"\n+     * StringUtils.strip(\"   \")    = \"\"\n+     * StringUtils.strip(\"abc\")    = \"abc\"\n+     * StringUtils.strip(\"  abc\")  = \"abc\"\n+     * StringUtils.strip(\"abc  \")  = \"abc\"\n+     * StringUtils.strip(\" abc \")  = \"abc\"\n+     * StringUtils.strip(\" ab c \") = \"ab c\"\n+     * </pre>\n+     *\n+     * @param str  the String to remove whitespace from, may be null\n+     * @return the stripped String, <code>null</code> if null String input\n+     */\n+    public static String strip(String str) {\n+        return strip(str, null);\n+    }\n+\n+    /**\n+     * <p>Strips whitespace from the start and end of a String  returning\n+     * <code>null</code> if the String is empty (\"\") after the strip.</p>\n+     *\n+     * <p>This is similar to {@link #trimToNull(String)} but removes whitespace.\n+     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n+     *\n+     * <pre>\n+     * StringUtils.stripToNull(null)     = null\n+     * StringUtils.stripToNull(\"\")       = null\n+     * StringUtils.stripToNull(\"   \")    = null\n+     * StringUtils.stripToNull(\"abc\")    = \"abc\"\n+     * StringUtils.stripToNull(\"  abc\")  = \"abc\"\n+     * StringUtils.stripToNull(\"abc  \")  = \"abc\"\n+     * StringUtils.stripToNull(\" abc \")  = \"abc\"\n+     * StringUtils.stripToNull(\" ab c \") = \"ab c\"\n+     * </pre>\n+     *\n+     * @param str  the String to be stripped, may be null\n+     * @return the stripped String,\n+     *  <code>null</code> if whitespace, empty or null String input\n+     * @since 2.0\n+     */\n+    public static String stripToNull(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        str = strip(str, null);\n+        return str.length() == 0 ? null : str;\n+    }\n+\n+    /**\n+     * <p>Strips whitespace from the start and end of a String  returning\n+     * an empty String if <code>null</code> input.</p>\n+     *\n+     * <p>This is similar to {@link #trimToEmpty(String)} but removes whitespace.\n+     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n+     *\n+     * <pre>\n+     * StringUtils.stripToEmpty(null)     = \"\"\n+     * StringUtils.stripToEmpty(\"\")       = \"\"\n+     * StringUtils.stripToEmpty(\"   \")    = \"\"\n+     * StringUtils.stripToEmpty(\"abc\")    = \"abc\"\n+     * StringUtils.stripToEmpty(\"  abc\")  = \"abc\"\n+     * StringUtils.stripToEmpty(\"abc  \")  = \"abc\"\n+     * StringUtils.stripToEmpty(\" abc \")  = \"abc\"\n+     * StringUtils.stripToEmpty(\" ab c \") = \"ab c\"\n+     * </pre>\n+     *\n+     * @param str  the String to be stripped, may be null\n+     * @return the trimmed String, or an empty String if <code>null</code> input\n+     * @since 2.0\n+     */\n+    public static String stripToEmpty(String str) {\n+        return str == null ? EMPTY : strip(str, null);\n+    }\n+\n+    /**\n+     * <p>Strips any of a set of characters from the start and end of a String.\n+     * This is similar to {@link String#trim()} but allows the characters\n+     * to be stripped to be controlled.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * An empty string (\"\") input returns the empty string.</p>\n+     *\n+     * <p>If the stripChars String is <code>null</code>, whitespace is\n+     * stripped as defined by {@link Character#isWhitespace(char)}.\n+     * Alternatively use {@link #strip(String)}.</p>\n+     *\n+     * <pre>\n+     * StringUtils.strip(null, *)          = null\n+     * StringUtils.strip(\"\", *)            = \"\"\n+     * StringUtils.strip(\"abc\", null)      = \"abc\"\n+     * StringUtils.strip(\"  abc\", null)    = \"abc\"\n+     * StringUtils.strip(\"abc  \", null)    = \"abc\"\n+     * StringUtils.strip(\" abc \", null)    = \"abc\"\n+     * StringUtils.strip(\"  abcyx\", \"xyz\") = \"  abc\"\n+     * </pre>\n+     *\n+     * @param str  the String to remove characters from, may be null\n+     * @param stripChars  the characters to remove, null treated as whitespace\n+     * @return the stripped String, <code>null</code> if null String input\n+     */\n+    public static String strip(String str, String stripChars) {\n+        if (isEmpty(str)) {\n+            return str;\n+        }\n+        str = stripStart(str, stripChars);\n+        return stripEnd(str, stripChars);\n+    }\n+\n+    /**\n+     * <p>Strips any of a set of characters from the start of a String.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * An empty string (\"\") input returns the empty string.</p>\n+     *\n+     * <p>If the stripChars String is <code>null</code>, whitespace is\n+     * stripped as defined by {@link Character#isWhitespace(char)}.</p>\n+     *\n+     * <pre>\n+     * StringUtils.stripStart(null, *)          = null\n+     * StringUtils.stripStart(\"\", *)            = \"\"\n+     * StringUtils.stripStart(\"abc\", \"\")        = \"abc\"\n+     * StringUtils.stripStart(\"abc\", null)      = \"abc\"\n+     * StringUtils.stripStart(\"  abc\", null)    = \"abc\"\n+     * StringUtils.stripStart(\"abc  \", null)    = \"abc  \"\n+     * StringUtils.stripStart(\" abc \", null)    = \"abc \"\n+     * StringUtils.stripStart(\"yxabc  \", \"xyz\") = \"abc  \"\n+     * </pre>\n+     *\n+     * @param str  the String to remove characters from, may be null\n+     * @param stripChars  the characters to remove, null treated as whitespace\n+     * @return the stripped String, <code>null</code> if null String input\n+     */\n+    public static String stripStart(String str, String stripChars) {\n+        int strLen;\n+        if (str == null || (strLen = str.length()) == 0) {\n+            return str;\n+        }\n+        int start = 0;\n+        if (stripChars == null) {\n+            while ((start != strLen) && Character.isWhitespace(str.charAt(start))) {\n+                start++;\n+            }\n+        } else if (stripChars.length() == 0) {\n+            return str;\n+        } else {\n+            while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != -1)) {\n+                start++;\n+            }\n+        }\n+        return str.substring(start);\n+    }\n+\n+    /**\n+     * <p>Strips any of a set of characters from the end of a String.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * An empty string (\"\") input returns the empty string.</p>\n+     *\n+     * <p>If the stripChars String is <code>null</code>, whitespace is\n+     * stripped as defined by {@link Character#isWhitespace(char)}.</p>\n+     *\n+     * <pre>\n+     * StringUtils.stripEnd(null, *)          = null\n+     * StringUtils.stripEnd(\"\", *)            = \"\"\n+     * StringUtils.stripEnd(\"abc\", \"\")        = \"abc\"\n+     * StringUtils.stripEnd(\"abc\", null)      = \"abc\"\n+     * StringUtils.stripEnd(\"  abc\", null)    = \"  abc\"\n+     * StringUtils.stripEnd(\"abc  \", null)    = \"abc\"\n+     * StringUtils.stripEnd(\" abc \", null)    = \" abc\"\n+     * StringUtils.stripEnd(\"  abcyx\", \"xyz\") = \"  abc\"\n+     * </pre>\n+     *\n+     * @param str  the String to remove characters from, may be null\n+     * @param stripChars  the characters to remove, null treated as whitespace\n+     * @return the stripped String, <code>null</code> if null String input\n+     */\n+    public static String stripEnd(String str, String stripChars) {\n+        int end;\n+        if (str == null || (end = str.length()) == 0) {\n+            return str;\n+        }\n+\n+        if (stripChars == null) {\n+            while ((end != 0) && Character.isWhitespace(str.charAt(end - 1))) {\n+                end--;\n+            }\n+        } else if (stripChars.length() == 0) {\n+            return str;\n+        } else {\n+            while ((end != 0) && (stripChars.indexOf(str.charAt(end - 1)) != -1)) {\n+                end--;\n+            }\n+        }\n+        return str.substring(0, end);\n+    }\n+\n+    // StripAll\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Strips whitespace from the start and end of every String in an array.\n+     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n+     *\n+     * <p>A new array is returned each time, except for length zero.\n+     * A <code>null</code> array will return <code>null</code>.\n+     * An empty array will return itself.\n+     * A <code>null</code> array entry will be ignored.</p>\n+     *\n+     * <pre>\n+     * StringUtils.stripAll(null)             = null\n+     * StringUtils.stripAll([])               = []\n+     * StringUtils.stripAll([\"abc\", \"  abc\"]) = [\"abc\", \"abc\"]\n+     * StringUtils.stripAll([\"abc  \", null])  = [\"abc\", null]\n+     * </pre>\n+     *\n+     * @param strs  the array to remove whitespace from, may be null\n+     * @return the stripped Strings, <code>null</code> if null array input\n+     */\n+    public static String[] stripAll(String[] strs) {\n+        return stripAll(strs, null);\n+    }\n+\n+    /**\n+     * <p>Strips any of a set of characters from the start and end of every\n+     * String in an array.</p>\n+     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n+     *\n+     * <p>A new array is returned each time, except for length zero.\n+     * A <code>null</code> array will return <code>null</code>.\n+     * An empty array will return itself.\n+     * A <code>null</code> array entry will be ignored.\n+     * A <code>null</code> stripChars will strip whitespace as defined by\n+     * {@link Character#isWhitespace(char)}.</p>\n+     *\n+     * <pre>\n+     * StringUtils.stripAll(null, *)                = null\n+     * StringUtils.stripAll([], *)                  = []\n+     * StringUtils.stripAll([\"abc\", \"  abc\"], null) = [\"abc\", \"abc\"]\n+     * StringUtils.stripAll([\"abc  \", null], null)  = [\"abc\", null]\n+     * StringUtils.stripAll([\"abc  \", null], \"yz\")  = [\"abc  \", null]\n+     * StringUtils.stripAll([\"yabcz\", null], \"yz\")  = [\"abc\", null]\n+     * </pre>\n+     *\n+     * @param strs  the array to remove characters from, may be null\n+     * @param stripChars  the characters to remove, null treated as whitespace\n+     * @return the stripped Strings, <code>null</code> if null array input\n+     */\n+    public static String[] stripAll(String[] strs, String stripChars) {\n+        int strsLen;\n+        if (strs == null || (strsLen = strs.length) == 0) {\n+            return strs;\n+        }\n+        String[] newArr = new String[strsLen];\n+        for (int i = 0; i < strsLen; i++) {\n+            newArr[i] = strip(strs[i], stripChars);\n+        }\n+        return newArr;\n+    }\n+\n+    /**\n+     * <p>Removes the accents from a string. </p>\n+     * <p>NOTE: This is a JDK 1.6 method, it will fail on JDK 1.5. </p>\n+     *\n+     * <pre>\n+     * StringUtils.stripAccents(null)                = null\n+     * StringUtils.stripAccents(\"\")                  = \"\"\n+     * StringUtils.stripAccents(\"control\")           = \"control\"\n+     * StringUtils.stripAccents(\"&ecute;clair\")      = \"eclair\"\n+     * </pre>\n+     * \n+     * @param input String to be stripped\n+     * @return String without accents on the text\n+     *\n+     * @since 3.0\n+     */\n+    public static String stripAccents(String input) {\n+        if(input == null) {\n+            return null;\n+        }\n+        if(SystemUtils.isJavaVersionAtLeast(1.6f)) {\n+\n+            // String decomposed = Normalizer.normalize(input, Normalizer.Form.NFD);\n+\n+            // START of 1.5 reflection - in 1.6 use the line commented out above\n+            try {\n+                // get java.text.Normalizer.Form class\n+                Class<?> normalizerFormClass = ClassUtils.getClass(\"java.text.Normalizer$Form\", false);\n+\n+                // get Normlizer class\n+                Class<?> normalizerClass = ClassUtils.getClass(\"java.text.Normalizer\", false);\n+\n+                // get static method on Normalizer\n+                java.lang.reflect.Method method = normalizerClass.getMethod(\"normalize\", CharSequence.class, normalizerFormClass );\n+\n+                // get Normalizer.NFD field\n+                java.lang.reflect.Field nfd = normalizerFormClass.getField(\"NFD\");\n+\n+                // invoke method\n+                String decomposed = (String) method.invoke( null, input, nfd.get(null) );\n+                // END of 1.5 reflection\n+\n+                java.util.regex.Pattern accentPattern = java.util.regex.Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\");\n+                return accentPattern.matcher(decomposed).replaceAll(\"\");\n+            } catch(ClassNotFoundException cnfe) {\n+                throw new RuntimeException(\"ClassNotFoundException occurred during 1.6 backcompat code\", cnfe);\n+            } catch(NoSuchMethodException nsme) {\n+                throw new RuntimeException(\"NoSuchMethodException occurred during 1.6 backcompat code\", nsme);\n+            } catch(NoSuchFieldException nsfe) {\n+                throw new RuntimeException(\"NoSuchFieldException occurred during 1.6 backcompat code\", nsfe);\n+            } catch(IllegalAccessException iae) {\n+                throw new RuntimeException(\"IllegalAccessException occurred during 1.6 backcompat code\", iae);\n+            } catch(IllegalArgumentException iae) {\n+                throw new RuntimeException(\"IllegalArgumentException occurred during 1.6 backcompat code\", iae);\n+            } catch(java.lang.reflect.InvocationTargetException ite) {\n+                throw new RuntimeException(\"InvocationTargetException occurred during 1.6 backcompat code\", ite);\n+            } catch(SecurityException se) {\n+                throw new RuntimeException(\"SecurityException occurred during 1.6 backcompat code\", se);\n+            }\n+        } else {\n+            throw new UnsupportedOperationException(\"The stripAccents(String) method is not supported until Java 1.6\");\n+        }\n+    }\n+\n+    // Equals\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Compares two Strings, returning <code>true</code> if they are equal.</p>\n+     *\n+     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n+     * references are considered to be equal. The comparison is case sensitive.</p>\n+     *\n+     * <pre>\n+     * StringUtils.equals(null, null)   = true\n+     * StringUtils.equals(null, \"abc\")  = false\n+     * StringUtils.equals(\"abc\", null)  = false\n+     * StringUtils.equals(\"abc\", \"abc\") = true\n+     * StringUtils.equals(\"abc\", \"ABC\") = false\n+     * </pre>\n+     *\n+     * @see java.lang.String#equals(Object)\n+     * @param str1  the first String, may be null\n+     * @param str2  the second String, may be null\n+     * @return <code>true</code> if the Strings are equal, case sensitive, or\n+     *  both <code>null</code>\n+     */\n+    public static boolean equals(String str1, String str2) {\n+        return str1 == null ? str2 == null : str1.equals(str2);\n+    }\n+\n+    /**\n+     * <p>Compares two Strings, returning <code>true</code> if they are equal ignoring\n+     * the case.</p>\n+     *\n+     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n+     * references are considered equal. Comparison is case insensitive.</p>\n+     *\n+     * <pre>\n+     * StringUtils.equalsIgnoreCase(null, null)   = true\n+     * StringUtils.equalsIgnoreCase(null, \"abc\")  = false\n+     * StringUtils.equalsIgnoreCase(\"abc\", null)  = false\n+     * StringUtils.equalsIgnoreCase(\"abc\", \"abc\") = true\n+     * StringUtils.equalsIgnoreCase(\"abc\", \"ABC\") = true\n+     * </pre>\n+     *\n+     * @see java.lang.String#equalsIgnoreCase(String)\n+     * @param str1  the first String, may be null\n+     * @param str2  the second String, may be null\n+     * @return <code>true</code> if the Strings are equal, case insensitive, or\n+     *  both <code>null</code>\n+     */\n+    public static boolean equalsIgnoreCase(String str1, String str2) {\n+        return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);\n+    }\n+\n+    // IndexOf\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Finds the first index within a String, handling <code>null</code>.\n+     * This method uses {@link String#indexOf(int)}.</p>\n+     *\n+     * <p>A <code>null</code> or empty (\"\") String will return <code>-1</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.indexOf(null, *)         = -1\n+     * StringUtils.indexOf(\"\", *)           = -1\n+     * StringUtils.indexOf(\"aabaabaa\", 'a') = 0\n+     * StringUtils.indexOf(\"aabaabaa\", 'b') = 2\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchChar  the character to find\n+     * @return the first index of the search character,\n+     *  -1 if no match or <code>null</code> string input\n+     * @since 2.0\n+     */\n+    public static int indexOf(String str, char searchChar) {\n+        if (isEmpty(str)) {\n+            return -1;\n+        }\n+        return str.indexOf(searchChar);\n+    }\n+\n+    /**\n+     * <p>Finds the first index within a String from a start position,\n+     * handling <code>null</code>.\n+     * This method uses {@link String#indexOf(int, int)}.</p>\n+     *\n+     * <p>A <code>null</code> or empty (\"\") String will return <code>-1</code>.\n+     * A negative start position is treated as zero.\n+     * A start position greater than the string length returns <code>-1</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.indexOf(null, *, *)          = -1\n+     * StringUtils.indexOf(\"\", *, *)            = -1\n+     * StringUtils.indexOf(\"aabaabaa\", 'b', 0)  = 2\n+     * StringUtils.indexOf(\"aabaabaa\", 'b', 3)  = 5\n+     * StringUtils.indexOf(\"aabaabaa\", 'b', 9)  = -1\n+     * StringUtils.indexOf(\"aabaabaa\", 'b', -1) = 2\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchChar  the character to find\n+     * @param startPos  the start position, negative treated as zero\n+     * @return the first index of the search character,\n+     *  -1 if no match or <code>null</code> string input\n+     * @since 2.0\n+     */\n+    public static int indexOf(String str, char searchChar, int startPos) {\n+        if (isEmpty(str)) {\n+            return -1;\n+        }\n+        return str.indexOf(searchChar, startPos);\n+    }\n+\n+    /**\n+     * <p>Finds the first index within a String, handling <code>null</code>.\n+     * This method uses {@link String#indexOf(String)}.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.indexOf(null, *)          = -1\n+     * StringUtils.indexOf(*, null)          = -1\n+     * StringUtils.indexOf(\"\", \"\")           = 0\n+     * StringUtils.indexOf(\"aabaabaa\", \"a\")  = 0\n+     * StringUtils.indexOf(\"aabaabaa\", \"b\")  = 2\n+     * StringUtils.indexOf(\"aabaabaa\", \"ab\") = 1\n+     * StringUtils.indexOf(\"aabaabaa\", \"\")   = 0\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchStr  the String to find, may be null\n+     * @return the first index of the search String,\n+     *  -1 if no match or <code>null</code> string input\n+     * @since 2.0\n+     */\n+    public static int indexOf(String str, String searchStr) {\n+        if (str == null || searchStr == null) {\n+            return -1;\n+        }\n+        return str.indexOf(searchStr);\n+    }\n+\n+    /**\n+     * <p>Finds the n-th index within a String, handling <code>null</code>.\n+     * This method uses {@link String#indexOf(String)}.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.ordinalIndexOf(null, *, *)          = -1\n+     * StringUtils.ordinalIndexOf(*, null, *)          = -1\n+     * StringUtils.ordinalIndexOf(\"\", \"\", *)           = 0\n+     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"a\", 1)  = 0\n+     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"a\", 2)  = 1\n+     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", 1)  = 2\n+     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", 2)  = 5\n+     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", 1) = 1\n+     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", 2) = 4\n+     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", 1)   = 0\n+     * StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", 2)   = 0\n+     * </pre>\n+     *\n+     * <p>Note that 'head(String str, int n)' may be implemented as: </p>\n+     *\n+     * <pre>\n+     *   str.substring(0, lastOrdinalIndexOf(str, \"\\n\", n))\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchStr  the String to find, may be null\n+     * @param ordinal  the n-th <code>searchStr</code> to find\n+     * @return the n-th index of the search String,\n+     *  <code>-1</code> (<code>INDEX_NOT_FOUND</code>) if no match or <code>null</code> string input\n+     * @since 2.1\n+     */\n+    public static int ordinalIndexOf(String str, String searchStr, int ordinal) {\n+        return ordinalIndexOf(str, searchStr, ordinal, false);\n+    }\n+\n+    // Shared code between ordinalIndexOf(String,String,int) and lastOrdinalIndexOf(String,String,int)\n+    private static int ordinalIndexOf(String str, String searchStr, int ordinal, boolean lastIndex) {\n+        if (str == null || searchStr == null || ordinal <= 0) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        if (searchStr.length() == 0) {\n+            return lastIndex ? str.length() : 0;\n+        }\n+        int found = 0;\n+        int index = lastIndex ? str.length() : INDEX_NOT_FOUND;\n+        do {\n+            if(lastIndex) {\n+                index = str.lastIndexOf(searchStr, index - 1);\n+            } else {\n+                index = str.indexOf(searchStr, index + 1);\n+            }\n+            if (index < 0) {\n+                return index;\n+            }\n+            found++;\n+        } while (found < ordinal);\n+        return index;\n+    }\n+\n+    /**\n+     * <p>Finds the first index within a String, handling <code>null</code>.\n+     * This method uses {@link String#indexOf(String, int)}.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.\n+     * A negative start position is treated as zero.\n+     * An empty (\"\") search String always matches.\n+     * A start position greater than the string length only matches\n+     * an empty search String.</p>\n+     *\n+     * <pre>\n+     * StringUtils.indexOf(null, *, *)          = -1\n+     * StringUtils.indexOf(*, null, *)          = -1\n+     * StringUtils.indexOf(\"\", \"\", 0)           = 0\n+     * StringUtils.indexOf(\"aabaabaa\", \"a\", 0)  = 0\n+     * StringUtils.indexOf(\"aabaabaa\", \"b\", 0)  = 2\n+     * StringUtils.indexOf(\"aabaabaa\", \"ab\", 0) = 1\n+     * StringUtils.indexOf(\"aabaabaa\", \"b\", 3)  = 5\n+     * StringUtils.indexOf(\"aabaabaa\", \"b\", 9)  = -1\n+     * StringUtils.indexOf(\"aabaabaa\", \"b\", -1) = 2\n+     * StringUtils.indexOf(\"aabaabaa\", \"\", 2)   = 2\n+     * StringUtils.indexOf(\"abc\", \"\", 9)        = 3\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchStr  the String to find, may be null\n+     * @param startPos  the start position, negative treated as zero\n+     * @return the first index of the search String,\n+     *  -1 if no match or <code>null</code> string input\n+     * @since 2.0\n+     */\n+    public static int indexOf(String str, String searchStr, int startPos) {\n+        if (str == null || searchStr == null) {\n+            return -1;\n+        }\n+        // JDK1.2/JDK1.3 have a bug, when startPos > str.length for \"\", hence\n+        if (searchStr.length() == 0 && startPos >= str.length()) {\n+            return str.length();\n+        }\n+        return str.indexOf(searchStr, startPos);\n+    }\n+\n+    /**\n+     * <p>Case in-sensitive find of the first index within a String.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.\n+     * A negative start position is treated as zero.\n+     * An empty (\"\") search String always matches.\n+     * A start position greater than the string length only matches\n+     * an empty search String.</p>\n+     *\n+     * <pre>\n+     * StringUtils.indexOfIgnoreCase(null, *)          = -1\n+     * StringUtils.indexOfIgnoreCase(*, null)          = -1\n+     * StringUtils.indexOfIgnoreCase(\"\", \"\")           = 0\n+     * StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"a\")  = 0\n+     * StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"b\")  = 2\n+     * StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"ab\") = 1\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchStr  the String to find, may be null\n+     * @return the first index of the search String,\n+     *  -1 if no match or <code>null</code> string input\n+     * @since 3.0\n+     */\n+    public static int indexOfIgnoreCase(String str, String searchStr) {\n+        return indexOfIgnoreCase(str, searchStr, 0);\n+    }\n+\n+    /**\n+     * <p>Case in-sensitive find of the first index within a String\n+     * from the specified position.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.\n+     * A negative start position is treated as zero.\n+     * An empty (\"\") search String always matches.\n+     * A start position greater than the string length only matches\n+     * an empty search String.</p>\n+     *\n+     * <pre>\n+     * StringUtils.indexOfIgnoreCase(null, *, *)          = -1\n+     * StringUtils.indexOfIgnoreCase(*, null, *)          = -1\n+     * StringUtils.indexOfIgnoreCase(\"\", \"\", 0)           = 0\n+     * StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"A\", 0)  = 0\n+     * StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"B\", 0)  = 2\n+     * StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"AB\", 0) = 1\n+     * StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"B\", 3)  = 5\n+     * StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"B\", 9)  = -1\n+     * StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"B\", -1) = 2\n+     * StringUtils.indexOfIgnoreCase(\"aabaabaa\", \"\", 2)   = 2\n+     * StringUtils.indexOfIgnoreCase(\"abc\", \"\", 9)        = 3\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchStr  the String to find, may be null\n+     * @param startPos  the start position, negative treated as zero\n+     * @return the first index of the search String,\n+     *  -1 if no match or <code>null</code> string input\n+     * @since 3.0\n+     */\n+    public static int indexOfIgnoreCase(String str, String searchStr, int startPos) {\n+        if (str == null || searchStr == null) {\n+            return -1;\n+        }\n+        if (startPos < 0) {\n+            startPos = 0;\n+        }\n+        int endLimit = (str.length() - searchStr.length()) + 1;\n+        if (startPos > endLimit) {\n+            return -1;\n+        }\n+        if (searchStr.length() == 0) {\n+            return startPos;\n+        }\n+        for (int i = startPos; i < endLimit; i++) {\n+            if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    // LastIndexOf\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Finds the last index within a String, handling <code>null</code>.\n+     * This method uses {@link String#lastIndexOf(int)}.</p>\n+     *\n+     * <p>A <code>null</code> or empty (\"\") String will return <code>-1</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.lastIndexOf(null, *)         = -1\n+     * StringUtils.lastIndexOf(\"\", *)           = -1\n+     * StringUtils.lastIndexOf(\"aabaabaa\", 'a') = 7\n+     * StringUtils.lastIndexOf(\"aabaabaa\", 'b') = 5\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchChar  the character to find\n+     * @return the last index of the search character,\n+     *  -1 if no match or <code>null</code> string input\n+     * @since 2.0\n+     */\n+    public static int lastIndexOf(String str, char searchChar) {\n+        if (isEmpty(str)) {\n+            return -1;\n+        }\n+        return str.lastIndexOf(searchChar);\n+    }\n+\n+    /**\n+     * <p>Finds the last index within a String from a start position,\n+     * handling <code>null</code>.\n+     * This method uses {@link String#lastIndexOf(int, int)}.</p>\n+     *\n+     * <p>A <code>null</code> or empty (\"\") String will return <code>-1</code>.\n+     * A negative start position returns <code>-1</code>.\n+     * A start position greater than the string length searches the whole string.</p>\n+     *\n+     * <pre>\n+     * StringUtils.lastIndexOf(null, *, *)          = -1\n+     * StringUtils.lastIndexOf(\"\", *,  *)           = -1\n+     * StringUtils.lastIndexOf(\"aabaabaa\", 'b', 8)  = 5\n+     * StringUtils.lastIndexOf(\"aabaabaa\", 'b', 4)  = 2\n+     * StringUtils.lastIndexOf(\"aabaabaa\", 'b', 0)  = -1\n+     * StringUtils.lastIndexOf(\"aabaabaa\", 'b', 9)  = 5\n+     * StringUtils.lastIndexOf(\"aabaabaa\", 'b', -1) = -1\n+     * StringUtils.lastIndexOf(\"aabaabaa\", 'a', 0)  = 0\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchChar  the character to find\n+     * @param startPos  the start position\n+     * @return the last index of the search character,\n+     *  -1 if no match or <code>null</code> string input\n+     * @since 2.0\n+     */\n+    public static int lastIndexOf(String str, char searchChar, int startPos) {\n+        if (isEmpty(str)) {\n+            return -1;\n+        }\n+        return str.lastIndexOf(searchChar, startPos);\n+    }\n+\n+    /**\n+     * <p>Finds the last index within a String, handling <code>null</code>.\n+     * This method uses {@link String#lastIndexOf(String)}.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.lastIndexOf(null, *)          = -1\n+     * StringUtils.lastIndexOf(*, null)          = -1\n+     * StringUtils.lastIndexOf(\"\", \"\")           = 0\n+     * StringUtils.lastIndexOf(\"aabaabaa\", \"a\")  = 0\n+     * StringUtils.lastIndexOf(\"aabaabaa\", \"b\")  = 2\n+     * StringUtils.lastIndexOf(\"aabaabaa\", \"ab\") = 1\n+     * StringUtils.lastIndexOf(\"aabaabaa\", \"\")   = 8\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchStr  the String to find, may be null\n+     * @return the last index of the search String,\n+     *  -1 if no match or <code>null</code> string input\n+     * @since 2.0\n+     */\n+    public static int lastIndexOf(String str, String searchStr) {\n+        if (str == null || searchStr == null) {\n+            return -1;\n+        }\n+        return str.lastIndexOf(searchStr);\n+    }\n+\n+    /**\n+     * <p>Finds the n-th last index within a String, handling <code>null</code>.\n+     * This method uses {@link String#lastIndexOf(String)}.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.lastOrdinalIndexOf(null, *, *)          = -1\n+     * StringUtils.lastOrdinalIndexOf(*, null, *)          = -1\n+     * StringUtils.lastOrdinalIndexOf(\"\", \"\", *)           = 0\n+     * StringUtils.lastOrdinalIndexOf(\"aabaabaa\", \"a\", 1)  = 7\n+     * StringUtils.lastOrdinalIndexOf(\"aabaabaa\", \"a\", 2)  = 6\n+     * StringUtils.lastOrdinalIndexOf(\"aabaabaa\", \"b\", 1)  = 5\n+     * StringUtils.lastOrdinalIndexOf(\"aabaabaa\", \"b\", 2)  = 2\n+     * StringUtils.lastOrdinalIndexOf(\"aabaabaa\", \"ab\", 1) = 4\n+     * StringUtils.lastOrdinalIndexOf(\"aabaabaa\", \"ab\", 2) = 1\n+     * StringUtils.lastOrdinalIndexOf(\"aabaabaa\", \"\", 1)   = 8\n+     * StringUtils.lastOrdinalIndexOf(\"aabaabaa\", \"\", 2)   = 8\n+     * </pre>\n+     *\n+     * <p>Note that 'tail(String str, int n)' may be implemented as: </p>\n+     *\n+     * <pre>\n+     *   str.substring(lastOrdinalIndexOf(str, \"\\n\", n) + 1)\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchStr  the String to find, may be null\n+     * @param ordinal  the n-th last <code>searchStr</code> to find\n+     * @return the n-th last index of the search String,\n+     *  <code>-1</code> (<code>INDEX_NOT_FOUND</code>) if no match or <code>null</code> string input\n+     * @since 3.0\n+     */\n+    public static int lastOrdinalIndexOf(String str, String searchStr, int ordinal) {\n+        return ordinalIndexOf(str, searchStr, ordinal, true);\n+    }\n+\n+    /**\n+     * <p>Finds the first index within a String, handling <code>null</code>.\n+     * This method uses {@link String#lastIndexOf(String, int)}.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.\n+     * A negative start position returns <code>-1</code>.\n+     * An empty (\"\") search String always matches unless the start position is negative.\n+     * A start position greater than the string length searches the whole string.</p>\n+     *\n+     * <pre>\n+     * StringUtils.lastIndexOf(null, *, *)          = -1\n+     * StringUtils.lastIndexOf(*, null, *)          = -1\n+     * StringUtils.lastIndexOf(\"aabaabaa\", \"a\", 8)  = 7\n+     * StringUtils.lastIndexOf(\"aabaabaa\", \"b\", 8)  = 5\n+     * StringUtils.lastIndexOf(\"aabaabaa\", \"ab\", 8) = 4\n+     * StringUtils.lastIndexOf(\"aabaabaa\", \"b\", 9)  = 5\n+     * StringUtils.lastIndexOf(\"aabaabaa\", \"b\", -1) = -1\n+     * StringUtils.lastIndexOf(\"aabaabaa\", \"a\", 0)  = 0\n+     * StringUtils.lastIndexOf(\"aabaabaa\", \"b\", 0)  = -1\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchStr  the String to find, may be null\n+     * @param startPos  the start position, negative treated as zero\n+     * @return the first index of the search String,\n+     *  -1 if no match or <code>null</code> string input\n+     * @since 2.0\n+     */\n+    public static int lastIndexOf(String str, String searchStr, int startPos) {\n+        if (str == null || searchStr == null) {\n+            return -1;\n+        }\n+        return str.lastIndexOf(searchStr, startPos);\n+    }\n+\n+    /**\n+     * <p>Case in-sensitive find of the last index within a String.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.\n+     * A negative start position returns <code>-1</code>.\n+     * An empty (\"\") search String always matches unless the start position is negative.\n+     * A start position greater than the string length searches the whole string.</p>\n+     *\n+     * <pre>\n+     * StringUtils.lastIndexOfIgnoreCase(null, *)          = -1\n+     * StringUtils.lastIndexOfIgnoreCase(*, null)          = -1\n+     * StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"A\")  = 7\n+     * StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"B\")  = 5\n+     * StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"AB\") = 4\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchStr  the String to find, may be null\n+     * @return the first index of the search String,\n+     *  -1 if no match or <code>null</code> string input\n+     * @since 3.0\n+     */\n+    public static int lastIndexOfIgnoreCase(String str, String searchStr) {\n+        if (str == null || searchStr == null) {\n+            return -1;\n+        }\n+        return lastIndexOfIgnoreCase(str, searchStr, str.length());\n+    }\n+\n+    /**\n+     * <p>Case in-sensitive find of the last index within a String\n+     * from the specified position.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.\n+     * A negative start position returns <code>-1</code>.\n+     * An empty (\"\") search String always matches unless the start position is negative.\n+     * A start position greater than the string length searches the whole string.</p>\n+     *\n+     * <pre>\n+     * StringUtils.lastIndexOfIgnoreCase(null, *, *)          = -1\n+     * StringUtils.lastIndexOfIgnoreCase(*, null, *)          = -1\n+     * StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"A\", 8)  = 7\n+     * StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"B\", 8)  = 5\n+     * StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"AB\", 8) = 4\n+     * StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"B\", 9)  = 5\n+     * StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"B\", -1) = -1\n+     * StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"A\", 0)  = 0\n+     * StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"B\", 0)  = -1\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchStr  the String to find, may be null\n+     * @param startPos  the start position\n+     * @return the first index of the search String,\n+     *  -1 if no match or <code>null</code> string input\n+     * @since 3.0\n+     */\n+    public static int lastIndexOfIgnoreCase(String str, String searchStr, int startPos) {\n+        if (str == null || searchStr == null) {\n+            return -1;\n+        }\n+        if (startPos > (str.length() - searchStr.length())) {\n+            startPos = str.length() - searchStr.length();\n+        }\n+        if (startPos < 0) {\n+            return -1;\n+        }\n+        if (searchStr.length() == 0) {\n+            return startPos;\n+        }\n+\n+        for (int i = startPos; i >= 0; i--) {\n+            if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    // Contains\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if String contains a search character, handling <code>null</code>.\n+     * This method uses {@link String#indexOf(int)}.</p>\n+     *\n+     * <p>A <code>null</code> or empty (\"\") String will return <code>false</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.contains(null, *)    = false\n+     * StringUtils.contains(\"\", *)      = false\n+     * StringUtils.contains(\"abc\", 'a') = true\n+     * StringUtils.contains(\"abc\", 'z') = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchChar  the character to find\n+     * @return true if the String contains the search character,\n+     *  false if not or <code>null</code> string input\n+     * @since 2.0\n+     */\n+    public static boolean contains(String str, char searchChar) {\n+        if (isEmpty(str)) {\n+            return false;\n+        }\n+        return str.indexOf(searchChar) >= 0;\n+    }\n+\n+    /**\n+     * <p>Checks if String contains a search String, handling <code>null</code>.\n+     * This method uses {@link String#indexOf(String)}.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>false</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.contains(null, *)     = false\n+     * StringUtils.contains(*, null)     = false\n+     * StringUtils.contains(\"\", \"\")      = true\n+     * StringUtils.contains(\"abc\", \"\")   = true\n+     * StringUtils.contains(\"abc\", \"a\")  = true\n+     * StringUtils.contains(\"abc\", \"z\")  = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchStr  the String to find, may be null\n+     * @return true if the String contains the search String,\n+     *  false if not or <code>null</code> string input\n+     * @since 2.0\n+     */\n+    public static boolean contains(String str, String searchStr) {\n+        if (str == null || searchStr == null) {\n+            return false;\n+        }\n+        return str.indexOf(searchStr) >= 0;\n+    }\n+\n+    /**\n+     * <p>Checks if String contains a search String irrespective of case,\n+     * handling <code>null</code>. Case-insensitivity is defined as by\n+     * {@link String#equalsIgnoreCase(String)}.\n+     *\n+     * <p>A <code>null</code> String will return <code>false</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.contains(null, *) = false\n+     * StringUtils.contains(*, null) = false\n+     * StringUtils.contains(\"\", \"\") = true\n+     * StringUtils.contains(\"abc\", \"\") = true\n+     * StringUtils.contains(\"abc\", \"a\") = true\n+     * StringUtils.contains(\"abc\", \"z\") = false\n+     * StringUtils.contains(\"abc\", \"A\") = true\n+     * StringUtils.contains(\"abc\", \"Z\") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchStr  the String to find, may be null\n+     * @return true if the String contains the search String irrespective of\n+     * case or false if not or <code>null</code> string input\n+     */\n+    public static boolean containsIgnoreCase(String str, String searchStr) {\n+        if (str == null || searchStr == null) {\n+            return false;\n+        }\n+        int len = searchStr.length();\n+        int max = str.length() - len;\n+        for (int i = 0; i <= max; i++) {\n+            if (str.regionMatches(true, i, searchStr, 0, len)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    // IndexOfAny chars\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Search a String to find the first index of any\n+     * character in the given set of characters.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.\n+     * A <code>null</code> or zero length search array will return <code>-1</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.indexOfAny(null, *)                = -1\n+     * StringUtils.indexOfAny(\"\", *)                  = -1\n+     * StringUtils.indexOfAny(*, null)                = -1\n+     * StringUtils.indexOfAny(*, [])                  = -1\n+     * StringUtils.indexOfAny(\"zzabyycdxx\",['z','a']) = 0\n+     * StringUtils.indexOfAny(\"zzabyycdxx\",['b','y']) = 3\n+     * StringUtils.indexOfAny(\"aba\", ['z'])           = -1\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchChars  the chars to search for, may be null\n+     * @return the index of any of the chars, -1 if no match or null input\n+     * @since 2.0\n+     */\n+    public static int indexOfAny(String str, char[] searchChars) {\n+        if (isEmpty(str) || ArrayUtils.isEmpty(searchChars)) {\n+            return -1;\n+        }\n+        for (int i = 0; i < str.length(); i++) {\n+            char ch = str.charAt(i);\n+            for (int j = 0; j < searchChars.length; j++) {\n+                if (searchChars[j] == ch) {\n+                    return i;\n+                }\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * <p>Search a String to find the first index of any\n+     * character in the given set of characters.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.\n+     * A <code>null</code> search string will return <code>-1</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.indexOfAny(null, *)            = -1\n+     * StringUtils.indexOfAny(\"\", *)              = -1\n+     * StringUtils.indexOfAny(*, null)            = -1\n+     * StringUtils.indexOfAny(*, \"\")              = -1\n+     * StringUtils.indexOfAny(\"zzabyycdxx\", \"za\") = 0\n+     * StringUtils.indexOfAny(\"zzabyycdxx\", \"by\") = 3\n+     * StringUtils.indexOfAny(\"aba\",\"z\")          = -1\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchChars  the chars to search for, may be null\n+     * @return the index of any of the chars, -1 if no match or null input\n+     * @since 2.0\n+     */\n+    public static int indexOfAny(String str, String searchChars) {\n+        if (isEmpty(str) || isEmpty(searchChars)) {\n+            return -1;\n+        }\n+        return indexOfAny(str, searchChars.toCharArray());\n+    }\n+\n+    // ContainsAny\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if the String contains any character in the given\n+     * set of characters.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>false</code>.\n+     * A <code>null</code> or zero length search array will return <code>false</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.containsAny(null, *)                = false\n+     * StringUtils.containsAny(\"\", *)                  = false\n+     * StringUtils.containsAny(*, null)                = false\n+     * StringUtils.containsAny(*, [])                  = false\n+     * StringUtils.containsAny(\"zzabyycdxx\",['z','a']) = true\n+     * StringUtils.containsAny(\"zzabyycdxx\",['b','y']) = true\n+     * StringUtils.containsAny(\"aba\", ['z'])           = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchChars  the chars to search for, may be null\n+     * @return the <code>true</code> if any of the chars are found,\n+     * <code>false</code> if no match or null input\n+     * @since 2.4\n+     */\n+    public static boolean containsAny(String str, char[] searchChars) {\n+        if (str == null || str.length() == 0 || searchChars == null || searchChars.length == 0) {\n+            return false;\n+        }\n+        for (int i = 0; i < str.length(); i++) {\n+            char ch = str.charAt(i);\n+            for (int j = 0; j < searchChars.length; j++) {\n+                if (searchChars[j] == ch) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * <p>\n+     * Checks if the String contains any character in the given set of characters.\n+     * </p>\n+     * \n+     * <p>\n+     * A <code>null</code> String will return <code>false</code>. A <code>null</code> search string will return\n+     * <code>false</code>.\n+     * </p>\n+     * \n+     * <pre>\n+     * StringUtils.containsAny(null, *)            = false\n+     * StringUtils.containsAny(\"\", *)              = false\n+     * StringUtils.containsAny(*, null)            = false\n+     * StringUtils.containsAny(*, \"\")              = false\n+     * StringUtils.containsAny(\"zzabyycdxx\", \"za\") = true\n+     * StringUtils.containsAny(\"zzabyycdxx\", \"by\") = true\n+     * StringUtils.containsAny(\"aba\",\"z\")          = false\n+     * </pre>\n+     * \n+     * @param str\n+     *            the String to check, may be null\n+     * @param searchChars\n+     *            the chars to search for, may be null\n+     * @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input\n+     * @since 2.4\n+     */\n+    public static boolean containsAny(String str, String searchChars) {\n+        if (searchChars == null) {\n+            return false;\n+        }\n+        return containsAny(str, searchChars.toCharArray());\n+    }\n+\n+    // IndexOfAnyBut chars\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Search a String to find the first index of any\n+     * character not in the given set of characters.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.\n+     * A <code>null</code> or zero length search array will return <code>-1</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.indexOfAnyBut(null, *)           = -1\n+     * StringUtils.indexOfAnyBut(\"\", *)             = -1\n+     * StringUtils.indexOfAnyBut(*, null)           = -1\n+     * StringUtils.indexOfAnyBut(*, [])             = -1\n+     * StringUtils.indexOfAnyBut(\"zzabyycdxx\",'za') = 3\n+     * StringUtils.indexOfAnyBut(\"zzabyycdxx\", '')  = 0\n+     * StringUtils.indexOfAnyBut(\"aba\", 'ab')       = -1\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchChars  the chars to search for, may be null\n+     * @return the index of any of the chars, -1 if no match or null input\n+     * @since 2.0\n+     */\n+    public static int indexOfAnyBut(String str, char[] searchChars) {\n+        if (isEmpty(str) || ArrayUtils.isEmpty(searchChars)) {\n+            return -1;\n+        }\n+        outer : for (int i = 0; i < str.length(); i++) {\n+            char ch = str.charAt(i);\n+            for (int j = 0; j < searchChars.length; j++) {\n+                if (searchChars[j] == ch) {\n+                    continue outer;\n+                }\n+            }\n+            return i;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * <p>Search a String to find the first index of any\n+     * character not in the given set of characters.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.\n+     * A <code>null</code> search string will return <code>-1</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.indexOfAnyBut(null, *)            = -1\n+     * StringUtils.indexOfAnyBut(\"\", *)              = -1\n+     * StringUtils.indexOfAnyBut(*, null)            = -1\n+     * StringUtils.indexOfAnyBut(*, \"\")              = -1\n+     * StringUtils.indexOfAnyBut(\"zzabyycdxx\", \"za\") = 3\n+     * StringUtils.indexOfAnyBut(\"zzabyycdxx\", \"\")   = 0\n+     * StringUtils.indexOfAnyBut(\"aba\",\"ab\")         = -1\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchChars  the chars to search for, may be null\n+     * @return the index of any of the chars, -1 if no match or null input\n+     * @since 2.0\n+     */\n+    public static int indexOfAnyBut(String str, String searchChars) {\n+        if (isEmpty(str) || isEmpty(searchChars)) {\n+            return -1;\n+        }\n+        for (int i = 0; i < str.length(); i++) {\n+            if (searchChars.indexOf(str.charAt(i)) < 0) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    // ContainsOnly\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if the String contains only certain characters.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>false</code>.\n+     * A <code>null</code> valid character array will return <code>false</code>.\n+     * An empty String (\"\") always returns <code>true</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.containsOnly(null, *)       = false\n+     * StringUtils.containsOnly(*, null)       = false\n+     * StringUtils.containsOnly(\"\", *)         = true\n+     * StringUtils.containsOnly(\"ab\", '')      = false\n+     * StringUtils.containsOnly(\"abab\", 'abc') = true\n+     * StringUtils.containsOnly(\"ab1\", 'abc')  = false\n+     * StringUtils.containsOnly(\"abz\", 'abc')  = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param valid  an array of valid chars, may be null\n+     * @return true if it only contains valid chars and is non-null\n+     */\n+    public static boolean containsOnly(String str, char[] valid) {\n+        // All these pre-checks are to maintain API with an older version\n+        if ((valid == null) || (str == null)) {\n+            return false;\n+        }\n+        if (str.length() == 0) {\n+            return true;\n+        }\n+        if (valid.length == 0) {\n+            return false;\n+        }\n+        return indexOfAnyBut(str, valid) == -1;\n+    }\n+\n+    /**\n+     * <p>Checks if the String contains only certain characters.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>false</code>.\n+     * A <code>null</code> valid character String will return <code>false</code>.\n+     * An empty String (\"\") always returns <code>true</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.containsOnly(null, *)       = false\n+     * StringUtils.containsOnly(*, null)       = false\n+     * StringUtils.containsOnly(\"\", *)         = true\n+     * StringUtils.containsOnly(\"ab\", \"\")      = false\n+     * StringUtils.containsOnly(\"abab\", \"abc\") = true\n+     * StringUtils.containsOnly(\"ab1\", \"abc\")  = false\n+     * StringUtils.containsOnly(\"abz\", \"abc\")  = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param validChars  a String of valid chars, may be null\n+     * @return true if it only contains valid chars and is non-null\n+     * @since 2.0\n+     */\n+    public static boolean containsOnly(String str, String validChars) {\n+        if (str == null || validChars == null) {\n+            return false;\n+        }\n+        return containsOnly(str, validChars.toCharArray());\n+    }\n+\n+    // ContainsNone\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks that the String does not contain certain characters.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>true</code>.\n+     * A <code>null</code> invalid character array will return <code>true</code>.\n+     * An empty String (\"\") always returns true.</p>\n+     *\n+     * <pre>\n+     * StringUtils.containsNone(null, *)       = true\n+     * StringUtils.containsNone(*, null)       = true\n+     * StringUtils.containsNone(\"\", *)         = true\n+     * StringUtils.containsNone(\"ab\", '')      = true\n+     * StringUtils.containsNone(\"abab\", 'xyz') = true\n+     * StringUtils.containsNone(\"ab1\", 'xyz')  = true\n+     * StringUtils.containsNone(\"abz\", 'xyz')  = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param invalidChars  an array of invalid chars, may be null\n+     * @return true if it contains none of the invalid chars, or is null\n+     * @since 2.0\n+     */\n+    public static boolean containsNone(String str, char[] invalidChars) {\n+        if (str == null || invalidChars == null) {\n+            return true;\n+        }\n+        int strSize = str.length();\n+        int validSize = invalidChars.length;\n+        for (int i = 0; i < strSize; i++) {\n+            char ch = str.charAt(i);\n+            for (int j = 0; j < validSize; j++) {\n+                if (invalidChars[j] == ch) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks that the String does not contain certain characters.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>true</code>.\n+     * A <code>null</code> invalid character array will return <code>true</code>.\n+     * An empty String (\"\") always returns true.</p>\n+     *\n+     * <pre>\n+     * StringUtils.containsNone(null, *)       = true\n+     * StringUtils.containsNone(*, null)       = true\n+     * StringUtils.containsNone(\"\", *)         = true\n+     * StringUtils.containsNone(\"ab\", \"\")      = true\n+     * StringUtils.containsNone(\"abab\", \"xyz\") = true\n+     * StringUtils.containsNone(\"ab1\", \"xyz\")  = true\n+     * StringUtils.containsNone(\"abz\", \"xyz\")  = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param invalidChars  a String of invalid chars, may be null\n+     * @return true if it contains none of the invalid chars, or is null\n+     * @since 2.0\n+     */\n+    public static boolean containsNone(String str, String invalidChars) {\n+        if (str == null || invalidChars == null) {\n+            return true;\n+        }\n+        return containsNone(str, invalidChars.toCharArray());\n+    }\n+\n+    // IndexOfAny strings\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Find the first index of any of a set of potential substrings.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.\n+     * A <code>null</code> or zero length search array will return <code>-1</code>.\n+     * A <code>null</code> search array entry will be ignored, but a search\n+     * array containing \"\" will return <code>0</code> if <code>str</code> is not\n+     * null. This method uses {@link String#indexOf(String)}.</p>\n+     *\n+     * <pre>\n+     * StringUtils.indexOfAny(null, *)                     = -1\n+     * StringUtils.indexOfAny(*, null)                     = -1\n+     * StringUtils.indexOfAny(*, [])                       = -1\n+     * StringUtils.indexOfAny(\"zzabyycdxx\", [\"ab\",\"cd\"])   = 2\n+     * StringUtils.indexOfAny(\"zzabyycdxx\", [\"cd\",\"ab\"])   = 2\n+     * StringUtils.indexOfAny(\"zzabyycdxx\", [\"mn\",\"op\"])   = -1\n+     * StringUtils.indexOfAny(\"zzabyycdxx\", [\"zab\",\"aby\"]) = 1\n+     * StringUtils.indexOfAny(\"zzabyycdxx\", [\"\"])          = 0\n+     * StringUtils.indexOfAny(\"\", [\"\"])                    = 0\n+     * StringUtils.indexOfAny(\"\", [\"a\"])                   = -1\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchStrs  the Strings to search for, may be null\n+     * @return the first index of any of the searchStrs in str, -1 if no match\n+     */\n+    public static int indexOfAny(String str, String[] searchStrs) {\n+        if ((str == null) || (searchStrs == null)) {\n+            return -1;\n+        }\n+        int sz = searchStrs.length;\n+\n+        // String's can't have a MAX_VALUEth index.\n+        int ret = Integer.MAX_VALUE;\n+\n+        int tmp = 0;\n+        for (int i = 0; i < sz; i++) {\n+            String search = searchStrs[i];\n+            if (search == null) {\n+                continue;\n+            }\n+            tmp = str.indexOf(search);\n+            if (tmp == -1) {\n+                continue;\n+            }\n+\n+            if (tmp < ret) {\n+                ret = tmp;\n+            }\n+        }\n+\n+        return (ret == Integer.MAX_VALUE) ? -1 : ret;\n+    }\n+\n+    /**\n+     * <p>Find the latest index of any of a set of potential substrings.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>-1</code>.\n+     * A <code>null</code> search array will return <code>-1</code>.\n+     * A <code>null</code> or zero length search array entry will be ignored,\n+     * but a search array containing \"\" will return the length of <code>str</code>\n+     * if <code>str</code> is not null. This method uses {@link String#indexOf(String)}</p>\n+     *\n+     * <pre>\n+     * StringUtils.lastIndexOfAny(null, *)                   = -1\n+     * StringUtils.lastIndexOfAny(*, null)                   = -1\n+     * StringUtils.lastIndexOfAny(*, [])                     = -1\n+     * StringUtils.lastIndexOfAny(*, [null])                 = -1\n+     * StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"ab\",\"cd\"]) = 6\n+     * StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"cd\",\"ab\"]) = 6\n+     * StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"mn\",\"op\"]) = -1\n+     * StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"mn\",\"op\"]) = -1\n+     * StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"mn\",\"\"])   = 10\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param searchStrs  the Strings to search for, may be null\n+     * @return the last index of any of the Strings, -1 if no match\n+     */\n+    public static int lastIndexOfAny(String str, String[] searchStrs) {\n+        if ((str == null) || (searchStrs == null)) {\n+            return -1;\n+        }\n+        int sz = searchStrs.length;\n+        int ret = -1;\n+        int tmp = 0;\n+        for (int i = 0; i < sz; i++) {\n+            String search = searchStrs[i];\n+            if (search == null) {\n+                continue;\n+            }\n+            tmp = str.lastIndexOf(search);\n+            if (tmp > ret) {\n+                ret = tmp;\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    // Substring\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets a substring from the specified String avoiding exceptions.</p>\n+     *\n+     * <p>A negative start position can be used to start <code>n</code>\n+     * characters from the end of the String.</p>\n+     *\n+     * <p>A <code>null</code> String will return <code>null</code>.\n+     * An empty (\"\") String will return \"\".</p>\n+     *\n+     * <pre>\n+     * StringUtils.substring(null, *)   = null\n+     * StringUtils.substring(\"\", *)     = \"\"\n+     * StringUtils.substring(\"abc\", 0)  = \"abc\"\n+     * StringUtils.substring(\"abc\", 2)  = \"c\"\n+     * StringUtils.substring(\"abc\", 4)  = \"\"\n+     * StringUtils.substring(\"abc\", -2) = \"bc\"\n+     * StringUtils.substring(\"abc\", -4) = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String to get the substring from, may be null\n+     * @param start  the position to start from, negative means\n+     *  count back from the end of the String by this many characters\n+     * @return substring from start position, <code>null</code> if null String input\n+     */\n+    public static String substring(String str, int start) {\n+        if (str == null) {\n+            return null;\n+        }\n+\n+        // handle negatives, which means last n characters\n+        if (start < 0) {\n+            start = str.length() + start; // remember start is negative\n+        }\n+\n+        if (start < 0) {\n+            start = 0;\n+        }\n+        if (start > str.length()) {\n+            return EMPTY;\n+        }\n+\n+        return str.substring(start);\n+    }\n+\n+    /**\n+     * <p>Gets a substring from the specified String avoiding exceptions.</p>\n+     *\n+     * <p>A negative start position can be used to start/end <code>n</code>\n+     * characters from the end of the String.</p>\n+     *\n+     * <p>The returned substring starts with the character in the <code>start</code>\n+     * position and ends before the <code>end</code> position. All position counting is\n+     * zero-based -- i.e., to start at the beginning of the string use\n+     * <code>start = 0</code>. Negative start and end positions can be used to\n+     * specify offsets relative to the end of the String.</p>\n+     *\n+     * <p>If <code>start</code> is not strictly to the left of <code>end</code>, \"\"\n+     * is returned.</p>\n+     *\n+     * <pre>\n+     * StringUtils.substring(null, *, *)    = null\n+     * StringUtils.substring(\"\", * ,  *)    = \"\";\n+     * StringUtils.substring(\"abc\", 0, 2)   = \"ab\"\n+     * StringUtils.substring(\"abc\", 2, 0)   = \"\"\n+     * StringUtils.substring(\"abc\", 2, 4)   = \"c\"\n+     * StringUtils.substring(\"abc\", 4, 6)   = \"\"\n+     * StringUtils.substring(\"abc\", 2, 2)   = \"\"\n+     * StringUtils.substring(\"abc\", -2, -1) = \"b\"\n+     * StringUtils.substring(\"abc\", -4, 2)  = \"ab\"\n+     * </pre>\n+     *\n+     * @param str  the String to get the substring from, may be null\n+     * @param start  the position to start from, negative means\n+     *  count back from the end of the String by this many characters\n+     * @param end  the position to end at (exclusive), negative means\n+     *  count back from the end of the String by this many characters\n+     * @return substring from start position to end positon,\n+     *  <code>null</code> if null String input\n+     */\n+    public static String substring(String str, int start, int end) {\n+        if (str == null) {\n+            return null;\n+        }\n+\n+        // handle negatives\n+        if (end < 0) {\n+            end = str.length() + end; // remember end is negative\n+        }\n+        if (start < 0) {\n+            start = str.length() + start; // remember start is negative\n+        }\n+\n+        // check length next\n+        if (end > str.length()) {\n+            end = str.length();\n+        }\n+\n+        // if start is greater than end, return \"\"\n+        if (start > end) {\n+            return EMPTY;\n+        }\n+\n+        if (start < 0) {\n+            start = 0;\n+        }\n+        if (end < 0) {\n+            end = 0;\n+        }\n+\n+        return str.substring(start, end);\n+    }\n+\n+    // Left/Right/Mid\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the leftmost <code>len</code> characters of a String.</p>\n+     *\n+     * <p>If <code>len</code> characters are not available, or the\n+     * String is <code>null</code>, the String will be returned without\n+     * an exception. An exception is thrown if len is negative.</p>\n+     *\n+     * <pre>\n+     * StringUtils.left(null, *)    = null\n+     * StringUtils.left(*, -ve)     = \"\"\n+     * StringUtils.left(\"\", *)      = \"\"\n+     * StringUtils.left(\"abc\", 0)   = \"\"\n+     * StringUtils.left(\"abc\", 2)   = \"ab\"\n+     * StringUtils.left(\"abc\", 4)   = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String to get the leftmost characters from, may be null\n+     * @param len  the length of the required String, must be zero or positive\n+     * @return the leftmost characters, <code>null</code> if null String input\n+     */\n+    public static String left(String str, int len) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (len < 0) {\n+            return EMPTY;\n+        }\n+        if (str.length() <= len) {\n+            return str;\n+        }\n+        return str.substring(0, len);\n+    }\n+\n+    /**\n+     * <p>Gets the rightmost <code>len</code> characters of a String.</p>\n+     *\n+     * <p>If <code>len</code> characters are not available, or the String\n+     * is <code>null</code>, the String will be returned without an\n+     * an exception. An exception is thrown if len is negative.</p>\n+     *\n+     * <pre>\n+     * StringUtils.right(null, *)    = null\n+     * StringUtils.right(*, -ve)     = \"\"\n+     * StringUtils.right(\"\", *)      = \"\"\n+     * StringUtils.right(\"abc\", 0)   = \"\"\n+     * StringUtils.right(\"abc\", 2)   = \"bc\"\n+     * StringUtils.right(\"abc\", 4)   = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String to get the rightmost characters from, may be null\n+     * @param len  the length of the required String, must be zero or positive\n+     * @return the rightmost characters, <code>null</code> if null String input\n+     */\n+    public static String right(String str, int len) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (len < 0) {\n+            return EMPTY;\n+        }\n+        if (str.length() <= len) {\n+            return str;\n+        }\n+        return str.substring(str.length() - len);\n+    }\n+\n+    /**\n+     * <p>Gets <code>len</code> characters from the middle of a String.</p>\n+     *\n+     * <p>If <code>len</code> characters are not available, the remainder\n+     * of the String will be returned without an exception. If the\n+     * String is <code>null</code>, <code>null</code> will be returned.\n+     * An exception is thrown if len is negative.</p>\n+     *\n+     * <pre>\n+     * StringUtils.mid(null, *, *)    = null\n+     * StringUtils.mid(*, *, -ve)     = \"\"\n+     * StringUtils.mid(\"\", 0, *)      = \"\"\n+     * StringUtils.mid(\"abc\", 0, 2)   = \"ab\"\n+     * StringUtils.mid(\"abc\", 0, 4)   = \"abc\"\n+     * StringUtils.mid(\"abc\", 2, 4)   = \"c\"\n+     * StringUtils.mid(\"abc\", 4, 2)   = \"\"\n+     * StringUtils.mid(\"abc\", -2, 2)  = \"ab\"\n+     * </pre>\n+     *\n+     * @param str  the String to get the characters from, may be null\n+     * @param pos  the position to start from, negative treated as zero\n+     * @param len  the length of the required String, must be zero or positive\n+     * @return the middle characters, <code>null</code> if null String input\n+     */\n+    public static String mid(String str, int pos, int len) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (len < 0 || pos > str.length()) {\n+            return EMPTY;\n+        }\n+        if (pos < 0) {\n+            pos = 0;\n+        }\n+        if (str.length() <= (pos + len)) {\n+            return str.substring(pos);\n+        }\n+        return str.substring(pos, pos + len);\n+    }\n+\n+    // SubStringAfter/SubStringBefore\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the substring before the first occurrence of a separator.\n+     * The separator is not returned.</p>\n+     *\n+     * <p>A <code>null</code> string input will return <code>null</code>.\n+     * An empty (\"\") string input will return the empty string.\n+     * A <code>null</code> separator will return the input string.</p>\n+     *\n+     * <p>If nothing is found, the string input is returned.</p>\n+     *\n+     * <pre>\n+     * StringUtils.substringBefore(null, *)      = null\n+     * StringUtils.substringBefore(\"\", *)        = \"\"\n+     * StringUtils.substringBefore(\"abc\", \"a\")   = \"\"\n+     * StringUtils.substringBefore(\"abcba\", \"b\") = \"a\"\n+     * StringUtils.substringBefore(\"abc\", \"c\")   = \"ab\"\n+     * StringUtils.substringBefore(\"abc\", \"d\")   = \"abc\"\n+     * StringUtils.substringBefore(\"abc\", \"\")    = \"\"\n+     * StringUtils.substringBefore(\"abc\", null)  = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String to get a substring from, may be null\n+     * @param separator  the String to search for, may be null\n+     * @return the substring before the first occurrence of the separator,\n+     *  <code>null</code> if null String input\n+     * @since 2.0\n+     */\n+    public static String substringBefore(String str, String separator) {\n+        if (isEmpty(str) || separator == null) {\n+            return str;\n+        }\n+        if (separator.length() == 0) {\n+            return EMPTY;\n+        }\n+        int pos = str.indexOf(separator);\n+        if (pos == -1) {\n+            return str;\n+        }\n+        return str.substring(0, pos);\n+    }\n+\n+    /**\n+     * <p>Gets the substring after the first occurrence of a separator.\n+     * The separator is not returned.</p>\n+     *\n+     * <p>A <code>null</code> string input will return <code>null</code>.\n+     * An empty (\"\") string input will return the empty string.\n+     * A <code>null</code> separator will return the empty string if the\n+     * input string is not <code>null</code>.</p>\n+     *\n+     * <p>If nothing is found, the empty string is returned.</p>\n+     *\n+     * <pre>\n+     * StringUtils.substringAfter(null, *)      = null\n+     * StringUtils.substringAfter(\"\", *)        = \"\"\n+     * StringUtils.substringAfter(*, null)      = \"\"\n+     * StringUtils.substringAfter(\"abc\", \"a\")   = \"bc\"\n+     * StringUtils.substringAfter(\"abcba\", \"b\") = \"cba\"\n+     * StringUtils.substringAfter(\"abc\", \"c\")   = \"\"\n+     * StringUtils.substringAfter(\"abc\", \"d\")   = \"\"\n+     * StringUtils.substringAfter(\"abc\", \"\")    = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String to get a substring from, may be null\n+     * @param separator  the String to search for, may be null\n+     * @return the substring after the first occurrence of the separator,\n+     *  <code>null</code> if null String input\n+     * @since 2.0\n+     */\n+    public static String substringAfter(String str, String separator) {\n+        if (isEmpty(str)) {\n+            return str;\n+        }\n+        if (separator == null) {\n+            return EMPTY;\n+        }\n+        int pos = str.indexOf(separator);\n+        if (pos == -1) {\n+            return EMPTY;\n+        }\n+        return str.substring(pos + separator.length());\n+    }\n+\n+    /**\n+     * <p>Gets the substring before the last occurrence of a separator.\n+     * The separator is not returned.</p>\n+     *\n+     * <p>A <code>null</code> string input will return <code>null</code>.\n+     * An empty (\"\") string input will return the empty string.\n+     * An empty or <code>null</code> separator will return the input string.</p>\n+     *\n+     * <p>If nothing is found, the string input is returned.</p>\n+     *\n+     * <pre>\n+     * StringUtils.substringBeforeLast(null, *)      = null\n+     * StringUtils.substringBeforeLast(\"\", *)        = \"\"\n+     * StringUtils.substringBeforeLast(\"abcba\", \"b\") = \"abc\"\n+     * StringUtils.substringBeforeLast(\"abc\", \"c\")   = \"ab\"\n+     * StringUtils.substringBeforeLast(\"a\", \"a\")     = \"\"\n+     * StringUtils.substringBeforeLast(\"a\", \"z\")     = \"a\"\n+     * StringUtils.substringBeforeLast(\"a\", null)    = \"a\"\n+     * StringUtils.substringBeforeLast(\"a\", \"\")      = \"a\"\n+     * </pre>\n+     *\n+     * @param str  the String to get a substring from, may be null\n+     * @param separator  the String to search for, may be null\n+     * @return the substring before the last occurrence of the separator,\n+     *  <code>null</code> if null String input\n+     * @since 2.0\n+     */\n+    public static String substringBeforeLast(String str, String separator) {\n+        if (isEmpty(str) || isEmpty(separator)) {\n+            return str;\n+        }\n+        int pos = str.lastIndexOf(separator);\n+        if (pos == -1) {\n+            return str;\n+        }\n+        return str.substring(0, pos);\n+    }\n+\n+    /**\n+     * <p>Gets the substring after the last occurrence of a separator.\n+     * The separator is not returned.</p>\n+     *\n+     * <p>A <code>null</code> string input will return <code>null</code>.\n+     * An empty (\"\") string input will return the empty string.\n+     * An empty or <code>null</code> separator will return the empty string if\n+     * the input string is not <code>null</code>.</p>\n+     *\n+     * <p>If nothing is found, the empty string is returned.</p>\n+     *\n+     * <pre>\n+     * StringUtils.substringAfterLast(null, *)      = null\n+     * StringUtils.substringAfterLast(\"\", *)        = \"\"\n+     * StringUtils.substringAfterLast(*, \"\")        = \"\"\n+     * StringUtils.substringAfterLast(*, null)      = \"\"\n+     * StringUtils.substringAfterLast(\"abc\", \"a\")   = \"bc\"\n+     * StringUtils.substringAfterLast(\"abcba\", \"b\") = \"a\"\n+     * StringUtils.substringAfterLast(\"abc\", \"c\")   = \"\"\n+     * StringUtils.substringAfterLast(\"a\", \"a\")     = \"\"\n+     * StringUtils.substringAfterLast(\"a\", \"z\")     = \"\"\n+     * </pre>\n+     *\n+     * @param str  the String to get a substring from, may be null\n+     * @param separator  the String to search for, may be null\n+     * @return the substring after the last occurrence of the separator,\n+     *  <code>null</code> if null String input\n+     * @since 2.0\n+     */\n+    public static String substringAfterLast(String str, String separator) {\n+        if (isEmpty(str)) {\n+            return str;\n+        }\n+        if (isEmpty(separator)) {\n+            return EMPTY;\n+        }\n+        int pos = str.lastIndexOf(separator);\n+        if (pos == -1 || pos == (str.length() - separator.length())) {\n+            return EMPTY;\n+        }\n+        return str.substring(pos + separator.length());\n+    }\n+\n+    // Substring between\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the String that is nested in between two instances of the\n+     * same String.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> tag returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.substringBetween(null, *)            = null\n+     * StringUtils.substringBetween(\"\", \"\")             = \"\"\n+     * StringUtils.substringBetween(\"\", \"tag\")          = null\n+     * StringUtils.substringBetween(\"tagabctag\", null)  = null\n+     * StringUtils.substringBetween(\"tagabctag\", \"\")    = \"\"\n+     * StringUtils.substringBetween(\"tagabctag\", \"tag\") = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String containing the substring, may be null\n+     * @param tag  the String before and after the substring, may be null\n+     * @return the substring, <code>null</code> if no match\n+     * @since 2.0\n+     */\n+    public static String substringBetween(String str, String tag) {\n+        return substringBetween(str, tag, tag);\n+    }\n+\n+    /**\n+     * <p>Gets the String that is nested in between two Strings.\n+     * Only the first match is returned.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> open/close returns <code>null</code> (no match).\n+     * An empty (\"\") open and close returns an empty string.</p>\n+     *\n+     * <pre>\n+     * StringUtils.substringBetween(\"wx[b]yz\", \"[\", \"]\") = \"b\"\n+     * StringUtils.substringBetween(null, *, *)          = null\n+     * StringUtils.substringBetween(*, null, *)          = null\n+     * StringUtils.substringBetween(*, *, null)          = null\n+     * StringUtils.substringBetween(\"\", \"\", \"\")          = \"\"\n+     * StringUtils.substringBetween(\"\", \"\", \"]\")         = null\n+     * StringUtils.substringBetween(\"\", \"[\", \"]\")        = null\n+     * StringUtils.substringBetween(\"yabcz\", \"\", \"\")     = \"\"\n+     * StringUtils.substringBetween(\"yabcz\", \"y\", \"z\")   = \"abc\"\n+     * StringUtils.substringBetween(\"yabczyabcz\", \"y\", \"z\")   = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String containing the substring, may be null\n+     * @param open  the String before the substring, may be null\n+     * @param close  the String after the substring, may be null\n+     * @return the substring, <code>null</code> if no match\n+     * @since 2.0\n+     */\n+    public static String substringBetween(String str, String open, String close) {\n+        if (str == null || open == null || close == null) {\n+            return null;\n+        }\n+        int start = str.indexOf(open);\n+        if (start != -1) {\n+            int end = str.indexOf(close, start + open.length());\n+            if (end != -1) {\n+                return str.substring(start + open.length(), end);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * <p>Searches a String for substrings delimited by a start and end tag,\n+     * returning all matching substrings in an array.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> open/close returns <code>null</code> (no match).\n+     * An empty (\"\") open/close returns <code>null</code> (no match).</p>\n+     *\n+     * <pre>\n+     * StringUtils.substringsBetween(\"[a][b][c]\", \"[\", \"]\") = [\"a\",\"b\",\"c\"]\n+     * StringUtils.substringsBetween(null, *, *)            = null\n+     * StringUtils.substringsBetween(*, null, *)            = null\n+     * StringUtils.substringsBetween(*, *, null)            = null\n+     * StringUtils.substringsBetween(\"\", \"[\", \"]\")          = []\n+     * </pre>\n+     *\n+     * @param str  the String containing the substrings, null returns null, empty returns empty\n+     * @param open  the String identifying the start of the substring, empty returns null\n+     * @param close  the String identifying the end of the substring, empty returns null\n+     * @return a String Array of substrings, or <code>null</code> if no match\n+     * @since 2.3\n+     */\n+    public static String[] substringsBetween(String str, String open, String close) {\n+        if (str == null || isEmpty(open) || isEmpty(close)) {\n+            return null;\n+        }\n+        int strLen = str.length();\n+        if (strLen == 0) {\n+            return ArrayUtils.EMPTY_STRING_ARRAY;\n+        }\n+        int closeLen = close.length();\n+        int openLen = open.length();\n+        List<String> list = new ArrayList<String>();\n+        int pos = 0;\n+        while (pos < (strLen - closeLen)) {\n+            int start = str.indexOf(open, pos);\n+            if (start < 0) {\n+                break;\n+            }\n+            start += openLen;\n+            int end = str.indexOf(close, start);\n+            if (end < 0) {\n+                break;\n+            }\n+            list.add(str.substring(start, end));\n+            pos = end + closeLen;\n+        }\n+        if (list.isEmpty()) {\n+            return null;\n+        } \n+        return list.toArray(new String [list.size()]);\n+    }\n+\n+    // Nested extraction\n+    //-----------------------------------------------------------------------\n+\n+    // Splitting\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Splits the provided text into an array, using whitespace as the\n+     * separator.\n+     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n+     *\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators are treated as one separator.\n+     * For more control over the split use the StrTokenizer class.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.split(null)       = null\n+     * StringUtils.split(\"\")         = []\n+     * StringUtils.split(\"abc def\")  = [\"abc\", \"def\"]\n+     * StringUtils.split(\"abc  def\") = [\"abc\", \"def\"]\n+     * StringUtils.split(\" abc \")    = [\"abc\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be null\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     */\n+    public static String[] split(String str) {\n+        return split(str, null, -1);\n+    }\n+\n+    /**\n+     * <p>Splits the provided text into an array, separator specified.\n+     * This is an alternative to using StringTokenizer.</p>\n+     *\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators are treated as one separator.\n+     * For more control over the split use the StrTokenizer class.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.split(null, *)         = null\n+     * StringUtils.split(\"\", *)           = []\n+     * StringUtils.split(\"a.b.c\", '.')    = [\"a\", \"b\", \"c\"]\n+     * StringUtils.split(\"a..b.c\", '.')   = [\"a\", \"b\", \"c\"]\n+     * StringUtils.split(\"a:b:c\", '.')    = [\"a:b:c\"]\n+     * StringUtils.split(\"a b c\", ' ')    = [\"a\", \"b\", \"c\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be null\n+     * @param separatorChar  the character used as the delimiter\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     * @since 2.0\n+     */\n+    public static String[] split(String str, char separatorChar) {\n+        return splitWorker(str, separatorChar, false);\n+    }\n+\n+    /**\n+     * <p>Splits the provided text into an array, separators specified.\n+     * This is an alternative to using StringTokenizer.</p>\n+     *\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators are treated as one separator.\n+     * For more control over the split use the StrTokenizer class.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> separatorChars splits on whitespace.</p>\n+     *\n+     * <pre>\n+     * StringUtils.split(null, *)         = null\n+     * StringUtils.split(\"\", *)           = []\n+     * StringUtils.split(\"abc def\", null) = [\"abc\", \"def\"]\n+     * StringUtils.split(\"abc def\", \" \")  = [\"abc\", \"def\"]\n+     * StringUtils.split(\"abc  def\", \" \") = [\"abc\", \"def\"]\n+     * StringUtils.split(\"ab:cd:ef\", \":\") = [\"ab\", \"cd\", \"ef\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be null\n+     * @param separatorChars  the characters used as the delimiters,\n+     *  <code>null</code> splits on whitespace\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     */\n+    public static String[] split(String str, String separatorChars) {\n+        return splitWorker(str, separatorChars, -1, false);\n+    }\n+\n+    /**\n+     * <p>Splits the provided text into an array with a maximum length,\n+     * separators specified.</p>\n+     *\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators are treated as one separator.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> separatorChars splits on whitespace.</p>\n+     *\n+     * <p>If more than <code>max</code> delimited substrings are found, the last\n+     * returned string includes all characters after the first <code>max - 1</code>\n+     * returned strings (including separator characters).</p>\n+     *\n+     * <pre>\n+     * StringUtils.split(null, *, *)            = null\n+     * StringUtils.split(\"\", *, *)              = []\n+     * StringUtils.split(\"ab de fg\", null, 0)   = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.split(\"ab   de fg\", null, 0) = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.split(\"ab:cd:ef\", \":\", 0)    = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.split(\"ab:cd:ef\", \":\", 2)    = [\"ab\", \"cd:ef\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be null\n+     * @param separatorChars  the characters used as the delimiters,\n+     *  <code>null</code> splits on whitespace\n+     * @param max  the maximum number of elements to include in the\n+     *  array. A zero or negative value implies no limit\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     */\n+    public static String[] split(String str, String separatorChars, int max) {\n+        return splitWorker(str, separatorChars, max, false);\n+    }\n+\n+    /**\n+     * <p>Splits the provided text into an array, separator string specified.</p>\n+     *\n+     * <p>The separator(s) will not be included in the returned String array.\n+     * Adjacent separators are treated as one separator.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> separator splits on whitespace.</p>\n+     *\n+     * <pre>\n+     * StringUtils.splitByWholeSeparator(null, *)               = null\n+     * StringUtils.splitByWholeSeparator(\"\", *)                 = []\n+     * StringUtils.splitByWholeSeparator(\"ab de fg\", null)      = [\"ab\", \"de\", \"fg\"]\n+     * StringUtils.splitByWholeSeparator(\"ab   de fg\", null)    = [\"ab\", \"de\", \"fg\"]\n+     * StringUtils.splitByWholeSeparator(\"ab:cd:ef\", \":\")       = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.splitByWholeSeparator(\"ab-!-cd-!-ef\", \"-!-\") = [\"ab\", \"cd\", \"ef\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be null\n+     * @param separator  String containing the String to be used as a delimiter,\n+     *  <code>null</code> splits on whitespace\n+     * @return an array of parsed Strings, <code>null</code> if null String was input\n+     */\n+    public static String[] splitByWholeSeparator(String str, String separator) {\n+        return splitByWholeSeparatorWorker( str, separator, -1, false ) ;\n+    }\n+\n+    /**\n+     * <p>Splits the provided text into an array, separator string specified.\n+     * Returns a maximum of <code>max</code> substrings.</p>\n+     *\n+     * <p>The separator(s) will not be included in the returned String array.\n+     * Adjacent separators are treated as one separator.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> separator splits on whitespace.</p>\n+     *\n+     * <pre>\n+     * StringUtils.splitByWholeSeparator(null, *, *)               = null\n+     * StringUtils.splitByWholeSeparator(\"\", *, *)                 = []\n+     * StringUtils.splitByWholeSeparator(\"ab de fg\", null, 0)      = [\"ab\", \"de\", \"fg\"]\n+     * StringUtils.splitByWholeSeparator(\"ab   de fg\", null, 0)    = [\"ab\", \"de\", \"fg\"]\n+     * StringUtils.splitByWholeSeparator(\"ab:cd:ef\", \":\", 2)       = [\"ab\", \"cd:ef\"]\n+     * StringUtils.splitByWholeSeparator(\"ab-!-cd-!-ef\", \"-!-\", 5) = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.splitByWholeSeparator(\"ab-!-cd-!-ef\", \"-!-\", 2) = [\"ab\", \"cd-!-ef\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be null\n+     * @param separator  String containing the String to be used as a delimiter,\n+     *  <code>null</code> splits on whitespace\n+     * @param max  the maximum number of elements to include in the returned\n+     *  array. A zero or negative value implies no limit.\n+     * @return an array of parsed Strings, <code>null</code> if null String was input\n+     */\n+    public static String[] splitByWholeSeparator( String str, String separator, int max ) {\n+        return splitByWholeSeparatorWorker(str, separator, max, false);\n+    }\n+\n+    /**\n+     * <p>Splits the provided text into an array, separator string specified. </p>\n+     *\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators are treated as separators for empty tokens.\n+     * For more control over the split use the StrTokenizer class.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> separator splits on whitespace.</p>\n+     *\n+     * <pre>\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(null, *)               = null\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"\", *)                 = []\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab de fg\", null)      = [\"ab\", \"de\", \"fg\"]\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab   de fg\", null)    = [\"ab\", \"\", \"\", \"de\", \"fg\"]\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab:cd:ef\", \":\")       = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab-!-cd-!-ef\", \"-!-\") = [\"ab\", \"cd\", \"ef\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be null\n+     * @param separator  String containing the String to be used as a delimiter,\n+     *  <code>null</code> splits on whitespace\n+     * @return an array of parsed Strings, <code>null</code> if null String was input\n+     * @since 2.4\n+     */\n+    public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) {\n+        return splitByWholeSeparatorWorker(str, separator, -1, true);\n+    }\n+\n+    /**\n+     * <p>Splits the provided text into an array, separator string specified.\n+     * Returns a maximum of <code>max</code> substrings.</p>\n+     *\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators are treated as separators for empty tokens.\n+     * For more control over the split use the StrTokenizer class.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> separator splits on whitespace.</p>\n+     *\n+     * <pre>\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(null, *, *)               = null\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"\", *, *)                 = []\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab de fg\", null, 0)      = [\"ab\", \"de\", \"fg\"]\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab   de fg\", null, 0)    = [\"ab\", \"\", \"\", \"de\", \"fg\"]\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab:cd:ef\", \":\", 2)       = [\"ab\", \"cd:ef\"]\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab-!-cd-!-ef\", \"-!-\", 5) = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab-!-cd-!-ef\", \"-!-\", 2) = [\"ab\", \"cd-!-ef\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be null\n+     * @param separator  String containing the String to be used as a delimiter,\n+     *  <code>null</code> splits on whitespace\n+     * @param max  the maximum number of elements to include in the returned\n+     *  array. A zero or negative value implies no limit.\n+     * @return an array of parsed Strings, <code>null</code> if null String was input\n+     * @since 2.4\n+     */\n+    public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max) {\n+        return splitByWholeSeparatorWorker(str, separator, max, true);\n+    }\n+\n+    /**\n+     * Performs the logic for the <code>splitByWholeSeparatorPreserveAllTokens</code> methods.\n+     *\n+     * @param str  the String to parse, may be <code>null</code>\n+     * @param separator  String containing the String to be used as a delimiter,\n+     *  <code>null</code> splits on whitespace\n+     * @param max  the maximum number of elements to include in the returned\n+     *  array. A zero or negative value implies no limit.\n+     * @param preserveAllTokens if <code>true</code>, adjacent separators are\n+     * treated as empty token separators; if <code>false</code>, adjacent\n+     * separators are treated as one separator.\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     * @since 2.4\n+     */\n+    private static String[] splitByWholeSeparatorWorker(String str, String separator, int max, \n+                                                        boolean preserveAllTokens) \n+    {\n+        if (str == null) {\n+            return null;\n+        }\n+\n+        int len = str.length();\n+\n+        if (len == 0) {\n+            return ArrayUtils.EMPTY_STRING_ARRAY;\n+        }\n+\n+        if ((separator == null) || (EMPTY.equals(separator))) {\n+            // Split on whitespace.\n+            return splitWorker(str, null, max, preserveAllTokens);\n+        }\n+\n+        int separatorLength = separator.length();\n+\n+        ArrayList<String> substrings = new ArrayList<String>();\n+        int numberOfSubstrings = 0;\n+        int beg = 0;\n+        int end = 0;\n+        while (end < len) {\n+            end = str.indexOf(separator, beg);\n+\n+            if (end > -1) {\n+                if (end > beg) {\n+                    numberOfSubstrings += 1;\n+\n+                    if (numberOfSubstrings == max) {\n+                        end = len;\n+                        substrings.add(str.substring(beg));\n+                    } else {\n+                        // The following is OK, because String.substring( beg, end ) excludes\n+                        // the character at the position 'end'.\n+                        substrings.add(str.substring(beg, end));\n+\n+                        // Set the starting point for the next search.\n+                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n+                        // which is the right calculation:\n+                        beg = end + separatorLength;\n+                    }\n+                } else {\n+                    // We found a consecutive occurrence of the separator, so skip it.\n+                    if (preserveAllTokens) {\n+                        numberOfSubstrings += 1;\n+                        if (numberOfSubstrings == max) {\n+                            end = len;\n+                            substrings.add(str.substring(beg));\n+                        } else {\n+                            substrings.add(EMPTY);\n+                        }\n+                    }\n+                    beg = end + separatorLength;\n+                }\n+            } else {\n+                // String.substring( beg ) goes from 'beg' to the end of the String.\n+                substrings.add(str.substring(beg));\n+                end = len;\n+            }\n+        }\n+\n+        return substrings.toArray(new String[substrings.size()]);\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    /**\n+     * <p>Splits the provided text into an array, using whitespace as the\n+     * separator, preserving all tokens, including empty tokens created by \n+     * adjacent separators. This is an alternative to using StringTokenizer.\n+     * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n+     *\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators are treated as separators for empty tokens.\n+     * For more control over the split use the StrTokenizer class.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.splitPreserveAllTokens(null)       = null\n+     * StringUtils.splitPreserveAllTokens(\"\")         = []\n+     * StringUtils.splitPreserveAllTokens(\"abc def\")  = [\"abc\", \"def\"]\n+     * StringUtils.splitPreserveAllTokens(\"abc  def\") = [\"abc\", \"\", \"def\"]\n+     * StringUtils.splitPreserveAllTokens(\" abc \")    = [\"\", \"abc\", \"\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be <code>null</code>\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     * @since 2.1\n+     */\n+    public static String[] splitPreserveAllTokens(String str) {\n+        return splitWorker(str, null, -1, true);\n+    }\n+\n+    /**\n+     * <p>Splits the provided text into an array, separator specified,\n+     * preserving all tokens, including empty tokens created by adjacent\n+     * separators. This is an alternative to using StringTokenizer.</p>\n+     *\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators are treated as separators for empty tokens.\n+     * For more control over the split use the StrTokenizer class.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.splitPreserveAllTokens(null, *)         = null\n+     * StringUtils.splitPreserveAllTokens(\"\", *)           = []\n+     * StringUtils.splitPreserveAllTokens(\"a.b.c\", '.')    = [\"a\", \"b\", \"c\"]\n+     * StringUtils.splitPreserveAllTokens(\"a..b.c\", '.')   = [\"a\", \"\", \"b\", \"c\"]\n+     * StringUtils.splitPreserveAllTokens(\"a:b:c\", '.')    = [\"a:b:c\"]\n+     * StringUtils.splitPreserveAllTokens(\"a\\tb\\nc\", null) = [\"a\", \"b\", \"c\"]\n+     * StringUtils.splitPreserveAllTokens(\"a b c\", ' ')    = [\"a\", \"b\", \"c\"]\n+     * StringUtils.splitPreserveAllTokens(\"a b c \", ' ')   = [\"a\", \"b\", \"c\", \"\"]\n+     * StringUtils.splitPreserveAllTokens(\"a b c  \", ' ')   = [\"a\", \"b\", \"c\", \"\", \"\"]\n+     * StringUtils.splitPreserveAllTokens(\" a b c\", ' ')   = [\"\", a\", \"b\", \"c\"]\n+     * StringUtils.splitPreserveAllTokens(\"  a b c\", ' ')  = [\"\", \"\", a\", \"b\", \"c\"]\n+     * StringUtils.splitPreserveAllTokens(\" a b c \", ' ')  = [\"\", a\", \"b\", \"c\", \"\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be <code>null</code>\n+     * @param separatorChar  the character used as the delimiter,\n+     *  <code>null</code> splits on whitespace\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     * @since 2.1\n+     */\n+    public static String[] splitPreserveAllTokens(String str, char separatorChar) {\n+        return splitWorker(str, separatorChar, true);\n+    }\n+\n+    /**\n+     * Performs the logic for the <code>split</code> and \n+     * <code>splitPreserveAllTokens</code> methods that do not return a\n+     * maximum array length.\n+     *\n+     * @param str  the String to parse, may be <code>null</code>\n+     * @param separatorChar the separate character\n+     * @param preserveAllTokens if <code>true</code>, adjacent separators are\n+     * treated as empty token separators; if <code>false</code>, adjacent\n+     * separators are treated as one separator.\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     */\n+    private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) {\n+        // Performance tuned for 2.0 (JDK1.4)\n+\n+        if (str == null) {\n+            return null;\n+        }\n+        int len = str.length();\n+        if (len == 0) {\n+            return ArrayUtils.EMPTY_STRING_ARRAY;\n+        }\n+        List<String> list = new ArrayList<String>();\n+        int i = 0, start = 0;\n+        boolean match = false;\n+        boolean lastMatch = false;\n+        while (i < len) {\n+            if (str.charAt(i) == separatorChar) {\n+                if (match || preserveAllTokens) {\n+                    list.add(str.substring(start, i));\n+                    match = false;\n+                    lastMatch = true;\n+                }\n+                start = ++i;\n+                continue;\n+            }\n+            lastMatch = false;\n+            match = true;\n+            i++;\n+        }\n+        if (match || (preserveAllTokens && lastMatch)) {\n+            list.add(str.substring(start, i));\n+        }\n+        return list.toArray(new String[list.size()]);\n+    }\n+\n+    /**\n+     * <p>Splits the provided text into an array, separators specified, \n+     * preserving all tokens, including empty tokens created by adjacent\n+     * separators. This is an alternative to using StringTokenizer.</p>\n+     *\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators are treated as separators for empty tokens.\n+     * For more control over the split use the StrTokenizer class.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> separatorChars splits on whitespace.</p>\n+     *\n+     * <pre>\n+     * StringUtils.splitPreserveAllTokens(null, *)           = null\n+     * StringUtils.splitPreserveAllTokens(\"\", *)             = []\n+     * StringUtils.splitPreserveAllTokens(\"abc def\", null)   = [\"abc\", \"def\"]\n+     * StringUtils.splitPreserveAllTokens(\"abc def\", \" \")    = [\"abc\", \"def\"]\n+     * StringUtils.splitPreserveAllTokens(\"abc  def\", \" \")   = [\"abc\", \"\", def\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab:cd:ef\", \":\")   = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab:cd:ef:\", \":\")  = [\"ab\", \"cd\", \"ef\", \"\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab:cd:ef::\", \":\") = [\"ab\", \"cd\", \"ef\", \"\", \"\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab::cd:ef\", \":\")  = [\"ab\", \"\", cd\", \"ef\"]\n+     * StringUtils.splitPreserveAllTokens(\":cd:ef\", \":\")     = [\"\", cd\", \"ef\"]\n+     * StringUtils.splitPreserveAllTokens(\"::cd:ef\", \":\")    = [\"\", \"\", cd\", \"ef\"]\n+     * StringUtils.splitPreserveAllTokens(\":cd:ef:\", \":\")    = [\"\", cd\", \"ef\", \"\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be <code>null</code>\n+     * @param separatorChars  the characters used as the delimiters,\n+     *  <code>null</code> splits on whitespace\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     * @since 2.1\n+     */\n+    public static String[] splitPreserveAllTokens(String str, String separatorChars) {\n+        return splitWorker(str, separatorChars, -1, true);\n+    }\n+\n+    /**\n+     * <p>Splits the provided text into an array with a maximum length,\n+     * separators specified, preserving all tokens, including empty tokens \n+     * created by adjacent separators.</p>\n+     *\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators are treated as separators for empty tokens.\n+     * Adjacent separators are treated as one separator.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * A <code>null</code> separatorChars splits on whitespace.</p>\n+     *\n+     * <p>If more than <code>max</code> delimited substrings are found, the last\n+     * returned string includes all characters after the first <code>max - 1</code>\n+     * returned strings (including separator characters).</p>\n+     *\n+     * <pre>\n+     * StringUtils.splitPreserveAllTokens(null, *, *)            = null\n+     * StringUtils.splitPreserveAllTokens(\"\", *, *)              = []\n+     * StringUtils.splitPreserveAllTokens(\"ab de fg\", null, 0)   = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 0) = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab:cd:ef\", \":\", 0)    = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab:cd:ef\", \":\", 2)    = [\"ab\", \"cd:ef\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 2) = [\"ab\", \"  de fg\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 3) = [\"ab\", \"\", \" de fg\"]\n+     * StringUtils.splitPreserveAllTokens(\"ab   de fg\", null, 4) = [\"ab\", \"\", \"\", \"de fg\"]\n+     * </pre>\n+     *\n+     * @param str  the String to parse, may be <code>null</code>\n+     * @param separatorChars  the characters used as the delimiters,\n+     *  <code>null</code> splits on whitespace\n+     * @param max  the maximum number of elements to include in the\n+     *  array. A zero or negative value implies no limit\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     * @since 2.1\n+     */\n+    public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) {\n+        return splitWorker(str, separatorChars, max, true);\n+    }\n+\n+    /**\n+     * Performs the logic for the <code>split</code> and \n+     * <code>splitPreserveAllTokens</code> methods that return a maximum array \n+     * length.\n+     *\n+     * @param str  the String to parse, may be <code>null</code>\n+     * @param separatorChars the separate character\n+     * @param max  the maximum number of elements to include in the\n+     *  array. A zero or negative value implies no limit.\n+     * @param preserveAllTokens if <code>true</code>, adjacent separators are\n+     * treated as empty token separators; if <code>false</code>, adjacent\n+     * separators are treated as one separator.\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     */\n+    private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) {\n+        // Performance tuned for 2.0 (JDK1.4)\n+        // Direct code is quicker than StringTokenizer.\n+        // Also, StringTokenizer uses isSpace() not isWhitespace()\n+\n+        if (str == null) {\n+            return null;\n+        }\n+        int len = str.length();\n+        if (len == 0) {\n+            return ArrayUtils.EMPTY_STRING_ARRAY;\n+        }\n+        List<String> list = new ArrayList<String>();\n+        int sizePlus1 = 1;\n+        int i = 0, start = 0;\n+        boolean match = false;\n+        boolean lastMatch = false;\n+        if (separatorChars == null) {\n+            // Null separator means use whitespace\n+            while (i < len) {\n+                if (Character.isWhitespace(str.charAt(i))) {\n+                    if (match || preserveAllTokens) {\n+                        lastMatch = true;\n+                        if (sizePlus1++ == max) {\n+                            i = len;\n+                            lastMatch = false;\n+                        }\n+                        list.add(str.substring(start, i));\n+                        match = false;\n+                    }\n+                    start = ++i;\n+                    continue;\n+                }\n+                lastMatch = false;\n+                match = true;\n+                i++;\n+            }\n+        } else if (separatorChars.length() == 1) {\n+            // Optimise 1 character case\n+            char sep = separatorChars.charAt(0);\n+            while (i < len) {\n+                if (str.charAt(i) == sep) {\n+                    if (match || preserveAllTokens) {\n+                        lastMatch = true;\n+                        if (sizePlus1++ == max) {\n+                            i = len;\n+                            lastMatch = false;\n+                        }\n+                        list.add(str.substring(start, i));\n+                        match = false;\n+                    }\n+                    start = ++i;\n+                    continue;\n+                }\n+                lastMatch = false;\n+                match = true;\n+                i++;\n+            }\n+        } else {\n+            // standard case\n+            while (i < len) {\n+                if (separatorChars.indexOf(str.charAt(i)) >= 0) {\n+                    if (match || preserveAllTokens) {\n+                        lastMatch = true;\n+                        if (sizePlus1++ == max) {\n+                            i = len;\n+                            lastMatch = false;\n+                        }\n+                        list.add(str.substring(start, i));\n+                        match = false;\n+                    }\n+                    start = ++i;\n+                    continue;\n+                }\n+                lastMatch = false;\n+                match = true;\n+                i++;\n+            }\n+        }\n+        if (match || (preserveAllTokens && lastMatch)) {\n+            list.add(str.substring(start, i));\n+        }\n+        return list.toArray(new String[list.size()]);\n+    }\n+\n+    /**\n+     * <p>Splits a String by Character type as returned by\n+     * <code>java.lang.Character.getType(char)</code>. Groups of contiguous\n+     * characters of the same type are returned as complete tokens. \n+     * <pre>\n+     * StringUtils.splitByCharacterType(null)         = null\n+     * StringUtils.splitByCharacterType(\"\")           = []\n+     * StringUtils.splitByCharacterType(\"ab de fg\")   = [\"ab\", \" \", \"de\", \" \", \"fg\"]\n+     * StringUtils.splitByCharacterType(\"ab   de fg\") = [\"ab\", \"   \", \"de\", \" \", \"fg\"]\n+     * StringUtils.splitByCharacterType(\"ab:cd:ef\")   = [\"ab\", \":\", \"cd\", \":\", \"ef\"]\n+     * StringUtils.splitByCharacterType(\"number5\")    = [\"number\", \"5\"]\n+     * StringUtils.splitByCharacterType(\"fooBar\")     = [\"foo\", \"B\", \"ar\"]\n+     * StringUtils.splitByCharacterType(\"foo200Bar\")  = [\"foo\", \"200\", \"B\", \"ar\"]\n+     * StringUtils.splitByCharacterType(\"ASFRules\")   = [\"ASFR\", \"ules\"]\n+     * </pre>\n+     * @param str the String to split, may be <code>null</code>\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     * @since 2.4\n+     */\n+    public static String[] splitByCharacterType(String str) {\n+        return splitByCharacterType(str, false);\n+    }\n+\n+    /**\n+     * <p>Splits a String by Character type as returned by\n+     * <code>java.lang.Character.getType(char)</code>. Groups of contiguous\n+     * characters of the same type are returned as complete tokens, with the\n+     * following exception: the character of type\n+     * <code>Character.UPPERCASE_LETTER</code>, if any, immediately\n+     * preceding a token of type <code>Character.LOWERCASE_LETTER</code>\n+     * will belong to the following token rather than to the preceding, if any,\n+     * <code>Character.UPPERCASE_LETTER</code> token. \n+     * <pre>\n+     * StringUtils.splitByCharacterTypeCamelCase(null)         = null\n+     * StringUtils.splitByCharacterTypeCamelCase(\"\")           = []\n+     * StringUtils.splitByCharacterTypeCamelCase(\"ab de fg\")   = [\"ab\", \" \", \"de\", \" \", \"fg\"]\n+     * StringUtils.splitByCharacterTypeCamelCase(\"ab   de fg\") = [\"ab\", \"   \", \"de\", \" \", \"fg\"]\n+     * StringUtils.splitByCharacterTypeCamelCase(\"ab:cd:ef\")   = [\"ab\", \":\", \"cd\", \":\", \"ef\"]\n+     * StringUtils.splitByCharacterTypeCamelCase(\"number5\")    = [\"number\", \"5\"]\n+     * StringUtils.splitByCharacterTypeCamelCase(\"fooBar\")     = [\"foo\", \"Bar\"]\n+     * StringUtils.splitByCharacterTypeCamelCase(\"foo200Bar\")  = [\"foo\", \"200\", \"Bar\"]\n+     * StringUtils.splitByCharacterTypeCamelCase(\"ASFRules\")   = [\"ASF\", \"Rules\"]\n+     * </pre>\n+     * @param str the String to split, may be <code>null</code>\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     * @since 2.4\n+     */\n+    public static String[] splitByCharacterTypeCamelCase(String str) {\n+        return splitByCharacterType(str, true);\n+    }\n+\n+    /**\n+     * <p>Splits a String by Character type as returned by\n+     * <code>java.lang.Character.getType(char)</code>. Groups of contiguous\n+     * characters of the same type are returned as complete tokens, with the\n+     * following exception: if <code>camelCase</code> is <code>true</code>,\n+     * the character of type <code>Character.UPPERCASE_LETTER</code>, if any,\n+     * immediately preceding a token of type <code>Character.LOWERCASE_LETTER</code>\n+     * will belong to the following token rather than to the preceding, if any,\n+     * <code>Character.UPPERCASE_LETTER</code> token. \n+     * @param str the String to split, may be <code>null</code>\n+     * @param camelCase whether to use so-called \"camel-case\" for letter types\n+     * @return an array of parsed Strings, <code>null</code> if null String input\n+     * @since 2.4\n+     */\n+    private static String[] splitByCharacterType(String str, boolean camelCase) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (str.length() == 0) {\n+            return ArrayUtils.EMPTY_STRING_ARRAY;\n+        }\n+        char[] c = str.toCharArray();\n+        List<String> list = new ArrayList<String>();\n+        int tokenStart = 0;\n+        int currentType = Character.getType(c[tokenStart]);\n+        for (int pos = tokenStart + 1; pos < c.length; pos++) {\n+            int type = Character.getType(c[pos]);\n+            if (type == currentType) {\n+                continue;\n+            }\n+            if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n+                int newTokenStart = pos - 1;\n+                if (newTokenStart != tokenStart) {\n+                    list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n+                    tokenStart = newTokenStart;\n+                }\n+            } else {\n+                list.add(new String(c, tokenStart, pos - tokenStart));\n+                tokenStart = pos;\n+            }\n+            currentType = type;\n+        }\n+        list.add(new String(c, tokenStart, c.length - tokenStart));\n+        return list.toArray(new String[list.size()]);\n+    }\n+\n+    // Joining\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Joins the elements of the provided array into a single String\n+     * containing the provided list of elements.</p>\n+     *\n+     * <p>No separator is added to the joined String.\n+     * Null objects or empty strings within the array are represented by\n+     * empty strings.</p>\n+     *\n+     * <pre>\n+     * StringUtils.join(null)            = null\n+     * StringUtils.join([])              = \"\"\n+     * StringUtils.join([null])          = \"\"\n+     * StringUtils.join([\"a\", \"b\", \"c\"]) = \"abc\"\n+     * StringUtils.join([null, \"\", \"a\"]) = \"a\"\n+     * </pre>\n+     *\n+     * @param array  the array of values to join together, may be null\n+     * @return the joined String, <code>null</code> if null array input\n+     * @since 2.0\n+     */\n+    public static String join(Object[] array) {\n+        return join(array, null);\n+    }\n+\n+    /**\n+     * <p>Joins the elements of the provided array into a single String\n+     * containing the provided list of elements.</p>\n+     *\n+     * <p>No delimiter is added before or after the list.\n+     * Null objects or empty strings within the array are represented by\n+     * empty strings.</p>\n+     *\n+     * <pre>\n+     * StringUtils.join(null, *)               = null\n+     * StringUtils.join([], *)                 = \"\"\n+     * StringUtils.join([null], *)             = \"\"\n+     * StringUtils.join([\"a\", \"b\", \"c\"], ';')  = \"a;b;c\"\n+     * StringUtils.join([\"a\", \"b\", \"c\"], null) = \"abc\"\n+     * StringUtils.join([null, \"\", \"a\"], ';')  = \";;a\"\n+     * </pre>\n+     *\n+     * @param array  the array of values to join together, may be null\n+     * @param separator  the separator character to use\n+     * @return the joined String, <code>null</code> if null array input\n+     * @since 2.0\n+     */\n+    public static String join(Object[] array, char separator) {\n+        if (array == null) {\n+            return null;\n+        }\n+\n+        return join(array, separator, 0, array.length);\n+    }\n+\n+    /**\n+     * <p>Joins the elements of the provided array into a single String\n+     * containing the provided list of elements.</p>\n+     *\n+     * <p>No delimiter is added before or after the list.\n+     * Null objects or empty strings within the array are represented by\n+     * empty strings.</p>\n+     *\n+     * <pre>\n+     * StringUtils.join(null, *)               = null\n+     * StringUtils.join([], *)                 = \"\"\n+     * StringUtils.join([null], *)             = \"\"\n+     * StringUtils.join([\"a\", \"b\", \"c\"], ';')  = \"a;b;c\"\n+     * StringUtils.join([\"a\", \"b\", \"c\"], null) = \"abc\"\n+     * StringUtils.join([null, \"\", \"a\"], ';')  = \";;a\"\n+     * </pre>\n+     *\n+     * @param array  the array of values to join together, may be null\n+     * @param separator  the separator character to use\n+     * @param startIndex the first index to start joining from.  It is\n+     * an error to pass in an end index past the end of the array\n+     * @param endIndex the index to stop joining from (exclusive). It is\n+     * an error to pass in an end index past the end of the array\n+     * @return the joined String, <code>null</code> if null array input\n+     * @since 2.0\n+     */\n+    public static String join(Object[] array, char separator, int startIndex, int endIndex) {\n+        if (array == null) {\n+            return null;\n+        }\n+        int bufSize = (endIndex - startIndex);\n+        if (bufSize <= 0) {\n+            return EMPTY;\n+        }\n+\n+        bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);\n+        StringBuilder buf = new StringBuilder(bufSize);\n+\n+        for (int i = startIndex; i < endIndex; i++) {\n+            if (i > startIndex) {\n+                buf.append(separator);\n+            }\n+            if (array[i] != null) {\n+                buf.append(array[i]);\n+            }\n+        }\n+        return buf.toString();\n+    }\n+\n+\n+    /**\n+     * <p>Joins the elements of the provided array into a single String\n+     * containing the provided list of elements.</p>\n+     *\n+     * <p>No delimiter is added before or after the list.\n+     * A <code>null</code> separator is the same as an empty String (\"\").\n+     * Null objects or empty strings within the array are represented by\n+     * empty strings.</p>\n+     *\n+     * <pre>\n+     * StringUtils.join(null, *)                = null\n+     * StringUtils.join([], *)                  = \"\"\n+     * StringUtils.join([null], *)              = \"\"\n+     * StringUtils.join([\"a\", \"b\", \"c\"], \"--\")  = \"a--b--c\"\n+     * StringUtils.join([\"a\", \"b\", \"c\"], null)  = \"abc\"\n+     * StringUtils.join([\"a\", \"b\", \"c\"], \"\")    = \"abc\"\n+     * StringUtils.join([null, \"\", \"a\"], ',')   = \",,a\"\n+     * </pre>\n+     *\n+     * @param array  the array of values to join together, may be null\n+     * @param separator  the separator character to use, null treated as \"\"\n+     * @return the joined String, <code>null</code> if null array input\n+     */\n+    public static String join(Object[] array, String separator) {\n+        if (array == null) {\n+            return null;\n+        }\n+        return join(array, separator, 0, array.length);\n+    }\n+\n+    /**\n+     * <p>Joins the elements of the provided array into a single String\n+     * containing the provided list of elements.</p>\n+     *\n+     * <p>No delimiter is added before or after the list.\n+     * A <code>null</code> separator is the same as an empty String (\"\").\n+     * Null objects or empty strings within the array are represented by\n+     * empty strings.</p>\n+     *\n+     * <pre>\n+     * StringUtils.join(null, *)                = null\n+     * StringUtils.join([], *)                  = \"\"\n+     * StringUtils.join([null], *)              = \"\"\n+     * StringUtils.join([\"a\", \"b\", \"c\"], \"--\")  = \"a--b--c\"\n+     * StringUtils.join([\"a\", \"b\", \"c\"], null)  = \"abc\"\n+     * StringUtils.join([\"a\", \"b\", \"c\"], \"\")    = \"abc\"\n+     * StringUtils.join([null, \"\", \"a\"], ',')   = \",,a\"\n+     * </pre>\n+     *\n+     * @param array  the array of values to join together, may be null\n+     * @param separator  the separator character to use, null treated as \"\"\n+     * @param startIndex the first index to start joining from.  It is\n+     * an error to pass in an end index past the end of the array\n+     * @param endIndex the index to stop joining from (exclusive). It is\n+     * an error to pass in an end index past the end of the array\n+     * @return the joined String, <code>null</code> if null array input\n+     */\n+    public static String join(Object[] array, String separator, int startIndex, int endIndex) {\n+        if (array == null) {\n+            return null;\n+        }\n+        if (separator == null) {\n+            separator = EMPTY;\n+        }\n+\n+        // endIndex - startIndex > 0:   Len = NofStrings *(len(firstString) + len(separator))\n+        //           (Assuming that all Strings are roughly equally long)\n+        int bufSize = (endIndex - startIndex);\n+        if (bufSize <= 0) {\n+            return EMPTY;\n+        }\n+\n+        bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length())\n+                        + separator.length());\n+\n+        StringBuilder buf = new StringBuilder(bufSize);\n+\n+        for (int i = startIndex; i < endIndex; i++) {\n+            if (i > startIndex) {\n+                buf.append(separator);\n+            }\n+            if (array[i] != null) {\n+                buf.append(array[i]);\n+            }\n+        }\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * <p>Joins the elements of the provided <code>Iterator</code> into\n+     * a single String containing the provided elements.</p>\n+     *\n+     * <p>No delimiter is added before or after the list. Null objects or empty\n+     * strings within the iteration are represented by empty strings.</p>\n+     *\n+     * <p>See the examples here: {@link #join(Object[],char)}. </p>\n+     *\n+     * @param iterator  the <code>Iterator</code> of values to join together, may be null\n+     * @param separator  the separator character to use\n+     * @return the joined String, <code>null</code> if null iterator input\n+     * @since 2.0\n+     */\n+    public static String join(Iterator<?> iterator, char separator) {\n+\n+        // handle null, zero and one elements before building a buffer\n+        if (iterator == null) {\n+            return null;\n+        }\n+        if (!iterator.hasNext()) {\n+            return EMPTY;\n+        }\n+        Object first = iterator.next();\n+        if (!iterator.hasNext()) {\n+            return ObjectUtils.toString(first);\n+        }\n+\n+        // two or more elements\n+        StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small\n+        if (first != null) {\n+            buf.append(first);\n+        }\n+\n+        while (iterator.hasNext()) {\n+            buf.append(separator);\n+            Object obj = iterator.next();\n+            if (obj != null) {\n+                buf.append(obj);\n+            }\n+        }\n+\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * <p>Joins the elements of the provided <code>Iterator</code> into\n+     * a single String containing the provided elements.</p>\n+     *\n+     * <p>No delimiter is added before or after the list.\n+     * A <code>null</code> separator is the same as an empty String (\"\").</p>\n+     *\n+     * <p>See the examples here: {@link #join(Object[],String)}. </p>\n+     *\n+     * @param iterator  the <code>Iterator</code> of values to join together, may be null\n+     * @param separator  the separator character to use, null treated as \"\"\n+     * @return the joined String, <code>null</code> if null iterator input\n+     */\n+    public static String join(Iterator<?> iterator, String separator) {\n+\n+        // handle null, zero and one elements before building a buffer\n+        if (iterator == null) {\n+            return null;\n+        }\n+        if (!iterator.hasNext()) {\n+            return EMPTY;\n+        }\n+        Object first = iterator.next();\n+        if (!iterator.hasNext()) {\n+            return ObjectUtils.toString(first);\n+        }\n+\n+        // two or more elements\n+        StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small\n+        if (first != null) {\n+            buf.append(first);\n+        }\n+\n+        while (iterator.hasNext()) {\n+            if (separator != null) {\n+                buf.append(separator);\n+            }\n+            Object obj = iterator.next();\n+            if (obj != null) {\n+                buf.append(obj);\n+            }\n+        }\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * <p>Joins the elements of the provided <code>Iterable</code> into\n+     * a single String containing the provided elements.</p>\n+     *\n+     * <p>No delimiter is added before or after the list. Null objects or empty\n+     * strings within the iteration are represented by empty strings.</p>\n+     *\n+     * <p>See the examples here: {@link #join(Object[],char)}. </p>\n+     *\n+     * @param iterable  the <code>Iterable</code> providing the values to join together, may be null\n+     * @param separator  the separator character to use\n+     * @return the joined String, <code>null</code> if null iterator input\n+     * @since 2.3\n+     */\n+    public static String join(Iterable<?> iterable, char separator) {\n+        if (iterable == null) {\n+            return null;\n+        }\n+        return join(iterable.iterator(), separator);\n+    }\n+\n+    /**\n+     * <p>Joins the elements of the provided <code>Iterable</code> into\n+     * a single String containing the provided elements.</p>\n+     *\n+     * <p>No delimiter is added before or after the list.\n+     * A <code>null</code> separator is the same as an empty String (\"\").</p>\n+     *\n+     * <p>See the examples here: {@link #join(Object[],String)}. </p>\n+     *\n+     * @param iterable  the <code>Iterable</code> providing the values to join together, may be null\n+     * @param separator  the separator character to use, null treated as \"\"\n+     * @return the joined String, <code>null</code> if null iterator input\n+     * @since 2.3\n+     */\n+    public static String join(Iterable<?> iterable, String separator) {\n+        if (iterable == null) {\n+            return null;\n+        }\n+        return join(iterable.iterator(), separator);\n+    }\n+\n+    // Delete\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Deletes all whitespaces from a String as defined by\n+     * {@link Character#isWhitespace(char)}.</p>\n+     *\n+     * <pre>\n+     * StringUtils.deleteWhitespace(null)         = null\n+     * StringUtils.deleteWhitespace(\"\")           = \"\"\n+     * StringUtils.deleteWhitespace(\"abc\")        = \"abc\"\n+     * StringUtils.deleteWhitespace(\"   ab  c  \") = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String to delete whitespace from, may be null\n+     * @return the String without whitespaces, <code>null</code> if null String input\n+     */\n+    public static String deleteWhitespace(String str) {\n+        if (isEmpty(str)) {\n+            return str;\n+        }\n+        int sz = str.length();\n+        char[] chs = new char[sz];\n+        int count = 0;\n+        for (int i = 0; i < sz; i++) {\n+            if (!Character.isWhitespace(str.charAt(i))) {\n+                chs[count++] = str.charAt(i);\n+            }\n+        }\n+        if (count == sz) {\n+            return str;\n+        }\n+        return new String(chs, 0, count);\n+    }\n+\n+    // Remove\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Removes a substring only if it is at the begining of a source string,\n+     * otherwise returns the source string.</p>\n+     *\n+     * <p>A <code>null</code> source string will return <code>null</code>.\n+     * An empty (\"\") source string will return the empty string.\n+     * A <code>null</code> search string will return the source string.</p>\n+     *\n+     * <pre>\n+     * StringUtils.removeStart(null, *)      = null\n+     * StringUtils.removeStart(\"\", *)        = \"\"\n+     * StringUtils.removeStart(*, null)      = *\n+     * StringUtils.removeStart(\"www.domain.com\", \"www.\")   = \"domain.com\"\n+     * StringUtils.removeStart(\"domain.com\", \"www.\")       = \"domain.com\"\n+     * StringUtils.removeStart(\"www.domain.com\", \"domain\") = \"www.domain.com\"\n+     * StringUtils.removeStart(\"abc\", \"\")    = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the source String to search, may be null\n+     * @param remove  the String to search for and remove, may be null\n+     * @return the substring with the string removed if found,\n+     *  <code>null</code> if null String input\n+     * @since 2.1\n+     */\n+    public static String removeStart(String str, String remove) {\n+        if (isEmpty(str) || isEmpty(remove)) {\n+            return str;\n+        }\n+        if (str.startsWith(remove)){\n+            return str.substring(remove.length());\n+        }\n+        return str;\n+    }\n+\n+    /**\n+     * <p>Case insensitive removal of a substring if it is at the begining of a source string,\n+     * otherwise returns the source string.</p>\n+     *\n+     * <p>A <code>null</code> source string will return <code>null</code>.\n+     * An empty (\"\") source string will return the empty string.\n+     * A <code>null</code> search string will return the source string.</p>\n+     *\n+     * <pre>\n+     * StringUtils.removeStartIgnoreCase(null, *)      = null\n+     * StringUtils.removeStartIgnoreCase(\"\", *)        = \"\"\n+     * StringUtils.removeStartIgnoreCase(*, null)      = *\n+     * StringUtils.removeStartIgnoreCase(\"www.domain.com\", \"www.\")   = \"domain.com\"\n+     * StringUtils.removeStartIgnoreCase(\"www.domain.com\", \"WWW.\")   = \"domain.com\"\n+     * StringUtils.removeStartIgnoreCase(\"domain.com\", \"www.\")       = \"domain.com\"\n+     * StringUtils.removeStartIgnoreCase(\"www.domain.com\", \"domain\") = \"www.domain.com\"\n+     * StringUtils.removeStartIgnoreCase(\"abc\", \"\")    = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the source String to search, may be null\n+     * @param remove  the String to search for (case insensitive) and remove, may be null\n+     * @return the substring with the string removed if found,\n+     *  <code>null</code> if null String input\n+     * @since 2.4\n+     */\n+    public static String removeStartIgnoreCase(String str, String remove) {\n+        if (isEmpty(str) || isEmpty(remove)) {\n+            return str;\n+        }\n+        if (startsWithIgnoreCase(str, remove)) {\n+            return str.substring(remove.length());\n+        }\n+        return str;\n+    }\n+\n+    /**\n+     * <p>Removes a substring only if it is at the end of a source string,\n+     * otherwise returns the source string.</p>\n+     *\n+     * <p>A <code>null</code> source string will return <code>null</code>.\n+     * An empty (\"\") source string will return the empty string.\n+     * A <code>null</code> search string will return the source string.</p>\n+     *\n+     * <pre>\n+     * StringUtils.removeEnd(null, *)      = null\n+     * StringUtils.removeEnd(\"\", *)        = \"\"\n+     * StringUtils.removeEnd(*, null)      = *\n+     * StringUtils.removeEnd(\"www.domain.com\", \".com.\")  = \"www.domain.com\"\n+     * StringUtils.removeEnd(\"www.domain.com\", \".com\")   = \"www.domain\"\n+     * StringUtils.removeEnd(\"www.domain.com\", \"domain\") = \"www.domain.com\"\n+     * StringUtils.removeEnd(\"abc\", \"\")    = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the source String to search, may be null\n+     * @param remove  the String to search for and remove, may be null\n+     * @return the substring with the string removed if found,\n+     *  <code>null</code> if null String input\n+     * @since 2.1\n+     */\n+    public static String removeEnd(String str, String remove) {\n+        if (isEmpty(str) || isEmpty(remove)) {\n+            return str;\n+        }\n+        if (str.endsWith(remove)) {\n+            return str.substring(0, str.length() - remove.length());\n+        }\n+        return str;\n+    }\n+\n+    /**\n+     * <p>Case insensitive removal of a substring if it is at the end of a source string,\n+     * otherwise returns the source string.</p>\n+     *\n+     * <p>A <code>null</code> source string will return <code>null</code>.\n+     * An empty (\"\") source string will return the empty string.\n+     * A <code>null</code> search string will return the source string.</p>\n+     *\n+     * <pre>\n+     * StringUtils.removeEnd(null, *)      = null\n+     * StringUtils.removeEnd(\"\", *)        = \"\"\n+     * StringUtils.removeEnd(*, null)      = *\n+     * StringUtils.removeEnd(\"www.domain.com\", \".com.\")  = \"www.domain.com.\"\n+     * StringUtils.removeEnd(\"www.domain.com\", \".com\")   = \"www.domain\"\n+     * StringUtils.removeEnd(\"www.domain.com\", \"domain\") = \"www.domain.com\"\n+     * StringUtils.removeEnd(\"abc\", \"\")    = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the source String to search, may be null\n+     * @param remove  the String to search for (case insensitive) and remove, may be null\n+     * @return the substring with the string removed if found,\n+     *  <code>null</code> if null String input\n+     * @since 2.4\n+     */\n+    public static String removeEndIgnoreCase(String str, String remove) {\n+        if (isEmpty(str) || isEmpty(remove)) {\n+            return str;\n+        }\n+        if (endsWithIgnoreCase(str, remove)) {\n+            return str.substring(0, str.length() - remove.length());\n+        }\n+        return str;\n+    }\n+\n+    /**\n+     * <p>Removes all occurrences of a substring from within the source string.</p>\n+     *\n+     * <p>A <code>null</code> source string will return <code>null</code>.\n+     * An empty (\"\") source string will return the empty string.\n+     * A <code>null</code> remove string will return the source string.\n+     * An empty (\"\") remove string will return the source string.</p>\n+     *\n+     * <pre>\n+     * StringUtils.remove(null, *)        = null\n+     * StringUtils.remove(\"\", *)          = \"\"\n+     * StringUtils.remove(*, null)        = *\n+     * StringUtils.remove(*, \"\")          = *\n+     * StringUtils.remove(\"queued\", \"ue\") = \"qd\"\n+     * StringUtils.remove(\"queued\", \"zz\") = \"queued\"\n+     * </pre>\n+     *\n+     * @param str  the source String to search, may be null\n+     * @param remove  the String to search for and remove, may be null\n+     * @return the substring with the string removed if found,\n+     *  <code>null</code> if null String input\n+     * @since 2.1\n+     */\n+    public static String remove(String str, String remove) {\n+        if (isEmpty(str) || isEmpty(remove)) {\n+            return str;\n+        }\n+        return replace(str, remove, EMPTY, -1);\n+    }\n+\n+    /**\n+     * <p>Removes all occurrences of a character from within the source string.</p>\n+     *\n+     * <p>A <code>null</code> source string will return <code>null</code>.\n+     * An empty (\"\") source string will return the empty string.</p>\n+     *\n+     * <pre>\n+     * StringUtils.remove(null, *)       = null\n+     * StringUtils.remove(\"\", *)         = \"\"\n+     * StringUtils.remove(\"queued\", 'u') = \"qeed\"\n+     * StringUtils.remove(\"queued\", 'z') = \"queued\"\n+     * </pre>\n+     *\n+     * @param str  the source String to search, may be null\n+     * @param remove  the char to search for and remove, may be null\n+     * @return the substring with the char removed if found,\n+     *  <code>null</code> if null String input\n+     * @since 2.1\n+     */\n+    public static String remove(String str, char remove) {\n+        if (isEmpty(str) || str.indexOf(remove) == -1) {\n+            return str;\n+        }\n+        char[] chars = str.toCharArray();\n+        int pos = 0;\n+        for (int i = 0; i < chars.length; i++) {\n+            if (chars[i] != remove) {\n+                chars[pos++] = chars[i];\n+            }\n+        }\n+        return new String(chars, 0, pos);\n+    }\n+\n+    // Replacing\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Replaces a String with another String inside a larger String, once.</p>\n+     *\n+     * <p>A <code>null</code> reference passed to this method is a no-op.</p>\n+     *\n+     * <pre>\n+     * StringUtils.replaceOnce(null, *, *)        = null\n+     * StringUtils.replaceOnce(\"\", *, *)          = \"\"\n+     * StringUtils.replaceOnce(\"any\", null, *)    = \"any\"\n+     * StringUtils.replaceOnce(\"any\", *, null)    = \"any\"\n+     * StringUtils.replaceOnce(\"any\", \"\", *)      = \"any\"\n+     * StringUtils.replaceOnce(\"aba\", \"a\", null)  = \"aba\"\n+     * StringUtils.replaceOnce(\"aba\", \"a\", \"\")    = \"ba\"\n+     * StringUtils.replaceOnce(\"aba\", \"a\", \"z\")   = \"zba\"\n+     * </pre>\n+     *\n+     * @see #replace(String text, String searchString, String replacement, int max)\n+     * @param text  text to search and replace in, may be null\n+     * @param searchString  the String to search for, may be null\n+     * @param replacement  the String to replace with, may be null\n+     * @return the text with any replacements processed,\n+     *  <code>null</code> if null String input\n+     */\n+    public static String replaceOnce(String text, String searchString, String replacement) {\n+        return replace(text, searchString, replacement, 1);\n+    }\n+\n+    /**\n+     * <p>Replaces all occurrences of a String within another String.</p>\n+     *\n+     * <p>A <code>null</code> reference passed to this method is a no-op.</p>\n+     *\n+     * <pre>\n+     * StringUtils.replace(null, *, *)        = null\n+     * StringUtils.replace(\"\", *, *)          = \"\"\n+     * StringUtils.replace(\"any\", null, *)    = \"any\"\n+     * StringUtils.replace(\"any\", *, null)    = \"any\"\n+     * StringUtils.replace(\"any\", \"\", *)      = \"any\"\n+     * StringUtils.replace(\"aba\", \"a\", null)  = \"aba\"\n+     * StringUtils.replace(\"aba\", \"a\", \"\")    = \"b\"\n+     * StringUtils.replace(\"aba\", \"a\", \"z\")   = \"zbz\"\n+     * </pre>\n+     *\n+     * @see #replace(String text, String searchString, String replacement, int max)\n+     * @param text  text to search and replace in, may be null\n+     * @param searchString  the String to search for, may be null\n+     * @param replacement  the String to replace it with, may be null\n+     * @return the text with any replacements processed,\n+     *  <code>null</code> if null String input\n+     */\n+    public static String replace(String text, String searchString, String replacement) {\n+        return replace(text, searchString, replacement, -1);\n+    }\n+\n+    /**\n+     * <p>Replaces a String with another String inside a larger String,\n+     * for the first <code>max</code> values of the search String.</p>\n+     *\n+     * <p>A <code>null</code> reference passed to this method is a no-op.</p>\n+     *\n+     * <pre>\n+     * StringUtils.replace(null, *, *, *)         = null\n+     * StringUtils.replace(\"\", *, *, *)           = \"\"\n+     * StringUtils.replace(\"any\", null, *, *)     = \"any\"\n+     * StringUtils.replace(\"any\", *, null, *)     = \"any\"\n+     * StringUtils.replace(\"any\", \"\", *, *)       = \"any\"\n+     * StringUtils.replace(\"any\", *, *, 0)        = \"any\"\n+     * StringUtils.replace(\"abaa\", \"a\", null, -1) = \"abaa\"\n+     * StringUtils.replace(\"abaa\", \"a\", \"\", -1)   = \"b\"\n+     * StringUtils.replace(\"abaa\", \"a\", \"z\", 0)   = \"abaa\"\n+     * StringUtils.replace(\"abaa\", \"a\", \"z\", 1)   = \"zbaa\"\n+     * StringUtils.replace(\"abaa\", \"a\", \"z\", 2)   = \"zbza\"\n+     * StringUtils.replace(\"abaa\", \"a\", \"z\", -1)  = \"zbzz\"\n+     * </pre>\n+     *\n+     * @param text  text to search and replace in, may be null\n+     * @param searchString  the String to search for, may be null\n+     * @param replacement  the String to replace it with, may be null\n+     * @param max  maximum number of values to replace, or <code>-1</code> if no maximum\n+     * @return the text with any replacements processed,\n+     *  <code>null</code> if null String input\n+     */\n+    public static String replace(String text, String searchString, String replacement, int max) {\n+        if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {\n+            return text;\n+        }\n+        int start = 0;\n+        int end = text.indexOf(searchString, start);\n+        if (end == -1) {\n+            return text;\n+        }\n+        int replLength = searchString.length();\n+        int increase = replacement.length() - replLength;\n+        increase = (increase < 0 ? 0 : increase);\n+        increase *= (max < 0 ? 16 : (max > 64 ? 64 : max));\n+        StringBuilder buf = new StringBuilder(text.length() + increase);\n+        while (end != -1) {\n+            buf.append(text.substring(start, end)).append(replacement);\n+            start = end + replLength;\n+            if (--max == 0) {\n+                break;\n+            }\n+            end = text.indexOf(searchString, start);\n+        }\n+        buf.append(text.substring(start));\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * <p>\n+     * Replaces all occurrences of Strings within another String.\n+     * </p>\n+     * \n+     * <p>\n+     * A <code>null</code> reference passed to this method is a no-op, or if\n+     * any \"search string\" or \"string to replace\" is null, that replace will be\n+     * ignored. This will not repeat. For repeating replaces, call the\n+     * overloaded method.\n+     * </p>\n+     * \n+     * <pre>\n+     *  StringUtils.replaceEach(null, *, *)        = null\n+     *  StringUtils.replaceEach(\"\", *, *)          = \"\"\n+     *  StringUtils.replaceEach(\"aba\", null, null) = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", new String[0], null) = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", null, new String[0]) = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null)  = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"})  = \"b\"\n+     *  StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"})  = \"aba\"\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"})  = \"wcte\"\n+     *  (example of how it does not repeat)\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"})  = \"dcte\"\n+     * </pre>\n+     * \n+     * @param text\n+     *            text to search and replace in, no-op if null\n+     * @param searchList\n+     *            the Strings to search for, no-op if null\n+     * @param replacementList\n+     *            the Strings to replace them with, no-op if null\n+     * @return the text with any replacements processed, <code>null</code> if\n+     *         null String input\n+     * @throws IndexOutOfBoundsException\n+     *             if the lengths of the arrays are not the same (null is ok,\n+     *             and/or size 0)\n+     * @since 2.4\n+     */\n+    public static String replaceEach(String text, String[] searchList, String[] replacementList) {\n+        return replaceEach(text, searchList, replacementList, false, 0);\n+    }\n+\n+    /**\n+     * <p>\n+     * Replaces all occurrences of Strings within another String.\n+     * </p>\n+     * \n+     * <p>\n+     * A <code>null</code> reference passed to this method is a no-op, or if\n+     * any \"search string\" or \"string to replace\" is null, that replace will be\n+     * ignored. This will not repeat. For repeating replaces, call the\n+     * overloaded method.\n+     * </p>\n+     * \n+     * <pre>\n+     *  StringUtils.replaceEach(null, *, *, *) = null\n+     *  StringUtils.replaceEach(\"\", *, *, *) = \"\"\n+     *  StringUtils.replaceEach(\"aba\", null, null, *) = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", new String[0], null, *) = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", null, new String[0], *) = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *) = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *) = \"b\"\n+     *  StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *) = \"aba\"\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *) = \"wcte\"\n+     *  (example of how it repeats)\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false) = \"dcte\"\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true) = \"tcte\"\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, true) = IllegalArgumentException\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, false) = \"dcabe\"\n+     * </pre>\n+     * \n+     * @param text\n+     *            text to search and replace in, no-op if null\n+     * @param searchList\n+     *            the Strings to search for, no-op if null\n+     * @param replacementList\n+     *            the Strings to replace them with, no-op if null\n+     * @return the text with any replacements processed, <code>null</code> if\n+     *         null String input\n+     * @throws IllegalArgumentException\n+     *             if the search is repeating and there is an endless loop due\n+     *             to outputs of one being inputs to another\n+     * @throws IndexOutOfBoundsException\n+     *             if the lengths of the arrays are not the same (null is ok,\n+     *             and/or size 0)\n+     * @since 2.4\n+     */\n+    public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) {\n+        // timeToLive should be 0 if not used or nothing to replace, else it's\n+        // the length of the replace array\n+        int timeToLive = searchList == null ? 0 : searchList.length;\n+        return replaceEach(text, searchList, replacementList, true, timeToLive);\n+    }\n+\n+    /**\n+     * <p>\n+     * Replaces all occurrences of Strings within another String.\n+     * </p>\n+     * \n+     * <p>\n+     * A <code>null</code> reference passed to this method is a no-op, or if\n+     * any \"search string\" or \"string to replace\" is null, that replace will be\n+     * ignored. \n+     * </p>\n+     * \n+     * <pre>\n+     *  StringUtils.replaceEach(null, *, *, *) = null\n+     *  StringUtils.replaceEach(\"\", *, *, *) = \"\"\n+     *  StringUtils.replaceEach(\"aba\", null, null, *) = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", new String[0], null, *) = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", null, new String[0], *) = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, null, *) = \"aba\"\n+     *  StringUtils.replaceEach(\"aba\", new String[]{\"a\"}, new String[]{\"\"}, *) = \"b\"\n+     *  StringUtils.replaceEach(\"aba\", new String[]{null}, new String[]{\"a\"}, *) = \"aba\"\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"w\", \"t\"}, *) = \"wcte\"\n+     *  (example of how it repeats)\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, false) = \"dcte\"\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true) = \"tcte\"\n+     *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *) = IllegalArgumentException\n+     * </pre>\n+     * \n+     * @param text\n+     *            text to search and replace in, no-op if null\n+     * @param searchList\n+     *            the Strings to search for, no-op if null\n+     * @param replacementList\n+     *            the Strings to replace them with, no-op if null\n+     * @param repeat if true, then replace repeatedly \n+     *       until there are no more possible replacements or timeToLive < 0\n+     * @param timeToLive\n+     *            if less than 0 then there is a circular reference and endless\n+     *            loop\n+     * @return the text with any replacements processed, <code>null</code> if\n+     *         null String input\n+     * @throws IllegalArgumentException\n+     *             if the search is repeating and there is an endless loop due\n+     *             to outputs of one being inputs to another\n+     * @throws IndexOutOfBoundsException\n+     *             if the lengths of the arrays are not the same (null is ok,\n+     *             and/or size 0)\n+     * @since 2.4\n+     */\n+    private static String replaceEach(String text, String[] searchList, String[] replacementList, \n+                                      boolean repeat, int timeToLive) \n+    {\n+\n+        // mchyzer Performance note: This creates very few new objects (one major goal)\n+        // let me know if there are performance requests, we can create a harness to measure\n+\n+        if (text == null || text.length() == 0 || searchList == null || \n+            searchList.length == 0 || replacementList == null || replacementList.length == 0) \n+        {\n+            return text;\n+        }\n+\n+        // if recursing, this shouldnt be less than 0\n+        if (timeToLive < 0) {\n+            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n+        }\n+\n+        int searchLength = searchList.length;\n+        int replacementLength = replacementList.length;\n+\n+        // make sure lengths are ok, these need to be equal\n+        if (searchLength != replacementLength) {\n+            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n+                + searchLength\n+                + \" vs \"\n+                + replacementLength);\n+        }\n+\n+        // keep track of which still have matches\n+        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n+\n+        // index on index that the match was found\n+        int textIndex = -1;\n+        int replaceIndex = -1;\n+        int tempIndex = -1;\n+\n+        // index of replace array that will replace the search string found\n+        // NOTE: logic duplicated below START\n+        for (int i = 0; i < searchLength; i++) {\n+            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n+                searchList[i].length() == 0 || replacementList[i] == null) \n+            {\n+                continue;\n+            }\n+            tempIndex = text.indexOf(searchList[i]);\n+\n+            // see if we need to keep searching for this\n+            if (tempIndex == -1) {\n+                noMoreMatchesForReplIndex[i] = true;\n+            } else {\n+                if (textIndex == -1 || tempIndex < textIndex) {\n+                    textIndex = tempIndex;\n+                    replaceIndex = i;\n+                }\n+            }\n+        }\n+        // NOTE: logic mostly below END\n+\n+        // no search strings found, we are done\n+        if (textIndex == -1) {\n+            return text;\n+        }\n+\n+        int start = 0;\n+\n+        // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n+        int increase = 0;\n+\n+        // count the replacement text elements that are larger than their corresponding text being replaced\n+        for (int i = 0; i < searchList.length; i++) {\n+            if (searchList[i] == null || replacementList[i] == null) {\n+                continue;\n+            }\n+            int greater = replacementList[i].length() - searchList[i].length();\n+            if (greater > 0) {\n+                increase += 3 * greater; // assume 3 matches\n+            }\n+        }\n+        // have upper-bound at 20% increase, then let Java take over\n+        increase = Math.min(increase, text.length() / 5);\n+\n+        StringBuilder buf = new StringBuilder(text.length() + increase);\n+\n+        while (textIndex != -1) {\n+\n+            for (int i = start; i < textIndex; i++) {\n+                buf.append(text.charAt(i));\n+            }\n+            buf.append(replacementList[replaceIndex]);\n+\n+            start = textIndex + searchList[replaceIndex].length();\n+\n+            textIndex = -1;\n+            replaceIndex = -1;\n+            tempIndex = -1;\n+            // find the next earliest match\n+            // NOTE: logic mostly duplicated above START\n+            for (int i = 0; i < searchLength; i++) {\n+                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n+                    searchList[i].length() == 0 || replacementList[i] == null) \n+                {\n+                    continue;\n+                }\n+                tempIndex = text.indexOf(searchList[i], start);\n+\n+                // see if we need to keep searching for this\n+                if (tempIndex == -1) {\n+                    noMoreMatchesForReplIndex[i] = true;\n+                } else {\n+                    if (textIndex == -1 || tempIndex < textIndex) {\n+                        textIndex = tempIndex;\n+                        replaceIndex = i;\n+                    }\n+                }\n+            }\n+            // NOTE: logic duplicated above END\n+\n+        }\n+        int textLength = text.length();\n+        for (int i = start; i < textLength; i++) {\n+            buf.append(text.charAt(i));\n+        }\n+        String result = buf.toString();\n+        if (!repeat) {\n+            return result;\n+        }\n+\n+        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n+    }\n+\n+    // Replace, character based\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Replaces all occurrences of a character in a String with another.\n+     * This is a null-safe version of {@link String#replace(char, char)}.</p>\n+     *\n+     * <p>A <code>null</code> string input returns <code>null</code>.\n+     * An empty (\"\") string input returns an empty string.</p>\n+     *\n+     * <pre>\n+     * StringUtils.replaceChars(null, *, *)        = null\n+     * StringUtils.replaceChars(\"\", *, *)          = \"\"\n+     * StringUtils.replaceChars(\"abcba\", 'b', 'y') = \"aycya\"\n+     * StringUtils.replaceChars(\"abcba\", 'z', 'y') = \"abcba\"\n+     * </pre>\n+     *\n+     * @param str  String to replace characters in, may be null\n+     * @param searchChar  the character to search for, may be null\n+     * @param replaceChar  the character to replace, may be null\n+     * @return modified String, <code>null</code> if null string input\n+     * @since 2.0\n+     */\n+    public static String replaceChars(String str, char searchChar, char replaceChar) {\n+        if (str == null) {\n+            return null;\n+        }\n+        return str.replace(searchChar, replaceChar);\n+    }\n+\n+    /**\n+     * <p>Replaces multiple characters in a String in one go.\n+     * This method can also be used to delete characters.</p>\n+     *\n+     * <p>For example:<br />\n+     * <code>replaceChars(&quot;hello&quot;, &quot;ho&quot;, &quot;jy&quot;) = jelly</code>.</p>\n+     *\n+     * <p>A <code>null</code> string input returns <code>null</code>.\n+     * An empty (\"\") string input returns an empty string.\n+     * A null or empty set of search characters returns the input string.</p>\n+     *\n+     * <p>The length of the search characters should normally equal the length\n+     * of the replace characters.\n+     * If the search characters is longer, then the extra search characters\n+     * are deleted.\n+     * If the search characters is shorter, then the extra replace characters\n+     * are ignored.</p>\n+     *\n+     * <pre>\n+     * StringUtils.replaceChars(null, *, *)           = null\n+     * StringUtils.replaceChars(\"\", *, *)             = \"\"\n+     * StringUtils.replaceChars(\"abc\", null, *)       = \"abc\"\n+     * StringUtils.replaceChars(\"abc\", \"\", *)         = \"abc\"\n+     * StringUtils.replaceChars(\"abc\", \"b\", null)     = \"ac\"\n+     * StringUtils.replaceChars(\"abc\", \"b\", \"\")       = \"ac\"\n+     * StringUtils.replaceChars(\"abcba\", \"bc\", \"yz\")  = \"ayzya\"\n+     * StringUtils.replaceChars(\"abcba\", \"bc\", \"y\")   = \"ayya\"\n+     * StringUtils.replaceChars(\"abcba\", \"bc\", \"yzx\") = \"ayzya\"\n+     * </pre>\n+     *\n+     * @param str  String to replace characters in, may be null\n+     * @param searchChars  a set of characters to search for, may be null\n+     * @param replaceChars  a set of characters to replace, may be null\n+     * @return modified String, <code>null</code> if null string input\n+     * @since 2.0\n+     */\n+    public static String replaceChars(String str, String searchChars, String replaceChars) {\n+        if (isEmpty(str) || isEmpty(searchChars)) {\n+            return str;\n+        }\n+        if (replaceChars == null) {\n+            replaceChars = EMPTY;\n+        }\n+        boolean modified = false;\n+        int replaceCharsLength = replaceChars.length();\n+        int strLength = str.length();\n+        StringBuilder buf = new StringBuilder(strLength);\n+        for (int i = 0; i < strLength; i++) {\n+            char ch = str.charAt(i);\n+            int index = searchChars.indexOf(ch);\n+            if (index >= 0) {\n+                modified = true;\n+                if (index < replaceCharsLength) {\n+                    buf.append(replaceChars.charAt(index));\n+                }\n+            } else {\n+                buf.append(ch);\n+            }\n+        }\n+        if (modified) {\n+            return buf.toString();\n+        }\n+        return str;\n+    }\n+\n+    // Overlay\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Overlays part of a String with another String.</p>\n+     *\n+     * <p>A <code>null</code> string input returns <code>null</code>.\n+     * A negative index is treated as zero.\n+     * An index greater than the string length is treated as the string length.\n+     * The start index is always the smaller of the two indices.</p>\n+     *\n+     * <pre>\n+     * StringUtils.overlay(null, *, *, *)            = null\n+     * StringUtils.overlay(\"\", \"abc\", 0, 0)          = \"abc\"\n+     * StringUtils.overlay(\"abcdef\", null, 2, 4)     = \"abef\"\n+     * StringUtils.overlay(\"abcdef\", \"\", 2, 4)       = \"abef\"\n+     * StringUtils.overlay(\"abcdef\", \"\", 4, 2)       = \"abef\"\n+     * StringUtils.overlay(\"abcdef\", \"zzzz\", 2, 4)   = \"abzzzzef\"\n+     * StringUtils.overlay(\"abcdef\", \"zzzz\", 4, 2)   = \"abzzzzef\"\n+     * StringUtils.overlay(\"abcdef\", \"zzzz\", -1, 4)  = \"zzzzef\"\n+     * StringUtils.overlay(\"abcdef\", \"zzzz\", 2, 8)   = \"abzzzz\"\n+     * StringUtils.overlay(\"abcdef\", \"zzzz\", -2, -3) = \"zzzzabcdef\"\n+     * StringUtils.overlay(\"abcdef\", \"zzzz\", 8, 10)  = \"abcdefzzzz\"\n+     * </pre>\n+     *\n+     * @param str  the String to do overlaying in, may be null\n+     * @param overlay  the String to overlay, may be null\n+     * @param start  the position to start overlaying at\n+     * @param end  the position to stop overlaying before\n+     * @return overlayed String, <code>null</code> if null String input\n+     * @since 2.0\n+     */\n+    public static String overlay(String str, String overlay, int start, int end) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (overlay == null) {\n+            overlay = EMPTY;\n+        }\n+        int len = str.length();\n+        if (start < 0) {\n+            start = 0;\n+        }\n+        if (start > len) {\n+            start = len;\n+        }\n+        if (end < 0) {\n+            end = 0;\n+        }\n+        if (end > len) {\n+            end = len;\n+        }\n+        if (start > end) {\n+            int temp = start;\n+            start = end;\n+            end = temp;\n+        }\n+        return new StringBuilder(len + start - end + overlay.length() + 1)\n+            .append(str.substring(0, start))\n+            .append(overlay)\n+            .append(str.substring(end))\n+            .toString();\n+    }\n+\n+    // Chomping\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Removes one newline from end of a String if it's there,\n+     * otherwise leave it alone.  A newline is &quot;<code>\\n</code>&quot;,\n+     * &quot;<code>\\r</code>&quot;, or &quot;<code>\\r\\n</code>&quot;.</p>\n+     *\n+     * <p>NOTE: This method changed in 2.0.\n+     * It now more closely matches Perl chomp.</p>\n+     *\n+     * <pre>\n+     * StringUtils.chomp(null)          = null\n+     * StringUtils.chomp(\"\")            = \"\"\n+     * StringUtils.chomp(\"abc \\r\")      = \"abc \"\n+     * StringUtils.chomp(\"abc\\n\")       = \"abc\"\n+     * StringUtils.chomp(\"abc\\r\\n\")     = \"abc\"\n+     * StringUtils.chomp(\"abc\\r\\n\\r\\n\") = \"abc\\r\\n\"\n+     * StringUtils.chomp(\"abc\\n\\r\")     = \"abc\\n\"\n+     * StringUtils.chomp(\"abc\\n\\rabc\")  = \"abc\\n\\rabc\"\n+     * StringUtils.chomp(\"\\r\")          = \"\"\n+     * StringUtils.chomp(\"\\n\")          = \"\"\n+     * StringUtils.chomp(\"\\r\\n\")        = \"\"\n+     * </pre>\n+     *\n+     * @param str  the String to chomp a newline from, may be null\n+     * @return String without newline, <code>null</code> if null String input\n+     */\n+    public static String chomp(String str) {\n+        if (isEmpty(str)) {\n+            return str;\n+        }\n+\n+        if (str.length() == 1) {\n+            char ch = str.charAt(0);\n+            if (ch == CharUtils.CR || ch == CharUtils.LF) {\n+                return EMPTY;\n+            }\n+            return str;\n+        }\n+\n+        int lastIdx = str.length() - 1;\n+        char last = str.charAt(lastIdx);\n+\n+        if (last == CharUtils.LF) {\n+            if (str.charAt(lastIdx - 1) == CharUtils.CR) {\n+                lastIdx--;\n+            }\n+        } else if (last != CharUtils.CR) {\n+            lastIdx++;\n+        }\n+        return str.substring(0, lastIdx);\n+    }\n+\n+    /**\n+     * <p>Removes <code>separator</code> from the end of\n+     * <code>str</code> if it's there, otherwise leave it alone.</p>\n+     *\n+     * <p>NOTE: This method changed in version 2.0.\n+     * It now more closely matches Perl chomp.\n+     * For the previous behavior, use {@link #substringBeforeLast(String, String)}.\n+     * This method uses {@link String#endsWith(String)}.</p>\n+     *\n+     * <pre>\n+     * StringUtils.chomp(null, *)         = null\n+     * StringUtils.chomp(\"\", *)           = \"\"\n+     * StringUtils.chomp(\"foobar\", \"bar\") = \"foo\"\n+     * StringUtils.chomp(\"foobar\", \"baz\") = \"foobar\"\n+     * StringUtils.chomp(\"foo\", \"foo\")    = \"\"\n+     * StringUtils.chomp(\"foo \", \"foo\")   = \"foo \"\n+     * StringUtils.chomp(\" foo\", \"foo\")   = \" \"\n+     * StringUtils.chomp(\"foo\", \"foooo\")  = \"foo\"\n+     * StringUtils.chomp(\"foo\", \"\")       = \"foo\"\n+     * StringUtils.chomp(\"foo\", null)     = \"foo\"\n+     * </pre>\n+     *\n+     * @param str  the String to chomp from, may be null\n+     * @param separator  separator String, may be null\n+     * @return String without trailing separator, <code>null</code> if null String input\n+     */\n+    public static String chomp(String str, String separator) {\n+        if (isEmpty(str) || separator == null) {\n+            return str;\n+        }\n+        if (str.endsWith(separator)) {\n+            return str.substring(0, str.length() - separator.length());\n+        }\n+        return str;\n+    }\n+\n+    // Chopping\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Remove the last character from a String.</p>\n+     *\n+     * <p>If the String ends in <code>\\r\\n</code>, then remove both\n+     * of them.</p>\n+     *\n+     * <pre>\n+     * StringUtils.chop(null)          = null\n+     * StringUtils.chop(\"\")            = \"\"\n+     * StringUtils.chop(\"abc \\r\")      = \"abc \"\n+     * StringUtils.chop(\"abc\\n\")       = \"abc\"\n+     * StringUtils.chop(\"abc\\r\\n\")     = \"abc\"\n+     * StringUtils.chop(\"abc\")         = \"ab\"\n+     * StringUtils.chop(\"abc\\nabc\")    = \"abc\\nab\"\n+     * StringUtils.chop(\"a\")           = \"\"\n+     * StringUtils.chop(\"\\r\")          = \"\"\n+     * StringUtils.chop(\"\\n\")          = \"\"\n+     * StringUtils.chop(\"\\r\\n\")        = \"\"\n+     * </pre>\n+     *\n+     * @param str  the String to chop last character from, may be null\n+     * @return String without last character, <code>null</code> if null String input\n+     */\n+    public static String chop(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        int strLen = str.length();\n+        if (strLen < 2) {\n+            return EMPTY;\n+        }\n+        int lastIdx = strLen - 1;\n+        String ret = str.substring(0, lastIdx);\n+        char last = str.charAt(lastIdx);\n+        if (last == CharUtils.LF) {\n+            if (ret.charAt(lastIdx - 1) == CharUtils.CR) {\n+                return ret.substring(0, lastIdx - 1);\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    // Conversion\n+    //-----------------------------------------------------------------------\n+\n+    // Padding\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Repeat a String <code>repeat</code> times to form a\n+     * new String.</p>\n+     *\n+     * <pre>\n+     * StringUtils.repeat(null, 2) = null\n+     * StringUtils.repeat(\"\", 0)   = \"\"\n+     * StringUtils.repeat(\"\", 2)   = \"\"\n+     * StringUtils.repeat(\"a\", 3)  = \"aaa\"\n+     * StringUtils.repeat(\"ab\", 2) = \"abab\"\n+     * StringUtils.repeat(\"a\", -2) = \"\"\n+     * </pre>\n+     *\n+     * @param str  the String to repeat, may be null\n+     * @param repeat  number of times to repeat str, negative treated as zero\n+     * @return a new String consisting of the original String repeated,\n+     *  <code>null</code> if null String input\n+     */\n+    public static String repeat(String str, int repeat) {\n+        // Performance tuned for 2.0 (JDK1.4)\n+\n+        if (str == null) {\n+            return null;\n+        }\n+        if (repeat <= 0) {\n+            return EMPTY;\n+        }\n+        int inputLength = str.length();\n+        if (repeat == 1 || inputLength == 0) {\n+            return str;\n+        }\n+        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n+            return padding(repeat, str.charAt(0));\n+        }\n+\n+        int outputLength = inputLength * repeat;\n+        switch (inputLength) {\n+            case 1 :\n+                char ch = str.charAt(0);\n+                char[] output1 = new char[outputLength];\n+                for (int i = repeat - 1; i >= 0; i--) {\n+                    output1[i] = ch;\n+                }\n+                return new String(output1);\n+            case 2 :\n+                char ch0 = str.charAt(0);\n+                char ch1 = str.charAt(1);\n+                char[] output2 = new char[outputLength];\n+                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n+                    output2[i] = ch0;\n+                    output2[i + 1] = ch1;\n+                }\n+                return new String(output2);\n+            default :\n+                StringBuilder buf = new StringBuilder(outputLength);\n+                for (int i = 0; i < repeat; i++) {\n+                    buf.append(str);\n+                }\n+                return buf.toString();\n+        }\n+    }\n+\n+    /**\n+     * <p>Repeat a String <code>repeat</code> times to form a\n+     * new String, with a String separator injected each time. </p>\n+     *\n+     * <pre>\n+     * StringUtils.repeat(null, null, 2) = null\n+     * StringUtils.repeat(null, \"x\", 2)  = null\n+     * StringUtils.repeat(\"\", null, 0)   = \"\"\n+     * StringUtils.repeat(\"\", \"\", 2)     = \"\"\n+     * StringUtils.repeat(\"\", \"x\", 3)    = \"xxx\"\n+     * StringUtils.repeat(\"?\", \", \", 3)  = \"?, ?, ?\"\n+     * </pre>\n+     *\n+     * @param str        the String to repeat, may be null\n+     * @param separator  the String to inject, may be null\n+     * @param repeat     number of times to repeat str, negative treated as zero\n+     * @return a new String consisting of the original String repeated,\n+     *  <code>null</code> if null String input\n+     */\n+    public static String repeat(String str, String separator, int repeat) {\n+        if(str == null || separator == null) {\n+            return repeat(str, repeat);\n+        } else {\n+            // given that repeat(String, int) is quite optimized, better to rely on it than try and splice this into it\n+            String result = repeat(str + separator, repeat);\n+            return removeEnd(result, separator);\n+        }\n+    }\n+\n+    /**\n+     * <p>Returns padding using the specified delimiter repeated\n+     * to a given length.</p>\n+     *\n+     * <pre>\n+     * StringUtils.padding(0, 'e')  = \"\"\n+     * StringUtils.padding(3, 'e')  = \"eee\"\n+     * StringUtils.padding(-2, 'e') = IndexOutOfBoundsException\n+     * </pre>\n+     *\n+     * <p>Note: this method doesn't not support padding with\n+     * <a href=\"http://www.unicode.org/glossary/#supplementary_character\">Unicode Supplementary Characters</a>\n+     * as they require a pair of <code>char</code>s to be represented.\n+     * If you are needing to support full I18N of your applications\n+     * consider using {@link #repeat(String, int)} instead. \n+     * </p>\n+     *\n+     * @param repeat  number of times to repeat delim\n+     * @param padChar  character to repeat\n+     * @return String with repeated character\n+     * @throws IndexOutOfBoundsException if <code>repeat &lt; 0</code>\n+     * @see #repeat(String, int)\n+     */\n+    private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException {\n+        if (repeat < 0) {\n+            throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat);\n+        }\n+        final char[] buf = new char[repeat];\n+        for (int i = 0; i < buf.length; i++) {\n+            buf[i] = padChar;\n+        }\n+        return new String(buf);\n+    }\n+\n+    /**\n+     * <p>Right pad a String with spaces (' ').</p>\n+     *\n+     * <p>The String is padded to the size of <code>size</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.rightPad(null, *)   = null\n+     * StringUtils.rightPad(\"\", 3)     = \"   \"\n+     * StringUtils.rightPad(\"bat\", 3)  = \"bat\"\n+     * StringUtils.rightPad(\"bat\", 5)  = \"bat  \"\n+     * StringUtils.rightPad(\"bat\", 1)  = \"bat\"\n+     * StringUtils.rightPad(\"bat\", -1) = \"bat\"\n+     * </pre>\n+     *\n+     * @param str  the String to pad out, may be null\n+     * @param size  the size to pad to\n+     * @return right padded String or original String if no padding is necessary,\n+     *  <code>null</code> if null String input\n+     */\n+    public static String rightPad(String str, int size) {\n+        return rightPad(str, size, ' ');\n+    }\n+\n+    /**\n+     * <p>Right pad a String with a specified character.</p>\n+     *\n+     * <p>The String is padded to the size of <code>size</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.rightPad(null, *, *)     = null\n+     * StringUtils.rightPad(\"\", 3, 'z')     = \"zzz\"\n+     * StringUtils.rightPad(\"bat\", 3, 'z')  = \"bat\"\n+     * StringUtils.rightPad(\"bat\", 5, 'z')  = \"batzz\"\n+     * StringUtils.rightPad(\"bat\", 1, 'z')  = \"bat\"\n+     * StringUtils.rightPad(\"bat\", -1, 'z') = \"bat\"\n+     * </pre>\n+     *\n+     * @param str  the String to pad out, may be null\n+     * @param size  the size to pad to\n+     * @param padChar  the character to pad with\n+     * @return right padded String or original String if no padding is necessary,\n+     *  <code>null</code> if null String input\n+     * @since 2.0\n+     */\n+    public static String rightPad(String str, int size, char padChar) {\n+        if (str == null) {\n+            return null;\n+        }\n+        int pads = size - str.length();\n+        if (pads <= 0) {\n+            return str; // returns original String when possible\n+        }\n+        if (pads > PAD_LIMIT) {\n+            return rightPad(str, size, String.valueOf(padChar));\n+        }\n+        return str.concat(padding(pads, padChar));\n+    }\n+\n+    /**\n+     * <p>Right pad a String with a specified String.</p>\n+     *\n+     * <p>The String is padded to the size of <code>size</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.rightPad(null, *, *)      = null\n+     * StringUtils.rightPad(\"\", 3, \"z\")      = \"zzz\"\n+     * StringUtils.rightPad(\"bat\", 3, \"yz\")  = \"bat\"\n+     * StringUtils.rightPad(\"bat\", 5, \"yz\")  = \"batyz\"\n+     * StringUtils.rightPad(\"bat\", 8, \"yz\")  = \"batyzyzy\"\n+     * StringUtils.rightPad(\"bat\", 1, \"yz\")  = \"bat\"\n+     * StringUtils.rightPad(\"bat\", -1, \"yz\") = \"bat\"\n+     * StringUtils.rightPad(\"bat\", 5, null)  = \"bat  \"\n+     * StringUtils.rightPad(\"bat\", 5, \"\")    = \"bat  \"\n+     * </pre>\n+     *\n+     * @param str  the String to pad out, may be null\n+     * @param size  the size to pad to\n+     * @param padStr  the String to pad with, null or empty treated as single space\n+     * @return right padded String or original String if no padding is necessary,\n+     *  <code>null</code> if null String input\n+     */\n+    public static String rightPad(String str, int size, String padStr) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (isEmpty(padStr)) {\n+            padStr = \" \";\n+        }\n+        int padLen = padStr.length();\n+        int strLen = str.length();\n+        int pads = size - strLen;\n+        if (pads <= 0) {\n+            return str; // returns original String when possible\n+        }\n+        if (padLen == 1 && pads <= PAD_LIMIT) {\n+            return rightPad(str, size, padStr.charAt(0));\n+        }\n+\n+        if (pads == padLen) {\n+            return str.concat(padStr);\n+        } else if (pads < padLen) {\n+            return str.concat(padStr.substring(0, pads));\n+        } else {\n+            char[] padding = new char[pads];\n+            char[] padChars = padStr.toCharArray();\n+            for (int i = 0; i < pads; i++) {\n+                padding[i] = padChars[i % padLen];\n+            }\n+            return str.concat(new String(padding));\n+        }\n+    }\n+\n+    /**\n+     * <p>Left pad a String with spaces (' ').</p>\n+     *\n+     * <p>The String is padded to the size of <code>size</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.leftPad(null, *)   = null\n+     * StringUtils.leftPad(\"\", 3)     = \"   \"\n+     * StringUtils.leftPad(\"bat\", 3)  = \"bat\"\n+     * StringUtils.leftPad(\"bat\", 5)  = \"  bat\"\n+     * StringUtils.leftPad(\"bat\", 1)  = \"bat\"\n+     * StringUtils.leftPad(\"bat\", -1) = \"bat\"\n+     * </pre>\n+     *\n+     * @param str  the String to pad out, may be null\n+     * @param size  the size to pad to\n+     * @return left padded String or original String if no padding is necessary,\n+     *  <code>null</code> if null String input\n+     */\n+    public static String leftPad(String str, int size) {\n+        return leftPad(str, size, ' ');\n+    }\n+\n+    /**\n+     * <p>Left pad a String with a specified character.</p>\n+     *\n+     * <p>Pad to a size of <code>size</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.leftPad(null, *, *)     = null\n+     * StringUtils.leftPad(\"\", 3, 'z')     = \"zzz\"\n+     * StringUtils.leftPad(\"bat\", 3, 'z')  = \"bat\"\n+     * StringUtils.leftPad(\"bat\", 5, 'z')  = \"zzbat\"\n+     * StringUtils.leftPad(\"bat\", 1, 'z')  = \"bat\"\n+     * StringUtils.leftPad(\"bat\", -1, 'z') = \"bat\"\n+     * </pre>\n+     *\n+     * @param str  the String to pad out, may be null\n+     * @param size  the size to pad to\n+     * @param padChar  the character to pad with\n+     * @return left padded String or original String if no padding is necessary,\n+     *  <code>null</code> if null String input\n+     * @since 2.0\n+     */\n+    public static String leftPad(String str, int size, char padChar) {\n+        if (str == null) {\n+            return null;\n+        }\n+        int pads = size - str.length();\n+        if (pads <= 0) {\n+            return str; // returns original String when possible\n+        }\n+        if (pads > PAD_LIMIT) {\n+            return leftPad(str, size, String.valueOf(padChar));\n+        }\n+        return padding(pads, padChar).concat(str);\n+    }\n+\n+    /**\n+     * <p>Left pad a String with a specified String.</p>\n+     *\n+     * <p>Pad to a size of <code>size</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.leftPad(null, *, *)      = null\n+     * StringUtils.leftPad(\"\", 3, \"z\")      = \"zzz\"\n+     * StringUtils.leftPad(\"bat\", 3, \"yz\")  = \"bat\"\n+     * StringUtils.leftPad(\"bat\", 5, \"yz\")  = \"yzbat\"\n+     * StringUtils.leftPad(\"bat\", 8, \"yz\")  = \"yzyzybat\"\n+     * StringUtils.leftPad(\"bat\", 1, \"yz\")  = \"bat\"\n+     * StringUtils.leftPad(\"bat\", -1, \"yz\") = \"bat\"\n+     * StringUtils.leftPad(\"bat\", 5, null)  = \"  bat\"\n+     * StringUtils.leftPad(\"bat\", 5, \"\")    = \"  bat\"\n+     * </pre>\n+     *\n+     * @param str  the String to pad out, may be null\n+     * @param size  the size to pad to\n+     * @param padStr  the String to pad with, null or empty treated as single space\n+     * @return left padded String or original String if no padding is necessary,\n+     *  <code>null</code> if null String input\n+     */\n+    public static String leftPad(String str, int size, String padStr) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (isEmpty(padStr)) {\n+            padStr = \" \";\n+        }\n+        int padLen = padStr.length();\n+        int strLen = str.length();\n+        int pads = size - strLen;\n+        if (pads <= 0) {\n+            return str; // returns original String when possible\n+        }\n+        if (padLen == 1 && pads <= PAD_LIMIT) {\n+            return leftPad(str, size, padStr.charAt(0));\n+        }\n+\n+        if (pads == padLen) {\n+            return padStr.concat(str);\n+        } else if (pads < padLen) {\n+            return padStr.substring(0, pads).concat(str);\n+        } else {\n+            char[] padding = new char[pads];\n+            char[] padChars = padStr.toCharArray();\n+            for (int i = 0; i < pads; i++) {\n+                padding[i] = padChars[i % padLen];\n+            }\n+            return new String(padding).concat(str);\n+        }\n+    }\n+\n+    /**\n+     * Gets a String's length or <code>0</code> if the String is <code>null</code>.\n+     * \n+     * @param str\n+     *            a String or <code>null</code>\n+     * @return String length or <code>0</code> if the String is <code>null</code>.\n+     * @since 2.4\n+     */\n+    public static int length(String str) {\n+        return str == null ? 0 : str.length();\n+    }\n+    \n+    // Centering\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Centers a String in a larger String of size <code>size</code>\n+     * using the space character (' ').<p>\n+     *\n+     * <p>If the size is less than the String length, the String is returned.\n+     * A <code>null</code> String returns <code>null</code>.\n+     * A negative size is treated as zero.</p>\n+     *\n+     * <p>Equivalent to <code>center(str, size, \" \")</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.center(null, *)   = null\n+     * StringUtils.center(\"\", 4)     = \"    \"\n+     * StringUtils.center(\"ab\", -1)  = \"ab\"\n+     * StringUtils.center(\"ab\", 4)   = \" ab \"\n+     * StringUtils.center(\"abcd\", 2) = \"abcd\"\n+     * StringUtils.center(\"a\", 4)    = \" a  \"\n+     * </pre>\n+     *\n+     * @param str  the String to center, may be null\n+     * @param size  the int size of new String, negative treated as zero\n+     * @return centered String, <code>null</code> if null String input\n+     */\n+    public static String center(String str, int size) {\n+        return center(str, size, ' ');\n+    }\n+\n+    /**\n+     * <p>Centers a String in a larger String of size <code>size</code>.\n+     * Uses a supplied character as the value to pad the String with.</p>\n+     *\n+     * <p>If the size is less than the String length, the String is returned.\n+     * A <code>null</code> String returns <code>null</code>.\n+     * A negative size is treated as zero.</p>\n+     *\n+     * <pre>\n+     * StringUtils.center(null, *, *)     = null\n+     * StringUtils.center(\"\", 4, ' ')     = \"    \"\n+     * StringUtils.center(\"ab\", -1, ' ')  = \"ab\"\n+     * StringUtils.center(\"ab\", 4, ' ')   = \" ab\"\n+     * StringUtils.center(\"abcd\", 2, ' ') = \"abcd\"\n+     * StringUtils.center(\"a\", 4, ' ')    = \" a  \"\n+     * StringUtils.center(\"a\", 4, 'y')    = \"yayy\"\n+     * </pre>\n+     *\n+     * @param str  the String to center, may be null\n+     * @param size  the int size of new String, negative treated as zero\n+     * @param padChar  the character to pad the new String with\n+     * @return centered String, <code>null</code> if null String input\n+     * @since 2.0\n+     */\n+    public static String center(String str, int size, char padChar) {\n+        if (str == null || size <= 0) {\n+            return str;\n+        }\n+        int strLen = str.length();\n+        int pads = size - strLen;\n+        if (pads <= 0) {\n+            return str;\n+        }\n+        str = leftPad(str, strLen + pads / 2, padChar);\n+        str = rightPad(str, size, padChar);\n+        return str;\n+    }\n+\n+    /**\n+     * <p>Centers a String in a larger String of size <code>size</code>.\n+     * Uses a supplied String as the value to pad the String with.</p>\n+     *\n+     * <p>If the size is less than the String length, the String is returned.\n+     * A <code>null</code> String returns <code>null</code>.\n+     * A negative size is treated as zero.</p>\n+     *\n+     * <pre>\n+     * StringUtils.center(null, *, *)     = null\n+     * StringUtils.center(\"\", 4, \" \")     = \"    \"\n+     * StringUtils.center(\"ab\", -1, \" \")  = \"ab\"\n+     * StringUtils.center(\"ab\", 4, \" \")   = \" ab\"\n+     * StringUtils.center(\"abcd\", 2, \" \") = \"abcd\"\n+     * StringUtils.center(\"a\", 4, \" \")    = \" a  \"\n+     * StringUtils.center(\"a\", 4, \"yz\")   = \"yayz\"\n+     * StringUtils.center(\"abc\", 7, null) = \"  abc  \"\n+     * StringUtils.center(\"abc\", 7, \"\")   = \"  abc  \"\n+     * </pre>\n+     *\n+     * @param str  the String to center, may be null\n+     * @param size  the int size of new String, negative treated as zero\n+     * @param padStr  the String to pad the new String with, must not be null or empty\n+     * @return centered String, <code>null</code> if null String input\n+     * @throws IllegalArgumentException if padStr is <code>null</code> or empty\n+     */\n+    public static String center(String str, int size, String padStr) {\n+        if (str == null || size <= 0) {\n+            return str;\n+        }\n+        if (isEmpty(padStr)) {\n+            padStr = \" \";\n+        }\n+        int strLen = str.length();\n+        int pads = size - strLen;\n+        if (pads <= 0) {\n+            return str;\n+        }\n+        str = leftPad(str, strLen + pads / 2, padStr);\n+        str = rightPad(str, size, padStr);\n+        return str;\n+    }\n+\n+    // Case conversion\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts a String to upper case as per {@link String#toUpperCase()}.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.upperCase(null)  = null\n+     * StringUtils.upperCase(\"\")    = \"\"\n+     * StringUtils.upperCase(\"aBc\") = \"ABC\"\n+     * </pre>\n+     *\n+     * <p><strong>Note:</strong> As described in the documentation for {@link String#toUpperCase()},\n+     * the result of this method is affected by the current locale.\n+     * For platform-independent case transformations, the method {@link #lowerCase(String, Locale)}\n+     * should be used with a specific locale (e.g. {@link Locale#ENGLISH}).</p>\n+     *\n+     * @param str  the String to upper case, may be null\n+     * @return the upper cased String, <code>null</code> if null String input\n+     */\n+    public static String upperCase(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        return str.toUpperCase();\n+    }\n+\n+    /**\n+     * <p>Converts a String to upper case as per {@link String#toUpperCase(Locale)}.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.upperCase(null, Locale.ENGLISH)  = null\n+     * StringUtils.upperCase(\"\", Locale.ENGLISH)    = \"\"\n+     * StringUtils.upperCase(\"aBc\", Locale.ENGLISH) = \"ABC\"\n+     * </pre>\n+     *\n+     * @param str  the String to upper case, may be null\n+     * @param locale  the locale that defines the case transformation rules, must not be null\n+     * @return the upper cased String, <code>null</code> if null String input\n+     * @since 3.0\n+     */\n+    public static String upperCase(String str, Locale locale) {\n+        if (str == null) {\n+            return null;\n+        }\n+        return str.toUpperCase(locale);\n+    }\n+\n+    /**\n+     * <p>Converts a String to lower case as per {@link String#toLowerCase()}.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.lowerCase(null)  = null\n+     * StringUtils.lowerCase(\"\")    = \"\"\n+     * StringUtils.lowerCase(\"aBc\") = \"abc\"\n+     * </pre>\n+     *\n+     * <p><strong>Note:</strong> As described in the documentation for {@link String#toLowerCase()},\n+     * the result of this method is affected by the current locale.\n+     * For platform-independent case transformations, the method {@link #lowerCase(String, Locale)}\n+     * should be used with a specific locale (e.g. {@link Locale#ENGLISH}).</p>\n+     *\n+     * @param str  the String to lower case, may be null\n+     * @return the lower cased String, <code>null</code> if null String input\n+     */\n+    public static String lowerCase(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        return str.toLowerCase();\n+    }\n+\n+    /**\n+     * <p>Converts a String to lower case as per {@link String#toLowerCase(Locale)}.</p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.lowerCase(null, Locale.ENGLISH)  = null\n+     * StringUtils.lowerCase(\"\", Locale.ENGLISH)    = \"\"\n+     * StringUtils.lowerCase(\"aBc\", Locale.ENGLISH) = \"abc\"\n+     * </pre>\n+     *\n+     * @param str  the String to lower case, may be null\n+     * @param locale  the locale that defines the case transformation rules, must not be null\n+     * @return the lower cased String, <code>null</code> if null String input\n+     * @since 3.0\n+     */\n+    public static String lowerCase(String str, Locale locale) {\n+        if (str == null) {\n+            return null;\n+        }\n+        return str.toLowerCase(locale);\n+    }\n+\n+    /**\n+     * <p>Capitalizes a String changing the first letter to title case as\n+     * per {@link Character#toTitleCase(char)}. No other letters are changed.</p>\n+     *\n+     * <p>For a word based algorithm, see {@link WordUtils#capitalize(String)}.\n+     * A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.capitalize(null)  = null\n+     * StringUtils.capitalize(\"\")    = \"\"\n+     * StringUtils.capitalize(\"cat\") = \"Cat\"\n+     * StringUtils.capitalize(\"cAt\") = \"CAt\"\n+     * </pre>\n+     *\n+     * @param str  the String to capitalize, may be null\n+     * @return the capitalized String, <code>null</code> if null String input\n+     * @see WordUtils#capitalize(String)\n+     * @see #uncapitalize(String)\n+     * @since 2.0\n+     */\n+    public static String capitalize(String str) {\n+        int strLen;\n+        if (str == null || (strLen = str.length()) == 0) {\n+            return str;\n+        }\n+        return new StringBuilder(strLen)\n+            .append(Character.toTitleCase(str.charAt(0)))\n+            .append(str.substring(1))\n+            .toString();\n+    }\n+\n+    /**\n+     * <p>Uncapitalizes a String changing the first letter to title case as\n+     * per {@link Character#toLowerCase(char)}. No other letters are changed.</p>\n+     *\n+     * <p>For a word based algorithm, see {@link WordUtils#uncapitalize(String)}.\n+     * A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.uncapitalize(null)  = null\n+     * StringUtils.uncapitalize(\"\")    = \"\"\n+     * StringUtils.uncapitalize(\"Cat\") = \"cat\"\n+     * StringUtils.uncapitalize(\"CAT\") = \"cAT\"\n+     * </pre>\n+     *\n+     * @param str  the String to uncapitalize, may be null\n+     * @return the uncapitalized String, <code>null</code> if null String input\n+     * @see WordUtils#uncapitalize(String)\n+     * @see #capitalize(String)\n+     * @since 2.0\n+     */\n+    public static String uncapitalize(String str) {\n+        int strLen;\n+        if (str == null || (strLen = str.length()) == 0) {\n+            return str;\n+        }\n+        return new StringBuilder(strLen)\n+            .append(Character.toLowerCase(str.charAt(0)))\n+            .append(str.substring(1))\n+            .toString();\n+    }\n+\n+    /**\n+     * <p>Swaps the case of a String changing upper and title case to\n+     * lower case, and lower case to upper case.</p>\n+     *\n+     * <ul>\n+     *  <li>Upper case character converts to Lower case</li>\n+     *  <li>Title case character converts to Lower case</li>\n+     *  <li>Lower case character converts to Upper case</li>\n+     * </ul>\n+     *\n+     * <p>For a word based algorithm, see {@link WordUtils#swapCase(String)}.\n+     * A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.swapCase(null)                 = null\n+     * StringUtils.swapCase(\"\")                   = \"\"\n+     * StringUtils.swapCase(\"The dog has a BONE\") = \"tHE DOG HAS A bone\"\n+     * </pre>\n+     *\n+     * <p>NOTE: This method changed in Lang version 2.0.\n+     * It no longer performs a word based algorithm.\n+     * If you only use ASCII, you will notice no change.\n+     * That functionality is available in WordUtils.</p>\n+     *\n+     * @param str  the String to swap case, may be null\n+     * @return the changed String, <code>null</code> if null String input\n+     */\n+    public static String swapCase(String str) {\n+        int strLen;\n+        if (str == null || (strLen = str.length()) == 0) {\n+            return str;\n+        }\n+        StringBuilder buffer = new StringBuilder(strLen);\n+\n+        char ch = 0;\n+        for (int i = 0; i < strLen; i++) {\n+            ch = str.charAt(i);\n+            if (Character.isUpperCase(ch)) {\n+                ch = Character.toLowerCase(ch);\n+            } else if (Character.isTitleCase(ch)) {\n+                ch = Character.toLowerCase(ch);\n+            } else if (Character.isLowerCase(ch)) {\n+                ch = Character.toUpperCase(ch);\n+            }\n+            buffer.append(ch);\n+        }\n+        return buffer.toString();\n+    }\n+\n+    // Count matches\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Counts how many times the substring appears in the larger String.</p>\n+     *\n+     * <p>A <code>null</code> or empty (\"\") String input returns <code>0</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.countMatches(null, *)       = 0\n+     * StringUtils.countMatches(\"\", *)         = 0\n+     * StringUtils.countMatches(\"abba\", null)  = 0\n+     * StringUtils.countMatches(\"abba\", \"\")    = 0\n+     * StringUtils.countMatches(\"abba\", \"a\")   = 2\n+     * StringUtils.countMatches(\"abba\", \"ab\")  = 1\n+     * StringUtils.countMatches(\"abba\", \"xxx\") = 0\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param sub  the substring to count, may be null\n+     * @return the number of occurrences, 0 if either String is <code>null</code>\n+     */\n+    public static int countMatches(String str, String sub) {\n+        if (isEmpty(str) || isEmpty(sub)) {\n+            return 0;\n+        }\n+        int count = 0;\n+        int idx = 0;\n+        while ((idx = str.indexOf(sub, idx)) != -1) {\n+            count++;\n+            idx += sub.length();\n+        }\n+        return count;\n+    }\n+\n+    // Character Tests\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if the String contains only unicode letters.</p>\n+     *\n+     * <p><code>null</code> will return <code>false</code>.\n+     * An empty String (\"\") will return <code>true</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.isAlpha(null)   = false\n+     * StringUtils.isAlpha(\"\")     = true\n+     * StringUtils.isAlpha(\"  \")   = false\n+     * StringUtils.isAlpha(\"abc\")  = true\n+     * StringUtils.isAlpha(\"ab2c\") = false\n+     * StringUtils.isAlpha(\"ab-c\") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @return <code>true</code> if only contains letters, and is non-null\n+     */\n+    public static boolean isAlpha(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int sz = str.length();\n+        for (int i = 0; i < sz; i++) {\n+            if (Character.isLetter(str.charAt(i)) == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks if the String contains only unicode letters and\n+     * space (' ').</p>\n+     *\n+     * <p><code>null</code> will return <code>false</code>\n+     * An empty String (\"\") will return <code>true</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.isAlphaSpace(null)   = false\n+     * StringUtils.isAlphaSpace(\"\")     = true\n+     * StringUtils.isAlphaSpace(\"  \")   = true\n+     * StringUtils.isAlphaSpace(\"abc\")  = true\n+     * StringUtils.isAlphaSpace(\"ab c\") = true\n+     * StringUtils.isAlphaSpace(\"ab2c\") = false\n+     * StringUtils.isAlphaSpace(\"ab-c\") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @return <code>true</code> if only contains letters and space,\n+     *  and is non-null\n+     */\n+    public static boolean isAlphaSpace(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int sz = str.length();\n+        for (int i = 0; i < sz; i++) {\n+            if ((Character.isLetter(str.charAt(i)) == false) && (str.charAt(i) != ' ')) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks if the String contains only unicode letters or digits.</p>\n+     *\n+     * <p><code>null</code> will return <code>false</code>.\n+     * An empty String (\"\") will return <code>true</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.isAlphanumeric(null)   = false\n+     * StringUtils.isAlphanumeric(\"\")     = true\n+     * StringUtils.isAlphanumeric(\"  \")   = false\n+     * StringUtils.isAlphanumeric(\"abc\")  = true\n+     * StringUtils.isAlphanumeric(\"ab c\") = false\n+     * StringUtils.isAlphanumeric(\"ab2c\") = true\n+     * StringUtils.isAlphanumeric(\"ab-c\") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @return <code>true</code> if only contains letters or digits,\n+     *  and is non-null\n+     */\n+    public static boolean isAlphanumeric(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int sz = str.length();\n+        for (int i = 0; i < sz; i++) {\n+            if (Character.isLetterOrDigit(str.charAt(i)) == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks if the String contains only unicode letters, digits\n+     * or space (<code>' '</code>).</p>\n+     *\n+     * <p><code>null</code> will return <code>false</code>.\n+     * An empty String (\"\") will return <code>true</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.isAlphanumeric(null)   = false\n+     * StringUtils.isAlphanumeric(\"\")     = true\n+     * StringUtils.isAlphanumeric(\"  \")   = true\n+     * StringUtils.isAlphanumeric(\"abc\")  = true\n+     * StringUtils.isAlphanumeric(\"ab c\") = true\n+     * StringUtils.isAlphanumeric(\"ab2c\") = true\n+     * StringUtils.isAlphanumeric(\"ab-c\") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @return <code>true</code> if only contains letters, digits or space,\n+     *  and is non-null\n+     */\n+    public static boolean isAlphanumericSpace(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int sz = str.length();\n+        for (int i = 0; i < sz; i++) {\n+            if ((Character.isLetterOrDigit(str.charAt(i)) == false) && (str.charAt(i) != ' ')) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks if the string contains only ASCII printable characters.</p>\n+     * \n+     * <p><code>null</code> will return <code>false</code>.\n+     * An empty String (\"\") will return <code>true</code>.</p>\n+     * \n+     * <pre>\n+     * StringUtils.isAsciiPrintable(null)     = false\n+     * StringUtils.isAsciiPrintable(\"\")       = true\n+     * StringUtils.isAsciiPrintable(\" \")      = true\n+     * StringUtils.isAsciiPrintable(\"Ceki\")   = true\n+     * StringUtils.isAsciiPrintable(\"ab2c\")   = true\n+     * StringUtils.isAsciiPrintable(\"!ab-c~\") = true\n+     * StringUtils.isAsciiPrintable(\"\\u0020\") = true\n+     * StringUtils.isAsciiPrintable(\"\\u0021\") = true\n+     * StringUtils.isAsciiPrintable(\"\\u007e\") = true\n+     * StringUtils.isAsciiPrintable(\"\\u007f\") = false\n+     * StringUtils.isAsciiPrintable(\"Ceki G\\u00fclc\\u00fc\") = false\n+     * </pre>\n+     *\n+     * @param str the string to check, may be null\n+     * @return <code>true</code> if every character is in the range\n+     *  32 thru 126\n+     * @since 2.1\n+     */\n+    public static boolean isAsciiPrintable(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int sz = str.length();\n+        for (int i = 0; i < sz; i++) {\n+            if (CharUtils.isAsciiPrintable(str.charAt(i)) == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks if the String contains only unicode digits.\n+     * A decimal point is not a unicode digit and returns false.</p>\n+     *\n+     * <p><code>null</code> will return <code>false</code>.\n+     * An empty String (\"\") will return <code>true</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.isNumeric(null)   = false\n+     * StringUtils.isNumeric(\"\")     = true\n+     * StringUtils.isNumeric(\"  \")   = false\n+     * StringUtils.isNumeric(\"123\")  = true\n+     * StringUtils.isNumeric(\"12 3\") = false\n+     * StringUtils.isNumeric(\"ab2c\") = false\n+     * StringUtils.isNumeric(\"12-3\") = false\n+     * StringUtils.isNumeric(\"12.3\") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @return <code>true</code> if only contains digits, and is non-null\n+     */\n+    public static boolean isNumeric(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int sz = str.length();\n+        for (int i = 0; i < sz; i++) {\n+            if (Character.isDigit(str.charAt(i)) == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks if the String contains only unicode digits or space\n+     * (<code>' '</code>).\n+     * A decimal point is not a unicode digit and returns false.</p>\n+     *\n+     * <p><code>null</code> will return <code>false</code>.\n+     * An empty String (\"\") will return <code>true</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.isNumeric(null)   = false\n+     * StringUtils.isNumeric(\"\")     = true\n+     * StringUtils.isNumeric(\"  \")   = true\n+     * StringUtils.isNumeric(\"123\")  = true\n+     * StringUtils.isNumeric(\"12 3\") = true\n+     * StringUtils.isNumeric(\"ab2c\") = false\n+     * StringUtils.isNumeric(\"12-3\") = false\n+     * StringUtils.isNumeric(\"12.3\") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @return <code>true</code> if only contains digits or space,\n+     *  and is non-null\n+     */\n+    public static boolean isNumericSpace(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int sz = str.length();\n+        for (int i = 0; i < sz; i++) {\n+            if ((Character.isDigit(str.charAt(i)) == false) && (str.charAt(i) != ' ')) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks if the String contains only whitespace.</p>\n+     *\n+     * <p><code>null</code> will return <code>false</code>.\n+     * An empty String (\"\") will return <code>true</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.isWhitespace(null)   = false\n+     * StringUtils.isWhitespace(\"\")     = true\n+     * StringUtils.isWhitespace(\"  \")   = true\n+     * StringUtils.isWhitespace(\"abc\")  = false\n+     * StringUtils.isWhitespace(\"ab2c\") = false\n+     * StringUtils.isWhitespace(\"ab-c\") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @return <code>true</code> if only contains whitespace, and is non-null\n+     * @since 2.0\n+     */\n+    public static boolean isWhitespace(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int sz = str.length();\n+        for (int i = 0; i < sz; i++) {\n+            if ((Character.isWhitespace(str.charAt(i)) == false)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks if the String contains only lowercase characters.</p>\n+     *\n+     * <p><code>null</code> will return <code>false</code>.\n+     * An empty String (\"\") will return <code>false</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.isAllLowerCase(null)   = false\n+     * StringUtils.isAllLowerCase(\"\")     = false\n+     * StringUtils.isAllLowerCase(\"  \")   = false\n+     * StringUtils.isAllLowerCase(\"abc\")  = true\n+     * StringUtils.isAllLowerCase(\"abC\") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @return <code>true</code> if only contains lowercase characters, and is non-null\n+     */\n+    public static boolean isAllLowerCase(String str) {\n+        if (str == null || isEmpty(str)) {\n+            return false;\n+        }\n+        int sz = str.length();\n+        for (int i = 0; i < sz; i++) {\n+            if (Character.isLowerCase(str.charAt(i)) == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks if the String contains only uppercase characters.</p>\n+     *\n+     * <p><code>null</code> will return <code>false</code>.\n+     * An empty String (\"\") will return <code>false</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.isAllUpperCase(null)   = false\n+     * StringUtils.isAllUpperCase(\"\")     = false\n+     * StringUtils.isAllUpperCase(\"  \")   = false\n+     * StringUtils.isAllUpperCase(\"ABC\")  = true\n+     * StringUtils.isAllUpperCase(\"aBC\") = false\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @return <code>true</code> if only contains uppercase characters, and is non-null\n+     */\n+    public static boolean isAllUpperCase(String str) {\n+        if (str == null || isEmpty(str)) {\n+            return false;\n+        }\n+        int sz = str.length();\n+        for (int i = 0; i < sz; i++) {\n+            if (Character.isUpperCase(str.charAt(i)) == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    // Defaults\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Returns either the passed in String,\n+     * or if the String is <code>null</code>, an empty String (\"\").</p>\n+     *\n+     * <pre>\n+     * StringUtils.defaultString(null)  = \"\"\n+     * StringUtils.defaultString(\"\")    = \"\"\n+     * StringUtils.defaultString(\"bat\") = \"bat\"\n+     * </pre>\n+     *\n+     * @see ObjectUtils#toString(Object)\n+     * @see String#valueOf(Object)\n+     * @param str  the String to check, may be null\n+     * @return the passed in String, or the empty String if it\n+     *  was <code>null</code>\n+     */\n+    public static String defaultString(String str) {\n+        return str == null ? EMPTY : str;\n+    }\n+\n+    /**\n+     * <p>Returns either the passed in String, or if the String is\n+     * <code>null</code>, the value of <code>defaultStr</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.defaultString(null, \"NULL\")  = \"NULL\"\n+     * StringUtils.defaultString(\"\", \"NULL\")    = \"\"\n+     * StringUtils.defaultString(\"bat\", \"NULL\") = \"bat\"\n+     * </pre>\n+     *\n+     * @see ObjectUtils#toString(Object,String)\n+     * @see String#valueOf(Object)\n+     * @param str  the String to check, may be null\n+     * @param defaultStr  the default String to return\n+     *  if the input is <code>null</code>, may be null\n+     * @return the passed in String, or the default if it was <code>null</code>\n+     */\n+    public static String defaultString(String str, String defaultStr) {\n+        return str == null ? defaultStr : str;\n+    }\n+\n+    /**\n+     * <p>Returns either the passed in String, or if the String is\n+     * empty or <code>null</code>, the value of <code>defaultStr</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.defaultIfEmpty(null, \"NULL\")  = \"NULL\"\n+     * StringUtils.defaultIfEmpty(\"\", \"NULL\")    = \"NULL\"\n+     * StringUtils.defaultIfEmpty(\"bat\", \"NULL\") = \"bat\"\n+     * StringUtils.defaultIfEmpty(\"\", null)      = null\n+     * </pre>\n+     *\n+     * @see StringUtils#defaultString(String, String)\n+     * @param str  the String to check, may be null\n+     * @param defaultStr  the default String to return\n+     *  if the input is empty (\"\") or <code>null</code>, may be null\n+     * @return the passed in String, or the default\n+     */\n+    public static String defaultIfEmpty(String str, String defaultStr) {\n+        return StringUtils.isEmpty(str) ? defaultStr : str;\n+    }\n+\n+    // Reversing\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Reverses a String as per {@link StringBuilder#reverse()}.</p>\n+     *\n+     * <p>A <code>null</code> String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.reverse(null)  = null\n+     * StringUtils.reverse(\"\")    = \"\"\n+     * StringUtils.reverse(\"bat\") = \"tab\"\n+     * </pre>\n+     *\n+     * @param str  the String to reverse, may be null\n+     * @return the reversed String, <code>null</code> if null String input\n+     */\n+    public static String reverse(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        return new StringBuilder(str).reverse().toString();\n+    }\n+\n+    /**\n+     * <p>Reverses a String that is delimited by a specific character.</p>\n+     *\n+     * <p>The Strings between the delimiters are not reversed.\n+     * Thus java.lang.String becomes String.lang.java (if the delimiter\n+     * is <code>'.'</code>).</p>\n+     *\n+     * <pre>\n+     * StringUtils.reverseDelimited(null, *)      = null\n+     * StringUtils.reverseDelimited(\"\", *)        = \"\"\n+     * StringUtils.reverseDelimited(\"a.b.c\", 'x') = \"a.b.c\"\n+     * StringUtils.reverseDelimited(\"a.b.c\", \".\") = \"c.b.a\"\n+     * </pre>\n+     *\n+     * @param str  the String to reverse, may be null\n+     * @param separatorChar  the separator character to use\n+     * @return the reversed String, <code>null</code> if null String input\n+     * @since 2.0\n+     */\n+    public static String reverseDelimited(String str, char separatorChar) {\n+        if (str == null) {\n+            return null;\n+        }\n+        // could implement manually, but simple way is to reuse other,\n+        // probably slower, methods.\n+        String[] strs = split(str, separatorChar);\n+        ArrayUtils.reverse(strs);\n+        return join(strs, separatorChar);\n+    }\n+\n+    // Abbreviating\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Abbreviates a String using ellipses. This will turn\n+     * \"Now is the time for all good men\" into \"Now is the time for...\"</p>\n+     *\n+     * <p>Specifically:\n+     * <ul>\n+     *   <li>If <code>str</code> is less than <code>maxWidth</code> characters\n+     *       long, return it.</li>\n+     *   <li>Else abbreviate it to <code>(substring(str, 0, max-3) + \"...\")</code>.</li>\n+     *   <li>If <code>maxWidth</code> is less than <code>4</code>, throw an\n+     *       <code>IllegalArgumentException</code>.</li>\n+     *   <li>In no case will it return a String of length greater than\n+     *       <code>maxWidth</code>.</li>\n+     * </ul>\n+     * </p>\n+     *\n+     * <pre>\n+     * StringUtils.abbreviate(null, *)      = null\n+     * StringUtils.abbreviate(\"\", 4)        = \"\"\n+     * StringUtils.abbreviate(\"abcdefg\", 6) = \"abc...\"\n+     * StringUtils.abbreviate(\"abcdefg\", 7) = \"abcdefg\"\n+     * StringUtils.abbreviate(\"abcdefg\", 8) = \"abcdefg\"\n+     * StringUtils.abbreviate(\"abcdefg\", 4) = \"a...\"\n+     * StringUtils.abbreviate(\"abcdefg\", 3) = IllegalArgumentException\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param maxWidth  maximum length of result String, must be at least 4\n+     * @return abbreviated String, <code>null</code> if null String input\n+     * @throws IllegalArgumentException if the width is too small\n+     * @since 2.0\n+     */\n+    public static String abbreviate(String str, int maxWidth) {\n+        return abbreviate(str, 0, maxWidth);\n+    }\n+\n+    /**\n+     * <p>Abbreviates a String using ellipses. This will turn\n+     * \"Now is the time for all good men\" into \"...is the time for...\"</p>\n+     *\n+     * <p>Works like <code>abbreviate(String, int)</code>, but allows you to specify\n+     * a \"left edge\" offset.  Note that this left edge is not necessarily going to\n+     * be the leftmost character in the result, or the first character following the\n+     * ellipses, but it will appear somewhere in the result.\n+     *\n+     * <p>In no case will it return a String of length greater than\n+     * <code>maxWidth</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.abbreviate(null, *, *)                = null\n+     * StringUtils.abbreviate(\"\", 0, 4)                  = \"\"\n+     * StringUtils.abbreviate(\"abcdefghijklmno\", -1, 10) = \"abcdefg...\"\n+     * StringUtils.abbreviate(\"abcdefghijklmno\", 0, 10)  = \"abcdefg...\"\n+     * StringUtils.abbreviate(\"abcdefghijklmno\", 1, 10)  = \"abcdefg...\"\n+     * StringUtils.abbreviate(\"abcdefghijklmno\", 4, 10)  = \"abcdefg...\"\n+     * StringUtils.abbreviate(\"abcdefghijklmno\", 5, 10)  = \"...fghi...\"\n+     * StringUtils.abbreviate(\"abcdefghijklmno\", 6, 10)  = \"...ghij...\"\n+     * StringUtils.abbreviate(\"abcdefghijklmno\", 8, 10)  = \"...ijklmno\"\n+     * StringUtils.abbreviate(\"abcdefghijklmno\", 10, 10) = \"...ijklmno\"\n+     * StringUtils.abbreviate(\"abcdefghijklmno\", 12, 10) = \"...ijklmno\"\n+     * StringUtils.abbreviate(\"abcdefghij\", 0, 3)        = IllegalArgumentException\n+     * StringUtils.abbreviate(\"abcdefghij\", 5, 6)        = IllegalArgumentException\n+     * </pre>\n+     *\n+     * @param str  the String to check, may be null\n+     * @param offset  left edge of source String\n+     * @param maxWidth  maximum length of result String, must be at least 4\n+     * @return abbreviated String, <code>null</code> if null String input\n+     * @throws IllegalArgumentException if the width is too small\n+     * @since 2.0\n+     */\n+    public static String abbreviate(String str, int offset, int maxWidth) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (maxWidth < 4) {\n+            throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n+        }\n+        if (str.length() <= maxWidth) {\n+            return str;\n+        }\n+        if (offset > str.length()) {\n+            offset = str.length();\n+        }\n+        if ((str.length() - offset) < (maxWidth - 3)) {\n+            offset = str.length() - (maxWidth - 3);\n+        }\n+        if (offset <= 4) {\n+            return str.substring(0, maxWidth - 3) + \"...\";\n+        }\n+        if (maxWidth < 7) {\n+            throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n+        }\n+        if ((offset + (maxWidth - 3)) < str.length()) {\n+            return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n+        }\n+        return \"...\" + str.substring(str.length() - (maxWidth - 3));\n+    }\n+\n+    // Difference\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Compares two Strings, and returns the portion where they differ.\n+     * (More precisely, return the remainder of the second String,\n+     * starting from where it's different from the first.)</p>\n+     *\n+     * <p>For example,\n+     * <code>difference(\"i am a machine\", \"i am a robot\") -> \"robot\"</code>.</p>\n+     *\n+     * <pre>\n+     * StringUtils.difference(null, null) = null\n+     * StringUtils.difference(\"\", \"\") = \"\"\n+     * StringUtils.difference(\"\", \"abc\") = \"abc\"\n+     * StringUtils.difference(\"abc\", \"\") = \"\"\n+     * StringUtils.difference(\"abc\", \"abc\") = \"\"\n+     * StringUtils.difference(\"ab\", \"abxyz\") = \"xyz\"\n+     * StringUtils.difference(\"abcde\", \"abxyz\") = \"xyz\"\n+     * StringUtils.difference(\"abcde\", \"xyz\") = \"xyz\"\n+     * </pre>\n+     *\n+     * @param str1  the first String, may be null\n+     * @param str2  the second String, may be null\n+     * @return the portion of str2 where it differs from str1; returns the\n+     * empty String if they are equal\n+     * @since 2.0\n+     */\n+    public static String difference(String str1, String str2) {\n+        if (str1 == null) {\n+            return str2;\n+        }\n+        if (str2 == null) {\n+            return str1;\n+        }\n+        int at = indexOfDifference(str1, str2);\n+        if (at == -1) {\n+            return EMPTY;\n+        }\n+        return str2.substring(at);\n+    }\n+\n+    /**\n+     * <p>Compares two Strings, and returns the index at which the\n+     * Strings begin to differ.</p>\n+     *\n+     * <p>For example,\n+     * <code>indexOfDifference(\"i am a machine\", \"i am a robot\") -> 7</code></p>\n+     *\n+     * <pre>\n+     * StringUtils.indexOfDifference(null, null) = -1\n+     * StringUtils.indexOfDifference(\"\", \"\") = -1\n+     * StringUtils.indexOfDifference(\"\", \"abc\") = 0\n+     * StringUtils.indexOfDifference(\"abc\", \"\") = 0\n+     * StringUtils.indexOfDifference(\"abc\", \"abc\") = -1\n+     * StringUtils.indexOfDifference(\"ab\", \"abxyz\") = 2\n+     * StringUtils.indexOfDifference(\"abcde\", \"abxyz\") = 2\n+     * StringUtils.indexOfDifference(\"abcde\", \"xyz\") = 0\n+     * </pre>\n+     *\n+     * @param str1  the first String, may be null\n+     * @param str2  the second String, may be null\n+     * @return the index where str2 and str1 begin to differ; -1 if they are equal\n+     * @since 2.0\n+     */\n+    public static int indexOfDifference(String str1, String str2) {\n+        if (str1 == str2) {\n+            return -1;\n+        }\n+        if (str1 == null || str2 == null) {\n+            return 0;\n+        }\n+        int i;\n+        for (i = 0; i < str1.length() && i < str2.length(); ++i) {\n+            if (str1.charAt(i) != str2.charAt(i)) {\n+                break;\n+            }\n+        }\n+        if (i < str2.length() || i < str1.length()) {\n+            return i;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * <p>Compares all Strings in an array and returns the index at which the\n+     * Strings begin to differ.</p>\n+     *\n+     * <p>For example,\n+     * <code>indexOfDifference(new String[] {\"i am a machine\", \"i am a robot\"}) -> 7</code></p>\n+     *\n+     * <pre>\n+     * StringUtils.indexOfDifference(null) = -1\n+     * StringUtils.indexOfDifference(new String[] {}) = -1\n+     * StringUtils.indexOfDifference(new String[] {\"abc\"}) = -1\n+     * StringUtils.indexOfDifference(new String[] {null, null}) = -1\n+     * StringUtils.indexOfDifference(new String[] {\"\", \"\"}) = -1\n+     * StringUtils.indexOfDifference(new String[] {\"\", null}) = 0\n+     * StringUtils.indexOfDifference(new String[] {\"abc\", null, null}) = 0\n+     * StringUtils.indexOfDifference(new String[] {null, null, \"abc\"}) = 0\n+     * StringUtils.indexOfDifference(new String[] {\"\", \"abc\"}) = 0\n+     * StringUtils.indexOfDifference(new String[] {\"abc\", \"\"}) = 0\n+     * StringUtils.indexOfDifference(new String[] {\"abc\", \"abc\"}) = -1\n+     * StringUtils.indexOfDifference(new String[] {\"abc\", \"a\"}) = 1\n+     * StringUtils.indexOfDifference(new String[] {\"ab\", \"abxyz\"}) = 2\n+     * StringUtils.indexOfDifference(new String[] {\"abcde\", \"abxyz\"}) = 2\n+     * StringUtils.indexOfDifference(new String[] {\"abcde\", \"xyz\"}) = 0\n+     * StringUtils.indexOfDifference(new String[] {\"xyz\", \"abcde\"}) = 0\n+     * StringUtils.indexOfDifference(new String[] {\"i am a machine\", \"i am a robot\"}) = 7\n+     * </pre>\n+     *\n+     * @param strs  array of strings, entries may be null\n+     * @return the index where the strings begin to differ; -1 if they are all equal\n+     * @since 2.4\n+     */\n+    public static int indexOfDifference(String[] strs) {\n+        if (strs == null || strs.length <= 1) {\n+            return -1;\n+        }\n+        boolean anyStringNull = false;\n+        boolean allStringsNull = true;\n+        int arrayLen = strs.length;\n+        int shortestStrLen = Integer.MAX_VALUE;\n+        int longestStrLen = 0;\n+\n+        // find the min and max string lengths; this avoids checking to make\n+        // sure we are not exceeding the length of the string each time through\n+        // the bottom loop.\n+        for (int i = 0; i < arrayLen; i++) {\n+            if (strs[i] == null) {\n+                anyStringNull = true;\n+                shortestStrLen = 0;\n+            } else {\n+                allStringsNull = false;\n+                shortestStrLen = Math.min(strs[i].length(), shortestStrLen);\n+                longestStrLen = Math.max(strs[i].length(), longestStrLen);\n+            }\n+        }\n+\n+        // handle lists containing all nulls or all empty strings\n+        if (allStringsNull || (longestStrLen == 0 && !anyStringNull)) {\n+            return -1;\n+        }\n+\n+        // handle lists containing some nulls or some empty strings\n+        if (shortestStrLen == 0) {\n+            return 0;\n+        }\n+\n+        // find the position with the first difference across all strings\n+        int firstDiff = -1;\n+        for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {\n+            char comparisonChar = strs[0].charAt(stringPos);\n+            for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {\n+                if (strs[arrayPos].charAt(stringPos) != comparisonChar) {\n+                    firstDiff = stringPos;\n+                    break;\n+                }\n+            }\n+            if (firstDiff != -1) {\n+                break;\n+            }\n+        }\n+\n+        if (firstDiff == -1 && shortestStrLen != longestStrLen) {\n+            // we compared all of the characters up to the length of the\n+            // shortest string and didn't find a match, but the string lengths\n+            // vary, so return the length of the shortest string.\n+            return shortestStrLen;\n+        }\n+        return firstDiff;\n+    }\n+    \n+    /**\n+     * <p>Compares all Strings in an array and returns the initial sequence of \n+     * characters that is common to all of them.</p>\n+     *\n+     * <p>For example,\n+     * <code>getCommonPrefix(new String[] {\"i am a machine\", \"i am a robot\"}) -> \"i am a \"</code></p>\n+     *\n+     * <pre>\n+     * StringUtils.getCommonPrefix(null) = \"\"\n+     * StringUtils.getCommonPrefix(new String[] {}) = \"\"\n+     * StringUtils.getCommonPrefix(new String[] {\"abc\"}) = \"abc\"\n+     * StringUtils.getCommonPrefix(new String[] {null, null}) = \"\"\n+     * StringUtils.getCommonPrefix(new String[] {\"\", \"\"}) = \"\"\n+     * StringUtils.getCommonPrefix(new String[] {\"\", null}) = \"\"\n+     * StringUtils.getCommonPrefix(new String[] {\"abc\", null, null}) = \"\"\n+     * StringUtils.getCommonPrefix(new String[] {null, null, \"abc\"}) = \"\"\n+     * StringUtils.getCommonPrefix(new String[] {\"\", \"abc\"}) = \"\"\n+     * StringUtils.getCommonPrefix(new String[] {\"abc\", \"\"}) = \"\"\n+     * StringUtils.getCommonPrefix(new String[] {\"abc\", \"abc\"}) = \"abc\"\n+     * StringUtils.getCommonPrefix(new String[] {\"abc\", \"a\"}) = \"a\"\n+     * StringUtils.getCommonPrefix(new String[] {\"ab\", \"abxyz\"}) = \"ab\"\n+     * StringUtils.getCommonPrefix(new String[] {\"abcde\", \"abxyz\"}) = \"ab\"\n+     * StringUtils.getCommonPrefix(new String[] {\"abcde\", \"xyz\"}) = \"\"\n+     * StringUtils.getCommonPrefix(new String[] {\"xyz\", \"abcde\"}) = \"\"\n+     * StringUtils.getCommonPrefix(new String[] {\"i am a machine\", \"i am a robot\"}) = \"i am a \"\n+     * </pre>\n+     *\n+     * @param strs  array of String objects, entries may be null\n+     * @return the initial sequence of characters that are common to all Strings\n+     * in the array; empty String if the array is null, the elements are all null \n+     * or if there is no common prefix. \n+     * @since 2.4\n+     */\n+    public static String getCommonPrefix(String[] strs) {\n+        if (strs == null || strs.length == 0) {\n+            return EMPTY;\n+        }\n+        int smallestIndexOfDiff = indexOfDifference(strs);\n+        if (smallestIndexOfDiff == -1) {\n+            // all strings were identical\n+            if (strs[0] == null) {\n+                return EMPTY;\n+            }\n+            return strs[0];\n+        } else if (smallestIndexOfDiff == 0) {\n+            // there were no common initial characters\n+            return EMPTY;\n+        } else {\n+            // we found a common initial character sequence\n+            return strs[0].substring(0, smallestIndexOfDiff);\n+        }\n+    }  \n+    \n+    // Misc\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Find the Levenshtein distance between two Strings.</p>\n+     *\n+     * <p>This is the number of changes needed to change one String into\n+     * another, where each change is a single character modification (deletion,\n+     * insertion or substitution).</p>\n+     *\n+     * <p>The previous implementation of the Levenshtein distance algorithm\n+     * was from <a href=\"http://www.merriampark.com/ld.htm\">http://www.merriampark.com/ld.htm</a></p>\n+     *\n+     * <p>Chas Emerick has written an implementation in Java, which avoids an OutOfMemoryError\n+     * which can occur when my Java implementation is used with very large strings.<br>\n+     * This implementation of the Levenshtein distance algorithm\n+     * is from <a href=\"http://www.merriampark.com/ldjava.htm\">http://www.merriampark.com/ldjava.htm</a></p>\n+     *\n+     * <pre>\n+     * StringUtils.getLevenshteinDistance(null, *)             = IllegalArgumentException\n+     * StringUtils.getLevenshteinDistance(*, null)             = IllegalArgumentException\n+     * StringUtils.getLevenshteinDistance(\"\",\"\")               = 0\n+     * StringUtils.getLevenshteinDistance(\"\",\"a\")              = 1\n+     * StringUtils.getLevenshteinDistance(\"aaapppp\", \"\")       = 7\n+     * StringUtils.getLevenshteinDistance(\"frog\", \"fog\")       = 1\n+     * StringUtils.getLevenshteinDistance(\"fly\", \"ant\")        = 3\n+     * StringUtils.getLevenshteinDistance(\"elephant\", \"hippo\") = 7\n+     * StringUtils.getLevenshteinDistance(\"hippo\", \"elephant\") = 7\n+     * StringUtils.getLevenshteinDistance(\"hippo\", \"zzzzzzzz\") = 8\n+     * StringUtils.getLevenshteinDistance(\"hello\", \"hallo\")    = 1\n+     * </pre>\n+     *\n+     * @param s  the first String, must not be null\n+     * @param t  the second String, must not be null\n+     * @return result distance\n+     * @throws IllegalArgumentException if either String input <code>null</code>\n+     */\n+    public static int getLevenshteinDistance(String s, String t) {\n+        if (s == null || t == null) {\n+            throw new IllegalArgumentException(\"Strings must not be null\");\n+        }\n+\n+        /*\n+           The difference between this impl. and the previous is that, rather \n+           than creating and retaining a matrix of size s.length()+1 by t.length()+1, \n+           we maintain two single-dimensional arrays of length s.length()+1.  The first, d,\n+           is the 'current working' distance array that maintains the newest distance cost\n+           counts as we iterate through the characters of String s.  Each time we increment\n+           the index of String t we are comparing, d is copied to p, the second int[].  Doing so\n+           allows us to retain the previous cost counts as required by the algorithm (taking \n+           the minimum of the cost count to the left, up one, and diagonally up and to the left\n+           of the current cost count being calculated).  (Note that the arrays aren't really \n+           copied anymore, just switched...this is clearly much better than cloning an array \n+           or doing a System.arraycopy() each time  through the outer loop.)\n+\n+           Effectively, the difference between the two implementations is this one does not \n+           cause an out of memory condition when calculating the LD over two very large strings.\n+         */\n+\n+        int n = s.length(); // length of s\n+        int m = t.length(); // length of t\n+\n+        if (n == 0) {\n+            return m;\n+        } else if (m == 0) {\n+            return n;\n+        }\n+\n+        if (n > m) {\n+            // swap the input strings to consume less memory\n+            String tmp = s;\n+            s = t;\n+            t = tmp;\n+            n = m;\n+            m = t.length();\n+        }\n+\n+        int p[] = new int[n+1]; //'previous' cost array, horizontally\n+        int d[] = new int[n+1]; // cost array, horizontally\n+        int _d[]; //placeholder to assist in swapping p and d\n+\n+        // indexes into strings s and t\n+        int i; // iterates through s\n+        int j; // iterates through t\n+\n+        char t_j; // jth character of t\n+\n+        int cost; // cost\n+\n+        for (i = 0; i<=n; i++) {\n+            p[i] = i;\n+        }\n+\n+        for (j = 1; j<=m; j++) {\n+            t_j = t.charAt(j-1);\n+            d[0] = j;\n+\n+            for (i=1; i<=n; i++) {\n+                cost = s.charAt(i-1)==t_j ? 0 : 1;\n+                // minimum of cell to the left+1, to the top+1, diagonally left and up +cost\n+                d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]+cost);\n+            }\n+\n+            // copy current distance counts to 'previous row' distance counts\n+            _d = p;\n+            p = d;\n+            d = _d;\n+        }\n+\n+        // our last action in the above loop was to switch d and p, so p now \n+        // actually has the most recent cost counts\n+        return p[n];\n+    }\n+\n+    /**\n+     * <p>Gets the minimum of three <code>int</code> values.</p>\n+     *\n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the smallest of the values\n+     */\n+/*\n+    private static int min(int a, int b, int c) {\n+        // Method copied from NumberUtils to avoid dependency on subpackage\n+        if (b < a) {\n+            a = b;\n+        }\n+        if (c < a) {\n+            a = c;\n+        }\n+        return a;\n+    }\n+*/\n+\n+    // startsWith\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * <p>Check if a String starts with a specified prefix.</p>\n+     *\n+     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n+     * references are considered to be equal. The comparison is case sensitive.</p>\n+     *\n+     * <pre>\n+     * StringUtils.startsWith(null, null)      = true\n+     * StringUtils.startsWith(null, \"abc\")     = false\n+     * StringUtils.startsWith(\"abcdef\", null)  = false\n+     * StringUtils.startsWith(\"abcdef\", \"abc\") = true\n+     * StringUtils.startsWith(\"ABCDEF\", \"abc\") = false\n+     * </pre>\n+     *\n+     * @see java.lang.String#startsWith(String)\n+     * @param str  the String to check, may be null\n+     * @param prefix the prefix to find, may be null\n+     * @return <code>true</code> if the String starts with the prefix, case sensitive, or\n+     *  both <code>null</code>\n+     * @since 2.4\n+     */\n+    public static boolean startsWith(String str, String prefix) {\n+        return startsWith(str, prefix, false);\n+    }\n+\n+    /**\n+     * <p>Case insensitive check if a String starts with a specified prefix.</p>\n+     *\n+     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n+     * references are considered to be equal. The comparison is case insensitive.</p>\n+     *\n+     * <pre>\n+     * StringUtils.startsWithIgnoreCase(null, null)      = true\n+     * StringUtils.startsWithIgnoreCase(null, \"abc\")     = false\n+     * StringUtils.startsWithIgnoreCase(\"abcdef\", null)  = false\n+     * StringUtils.startsWithIgnoreCase(\"abcdef\", \"abc\") = true\n+     * StringUtils.startsWithIgnoreCase(\"ABCDEF\", \"abc\") = true\n+     * </pre>\n+     *\n+     * @see java.lang.String#startsWith(String)\n+     * @param str  the String to check, may be null\n+     * @param prefix the prefix to find, may be null\n+     * @return <code>true</code> if the String starts with the prefix, case insensitive, or\n+     *  both <code>null</code>\n+     * @since 2.4\n+     */\n+    public static boolean startsWithIgnoreCase(String str, String prefix) {\n+        return startsWith(str, prefix, true);\n+    }\n+\n+    /**\n+     * <p>Check if a String starts with a specified prefix (optionally case insensitive).</p>\n+     *\n+     * @see java.lang.String#startsWith(String)\n+     * @param str  the String to check, may be null\n+     * @param prefix the prefix to find, may be null\n+     * @param ignoreCase inidicates whether the compare should ignore case\n+     *  (case insensitive) or not.\n+     * @return <code>true</code> if the String starts with the prefix or\n+     *  both <code>null</code>\n+     */\n+    private static boolean startsWith(String str, String prefix, boolean ignoreCase) {\n+        if (str == null || prefix == null) {\n+            return (str == null && prefix == null);\n+        }\n+        if (prefix.length() > str.length()) {\n+            return false;\n+        }\n+        return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length());\n+    }\n+    \n+    /**\n+     * <p>Check if a String starts with any of an array of specified strings.</p>\n+     * \n+     * <pre>\n+     * StringUtils.startsWithAny(null, null)      = false\n+     * StringUtils.startsWithAny(null, new String[] {\"abc\"})  = false\n+     * StringUtils.startsWithAny(\"abcxyz\", null)     = false\n+     * StringUtils.startsWithAny(\"abcxyz\", new String[] {\"\"}) = false\n+     * StringUtils.startsWithAny(\"abcxyz\", new String[] {\"abc\"}) = true\n+     * StringUtils.startsWithAny(\"abcxyz\", new String[] {null, \"xyz\", \"abc\"}) = true\n+     * </pre>\n+     *\n+     * @param string  the String to check, may be null\n+     * @param searchStrings the Strings to find, may be null or empty\n+     * @return <code>true</code> if the String starts with any of the the prefixes, case insensitive, or\n+     *  both <code>null</code>\n+     * @since 3.0\n+     */\n+    public static boolean startsWithAny(String string, String[] searchStrings) {\n+        if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {\n+            return false;\n+        }\n+        for (int i = 0; i < searchStrings.length; i++) {\n+            String searchString = searchStrings[i];\n+            if (StringUtils.startsWith(string, searchString)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    // endsWith\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * <p>Check if a String ends with a specified suffix.</p>\n+     *\n+     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n+     * references are considered to be equal. The comparison is case sensitive.</p>\n+     *\n+     * <pre>\n+     * StringUtils.endsWith(null, null)      = true\n+     * StringUtils.endsWith(null, \"def\")     = false\n+     * StringUtils.endsWith(\"abcdef\", null)  = false\n+     * StringUtils.endsWith(\"abcdef\", \"def\") = true\n+     * StringUtils.endsWith(\"ABCDEF\", \"def\") = false\n+     * StringUtils.endsWith(\"ABCDEF\", \"cde\") = false\n+     * </pre>\n+     *\n+     * @see java.lang.String#endsWith(String)\n+     * @param str  the String to check, may be null\n+     * @param suffix the suffix to find, may be null\n+     * @return <code>true</code> if the String ends with the suffix, case sensitive, or\n+     *  both <code>null</code>\n+     * @since 2.4\n+     */\n+    public static boolean endsWith(String str, String suffix) {\n+        return endsWith(str, suffix, false);\n+    }\n+\n+    /**\n+     * <p>Case insensitive check if a String ends with a specified suffix.</p>\n+     *\n+     * <p><code>null</code>s are handled without exceptions. Two <code>null</code>\n+     * references are considered to be equal. The comparison is case insensitive.</p>\n+     *\n+     * <pre>\n+     * StringUtils.endsWithIgnoreCase(null, null)      = true\n+     * StringUtils.endsWithIgnoreCase(null, \"def\")     = false\n+     * StringUtils.endsWithIgnoreCase(\"abcdef\", null)  = false\n+     * StringUtils.endsWithIgnoreCase(\"abcdef\", \"def\") = true\n+     * StringUtils.endsWithIgnoreCase(\"ABCDEF\", \"def\") = true\n+     * StringUtils.endsWithIgnoreCase(\"ABCDEF\", \"cde\") = false\n+     * </pre>\n+     *\n+     * @see java.lang.String#endsWith(String)\n+     * @param str  the String to check, may be null\n+     * @param suffix the suffix to find, may be null\n+     * @return <code>true</code> if the String ends with the suffix, case insensitive, or\n+     *  both <code>null</code>\n+     * @since 2.4\n+     */\n+    public static boolean endsWithIgnoreCase(String str, String suffix) {\n+        return endsWith(str, suffix, true);\n+    }\n+\n+    /**\n+     * <p>Check if a String ends with a specified suffix (optionally case insensitive).</p>\n+     *\n+     * @see java.lang.String#endsWith(String)\n+     * @param str  the String to check, may be null\n+     * @param suffix the suffix to find, may be null\n+     * @param ignoreCase inidicates whether the compare should ignore case\n+     *  (case insensitive) or not.\n+     * @return <code>true</code> if the String starts with the prefix or\n+     *  both <code>null</code>\n+     */\n+    private static boolean endsWith(String str, String suffix, boolean ignoreCase) {\n+        if (str == null || suffix == null) {\n+            return (str == null && suffix == null);\n+        }\n+        if (suffix.length() > str.length()) {\n+            return false;\n+        }\n+        int strOffset = str.length() - suffix.length();\n+        return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length());\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/SystemUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3;\n+\n+import java.io.File;\n+\n+/**\n+ * <p>Helpers for <code>java.lang.System</code>.</p>\n+ * \n+ * <p>If a system property cannot be read due to security restrictions, \n+ * the corresponding field in this class will be set to <code>null</code>\n+ * and a message will be written to <code>System.err</code>.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author Based on code from Avalon Excalibur\n+ * @author Based on code from Lucene\n+ * @author <a href=\"mailto:sdowney@panix.com\">Steve Downey</a>\n+ * @author Gary Gregory\n+ * @author Michael Becke\n+ * @author Tetsuya Kaneuchi\n+ * @author Rafal Krupinski\n+ * @author Jason Gritman\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class SystemUtils {\n+\n+    /**\n+     * The prefix String for all Windows OS.\n+     */\n+    private static final String OS_NAME_WINDOWS_PREFIX = \"Windows\";\n+    \n+    // System property constants\n+    //-----------------------------------------------------------------------\n+    // These MUST be declared first. Other constants depend on this.\n+    \n+    /**\n+     * The System property key for the user home directory.\n+     */\n+    private static final String USER_HOME_KEY = \"user.home\";\n+\n+    /**\n+     * The System property key for the user directory.\n+     */\n+    private static final String USER_DIR_KEY = \"user.dir\";\n+    \n+    /**\n+     * The System property key for the Java IO temporary directory.\n+     */\n+    private static final String JAVA_IO_TMPDIR_KEY = \"java.io.tmpdir\";\n+    \n+    /**\n+     * The System property key for the Java home directory.\n+     */\n+    private static final String JAVA_HOME_KEY = \"java.home\";\n+    \n+    /**\n+     * <p>The <code>awt.toolkit</code> System Property.</p>\n+     * <p>Holds a class name, on Windows XP this is <code>sun.awt.windows.WToolkit</code>.</p>\n+     * <p><b>On platforms without a GUI, this value is <code>null</code>.</b></p>\n+     * \n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since 2.1\n+     */\n+    public static final String AWT_TOOLKIT = getSystemProperty(\"awt.toolkit\");\n+\n+    /**\n+     * <p>The <code>file.encoding</code> System Property.</p>\n+     * <p>File encoding, such as <code>Cp1252</code>.</p>\n+     * \n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since 2.0\n+     * @since Java 1.2\n+     */\n+    public static final String FILE_ENCODING = getSystemProperty(\"file.encoding\");\n+\n+    /**\n+     * <p>The <code>file.separator</code> System Property.\n+     * File separator (<code>&quot;/&quot;</code> on UNIX).</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String FILE_SEPARATOR = getSystemProperty(\"file.separator\");\n+\n+    /**\n+     * <p>The <code>java.awt.fonts</code> System Property.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since 2.1\n+     */\n+    public static final String JAVA_AWT_FONTS = getSystemProperty(\"java.awt.fonts\");\n+\n+    /**\n+     * <p>The <code>java.awt.graphicsenv</code> System Property.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since 2.1\n+     */\n+    public static final String JAVA_AWT_GRAPHICSENV = getSystemProperty(\"java.awt.graphicsenv\");\n+\n+    /**\n+     * <p>\n+     * The <code>java.awt.headless</code> System Property.\n+     * The value of this property is the String <code>\"true\"</code> or <code>\"false\"</code>. \n+     * </p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @see #isJavaAwtHeadless()\n+     * @since 2.1\n+     * @since Java 1.4\n+     */\n+    public static final String JAVA_AWT_HEADLESS = getSystemProperty(\"java.awt.headless\");\n+\n+    /**\n+     * <p>The <code>java.awt.printerjob</code> System Property.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since 2.1\n+     */\n+    public static final String JAVA_AWT_PRINTERJOB = getSystemProperty(\"java.awt.printerjob\");\n+\n+    /**\n+     * <p>The <code>java.class.path</code> System Property. Java class path.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String JAVA_CLASS_PATH = getSystemProperty(\"java.class.path\");\n+\n+    /**\n+     * <p>The <code>java.class.version</code> System Property.\n+     * Java class format version number.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String JAVA_CLASS_VERSION = getSystemProperty(\"java.class.version\");\n+\n+    /**\n+     * <p>The <code>java.compiler</code> System Property. Name of JIT compiler to use.\n+     * First in JDK version 1.2. Not used in Sun JDKs after 1.2.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.2. Not used in Sun versions after 1.2.\n+     */\n+    public static final String JAVA_COMPILER = getSystemProperty(\"java.compiler\");\n+\n+    /**\n+     * <p>The <code>java.endorsed.dirs</code> System Property. Path of endorsed directory\n+     * or directories.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.4\n+     */\n+    public static final String JAVA_ENDORSED_DIRS = getSystemProperty(\"java.endorsed.dirs\");\n+\n+    /**\n+     * <p>The <code>java.ext.dirs</code> System Property. Path of extension directory\n+     * or directories.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.3\n+     */\n+    public static final String JAVA_EXT_DIRS = getSystemProperty(\"java.ext.dirs\");\n+\n+    /**\n+     * <p>The <code>java.home</code> System Property. Java installation directory.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String JAVA_HOME = getSystemProperty(JAVA_HOME_KEY);\n+\n+    /**\n+     * <p>The <code>java.io.tmpdir</code> System Property. Default temp file path.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.2\n+     */\n+    public static final String JAVA_IO_TMPDIR = getSystemProperty(JAVA_IO_TMPDIR_KEY);\n+\n+    /**\n+     * <p>The <code>java.library.path</code> System Property. List of paths to search\n+     * when loading libraries.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.2\n+     */\n+    public static final String JAVA_LIBRARY_PATH = getSystemProperty(\"java.library.path\");\n+\n+    /**\n+     * <p>The <code>java.runtime.name</code> System Property. Java Runtime Environment\n+     * name.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since 2.0\n+     * @since Java 1.3\n+     */\n+    public static final String JAVA_RUNTIME_NAME = getSystemProperty(\"java.runtime.name\");\n+\n+    /**\n+     * <p>The <code>java.runtime.version</code> System Property. Java Runtime Environment\n+     * version.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since 2.0\n+     * @since Java 1.3\n+     */\n+    public static final String JAVA_RUNTIME_VERSION = getSystemProperty(\"java.runtime.version\");\n+\n+    /**\n+     * <p>The <code>java.specification.name</code> System Property. Java Runtime Environment\n+     * specification name.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.2\n+     */\n+    public static final String JAVA_SPECIFICATION_NAME = getSystemProperty(\"java.specification.name\");\n+\n+    /**\n+     * <p>The <code>java.specification.vendor</code> System Property. Java Runtime Environment\n+     * specification vendor.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.2\n+     */\n+    public static final String JAVA_SPECIFICATION_VENDOR = getSystemProperty(\"java.specification.vendor\");\n+\n+    /**\n+     * <p>The <code>java.specification.version</code> System Property. Java Runtime Environment\n+     * specification version.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.3\n+     */\n+    public static final String JAVA_SPECIFICATION_VERSION = getSystemProperty(\"java.specification.version\");\n+\n+    /**\n+     * <p>The <code>java.util.prefs.PreferencesFactory</code> System Property. A class name.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since 2.1\n+     * @since Java 1.4\n+     */\n+    public static final String JAVA_UTIL_PREFS_PREFERENCES_FACTORY = \n+        getSystemProperty(\"java.util.prefs.PreferencesFactory\");\n+\n+    /**\n+     * <p>The <code>java.vendor</code> System Property. Java vendor-specific string.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String JAVA_VENDOR = getSystemProperty(\"java.vendor\");\n+\n+    /**\n+     * <p>The <code>java.vendor.url</code> System Property. Java vendor URL.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+    */\n+    public static final String JAVA_VENDOR_URL = getSystemProperty(\"java.vendor.url\");\n+\n+    /**\n+     * <p>The <code>java.version</code> System Property. Java version number.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String JAVA_VERSION = getSystemProperty(\"java.version\");\n+\n+    /**\n+     * <p>The <code>java.vm.info</code> System Property. Java Virtual Machine implementation\n+     * info.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since 2.0\n+     * @since Java 1.2\n+     */\n+    public static final String JAVA_VM_INFO = getSystemProperty(\"java.vm.info\");\n+\n+    /**\n+     * <p>The <code>java.vm.name</code> System Property. Java Virtual Machine implementation\n+     * name.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.2\n+     */\n+    public static final String JAVA_VM_NAME = getSystemProperty(\"java.vm.name\");\n+\n+    /**\n+     * <p>The <code>java.vm.specification.name</code> System Property. Java Virtual Machine\n+     * specification name.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.2\n+     */\n+    public static final String JAVA_VM_SPECIFICATION_NAME = getSystemProperty(\"java.vm.specification.name\");\n+\n+    /**\n+     * <p>The <code>java.vm.specification.vendor</code> System Property. Java Virtual\n+     * Machine specification vendor.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.2\n+     */\n+    public static final String JAVA_VM_SPECIFICATION_VENDOR = getSystemProperty(\"java.vm.specification.vendor\");\n+\n+    /**\n+     * <p>The <code>java.vm.specification.version</code> System Property. Java Virtual Machine\n+     * specification version.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.2\n+     */\n+    public static final String JAVA_VM_SPECIFICATION_VERSION = getSystemProperty(\"java.vm.specification.version\");\n+\n+    /**\n+     * <p>The <code>java.vm.vendor</code> System Property. Java Virtual Machine implementation\n+     * vendor.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.2\n+     */\n+    public static final String JAVA_VM_VENDOR = getSystemProperty(\"java.vm.vendor\");\n+\n+    /**\n+     * <p>The <code>java.vm.version</code> System Property. Java Virtual Machine\n+     * implementation version.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.2\n+     */\n+    public static final String JAVA_VM_VERSION = getSystemProperty(\"java.vm.version\");\n+\n+    /**\n+     * <p>The <code>line.separator</code> System Property. Line separator\n+     * (<code>&quot;\\n&quot;</code> on UNIX).</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String LINE_SEPARATOR = getSystemProperty(\"line.separator\");\n+\n+    /**\n+     * <p>The <code>os.arch</code> System Property. Operating system architecture.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String OS_ARCH = getSystemProperty(\"os.arch\");\n+\n+    /**\n+     * <p>The <code>os.name</code> System Property. Operating system name.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String OS_NAME = getSystemProperty(\"os.name\");\n+\n+    /**\n+     * <p>The <code>os.version</code> System Property. Operating system version.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String OS_VERSION = getSystemProperty(\"os.version\");\n+\n+    /**\n+     * <p>The <code>path.separator</code> System Property. Path separator\n+     * (<code>&quot;:&quot;</code> on UNIX).</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String PATH_SEPARATOR = getSystemProperty(\"path.separator\");\n+\n+    /**\n+     * <p>The <code>user.country</code> or <code>user.region</code> System Property.\n+     * User's country code, such as <code>GB</code>. First in JDK version 1.2 as\n+     * <code>user.region</code>. Renamed to <code>user.country</code> in 1.4</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since 2.0\n+     * @since Java 1.2\n+     */\n+    public static final String USER_COUNTRY = \n+        getSystemProperty(\"user.country\") == null ?\n+            getSystemProperty(\"user.region\") : getSystemProperty(\"user.country\");\n+\n+    /**\n+     * <p>The <code>user.dir</code> System Property. User's current working\n+     * directory.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String USER_DIR = getSystemProperty(USER_DIR_KEY);\n+\n+    /**\n+     * <p>The <code>user.home</code> System Property. User's home directory.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String USER_HOME = getSystemProperty(USER_HOME_KEY);\n+\n+    /**\n+     * <p>The <code>user.language</code> System Property. User's language code,\n+     * such as <code>\"en\"</code>.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since 2.0\n+     * @since Java 1.2\n+     */\n+    public static final String USER_LANGUAGE = getSystemProperty(\"user.language\");\n+\n+    /**\n+     * <p>The <code>user.name</code> System Property. User's account name.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since Java 1.1\n+     */\n+    public static final String USER_NAME = getSystemProperty(\"user.name\");\n+\n+    /**\n+     * <p>The <code>user.timezone</code> System Property. \n+     * For example: <code>\"America/Los_Angeles\"</code>.</p>\n+     *\n+     * <p>Defaults to <code>null</code> if the runtime does not have\n+     * security access to read this property or the property does not exist.</p>\n+     * \n+     * <p>\n+     * This value is initialized when the class is loaded. If {@link System#setProperty(String,String)}\n+     * or {@link System#setProperties(java.util.Properties)} is called after this class is loaded, the value\n+     * will be out of sync with that System property.\n+     * </p>\n+     * \n+     * @since 2.1\n+     */\n+    public static final String USER_TIMEZONE = getSystemProperty(\"user.timezone\");\n+\n+    // Java version\n+    //-----------------------------------------------------------------------\n+    // This MUST be declared after those above as it depends on the\n+    // values being set up\n+\n+    /**\n+     * <p>Gets the Java version as a <code>String</code> trimming leading letters.</p>\n+     *\n+     * <p>The field will return <code>null</code> if {@link #JAVA_VERSION} is <code>null</code>.</p>\n+     * \n+     * @since 2.1\n+     */\n+    public static final String JAVA_VERSION_TRIMMED = getJavaVersionTrimmed();\n+\n+    // Java version values\n+    //-----------------------------------------------------------------------\n+    // These MUST be declared after the trim above as they depend on the\n+    // value being set up\n+\n+    /**\n+     * <p>Gets the Java version as a <code>float</code>.</p>\n+     *\n+     * <p>Example return values:</p>\n+     * <ul>\n+     *  <li><code>1.2f</code> for JDK 1.2\n+     *  <li><code>1.31f</code> for JDK 1.3.1\n+     * </ul>\n+     *\n+     * <p>The field will return zero if {@link #JAVA_VERSION} is <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final float JAVA_VERSION_FLOAT = getJavaVersionAsFloat();\n+\n+    /**\n+     * <p>Gets the Java version as an <code>int</code>.</p>\n+     *\n+     * <p>Example return values:</p>\n+     * <ul>\n+     *  <li><code>120</code> for JDK 1.2\n+     *  <li><code>131</code> for JDK 1.3.1\n+     * </ul>\n+     *\n+     * <p>The field will return zero if {@link #JAVA_VERSION} is <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final int JAVA_VERSION_INT = getJavaVersionAsInt();\n+\n+    // Java version checks\n+    //-----------------------------------------------------------------------\n+    // These MUST be declared after those above as they depend on the\n+    // values being set up\n+    \n+    /**\n+     * <p>Is <code>true</code> if this is Java version 1.1 (also 1.1.x versions).</p>\n+     *\n+     * <p>The field will return <code>false</code> if {@link #JAVA_VERSION} is\n+     * <code>null</code>.</p>\n+     */\n+    public static final boolean IS_JAVA_1_1 = getJavaVersionMatches(\"1.1\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Java version 1.2 (also 1.2.x versions).</p>\n+     *\n+     * <p>The field will return <code>false</code> if {@link #JAVA_VERSION} is\n+     * <code>null</code>.</p>\n+     */\n+    public static final boolean IS_JAVA_1_2 = getJavaVersionMatches(\"1.2\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Java version 1.3 (also 1.3.x versions).</p>\n+     *\n+     * <p>The field will return <code>false</code> if {@link #JAVA_VERSION} is\n+     * <code>null</code>.</p>\n+     */\n+    public static final boolean IS_JAVA_1_3 = getJavaVersionMatches(\"1.3\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Java version 1.4 (also 1.4.x versions).</p>\n+     *\n+     * <p>The field will return <code>false</code> if {@link #JAVA_VERSION} is\n+     * <code>null</code>.</p>\n+     */\n+    public static final boolean IS_JAVA_1_4 = getJavaVersionMatches(\"1.4\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Java version 1.5 (also 1.5.x versions).</p>\n+     *\n+     * <p>The field will return <code>false</code> if {@link #JAVA_VERSION} is\n+     * <code>null</code>.</p>\n+     */\n+    public static final boolean IS_JAVA_1_5 = getJavaVersionMatches(\"1.5\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Java version 1.6 (also 1.6.x versions).</p>\n+     *\n+     * <p>The field will return <code>false</code> if {@link #JAVA_VERSION} is\n+     * <code>null</code>.</p>\n+     */\n+    public static final boolean IS_JAVA_1_6 = getJavaVersionMatches(\"1.6\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Java version 1.7 (also 1.7.x versions).</p>\n+     *\n+     * <p>The field will return <code>false</code> if {@link #JAVA_VERSION} is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 3.0\n+     */\n+    public static final boolean IS_JAVA_1_7 = getJavaVersionMatches(\"1.7\");\n+\n+    // Operating system checks\n+    //-----------------------------------------------------------------------\n+    // These MUST be declared after those above as they depend on the\n+    // values being set up\n+    // OS names from http://www.vamphq.com/os.html\n+    // Selected ones included - please advise dev@commons.apache.org\n+    // if you want another added or a mistake corrected\n+\n+    /**\n+     * <p>Is <code>true</code> if this is AIX.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_AIX = getOSMatches(\"AIX\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is HP-UX.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_HP_UX = getOSMatches(\"HP-UX\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Irix.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_IRIX = getOSMatches(\"Irix\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Linux.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_LINUX = getOSMatches(\"Linux\") || getOSMatches(\"LINUX\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Mac.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_MAC = getOSMatches(\"Mac\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Mac.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_MAC_OSX = getOSMatches(\"Mac OS X\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is OS/2.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_OS2 = getOSMatches(\"OS/2\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Solaris.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_SOLARIS = getOSMatches(\"Solaris\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is SunOS.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_SUN_OS = getOSMatches(\"SunOS\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is a POSIX compilant system,\n+     * as in any of AIX, HP-UX, Irix, Linux, MacOSX, Solaris or SUN OS.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.1\n+     */\n+    public static final boolean IS_OS_UNIX =\n+        IS_OS_AIX || IS_OS_HP_UX || IS_OS_IRIX || IS_OS_LINUX ||\n+        IS_OS_MAC_OSX || IS_OS_SOLARIS || IS_OS_SUN_OS;\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Windows.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_WINDOWS = getOSMatches(OS_NAME_WINDOWS_PREFIX);\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Windows 2000.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_WINDOWS_2000 = getOSMatches(OS_NAME_WINDOWS_PREFIX, \"5.0\");\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Windows 95.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_WINDOWS_95 = getOSMatches(OS_NAME_WINDOWS_PREFIX + \" 9\", \"4.0\");\n+    // JDK 1.2 running on Windows98 returns 'Windows 95', hence the above\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Windows 98.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_WINDOWS_98 = getOSMatches(OS_NAME_WINDOWS_PREFIX + \" 9\", \"4.1\");\n+    // JDK 1.2 running on Windows98 returns 'Windows 95', hence the above\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Windows ME.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_WINDOWS_ME = getOSMatches(OS_NAME_WINDOWS_PREFIX, \"4.9\");\n+    // JDK 1.2 running on WindowsME may return 'Windows 95', hence the above\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Windows NT.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_WINDOWS_NT = getOSMatches(OS_NAME_WINDOWS_PREFIX + \" NT\");\n+    // Windows 2000 returns 'Windows 2000' but may suffer from same JDK1.2 problem\n+\n+    /**\n+     * <p>Is <code>true</code> if this is Windows XP.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     * \n+     * @since 2.0\n+     */\n+    public static final boolean IS_OS_WINDOWS_XP = getOSMatches(OS_NAME_WINDOWS_PREFIX, \"5.1\");\n+\n+    //-----------------------------------------------------------------------    \n+    /**\n+     * <p>Is <code>true</code> if this is Windows Vista.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     *\n+     * @since 2.4\n+     */\n+    public static final boolean IS_OS_WINDOWS_VISTA = getOSMatches(OS_NAME_WINDOWS_PREFIX, \"6.0\"); \n+\n+    /**\n+     * <p>Is <code>true</code> if this is Windows 7.</p>\n+     *\n+     * <p>The field will return <code>false</code> if <code>OS_NAME</code> is\n+     * <code>null</code>.</p>\n+     *\n+     * @since 3.0\n+     */\n+    public static final boolean IS_OS_WINDOWS_7 = getOSMatches(OS_NAME_WINDOWS_PREFIX, \"6.1\"); \n+\n+    //-----------------------------------------------------------------------    \n+    /**\n+     * <p>SystemUtils instances should NOT be constructed in standard\n+     * programming. Instead, the class should be used as\n+     * <code>SystemUtils.FILE_SEPARATOR</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean\n+     * instance to operate.</p>\n+     */\n+    public SystemUtils() {\n+        super();\n+    }\n+    \n+    //-----------------------------------------------------------------------    \n+    /**\n+     * <p>Gets the Java version number as a <code>float</code>.</p>\n+     *\n+     * <p>Example return values:</p>\n+     * <ul>\n+     *  <li><code>1.2f</code> for JDK 1.2\n+     *  <li><code>1.31f</code> for JDK 1.3.1\n+     * </ul>\n+     * \n+     * <p>Patch releases are not reported.\n+     * Zero is returned if {@link #JAVA_VERSION_TRIMMED} is <code>null</code>.</p>\n+     * \n+     * @return the version, for example 1.31f for JDK 1.3.1\n+     */\n+    private static float getJavaVersionAsFloat() {\n+        if (JAVA_VERSION_TRIMMED == null) {\n+            return 0f;\n+        }\n+        String str = JAVA_VERSION_TRIMMED.substring(0, 3);\n+        if (JAVA_VERSION_TRIMMED.length() >= 5) {\n+            str = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n+        }\n+        try {\n+            return Float.parseFloat(str);\n+        } catch (Exception ex) {\n+            return 0;\n+        }\n+    }\n+    \n+    /**\n+     * <p>Gets the Java version number as an <code>int</code>.</p>\n+     *\n+     * <p>Example return values:</p>\n+     * <ul>\n+     *  <li><code>120</code> for JDK 1.2\n+     *  <li><code>131</code> for JDK 1.3.1\n+     * </ul>\n+     * \n+     * <p>Patch releases are not reported.\n+     * Zero is returned if {@link #JAVA_VERSION_TRIMMED} is <code>null</code>.</p>\n+     * \n+     * @return the version, for example 131 for JDK 1.3.1\n+     */\n+    private static int getJavaVersionAsInt() {\n+        if (JAVA_VERSION_TRIMMED == null) {\n+            return 0;\n+        }\n+        String str = JAVA_VERSION_TRIMMED.substring(0, 1);\n+        str = str + JAVA_VERSION_TRIMMED.substring(2, 3);\n+        if (JAVA_VERSION_TRIMMED.length() >= 5) {\n+            str = str + JAVA_VERSION_TRIMMED.substring(4, 5);\n+        } else {\n+            str = str + \"0\";\n+        }\n+        try {\n+            return Integer.parseInt(str);\n+        } catch (Exception ex) {\n+            return 0;\n+        }\n+    }\n+\n+    /**\n+     * Trims the text of the java version to start with numbers.\n+     * \n+     * @return the trimmed java version\n+     */\n+    private static String getJavaVersionTrimmed() {\n+        if (JAVA_VERSION != null) {\n+            for (int i = 0; i < JAVA_VERSION.length(); i++) {\n+                char ch = JAVA_VERSION.charAt(i);\n+                if (ch >= '0' && ch <= '9') {\n+                    return JAVA_VERSION.substring(i);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * <p>Decides if the java version matches.</p>\n+     * \n+     * @param versionPrefix  the prefix for the java version\n+     * @return true if matches, or false if not or can't determine\n+     */\n+    private static boolean getJavaVersionMatches(String versionPrefix) {\n+        if (JAVA_VERSION_TRIMMED == null) {\n+            return false;\n+        }\n+        return JAVA_VERSION_TRIMMED.startsWith(versionPrefix);\n+    }    \n+    \n+    /**\n+     * <p>Decides if the operating system matches.</p>\n+     * \n+     * @param osNamePrefix  the prefix for the os name\n+     * @return true if matches, or false if not or can't determine\n+     */\n+    private static boolean getOSMatches(String osNamePrefix) {\n+        if (OS_NAME == null) {\n+            return false;\n+        }\n+        return OS_NAME.startsWith(osNamePrefix);\n+    }    \n+\n+    /**\n+     * <p>Decides if the operating system matches.</p>\n+     * \n+     * @param osNamePrefix  the prefix for the os name\n+     * @param osVersionPrefix  the prefix for the version\n+     * @return true if matches, or false if not or can't determine\n+     */\n+    private static boolean getOSMatches(String osNamePrefix, String osVersionPrefix) {\n+        if (OS_NAME == null || OS_VERSION == null) {\n+            return false;\n+        }\n+        return OS_NAME.startsWith(osNamePrefix) && OS_VERSION.startsWith(osVersionPrefix);\n+    }    \n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets a System property, defaulting to <code>null</code> if the property\n+     * cannot be read.</p>\n+     *\n+     * <p>If a <code>SecurityException</code> is caught, the return\n+     * value is <code>null</code> and a message is written to <code>System.err</code>.</p>\n+     * \n+     * @param property the system property name\n+     * @return the system property value or <code>null</code> if a security problem occurs\n+     */\n+    private static String getSystemProperty(String property) {\n+        try {\n+            return System.getProperty(property);\n+        } catch (SecurityException ex) {\n+            // we are not allowed to look at this property\n+            System.err.println(\n+                \"Caught a SecurityException reading the system property '\" + property \n+                + \"'; the SystemUtils property value will default to null.\"\n+            );\n+            return null;\n+        }\n+    }\n+    \n+    /**\n+     * <p>Is the Java version at least the requested version.</p>\n+     *\n+     * <p>Example input:</p>\n+     * <ul>\n+     *  <li><code>1.2f</code> to test for JDK 1.2</li>\n+     *  <li><code>1.31f</code> to test for JDK 1.3.1</li>\n+     * </ul>\n+     * \n+     * @param requiredVersion  the required version, for example 1.31f\n+     * @return <code>true</code> if the actual version is equal or greater\n+     *  than the required version\n+     */\n+    public static boolean isJavaVersionAtLeast(float requiredVersion) {\n+        return JAVA_VERSION_FLOAT >= requiredVersion;\n+    }\n+    \n+    /**\n+     * <p>Is the Java version at least the requested version.</p>\n+     *\n+     * <p>Example input:</p>\n+     * <ul>\n+     *  <li><code>120</code> to test for JDK 1.2 or greater</li>\n+     *  <li><code>131</code> to test for JDK 1.3.1 or greater</li>\n+     * </ul>\n+     * \n+     * @param requiredVersion  the required version, for example 131\n+     * @return <code>true</code> if the actual version is equal or greater\n+     *  than the required version\n+     * @since 2.0\n+     */\n+    public static boolean isJavaVersionAtLeast(int requiredVersion) {\n+        return JAVA_VERSION_INT >= requiredVersion;\n+    }\n+\n+    /**\n+     * Returns whether the {@link #JAVA_AWT_HEADLESS} value is <code>true</code>.\n+     *  \n+     * @return <code>true</code> if <code>JAVA_AWT_HEADLESS</code> is <code>\"true\"</code>,\n+     * <code>false</code> otherwise.\n+     * \n+     * @see #JAVA_AWT_HEADLESS\n+     * @since 2.1\n+     * @since Java 1.4\n+     */\n+    public static boolean isJavaAwtHeadless() {\n+        return JAVA_AWT_HEADLESS != null ? JAVA_AWT_HEADLESS.equals(Boolean.TRUE.toString()) : false;\n+    }\n+    /**\n+     * <p>Gets the Java home directory as a <code>File</code>.</p>\n+     * \n+     * @return a directory\n+     * @throws  SecurityException  if a security manager exists and its  \n+     *             <code>checkPropertyAccess</code> method doesn't allow\n+     *              access to the specified system property.\n+     * @see System#getProperty(String)\n+     * @since 2.1\n+     */\n+    public static File getJavaHome() {\n+        return new File(System.getProperty(JAVA_HOME_KEY));\n+    }\n+\n+    /**\n+     * <p>Gets the Java IO temporary directory as a <code>File</code>.</p>\n+     * \n+     * @return a directory\n+     * @throws  SecurityException  if a security manager exists and its  \n+     *             <code>checkPropertyAccess</code> method doesn't allow\n+     *              access to the specified system property.\n+     * @see System#getProperty(String)\n+     * @since 2.1\n+     */\n+    public static File getJavaIoTmpDir() {\n+        return new File(System.getProperty(JAVA_IO_TMPDIR_KEY));\n+    }\n+\n+    /**\n+     * <p>Gets the user directory as a <code>File</code>.</p>\n+     * \n+     * @return a directory\n+     * @throws  SecurityException  if a security manager exists and its  \n+     *             <code>checkPropertyAccess</code> method doesn't allow\n+     *              access to the specified system property.\n+     * @see System#getProperty(String)\n+     * @since 2.1\n+     */\n+    public static File getUserDir() {\n+        return new File(System.getProperty(USER_DIR_KEY));\n+    }\n+\n+    /**\n+     * <p>Gets the user home directory as a <code>File</code>.</p>\n+     * \n+     * @return a directory\n+     * @throws  SecurityException  if a security manager exists and its  \n+     *             <code>checkPropertyAccess</code> method doesn't allow\n+     *              access to the specified system property.\n+     * @see System#getProperty(String)\n+     * @since 2.1\n+     */\n+    public static File getUserHome() {\n+        return new File(System.getProperty(USER_HOME_KEY));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/Validate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+/**\n+ * <p>This class assists in validating arguments. The validation methods are \n+ * based along the following principles: \n+ * <ul>\n+ *   <li>An invalid <code>null</code> argument causes a {@link NullPointerException}.</li>\n+ *   <li>A non-<code>null</code> argument causes an {@link IllegalArgumentException}.</li>\n+ *   <li>An invalid index into an array/collection/map/string causes an {@link IndexOutOfBoundsException}.</li> \n+ * </ul>\n+ *  \n+ * <p>All exceptions messages are <a href=\"http://java.sun.com/j2se/1.5.0/docs/api/java/util/Formatter.html#syntax\">format strings</a>\n+ * as defined by the Java platform. For example:</p>\n+ * \n+ * <pre>\n+ * Validate.isTrue(i > 0, \"The value must be greater than zero: %d\", i);\n+ * Validate.notNull(surname, \"The surname must not be %s\", null);\n+ * </pre>\n+ * \n+ * @author Apache Software Foundation\n+ * @author <a href=\"mailto:ola.berg@arkitema.se\">Ola Berg</a>\n+ * @author Gary Gregory\n+ * @author Norm Deane\n+ * @author Paul Benedict\n+ * @version $Id$\n+ * @see java.lang.String#format(String, Object...)\n+ * @since 2.0\n+ */\n+public class Validate {\n+\n+    private static final String DEFAULT_IS_NULL_EXCEPTION_MESSAGE = \"The validated object is null\";\n+    private static final String DEFAULT_IS_TRUE_EXCEPTION_MESSAGE = \"The validated expression is false\";\n+    private static final String DEFAULT_NO_NULL_ELEMENTS_ARRAY_EXCEPTION_MESSAGE = \"The validated array contains null element at index: %d\";\n+    private static final String DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EXCEPTION_MESSAGE = \"The validated collection contains null element at index: %d\";\n+    private static final String DEFAULT_NOT_BLANK_EXCEPTION_MESSAGE = \"The validated character sequence is blank\";\n+    private static final String DEFAULT_NOT_EMPTY_ARRAY_EXCEPTION_MESSAGE = \"The validated array is empty\";\n+    private static final String DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EXCEPTION_MESSAGE = \"The validated character sequence is empty\";\n+    private static final String DEFAULT_NOT_EMPTY_COLLECTION_EXCEPTION_MESSAGE = \"The validated collection is empty\";\n+    private static final String DEFAULT_NOT_EMPTY_MAP_EXCEPTION_MESSAGE = \"The validated map is empty\";\n+    private static final String DEFAULT_VALID_INDEX_ARRAY_EXCEPTION_MESSAGE = \"The validated array index is invalid: %d\";\n+    private static final String DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EXCEPTION_MESSAGE = \"The validated character sequence index is invalid: %d\";\n+    private static final String DEFAULT_VALID_INDEX_COLLECTION_EXCEPTION_MESSAGE = \"The validated collection index is invalid: %d\";\n+\n+    /**\n+     * Constructor. This class should not normally be instantiated.\n+     */\n+    public Validate() {\n+      super();\n+    }\n+\n+    // isTrue\n+    //---------------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Validate that the argument condition is <code>true</code>; otherwise \n+     * throwing an exception with the specified message. This method is useful when\n+     * validating according to an arbitrary boolean expression, such as validating a \n+     * primitive number or using your own custom validation expression.</p>\n+     *\n+     * <pre>Validate.isTrue(myObject.isOk(), \"The object is not OK: %s\", myObject);</pre>\n+     *\n+     * <p>For performance reasons, the object is passed as a separate parameter and\n+     * appended to the exception message only in the case of an error.</p>\n+     * \n+     * @param expression the boolean expression to check \n+     * @param message the exception message if invalid\n+     * @param value the value to append to the message when invalid\n+     * @throws IllegalArgumentException if expression is <code>false</code>\n+     * @see #isTrue(boolean)\n+     * @see #isTrue(boolean, String, long)\n+     * @see #isTrue(boolean, String, double)\n+     * @see #isTrue(boolean, String, Object...)\n+     */\n+    public static void isTrue(boolean expression, String message, Object value) {\n+        if (expression == false) {\n+            throw new IllegalArgumentException(String.format(message, value));\n+        }\n+    }\n+\n+    /**\n+     * <p>Validate that the argument condition is <code>true</code>; otherwise \n+     * throwing an exception with the specified message. This method is useful when\n+     * validating according to an arbitrary boolean expression, such as validating a \n+     * primitive number or using your own custom validation expression.</p>\n+     *\n+     * <pre>Validate.isTrue(i > 0.0, \"The value must be greater than zero: %d\", i);</pre>\n+     *\n+     * <p>For performance reasons, the long value is passed as a separate parameter and\n+     * appended to the exception message only in the case of an error.</p>\n+     * \n+     * @param expression the boolean expression to check \n+     * @param message the exception message if invalid\n+     * @param value the value to append to the message when invalid\n+     * @throws IllegalArgumentException if expression is <code>false</code>\n+     * @see #isTrue(boolean)\n+     * @see #isTrue(boolean, String, double)\n+     * @see #isTrue(boolean, String, Object)\n+     * @see #isTrue(boolean, String, Object...)\n+     */\n+    public static void isTrue(boolean expression, String message, long value) {\n+        if (expression == false) {\n+            throw new IllegalArgumentException(String.format(message, Long.valueOf(value)));\n+        }\n+    }\n+\n+    /**\n+     * <p>Validate that the argument condition is <code>true</code>; otherwise \n+     * throwing an exception with the specified message. This method is useful when\n+     * validating according to an arbitrary boolean expression, such as validating a \n+     * primitive number or using your own custom validation expression.</p>\n+     *\n+     * <pre>Validate.isTrue(d > 0.0, \"The value must be greater than zero: %s\", d);</pre>\n+     *\n+     * <p>For performance reasons, the double value is passed as a separate parameter and\n+     * appended to the exception message only in the case of an error.</p>\n+     * \n+     * @param expression the boolean expression to check \n+     * @param message the exception message if invalid\n+     * @param value the value to append to the message when invalid\n+     * @throws IllegalArgumentException if expression is <code>false</code>\n+     * @see #isTrue(boolean)\n+     * @see #isTrue(boolean, String, long)\n+     * @see #isTrue(boolean, String, Object)\n+     * @see #isTrue(boolean, String, Object...)\n+     */\n+    public static void isTrue(boolean expression, String message, double value) {\n+        if (expression == false) {\n+            throw new IllegalArgumentException(String.format(message, new Double(value)));\n+        }\n+    }\n+\n+    /**\n+     * <p>Validate that the argument condition is <code>true</code>; otherwise \n+     * throwing an exception with the specified message. This method is useful when\n+     * validating according to an arbitrary boolean expression, such as validating a \n+     * primitive number or using your own custom validation expression.</p>\n+     *\n+     * <pre>\n+     * Validate.isTrue(i >= min && i <= max, \"The value must be between %d and %d\", min, max);\n+     * Validate.isTrue(myObject.isOk(), \"The object is not okay\");</pre>\n+     *\n+     * <p>For performance reasons, the message string should not involve a string append,\n+     * instead use the {@link #isTrue(boolean, String, Object)} method.</p>\n+     * \n+     * @param expression the boolean expression to check \n+     * @param message the exception message if invalid\n+     * @param values the optional values for the formatted exception message\n+     * @throws IllegalArgumentException if expression is <code>false</code>\n+     * @see #isTrue(boolean)\n+     * @see #isTrue(boolean, String, long)\n+     * @see #isTrue(boolean, String, double)\n+     * @see #isTrue(boolean, String, Object)\n+     */\n+    public static void isTrue(boolean expression, String message, Object... values) {\n+        if (expression == false) {\n+            throw new IllegalArgumentException(String.format(message, values));\n+        }\n+    }\n+\n+    /**\n+     * <p>Validate that the argument condition is <code>true</code>; otherwise \n+     * throwing an exception. This method is useful when validating according \n+     * to an arbitrary boolean expression, such as validating a \n+     * primitive number or using your own custom validation expression.</p>\n+     *\n+     * <pre>\n+     * Validate.isTrue(i > 0);\n+     * Validate.isTrue(myObject.isOk());</pre>\n+     *\n+     * <p>The message of the exception is &quot;The validated expression is \n+     * false&quot;.</p>\n+     * \n+     * @param expression the boolean expression to check \n+     * @throws IllegalArgumentException if expression is <code>false</code>\n+     * @see #isTrue(boolean, String, long)\n+     * @see #isTrue(boolean, String, double)\n+     * @see #isTrue(boolean, String, Object)\n+     * @see #isTrue(boolean, String, Object...)\n+     */\n+    public static void isTrue(boolean expression) {\n+        if (expression == false) {\n+            throw new IllegalArgumentException(DEFAULT_IS_TRUE_EXCEPTION_MESSAGE);\n+        }\n+    }\n+\n+    // notNull\n+    //---------------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Validate that the specified argument is not <code>null</code>; \n+     * otherwise throwing an exception.\n+     *\n+     * <pre>Validate.notNull(myObject, \"The object must not be null\");</pre>\n+     *\n+     * <p>The message of the exception is &quot;The validated object is \n+     * null&quot;.</p>\n+     * \n+     * @param <T> the object type\n+     * @param object the object to check\n+     * @return the validated object (never <code>null</code> for method chaining)\n+     * @throws NullPointerException if the object is <code>null</code>\n+     * @see #notNull(Object, String, Object...)\n+     */\n+    public static <T> T notNull(T object) {\n+        return notNull(object, DEFAULT_IS_NULL_EXCEPTION_MESSAGE);\n+    }\n+\n+    /**\n+     * <p>Validate that the specified argument is not <code>null</code>; \n+     * otherwise throwing an exception with the specified message.\n+     *\n+     * <pre>Validate.notNull(myObject, \"The object must not be null\");</pre>\n+     * \n+     * @param <T> the object type\n+     * @param object the object to check\n+     * @param message the exception message if invalid\n+     * @param values the optional values for the formatted exception message\n+     * @return the validated object (never <code>null</code> for method chaining)\n+     * @throws NullPointerException if the object is <code>null</code>\n+     * @see #notNull(Object)\n+     */\n+    public static <T> T notNull(T object, String message, Object... values) {\n+        if (object == null) {\n+            throw new NullPointerException(String.format(message, values));\n+        }\n+        return object;\n+    }\n+\n+    // notEmpty array\n+    //---------------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Validate that the specified argument array is neither <code>null</code> \n+     * nor a length of zero (no elements); otherwise throwing an exception \n+     * with the specified message.\n+     *\n+     * <pre>Validate.notEmpty(myArray, \"The array must not be empty\");</pre>\n+     * \n+     * @param <T> the array type\n+     * @param array the array to check\n+     * @param message the exception message if invalid\n+     * @return the validated array (never <code>null</code> method for chaining)\n+     * @throws NullPointerException if the array is <code>null</code>\n+     * @throws IllegalArgumentException if the array is empty\n+     * @see #notEmpty(Object[])\n+     */\n+    public static <T> T[] notEmpty(T[] array, String message, Object... values) {\n+        if (array == null) {\n+            throw new NullPointerException(String.format(message, values));\n+        }\n+        if (array.length == 0) {\n+            throw new IllegalArgumentException(String.format(message, values));\n+        }\n+        return array;\n+    }\n+\n+    /**\n+     * <p>Validate that the specified argument array is neither <code>null</code> \n+     * nor a length of zero (no elements); otherwise throwing an exception. \n+     *\n+     * <pre>Validate.notEmpty(myArray);</pre>\n+     * \n+     * <p>The message in the exception is &quot;The validated array is \n+     * empty&quot;.\n+     * \n+     * @param <T> the array type\n+     * @param array the array to check\n+     * @return the validated array (never <code>null</code> method for chaining)\n+     * @throws NullPointerException if the array is <code>null</code>\n+     * @throws IllegalArgumentException if the array is empty\n+     * @see #notEmpty(Object[], String, Object...)\n+     */\n+    public static <T> T[] notEmpty(T[] array) {\n+        return notEmpty(array, DEFAULT_NOT_EMPTY_ARRAY_EXCEPTION_MESSAGE);\n+    }\n+\n+    // notEmpty collection\n+    //---------------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Validate that the specified argument collection is neither <code>null</code> \n+     * nor a size of zero (no elements); otherwise throwing an exception \n+     * with the specified message.\n+     *\n+     * <pre>Validate.notEmpty(myCollection, \"The collection must not be empty\");</pre>\n+     * \n+     * @param <T> the collection type\n+     * @param collection the collection to check\n+     * @param message the exception message if invalid\n+     * @return the validated collection (never <code>null</code> method for chaining)\n+     * @throws NullPointerException if the collection is <code>null</code>\n+     * @throws IllegalArgumentException if the collection is empty\n+     * @see #notEmpty(Object[])\n+     */\n+    public static <T extends Collection<?>> T notEmpty(T collection, String message, Object... values) {\n+        if (collection == null) {\n+            throw new NullPointerException(String.format(message, values));\n+        }\n+        if (collection.size() == 0) {\n+            throw new IllegalArgumentException(String.format(message, values));\n+        }\n+        return collection;\n+    }\n+\n+    /**\n+     * <p>Validate that the specified argument collection is neither <code>null</code> \n+     * nor a size of zero (no elements); otherwise throwing an exception. \n+     *\n+     * <pre>Validate.notEmpty(myCollection);</pre>\n+     * \n+     * <p>The message in the exception is &quot;The validated collection is \n+     * empty&quot;.</p>\n+     * \n+     * @param <T> the collection type\n+     * @param collection the collection to check\n+     * @return the validated collection (never <code>null</code> method for chaining)\n+     * @throws NullPointerException if the collection is <code>null</code>\n+     * @throws IllegalArgumentException if the collection is empty\n+     * @see #notEmpty(Collection, String, Object...)\n+     */\n+    public static <T extends Collection<?>> T notEmpty(T collection) {\n+        return notEmpty(collection, DEFAULT_NOT_EMPTY_COLLECTION_EXCEPTION_MESSAGE);\n+    }\n+\n+    // notEmpty map\n+    //---------------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Validate that the specified argument map is neither <code>null</code> \n+     * nor a size of zero (no elements); otherwise throwing an exception \n+     * with the specified message.\n+     *\n+     * <pre>Validate.notEmpty(myMap, \"The map must not be empty\");</pre>\n+     * \n+     * @param <T> the map type\n+     * @param map the map to check\n+     * @param message the exception message if invalid\n+     * @return the validated map (never <code>null</code> method for chaining)\n+     * @throws NullPointerException if the map is <code>null</code>\n+     * @throws IllegalArgumentException if the map is empty\n+     * @see #notEmpty(Object[])\n+     */\n+    public static <T extends Map<?, ?>> T notEmpty(T map, String message, Object... values) {\n+        if (map == null) {\n+            throw new NullPointerException(String.format(message, values));\n+        }\n+        if (map.size() == 0) {\n+            throw new IllegalArgumentException(String.format(message, values));\n+        }\n+        return map;\n+    }\n+\n+    /**\n+     * <p>Validate that the specified argument map is neither <code>null</code> \n+     * nor a size of zero (no elements); otherwise throwing an exception. \n+     *\n+     * <pre>Validate.notEmpty(myMap);</pre>\n+     * \n+     * <p>The message in the exception is &quot;The validated map is \n+     * empty&quot;.</p>\n+     * \n+     * @param <T> the map type\n+     * @param map the map to check\n+     * @return the validated map (never <code>null</code> method for chaining)\n+     * @throws NullPointerException if the map is <code>null</code>\n+     * @throws IllegalArgumentException if the map is empty\n+     * @see #notEmpty(Map, String, Object...)\n+     */\n+    public static <T extends Map<?, ?>> T notEmpty(T map) {\n+        return notEmpty(map, DEFAULT_NOT_EMPTY_MAP_EXCEPTION_MESSAGE);\n+    }\n+\n+    // notEmpty string\n+    //---------------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Validate that the specified argument character sequence is \n+     * neither <code>null</code> nor a length of zero (no characters); \n+     * otherwise throwing an exception with the specified message.\n+     *\n+     * <pre>Validate.notEmpty(myString, \"The string must not be empty\");</pre>\n+     * \n+     * @param <T> the character sequence type\n+     * @param chars the character sequence to check\n+     * @param message the exception message if invalid\n+     * @return the validated character sequence (never <code>null</code> method for chaining)\n+     * @throws NullPointerException if the character sequence is <code>null</code>\n+     * @throws IllegalArgumentException if the character sequence is empty\n+     * @see #notEmpty(CharSequence)\n+     */\n+    public static <T extends CharSequence> T notEmpty(T chars, String message, Object... values) {\n+        if (chars == null) {\n+            throw new NullPointerException(String.format(message, values));\n+        }\n+        if (chars.length() == 0) {\n+            throw new IllegalArgumentException(String.format(message, values));\n+        }\n+        return chars;\n+    }\n+\n+    /**\n+     * <p>Validate that the specified argument character sequence is \n+     * neither <code>null</code> nor a length of zero (no characters); \n+     * otherwise throwing an exception with the specified message.\n+     *\n+     * <pre>Validate.notEmpty(myString);</pre>\n+     * \n+     * <p>The message in the exception is &quot;The validated \n+     * character sequence is empty&quot;.</p>\n+     * \n+     * @param <T> the character sequence type\n+     * @param chars the character sequence to check\n+     * @return the validated character sequence (never <code>null</code> method for chaining)\n+     * @throws NullPointerException if the character sequence is <code>null</code>\n+     * @throws IllegalArgumentException if the character sequence is empty\n+     * @see #notEmpty(CharSequence, String, Object...)\n+     */\n+    public static <T extends CharSequence> T notEmpty(T chars) {\n+        return notEmpty(chars, DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EXCEPTION_MESSAGE);\n+    }\n+\n+    // notBlank string\n+    //---------------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Validate that the specified argument character sequence is \n+     * neither <code>null</code>, a length of zero (no characters), empty\n+     * nor whitespace; otherwise throwing an exception with the specified \n+     * message.\n+     *\n+     * <pre>Validate.notBlank(myString, \"The string must not be blank\");</pre>\n+     * \n+     * @param <T> the character sequence type\n+     * @param chars the character sequence to check\n+     * @param message the exception message if invalid\n+     * @return the validated character sequence (never <code>null</code> method for chaining)\n+     * @throws NullPointerException if the character sequence is <code>null</code>\n+     * @throws IllegalArgumentException if the character sequence is blank\n+     * @see #notBlank(CharSequence)\n+     */\n+    public static <T extends CharSequence> T notBlank(T chars, String message, Object... values) {\n+        if (chars == null) {\n+            throw new NullPointerException(String.format(message, values));\n+        }\n+        if (StringUtils.isBlank(chars)) {\n+            throw new IllegalArgumentException(String.format(message, values));\n+        }\n+        return chars;\n+    }\n+\n+    /**\n+     * <p>Validate that the specified argument character sequence is \n+     * neither <code>null</code>, a length of zero (no characters), empty\n+     * nor whitespace; otherwise throwing an exception.\n+     *\n+     * <pre>Validate.notBlank(myString);</pre>\n+     * \n+     * <p>The message in the exception is &quot;The validated character \n+     * sequence is blank&quot;.</p>\n+     * \n+     * @param <T> the character sequence type\n+     * @param chars the character sequence to check\n+     * @return the validated character sequence (never <code>null</code> method for chaining)\n+     * @throws NullPointerException if the character sequence is <code>null</code>\n+     * @throws IllegalArgumentException if the character sequence is blank\n+     * @see #notBlank(CharSequence, String, Object...)\n+     */\n+    public static <T extends CharSequence> T notBlank(T chars) {\n+        return notBlank(chars, DEFAULT_NOT_BLANK_EXCEPTION_MESSAGE);\n+    }\n+\n+    // notNullElements array\n+    //---------------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Validate that the specified argument array is neither \n+     * <code>null</code> nor contains any elements that are <code>null</code>;\n+     * otherwise throwing an exception with the specified message.\n+     *\n+     * <pre>Validate.noNullElements(myArray, \"The array contain null at position %d\");</pre>\n+     * \n+     * <p>If the array is <code>null</code>, then the message in the exception \n+     * is &quot;The validated object is null&quot;.</p>\n+     * \n+     * <p>If the array has a <code>null</code> element, then the iteration \n+     * index of the invalid element is appended to the <code>values</code> \n+     * argument.</p>\n+     * \n+     * @param <T> the array type\n+     * @param array the array to check\n+     * @return the validated array (never <code>null</code> method for chaining)\n+     * @throws NullPointerException if the array is <code>null</code>\n+     * @throws IllegalArgumentException if an element is <code>null</code>\n+     * @see #noNullElements(Object[])\n+     */\n+    public static <T> T[] noNullElements(T[] array, String message, Object... values) {\n+        Validate.notNull(array);\n+        for (int i = 0; i < array.length; i++) {\n+            if (array[i] == null) {\n+                Object[] values2 = ArrayUtils.add(values, Integer.valueOf(i));\n+                throw new IllegalArgumentException(String.format(message, values2));\n+            }\n+        }\n+        return array;\n+    }\n+\n+    /**\n+     * <p>Validate that the specified argument array is neither \n+     * <code>null</code> nor contains any elements that are <code>null</code>;\n+     * otherwise throwing an exception.\n+     *\n+     * <pre>Validate.noNullElements(myArray);</pre>\n+     * \n+     * <p>If the array is <code>null</code>, then the message in the exception \n+     * is &quot;The validated object is null&quot;.</p>\n+     * \n+     * <p>If the array has a <code>null</code> element, then the message in the\n+     * exception is &quot;The validated array contains null element at index: \n+     * &quot followed by the index.</p>\n+     *\n+     * @param <T> the array type\n+     * @param array the array to check\n+     * @return the validated array (never <code>null</code> method for chaining)\n+     * @throws NullPointerException if the array is <code>null</code>\n+     * @throws IllegalArgumentException if an element is <code>null</code>\n+     * @see #noNullElements(Object[], String, Object...)\n+     */\n+    public static <T> T[] noNullElements(T[] array) {\n+        return noNullElements(array, DEFAULT_NO_NULL_ELEMENTS_ARRAY_EXCEPTION_MESSAGE);\n+    }\n+\n+    // notNullElements collection\n+    //---------------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Validate that the specified argument iterable is neither \n+     * <code>null</code> nor contains any elements that are <code>null</code>;\n+     * otherwise throwing an exception with the specified message.\n+     *\n+     * <pre>Validate.noNullElements(myCollection, \"The collection contains null at position %d\");</pre>\n+     * \n+     * <p>If the iterable is <code>null</code>, then the message in the exception \n+     * is &quot;The validated object is null&quot;.</p>\n+     * \n+     * <p>If the iterable has a <code>null</code> element, then the iteration \n+     * index of the invalid element is appended to the <code>values</code> \n+     * argument.</p>\n+     *\n+     * @param <T> the iterable type\n+     * @param iterable the iterable to check\n+     * @return the validated iterable (never <code>null</code> method for chaining)\n+     * @throws NullPointerException if the array is <code>null</code>\n+     * @throws IllegalArgumentException if an element is <code>null</code>\n+     * @see #noNullElements(Iterable)\n+     */\n+    public static <T extends Iterable<?>> T noNullElements(T iterable, String message, Object... values) {\n+        Validate.notNull(iterable);\n+        int i = 0;\n+        for (Iterator<?> it = iterable.iterator(); it.hasNext(); i++) {\n+            if (it.next() == null) {\n+                Object[] values2 = ArrayUtils.addAll(values, Integer.valueOf(i));\n+                throw new IllegalArgumentException(String.format(message, values2));\n+            }\n+        }\n+        return iterable;\n+    }\n+\n+    /**\n+     * <p>Validate that the specified argument iterable is neither \n+     * <code>null</code> nor contains any elements that are <code>null</code>;\n+     * otherwise throwing an exception.\n+     *\n+     * <pre>Validate.noNullElements(myCollection);</pre>\n+     * \n+     * <p>If the iterable is <code>null</code>, then the message in the exception \n+     * is &quot;The validated object is null&quot;.</p>\n+     * \n+     * <p>If the array has a <code>null</code> element, then the message in the\n+     * exception is &quot;The validated iterable contains null element at index: \n+     * &quot followed by the index.</p>\n+     *\n+     * @param <T> the iterable type\n+     * @param iterable the iterable to check\n+     * @return the validated iterable (never <code>null</code> method for chaining)\n+     * @throws NullPointerException if the array is <code>null</code>\n+     * @throws IllegalArgumentException if an element is <code>null</code>\n+     * @see #noNullElements(Collection, String, Object...)\n+     */\n+    public static <T extends Iterable<?>> T noNullElements(T iterable) {\n+        return noNullElements(iterable, DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EXCEPTION_MESSAGE);\n+    }\n+\n+    // validIndex array\n+    //---------------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Validates that the index is within the bounds of the argument \n+     * array; otherwise throwing an exception with the specified message.</p>\n+     *\n+     * <pre>Validate.validIndex(myArray, 2, \"The array index is invalid: \");</pre>\n+     * \n+     * <p>If the array is <code>null</code>, then the message of the exception \n+     * is &quot;The validated object is null&quot;.</p>\n+     * \n+     * @param <T> the array type\n+     * @param array the array to check\n+     * @param index the index\n+     * @param message the exception message if invalid\n+     * @return the validated array (never <code>null</code> for method chaining)\n+     * @throws NullPointerException if the array is <code>null</code>\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     * @see #validIndex(Object[], int)\n+     */\n+    public static <T> T[] validIndex(T[] array, int index, String message, Object... values) {\n+        Validate.notNull(array);\n+        if (index < 0 || index >= array.length) {\n+            throw new IndexOutOfBoundsException(String.format(message, values));\n+        }\n+        return array;\n+    }\n+\n+    /**\n+     * <p>Validates that the index is within the bounds of the argument \n+     * array; otherwise throwing an exception.</p>\n+     *\n+     * <pre>Validate.validIndex(myArray, 2);</pre>\n+     *\n+     * <p>If the array is <code>null</code>, then the message of the exception\n+     * is &quot;The validated object is null&quot;.</p>\n+     * \n+     * <p>If the index is invalid, then the message of the exception is \n+     * &quot;The validated array index is invalid: &quot; followed by the \n+     * index.</p>\n+     * \n+     * @param <T> the array type\n+     * @param array the array to check\n+     * @param index the index\n+     * @return the validated array (never <code>null</code> for method chaining)\n+     * @throws NullPointerException if the array is <code>null</code>\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     * @see #validIndex(Object[], int, String, Object...)\n+     */\n+    public static <T> T[] validIndex(T[] array, int index) {\n+        return validIndex(array, index, DEFAULT_VALID_INDEX_ARRAY_EXCEPTION_MESSAGE, Integer.valueOf(index));\n+    }\n+\n+    // validIndex collection\n+    //---------------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Validates that the index is within the bounds of the argument \n+     * collection; otherwise throwing an exception with the specified message.</p>\n+     *\n+     * <pre>Validate.validIndex(myCollection, 2, \"The collection index is invalid: \");</pre>\n+     * \n+     * <p>If the collection is <code>null</code>, then the message of the \n+     * exception is &quot;The validated object is null&quot;.</p>\n+     *\n+     * @param <T> the collection type\n+     * @param collection the collection to check\n+     * @param index the index\n+     * @param message the exception message if invalid\n+     * @return the validated collection (never <code>null</code> for chaining)\n+     * @throws NullPointerException if the collection is <code>null</code>\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     * @see #validIndex(Collection, int)\n+     */\n+    public static <T extends Collection<?>> T validIndex(T collection, int index, String message, Object... values) {\n+        Validate.notNull(collection);\n+        if (index < 0 || index >= collection.size()) {\n+            throw new IndexOutOfBoundsException(String.format(message, values));\n+        }\n+        return collection;\n+    }\n+\n+    /**\n+     * <p>Validates that the index is within the bounds of the argument \n+     * collection; otherwise throwing an exception.</p>\n+     *\n+     * <pre>Validate.validIndex(myCollection, 2);</pre>\n+     *\n+     * <p>If the index is invalid, then the message of the exception \n+     * is &quot;The validated collection index is invalid: &quot; \n+     * followed by the index.</p>\n+     * \n+     * @param <T> the collection type\n+     * @param collection the collection to check\n+     * @param index the index\n+     * @return the validated collection (never <code>null</code> for method chaining)\n+     * @throws NullPointerException if the collection is <code>null</code>\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     * @see #validIndex(Collection, int, String, Object...)\n+     */\n+    public static <T extends Collection<?>> T validIndex(T collection, int index) {\n+        return validIndex(collection, index, DEFAULT_VALID_INDEX_COLLECTION_EXCEPTION_MESSAGE, Integer.valueOf(index));\n+    }\n+\n+    // validIndex string\n+    //---------------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Validates that the index is within the bounds of the argument \n+     * character sequence; otherwise throwing an exception with the \n+     * specified message.</p>\n+     *\n+     * <pre>Validate.validIndex(myStr, 2, \"The string index is invalid: \");</pre>\n+     * \n+     * <p>If the character sequence is <code>null</code>, then the message \n+     * of the exception is &quot;The validated object is null&quot;.</p>\n+     *\n+     * @param <T> the character sequence type\n+     * @param chars the character sequence to check\n+     * @param index the index\n+     * @param message the exception message if invalid\n+     * @return the validated character sequence (never <code>null</code> for method chaining)\n+     * @throws NullPointerException if the character sequence is <code>null</code>\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     * @see #validIndex(CharSequence, int)\n+     */\n+    public static <T extends CharSequence> T validIndex(T chars, int index, String message, Object... values) {\n+        Validate.notNull(chars);\n+        if (index < 0 || index >= chars.length()) {\n+            throw new IndexOutOfBoundsException(String.format(message, values));\n+        }\n+        return chars;\n+    }\n+\n+    /**\n+     * <p>Validates that the index is within the bounds of the argument \n+     * character sequence; otherwise throwing an exception.</p>\n+     * \n+     * <pre>Validate.validIndex(myStr, 2);</pre>\n+     *\n+     * <p>If the character sequence is <code>null</code>, then the message \n+     * of the exception is &quot;The validated object is \n+     * null&quot;.</p>\n+     * \n+     * <p>If the index is invalid, then the message of the exception \n+     * is &quot;The validated character sequence index is invalid: &quot; \n+     * followed by the index.</p>\n+     * \n+     * @param <T> the character sequence type\n+     * @param chars the character sequence to check\n+     * @param index the index\n+     * @return the validated character sequence (never <code>null</code> for method chaining)\n+     * @throws NullPointerException if the character sequence is <code>null</code>\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     * @see #validIndex(CharSequence, int, String, Object...)\n+     */\n+    public static <T extends CharSequence> T validIndex(T chars, int index) {\n+        return validIndex(chars, index, DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EXCEPTION_MESSAGE, Integer.valueOf(index));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/WordUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3;\n+\n+/**\n+ * <p>Operations on Strings that contain words.</p>\n+ * \n+ * <p>This class tries to handle <code>null</code> input gracefully.\n+ * An exception will not be thrown for a <code>null</code> input.\n+ * Each method documents its behaviour in more detail.</p>\n+ * \n+ * @author Apache Software Foundation\n+ * @author Apache Jakarta Velocity\n+ * @author <a href=\"mailto:hps@intermeta.de\">Henning P. Schmiedehausen</a>\n+ * @author Gary Gregory\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class WordUtils {\n+\n+    /**\n+     * <p><code>WordUtils</code> instances should NOT be constructed in\n+     * standard programming. Instead, the class should be used as\n+     * <code>WordUtils.wrap(\"foo bar\", 20);</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean\n+     * instance to operate.</p>\n+     */\n+    public WordUtils() {\n+      super();\n+    }\n+\n+    // Wrapping\n+    //--------------------------------------------------------------------------\n+    /**\n+     * <p>Wraps a single line of text, identifying words by <code>' '</code>.</p>\n+     * \n+     * <p>New lines will be separated by the system property line separator.\n+     * Very long words, such as URLs will <i>not</i> be wrapped.</p>\n+     * \n+     * <p>Leading spaces on a new line are stripped.\n+     * Trailing spaces are not stripped.</p>\n+     *\n+     * <pre>\n+     * WordUtils.wrap(null, *) = null\n+     * WordUtils.wrap(\"\", *) = \"\"\n+     * </pre>\n+     *\n+     * @param str  the String to be word wrapped, may be null\n+     * @param wrapLength  the column to wrap the words at, less than 1 is treated as 1\n+     * @return a line with newlines inserted, <code>null</code> if null input\n+     */\n+    public static String wrap(String str, int wrapLength) {\n+        return wrap(str, wrapLength, null, false);\n+    }\n+    \n+    /**\n+     * <p>Wraps a single line of text, identifying words by <code>' '</code>.</p>\n+     * \n+     * <p>Leading spaces on a new line are stripped.\n+     * Trailing spaces are not stripped.</p>\n+     * \n+     * <pre>\n+     * WordUtils.wrap(null, *, *, *) = null\n+     * WordUtils.wrap(\"\", *, *, *) = \"\"\n+     * </pre>\n+     *\n+     * @param str  the String to be word wrapped, may be null\n+     * @param wrapLength  the column to wrap the words at, less than 1 is treated as 1\n+     * @param newLineStr  the string to insert for a new line, \n+     *  <code>null</code> uses the system property line separator\n+     * @param wrapLongWords  true if long words (such as URLs) should be wrapped\n+     * @return a line with newlines inserted, <code>null</code> if null input\n+     */\n+    public static String wrap(String str, int wrapLength, String newLineStr, boolean wrapLongWords) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (newLineStr == null) {\n+            newLineStr = SystemUtils.LINE_SEPARATOR;\n+        }\n+        if (wrapLength < 1) {\n+            wrapLength = 1;\n+        }\n+        int inputLineLength = str.length();\n+        int offset = 0;\n+        StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32);\n+        \n+        while ((inputLineLength - offset) > wrapLength) {\n+            if (str.charAt(offset) == ' ') {\n+                offset++;\n+                continue;\n+            }\n+            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);\n+\n+            if (spaceToWrapAt >= offset) {\n+                // normal case\n+                wrappedLine.append(str.substring(offset, spaceToWrapAt));\n+                wrappedLine.append(newLineStr);\n+                offset = spaceToWrapAt + 1;\n+                \n+            } else {\n+                // really long word or URL\n+                if (wrapLongWords) {\n+                    // wrap really long word one line at a time\n+                    wrappedLine.append(str.substring(offset, wrapLength + offset));\n+                    wrappedLine.append(newLineStr);\n+                    offset += wrapLength;\n+                } else {\n+                    // do not wrap really long word, just extend beyond limit\n+                    spaceToWrapAt = str.indexOf(' ', wrapLength + offset);\n+                    if (spaceToWrapAt >= 0) {\n+                        wrappedLine.append(str.substring(offset, spaceToWrapAt));\n+                        wrappedLine.append(newLineStr);\n+                        offset = spaceToWrapAt + 1;\n+                    } else {\n+                        wrappedLine.append(str.substring(offset));\n+                        offset = inputLineLength;\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Whatever is left in line is short enough to just pass through\n+        wrappedLine.append(str.substring(offset));\n+\n+        return wrappedLine.toString();\n+    }\n+\n+    // Capitalizing\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Capitalizes all the whitespace separated words in a String.\n+     * Only the first letter of each word is changed. To convert the \n+     * rest of each word to lowercase at the same time, \n+     * use {@link #capitalizeFully(String)}.</p>\n+     *\n+     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n+     * A <code>null</code> input String returns <code>null</code>.\n+     * Capitalization uses the unicode title case, normally equivalent to\n+     * upper case.</p>\n+     *\n+     * <pre>\n+     * WordUtils.capitalize(null)        = null\n+     * WordUtils.capitalize(\"\")          = \"\"\n+     * WordUtils.capitalize(\"i am FINE\") = \"I Am FINE\"\n+     * </pre>\n+     * \n+     * @param str  the String to capitalize, may be null\n+     * @return capitalized String, <code>null</code> if null String input\n+     * @see #uncapitalize(String)\n+     * @see #capitalizeFully(String)\n+     */\n+    public static String capitalize(String str) {\n+        return capitalize(str, null);\n+    }\n+\n+    /**\n+     * <p>Capitalizes all the delimiter separated words in a String.\n+     * Only the first letter of each word is changed. To convert the \n+     * rest of each word to lowercase at the same time, \n+     * use {@link #capitalizeFully(String, char[])}.</p>\n+     *\n+     * <p>The delimiters represent a set of characters understood to separate words.\n+     * The first string character and the first non-delimiter character after a\n+     * delimiter will be capitalized. </p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * Capitalization uses the unicode title case, normally equivalent to\n+     * upper case.</p>\n+     *\n+     * <pre>\n+     * WordUtils.capitalize(null, *)            = null\n+     * WordUtils.capitalize(\"\", *)              = \"\"\n+     * WordUtils.capitalize(*, new char[0])     = *\n+     * WordUtils.capitalize(\"i am fine\", null)  = \"I Am Fine\"\n+     * WordUtils.capitalize(\"i aM.fine\", {'.'}) = \"I aM.Fine\"\n+     * </pre>\n+     * \n+     * @param str  the String to capitalize, may be null\n+     * @param delimiters  set of characters to determine capitalization, null means whitespace\n+     * @return capitalized String, <code>null</code> if null String input\n+     * @see #uncapitalize(String)\n+     * @see #capitalizeFully(String)\n+     * @since 2.1\n+     */\n+    public static String capitalize(String str, char[] delimiters) {\n+        int delimLen = (delimiters == null ? -1 : delimiters.length);\n+        if (str == null || str.length() == 0 || delimLen == 0) {\n+            return str;\n+        }\n+        int strLen = str.length();\n+        StringBuilder buffer = new StringBuilder(strLen);\n+        boolean capitalizeNext = true;\n+        for (int i = 0; i < strLen; i++) {\n+            char ch = str.charAt(i);\n+\n+            if (isDelimiter(ch, delimiters)) {\n+                buffer.append(ch);\n+                capitalizeNext = true;\n+            } else if (capitalizeNext) {\n+                buffer.append(Character.toTitleCase(ch));\n+                capitalizeNext = false;\n+            } else {\n+                buffer.append(ch);\n+            }\n+        }\n+        return buffer.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Converts all the whitespace separated words in a String into capitalized words, \n+     * that is each word is made up of a titlecase character and then a series of \n+     * lowercase characters.  </p>\n+     *\n+     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n+     * A <code>null</code> input String returns <code>null</code>.\n+     * Capitalization uses the unicode title case, normally equivalent to\n+     * upper case.</p>\n+     *\n+     * <pre>\n+     * WordUtils.capitalizeFully(null)        = null\n+     * WordUtils.capitalizeFully(\"\")          = \"\"\n+     * WordUtils.capitalizeFully(\"i am FINE\") = \"I Am Fine\"\n+     * </pre>\n+     * \n+     * @param str  the String to capitalize, may be null\n+     * @return capitalized String, <code>null</code> if null String input\n+     */\n+    public static String capitalizeFully(String str) {\n+        return capitalizeFully(str, null);\n+    }\n+\n+    /**\n+     * <p>Converts all the delimiter separated words in a String into capitalized words, \n+     * that is each word is made up of a titlecase character and then a series of \n+     * lowercase characters. </p>\n+     *\n+     * <p>The delimiters represent a set of characters understood to separate words.\n+     * The first string character and the first non-delimiter character after a\n+     * delimiter will be capitalized. </p>\n+     *\n+     * <p>A <code>null</code> input String returns <code>null</code>.\n+     * Capitalization uses the unicode title case, normally equivalent to\n+     * upper case.</p>\n+     *\n+     * <pre>\n+     * WordUtils.capitalizeFully(null, *)            = null\n+     * WordUtils.capitalizeFully(\"\", *)              = \"\"\n+     * WordUtils.capitalizeFully(*, null)            = *\n+     * WordUtils.capitalizeFully(*, new char[0])     = *\n+     * WordUtils.capitalizeFully(\"i aM.fine\", {'.'}) = \"I am.Fine\"\n+     * </pre>\n+     * \n+     * @param str  the String to capitalize, may be null\n+     * @param delimiters  set of characters to determine capitalization, null means whitespace\n+     * @return capitalized String, <code>null</code> if null String input\n+     * @since 2.1\n+     */\n+    public static String capitalizeFully(String str, char[] delimiters) {\n+        int delimLen = (delimiters == null ? -1 : delimiters.length);\n+        if (str == null || str.length() == 0 || delimLen == 0) {\n+            return str;\n+        }\n+        str = str.toLowerCase();\n+        return capitalize(str, delimiters);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Uncapitalizes all the whitespace separated words in a String.\n+     * Only the first letter of each word is changed.</p>\n+     *\n+     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n+     * A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * WordUtils.uncapitalize(null)        = null\n+     * WordUtils.uncapitalize(\"\")          = \"\"\n+     * WordUtils.uncapitalize(\"I Am FINE\") = \"i am fINE\"\n+     * </pre>\n+     * \n+     * @param str  the String to uncapitalize, may be null\n+     * @return uncapitalized String, <code>null</code> if null String input\n+     * @see #capitalize(String)\n+     */\n+    public static String uncapitalize(String str) {\n+        return uncapitalize(str, null);\n+    }\n+\n+    /**\n+     * <p>Uncapitalizes all the whitespace separated words in a String.\n+     * Only the first letter of each word is changed.</p>\n+     *\n+     * <p>The delimiters represent a set of characters understood to separate words.\n+     * The first string character and the first non-delimiter character after a\n+     * delimiter will be uncapitalized. </p>\n+     *\n+     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n+     * A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * WordUtils.uncapitalize(null, *)            = null\n+     * WordUtils.uncapitalize(\"\", *)              = \"\"\n+     * WordUtils.uncapitalize(*, null)            = *\n+     * WordUtils.uncapitalize(*, new char[0])     = *\n+     * WordUtils.uncapitalize(\"I AM.FINE\", {'.'}) = \"i AM.fINE\"\n+     * </pre>\n+     * \n+     * @param str  the String to uncapitalize, may be null\n+     * @param delimiters  set of characters to determine uncapitalization, null means whitespace\n+     * @return uncapitalized String, <code>null</code> if null String input\n+     * @see #capitalize(String)\n+     * @since 2.1\n+     */\n+    public static String uncapitalize(String str, char[] delimiters) {\n+        int delimLen = (delimiters == null ? -1 : delimiters.length);\n+        if (str == null || str.length() == 0 || delimLen == 0) {\n+            return str;\n+        }\n+        int strLen = str.length();\n+        StringBuilder buffer = new StringBuilder(strLen);\n+        boolean uncapitalizeNext = true;\n+        for (int i = 0; i < strLen; i++) {\n+            char ch = str.charAt(i);\n+\n+            if (isDelimiter(ch, delimiters)) {\n+                buffer.append(ch);\n+                uncapitalizeNext = true;\n+            } else if (uncapitalizeNext) {\n+                buffer.append(Character.toLowerCase(ch));\n+                uncapitalizeNext = false;\n+            } else {\n+                buffer.append(ch);\n+            }\n+        }\n+        return buffer.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Swaps the case of a String using a word based algorithm.</p>\n+     * \n+     * <ul>\n+     *  <li>Upper case character converts to Lower case</li>\n+     *  <li>Title case character converts to Lower case</li>\n+     *  <li>Lower case character after Whitespace or at start converts to Title case</li>\n+     *  <li>Other Lower case character converts to Upper case</li>\n+     * </ul>\n+     * \n+     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n+     * A <code>null</code> input String returns <code>null</code>.</p>\n+     * \n+     * <pre>\n+     * StringUtils.swapCase(null)                 = null\n+     * StringUtils.swapCase(\"\")                   = \"\"\n+     * StringUtils.swapCase(\"The dog has a BONE\") = \"tHE DOG HAS A bone\"\n+     * </pre>\n+     * \n+     * @param str  the String to swap case, may be null\n+     * @return the changed String, <code>null</code> if null String input\n+     */\n+    public static String swapCase(String str) {\n+        int strLen;\n+        if (str == null || (strLen = str.length()) == 0) {\n+            return str;\n+        }\n+        StringBuilder buffer = new StringBuilder(strLen);\n+\n+        boolean whitespace = true;\n+        char ch = 0;\n+        char tmp = 0;\n+\n+        for (int i = 0; i < strLen; i++) {\n+            ch = str.charAt(i);\n+            if (Character.isUpperCase(ch)) {\n+                tmp = Character.toLowerCase(ch);\n+            } else if (Character.isTitleCase(ch)) {\n+                tmp = Character.toLowerCase(ch);\n+            } else if (Character.isLowerCase(ch)) {\n+                if (whitespace) {\n+                    tmp = Character.toTitleCase(ch);\n+                } else {\n+                    tmp = Character.toUpperCase(ch);\n+                }\n+            } else {\n+                tmp = ch;\n+            }\n+            buffer.append(tmp);\n+            whitespace = Character.isWhitespace(ch);\n+        }\n+        return buffer.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Extracts the initial letters from each word in the String.</p>\n+     * \n+     * <p>The first letter of the string and all first letters after\n+     * whitespace are returned as a new string.\n+     * Their case is not changed.</p>\n+     *\n+     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n+     * A <code>null</code> input String returns <code>null</code>.</p>\n+     *\n+     * <pre>\n+     * WordUtils.initials(null)             = null\n+     * WordUtils.initials(\"\")               = \"\"\n+     * WordUtils.initials(\"Ben John Lee\")   = \"BJL\"\n+     * WordUtils.initials(\"Ben J.Lee\")      = \"BJ\"\n+     * </pre>\n+     *\n+     * @param str  the String to get initials from, may be null\n+     * @return String of initial letters, <code>null</code> if null String input\n+     * @see #initials(String,char[])\n+     * @since 2.2\n+     */\n+    public static String initials(String str) {\n+        return initials(str, null);\n+    }\n+\n+    /**\n+     * <p>Extracts the initial letters from each word in the String.</p>\n+     * \n+     * <p>The first letter of the string and all first letters after the\n+     * defined delimiters are returned as a new string.\n+     * Their case is not changed.</p>\n+     *\n+     * <p>If the delimiters array is null, then Whitespace is used.\n+     * Whitespace is defined by {@link Character#isWhitespace(char)}.\n+     * A <code>null</code> input String returns <code>null</code>.\n+     * An empty delimiter array returns an empty String.</p>\n+     *\n+     * <pre>\n+     * WordUtils.initials(null, *)                = null\n+     * WordUtils.initials(\"\", *)                  = \"\"\n+     * WordUtils.initials(\"Ben John Lee\", null)   = \"BJL\"\n+     * WordUtils.initials(\"Ben J.Lee\", null)      = \"BJ\"\n+     * WordUtils.initials(\"Ben J.Lee\", [' ','.']) = \"BJL\"\n+     * WordUtils.initials(*, new char[0])         = \"\"\n+     * </pre>\n+     * \n+     * @param str  the String to get initials from, may be null\n+     * @param delimiters  set of characters to determine words, null means whitespace\n+     * @return String of initial letters, <code>null</code> if null String input\n+     * @see #initials(String)\n+     * @since 2.2\n+     */\n+    public static String initials(String str, char[] delimiters) {\n+        if (str == null || str.length() == 0) {\n+            return str;\n+        }\n+        if (delimiters != null && delimiters.length == 0) {\n+            return \"\";\n+        }\n+        int strLen = str.length();\n+        char[] buf = new char[strLen / 2 + 1];\n+        int count = 0;\n+        boolean lastWasGap = true;\n+        for (int i = 0; i < strLen; i++) {\n+            char ch = str.charAt(i);\n+\n+            if (isDelimiter(ch, delimiters)) {\n+                lastWasGap = true;\n+            } else if (lastWasGap) {\n+                buf[count++] = ch;\n+                lastWasGap = false;\n+            } else {\n+                // ignore ch\n+            }\n+        }\n+        return new String(buf, 0, count);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Is the character a delimiter.\n+     *\n+     * @param ch  the character to check\n+     * @param delimiters  the delimiters\n+     * @return true if it is a delimiter\n+     */\n+    private static boolean isDelimiter(char ch, char[] delimiters) {\n+        if (delimiters == null) {\n+            return Character.isWhitespace(ch);\n+        }\n+        for (int i = 0, isize = delimiters.length; i < isize; i++) {\n+            if (ch == delimiters[i]) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Abbreviates a string nicely.\n+     * \n+     * This method searches for the first space after the lower limit and abbreviates\n+     * the String there. It will also append any String passed as a parameter\n+     * to the end of the String. The upper limit can be specified to forcibly\n+     * abbreviate a String.\n+     * \n+     * @param str         the string to be abbreviated. If null is passed, null is returned.\n+     *                    If the empty String is passed, the empty string is returned.\n+     * @param lower       the lower limit.\n+     * @param upper       the upper limit; specify -1 if no limit is desired.\n+     *                    If the upper limit is lower than the lower limit, it will be\n+     *                    adjusted to be the same as the lower limit.\n+     * @param appendToEnd String to be appended to the end of the abbreviated string.\n+     *                    This is appended ONLY if the string was indeed abbreviated.\n+     *                    The append does not count towards the lower or upper limits.\n+     * @return the abbreviated String.\n+     * @since 2.4\n+     */\n+    public static String abbreviate(String str, int lower, int upper, String appendToEnd) {\n+        // initial parameter checks\n+        if (str == null) {\n+            return null;\n+        }\n+        if (str.length() == 0) {\n+            return StringUtils.EMPTY;\n+        }\n+\n+        // if the lower value is greater than the length of the string,\n+        // set to the length of the string\n+        if (lower > str.length()) {\n+            lower = str.length();    \n+        }\n+        // if the upper value is -1 (i.e. no limit) or is greater\n+        // than the length of the string, set to the length of the string\n+        if (upper == -1 || upper > str.length()) {\n+            upper = str.length();\n+        }\n+        // if upper is less than lower, raise it to lower\n+        if (upper < lower) {\n+            upper = lower;\n+        }\n+\n+        StringBuilder result = new StringBuilder();\n+        int index = StringUtils.indexOf(str, \" \", lower);\n+        if (index == -1) {\n+            result.append(str.substring(0, upper));\n+            // only if abbreviation has occured do we append the appendToEnd value\n+            if (upper != str.length()) {\n+                result.append(StringUtils.defaultString(appendToEnd));\n+            }\n+        } else if (index > upper) {\n+            result.append(str.substring(0, upper));\n+            result.append(StringUtils.defaultString(appendToEnd));\n+        } else {\n+            result.append(str.substring(0, index));\n+            result.append(StringUtils.defaultString(appendToEnd));\n+        }\n+        return result.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/builder/CompareToBuilder.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.builder;\n+\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+/** \n+ * Assists in implementing {@link java.lang.Comparable#compareTo(Object)} methods.\n+ *\n+ * It is consistent with <code>equals(Object)</code> and\n+ * <code>hashcode()</code> built with {@link EqualsBuilder} and\n+ * {@link HashCodeBuilder}.</p>\n+ *\n+ * <p>Two Objects that compare equal using <code>equals(Object)</code> should normally\n+ * also compare equal using <code>compareTo(Object)</code>.</p>\n+ *\n+ * <p>All relevant fields should be included in the calculation of the\n+ * comparison. Derived fields may be ignored. The same fields, in the same\n+ * order, should be used in both <code>compareTo(Object)</code> and\n+ * <code>equals(Object)</code>.</p>\n+ *\n+ * <p>To use this class write code as follows:</p>\n+ *\n+ * <pre>\n+ * public class MyClass {\n+ *   String field1;\n+ *   int field2;\n+ *   boolean field3;\n+ *\n+ *   ...\n+ *\n+ *   public int compareTo(Object o) {\n+ *     MyClass myClass = (MyClass) o;\n+ *     return new CompareToBuilder()\n+ *       .appendSuper(super.compareTo(o)\n+ *       .append(this.field1, myClass.field1)\n+ *       .append(this.field2, myClass.field2)\n+ *       .append(this.field3, myClass.field3)\n+ *       .toComparison();\n+ *   }\n+ * }\n+ * </pre>\n+ *\n+ * <p>Alternatively, there are {@link #reflectionCompare(Object, Object) reflectionCompare} methods that use\n+ * reflection to determine the fields to append. Because fields can be private,\n+ * <code>reflectionCompare</code> uses {@link java.lang.reflect.AccessibleObject#setAccessible(boolean)} to\n+ * bypass normal access control checks. This will fail under a security manager,\n+ * unless the appropriate permissions are set up correctly. It is also\n+ * slower than appending explicitly.</p>\n+ *\n+ * <p>A typical implementation of <code>compareTo(Object)</code> using\n+ * <code>reflectionCompare</code> looks like:</p>\n+\n+ * <pre>\n+ * public int compareTo(Object o) {\n+ *   return CompareToBuilder.reflectionCompare(this, o);\n+ * }\n+ * </pre>\n+ *\n+ * @see java.lang.Comparable\n+ * @see java.lang.Object#equals(Object)\n+ * @see java.lang.Object#hashCode()\n+ * @see EqualsBuilder\n+ * @see HashCodeBuilder\n+ * @author Apache Software Foundation\n+ * @author <a href=\"mailto:steve.downey@netfolio.com\">Steve Downey</a>\n+ * @author Gary Gregory\n+ * @author Pete Gieser\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class CompareToBuilder {\n+    \n+    /**\n+     * Current state of the comparison as appended fields are checked.\n+     */\n+    private int comparison;\n+\n+    /**\n+     * <p>Constructor for CompareToBuilder.</p>\n+     *\n+     * <p>Starts off assuming that the objects are equal. Multiple calls are \n+     * then made to the various append methods, followed by a call to \n+     * {@link #toComparison} to get the result.</p>\n+     */\n+    public CompareToBuilder() {\n+        super();\n+        comparison = 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /** \n+     * <p>Compares two <code>Object</code>s via reflection.</p>\n+     *\n+     * <p>Fields can be private, thus <code>AccessibleObject.setAccessible</code>\n+     * is used to bypass normal access control checks. This will fail under a \n+     * security manager unless the appropriate permissions are set.</p>\n+     *\n+     * <ul>\n+     * <li>Static fields will not be compared</li>\n+     * <li>Transient members will be not be compared, as they are likely derived\n+     *     fields</li>\n+     * <li>Superclass fields will be compared</li>\n+     * </ul>\n+     *\n+     * <p>If both <code>lhs</code> and <code>rhs</code> are <code>null</code>,\n+     * they are considered equal.</p>\n+     *\n+     * @param lhs  left-hand object\n+     * @param rhs  right-hand object\n+     * @return a negative integer, zero, or a positive integer as <code>lhs</code>\n+     *  is less than, equal to, or greater than <code>rhs</code>\n+     * @throws NullPointerException  if either (but not both) parameters are\n+     *  <code>null</code>\n+     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n+     *  with <code>lhs</code>\n+     */\n+    public static int reflectionCompare(Object lhs, Object rhs) {\n+        return reflectionCompare(lhs, rhs, false, null, null);\n+    }\n+\n+    /**\n+     * <p>Compares two <code>Object</code>s via reflection.</p>\n+     *\n+     * <p>Fields can be private, thus <code>AccessibleObject.setAccessible</code>\n+     * is used to bypass normal access control checks. This will fail under a \n+     * security manager unless the appropriate permissions are set.</p>\n+     *\n+     * <ul>\n+     * <li>Static fields will not be compared</li>\n+     * <li>If <code>compareTransients</code> is <code>true</code>,\n+     *     compares transient members.  Otherwise ignores them, as they\n+     *     are likely derived fields.</li>\n+     * <li>Superclass fields will be compared</li>\n+     * </ul>\n+     *\n+     * <p>If both <code>lhs</code> and <code>rhs</code> are <code>null</code>,\n+     * they are considered equal.</p>\n+     *\n+     * @param lhs  left-hand object\n+     * @param rhs  right-hand object\n+     * @param compareTransients  whether to compare transient fields\n+     * @return a negative integer, zero, or a positive integer as <code>lhs</code>\n+     *  is less than, equal to, or greater than <code>rhs</code>\n+     * @throws NullPointerException  if either <code>lhs</code> or <code>rhs</code>\n+     *  (but not both) is <code>null</code>\n+     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n+     *  with <code>lhs</code>\n+     */\n+    public static int reflectionCompare(Object lhs, Object rhs, boolean compareTransients) {\n+        return reflectionCompare(lhs, rhs, compareTransients, null, null);\n+    }\n+\n+    /**\n+     * <p>Compares two <code>Object</code>s via reflection.</p>\n+     *\n+     * <p>Fields can be private, thus <code>AccessibleObject.setAccessible</code>\n+     * is used to bypass normal access control checks. This will fail under a \n+     * security manager unless the appropriate permissions are set.</p>\n+     *\n+     * <ul>\n+     * <li>Static fields will not be compared</li>\n+     * <li>If <code>compareTransients</code> is <code>true</code>,\n+     *     compares transient members.  Otherwise ignores them, as they\n+     *     are likely derived fields.</li>\n+     * <li>Superclass fields will be compared</li>\n+     * </ul>\n+     *\n+     * <p>If both <code>lhs</code> and <code>rhs</code> are <code>null</code>,\n+     * they are considered equal.</p>\n+     *\n+     * @param lhs  left-hand object\n+     * @param rhs  right-hand object\n+     * @param excludeFields  Collection of String fields to exclude\n+     * @return a negative integer, zero, or a positive integer as <code>lhs</code>\n+     *  is less than, equal to, or greater than <code>rhs</code>\n+     * @throws NullPointerException  if either <code>lhs</code> or <code>rhs</code>\n+     *  (but not both) is <code>null</code>\n+     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n+     *  with <code>lhs</code>\n+     * @since 2.2\n+     */\n+    public static int reflectionCompare(Object lhs, Object rhs, Collection<String> excludeFields) {\n+        return reflectionCompare(lhs, rhs, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\n+    }\n+\n+    /**\n+     * <p>Compares two <code>Object</code>s via reflection.</p>\n+     *\n+     * <p>Fields can be private, thus <code>AccessibleObject.setAccessible</code>\n+     * is used to bypass normal access control checks. This will fail under a \n+     * security manager unless the appropriate permissions are set.</p>\n+     *\n+     * <ul>\n+     * <li>Static fields will not be compared</li>\n+     * <li>If <code>compareTransients</code> is <code>true</code>,\n+     *     compares transient members.  Otherwise ignores them, as they\n+     *     are likely derived fields.</li>\n+     * <li>Superclass fields will be compared</li>\n+     * </ul>\n+     *\n+     * <p>If both <code>lhs</code> and <code>rhs</code> are <code>null</code>,\n+     * they are considered equal.</p>\n+     *\n+     * @param lhs  left-hand object\n+     * @param rhs  right-hand object\n+     * @param excludeFields  array of fields to exclude\n+     * @return a negative integer, zero, or a positive integer as <code>lhs</code>\n+     *  is less than, equal to, or greater than <code>rhs</code>\n+     * @throws NullPointerException  if either <code>lhs</code> or <code>rhs</code>\n+     *  (but not both) is <code>null</code>\n+     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n+     *  with <code>lhs</code>\n+     * @since 2.2\n+     */\n+    public static int reflectionCompare(Object lhs, Object rhs, String[] excludeFields) {\n+        return reflectionCompare(lhs, rhs, false, null, excludeFields);\n+    }\n+\n+    /**\n+     * <p>Compares two <code>Object</code>s via reflection.</p>\n+     *\n+     * <p>Fields can be private, thus <code>AccessibleObject.setAccessible</code>\n+     * is used to bypass normal access control checks. This will fail under a \n+     * security manager unless the appropriate permissions are set.</p>\n+     *\n+     * <ul>\n+     * <li>Static fields will not be compared</li>\n+     * <li>If the <code>compareTransients</code> is <code>true</code>,\n+     *     compares transient members.  Otherwise ignores them, as they\n+     *     are likely derived fields.</li>\n+     * <li>Compares superclass fields up to and including <code>reflectUpToClass</code>.\n+     *     If <code>reflectUpToClass</code> is <code>null</code>, compares all superclass fields.</li>\n+     * </ul>\n+     *\n+     * <p>If both <code>lhs</code> and <code>rhs</code> are <code>null</code>,\n+     * they are considered equal.</p>\n+     *\n+     * @param lhs  left-hand object\n+     * @param rhs  right-hand object\n+     * @param compareTransients  whether to compare transient fields\n+     * @param reflectUpToClass  last superclass for which fields are compared\n+     * @return a negative integer, zero, or a positive integer as <code>lhs</code>\n+     *  is less than, equal to, or greater than <code>rhs</code>\n+     * @throws NullPointerException  if either <code>lhs</code> or <code>rhs</code>\n+     *  (but not both) is <code>null</code>\n+     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n+     *  with <code>lhs</code>\n+     * @since 2.0\n+     */\n+    public static int reflectionCompare(Object lhs, Object rhs, boolean compareTransients, \n+                                        Class<?> reflectUpToClass) \n+    {\n+        return reflectionCompare(lhs, rhs, false, reflectUpToClass, null);\n+    }\n+\n+    /**\n+     * <p>Compares two <code>Object</code>s via reflection.</p>\n+     *\n+     * <p>Fields can be private, thus <code>AccessibleObject.setAccessible</code>\n+     * is used to bypass normal access control checks. This will fail under a \n+     * security manager unless the appropriate permissions are set.</p>\n+     *\n+     * <ul>\n+     * <li>Static fields will not be compared</li>\n+     * <li>If the <code>compareTransients</code> is <code>true</code>,\n+     *     compares transient members.  Otherwise ignores them, as they\n+     *     are likely derived fields.</li>\n+     * <li>Compares superclass fields up to and including <code>reflectUpToClass</code>.\n+     *     If <code>reflectUpToClass</code> is <code>null</code>, compares all superclass fields.</li>\n+     * </ul>\n+     *\n+     * <p>If both <code>lhs</code> and <code>rhs</code> are <code>null</code>,\n+     * they are considered equal.</p>\n+     *\n+     * @param lhs  left-hand object\n+     * @param rhs  right-hand object\n+     * @param compareTransients  whether to compare transient fields\n+     * @param reflectUpToClass  last superclass for which fields are compared\n+     * @param excludeFields  fields to exclude\n+     * @return a negative integer, zero, or a positive integer as <code>lhs</code>\n+     *  is less than, equal to, or greater than <code>rhs</code>\n+     * @throws NullPointerException  if either <code>lhs</code> or <code>rhs</code>\n+     *  (but not both) is <code>null</code>\n+     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n+     *  with <code>lhs</code>\n+     * @since 2.2\n+     */\n+    public static int reflectionCompare(\n+        Object lhs, \n+        Object rhs, \n+        boolean compareTransients, \n+        Class<?> reflectUpToClass, \n+        String[] excludeFields) {\n+\n+        if (lhs == rhs) {\n+            return 0;\n+        }\n+        if (lhs == null || rhs == null) {\n+            throw new NullPointerException();\n+        }\n+        Class<?> lhsClazz = lhs.getClass();\n+        if (!lhsClazz.isInstance(rhs)) {\n+            throw new ClassCastException();\n+        }\n+        CompareToBuilder compareToBuilder = new CompareToBuilder();\n+        reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);\n+        while (lhsClazz.getSuperclass() != null && lhsClazz != reflectUpToClass) {\n+            lhsClazz = lhsClazz.getSuperclass();\n+            reflectionAppend(lhs, rhs, lhsClazz, compareToBuilder, compareTransients, excludeFields);\n+        }\n+        return compareToBuilder.toComparison();\n+    }\n+\n+    /**\n+     * <p>Appends to <code>builder</code> the comparison of <code>lhs</code>\n+     * to <code>rhs</code> using the fields defined in <code>clazz</code>.</p>\n+     * \n+     * @param lhs  left-hand object\n+     * @param rhs  right-hand object\n+     * @param clazz  <code>Class</code> that defines fields to be compared\n+     * @param builder  <code>CompareToBuilder</code> to append to\n+     * @param useTransients  whether to compare transient fields\n+     * @param excludeFields  fields to exclude\n+     */\n+    private static void reflectionAppend(\n+        Object lhs,\n+        Object rhs,\n+        Class<?> clazz,\n+        CompareToBuilder builder,\n+        boolean useTransients,\n+        String[] excludeFields) {\n+        \n+        Field[] fields = clazz.getDeclaredFields();\n+        List<String> excludedFieldList = excludeFields != null ? Arrays.asList(excludeFields) : Collections.<String>emptyList();\n+        AccessibleObject.setAccessible(fields, true);\n+        for (int i = 0; i < fields.length && builder.comparison == 0; i++) {\n+            Field f = fields[i];\n+            if (!excludedFieldList.contains(f.getName())\n+                && (f.getName().indexOf('$') == -1)\n+                && (useTransients || !Modifier.isTransient(f.getModifiers()))\n+                && (!Modifier.isStatic(f.getModifiers()))) {\n+                try {\n+                    builder.append(f.get(lhs), f.get(rhs));\n+                } catch (IllegalAccessException e) {\n+                    // This can't happen. Would get a Security exception instead.\n+                    // Throw a runtime exception in case the impossible happens.\n+                    throw new InternalError(\"Unexpected IllegalAccessException\");\n+                }\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Appends to the <code>builder</code> the <code>compareTo(Object)</code>\n+     * result of the superclass.</p>\n+     *\n+     * @param superCompareTo  result of calling <code>super.compareTo(Object)</code>\n+     * @return this - used to chain append calls\n+     * @since 2.0\n+     */\n+    public CompareToBuilder appendSuper(int superCompareTo) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        comparison = superCompareTo;\n+        return this;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Appends to the <code>builder</code> the comparison of\n+     * two <code>Object</code>s.</p>\n+     *\n+     * <ol>\n+     * <li>Check if <code>lhs == rhs</code></li>\n+     * <li>Check if either <code>lhs</code> or <code>rhs</code> is <code>null</code>,\n+     *     a <code>null</code> object is less than a non-<code>null</code> object</li>\n+     * <li>Check the object contents</li>\n+     * </ol>\n+     * \n+     * <p><code>lhs</code> must either be an array or implement {@link Comparable}.</p>\n+     *\n+     * @param lhs  left-hand object\n+     * @param rhs  right-hand object\n+     * @return this - used to chain append calls\n+     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n+     *  with <code>lhs</code>\n+     */\n+    public CompareToBuilder append(Object lhs, Object rhs) {\n+        return append(lhs, rhs, null);\n+    }\n+\n+    /**\n+     * <p>Appends to the <code>builder</code> the comparison of\n+     * two <code>Object</code>s.</p>\n+     *\n+     * <ol>\n+     * <li>Check if <code>lhs == rhs</code></li>\n+     * <li>Check if either <code>lhs</code> or <code>rhs</code> is <code>null</code>,\n+     *     a <code>null</code> object is less than a non-<code>null</code> object</li>\n+     * <li>Check the object contents</li>\n+     * </ol>\n+     *\n+     * <p>If <code>lhs</code> is an array, array comparison methods will be used.\n+     * Otherwise <code>comparator</code> will be used to compare the objects.\n+     * If <code>comparator</code> is <code>null</code>, <code>lhs</code> must\n+     * implement {@link Comparable} instead.</p>\n+     *\n+     * @param lhs  left-hand object\n+     * @param rhs  right-hand object\n+     * @param comparator  <code>Comparator</code> used to compare the objects,\n+     *  <code>null</code> means treat lhs as <code>Comparable</code>\n+     * @return this - used to chain append calls\n+     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n+     *  with <code>lhs</code>\n+     * @since 2.0\n+     */\n+    public CompareToBuilder append(Object lhs, Object rhs, Comparator<?> comparator) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.getClass().isArray()) {\n+            // switch on type of array, to dispatch to the correct handler\n+            // handles multi dimensional arrays\n+            // throws a ClassCastException if rhs is not the correct array type\n+            if (lhs instanceof long[]) {\n+                append((long[]) lhs, (long[]) rhs);\n+            } else if (lhs instanceof int[]) {\n+                append((int[]) lhs, (int[]) rhs);\n+            } else if (lhs instanceof short[]) {\n+                append((short[]) lhs, (short[]) rhs);\n+            } else if (lhs instanceof char[]) {\n+                append((char[]) lhs, (char[]) rhs);\n+            } else if (lhs instanceof byte[]) {\n+                append((byte[]) lhs, (byte[]) rhs);\n+            } else if (lhs instanceof double[]) {\n+                append((double[]) lhs, (double[]) rhs);\n+            } else if (lhs instanceof float[]) {\n+                append((float[]) lhs, (float[]) rhs);\n+            } else if (lhs instanceof boolean[]) {\n+                append((boolean[]) lhs, (boolean[]) rhs);\n+            } else {\n+                // not an array of primitives\n+                // throws a ClassCastException if rhs is not an array\n+                append((Object[]) lhs, (Object[]) rhs, comparator);\n+            }\n+        } else {\n+            // the simple case, not an array, just test the element\n+            if (comparator == null) {\n+                @SuppressWarnings(\"unchecked\") // assume this can be done; if not throw CCE as per Javadoc\n+                final Comparable<Object> comparable = (Comparable<Object>) lhs;\n+                comparison = comparable.compareTo(rhs);\n+            } else {\n+                @SuppressWarnings(\"unchecked\") // assume this can be done; if not throw CCE as per Javadoc\n+                final Comparator<Object> comparator2 = (Comparator<Object>) comparator;\n+                comparison = comparator2.compare(lhs, rhs);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    //-------------------------------------------------------------------------\n+    /**\n+     * Appends to the <code>builder</code> the comparison of\n+     * two <code>long</code>s.\n+     *\n+     * @param lhs  left-hand value\n+     * @param rhs  right-hand value\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(long lhs, long rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0));\n+        return this;\n+    }\n+\n+    /**\n+     * Appends to the <code>builder</code> the comparison of\n+     * two <code>int</code>s.\n+     *\n+     * @param lhs  left-hand value\n+     * @param rhs  right-hand value\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(int lhs, int rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0));\n+        return this;\n+    }\n+\n+    /**\n+     * Appends to the <code>builder</code> the comparison of\n+     * two <code>short</code>s.\n+     * \n+     * @param lhs  left-hand value\n+     * @param rhs  right-hand value\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(short lhs, short rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0));\n+        return this;\n+    }\n+\n+    /**\n+     * Appends to the <code>builder</code> the comparison of\n+     * two <code>char</code>s.\n+     *\n+     * @param lhs  left-hand value\n+     * @param rhs  right-hand value\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(char lhs, char rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0));\n+        return this;\n+    }\n+\n+    /**\n+     * Appends to the <code>builder</code> the comparison of\n+     * two <code>byte</code>s.\n+     * \n+     * @param lhs  left-hand value\n+     * @param rhs  right-hand value\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(byte lhs, byte rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        comparison = ((lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Appends to the <code>builder</code> the comparison of\n+     * two <code>double</code>s.</p>\n+     *\n+     * <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p>\n+     *\n+     * <p>It is compatible with the hash code generated by\n+     * <code>HashCodeBuilder</code>.</p>\n+     *\n+     * @param lhs  left-hand value\n+     * @param rhs  right-hand value\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(double lhs, double rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        comparison = Double.compare(lhs, rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Appends to the <code>builder</code> the comparison of\n+     * two <code>float</code>s.</p>\n+     *\n+     * <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p>\n+     *\n+     * <p>It is compatible with the hash code generated by\n+     * <code>HashCodeBuilder</code>.</p>\n+     *\n+     * @param lhs  left-hand value\n+     * @param rhs  right-hand value\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(float lhs, float rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        comparison = Float.compare(lhs, rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * Appends to the <code>builder</code> the comparison of\n+     * two <code>booleans</code>s.\n+     *\n+     * @param lhs  left-hand value\n+     * @param rhs  right-hand value\n+     * @return this - used to chain append calls\n+      */\n+    public CompareToBuilder append(boolean lhs, boolean rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == false) {\n+            comparison = -1;\n+        } else {\n+            comparison = +1;\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Appends to the <code>builder</code> the deep comparison of\n+     * two <code>Object</code> arrays.</p>\n+     *\n+     * <ol>\n+     *  <li>Check if arrays are the same using <code>==</code></li>\n+     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>\n+     *  <li>Check array length, a short length array is less than a long length array</li>\n+     *  <li>Check array contents element by element using {@link #append(Object, Object, Comparator)}</li>\n+     * </ol>\n+     *\n+     * <p>This method will also will be called for the top level of multi-dimensional,\n+     * ragged, and multi-typed arrays.</p>\n+     *\n+     * @param lhs  left-hand array\n+     * @param rhs  right-hand array\n+     * @return this - used to chain append calls\n+     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n+     *  with <code>lhs</code>\n+     */\n+    public CompareToBuilder append(Object[] lhs, Object[] rhs) {\n+        return append(lhs, rhs, null);\n+    }\n+    \n+    /**\n+     * <p>Appends to the <code>builder</code> the deep comparison of\n+     * two <code>Object</code> arrays.</p>\n+     *\n+     * <ol>\n+     *  <li>Check if arrays are the same using <code>==</code></li>\n+     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>\n+     *  <li>Check array length, a short length array is less than a long length array</li>\n+     *  <li>Check array contents element by element using {@link #append(Object, Object, Comparator)}</li>\n+     * </ol>\n+     *\n+     * <p>This method will also will be called for the top level of multi-dimensional,\n+     * ragged, and multi-typed arrays.</p>\n+     *\n+     * @param lhs  left-hand array\n+     * @param rhs  right-hand array\n+     * @param comparator  <code>Comparator</code> to use to compare the array elements,\n+     *  <code>null</code> means to treat <code>lhs</code> elements as <code>Comparable</code>.\n+     * @return this - used to chain append calls\n+     * @throws ClassCastException  if <code>rhs</code> is not assignment-compatible\n+     *  with <code>lhs</code>\n+     * @since 2.0\n+     */\n+    public CompareToBuilder append(Object[] lhs, Object[] rhs, Comparator<?> comparator) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            comparison = (lhs.length < rhs.length) ? -1 : +1;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n+            append(lhs[i], rhs[i], comparator);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Appends to the <code>builder</code> the deep comparison of\n+     * two <code>long</code> arrays.</p>\n+     *\n+     * <ol>\n+     *  <li>Check if arrays are the same using <code>==</code></li>\n+     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>\n+     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n+     *  <li>Check array contents element by element using {@link #append(long, long)}</li>\n+     * </ol>\n+     *\n+     * @param lhs  left-hand array\n+     * @param rhs  right-hand array\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(long[] lhs, long[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            comparison = (lhs.length < rhs.length) ? -1 : +1;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Appends to the <code>builder</code> the deep comparison of\n+     * two <code>int</code> arrays.</p>\n+     *\n+     * <ol>\n+     *  <li>Check if arrays are the same using <code>==</code></li>\n+     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>\n+     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n+     *  <li>Check array contents element by element using {@link #append(int, int)}</li>\n+     * </ol>\n+     *\n+     * @param lhs  left-hand array\n+     * @param rhs  right-hand array\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(int[] lhs, int[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            comparison = (lhs.length < rhs.length) ? -1 : +1;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Appends to the <code>builder</code> the deep comparison of\n+     * two <code>short</code> arrays.</p>\n+     *\n+     * <ol>\n+     *  <li>Check if arrays are the same using <code>==</code></li>\n+     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>\n+     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n+     *  <li>Check array contents element by element using {@link #append(short, short)}</li>\n+     * </ol>\n+     *\n+     * @param lhs  left-hand array\n+     * @param rhs  right-hand array\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(short[] lhs, short[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            comparison = (lhs.length < rhs.length) ? -1 : +1;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Appends to the <code>builder</code> the deep comparison of\n+     * two <code>char</code> arrays.</p>\n+     *\n+     * <ol>\n+     *  <li>Check if arrays are the same using <code>==</code></li>\n+     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>\n+     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n+     *  <li>Check array contents element by element using {@link #append(char, char)}</li>\n+     * </ol>\n+     *\n+     * @param lhs  left-hand array\n+     * @param rhs  right-hand array\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(char[] lhs, char[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            comparison = (lhs.length < rhs.length) ? -1 : +1;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Appends to the <code>builder</code> the deep comparison of\n+     * two <code>byte</code> arrays.</p>\n+     *\n+     * <ol>\n+     *  <li>Check if arrays are the same using <code>==</code></li>\n+     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>\n+     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n+     *  <li>Check array contents element by element using {@link #append(byte, byte)}</li>\n+     * </ol>\n+     *\n+     * @param lhs  left-hand array\n+     * @param rhs  right-hand array\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(byte[] lhs, byte[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            comparison = (lhs.length < rhs.length) ? -1 : +1;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Appends to the <code>builder</code> the deep comparison of\n+     * two <code>double</code> arrays.</p>\n+     *\n+     * <ol>\n+     *  <li>Check if arrays are the same using <code>==</code></li>\n+     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>\n+     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n+     *  <li>Check array contents element by element using {@link #append(double, double)}</li>\n+     * </ol>\n+     *\n+     * @param lhs  left-hand array\n+     * @param rhs  right-hand array\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(double[] lhs, double[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            comparison = (lhs.length < rhs.length) ? -1 : +1;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Appends to the <code>builder</code> the deep comparison of\n+     * two <code>float</code> arrays.</p>\n+     *\n+     * <ol>\n+     *  <li>Check if arrays are the same using <code>==</code></li>\n+     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>\n+     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n+     *  <li>Check array contents element by element using {@link #append(float, float)}</li>\n+     * </ol>\n+     *\n+     * @param lhs  left-hand array\n+     * @param rhs  right-hand array\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(float[] lhs, float[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            comparison = (lhs.length < rhs.length) ? -1 : +1;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Appends to the <code>builder</code> the deep comparison of\n+     * two <code>boolean</code> arrays.</p>\n+     *\n+     * <ol>\n+     *  <li>Check if arrays are the same using <code>==</code></li>\n+     *  <li>Check if for <code>null</code>, <code>null</code> is less than non-<code>null</code></li>\n+     *  <li>Check array length, a shorter length array is less than a longer length array</li>\n+     *  <li>Check array contents element by element using {@link #append(boolean, boolean)}</li>\n+     * </ol>\n+     *\n+     * @param lhs  left-hand array\n+     * @param rhs  right-hand array\n+     * @return this - used to chain append calls\n+     */\n+    public CompareToBuilder append(boolean[] lhs, boolean[] rhs) {\n+        if (comparison != 0) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null) {\n+            comparison = -1;\n+            return this;\n+        }\n+        if (rhs == null) {\n+            comparison = +1;\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            comparison = (lhs.length < rhs.length) ? -1 : +1;\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && comparison == 0; i++) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a negative integer, a positive integer, or zero as\n+     * the <code>builder</code> has judged the \"left-hand\" side\n+     * as less than, greater than, or equal to the \"right-hand\"\n+     * side.\n+     * \n+     * @return final comparison result\n+     */\n+    public int toComparison() {\n+        return comparison;\n+    }\n+\n+}\n+\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/builder/EqualsBuilder.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.builder;\n+\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * <p>Assists in implementing {@link Object#equals(Object)} methods.</p>\n+ *\n+ * <p> This class provides methods to build a good equals method for any\n+ * class. It follows rules laid out in\n+ * <a href=\"http://java.sun.com/docs/books/effective/index.html\">Effective Java</a>\n+ * , by Joshua Bloch. In particular the rule for comparing <code>doubles</code>,\n+ * <code>floats</code>, and arrays can be tricky. Also, making sure that\n+ * <code>equals()</code> and <code>hashCode()</code> are consistent can be\n+ * difficult.</p>\n+ *\n+ * <p>Two Objects that compare as equals must generate the same hash code,\n+ * but two Objects with the same hash code do not have to be equal.</p>\n+ *\n+ * <p>All relevant fields should be included in the calculation of equals.\n+ * Derived fields may be ignored. In particular, any field used in\n+ * generating a hash code must be used in the equals method, and vice\n+ * versa.</p>\n+ *\n+ * <p>Typical use for the code is as follows:</p>\n+ * <pre>\n+ * public boolean equals(Object obj) {\n+ *   if (obj == null) { return false; }\n+ *   if (obj == this) { return true; }\n+ *   if (obj.getClass() != getClass()) {\n+ *     return false;\n+ *   }\n+ *   MyClass rhs = (MyClass) obj;\n+ *   return new EqualsBuilder()\n+ *                 .appendSuper(super.equals(obj))\n+ *                 .append(field1, rhs.field1)\n+ *                 .append(field2, rhs.field2)\n+ *                 .append(field3, rhs.field3)\n+ *                 .isEquals();\n+ *  }\n+ * </pre>\n+ *\n+ * <p> Alternatively, there is a method that uses reflection to determine\n+ * the fields to test. Because these fields are usually private, the method,\n+ * <code>reflectionEquals</code>, uses <code>AccessibleObject.setAccessible</code> to\n+ * change the visibility of the fields. This will fail under a security\n+ * manager, unless the appropriate permissions are set up correctly. It is\n+ * also slower than testing explicitly.</p>\n+ *\n+ * <p> A typical invocation for this method would look like:</p>\n+ * <pre>\n+ * public boolean equals(Object obj) {\n+ *   return EqualsBuilder.reflectionEquals(this, obj);\n+ * }\n+ * </pre>\n+ *\n+ * @author Apache Software Foundation\n+ * @author <a href=\"mailto:steve.downey@netfolio.com\">Steve Downey</a>\n+ * @author Gary Gregory\n+ * @author Pete Gieser\n+ * @author Arun Mammen Thomas\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class EqualsBuilder {\n+    \n+    /**\n+     * If the fields tested are equals.\n+     * The default value is <code>true</code>.\n+     */\n+    private boolean isEquals = true;\n+\n+    /**\n+     * <p>Constructor for EqualsBuilder.</p>\n+     *\n+     * <p>Starts off assuming that equals is <code>true</code>.</p>\n+     * @see Object#equals(Object)\n+     */\n+    public EqualsBuilder() {\n+        // do nothing for now.\n+    }\n+\n+    //-------------------------------------------------------------------------\n+\n+    /**\n+     * <p>This method uses reflection to determine if the two <code>Object</code>s\n+     * are equal.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n+     * <p>Transient members will be not be tested, as they are likely derived\n+     * fields, and not part of the value of the Object.</p>\n+     *\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n+     *\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n+     * @return <code>true</code> if the two Objects have tested equals.\n+     */\n+    public static boolean reflectionEquals(Object lhs, Object rhs) {\n+        return reflectionEquals(lhs, rhs, false, null, null);\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to determine if the two <code>Object</code>s\n+     * are equal.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n+     * <p>Transient members will be not be tested, as they are likely derived\n+     * fields, and not part of the value of the Object.</p>\n+     *\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n+     *\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n+     * @param excludeFields  Collection of String field names to exclude from testing\n+     * @return <code>true</code> if the two Objects have tested equals.\n+     */\n+    public static boolean reflectionEquals(Object lhs, Object rhs, Collection<String> excludeFields) {\n+        return reflectionEquals(lhs, rhs, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to determine if the two <code>Object</code>s\n+     * are equal.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n+     * <p>Transient members will be not be tested, as they are likely derived\n+     * fields, and not part of the value of the Object.</p>\n+     *\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n+     *\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n+     * @param excludeFields  array of field names to exclude from testing\n+     * @return <code>true</code> if the two Objects have tested equals.\n+     */\n+    public static boolean reflectionEquals(Object lhs, Object rhs, String[] excludeFields) {\n+        return reflectionEquals(lhs, rhs, false, null, excludeFields);\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to determine if the two <code>Object</code>s\n+     * are equal.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n+     * <p>If the TestTransients parameter is set to <code>true</code>, transient\n+     * members will be tested, otherwise they are ignored, as they are likely\n+     * derived fields, and not part of the value of the <code>Object</code>.</p>\n+     *\n+     * <p>Static fields will not be tested. Superclass fields will be included.</p>\n+     *\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n+     * @param testTransients  whether to include transient fields\n+     * @return <code>true</code> if the two Objects have tested equals.\n+     */\n+    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients) {\n+        return reflectionEquals(lhs, rhs, testTransients, null, null);\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to determine if the two <code>Object</code>s\n+     * are equal.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n+     * <p>If the testTransients parameter is set to <code>true</code>, transient\n+     * members will be tested, otherwise they are ignored, as they are likely\n+     * derived fields, and not part of the value of the <code>Object</code>.</p>\n+     *\n+     * <p>Static fields will not be included. Superclass fields will be appended\n+     * up to and including the specified superclass. A null superclass is treated\n+     * as java.lang.Object.</p>\n+     *\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n+     * @param testTransients  whether to include transient fields\n+     * @param reflectUpToClass  the superclass to reflect up to (inclusive),\n+     *  may be <code>null</code>\n+     * @return <code>true</code> if the two Objects have tested equals.\n+     * @since 2.0\n+     */\n+    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class<?> reflectUpToClass) {\n+        return reflectionEquals(lhs, rhs, testTransients, reflectUpToClass, null);\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to determine if the two <code>Object</code>s\n+     * are equal.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run under\n+     * a security manager, if the permissions are not set up correctly. It is also\n+     * not as efficient as testing explicitly.</p>\n+     *\n+     * <p>If the testTransients parameter is set to <code>true</code>, transient\n+     * members will be tested, otherwise they are ignored, as they are likely\n+     * derived fields, and not part of the value of the <code>Object</code>.</p>\n+     *\n+     * <p>Static fields will not be included. Superclass fields will be appended\n+     * up to and including the specified superclass. A null superclass is treated\n+     * as java.lang.Object.</p>\n+     *\n+     * @param lhs  <code>this</code> object\n+     * @param rhs  the other object\n+     * @param testTransients  whether to include transient fields\n+     * @param reflectUpToClass  the superclass to reflect up to (inclusive),\n+     *  may be <code>null</code>\n+     * @param excludeFields  array of field names to exclude from testing\n+     * @return <code>true</code> if the two Objects have tested equals.\n+     * @since 2.0\n+     */\n+    public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class<?> reflectUpToClass,\n+            String[] excludeFields) {\n+        if (lhs == rhs) {\n+            return true;\n+        }\n+        if (lhs == null || rhs == null) {\n+            return false;\n+        }\n+        // Find the leaf class since there may be transients in the leaf \n+        // class or in classes between the leaf and root.\n+        // If we are not testing transients or a subclass has no ivars, \n+        // then a subclass can test equals to a superclass.\n+        Class<?> lhsClass = lhs.getClass();\n+        Class<?> rhsClass = rhs.getClass();\n+        Class<?> testClass;\n+        if (lhsClass.isInstance(rhs)) {\n+            testClass = lhsClass;\n+            if (!rhsClass.isInstance(lhs)) {\n+                // rhsClass is a subclass of lhsClass\n+                testClass = rhsClass;\n+            }\n+        } else if (rhsClass.isInstance(lhs)) {\n+            testClass = rhsClass;\n+            if (!lhsClass.isInstance(rhs)) {\n+                // lhsClass is a subclass of rhsClass\n+                testClass = lhsClass;\n+            }\n+        } else {\n+            // The two classes are not related.\n+            return false;\n+        }\n+        EqualsBuilder equalsBuilder = new EqualsBuilder();\n+        try {\n+            reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);\n+            while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {\n+                testClass = testClass.getSuperclass();\n+                reflectionAppend(lhs, rhs, testClass, equalsBuilder, testTransients, excludeFields);\n+            }\n+        } catch (IllegalArgumentException e) {\n+            // In this case, we tried to test a subclass vs. a superclass and\n+            // the subclass has ivars or the ivars are transient and \n+            // we are testing transients.\n+            // If a subclass has ivars that we are trying to test them, we get an\n+            // exception and we know that the objects are not equal.\n+            return false;\n+        }\n+        return equalsBuilder.isEquals();\n+    }\n+\n+    /**\n+     * <p>Appends the fields and values defined by the given object of the\n+     * given Class.</p>\n+     * \n+     * @param lhs  the left hand object\n+     * @param rhs  the right hand object\n+     * @param clazz  the class to append details of\n+     * @param builder  the builder to append to\n+     * @param useTransients  whether to test transient fields\n+     * @param excludeFields  array of field names to exclude from testing\n+     */\n+    private static void reflectionAppend(\n+        Object lhs,\n+        Object rhs,\n+        Class<?> clazz,\n+        EqualsBuilder builder,\n+        boolean useTransients,\n+        String[] excludeFields) {\n+        Field[] fields = clazz.getDeclaredFields();\n+        List<String> excludedFieldList = excludeFields != null ? Arrays.asList(excludeFields) : Collections.<String>emptyList();\n+        AccessibleObject.setAccessible(fields, true);\n+        for (int i = 0; i < fields.length && builder.isEquals; i++) {\n+            Field f = fields[i];\n+            if (!excludedFieldList.contains(f.getName())\n+                && (f.getName().indexOf('$') == -1)\n+                && (useTransients || !Modifier.isTransient(f.getModifiers()))\n+                && (!Modifier.isStatic(f.getModifiers()))) {\n+                try {\n+                    builder.append(f.get(lhs), f.get(rhs));\n+                } catch (IllegalAccessException e) {\n+                    //this can't happen. Would get a Security exception instead\n+                    //throw a runtime exception in case the impossible happens.\n+                    throw new InternalError(\"Unexpected IllegalAccessException\");\n+                }\n+            }\n+        }\n+    }\n+\n+    //-------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Adds the result of <code>super.equals()</code> to this builder.</p>\n+     *\n+     * @param superEquals  the result of calling <code>super.equals()</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     * @since 2.0\n+     */\n+    public EqualsBuilder appendSuper(boolean superEquals) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = superEquals;\n+        return this;\n+    }\n+\n+    //-------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Test if two <code>Object</code>s are equal using their\n+     * <code>equals</code> method.</p>\n+     *\n+     * @param lhs  the left hand object\n+     * @param rhs  the right hand object\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(Object lhs, Object rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        Class<?> lhsClass = lhs.getClass();\n+        if (!lhsClass.isArray()) {\n+            // The simple case, not an array, just test the element\n+            isEquals = lhs.equals(rhs);\n+        } else if (lhs.getClass() != rhs.getClass()) {\n+            // Here when we compare different dimensions, for example: a boolean[][] to a boolean[] \n+            this.setEquals(false);\n+        }\n+        // 'Switch' on type of array, to dispatch to the correct handler\n+        // This handles multi dimensional arrays of the same depth\n+        else if (lhs instanceof long[]) {\n+            append((long[]) lhs, (long[]) rhs);\n+        } else if (lhs instanceof int[]) {\n+            append((int[]) lhs, (int[]) rhs);\n+        } else if (lhs instanceof short[]) {\n+            append((short[]) lhs, (short[]) rhs);\n+        } else if (lhs instanceof char[]) {\n+            append((char[]) lhs, (char[]) rhs);\n+        } else if (lhs instanceof byte[]) {\n+            append((byte[]) lhs, (byte[]) rhs);\n+        } else if (lhs instanceof double[]) {\n+            append((double[]) lhs, (double[]) rhs);\n+        } else if (lhs instanceof float[]) {\n+            append((float[]) lhs, (float[]) rhs);\n+        } else if (lhs instanceof boolean[]) {\n+            append((boolean[]) lhs, (boolean[]) rhs);\n+        } else {\n+            // Not an array of primitives\n+            append((Object[]) lhs, (Object[]) rhs);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Test if two <code>long</code> s are equal.\n+     * </p>\n+     * \n+     * @param lhs\n+     *                  the left hand <code>long</code>\n+     * @param rhs\n+     *                  the right hand <code>long</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(long lhs, long rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Test if two <code>int</code>s are equal.</p>\n+     *\n+     * @param lhs  the left hand <code>int</code>\n+     * @param rhs  the right hand <code>int</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(int lhs, int rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Test if two <code>short</code>s are equal.</p>\n+     *\n+     * @param lhs  the left hand <code>short</code>\n+     * @param rhs  the right hand <code>short</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(short lhs, short rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Test if two <code>char</code>s are equal.</p>\n+     *\n+     * @param lhs  the left hand <code>char</code>\n+     * @param rhs  the right hand <code>char</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(char lhs, char rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Test if two <code>byte</code>s are equal.</p>\n+     *\n+     * @param lhs  the left hand <code>byte</code>\n+     * @param rhs  the right hand <code>byte</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(byte lhs, byte rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Test if two <code>double</code>s are equal by testing that the\n+     * pattern of bits returned by <code>doubleToLong</code> are equal.</p>\n+     *\n+     * <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p>\n+     *\n+     * <p>It is compatible with the hash code generated by\n+     * <code>HashCodeBuilder</code>.</p>\n+     *\n+     * @param lhs  the left hand <code>double</code>\n+     * @param rhs  the right hand <code>double</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(double lhs, double rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        return append(Double.doubleToLongBits(lhs), Double.doubleToLongBits(rhs));\n+    }\n+\n+    /**\n+     * <p>Test if two <code>float</code>s are equal byt testing that the\n+     * pattern of bits returned by doubleToLong are equal.</p>\n+     *\n+     * <p>This handles NaNs, Infinities, and <code>-0.0</code>.</p>\n+     *\n+     * <p>It is compatible with the hash code generated by\n+     * <code>HashCodeBuilder</code>.</p>\n+     *\n+     * @param lhs  the left hand <code>float</code>\n+     * @param rhs  the right hand <code>float</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(float lhs, float rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        return append(Float.floatToIntBits(lhs), Float.floatToIntBits(rhs));\n+    }\n+\n+    /**\n+     * <p>Test if two <code>booleans</code>s are equal.</p>\n+     *\n+     * @param lhs  the left hand <code>boolean</code>\n+     * @param rhs  the right hand <code>boolean</code>\n+     * @return EqualsBuilder - used to chain calls.\n+      */\n+    public EqualsBuilder append(boolean lhs, boolean rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        isEquals = (lhs == rhs);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Performs a deep comparison of two <code>Object</code> arrays.</p>\n+     *\n+     * <p>This also will be called for the top level of\n+     * multi-dimensional, ragged, and multi-typed arrays.</p>\n+     *\n+     * @param lhs  the left hand <code>Object[]</code>\n+     * @param rhs  the right hand <code>Object[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(Object[] lhs, Object[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>long</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(long, long)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>long[]</code>\n+     * @param rhs  the right hand <code>long[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(long[] lhs, long[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>int</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(int, int)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>int[]</code>\n+     * @param rhs  the right hand <code>int[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(int[] lhs, int[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>short</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(short, short)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>short[]</code>\n+     * @param rhs  the right hand <code>short[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(short[] lhs, short[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>char</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(char, char)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>char[]</code>\n+     * @param rhs  the right hand <code>char[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(char[] lhs, char[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>byte</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(byte, byte)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>byte[]</code>\n+     * @param rhs  the right hand <code>byte[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(byte[] lhs, byte[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>double</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(double, double)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>double[]</code>\n+     * @param rhs  the right hand <code>double[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(double[] lhs, double[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>float</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(float, float)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>float[]</code>\n+     * @param rhs  the right hand <code>float[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(float[] lhs, float[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Deep comparison of array of <code>boolean</code>. Length and all\n+     * values are compared.</p>\n+     *\n+     * <p>The method {@link #append(boolean, boolean)} is used.</p>\n+     *\n+     * @param lhs  the left hand <code>boolean[]</code>\n+     * @param rhs  the right hand <code>boolean[]</code>\n+     * @return EqualsBuilder - used to chain calls.\n+     */\n+    public EqualsBuilder append(boolean[] lhs, boolean[] rhs) {\n+        if (isEquals == false) {\n+            return this;\n+        }\n+        if (lhs == rhs) {\n+            return this;\n+        }\n+        if (lhs == null || rhs == null) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        if (lhs.length != rhs.length) {\n+            this.setEquals(false);\n+            return this;\n+        }\n+        for (int i = 0; i < lhs.length && isEquals; ++i) {\n+            append(lhs[i], rhs[i]);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Returns <code>true</code> if the fields that have been checked\n+     * are all equal.</p>\n+     *\n+     * @return boolean\n+     */\n+    public boolean isEquals() {\n+        return this.isEquals;\n+    }\n+\n+    /**\n+     * Sets the <code>isEquals</code> value.\n+     * \n+     * @param isEquals The value to set.\n+     * @since 2.1\n+     */\n+    protected void setEquals(boolean isEquals) {\n+        this.isEquals = isEquals;\n+    }\n+\n+    /**\n+     * Reset the EqualsBuilder so you can use the same object again\n+     */\n+    public void reset() {\n+        this.isEquals = true;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang3.builder;\n+\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * <p>\n+ * Assists in implementing {@link Object#hashCode()} methods.\n+ * </p>\n+ * \n+ * <p>\n+ * This class enables a good <code>hashCode</code> method to be built for any class. It follows the rules laid out in\n+ * the book <a href=\"http://java.sun.com/docs/books/effective/index.html\">Effective Java</a> by Joshua Bloch. Writing a\n+ * good <code>hashCode</code> method is actually quite difficult. This class aims to simplify the process.\n+ * </p>\n+ * \n+ * <p>\n+ * All relevant fields from the object should be included in the <code>hashCode</code> method. Derived fields may be\n+ * excluded. In general, any field used in the <code>equals</code> method must be used in the <code>hashCode</code>\n+ * method.\n+ * </p>\n+ * \n+ * <p>\n+ * To use this class write code as follows:\n+ * </p>\n+ * \n+ * <pre>\n+ * public class Person {\n+ *   String name;\n+ *   int age;\n+ *   boolean smoker;\n+ *   ...\n+ *\n+ *   public int hashCode() {\n+ *     // you pick a hard-coded, randomly chosen, non-zero, odd number\n+ *     // ideally different for each class\n+ *     return new HashCodeBuilder(17, 37).\n+ *       append(name).\n+ *       append(age).\n+ *       append(smoker).\n+ *       toHashCode();\n+ *   }\n+ * }\n+ * </pre>\n+ * \n+ * <p>\n+ * If required, the superclass <code>hashCode()</code> can be added using {@link #appendSuper}.\n+ * </p>\n+ * \n+ * <p>\n+ * Alternatively, there is a method that uses reflection to determine the fields to test. Because these fields are\n+ * usually private, the method, <code>reflectionHashCode</code>, uses <code>AccessibleObject.setAccessible</code>\n+ * to change the visibility of the fields. This will fail under a security manager, unless the appropriate permissions\n+ * are set up correctly. It is also slower than testing explicitly.\n+ * </p>\n+ * \n+ * <p>\n+ * A typical invocation for this method would look like:\n+ * </p>\n+ * \n+ * <pre>\n+ * public int hashCode() {\n+ *   return HashCodeBuilder.reflectionHashCode(this);\n+ * }\n+ * </pre>\n+ * \n+ * @author Apache Software Foundation\n+ * @author Gary Gregory\n+ * @author Pete Gieser\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class HashCodeBuilder {\n+    /**\n+     * <p>\n+     * A registry of objects used by reflection methods to detect cyclical object references and avoid infinite loops.\n+     * </p>\n+     * \n+     * @since 2.3\n+     */\n+    private static final ThreadLocal<Set<IDKey>> registry = new ThreadLocal<Set<IDKey>>() {\n+        @Override\n+        protected Set<IDKey> initialValue() {\n+            // The HashSet implementation is not synchronized,\n+            // which is just what we need here.\n+            return new HashSet<IDKey>();\n+        }\n+    };\n+\n+    /*\n+     * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()\n+     * we are in the process of calculating.\n+     * \n+     * So we generate a one-to-one mapping from the original object to a new object.\n+     * \n+     * Now HashSet uses equals() to determine if two elements with the same hashcode really\n+     * are equal, so we also need to ensure that the replacement objects are only equal\n+     * if the original objects are identical.\n+     * \n+     * The original implementation (2.4 and before) used the System.indentityHashCode()\n+     * method - however this is not guaranteed to generate unique ids (e.g. LANG-459)\n+     *  \n+     * We now use the IDKey helper class (adapted from org.apache.axis.utils.IDKey)\n+     * to disambiguate the duplicate ids.\n+     */\n+    \n+    /**\n+     * <p>\n+     * Returns the registry of objects being traversed by the reflection methods in the current thread.\n+     * </p>\n+     * \n+     * @return Set the registry of objects being traversed\n+     * @since 2.3\n+     */\n+    static Set<IDKey> getRegistry() {\n+        return registry.get();\n+    }\n+\n+    /**\n+     * <p>\n+     * Returns <code>true</code> if the registry contains the given object. Used by the reflection methods to avoid\n+     * infinite loops.\n+     * </p>\n+     * \n+     * @param value\n+     *            The object to lookup in the registry.\n+     * @return boolean <code>true</code> if the registry contains the given object.\n+     * @since 2.3\n+     */\n+    static boolean isRegistered(Object value) {\n+        return getRegistry().contains(new IDKey(value));\n+    }\n+\n+    /**\n+     * <p>\n+     * Appends the fields and values defined by the given object of the given <code>Class</code>.\n+     * </p>\n+     * \n+     * @param object\n+     *            the object to append details of\n+     * @param clazz\n+     *            the class to append details of\n+     * @param builder\n+     *            the builder to append to\n+     * @param useTransients\n+     *            whether to use transient fields\n+     * @param excludeFields\n+     *            Collection of String field names to exclude from use in calculation of hash code\n+     */\n+    private static void reflectionAppend(Object object, Class<?> clazz, HashCodeBuilder builder, boolean useTransients,\n+            String[] excludeFields) {\n+        if (isRegistered(object)) {\n+            return;\n+        }\n+        try {\n+            register(object);\n+            Field[] fields = clazz.getDeclaredFields();\n+            List<String> excludedFieldList = excludeFields != null ? Arrays.asList(excludeFields) : Collections.<String>emptyList();\n+            AccessibleObject.setAccessible(fields, true);\n+            for (Field field : fields) {\n+                if (!excludedFieldList.contains(field.getName())\n+                    && (field.getName().indexOf('$') == -1)\n+                    && (useTransients || !Modifier.isTransient(field.getModifiers()))\n+                    && (!Modifier.isStatic(field.getModifiers()))) {\n+                    try {\n+                        Object fieldValue = field.get(object);\n+                        builder.append(fieldValue);\n+                    } catch (IllegalAccessException e) {\n+                        // this can't happen. Would get a Security exception instead\n+                        // throw a runtime exception in case the impossible happens.\n+                        throw new InternalError(\"Unexpected IllegalAccessException\");\n+                    }\n+                }\n+            }\n+        } finally {\n+            unregister(object);\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * This method uses reflection to build a valid hash code.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\n+     * <code>Object</code>.\n+     * </p>\n+     * \n+     * <p>\n+     * Static fields will not be tested. Superclass fields will be included.\n+     * </p>\n+     * \n+     * <p>\n+     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\n+     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\n+     * </p>\n+     * \n+     * @param initialNonZeroOddNumber\n+     *            a non-zero, odd number used as the initial value\n+     * @param multiplierNonZeroOddNumber\n+     *            a non-zero, odd number used as the multiplier\n+     * @param object\n+     *            the Object to create a <code>hashCode</code> for\n+     * @return int hash code\n+     * @throws IllegalArgumentException\n+     *             if the Object is <code>null</code>\n+     * @throws IllegalArgumentException\n+     *             if the number is zero or even\n+     */\n+    public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object) {\n+        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, false, null, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * This method uses reflection to build a valid hash code.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\n+     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\n+     * </p>\n+     * \n+     * <p>\n+     * Static fields will not be tested. Superclass fields will be included.\n+     * </p>\n+     * \n+     * <p>\n+     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\n+     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\n+     * </p>\n+     * \n+     * @param initialNonZeroOddNumber\n+     *            a non-zero, odd number used as the initial value\n+     * @param multiplierNonZeroOddNumber\n+     *            a non-zero, odd number used as the multiplier\n+     * @param object\n+     *            the Object to create a <code>hashCode</code> for\n+     * @param testTransients\n+     *            whether to include transient fields\n+     * @return int hash code\n+     * @throws IllegalArgumentException\n+     *             if the Object is <code>null</code>\n+     * @throws IllegalArgumentException\n+     *             if the number is zero or even\n+     */\n+    public static int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, Object object,\n+            boolean testTransients) {\n+        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients, null,\n+                null);\n+    }\n+\n+    /**\n+     * Calls {@link #reflectionHashCode(int, int, Object, boolean, Class, String[])} with excludeFields set to\n+     * <code>null</code>.\n+     * \n+     * @param initialNonZeroOddNumber\n+     *            a non-zero, odd number used as the initial value\n+     * @param multiplierNonZeroOddNumber\n+     *            a non-zero, odd number used as the multiplier\n+     * @param object\n+     *            the Object to create a <code>hashCode</code> for\n+     * @param testTransients\n+     *            whether to include transient fields\n+     * @param reflectUpToClass\n+     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n+     * @return int hash code\n+     */\n+    public static <T> int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, T object,\n+            boolean testTransients, Class<? super T> reflectUpToClass) {\n+        return reflectionHashCode(initialNonZeroOddNumber, multiplierNonZeroOddNumber, object, testTransients,\n+                reflectUpToClass, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * This method uses reflection to build a valid hash code.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\n+     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\n+     * </p>\n+     * \n+     * <p>\n+     * Static fields will not be included. Superclass fields will be included up to and including the specified\n+     * superclass. A null superclass is treated as java.lang.Object.\n+     * </p>\n+     * \n+     * <p>\n+     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\n+     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\n+     * </p>\n+     * \n+     * @param initialNonZeroOddNumber\n+     *            a non-zero, odd number used as the initial value\n+     * @param multiplierNonZeroOddNumber\n+     *            a non-zero, odd number used as the multiplier\n+     * @param object\n+     *            the Object to create a <code>hashCode</code> for\n+     * @param testTransients\n+     *            whether to include transient fields\n+     * @param reflectUpToClass\n+     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n+     * @param excludeFields\n+     *            array of field names to exclude from use in calculation of hash code\n+     * @return int hash code\n+     * @throws IllegalArgumentException\n+     *             if the Object is <code>null</code>\n+     * @throws IllegalArgumentException\n+     *             if the number is zero or even\n+     * @since 2.0\n+     */\n+    public static <T> int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, T object,\n+            boolean testTransients, Class<? super T> reflectUpToClass, String[] excludeFields) {\n+\n+        if (object == null) {\n+            throw new IllegalArgumentException(\"The object to build a hash code for must not be null\");\n+        }\n+        HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber);\n+        Class<?> clazz = object.getClass();\n+        reflectionAppend(object, clazz, builder, testTransients, excludeFields);\n+        while (clazz.getSuperclass() != null && clazz != reflectUpToClass) {\n+            clazz = clazz.getSuperclass();\n+            reflectionAppend(object, clazz, builder, testTransients, excludeFields);\n+        }\n+        return builder.toHashCode();\n+    }\n+\n+    /**\n+     * <p>\n+     * This method uses reflection to build a valid hash code.\n+     * </p>\n+     * \n+     * <p>\n+     * This constructor uses two hard coded choices for the constants needed to build a hash code.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\n+     * <code>Object</code>.\n+     * </p>\n+     * \n+     * <p>\n+     * Static fields will not be tested. Superclass fields will be included.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to create a <code>hashCode</code> for\n+     * @return int hash code\n+     * @throws IllegalArgumentException\n+     *             if the object is <code>null</code>\n+     */\n+    public static int reflectionHashCode(Object object) {\n+        return reflectionHashCode(17, 37, object, false, null, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * This method uses reflection to build a valid hash code.\n+     * </p>\n+     * \n+     * <p>\n+     * This constructor uses two hard coded choices for the constants needed to build a hash code.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <P>\n+     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\n+     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\n+     * </p>\n+     * \n+     * <p>\n+     * Static fields will not be tested. Superclass fields will be included.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to create a <code>hashCode</code> for\n+     * @param testTransients\n+     *            whether to include transient fields\n+     * @return int hash code\n+     * @throws IllegalArgumentException\n+     *             if the object is <code>null</code>\n+     */\n+    public static int reflectionHashCode(Object object, boolean testTransients) {\n+        return reflectionHashCode(17, 37, object, testTransients, null, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * This method uses reflection to build a valid hash code.\n+     * </p>\n+     * \n+     * <p>\n+     * This constructor uses two hard coded choices for the constants needed to build a hash code.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\n+     * <code>Object</code>.\n+     * </p>\n+     * \n+     * <p>\n+     * Static fields will not be tested. Superclass fields will be included.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to create a <code>hashCode</code> for\n+     * @param excludeFields\n+     *            Collection of String field names to exclude from use in calculation of hash code\n+     * @return int hash code\n+     * @throws IllegalArgumentException\n+     *             if the object is <code>null</code>\n+     */\n+    public static int reflectionHashCode(Object object, Collection<String> excludeFields) {\n+        return reflectionHashCode(object, ReflectionToStringBuilder.toNoNullStringArray(excludeFields));\n+    }\n+\n+    // -------------------------------------------------------------------------\n+\n+    /**\n+     * <p>\n+     * This method uses reflection to build a valid hash code.\n+     * </p>\n+     * \n+     * <p>\n+     * This constructor uses two hard coded choices for the constants needed to build a hash code.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\n+     * <code>Object</code>.\n+     * </p>\n+     * \n+     * <p>\n+     * Static fields will not be tested. Superclass fields will be included.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to create a <code>hashCode</code> for\n+     * @param excludeFields\n+     *            array of field names to exclude from use in calculation of hash code\n+     * @return int hash code\n+     * @throws IllegalArgumentException\n+     *             if the object is <code>null</code>\n+     */\n+    public static int reflectionHashCode(Object object, String[] excludeFields) {\n+        return reflectionHashCode(17, 37, object, false, null, excludeFields);\n+    }\n+\n+    /**\n+     * <p>\n+     * Registers the given object. Used by the reflection methods to avoid infinite loops.\n+     * </p>\n+     * \n+     * @param value\n+     *            The object to register.\n+     */\n+    static void register(Object value) {\n+        getRegistry().add(new IDKey(value));\n+    }\n+\n+    /**\n+     * <p>\n+     * Unregisters the given object.\n+     * </p>\n+     * \n+     * <p>\n+     * Used by the reflection methods to avoid infinite loops.\n+     * \n+     * @param value\n+     *            The object to unregister.\n+     * @since 2.3\n+     */\n+    static void unregister(Object value) {\n+        getRegistry().remove(new IDKey(value));\n+    }\n+\n+    /**\n+     * Constant to use in building the hashCode.\n+     */\n+    private final int iConstant;\n+\n+    /**\n+     * Running total of the hashCode.\n+     */\n+    private int iTotal = 0;\n+\n+    /**\n+     * <p>\n+     * Uses two hard coded choices for the constants needed to build a <code>hashCode</code>.\n+     * </p>\n+     */\n+    public HashCodeBuilder() {\n+        iConstant = 37;\n+        iTotal = 17;\n+    }\n+\n+    /**\n+     * <p>\n+     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\n+     * however this is not vital.\n+     * </p>\n+     * \n+     * <p>\n+     * Prime numbers are preferred, especially for the multiplier.\n+     * </p>\n+     * \n+     * @param initialNonZeroOddNumber\n+     *            a non-zero, odd number used as the initial value\n+     * @param multiplierNonZeroOddNumber\n+     *            a non-zero, odd number used as the multiplier\n+     * @throws IllegalArgumentException\n+     *             if the number is zero or even\n+     */\n+    public HashCodeBuilder(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber) {\n+        if (initialNonZeroOddNumber == 0) {\n+            throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero initial value\");\n+        }\n+        if (initialNonZeroOddNumber % 2 == 0) {\n+            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd initial value\");\n+        }\n+        if (multiplierNonZeroOddNumber == 0) {\n+            throw new IllegalArgumentException(\"HashCodeBuilder requires a non zero multiplier\");\n+        }\n+        if (multiplierNonZeroOddNumber % 2 == 0) {\n+            throw new IllegalArgumentException(\"HashCodeBuilder requires an odd multiplier\");\n+        }\n+        iConstant = multiplierNonZeroOddNumber;\n+        iTotal = initialNonZeroOddNumber;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>boolean</code>.\n+     * </p>\n+     * <p>\n+     * This adds <code>iConstant * 1</code> to the <code>hashCode</code> and not a <code>1231</code> or\n+     * <code>1237</code> as done in java.lang.Boolean. This is in accordance with the <quote>Effective Java</quote>\n+     * design.\n+     * </p>\n+     * \n+     * @param value\n+     *            the boolean to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(boolean value) {\n+        iTotal = iTotal * iConstant + (value ? 0 : 1);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>boolean</code> array.\n+     * </p>\n+     * \n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(boolean[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    // -------------------------------------------------------------------------\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>byte</code>.\n+     * </p>\n+     * \n+     * @param value\n+     *            the byte to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(byte value) {\n+        iTotal = iTotal * iConstant + value;\n+        return this;\n+    }\n+\n+    // -------------------------------------------------------------------------\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>byte</code> array.\n+     * </p>\n+     * \n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(byte[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>char</code>.\n+     * </p>\n+     * \n+     * @param value\n+     *            the char to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(char value) {\n+        iTotal = iTotal * iConstant + value;\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>char</code> array.\n+     * </p>\n+     * \n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(char[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>double</code>.\n+     * </p>\n+     * \n+     * @param value\n+     *            the double to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(double value) {\n+        return append(Double.doubleToLongBits(value));\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>double</code> array.\n+     * </p>\n+     * \n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(double[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>float</code>.\n+     * </p>\n+     * \n+     * @param value\n+     *            the float to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(float value) {\n+        iTotal = iTotal * iConstant + Float.floatToIntBits(value);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>float</code> array.\n+     * </p>\n+     * \n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(float[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for an <code>int</code>.\n+     * </p>\n+     * \n+     * @param value\n+     *            the int to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(int value) {\n+        iTotal = iTotal * iConstant + value;\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for an <code>int</code> array.\n+     * </p>\n+     * \n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(int[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>long</code>.\n+     * </p>\n+     * <p>\n+     * \n+     * @param value\n+     *            the long to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    // NOTE: This method uses >> and not >>> as Effective Java and \n+    //       Long.hashCode do. Ideally we should switch to >>> at \n+    //       some stage. There are backwards compat issues, so \n+    //       that will have to wait for the time being. cf LANG-342.\n+    public HashCodeBuilder append(long value) {\n+        iTotal = iTotal * iConstant + ((int) (value ^ (value >> 32)));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>long</code> array.\n+     * </p>\n+     * \n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(long[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for an <code>Object</code>.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(Object object) {\n+        if (object == null) {\n+            iTotal = iTotal * iConstant;\n+\n+        } else {\n+                // 'Switch' on type of array, to dispatch to the correct handler\n+                // This handles multi dimensional arrays\n+                if (object instanceof long[]) {\n+                    append((long[]) object);\n+                } else if (object instanceof int[]) {\n+                    append((int[]) object);\n+                } else if (object instanceof short[]) {\n+                    append((short[]) object);\n+                } else if (object instanceof char[]) {\n+                    append((char[]) object);\n+                } else if (object instanceof byte[]) {\n+                    append((byte[]) object);\n+                } else if (object instanceof double[]) {\n+                    append((double[]) object);\n+                } else if (object instanceof float[]) {\n+                    append((float[]) object);\n+                } else if (object instanceof boolean[]) {\n+                    append((boolean[]) object);\n+                } else if (object instanceof Object[]) {\n+                    // Not an array of primitives\n+                    append((Object[]) object);\n+                } else {\n+                    iTotal = iTotal * iConstant + object.hashCode();\n+                }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for an <code>Object</code> array.\n+     * </p>\n+     * \n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(Object[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>short</code>.\n+     * </p>\n+     * \n+     * @param value\n+     *            the short to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(short value) {\n+        iTotal = iTotal * iConstant + value;\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append a <code>hashCode</code> for a <code>short</code> array.\n+     * </p>\n+     * \n+     * @param array\n+     *            the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public HashCodeBuilder append(short[] array) {\n+        if (array == null) {\n+            iTotal = iTotal * iConstant;\n+        } else {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Adds the result of super.hashCode() to this builder.\n+     * </p>\n+     * \n+     * @param superHashCode\n+     *            the result of calling <code>super.hashCode()</code>\n+     * @return this HashCodeBuilder, used to chain calls.\n+     * @since 2.0\n+     */\n+    public HashCodeBuilder appendSuper(int superHashCode) {\n+        iTotal = iTotal * iConstant + superHashCode;\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Return the computed <code>hashCode</code>.\n+     * </p>\n+     * \n+     * @return <code>hashCode</code> based on the fields appended\n+     */\n+    public int toHashCode() {\n+        return iTotal;\n+    }\n+\n+    /**\n+     * <p>\n+     * The computed <code>hashCode</code> from toHashCode() is returned due to the likelyhood \n+     * of bugs in mis-calling toHashCode() and the unlikelyness of it mattering what the hashCode for \n+     * HashCodeBuilder itself is.\n+     * \n+     * @return <code>hashCode</code> based on the fields appended\n+     */\n+    @Override\n+    public int hashCode() {\n+        return toHashCode();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/builder/IDKey.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \n+ */\n+\n+package org.apache.commons.lang3.builder;\n+\n+// adapted from org.apache.axis.utils.IDKey\n+\n+/**\n+ * Wrap an identity key (System.identityHashCode()) \n+ * so that an object can only be equal() to itself.\n+ * \n+ * This is necessary to disambiguate the occasional duplicate\n+ * identityHashCodes that can occur.\n+ * \n+ * @author Apache Software Foundation\n+ */ \n+final class IDKey {\n+        private final Object value;\n+        private final int id;\n+\n+        /**\n+         * Constructor for IDKey\n+         * @param _value\n+         */ \n+        public IDKey(Object _value) {\n+            // This is the Object hashcode \n+            id = System.identityHashCode(_value);  \n+            // There have been some cases (LANG-459) that return the \n+            // same identity hash code for different objects.  So \n+            // the value is also added to disambiguate these cases.\n+            value = _value;\n+        }\n+\n+        /**\n+         * returns hashcode - i.e. the system identity hashcode.\n+         * @return the hashcode\n+         */ \n+        @Override\n+        public int hashCode() {\n+           return id;\n+        }\n+\n+        /**\n+         * checks if instances are equal\n+         * @param other\n+         * @return if the instances are for the same object\n+         */ \n+        @Override\n+        public boolean equals(Object other) {\n+            if (!(other instanceof IDKey)) {\n+                return false;\n+            }\n+            IDKey idKey = (IDKey) other;\n+            if (id != idKey.id) {\n+                return false;\n+            }\n+            // Note that identity equals is used.\n+            return value == idKey.value;\n+         }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang3.builder;\n+\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.commons.lang3.ClassUtils;\n+\n+/**\n+ * <p>\n+ * Assists in implementing {@link Object#toString()} methods using reflection.\n+ * </p>\n+ * \n+ * <p>\n+ * This class uses reflection to determine the fields to append. Because these fields are usually private, the class\n+ * uses {@link java.lang.reflect.AccessibleObject#setAccessible(java.lang.reflect.AccessibleObject[], boolean)} to\n+ * change the visibility of the fields. This will fail under a security manager, unless the appropriate permissions are\n+ * set up correctly.\n+ * </p>\n+ * \n+ * <p>\n+ * A typical invocation for this method would look like:\n+ * </p>\n+ * \n+ * <pre>\n+ * public String toString() {\n+ *   return ReflectionToStringBuilder.toString(this);\n+ * }</pre>\n+ * \n+ * \n+ * \n+ * <p>\n+ * You can also use the builder to debug 3rd party objects:\n+ * </p>\n+ * \n+ * <pre>\n+ * System.out.println(\"An object: \" + ReflectionToStringBuilder.toString(anObject));</pre>\n+ * \n+ * \n+ * \n+ * <p>\n+ * A subclass can control field output by overriding the methods:\n+ * <ul>\n+ * <li>{@link #accept(java.lang.reflect.Field)}</li>\n+ * <li>{@link #getValue(java.lang.reflect.Field)}</li>\n+ * </ul>\n+ * </p>\n+ * <p>\n+ * For example, this method does <i>not</i> include the <code>password</code> field in the returned\n+ * <code>String</code>:\n+ * </p>\n+ * \n+ * <pre>\n+ * public String toString() {\n+ *     return (new ReflectionToStringBuilder(this) {\n+ *         protected boolean accept(Field f) {\n+ *             return super.accept(f) && !f.getName().equals(\"password\");\n+ *         }\n+ *     }).toString();\n+ * }</pre>\n+ * \n+ * \n+ * \n+ * <p>\n+ * The exact format of the <code>toString</code> is determined by the {@link ToStringStyle} passed into the\n+ * constructor.\n+ * </p>\n+ * \n+ * @author Apache Software Foundation\n+ * @author Gary Gregory\n+ * @author Pete Gieser\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class ReflectionToStringBuilder extends ToStringBuilder {\n+\n+    /**\n+     * <p>\n+     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n+     * Superclass fields will be appended.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to be output\n+     * @return the String result\n+     * @throws IllegalArgumentException\n+     *             if the Object is <code>null</code>\n+     */\n+    public static String toString(Object object) {\n+        return toString(object, null, false, false, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * Builds a <code>toString</code> value through reflection.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n+     * Superclass fields will be appended.\n+     * </p>\n+     * \n+     * <p>\n+     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to be output\n+     * @param style\n+     *            the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @return the String result\n+     * @throws IllegalArgumentException\n+     *             if the Object or <code>ToStringStyle</code> is <code>null</code>\n+     */\n+    public static String toString(Object object, ToStringStyle style) {\n+        return toString(object, style, false, false, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * Builds a <code>toString</code> value through reflection.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * If the <code>outputTransients</code> is <code>true</code>, transient members will be output, otherwise they\n+     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n+     * </p>\n+     * \n+     * <p>\n+     * Static fields will not be included. Superclass fields will be appended.\n+     * </p>\n+     * \n+     * <p>\n+     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to be output\n+     * @param style\n+     *            the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @param outputTransients\n+     *            whether to include transient fields\n+     * @return the String result\n+     * @throws IllegalArgumentException\n+     *             if the Object is <code>null</code>\n+     */\n+    public static String toString(Object object, ToStringStyle style, boolean outputTransients) {\n+        return toString(object, style, outputTransients, false, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * Builds a <code>toString</code> value through reflection.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n+     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n+     * </p>\n+     * \n+     * <p>\n+     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n+     * ignored.\n+     * </p>\n+     * \n+     * <p>\n+     * Static fields will not be included. Superclass fields will be appended.\n+     * </p>\n+     * \n+     * <p>\n+     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to be output\n+     * @param style\n+     *            the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @param outputTransients\n+     *            whether to include transient fields\n+     * @param outputStatics\n+     *            whether to include transient fields\n+     * @return the String result\n+     * @throws IllegalArgumentException\n+     *             if the Object is <code>null</code>\n+     * @since 2.1\n+     */\n+    public static String toString(Object object, ToStringStyle style, boolean outputTransients, boolean outputStatics) {\n+        return toString(object, style, outputTransients, outputStatics, null);\n+    }\n+\n+    /**\n+     * <p>\n+     * Builds a <code>toString</code> value through reflection.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n+     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n+     * also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n+     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n+     * </p>\n+     * \n+     * <p>\n+     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n+     * ignored.\n+     * </p>\n+     * \n+     * <p>\n+     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\n+     * <code>java.lang.Object</code>.\n+     * </p>\n+     * \n+     * <p>\n+     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to be output\n+     * @param style\n+     *            the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @param outputTransients\n+     *            whether to include transient fields\n+     * @param outputStatics\n+     *            whether to include static fields\n+     * @param reflectUpToClass\n+     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n+     * @return the String result\n+     * @throws IllegalArgumentException\n+     *             if the Object is <code>null</code>\n+     * @since 2.1\n+     */\n+    public static <T> String toString(\n+            T object, ToStringStyle style, boolean outputTransients,\n+            boolean outputStatics, Class<? super T> reflectUpToClass) {\n+        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n+                .toString();\n+    }\n+\n+    /**\n+     * Builds a String for a toString method excluding the given field name.\n+     * \n+     * @param object\n+     *            The object to \"toString\".\n+     * @param excludeFieldName\n+     *            The field name to exclude\n+     * @return The toString value.\n+     */\n+    public static String toStringExclude(Object object, final String excludeFieldName) {\n+        return toStringExclude(object, new String[]{excludeFieldName});\n+    }\n+\n+    /**\n+     * Builds a String for a toString method excluding the given field names.\n+     * \n+     * @param object\n+     *            The object to \"toString\".\n+     * @param excludeFieldNames\n+     *            The field names to exclude. Null excludes nothing.\n+     * @return The toString value.\n+     */\n+    public static String toStringExclude(Object object, Collection<String> excludeFieldNames) {\n+        return toStringExclude(object, toNoNullStringArray(excludeFieldNames));\n+    }\n+\n+    /**\n+     * Converts the given Collection into an array of Strings. The returned array does not contain <code>null</code>\n+     * entries. Note that {@link Arrays#sort(Object[])} will throw an {@link NullPointerException} if an array element \n+     * is <code>null</code>.\n+     * \n+     * @param collection\n+     *            The collection to convert\n+     * @return A new array of Strings.\n+     */\n+    static String[] toNoNullStringArray(Collection<String> collection) {\n+        if (collection == null) {\n+            return ArrayUtils.EMPTY_STRING_ARRAY;\n+        }\n+        return toNoNullStringArray(collection.toArray());\n+    }\n+\n+    /**\n+     * Returns a new array of Strings without null elements. Internal method used to normalize exclude lists\n+     * (arrays and collections). Note that {@link Arrays#sort(Object[])} will throw an {@link NullPointerException} \n+     * if an array element is <code>null</code>.\n+     * \n+     * @param array\n+     *            The array to check\n+     * @return The given array or a new array without null.\n+     */\n+    static String[] toNoNullStringArray(Object[] array) {\n+        List<String> list = new ArrayList<String>(array.length);\n+        for (Object e : array) {\n+            if (e != null) {\n+                list.add(e.toString());\n+            }\n+        }\n+        return list.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n+    }\n+    \n+\n+    /**\n+     * Builds a String for a toString method excluding the given field names.\n+     * \n+     * @param object\n+     *            The object to \"toString\".\n+     * @param excludeFieldNames\n+     *            The field names to exclude\n+     * @return The toString value.\n+     */\n+    public static String toStringExclude(Object object, String[] excludeFieldNames) {\n+        return new ReflectionToStringBuilder(object).setExcludeFieldNames(excludeFieldNames).toString();\n+    }\n+\n+    /**\n+     * Whether or not to append static fields.\n+     */\n+    private boolean appendStatics = false;\n+\n+    /**\n+     * Whether or not to append transient fields.\n+     */\n+    private boolean appendTransients = false;\n+\n+    /**\n+     * Which field names to exclude from output. Intended for fields like <code>\"password\"</code>.\n+     */\n+    protected String[] excludeFieldNames;\n+\n+    /**\n+     * The last super class to stop appending fields for.\n+     */\n+    private Class<?> upToClass = null;\n+\n+    /**\n+     * <p>\n+     * Constructor.\n+     * </p>\n+     * \n+     * <p>\n+     * This constructor outputs using the default style set with <code>setDefaultStyle</code>.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to build a <code>toString</code> for, must not be <code>null</code>\n+     * @throws IllegalArgumentException\n+     *             if the Object passed in is <code>null</code>\n+     */\n+    public ReflectionToStringBuilder(Object object) {\n+        super(object);\n+    }\n+\n+    /**\n+     * <p>\n+     * Constructor.\n+     * </p>\n+     * \n+     * <p>\n+     * If the style is <code>null</code>, the default style is used.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to build a <code>toString</code> for, must not be <code>null</code>\n+     * @param style\n+     *            the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @throws IllegalArgumentException\n+     *             if the Object passed in is <code>null</code>\n+     */\n+    public ReflectionToStringBuilder(Object object, ToStringStyle style) {\n+        super(object, style);\n+    }\n+\n+    /**\n+     * <p>\n+     * Constructor.\n+     * </p>\n+     * \n+     * <p>\n+     * If the style is <code>null</code>, the default style is used.\n+     * </p>\n+     * \n+     * <p>\n+     * If the buffer is <code>null</code>, a new one is created.\n+     * </p>\n+     * \n+     * @param object\n+     *            the Object to build a <code>toString</code> for\n+     * @param style\n+     *            the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @param buffer\n+     *            the <code>StringBuffer</code> to populate, may be <code>null</code>\n+     * @throws IllegalArgumentException\n+     *             if the Object passed in is <code>null</code>\n+     */\n+    public ReflectionToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\n+        super(object, style, buffer);\n+    }\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param object\n+     *            the Object to build a <code>toString</code> for\n+     * @param style\n+     *            the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @param buffer\n+     *            the <code>StringBuffer</code> to populate, may be <code>null</code>\n+     * @param reflectUpToClass\n+     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n+     * @param outputTransients\n+     *            whether to include transient fields\n+     * @param outputStatics\n+     *            whether to include static fields\n+     * @since 2.1\n+     */\n+    public <T> ReflectionToStringBuilder(\n+            T object, ToStringStyle style, StringBuffer buffer,\n+            Class<? super T> reflectUpToClass, boolean outputTransients, boolean outputStatics) {\n+        super(object, style, buffer);\n+        this.setUpToClass(reflectUpToClass);\n+        this.setAppendTransients(outputTransients);\n+        this.setAppendStatics(outputStatics);\n+    }\n+\n+    /**\n+     * Returns whether or not to append the given <code>Field</code>.\n+     * <ul>\n+     * <li>Transient fields are appended only if {@link #isAppendTransients()} returns <code>true</code>.\n+     * <li>Static fields are appended only if {@link #isAppendStatics()} returns <code>true</code>.\n+     * <li>Inner class fields are not appened.</li>\n+     * </ul>\n+     * \n+     * @param field\n+     *            The Field to test.\n+     * @return Whether or not to append the given <code>Field</code>.\n+     */\n+    protected boolean accept(Field field) {\n+        if (field.getName().indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) != -1) {\n+            // Reject field from inner class.\n+            return false;\n+        }\n+        if (Modifier.isTransient(field.getModifiers()) && !this.isAppendTransients()) {\n+            // Reject transient fields.\n+            return false;\n+        }\n+        if (Modifier.isStatic(field.getModifiers()) && !this.isAppendStatics()) {\n+            // Reject static fields.\n+            return false;\n+        }\n+        if (this.excludeFieldNames != null\n+            && Arrays.binarySearch(this.excludeFieldNames, field.getName()) >= 0) {\n+            // Reject fields from the getExcludeFieldNames list.\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>\n+     * Appends the fields and values defined by the given object of the given Class.\n+     * </p>\n+     * \n+     * <p>\n+     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\n+     * <code>Object.toString()</code> had been called and not implemented by the object.\n+     * </p>\n+     * \n+     * @param clazz\n+     *            The class of object parameter\n+     */\n+    protected void appendFieldsIn(Class<?> clazz) {\n+        if (clazz.isArray()) {\n+            this.reflectionAppendArray(this.getObject());\n+            return;\n+        }\n+        Field[] fields = clazz.getDeclaredFields();\n+        AccessibleObject.setAccessible(fields, true);\n+        for (Field field : fields) {\n+            String fieldName = field.getName();\n+            if (this.accept(field)) {\n+                try {\n+                    // Warning: Field.get(Object) creates wrappers objects\n+                    // for primitive types.\n+                    Object fieldValue = this.getValue(field);\n+                    this.append(fieldName, fieldValue);\n+                } catch (IllegalAccessException ex) {\n+                    //this can't happen. Would get a Security exception\n+                    // instead\n+                    //throw a runtime exception in case the impossible\n+                    // happens.\n+                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * @return Returns the excludeFieldNames.\n+     */\n+    public String[] getExcludeFieldNames() {\n+        return this.excludeFieldNames.clone();\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets the last super class to stop appending fields for.\n+     * </p>\n+     * \n+     * @return The last super class to stop appending fields for.\n+     */\n+    public Class<?> getUpToClass() {\n+        return this.upToClass;\n+    }\n+\n+    /**\n+     * <p>\n+     * Calls <code>java.lang.reflect.Field.get(Object)</code>.\n+     * </p>\n+     * \n+     * @param field\n+     *            The Field to query.\n+     * @return The Object from the given Field.\n+     * \n+     * @throws IllegalArgumentException\n+     *             see {@link java.lang.reflect.Field#get(Object)}\n+     * @throws IllegalAccessException\n+     *             see {@link java.lang.reflect.Field#get(Object)}\n+     * \n+     * @see java.lang.reflect.Field#get(Object)\n+     */\n+    protected Object getValue(Field field) throws IllegalArgumentException, IllegalAccessException {\n+        return field.get(this.getObject());\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets whether or not to append static fields.\n+     * </p>\n+     * \n+     * @return Whether or not to append static fields.\n+     * @since 2.1\n+     */\n+    public boolean isAppendStatics() {\n+        return this.appendStatics;\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets whether or not to append transient fields.\n+     * </p>\n+     * \n+     * @return Whether or not to append transient fields.\n+     */\n+    public boolean isAppendTransients() {\n+        return this.appendTransients;\n+    }\n+\n+    /**\n+     * <p>\n+     * Append to the <code>toString</code> an <code>Object</code> array.\n+     * </p>\n+     * \n+     * @param array\n+     *            the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ReflectionToStringBuilder reflectionAppendArray(Object array) {\n+        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Sets whether or not to append static fields.\n+     * </p>\n+     * \n+     * @param appendStatics\n+     *            Whether or not to append static fields.\n+     * @since 2.1\n+     */\n+    public void setAppendStatics(boolean appendStatics) {\n+        this.appendStatics = appendStatics;\n+    }\n+\n+    /**\n+     * <p>\n+     * Sets whether or not to append transient fields.\n+     * </p>\n+     * \n+     * @param appendTransients\n+     *            Whether or not to append transient fields.\n+     */\n+    public void setAppendTransients(boolean appendTransients) {\n+        this.appendTransients = appendTransients;\n+    }\n+\n+    /**\n+     * Sets the field names to exclude.\n+     * \n+     * @param excludeFieldNamesParam\n+     *            The excludeFieldNames to excluding from toString or <code>null</code>.\n+     * @return <code>this</code>\n+     */\n+    public ReflectionToStringBuilder setExcludeFieldNames(String[] excludeFieldNamesParam) {\n+        if (excludeFieldNamesParam == null) {\n+            this.excludeFieldNames = null;\n+        } else {\n+            this.excludeFieldNames = toNoNullStringArray(excludeFieldNamesParam);\n+            Arrays.sort(this.excludeFieldNames);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>\n+     * Sets the last super class to stop appending fields for.\n+     * </p>\n+     * \n+     * @param clazz\n+     *            The last super class to stop appending fields for.\n+     */\n+    public void setUpToClass(Class<?> clazz) {\n+        if (clazz != null) {\n+            Object object = getObject();\n+            if (object != null && clazz.isInstance(object) == false) {\n+                throw new IllegalArgumentException(\"Specified class is not a superclass of the object\");\n+            }\n+        }\n+        this.upToClass = clazz;\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets the String built by this builder.\n+     * </p>\n+     * \n+     * @return the built string\n+     */\n+    @Override\n+    public String toString() {\n+        if (this.getObject() == null) {\n+            return this.getStyle().getNullText();\n+        }\n+        Class<?> clazz = this.getObject().getClass();\n+        this.appendFieldsIn(clazz);\n+        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n+            clazz = clazz.getSuperclass();\n+            this.appendFieldsIn(clazz);\n+        }\n+        return super.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/builder/StandardToStringStyle.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.builder;\n+\n+/**\n+ * <p>Works with {@link ToStringBuilder} to create a <code>toString</code>.</p>\n+ *\n+ * <p>This class is intended to be used as a singleton.\n+ * There is no need to instantiate a new style each time.\n+ * Simply instantiate the class once, customize the values as required, and\n+ * store the result in a public static final variable for the rest of the\n+ * program to access.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author Pete Gieser\n+ * @author Gary Gregory\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class StandardToStringStyle extends ToStringStyle {\n+    \n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * <p>Constructor.</p>\n+     */\n+    public StandardToStringStyle() {\n+        super();\n+    }\n+    \n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets whether to use the class name.</p>\n+     *\n+     * @return the current useClassName flag\n+     */\n+    @Override\n+    public boolean isUseClassName() {\n+        return super.isUseClassName();\n+    }\n+\n+    /**\n+     * <p>Sets whether to use the class name.</p>\n+     *\n+     * @param useClassName  the new useClassName flag\n+     */\n+    @Override\n+    public void setUseClassName(boolean useClassName) {\n+        super.setUseClassName(useClassName);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets whether to output short or long class names.</p>\n+     *\n+     * @return the current useShortClassName flag\n+     * @since 2.0\n+     */\n+    @Override\n+    public boolean isUseShortClassName() {\n+        return super.isUseShortClassName();\n+    }\n+\n+    /**\n+     * <p>Sets whether to output short or long class names.</p>\n+     *\n+     * @param useShortClassName  the new useShortClassName flag\n+     * @since 2.0\n+     */\n+    @Override\n+    public void setUseShortClassName(boolean useShortClassName) {\n+        super.setUseShortClassName(useShortClassName);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets whether to use the identity hash code.</p>\n+     * @return the current useIdentityHashCode flag\n+     */\n+    @Override\n+    public boolean isUseIdentityHashCode() {\n+        return super.isUseIdentityHashCode();\n+    }\n+\n+    /**\n+     * <p>Sets whether to use the identity hash code.</p>\n+     *\n+     * @param useIdentityHashCode  the new useIdentityHashCode flag\n+     */\n+    @Override\n+    public void setUseIdentityHashCode(boolean useIdentityHashCode) {\n+        super.setUseIdentityHashCode(useIdentityHashCode);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets whether to use the field names passed in.</p>\n+     *\n+     * @return the current useFieldNames flag\n+     */\n+    @Override\n+    public boolean isUseFieldNames() {\n+        return super.isUseFieldNames();\n+    }\n+\n+    /**\n+     * <p>Sets whether to use the field names passed in.</p>\n+     *\n+     * @param useFieldNames  the new useFieldNames flag\n+     */\n+    @Override\n+    public void setUseFieldNames(boolean useFieldNames) {\n+        super.setUseFieldNames(useFieldNames);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets whether to use full detail when the caller doesn't\n+     * specify.</p>\n+     *\n+     * @return the current defaultFullDetail flag\n+     */\n+    @Override\n+    public boolean isDefaultFullDetail() {\n+        return super.isDefaultFullDetail();\n+    }\n+\n+    /**\n+     * <p>Sets whether to use full detail when the caller doesn't\n+     * specify.</p>\n+     *\n+     * @param defaultFullDetail  the new defaultFullDetail flag\n+     */\n+    @Override\n+    public void setDefaultFullDetail(boolean defaultFullDetail) {\n+        super.setDefaultFullDetail(defaultFullDetail);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets whether to output array content detail.</p>\n+     *\n+     * @return the current array content detail setting\n+     */\n+    @Override\n+    public boolean isArrayContentDetail() {\n+        return super.isArrayContentDetail();\n+    }\n+    \n+    /**\n+     * <p>Sets whether to output array content detail.</p>\n+     *\n+     * @param arrayContentDetail  the new arrayContentDetail flag\n+     */\n+    @Override\n+    public void setArrayContentDetail(boolean arrayContentDetail) {\n+        super.setArrayContentDetail(arrayContentDetail);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the array start text.</p>\n+     *\n+     * @return the current array start text\n+     */\n+    @Override\n+    public String getArrayStart() {\n+        return super.getArrayStart();\n+    }\n+\n+    /**\n+     * <p>Sets the array start text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted\n+     * to an empty String.</p>\n+     *\n+     * @param arrayStart  the new array start text\n+     */\n+    @Override\n+    public void setArrayStart(String arrayStart) {\n+        super.setArrayStart(arrayStart);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the array end text.</p>\n+     *\n+     * @return the current array end text\n+     */\n+    @Override\n+    public String getArrayEnd() {\n+        return super.getArrayEnd();\n+    }\n+\n+    /**\n+     * <p>Sets the array end text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted\n+     * to an empty String.</p>\n+     *\n+     * @param arrayEnd  the new array end text\n+     */\n+    @Override\n+    public void setArrayEnd(String arrayEnd) {\n+        super.setArrayEnd(arrayEnd);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the array separator text.</p>\n+     *\n+     * @return the current array separator text\n+     */\n+    @Override\n+    public String getArraySeparator() {\n+        return super.getArraySeparator();\n+    }\n+\n+    /**\n+     * <p>Sets the array separator text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted\n+     * to an empty String.</p>\n+     *\n+     * @param arraySeparator  the new array separator text\n+     */\n+    @Override\n+    public void setArraySeparator(String arraySeparator) {\n+        super.setArraySeparator(arraySeparator);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the content start text.</p>\n+     *\n+     * @return the current content start text\n+     */\n+    @Override\n+    public String getContentStart() {\n+        return super.getContentStart();\n+    }\n+\n+    /**\n+     * <p>Sets the content start text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted\n+     * to an empty String.</p>\n+     *\n+     * @param contentStart  the new content start text\n+     */\n+    @Override\n+    public void setContentStart(String contentStart) {\n+        super.setContentStart(contentStart);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the content end text.</p>\n+     *\n+     * @return the current content end text\n+     */\n+    @Override\n+    public String getContentEnd() {\n+        return super.getContentEnd();\n+    }\n+\n+    /**\n+     * <p>Sets the content end text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted\n+     * to an empty String.</p>\n+     *\n+     * @param contentEnd  the new content end text\n+     */\n+    @Override\n+    public void setContentEnd(String contentEnd) {\n+        super.setContentEnd(contentEnd);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the field name value separator text.</p>\n+     *\n+     * @return the current field name value separator text\n+     */\n+    @Override\n+    public String getFieldNameValueSeparator() {\n+        return super.getFieldNameValueSeparator();\n+    }\n+\n+    /**\n+     * <p>Sets the field name value separator text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted\n+     * to an empty String.</p>\n+     *\n+     * @param fieldNameValueSeparator  the new field name value separator text\n+     */\n+    @Override\n+    public void setFieldNameValueSeparator(String fieldNameValueSeparator) {\n+        super.setFieldNameValueSeparator(fieldNameValueSeparator);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the field separator text.</p>\n+     *\n+     * @return the current field separator text\n+     */\n+    @Override\n+    public String getFieldSeparator() {\n+        return super.getFieldSeparator();\n+    }\n+\n+    /**\n+     * <p>Sets the field separator text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted\n+     * to an empty String.</p>\n+     *\n+     * @param fieldSeparator  the new field separator text\n+     */\n+    @Override\n+    public void setFieldSeparator(String fieldSeparator) {\n+        super.setFieldSeparator(fieldSeparator);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets whether the field separator should be added at the start \n+     * of each buffer.</p>\n+     * \n+     * @return the fieldSeparatorAtStart flag\n+     * @since 2.0\n+     */\n+    @Override\n+    public boolean isFieldSeparatorAtStart() {\n+        return super.isFieldSeparatorAtStart();\n+    }\n+\n+    /**\n+     * <p>Sets whether the field separator should be added at the start \n+     * of each buffer.</p>\n+     * \n+     * @param fieldSeparatorAtStart  the fieldSeparatorAtStart flag\n+     * @since 2.0\n+     */\n+    @Override\n+    public void setFieldSeparatorAtStart(boolean fieldSeparatorAtStart) {\n+        super.setFieldSeparatorAtStart(fieldSeparatorAtStart);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets whether the field separator should be added at the end \n+     * of each buffer.</p>\n+     * \n+     * @return fieldSeparatorAtEnd flag\n+     * @since 2.0\n+     */\n+    @Override\n+    public boolean isFieldSeparatorAtEnd() {\n+        return super.isFieldSeparatorAtEnd();\n+    }\n+\n+    /**\n+     * <p>Sets whether the field separator should be added at the end \n+     * of each buffer.</p>\n+     * \n+     * @param fieldSeparatorAtEnd  the fieldSeparatorAtEnd flag\n+     * @since 2.0\n+     */\n+    @Override\n+    public void setFieldSeparatorAtEnd(boolean fieldSeparatorAtEnd) {\n+        super.setFieldSeparatorAtEnd(fieldSeparatorAtEnd);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the text to output when <code>null</code> found.</p>\n+     *\n+     * @return the current text to output when <code>null</code> found\n+     */\n+    @Override\n+    public String getNullText() {\n+        return super.getNullText();\n+    }\n+\n+    /**\n+     * <p>Sets the text to output when <code>null</code> found.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted\n+     * to an empty String.</p>\n+     *\n+     * @param nullText  the new text to output when <code>null</code> found\n+     */\n+    @Override\n+    public void setNullText(String nullText) {\n+        super.setNullText(nullText);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the text to output when a <code>Collection</code>,\n+     * <code>Map</code> or <code>Array</code> size is output.</p>\n+     *\n+     * <p>This is output before the size value.</p>\n+     *\n+     * @return the current start of size text\n+     */\n+    @Override\n+    public String getSizeStartText() {\n+        return super.getSizeStartText();\n+    }\n+\n+    /**\n+     * <p>Sets the start text to output when a <code>Collection</code>,\n+     * <code>Map</code> or <code>Array</code> size is output.</p>\n+     *\n+     * <p>This is output before the size value.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param sizeStartText  the new start of size text\n+     */\n+    @Override\n+    public void setSizeStartText(String sizeStartText) {\n+        super.setSizeStartText(sizeStartText);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * Gets the end text to output when a <code>Collection</code>,\n+     * <code>Map</code> or <code>Array</code> size is output.</p>\n+     *\n+     * <p>This is output after the size value.</p>\n+     *\n+     * @return the current end of size text\n+     */\n+    @Override\n+    public String getSizeEndText() {\n+        return super.getSizeEndText();\n+    }\n+\n+    /**\n+     * <p>Sets the end text to output when a <code>Collection</code>,\n+     * <code>Map</code> or <code>Array</code> size is output.</p>\n+     *\n+     * <p>This is output after the size value.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted\n+     * to an empty String.</p>\n+     *\n+     * @param sizeEndText  the new end of size text\n+     */\n+    @Override\n+    public void setSizeEndText(String sizeEndText) {\n+        super.setSizeEndText(sizeEndText);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the start text to output when an <code>Object</code> is\n+     * output in summary mode.</p>\n+     *\n+     * <P>This is output before the size value.</p>\n+     *\n+     * @return the current start of summary text\n+     */\n+    @Override\n+    public String getSummaryObjectStartText() {\n+        return super.getSummaryObjectStartText();\n+    }\n+\n+    /**\n+     * <p>Sets the start text to output when an <code>Object</code> is\n+     * output in summary mode.</p>\n+     *\n+     * <p>This is output before the size value.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param summaryObjectStartText  the new start of summary text\n+     */\n+    @Override\n+    public void setSummaryObjectStartText(String summaryObjectStartText) {\n+        super.setSummaryObjectStartText(summaryObjectStartText);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the end text to output when an <code>Object</code> is\n+     * output in summary mode.</p>\n+     *\n+     * <p>This is output after the size value.</p>\n+     *\n+     * @return the current end of summary text\n+     */\n+    @Override\n+    public String getSummaryObjectEndText() {\n+        return super.getSummaryObjectEndText();\n+    }\n+\n+    /**\n+     * <p>Sets the end text to output when an <code>Object</code> is\n+     * output in summary mode.</p>\n+     *\n+     * <p>This is output after the size value.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param summaryObjectEndText  the new end of summary text\n+     */\n+    @Override\n+    public void setSummaryObjectEndText(String summaryObjectEndText) {\n+        super.setSummaryObjectEndText(summaryObjectEndText);\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.builder;\n+\n+import org.apache.commons.lang3.ObjectUtils;\n+\n+/**\n+ * <p>Assists in implementing {@link Object#toString()} methods.</p>\n+ *\n+ * <p>This class enables a good and consistent <code>toString()</code> to be built for any\n+ * class or object. This class aims to simplify the process by:</p>\n+ * <ul>\n+ *  <li>allowing field names</li>\n+ *  <li>handling all types consistently</li>\n+ *  <li>handling nulls consistently</li>\n+ *  <li>outputting arrays and multi-dimensional arrays</li>\n+ *  <li>enabling the detail level to be controlled for Objects and Collections</li>\n+ *  <li>handling class hierarchies</li>\n+ * </ul>\n+ *\n+ * <p>To use this class write code as follows:</p>\n+ *\n+ * <pre>\n+ * public class Person {\n+ *   String name;\n+ *   int age;\n+ *   boolean smoker;\n+ * \n+ *   ...\n+ * \n+ *   public String toString() {\n+ *     return new ToStringBuilder(this).\n+ *       append(\"name\", name).\n+ *       append(\"age\", age).\n+ *       append(\"smoker\", smoker).\n+ *       toString();\n+ *   }\n+ * }\n+ * </pre>\n+ *\n+ * <p>This will produce a toString of the format:\n+ * <code>Person@7f54[name=Stephen,age=29,smoker=false]</code></p>\n+ * \n+ * <p>To add the superclass <code>toString</code>, use {@link #appendSuper}.\n+ * To append the <code>toString</code> from an object that is delegated\n+ * to (or any other object), use {@link #appendToString}.</p>\n+ *\n+ * <p>Alternatively, there is a method that uses reflection to determine\n+ * the fields to test. Because these fields are usually private, the method, \n+ * <code>reflectionToString</code>, uses <code>AccessibleObject.setAccessible</code> to\n+ * change the visibility of the fields. This will fail under a security manager,\n+ * unless the appropriate permissions are set up correctly. It is also\n+ * slower than testing explicitly.</p>\n+ *\n+ * <p>A typical invocation for this method would look like:</p>\n+ *\n+ * <pre>\n+ * public String toString() {\n+ *   return ToStringBuilder.reflectionToString(this);\n+ * }\n+ * </pre>\n+ *\n+ * <p>You can also use the builder to debug 3rd party objects:</p>\n+ *\n+ * <pre>\n+ * System.out.println(\"An object: \" + ToStringBuilder.reflectionToString(anObject));\n+ * </pre>\n+ * \n+ * <p>The exact format of the <code>toString</code> is determined by\n+ * the {@link ToStringStyle} passed into the constructor.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author Gary Gregory\n+ * @author Pete Gieser\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class ToStringBuilder {\n+\n+    /**\n+     * The default style of output to use, not null.\n+     */\n+    private static volatile ToStringStyle defaultStyle = ToStringStyle.DEFAULT_STYLE;\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the default <code>ToStringStyle</code> to use.</p>\n+     * \n+     * <p>This method gets a singleton default value, typically for the whole JVM.\n+     * Changing this default should generally only be done during application startup.\n+     * It is recommended to pass a <code>ToStringStyle</code> to the constructor instead\n+     * of using this global default.</p>\n+     * \n+     * <p>This method can be used from multiple threads.\n+     * Internally, a <code>volatile</code> variable is used to provide the guarantee\n+     * that the latest value set using {@link #setDefaultStyle} is the value returned.\n+     * It is strongly recommended that the default style is only changed during application startup.</p>\n+     * \n+     * <p>One reason for changing the default could be to have a verbose style during\n+     * development and a compact style in production.</p>\n+     * \n+     * @return the default <code>ToStringStyle</code>, never null\n+     */\n+    public static ToStringStyle getDefaultStyle() {\n+        return defaultStyle;\n+    }\n+\n+    /**\n+     * <p>Sets the default <code>ToStringStyle</code> to use.</p>\n+     * \n+     * <p>This method sets a singleton default value, typically for the whole JVM.\n+     * Changing this default should generally only be done during application startup.\n+     * It is recommended to pass a <code>ToStringStyle</code> to the constructor instead\n+     * of changing this global default.</p>\n+     * \n+     * <p>This method is not intended for use from multiple threads.\n+     * Internally, a <code>volatile</code> variable is used to provide the guarantee\n+     * that the latest value set is the value returned from {@link #getDefaultStyle}.</p>\n+     * \n+     * @param style  the default <code>ToStringStyle</code>\n+     * @throws IllegalArgumentException if the style is <code>null</code>\n+     */\n+    public static void setDefaultStyle(ToStringStyle style) {\n+        if (style == null) {\n+            throw new IllegalArgumentException(\"The style must not be null\");\n+        }\n+        defaultStyle = style;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    /**\n+     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a\n+     * <code>toString</code> for the specified object.</p>\n+     * \n+     * @param object  the Object to be output\n+     * @return the String result\n+     * @see ReflectionToStringBuilder#toString(Object)\n+     */\n+    public static String reflectionToString(Object object) {\n+        return ReflectionToStringBuilder.toString(object);\n+    }\n+\n+    /**\n+     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a\n+     * <code>toString</code> for the specified object.</p>\n+     * \n+     * @param object  the Object to be output\n+     * @param style  the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @return the String result\n+     * @see ReflectionToStringBuilder#toString(Object,ToStringStyle)\n+     */\n+    public static String reflectionToString(Object object, ToStringStyle style) {\n+        return ReflectionToStringBuilder.toString(object, style);\n+    }\n+\n+    /**\n+     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a\n+     * <code>toString</code> for the specified object.</p>\n+     * \n+     * @param object  the Object to be output\n+     * @param style  the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @param outputTransients  whether to include transient fields\n+     * @return the String result\n+     * @see ReflectionToStringBuilder#toString(Object,ToStringStyle,boolean)\n+     */\n+    public static String reflectionToString(Object object, ToStringStyle style, boolean outputTransients) {\n+        return ReflectionToStringBuilder.toString(object, style, outputTransients, false, null);\n+    }\n+\n+    /**\n+     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a\n+     * <code>toString</code> for the specified object.</p>\n+     * \n+     * @param object  the Object to be output\n+     * @param style  the style of the <code>toString</code> to create, may be <code>null</code>\n+     * @param outputTransients  whether to include transient fields\n+     * @param reflectUpToClass  the superclass to reflect up to (inclusive), may be <code>null</code>\n+     * @return the String result\n+     * @see ReflectionToStringBuilder#toString(Object,ToStringStyle,boolean,boolean,Class)\n+     * @since 2.0\n+     */\n+    public static <T> String reflectionToString(\n+        T object,\n+        ToStringStyle style,\n+        boolean outputTransients,\n+        Class<? super T> reflectUpToClass) {\n+        return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * Current toString buffer, not null.\n+     */\n+    private final StringBuffer buffer;\n+    /**\n+     * The object being output, may be null.\n+     */\n+    private final Object object;\n+    /**\n+     * The style of output to use, not null.\n+     */\n+    private final ToStringStyle style;\n+\n+    /**\n+     * <p>Constructs a builder for the specified object using the default output style.</p>\n+     *\n+     * <p>This default style is obtained from {@link #getDefaultStyle()}.</p>\n+     * \n+     * @param object  the Object to build a <code>toString</code> for, not recommended to be null\n+     */\n+    public ToStringBuilder(Object object) {\n+        this(object, null, null);\n+    }\n+\n+    /**\n+     * <p>Constructs a builder for the specified object using the a defined output style.</p>\n+     *\n+     * <p>If the style is <code>null</code>, the default style is used.</p>\n+     * \n+     * @param object  the Object to build a <code>toString</code> for, not recommended to be null\n+     * @param style  the style of the <code>toString</code> to create, null uses the default style\n+     */\n+    public ToStringBuilder(Object object, ToStringStyle style) {\n+        this(object, style, null);\n+    }\n+\n+    /**\n+     * <p>Constructs a builder for the specified object.</p>\n+     *\n+     * <p>If the style is <code>null</code>, the default style is used.</p>\n+     *\n+     * <p>If the buffer is <code>null</code>, a new one is created.</p>\n+     * \n+     * @param object  the Object to build a <code>toString</code> for, not recommended to be null\n+     * @param style  the style of the <code>toString</code> to create, null uses the default style\n+     * @param buffer  the <code>StringBuffer</code> to populate, may be null\n+     */\n+    public ToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\n+        if (style == null) {\n+            style = getDefaultStyle();\n+        }\n+        if (buffer == null) {\n+            buffer = new StringBuffer(512);\n+        }\n+        this.buffer = buffer;\n+        this.style = style;\n+        this.object = object;\n+\n+        style.appendStart(buffer, object);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>boolean</code>\n+     * value.</p>\n+     *\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(boolean value) {\n+        style.append(buffer, null, value);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>boolean</code>\n+     * array.</p>\n+     *\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(boolean[] array) {\n+        style.append(buffer, null, array, null);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>byte</code>\n+     * value.</p>\n+     *\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(byte value) {\n+        style.append(buffer, null, value);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>byte</code>\n+     * array.</p>\n+     *\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(byte[] array) {\n+        style.append(buffer, null, array, null);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>char</code>\n+     * value.</p>\n+     *\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(char value) {\n+        style.append(buffer, null, value);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>char</code>\n+     * array.</p>\n+     *\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(char[] array) {\n+        style.append(buffer, null, array, null);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>double</code>\n+     * value.</p>\n+     *\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(double value) {\n+        style.append(buffer, null, value);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>double</code>\n+     * array.</p>\n+     *\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(double[] array) {\n+        style.append(buffer, null, array, null);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>float</code>\n+     * value.</p>\n+     *\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(float value) {\n+        style.append(buffer, null, value);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>float</code>\n+     * array.</p>\n+     *\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(float[] array) {\n+        style.append(buffer, null, array, null);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>int</code>\n+     * value.</p>\n+     *\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(int value) {\n+        style.append(buffer, null, value);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>int</code>\n+     * array.</p>\n+     *\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(int[] array) {\n+        style.append(buffer, null, array, null);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>long</code>\n+     * value.</p>\n+     *\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(long value) {\n+        style.append(buffer, null, value);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>long</code>\n+     * array.</p>\n+     *\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(long[] array) {\n+        style.append(buffer, null, array, null);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>\n+     * value.</p>\n+     *\n+     * @param obj  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(Object obj) {\n+        style.append(buffer, null, obj, null);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>\n+     * array.</p>\n+     *\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(Object[] array) {\n+        style.append(buffer, null, array, null);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>short</code>\n+     * value.</p>\n+     *\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(short value) {\n+        style.append(buffer, null, value);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>short</code>\n+     * array.</p>\n+     *\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(short[] array) {\n+        style.append(buffer, null, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>boolean</code>\n+     * value.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, boolean value) {\n+        style.append(buffer, fieldName, value);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>boolean</code>\n+     * array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>hashCode</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, boolean[] array) {\n+        style.append(buffer, fieldName, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>boolean</code>\n+     * array.</p>\n+     *\n+     * <p>A boolean parameter controls the level of detail to show.\n+     * Setting <code>true</code> will output the array in full. Setting\n+     * <code>false</code> will output a summary, typically the size of\n+     * the array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, boolean[] array, boolean fullDetail) {\n+        style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>byte</code>\n+     * value.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, byte value) {\n+        style.append(buffer, fieldName, value);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>byte</code> array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, byte[] array) {\n+        style.append(buffer, fieldName, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>byte</code>\n+     * array.</p>\n+     *\n+     * <p>A boolean parameter controls the level of detail to show.\n+     * Setting <code>true</code> will output the array in full. Setting\n+     * <code>false</code> will output a summary, typically the size of\n+     * the array.\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, byte[] array, boolean fullDetail) {\n+        style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>char</code>\n+     * value.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, char value) {\n+        style.append(buffer, fieldName, value);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>char</code>\n+     * array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, char[] array) {\n+        style.append(buffer, fieldName, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>char</code>\n+     * array.</p>\n+     *\n+     * <p>A boolean parameter controls the level of detail to show.\n+     * Setting <code>true</code> will output the array in full. Setting\n+     * <code>false</code> will output a summary, typically the size of\n+     * the array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, char[] array, boolean fullDetail) {\n+        style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>double</code>\n+     * value.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, double value) {\n+        style.append(buffer, fieldName, value);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>double</code>\n+     * array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, double[] array) {\n+        style.append(buffer, fieldName, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>double</code>\n+     * array.</p>\n+     *\n+     * <p>A boolean parameter controls the level of detail to show.\n+     * Setting <code>true</code> will output the array in full. Setting\n+     * <code>false</code> will output a summary, typically the size of\n+     * the array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, double[] array, boolean fullDetail) {\n+        style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>float</code>\n+     * value.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, float value) {\n+        style.append(buffer, fieldName, value);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>float</code>\n+     * array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, float[] array) {\n+        style.append(buffer, fieldName, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>float</code>\n+     * array.</p>\n+     *\n+     * <p>A boolean parameter controls the level of detail to show.\n+     * Setting <code>true</code> will output the array in full. Setting\n+     * <code>false</code> will output a summary, typically the size of\n+     * the array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, float[] array, boolean fullDetail) {\n+        style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>int</code>\n+     * value.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, int value) {\n+        style.append(buffer, fieldName, value);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>int</code>\n+     * array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, int[] array) {\n+        style.append(buffer, fieldName, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>int</code>\n+     * array.</p>\n+     *\n+     * <p>A boolean parameter controls the level of detail to show.\n+     * Setting <code>true</code> will output the array in full. Setting\n+     * <code>false</code> will output a summary, typically the size of\n+     * the array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, int[] array, boolean fullDetail) {\n+        style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>long</code>\n+     * value.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, long value) {\n+        style.append(buffer, fieldName, value);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>long</code>\n+     * array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, long[] array) {\n+        style.append(buffer, fieldName, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>long</code>\n+     * array.</p>\n+     *\n+     * <p>A boolean parameter controls the level of detail to show.\n+     * Setting <code>true</code> will output the array in full. Setting\n+     * <code>false</code> will output a summary, typically the size of\n+     * the array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, long[] array, boolean fullDetail) {\n+        style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>\n+     * value.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param obj  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, Object obj) {\n+        style.append(buffer, fieldName, obj, null);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>\n+     * value.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param obj  the value to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail,\n+     *  <code>false</code> for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, Object obj, boolean fullDetail) {\n+        style.append(buffer, fieldName, obj, Boolean.valueOf(fullDetail));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>\n+     * array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, Object[] array) {\n+        style.append(buffer, fieldName, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>\n+     * array.</p>\n+     *\n+     * <p>A boolean parameter controls the level of detail to show.\n+     * Setting <code>true</code> will output the array in full. Setting\n+     * <code>false</code> will output a summary, typically the size of\n+     * the array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, Object[] array, boolean fullDetail) {\n+        style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>short</code>\n+     * value.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, short value) {\n+        style.append(buffer, fieldName, value);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>short</code>\n+     * array.</p>\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, short[] array) {\n+        style.append(buffer, fieldName, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>short</code>\n+     * array.</p>\n+     *\n+     * <p>A boolean parameter controls the level of detail to show.\n+     * Setting <code>true</code> will output the array in full. Setting\n+     * <code>false</code> will output a summary, typically the size of\n+     * the array.\n+     *\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, short[] array, boolean fullDetail) {\n+        style.append(buffer, fieldName, array, Boolean.valueOf(fullDetail));\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Appends with the same format as the default <code>Object toString()\n+     * </code> method. Appends the class name followed by \n+     * {@link System#identityHashCode(java.lang.Object)}.</p>\n+     * \n+     * @param object  the <code>Object</code> whose class name and id to output\n+     * @return this\n+     * @since 2.0\n+     */\n+    public ToStringBuilder appendAsObjectToString(Object object) {\n+        ObjectUtils.identityToString(this.getStringBuffer(), object);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append the <code>toString</code> from the superclass.</p>\n+     * \n+     * <p>This method assumes that the superclass uses the same <code>ToStringStyle</code>\n+     * as this one.</p>\n+     * \n+     * <p>If <code>superToString</code> is <code>null</code>, no change is made.</p>\n+     *\n+     * @param superToString  the result of <code>super.toString()</code>\n+     * @return this\n+     * @since 2.0\n+     */\n+    public ToStringBuilder appendSuper(String superToString) {\n+        if (superToString != null) {\n+            style.appendSuper(buffer, superToString);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Append the <code>toString</code> from another object.</p>\n+     * \n+     * <p>This method is useful where a class delegates most of the implementation of\n+     * its properties to another class. You can then call <code>toString()</code> on\n+     * the other class and pass the result into this method.</p>\n+     * \n+     * <pre>\n+     *   private AnotherObject delegate;\n+     *   private String fieldInThisClass;\n+     * \n+     *   public String toString() {\n+     *     return new ToStringBuilder(this).\n+     *       appendToString(delegate.toString()).\n+     *       append(fieldInThisClass).\n+     *       toString();\n+     *   }</pre>\n+     * \n+     * <p>This method assumes that the other object uses the same <code>ToStringStyle</code>\n+     * as this one.</p>\n+     * \n+     * <p>If the <code>toString</code> is <code>null</code>, no change is made.</p>\n+     *\n+     * @param toString  the result of <code>toString()</code> on another object\n+     * @return this\n+     * @since 2.0\n+     */\n+    public ToStringBuilder appendToString(String toString) {\n+        if (toString != null) {\n+            style.appendToString(buffer, toString);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * <p>Returns the <code>Object</code> being output.</p>\n+     * \n+     * @return The object being output.\n+     * @since 2.0\n+     */\n+    public Object getObject() {\n+        return object;\n+    }\n+\n+    /**\n+     * <p>Gets the <code>StringBuffer</code> being populated.</p>\n+     * \n+     * @return the <code>StringBuffer</code> being populated\n+     */\n+    public StringBuffer getStringBuffer() {\n+        return buffer;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the <code>ToStringStyle</code> being used.</p>\n+     * \n+     * @return the <code>ToStringStyle</code> being used\n+     * @since 2.0\n+     */\n+    public ToStringStyle getStyle() {\n+        return style;\n+    }\n+\n+    /**\n+     * <p>Returns the built <code>toString</code>.</p>\n+     * \n+     * <p>This method appends the end of data indicator, and can only be called once.\n+     * Use {@link #getStringBuffer} to get the current string state.</p>\n+     * \n+     * <p>If the object is <code>null</code>, return the style's <code>nullText</code></p>\n+     * \n+     * @return the String <code>toString</code>\n+     */\n+    @Override\n+    public String toString() {\n+        if (this.getObject() == null) {\n+            this.getStringBuffer().append(this.getStyle().getNullText());\n+        } else {\n+            style.appendEnd(this.getStringBuffer(), this.getObject());\n+        }\n+        return this.getStringBuffer().toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.builder;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.lang3.ClassUtils;\n+import org.apache.commons.lang3.ObjectUtils;\n+import org.apache.commons.lang3.SystemUtils;\n+\n+/**\n+ * <p>Controls <code>String</code> formatting for {@link ToStringBuilder}.\n+ * The main public interface is always via <code>ToStringBuilder</code>.</p>\n+ *\n+ * <p>These classes are intended to be used as <code>Singletons</code>.\n+ * There is no need to instantiate a new style each time. A program\n+ * will generally use one of the predefined constants on this class.\n+ * Alternatively, the {@link StandardToStringStyle} class can be used\n+ * to set the individual settings. Thus most styles can be achieved\n+ * without subclassing.</p>\n+ *\n+ * <p>If required, a subclass can override as many or as few of the\n+ * methods as it requires. Each object type (from <code>boolean</code>\n+ * to <code>long</code> to <code>Object</code> to <code>int[]</code>) has\n+ * its own methods to output it. Most have two versions, detail and summary.\n+ *\n+ * <p>For example, the detail version of the array based methods will\n+ * output the whole array, whereas the summary method will just output\n+ * the array length.</p>\n+ * \n+ * <p>If you want to format the output of certain objects, such as dates, you\n+ * must create a subclass and override a method.\n+ * <pre>\n+ * public class MyStyle extends ToStringStyle {\n+ *   protected void appendDetail(StringBuffer buffer, String fieldName, Object value) {\n+ *     if (value instanceof Date) {\n+ *       value = new SimpleDateFormat(\"yyyy-MM-dd\").format(value);\n+ *     }\n+ *     buffer.append(value);\n+ *   }\n+ * }\n+ * </pre>\n+ * </p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author Gary Gregory\n+ * @author Pete Gieser\n+ * @author Masato Tezuka\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public abstract class ToStringStyle implements Serializable {\n+\n+    /**\n+     * The default toString style. Using the Using the <code>Person</code>\n+     * example from {@link ToStringBuilder}, the output would look like this:\n+     * \n+     * <pre>\n+     * Person@182f0db[name=John Doe,age=33,smoker=false]\n+     * </pre>\n+     */\n+    public static final ToStringStyle DEFAULT_STYLE = new DefaultToStringStyle();\n+    \n+    /**\n+     * The multi line toString style. Using the Using the <code>Person</code>\n+     * example from {@link ToStringBuilder}, the output would look like this:\n+     * \n+     * <pre>\n+     * Person@182f0db[\n+     *   name=John Doe\n+     *   age=33\n+     *   smoker=false\n+     * ]\n+     * </pre>\n+     */\n+    public static final ToStringStyle MULTI_LINE_STYLE = new MultiLineToStringStyle();\n+    \n+    /**\n+     * The no field names toString style. Using the Using the\n+     * <code>Person</code> example from {@link ToStringBuilder}, the output\n+     * would look like this:\n+     * \n+     * <pre>\n+     * Person@182f0db[John Doe,33,false]\n+     * </pre>\n+     */\n+    public static final ToStringStyle NO_FIELD_NAMES_STYLE = new NoFieldNameToStringStyle();\n+    \n+    /**\n+     * The short prefix toString style. Using the <code>Person</code> example\n+     * from {@link ToStringBuilder}, the output would look like this:\n+     * \n+     * <pre>\n+     * Person[name=John Doe,age=33,smoker=false]\n+     * </pre>\n+     * \n+     * @since 2.1\n+     */\n+    public static final ToStringStyle SHORT_PREFIX_STYLE = new ShortPrefixToStringStyle();\n+\n+    /**\n+     * The simple toString style. Using the Using the <code>Person</code>\n+     * example from {@link ToStringBuilder}, the output would look like this:\n+     * \n+     * <pre>\n+     * John Doe,33,false\n+     * </pre>\n+     */\n+    public static final ToStringStyle SIMPLE_STYLE = new SimpleToStringStyle();\n+    \n+    /**\n+     * <p>\n+     * A registry of objects used by <code>reflectionToString</code> methods\n+     * to detect cyclical object references and avoid infinite loops.\n+     * </p>\n+     */\n+    private static final ThreadLocal<Set<Object>> registry = new ThreadLocal<Set<Object>>() {\n+        @Override\n+        protected Set<Object> initialValue() {\n+            // The HashSet implementation is not synchronized,\n+            // which is just what we need here.\n+            return new HashSet<Object>();\n+        }\n+    };\n+\n+    /**\n+     * <p>\n+     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n+     * methods in the current thread.\n+     * </p>\n+     * \n+     * @return Set the registry of objects being traversed\n+     */\n+    static Set<Object> getRegistry() {\n+        return registry.get();\n+    }\n+\n+    /**\n+     * <p>\n+     * Returns <code>true</code> if the registry contains the given object.\n+     * Used by the reflection methods to avoid infinite loops.\n+     * </p>\n+     * \n+     * @param value\n+     *                  The object to lookup in the registry.\n+     * @return boolean <code>true</code> if the registry contains the given\n+     *             object.\n+     */\n+    static boolean isRegistered(Object value) {\n+        return getRegistry().contains(value);\n+    }\n+\n+    /**\n+     * <p>\n+     * Registers the given object. Used by the reflection methods to avoid\n+     * infinite loops.\n+     * </p>\n+     * \n+     * @param value\n+     *                  The object to register.\n+     */\n+    static void register(Object value) {\n+        if (value != null) {\n+            getRegistry().add(value);\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Unregisters the given object.\n+     * </p>\n+     * \n+     * <p>\n+     * Used by the reflection methods to avoid infinite loops.\n+     * </p>\n+     * \n+     * @param value\n+     *                  The object to unregister.\n+     */\n+    static void unregister(Object value) {\n+        getRegistry().remove(value);\n+    }\n+\n+    /**\n+     * Whether to use the field names, the default is <code>true</code>.\n+     */\n+    private boolean useFieldNames = true;\n+    \n+    /**\n+     * Whether to use the class name, the default is <code>true</code>.\n+     */\n+    private boolean useClassName = true;\n+    \n+    /**\n+     * Whether to use short class names, the default is <code>false</code>.\n+     */\n+    private boolean useShortClassName = false;\n+    \n+    /**\n+     * Whether to use the identity hash code, the default is <code>true</code>.\n+     */\n+    private boolean useIdentityHashCode = true;\n+\n+    /**\n+     * The content start <code>'['</code>.\n+     */\n+    private String contentStart = \"[\";\n+    \n+    /**\n+     * The content end <code>']'</code>.\n+     */\n+    private String contentEnd = \"]\";\n+    \n+    /**\n+     * The field name value separator <code>'='</code>.\n+     */\n+    private String fieldNameValueSeparator = \"=\";\n+    \n+    /**\n+     * Whether the field separator should be added before any other fields.\n+     */\n+    private boolean fieldSeparatorAtStart = false;\n+    \n+    /**\n+     * Whether the field separator should be added after any other fields.\n+     */\n+    private boolean fieldSeparatorAtEnd = false;\n+    \n+    /**\n+     * The field separator <code>','</code>.\n+     */\n+    private String fieldSeparator = \",\";\n+    \n+    /**\n+     * The array start <code>'{'</code>.\n+     */\n+    private String arrayStart = \"{\";\n+    \n+    /**\n+     * The array separator <code>','</code>.\n+     */\n+    private String arraySeparator = \",\";\n+    \n+    /**\n+     * The detail for array content.\n+     */\n+    private boolean arrayContentDetail = true;\n+    \n+    /**\n+     * The array end <code>'}'</code>.\n+     */\n+    private String arrayEnd = \"}\";\n+    \n+    /**\n+     * The value to use when fullDetail is <code>null</code>,\n+     * the default value is <code>true</code>.\n+     */\n+    private boolean defaultFullDetail = true;\n+    \n+    /**\n+     * The <code>null</code> text <code>'&lt;null&gt;'</code>.\n+     */\n+    private String nullText = \"<null>\";\n+    \n+    /**\n+     * The summary size text start <code>'<size'</code>.\n+     */\n+    private String sizeStartText = \"<size=\";\n+    \n+    /**\n+     * The summary size text start <code>'&gt;'</code>.\n+     */\n+    private String sizeEndText = \">\";\n+    \n+    /**\n+     * The summary object text start <code>'&lt;'</code>.\n+     */\n+    private String summaryObjectStartText = \"<\";\n+    \n+    /**\n+     * The summary object text start <code>'&gt;'</code>.\n+     */\n+    private String summaryObjectEndText = \">\";\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Constructor.</p>\n+     */\n+    protected ToStringStyle() {\n+        super();\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the superclass toString.</p>\n+     * <p>NOTE: It assumes that the toString has been created from the same ToStringStyle. </p>\n+     * \n+     * <p>A <code>null</code> <code>superToString</code> is ignored.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param superToString  the <code>super.toString()</code>\n+     * @since 2.0\n+     */\n+    public void appendSuper(StringBuffer buffer, String superToString) {\n+        appendToString(buffer, superToString);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> another toString.</p>\n+     * <p>NOTE: It assumes that the toString has been created from the same ToStringStyle. </p>\n+     * \n+     * <p>A <code>null</code> <code>toString</code> is ignored.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param toString  the additional <code>toString</code>\n+     * @since 2.0\n+     */\n+    public void appendToString(StringBuffer buffer, String toString) {\n+        if (toString != null) {\n+            int pos1 = toString.indexOf(contentStart) + contentStart.length();\n+            int pos2 = toString.lastIndexOf(contentEnd);\n+            if (pos1 != pos2 && pos1 >= 0 && pos2 >= 0) {\n+                String data = toString.substring(pos1, pos2);\n+                if (fieldSeparatorAtStart) {\n+                    removeLastFieldSeparator(buffer);\n+                }\n+                buffer.append(data);\n+                appendFieldSeparator(buffer);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the start of data indicator.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param object  the <code>Object</code> to build a <code>toString</code> for\n+     */\n+    public void appendStart(StringBuffer buffer, Object object) {\n+        if (object != null) {\n+            appendClassName(buffer, object);\n+            appendIdentityHashCode(buffer, object);\n+            appendContentStart(buffer);\n+            if (fieldSeparatorAtStart) {\n+                appendFieldSeparator(buffer);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the end of data indicator.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param object  the <code>Object</code> to build a\n+     *  <code>toString</code> for.\n+     */\n+    public void appendEnd(StringBuffer buffer, Object object) {\n+        if (this.fieldSeparatorAtEnd == false) {\n+            removeLastFieldSeparator(buffer);\n+        }\n+        appendContentEnd(buffer);\n+        unregister(object);\n+    }\n+\n+    /**\n+     * <p>Remove the last field separator from the buffer.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @since 2.0\n+     */\n+    protected void removeLastFieldSeparator(StringBuffer buffer) {\n+        int len = buffer.length();\n+        int sepLen = fieldSeparator.length();\n+        if (len > 0 && sepLen > 0 && len >= sepLen) {\n+            boolean match = true;\n+            for (int i = 0; i < sepLen; i++) {\n+                if (buffer.charAt(len - 1 - i) != fieldSeparator.charAt(sepLen - 1 - i)) {\n+                    match = false;\n+                    break;\n+                }\n+            }\n+            if (match) {\n+                buffer.setLength(len - sepLen);\n+            }\n+        }\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>\n+     * value, printing the full <code>toString</code> of the\n+     * <code>Object</code> passed in.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info, <code>null</code> for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, Object value, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+\n+        if (value == null) {\n+            appendNullText(buffer, fieldName);\n+\n+        } else {\n+            appendInternal(buffer, fieldName, value, isFullDetail(fullDetail));\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>,\n+     * correctly interpreting its type.</p>\n+     *\n+     * <p>This method performs the main lookup by Class type to correctly\n+     * route arrays, <code>Collections</code>, <code>Maps</code> and\n+     * <code>Objects</code> to the appropriate method.</p>\n+     *\n+     * <p>Either detail or summary views can be specified.</p>\n+     *\n+     * <p>If a cycle is detected, an object will be appended with the\n+     * <code>Object.toString()</code> format.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     * @param detail  output detail or not\n+     */\n+    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n+        if (isRegistered(value)\n+            && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n+           appendCyclicObject(buffer, fieldName, value);\n+           return;\n+        }   \n+\n+        register(value);\n+\n+        try {\n+            if (value instanceof Collection<?>) {\n+                if (detail) {\n+                    appendDetail(buffer, fieldName, (Collection<?>) value);\n+                } else {\n+                    appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n+                }\n+    \n+            } else if (value instanceof Map<?, ?>) {\n+                if (detail) {\n+                    appendDetail(buffer, fieldName, (Map<?, ?>) value);\n+                } else {\n+                    appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n+                }\n+    \n+            } else if (value instanceof long[]) {\n+                if (detail) {\n+                    appendDetail(buffer, fieldName, (long[]) value);\n+                } else {\n+                    appendSummary(buffer, fieldName, (long[]) value);\n+                }\n+    \n+            } else if (value instanceof int[]) {\n+                if (detail) {\n+                    appendDetail(buffer, fieldName, (int[]) value);\n+                } else {\n+                    appendSummary(buffer, fieldName, (int[]) value);\n+                }\n+    \n+            } else if (value instanceof short[]) {\n+                if (detail) {\n+                    appendDetail(buffer, fieldName, (short[]) value);\n+                } else {\n+                    appendSummary(buffer, fieldName, (short[]) value);\n+                }\n+    \n+            } else if (value instanceof byte[]) {\n+                if (detail) {\n+                    appendDetail(buffer, fieldName, (byte[]) value);\n+                } else {\n+                    appendSummary(buffer, fieldName, (byte[]) value);\n+                }\n+    \n+            } else if (value instanceof char[]) {\n+                if (detail) {\n+                    appendDetail(buffer, fieldName, (char[]) value);\n+                } else {\n+                    appendSummary(buffer, fieldName, (char[]) value);\n+                }\n+    \n+            } else if (value instanceof double[]) {\n+                if (detail) {\n+                    appendDetail(buffer, fieldName, (double[]) value);\n+                } else {\n+                    appendSummary(buffer, fieldName, (double[]) value);\n+                }\n+    \n+            } else if (value instanceof float[]) {\n+                if (detail) {\n+                    appendDetail(buffer, fieldName, (float[]) value);\n+                } else {\n+                    appendSummary(buffer, fieldName, (float[]) value);\n+                }\n+    \n+            } else if (value instanceof boolean[]) {\n+                if (detail) {\n+                    appendDetail(buffer, fieldName, (boolean[]) value);\n+                } else {\n+                    appendSummary(buffer, fieldName, (boolean[]) value);\n+                }\n+    \n+            } else if (value.getClass().isArray()) {\n+                if (detail) {\n+                    appendDetail(buffer, fieldName, (Object[]) value);\n+                } else {\n+                    appendSummary(buffer, fieldName, (Object[]) value);\n+                }\n+    \n+            } else {\n+                    if (detail) {\n+                        appendDetail(buffer, fieldName, value);\n+                    } else {\n+                        appendSummary(buffer, fieldName, value);\n+                    }\n+            }\n+        } finally {\n+            unregister(value);\n+        }\n+    }\n+    \n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>\n+     * value that has been detected to participate in a cycle. This\n+     * implementation will print the standard string value of the value.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     *  \n+     * @since 2.2\n+     */\n+    protected void appendCyclicObject(StringBuffer buffer, String fieldName, Object value) {\n+       ObjectUtils.identityToString(buffer, value);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>\n+     * value, printing the full detail of the <code>Object</code>.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, Object value) {\n+        buffer.append(value);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>Collection</code>.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param coll  the <code>Collection</code> to add to the\n+     *  <code>toString</code>, not <code>null</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, Collection<?> coll) {\n+        buffer.append(coll);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>Map<code>.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param map  the <code>Map</code> to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, Map<?, ?> map) {\n+        buffer.append(map);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>\n+     * value, printing a summary of the <code>Object</code>.</P>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, Object value) {\n+        buffer.append(summaryObjectStartText);\n+        buffer.append(getShortClassName(value.getClass()));\n+        buffer.append(summaryObjectEndText);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>long</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    public void append(StringBuffer buffer, String fieldName, long value) {\n+        appendFieldStart(buffer, fieldName);\n+        appendDetail(buffer, fieldName, value);\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>long</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, long value) {\n+        buffer.append(value);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>int</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    public void append(StringBuffer buffer, String fieldName, int value) {\n+        appendFieldStart(buffer, fieldName);\n+        appendDetail(buffer, fieldName, value);\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>int</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, int value) {\n+        buffer.append(value);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>short</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    public void append(StringBuffer buffer, String fieldName, short value) {\n+        appendFieldStart(buffer, fieldName);\n+        appendDetail(buffer, fieldName, value);\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>short</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, short value) {\n+        buffer.append(value);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>byte</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    public void append(StringBuffer buffer, String fieldName, byte value) {\n+        appendFieldStart(buffer, fieldName);\n+        appendDetail(buffer, fieldName, value);\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>byte</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, byte value) {\n+        buffer.append(value);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>char</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    public void append(StringBuffer buffer, String fieldName, char value) {\n+        appendFieldStart(buffer, fieldName);\n+        appendDetail(buffer, fieldName, value);\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>char</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, char value) {\n+        buffer.append(value);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>double</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    public void append(StringBuffer buffer, String fieldName, double value) {\n+        appendFieldStart(buffer, fieldName);\n+        appendDetail(buffer, fieldName, value);\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>double</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, double value) {\n+        buffer.append(value);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>float</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    public void append(StringBuffer buffer, String fieldName, float value) {\n+        appendFieldStart(buffer, fieldName);\n+        appendDetail(buffer, fieldName, value);\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>float</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, float value) {\n+        buffer.append(value);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>boolean</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    public void append(StringBuffer buffer, String fieldName, boolean value) {\n+        appendFieldStart(buffer, fieldName);\n+        appendDetail(buffer, fieldName, value);\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>boolean</code>\n+     * value.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the <code>toString</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, boolean value) {\n+        buffer.append(value);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>\n+     * array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the toString\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info, <code>null</code> for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, Object[] array, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+\n+        if (array == null) {\n+            appendNullText(buffer, fieldName);\n+\n+        } else if (isFullDetail(fullDetail)) {\n+            appendDetail(buffer, fieldName, array);\n+\n+        } else {\n+            appendSummary(buffer, fieldName, array);\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the detail of an\n+     * <code>Object</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, Object[] array) {\n+        buffer.append(arrayStart);\n+        for (int i = 0; i < array.length; i++) {\n+            Object item = array[i];\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            if (item == null) {\n+                appendNullText(buffer, fieldName);\n+\n+            } else {\n+                appendInternal(buffer, fieldName, item, arrayContentDetail);\n+            }\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the detail of an array type.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     * @since 2.0\n+     */\n+    protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\n+        buffer.append(arrayStart);\n+        int length = Array.getLength(array);\n+        for (int i = 0; i < length; i++) {\n+            Object item = Array.get(array, i);\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            if (item == null) {\n+                appendNullText(buffer, fieldName);\n+\n+            } else {\n+                appendInternal(buffer, fieldName, item, arrayContentDetail);\n+            }\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a summary of an\n+     * <code>Object</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, Object[] array) {\n+        appendSummarySize(buffer, fieldName, array.length);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>long</code>\n+     * array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info, <code>null</code> for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, long[] array, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+\n+        if (array == null) {\n+            appendNullText(buffer, fieldName);\n+\n+        } else if (isFullDetail(fullDetail)) {\n+            appendDetail(buffer, fieldName, array);\n+\n+        } else {\n+            appendSummary(buffer, fieldName, array);\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the detail of a\n+     * <code>long</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, long[] array) {\n+        buffer.append(arrayStart);\n+        for (int i = 0; i < array.length; i++) {\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            appendDetail(buffer, fieldName, array[i]);\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a summary of a\n+     * <code>long</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, long[] array) {\n+        appendSummarySize(buffer, fieldName, array.length);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an <code>int</code>\n+     * array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info, <code>null</code> for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, int[] array, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+\n+        if (array == null) {\n+            appendNullText(buffer, fieldName);\n+\n+        } else if (isFullDetail(fullDetail)) {\n+            appendDetail(buffer, fieldName, array);\n+\n+        } else {\n+            appendSummary(buffer, fieldName, array);\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the detail of an\n+     * <code>int</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, int[] array) {\n+        buffer.append(arrayStart);\n+        for (int i = 0; i < array.length; i++) {\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            appendDetail(buffer, fieldName, array[i]);\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a summary of an\n+     * <code>int</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, int[] array) {\n+        appendSummarySize(buffer, fieldName, array.length);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>short</code>\n+     * array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info, <code>null</code> for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, short[] array, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+\n+        if (array == null) {\n+            appendNullText(buffer, fieldName);\n+\n+        } else if (isFullDetail(fullDetail)) {\n+            appendDetail(buffer, fieldName, array);\n+\n+        } else {\n+            appendSummary(buffer, fieldName, array);\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the detail of a\n+     * <code>short</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, short[] array) {\n+        buffer.append(arrayStart);\n+        for (int i = 0; i < array.length; i++) {\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            appendDetail(buffer, fieldName, array[i]);\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a summary of a\n+     * <code>short</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, short[] array) {\n+        appendSummarySize(buffer, fieldName, array.length);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>byte</code>\n+     * array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info, <code>null</code> for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, byte[] array, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+\n+        if (array == null) {\n+            appendNullText(buffer, fieldName);\n+\n+        } else if (isFullDetail(fullDetail)) {\n+            appendDetail(buffer, fieldName, array);\n+\n+        } else {\n+            appendSummary(buffer, fieldName, array);\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the detail of a\n+     * <code>byte</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, byte[] array) {\n+        buffer.append(arrayStart);\n+        for (int i = 0; i < array.length; i++) {\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            appendDetail(buffer, fieldName, array[i]);\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a summary of a\n+     * <code>byte</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, byte[] array) {\n+        appendSummarySize(buffer, fieldName, array.length);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>char</code>\n+     * array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the <code>toString</code>\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info, <code>null</code> for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, char[] array, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+\n+        if (array == null) {\n+            appendNullText(buffer, fieldName);\n+\n+        } else if (isFullDetail(fullDetail)) {\n+            appendDetail(buffer, fieldName, array);\n+\n+        } else {\n+            appendSummary(buffer, fieldName, array);\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the detail of a\n+     * <code>char</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, char[] array) {\n+        buffer.append(arrayStart);\n+        for (int i = 0; i < array.length; i++) {\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            appendDetail(buffer, fieldName, array[i]);\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a summary of a\n+     * <code>char</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, char[] array) {\n+        appendSummarySize(buffer, fieldName, array.length);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>double</code>\n+     * array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the toString\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info, <code>null</code> for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, double[] array, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+\n+        if (array == null) {\n+            appendNullText(buffer, fieldName);\n+\n+        } else if (isFullDetail(fullDetail)) {\n+            appendDetail(buffer, fieldName, array);\n+\n+        } else {\n+            appendSummary(buffer, fieldName, array);\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the detail of a\n+     * <code>double</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, double[] array) {\n+        buffer.append(arrayStart);\n+        for (int i = 0; i < array.length; i++) {\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            appendDetail(buffer, fieldName, array[i]);\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a summary of a\n+     * <code>double</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, double[] array) {\n+        appendSummarySize(buffer, fieldName, array.length);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>float</code>\n+     * array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the toString\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info, <code>null</code> for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, float[] array, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+\n+        if (array == null) {\n+            appendNullText(buffer, fieldName);\n+\n+        } else if (isFullDetail(fullDetail)) {\n+            appendDetail(buffer, fieldName, array);\n+\n+        } else {\n+            appendSummary(buffer, fieldName, array);\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the detail of a\n+     * <code>float</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, float[] array) {\n+        buffer.append(arrayStart);\n+        for (int i = 0; i < array.length; i++) {\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            appendDetail(buffer, fieldName, array[i]);\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a summary of a\n+     * <code>float</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, float[] array) {\n+        appendSummarySize(buffer, fieldName, array.length);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a <code>boolean</code>\n+     * array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the toString\n+     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n+     *  for summary info, <code>null</code> for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, boolean[] array, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+\n+        if (array == null) {\n+            appendNullText(buffer, fieldName);\n+\n+        } else if (isFullDetail(fullDetail)) {\n+            appendDetail(buffer, fieldName, array);\n+\n+        } else {\n+            appendSummary(buffer, fieldName, array);\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the detail of a\n+     * <code>boolean</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, boolean[] array) {\n+        buffer.append(arrayStart);\n+        for (int i = 0; i < array.length; i++) {\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            appendDetail(buffer, fieldName, array[i]);\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a summary of a\n+     * <code>boolean</code> array.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, boolean[] array) {\n+        appendSummarySize(buffer, fieldName, array.length);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the class name.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param object  the <code>Object</code> whose name to output\n+     */\n+    protected void appendClassName(StringBuffer buffer, Object object) {\n+        if (useClassName && object != null) {\n+            register(object);\n+            if (useShortClassName) {\n+                buffer.append(getShortClassName(object.getClass()));\n+            } else {\n+                buffer.append(object.getClass().getName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Append the {@link System#identityHashCode(java.lang.Object)}.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param object  the <code>Object</code> whose id to output\n+     */\n+    protected void appendIdentityHashCode(StringBuffer buffer, Object object) {\n+        if (this.isUseIdentityHashCode() && object!=null) {\n+            register(object);\n+            buffer.append('@');\n+            buffer.append(Integer.toHexString(System.identityHashCode(object)));\n+        }\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the content start.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     */\n+    protected void appendContentStart(StringBuffer buffer) {\n+        buffer.append(contentStart);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the content end.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     */\n+    protected void appendContentEnd(StringBuffer buffer) {\n+        buffer.append(contentEnd);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> an indicator for <code>null</code>.</p>\n+     *\n+     * <p>The default indicator is <code>'&lt;null&gt;'</code>.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     */\n+    protected void appendNullText(StringBuffer buffer, String fieldName) {\n+        buffer.append(nullText);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the field separator.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     */\n+    protected void appendFieldSeparator(StringBuffer buffer) {\n+        buffer.append(fieldSeparator);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> the field start.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name\n+     */\n+    protected void appendFieldStart(StringBuffer buffer, String fieldName) {\n+        if (useFieldNames && fieldName != null) {\n+            buffer.append(fieldName);\n+            buffer.append(fieldNameValueSeparator);\n+        }\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString<code> the field end.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     */\n+    protected void appendFieldEnd(StringBuffer buffer, String fieldName) {\n+        appendFieldSeparator(buffer);\n+    }\n+\n+    /**\n+     * <p>Append to the <code>toString</code> a size summary.</p>\n+     *\n+     * <p>The size summary is used to summarize the contents of\n+     * <code>Collections</code>, <code>Maps</code> and arrays.</p>\n+     *\n+     * <p>The output consists of a prefix, the passed in size\n+     * and a suffix.</p>\n+     *\n+     * <p>The default format is <code>'&lt;size=n&gt;'<code>.</p>\n+     *\n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param size  the size to append\n+     */\n+    protected void appendSummarySize(StringBuffer buffer, String fieldName, int size) {\n+        buffer.append(sizeStartText);\n+        buffer.append(size);\n+        buffer.append(sizeEndText);\n+    }\n+\n+    /**\n+     * <p>Is this field to be output in full detail.</p>\n+     *\n+     * <p>This method converts a detail request into a detail level.\n+     * The calling code may request full detail (<code>true</code>),\n+     * but a subclass might ignore that and always return\n+     * <code>false</code>. The calling code may pass in\n+     * <code>null</code> indicating that it doesn't care about\n+     * the detail level. In this case the default detail level is\n+     * used.</p>\n+     * \n+     * @param fullDetailRequest  the detail level requested\n+     * @return whether full detail is to be shown\n+     */\n+    protected boolean isFullDetail(Boolean fullDetailRequest) {\n+        if (fullDetailRequest == null) {\n+            return defaultFullDetail;\n+        }\n+        return fullDetailRequest.booleanValue();\n+    }\n+\n+    /**\n+     * <p>Gets the short class name for a class.</p>\n+     *\n+     * <p>The short class name is the classname excluding\n+     * the package name.</p>\n+     *\n+     * @param cls  the <code>Class</code> to get the short name of\n+     * @return the short name\n+     */\n+    protected String getShortClassName(Class<?> cls) {\n+        return ClassUtils.getShortClassName(cls);\n+    }\n+\n+    // Setters and getters for the customizable parts of the style\n+    // These methods are not expected to be overridden, except to make public\n+    // (They are not public so that immutable subclasses can be written)\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets whether to use the class name.</p>\n+     *\n+     * @return the current useClassName flag\n+     */\n+    protected boolean isUseClassName() {\n+        return useClassName;\n+    }\n+\n+    /**\n+     * <p>Sets whether to use the class name.</p>\n+     *\n+     * @param useClassName  the new useClassName flag\n+     */\n+    protected void setUseClassName(boolean useClassName) {\n+        this.useClassName = useClassName;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets whether to output short or long class names.</p>\n+     *\n+     * @return the current useShortClassName flag\n+     * @since 2.0\n+     */\n+    protected boolean isUseShortClassName() {\n+        return useShortClassName;\n+    }\n+\n+    /**\n+     * <p>Sets whether to output short or long class names.</p>\n+     *\n+     * @param useShortClassName  the new useShortClassName flag\n+     * @since 2.0\n+     */\n+    protected void setUseShortClassName(boolean useShortClassName) {\n+        this.useShortClassName = useShortClassName;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets whether to use the identity hash code.</p>\n+     *\n+     * @return the current useIdentityHashCode flag\n+     */\n+    protected boolean isUseIdentityHashCode() {\n+        return useIdentityHashCode;\n+    }\n+\n+    /**\n+     * <p>Sets whether to use the identity hash code.</p>\n+     *\n+     * @param useIdentityHashCode  the new useIdentityHashCode flag\n+     */\n+    protected void setUseIdentityHashCode(boolean useIdentityHashCode) {\n+        this.useIdentityHashCode = useIdentityHashCode;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets whether to use the field names passed in.</p>\n+     *\n+     * @return the current useFieldNames flag\n+     */\n+    protected boolean isUseFieldNames() {\n+        return useFieldNames;\n+    }\n+\n+    /**\n+     * <p>Sets whether to use the field names passed in.</p>\n+     *\n+     * @param useFieldNames  the new useFieldNames flag\n+     */\n+    protected void setUseFieldNames(boolean useFieldNames) {\n+        this.useFieldNames = useFieldNames;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets whether to use full detail when the caller doesn't\n+     * specify.</p>\n+     *\n+     * @return the current defaultFullDetail flag\n+     */\n+    protected boolean isDefaultFullDetail() {\n+        return defaultFullDetail;\n+    }\n+\n+    /**\n+     * <p>Sets whether to use full detail when the caller doesn't\n+     * specify.</p>\n+     *\n+     * @param defaultFullDetail  the new defaultFullDetail flag\n+     */\n+    protected void setDefaultFullDetail(boolean defaultFullDetail) {\n+        this.defaultFullDetail = defaultFullDetail;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets whether to output array content detail.</p>\n+     *\n+     * @return the current array content detail setting\n+     */\n+    protected boolean isArrayContentDetail() {\n+        return arrayContentDetail;\n+    }\n+\n+    /**\n+     * <p>Sets whether to output array content detail.</p>\n+     *\n+     * @param arrayContentDetail  the new arrayContentDetail flag\n+     */\n+    protected void setArrayContentDetail(boolean arrayContentDetail) {\n+        this.arrayContentDetail = arrayContentDetail;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the array start text.</p>\n+     *\n+     * @return the current array start text\n+     */\n+    protected String getArrayStart() {\n+        return arrayStart;\n+    }\n+\n+    /**\n+     * <p>Sets the array start text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param arrayStart  the new array start text\n+     */\n+    protected void setArrayStart(String arrayStart) {\n+        if (arrayStart == null) {\n+            arrayStart = \"\";\n+        }\n+        this.arrayStart = arrayStart;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the array end text.</p>\n+     *\n+     * @return the current array end text\n+     */\n+    protected String getArrayEnd() {\n+        return arrayEnd;\n+    }\n+\n+    /**\n+     * <p>Sets the array end text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param arrayEnd  the new array end text\n+     */\n+    protected void setArrayEnd(String arrayEnd) {\n+        if (arrayEnd == null) {\n+            arrayEnd = \"\";\n+        }\n+        this.arrayEnd = arrayEnd;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the array separator text.</p>\n+     *\n+     * @return the current array separator text\n+     */\n+    protected String getArraySeparator() {\n+        return arraySeparator;\n+    }\n+\n+    /**\n+     * <p>Sets the array separator text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param arraySeparator  the new array separator text\n+     */\n+    protected void setArraySeparator(String arraySeparator) {\n+        if (arraySeparator == null) {\n+            arraySeparator = \"\";\n+        }\n+        this.arraySeparator = arraySeparator;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the content start text.</p>\n+     *\n+     * @return the current content start text\n+     */\n+    protected String getContentStart() {\n+        return contentStart;\n+    }\n+\n+    /**\n+     * <p>Sets the content start text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param contentStart  the new content start text\n+     */\n+    protected void setContentStart(String contentStart) {\n+        if (contentStart == null) {\n+            contentStart = \"\";\n+        }\n+        this.contentStart = contentStart;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the content end text.</p>\n+     *\n+     * @return the current content end text\n+     */\n+    protected String getContentEnd() {\n+        return contentEnd;\n+    }\n+\n+    /**\n+     * <p>Sets the content end text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param contentEnd  the new content end text\n+     */\n+    protected void setContentEnd(String contentEnd) {\n+        if (contentEnd == null) {\n+            contentEnd = \"\";\n+        }\n+        this.contentEnd = contentEnd;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the field name value separator text.</p>\n+     *\n+     * @return the current field name value separator text\n+     */\n+    protected String getFieldNameValueSeparator() {\n+        return fieldNameValueSeparator;\n+    }\n+\n+    /**\n+     * <p>Sets the field name value separator text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param fieldNameValueSeparator  the new field name value separator text\n+     */\n+    protected void setFieldNameValueSeparator(String fieldNameValueSeparator) {\n+        if (fieldNameValueSeparator == null) {\n+            fieldNameValueSeparator = \"\";\n+        }\n+        this.fieldNameValueSeparator = fieldNameValueSeparator;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the field separator text.</p>\n+     *\n+     * @return the current field separator text\n+     */\n+    protected String getFieldSeparator() {\n+        return fieldSeparator;\n+    }\n+\n+    /**\n+     * <p>Sets the field separator text.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param fieldSeparator  the new field separator text\n+     */\n+    protected void setFieldSeparator(String fieldSeparator) {\n+        if (fieldSeparator == null) {\n+            fieldSeparator = \"\";\n+        }\n+        this.fieldSeparator = fieldSeparator;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets whether the field separator should be added at the start \n+     * of each buffer.</p>\n+     * \n+     * @return the fieldSeparatorAtStart flag\n+     * @since 2.0\n+     */\n+    protected boolean isFieldSeparatorAtStart() {\n+        return fieldSeparatorAtStart;\n+    }\n+\n+    /**\n+     * <p>Sets whether the field separator should be added at the start \n+     * of each buffer.</p>\n+     * \n+     * @param fieldSeparatorAtStart  the fieldSeparatorAtStart flag\n+     * @since 2.0\n+     */\n+    protected void setFieldSeparatorAtStart(boolean fieldSeparatorAtStart) {\n+        this.fieldSeparatorAtStart = fieldSeparatorAtStart;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets whether the field separator should be added at the end \n+     * of each buffer.</p>\n+     * \n+     * @return fieldSeparatorAtEnd flag\n+     * @since 2.0\n+     */\n+    protected boolean isFieldSeparatorAtEnd() {\n+        return fieldSeparatorAtEnd;\n+    }\n+\n+    /**\n+     * <p>Sets whether the field separator should be added at the end \n+     * of each buffer.</p>\n+     * \n+     * @param fieldSeparatorAtEnd  the fieldSeparatorAtEnd flag\n+     * @since 2.0\n+     */\n+    protected void setFieldSeparatorAtEnd(boolean fieldSeparatorAtEnd) {\n+        this.fieldSeparatorAtEnd = fieldSeparatorAtEnd;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the text to output when <code>null</code> found.</p>\n+     *\n+     * @return the current text to output when null found\n+     */\n+    protected String getNullText() {\n+        return nullText;\n+    }\n+\n+    /**\n+     * <p>Sets the text to output when <code>null</code> found.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param nullText  the new text to output when null found\n+     */\n+    protected void setNullText(String nullText) {\n+        if (nullText == null) {\n+            nullText = \"\";\n+        }\n+        this.nullText = nullText;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the start text to output when a <code>Collection</code>,\n+     * <code>Map</code> or array size is output.</p>\n+     *\n+     * <p>This is output before the size value.</p>\n+     *\n+     * @return the current start of size text\n+     */\n+    protected String getSizeStartText() {\n+        return sizeStartText;\n+    }\n+\n+    /**\n+     * <p>Sets the start text to output when a <code>Collection</code>,\n+     * <code>Map</code> or array size is output.</p>\n+     *\n+     * <p>This is output before the size value.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param sizeStartText  the new start of size text\n+     */\n+    protected void setSizeStartText(String sizeStartText) {\n+        if (sizeStartText == null) {\n+            sizeStartText = \"\";\n+        }\n+        this.sizeStartText = sizeStartText;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the end text to output when a <code>Collection</code>,\n+     * <code>Map</code> or array size is output.</p>\n+     *\n+     * <p>This is output after the size value.</p>\n+     *\n+     * @return the current end of size text\n+     */\n+    protected String getSizeEndText() {\n+        return sizeEndText;\n+    }\n+\n+    /**\n+     * <p>Sets the end text to output when a <code>Collection</code>,\n+     * <code>Map</code> or array size is output.</p>\n+     *\n+     * <p>This is output after the size value.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param sizeEndText  the new end of size text\n+     */\n+    protected void setSizeEndText(String sizeEndText) {\n+        if (sizeEndText == null) {\n+            sizeEndText = \"\";\n+        }\n+        this.sizeEndText = sizeEndText;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the start text to output when an <code>Object</code> is\n+     * output in summary mode.</p>\n+     *\n+     * <p>This is output before the size value.</p>\n+     *\n+     * @return the current start of summary text\n+     */\n+    protected String getSummaryObjectStartText() {\n+        return summaryObjectStartText;\n+    }\n+\n+    /**\n+     * <p>Sets the start text to output when an <code>Object</code> is\n+     * output in summary mode.</p>\n+     *\n+     * <p>This is output before the size value.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param summaryObjectStartText  the new start of summary text\n+     */\n+    protected void setSummaryObjectStartText(String summaryObjectStartText) {\n+        if (summaryObjectStartText == null) {\n+            summaryObjectStartText = \"\";\n+        }\n+        this.summaryObjectStartText = summaryObjectStartText;\n+    }\n+\n+    //---------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the end text to output when an <code>Object</code> is\n+     * output in summary mode.</p>\n+     *\n+     * <p>This is output after the size value.</p>\n+     *\n+     * @return the current end of summary text\n+     */\n+    protected String getSummaryObjectEndText() {\n+        return summaryObjectEndText;\n+    }\n+\n+    /**\n+     * <p>Sets the end text to output when an <code>Object</code> is\n+     * output in summary mode.</p>\n+     *\n+     * <p>This is output after the size value.</p>\n+     *\n+     * <p><code>null</code> is accepted, but will be converted to\n+     * an empty String.</p>\n+     *\n+     * @param summaryObjectEndText  the new end of summary text\n+     */\n+    protected void setSummaryObjectEndText(String summaryObjectEndText) {\n+        if (summaryObjectEndText == null) {\n+            summaryObjectEndText = \"\";\n+        }\n+        this.summaryObjectEndText = summaryObjectEndText;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p>Default <code>ToStringStyle</code>.</p>\n+     *\n+     * <p>This is an inner class rather than using\n+     * <code>StandardToStringStyle</code> to ensure its immutability.</p>\n+     */\n+    private static final class DefaultToStringStyle extends ToStringStyle {\n+\n+        /**\n+         * Required for serialization support.\n+         * \n+         * @see java.io.Serializable\n+         */\n+        private static final long serialVersionUID = 1L;\n+\n+        /**\n+         * <p>Constructor.</p>\n+         *\n+         * <p>Use the static constant rather than instantiating.</p>\n+         */\n+        DefaultToStringStyle() {\n+            super();\n+        }\n+\n+        /**\n+         * <p>Ensure <code>Singleton</code> after serialization.</p>\n+         *\n+         * @return the singleton\n+         */\n+        private Object readResolve() {\n+            return ToStringStyle.DEFAULT_STYLE;\n+        }\n+\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p><code>ToStringStyle</code> that does not print out\n+     * the field names.</p>\n+     *\n+     * <p>This is an inner class rather than using\n+     * <code>StandardToStringStyle</code> to ensure its immutability.\n+     */\n+    private static final class NoFieldNameToStringStyle extends ToStringStyle {\n+\n+        private static final long serialVersionUID = 1L;\n+\n+        /**\n+         * <p>Constructor.</p>\n+         *\n+         * <p>Use the static constant rather than instantiating.</p>\n+         */\n+        NoFieldNameToStringStyle() {\n+            super();\n+            this.setUseFieldNames(false);\n+        }\n+\n+        /**\n+         * <p>Ensure <code>Singleton</code> after serialization.</p>\n+         *\n+         * @return the singleton\n+         */\n+        private Object readResolve() {\n+            return ToStringStyle.NO_FIELD_NAMES_STYLE;\n+        }\n+\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * <p><code>ToStringStyle</code> that prints out the short\n+     * class name and no identity hashcode.</p>\n+     *\n+     * <p>This is an inner class rather than using\n+     * <code>StandardToStringStyle</code> to ensure its immutability.</p>\n+     */\n+    private static final class ShortPrefixToStringStyle extends ToStringStyle {\n+\n+        private static final long serialVersionUID = 1L;\n+\n+        /**\n+         * <p>Constructor.</p>\n+         *\n+         * <p>Use the static constant rather than instantiating.</p>\n+         */\n+        ShortPrefixToStringStyle() {\n+            super();\n+            this.setUseShortClassName(true);\n+            this.setUseIdentityHashCode(false);\n+        }\n+\n+        /**\n+         * <p>Ensure <code>Singleton</ode> after serialization.</p>\n+         * @return the singleton\n+         */\n+        private Object readResolve() {\n+            return ToStringStyle.SHORT_PREFIX_STYLE;\n+        }\n+\n+    }\n+\n+    /**\n+     * <p><code>ToStringStyle</code> that does not print out the\n+     * classname, identity hashcode, content start or field name.</p>\n+     *\n+     * <p>This is an inner class rather than using\n+     * <code>StandardToStringStyle</code> to ensure its immutability.</p>\n+     */\n+    private static final class SimpleToStringStyle extends ToStringStyle {\n+\n+        private static final long serialVersionUID = 1L;\n+\n+        /**\n+         * <p>Constructor.</p>\n+         *\n+         * <p>Use the static constant rather than instantiating.</p>\n+         */\n+        SimpleToStringStyle() {\n+            super();\n+            this.setUseClassName(false);\n+            this.setUseIdentityHashCode(false);\n+            this.setUseFieldNames(false);\n+            this.setContentStart(\"\");\n+            this.setContentEnd(\"\");\n+        }\n+\n+        /**\n+         * <p>Ensure <code>Singleton</ode> after serialization.</p>\n+         * @return the singleton\n+         */\n+        private Object readResolve() {\n+            return ToStringStyle.SIMPLE_STYLE;\n+        }\n+\n+    }\n+\n+    //----------------------------------------------------------------------------\n+\n+    /**\n+     * <p><code>ToStringStyle</code> that outputs on multiple lines.</p>\n+     *\n+     * <p>This is an inner class rather than using\n+     * <code>StandardToStringStyle</code> to ensure its immutability.</p>\n+     */\n+    private static final class MultiLineToStringStyle extends ToStringStyle {\n+\n+        private static final long serialVersionUID = 1L;\n+\n+        /**\n+         * <p>Constructor.</p>\n+         *\n+         * <p>Use the static constant rather than instantiating.</p>\n+         */\n+        MultiLineToStringStyle() {\n+            super();\n+            this.setContentStart(\"[\");\n+            this.setFieldSeparator(SystemUtils.LINE_SEPARATOR + \"  \");\n+            this.setFieldSeparatorAtStart(true);\n+            this.setContentEnd(SystemUtils.LINE_SEPARATOR + \"]\");\n+        }\n+\n+        /**\n+         * <p>Ensure <code>Singleton</code> after serialization.</p>\n+         *\n+         * @return the singleton\n+         */\n+        private Object readResolve() {\n+            return ToStringStyle.MULTI_LINE_STYLE;\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/BackgroundInitializer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.concurrent;\n+\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * <p>\n+ * A class that allows complex initialization operations in a background task.\n+ * </p>\n+ * <p>\n+ * Applications often have to do some expensive initialization steps when they\n+ * are started, e.g. constructing a connection to a database, reading a\n+ * configuration file, etc. Doing these things in parallel can enhance\n+ * performance as the CPU load can be improved. However, when access to the\n+ * resources initialized in a background thread is actually required,\n+ * synchronization has to be performed to ensure that their initialization is\n+ * complete.\n+ * </p>\n+ * <p>\n+ * This abstract base class provides support for this use case. A concrete\n+ * subclass must implement the {@link #initialize()} method. Here an arbitrary\n+ * initialization can be implemented, and a result object can be returned. With\n+ * this method in place the basic usage of this class is as follows (where\n+ * {@code MyBackgroundInitializer} is a concrete subclass):\n+ *\n+ * <pre>\n+ * MyBackgroundInitializer initializer = new MyBackgroundInitializer();\n+ * initializer.start();\n+ * // Now do some other things. Initialization runs in a parallel thread\n+ * ...\n+ * // Wait for the end of initialization and access the result object\n+ * Object result = initializer.get();\n+ * </pre>\n+ *\n+ * </p>\n+ * <p>\n+ * After the construction of a {@code BackgroundInitializer} object its\n+ * {@link #start()} method has to be called. This starts the background\n+ * processing. The application can now continue to do other things. When it\n+ * needs access to the object produced by the {@code BackgroundInitializer} it\n+ * calls its {@link #get()} method. If initialization is already complete,\n+ * {@link #get()} returns the result object immediately. Otherwise it blocks\n+ * until the result object is fully constructed.\n+ * </p>\n+ * <p>\n+ * {@code BackgroundInitializer} is a thin wrapper around a {@code Future}\n+ * object and uses an {@code ExecutorService} for running the background\n+ * initialization task. It is possible to pass in an {@code ExecutorService} at\n+ * construction time or set one using {@code setExternalExecutor()} before\n+ * {@code start()} was called. Then this object is used to spawn the background\n+ * task. If no {@code ExecutorService} has been provided, {@code\n+ * BackgroundInitializer} creates a temporary {@code ExecutorService} and\n+ * destroys it when initialization is complete.\n+ * </p>\n+ * <p>\n+ * The methods provided by {@code BackgroundInitializer} provide for minimal\n+ * interaction with the wrapped {@code Future} object. It is also possible to\n+ * obtain the {@code Future} object directly. Then the enhanced functionality\n+ * offered by {@code Future} can be used, e.g. to check whether the background\n+ * operation is complete or to cancel the operation.\n+ * </p>\n+ *\n+ * @version $Id$\n+ * @param <T> the type of the object managed by this initializer class\n+ */\n+public abstract class BackgroundInitializer<T> {\n+    /** The external executor service for executing tasks. */\n+    private ExecutorService externalExecutor;\n+\n+    /** A reference to the executor service that is actually used. */\n+    private ExecutorService executor;\n+\n+    /** Stores the handle to the background task. */\n+    private Future<T> future;\n+\n+    /**\n+     * Creates a new instance of {@code BackgroundInitializer}. No external\n+     * {@code ExecutorService} is used.\n+     */\n+    protected BackgroundInitializer() {\n+        this(null);\n+    }\n+\n+    /**\n+     * Creates a new instance of {@code BackgroundInitializer} and initializes\n+     * it with the given {@code ExecutorService}. If the {@code ExecutorService}\n+     * is not null, the background task for initializing this object will be\n+     * scheduled at this service. Otherwise a new temporary {@code\n+     * ExecutorService} is created.\n+     *\n+     * @param exec an external {@code ExecutorService} to be used for task\n+     * execution\n+     */\n+    protected BackgroundInitializer(ExecutorService exec) {\n+        setExternalExecutor(exec);\n+    }\n+\n+    /**\n+     * Returns the external {@code ExecutorService} to be used by this class.\n+     *\n+     * @return the {@code ExecutorService}\n+     */\n+    public final synchronized ExecutorService getExternalExecutor() {\n+        return externalExecutor;\n+    }\n+\n+    /**\n+     * Returns a flag whether this {@code BackgroundInitializer} has already\n+     * been started.\n+     *\n+     * @return a flag whether the {@link #start()} method has already been\n+     * called\n+     */\n+    public synchronized boolean isStarted() {\n+        return future != null;\n+    }\n+\n+    /**\n+     * Sets an {@code ExecutorService} to be used by this class. The {@code\n+     * ExecutorService} passed to this method is used for executing the\n+     * background task. Thus it is possible to re-use an already existing\n+     * {@code ExecutorService} or to use a specially configured one. If no\n+     * {@code ExecutorService} is set, this instance creates a temporary one and\n+     * destroys it after background initialization is complete. Note that this\n+     * method must be called before {@link #start()}; otherwise an exception is\n+     * thrown.\n+     *\n+     * @param externalExecutor the {@code ExecutorService} to be used\n+     * @throws IllegalStateException if this initializer has already been\n+     * started\n+     */\n+    public final synchronized void setExternalExecutor(\n+            ExecutorService externalExecutor) {\n+        if (isStarted()) {\n+            throw new IllegalStateException(\n+                    \"Cannot set ExecutorService after start()!\");\n+        }\n+\n+        this.externalExecutor = externalExecutor;\n+    }\n+\n+    /**\n+     * Starts the background initialization. With this method the initializer\n+     * becomes active and invokes the {@link #initialize()} method in a\n+     * background task. A {@code BackgroundInitializer} can be started exactly\n+     * once. The return value of this method determines whether the start was\n+     * successful: only the first invocation of this method returns <b>true</b>,\n+     * following invocations will return <b>false</b>.\n+     *\n+     * @return a flag whether the initializer could be started successfully\n+     */\n+    public synchronized boolean start() {\n+        // Not yet started?\n+        if (!isStarted()) {\n+\n+            // Determine the executor to use and whether a temporary one has to\n+            // be created\n+            ExecutorService tempExec;\n+            executor = getExternalExecutor();\n+            if (executor == null) {\n+                executor = tempExec = createExecutor();\n+            } else {\n+                tempExec = null;\n+            }\n+\n+            future = executor.submit(createTask(tempExec));\n+\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * Returns the result of the background initialization. This method blocks\n+     * until initialization is complete. If the background processing caused a\n+     * runtime exception, it is directly thrown by this method. Checked\n+     * exceptions, including {@code InterruptedException} are wrapped in a\n+     * {@link ConcurrentException}. Calling this method before {@link #start()}\n+     * was called causes an {@code IllegalStateException} exception to be\n+     * thrown.\n+     *\n+     * @return the object produced by this initializer\n+     * @throws ConcurrentException if a checked exception occurred during\n+     * background processing\n+     * @throws IllegalStateException if {@link #start()} has not been called\n+     */\n+    public T get() throws ConcurrentException {\n+        try {\n+            return getFuture().get();\n+        } catch (ExecutionException execex) {\n+            ConcurrentUtils.handleCause(execex);\n+            return null; // should not be reached\n+        } catch (InterruptedException iex) {\n+            // reset interrupted state\n+            Thread.currentThread().interrupt();\n+            throw new ConcurrentException(iex);\n+        }\n+    }\n+\n+    /**\n+     * Returns the {@code Future} object that was created when {@link #start()}\n+     * was called. Therefore this method can only be called after {@code\n+     * start()}.\n+     *\n+     * @return the {@code Future} object wrapped by this initializer\n+     * @throws IllegalStateException if {@link #start()} has not been called\n+     */\n+    public synchronized Future<T> getFuture() {\n+        if (future == null) {\n+            throw new IllegalStateException(\"start() must be called first!\");\n+        }\n+\n+        return future;\n+    }\n+\n+    /**\n+     * Returns the {@code ExecutorService} that is actually used for executing\n+     * the background task. This method can be called after {@link #start()}\n+     * (before {@code start()} it returns <b>null</b>). If an external executor\n+     * was set, this is also the active executor. Otherwise this method returns\n+     * the temporary executor that was created by this object.\n+     *\n+     * @return the {@code ExecutorService} for executing the background task\n+     */\n+    protected synchronized final ExecutorService getActiveExecutor() {\n+        return executor;\n+    }\n+\n+    /**\n+     * Returns the number of background tasks to be created for this\n+     * initializer. This information is evaluated when a temporary {@code\n+     * ExecutorService} is created. This base implementation returns 1. Derived\n+     * classes that do more complex background processing can override it. This\n+     * method is called from a synchronized block by the {@link #start()}\n+     * method. Therefore overriding methods should be careful with obtaining\n+     * other locks and return as fast as possible.\n+     *\n+     * @return the number of background tasks required by this initializer\n+     */\n+    protected int getTaskCount() {\n+        return 1;\n+    }\n+\n+    /**\n+     * Performs the initialization. This method is called in a background task\n+     * when this {@code BackgroundInitializer} is started. It must be\n+     * implemented by a concrete subclass. An implementation is free to perform\n+     * arbitrary initialization. The object returned by this method can be\n+     * queried using the {@link #get()} method.\n+     *\n+     * @return a result object\n+     * @throws Exception if an error occurs\n+     */\n+    protected abstract T initialize() throws Exception;\n+\n+    /**\n+     * Creates a task for the background initialization. The {@code Callable}\n+     * object returned by this method is passed to the {@code ExecutorService}.\n+     * This implementation returns a task that invokes the {@link #initialize()}\n+     * method. If a temporary {@code ExecutorService} is used, it is destroyed\n+     * at the end of the task.\n+     *\n+     * @param execDestroy the {@code ExecutorService} to be destroyed by the\n+     * task\n+     * @return a task for the background initialization\n+     */\n+    private Callable<T> createTask(ExecutorService execDestroy) {\n+        return new InitializationTask(execDestroy);\n+    }\n+\n+    /**\n+     * Creates the {@code ExecutorService} to be used. This method is called if\n+     * no {@code ExecutorService} was provided at construction time.\n+     *\n+     * @return the {@code ExecutorService} to be used\n+     */\n+    private ExecutorService createExecutor() {\n+        return Executors.newFixedThreadPool(getTaskCount());\n+    }\n+\n+    private class InitializationTask implements Callable<T> {\n+        /** Stores the executor service to be destroyed at the end. */\n+        private final ExecutorService execFinally;\n+\n+        /**\n+         * Creates a new instance of {@code InitializationTask} and initializes\n+         * it with the {@code ExecutorService} to be destroyed at the end.\n+         *\n+         * @param exec the {@code ExecutorService}\n+         */\n+        public InitializationTask(ExecutorService exec) {\n+            execFinally = exec;\n+        }\n+\n+        /**\n+         * Initiates initialization and returns the result.\n+         *\n+         * @return the result object\n+         * @throws Exception if an error occurs\n+         */\n+        public T call() throws Exception {\n+            try {\n+                return initialize();\n+            } finally {\n+                if (execFinally != null) {\n+                    execFinally.shutdown();\n+                }\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/CallableBackgroundInitializer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.concurrent;\n+\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+\n+/**\n+ * <p>\n+ * A specialized {@link BackgroundInitializer} implementation that wraps a\n+ * {@code Callable} object.\n+ * </p>\n+ * <p>\n+ * An instance of this class is initialized with a {@code Callable} object when\n+ * it is constructed. The implementation of the {@link #initialize()} method\n+ * defined in the super class delegates to this {@code Callable} so that the\n+ * {@code Callable} is executed in the background thread.\n+ * </p>\n+ * <p>\n+ * The {@code java.util.concurrent.Callable} interface is a standard mechanism\n+ * of the JDK to define tasks to be executed by another thread. The {@code\n+ * CallableBackgroundInitializer} class allows combining this standard interface\n+ * with the background initializer API.\n+ * </p>\n+ * <p>\n+ * Usage of this class is very similar to the default usage pattern of the\n+ * {@link BackgroundInitializer} class: Just create an instance and provide the\n+ * {@code Callable} object to be executed, then call the initializer's\n+ * {@link #start()} method. This causes the {@code Callable} to be executed in\n+ * another thread. When the results of the {@code Callable} are needed the\n+ * initializer's {@link #get()} method can be called (which may block until\n+ * background execution is complete). The following code fragment shows a\n+ * typical usage example:\n+ *\n+ * <pre>\n+ * // a Callable that performs a complex computation\n+ * Callable&lt;Integer&gt; computationCallable = new MyComputationCallable();\n+ * // setup the background initializer\n+ * CallableBackgroundInitializer&lt;Integer&gt; initializer =\n+ *     new CallableBackgroundInitializer(computationCallable);\n+ * initializer.start();\n+ * // Now do some other things. Initialization runs in a parallel thread\n+ * ...\n+ * // Wait for the end of initialization and access the result\n+ * Integer result = initializer.get();\n+ * </pre>\n+ *\n+ * </p>\n+ *\n+ * @version $Id$\n+ * @param <T> the type of the object managed by this initializer class\n+ */\n+public class CallableBackgroundInitializer<T> extends BackgroundInitializer<T> {\n+    /** The Callable to be executed. */\n+    private final Callable<T> callable;\n+\n+    /**\n+     * Creates a new instance of {@code CallableBackgroundInitializer} and sets\n+     * the {@code Callable} to be executed in a background thread.\n+     *\n+     * @param call the {@code Callable} (must not be <b>null</b>)\n+     * @throws IllegalArgumentException if the {@code Callable} is <b>null</b>\n+     */\n+    public CallableBackgroundInitializer(Callable<T> call) {\n+        checkCallable(call);\n+        callable = call;\n+    }\n+\n+    /**\n+     * Creates a new instance of {@code CallableBackgroundInitializer} and\n+     * initializes it with the {@code Callable} to be executed in a background\n+     * thread and the {@code ExecutorService} for managing the background\n+     * execution.\n+     *\n+     * @param call the {@code Callable} (must not be <b>null</b>)\n+     * @param exec an external {@code ExecutorService} to be used for task\n+     * execution\n+     * @throws IllegalArgumentException if the {@code Callable} is <b>null</b>\n+     */\n+    public CallableBackgroundInitializer(Callable<T> call, ExecutorService exec) {\n+        super(exec);\n+        checkCallable(call);\n+        callable = call;\n+    }\n+\n+    /**\n+     * Performs initialization in a background thread. This implementation\n+     * delegates to the {@code Callable} passed at construction time of this\n+     * object.\n+     *\n+     * @return the result of the initialization\n+     * @throws Exception if an error occurs\n+     */\n+    @Override\n+    protected T initialize() throws Exception {\n+        return callable.call();\n+    }\n+\n+    /**\n+     * Tests the passed in {@code Callable} and throws an exception if it is\n+     * undefined.\n+     *\n+     * @param call the object to check\n+     * @throws IllegalArgumentException if the {@code Callable} is <b>null</b>\n+     */\n+    private void checkCallable(Callable<T> call) {\n+        if (call == null) {\n+            throw new IllegalArgumentException(\"Callable must not be null!\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/ConcurrentException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.concurrent;\n+\n+/**\n+ * <p>\n+ * An exception class used for reporting error conditions related to accessing\n+ * data of background tasks.\n+ * </p>\n+ * <p>\n+ * The purpose of this exception class is analogous to the default JDK exception\n+ * class {@link java.util.concurrent.ExecutionException}, i.e. it wraps an\n+ * exception that occurred during the execution of a task. However, in contrast\n+ * to {@code ExecutionException}, it wraps only checked exceptions. Runtime\n+ * exceptions are thrown directly.\n+ * </p>\n+ *\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class ConcurrentException extends Exception {\n+    /**\n+     * The serial version UID.\n+     */\n+    private static final long serialVersionUID = 6622707671812226130L;\n+\n+    /**\n+     * Creates a new, uninitialized instance of {@code ConcurrentException}.\n+     */\n+    protected ConcurrentException() {\n+        super();\n+    }\n+\n+    /**\n+     * Creates a new instance of {@code ConcurrentException} and initializes it\n+     * with the given cause.\n+     *\n+     * @param cause the cause of this exception\n+     * @throws IllegalArgumentException if the cause is not a checked exception\n+     */\n+    public ConcurrentException(Throwable cause) {\n+        super(ConcurrentUtils.checkedException(cause));\n+    }\n+\n+    /**\n+     * Creates a new instance of {@code ConcurrentException} and initializes it\n+     * with the given message and cause.\n+     *\n+     * @param msg the error message\n+     * @param cause the cause of this exception\n+     * @throws IllegalArgumentException if the cause is not a checked exception\n+     */\n+    public ConcurrentException(String msg, Throwable cause) {\n+        super(msg, ConcurrentUtils.checkedException(cause));\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/ConcurrentUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.concurrent;\n+\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * <p>\n+ * An utility class providing functionality related to the {@code\n+ * java.util.concurrent} package.\n+ * </p>\n+ *\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class ConcurrentUtils {\n+\n+    /**\n+     * Private constructor so that no instances can be created. This class\n+     * contains only static utility methods.\n+     */\n+    private ConcurrentUtils() {\n+    }\n+\n+    /**\n+     * Inspects the cause of the specified {@code ExecutionException} and\n+     * creates a {@code ConcurrentException} with the checked cause if\n+     * necessary. This method performs the following checks on the cause of the\n+     * passed in exception:\n+     * <ul>\n+     * <li>If the passed in exception is <b>null</b> or the cause is\n+     * <b>null</b>, this method returns <b>null</b>.</li>\n+     * <li>If the cause is a runtime exception, it is directly thrown.</li>\n+     * <li>If the cause is an error, it is directly thrown, too.</li>\n+     * <li>In any other case the cause is a checked exception. The method then\n+     * creates a {@link ConcurrentException}, initializes it with the cause, and\n+     * returns it.</li>\n+     * </ul>\n+     *\n+     * @param ex the exception to be processed\n+     * @return a {@code ConcurrentException} with the checked cause\n+     */\n+    public static ConcurrentException extractCause(ExecutionException ex) {\n+        if (ex == null || ex.getCause() == null) {\n+            return null;\n+        }\n+\n+        throwCause(ex);\n+        return new ConcurrentException(ex.getMessage(), ex.getCause());\n+    }\n+\n+    /**\n+     * Handles the specified {@code ExecutionException}. This method calls\n+     * {@link #extractCause(ExecutionException)} for obtaining the cause of the\n+     * exception - which might already cause an unchecked exception or an error\n+     * being thrown. If the cause is a checked exception however, it is wrapped\n+     * in a {@code ConcurrentException}, which is thrown. If the passed in\n+     * exception is <b>null</b> or has no cause, the method simply returns\n+     * without throwing an exception.\n+     *\n+     * @param ex the exception to be handled\n+     * @throws ConcurrentException if the cause of the {@code\n+     * ExecutionException} is a checked exception\n+     */\n+    public static void handleCause(ExecutionException ex)\n+            throws ConcurrentException {\n+        ConcurrentException cex = extractCause(ex);\n+\n+        if (cex != null) {\n+            throw cex;\n+        }\n+    }\n+\n+    /**\n+     * Tests whether the specified {@code Throwable} is a checked exception. If\n+     * not, an exception is thrown.\n+     *\n+     * @param ex the {@code Throwable} to check\n+     * @return a flag whether the passed in exception is a checked exception\n+     * @throws IllegalArgumentException if the {@code Throwable} is not a\n+     * checked exception\n+     */\n+    static Throwable checkedException(Throwable ex) {\n+        if (ex != null && !(ex instanceof RuntimeException)\n+                && !(ex instanceof Error)) {\n+            return ex;\n+        } else {\n+            throw new IllegalArgumentException(\"Not a checked exception: \" + ex);\n+        }\n+    }\n+\n+    /**\n+     * Tests whether the cause of the specified {@code ExecutionException}\n+     * should be thrown and does it if necessary.\n+     *\n+     * @param ex the exception in question\n+     */\n+    private static void throwCause(ExecutionException ex) {\n+        if (ex.getCause() instanceof RuntimeException) {\n+            throw (RuntimeException) ex.getCause();\n+        }\n+\n+        if (ex.getCause() instanceof Error) {\n+            throw (Error) ex.getCause();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>\n+     * Gets an implementation of <code>Future</code> that is immediately done\n+     * and returns the specified constant value.\n+     * </p>\n+     * <p>\n+     * This can be useful to return a simple constant immediately from the\n+     * concurrent processing, perhaps as part of avoiding nulls.\n+     * A constant future can also be useful in testing.\n+     * </p>\n+     * \n+     * @param value  the constant value to return, may be null\n+     * @return an instance of Future that will return the value, never null\n+     */\n+    public static <T> Future<T> constantFuture(T value) {\n+        return new ConstantFuture<T>(value);\n+    }\n+\n+    static final class ConstantFuture<T> implements Future<T> {\n+        /** The constant value. */\n+        private final T value;\n+\n+        ConstantFuture(T value) {\n+            this.value = value;\n+        }\n+\n+        public boolean isDone() {\n+            return true;\n+        }\n+\n+        public T get() {\n+            return value;\n+        }\n+\n+        public T get(long timeout, TimeUnit unit) {\n+            return value;\n+        }\n+\n+        public boolean isCancelled() {\n+            return false;\n+        }\n+\n+        public boolean cancel(boolean mayInterruptIfRunning) {\n+            return false;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/LazyInitializer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.concurrent;\n+\n+/**\n+ * <p>\n+ * This class provides a generic implementation of the lazy initialization\n+ * pattern.\n+ * </p>\n+ * <p>\n+ * Sometimes an application has to deal with an object only under certain\n+ * circumstances, e.g. when the user selects a specific menu item or if a\n+ * special event is received. If the creation of the object is costly or the\n+ * consumption of memory or other system resources is significant, it may make\n+ * sense to defer the creation of this object until it is really needed. This is\n+ * a use case for the lazy initialization pattern.\n+ * </p>\n+ * <p>\n+ * This abstract base class provides an implementation of the double-check idiom\n+ * for an instance field as discussed in Joshua Bloch's \"Effective Java\", 2nd\n+ * edition, item 71. The class already implements all necessary synchronization.\n+ * A concrete subclass has to implement the {@code initialize()} method, which\n+ * actually creates the wrapped data object.\n+ * </p>\n+ * <p>\n+ * As an usage example consider that we have a class {@code ComplexObject} whose\n+ * instantiation is a complex operation. In order to apply lazy initialization\n+ * to this class, a subclass of {@code LazyInitializer} has to be created:\n+ *\n+ * <pre>\n+ * public class ComplexObjectInitializer extends LazyInitializer&lt;ComplexObject&gt; {\n+ *     &#064;Override\n+ *     protected ComplexObject initialize() {\n+ *         return new ComplexObject();\n+ *     }\n+ * }\n+ * </pre>\n+ *\n+ * Access to the data object is provided through the {@code get()} method. So,\n+ * code that wants to obtain the {@code ComplexObject} instance would simply\n+ * look like this:\n+ *\n+ * <pre>\n+ * // Create an instance of the lazy initializer\n+ * ComplexObjectInitializer initializer = new ComplexObjectInitializer();\n+ * ...\n+ * // When the object is actually needed:\n+ * ComplexObject cobj = initializer.get();\n+ * </pre>\n+ *\n+ * </p>\n+ * <p>\n+ * If multiple threads call the {@code get()} method when the object has not yet\n+ * been created, they are blocked until initialization completes. The algorithm\n+ * guarantees that only a single instance of the wrapped object class is\n+ * created, which is passed to all callers. Once initialized, calls to the\n+ * {@code get()} method are pretty fast because no synchronization is needed\n+ * (only an access to a <b>volatile</b> member field).\n+ * </p>\n+ *\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ * @param <T> the type of the object managed by this initializer class\n+ */\n+public abstract class LazyInitializer<T> {\n+    /** Stores the managed object. */\n+    private volatile T object;\n+\n+    /**\n+     * Returns the object wrapped by this instance. On first access the object\n+     * is created. After that it is cached and can be accessed pretty fast.\n+     *\n+     * @return the object initialized by this {@code LazyInitializer}\n+     */\n+    public T get() {\n+        // use a temporary variable to reduce the number of reads of the\n+        // volatile field\n+        T result = object;\n+\n+        if (result == null) {\n+            synchronized (this) {\n+                result = object;\n+                if (result == null) {\n+                    object = result = initialize();\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Creates and initializes the object managed by this {@code\n+     * LazyInitializer}. This method is called by {@link #get()} when the object\n+     * is accessed for the first time. An implementation can focus on the\n+     * creation of the object. No synchronization is needed, as this is already\n+     * handled by {@code get()}.\n+     *\n+     * @return the managed data object\n+     */\n+    protected abstract T initialize();\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/MultiBackgroundInitializer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.concurrent;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+\n+/**\n+ * <p>\n+ * A specialized {@link BackgroundInitializer} implementation that can deal with\n+ * multiple background initialization tasks.\n+ * </p>\n+ * <p>\n+ * This class has a similar purpose as {@link BackgroundInitializer}. However,\n+ * it is not limited to a single background initialization task. Rather it\n+ * manages an arbitrary number of {@code BackgroundInitializer} objects,\n+ * executes them, and waits until they are completely initialized. This is\n+ * useful for applications that have to perform multiple initialization tasks\n+ * that can run in parallel (i.e. that do not depend on each other). This class\n+ * takes care about the management of an {@code ExecutorService} and shares it\n+ * with the {@code BackgroundInitializer} objects it is responsible for; so the\n+ * using application need not bother with these details.\n+ * </p>\n+ * <p>\n+ * The typical usage scenario for {@code MultiBackgroundInitializer} is as\n+ * follows:\n+ * <ul>\n+ * <li>Create a new instance of the class. Optionally pass in a pre-configured\n+ * {@code ExecutorService}. Alternatively {@code MultiBackgroundInitializer} can\n+ * create a temporary {@code ExecutorService} and delete it after initialization\n+ * is complete.</li>\n+ * <li>Create specialized {@link BackgroundInitializer} objects for the\n+ * initialization tasks to be performed and add them to the {@code\n+ * MultiBackgroundInitializer} using the\n+ * {@link #addInitializer(String, BackgroundInitializer)} method.</li>\n+ * <li>After all initializers have been added, call the {@link #start()} method.\n+ * </li>\n+ * <li>When access to the result objects produced by the {@code\n+ * BackgroundInitializer} objects is needed call the {@link #get()} method. The\n+ * object returned here provides access to all result objects created during\n+ * initialization. It also stores information about exceptions that have\n+ * occurred.</li>\n+ * </ul>\n+ * </p>\n+ * <p>\n+ * {@code MultiBackgroundInitializer} starts a special controller task that\n+ * starts all {@code BackgroundInitializer} objects added to the instance.\n+ * Before the an initializer is started it is checked whether this initializer\n+ * already has an {@code ExecutorService} set. If this is the case, this {@code\n+ * ExecutorService} is used for running the background task. Otherwise the\n+ * current {@code ExecutorService} of this {@code MultiBackgroundInitializer} is\n+ * shared with the initializer.\n+ * </p>\n+ * <p>\n+ * The easiest way of using this class is to let it deal with the management of\n+ * an {@code ExecutorService} itself: If no external {@code ExecutorService} is\n+ * provided, the class creates a temporary {@code ExecutorService} (that is\n+ * capable of executing all background tasks in parallel) and destroys it at the\n+ * end of background processing.\n+ * </p>\n+ * <p>\n+ * Alternatively an external {@code ExecutorService} can be provided - either at\n+ * construction time or later by calling the\n+ * {@link #setExternalExecutor(ExecutorService)} method. In this case all\n+ * background tasks are scheduled at this external {@code ExecutorService}.\n+ * <strong>Important note:</strong> When using an external {@code\n+ * ExecutorService} be sure that the number of threads managed by the service is\n+ * large enough. Otherwise a deadlock can happen! This is the case in the\n+ * following scenario: {@code MultiBackgroundInitializer} starts a task that\n+ * starts all registered {@code BackgroundInitializer} objects and waits for\n+ * their completion. If for instance a single threaded {@code ExecutorService}\n+ * is used, none of the background tasks can be executed, and the task created\n+ * by {@code MultiBackgroundInitializer} waits forever.\n+ * </p>\n+ *\n+ * @version $Id$\n+ */\n+public class MultiBackgroundInitializer\n+        extends\n+        BackgroundInitializer<MultiBackgroundInitializer.MultiBackgroundInitializerResults> {\n+    /** A map with the child initializers. */\n+    private final Map<String, BackgroundInitializer<?>> childInitializers = new HashMap<String, BackgroundInitializer<?>>();\n+\n+    /**\n+     * Creates a new instance of {@code MultiBackgroundInitializer}.\n+     */\n+    public MultiBackgroundInitializer() {\n+        super();\n+    }\n+\n+    /**\n+     * Creates a new instance of {@code MultiBackgroundInitializer} and\n+     * initializes it with the given external {@code ExecutorService}.\n+     *\n+     * @param exec the {@code ExecutorService} for executing the background\n+     * tasks\n+     */\n+    public MultiBackgroundInitializer(ExecutorService exec) {\n+        super(exec);\n+    }\n+\n+    /**\n+     * Adds a new {@code BackgroundInitializer} to this object. When this\n+     * {@code MultiBackgroundInitializer} is started, the given initializer will\n+     * be processed. This method must not be called after {@link #start()} has\n+     * been invoked.\n+     *\n+     * @param name the name of the initializer (must not be <b>null</b>)\n+     * @param init the {@code BackgroundInitializer} to add (must not be\n+     * <b>null</b>)\n+     * @throws IllegalArgumentException if a required parameter is missing\n+     * @throws IllegalStateException if {@code start()} has already been called\n+     */\n+    public void addInitializer(String name, BackgroundInitializer<?> init) {\n+        if (name == null) {\n+            throw new IllegalArgumentException(\n+                    \"Name of child initializer must not be null!\");\n+        }\n+        if (init == null) {\n+            throw new IllegalArgumentException(\n+                    \"Child initializer must not be null!\");\n+        }\n+\n+        synchronized (this) {\n+            if (isStarted()) {\n+                throw new IllegalStateException(\n+                        \"addInitializer() must not be called after start()!\");\n+            }\n+            childInitializers.put(name, init);\n+        }\n+    }\n+\n+    /**\n+     * Returns the number of tasks needed for executing all child {@code\n+     * BackgroundInitializer} objects in parallel. This implementation sums up\n+     * the required tasks for all child initializers (which is necessary if one\n+     * of the child initializers is itself a {@code MultiBackgroundInitializer}\n+     * ). Then it adds 1 for the control task that waits for the completion of\n+     * the children.\n+     *\n+     * @return the number of tasks required for background processing\n+     */\n+    @Override\n+    protected int getTaskCount() {\n+        int result = 1;\n+\n+        for (BackgroundInitializer<?> bi : childInitializers.values()) {\n+            result += bi.getTaskCount();\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Creates the results object. This implementation starts all child {@code\n+     * BackgroundInitializer} objects. Then it collects their results and\n+     * creates a {@code MultiBackgroundInitializerResults} object with this\n+     * data. If a child initializer throws a checked exceptions, it is added to\n+     * the results object. Unchecked exceptions are propagated.\n+     *\n+     * @return the results object\n+     * @throws Exception if an error occurs\n+     */\n+    @Override\n+    protected MultiBackgroundInitializerResults initialize() throws Exception {\n+        Map<String, BackgroundInitializer<?>> inits;\n+        synchronized (this) {\n+            // create a snapshot to operate on\n+            inits = new HashMap<String, BackgroundInitializer<?>>(\n+                    childInitializers);\n+        }\n+\n+        // start the child initializers\n+        ExecutorService exec = getActiveExecutor();\n+        for (BackgroundInitializer<?> bi : inits.values()) {\n+            if (bi.getExternalExecutor() == null) {\n+                // share the executor service if necessary\n+                bi.setExternalExecutor(exec);\n+            }\n+            bi.start();\n+        }\n+\n+        // collect the results\n+        Map<String, Object> results = new HashMap<String, Object>();\n+        Map<String, ConcurrentException> excepts = new HashMap<String, ConcurrentException>();\n+        for (Map.Entry<String, BackgroundInitializer<?>> e : inits.entrySet()) {\n+            try {\n+                results.put(e.getKey(), e.getValue().get());\n+            } catch (ConcurrentException cex) {\n+                excepts.put(e.getKey(), cex);\n+            }\n+        }\n+\n+        return new MultiBackgroundInitializerResults(inits, results, excepts);\n+    }\n+\n+    /**\n+     * A data class for storing the results of the background initialization\n+     * performed by {@code MultiBackgroundInitializer}. Objects of this inner\n+     * class are returned by {@link MultiBackgroundInitializer#initialize()}.\n+     * They allow access to all result objects produced by the\n+     * {@link BackgroundInitializer} objects managed by the owning instance. It\n+     * is also possible to retrieve status information about single\n+     * {@link BackgroundInitializer}s, i.e. whether they completed normally or\n+     * caused an exception.\n+     */\n+    public static class MultiBackgroundInitializerResults {\n+        /** A map with the child initializers. */\n+        private final Map<String, BackgroundInitializer<?>> initializers;\n+\n+        /** A map with the result objects. */\n+        private final Map<String, Object> resultObjects;\n+\n+        /** A map with the exceptions. */\n+        private final Map<String, ConcurrentException> exceptions;\n+\n+        /**\n+         * Creates a new instance of {@code MultiBackgroundInitializerResults}\n+         * and initializes it with maps for the {@code BackgroundInitializer}\n+         * objects, their result objects and the exceptions thrown by them.\n+         *\n+         * @param inits the {@code BackgroundInitializer} objects\n+         * @param results the result objects\n+         * @param excepts the exceptions\n+         */\n+        private MultiBackgroundInitializerResults(\n+                Map<String, BackgroundInitializer<?>> inits,\n+                Map<String, Object> results,\n+                Map<String, ConcurrentException> excepts) {\n+            initializers = inits;\n+            resultObjects = results;\n+            exceptions = excepts;\n+        }\n+\n+        /**\n+         * Returns the {@code BackgroundInitializer} with the given name. If the\n+         * name cannot be resolved, an exception is thrown.\n+         *\n+         * @param name the name of the {@code BackgroundInitializer}\n+         * @return the {@code BackgroundInitializer} with this name\n+         * @throws NoSuchElementException if the name cannot be resolved\n+         */\n+        public BackgroundInitializer<?> getInitializer(String name) {\n+            return checkName(name);\n+        }\n+\n+        /**\n+         * Returns the result object produced by the {@code\n+         * BackgroundInitializer} with the given name. This is the object\n+         * returned by the initializer's {@code initialize()} method. If this\n+         * {@code BackgroundInitializer} caused an exception, <b>null</b> is\n+         * returned. If the name cannot be resolved, an exception is thrown.\n+         *\n+         * @param name the name of the {@code BackgroundInitializer}\n+         * @return the result object produced by this {@code\n+         * BackgroundInitializer}\n+         * @throws NoSuchElementException if the name cannot be resolved\n+         */\n+        public Object getResultObject(String name) {\n+            checkName(name);\n+            return resultObjects.get(name);\n+        }\n+\n+        /**\n+         * Returns a flag whether the {@code BackgroundInitializer} with the\n+         * given name caused an exception.\n+         *\n+         * @param name the name of the {@code BackgroundInitializer}\n+         * @return a flag whether this initializer caused an exception\n+         * @throws NoSuchElementException if the name cannot be resolved\n+         */\n+        public boolean isException(String name) {\n+            checkName(name);\n+            return exceptions.containsKey(name);\n+        }\n+\n+        /**\n+         * Returns the {@code ConcurrentException} object that was thrown by the\n+         * {@code BackgroundInitializer} with the given name. If this\n+         * initializer did not throw an exception, the return value is\n+         * <b>null</b>. If the name cannot be resolved, an exception is thrown.\n+         *\n+         * @param name the name of the {@code BackgroundInitializer}\n+         * @return the exception thrown by this initializer\n+         * @throws NoSuchElementException if the name cannot be resolved\n+         */\n+        public ConcurrentException getException(String name) {\n+            checkName(name);\n+            return exceptions.get(name);\n+        }\n+\n+        /**\n+         * Returns a set with the names of all {@code BackgroundInitializer}\n+         * objects managed by the {@code MultiBackgroundInitializer}.\n+         *\n+         * @return an (unmodifiable) set with the names of the managed {@code\n+         * BackgroundInitializer} objects\n+         */\n+        public Set<String> initializerNames() {\n+            return Collections.unmodifiableSet(initializers.keySet());\n+        }\n+\n+        /**\n+         * Checks whether an initializer with the given name exists. If not,\n+         * throws an exception. If it exists, the associated child initializer\n+         * is returned.\n+         *\n+         * @param name the name to check\n+         * @return the initializer with this name\n+         * @throws NoSuchElementException if the name is unknown\n+         */\n+        private BackgroundInitializer<?> checkName(String name) {\n+            BackgroundInitializer<?> init = initializers.get(name);\n+            if (init == null) {\n+                throw new NoSuchElementException(\n+                        \"No child initializer with name \" + name);\n+            }\n+\n+            return init;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/exception/ContextedException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.exception;\n+\n+import java.util.Set;\n+\n+/**\n+ * <p>\n+ * An exception that provides an easy and safe way to add contextual information.\n+ * </p><p>\n+ * An exception trace itself is often insufficient to provide rapid diagnosis of the issue.\n+ * Frequently what is needed is a select few pieces of local contextual data.\n+ * Providing this data is tricky however, due to concerns over formatting and nulls.\n+ * </p><p>\n+ * The contexted exception approach allows the exception to be created together with a\n+ * map of context values. This additional information is automatically included in the\n+ * message and printed stack trace.\n+ * </p><p>\n+ * An unchecked version of this exception is provided by ContextedRuntimeException.\n+ * </p>\n+ * <p>\n+ * To use this class write code as follows:\n+ * </p>\n+ * <pre>\n+ *   try {\n+ *     ...\n+ *   } catch (Throwable e) {\n+ *     throw new ContextedException(\"Error posting account transaction\", e)\n+ *          .addValue(\"accountNumber\", accountNumber)\n+ *          .addValue(\"amountPosted\", amountPosted)\n+ *          .addValue(\"previousBalance\", previousBalance)\n+ *   }\n+ * }\n+ * </pre>\n+ * </p><p>\n+ * The output in a printStacktrace() (which often is written to a log) would look something like the following:\n+ * <pre>\n+ * org.apache.commons.lang3.exception.ContextedException: java.lang.Exception: Error posting account transaction\n+ *  Exception Context:\n+ *  [accountNumber=null]\n+ *  [amountPosted=100.00]\n+ *  [previousBalance=-2.17]\n+ *\n+ *  ---------------------------------\n+ *  at org.apache.commons.lang3.exception.ContextedExceptionTest.testAddValue(ContextedExceptionTest.java:88)\n+ *  ..... (rest of trace)\n+ * </pre>\n+ * </p>\n+ * \n+ * @see ContextedRuntimeException\n+ * @author Apache Software Foundation\n+ * @author D. Ashmore\n+ * @since 3.0\n+ */\n+public class ContextedException extends Exception implements ExceptionContext {\n+\n+    /** The serialization version. */\n+    private static final long serialVersionUID = 8940917952810290164L;\n+    /** The context where the data is stored. */\n+    private final ExceptionContext exceptionContext;\n+\n+    /**\n+     * Instantiates ContextedException without message or cause.\n+     * <p>\n+     * The context information is stored using a default implementation.\n+     */\n+    public ContextedException() {\n+        super();\n+        exceptionContext = new DefaultExceptionContext();\n+    }\n+\n+    /**\n+     * Instantiates ContextedException with message, but without cause.\n+     * <p>\n+     * The context information is stored using a default implementation.\n+     * \n+     * @param message  the exception message, may be null\n+     */\n+    public ContextedException(String message) {\n+        super(message);\n+        exceptionContext = new DefaultExceptionContext();\n+    }\n+\n+    /**\n+     * Instantiates ContextedException with cause, but without message.\n+     * <p>\n+     * The context information is stored using a default implementation.\n+     * \n+     * @param cause  the underlying cause of the exception, may be null\n+     */\n+    public ContextedException(Throwable cause) {\n+        super(cause);\n+        exceptionContext = new DefaultExceptionContext();\n+    }\n+\n+    /**\n+     * Instantiates ContextedException with cause and message.\n+     * <p>\n+     * The context information is stored using a default implementation.\n+     * \n+     * @param message  the exception message, may be null\n+     * @param cause  the underlying cause of the exception, may be null\n+     */\n+    public ContextedException(String message, Throwable cause) {\n+        super(message, cause);\n+        exceptionContext = new DefaultExceptionContext();\n+    }\n+\n+    /**\n+     * Instantiates ContextedException with cause, message, and ExceptionContext.\n+     * \n+     * @param message  the exception message, may be null\n+     * @param cause  the underlying cause of the exception, may be null\n+     * @param context  the context used to store the additional information, null uses default implementation\n+     */\n+    public ContextedException(String message, Throwable cause, ExceptionContext context) {\n+        super(message, cause);\n+        if (context == null) {\n+            context = new DefaultExceptionContext();\n+        }\n+        exceptionContext = context;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds information helpful to a developer in diagnosing and correcting\n+     * the problem.  For the information to be meaningful, the value passed\n+     * should have a reasonable toString() implementation.\n+     * <p>\n+     * Note: This exception is only serializable if the object added is serializable.\n+     * \n+     * @param label  a textual label associated with information, null not recommended\n+     * @param value  information needed to understand exception, may be null\n+     * @return this, for method chaining\n+     */\n+    public ContextedException addValue(String label, Object value) {        \n+        exceptionContext.addValue(label, value);\n+        return this;\n+    }\n+\n+    /**\n+     * Retrieves a contextual data value associated with the label.\n+     * \n+     * @param label  the label to get the contextual value for, may be null\n+     * @return the contextual value associated with the label, may be null\n+     */\n+    public Object getValue(String label) {\n+        return exceptionContext.getValue(label);\n+    }\n+\n+    /**\n+     * Retrieves the labels defined in the contextual data.\n+     * \n+     * @return the set of labels, never null\n+     */\n+    public Set<String> getLabelSet() {\n+        return exceptionContext.getLabelSet();\n+    }\n+\n+    /**\n+     * Provides the message explaining the exception, including the contextual data.\n+     * \n+     * @see java.lang.Throwable#getMessage()\n+     * @return the message, never null\n+     */\n+    @Override\n+    public String getMessage(){\n+        return getFormattedExceptionMessage(super.getMessage());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public String getFormattedExceptionMessage(String baseMessage) {\n+        return exceptionContext.getFormattedExceptionMessage(baseMessage);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/exception/ContextedRuntimeException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.exception;\n+\n+import java.util.Set;\n+\n+/**\n+ * <p>\n+ * A runtime exception that provides an easy and safe way to add contextual information.\n+ * </p><p>\n+ * An exception trace itself is often insufficient to provide rapid diagnosis of the issue.\n+ * Frequently what is needed is a select few pieces of local contextual data.\n+ * Providing this data is tricky however, due to concerns over formatting and nulls.\n+ * </p><p>\n+ * The contexted exception approach allows the exception to be created together with a\n+ * map of context values. This additional information is automatically included in the\n+ * message and printed stack trace.\n+ * </p><p>\n+ * An checked version of this exception is provided by ContextedException.\n+ * </p>\n+ * <p>\n+ * To use this class write code as follows:\n+ * </p>\n+ * <pre>\n+ *   try {\n+ *     ...\n+ *   } catch (Throwable e) {\n+ *     throw new ContextedException(\"Error posting account transaction\", e)\n+ *          .addValue(\"accountNumber\", accountNumber)\n+ *          .addValue(\"amountPosted\", amountPosted)\n+ *          .addValue(\"previousBalance\", previousBalance)\n+ *   }\n+ * }\n+ * </pre>\n+ * </p><p>\n+ * The output in a printStacktrace() (which often is written to a log) would look something like the following:\n+ * <pre>\n+ * org.apache.commons.lang3.exception.ContextedRuntimeException: java.lang.Exception: Error posting account transaction\n+ *  Exception Context:\n+ *  [accountNumber=null]\n+ *  [amountPosted=100.00]\n+ *  [previousBalance=-2.17]\n+ *\n+ *  ---------------------------------\n+ *  at org.apache.commons.lang3.exception.ContextedRuntimeExceptionTest.testAddValue(ContextedExceptionTest.java:88)\n+ *  ..... (rest of trace)\n+ * </pre>\n+ * </p>\n+ * \n+ * @see ContextedException\n+ * @author Apache Software Foundation\n+ * @author D. Ashmore\n+ * @author J&ouml;rg Schaible\n+ * @since 3.0\n+ */\n+public class ContextedRuntimeException extends Exception implements ExceptionContext {\n+\n+    /** The serialization version. */\n+    private static final long serialVersionUID = 1459691936045811817L;\n+    /** The context where the data is stored. */\n+    private final ExceptionContext exceptionContext;\n+\n+    /**\n+     * Instantiates ContextedRuntimeException without message or cause.\n+     * <p>\n+     * The context information is stored using a default implementation.\n+     */\n+    public ContextedRuntimeException() {\n+        super();\n+        exceptionContext = new DefaultExceptionContext();\n+    }\n+\n+    /**\n+     * Instantiates ContextedRuntimeException with message, but without cause.\n+     * <p>\n+     * The context information is stored using a default implementation.\n+     * \n+     * @param message  the exception message, may be null\n+     */\n+    public ContextedRuntimeException(String message) {\n+        super(message);\n+        exceptionContext = new DefaultExceptionContext();\n+    }\n+\n+    /**\n+     * Instantiates ContextedRuntimeException with cause, but without message.\n+     * <p>\n+     * The context information is stored using a default implementation.\n+     * \n+     * @param cause  the underlying cause of the exception, may be null\n+     */\n+    public ContextedRuntimeException(Throwable cause) {\n+        super(cause);\n+        exceptionContext = new DefaultExceptionContext();\n+    }\n+\n+    /**\n+     * Instantiates ContextedRuntimeException with cause and message.\n+     * <p>\n+     * The context information is stored using a default implementation.\n+     * \n+     * @param message  the exception message, may be null\n+     * @param cause  the underlying cause of the exception, may be null\n+     */\n+    public ContextedRuntimeException(String message, Throwable cause) {\n+        super(message, cause);\n+        exceptionContext = new DefaultExceptionContext();\n+    }\n+\n+    /**\n+     * Instantiates ContextedRuntimeException with cause, message, and ExceptionContext.\n+     * \n+     * @param message  the exception message, may be null\n+     * @param cause  the underlying cause of the exception, may be null\n+     * @param context  the context used to store the additional information, null uses default implementation\n+     */\n+    public ContextedRuntimeException(String message, Throwable cause, ExceptionContext context) {\n+        super(message, cause);\n+        if (context == null) {\n+            context = new DefaultExceptionContext();\n+        }\n+        exceptionContext = context;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds information helpful to a developer in diagnosing and correcting\n+     * the problem.  For the information to be meaningful, the value passed\n+     * should have a reasonable toString() implementation.\n+     * <p>\n+     * Note: This exception is only serializable if the object added is serializable.\n+     * \n+     * @param label  a textual label associated with information, null not recommended\n+     * @param value  information needed to understand exception, may be null\n+     * @return this, for method chaining\n+     */\n+    public ContextedRuntimeException addValue(String label, Object value) {        \n+        exceptionContext.addValue(label, value);\n+        return this;\n+    }\n+\n+    /**\n+     * Retrieves a contextual data value associated with the label.\n+     * \n+     * @param label  the label to get the contextual value for, may be null\n+     * @return the contextual value associated with the label, may be null\n+     */\n+    public Object getValue(String label) {\n+        return exceptionContext.getValue(label);\n+    }\n+\n+    /**\n+     * Retrieves the labels defined in the contextual data.\n+     * \n+     * @return the set of labels, never null\n+     */\n+    public Set<String> getLabelSet() {\n+        return exceptionContext.getLabelSet();\n+    }\n+\n+    /**\n+     * Provides the message explaining the exception, including the contextual data.\n+     * \n+     * @see java.lang.Throwable#getMessage()\n+     * @return the message, never null\n+     */\n+    @Override\n+    public String getMessage(){\n+        return getFormattedExceptionMessage(super.getMessage());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public String getFormattedExceptionMessage(String baseMessage) {\n+        return exceptionContext.getFormattedExceptionMessage(baseMessage);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/exception/DefaultExceptionContext.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.exception;\n+\n+import java.io.Serializable;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.lang3.SystemUtils;\n+\n+/**\n+ * Default implementation of the context storing the label-value pairs for contexted exceptions.\n+ * <p>\n+ * This implementation is serializable, however this is dependent on the values that\n+ * are added also being serializable.\n+ * \n+ * @author Apache Software Foundation\n+ * @author D. Ashmore\n+ * @since 3.0\n+ */\n+class DefaultExceptionContext implements ExceptionContext, Serializable {\n+\n+    /** The serialization version. */\n+    private static final long serialVersionUID = 293747957535772807L;\n+    /** The ordered map storing the label-data pairs. */\n+    private Map<String, Object> contextValueMap = new LinkedHashMap<String, Object>();\n+\n+    /**\n+     * Adds a contextual label-value pair into this context.\n+     * <p>\n+     * This label-value pair provides information useful for debugging.\n+     * \n+     * @param label  the label of the item to add, null not recommended\n+     * @param value  the value of item to add, may be null\n+     * @return this, for method chaining\n+     */\n+    public ExceptionContext addValue(String label, Object value) {        \n+        contextValueMap.put(label, value);\n+        return this;\n+    }\n+\n+    /**\n+     * Retrieves a contextual data value associated with the label.\n+     * \n+     * @param label  the label to get the contextual value for, may be null\n+     * @return the contextual value associated with the label, may be null\n+     */\n+    public Object getValue(String label) {\n+        return contextValueMap.get(label);\n+    }\n+\n+    /**\n+     * Retrieves the labels defined in the contextual data.\n+     * \n+     * @return the set of labels, never null\n+     */\n+    public Set<String> getLabelSet() {\n+        return contextValueMap.keySet();\n+    }\n+\n+    /**\n+     * Builds the message containing the contextual information.\n+     * \n+     * @param baseMessage  the base exception message <b>without</b> context information appended\n+     * @return the exception message <b>with</b> context information appended, never null\n+     */\n+    public String getFormattedExceptionMessage(String baseMessage){\n+        StringBuilder buffer = new StringBuilder(256);\n+        if (baseMessage != null) {\n+            buffer.append(baseMessage);\n+        }\n+        \n+        if (contextValueMap.size() > 0) {\n+            if (buffer.length() > 0l) {\n+                buffer.append(SystemUtils.LINE_SEPARATOR);\n+            }\n+            buffer.append(\"Exception Context:\");\n+            buffer.append(SystemUtils.LINE_SEPARATOR); \n+            buffer.append(\"\\t\");  \n+            \n+            Object value;\n+            String valueStr;\n+            for (String label : contextValueMap.keySet()) {\n+                buffer.append(\"[\");\n+                buffer.append(label);\n+                buffer.append(\"=\");\n+                value = this.contextValueMap.get(label);\n+                if (value == null) {\n+                    buffer.append(\"null\");\n+                }\n+                else {\n+                    try {valueStr = value.toString();}\n+                    catch (Throwable t) {\n+                        valueStr = \"Excepted on toString(): \" + \n+                            ExceptionUtils.getStackTrace(t);\n+                    }\n+                    buffer.append(valueStr);\n+                }\n+                buffer.append(\"]\");\n+                buffer.append(SystemUtils.LINE_SEPARATOR);  \n+                buffer.append(\"\\t\");  \n+            }\n+            buffer.append(\"---------------------------------\");\n+        }\n+        return buffer.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/exception/ExceptionContext.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.exception;\n+\n+import java.util.Set;\n+\n+/**\n+ * Allows the storage and retrieval of contextual information based on label-value\n+ * pairs for exceptions.\n+ * \n+ * @see ContextedException\n+ * @see ContextedRuntimeException\n+ * @author Apache Software Foundation\n+ * @author D. Ashmore\n+ * @since 3.0\n+ */\n+public interface ExceptionContext {\n+\n+    /**\n+     * Adds a contextual label-value pair into this context.\n+     * <p>\n+     * This label-value pair provides information useful for debugging.\n+     * \n+     * @param label  the label of the item to add, null not recommended\n+     * @param value  the value of item to add, may be null\n+     * @return context itself to allow method chaining\n+     */\n+    public ExceptionContext addValue(String label, Object value);\n+\n+    /**\n+     * Retrieves a contextual data value associated with the label.\n+     * \n+     * @param label  the label to get the contextual value for, may be null\n+     * @return the contextual value associated with the label, may be null\n+     */\n+    public Object getValue(String label);\n+\n+    /**\n+     * Retrieves the labels defined in the contextual data.\n+     * \n+     * @return the set of labels, never null\n+     */\n+    public Set<String> getLabelSet();\n+\n+    /**\n+     * Implementors provide the given base message with context label/value item \n+     * information appended.\n+     * \n+     * @param baseMessage  the base exception message <b>without</b> context information appended\n+     * @return the exception message <b>with</b> context information appended, never null\n+     */\n+    public String getFormattedExceptionMessage(String baseMessage);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/exception/ExceptionUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.exception;\n+\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.StringTokenizer;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.commons.lang3.ClassUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.SystemUtils;\n+\n+/**\n+ * <p>Provides utilities for manipulating and examining \n+ * <code>Throwable</code> objects.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author Daniel L. Rall\n+ * @author Dmitri Plotnikov\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @author Pete Gieser\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class ExceptionUtils {\n+    \n+    /**\n+     * <p>Used when printing stack frames to denote the start of a\n+     * wrapped exception.</p>\n+     *\n+     * <p>Package private for accessibility by test suite.</p>\n+     */\n+    static final String WRAPPED_MARKER = \" [wrapped] \";\n+\n+    /**\n+     * <p>The names of methods commonly used to access a wrapped exception.</p>\n+     */\n+    // TODO: Remove in Lang 4.0\n+    private static final String[] CAUSE_METHOD_NAMES = {\n+        \"getCause\",\n+        \"getNextException\",\n+        \"getTargetException\",\n+        \"getException\",\n+        \"getSourceException\",\n+        \"getRootCause\",\n+        \"getCausedByException\",\n+        \"getNested\",\n+        \"getLinkedException\",\n+        \"getNestedException\",\n+        \"getLinkedCause\",\n+        \"getThrowable\",\n+    };\n+\n+    /**\n+     * <p>\n+     * Public constructor allows an instance of <code>ExceptionUtils</code> to be created, although that is not\n+     * normally necessary.\n+     * </p>\n+     */\n+    public ExceptionUtils() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Returns the default names used when searching for the cause of an exception.</p>\n+     *\n+     * <p>This may be modified and used in the overloaded getCause(Throwable, String[]) method.</p>\n+     *\n+     * @return cloned array of the default method names\n+     * @since 3.0\n+     * @deprecated This feature will be removed in Lang 4.0\n+     */\n+    @Deprecated\n+    public static String[] getDefaultCauseMethodNames() {\n+        return ArrayUtils.clone(CAUSE_METHOD_NAMES);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Introspects the <code>Throwable</code> to obtain the cause.</p>\n+     *\n+     * <p>The method searches for methods with specific names that return a \n+     * <code>Throwable</code> object. This will pick up most wrapping exceptions,\n+     * including those from JDK 1.4.\n+     * The method names can be added to using {@link #addCauseMethodName(String)}.</p>\n+     *\n+     * <p>The default list searched for are:</p>\n+     * <ul>\n+     *  <li><code>getCause()</code></li>\n+     *  <li><code>getNextException()</code></li>\n+     *  <li><code>getTargetException()</code></li>\n+     *  <li><code>getException()</code></li>\n+     *  <li><code>getSourceException()</code></li>\n+     *  <li><code>getRootCause()</code></li>\n+     *  <li><code>getCausedByException()</code></li>\n+     *  <li><code>getNested()</code></li>\n+     * </ul>\n+     * \n+     * <p>In the absence of any such method, the object is inspected for a\n+     * <code>detail</code> field assignable to a <code>Throwable</code>.</p>\n+     *\n+     * <p>If none of the above is found, returns <code>null</code>.</p>\n+     *\n+     * @param throwable  the throwable to introspect for a cause, may be null\n+     * @return the cause of the <code>Throwable</code>,\n+     *  <code>null</code> if none found or null throwable input\n+     * @since 1.0\n+     * @deprecated This feature will be removed in Lang 4.0\n+     */\n+    @Deprecated\n+    public static Throwable getCause(Throwable throwable) {\n+        return getCause(throwable, CAUSE_METHOD_NAMES);\n+    }\n+\n+    /**\n+     * <p>Introspects the <code>Throwable</code> to obtain the cause.</p>\n+     *\n+     * <ol>\n+     * <li>Try known exception types.</li>\n+     * <li>Try the supplied array of method names.</li>\n+     * <li>Try the field 'detail'.</li>\n+     * </ol>\n+     *\n+     * <p>A <code>null</code> set of method names means use the default set.\n+     * A <code>null</code> in the set of method names will be ignored.</p>\n+     *\n+     * @param throwable  the throwable to introspect for a cause, may be null\n+     * @param methodNames  the method names, null treated as default set\n+     * @return the cause of the <code>Throwable</code>,\n+     *  <code>null</code> if none found or null throwable input\n+     * @since 1.0\n+     * @deprecated This feature will be removed in Lang 4.0\n+     */\n+    @Deprecated\n+    public static Throwable getCause(Throwable throwable, String[] methodNames) {\n+        if (throwable == null) {\n+            return null;\n+        }\n+\n+        if (methodNames == null) {\n+            methodNames = CAUSE_METHOD_NAMES;\n+        }\n+\n+        for (int i = 0; i < methodNames.length; i++) {\n+            String methodName = methodNames[i];\n+            if (methodName != null) {\n+                Throwable cause = getCauseUsingMethodName(throwable, methodName);\n+                if (cause != null) {\n+                    return cause;\n+                }\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * <p>Introspects the <code>Throwable</code> to obtain the root cause.</p>\n+     *\n+     * <p>This method walks through the exception chain to the last element,\n+     * \"root\" of the tree, using {@link #getCause(Throwable)}, and\n+     * returns that exception.</p>\n+     *\n+     * <p>From version 2.2, this method handles recursive cause structures\n+     * that might otherwise cause infinite loops. If the throwable parameter\n+     * has a cause of itself, then null will be returned. If the throwable\n+     * parameter cause chain loops, the last element in the chain before the\n+     * loop is returned.</p>\n+     *\n+     * @param throwable  the throwable to get the root cause for, may be null\n+     * @return the root cause of the <code>Throwable</code>,\n+     *  <code>null</code> if none found or null throwable input\n+     */\n+    public static Throwable getRootCause(Throwable throwable) {\n+        List<Throwable> list = getThrowableList(throwable);\n+        return (list.size() < 2 ? null : (Throwable)list.get(list.size() - 1));\n+    }\n+\n+    /**\n+     * <p>Finds a <code>Throwable</code> by method name.</p>\n+     *\n+     * @param throwable  the exception to examine\n+     * @param methodName  the name of the method to find and invoke\n+     * @return the wrapped exception, or <code>null</code> if not found\n+     */\n+    // TODO: Remove in Lang 4.0\n+    private static Throwable getCauseUsingMethodName(Throwable throwable, String methodName) {\n+        Method method = null;\n+        try {\n+            method = throwable.getClass().getMethod(methodName, (Class[]) null);\n+        } catch (NoSuchMethodException ignored) {\n+            // exception ignored\n+        } catch (SecurityException ignored) {\n+            // exception ignored\n+        }\n+\n+        if (method != null && Throwable.class.isAssignableFrom(method.getReturnType())) {\n+            try {\n+                return (Throwable) method.invoke(throwable, ArrayUtils.EMPTY_OBJECT_ARRAY);\n+            } catch (IllegalAccessException ignored) {\n+                // exception ignored\n+            } catch (IllegalArgumentException ignored) {\n+                // exception ignored\n+            } catch (InvocationTargetException ignored) {\n+                // exception ignored\n+            }\n+        }\n+        return null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Counts the number of <code>Throwable</code> objects in the\n+     * exception chain.</p>\n+     *\n+     * <p>A throwable without cause will return <code>1</code>.\n+     * A throwable with one cause will return <code>2</code> and so on.\n+     * A <code>null</code> throwable will return <code>0</code>.</p>\n+     *\n+     * <p>From version 2.2, this method handles recursive cause structures\n+     * that might otherwise cause infinite loops. The cause chain is\n+     * processed until the end is reached, or until the next item in the\n+     * chain is already in the result set.</p>\n+     *\n+     * @param throwable  the throwable to inspect, may be null\n+     * @return the count of throwables, zero if null input\n+     */\n+    public static int getThrowableCount(Throwable throwable) {\n+        return getThrowableList(throwable).size();\n+    }\n+\n+    /**\n+     * <p>Returns the list of <code>Throwable</code> objects in the\n+     * exception chain.</p>\n+     *\n+     * <p>A throwable without cause will return an array containing\n+     * one element - the input throwable.\n+     * A throwable with one cause will return an array containing\n+     * two elements. - the input throwable and the cause throwable.\n+     * A <code>null</code> throwable will return an array of size zero.</p>\n+     *\n+     * <p>From version 2.2, this method handles recursive cause structures\n+     * that might otherwise cause infinite loops. The cause chain is\n+     * processed until the end is reached, or until the next item in the\n+     * chain is already in the result set.</p>\n+     *\n+     * @see #getThrowableList(Throwable)\n+     * @param throwable  the throwable to inspect, may be null\n+     * @return the array of throwables, never null\n+     */\n+    public static Throwable[] getThrowables(Throwable throwable) {\n+        List<Throwable> list = getThrowableList(throwable);\n+        return list.toArray(new Throwable[list.size()]);\n+    }\n+\n+    /**\n+     * <p>Returns the list of <code>Throwable</code> objects in the\n+     * exception chain.</p>\n+     *\n+     * <p>A throwable without cause will return a list containing\n+     * one element - the input throwable.\n+     * A throwable with one cause will return a list containing\n+     * two elements. - the input throwable and the cause throwable.\n+     * A <code>null</code> throwable will return a list of size zero.</p>\n+     *\n+     * <p>This method handles recursive cause structures that might\n+     * otherwise cause infinite loops. The cause chain is processed until\n+     * the end is reached, or until the next item in the chain is already\n+     * in the result set.</p>\n+     *\n+     * @param throwable  the throwable to inspect, may be null\n+     * @return the list of throwables, never null\n+     * @since Commons Lang 2.2\n+     */\n+    public static List<Throwable> getThrowableList(Throwable throwable) {\n+        List<Throwable> list = new ArrayList<Throwable>();\n+        while (throwable != null && list.contains(throwable) == false) {\n+            list.add(throwable);\n+            throwable = ExceptionUtils.getCause(throwable);\n+        }\n+        return list;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Returns the (zero based) index of the first <code>Throwable</code>\n+     * that matches the specified class (exactly) in the exception chain.\n+     * Subclasses of the specified class do not match - see\n+     * {@link #indexOfType(Throwable, Class)} for the opposite.</p>\n+     *\n+     * <p>A <code>null</code> throwable returns <code>-1</code>.\n+     * A <code>null</code> type returns <code>-1</code>.\n+     * No match in the chain returns <code>-1</code>.</p>\n+     *\n+     * @param throwable  the throwable to inspect, may be null\n+     * @param clazz  the class to search for, subclasses do not match, null returns -1\n+     * @return the index into the throwable chain, -1 if no match or null input\n+     */\n+    public static int indexOfThrowable(Throwable throwable, Class<?> clazz) {\n+        return indexOf(throwable, clazz, 0, false);\n+    }\n+\n+    /**\n+     * <p>Returns the (zero based) index of the first <code>Throwable</code>\n+     * that matches the specified type in the exception chain from\n+     * a specified index.\n+     * Subclasses of the specified class do not match - see\n+     * {@link #indexOfType(Throwable, Class, int)} for the opposite.</p>\n+     *\n+     * <p>A <code>null</code> throwable returns <code>-1</code>.\n+     * A <code>null</code> type returns <code>-1</code>.\n+     * No match in the chain returns <code>-1</code>.\n+     * A negative start index is treated as zero.\n+     * A start index greater than the number of throwables returns <code>-1</code>.</p>\n+     *\n+     * @param throwable  the throwable to inspect, may be null\n+     * @param clazz  the class to search for, subclasses do not match, null returns -1\n+     * @param fromIndex  the (zero based) index of the starting position,\n+     *  negative treated as zero, larger than chain size returns -1\n+     * @return the index into the throwable chain, -1 if no match or null input\n+     */\n+    public static int indexOfThrowable(Throwable throwable, Class<?> clazz, int fromIndex) {\n+        return indexOf(throwable, clazz, fromIndex, false);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Returns the (zero based) index of the first <code>Throwable</code>\n+     * that matches the specified class or subclass in the exception chain.\n+     * Subclasses of the specified class do match - see\n+     * {@link #indexOfThrowable(Throwable, Class)} for the opposite.</p>\n+     *\n+     * <p>A <code>null</code> throwable returns <code>-1</code>.\n+     * A <code>null</code> type returns <code>-1</code>.\n+     * No match in the chain returns <code>-1</code>.</p>\n+     *\n+     * @param throwable  the throwable to inspect, may be null\n+     * @param type  the type to search for, subclasses match, null returns -1\n+     * @return the index into the throwable chain, -1 if no match or null input\n+     * @since 2.1\n+     */\n+    public static int indexOfType(Throwable throwable, Class<?> type) {\n+        return indexOf(throwable, type, 0, true);\n+    }\n+\n+    /**\n+     * <p>Returns the (zero based) index of the first <code>Throwable</code>\n+     * that matches the specified type in the exception chain from\n+     * a specified index.\n+     * Subclasses of the specified class do match - see\n+     * {@link #indexOfThrowable(Throwable, Class)} for the opposite.</p>\n+     *\n+     * <p>A <code>null</code> throwable returns <code>-1</code>.\n+     * A <code>null</code> type returns <code>-1</code>.\n+     * No match in the chain returns <code>-1</code>.\n+     * A negative start index is treated as zero.\n+     * A start index greater than the number of throwables returns <code>-1</code>.</p>\n+     *\n+     * @param throwable  the throwable to inspect, may be null\n+     * @param type  the type to search for, subclasses match, null returns -1\n+     * @param fromIndex  the (zero based) index of the starting position,\n+     *  negative treated as zero, larger than chain size returns -1\n+     * @return the index into the throwable chain, -1 if no match or null input\n+     * @since 2.1\n+     */\n+    public static int indexOfType(Throwable throwable, Class<?> type, int fromIndex) {\n+        return indexOf(throwable, type, fromIndex, true);\n+    }\n+\n+    /**\n+     * <p>Worker method for the <code>indexOfType</code> methods.</p>\n+     *\n+     * @param throwable  the throwable to inspect, may be null\n+     * @param type  the type to search for, subclasses match, null returns -1\n+     * @param fromIndex  the (zero based) index of the starting position,\n+     *  negative treated as zero, larger than chain size returns -1\n+     * @param subclass if <code>true</code>, compares with {@link Class#isAssignableFrom(Class)}, otherwise compares\n+     * using references\n+     * @return index of the <code>type</code> within throwables nested withing the specified <code>throwable</code>\n+     */\n+    private static int indexOf(Throwable throwable, Class<?> type, int fromIndex, boolean subclass) {\n+        if (throwable == null || type == null) {\n+            return -1;\n+        }\n+        if (fromIndex < 0) {\n+            fromIndex = 0;\n+        }\n+        Throwable[] throwables = ExceptionUtils.getThrowables(throwable);\n+        if (fromIndex >= throwables.length) {\n+            return -1;\n+        }\n+        if (subclass) {\n+            for (int i = fromIndex; i < throwables.length; i++) {\n+                if (type.isAssignableFrom(throwables[i].getClass())) {\n+                    return i;\n+                }\n+            }\n+        } else {\n+            for (int i = fromIndex; i < throwables.length; i++) {\n+                if (type.equals(throwables[i].getClass())) {\n+                    return i;\n+                }\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Prints a compact stack trace for the root cause of a throwable\n+     * to <code>System.err</code>.</p>\n+     *\n+     * <p>The compact stack trace starts with the root cause and prints\n+     * stack frames up to the place where it was caught and wrapped.\n+     * Then it prints the wrapped exception and continues with stack frames\n+     * until the wrapper exception is caught and wrapped again, etc.</p>\n+     *\n+     * <p>The output of this method is consistent across JDK versions.\n+     * Note that this is the opposite order to the JDK1.4 display.</p>\n+     *\n+     * <p>The method is equivalent to <code>printStackTrace</code> for throwables\n+     * that don't have nested causes.</p>\n+     *\n+     * @param throwable  the throwable to output\n+     * @since 2.0\n+     */\n+    public static void printRootCauseStackTrace(Throwable throwable) {\n+        printRootCauseStackTrace(throwable, System.err);\n+    }\n+\n+    /**\n+     * <p>Prints a compact stack trace for the root cause of a throwable.</p>\n+     *\n+     * <p>The compact stack trace starts with the root cause and prints\n+     * stack frames up to the place where it was caught and wrapped.\n+     * Then it prints the wrapped exception and continues with stack frames\n+     * until the wrapper exception is caught and wrapped again, etc.</p>\n+     *\n+     * <p>The output of this method is consistent across JDK versions.\n+     * Note that this is the opposite order to the JDK1.4 display.</p>\n+     *\n+     * <p>The method is equivalent to <code>printStackTrace</code> for throwables\n+     * that don't have nested causes.</p>\n+     *\n+     * @param throwable  the throwable to output, may be null\n+     * @param stream  the stream to output to, may not be null\n+     * @throws IllegalArgumentException if the stream is <code>null</code>\n+     * @since 2.0\n+     */\n+    public static void printRootCauseStackTrace(Throwable throwable, PrintStream stream) {\n+        if (throwable == null) {\n+            return;\n+        }\n+        if (stream == null) {\n+            throw new IllegalArgumentException(\"The PrintStream must not be null\");\n+        }\n+        String trace[] = getRootCauseStackTrace(throwable);\n+        for (int i = 0; i < trace.length; i++) {\n+            stream.println(trace[i]);\n+        }\n+        stream.flush();\n+    }\n+\n+    /**\n+     * <p>Prints a compact stack trace for the root cause of a throwable.</p>\n+     *\n+     * <p>The compact stack trace starts with the root cause and prints\n+     * stack frames up to the place where it was caught and wrapped.\n+     * Then it prints the wrapped exception and continues with stack frames\n+     * until the wrapper exception is caught and wrapped again, etc.</p>\n+     *\n+     * <p>The output of this method is consistent across JDK versions.\n+     * Note that this is the opposite order to the JDK1.4 display.</p>\n+     *\n+     * <p>The method is equivalent to <code>printStackTrace</code> for throwables\n+     * that don't have nested causes.</p>\n+     *\n+     * @param throwable  the throwable to output, may be null\n+     * @param writer  the writer to output to, may not be null\n+     * @throws IllegalArgumentException if the writer is <code>null</code>\n+     * @since 2.0\n+     */\n+    public static void printRootCauseStackTrace(Throwable throwable, PrintWriter writer) {\n+        if (throwable == null) {\n+            return;\n+        }\n+        if (writer == null) {\n+            throw new IllegalArgumentException(\"The PrintWriter must not be null\");\n+        }\n+        String trace[] = getRootCauseStackTrace(throwable);\n+        for (int i = 0; i < trace.length; i++) {\n+            writer.println(trace[i]);\n+        }\n+        writer.flush();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Creates a compact stack trace for the root cause of the supplied\n+     * <code>Throwable</code>.</p>\n+     *\n+     * <p>The output of this method is consistent across JDK versions.\n+     * It consists of the root exception followed by each of its wrapping\n+     * exceptions separated by '[wrapped]'. Note that this is the opposite\n+     * order to the JDK1.4 display.</p>\n+     *\n+     * @param throwable  the throwable to examine, may be null\n+     * @return an array of stack trace frames, never null\n+     * @since 2.0\n+     */\n+    public static String[] getRootCauseStackTrace(Throwable throwable) {\n+        if (throwable == null) {\n+            return ArrayUtils.EMPTY_STRING_ARRAY;\n+        }\n+        Throwable throwables[] = getThrowables(throwable);\n+        int count = throwables.length;\n+        List<String> frames = new ArrayList<String>();\n+        List<String> nextTrace = getStackFrameList(throwables[count - 1]);\n+        for (int i = count; --i >= 0;) {\n+            List<String> trace = nextTrace;\n+            if (i != 0) {\n+                nextTrace = getStackFrameList(throwables[i - 1]);\n+                removeCommonFrames(trace, nextTrace);\n+            }\n+            if (i == count - 1) {\n+                frames.add(throwables[i].toString());\n+            } else {\n+                frames.add(WRAPPED_MARKER + throwables[i].toString());\n+            }\n+            for (int j = 0; j < trace.size(); j++) {\n+                frames.add(trace.get(j));\n+            }\n+        }\n+        return frames.toArray(new String[0]);\n+    }\n+\n+    /**\n+     * <p>Removes common frames from the cause trace given the two stack traces.</p>\n+     *\n+     * @param causeFrames  stack trace of a cause throwable\n+     * @param wrapperFrames  stack trace of a wrapper throwable\n+     * @throws IllegalArgumentException if either argument is null\n+     * @since 2.0\n+     */\n+    public static void removeCommonFrames(List<String> causeFrames, List<String> wrapperFrames) {\n+        if (causeFrames == null || wrapperFrames == null) {\n+            throw new IllegalArgumentException(\"The List must not be null\");\n+        }\n+        int causeFrameIndex = causeFrames.size() - 1;\n+        int wrapperFrameIndex = wrapperFrames.size() - 1;\n+        while (causeFrameIndex >= 0 && wrapperFrameIndex >= 0) {\n+            // Remove the frame from the cause trace if it is the same\n+            // as in the wrapper trace\n+            String causeFrame = causeFrames.get(causeFrameIndex);\n+            String wrapperFrame = wrapperFrames.get(wrapperFrameIndex);\n+            if (causeFrame.equals(wrapperFrame)) {\n+                causeFrames.remove(causeFrameIndex);\n+            }\n+            causeFrameIndex--;\n+            wrapperFrameIndex--;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the stack trace from a Throwable as a String.</p>\n+     *\n+     * <p>The result of this method vary by JDK version as this method\n+     * uses {@link Throwable#printStackTrace(java.io.PrintWriter)}.\n+     * On JDK1.3 and earlier, the cause exception will not be shown\n+     * unless the specified throwable alters printStackTrace.</p>\n+     *\n+     * @param throwable  the <code>Throwable</code> to be examined\n+     * @return the stack trace as generated by the exception's\n+     *  <code>printStackTrace(PrintWriter)</code> method\n+     */\n+    public static String getStackTrace(Throwable throwable) {\n+        StringWriter sw = new StringWriter();\n+        PrintWriter pw = new PrintWriter(sw, true);\n+        throwable.printStackTrace(pw);\n+        return sw.getBuffer().toString();\n+    }\n+\n+    /**\n+     * <p>Captures the stack trace associated with the specified\n+     * <code>Throwable</code> object, decomposing it into a list of\n+     * stack frames.</p>\n+     *\n+     * <p>The result of this method vary by JDK version as this method\n+     * uses {@link Throwable#printStackTrace(java.io.PrintWriter)}.\n+     * On JDK1.3 and earlier, the cause exception will not be shown\n+     * unless the specified throwable alters printStackTrace.</p>\n+     *\n+     * @param throwable  the <code>Throwable</code> to examine, may be null\n+     * @return an array of strings describing each stack frame, never null\n+     */\n+    public static String[] getStackFrames(Throwable throwable) {\n+        if (throwable == null) {\n+            return ArrayUtils.EMPTY_STRING_ARRAY;\n+        }\n+        return getStackFrames(getStackTrace(throwable));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Returns an array where each element is a line from the argument.</p>\n+     *\n+     * <p>The end of line is determined by the value of {@link SystemUtils#LINE_SEPARATOR}.</p>\n+     *\n+     * @param stackTrace  a stack trace String\n+     * @return an array where each element is a line from the argument\n+     */\n+    static String[] getStackFrames(String stackTrace) {\n+        String linebreak = SystemUtils.LINE_SEPARATOR;\n+        StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n+        List<String> list = new ArrayList<String>();\n+        while (frames.hasMoreTokens()) {\n+            list.add(frames.nextToken());\n+        }\n+        return list.toArray(new String[list.size()]);\n+    }\n+\n+    /**\n+     * <p>Produces a <code>List</code> of stack frames - the message\n+     * is not included. Only the trace of the specified exception is\n+     * returned, any caused by trace is stripped.</p>\n+     *\n+     * <p>This works in most cases - it will only fail if the exception\n+     * message contains a line that starts with:\n+     * <code>&quot;&nbsp;&nbsp;&nbsp;at&quot;.</code></p>\n+     * \n+     * @param t is any throwable\n+     * @return List of stack frames\n+     */\n+    static List<String> getStackFrameList(Throwable t) {\n+        String stackTrace = getStackTrace(t);\n+        String linebreak = SystemUtils.LINE_SEPARATOR;\n+        StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n+        List<String> list = new ArrayList<String>();\n+        boolean traceStarted = false;\n+        while (frames.hasMoreTokens()) {\n+            String token = frames.nextToken();\n+            // Determine if the line starts with <whitespace>at\n+            int at = token.indexOf(\"at\");\n+            if (at != -1 && token.substring(0, at).trim().length() == 0) {\n+                traceStarted = true;\n+                list.add(token);\n+            } else if (traceStarted) {\n+                break;\n+            }\n+        }\n+        return list;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a short message summarising the exception.\n+     * <p>\n+     * The message returned is of the form\n+     * {ClassNameWithoutPackage}: {ThrowableMessage}\n+     *\n+     * @param th  the throwable to get a message for, null returns empty string\n+     * @return the message, non-null\n+     * @since Commons Lang 2.2\n+     */\n+    public static String getMessage(Throwable th) {\n+        if (th == null) {\n+            return \"\";\n+        }\n+        String clsName = ClassUtils.getShortClassName(th, null);\n+        String msg = th.getMessage();\n+        return clsName + \": \" + StringUtils.defaultString(msg);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a short message summarising the root cause exception.\n+     * <p>\n+     * The message returned is of the form\n+     * {ClassNameWithoutPackage}: {ThrowableMessage}\n+     *\n+     * @param th  the throwable to get a message for, null returns empty string\n+     * @return the message, non-null\n+     * @since Commons Lang 2.2\n+     */\n+    public static String getRootCauseMessage(Throwable th) {\n+        Throwable root = ExceptionUtils.getRootCause(th);\n+        root = (root == null ? th : root);\n+        return getMessage(root);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/math/Fraction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.math;\n+\n+import java.math.BigInteger;\n+\n+/**\n+ * <p><code>Fraction</code> is a <code>Number</code> implementation that\n+ * stores fractions accurately.</p>\n+ *\n+ * <p>This class is immutable, and interoperable with most methods that accept\n+ * a <code>Number</code>.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author Travis Reeder\n+ * @author Tim O'Brien\n+ * @author Pete Gieser\n+ * @author C. Scott Ananian\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public final class Fraction extends Number implements Comparable<Fraction> {\n+\n+    /**\n+     * Required for serialization support. Lang version 2.0.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 65382027393090L;\n+\n+    /**\n+     * <code>Fraction</code> representation of 0.\n+     */\n+    public static final Fraction ZERO = new Fraction(0, 1);\n+    /**\n+     * <code>Fraction</code> representation of 1.\n+     */\n+    public static final Fraction ONE = new Fraction(1, 1);\n+    /**\n+     * <code>Fraction</code> representation of 1/2.\n+     */\n+    public static final Fraction ONE_HALF = new Fraction(1, 2);\n+    /**\n+     * <code>Fraction</code> representation of 1/3.\n+     */\n+    public static final Fraction ONE_THIRD = new Fraction(1, 3);\n+    /**\n+     * <code>Fraction</code> representation of 2/3.\n+     */\n+    public static final Fraction TWO_THIRDS = new Fraction(2, 3);\n+    /**\n+     * <code>Fraction</code> representation of 1/4.\n+     */\n+    public static final Fraction ONE_QUARTER = new Fraction(1, 4);\n+    /**\n+     * <code>Fraction</code> representation of 2/4.\n+     */\n+    public static final Fraction TWO_QUARTERS = new Fraction(2, 4);\n+    /**\n+     * <code>Fraction</code> representation of 3/4.\n+     */\n+    public static final Fraction THREE_QUARTERS = new Fraction(3, 4);\n+    /**\n+     * <code>Fraction</code> representation of 1/5.\n+     */\n+    public static final Fraction ONE_FIFTH = new Fraction(1, 5);\n+    /**\n+     * <code>Fraction</code> representation of 2/5.\n+     */\n+    public static final Fraction TWO_FIFTHS = new Fraction(2, 5);\n+    /**\n+     * <code>Fraction</code> representation of 3/5.\n+     */\n+    public static final Fraction THREE_FIFTHS = new Fraction(3, 5);\n+    /**\n+     * <code>Fraction</code> representation of 4/5.\n+     */\n+    public static final Fraction FOUR_FIFTHS = new Fraction(4, 5);\n+\n+\n+    /**\n+     * The numerator number part of the fraction (the three in three sevenths).\n+     */\n+    private final int numerator;\n+    /**\n+     * The denominator number part of the fraction (the seven in three sevenths).\n+     */\n+    private final int denominator;\n+\n+    /**\n+     * Cached output hashCode (class is immutable).\n+     */\n+    private transient int hashCode = 0;\n+    /**\n+     * Cached output toString (class is immutable).\n+     */\n+    private transient String toString = null;\n+    /**\n+     * Cached output toProperString (class is immutable).\n+     */\n+    private transient String toProperString = null;\n+\n+    /**\n+     * <p>Constructs a <code>Fraction</code> instance with the 2 parts\n+     * of a fraction Y/Z.</p>\n+     *\n+     * @param numerator  the numerator, for example the three in 'three sevenths'\n+     * @param denominator  the denominator, for example the seven in 'three sevenths'\n+     */\n+    private Fraction(int numerator, int denominator) {\n+        super();\n+        this.numerator = numerator;\n+        this.denominator = denominator;\n+    }\n+\n+    /**\n+     * <p>Creates a <code>Fraction</code> instance with the 2 parts\n+     * of a fraction Y/Z.</p>\n+     *\n+     * <p>Any negative signs are resolved to be on the numerator.</p>\n+     *\n+     * @param numerator  the numerator, for example the three in 'three sevenths'\n+     * @param denominator  the denominator, for example the seven in 'three sevenths'\n+     * @return a new fraction instance\n+     * @throws ArithmeticException if the denomiator is <code>zero</code>\n+     */\n+    public static Fraction getFraction(int numerator, int denominator) {\n+        if (denominator == 0) {\n+            throw new ArithmeticException(\"The denominator must not be zero\");\n+        }\n+        if (denominator < 0) {\n+            if (numerator==Integer.MIN_VALUE ||\n+                    denominator==Integer.MIN_VALUE) {\n+                throw new ArithmeticException(\"overflow: can't negate\");\n+            }\n+            numerator = -numerator;\n+            denominator = -denominator;\n+        }\n+        return new Fraction(numerator, denominator);\n+    }\n+\n+    /**\n+     * <p>Creates a <code>Fraction</code> instance with the 3 parts\n+     * of a fraction X Y/Z.</p>\n+     *\n+     * <p>The negative sign must be passed in on the whole number part.</p>\n+     *\n+     * @param whole  the whole number, for example the one in 'one and three sevenths'\n+     * @param numerator  the numerator, for example the three in 'one and three sevenths'\n+     * @param denominator  the denominator, for example the seven in 'one and three sevenths'\n+     * @return a new fraction instance\n+     * @throws ArithmeticException if the denomiator is <code>zero</code>\n+     * @throws ArithmeticException if the denominator is negative\n+     * @throws ArithmeticException if the numerator is negative\n+     * @throws ArithmeticException if the resulting numerator exceeds \n+     *  <code>Integer.MAX_VALUE</code>\n+     */\n+    public static Fraction getFraction(int whole, int numerator, int denominator) {\n+        if (denominator == 0) {\n+            throw new ArithmeticException(\"The denominator must not be zero\");\n+        }\n+        if (denominator < 0) {\n+            throw new ArithmeticException(\"The denominator must not be negative\");\n+        }\n+        if (numerator < 0) {\n+            throw new ArithmeticException(\"The numerator must not be negative\");\n+        }\n+        long numeratorValue;\n+        if (whole < 0) {\n+            numeratorValue = whole * (long)denominator - numerator;\n+        } else {\n+            numeratorValue = whole * (long)denominator + numerator;\n+        }\n+        if (numeratorValue < Integer.MIN_VALUE ||\n+                numeratorValue > Integer.MAX_VALUE)  {\n+            throw new ArithmeticException(\"Numerator too large to represent as an Integer.\");\n+        }\n+        return new Fraction((int) numeratorValue, denominator);\n+    }\n+\n+    /**\n+     * <p>Creates a reduced <code>Fraction</code> instance with the 2 parts\n+     * of a fraction Y/Z.</p>\n+     *\n+     * <p>For example, if the input parameters represent 2/4, then the created\n+     * fraction will be 1/2.</p>\n+     *\n+     * <p>Any negative signs are resolved to be on the numerator.</p>\n+     *\n+     * @param numerator  the numerator, for example the three in 'three sevenths'\n+     * @param denominator  the denominator, for example the seven in 'three sevenths'\n+     * @return a new fraction instance, with the numerator and denominator reduced\n+     * @throws ArithmeticException if the denominator is <code>zero</code>\n+     */\n+    public static Fraction getReducedFraction(int numerator, int denominator) {\n+        if (denominator == 0) {\n+            throw new ArithmeticException(\"The denominator must not be zero\");\n+        }\n+        if (numerator==0) {\n+            return ZERO; // normalize zero.\n+        }\n+        // allow 2^k/-2^31 as a valid fraction (where k>0)\n+        if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {\n+            numerator/=2; denominator/=2;\n+        }\n+        if (denominator < 0) {\n+            if (numerator==Integer.MIN_VALUE ||\n+                    denominator==Integer.MIN_VALUE) {\n+                throw new ArithmeticException(\"overflow: can't negate\");\n+            }\n+            numerator = -numerator;\n+            denominator = -denominator;\n+        }\n+        // simplify fraction.\n+        int gcd = greatestCommonDivisor(numerator, denominator);\n+        numerator /= gcd;\n+        denominator /= gcd;\n+        return new Fraction(numerator, denominator);\n+    }\n+\n+    /**\n+     * <p>Creates a <code>Fraction</code> instance from a <code>double</code> value.</p>\n+     *\n+     * <p>This method uses the <a href=\"http://archives.math.utk.edu/articles/atuyl/confrac/\">\n+     *  continued fraction algorithm</a>, computing a maximum of\n+     *  25 convergents and bounding the denominator by 10,000.</p>\n+     *\n+     * @param value  the double value to convert\n+     * @return a new fraction instance that is close to the value\n+     * @throws ArithmeticException if <code>|value| > Integer.MAX_VALUE</code> \n+     *  or <code>value = NaN</code>\n+     * @throws ArithmeticException if the calculated denominator is <code>zero</code>\n+     * @throws ArithmeticException if the the algorithm does not converge\n+     */\n+    public static Fraction getFraction(double value) {\n+        int sign = (value < 0 ? -1 : 1);\n+        value = Math.abs(value);\n+        if (value  > Integer.MAX_VALUE || Double.isNaN(value)) {\n+            throw new ArithmeticException\n+                (\"The value must not be greater than Integer.MAX_VALUE or NaN\");\n+        }\n+        int wholeNumber = (int) value;\n+        value -= wholeNumber;\n+        \n+        int numer0 = 0;  // the pre-previous\n+        int denom0 = 1;  // the pre-previous\n+        int numer1 = 1;  // the previous\n+        int denom1 = 0;  // the previous\n+        int numer2 = 0;  // the current, setup in calculation\n+        int denom2 = 0;  // the current, setup in calculation\n+        int a1 = (int) value;\n+        int a2 = 0;\n+        double x1 = 1;\n+        double x2 = 0;\n+        double y1 = value - a1;\n+        double y2 = 0;\n+        double delta1, delta2 = Double.MAX_VALUE;\n+        double fraction;\n+        int i = 1;\n+//        System.out.println(\"---\");\n+        do {\n+            delta1 = delta2;\n+            a2 = (int) (x1 / y1);\n+            x2 = y1;\n+            y2 = x1 - a2 * y1;\n+            numer2 = a1 * numer1 + numer0;\n+            denom2 = a1 * denom1 + denom0;\n+            fraction = (double) numer2 / (double) denom2;\n+            delta2 = Math.abs(value - fraction);\n+//            System.out.println(numer2 + \" \" + denom2 + \" \" + fraction + \" \" + delta2 + \" \" + y1);\n+            a1 = a2;\n+            x1 = x2;\n+            y1 = y2;\n+            numer0 = numer1;\n+            denom0 = denom1;\n+            numer1 = numer2;\n+            denom1 = denom2;\n+            i++;\n+//            System.out.println(\">>\" + delta1 +\" \"+ delta2+\" \"+(delta1 > delta2)+\" \"+i+\" \"+denom2);\n+        } while ((delta1 > delta2) && (denom2 <= 10000) && (denom2 > 0) && (i < 25));\n+        if (i == 25) {\n+            throw new ArithmeticException(\"Unable to convert double to fraction\");\n+        }\n+        return getReducedFraction((numer0 + wholeNumber * denom0) * sign, denom0);\n+    }\n+\n+    /**\n+     * <p>Creates a Fraction from a <code>String</code>.</p>\n+     *\n+     * <p>The formats accepted are:</p>\n+     *\n+     * <ol>\n+     *  <li><code>double</code> String containing a dot</li>\n+     *  <li>'X Y/Z'</li>\n+     *  <li>'Y/Z'</li>\n+     *  <li>'X' (a simple whole number)</li>\n+     * </ol>\n+     * and a .</p>\n+     *\n+     * @param str  the string to parse, must not be <code>null</code>\n+     * @return the new <code>Fraction</code> instance\n+     * @throws IllegalArgumentException if the string is <code>null</code>\n+     * @throws NumberFormatException if the number format is invalid\n+     */\n+    public static Fraction getFraction(String str) {\n+        if (str == null) {\n+            throw new IllegalArgumentException(\"The string must not be null\");\n+        }\n+        // parse double format\n+        int pos = str.indexOf('.');\n+        if (pos >= 0) {\n+            return getFraction(Double.parseDouble(str));\n+        }\n+\n+        // parse X Y/Z format\n+        pos = str.indexOf(' ');\n+        if (pos > 0) {\n+            int whole = Integer.parseInt(str.substring(0, pos));\n+            str = str.substring(pos + 1);\n+            pos = str.indexOf('/');\n+            if (pos < 0) {\n+                throw new NumberFormatException(\"The fraction could not be parsed as the format X Y/Z\");\n+            } else {\n+                int numer = Integer.parseInt(str.substring(0, pos));\n+                int denom = Integer.parseInt(str.substring(pos + 1));\n+                return getFraction(whole, numer, denom);\n+            }\n+        }\n+\n+        // parse Y/Z format\n+        pos = str.indexOf('/');\n+        if (pos < 0) {\n+            // simple whole number\n+            return getFraction(Integer.parseInt(str), 1);\n+        } else {\n+            int numer = Integer.parseInt(str.substring(0, pos));\n+            int denom = Integer.parseInt(str.substring(pos + 1));\n+            return getFraction(numer, denom);\n+        }\n+    }\n+\n+    // Accessors\n+    //-------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the numerator part of the fraction.</p>\n+     *\n+     * <p>This method may return a value greater than the denominator, an\n+     * improper fraction, such as the seven in 7/4.</p>\n+     *\n+     * @return the numerator fraction part\n+     */\n+    public int getNumerator() {\n+        return numerator;\n+    }\n+\n+    /**\n+     * <p>Gets the denominator part of the fraction.</p>\n+     *\n+     * @return the denominator fraction part\n+     */\n+    public int getDenominator() {\n+        return denominator;\n+    }\n+\n+    /**\n+     * <p>Gets the proper numerator, always positive.</p>\n+     *\n+     * <p>An improper fraction 7/4 can be resolved into a proper one, 1 3/4.\n+     * This method returns the 3 from the proper fraction.</p>\n+     *\n+     * <p>If the fraction is negative such as -7/4, it can be resolved into\n+     * -1 3/4, so this method returns the positive proper numerator, 3.</p>\n+     *\n+     * @return the numerator fraction part of a proper fraction, always positive\n+     */\n+    public int getProperNumerator() {\n+        return Math.abs(numerator % denominator);\n+    }\n+\n+    /**\n+     * <p>Gets the proper whole part of the fraction.</p>\n+     *\n+     * <p>An improper fraction 7/4 can be resolved into a proper one, 1 3/4.\n+     * This method returns the 1 from the proper fraction.</p>\n+     *\n+     * <p>If the fraction is negative such as -7/4, it can be resolved into\n+     * -1 3/4, so this method returns the positive whole part -1.</p>\n+     *\n+     * @return the whole fraction part of a proper fraction, that includes the sign\n+     */\n+    public int getProperWhole() {\n+        return numerator / denominator;\n+    }\n+\n+    // Number methods\n+    //-------------------------------------------------------------------\n+\n+    /**\n+     * <p>Gets the fraction as an <code>int</code>. This returns the whole number\n+     * part of the fraction.</p>\n+     *\n+     * @return the whole number fraction part\n+     */\n+    @Override\n+    public int intValue() {\n+        return numerator / denominator;\n+    }\n+\n+    /**\n+     * <p>Gets the fraction as a <code>long</code>. This returns the whole number\n+     * part of the fraction.</p>\n+     *\n+     * @return the whole number fraction part\n+     */\n+    @Override\n+    public long longValue() {\n+        return (long) numerator / denominator;\n+    }\n+\n+    /**\n+     * <p>Gets the fraction as a <code>float</code>. This calculates the fraction\n+     * as the numerator divided by denominator.</p>\n+     *\n+     * @return the fraction as a <code>float</code>\n+     */\n+    @Override\n+    public float floatValue() {\n+        return ((float) numerator) / ((float) denominator);\n+    }\n+\n+    /**\n+     * <p>Gets the fraction as a <code>double</code>. This calculates the fraction\n+     * as the numerator divided by denominator.</p>\n+     *\n+     * @return the fraction as a <code>double</code>\n+     */\n+    @Override\n+    public double doubleValue() {\n+        return ((double) numerator) / ((double) denominator);\n+    }\n+\n+    // Calculations\n+    //-------------------------------------------------------------------\n+\n+    /**\n+     * <p>Reduce the fraction to the smallest values for the numerator and\n+     * denominator, returning the result.</p>\n+     * \n+     * <p>For example, if this fraction represents 2/4, then the result\n+     * will be 1/2.</p>\n+     *\n+     * @return a new reduced fraction instance, or this if no simplification possible\n+     */\n+    public Fraction reduce() {\n+        if (numerator == 0) {\n+            return equals(ZERO) ? this : ZERO;\n+        }\n+        int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n+        if (gcd == 1) {\n+            return this;\n+        }\n+        return Fraction.getFraction(numerator / gcd, denominator / gcd);\n+    }\n+\n+    /**\n+     * <p>Gets a fraction that is the inverse (1/fraction) of this one.</p>\n+     * \n+     * <p>The returned fraction is not reduced.</p>\n+     *\n+     * @return a new fraction instance with the numerator and denominator\n+     *         inverted.\n+     * @throws ArithmeticException if the fraction represents zero.\n+     */\n+    public Fraction invert() {\n+        if (numerator == 0) {\n+            throw new ArithmeticException(\"Unable to invert zero.\");\n+        }\n+        if (numerator==Integer.MIN_VALUE) {\n+            throw new ArithmeticException(\"overflow: can't negate numerator\");\n+        }\n+        if (numerator<0) {\n+            return new Fraction(-denominator, -numerator);\n+        } else {\n+            return new Fraction(denominator, numerator);\n+        }\n+    }\n+\n+    /**\n+     * <p>Gets a fraction that is the negative (-fraction) of this one.</p>\n+     *\n+     * <p>The returned fraction is not reduced.</p>\n+     *\n+     * @return a new fraction instance with the opposite signed numerator\n+     */\n+    public Fraction negate() {\n+        // the positive range is one smaller than the negative range of an int.\n+        if (numerator==Integer.MIN_VALUE) {\n+            throw new ArithmeticException(\"overflow: too large to negate\");\n+        }\n+        return new Fraction(-numerator, denominator);\n+    }\n+\n+    /**\n+     * <p>Gets a fraction that is the positive equivalent of this one.</p>\n+     * <p>More precisely: <code>(fraction >= 0 ? this : -fraction)</code></p>\n+     *\n+     * <p>The returned fraction is not reduced.</p>\n+     *\n+     * @return <code>this</code> if it is positive, or a new positive fraction\n+     *  instance with the opposite signed numerator\n+     */\n+    public Fraction abs() {\n+        if (numerator >= 0) {\n+            return this;\n+        }\n+        return negate();\n+    }\n+\n+    /**\n+     * <p>Gets a fraction that is raised to the passed in power.</p>\n+     *\n+     * <p>The returned fraction is in reduced form.</p>\n+     *\n+     * @param power  the power to raise the fraction to\n+     * @return <code>this</code> if the power is one, <code>ONE</code> if the power\n+     * is zero (even if the fraction equals ZERO) or a new fraction instance \n+     * raised to the appropriate power\n+     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n+     *  <code>Integer.MAX_VALUE</code>\n+     */\n+    public Fraction pow(int power) {\n+        if (power == 1) {\n+            return this;\n+        } else if (power == 0) {\n+            return ONE;\n+        } else if (power < 0) {\n+            if (power==Integer.MIN_VALUE) { // MIN_VALUE can't be negated.\n+                return this.invert().pow(2).pow(-(power/2));\n+            }\n+            return this.invert().pow(-power);\n+        } else {\n+            Fraction f = this.multiplyBy(this);\n+            if ((power % 2) == 0) { // if even...\n+                return f.pow(power/2);\n+            } else { // if odd...\n+                return f.pow(power/2).multiplyBy(this);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Gets the greatest common divisor of the absolute value of\n+     * two numbers, using the \"binary gcd\" method which avoids\n+     * division and modulo operations.  See Knuth 4.5.2 algorithm B.\n+     * This algorithm is due to Josef Stein (1961).</p>\n+     *\n+     * @param u  a non-zero number\n+     * @param v  a non-zero number\n+     * @return the greatest common divisor, never zero\n+     */\n+    private static int greatestCommonDivisor(int u, int v) {\n+        //if either op. is abs 0 or 1, return 1:\n+        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+            return 1;\n+        }\n+        // keep u and v negative, as negative integers range down to\n+        // -2^31, while positive numbers can only be as large as 2^31-1\n+        // (i.e. we can't necessarily negate a negative number without\n+        // overflow)\n+        if (u>0) { u=-u; } // make u negative\n+        if (v>0) { v=-v; } // make v negative\n+        // B1. [Find power of 2]\n+        int k=0;\n+        while ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...\n+            u/=2; v/=2; k++; // cast out twos.\n+        }\n+        if (k==31) {\n+            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n+        }\n+        // B2. Initialize: u and v have been divided by 2^k and at least\n+        //     one is odd.\n+        int t = ((u&1)==1) ? v : -(u/2)/*B3*/;\n+        // t negative: u was odd, v may be even (t replaces v)\n+        // t positive: u was even, v is odd (t replaces u)\n+        do {\n+            /* assert u<0 && v<0; */\n+            // B4/B3: cast out twos from t.\n+            while ((t&1)==0) { // while t is even..\n+                t/=2; // cast out twos\n+            }\n+            // B5 [reset max(u,v)]\n+            if (t>0) {\n+                u = -t;\n+            } else {\n+                v = t;\n+            }\n+            // B6/B3. at this point both u and v should be odd.\n+            t = (v - u)/2;\n+            // |u| larger: t positive (replace u)\n+            // |v| larger: t negative (replace v)\n+        } while (t!=0);\n+        return -u*(1<<k); // gcd is u*2^k\n+    }\n+\n+    // Arithmetic\n+    //-------------------------------------------------------------------\n+\n+    /** \n+     * Multiply two integers, checking for overflow.\n+     * \n+     * @param x a factor\n+     * @param y a factor\n+     * @return the product <code>x*y</code>\n+     * @throws ArithmeticException if the result can not be represented as\n+     *                             an int\n+     */\n+    private static int mulAndCheck(int x, int y) {\n+        long m = ((long)x)*((long)y);\n+        if (m < Integer.MIN_VALUE ||\n+            m > Integer.MAX_VALUE) {\n+            throw new ArithmeticException(\"overflow: mul\");\n+        }\n+        return (int)m;\n+    }\n+    \n+    /**\n+     *  Multiply two non-negative integers, checking for overflow.\n+     * \n+     * @param x a non-negative factor\n+     * @param y a non-negative factor\n+     * @return the product <code>x*y</code>\n+     * @throws ArithmeticException if the result can not be represented as\n+     * an int\n+     */\n+    private static int mulPosAndCheck(int x, int y) {\n+        /* assert x>=0 && y>=0; */\n+        long m = ((long)x)*((long)y);\n+        if (m > Integer.MAX_VALUE) {\n+            throw new ArithmeticException(\"overflow: mulPos\");\n+        }\n+        return (int)m;\n+    }\n+    \n+    /** \n+     * Add two integers, checking for overflow.\n+     * \n+     * @param x an addend\n+     * @param y an addend\n+     * @return the sum <code>x+y</code>\n+     * @throws ArithmeticException if the result can not be represented as\n+     * an int\n+     */\n+    private static int addAndCheck(int x, int y) {\n+        long s = (long)x+(long)y;\n+        if (s < Integer.MIN_VALUE ||\n+            s > Integer.MAX_VALUE) {\n+            throw new ArithmeticException(\"overflow: add\");\n+        }\n+        return (int)s;\n+    }\n+    \n+    /** \n+     * Subtract two integers, checking for overflow.\n+     * \n+     * @param x the minuend\n+     * @param y the subtrahend\n+     * @return the difference <code>x-y</code>\n+     * @throws ArithmeticException if the result can not be represented as\n+     * an int\n+     */\n+    private static int subAndCheck(int x, int y) {\n+        long s = (long)x-(long)y;\n+        if (s < Integer.MIN_VALUE ||\n+            s > Integer.MAX_VALUE) {\n+            throw new ArithmeticException(\"overflow: add\");\n+        }\n+        return (int)s;\n+    }\n+    \n+    /**\n+     * <p>Adds the value of this fraction to another, returning the result in reduced form.\n+     * The algorithm follows Knuth, 4.5.1.</p>\n+     *\n+     * @param fraction  the fraction to add, must not be <code>null</code>\n+     * @return a <code>Fraction</code> instance with the resulting values\n+     * @throws IllegalArgumentException if the fraction is <code>null</code>\n+     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n+     *  <code>Integer.MAX_VALUE</code>\n+     */\n+    public Fraction add(Fraction fraction) {\n+        return addSub(fraction, true /* add */);\n+    }\n+\n+    /**\n+     * <p>Subtracts the value of another fraction from the value of this one, \n+     * returning the result in reduced form.</p>\n+     *\n+     * @param fraction  the fraction to subtract, must not be <code>null</code>\n+     * @return a <code>Fraction</code> instance with the resulting values\n+     * @throws IllegalArgumentException if the fraction is <code>null</code>\n+     * @throws ArithmeticException if the resulting numerator or denominator\n+     *   cannot be represented in an <code>int</code>.\n+     */\n+    public Fraction subtract(Fraction fraction) {\n+        return addSub(fraction, false /* subtract */);\n+    }\n+\n+    /** \n+     * Implement add and subtract using algorithm described in Knuth 4.5.1.\n+     * \n+     * @param fraction the fraction to subtract, must not be <code>null</code>\n+     * @param isAdd true to add, false to subtract\n+     * @return a <code>Fraction</code> instance with the resulting values\n+     * @throws IllegalArgumentException if the fraction is <code>null</code>\n+     * @throws ArithmeticException if the resulting numerator or denominator\n+     *   cannot be represented in an <code>int</code>.\n+     */\n+    private Fraction addSub(Fraction fraction, boolean isAdd) {\n+        if (fraction == null) {\n+            throw new IllegalArgumentException(\"The fraction must not be null\");\n+        }\n+        // zero is identity for addition.\n+        if (numerator == 0) {\n+            return isAdd ? fraction : fraction.negate();\n+        }\n+        if (fraction.numerator == 0) {\n+            return this;\n+        }     \n+        // if denominators are randomly distributed, d1 will be 1 about 61%\n+        // of the time.\n+        int d1 = greatestCommonDivisor(denominator, fraction.denominator);\n+        if (d1==1) {\n+            // result is ( (u*v' +/- u'v) / u'v')\n+            int uvp = mulAndCheck(numerator, fraction.denominator);\n+            int upv = mulAndCheck(fraction.numerator, denominator);\n+            return new Fraction\n+                (isAdd ? addAndCheck(uvp, upv) : subAndCheck(uvp, upv),\n+                 mulPosAndCheck(denominator, fraction.denominator));\n+        }\n+        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n+        // exercise 7.  we're going to use a BigInteger.\n+        // t = u(v'/d1) +/- v(u'/d1)\n+        BigInteger uvp = BigInteger.valueOf(numerator)\n+            .multiply(BigInteger.valueOf(fraction.denominator/d1));\n+        BigInteger upv = BigInteger.valueOf(fraction.numerator)\n+            .multiply(BigInteger.valueOf(denominator/d1));\n+        BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv);\n+        // but d2 doesn't need extra precision because\n+        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n+        int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n+        int d2 = (tmodd1==0)?d1:greatestCommonDivisor(tmodd1, d1);\n+\n+        // result is (t/d2) / (u'/d1)(v'/d2)\n+        BigInteger w = t.divide(BigInteger.valueOf(d2));\n+        if (w.bitLength() > 31) {\n+            throw new ArithmeticException\n+                (\"overflow: numerator too large after multiply\");\n+        }\n+        return new Fraction\n+            (w.intValue(),\n+             mulPosAndCheck(denominator/d1, fraction.denominator/d2));\n+    }\n+\n+    /**\n+     * <p>Multiplies the value of this fraction by another, returning the \n+     * result in reduced form.</p>\n+     *\n+     * @param fraction  the fraction to multiply by, must not be <code>null</code>\n+     * @return a <code>Fraction</code> instance with the resulting values\n+     * @throws IllegalArgumentException if the fraction is <code>null</code>\n+     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n+     *  <code>Integer.MAX_VALUE</code>\n+     */\n+    public Fraction multiplyBy(Fraction fraction) {\n+        if (fraction == null) {\n+            throw new IllegalArgumentException(\"The fraction must not be null\");\n+        }\n+        if (numerator == 0 || fraction.numerator == 0) {\n+            return ZERO;\n+        }\n+        // knuth 4.5.1\n+        // make sure we don't overflow unless the result *must* overflow.\n+        int d1 = greatestCommonDivisor(numerator, fraction.denominator);\n+        int d2 = greatestCommonDivisor(fraction.numerator, denominator);\n+        return getReducedFraction\n+            (mulAndCheck(numerator/d1, fraction.numerator/d2),\n+             mulPosAndCheck(denominator/d2, fraction.denominator/d1));\n+    }\n+\n+    /**\n+     * <p>Divide the value of this fraction by another.</p>\n+     *\n+     * @param fraction  the fraction to divide by, must not be <code>null</code>\n+     * @return a <code>Fraction</code> instance with the resulting values\n+     * @throws IllegalArgumentException if the fraction is <code>null</code>\n+     * @throws ArithmeticException if the fraction to divide by is zero\n+     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n+     *  <code>Integer.MAX_VALUE</code>\n+     */\n+    public Fraction divideBy(Fraction fraction) {\n+        if (fraction == null) {\n+            throw new IllegalArgumentException(\"The fraction must not be null\");\n+        }\n+        if (fraction.numerator == 0) {\n+            throw new ArithmeticException(\"The fraction to divide by must not be zero\");\n+        }\n+        return multiplyBy(fraction.invert());\n+    }\n+\n+    // Basics\n+    //-------------------------------------------------------------------\n+\n+    /**\n+     * <p>Compares this fraction to another object to test if they are equal.</p>.\n+     *\n+     * <p>To be equal, both values must be equal. Thus 2/4 is not equal to 1/2.</p>\n+     *\n+     * @param obj the reference object with which to compare\n+     * @return <code>true</code> if this object is equal\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof Fraction == false) {\n+            return false;\n+        }\n+        Fraction other = (Fraction) obj;\n+        return (getNumerator() == other.getNumerator() &&\n+                getDenominator() == other.getDenominator());\n+    }\n+\n+    /**\n+     * <p>Gets a hashCode for the fraction.</p>\n+     *\n+     * @return a hash code value for this object\n+     */\n+    @Override\n+    public int hashCode() {\n+        if (hashCode == 0) {\n+            // hashcode update should be atomic.\n+            hashCode = 37 * (37 * 17 + getNumerator()) + getDenominator();\n+        }\n+        return hashCode;\n+    }\n+\n+    /**\n+     * <p>Compares this object to another based on size.</p>\n+     *\n+     * <p>Note: this class has a natural ordering that is inconsistent\n+     * with equals, because, for example, equals treats 1/2 and 2/4 as\n+     * different, whereas compareTo treats them as equal.\n+     *\n+     * @param other  the object to compare to\n+     * @return -1 if this is less, 0 if equal, +1 if greater\n+     * @throws ClassCastException if the object is not a <code>Fraction</code>\n+     * @throws NullPointerException if the object is <code>null</code>\n+     */\n+    public int compareTo(Fraction other) {\n+        if (this==other) {\n+            return 0;\n+        }\n+        if (numerator == other.numerator && denominator == other.denominator) {\n+            return 0;\n+        }\n+\n+        // otherwise see which is less\n+        long first = (long) numerator * (long) other.denominator;\n+        long second = (long) other.numerator * (long) denominator;\n+        if (first == second) {\n+            return 0;\n+        } else if (first < second) {\n+            return -1;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    /**\n+     * <p>Gets the fraction as a <code>String</code>.</p>\n+     *\n+     * <p>The format used is '<i>numerator</i>/<i>denominator</i>' always.\n+     *\n+     * @return a <code>String</code> form of the fraction\n+     */\n+    @Override\n+    public String toString() {\n+        if (toString == null) {\n+            toString = new StringBuilder(32)\n+                .append(getNumerator())\n+                .append('/')\n+                .append(getDenominator()).toString();\n+        }\n+        return toString;\n+    }\n+\n+    /**\n+     * <p>Gets the fraction as a proper <code>String</code> in the format X Y/Z.</p>\n+     *\n+     * <p>The format used in '<i>wholeNumber</i> <i>numerator</i>/<i>denominator</i>'.\n+     * If the whole number is zero it will be ommitted. If the numerator is zero,\n+     * only the whole number is returned.</p>\n+     *\n+     * @return a <code>String</code> form of the fraction\n+     */\n+    public String toProperString() {\n+        if (toProperString == null) {\n+            if (numerator == 0) {\n+                toProperString = \"0\";\n+            } else if (numerator == denominator) {\n+                toProperString = \"1\";\n+            } else if (numerator == -1 * denominator) {\n+                toProperString = \"-1\";\n+            } else if ((numerator>0?-numerator:numerator) < -denominator) {\n+                // note that we do the magnitude comparison test above with\n+                // NEGATIVE (not positive) numbers, since negative numbers\n+                // have a larger range.  otherwise numerator==Integer.MIN_VALUE\n+                // is handled incorrectly.\n+                int properNumerator = getProperNumerator();\n+                if (properNumerator == 0) {\n+                    toProperString = Integer.toString(getProperWhole());\n+                } else {\n+                    toProperString = new StringBuilder(32)\n+                        .append(getProperWhole()).append(' ')\n+                        .append(properNumerator).append('/')\n+                        .append(getDenominator()).toString();\n+                }\n+            } else {\n+                toProperString = new StringBuilder(32)\n+                    .append(getNumerator()).append('/')\n+                    .append(getDenominator()).toString();\n+            }\n+        }\n+        return toProperString;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/math/IEEE754rUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.math;\n+\n+/**\n+ * <p>Provides IEEE-754r variants of NumberUtils methods. </p>\n+ *\n+ * <p>See: <a href=\"http://en.wikipedia.org/wiki/IEEE_754r\">http://en.wikipedia.org/wiki/IEEE_754r</a></p>\n+ *\n+ * @since 2.4\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class IEEE754rUtils {\n+    \n+     /**\n+     * <p>Returns the minimum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     */\n+    public static double min(double[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+    \n+        // Finds and returns min\n+        double min = array[0];\n+        for (int i = 1; i < array.length; i++) {\n+            min = min(array[i], min);\n+        }\n+    \n+        return min;\n+    }\n+\n+    /**\n+     * <p>Returns the minimum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     */\n+    public static float min(float[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+    \n+        // Finds and returns min\n+        float min = array[0];\n+        for (int i = 1; i < array.length; i++) {\n+            min = min(array[i], min);\n+        }\n+    \n+        return min;\n+    }\n+\n+    /**\n+     * <p>Gets the minimum of three <code>double</code> values.</p>\n+     * \n+     * <p>NaN is only returned if all numbers are NaN as per IEEE-754r. </p>\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the smallest of the values\n+     */\n+    public static double min(double a, double b, double c) {\n+        return min(min(a, b), c);\n+    }\n+\n+    /**\n+     * <p>Gets the minimum of two <code>double</code> values.</p>\n+     * \n+     * <p>NaN is only returned if all numbers are NaN as per IEEE-754r. </p>\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @return  the smallest of the values\n+     */\n+    public static double min(double a, double b) {\n+        if(Double.isNaN(a)) {\n+            return b;\n+        } else\n+        if(Double.isNaN(b)) {\n+            return a;\n+        } else {\n+            return Math.min(a, b);\n+        }\n+    }\n+\n+    /**\n+     * <p>Gets the minimum of three <code>float</code> values.</p>\n+     * \n+     * <p>NaN is only returned if all numbers are NaN as per IEEE-754r. </p>\n+     *\n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the smallest of the values\n+     */\n+    public static float min(float a, float b, float c) {\n+        return min(min(a, b), c);\n+    }\n+\n+    /**\n+     * <p>Gets the minimum of two <code>float</code> values.</p>\n+     * \n+     * <p>NaN is only returned if all numbers are NaN as per IEEE-754r. </p>\n+     *\n+     * @param a  value 1\n+     * @param b  value 2\n+     * @return  the smallest of the values\n+     */\n+    public static float min(float a, float b) {\n+        if(Float.isNaN(a)) {\n+            return b;\n+        } else\n+        if(Float.isNaN(b)) {\n+            return a;\n+        } else {\n+            return Math.min(a, b);\n+        }\n+    }\n+\n+    /**\n+     * <p>Returns the maximum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     */\n+    public static double max(double[] array) {\n+        // Validates input\n+        if (array== null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+    \n+        // Finds and returns max\n+        double max = array[0];\n+        for (int j = 1; j < array.length; j++) {\n+            max = max(array[j], max);\n+        }\n+    \n+        return max;\n+    }\n+\n+    /**\n+     * <p>Returns the maximum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     */\n+    public static float max(float[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+\n+        // Finds and returns max\n+        float max = array[0];\n+        for (int j = 1; j < array.length; j++) {\n+            max = max(array[j], max);\n+        }\n+\n+        return max;\n+    }\n+     \n+    /**\n+     * <p>Gets the maximum of three <code>double</code> values.</p>\n+     * \n+     * <p>NaN is only returned if all numbers are NaN as per IEEE-754r. </p>\n+     *\n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the largest of the values\n+     */\n+    public static double max(double a, double b, double c) {\n+        return max(max(a, b), c);\n+    }\n+\n+    /**\n+     * <p>Gets the maximum of two <code>double</code> values.</p>\n+     * \n+     * <p>NaN is only returned if all numbers are NaN as per IEEE-754r. </p>\n+     *\n+     * @param a  value 1\n+     * @param b  value 2\n+     * @return  the largest of the values\n+     */\n+    public static double max(double a, double b) {\n+        if(Double.isNaN(a)) {\n+            return b;\n+        } else\n+        if(Double.isNaN(b)) {\n+            return a;\n+        } else {\n+            return Math.max(a, b);\n+        }\n+    }\n+\n+    /**\n+     * <p>Gets the maximum of three <code>float</code> values.</p>\n+     * \n+     * <p>NaN is only returned if all numbers are NaN as per IEEE-754r. </p>\n+     *\n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the largest of the values\n+     */\n+    public static float max(float a, float b, float c) {\n+        return max(max(a, b), c);\n+    }\n+\n+    /**\n+     * <p>Gets the maximum of two <code>float</code> values.</p>\n+     * \n+     * <p>NaN is only returned if all numbers are NaN as per IEEE-754r. </p>\n+     *\n+     * @param a  value 1\n+     * @param b  value 2\n+     * @return  the largest of the values\n+     */\n+    public static float max(float a, float b) {\n+        if(Float.isNaN(a)) {\n+            return b;\n+        } else\n+        if(Float.isNaN(b)) {\n+            return a;\n+        } else {\n+            return Math.max(a, b);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.math;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+/**\n+ * <p>Provides extra functionality for Java Number classes.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author <a href=\"mailto:rand_mcneely@yahoo.com\">Rand McNeely</a>\n+ * @author <a href=\"mailto:steve.downey@netfolio.com\">Steve Downey</a>\n+ * @author Eric Pugh\n+ * @author Phil Steitz\n+ * @author Matthew Hawthorne\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @author <a href=\"mailto:fredrik@westermarck.com\">Fredrik Westermarck</a>\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class NumberUtils {\n+    \n+    /** Reusable Long constant for zero. */\n+    public static final Long LONG_ZERO = new Long(0L);\n+    /** Reusable Long constant for one. */\n+    public static final Long LONG_ONE = new Long(1L);\n+    /** Reusable Long constant for minus one. */\n+    public static final Long LONG_MINUS_ONE = new Long(-1L);\n+    /** Reusable Integer constant for zero. */\n+    public static final Integer INTEGER_ZERO = new Integer(0);\n+    /** Reusable Integer constant for one. */\n+    public static final Integer INTEGER_ONE = new Integer(1);\n+    /** Reusable Integer constant for minus one. */\n+    public static final Integer INTEGER_MINUS_ONE = new Integer(-1);\n+    /** Reusable Short constant for zero. */\n+    public static final Short SHORT_ZERO = new Short((short) 0);\n+    /** Reusable Short constant for one. */\n+    public static final Short SHORT_ONE = new Short((short) 1);\n+    /** Reusable Short constant for minus one. */\n+    public static final Short SHORT_MINUS_ONE = new Short((short) -1);\n+    /** Reusable Byte constant for zero. */\n+    public static final Byte BYTE_ZERO = Byte.valueOf((byte) 0);\n+    /** Reusable Byte constant for one. */\n+    public static final Byte BYTE_ONE = Byte.valueOf((byte) 1);\n+    /** Reusable Byte constant for minus one. */\n+    public static final Byte BYTE_MINUS_ONE = Byte.valueOf((byte) -1);\n+    /** Reusable Double constant for zero. */\n+    public static final Double DOUBLE_ZERO = new Double(0.0d);\n+    /** Reusable Double constant for one. */\n+    public static final Double DOUBLE_ONE = new Double(1.0d);\n+    /** Reusable Double constant for minus one. */\n+    public static final Double DOUBLE_MINUS_ONE = new Double(-1.0d);\n+    /** Reusable Float constant for zero. */\n+    public static final Float FLOAT_ZERO = new Float(0.0f);\n+    /** Reusable Float constant for one. */\n+    public static final Float FLOAT_ONE = new Float(1.0f);\n+    /** Reusable Float constant for minus one. */\n+    public static final Float FLOAT_MINUS_ONE = new Float(-1.0f);\n+\n+    /**\n+     * <p><code>NumberUtils</code> instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as <code>NumberUtils.toInt(\"6\");</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n+     */\n+    public NumberUtils() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Convert a <code>String</code> to an <code>int</code>, returning\n+     * <code>zero</code> if the conversion fails.</p>\n+     *\n+     * <p>If the string is <code>null</code>, <code>zero</code> is returned.</p>\n+     *\n+     * <pre>\n+     *   NumberUtils.toInt(null) = 0\n+     *   NumberUtils.toInt(\"\")   = 0\n+     *   NumberUtils.toInt(\"1\")  = 1\n+     * </pre>\n+     *\n+     * @param str  the string to convert, may be null\n+     * @return the int represented by the string, or <code>zero</code> if\n+     *  conversion fails\n+     * @since 2.1\n+     */\n+    public static int toInt(String str) {\n+        return toInt(str, 0);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to an <code>int</code>, returning a\n+     * default value if the conversion fails.</p>\n+     *\n+     * <p>If the string is <code>null</code>, the default value is returned.</p>\n+     *\n+     * <pre>\n+     *   NumberUtils.toInt(null, 1) = 1\n+     *   NumberUtils.toInt(\"\", 1)   = 1\n+     *   NumberUtils.toInt(\"1\", 0)  = 1\n+     * </pre>\n+     *\n+     * @param str  the string to convert, may be null\n+     * @param defaultValue  the default value\n+     * @return the int represented by the string, or the default if conversion fails\n+     * @since 2.1\n+     */\n+    public static int toInt(String str, int defaultValue) {\n+        if(str == null) {\n+            return defaultValue;\n+        }\n+        try {\n+            return Integer.parseInt(str);\n+        } catch (NumberFormatException nfe) {\n+            return defaultValue;\n+        }\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>long</code>, returning\n+     * <code>zero</code> if the conversion fails.</p>\n+     *\n+     * <p>If the string is <code>null</code>, <code>zero</code> is returned.</p>\n+     *\n+     * <pre>\n+     *   NumberUtils.toLong(null) = 0L\n+     *   NumberUtils.toLong(\"\")   = 0L\n+     *   NumberUtils.toLong(\"1\")  = 1L\n+     * </pre>\n+     *\n+     * @param str  the string to convert, may be null\n+     * @return the long represented by the string, or <code>0</code> if\n+     *  conversion fails\n+     * @since 2.1\n+     */\n+    public static long toLong(String str) {\n+        return toLong(str, 0L);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>long</code>, returning a\n+     * default value if the conversion fails.</p>\n+     *\n+     * <p>If the string is <code>null</code>, the default value is returned.</p>\n+     *\n+     * <pre>\n+     *   NumberUtils.toLong(null, 1L) = 1L\n+     *   NumberUtils.toLong(\"\", 1L)   = 1L\n+     *   NumberUtils.toLong(\"1\", 0L)  = 1L\n+     * </pre>\n+     *\n+     * @param str  the string to convert, may be null\n+     * @param defaultValue  the default value\n+     * @return the long represented by the string, or the default if conversion fails\n+     * @since 2.1\n+     */\n+    public static long toLong(String str, long defaultValue) {\n+        if (str == null) {\n+            return defaultValue;\n+        }\n+        try {\n+            return Long.parseLong(str);\n+        } catch (NumberFormatException nfe) {\n+            return defaultValue;\n+        }\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>float</code>, returning\n+     * <code>0.0f</code> if the conversion fails.</p>\n+     *\n+     * <p>If the string <code>str</code> is <code>null</code>,\n+     * <code>0.0f</code> is returned.</p>\n+     *\n+     * <pre>\n+     *   NumberUtils.toFloat(null)   = 0.0f\n+     *   NumberUtils.toFloat(\"\")     = 0.0f\n+     *   NumberUtils.toFloat(\"1.5\")  = 1.5f\n+     * </pre>\n+     *\n+     * @param str the string to convert, may be <code>null</code>\n+     * @return the float represented by the string, or <code>0.0f</code>\n+     *  if conversion fails\n+     * @since 2.1\n+     */\n+    public static float toFloat(String str) {\n+        return toFloat(str, 0.0f);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>float</code>, returning a\n+     * default value if the conversion fails.</p>\n+     *\n+     * <p>If the string <code>str</code> is <code>null</code>, the default\n+     * value is returned.</p>\n+     *\n+     * <pre>\n+     *   NumberUtils.toFloat(null, 1.1f)   = 1.0f\n+     *   NumberUtils.toFloat(\"\", 1.1f)     = 1.1f\n+     *   NumberUtils.toFloat(\"1.5\", 0.0f)  = 1.5f\n+     * </pre>\n+     *\n+     * @param str the string to convert, may be <code>null</code>\n+     * @param defaultValue the default value\n+     * @return the float represented by the string, or defaultValue\n+     *  if conversion fails\n+     * @since 2.1\n+     */\n+    public static float toFloat(String str, float defaultValue) {\n+      if (str == null) {\n+          return defaultValue;\n+      }     \n+      try {\n+          return Float.parseFloat(str);\n+      } catch (NumberFormatException nfe) {\n+          return defaultValue;\n+      }\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>double</code>, returning\n+     * <code>0.0d</code> if the conversion fails.</p>\n+     *\n+     * <p>If the string <code>str</code> is <code>null</code>,\n+     * <code>0.0d</code> is returned.</p>\n+     *\n+     * <pre>\n+     *   NumberUtils.toDouble(null)   = 0.0d\n+     *   NumberUtils.toDouble(\"\")     = 0.0d\n+     *   NumberUtils.toDouble(\"1.5\")  = 1.5d\n+     * </pre>\n+     *\n+     * @param str the string to convert, may be <code>null</code>\n+     * @return the double represented by the string, or <code>0.0d</code>\n+     *  if conversion fails\n+     * @since 2.1\n+     */\n+    public static double toDouble(String str) {\n+        return toDouble(str, 0.0d);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>double</code>, returning a\n+     * default value if the conversion fails.</p>\n+     *\n+     * <p>If the string <code>str</code> is <code>null</code>, the default\n+     * value is returned.</p>\n+     *\n+     * <pre>\n+     *   NumberUtils.toDouble(null, 1.1d)   = 1.1d\n+     *   NumberUtils.toDouble(\"\", 1.1d)     = 1.1d\n+     *   NumberUtils.toDouble(\"1.5\", 0.0d)  = 1.5d\n+     * </pre>\n+     *\n+     * @param str the string to convert, may be <code>null</code>\n+     * @param defaultValue the default value\n+     * @return the double represented by the string, or defaultValue\n+     *  if conversion fails\n+     * @since 2.1\n+     */\n+    public static double toDouble(String str, double defaultValue) {\n+      if (str == null) {\n+          return defaultValue;\n+      }\n+      try {\n+          return Double.parseDouble(str);\n+      } catch (NumberFormatException nfe) {\n+          return defaultValue;\n+      }\n+    }\n+\n+     //-----------------------------------------------------------------------\n+     /**\n+     * <p>Convert a <code>String</code> to a <code>byte</code>, returning\n+     * <code>zero</code> if the conversion fails.</p>\n+     *\n+     * <p>If the string is <code>null</code>, <code>zero</code> is returned.</p>\n+     *\n+     * <pre>\n+     *   NumberUtils.toByte(null) = 0\n+     *   NumberUtils.toByte(\"\")   = 0\n+     *   NumberUtils.toByte(\"1\")  = 1\n+     * </pre>\n+     *\n+     * @param str  the string to convert, may be null\n+     * @return the byte represented by the string, or <code>zero</code> if\n+     *  conversion fails\n+     */\n+    public static byte toByte(String str) {\n+        return toByte(str, (byte) 0);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>byte</code>, returning a\n+     * default value if the conversion fails.</p>\n+     *\n+     * <p>If the string is <code>null</code>, the default value is returned.</p>\n+     *\n+     * <pre>\n+     *   NumberUtils.toByte(null, 1) = 1\n+     *   NumberUtils.toByte(\"\", 1)   = 1\n+     *   NumberUtils.toByte(\"1\", 0)  = 1\n+     * </pre>\n+     *\n+     * @param str  the string to convert, may be null\n+     * @param defaultValue  the default value\n+     * @return the byte represented by the string, or the default if conversion fails\n+     */\n+    public static byte toByte(String str, byte defaultValue) {\n+        if(str == null) {\n+            return defaultValue;\n+        }\n+        try {\n+            return Byte.parseByte(str);\n+        } catch (NumberFormatException nfe) {\n+            return defaultValue;\n+        }\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>short</code>, returning\n+     * <code>zero</code> if the conversion fails.</p>\n+     *\n+     * <p>If the string is <code>null</code>, <code>zero</code> is returned.</p>\n+     *\n+     * <pre>\n+     *   NumberUtils.toShort(null) = 0\n+     *   NumberUtils.toShort(\"\")   = 0\n+     *   NumberUtils.toShort(\"1\")  = 1\n+     * </pre>\n+     *\n+     * @param str  the string to convert, may be null\n+     * @return the short represented by the string, or <code>zero</code> if\n+     *  conversion fails\n+     */\n+    public static short toShort(String str) {\n+        return toShort(str, (short) 0);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to an <code>short</code>, returning a\n+     * default value if the conversion fails.</p>\n+     *\n+     * <p>If the string is <code>null</code>, the default value is returned.</p>\n+     *\n+     * <pre>\n+     *   NumberUtils.toShort(null, 1) = 1\n+     *   NumberUtils.toShort(\"\", 1)   = 1\n+     *   NumberUtils.toShort(\"1\", 0)  = 1\n+     * </pre>\n+     *\n+     * @param str  the string to convert, may be null\n+     * @param defaultValue  the default value\n+     * @return the short represented by the string, or the default if conversion fails\n+     */\n+    public static short toShort(String str, short defaultValue) {\n+        if(str == null) {\n+            return defaultValue;\n+        }\n+        try {\n+            return Short.parseShort(str);\n+        } catch (NumberFormatException nfe) {\n+            return defaultValue;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    // must handle Long, Float, Integer, Float, Short,\n+    //                  BigDecimal, BigInteger and Byte\n+    // useful methods:\n+    // Byte.decode(String)\n+    // Byte.valueOf(String,int radix)\n+    // Byte.valueOf(String)\n+    // Double.valueOf(String)\n+    // Float.valueOf(String)\n+    // new Float(String)\n+    // Integer.valueOf(String,int radix)\n+    // Integer.valueOf(String)\n+    // Integer.decode(String)\n+    // Integer.getInteger(String)\n+    // Integer.getInteger(String,int val)\n+    // Integer.getInteger(String,Integer val)\n+    // new Integer(String)\n+    // new Double(String)\n+    // new Byte(String)\n+    // new Long(String)\n+    // Long.getLong(String)\n+    // Long.getLong(String,int)\n+    // Long.getLong(String,Integer)\n+    // Long.valueOf(String,int)\n+    // Long.valueOf(String)\n+    // new Short(String)\n+    // Short.decode(String)\n+    // Short.valueOf(String,int)\n+    // Short.valueOf(String)\n+    // new BigDecimal(String)\n+    // new BigInteger(String)\n+    // new BigInteger(String,int radix)\n+    // Possible inputs:\n+    // 45 45.5 45E7 4.5E7 Hex Oct Binary xxxF xxxD xxxf xxxd\n+    // plus minus everything. Prolly more. A lot are not separable.\n+\n+    /**\n+     * <p>Turns a string value into a java.lang.Number.</p>\n+     *\n+     * <p>First, the value is examined for a type qualifier on the end\n+     * (<code>'f','F','d','D','l','L'</code>).  If it is found, it starts \n+     * trying to create successively larger types from the type specified\n+     * until one is found that can represent the value.</p>\n+     *\n+     * <p>If a type specifier is not found, it will check for a decimal point\n+     * and then try successively larger types from <code>Integer</code> to\n+     * <code>BigInteger</code> and from <code>Float</code> to\n+     * <code>BigDecimal</code>.</p>\n+     *\n+     * <p>If the string starts with <code>0x</code> or <code>-0x</code>, it\n+     * will be interpreted as a hexadecimal integer.  Values with leading\n+     * <code>0</code>'s will not be interpreted as octal.</p>\n+     *\n+     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n+     *\n+     * <p>This method does not trim the input string, i.e., strings with leading\n+     * or trailing spaces will generate NumberFormatExceptions.</p>\n+     *\n+     * @param str  String containing a number, may be null\n+     * @return Number created from the string\n+     * @throws NumberFormatException if the value cannot be converted\n+     */\n+    public static Number createNumber(String str) throws NumberFormatException {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (StringUtils.isBlank(str)) {\n+            throw new NumberFormatException(\"A blank string is not a valid number\");\n+        }  \n+        if (str.startsWith(\"--\")) {\n+            // this is protection for poorness in java.lang.BigDecimal.\n+            // it accepts this as a legal value, but it does not appear \n+            // to be in specification of class. OS X Java parses it to \n+            // a wrong value.\n+            return null;\n+        }\n+        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+            return createInteger(str);\n+        }   \n+        char lastChar = str.charAt(str.length() - 1);\n+        String mant;\n+        String dec;\n+        String exp;\n+        int decPos = str.indexOf('.');\n+        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n+\n+        if (decPos > -1) {\n+\n+            if (expPos > -1) {\n+                if (expPos < decPos) {\n+                    throw new NumberFormatException(str + \" is not a valid number.\");\n+                }\n+                dec = str.substring(decPos + 1, expPos);\n+            } else {\n+                dec = str.substring(decPos + 1);\n+            }\n+            mant = str.substring(0, decPos);\n+        } else {\n+            if (expPos > -1) {\n+                mant = str.substring(0, expPos);\n+            } else {\n+                mant = str;\n+            }\n+            dec = null;\n+        }\n+        if (!Character.isDigit(lastChar) && lastChar != '.') {\n+            if (expPos > -1 && expPos < str.length() - 1) {\n+                exp = str.substring(expPos + 1, str.length() - 1);\n+            } else {\n+                exp = null;\n+            }\n+            //Requesting a specific type..\n+            String numeric = str.substring(0, str.length() - 1);\n+            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n+            switch (lastChar) {\n+                case 'l' :\n+                case 'L' :\n+                    if (dec == null\n+                        && exp == null\n+                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n+                        try {\n+                            return createLong(numeric);\n+                        } catch (NumberFormatException nfe) {\n+                            //Too big for a long\n+                        }\n+                        return createBigInteger(numeric);\n+\n+                    }\n+                    throw new NumberFormatException(str + \" is not a valid number.\");\n+                case 'f' :\n+                case 'F' :\n+                    try {\n+                        Float f = NumberUtils.createFloat(numeric);\n+                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n+                            //If it's too big for a float or the float value = 0 and the string\n+                            //has non-zeros in it, then float does not have the precision we want\n+                            return f;\n+                        }\n+\n+                    } catch (NumberFormatException nfe) {\n+                        // ignore the bad number\n+                    }\n+                    //$FALL-THROUGH$\n+                case 'd' :\n+                case 'D' :\n+                    try {\n+                        Double d = NumberUtils.createDouble(numeric);\n+                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n+                            return d;\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        // ignore the bad number\n+                    }\n+                    try {\n+                        return createBigDecimal(numeric);\n+                    } catch (NumberFormatException e) {\n+                        // ignore the bad number\n+                    }\n+                    //$FALL-THROUGH$\n+                default :\n+                    throw new NumberFormatException(str + \" is not a valid number.\");\n+\n+            }\n+        } else {\n+            //User doesn't have a preference on the return type, so let's start\n+            //small and go from there...\n+            if (expPos > -1 && expPos < str.length() - 1) {\n+                exp = str.substring(expPos + 1, str.length());\n+            } else {\n+                exp = null;\n+            }\n+            if (dec == null && exp == null) {\n+                //Must be an int,long,bigint\n+                try {\n+                    return createInteger(str);\n+                } catch (NumberFormatException nfe) {\n+                    // ignore the bad number\n+                }\n+                try {\n+                    return createLong(str);\n+                } catch (NumberFormatException nfe) {\n+                    // ignore the bad number\n+                }\n+                return createBigInteger(str);\n+\n+            } else {\n+                //Must be a float,double,BigDec\n+                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n+                try {\n+                    Float f = createFloat(str);\n+                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n+                        return f;\n+                    }\n+                } catch (NumberFormatException nfe) {\n+                    // ignore the bad number\n+                }\n+                try {\n+                    Double d = createDouble(str);\n+                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n+                        return d;\n+                    }\n+                } catch (NumberFormatException nfe) {\n+                    // ignore the bad number\n+                }\n+\n+                return createBigDecimal(str);\n+\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Utility method for {@link #createNumber(java.lang.String)}.</p>\n+     *\n+     * <p>Returns <code>true</code> if s is <code>null</code>.</p>\n+     * \n+     * @param str  the String to check\n+     * @return if it is all zeros or <code>null</code>\n+     */\n+    private static boolean isAllZeros(String str) {\n+        if (str == null) {\n+            return true;\n+        }\n+        for (int i = str.length() - 1; i >= 0; i--) {\n+            if (str.charAt(i) != '0') {\n+                return false;\n+            }\n+        }\n+        return str.length() > 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>Float</code>.</p>\n+     *\n+     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n+     * \n+     * @param str  a <code>String</code> to convert, may be null\n+     * @return converted <code>Float</code>\n+     * @throws NumberFormatException if the value cannot be converted\n+     */\n+    public static Float createFloat(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        return Float.valueOf(str);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>Double</code>.</p>\n+     * \n+     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n+     *\n+     * @param str  a <code>String</code> to convert, may be null\n+     * @return converted <code>Double</code>\n+     * @throws NumberFormatException if the value cannot be converted\n+     */\n+    public static Double createDouble(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        return Double.valueOf(str);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>Integer</code>, handling\n+     * hex and octal notations.</p>\n+     *\n+     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n+     * \n+     * @param str  a <code>String</code> to convert, may be null\n+     * @return converted <code>Integer</code>\n+     * @throws NumberFormatException if the value cannot be converted\n+     */\n+    public static Integer createInteger(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        // decode() handles 0xAABD and 0777 (hex and octal) as well.\n+        return Integer.decode(str);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>Long</code>.</p>\n+     * \n+     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n+     *\n+     * @param str  a <code>String</code> to convert, may be null\n+     * @return converted <code>Long</code>\n+     * @throws NumberFormatException if the value cannot be converted\n+     */\n+    public static Long createLong(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        return Long.valueOf(str);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>BigInteger</code>.</p>\n+     *\n+     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n+     * \n+     * @param str  a <code>String</code> to convert, may be null\n+     * @return converted <code>BigInteger</code>\n+     * @throws NumberFormatException if the value cannot be converted\n+     */\n+    public static BigInteger createBigInteger(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        return new BigInteger(str);\n+    }\n+\n+    /**\n+     * <p>Convert a <code>String</code> to a <code>BigDecimal</code>.</p>\n+     * \n+     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n+     *\n+     * @param str  a <code>String</code> to convert, may be null\n+     * @return converted <code>BigDecimal</code>\n+     * @throws NumberFormatException if the value cannot be converted\n+     */\n+    public static BigDecimal createBigDecimal(String str) {\n+        if (str == null) {\n+            return null;\n+        }\n+        // handle JDK1.3.1 bug where \"\" throws IndexOutOfBoundsException\n+        if (StringUtils.isBlank(str)) {\n+            throw new NumberFormatException(\"A blank string is not a valid number\");\n+        }  \n+        return new BigDecimal(str);\n+    }\n+\n+    // Min in array\n+    //--------------------------------------------------------------------\n+    /**\n+     * <p>Returns the minimum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     */\n+    public static long min(long[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+    \n+        // Finds and returns min\n+        long min = array[0];\n+        for (int i = 1; i < array.length; i++) {\n+            if (array[i] < min) {\n+                min = array[i];\n+            }\n+        }\n+    \n+        return min;\n+    }\n+\n+    /**\n+     * <p>Returns the minimum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     */\n+    public static int min(int[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+    \n+        // Finds and returns min\n+        int min = array[0];\n+        for (int j = 1; j < array.length; j++) {\n+            if (array[j] < min) {\n+                min = array[j];\n+            }\n+        }\n+    \n+        return min;\n+    }\n+\n+    /**\n+     * <p>Returns the minimum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     */\n+    public static short min(short[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+    \n+        // Finds and returns min\n+        short min = array[0];\n+        for (int i = 1; i < array.length; i++) {\n+            if (array[i] < min) {\n+                min = array[i];\n+            }\n+        }\n+    \n+        return min;\n+    }\n+\n+    /**\n+     * <p>Returns the minimum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     */\n+    public static byte min(byte[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+    \n+        // Finds and returns min\n+        byte min = array[0];\n+        for (int i = 1; i < array.length; i++) {\n+            if (array[i] < min) {\n+                min = array[i];\n+            }\n+        }\n+    \n+        return min;\n+    }\n+\n+     /**\n+     * <p>Returns the minimum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     * @see IEEE754rUtils#min(double[]) IEEE754rUtils for a version of this method that handles NaN differently\n+     */\n+    public static double min(double[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+    \n+        // Finds and returns min\n+        double min = array[0];\n+        for (int i = 1; i < array.length; i++) {\n+            if (Double.isNaN(array[i])) {\n+                return Double.NaN;\n+            }\n+            if (array[i] < min) {\n+                min = array[i];\n+            }\n+        }\n+    \n+        return min;\n+    }\n+\n+    /**\n+     * <p>Returns the minimum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     * @see IEEE754rUtils#min(float[]) IEEE754rUtils for a version of this method that handles NaN differently\n+     */\n+    public static float min(float[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+    \n+        // Finds and returns min\n+        float min = array[0];\n+        for (int i = 1; i < array.length; i++) {\n+            if (Float.isNaN(array[i])) {\n+                return Float.NaN;\n+            }\n+            if (array[i] < min) {\n+                min = array[i];\n+            }\n+        }\n+    \n+        return min;\n+    }\n+\n+    // Max in array\n+    //--------------------------------------------------------------------\n+    /**\n+     * <p>Returns the maximum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     */\n+    public static long max(long[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+\n+        // Finds and returns max\n+        long max = array[0];\n+        for (int j = 1; j < array.length; j++) {\n+            if (array[j] > max) {\n+                max = array[j];\n+            }\n+        }\n+\n+        return max;\n+    }\n+\n+    /**\n+     * <p>Returns the maximum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     */\n+    public static int max(int[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+    \n+        // Finds and returns max\n+        int max = array[0];\n+        for (int j = 1; j < array.length; j++) {\n+            if (array[j] > max) {\n+                max = array[j];\n+            }\n+        }\n+    \n+        return max;\n+    }\n+\n+    /**\n+     * <p>Returns the maximum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     */\n+    public static short max(short[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+    \n+        // Finds and returns max\n+        short max = array[0];\n+        for (int i = 1; i < array.length; i++) {\n+            if (array[i] > max) {\n+                max = array[i];\n+            }\n+        }\n+    \n+        return max;\n+    }\n+\n+    /**\n+     * <p>Returns the maximum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     */\n+    public static byte max(byte[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+    \n+        // Finds and returns max\n+        byte max = array[0];\n+        for (int i = 1; i < array.length; i++) {\n+            if (array[i] > max) {\n+                max = array[i];\n+            }\n+        }\n+    \n+        return max;\n+    }\n+\n+    /**\n+     * <p>Returns the maximum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     * @see IEEE754rUtils#max(double[]) IEEE754rUtils for a version of this method that handles NaN differently\n+     */\n+    public static double max(double[] array) {\n+        // Validates input\n+        if (array== null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+    \n+        // Finds and returns max\n+        double max = array[0];\n+        for (int j = 1; j < array.length; j++) {\n+            if (Double.isNaN(array[j])) {\n+                return Double.NaN;\n+            }\n+            if (array[j] > max) {\n+                max = array[j];\n+            }\n+        }\n+    \n+        return max;\n+    }\n+\n+    /**\n+     * <p>Returns the maximum value in an array.</p>\n+     * \n+     * @param array  an array, must not be null or empty\n+     * @return the minimum value in the array\n+     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n+     * @throws IllegalArgumentException if <code>array</code> is empty\n+     * @see IEEE754rUtils#max(float[]) IEEE754rUtils for a version of this method that handles NaN differently\n+     */\n+    public static float max(float[] array) {\n+        // Validates input\n+        if (array == null) {\n+            throw new IllegalArgumentException(\"The Array must not be null\");\n+        } else if (array.length == 0) {\n+            throw new IllegalArgumentException(\"Array cannot be empty.\");\n+        }\n+\n+        // Finds and returns max\n+        float max = array[0];\n+        for (int j = 1; j < array.length; j++) {\n+            if (Float.isNaN(array[j])) {\n+                return Float.NaN;\n+            }\n+            if (array[j] > max) {\n+                max = array[j];\n+            }\n+        }\n+\n+        return max;\n+    }\n+     \n+    // 3 param min\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the minimum of three <code>long</code> values.</p>\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the smallest of the values\n+     */\n+    public static long min(long a, long b, long c) {\n+        if (b < a) {\n+            a = b;\n+        }\n+        if (c < a) {\n+            a = c;\n+        }\n+        return a;\n+    }\n+\n+    /**\n+     * <p>Gets the minimum of three <code>int</code> values.</p>\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the smallest of the values\n+     */\n+    public static int min(int a, int b, int c) {\n+        if (b < a) {\n+            a = b;\n+        }\n+        if (c < a) {\n+            a = c;\n+        }\n+        return a;\n+    }\n+\n+    /**\n+     * <p>Gets the minimum of three <code>short</code> values.</p>\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the smallest of the values\n+     */\n+    public static short min(short a, short b, short c) {\n+        if (b < a) {\n+            a = b;\n+        }\n+        if (c < a) {\n+            a = c;\n+        }\n+        return a;\n+    }\n+\n+    /**\n+     * <p>Gets the minimum of three <code>byte</code> values.</p>\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the smallest of the values\n+     */\n+    public static byte min(byte a, byte b, byte c) {\n+        if (b < a) {\n+            a = b;\n+        }\n+        if (c < a) {\n+            a = c;\n+        }\n+        return a;\n+    }\n+\n+    /**\n+     * <p>Gets the minimum of three <code>double</code> values.</p>\n+     * \n+     * <p>If any value is <code>NaN</code>, <code>NaN</code> is\n+     * returned. Infinity is handled.</p>\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the smallest of the values\n+     * @see IEEE754rUtils#min(double, double, double) for a version of this method that handles NaN differently\n+     */\n+    public static double min(double a, double b, double c) {\n+        return Math.min(Math.min(a, b), c);\n+    }\n+\n+    /**\n+     * <p>Gets the minimum of three <code>float</code> values.</p>\n+     * \n+     * <p>If any value is <code>NaN</code>, <code>NaN</code> is\n+     * returned. Infinity is handled.</p>\n+     *\n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the smallest of the values\n+     * @see IEEE754rUtils#min(float, float, float) for a version of this method that handles NaN differently\n+     */\n+    public static float min(float a, float b, float c) {\n+        return Math.min(Math.min(a, b), c);\n+    }\n+\n+    // 3 param max\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the maximum of three <code>long</code> values.</p>\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the largest of the values\n+     */\n+    public static long max(long a, long b, long c) {\n+        if (b > a) {\n+            a = b;\n+        }\n+        if (c > a) {\n+            a = c;\n+        }\n+        return a;\n+    }\n+\n+    /**\n+     * <p>Gets the maximum of three <code>int</code> values.</p>\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the largest of the values\n+     */\n+    public static int max(int a, int b, int c) {\n+        if (b > a) {\n+            a = b;\n+        }\n+        if (c > a) {\n+            a = c;\n+        }\n+        return a;\n+    }\n+\n+    /**\n+     * <p>Gets the maximum of three <code>short</code> values.</p>\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the largest of the values\n+     */\n+    public static short max(short a, short b, short c) {\n+        if (b > a) {\n+            a = b;\n+        }\n+        if (c > a) {\n+            a = c;\n+        }\n+        return a;\n+    }\n+\n+    /**\n+     * <p>Gets the maximum of three <code>byte</code> values.</p>\n+     * \n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the largest of the values\n+     */\n+    public static byte max(byte a, byte b, byte c) {\n+        if (b > a) {\n+            a = b;\n+        }\n+        if (c > a) {\n+            a = c;\n+        }\n+        return a;\n+    }\n+\n+    /**\n+     * <p>Gets the maximum of three <code>double</code> values.</p>\n+     * \n+     * <p>If any value is <code>NaN</code>, <code>NaN</code> is\n+     * returned. Infinity is handled.</p>\n+     *\n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the largest of the values\n+     * @see IEEE754rUtils#max(double, double, double) for a version of this method that handles NaN differently\n+     */\n+    public static double max(double a, double b, double c) {\n+        return Math.max(Math.max(a, b), c);\n+    }\n+\n+    /**\n+     * <p>Gets the maximum of three <code>float</code> values.</p>\n+     * \n+     * <p>If any value is <code>NaN</code>, <code>NaN</code> is\n+     * returned. Infinity is handled.</p>\n+     *\n+     * @param a  value 1\n+     * @param b  value 2\n+     * @param c  value 3\n+     * @return  the largest of the values\n+     * @see IEEE754rUtils#max(float, float, float) for a version of this method that handles NaN differently\n+     */\n+    public static float max(float a, float b, float c) {\n+        return Math.max(Math.max(a, b), c);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks whether the <code>String</code> contains only\n+     * digit characters.</p>\n+     *\n+     * <p><code>Null</code> and empty String will return\n+     * <code>false</code>.</p>\n+     *\n+     * @param str  the <code>String</code> to check\n+     * @return <code>true</code> if str contains only unicode numeric\n+     */\n+    public static boolean isDigits(String str) {\n+        if (StringUtils.isEmpty(str)) {\n+            return false;\n+        }\n+        for (int i = 0; i < str.length(); i++) {\n+            if (!Character.isDigit(str.charAt(i))) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * <p>Checks whether the String a valid Java number.</p>\n+     *\n+     * <p>Valid numbers include hexadecimal marked with the <code>0x</code>\n+     * qualifier, scientific notation and numbers marked with a type\n+     * qualifier (e.g. 123L).</p>\n+     *\n+     * <p><code>Null</code> and empty String will return\n+     * <code>false</code>.</p>\n+     *\n+     * @param str  the <code>String</code> to check\n+     * @return <code>true</code> if the string is a correctly formatted number\n+     */\n+    public static boolean isNumber(String str) {\n+        if (StringUtils.isEmpty(str)) {\n+            return false;\n+        }\n+        char[] chars = str.toCharArray();\n+        int sz = chars.length;\n+        boolean hasExp = false;\n+        boolean hasDecPoint = false;\n+        boolean allowSigns = false;\n+        boolean foundDigit = false;\n+        // deal with any possible sign up front\n+        int start = (chars[0] == '-') ? 1 : 0;\n+        if (sz > start + 1) {\n+            if (chars[start] == '0' && chars[start + 1] == 'x') {\n+                int i = start + 2;\n+                if (i == sz) {\n+                    return false; // str == \"0x\"\n+                }\n+                // checking hex (it can't be anything else)\n+                for (; i < chars.length; i++) {\n+                    if ((chars[i] < '0' || chars[i] > '9')\n+                        && (chars[i] < 'a' || chars[i] > 'f')\n+                        && (chars[i] < 'A' || chars[i] > 'F')) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+        }\n+        sz--; // don't want to loop to the last char, check it afterwords\n+              // for type qualifiers\n+        int i = start;\n+        // loop to the next to last char or to the last char if we need another digit to\n+        // make a valid number (e.g. chars[0..5] = \"1234E\")\n+        while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n+            if (chars[i] >= '0' && chars[i] <= '9') {\n+                foundDigit = true;\n+                allowSigns = false;\n+\n+            } else if (chars[i] == '.') {\n+                if (hasDecPoint || hasExp) {\n+                    // two decimal points or dec in exponent   \n+                    return false;\n+                }\n+                hasDecPoint = true;\n+            } else if (chars[i] == 'e' || chars[i] == 'E') {\n+                // we've already taken care of hex.\n+                if (hasExp) {\n+                    // two E's\n+                    return false;\n+                }\n+                if (!foundDigit) {\n+                    return false;\n+                }\n+                hasExp = true;\n+                allowSigns = true;\n+            } else if (chars[i] == '+' || chars[i] == '-') {\n+                if (!allowSigns) {\n+                    return false;\n+                }\n+                allowSigns = false;\n+                foundDigit = false; // we need a digit after the E\n+            } else {\n+                return false;\n+            }\n+            i++;\n+        }\n+        if (i < chars.length) {\n+            if (chars[i] >= '0' && chars[i] <= '9') {\n+                // no type qualifier, OK\n+                return true;\n+            }\n+            if (chars[i] == 'e' || chars[i] == 'E') {\n+                // can't have an E at the last byte\n+                return false;\n+            }\n+            if (chars[i] == '.') {\n+                if (hasDecPoint || hasExp) {\n+                    // two decimal points or dec in exponent\n+                    return false;\n+                }\n+                // single trailing decimal point after non-exponent is ok\n+                return foundDigit;\n+            }\n+            if (!allowSigns\n+                && (chars[i] == 'd'\n+                    || chars[i] == 'D'\n+                    || chars[i] == 'f'\n+                    || chars[i] == 'F')) {\n+                return foundDigit;\n+            }\n+            if (chars[i] == 'l'\n+                || chars[i] == 'L') {\n+                // not allowing L with an exponent\n+                return foundDigit && !hasExp;\n+            }\n+            // last character is illegal\n+            return false;\n+        }\n+        // allowSigns is true iff the val ends in 'E'\n+        // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n+        return !allowSigns && foundDigit;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/mutable/Mutable.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang3.mutable;\n+\n+/**\n+ * Provides mutable access to a value.\n+ * <p>\n+ * <code>Mutable</code> is used as a generic interface to the implementations in this package.\n+ * <p>\n+ * A typical use case would be to enable a primitive or string to be passed to a method and allow that method to\n+ * effectively change the value of the primitive/string. Another use case is to store a frequently changing primitive in\n+ * a collection (for example a total in a map) without needing to create new Integer/Long wrapper objects.\n+ * \n+ * @author Apache Software Foundation\n+ * @author Matthew Hawthorne\n+ * @since 2.1\n+ * @version $Id$\n+ */\n+public interface Mutable<T> {\n+\n+    /**\n+     * Gets the value of this mutable.\n+     * \n+     * @return the stored value\n+     */\n+    T getValue();\n+\n+    /**\n+     * Sets the value of this mutable.\n+     * \n+     * @param value\n+     *            the value to store\n+     * @throws NullPointerException\n+     *             if the object is null and null is invalid\n+     * @throws ClassCastException\n+     *             if the type is invalid\n+     */\n+    void setValue(T value);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/mutable/MutableBoolean.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang3.mutable;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * A mutable <code>boolean</code> wrapper.\n+ * \n+ * @see Boolean\n+ * @since 2.2\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class MutableBoolean implements Mutable<Boolean>, Serializable, Comparable<MutableBoolean> {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = -4830728138360036487L;\n+\n+    /** The mutable value. */\n+    private boolean value;\n+\n+    /**\n+     * Constructs a new MutableBoolean with the default value of false.\n+     */\n+    public MutableBoolean() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new MutableBoolean with the specified value.\n+     * \n+     * @param value  the initial value to store\n+     */\n+    public MutableBoolean(boolean value) {\n+        super();\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Constructs a new MutableBoolean with the specified value.\n+     * \n+     * @param value  the initial value to store, not null\n+     * @throws NullPointerException if the object is null\n+     */\n+    public MutableBoolean(Boolean value) {\n+        super();\n+        this.value = value.booleanValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value as a Boolean instance.\n+     * \n+     * @return the value as a Boolean, never null\n+     */\n+    public Boolean getValue() {\n+        return Boolean.valueOf(this.value);\n+    }\n+\n+    /**\n+     * Sets the value.\n+     * \n+     * @param value  the value to set\n+     */\n+    public void setValue(boolean value) {\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Sets the value from any Boolean instance.\n+     * \n+     * @param value  the value to set, not null\n+     * @throws NullPointerException if the object is null\n+     */\n+    public void setValue(Boolean value) {\n+        this.value = value.booleanValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks if the current value is <code>true</code>.\n+     * \n+     * @return <code>true</code> if the current value is <code>true</code>\n+     */\n+    public boolean isTrue() {\n+        return value == true;\n+    }\n+\n+    /**\n+     * Checks if the current value is <code>false</code>.\n+     * \n+     * @return <code>true</code> if the current value is <code>false</code>\n+     */\n+    public boolean isFalse() {\n+        return value == false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the value of this MutableBoolean as a boolean.\n+     * \n+     * @return the boolean value represented by this object.\n+     */\n+    public boolean booleanValue() {\n+        return value;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this mutable as an instance of Boolean.\n+     *\n+     * @return a Boolean instance containing the value from this mutable, never null\n+     */\n+    public Boolean toBoolean() {\n+        return Boolean.valueOf(booleanValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object to the specified object. The result is <code>true</code> if and only if the argument is\n+     * not <code>null</code> and is an <code>MutableBoolean</code> object that contains the same\n+     * <code>boolean</code> value as this object.\n+     * \n+     * @param obj  the object to compare with, null returns false\n+     * @return <code>true</code> if the objects are the same; <code>false</code> otherwise.\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof MutableBoolean) {\n+            return value == ((MutableBoolean) obj).booleanValue();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns a suitable hash code for this mutable.\n+     * \n+     * @return the hash code returned by <code>Boolean.TRUE</code> or <code>Boolean.FALSE</code>\n+     */\n+    @Override\n+    public int hashCode() {\n+        return value ? Boolean.TRUE.hashCode() : Boolean.FALSE.hashCode();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this mutable to another in ascending order.\n+     * \n+     * @param other  the other mutable to compare to, not null\n+     * @return negative if this is less, zero if equal, positive if greater\n+     *  where false is less than true\n+     */\n+    public int compareTo(MutableBoolean other) {\n+        boolean anotherVal = other.value;\n+        return value == anotherVal ? 0 : (value ? 1 : -1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the String value of this mutable.\n+     * \n+     * @return the mutable value as a string\n+     */\n+    @Override\n+    public String toString() {\n+        return String.valueOf(value);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/mutable/MutableByte.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.mutable;\n+\n+/**\n+ * A mutable <code>byte</code> wrapper.\n+ * \n+ * @see Byte\n+ * @since 2.1\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class MutableByte extends Number implements Comparable<MutableByte>, Mutable<Number> {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = -1585823265L;\n+\n+    /** The mutable value. */\n+    private byte value;\n+\n+    /**\n+     * Constructs a new MutableByte with the default value of zero.\n+     */\n+    public MutableByte() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new MutableByte with the specified value.\n+     * \n+     * @param value  the initial value to store\n+     */\n+    public MutableByte(byte value) {\n+        super();\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Constructs a new MutableByte with the specified value.\n+     * \n+     * @param value  the initial value to store, not null\n+     * @throws NullPointerException if the object is null\n+     */\n+    public MutableByte(Number value) {\n+        super();\n+        this.value = value.byteValue();\n+    }\n+\n+    /**\n+     * Constructs a new MutableByte parsing the given string.\n+     * \n+     * @param value  the string to parse, not null\n+     * @throws NumberFormatException if the string cannot be parsed into a byte\n+     */\n+    public MutableByte(String value) throws NumberFormatException {\n+        super();\n+        this.value = Byte.parseByte(value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value as a Byte instance.\n+     * \n+     * @return the value as a Byte, never null\n+     */\n+    public Byte getValue() {\n+        return Byte.valueOf(this.value);\n+    }\n+\n+    /**\n+     * Sets the value.\n+     * \n+     * @param value  the value to set\n+     */\n+    public void setValue(byte value) {\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Sets the value from any Number instance.\n+     * \n+     * @param value  the value to set, not null\n+     * @throws NullPointerException if the object is null\n+     */\n+    public void setValue(Number value) {\n+        this.value = value.byteValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Increments the value.\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void increment() {\n+        value++;\n+    }\n+\n+    /**\n+     * Decrements the value.\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void decrement() {\n+        value--;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a value to the value of this instance.\n+     * \n+     * @param operand  the value to add, not null\n+     * @since Commons Lang 2.2\n+     */\n+    public void add(byte operand) {\n+        this.value += operand;\n+    }\n+\n+    /**\n+     * Adds a value to the value of this instance.\n+     * \n+     * @param operand  the value to add, not null\n+     * @throws NullPointerException if the object is null\n+     * @since Commons Lang 2.2\n+     */\n+    public void add(Number operand) {\n+        this.value += operand.byteValue();\n+    }\n+\n+    /**\n+     * Subtracts a value from the value of this instance.\n+     * \n+     * @param operand  the value to subtract, not null\n+     * @since Commons Lang 2.2\n+     */\n+    public void subtract(byte operand) {\n+        this.value -= operand;\n+    }\n+\n+    /**\n+     * Subtracts a value from the value of this instance.\n+     * \n+     * @param operand  the value to subtract, not null\n+     * @throws NullPointerException if the object is null\n+     * @since Commons Lang 2.2\n+     */\n+    public void subtract(Number operand) {\n+        this.value -= operand.byteValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    // shortValue relies on Number implementation\n+    /**\n+     * Returns the value of this MutableByte as a byte.\n+     *\n+     * @return the numeric value represented by this object after conversion to type byte.\n+     */\n+    @Override\n+    public byte byteValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableByte as an int.\n+     *\n+     * @return the numeric value represented by this object after conversion to type int.\n+     */\n+    @Override\n+    public int intValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableByte as a long.\n+     *\n+     * @return the numeric value represented by this object after conversion to type long.\n+     */\n+    @Override\n+    public long longValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableByte as a float.\n+     *\n+     * @return the numeric value represented by this object after conversion to type float.\n+     */\n+    @Override\n+    public float floatValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableByte as a double.\n+     *\n+     * @return the numeric value represented by this object after conversion to type double.\n+     */\n+    @Override\n+    public double doubleValue() {\n+        return value;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this mutable as an instance of Byte.\n+     *\n+     * @return a Byte instance containing the value from this mutable\n+     */\n+    public Byte toByte() {\n+        return Byte.valueOf(byteValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object to the specified object. The result is <code>true</code> if and only if the argument is\n+     * not <code>null</code> and is a <code>MutableByte</code> object that contains the same <code>byte</code> value\n+     * as this object.\n+     * \n+     * @param obj  the object to compare with, null returns false\n+     * @return <code>true</code> if the objects are the same; <code>false</code> otherwise.\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof MutableByte) {\n+            return value == ((MutableByte) obj).byteValue();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns a suitable hash code for this mutable.\n+     * \n+     * @return a suitable hash code\n+     */\n+    @Override\n+    public int hashCode() {\n+        return value;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this mutable to another in ascending order.\n+     * \n+     * @param other  the other mutable to compare to, not null\n+     * @return negative if this is less, zero if equal, positive if greater\n+     */\n+    public int compareTo(MutableByte other) {\n+        byte anotherVal = other.value;\n+        return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the String value of this mutable.\n+     * \n+     * @return the mutable value as a string\n+     */\n+    @Override\n+    public String toString() {\n+        return String.valueOf(value);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/mutable/MutableDouble.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.mutable;\n+\n+/**\n+ * A mutable <code>double</code> wrapper.\n+ * \n+ * @see Double\n+ * @since 2.1\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class MutableDouble extends Number implements Comparable<MutableDouble>, Mutable<Number> {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 1587163916L;\n+\n+    /** The mutable value. */\n+    private double value;\n+\n+    /**\n+     * Constructs a new MutableDouble with the default value of zero.\n+     */\n+    public MutableDouble() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new MutableDouble with the specified value.\n+     * \n+     * @param value  the initial value to store\n+     */\n+    public MutableDouble(double value) {\n+        super();\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Constructs a new MutableDouble with the specified value.\n+     * \n+     * @param value  the initial value to store, not null\n+     * @throws NullPointerException if the object is null\n+     */\n+    public MutableDouble(Number value) {\n+        super();\n+        this.value = value.doubleValue();\n+    }\n+\n+    /**\n+     * Constructs a new MutableDouble parsing the given string.\n+     * \n+     * @param value  the string to parse, not null\n+     * @throws NumberFormatException if the string cannot be parsed into a double\n+     */\n+    public MutableDouble(String value) throws NumberFormatException {\n+        super();\n+        this.value = Double.parseDouble(value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value as a Double instance.\n+     * \n+     * @return the value as a Double, never null\n+     */\n+    public Double getValue() {\n+        return new Double(this.value);\n+    }\n+\n+    /**\n+     * Sets the value.\n+     * \n+     * @param value  the value to set\n+     */\n+    public void setValue(double value) {\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Sets the value from any Number instance.\n+     * \n+     * @param value  the value to set, not null\n+     * @throws NullPointerException if the object is null\n+     */\n+    public void setValue(Number value) {\n+        this.value = value.doubleValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether the double value is the special NaN value.\n+     * \n+     * @return true if NaN\n+     */\n+    public boolean isNaN() {\n+        return Double.isNaN(value);\n+    }\n+\n+    /**\n+     * Checks whether the double value is infinite.\n+     * \n+     * @return true if infinite\n+     */\n+    public boolean isInfinite() {\n+        return Double.isInfinite(value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Increments the value.\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void increment() {\n+        value++;\n+    }\n+\n+    /**\n+     * Decrements the value.\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void decrement() {\n+        value--;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a value to the value of this instance.\n+     * \n+     * @param operand  the value to add\n+     * @since Commons Lang 2.2\n+     */\n+    public void add(double operand) {\n+        this.value += operand;\n+    }\n+\n+    /**\n+     * Adds a value to the value of this instance.\n+     * \n+     * @param operand  the value to add, not null\n+     * @throws NullPointerException if the object is null\n+     * @since Commons Lang 2.2\n+     */\n+    public void add(Number operand) {\n+        this.value += operand.doubleValue();\n+    }\n+\n+    /**\n+     * Subtracts a value from the value of this instance.\n+     * \n+     * @param operand  the value to subtract, not null\n+     * @since Commons Lang 2.2\n+     */\n+    public void subtract(double operand) {\n+        this.value -= operand;\n+    }\n+\n+    /**\n+     * Subtracts a value from the value of this instance.\n+     * \n+     * @param operand  the value to subtract, not null\n+     * @throws NullPointerException if the object is null\n+     * @since Commons Lang 2.2\n+     */\n+    public void subtract(Number operand) {\n+        this.value -= operand.doubleValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    // shortValue and bytValue rely on Number implementation\n+    /**\n+     * Returns the value of this MutableDouble as an int.\n+     *\n+     * @return the numeric value represented by this object after conversion to type int.\n+     */\n+    @Override\n+    public int intValue() {\n+        return (int) value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableDouble as a long.\n+     *\n+     * @return the numeric value represented by this object after conversion to type long.\n+     */\n+    @Override\n+    public long longValue() {\n+        return (long) value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableDouble as a float.\n+     *\n+     * @return the numeric value represented by this object after conversion to type float.\n+     */\n+    @Override\n+    public float floatValue() {\n+        return (float) value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableDouble as a double.\n+     *\n+     * @return the numeric value represented by this object after conversion to type double.\n+     */\n+    @Override\n+    public double doubleValue() {\n+        return value;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this mutable as an instance of Double.\n+     *\n+     * @return a Double instance containing the value from this mutable, never null\n+     */\n+    public Double toDouble() {\n+        return Double.valueOf(doubleValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object against the specified object. The result is <code>true</code> if and only if the argument\n+     * is not <code>null</code> and is a <code>Double</code> object that represents a double that has the identical\n+     * bit pattern to the bit pattern of the double represented by this object. For this purpose, two\n+     * <code>double</code> values are considered to be the same if and only if the method\n+     * {@link Double#doubleToLongBits(double)}returns the same long value when applied to each.\n+     * <p>\n+     * Note that in most cases, for two instances of class <code>Double</code>,<code>d1</code> and <code>d2</code>,\n+     * the value of <code>d1.equals(d2)</code> is <code>true</code> if and only if <blockquote>\n+     * \n+     * <pre>\n+     *   d1.doubleValue()&nbsp;== d2.doubleValue()\n+     * </pre>\n+     * \n+     * </blockquote>\n+     * <p>\n+     * also has the value <code>true</code>. However, there are two exceptions:\n+     * <ul>\n+     * <li>If <code>d1</code> and <code>d2</code> both represent <code>Double.NaN</code>, then the\n+     * <code>equals</code> method returns <code>true</code>, even though <code>Double.NaN==Double.NaN</code> has\n+     * the value <code>false</code>.\n+     * <li>If <code>d1</code> represents <code>+0.0</code> while <code>d2</code> represents <code>-0.0</code>,\n+     * or vice versa, the <code>equal</code> test has the value <code>false</code>, even though\n+     * <code>+0.0==-0.0</code> has the value <code>true</code>. This allows hashtables to operate properly.\n+     * </ul>\n+     * \n+     * @param obj  the object to compare with, null returns false\n+     * @return <code>true</code> if the objects are the same; <code>false</code> otherwise.\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        return (obj instanceof MutableDouble)\n+            && (Double.doubleToLongBits(((MutableDouble) obj).value) == Double.doubleToLongBits(value));\n+    }\n+\n+    /**\n+     * Returns a suitable hash code for this mutable.\n+     * \n+     * @return a suitable hash code\n+     */\n+    @Override\n+    public int hashCode() {\n+        long bits = Double.doubleToLongBits(value);\n+        return (int) (bits ^ (bits >>> 32));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this mutable to another in ascending order.\n+     * \n+     * @param other  the other mutable to compare to, not null\n+     * @return negative if this is less, zero if equal, positive if greater\n+     */\n+    public int compareTo(MutableDouble other) {\n+        double anotherVal = other.value;\n+        return Double.compare(value, anotherVal);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the String value of this mutable.\n+     * \n+     * @return the mutable value as a string\n+     */\n+    @Override\n+    public String toString() {\n+        return String.valueOf(value);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/mutable/MutableFloat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.mutable;\n+\n+/**\n+ * A mutable <code>float</code> wrapper.\n+ * \n+ * @see Float\n+ * @since 2.1\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class MutableFloat extends Number implements Comparable<MutableFloat>, Mutable<Number> {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 5787169186L;\n+\n+    /** The mutable value. */\n+    private float value;\n+\n+    /**\n+     * Constructs a new MutableFloat with the default value of zero.\n+     */\n+    public MutableFloat() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new MutableFloat with the specified value.\n+     * \n+     * @param value  the initial value to store\n+     */\n+    public MutableFloat(float value) {\n+        super();\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Constructs a new MutableFloat with the specified value.\n+     * \n+     * @param value  the initial value to store, not null\n+     * @throws NullPointerException if the object is null\n+     */\n+    public MutableFloat(Number value) {\n+        super();\n+        this.value = value.floatValue();\n+    }\n+\n+    /**\n+     * Constructs a new MutableFloat parsing the given string.\n+     * \n+     * @param value  the string to parse, not null\n+     * @throws NumberFormatException if the string cannot be parsed into a float\n+     */\n+    public MutableFloat(String value) throws NumberFormatException {\n+        super();\n+        this.value = Float.parseFloat(value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value as a Float instance.\n+     * \n+     * @return the value as a Float, never null\n+     */\n+    public Float getValue() {\n+        return new Float(this.value);\n+    }\n+\n+    /**\n+     * Sets the value.\n+     * \n+     * @param value  the value to set\n+     */\n+    public void setValue(float value) {\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Sets the value from any Number instance.\n+     * \n+     * @param value  the value to set, not null\n+     * @throws NullPointerException if the object is null\n+     */\n+    public void setValue(Number value) {\n+        this.value = value.floatValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether the float value is the special NaN value.\n+     * \n+     * @return true if NaN\n+     */\n+    public boolean isNaN() {\n+        return Float.isNaN(value);\n+    }\n+\n+    /**\n+     * Checks whether the float value is infinite.\n+     * \n+     * @return true if infinite\n+     */\n+    public boolean isInfinite() {\n+        return Float.isInfinite(value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Increments the value.\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void increment() {\n+        value++;\n+    }\n+\n+    /**\n+     * Decrements the value.\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void decrement() {\n+        value--;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a value to the value of this instance.\n+     * \n+     * @param operand  the value to add, not null\n+     * @since Commons Lang 2.2\n+     */\n+    public void add(float operand) {\n+        this.value += operand;\n+    }\n+\n+    /**\n+     * Adds a value to the value of this instance.\n+     * \n+     * @param operand  the value to add, not null\n+     * @throws NullPointerException if the object is null\n+     * @since Commons Lang 2.2\n+     */\n+    public void add(Number operand) {\n+        this.value += operand.floatValue();\n+    }\n+\n+    /**\n+     * Subtracts a value from the value of this instance.\n+     * \n+     * @param operand  the value to subtract\n+     * @since Commons Lang 2.2\n+     */\n+    public void subtract(float operand) {\n+        this.value -= operand;\n+    }\n+\n+    /**\n+     * Subtracts a value from the value of this instance.\n+     * \n+     * @param operand  the value to subtract, not null\n+     * @throws NullPointerException if the object is null\n+     * @since Commons Lang 2.2\n+     */\n+    public void subtract(Number operand) {\n+        this.value -= operand.floatValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    // shortValue and bytValue rely on Number implementation\n+    /**\n+     * Returns the value of this MutableFloat as an int.\n+     *\n+     * @return the numeric value represented by this object after conversion to type int.\n+     */\n+    @Override\n+    public int intValue() {\n+        return (int) value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableFloat as a long.\n+     *\n+     * @return the numeric value represented by this object after conversion to type long.\n+     */\n+    @Override\n+    public long longValue() {\n+        return (long) value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableFloat as a float.\n+     *\n+     * @return the numeric value represented by this object after conversion to type float.\n+     */\n+    @Override\n+    public float floatValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableFloat as a double.\n+     *\n+     * @return the numeric value represented by this object after conversion to type double.\n+     */\n+    @Override\n+    public double doubleValue() {\n+        return value;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this mutable as an instance of Float.\n+     *\n+     * @return a Float instance containing the value from this mutable, never null\n+     */\n+    public Float toFloat() {\n+        return Float.valueOf(floatValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object against some other object. The result is <code>true</code> if and only if the argument is\n+     * not <code>null</code> and is a <code>Float</code> object that represents a <code>float</code> that has the\n+     * identical bit pattern to the bit pattern of the <code>float</code> represented by this object. For this\n+     * purpose, two float values are considered to be the same if and only if the method\n+     * {@link Float#floatToIntBits(float)}returns the same int value when applied to each.\n+     * <p>\n+     * Note that in most cases, for two instances of class <code>Float</code>,<code>f1</code> and <code>f2</code>,\n+     * the value of <code>f1.equals(f2)</code> is <code>true</code> if and only if <blockquote>\n+     * \n+     * <pre>\n+     *   f1.floatValue() == f2.floatValue()\n+     * </pre>\n+     * \n+     * </blockquote>\n+     * <p>\n+     * also has the value <code>true</code>. However, there are two exceptions:\n+     * <ul>\n+     * <li>If <code>f1</code> and <code>f2</code> both represent <code>Float.NaN</code>, then the\n+     * <code>equals</code> method returns <code>true</code>, even though <code>Float.NaN==Float.NaN</code> has\n+     * the value <code>false</code>.\n+     * <li>If <code>f1</code> represents <code>+0.0f</code> while <code>f2</code> represents <code>-0.0f</code>,\n+     * or vice versa, the <code>equal</code> test has the value <code>false</code>, even though\n+     * <code>0.0f==-0.0f</code> has the value <code>true</code>.\n+     * </ul>\n+     * This definition allows hashtables to operate properly.\n+     * \n+     * @param obj  the object to compare with, null returns false\n+     * @return <code>true</code> if the objects are the same; <code>false</code> otherwise.\n+     * @see java.lang.Float#floatToIntBits(float)\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        return (obj instanceof MutableFloat)\n+            && (Float.floatToIntBits(((MutableFloat) obj).value) == Float.floatToIntBits(value));\n+    }\n+\n+    /**\n+     * Returns a suitable hash code for this mutable.\n+     * \n+     * @return a suitable hash code\n+     */\n+    @Override\n+    public int hashCode() {\n+        return Float.floatToIntBits(value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this mutable to another in ascending order.\n+     * \n+     * @param other  the other mutable to compare to, not null\n+     * @return negative if this is less, zero if equal, positive if greater\n+     */\n+    public int compareTo(MutableFloat other) {\n+        float anotherVal = other.value;\n+        return Float.compare(value, anotherVal);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the String value of this mutable.\n+     * \n+     * @return the mutable value as a string\n+     */\n+    @Override\n+    public String toString() {\n+        return String.valueOf(value);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/mutable/MutableInt.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.mutable;\n+\n+/**\n+ * A mutable <code>int</code> wrapper.\n+ * \n+ * @see Integer\n+ * @since 2.1\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class MutableInt extends Number implements Comparable<MutableInt>, Mutable<Number> {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 512176391864L;\n+\n+    /** The mutable value. */\n+    private int value;\n+\n+    /**\n+     * Constructs a new MutableInt with the default value of zero.\n+     */\n+    public MutableInt() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new MutableInt with the specified value.\n+     * \n+     * @param value  the initial value to store\n+     */\n+    public MutableInt(int value) {\n+        super();\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Constructs a new MutableInt with the specified value.\n+     * \n+     * @param value  the initial value to store, not null\n+     * @throws NullPointerException if the object is null\n+     */\n+    public MutableInt(Number value) {\n+        super();\n+        this.value = value.intValue();\n+    }\n+\n+    /**\n+     * Constructs a new MutableInt parsing the given string.\n+     * \n+     * @param value  the string to parse, not null\n+     * @throws NumberFormatException if the string cannot be parsed into an int\n+     */\n+    public MutableInt(String value) throws NumberFormatException {\n+        super();\n+        this.value = Integer.parseInt(value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value as a Integer instance.\n+     * \n+     * @return the value as a Integer, never null\n+     */\n+    public Integer getValue() {\n+        return new Integer(this.value);\n+    }\n+\n+    /**\n+     * Sets the value.\n+     * \n+     * @param value  the value to set\n+     */\n+    public void setValue(int value) {\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Sets the value from any Number instance.\n+     * \n+     * @param value  the value to set, not null\n+     * @throws NullPointerException if the object is null\n+     */\n+    public void setValue(Number value) {\n+        this.value = value.intValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Increments the value.\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void increment() {\n+        value++;\n+    }\n+\n+    /**\n+     * Decrements the value.\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void decrement() {\n+        value--;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a value to the value of this instance.\n+     * \n+     * @param operand  the value to add, not null\n+     * @since Commons Lang 2.2\n+     */\n+    public void add(int operand) {\n+        this.value += operand;\n+    }\n+\n+    /**\n+     * Adds a value to the value of this instance.\n+     * \n+     * @param operand  the value to add, not null\n+     * @throws NullPointerException if the object is null\n+     * @since Commons Lang 2.2\n+     */\n+    public void add(Number operand) {\n+        this.value += operand.intValue();\n+    }\n+\n+    /**\n+     * Subtracts a value from the value of this instance.\n+     * \n+     * @param operand  the value to subtract, not null\n+     * @since Commons Lang 2.2\n+     */\n+    public void subtract(int operand) {\n+        this.value -= operand;\n+    }\n+\n+    /**\n+     * Subtracts a value from the value of this instance.\n+     * \n+     * @param operand  the value to subtract, not null\n+     * @throws NullPointerException if the object is null\n+     * @since Commons Lang 2.2\n+     */\n+    public void subtract(Number operand) {\n+        this.value -= operand.intValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    // shortValue and bytValue rely on Number implementation\n+    /**\n+     * Returns the value of this MutableInt as an int.\n+     *\n+     * @return the numeric value represented by this object after conversion to type int.\n+     */\n+    @Override\n+    public int intValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableInt as a long.\n+     *\n+     * @return the numeric value represented by this object after conversion to type long.\n+     */\n+    @Override\n+    public long longValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableInt as a float.\n+     *\n+     * @return the numeric value represented by this object after conversion to type float.\n+     */\n+    @Override\n+    public float floatValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableInt as a double.\n+     *\n+     * @return the numeric value represented by this object after conversion to type double.\n+     */\n+    @Override\n+    public double doubleValue() {\n+        return value;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this mutable as an instance of Integer.\n+     *\n+     * @return a Integer instance containing the value from this mutable, never null\n+     */\n+    public Integer toInteger() {\n+        return Integer.valueOf(intValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object to the specified object. The result is <code>true</code> if and only if the argument is\n+     * not <code>null</code> and is a <code>MutableInt</code> object that contains the same <code>int</code> value\n+     * as this object.\n+     * \n+     * @param obj  the object to compare with, null returns false\n+     * @return <code>true</code> if the objects are the same; <code>false</code> otherwise.\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof MutableInt) {\n+            return value == ((MutableInt) obj).intValue();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns a suitable hash code for this mutable.\n+     * \n+     * @return a suitable hash code\n+     */\n+    @Override\n+    public int hashCode() {\n+        return value;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this mutable to another in ascending order.\n+     * \n+     * @param other  the other mutable to compare to, not null\n+     * @return negative if this is less, zero if equal, positive if greater\n+     */\n+    public int compareTo(MutableInt other) {\n+        int anotherVal = other.value;\n+        return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the String value of this mutable.\n+     * \n+     * @return the mutable value as a string\n+     */\n+    @Override\n+    public String toString() {\n+        return String.valueOf(value);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/mutable/MutableLong.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.mutable;\n+\n+/**\n+ * A mutable <code>long</code> wrapper.\n+ * \n+ * @see Long\n+ * @since 2.1\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class MutableLong extends Number implements Comparable<MutableLong>, Mutable<Number> {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 62986528375L;\n+\n+    /** The mutable value. */\n+    private long value;\n+\n+    /**\n+     * Constructs a new MutableLong with the default value of zero.\n+     */\n+    public MutableLong() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new MutableLong with the specified value.\n+     * \n+     * @param value  the initial value to store\n+     */\n+    public MutableLong(long value) {\n+        super();\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Constructs a new MutableLong with the specified value.\n+     * \n+     * @param value  the initial value to store, not null\n+     * @throws NullPointerException if the object is null\n+     */\n+    public MutableLong(Number value) {\n+        super();\n+        this.value = value.longValue();\n+    }\n+\n+    /**\n+     * Constructs a new MutableLong parsing the given string.\n+     * \n+     * @param value  the string to parse, not null\n+     * @throws NumberFormatException if the string cannot be parsed into a long\n+     */\n+    public MutableLong(String value) throws NumberFormatException {\n+        super();\n+        this.value = Long.parseLong(value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value as a Long instance.\n+     * \n+     * @return the value as a Long, never null\n+     */\n+    public Long getValue() {\n+        return new Long(this.value);\n+    }\n+\n+    /**\n+     * Sets the value.\n+     * \n+     * @param value  the value to set\n+     */\n+    public void setValue(long value) {\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Sets the value from any Number instance.\n+     * \n+     * @param value  the value to set, not null\n+     * @throws NullPointerException if the object is null\n+     */\n+    public void setValue(Number value) {\n+        this.value = value.longValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Increments the value.\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void increment() {\n+        value++;\n+    }\n+\n+    /**\n+     * Decrements the value.\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void decrement() {\n+        value--;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a value to the value of this instance.\n+     * \n+     * @param operand  the value to add, not null\n+     * @since Commons Lang 2.2\n+     */\n+    public void add(long operand) {\n+        this.value += operand;\n+    }\n+\n+    /**\n+     * Adds a value to the value of this instance.\n+     * \n+     * @param operand  the value to add, not null\n+     * @throws NullPointerException if the object is null\n+     * @since Commons Lang 2.2\n+     */\n+    public void add(Number operand) {\n+        this.value += operand.longValue();\n+    }\n+\n+    /**\n+     * Subtracts a value from the value of this instance.\n+     * \n+     * @param operand  the value to subtract, not null\n+     * @since Commons Lang 2.2\n+     */\n+    public void subtract(long operand) {\n+        this.value -= operand;\n+    }\n+\n+    /**\n+     * Subtracts a value from the value of this instance.\n+     * \n+     * @param operand  the value to subtract, not null\n+     * @throws NullPointerException if the object is null\n+     * @since Commons Lang 2.2\n+     */\n+    public void subtract(Number operand) {\n+        this.value -= operand.longValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    // shortValue and bytValue rely on Number implementation\n+    /**\n+     * Returns the value of this MutableLong as an int.\n+     *\n+     * @return the numeric value represented by this object after conversion to type int.\n+     */\n+    @Override\n+    public int intValue() {\n+        return (int) value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableLong as a long.\n+     *\n+     * @return the numeric value represented by this object after conversion to type long.\n+     */\n+    @Override\n+    public long longValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableLong as a float.\n+     *\n+     * @return the numeric value represented by this object after conversion to type float.\n+     */\n+    @Override\n+    public float floatValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableLong as a double.\n+     *\n+     * @return the numeric value represented by this object after conversion to type double.\n+     */\n+    @Override\n+    public double doubleValue() {\n+        return value;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this mutable as an instance of Long.\n+     *\n+     * @return a Long instance containing the value from this mutable, never null\n+     */\n+    public Long toLong() {\n+        return Long.valueOf(longValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object to the specified object. The result is <code>true</code> if and only if the argument\n+     * is not <code>null</code> and is a <code>MutableLong</code> object that contains the same <code>long</code>\n+     * value as this object.\n+     * \n+     * @param obj  the object to compare with, null returns false\n+     * @return <code>true</code> if the objects are the same; <code>false</code> otherwise.\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof MutableLong) {\n+            return value == ((MutableLong) obj).longValue();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns a suitable hash code for this mutable.\n+     * \n+     * @return a suitable hash code\n+     */\n+    @Override\n+    public int hashCode() {\n+        return (int) (value ^ (value >>> 32));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this mutable to another in ascending order.\n+     * \n+     * @param other  the other mutable to compare to, not null\n+     * @return negative if this is less, zero if equal, positive if greater\n+     */\n+    public int compareTo(MutableLong other) {\n+        long anotherVal = other.value;\n+        return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the String value of this mutable.\n+     * \n+     * @return the mutable value as a string\n+     */\n+    @Override\n+    public String toString() {\n+        return String.valueOf(value);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/mutable/MutableObject.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang3.mutable;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * A mutable <code>Object</code> wrapper.\n+ * \n+ * @since 2.1\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class MutableObject<T> implements Mutable<T>, Serializable {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 86241875189L;\n+\n+    /** The mutable value. */\n+    private T value;\n+\n+    /**\n+     * Constructs a new MutableObject with the default value of <code>null</code>.\n+     */\n+    public MutableObject() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new MutableObject with the specified value.\n+     * \n+     * @param value  the initial value to store\n+     */\n+    public MutableObject(T value) {\n+        super();\n+        this.value = value;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value.\n+     * \n+     * @return the value, may be null\n+     */\n+    public T getValue() {\n+        return this.value;\n+    }\n+\n+    /**\n+     * Sets the value.\n+     * \n+     * @param value  the value to set\n+     */\n+    public void setValue(T value) {\n+        this.value = value;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object against the specified object. The result is <code>true</code> if and only if the argument\n+     * is not <code>null</code> and is a <code>MutableObject</code> object that contains the same <code>T</code>\n+     * value as this object.\n+     * \n+     * @param obj  the object to compare with, null returns false\n+     * @return <code>true</code> if the objects are the same; <code>false</code> otherwise.\n+     */\n+    public boolean equals(MutableObject<T> obj) {\n+        if(obj == null) {\n+            return false;\n+        }\n+\n+        T other = obj.value;\n+        return value == other || (value != null && value.equals(other));\n+    }\n+\n+    /**\n+     * Returns the value's hash code or <code>0</code> if the value is <code>null</code>.\n+     * \n+     * @return the value's hash code or <code>0</code> if the value is <code>null</code>.\n+     */\n+    @Override\n+    public int hashCode() {\n+        return value == null ? 0 : value.hashCode();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the String value of this mutable.\n+     * \n+     * @return the mutable value as a string\n+     */\n+    @Override\n+    public String toString() {\n+        return value == null ? \"null\" : value.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/mutable/MutableShort.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.mutable;\n+\n+/**\n+ * A mutable <code>short</code> wrapper.\n+ * \n+ * @see Short\n+ * @since 2.1\n+ * @author Apache Software Foundation\n+ * @version $Id$\n+ */\n+public class MutableShort extends Number implements Comparable<MutableShort>, Mutable<Number> {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = -2135791679L;\n+\n+    /** The mutable value. */\n+    private short value;\n+\n+    /**\n+     * Constructs a new MutableShort with the default value of zero.\n+     */\n+    public MutableShort() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new MutableShort with the specified value.\n+     * \n+     * @param value  the initial value to store\n+     */\n+    public MutableShort(short value) {\n+        super();\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Constructs a new MutableShort with the specified value.\n+     * \n+     * @param value  the initial value to store, not null\n+     * @throws NullPointerException if the object is null\n+     */\n+    public MutableShort(Number value) {\n+        super();\n+        this.value = value.shortValue();\n+    }\n+\n+    /**\n+     * Constructs a new MutableShort parsing the given string.\n+     * \n+     * @param value  the string to parse, not null\n+     * @throws NumberFormatException if the string cannot be parsed into a short\n+     */\n+    public MutableShort(String value) throws NumberFormatException {\n+        super();\n+        this.value = Short.parseShort(value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value as a Short instance.\n+     * \n+     * @return the value as a Short, never null\n+     */\n+    public Short getValue() {\n+        return new Short(this.value);\n+    }\n+\n+    /**\n+     * Sets the value.\n+     * \n+     * @param value  the value to set\n+     */\n+    public void setValue(short value) {\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Sets the value from any Number instance.\n+     * \n+     * @param value  the value to set, not null\n+     * @throws NullPointerException if the object is null\n+     */\n+    public void setValue(Number value) {\n+        this.value = value.shortValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Increments the value.\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void increment() {\n+        value++;\n+    }\n+\n+    /**\n+     * Decrements the value.\n+     *\n+     * @since Commons Lang 2.2\n+     */\n+    public void decrement() {\n+        value--;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a value to the value of this instance.\n+     * \n+     * @param operand  the value to add, not null\n+     * @since Commons Lang 2.2\n+     */\n+    public void add(short operand) {\n+        this.value += operand;\n+    }\n+\n+    /**\n+     * Adds a value to the value of this instance.\n+     * \n+     * @param operand  the value to add, not null\n+     * @throws NullPointerException if the object is null\n+     * @since Commons Lang 2.2\n+     */\n+    public void add(Number operand) {\n+        this.value += operand.shortValue();\n+    }\n+\n+    /**\n+     * Subtracts a value from the value of this instance.\n+     * \n+     * @param operand  the value to subtract, not null\n+     * @since Commons Lang 2.2\n+     */\n+    public void subtract(short operand) {\n+        this.value -= operand;\n+    }\n+\n+    /**\n+     * Subtracts a value from the value of this instance.\n+     * \n+     * @param operand  the value to subtract, not null\n+     * @throws NullPointerException if the object is null\n+     * @since Commons Lang 2.2\n+     */\n+    public void subtract(Number operand) {\n+        this.value -= operand.shortValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    // bytValue relies on Number implementation\n+    /**\n+     * Returns the value of this MutableShort as a short.\n+     *\n+     * @return the numeric value represented by this object after conversion to type short.\n+     */\n+    @Override\n+    public short shortValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableShort as an int.\n+     *\n+     * @return the numeric value represented by this object after conversion to type int.\n+     */\n+    @Override\n+    public int intValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableShort as a long.\n+     *\n+     * @return the numeric value represented by this object after conversion to type long.\n+     */\n+    @Override\n+    public long longValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableShort as a float.\n+     *\n+     * @return the numeric value represented by this object after conversion to type float.\n+     */\n+    @Override\n+    public float floatValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Returns the value of this MutableShort as a double.\n+     *\n+     * @return the numeric value represented by this object after conversion to type double.\n+     */\n+    @Override\n+    public double doubleValue() {\n+        return value;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this mutable as an instance of Short.\n+     *\n+     * @return a Short instance containing the value from this mutable, never null\n+     */\n+    public Short toShort() {\n+        return Short.valueOf(shortValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object to the specified object. The result is <code>true</code> if and only if the argument\n+     * is not <code>null</code> and is a <code>MutableShort</code> object that contains the same <code>short</code>\n+     * value as this object.\n+     * \n+     * @param obj  the object to compare with, null returns false\n+     * @return <code>true</code> if the objects are the same; <code>false</code> otherwise.\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof MutableShort) {\n+            return value == ((MutableShort) obj).shortValue();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns a suitable hash code for this mutable.\n+     * \n+     * @return a suitable hash code\n+     */\n+    @Override\n+    public int hashCode() {\n+        return value;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this mutable to another in ascending order.\n+     * \n+     * @param other  the other mutable to compare to, not null\n+     * @return negative if this is less, zero if equal, positive if greater\n+     */\n+    public int compareTo(MutableShort other) {\n+        short anotherVal = other.value;\n+        return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the String value of this mutable.\n+     * \n+     * @return the mutable value as a string\n+     */\n+    @Override\n+    public String toString() {\n+        return String.valueOf(value);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/reflect/ConstructorUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.reflect;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Modifier;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.commons.lang3.ClassUtils;\n+\n+/**\n+ * <p> Utility reflection methods focussed on constructors, modelled after {@link MethodUtils}. </p>\n+ *\n+ * <h3>Known Limitations</h3>\n+ * <h4>Accessing Public Constructors In A Default Access Superclass</h4>\n+ * <p>There is an issue when invoking public constructors contained in a default access superclass.\n+ * Reflection locates these constructors fine and correctly assigns them as public.\n+ * However, an <code>IllegalAccessException</code> is thrown if the constructors is invoked.</p>\n+ *\n+ * <p><code>ConstructorUtils</code> contains a workaround for this situation.\n+ * It will attempt to call <code>setAccessible</code> on this constructor.\n+ * If this call succeeds, then the method can be invoked as normal.\n+ * This call will only succeed when the application has sufficient security privilages.\n+ * If this call fails then a warning will be logged and the method may fail.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author Craig R. McClanahan\n+ * @author Ralph Schaer\n+ * @author Chris Audley\n+ * @author Rey Francois\n+ * @author Gregor Rayman\n+ * @author Jan Sorensen\n+ * @author Robert Burrell Donkin\n+ * @author Rodney Waldhoff\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class ConstructorUtils {\n+\n+    /**\n+     * <p>ConstructorUtils instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as\n+     * <code>ConstructorUtils.invokeConstructor(cls, args)</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean\n+     * instance to operate.</p>\n+     */\n+    public ConstructorUtils() {\n+        super();\n+    }\n+\n+    /**\n+     * <p>Convenience method returning new instance of <code>klazz</code> using a single argument constructor.\n+     * The formal parameter type is inferred from the actual values of <code>arg</code>.\n+     * See {@link #invokeExactConstructor(Class, Object[], Class[])} for more details.</p>\n+     *\n+     * <p>The signatures should be assignment compatible.</p>\n+     *\n+     * @param cls the class to be constructed.\n+     * @param arg the actual argument\n+     * @return new instance of <code>klazz</code>\n+     *\n+     * @throws NoSuchMethodException If the constructor cannot be found\n+     * @throws IllegalAccessException If an error occurs accessing the constructor\n+     * @throws InvocationTargetException If an error occurs invoking the constructor\n+     * @throws InstantiationException If an error occurs instantiating the class\n+     *\n+     * @see #invokeConstructor(java.lang.Class, java.lang.Object[], java.lang.Class[])\n+     */\n+    public static Object invokeConstructor(Class<?> cls, Object arg)\n+            throws NoSuchMethodException, IllegalAccessException,\n+            InvocationTargetException, InstantiationException {\n+        return invokeConstructor(cls, new Object[] { arg });\n+    }\n+\n+    /**\n+     * <p>Returns new instance of <code>klazz</code> created using the actual arguments <code>args</code>.\n+     * The formal parameter types are inferred from the actual values of <code>args</code>.\n+     * See {@link #invokeExactConstructor(Class, Object[], Class[])} for more details.</p>\n+     *\n+     * <p>The signatures should be assignment compatible.</p>\n+     *\n+     * @param cls the class to be constructed.\n+     * @param args actual argument array\n+     * @return new instance of <code>klazz</code>\n+     *\n+     * @throws NoSuchMethodException If the constructor cannot be found\n+     * @throws IllegalAccessException If an error occurs accessing the constructor\n+     * @throws InvocationTargetException If an error occurs invoking the constructor\n+     * @throws InstantiationException If an error occurs instantiating the class\n+     *\n+     * @see #invokeConstructor(java.lang.Class, java.lang.Object[], java.lang.Class[])\n+     */\n+    public static Object invokeConstructor(Class<?> cls, Object[] args)\n+            throws NoSuchMethodException, IllegalAccessException,\n+            InvocationTargetException, InstantiationException {\n+        if (null == args) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }\n+        Class<?> parameterTypes[] = new Class[args.length];\n+        for (int i = 0; i < args.length; i++) {\n+            parameterTypes[i] = args[i].getClass();\n+        }\n+        return invokeConstructor(cls, args, parameterTypes);\n+    }\n+\n+    /**\n+     * <p>Returns new instance of <code>klazz</code> created using constructor\n+     * with signature <code>parameterTypes</code> and actual arguments <code>args</code>.</p>\n+     *\n+     * <p>The signatures should be assignment compatible.</p>\n+     *\n+     * @param cls the class to be constructed.\n+     * @param args actual argument array\n+     * @param parameterTypes parameter types array\n+     * @return new instance of <code>klazz</code>\n+     *\n+     * @throws NoSuchMethodException if matching constructor cannot be found\n+     * @throws IllegalAccessException thrown on the constructor's invocation\n+     * @throws InvocationTargetException thrown on the constructor's invocation\n+     * @throws InstantiationException thrown on the constructor's invocation\n+     * @see Constructor#newInstance\n+     */\n+    public static Object invokeConstructor(Class<?> cls, Object[] args,\n+            Class<?>[] parameterTypes) throws NoSuchMethodException,\n+            IllegalAccessException, InvocationTargetException,\n+            InstantiationException {\n+        if (parameterTypes == null) {\n+            parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;\n+        }\n+        if (args == null) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }\n+        Constructor<?> ctor = getMatchingAccessibleConstructor(cls, parameterTypes);\n+        if (null == ctor) {\n+            throw new NoSuchMethodException(\n+                    \"No such accessible constructor on object: \"\n+                            + cls.getName());\n+        }\n+        return ctor.newInstance(args);\n+    }\n+\n+    /**\n+     * <p>Convenience method returning new instance of <code>klazz</code> using a single argument constructor.\n+     * The formal parameter type is inferred from the actual values of <code>arg</code>.\n+     * See {@link #invokeExactConstructor(Class, Object[], Class[])} for more details.</p>\n+     *\n+     * <p>The signatures should match exactly.</p>\n+     *\n+     * @param cls the class to be constructed.\n+     * @param arg the actual argument\n+     * @return new instance of <code>klazz</code>\n+     *\n+     * @throws NoSuchMethodException If the constructor cannot be found\n+     * @throws IllegalAccessException If an error occurs accessing the constructor\n+     * @throws InvocationTargetException If an error occurs invoking the constructor\n+     * @throws InstantiationException If an error occurs instantiating the class\n+     *\n+     * @see #invokeExactConstructor(java.lang.Class, java.lang.Object[], java.lang.Class[])\n+     */\n+    public static Object invokeExactConstructor(Class<?> cls, Object arg)\n+            throws NoSuchMethodException, IllegalAccessException,\n+            InvocationTargetException, InstantiationException {\n+        return invokeExactConstructor(cls, new Object[] { arg });\n+    }\n+\n+    /**\n+     * <p>Returns new instance of <code>klazz</code> created using the actual arguments <code>args</code>.\n+     * The formal parameter types are inferred from the actual values of <code>args</code>.\n+     * See {@link #invokeExactConstructor(Class, Object[], Class[])} for more details.</p>\n+     *\n+     * <p>The signatures should match exactly.</p>\n+     *\n+     * @param cls the class to be constructed.\n+     * @param args actual argument array\n+     * @return new instance of <code>klazz</code>\n+     *\n+     * @throws NoSuchMethodException If the constructor cannot be found\n+     * @throws IllegalAccessException If an error occurs accessing the constructor\n+     * @throws InvocationTargetException If an error occurs invoking the constructor\n+     * @throws InstantiationException If an error occurs instantiating the class\n+     *\n+     * @see #invokeExactConstructor(java.lang.Class, java.lang.Object[], java.lang.Class[])\n+     */\n+    public static Object invokeExactConstructor(Class<?> cls, Object[] args)\n+            throws NoSuchMethodException, IllegalAccessException,\n+            InvocationTargetException, InstantiationException {\n+        if (null == args) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }\n+        int arguments = args.length;\n+        Class<?> parameterTypes[] = new Class[arguments];\n+        for (int i = 0; i < arguments; i++) {\n+            parameterTypes[i] = args[i].getClass();\n+        }\n+        return invokeExactConstructor(cls, args, parameterTypes);\n+    }\n+\n+    /**\n+     * <p>Returns new instance of <code>klazz</code> created using constructor\n+     * with signature <code>parameterTypes</code> and actual arguments\n+     * <code>args</code>.</p>\n+     *\n+     * <p>The signatures should match exactly.</p>\n+     *\n+     * @param cls the class to be constructed.\n+     * @param args actual argument array\n+     * @param parameterTypes parameter types array\n+     * @return new instance of <code>klazz</code>\n+     *\n+     * @throws NoSuchMethodException if matching constructor cannot be found\n+     * @throws IllegalAccessException thrown on the constructor's invocation\n+     * @throws InvocationTargetException thrown on the constructor's invocation\n+     * @throws InstantiationException thrown on the constructor's invocation\n+     * @see Constructor#newInstance\n+     */\n+    public static Object invokeExactConstructor(Class<?> cls, Object[] args,\n+            Class<?>[] parameterTypes) throws NoSuchMethodException,\n+            IllegalAccessException, InvocationTargetException,\n+            InstantiationException {\n+        if (args == null) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }\n+        if (parameterTypes == null) {\n+            parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;\n+        }\n+        Constructor<?> ctor = getAccessibleConstructor(cls, parameterTypes);\n+        if (null == ctor) {\n+            throw new NoSuchMethodException(\n+                    \"No such accessible constructor on object: \"\n+                            + cls.getName());\n+        }\n+        return ctor.newInstance(args);\n+    }\n+\n+    /**\n+     * Returns a constructor with single argument.\n+     * @param cls the class to be constructed\n+     * @param parameterType The constructor parameter type\n+     * @return null if matching accessible constructor can not be found.\n+     * @see Class#getConstructor\n+     * @see #getAccessibleConstructor(java.lang.reflect.Constructor)\n+     */\n+    public static Constructor<?> getAccessibleConstructor(Class<?> cls,\n+            Class<?> parameterType) {\n+        return getAccessibleConstructor(cls, new Class[] { parameterType });\n+    }\n+\n+    /**\n+     * Returns a constructor given a class and signature.\n+     * @param cls the class to be constructed\n+     * @param parameterTypes the parameter array\n+     * @return null if matching accessible constructor can not be found\n+     * @see Class#getConstructor\n+     * @see #getAccessibleConstructor(java.lang.reflect.Constructor)\n+     */\n+    public static Constructor<?> getAccessibleConstructor(Class<?> cls,\n+            Class<?>[] parameterTypes) {\n+        try {\n+            return getAccessibleConstructor(cls.getConstructor(parameterTypes));\n+        } catch (NoSuchMethodException e) {\n+            return (null);\n+        }\n+    }\n+\n+    /**\n+     * Returns accessible version of the given constructor.\n+     * @param ctor prototype constructor object.\n+     * @return <code>null</code> if accessible constructor can not be found.\n+     * @see java.lang.SecurityManager\n+     */\n+    public static Constructor<?> getAccessibleConstructor(Constructor<?> ctor) {\n+        return MemberUtils.isAccessible(ctor)\n+                && Modifier.isPublic(ctor.getDeclaringClass().getModifiers()) ? ctor\n+                : null;\n+    }\n+\n+    /**\n+     * <p>Find an accessible constructor with compatible parameters.\n+     * Compatible parameters mean that every method parameter is assignable from\n+     * the given parameters. In other words, it finds constructor that will take\n+     * the parameters given.</p>\n+     *\n+     * <p>First it checks if there is constructor matching the exact signature.\n+     * If no such, all the constructors of the class are tested if their signatures\n+     * are assignment compatible with the parameter types.\n+     * The first matching constructor is returned.</p>\n+     *\n+     * @param cls find constructor for this class\n+     * @param parameterTypes find method with compatible parameters\n+     * @return a valid Constructor object. If there's no matching constructor, returns <code>null</code>.\n+     */\n+    public static Constructor<?> getMatchingAccessibleConstructor(Class<?> cls,\n+            Class<?>[] parameterTypes) {\n+        // see if we can find the constructor directly\n+        // most of the time this works and it's much faster\n+        try {\n+            Constructor<?> ctor = cls.getConstructor(parameterTypes);\n+            MemberUtils.setAccessibleWorkaround(ctor);\n+            return ctor;\n+        } catch (NoSuchMethodException e) { /* SWALLOW */\n+        }\n+        Constructor<?> result = null;\n+        // search through all constructors\n+        Constructor<?>[] ctors = cls.getConstructors();\n+        for (int i = 0; i < ctors.length; i++) {\n+            // compare parameters\n+            if (ClassUtils.isAssignable(parameterTypes, ctors[i]\n+                    .getParameterTypes(), true)) {\n+                // get accessible version of method\n+                Constructor<?> ctor = getAccessibleConstructor(ctors[i]);\n+                if (ctor != null) {\n+                    MemberUtils.setAccessibleWorkaround(ctor);\n+                    if (result == null\n+                            || MemberUtils.compareParameterTypes(ctor\n+                                    .getParameterTypes(), result\n+                                    .getParameterTypes(), parameterTypes) < 0) {\n+                        result = ctor;\n+                    }\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/reflect/FieldUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.reflect;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.Iterator;\n+\n+import org.apache.commons.lang3.ClassUtils;\n+\n+/**\n+ * Utilities for working with fields by reflection. Adapted and refactored\n+ * from the dormant [reflect] Commons sandbox component.\n+ * <p>\n+ * The ability is provided to break the scoping restrictions coded by the\n+ * programmer. This can allow fields to be changed that shouldn't be. This\n+ * facility should be used with care.\n+ *\n+ * @author Apache Software Foundation\n+ * @author Matt Benson\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class FieldUtils {\n+\n+    /**\n+     * FieldUtils instances should NOT be constructed in standard programming.\n+     * <p>\n+     * This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.\n+     */\n+    public FieldUtils() {\n+        super();\n+    }\n+\n+    /**\n+     * Gets an accessible <code>Field</code> by name repecting scope.\n+     * Superclasses/interfaces will be considered.\n+     *\n+     * @param cls  the class to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @return the Field object\n+     * @throws IllegalArgumentException if the class or field name is null\n+     */\n+    public static Field getField(Class<?> cls, String fieldName) {\n+        Field field = getField(cls, fieldName, false);\n+        MemberUtils.setAccessibleWorkaround(field);\n+        return field;\n+    }\n+\n+    /**\n+     * Gets an accessible <code>Field</code> by name breaking scope\n+     * if requested. Superclasses/interfaces will be considered.\n+     *\n+     * @param cls  the class to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. <code>False</code> will only\n+     *  match public fields.\n+     * @return the Field object\n+     * @throws IllegalArgumentException if the class or field name is null\n+     */\n+    public static Field getField(final Class<?> cls, String fieldName, boolean forceAccess) {\n+        if (cls == null) {\n+            throw new IllegalArgumentException(\"The class must not be null\");\n+        }\n+        if (fieldName == null) {\n+            throw new IllegalArgumentException(\"The field name must not be null\");\n+        }\n+        // Sun Java 1.3 has a bugged implementation of getField hence we write the\n+        // code ourselves\n+\n+        // getField() will return the Field object with the declaring class\n+        // set correctly to the class that declares the field. Thus requesting the\n+        // field on a subclass will return the field from the superclass.\n+        //\n+        // priority order for lookup:\n+        // searchclass private/protected/package/public\n+        // superclass protected/package/public\n+        //  private/different package blocks access to further superclasses\n+        // implementedinterface public\n+\n+        // check up the superclass hierarchy\n+        for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) {\n+            try {\n+                Field field = acls.getDeclaredField(fieldName);\n+                // getDeclaredField checks for non-public scopes as well\n+                // and it returns accurate results\n+                if (!Modifier.isPublic(field.getModifiers())) {\n+                    if (forceAccess) {\n+                        field.setAccessible(true);\n+                    } else {\n+                        continue;\n+                    }\n+                }\n+                return field;\n+            } catch (NoSuchFieldException ex) {\n+                // ignore\n+            }\n+        }\n+        // check the public interface case. This must be manually searched for\n+        // incase there is a public supersuperclass field hidden by a private/package\n+        // superclass field.\n+        Field match = null;\n+        for (Iterator<Class<?>> intf = ClassUtils.getAllInterfaces(cls).iterator(); intf\n+                .hasNext();) {\n+            try {\n+                Field test = ((Class<?>) intf.next()).getField(fieldName);\n+                if (match != null) {\n+                    throw new IllegalArgumentException(\n+                            \"Reference to field \"\n+                                    + fieldName\n+                                    + \" is ambiguous relative to \"\n+                                    + cls\n+                                    + \"; a matching field exists on two or more implemented interfaces.\");\n+                }\n+                match = test;\n+            } catch (NoSuchFieldException ex) {\n+                // ignore\n+            }\n+        }\n+        return match;\n+    }\n+\n+    /**\n+     * Gets an accessible <code>Field</code> by name respecting scope.\n+     * Only the specified class will be considered.\n+     *\n+     * @param cls  the class to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @return the Field object\n+     * @throws IllegalArgumentException if the class or field name is null\n+     */\n+    public static Field getDeclaredField(Class<?> cls, String fieldName) {\n+        return getDeclaredField(cls, fieldName, false);\n+    }\n+\n+    /**\n+     * Gets an accessible <code>Field</code> by name breaking scope\n+     * if requested. Only the specified class will be considered.\n+     *\n+     * @param cls  the class to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. False will only match public fields.\n+     * @return the Field object\n+     * @throws IllegalArgumentException if the class or field name is null\n+     */\n+    public static Field getDeclaredField(Class<?> cls, String fieldName, boolean forceAccess) {\n+        if (cls == null) {\n+            throw new IllegalArgumentException(\"The class must not be null\");\n+        }\n+        if (fieldName == null) {\n+            throw new IllegalArgumentException(\"The field name must not be null\");\n+        }\n+        try {\n+            // only consider the specified class by using getDeclaredField()\n+            Field field = cls.getDeclaredField(fieldName);\n+            if (!MemberUtils.isAccessible(field)) {\n+                if (forceAccess) {\n+                    field.setAccessible(true);\n+                } else {\n+                    return null;\n+                }\n+            }\n+            return field;\n+        } catch (NoSuchFieldException e) {\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Read an accessible static Field.\n+     * @param field to read\n+     * @return the field value\n+     * @throws IllegalArgumentException if the field is null or not static\n+     * @throws IllegalAccessException if the field is not accessible\n+     */\n+    public static Object readStaticField(Field field) throws IllegalAccessException {\n+        return readStaticField(field, false);\n+    }\n+\n+    /**\n+     * Read a static Field.\n+     * @param field to read\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method.\n+     * @return the field value\n+     * @throws IllegalArgumentException if the field is null or not static\n+     * @throws IllegalAccessException if the field is not made accessible\n+     */\n+    public static Object readStaticField(Field field, boolean forceAccess) throws IllegalAccessException {\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"The field must not be null\");\n+        }\n+        if (!Modifier.isStatic(field.getModifiers())) {\n+            throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n+        }\n+        return readField(field, (Object) null, forceAccess);\n+    }\n+\n+    /**\n+     * Read the named public static field. Superclasses will be considered.\n+     * @param cls  the class to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @return the value of the field\n+     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws IllegalAccessException if the field is not accessible\n+     */\n+    public static Object readStaticField(Class<?> cls, String fieldName) throws IllegalAccessException {\n+        return readStaticField(cls, fieldName, false);\n+    }\n+\n+    /**\n+     * Read the named static field. Superclasses will be considered.\n+     * @param cls  the class to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. <code>False</code> will only\n+     *  match public fields.\n+     * @return the Field object\n+     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws IllegalAccessException if the field is not made accessible\n+     */\n+    public static Object readStaticField(Class<?> cls, String fieldName, boolean forceAccess) throws IllegalAccessException {\n+        Field field = getField(cls, fieldName, forceAccess);\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n+        }\n+        //already forced access above, don't repeat it here:\n+        return readStaticField(field, false);\n+    }\n+\n+    /**\n+     * Gets a static Field value by name. The field must be public.\n+     * Only the specified class will be considered.\n+     *\n+     * @param cls  the class to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @return the value of the field\n+     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws IllegalAccessException if the field is not accessible\n+     */\n+    public static Object readDeclaredStaticField(Class<?> cls, String fieldName) throws IllegalAccessException {\n+        return readDeclaredStaticField(cls, fieldName, false);\n+    }\n+\n+    /**\n+     * Gets a static Field value by name. Only the specified class will\n+     * be considered.\n+     *\n+     * @param cls  the class to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. <code>False</code> will only\n+     *  match public fields.\n+     * @return the Field object\n+     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws IllegalAccessException if the field is not made accessible\n+     */\n+    public static Object readDeclaredStaticField(Class<?> cls, String fieldName, boolean forceAccess)\n+            throws IllegalAccessException {\n+        Field field = getDeclaredField(cls, fieldName, forceAccess);\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n+        }\n+        //already forced access above, don't repeat it here:\n+        return readStaticField(field, false);\n+    }\n+\n+    /**\n+     * Read an accessible Field.\n+     * @param field  the field to use\n+     * @param target  the object to call on, may be null for static fields\n+     * @return the field value\n+     * @throws IllegalArgumentException if the field is null\n+     * @throws IllegalAccessException if the field is not accessible\n+     */\n+    public static Object readField(Field field, Object target) throws IllegalAccessException {\n+        return readField(field, target, false);\n+    }\n+\n+    /**\n+     * Read a Field.\n+     * @param field  the field to use\n+     * @param target  the object to call on, may be null for static fields\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method.\n+     * @return the field value\n+     * @throws IllegalArgumentException if the field is null\n+     * @throws IllegalAccessException if the field is not made accessible\n+     */\n+    public static Object readField(Field field, Object target, boolean forceAccess) throws IllegalAccessException {\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"The field must not be null\");\n+        }\n+        if (forceAccess && !field.isAccessible()) {\n+            field.setAccessible(true);\n+        } else {\n+            MemberUtils.setAccessibleWorkaround(field);\n+        }\n+        return field.get(target);\n+    }\n+\n+    /**\n+     * Read the named public field. Superclasses will be considered.\n+     * @param target  the object to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @return the value of the field\n+     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws IllegalAccessException if the named field is not public\n+     */\n+    public static Object readField(Object target, String fieldName) throws IllegalAccessException {\n+        return readField(target, fieldName, false);\n+    }\n+\n+    /**\n+     * Read the named field. Superclasses will be considered.\n+     * @param target  the object to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. <code>False</code> will only\n+     *  match public fields.\n+     * @return the field value\n+     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws IllegalAccessException if the named field is not made accessible\n+     */\n+    public static Object readField(Object target, String fieldName, boolean forceAccess) throws IllegalAccessException {\n+        if (target == null) {\n+            throw new IllegalArgumentException(\"target object must not be null\");\n+        }\n+        Class<?> cls = target.getClass();\n+        Field field = getField(cls, fieldName, forceAccess);\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n+        }\n+        //already forced access above, don't repeat it here:\n+        return readField(field, target);\n+    }\n+\n+    /**\n+     * Read the named public field. Only the class of the specified object will be considered.\n+     * @param target  the object to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @return the value of the field\n+     * @throws IllegalArgumentException if the class or field name is null\n+     * @throws IllegalAccessException if the named field is not public\n+     */\n+    public static Object readDeclaredField(Object target, String fieldName) throws IllegalAccessException {\n+        return readDeclaredField(target, fieldName, false);\n+    }\n+\n+    /**\n+     * <p<>Gets a Field value by name. Only the class of the specified\n+     * object will be considered.\n+     *\n+     * @param target  the object to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. <code>False</code> will only\n+     *  match public fields.\n+     * @return the Field object\n+     * @throws IllegalArgumentException if <code>target</code> or <code>fieldName</code> is null\n+     * @throws IllegalAccessException if the field is not made accessible\n+     */\n+    public static Object readDeclaredField(Object target, String fieldName, boolean forceAccess) throws IllegalAccessException {\n+        if (target == null) {\n+            throw new IllegalArgumentException(\"target object must not be null\");\n+        }\n+        Class<?> cls = target.getClass();\n+        Field field = getDeclaredField(cls, fieldName, forceAccess);\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n+        }\n+        //already forced access above, don't repeat it here:\n+        return readField(field, target);\n+    }\n+\n+    /**\n+     * Write a public static Field.\n+     * @param field to write\n+     * @param value to set\n+     * @throws IllegalArgumentException if the field is null or not static\n+     * @throws IllegalAccessException if the field is not public or is final\n+     */\n+    public static void writeStaticField(Field field, Object value) throws IllegalAccessException {\n+        writeStaticField(field, value, false);\n+    }\n+\n+    /**\n+     * Write a static Field.\n+     * @param field to write\n+     * @param value to set\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. <code>False</code> will only\n+     *  match public fields.\n+     * @throws IllegalArgumentException if the field is null or not static\n+     * @throws IllegalAccessException if the field is not made accessible or is final\n+     */\n+    public static void writeStaticField(Field field, Object value, boolean forceAccess) throws IllegalAccessException {\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"The field must not be null\");\n+        }\n+        if (!Modifier.isStatic(field.getModifiers())) {\n+            throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n+        }\n+        writeField(field, (Object) null, value, forceAccess);\n+    }\n+\n+    /**\n+     * Write a named public static Field. Superclasses will be considered.\n+     * @param cls Class on which the Field is to be found\n+     * @param fieldName to write\n+     * @param value to set\n+     * @throws IllegalArgumentException if the field cannot be located or is not static\n+     * @throws IllegalAccessException if the field is not public or is final\n+     */\n+    public static void writeStaticField(Class<?> cls, String fieldName, Object value) throws IllegalAccessException {\n+        writeStaticField(cls, fieldName, value, false);\n+    }\n+\n+    /**\n+     * Write a named static Field. Superclasses will be considered.\n+     * @param cls Class on which the Field is to be found\n+     * @param fieldName to write\n+     * @param value to set\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. <code>False</code> will only\n+     *  match public fields.\n+     * @throws IllegalArgumentException if the field cannot be located or is not static\n+     * @throws IllegalAccessException if the field is not made accessible or is final\n+     */\n+    public static void writeStaticField(Class<?> cls, String fieldName, Object value, boolean forceAccess)\n+            throws IllegalAccessException {\n+        Field field = getField(cls, fieldName, forceAccess);\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"Cannot locate field \" + fieldName + \" on \" + cls);\n+        }\n+        //already forced access above, don't repeat it here:\n+        writeStaticField(field, value);\n+    }\n+\n+    /**\n+     * Write a named public static Field. Only the specified class will be considered.\n+     * @param cls Class on which the Field is to be found\n+     * @param fieldName to write\n+     * @param value to set\n+     * @throws IllegalArgumentException if the field cannot be located or is not static\n+     * @throws IllegalAccessException if the field is not public or is final\n+     */\n+    public static void writeDeclaredStaticField(Class<?> cls, String fieldName, Object value)\n+            throws IllegalAccessException {\n+        writeDeclaredStaticField(cls, fieldName, value, false);\n+    }\n+\n+    /**\n+     * Write a named static Field. Only the specified class will be considered.\n+     * @param cls Class on which the Field is to be found\n+     * @param fieldName to write\n+     * @param value to set\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. <code>False</code> will only\n+     *  match public fields.\n+     * @throws IllegalArgumentException if the field cannot be located or is not static\n+     * @throws IllegalAccessException if the field is not made accessible or is final\n+      */\n+    public static void writeDeclaredStaticField(Class<?> cls, String fieldName, Object value, boolean forceAccess)\n+            throws IllegalAccessException {\n+        Field field = getDeclaredField(cls, fieldName, forceAccess);\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n+        }\n+        //already forced access above, don't repeat it here:\n+        writeField(field, (Object) null, value);\n+    }\n+\n+    /**\n+     * Write an accessible field.\n+     * @param field to write\n+     * @param target  the object to call on, may be null for static fields\n+     * @param value to set\n+     * @throws IllegalArgumentException if the field is null\n+     * @throws IllegalAccessException if the field is not accessible or is final\n+     */\n+    public static void writeField(Field field, Object target, Object value) throws IllegalAccessException {\n+        writeField(field, target, value, false);\n+    }\n+\n+    /**\n+     * Write a field.\n+     * @param field to write\n+     * @param target  the object to call on, may be null for static fields\n+     * @param value to set\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. <code>False</code> will only\n+     *  match public fields.\n+     * @throws IllegalArgumentException if the field is null\n+     * @throws IllegalAccessException if the field is not made accessible or is final\n+     */\n+    public static void writeField(Field field, Object target, Object value, boolean forceAccess) throws IllegalAccessException {\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"The field must not be null\");\n+        }\n+        if (forceAccess && !field.isAccessible()) {\n+            field.setAccessible(true);\n+        } else {\n+            MemberUtils.setAccessibleWorkaround(field);\n+        }\n+        field.set(target, value);\n+    }\n+\n+    /**\n+     * Write a public field. Superclasses will be considered.\n+     * @param target  the object to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @param value to set\n+     * @throws IllegalArgumentException if <code>target</code> or <code>fieldName</code> is null\n+     * @throws IllegalAccessException if the field is not accessible\n+     */\n+    public static void writeField(Object target, String fieldName, Object value) throws IllegalAccessException {\n+        writeField(target, fieldName, value, false);\n+    }\n+\n+    /**\n+     * Write a field. Superclasses will be considered.\n+     * @param target  the object to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @param value to set\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. <code>False</code> will only\n+     *  match public fields.\n+     * @throws IllegalArgumentException if <code>target</code> or <code>fieldName</code> is null\n+     * @throws IllegalAccessException if the field is not made accessible\n+     */\n+    public static void writeField(Object target, String fieldName, Object value, boolean forceAccess)\n+            throws IllegalAccessException {\n+        if (target == null) {\n+            throw new IllegalArgumentException(\"target object must not be null\");\n+        }\n+        Class<?> cls = target.getClass();\n+        Field field = getField(cls, fieldName, forceAccess);\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n+        }\n+        //already forced access above, don't repeat it here:\n+        writeField(field, target, value);\n+    }\n+\n+    /**\n+     * Write a public field. Only the specified class will be considered.\n+     * @param target  the object to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @param value to set\n+     * @throws IllegalArgumentException if <code>target</code> or <code>fieldName</code> is null\n+     * @throws IllegalAccessException if the field is not made accessible\n+     */\n+    public static void writeDeclaredField(Object target, String fieldName, Object value) throws IllegalAccessException {\n+        writeDeclaredField(target, fieldName, value, false);\n+    }\n+\n+    /**\n+     * Write a public field. Only the specified class will be considered.\n+     * @param target  the object to reflect, must not be null\n+     * @param fieldName  the field name to obtain\n+     * @param value to set\n+     * @param forceAccess  whether to break scope restrictions using the\n+     *  <code>setAccessible</code> method. <code>False</code> will only\n+     *  match public fields.\n+     * @throws IllegalArgumentException if <code>target</code> or <code>fieldName</code> is null\n+     * @throws IllegalAccessException if the field is not made accessible\n+     */\n+    public static void writeDeclaredField(Object target, String fieldName, Object value, boolean forceAccess)\n+            throws IllegalAccessException {\n+        if (target == null) {\n+            throw new IllegalArgumentException(\"target object must not be null\");\n+        }\n+        Class<?> cls = target.getClass();\n+        Field field = getDeclaredField(cls, fieldName, forceAccess);\n+        if (field == null) {\n+            throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n+        }\n+        //already forced access above, don't repeat it here:\n+        writeField(field, target, value);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/reflect/MemberUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.reflect;\n+\n+import java.lang.reflect.AccessibleObject;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.commons.lang3.ClassUtils;\n+import org.apache.commons.lang3.SystemUtils;\n+\n+/**\n+ * Contains common code for working with Methods/Constructors, extracted and\n+ * refactored from <code>MethodUtils</code> when it was imported from Commons BeanUtils.\n+ *\n+ * @author Apache Software Foundation\n+ * @author Steve Cohen\n+ * @author Matt Benson\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+abstract class MemberUtils {\n+    // TODO extract an interface to implement compareParameterSets(...)?\n+\n+    private static final int ACCESS_TEST = Modifier.PUBLIC | Modifier.PROTECTED | Modifier.PRIVATE;\n+\n+    private static final Method IS_SYNTHETIC;\n+    static {\n+        Method isSynthetic = null;\n+        if (SystemUtils.isJavaVersionAtLeast(1.5f)) {\n+            // cannot call synthetic methods:\n+            try {\n+                isSynthetic = Member.class.getMethod(\"isSynthetic\",\n+                        ArrayUtils.EMPTY_CLASS_ARRAY);\n+            } catch (Exception e) {\n+            }\n+        }\n+        IS_SYNTHETIC = isSynthetic;\n+    }\n+\n+    /** Array of primitive number types ordered by \"promotability\" */\n+    private static final Class<?>[] ORDERED_PRIMITIVE_TYPES = { Byte.TYPE,\n+            Short.TYPE, Character.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE,\n+            Double.TYPE };\n+\n+    /**\n+     * XXX Default access superclass workaround\n+     *\n+     * When a public class has a default access superclass with public\n+     * members, these members are accessible. Calling them from\n+     * compiled code works fine. Unfortunately, on some JVMs, using reflection to invoke these\n+     * members seems to (wrongly) to prevent access even when the\n+     * modifer is public. Calling setAccessible(true) solves the problem\n+     * but will only work from sufficiently privileged code. Better\n+     * workarounds would be gratefully accepted.\n+     * @param o the AccessibleObject to set as accessible\n+     */\n+    static void setAccessibleWorkaround(AccessibleObject o) {\n+        if (o == null || o.isAccessible()) {\n+            return;\n+        }\n+        Member m = (Member) o;\n+        if (Modifier.isPublic(m.getModifiers()) && isPackageAccess(m.getDeclaringClass().getModifiers())) {\n+            try {\n+                o.setAccessible(true);\n+            } catch (SecurityException e) {\n+                // ignore in favor of subsequent IllegalAccessException\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Learn whether a given set of modifiers implies package access.\n+     * @param modifiers to test\n+     * @return true unless package/protected/private modifier detected\n+     */\n+    static boolean isPackageAccess(int modifiers) {\n+        return (modifiers & ACCESS_TEST) == 0;\n+    }\n+\n+    /**\n+     * Check a Member for basic accessibility.\n+     * @param m Member to check\n+     * @return true if <code>m</code> is accessible\n+     */\n+    static boolean isAccessible(Member m) {\n+        return m != null && Modifier.isPublic(m.getModifiers())\n+                && !isSynthetic(m);\n+    }\n+\n+    /**\n+     * Try to learn whether a given member, on JDK >= 1.5, is synthetic.\n+     * @param m Member to check\n+     * @return true if <code>m</code> was introduced by the compiler.\n+     */\n+    static boolean isSynthetic(Member m) {\n+        if (IS_SYNTHETIC != null) {\n+            try {\n+                return ((Boolean) IS_SYNTHETIC.invoke(m, (Object[]) null)).booleanValue();\n+            } catch (Exception e) {\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Compare the relative fitness of two sets of parameter types in terms of\n+     * matching a third set of runtime parameter types, such that a list ordered\n+     * by the results of the comparison would return the best match first (least).\n+     *\n+     * @param left the \"left\" parameter set\n+     * @param right the \"right\" parameter set\n+     * @param actual the runtime parameter types to match against <code>left</code>/<code>right</code>\n+     * @return int consistent with <code>compare</code> semantics\n+     */\n+    static int compareParameterTypes(Class<?>[] left, Class<?>[] right, Class<?>[] actual) {\n+        float leftCost = getTotalTransformationCost(actual, left);\n+        float rightCost = getTotalTransformationCost(actual, right);\n+        return leftCost < rightCost ? -1 : rightCost < leftCost ? 1 : 0;\n+    }\n+\n+    /**\n+     * Returns the sum of the object transformation cost for each class in the source\n+     * argument list.\n+     * @param srcArgs The source arguments\n+     * @param destArgs The destination arguments\n+     * @return The total transformation cost\n+     */\n+    private static float getTotalTransformationCost(Class<?>[] srcArgs,\n+            Class<?>[] destArgs) {\n+        float totalCost = 0.0f;\n+        for (int i = 0; i < srcArgs.length; i++) {\n+            Class<?> srcClass, destClass;\n+            srcClass = srcArgs[i];\n+            destClass = destArgs[i];\n+            totalCost += getObjectTransformationCost(srcClass, destClass);\n+        }\n+        return totalCost;\n+    }\n+\n+    /**\n+     * Gets the number of steps required needed to turn the source class into the \n+     * destination class. This represents the number of steps in the object hierarchy \n+     * graph.\n+     * @param srcClass The source class\n+     * @param destClass The destination class\n+     * @return The cost of transforming an object\n+     */\n+    private static float getObjectTransformationCost(Class<?> srcClass,\n+            Class<?> destClass) {\n+        if (destClass.isPrimitive()) {\n+            return getPrimitivePromotionCost(srcClass, destClass);\n+        }\n+        float cost = 0.0f;\n+        while (destClass != null && !destClass.equals(srcClass)) {\n+            if (destClass.isInterface()\n+                    && ClassUtils.isAssignable(srcClass, destClass)) {\n+                // slight penalty for interface match.\n+                // we still want an exact match to override an interface match,\n+                // but\n+                // an interface match should override anything where we have to\n+                // get a superclass.\n+                cost += 0.25f;\n+                break;\n+            }\n+            cost++;\n+            destClass = destClass.getSuperclass();\n+        }\n+        /*\n+         * If the destination class is null, we've travelled all the way up to\n+         * an Object match. We'll penalize this by adding 1.5 to the cost.\n+         */\n+        if (destClass == null) {\n+            cost += 1.5f;\n+        }\n+        return cost;\n+    }\n+\n+    /**\n+     * Get the number of steps required to promote a primitive number to another type.\n+     * @param srcClass the (primitive) source class\n+     * @param destClass the (primitive) destination class\n+     * @return The cost of promoting the primitive\n+     */\n+    private static float getPrimitivePromotionCost(final Class<?> srcClass,\n+            final Class<?> destClass) {\n+        float cost = 0.0f;\n+        Class<?> cls = srcClass;\n+        if (!cls.isPrimitive()) {\n+            // slight unwrapping penalty\n+            cost += 0.1f;\n+            cls = ClassUtils.wrapperToPrimitive(cls);\n+        }\n+        for (int i = 0; cls != destClass && i < ORDERED_PRIMITIVE_TYPES.length; i++) {\n+            if (cls == ORDERED_PRIMITIVE_TYPES[i]) {\n+                cost += 0.1f;\n+                if (i < ORDERED_PRIMITIVE_TYPES.length - 1) {\n+                    cls = ORDERED_PRIMITIVE_TYPES[i + 1];\n+                }\n+            }\n+        }\n+        return cost;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/reflect/MethodUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.reflect;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.commons.lang3.ClassUtils;\n+\n+/**\n+ * <p> Utility reflection methods focused on methods, originally from Commons BeanUtils.\n+ * Differences from the BeanUtils version may be noted, especially where similar functionality\n+ * already existed within Lang.\n+ * </p>\n+ *\n+ * <h3>Known Limitations</h3>\n+ * <h4>Accessing Public Methods In A Default Access Superclass</h4>\n+ * <p>There is an issue when invoking public methods contained in a default access superclass on JREs prior to 1.4.\n+ * Reflection locates these methods fine and correctly assigns them as public.\n+ * However, an <code>IllegalAccessException</code> is thrown if the method is invoked.</p>\n+ *\n+ * <p><code>MethodUtils</code> contains a workaround for this situation. \n+ * It will attempt to call <code>setAccessible</code> on this method.\n+ * If this call succeeds, then the method can be invoked as normal.\n+ * This call will only succeed when the application has sufficient security privileges. \n+ * If this call fails then the method may fail.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author Craig R. McClanahan\n+ * @author Ralph Schaer\n+ * @author Chris Audley\n+ * @author Rey Fran&#231;ois\n+ * @author Gregor Ra&#253;man\n+ * @author Jan Sorensen\n+ * @author Robert Burrell Donkin\n+ * @author Niall Pemberton\n+ * @author Matt Benson\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class MethodUtils {\n+\n+    /**\n+     * <p>MethodUtils instances should NOT be constructed in standard programming.\n+     * Instead, the class should be used as\n+     * <code>MethodUtils.getAccessibleMethod(method)</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean\n+     * instance to operate.</p>\n+     */\n+    public MethodUtils() {\n+        super();\n+    }\n+\n+    /**\n+     * <p>Invoke a named method whose parameter type matches the object type.</p>\n+     *\n+     * <p>This method delegates the method search to {@link #getMatchingAccessibleMethod(Class, String, Class[])}.</p>\n+     *\n+     * <p>This method supports calls to methods taking primitive parameters \n+     * via passing in wrapping classes. So, for example, a <code>Boolean</code> object\n+     * would match a <code>boolean</code> primitive.</p>\n+     *\n+     * <p> This is a convenient wrapper for\n+     * {@link #invokeMethod(Object object, String methodName, Object[] args)}.\n+     * </p>\n+     *\n+     * @param object invoke method on this object\n+     * @param methodName get method with this name\n+     * @param arg use this argument\n+     * @return The value returned by the invoked method\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible via reflection\n+     */\n+    public static Object invokeMethod(Object object, String methodName,\n+            Object arg) throws NoSuchMethodException, IllegalAccessException,\n+            InvocationTargetException {\n+        return invokeMethod(object, methodName, new Object[] { arg });\n+    }\n+\n+    /**\n+     * <p>Invoke a named method whose parameter type matches the object type.</p>\n+     *\n+     * <p>This method delegates the method search to {@link #getMatchingAccessibleMethod(Class, String, Class[])}.</p>\n+     *\n+     * <p>This method supports calls to methods taking primitive parameters \n+     * via passing in wrapping classes. So, for example, a <code>Boolean</code> object\n+     * would match a <code>boolean</code> primitive.</p>\n+     *\n+     * <p> This is a convenient wrapper for\n+     * {@link #invokeMethod(Object object,String methodName, Object[] args, Class[] parameterTypes)}.\n+     * </p>\n+     *\n+     * @param object invoke method on this object\n+     * @param methodName get method with this name\n+     * @param args use these arguments - treat null as empty array\n+     * @return The value returned by the invoked method\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible via reflection\n+     */\n+    public static Object invokeMethod(Object object, String methodName,\n+            Object[] args) throws NoSuchMethodException,\n+            IllegalAccessException, InvocationTargetException {\n+        if (args == null) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }\n+        int arguments = args.length;\n+        Class<?>[] parameterTypes = new Class[arguments];\n+        for (int i = 0; i < arguments; i++) {\n+            parameterTypes[i] = args[i].getClass();\n+        }\n+        return invokeMethod(object, methodName, args, parameterTypes);\n+    }\n+\n+    /**\n+     * <p>Invoke a named method whose parameter type matches the object type.</p>\n+     *\n+     * <p>This method delegates the method search to {@link #getMatchingAccessibleMethod(Class, String, Class[])}.</p>\n+     *\n+     * <p>This method supports calls to methods taking primitive parameters \n+     * via passing in wrapping classes. So, for example, a <code>Boolean</code> object\n+     * would match a <code>boolean</code> primitive.</p>\n+     *\n+     * @param object invoke method on this object\n+     * @param methodName get method with this name\n+     * @param args use these arguments - treat null as empty array\n+     * @param parameterTypes match these parameters - treat null as empty array\n+     * @return The value returned by the invoked method\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible via reflection\n+     */\n+    public static Object invokeMethod(Object object, String methodName,\n+            Object[] args, Class<?>[] parameterTypes)\n+            throws NoSuchMethodException, IllegalAccessException,\n+            InvocationTargetException {\n+        if (parameterTypes == null) {\n+            parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;\n+        }\n+        if (args == null) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }\n+        Method method = getMatchingAccessibleMethod(object.getClass(),\n+                methodName, parameterTypes);\n+        if (method == null) {\n+            throw new NoSuchMethodException(\"No such accessible method: \"\n+                    + methodName + \"() on object: \"\n+                    + object.getClass().getName());\n+        }\n+        return method.invoke(object, args);\n+    }\n+\n+    /**\n+     * <p>Invoke a method whose parameter type matches exactly the object\n+     * type.</p>\n+     *\n+     * <p> This is a convenient wrapper for\n+     * {@link #invokeExactMethod(Object object,String methodName,Object [] args)}.\n+     * </p>\n+     *\n+     * @param object invoke method on this object\n+     * @param methodName get method with this name\n+     * @param arg use this argument\n+     * @return The value returned by the invoked method\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the\n+     *  method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible\n+     *  via reflection\n+     */\n+    public static Object invokeExactMethod(Object object, String methodName,\n+            Object arg) throws NoSuchMethodException, IllegalAccessException,\n+            InvocationTargetException {\n+        return invokeExactMethod(object, methodName, new Object[] { arg });\n+    }\n+\n+    /**\n+     * <p>Invoke a method whose parameter types match exactly the object\n+     * types.</p>\n+     *\n+     * <p> This uses reflection to invoke the method obtained from a call to\n+     * <code>getAccessibleMethod()</code>.</p>\n+     *\n+     * @param object invoke method on this object\n+     * @param methodName get method with this name\n+     * @param args use these arguments - treat null as empty array\n+     * @return The value returned by the invoked method\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the\n+     *  method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible\n+     *  via reflection\n+     */\n+    public static Object invokeExactMethod(Object object, String methodName,\n+            Object[] args) throws NoSuchMethodException,\n+            IllegalAccessException, InvocationTargetException {\n+        if (args == null) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }\n+        int arguments = args.length;\n+        Class<?>[] parameterTypes = new Class[arguments];\n+        for (int i = 0; i < arguments; i++) {\n+            parameterTypes[i] = args[i].getClass();\n+        }\n+        return invokeExactMethod(object, methodName, args, parameterTypes);\n+    }\n+\n+    /**\n+     * <p>Invoke a method whose parameter types match exactly the parameter\n+     * types given.</p>\n+     *\n+     * <p>This uses reflection to invoke the method obtained from a call to\n+     * <code>getAccessibleMethod()</code>.</p>\n+     *\n+     * @param object invoke method on this object\n+     * @param methodName get method with this name\n+     * @param args use these arguments - treat null as empty array\n+     * @param parameterTypes match these parameters - treat null as empty array\n+     * @return The value returned by the invoked method\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the\n+     *  method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible\n+     *  via reflection\n+     */\n+    public static Object invokeExactMethod(Object object, String methodName,\n+            Object[] args, Class<?>[] parameterTypes)\n+            throws NoSuchMethodException, IllegalAccessException,\n+            InvocationTargetException {\n+        if (args == null) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }\n+        if (parameterTypes == null) {\n+            parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;\n+        }\n+        Method method = getAccessibleMethod(object.getClass(), methodName,\n+                parameterTypes);\n+        if (method == null) {\n+            throw new NoSuchMethodException(\"No such accessible method: \"\n+                    + methodName + \"() on object: \"\n+                    + object.getClass().getName());\n+        }\n+        return method.invoke(object, args);\n+    }\n+\n+    /**\n+     * <p>Invoke a static method whose parameter types match exactly the parameter\n+     * types given.</p>\n+     *\n+     * <p>This uses reflection to invoke the method obtained from a call to\n+     * {@link #getAccessibleMethod(Class, String, Class[])}.</p>\n+     *\n+     * @param cls invoke static method on this class\n+     * @param methodName get method with this name\n+     * @param args use these arguments - treat null as empty array\n+     * @param parameterTypes match these parameters - treat null as empty array\n+     * @return The value returned by the invoked method\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the\n+     *  method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible\n+     *  via reflection\n+     */\n+    public static Object invokeExactStaticMethod(Class<?> cls, String methodName,\n+            Object[] args, Class<?>[] parameterTypes)\n+            throws NoSuchMethodException, IllegalAccessException,\n+            InvocationTargetException {\n+        if (args == null) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }\n+        if (parameterTypes == null) {\n+            parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;\n+        }\n+        Method method = getAccessibleMethod(cls, methodName, parameterTypes);\n+        if (method == null) {\n+            throw new NoSuchMethodException(\"No such accessible method: \"\n+                    + methodName + \"() on class: \" + cls.getName());\n+        }\n+        return method.invoke(null, args);\n+    }\n+\n+    /**\n+     * <p>Invoke a named static method whose parameter type matches the object type.</p>\n+     *\n+     * <p>This method delegates the method search to {@link #getMatchingAccessibleMethod(Class, String, Class[])}.</p>\n+     *\n+     * <p>This method supports calls to methods taking primitive parameters \n+     * via passing in wrapping classes. So, for example, a <code>Boolean</code> class\n+     * would match a <code>boolean</code> primitive.</p>\n+     *\n+     * <p> This is a convenient wrapper for\n+     * {@link #invokeStaticMethod(Class objectClass,String methodName,Object [] args)}.\n+     * </p>\n+     *\n+     * @param cls invoke static method on this class\n+     * @param methodName get method with this name\n+     * @param arg use this argument\n+     * @return The value returned by the invoked method\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the\n+     *  method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible\n+     *  via reflection\n+     */\n+    public static Object invokeStaticMethod(Class<?> cls, String methodName,\n+            Object arg) throws NoSuchMethodException, IllegalAccessException,\n+            InvocationTargetException {\n+        return invokeStaticMethod(cls, methodName, new Object[] { arg });\n+    }\n+\n+    /**\n+     * <p>Invoke a named static method whose parameter type matches the object type.</p>\n+     *\n+     * <p>This method delegates the method search to {@link #getMatchingAccessibleMethod(Class, String, Class[])}.</p>\n+     *\n+     * <p>This method supports calls to methods taking primitive parameters \n+     * via passing in wrapping classes. So, for example, a <code>Boolean</code> class\n+     * would match a <code>boolean</code> primitive.</p>\n+     *\n+     * <p> This is a convenient wrapper for\n+     * {@link #invokeStaticMethod(Class objectClass,String methodName,Object [] args,Class[] parameterTypes)}.\n+     * </p>\n+     *\n+     * @param cls invoke static method on this class\n+     * @param methodName get method with this name\n+     * @param args use these arguments - treat null as empty array\n+     * @return The value returned by the invoked method\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the\n+     *  method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible\n+     *  via reflection\n+     */\n+    public static Object invokeStaticMethod(Class<?> cls, String methodName,\n+            Object[] args) throws NoSuchMethodException,\n+            IllegalAccessException, InvocationTargetException {\n+        if (args == null) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }\n+        int arguments = args.length;\n+        Class<?>[] parameterTypes = new Class[arguments];\n+        for (int i = 0; i < arguments; i++) {\n+            parameterTypes[i] = args[i].getClass();\n+        }\n+        return invokeStaticMethod(cls, methodName, args, parameterTypes);\n+    }\n+\n+    /**\n+     * <p>Invoke a named static method whose parameter type matches the object type.</p>\n+     *\n+     * <p>This method delegates the method search to {@link #getMatchingAccessibleMethod(Class, String, Class[])}.</p>\n+     *\n+     * <p>This method supports calls to methods taking primitive parameters \n+     * via passing in wrapping classes. So, for example, a <code>Boolean</code> class\n+     * would match a <code>boolean</code> primitive.</p>\n+     *\n+     *\n+     * @param cls invoke static method on this class\n+     * @param methodName get method with this name\n+     * @param args use these arguments - treat null as empty array\n+     * @param parameterTypes match these parameters - treat null as empty array\n+     * @return The value returned by the invoked method\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the\n+     *  method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible\n+     *  via reflection\n+     */\n+    public static Object invokeStaticMethod(Class<?> cls, String methodName,\n+            Object[] args, Class<?>[] parameterTypes)\n+            throws NoSuchMethodException, IllegalAccessException,\n+            InvocationTargetException {\n+        if (parameterTypes == null) {\n+            parameterTypes = ArrayUtils.EMPTY_CLASS_ARRAY;\n+        }\n+        if (args == null) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }\n+        Method method = getMatchingAccessibleMethod(cls, methodName,\n+                parameterTypes);\n+        if (method == null) {\n+            throw new NoSuchMethodException(\"No such accessible method: \"\n+                    + methodName + \"() on class: \" + cls.getName());\n+        }\n+        return method.invoke(null, args);\n+    }\n+\n+    /**\n+     * <p>Invoke a static method whose parameter type matches exactly the object\n+     * type.</p>\n+     *\n+     * <p> This is a convenient wrapper for\n+     * {@link #invokeExactStaticMethod(Class objectClass,String methodName,Object [] args)}.\n+     * </p>\n+     *\n+     * @param cls invoke static method on this class\n+     * @param methodName get method with this name\n+     * @param arg use this argument\n+     * @return The value returned by the invoked method\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the\n+     *  method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible\n+     *  via reflection\n+     */\n+    public static Object invokeExactStaticMethod(Class<?> cls, String methodName,\n+            Object arg) throws NoSuchMethodException, IllegalAccessException,\n+            InvocationTargetException {\n+        return invokeExactStaticMethod(cls, methodName, new Object[] { arg });\n+    }\n+\n+    /**\n+     * <p>Invoke a static method whose parameter types match exactly the object\n+     * types.</p>\n+     *\n+     * <p> This uses reflection to invoke the method obtained from a call to\n+     * {@link #getAccessibleMethod(Class, String, Class[])}.</p>\n+     *\n+     * @param cls invoke static method on this class\n+     * @param methodName get method with this name\n+     * @param args use these arguments - treat null as empty array\n+     * @return The value returned by the invoked method\n+     *\n+     * @throws NoSuchMethodException if there is no such accessible method\n+     * @throws InvocationTargetException wraps an exception thrown by the\n+     *  method invoked\n+     * @throws IllegalAccessException if the requested method is not accessible\n+     *  via reflection\n+     */\n+    public static Object invokeExactStaticMethod(Class<?> cls, String methodName,\n+            Object[] args) throws NoSuchMethodException,\n+            IllegalAccessException, InvocationTargetException {\n+        if (args == null) {\n+            args = ArrayUtils.EMPTY_OBJECT_ARRAY;\n+        }\n+        int arguments = args.length;\n+        Class<?>[] parameterTypes = new Class[arguments];\n+        for (int i = 0; i < arguments; i++) {\n+            parameterTypes[i] = args[i].getClass();\n+        }\n+        return invokeExactStaticMethod(cls, methodName, args, parameterTypes);\n+    }\n+\n+    /**\n+     * <p>Return an accessible method (that is, one that can be invoked via\n+     * reflection) with given name and a single parameter.  If no such method\n+     * can be found, return <code>null</code>.\n+     * Basically, a convenience wrapper that constructs a <code>Class</code>\n+     * array for you.</p>\n+     *\n+     * @param cls get method from this class\n+     * @param methodName get method with this name\n+     * @param parameterType taking this type of parameter\n+     * @return The accessible method\n+     */\n+    public static Method getAccessibleMethod(Class<?> cls, String methodName,\n+            Class<?> parameterType) {\n+        return getAccessibleMethod(cls, methodName,\n+                new Class<?>[] { parameterType });\n+    }\n+\n+    /**\n+     * <p>Return an accessible method (that is, one that can be invoked via\n+     * reflection) with given name and parameters.  If no such method\n+     * can be found, return <code>null</code>.\n+     * This is just a convenient wrapper for\n+     * {@link #getAccessibleMethod(Method method)}.</p>\n+     *\n+     * @param cls get method from this class\n+     * @param methodName get method with this name\n+     * @param parameterTypes with these parameters types\n+     * @return The accessible method\n+     */\n+    public static Method getAccessibleMethod(Class<?> cls, String methodName,\n+            Class<?>[] parameterTypes) {\n+        try {\n+            return getAccessibleMethod(cls.getMethod(methodName,\n+                    parameterTypes));\n+        } catch (NoSuchMethodException e) {\n+            return (null);\n+        }\n+    }\n+\n+    /**\n+     * <p>Return an accessible method (that is, one that can be invoked via\n+     * reflection) that implements the specified Method.  If no such method\n+     * can be found, return <code>null</code>.</p>\n+     *\n+     * @param method The method that we wish to call\n+     * @return The accessible method\n+     */\n+    public static Method getAccessibleMethod(Method method) {\n+        if (!MemberUtils.isAccessible(method)) {\n+            return null;\n+        }\n+        // If the declaring class is public, we are done\n+        Class<?> cls = method.getDeclaringClass();\n+        if (Modifier.isPublic(cls.getModifiers())) {\n+            return method;\n+        }\n+        String methodName = method.getName();\n+        Class<?>[] parameterTypes = method.getParameterTypes();\n+\n+        // Check the implemented interfaces and subinterfaces\n+        method = getAccessibleMethodFromInterfaceNest(cls, methodName,\n+                parameterTypes);\n+\n+        // Check the superclass chain\n+        if (method == null) {\n+            method = getAccessibleMethodFromSuperclass(cls, methodName,\n+                    parameterTypes);\n+        }\n+        return method;\n+    }\n+\n+    /**\n+     * <p>Return an accessible method (that is, one that can be invoked via\n+     * reflection) by scanning through the superclasses. If no such method\n+     * can be found, return <code>null</code>.</p>\n+     *\n+     * @param cls Class to be checked\n+     * @param methodName Method name of the method we wish to call\n+     * @param parameterTypes The parameter type signatures\n+     */\n+    private static Method getAccessibleMethodFromSuperclass(Class<?> cls,\n+            String methodName, Class<?>[] parameterTypes) {\n+        Class<?> parentClass = cls.getSuperclass();\n+        while (parentClass != null) {\n+            if (Modifier.isPublic(parentClass.getModifiers())) {\n+                try {\n+                    return parentClass.getMethod(methodName, parameterTypes);\n+                } catch (NoSuchMethodException e) {\n+                    return null;\n+                }\n+            }\n+            parentClass = parentClass.getSuperclass();\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * <p>Return an accessible method (that is, one that can be invoked via\n+     * reflection) that implements the specified method, by scanning through\n+     * all implemented interfaces and subinterfaces.  If no such method\n+     * can be found, return <code>null</code>.</p>\n+     *\n+     * <p> There isn't any good reason why this method must be private.\n+     * It is because there doesn't seem any reason why other classes should\n+     * call this rather than the higher level methods.</p>\n+     *\n+     * @param cls Parent class for the interfaces to be checked\n+     * @param methodName Method name of the method we wish to call\n+     * @param parameterTypes The parameter type signatures\n+     */\n+    private static Method getAccessibleMethodFromInterfaceNest(Class<?> cls,\n+            String methodName, Class<?>[] parameterTypes) {\n+        Method method = null;\n+\n+        // Search up the superclass chain\n+        for (; cls != null; cls = cls.getSuperclass()) {\n+\n+            // Check the implemented interfaces of the parent class\n+            Class<?>[] interfaces = cls.getInterfaces();\n+            for (int i = 0; i < interfaces.length; i++) {\n+                // Is this interface public?\n+                if (!Modifier.isPublic(interfaces[i].getModifiers())) {\n+                    continue;\n+                }\n+                // Does the method exist on this interface?\n+                try {\n+                    method = interfaces[i].getDeclaredMethod(methodName,\n+                            parameterTypes);\n+                } catch (NoSuchMethodException e) {\n+                    /*\n+                     * Swallow, if no method is found after the loop then this\n+                     * method returns null.\n+                     */\n+                }\n+                if (method != null) {\n+                    break;\n+                }\n+                // Recursively check our parent interfaces\n+                method = getAccessibleMethodFromInterfaceNest(interfaces[i],\n+                        methodName, parameterTypes);\n+                if (method != null) {\n+                    break;\n+                }\n+            }\n+        }\n+        return method;\n+    }\n+\n+    /**\n+     * <p>Find an accessible method that matches the given name and has compatible parameters.\n+     * Compatible parameters mean that every method parameter is assignable from \n+     * the given parameters.\n+     * In other words, it finds a method with the given name \n+     * that will take the parameters given.<p>\n+     *\n+     * <p>This method is used by \n+     * {@link \n+     * #invokeMethod(Object object, String methodName, Object[] args, Class[] parameterTypes)}.\n+     *\n+     * <p>This method can match primitive parameter by passing in wrapper classes.\n+     * For example, a <code>Boolean</code> will match a primitive <code>boolean</code>\n+     * parameter.\n+     *\n+     * @param cls find method in this class\n+     * @param methodName find method with this name\n+     * @param parameterTypes find method with most compatible parameters \n+     * @return The accessible method\n+     */\n+    public static Method getMatchingAccessibleMethod(Class<?> cls,\n+            String methodName, Class<?>[] parameterTypes) {\n+        try {\n+            Method method = cls.getMethod(methodName, parameterTypes);\n+            MemberUtils.setAccessibleWorkaround(method);\n+            return method;\n+        } catch (NoSuchMethodException e) { /* SWALLOW */\n+        }\n+        // search through all methods\n+        Method bestMatch = null;\n+        Method[] methods = cls.getMethods();\n+        for (int i = 0, size = methods.length; i < size; i++) {\n+            if (methods[i].getName().equals(methodName)) {\n+                // compare parameters\n+                if (ClassUtils.isAssignable(parameterTypes, methods[i]\n+                        .getParameterTypes(), true)) {\n+                    // get accessible version of method\n+                    Method accessibleMethod = getAccessibleMethod(methods[i]);\n+                    if (accessibleMethod != null) {\n+                        if (bestMatch == null\n+                                || MemberUtils.compareParameterTypes(\n+                                        accessibleMethod.getParameterTypes(),\n+                                        bestMatch.getParameterTypes(),\n+                                        parameterTypes) < 0) {\n+                            bestMatch = accessibleMethod;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        if (bestMatch != null) {\n+            MemberUtils.setAccessibleWorkaround(bestMatch);\n+        }\n+        return bestMatch;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.reflect;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+\n+import org.apache.commons.lang3.Validate;\n+\n+/**\n+ * <p>Utility methods focusing on type inspection, particularly with regard to\n+ * generics.</p>\n+ * @author James Carman\n+ * @author Matt Benson\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class TypeUtils {\n+\n+    /**\n+     * Get the raw type of a Java type, given its context. Primarily for use\n+     * with {@link TypeVariable}s and {@link GenericArrayType}s, or when you do\n+     * not know the runtime type of <code>type</code>: if you know you have a\n+     * {@link Class} instance, it is already raw; if you know you have a\n+     * {@link ParameterizedType}, its raw type is only a method call away.\n+     * @param enclosingType context\n+     * @param type to read\n+     * @return Class<?>\n+     */\n+    // original code stolen from commons [proxy]'s 2.0 branch, then kneaded until firm\n+    public static Class<?> getRawType(Type enclosingType, Type type) {\n+        if (type instanceof Class<?>) {\n+            // it is raw, no problem\n+            return (Class<?>) type;\n+        }\n+        if (type instanceof ParameterizedType) {\n+            // simple enough to get the raw type of a ParameterizedType\n+            return (Class<?>) ((ParameterizedType) type).getRawType();\n+        }\n+        if (type instanceof TypeVariable<?>) {\n+            Validate.notNull(enclosingType,\n+                    \"Cannot get raw type of TypeVariable without enclosing type\");\n+            // resolve the variable against the enclosing type, hope for the best (casting)\n+            return (Class<?>) resolveVariable(enclosingType, (TypeVariable<?>) type);\n+        }\n+        if (type instanceof GenericArrayType) {\n+            Validate.notNull(enclosingType,\n+                    \"Cannot get raw type of GenericArrayType without enclosing type\");\n+            // not included in original code, but not too difficult:  just have to get raw component type...\n+            Class<?> rawComponentType = getRawType(enclosingType, ((GenericArrayType) type)\n+                    .getGenericComponentType());\n+            // ...and know how to reflectively create array types, uncommon but not unheard of:\n+            return Array.newInstance(rawComponentType, 0).getClass();\n+        }\n+        throw new IllegalArgumentException(String.valueOf(type));\n+    }\n+\n+    /**\n+     * We plan to return Class<?> from the top-level call, as evidenced by the\n+     * cast in the above method, but to handle recursion and falling back up the\n+     * graph, as it were, return Type\n+     * @param enclosingType\n+     * @param typeVar\n+     * @return Type resolved\n+     */\n+    // original code stolen from commons [proxy]'s 2.0 branch, then kneaded until firm\n+    private static Type resolveVariable(Type enclosingType, TypeVariable<?> typeVar) {\n+        if (enclosingType instanceof ParameterizedType) {\n+            ParameterizedType parameterizedEnclosingType = (ParameterizedType) enclosingType;\n+            TypeVariable<?>[] typeVariables = getRawType(null,\n+                    parameterizedEnclosingType.getRawType()).getTypeParameters();\n+            //look for the matching variable:\n+            for (int i = 0; i < typeVariables.length; i++) {\n+                if (typeVariables[i].equals(typeVar)) {\n+                    return parameterizedEnclosingType.getActualTypeArguments()[i];\n+                }\n+            }\n+            //otherwise recurse to try against raw class\n+            Type result = resolveVariable(parameterizedEnclosingType.getRawType(), typeVar);\n+            //unroll variable if returned\n+            if (result instanceof TypeVariable<?>) {\n+                return resolveVariable(enclosingType, (TypeVariable<?>) result);\n+            }\n+            return result;\n+        }\n+        if (enclosingType instanceof Class<?>) {\n+            Class<?> enclosingClass = (Class<?>) enclosingType;\n+            Type result = null;\n+            Type genericSuperclass = enclosingClass.getGenericSuperclass();\n+            if (genericSuperclass != null && !Object.class.equals(genericSuperclass)) {\n+                result = resolveVariable(genericSuperclass, typeVar);\n+            }\n+            if (result == null) {\n+                for (Type genericInterface : enclosingClass.getGenericInterfaces()) {\n+                    result = resolveVariable(genericInterface, typeVar);\n+                    if (result != null) {\n+                        break;\n+                    }\n+                }\n+            }\n+            if (result != null) {\n+                return result;\n+            }\n+        }\n+        throw new IllegalArgumentException(String.valueOf(typeVar));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/text/CompositeFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.text;\n+\n+import java.text.FieldPosition;\n+import java.text.Format;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+\n+/**\n+ * Formats using one formatter and parses using a different formatter. An\n+ * example of use for this would be a webapp where data is taken in one way and\n+ * stored in a database another way.\n+ * \n+ * @author Apache Software Foundation\n+ * @author Archimedes Trajano\n+ * @version $Id$\n+ */\n+public class CompositeFormat extends Format {\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = -4329119827877627683L;\n+\n+    /** The parser to use. */\n+    private final Format parser;\n+    /** The formatter to use. */\n+    private final Format formatter;\n+\n+    /**\n+     * Create a format that points its parseObject method to one implementation\n+     * and its format method to another.\n+     * \n+     * @param parser implementation\n+     * @param formatter implementation\n+     */\n+    public CompositeFormat(Format parser, Format formatter) {\n+        this.parser = parser;\n+        this.formatter = formatter;\n+    }\n+\n+    /**\n+     * Uses the formatter Format instance.\n+     * \n+     * @param obj the object to format\n+     * @param toAppendTo the {@link StringBuffer} to append to\n+     * @param pos the FieldPosition to use (or ignore).\n+     * @return <code>toAppendTo</code>\n+     * @see Format#format(Object, StringBuffer, FieldPosition)\n+     */\n+    @Override\n+    public StringBuffer format(Object obj, StringBuffer toAppendTo,\n+            FieldPosition pos) {\n+        return formatter.format(obj, toAppendTo, pos);\n+    }\n+\n+    /**\n+     * Uses the parser Format instance.\n+     * \n+     * @param source the String source\n+     * @param pos the ParsePosition containing the position to parse from, will\n+     *            be updated according to parsing success (index) or failure\n+     *            (error index)\n+     * @return the parsed Object\n+     * @see Format#parseObject(String, ParsePosition)\n+     */\n+    @Override\n+    public Object parseObject(String source, ParsePosition pos) {\n+        return parser.parseObject(source, pos);\n+    }\n+\n+    /**\n+     * Provides access to the parser Format implementation.\n+     * \n+     * @return parser Format implementation\n+     */\n+    public Format getParser() {\n+        return this.parser;\n+    }\n+\n+    /**\n+     * Provides access to the parser Format implementation.\n+     * \n+     * @return formatter Format implementation\n+     */\n+    public Format getFormatter() {\n+        return this.formatter;\n+    }\n+\n+    /**\n+     * Utility method to parse and then reformat a String.\n+     * \n+     * @param input String to reformat\n+     * @return A reformatted String\n+     * @throws ParseException thrown by parseObject(String) call\n+     */\n+    public String reformat(String input) throws ParseException {\n+        return format(parseObject(input));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.text;\n+\n+import java.text.Format;\n+import java.text.MessageFormat;\n+import java.text.ParsePosition;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import org.apache.commons.lang3.Validate;\n+\n+/**\n+ * Extends <code>java.text.MessageFormat</code> to allow pluggable/additional formatting\n+ * options for embedded format elements.  Client code should specify a registry\n+ * of <code>FormatFactory</code> instances associated with <code>String</code>\n+ * format names.  This registry will be consulted when the format elements are \n+ * parsed from the message pattern.  In this way custom patterns can be specified,\n+ * and the formats supported by <code>java.text.MessageFormat</code> can be overridden\n+ * at the format and/or format style level (see MessageFormat).  A \"format element\"\n+ * embedded in the message pattern is specified (<b>()?</b> signifies optionality):<br />\n+ * <code>{</code><i>argument-number</i><b>(</b><code>,</code><i>format-name</i><b>(</b><code>,</code><i>format-style</i><b>)?)?</b><code>}</code>\n+ *\n+ * <p>\n+ * <i>format-name</i> and <i>format-style</i> values are trimmed of surrounding whitespace\n+ * in the manner of <code>java.text.MessageFormat</code>.  If <i>format-name</i> denotes\n+ * <code>FormatFactory formatFactoryInstance</code> in <code>registry</code>, a <code>Format</code>\n+ * matching <i>format-name</i> and <i>format-style</i> is requested from\n+ * <code>formatFactoryInstance</code>.  If this is successful, the <code>Format</code>\n+ * found is used for this format element.\n+ * </p>\n+ *\n+ * <p>NOTICE: The various subformat mutator methods are considered unnecessary; they exist on the parent\n+ * class to allow the type of customization which it is the job of this class to provide in\n+ * a configurable fashion.  These methods have thus been disabled and will throw\n+ * <code>UnsupportedOperationException</code> if called.\n+ * </p>\n+ * \n+ * <p>Limitations inherited from <code>java.text.MessageFormat</code>:\n+ * <ul>\n+ * <li>When using \"choice\" subformats, support for nested formatting instructions is limited\n+ *     to that provided by the base class.</li>\n+ * <li>Thread-safety of <code>Format</code>s, including <code>MessageFormat</code> and thus\n+ *     <code>ExtendedMessageFormat</code>, is not guaranteed.</li>\n+ * </ul>\n+ * </p>\n+ * \n+ * @author Apache Software Foundation\n+ * @author Matt Benson\n+ * @author Niall Pemberton\n+ * @since 2.4\n+ * @version $Id$\n+ */\n+public class ExtendedMessageFormat extends MessageFormat {\n+    private static final long serialVersionUID = -2362048321261811743L;\n+\n+    private static final String DUMMY_PATTERN = \"\";\n+    private static final String ESCAPED_QUOTE = \"''\";\n+    private static final char START_FMT = ',';\n+    private static final char END_FE = '}';\n+    private static final char START_FE = '{';\n+    private static final char QUOTE = '\\'';\n+\n+    private String toPattern;\n+    private final Map<String, ? extends FormatFactory> registry;\n+\n+    /**\n+     * Create a new ExtendedMessageFormat for the default locale.\n+     * \n+     * @param pattern  the pattern to use, not null\n+     * @throws IllegalArgumentException in case of a bad pattern.\n+     */\n+    public ExtendedMessageFormat(String pattern) {\n+        this(pattern, Locale.getDefault());\n+    }\n+\n+    /**\n+     * Create a new ExtendedMessageFormat.\n+     * \n+     * @param pattern  the pattern to use, not null\n+     * @param locale  the locale to use, not null\n+     * @throws IllegalArgumentException in case of a bad pattern.\n+     */\n+    public ExtendedMessageFormat(String pattern, Locale locale) {\n+        this(pattern, locale, null);\n+    }\n+\n+    /**\n+     * Create a new ExtendedMessageFormat for the default locale.\n+     * \n+     * @param pattern  the pattern to use, not null\n+     * @param registry  the registry of format factories, may be null\n+     * @throws IllegalArgumentException in case of a bad pattern.\n+     */\n+    public ExtendedMessageFormat(String pattern, Map<String, ? extends FormatFactory> registry) {\n+        this(pattern, Locale.getDefault(), registry);\n+    }\n+\n+    /**\n+     * Create a new ExtendedMessageFormat.\n+     * \n+     * @param pattern  the pattern to use, not null\n+     * @param locale  the locale to use, not null\n+     * @param registry  the registry of format factories, may be null\n+     * @throws IllegalArgumentException in case of a bad pattern.\n+     */\n+    public ExtendedMessageFormat(String pattern, Locale locale, Map<String, ? extends FormatFactory> registry) {\n+        super(DUMMY_PATTERN);\n+        setLocale(locale);\n+        this.registry = registry;\n+        applyPattern(pattern);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public String toPattern() {\n+        return toPattern;\n+    }\n+\n+    /**\n+     * Apply the specified pattern.\n+     * \n+     * @param pattern String\n+     */\n+    @Override\n+    public final void applyPattern(String pattern) {\n+        if (registry == null) {\n+            super.applyPattern(pattern);\n+            toPattern = super.toPattern();\n+            return;\n+        }\n+        ArrayList<Format> foundFormats = new ArrayList<Format>();\n+        ArrayList<String> foundDescriptions = new ArrayList<String>();\n+        StringBuilder stripCustom = new StringBuilder(pattern.length());\n+\n+        ParsePosition pos = new ParsePosition(0);\n+        char[] c = pattern.toCharArray();\n+        int fmtCount = 0;\n+        while (pos.getIndex() < pattern.length()) {\n+            switch (c[pos.getIndex()]) {\n+            case QUOTE:\n+                appendQuotedString(pattern, pos, stripCustom, true);\n+                break;\n+            case START_FE:\n+                fmtCount++;\n+                seekNonWs(pattern, pos);\n+                int start = pos.getIndex();\n+                int index = readArgumentIndex(pattern, next(pos));\n+                stripCustom.append(START_FE).append(index);\n+                seekNonWs(pattern, pos);\n+                Format format = null;\n+                String formatDescription = null;\n+                if (c[pos.getIndex()] == START_FMT) {\n+                    formatDescription = parseFormatDescription(pattern,\n+                            next(pos));\n+                    format = getFormat(formatDescription);\n+                    if (format == null) {\n+                        stripCustom.append(START_FMT).append(formatDescription);\n+                    }\n+                }\n+                foundFormats.add(format);\n+                foundDescriptions.add(format == null ? null : formatDescription);\n+                Validate.isTrue(foundFormats.size() == fmtCount);\n+                Validate.isTrue(foundDescriptions.size() == fmtCount);\n+                if (c[pos.getIndex()] != END_FE) {\n+                    throw new IllegalArgumentException(\n+                            \"Unreadable format element at position \" + start);\n+                }\n+                //$FALL-THROUGH$\n+            default:\n+                stripCustom.append(c[pos.getIndex()]);\n+                next(pos);\n+            }\n+        }\n+        super.applyPattern(stripCustom.toString());\n+        toPattern = insertFormats(super.toPattern(), foundDescriptions);\n+        if (containsElements(foundFormats)) {\n+            Format[] origFormats = getFormats();\n+            // only loop over what we know we have, as MessageFormat on Java 1.3 \n+            // seems to provide an extra format element:\n+            int i = 0;\n+            for (Iterator<Format> it = foundFormats.iterator(); it.hasNext(); i++) {\n+                Format f = it.next();\n+                if (f != null) {\n+                    origFormats[i] = f;\n+                }\n+            }\n+            super.setFormats(origFormats);\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @throws UnsupportedOperationException\n+     */\n+    @Override\n+    public void setFormat(int formatElementIndex, Format newFormat) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @throws UnsupportedOperationException\n+     */\n+    @Override\n+    public void setFormatByArgumentIndex(int argumentIndex, Format newFormat) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @throws UnsupportedOperationException\n+     */\n+    @Override\n+    public void setFormats(Format[] newFormats) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @throws UnsupportedOperationException\n+     */\n+    @Override\n+    public void setFormatsByArgumentIndex(Format[] newFormats) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Get a custom format from a format description.\n+     * \n+     * @param desc String\n+     * @return Format\n+     */\n+    private Format getFormat(String desc) {\n+        if (registry != null) {\n+            String name = desc;\n+            String args = null;\n+            int i = desc.indexOf(START_FMT);\n+            if (i > 0) {\n+                name = desc.substring(0, i).trim();\n+                args = desc.substring(i + 1).trim();\n+            }\n+            FormatFactory factory = registry.get(name);\n+            if (factory != null) {\n+                return factory.getFormat(name, args, getLocale());\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Read the argument index from the current format element\n+     * \n+     * @param pattern pattern to parse\n+     * @param pos current parse position\n+     * @return argument index\n+     */\n+    private int readArgumentIndex(String pattern, ParsePosition pos) {\n+        int start = pos.getIndex();\n+        seekNonWs(pattern, pos);\n+        StringBuffer result = new StringBuffer();\n+        boolean error = false;\n+        for (; !error && pos.getIndex() < pattern.length(); next(pos)) {\n+            char c = pattern.charAt(pos.getIndex());\n+            if (Character.isWhitespace(c)) {\n+                seekNonWs(pattern, pos);\n+                c = pattern.charAt(pos.getIndex());\n+                if (c != START_FMT && c != END_FE) {\n+                    error = true;\n+                    continue;\n+                }\n+            }\n+            if ((c == START_FMT || c == END_FE) && result.length() > 0) {\n+                try {\n+                    return Integer.parseInt(result.toString());\n+                } catch (NumberFormatException e) {\n+                    // we've already ensured only digits, so unless something\n+                    // outlandishly large was specified we should be okay.\n+                }\n+            }\n+            error = !Character.isDigit(c);\n+            result.append(c);\n+        }\n+        if (error) {\n+            throw new IllegalArgumentException(\n+                    \"Invalid format argument index at position \" + start + \": \"\n+                            + pattern.substring(start, pos.getIndex()));\n+        }\n+        throw new IllegalArgumentException(\n+                \"Unterminated format element at position \" + start);\n+    }\n+\n+    /**\n+     * Parse the format component of a format element.\n+     * \n+     * @param pattern string to parse\n+     * @param pos current parse position\n+     * @return Format description String\n+     */\n+    private String parseFormatDescription(String pattern, ParsePosition pos) {\n+        int start = pos.getIndex();\n+        seekNonWs(pattern, pos);\n+        int text = pos.getIndex();\n+        int depth = 1;\n+        for (; pos.getIndex() < pattern.length(); next(pos)) {\n+            switch (pattern.charAt(pos.getIndex())) {\n+            case START_FE:\n+                depth++;\n+                break;\n+            case END_FE:\n+                depth--;\n+                if (depth == 0) {\n+                    return pattern.substring(text, pos.getIndex());\n+                }\n+                break;\n+            case QUOTE:\n+                getQuotedString(pattern, pos, false);\n+                break;\n+            }\n+        }\n+        throw new IllegalArgumentException(\n+                \"Unterminated format element at position \" + start);\n+    }\n+\n+    /**\n+     * Insert formats back into the pattern for toPattern() support.\n+     *\n+     * @param pattern source\n+     * @param customPatterns The custom patterns to re-insert, if any\n+     * @return full pattern\n+     */\n+    private String insertFormats(String pattern, ArrayList<String> customPatterns) {\n+        if (!containsElements(customPatterns)) {\n+            return pattern;\n+        }\n+        StringBuilder sb = new StringBuilder(pattern.length() * 2);\n+        ParsePosition pos = new ParsePosition(0);\n+        int fe = -1;\n+        int depth = 0;\n+        while (pos.getIndex() < pattern.length()) {\n+            char c = pattern.charAt(pos.getIndex());\n+            switch (c) {\n+            case QUOTE:\n+                appendQuotedString(pattern, pos, sb, false);\n+                break;\n+            case START_FE:\n+                depth++;\n+                if (depth == 1) {\n+                    fe++;\n+                    sb.append(START_FE).append(\n+                            readArgumentIndex(pattern, next(pos)));\n+                    String customPattern = customPatterns.get(fe);\n+                    if (customPattern != null) {\n+                        sb.append(START_FMT).append(customPattern);\n+                    }\n+                }\n+                break;\n+            case END_FE:\n+                depth--;\n+                //$FALL-THROUGH$\n+            default:\n+                sb.append(c);\n+                next(pos);\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Consume whitespace from the current parse position.\n+     * \n+     * @param pattern String to read\n+     * @param pos current position\n+     */\n+    private void seekNonWs(String pattern, ParsePosition pos) {\n+        int len = 0;\n+        char[] buffer = pattern.toCharArray();\n+        do {\n+            len = StrMatcher.splitMatcher().isMatch(buffer, pos.getIndex());\n+            pos.setIndex(pos.getIndex() + len);\n+        } while (len > 0 && pos.getIndex() < pattern.length());\n+    }\n+\n+    /**\n+     * Convenience method to advance parse position by 1\n+     * \n+     * @param pos ParsePosition\n+     * @return <code>pos</code>\n+     */\n+    private ParsePosition next(ParsePosition pos) {\n+        pos.setIndex(pos.getIndex() + 1);\n+        return pos;\n+    }\n+\n+    /**\n+     * Consume a quoted string, adding it to <code>appendTo</code> if\n+     * specified.\n+     * \n+     * @param pattern pattern to parse\n+     * @param pos current parse position\n+     * @param appendTo optional StringBuffer to append\n+     * @param escapingOn whether to process escaped quotes\n+     * @return <code>appendTo</code>\n+     */\n+    private StringBuilder appendQuotedString(String pattern, ParsePosition pos,\n+            StringBuilder appendTo, boolean escapingOn) {\n+        int start = pos.getIndex();\n+        char[] c = pattern.toCharArray();\n+        if (escapingOn && c[start] == QUOTE) {\n+            next(pos);\n+            return appendTo == null ? null : appendTo.append(QUOTE);\n+        }\n+        int lastHold = start;\n+        for (int i = pos.getIndex(); i < pattern.length(); i++) {\n+            if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n+                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n+                        QUOTE);\n+                pos.setIndex(i + ESCAPED_QUOTE.length());\n+                lastHold = pos.getIndex();\n+                continue;\n+            }\n+            switch (c[pos.getIndex()]) {\n+            case QUOTE:\n+                next(pos);\n+                return appendTo == null ? null : appendTo.append(c, lastHold,\n+                        pos.getIndex() - lastHold);\n+            default:\n+                next(pos);\n+            }\n+        }\n+        throw new IllegalArgumentException(\n+                \"Unterminated quoted string at position \" + start);\n+    }\n+\n+    /**\n+     * Consume quoted string only\n+     * \n+     * @param pattern pattern to parse\n+     * @param pos current parse position\n+     * @param escapingOn whether to process escaped quotes\n+     */\n+    private void getQuotedString(String pattern, ParsePosition pos,\n+            boolean escapingOn) {\n+        appendQuotedString(pattern, pos, null, escapingOn);\n+    }\n+\n+    /**\n+     * Learn whether the specified Collection contains non-null elements.\n+     * @param coll to check\n+     * @return <code>true</code> if some Object was found, <code>false</code> otherwise.\n+     */\n+    private boolean containsElements(Collection<?> coll) {\n+        if (coll == null || coll.size() == 0) {\n+            return false;\n+        }\n+        for (Iterator<?> iter = coll.iterator(); iter.hasNext();) {\n+            if (iter.next() != null) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/text/FormatFactory.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.text;\n+\n+import java.text.Format;\n+import java.util.Locale;\n+\n+/**\n+ * Format factory.\n+ * \n+ * @author Apache Software Foundation\n+ * @author Niall Pemberton\n+ * @since 2.4\n+ * @version $Id$\n+ */\n+public interface FormatFactory {\n+\n+    /**\n+     * Create or retrieve a format instance.\n+     *\n+     * @param name The format type name\n+     * @param arguments Arguments used to create the format instance. This allows the\n+     *                  <code>FormatFactory</code> to implement the \"format style\"\n+     *                  concept from <code>java.text.MessageFormat</code>.\n+     * @param locale The locale, may be null\n+     * @return The format instance\n+     */\n+    Format getFormat(String name, String arguments, Locale locale);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/text/StrBuilder.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.text;\n+\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.commons.lang3.SystemUtils;\n+\n+/**\n+ * Builds a string from constituent parts providing a more flexible and powerful API\n+ * than StringBuffer.\n+ * <p>\n+ * The main differences from StringBuffer/StringBuilder are:\n+ * <ul>\n+ * <li>Not synchronized</li>\n+ * <li>Not final</li>\n+ * <li>Subclasses have direct access to character array</li>\n+ * <li>Additional methods\n+ *  <ul>\n+ *   <li>appendWithSeparators - adds an array of values, with a separator</li>\n+ *   <li>appendPadding - adds a length padding characters</li>\n+ *   <li>appendFixedLength - adds a fixed width field to the builder</li>\n+ *   <li>toCharArray/getChars - simpler ways to get a range of the character array</li>\n+ *   <li>delete - delete char or string</li>\n+ *   <li>replace - search and replace for a char or string</li>\n+ *   <li>leftString/rightString/midString - substring without exceptions</li>\n+ *   <li>contains - whether the builder contains a char or string</li>\n+ *   <li>size/clear/isEmpty - collections style API methods</li>\n+ *  </ul>\n+ * </li>\n+ * </ul>\n+ * <li>Views\n+ *  <ul>\n+ *   <li>asTokenizer - uses the internal buffer as the source of a StrTokenizer</li>\n+ *   <li>asReader - uses the internal buffer as the source of a Reader</li>\n+ *   <li>asWriter - allows a Writer to write directly to the internal buffer</li>\n+ *  </ul>\n+ * </li>\n+ * </ul>\n+ * <p>\n+ * The aim has been to provide an API that mimics very closely what StringBuffer\n+ * provides, but with additional methods. It should be noted that some edge cases,\n+ * with invalid indices or null input, have been altered - see individual methods.\n+ * The biggest of these changes is that by default, null will not output the text\n+ * 'null'. This can be controlled by a property, {@link #setNullText(String)}.\n+ * <p>\n+ * Prior to 3.0, this class implemented Cloneable but did not implement the \n+ * clone method so could not be used. From 3.0 onwards it no longer implements \n+ * the interface. \n+ *\n+ * @author Apache Software Foundation\n+ * @author Robert Scholte\n+ * @since 2.2\n+ * @version $Id$\n+ */\n+public class StrBuilder implements CharSequence, Appendable {\n+\n+    /**\n+     * The extra capacity for new builders.\n+     */\n+    static final int CAPACITY = 32;\n+\n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 7628716375283629643L;\n+\n+    /** Internal data storage. */\n+    protected char[] buffer; // TODO make private?\n+    /** Current size of the buffer. */\n+    protected int size; // TODO make private?\n+    /** The new line. */\n+    private String newLine;\n+    /** The null text. */\n+    private String nullText;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that creates an empty builder initial capacity 32 characters.\n+     */\n+    public StrBuilder() {\n+        this(CAPACITY);\n+    }\n+\n+    /**\n+     * Constructor that creates an empty builder the specified initial capacity.\n+     *\n+     * @param initialCapacity  the initial capacity, zero or less will be converted to 32\n+     */\n+    public StrBuilder(int initialCapacity) {\n+        super();\n+        if (initialCapacity <= 0) {\n+            initialCapacity = CAPACITY;\n+        }\n+        buffer = new char[initialCapacity];\n+    }\n+\n+    /**\n+     * Constructor that creates a builder from the string, allocating\n+     * 32 extra characters for growth.\n+     *\n+     * @param str  the string to copy, null treated as blank string\n+     */\n+    public StrBuilder(String str) {\n+        super();\n+        if (str == null) {\n+            buffer = new char[CAPACITY];\n+        } else {\n+            buffer = new char[str.length() + CAPACITY];\n+            append(str);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the text to be appended when a new line is added.\n+     *\n+     * @return the new line text, null means use system default\n+     */\n+    public String getNewLineText() {\n+        return newLine;\n+    }\n+\n+    /**\n+     * Sets the text to be appended when a new line is added.\n+     *\n+     * @param newLine  the new line text, null means use system default\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder setNewLineText(String newLine) {\n+        this.newLine = newLine;\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the text to be appended when null is added.\n+     *\n+     * @return the null text, null means no append\n+     */\n+    public String getNullText() {\n+        return nullText;\n+    }\n+\n+    /**\n+     * Sets the text to be appended when null is added.\n+     *\n+     * @param nullText  the null text, null means no append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder setNullText(String nullText) {\n+        if (nullText != null && nullText.length() == 0) {\n+            nullText = null;\n+        }\n+        this.nullText = nullText;\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the length of the string builder.\n+     *\n+     * @return the length\n+     */\n+    public int length() {\n+        return size;\n+    }\n+\n+    /**\n+     * Updates the length of the builder by either dropping the last characters\n+     * or adding filler of unicode zero.\n+     *\n+     * @param length  the length to set to, must be zero or positive\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the length is negative\n+     */\n+    public StrBuilder setLength(int length) {\n+        if (length < 0) {\n+            throw new StringIndexOutOfBoundsException(length);\n+        }\n+        if (length < size) {\n+            size = length;\n+        } else if (length > size) {\n+            ensureCapacity(length);\n+            int oldEnd = size;\n+            int newEnd = length;\n+            size = length;\n+            for (int i = oldEnd; i < newEnd; i++) {\n+                buffer[i] = '\\0';\n+            }\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the current size of the internal character array buffer.\n+     *\n+     * @return the capacity\n+     */\n+    public int capacity() {\n+        return buffer.length;\n+    }\n+\n+    /**\n+     * Checks the capacity and ensures that it is at least the size specified.\n+     *\n+     * @param capacity  the capacity to ensure\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder ensureCapacity(int capacity) {\n+        if (capacity > buffer.length) {\n+            char[] old = buffer;\n+            buffer = new char[capacity * 2];\n+            System.arraycopy(old, 0, buffer, 0, size);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Minimizes the capacity to the actual length of the string.\n+     *\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder minimizeCapacity() {\n+        if (buffer.length > length()) {\n+            char[] old = buffer;\n+            buffer = new char[length()];\n+            System.arraycopy(old, 0, buffer, 0, size);\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the length of the string builder.\n+     * <p>\n+     * This method is the same as {@link #length()} and is provided to match the\n+     * API of Collections.\n+     *\n+     * @return the length\n+     */\n+    public int size() {\n+        return size;\n+    }\n+\n+    /**\n+     * Checks is the string builder is empty (convenience Collections API style method).\n+     * <p>\n+     * This method is the same as checking {@link #length()} and is provided to match the\n+     * API of Collections.\n+     *\n+     * @return <code>true</code> if the size is <code>0</code>.\n+     */\n+    public boolean isEmpty() {\n+        return size == 0;\n+    }\n+\n+    /**\n+     * Clears the string builder (convenience Collections API style method).\n+     * <p>\n+     * This method does not reduce the size of the internal character buffer.\n+     * To do that, call <code>clear()</code> followed by {@link #minimizeCapacity()}.\n+     * <p>\n+     * This method is the same as {@link #setLength(int)} called with zero\n+     * and is provided to match the API of Collections.\n+     *\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder clear() {\n+        size = 0;\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the character at the specified index.\n+     *\n+     * @see #setCharAt(int, char)\n+     * @see #deleteCharAt(int)\n+     * @param index  the index to retrieve, must be valid\n+     * @return the character at the index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public char charAt(int index) {\n+        if (index < 0 || index >= length()) {\n+            throw new StringIndexOutOfBoundsException(index);\n+        }\n+        return buffer[index];\n+    }\n+\n+    /**\n+     * Sets the character at the specified index.\n+     *\n+     * @see #charAt(int)\n+     * @see #deleteCharAt(int)\n+     * @param index  the index to set\n+     * @param ch  the new character\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder setCharAt(int index, char ch) {\n+        if (index < 0 || index >= length()) {\n+            throw new StringIndexOutOfBoundsException(index);\n+        }\n+        buffer[index] = ch;\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the character at the specified index.\n+     *\n+     * @see #charAt(int)\n+     * @see #setCharAt(int, char)\n+     * @param index  the index to delete\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder deleteCharAt(int index) {\n+        if (index < 0 || index >= size) {\n+            throw new StringIndexOutOfBoundsException(index);\n+        }\n+        deleteImpl(index, index + 1, 1);\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Copies the builder's character array into a new character array.\n+     * \n+     * @return a new array that represents the contents of the builder\n+     */\n+    public char[] toCharArray() {\n+        if (size == 0) {\n+            return ArrayUtils.EMPTY_CHAR_ARRAY;\n+        }\n+        char chars[] = new char[size];\n+        System.arraycopy(buffer, 0, chars, 0, size);\n+        return chars;\n+    }\n+\n+    /**\n+     * Copies part of the builder's character array into a new character array.\n+     * \n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param endIndex  the end index, exclusive, must be valid except that\n+     *  if too large it is treated as end of string\n+     * @return a new array that holds part of the contents of the builder\n+     * @throws IndexOutOfBoundsException if startIndex is invalid,\n+     *  or if endIndex is invalid (but endIndex greater than size is valid)\n+     */\n+    public char[] toCharArray(int startIndex, int endIndex) {\n+        endIndex = validateRange(startIndex, endIndex);\n+        int len = endIndex - startIndex;\n+        if (len == 0) {\n+            return ArrayUtils.EMPTY_CHAR_ARRAY;\n+        }\n+        char chars[] = new char[len];\n+        System.arraycopy(buffer, startIndex, chars, 0, len);\n+        return chars;\n+    }\n+\n+    /**\n+     * Copies the character array into the specified array.\n+     * \n+     * @param destination  the destination array, null will cause an array to be created\n+     * @return the input array, unless that was null or too small\n+     */\n+    public char[] getChars(char[] destination) {\n+        int len = length();\n+        if (destination == null || destination.length < len) {\n+            destination = new char[len];\n+        }\n+        System.arraycopy(buffer, 0, destination, 0, len);\n+        return destination;\n+    }\n+\n+    /**\n+     * Copies the character array into the specified array.\n+     *\n+     * @param startIndex  first index to copy, inclusive, must be valid\n+     * @param endIndex  last index, exclusive, must be valid\n+     * @param destination  the destination array, must not be null or too small\n+     * @param destinationIndex  the index to start copying in destination\n+     * @throws NullPointerException if the array is null\n+     * @throws IndexOutOfBoundsException if any index is invalid\n+     */\n+    public void getChars(int startIndex, int endIndex, char destination[], int destinationIndex) {\n+        if (startIndex < 0) {\n+            throw new StringIndexOutOfBoundsException(startIndex);\n+        }\n+        if (endIndex < 0 || endIndex > length()) {\n+            throw new StringIndexOutOfBoundsException(endIndex);\n+        }\n+        if (startIndex > endIndex) {\n+            throw new StringIndexOutOfBoundsException(\"end < start\");\n+        }\n+        System.arraycopy(buffer, startIndex, destination, destinationIndex, endIndex - startIndex);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Appends the new line string to this string builder.\n+     * <p>\n+     * The new line string can be altered using {@link #setNewLineText(String)}.\n+     * This might be used to force the output to always use Unix line endings\n+     * even when on Windows.\n+     *\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder appendNewLine() {\n+        if (newLine == null)  {\n+            append(SystemUtils.LINE_SEPARATOR);\n+            return this;\n+        }\n+        return append(newLine);\n+    }\n+\n+    /**\n+     * Appends the text representing <code>null</code> to this string builder.\n+     *\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder appendNull() {\n+        if (nullText == null)  {\n+            return this;\n+        }\n+        return append(nullText);\n+    }\n+\n+    /**\n+     * Appends an object to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param obj  the object to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(Object obj) {\n+        if (obj == null) {\n+            return appendNull();\n+        } \n+        return append(obj.toString());        \n+    }\n+\n+    /**\n+     * Appends a CharSequence to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param seq  the CharSequence to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(CharSequence seq) {\n+        if (seq == null) {\n+            return appendNull();\n+        } \n+        return append(seq.toString());        \n+    }\n+\n+    /**\n+     * Appends part of a CharSequence to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param seq  the CharSequence to append\n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param length  the length to append, must be valid\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(CharSequence seq, int startIndex, int length) {\n+        if (seq == null) {\n+            return appendNull();\n+        } \n+        return append(seq.toString(), startIndex, length);\n+    }\n+\n+    /**\n+     * Appends a string to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param str  the string to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(String str) {\n+        if (str == null) {\n+            return appendNull();\n+        }\n+        int strLen = str.length();\n+        if (strLen > 0) {\n+            int len = length();\n+            ensureCapacity(len + strLen);\n+            str.getChars(0, strLen, buffer, len);\n+            size += strLen;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends part of a string to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param str  the string to append\n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param length  the length to append, must be valid\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(String str, int startIndex, int length) {\n+        if (str == null) {\n+            return appendNull();\n+        }\n+        if (startIndex < 0 || startIndex > str.length()) {\n+            throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n+        }\n+        if (length < 0 || (startIndex + length) > str.length()) {\n+            throw new StringIndexOutOfBoundsException(\"length must be valid\");\n+        }\n+        if (length > 0) {\n+            int len = length();\n+            ensureCapacity(len + length);\n+            str.getChars(startIndex, startIndex + length, buffer, len);\n+            size += length;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends a string buffer to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param str  the string buffer to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(StringBuffer str) {\n+        if (str == null) {\n+            return appendNull();\n+        }\n+        int strLen = str.length();\n+        if (strLen > 0) {\n+            int len = length();\n+            ensureCapacity(len + strLen);\n+            str.getChars(0, strLen, buffer, len);\n+            size += strLen;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends part of a string buffer to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param str  the string to append\n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param length  the length to append, must be valid\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(StringBuffer str, int startIndex, int length) {\n+        if (str == null) {\n+            return appendNull();\n+        }\n+        if (startIndex < 0 || startIndex > str.length()) {\n+            throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n+        }\n+        if (length < 0 || (startIndex + length) > str.length()) {\n+            throw new StringIndexOutOfBoundsException(\"length must be valid\");\n+        }\n+        if (length > 0) {\n+            int len = length();\n+            ensureCapacity(len + length);\n+            str.getChars(startIndex, startIndex + length, buffer, len);\n+            size += length;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends another string builder to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param str  the string builder to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(StrBuilder str) {\n+        if (str == null) {\n+            return appendNull();\n+        }\n+        int strLen = str.length();\n+        if (strLen > 0) {\n+            int len = length();\n+            ensureCapacity(len + strLen);\n+            System.arraycopy(str.buffer, 0, buffer, len, strLen);\n+            size += strLen;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends part of a string builder to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param str  the string to append\n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param length  the length to append, must be valid\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(StrBuilder str, int startIndex, int length) {\n+        if (str == null) {\n+            return appendNull();\n+        }\n+        if (startIndex < 0 || startIndex > str.length()) {\n+            throw new StringIndexOutOfBoundsException(\"startIndex must be valid\");\n+        }\n+        if (length < 0 || (startIndex + length) > str.length()) {\n+            throw new StringIndexOutOfBoundsException(\"length must be valid\");\n+        }\n+        if (length > 0) {\n+            int len = length();\n+            ensureCapacity(len + length);\n+            str.getChars(startIndex, startIndex + length, buffer, len);\n+            size += length;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends a char array to the string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param chars  the char array to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(char[] chars) {\n+        if (chars == null) {\n+            return appendNull();\n+        }\n+        int strLen = chars.length;\n+        if (strLen > 0) {\n+            int len = length();\n+            ensureCapacity(len + strLen);\n+            System.arraycopy(chars, 0, buffer, len, strLen);\n+            size += strLen;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends a char array to the string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param chars  the char array to append\n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param length  the length to append, must be valid\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(char[] chars, int startIndex, int length) {\n+        if (chars == null) {\n+            return appendNull();\n+        }\n+        if (startIndex < 0 || startIndex > chars.length) {\n+            throw new StringIndexOutOfBoundsException(\"Invalid startIndex: \" + length);\n+        }\n+        if (length < 0 || (startIndex + length) > chars.length) {\n+            throw new StringIndexOutOfBoundsException(\"Invalid length: \" + length);\n+        }\n+        if (length > 0) {\n+            int len = length();\n+            ensureCapacity(len + length);\n+            System.arraycopy(chars, startIndex, buffer, len, length);\n+            size += length;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends a boolean value to the string builder.\n+     *\n+     * @param value  the value to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(boolean value) {\n+        if (value) {\n+            ensureCapacity(size + 4);\n+            buffer[size++] = 't';\n+            buffer[size++] = 'r';\n+            buffer[size++] = 'u';\n+            buffer[size++] = 'e';\n+        } else {\n+            ensureCapacity(size + 5);\n+            buffer[size++] = 'f';\n+            buffer[size++] = 'a';\n+            buffer[size++] = 'l';\n+            buffer[size++] = 's';\n+            buffer[size++] = 'e';\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends a char value to the string builder.\n+     *\n+     * @param ch  the value to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(char ch) {\n+        int len = length();\n+        ensureCapacity(len + 1);\n+        buffer[size++] = ch;\n+        return this;\n+    }\n+\n+    /**\n+     * Appends an int value to the string builder using <code>String.valueOf</code>.\n+     *\n+     * @param value  the value to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(int value) {\n+        return append(String.valueOf(value));\n+    }\n+\n+    /**\n+     * Appends a long value to the string builder using <code>String.valueOf</code>.\n+     *\n+     * @param value  the value to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(long value) {\n+        return append(String.valueOf(value));\n+    }\n+\n+    /**\n+     * Appends a float value to the string builder using <code>String.valueOf</code>.\n+     *\n+     * @param value  the value to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(float value) {\n+        return append(String.valueOf(value));\n+    }\n+\n+    /**\n+     * Appends a double value to the string builder using <code>String.valueOf</code>.\n+     *\n+     * @param value  the value to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(double value) {\n+        return append(String.valueOf(value));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Appends an object followed by a new line to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param obj  the object to append\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendln(Object obj) {\n+        return append(obj).appendNewLine();\n+    }\n+\n+    /**\n+     * Appends a string followed by a new line to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param str  the string to append\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendln(String str) {\n+        return append(str).appendNewLine();\n+    }\n+\n+    /**\n+     * Appends part of a string followed by a new line to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param str  the string to append\n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param length  the length to append, must be valid\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendln(String str, int startIndex, int length) {\n+        return append(str, startIndex, length).appendNewLine();\n+    }\n+\n+    /**\n+     * Appends a string buffer followed by a new line to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param str  the string buffer to append\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendln(StringBuffer str) {\n+        return append(str).appendNewLine();\n+    }\n+\n+    /**\n+     * Appends part of a string buffer followed by a new line to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param str  the string to append\n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param length  the length to append, must be valid\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendln(StringBuffer str, int startIndex, int length) {\n+        return append(str, startIndex, length).appendNewLine();\n+    }\n+\n+    /**\n+     * Appends another string builder followed by a new line to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param str  the string builder to append\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendln(StrBuilder str) {\n+        return append(str).appendNewLine();\n+    }\n+\n+    /**\n+     * Appends part of a string builder followed by a new line to this string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param str  the string to append\n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param length  the length to append, must be valid\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendln(StrBuilder str, int startIndex, int length) {\n+        return append(str, startIndex, length).appendNewLine();\n+    }\n+\n+    /**\n+     * Appends a char array followed by a new line to the string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param chars  the char array to append\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendln(char[] chars) {\n+        return append(chars).appendNewLine();\n+    }\n+\n+    /**\n+     * Appends a char array followed by a new line to the string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param chars  the char array to append\n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param length  the length to append, must be valid\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendln(char[] chars, int startIndex, int length) {\n+        return append(chars, startIndex, length).appendNewLine();\n+    }\n+\n+    /**\n+     * Appends a boolean value followed by a new line to the string builder.\n+     *\n+     * @param value  the value to append\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendln(boolean value) {\n+        return append(value).appendNewLine();\n+    }\n+\n+    /**\n+     * Appends a char value followed by a new line to the string builder.\n+     *\n+     * @param ch  the value to append\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendln(char ch) {\n+        return append(ch).appendNewLine();\n+    }\n+\n+    /**\n+     * Appends an int value followed by a new line to the string builder using <code>String.valueOf</code>.\n+     *\n+     * @param value  the value to append\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendln(int value) {\n+        return append(value).appendNewLine();\n+    }\n+\n+    /**\n+     * Appends a long value followed by a new line to the string builder using <code>String.valueOf</code>.\n+     *\n+     * @param value  the value to append\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendln(long value) {\n+        return append(value).appendNewLine();\n+    }\n+\n+    /**\n+     * Appends a float value followed by a new line to the string builder using <code>String.valueOf</code>.\n+     *\n+     * @param value  the value to append\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendln(float value) {\n+        return append(value).appendNewLine();\n+    }\n+\n+    /**\n+     * Appends a double value followed by a new line to the string builder using <code>String.valueOf</code>.\n+     *\n+     * @param value  the value to append\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendln(double value) {\n+        return append(value).appendNewLine();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Appends each item in an array to the builder without any separators.\n+     * Appending a null array will have no effect.\n+     * Each object is appended using {@link #append(Object)}.\n+     *\n+     * @param array  the array to append\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendAll(Object[] array) {\n+        if (array != null && array.length > 0) {\n+            for (int i = 0; i < array.length; i++) {\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends each item in a iterable to the builder without any separators.\n+     * Appending a null iterable will have no effect.\n+     * Each object is appended using {@link #append(Object)}.\n+     *\n+     * @param iterable  the iterable to append\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendAll(Iterable<?> iterable) {\n+        if (iterable != null) {\n+            Iterator<?> it = iterable.iterator();\n+            while (it.hasNext()) {\n+                append(it.next());\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends each item in an iterator to the builder without any separators.\n+     * Appending a null iterator will have no effect.\n+     * Each object is appended using {@link #append(Object)}.\n+     *\n+     * @param it  the iterator to append\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendAll(Iterator<?> it) {\n+        if (it != null) {\n+            while (it.hasNext()) {\n+                append(it.next());\n+            }\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Appends an array placing separators between each value, but\n+     * not before the first or after the last.\n+     * Appending a null array will have no effect.\n+     * Each object is appended using {@link #append(Object)}.\n+     *\n+     * @param array  the array to append\n+     * @param separator  the separator to use, null means no separator\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder appendWithSeparators(Object[] array, String separator) {\n+        if (array != null && array.length > 0) {\n+            separator = (separator == null ? \"\" : separator);\n+            append(array[0]);\n+            for (int i = 1; i < array.length; i++) {\n+                append(separator);\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends a iterable placing separators between each value, but\n+     * not before the first or after the last.\n+     * Appending a null iterable will have no effect.\n+     * Each object is appended using {@link #append(Object)}.\n+     *\n+     * @param iterable  the iterable to append\n+     * @param separator  the separator to use, null means no separator\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder appendWithSeparators(Iterable<?> iterable, String separator) {\n+        if (iterable != null) {\n+            separator = (separator == null ? \"\" : separator);\n+            Iterator<?> it = iterable.iterator();\n+            while (it.hasNext()) {\n+                append(it.next());\n+                if (it.hasNext()) {\n+                    append(separator);\n+                }\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends an iterator placing separators between each value, but\n+     * not before the first or after the last.\n+     * Appending a null iterator will have no effect.\n+     * Each object is appended using {@link #append(Object)}.\n+     *\n+     * @param it  the iterator to append\n+     * @param separator  the separator to use, null means no separator\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder appendWithSeparators(Iterator<?> it, String separator) {\n+        if (it != null) {\n+            separator = (separator == null ? \"\" : separator);\n+            while (it.hasNext()) {\n+                append(it.next());\n+                if (it.hasNext()) {\n+                    append(separator);\n+                }\n+            }\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Appends a separator if the builder is currently non-empty.\n+     * Appending a null separator will have no effect.\n+     * The separator is appended using {@link #append(String)}.\n+     * <p>\n+     * This method is useful for adding a separator each time around the\n+     * loop except the first.\n+     * <pre>\n+     * for (Iterator it = list.iterator(); it.hasNext(); ) {\n+     *   appendSeparator(\",\");\n+     *   append(it.next());\n+     * }\n+     * </pre>\n+     * Note that for this simple example, you should use\n+     * {@link #appendWithSeparators(Iterable, String)}.\n+     * \n+     * @param separator  the separator to use, null means no separator\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendSeparator(String separator) {\n+        return appendSeparator(separator, null);\n+    }\n+\n+    /**\n+     * Appends one of both separators to the StrBuilder.\n+     * If the builder is currently empty it will append the defaultIfEmpty-separator\n+     * Otherwise it will append the standard-separator\n+     * \n+     * Appending a null separator will have no effect.\n+     * The separator is appended using {@link #append(String)}.\n+     * <p>\n+     * This method is for example useful for constructing queries\n+     * <pre>\n+     * StrBuilder whereClause = new StrBuilder();\n+     * if(searchCommand.getPriority() != null) {\n+     *  whereClause.appendSeparator(\" and\", \" where\");\n+     *  whereClause.append(\" priority = ?\")\n+     * }\n+     * if(searchCommand.getComponent() != null) {\n+     *  whereClause.appendSeparator(\" and\", \" where\");\n+     *  whereClause.append(\" component = ?\")\n+     * }\n+     * selectClause.append(whereClause)\n+     * </pre>\n+     * \n+     * @param standard the separator if builder is not empty, null means no separator\n+     * @param defaultIfEmpty the separator if builder is empty, null means no separator\n+     * @return this, to enable chaining\n+     * @since 3.0\n+     */\n+    public StrBuilder appendSeparator(String standard, String defaultIfEmpty) {\n+        String str = isEmpty() ? defaultIfEmpty : standard;\n+        if (str != null) {\n+            append(str);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends a separator if the builder is currently non-empty.\n+     * The separator is appended using {@link #append(char)}.\n+     * <p>\n+     * This method is useful for adding a separator each time around the\n+     * loop except the first.\n+     * <pre>\n+     * for (Iterator it = list.iterator(); it.hasNext(); ) {\n+     *   appendSeparator(',');\n+     *   append(it.next());\n+     * }\n+     * </pre>\n+     * Note that for this simple example, you should use\n+     * {@link #appendWithSeparators(Iterable, String)}.\n+     * \n+     * @param separator  the separator to use\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendSeparator(char separator) {\n+        if (size() > 0) {\n+            append(separator);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Append one of both separators to the builder\n+     * If the builder is currently empty it will append the defaultIfEmpty-separator\n+     * Otherwise it will append the standard-separator\n+     *\n+     * The separator is appended using {@link #append(char)}.\n+     * @param standard the separator if builder is not empty\n+     * @param defaultIfEmpty the separator if builder is empty\n+     * @return this, to enable chaining\n+     * @since 3.0\n+     */\n+    public StrBuilder appendSeparator(char standard, char defaultIfEmpty) {\n+        if (size() > 0) {\n+            append(standard);\n+        }\n+        else {\n+            append(defaultIfEmpty);\n+        }\n+        return this;\n+    }\n+    /**\n+     * Appends a separator to the builder if the loop index is greater than zero.\n+     * Appending a null separator will have no effect.\n+     * The separator is appended using {@link #append(String)}.\n+     * <p>\n+     * This method is useful for adding a separator each time around the\n+     * loop except the first.\n+     * <pre>\n+     * for (int i = 0; i < list.size(); i++) {\n+     *   appendSeparator(\",\", i);\n+     *   append(list.get(i));\n+     * }\n+     * </pre>\n+     * Note that for this simple example, you should use\n+     * {@link #appendWithSeparators(Iterable, String)}.\n+     * \n+     * @param separator  the separator to use, null means no separator\n+     * @param loopIndex  the loop index\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendSeparator(String separator, int loopIndex) {\n+        if (separator != null && loopIndex > 0) {\n+            append(separator);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends a separator to the builder if the loop index is greater than zero.\n+     * The separator is appended using {@link #append(char)}.\n+     * <p>\n+     * This method is useful for adding a separator each time around the\n+     * loop except the first.\n+     * <pre>\n+     * for (int i = 0; i < list.size(); i++) {\n+     *   appendSeparator(\",\", i);\n+     *   append(list.get(i));\n+     * }\n+     * </pre>\n+     * Note that for this simple example, you should use\n+     * {@link #appendWithSeparators(Iterable, String)}.\n+     * \n+     * @param separator  the separator to use\n+     * @param loopIndex  the loop index\n+     * @return this, to enable chaining\n+     * @since 2.3\n+     */\n+    public StrBuilder appendSeparator(char separator, int loopIndex) {\n+        if (loopIndex > 0) {\n+            append(separator);\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Appends the pad character to the builder the specified number of times.\n+     * \n+     * @param length  the length to append, negative means no append\n+     * @param padChar  the character to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder appendPadding(int length, char padChar) {\n+        if (length >= 0) {\n+            ensureCapacity(size + length);\n+            for (int i = 0; i < length; i++) {\n+                buffer[size++] = padChar;\n+            }\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Appends an object to the builder padding on the left to a fixed width.\n+     * The <code>toString</code> of the object is used.\n+     * If the object is larger than the length, the left hand side is lost.\n+     * If the object is null, the null text value is used.\n+     * \n+     * @param obj  the object to append, null uses null text\n+     * @param width  the fixed field width, zero or negative has no effect\n+     * @param padChar  the pad character to use\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n+        if (width > 0) {\n+            ensureCapacity(size + width);\n+            String str = (obj == null ? getNullText() : obj.toString());\n+            if (str == null) {\n+                str = \"\";\n+            }\n+            int strLen = str.length();\n+            if (strLen >= width) {\n+                str.getChars(strLen - width, strLen, buffer, size);\n+            } else {\n+                int padLen = width - strLen;\n+                for (int i = 0; i < padLen; i++) {\n+                    buffer[size + i] = padChar;\n+                }\n+                str.getChars(0, strLen, buffer, size + padLen);\n+            }\n+            size += width;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends an object to the builder padding on the left to a fixed width.\n+     * The <code>String.valueOf</code> of the <code>int</code> value is used.\n+     * If the formatted value is larger than the length, the left hand side is lost.\n+     * \n+     * @param value  the value to append\n+     * @param width  the fixed field width, zero or negative has no effect\n+     * @param padChar  the pad character to use\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder appendFixedWidthPadLeft(int value, int width, char padChar) {\n+        return appendFixedWidthPadLeft(String.valueOf(value), width, padChar);\n+    }\n+\n+    /**\n+     * Appends an object to the builder padding on the right to a fixed length.\n+     * The <code>toString</code> of the object is used.\n+     * If the object is larger than the length, the right hand side is lost.\n+     * If the object is null, null text value is used.\n+     * \n+     * @param obj  the object to append, null uses null text\n+     * @param width  the fixed field width, zero or negative has no effect\n+     * @param padChar  the pad character to use\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n+        if (width > 0) {\n+            ensureCapacity(size + width);\n+            String str = (obj == null ? getNullText() : obj.toString());\n+            if (str == null) {\n+                str = \"\";\n+            }\n+            int strLen = str.length();\n+            if (strLen >= width) {\n+                str.getChars(0, width, buffer, size);\n+            } else {\n+                int padLen = width - strLen;\n+                str.getChars(0, strLen, buffer, size);\n+                for (int i = 0; i < padLen; i++) {\n+                    buffer[size + strLen + i] = padChar;\n+                }\n+            }\n+            size += width;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends an object to the builder padding on the right to a fixed length.\n+     * The <code>String.valueOf</code> of the <code>int</code> value is used.\n+     * If the object is larger than the length, the right hand side is lost.\n+     * \n+     * @param value  the value to append\n+     * @param width  the fixed field width, zero or negative has no effect\n+     * @param padChar  the pad character to use\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder appendFixedWidthPadRight(int value, int width, char padChar) {\n+        return appendFixedWidthPadRight(String.valueOf(value), width, padChar);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inserts the string representation of an object into this builder.\n+     * Inserting null will use the stored null text value.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param obj  the object to insert\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder insert(int index, Object obj) {\n+        if (obj == null) {\n+            return insert(index, nullText);\n+        }\n+        return insert(index, obj.toString());\n+    }\n+\n+    /**\n+     * Inserts the string into this builder.\n+     * Inserting null will use the stored null text value.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param str  the string to insert\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    @SuppressWarnings(\"null\") // str cannot be null\n+    public StrBuilder insert(int index, String str) {\n+        validateIndex(index);\n+        if (str == null) {\n+            str = nullText;\n+        }\n+        int strLen = (str == null ? 0 : str.length());\n+        if (strLen > 0) {\n+            int newSize = size + strLen;\n+            ensureCapacity(newSize);\n+            System.arraycopy(buffer, index, buffer, index + strLen, size - index);\n+            size = newSize;\n+            str.getChars(0, strLen, buffer, index); // str cannot be null here\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Inserts the character array into this builder.\n+     * Inserting null will use the stored null text value.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param chars  the char array to insert\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder insert(int index, char chars[]) {\n+        validateIndex(index);\n+        if (chars == null) {\n+            return insert(index, nullText);\n+        }\n+        int len = chars.length;\n+        if (len > 0) {\n+            ensureCapacity(size + len);\n+            System.arraycopy(buffer, index, buffer, index + len, size - index);\n+            System.arraycopy(chars, 0, buffer, index, len);\n+            size += len;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Inserts part of the character array into this builder.\n+     * Inserting null will use the stored null text value.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param chars  the char array to insert\n+     * @param offset  the offset into the character array to start at, must be valid\n+     * @param length  the length of the character array part to copy, must be positive\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if any index is invalid\n+     */\n+    public StrBuilder insert(int index, char chars[], int offset, int length) {\n+        validateIndex(index);\n+        if (chars == null) {\n+            return insert(index, nullText);\n+        }\n+        if (offset < 0 || offset > chars.length) {\n+            throw new StringIndexOutOfBoundsException(\"Invalid offset: \" + offset);\n+        }\n+        if (length < 0 || offset + length > chars.length) {\n+            throw new StringIndexOutOfBoundsException(\"Invalid length: \" + length);\n+        }\n+        if (length > 0) {\n+            ensureCapacity(size + length);\n+            System.arraycopy(buffer, index, buffer, index + length, size - index);\n+            System.arraycopy(chars, offset, buffer, index, length);\n+            size += length;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Inserts the value into this builder.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param value  the value to insert\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder insert(int index, boolean value) {\n+        validateIndex(index);\n+        if (value) {\n+            ensureCapacity(size + 4);\n+            System.arraycopy(buffer, index, buffer, index + 4, size - index);\n+            buffer[index++] = 't';\n+            buffer[index++] = 'r';\n+            buffer[index++] = 'u';\n+            buffer[index] = 'e';\n+            size += 4;\n+        } else {\n+            ensureCapacity(size + 5);\n+            System.arraycopy(buffer, index, buffer, index + 5, size - index);\n+            buffer[index++] = 'f';\n+            buffer[index++] = 'a';\n+            buffer[index++] = 'l';\n+            buffer[index++] = 's';\n+            buffer[index] = 'e';\n+            size += 5;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Inserts the value into this builder.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param value  the value to insert\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder insert(int index, char value) {\n+        validateIndex(index);\n+        ensureCapacity(size + 1);\n+        System.arraycopy(buffer, index, buffer, index + 1, size - index);\n+        buffer[index] = value;\n+        size++;\n+        return this;\n+    }\n+\n+    /**\n+     * Inserts the value into this builder.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param value  the value to insert\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder insert(int index, int value) {\n+        return insert(index, String.valueOf(value));\n+    }\n+\n+    /**\n+     * Inserts the value into this builder.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param value  the value to insert\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder insert(int index, long value) {\n+        return insert(index, String.valueOf(value));\n+    }\n+\n+    /**\n+     * Inserts the value into this builder.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param value  the value to insert\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder insert(int index, float value) {\n+        return insert(index, String.valueOf(value));\n+    }\n+\n+    /**\n+     * Inserts the value into this builder.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param value  the value to insert\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder insert(int index, double value) {\n+        return insert(index, String.valueOf(value));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Internal method to delete a range without validation.\n+     *\n+     * @param startIndex  the start index, must be valid\n+     * @param endIndex  the end index (exclusive), must be valid\n+     * @param len  the length, must be valid\n+     * @throws IndexOutOfBoundsException if any index is invalid\n+     */\n+    private void deleteImpl(int startIndex, int endIndex, int len) {\n+        System.arraycopy(buffer, endIndex, buffer, startIndex, size - endIndex);\n+        size -= len;\n+    }\n+\n+    /**\n+     * Deletes the characters between the two specified indices.\n+     *\n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param endIndex  the end index, exclusive, must be valid except\n+     *  that if too large it is treated as end of string\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder delete(int startIndex, int endIndex) {\n+        endIndex = validateRange(startIndex, endIndex);\n+        int len = endIndex - startIndex;\n+        if (len > 0) {\n+            deleteImpl(startIndex, endIndex, len);\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Deletes the character wherever it occurs in the builder.\n+     *\n+     * @param ch  the character to delete\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder deleteAll(char ch) {\n+        for (int i = 0; i < size; i++) {\n+            if (buffer[i] == ch) {\n+                int start = i;\n+                while (++i < size) {\n+                    if (buffer[i] != ch) {\n+                        break;\n+                    }\n+                }\n+                int len = i - start;\n+                deleteImpl(start, i, len);\n+                i -= len;\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the character wherever it occurs in the builder.\n+     *\n+     * @param ch  the character to delete\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder deleteFirst(char ch) {\n+        for (int i = 0; i < size; i++) {\n+            if (buffer[i] == ch) {\n+                deleteImpl(i, i + 1, 1);\n+                break;\n+            }\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Deletes the string wherever it occurs in the builder.\n+     *\n+     * @param str  the string to delete, null causes no action\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder deleteAll(String str) {\n+        int len = (str == null ? 0 : str.length());\n+        if (len > 0) {\n+            int index = indexOf(str, 0);\n+            while (index >= 0) {\n+                deleteImpl(index, index + len, len);\n+                index = indexOf(str, index);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the string wherever it occurs in the builder.\n+     *\n+     * @param str  the string to delete, null causes no action\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder deleteFirst(String str) {\n+        int len = (str == null ? 0 : str.length());\n+        if (len > 0) {\n+            int index = indexOf(str, 0);\n+            if (index >= 0) {\n+                deleteImpl(index, index + len, len);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Deletes all parts of the builder that the matcher matches.\n+     * <p>\n+     * Matchers can be used to perform advanced deletion behaviour.\n+     * For example you could write a matcher to delete all occurances\n+     * where the character 'a' is followed by a number.\n+     *\n+     * @param matcher  the matcher to use to find the deletion, null causes no action\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder deleteAll(StrMatcher matcher) {\n+        return replace(matcher, null, 0, size, -1);\n+    }\n+\n+    /**\n+     * Deletes the first match within the builder using the specified matcher.\n+     * <p>\n+     * Matchers can be used to perform advanced deletion behaviour.\n+     * For example you could write a matcher to delete\n+     * where the character 'a' is followed by a number.\n+     *\n+     * @param matcher  the matcher to use to find the deletion, null causes no action\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder deleteFirst(StrMatcher matcher) {\n+        return replace(matcher, null, 0, size, 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Internal method to delete a range without validation.\n+     *\n+     * @param startIndex  the start index, must be valid\n+     * @param endIndex  the end index (exclusive), must be valid\n+     * @param removeLen  the length to remove (endIndex - startIndex), must be valid\n+     * @param insertStr  the string to replace with, null means delete range\n+     * @param insertLen  the length of the insert string, must be valid\n+     * @throws IndexOutOfBoundsException if any index is invalid\n+     */\n+    private void replaceImpl(int startIndex, int endIndex, int removeLen, String insertStr, int insertLen) {\n+        int newSize = size - removeLen + insertLen;\n+        if (insertLen != removeLen) {\n+            ensureCapacity(newSize);\n+            System.arraycopy(buffer, endIndex, buffer, startIndex + insertLen, size - endIndex);\n+            size = newSize;\n+        }\n+        if (insertLen > 0) {\n+            insertStr.getChars(0, insertLen, buffer, startIndex);\n+        }\n+    }\n+\n+    /**\n+     * Replaces a portion of the string builder with another string.\n+     * The length of the inserted string does not have to match the removed length.\n+     *\n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param endIndex  the end index, exclusive, must be valid except\n+     *  that if too large it is treated as end of string\n+     * @param replaceStr  the string to replace with, null means delete range\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder replace(int startIndex, int endIndex, String replaceStr) {\n+        endIndex = validateRange(startIndex, endIndex);\n+        int insertLen = (replaceStr == null ? 0 : replaceStr.length());\n+        replaceImpl(startIndex, endIndex, endIndex - startIndex, replaceStr, insertLen);\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces the search character with the replace character\n+     * throughout the builder.\n+     *\n+     * @param search  the search character\n+     * @param replace  the replace character\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder replaceAll(char search, char replace) {\n+        if (search != replace) {\n+            for (int i = 0; i < size; i++) {\n+                if (buffer[i] == search) {\n+                    buffer[i] = replace;\n+                }\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Replaces the first instance of the search character with the\n+     * replace character in the builder.\n+     *\n+     * @param search  the search character\n+     * @param replace  the replace character\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder replaceFirst(char search, char replace) {\n+        if (search != replace) {\n+            for (int i = 0; i < size; i++) {\n+                if (buffer[i] == search) {\n+                    buffer[i] = replace;\n+                    break;\n+                }\n+            }\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces the search string with the replace string throughout the builder.\n+     *\n+     * @param searchStr  the search string, null causes no action to occur\n+     * @param replaceStr  the replace string, null is equivalent to an empty string\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder replaceAll(String searchStr, String replaceStr) {\n+        int searchLen = (searchStr == null ? 0 : searchStr.length());\n+        if (searchLen > 0) {\n+            int replaceLen = (replaceStr == null ? 0 : replaceStr.length());\n+            int index = indexOf(searchStr, 0);\n+            while (index >= 0) {\n+                replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen);\n+                index = indexOf(searchStr, index + replaceLen);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Replaces the first instance of the search string with the replace string.\n+     *\n+     * @param searchStr  the search string, null causes no action to occur\n+     * @param replaceStr  the replace string, null is equivalent to an empty string\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder replaceFirst(String searchStr, String replaceStr) {\n+        int searchLen = (searchStr == null ? 0 : searchStr.length());\n+        if (searchLen > 0) {\n+            int index = indexOf(searchStr, 0);\n+            if (index >= 0) {\n+                int replaceLen = (replaceStr == null ? 0 : replaceStr.length());\n+                replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces all matches within the builder with the replace string.\n+     * <p>\n+     * Matchers can be used to perform advanced replace behaviour.\n+     * For example you could write a matcher to replace all occurances\n+     * where the character 'a' is followed by a number.\n+     *\n+     * @param matcher  the matcher to use to find the deletion, null causes no action\n+     * @param replaceStr  the replace string, null is equivalent to an empty string\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder replaceAll(StrMatcher matcher, String replaceStr) {\n+        return replace(matcher, replaceStr, 0, size, -1);\n+    }\n+\n+    /**\n+     * Replaces the first match within the builder with the replace string.\n+     * <p>\n+     * Matchers can be used to perform advanced replace behaviour.\n+     * For example you could write a matcher to replace\n+     * where the character 'a' is followed by a number.\n+     *\n+     * @param matcher  the matcher to use to find the deletion, null causes no action\n+     * @param replaceStr  the replace string, null is equivalent to an empty string\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder replaceFirst(StrMatcher matcher, String replaceStr) {\n+        return replace(matcher, replaceStr, 0, size, 1);\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    /**\n+     * Advanced search and replaces within the builder using a matcher.\n+     * <p>\n+     * Matchers can be used to perform advanced behaviour.\n+     * For example you could write a matcher to delete all occurances\n+     * where the character 'a' is followed by a number.\n+     *\n+     * @param matcher  the matcher to use to find the deletion, null causes no action\n+     * @param replaceStr  the string to replace the match with, null is a delete\n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param endIndex  the end index, exclusive, must be valid except\n+     *  that if too large it is treated as end of string\n+     * @param replaceCount  the number of times to replace, -1 for replace all\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if start index is invalid\n+     */\n+    public StrBuilder replace(\n+            StrMatcher matcher, String replaceStr,\n+            int startIndex, int endIndex, int replaceCount) {\n+        endIndex = validateRange(startIndex, endIndex);\n+        return replaceImpl(matcher, replaceStr, startIndex, endIndex, replaceCount);\n+    }\n+\n+    /**\n+     * Replaces within the builder using a matcher.\n+     * <p>\n+     * Matchers can be used to perform advanced behaviour.\n+     * For example you could write a matcher to delete all occurances\n+     * where the character 'a' is followed by a number.\n+     *\n+     * @param matcher  the matcher to use to find the deletion, null causes no action\n+     * @param replaceStr  the string to replace the match with, null is a delete\n+     * @param from  the start index, must be valid\n+     * @param to  the end index (exclusive), must be valid\n+     * @param replaceCount  the number of times to replace, -1 for replace all\n+     * @return this, to enable chaining\n+     * @throws IndexOutOfBoundsException if any index is invalid\n+     */\n+    private StrBuilder replaceImpl(\n+            StrMatcher matcher, String replaceStr,\n+            int from, int to, int replaceCount) {\n+        if (matcher == null || size == 0) {\n+            return this;\n+        }\n+        int replaceLen = (replaceStr == null ? 0 : replaceStr.length());\n+        char[] buf = buffer;\n+        for (int i = from; i < to && replaceCount != 0; i++) {\n+            int removeLen = matcher.isMatch(buf, i, from, to);\n+            if (removeLen > 0) {\n+                replaceImpl(i, i + removeLen, removeLen, replaceStr, replaceLen);\n+                to = to - removeLen + replaceLen;\n+                i = i + replaceLen - 1;\n+                if (replaceCount > 0) {\n+                    replaceCount--;\n+                }\n+            }\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Reverses the string builder placing each character in the opposite index.\n+     * \n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder reverse() {\n+        if (size == 0) {\n+            return this;\n+        }\n+        \n+        int half = size / 2;\n+        char[] buf = buffer;\n+        for (int leftIdx = 0, rightIdx = size - 1; leftIdx < half; leftIdx++,rightIdx--) {\n+            char swap = buf[leftIdx];\n+            buf[leftIdx] = buf[rightIdx];\n+            buf[rightIdx] = swap;\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Trims the builder by removing characters less than or equal to a space\n+     * from the beginning and end.\n+     *\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder trim() {\n+        if (size == 0) {\n+            return this;\n+        }\n+        int len = size;\n+        char[] buf = buffer;\n+        int pos = 0;\n+        while (pos < len && buf[pos] <= ' ') {\n+            pos++;\n+        }\n+        while (pos < len && buf[len - 1] <= ' ') {\n+            len--;\n+        }\n+        if (len < size) {\n+            delete(len, size);\n+        }\n+        if (pos > 0) {\n+            delete(0, pos);\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether this builder starts with the specified string.\n+     * <p>\n+     * Note that this method handles null input quietly, unlike String.\n+     * \n+     * @param str  the string to search for, null returns false\n+     * @return true if the builder starts with the string\n+     */\n+    public boolean startsWith(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int len = str.length();\n+        if (len == 0) {\n+            return true;\n+        }\n+        if (len > size) {\n+            return false;\n+        }\n+        for (int i = 0; i < len; i++) {\n+            if (buffer[i] != str.charAt(i)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Checks whether this builder ends with the specified string.\n+     * <p>\n+     * Note that this method handles null input quietly, unlike String.\n+     * \n+     * @param str  the string to search for, null returns false\n+     * @return true if the builder ends with the string\n+     */\n+    public boolean endsWith(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int len = str.length();\n+        if (len == 0) {\n+            return true;\n+        }\n+        if (len > size) {\n+            return false;\n+        }\n+        int pos = size - len;\n+        for (int i = 0; i < len; i++,pos++) {\n+            if (buffer[pos] != str.charAt(i)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public CharSequence subSequence(int startIndex, int endIndex) {\n+      if (startIndex < 0) {\n+          throw new StringIndexOutOfBoundsException(startIndex);\n+      }\n+      if (endIndex > size) {\n+          throw new StringIndexOutOfBoundsException(endIndex);\n+      }\n+      if (startIndex > endIndex) {\n+          throw new StringIndexOutOfBoundsException(endIndex - startIndex);\n+      }\n+      return substring(startIndex, endIndex);\n+    }\n+\n+    /**\n+     * Extracts a portion of this string builder as a string.\n+     * \n+     * @param start  the start index, inclusive, must be valid\n+     * @return the new string\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public String substring(int start) {\n+        return substring(start, size);\n+    }\n+\n+    /**\n+     * Extracts a portion of this string builder as a string.\n+     * <p>\n+     * Note: This method treats an endIndex greater than the length of the\n+     * builder as equal to the length of the builder, and continues\n+     * without error, unlike StringBuffer or String.\n+     * \n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param endIndex  the end index, exclusive, must be valid except\n+     *  that if too large it is treated as end of string\n+     * @return the new string\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public String substring(int startIndex, int endIndex) {\n+        endIndex = validateRange(startIndex, endIndex);\n+        return new String(buffer, startIndex, endIndex - startIndex);\n+    }\n+\n+    /**\n+     * Extracts the leftmost characters from the string builder without\n+     * throwing an exception.\n+     * <p>\n+     * This method extracts the left <code>length</code> characters from\n+     * the builder. If this many characters are not available, the whole\n+     * builder is returned. Thus the returned string may be shorter than the\n+     * length requested.\n+     * \n+     * @param length  the number of characters to extract, negative returns empty string\n+     * @return the new string\n+     */\n+    public String leftString(int length) {\n+        if (length <= 0) {\n+            return \"\";\n+        } else if (length >= size) {\n+            return new String(buffer, 0, size);\n+        } else {\n+            return new String(buffer, 0, length);\n+        }\n+    }\n+\n+    /**\n+     * Extracts the rightmost characters from the string builder without\n+     * throwing an exception.\n+     * <p>\n+     * This method extracts the right <code>length</code> characters from\n+     * the builder. If this many characters are not available, the whole\n+     * builder is returned. Thus the returned string may be shorter than the\n+     * length requested.\n+     * \n+     * @param length  the number of characters to extract, negative returns empty string\n+     * @return the new string\n+     */\n+    public String rightString(int length) {\n+        if (length <= 0) {\n+            return \"\";\n+        } else if (length >= size) {\n+            return new String(buffer, 0, size);\n+        } else {\n+            return new String(buffer, size - length, length);\n+        }\n+    }\n+\n+    /**\n+     * Extracts some characters from the middle of the string builder without\n+     * throwing an exception.\n+     * <p>\n+     * This method extracts <code>length</code> characters from the builder\n+     * at the specified index.\n+     * If the index is negative it is treated as zero.\n+     * If the index is greater than the builder size, it is treated as the builder size.\n+     * If the length is negative, the empty string is returned.\n+     * If insufficient characters are available in the builder, as much as possible is returned.\n+     * Thus the returned string may be shorter than the length requested.\n+     * \n+     * @param index  the index to start at, negative means zero\n+     * @param length  the number of characters to extract, negative returns empty string\n+     * @return the new string\n+     */\n+    public String midString(int index, int length) {\n+        if (index < 0) {\n+            index = 0;\n+        }\n+        if (length <= 0 || index >= size) {\n+            return \"\";\n+        }\n+        if (size <= index + length) {\n+            return new String(buffer, index, size - index);\n+        } else {\n+            return new String(buffer, index, length);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks if the string builder contains the specified char.\n+     *\n+     * @param ch  the character to find\n+     * @return true if the builder contains the character\n+     */\n+    public boolean contains(char ch) {\n+        char[] thisBuf = buffer;\n+        for (int i = 0; i < this.size; i++) {\n+            if (thisBuf[i] == ch) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Checks if the string builder contains the specified string.\n+     *\n+     * @param str  the string to find\n+     * @return true if the builder contains the string\n+     */\n+    public boolean contains(String str) {\n+        return indexOf(str, 0) >= 0;\n+    }\n+\n+    /**\n+     * Checks if the string builder contains a string matched using the\n+     * specified matcher.\n+     * <p>\n+     * Matchers can be used to perform advanced searching behaviour.\n+     * For example you could write a matcher to search for the character\n+     * 'a' followed by a number.\n+     *\n+     * @param matcher  the matcher to use, null returns -1\n+     * @return true if the matcher finds a match in the builder\n+     */\n+    public boolean contains(StrMatcher matcher) {\n+        return indexOf(matcher, 0) >= 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Searches the string builder to find the first reference to the specified char.\n+     * \n+     * @param ch  the character to find\n+     * @return the first index of the character, or -1 if not found\n+     */\n+    public int indexOf(char ch) {\n+        return indexOf(ch, 0);\n+    }\n+\n+    /**\n+     * Searches the string builder to find the first reference to the specified char.\n+     * \n+     * @param ch  the character to find\n+     * @param startIndex  the index to start at, invalid index rounded to edge\n+     * @return the first index of the character, or -1 if not found\n+     */\n+    public int indexOf(char ch, int startIndex) {\n+        startIndex = (startIndex < 0 ? 0 : startIndex);\n+        if (startIndex >= size) {\n+            return -1;\n+        }\n+        char[] thisBuf = buffer;\n+        for (int i = startIndex; i < size; i++) {\n+            if (thisBuf[i] == ch) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Searches the string builder to find the first reference to the specified string.\n+     * <p>\n+     * Note that a null input string will return -1, whereas the JDK throws an exception.\n+     * \n+     * @param str  the string to find, null returns -1\n+     * @return the first index of the string, or -1 if not found\n+     */\n+    public int indexOf(String str) {\n+        return indexOf(str, 0);\n+    }\n+\n+    /**\n+     * Searches the string builder to find the first reference to the specified\n+     * string starting searching from the given index.\n+     * <p>\n+     * Note that a null input string will return -1, whereas the JDK throws an exception.\n+     * \n+     * @param str  the string to find, null returns -1\n+     * @param startIndex  the index to start at, invalid index rounded to edge\n+     * @return the first index of the string, or -1 if not found\n+     */\n+    public int indexOf(String str, int startIndex) {\n+        startIndex = (startIndex < 0 ? 0 : startIndex);\n+        if (str == null || startIndex >= size) {\n+            return -1;\n+        }\n+        int strLen = str.length();\n+        if (strLen == 1) {\n+            return indexOf(str.charAt(0), startIndex);\n+        }\n+        if (strLen == 0) {\n+            return startIndex;\n+        }\n+        if (strLen > size) {\n+            return -1;\n+        }\n+        char[] thisBuf = buffer;\n+        int len = size - strLen + 1;\n+        outer:\n+        for (int i = startIndex; i < len; i++) {\n+            for (int j = 0; j < strLen; j++) {\n+                if (str.charAt(j) != thisBuf[i + j]) {\n+                    continue outer;\n+                }\n+            }\n+            return i;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Searches the string builder using the matcher to find the first match.\n+     * <p>\n+     * Matchers can be used to perform advanced searching behaviour.\n+     * For example you could write a matcher to find the character 'a'\n+     * followed by a number.\n+     *\n+     * @param matcher  the matcher to use, null returns -1\n+     * @return the first index matched, or -1 if not found\n+     */\n+    public int indexOf(StrMatcher matcher) {\n+        return indexOf(matcher, 0);\n+    }\n+\n+    /**\n+     * Searches the string builder using the matcher to find the first\n+     * match searching from the given index.\n+     * <p>\n+     * Matchers can be used to perform advanced searching behaviour.\n+     * For example you could write a matcher to find the character 'a'\n+     * followed by a number.\n+     *\n+     * @param matcher  the matcher to use, null returns -1\n+     * @param startIndex  the index to start at, invalid index rounded to edge\n+     * @return the first index matched, or -1 if not found\n+     */\n+    public int indexOf(StrMatcher matcher, int startIndex) {\n+        startIndex = (startIndex < 0 ? 0 : startIndex);\n+        if (matcher == null || startIndex >= size) {\n+            return -1;\n+        }\n+        int len = size;\n+        char[] buf = buffer;\n+        for (int i = startIndex; i < len; i++) {\n+            if (matcher.isMatch(buf, i, startIndex, len) > 0) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Searches the string builder to find the last reference to the specified char.\n+     * \n+     * @param ch  the character to find\n+     * @return the last index of the character, or -1 if not found\n+     */\n+    public int lastIndexOf(char ch) {\n+        return lastIndexOf(ch, size - 1);\n+    }\n+\n+    /**\n+     * Searches the string builder to find the last reference to the specified char.\n+     * \n+     * @param ch  the character to find\n+     * @param startIndex  the index to start at, invalid index rounded to edge\n+     * @return the last index of the character, or -1 if not found\n+     */\n+    public int lastIndexOf(char ch, int startIndex) {\n+        startIndex = (startIndex >= size ? size - 1 : startIndex);\n+        if (startIndex < 0) {\n+            return -1;\n+        }\n+        for (int i = startIndex; i >= 0; i--) {\n+            if (buffer[i] == ch) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Searches the string builder to find the last reference to the specified string.\n+     * <p>\n+     * Note that a null input string will return -1, whereas the JDK throws an exception.\n+     * \n+     * @param str  the string to find, null returns -1\n+     * @return the last index of the string, or -1 if not found\n+     */\n+    public int lastIndexOf(String str) {\n+        return lastIndexOf(str, size - 1);\n+    }\n+\n+    /**\n+     * Searches the string builder to find the last reference to the specified\n+     * string starting searching from the given index.\n+     * <p>\n+     * Note that a null input string will return -1, whereas the JDK throws an exception.\n+     * \n+     * @param str  the string to find, null returns -1\n+     * @param startIndex  the index to start at, invalid index rounded to edge\n+     * @return the last index of the string, or -1 if not found\n+     */\n+    public int lastIndexOf(String str, int startIndex) {\n+        startIndex = (startIndex >= size ? size - 1 : startIndex);\n+        if (str == null || startIndex < 0) {\n+            return -1;\n+        }\n+        int strLen = str.length();\n+        if (strLen > 0 && strLen <= size) {\n+            if (strLen == 1) {\n+                return lastIndexOf(str.charAt(0), startIndex);\n+            }\n+\n+            outer:\n+            for (int i = startIndex - strLen + 1; i >= 0; i--) {\n+                for (int j = 0; j < strLen; j++) {\n+                    if (str.charAt(j) != buffer[i + j]) {\n+                        continue outer;\n+                    }\n+                }\n+                return i;\n+            }\n+            \n+        } else if (strLen == 0) {\n+            return startIndex;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Searches the string builder using the matcher to find the last match.\n+     * <p>\n+     * Matchers can be used to perform advanced searching behaviour.\n+     * For example you could write a matcher to find the character 'a'\n+     * followed by a number.\n+     *\n+     * @param matcher  the matcher to use, null returns -1\n+     * @return the last index matched, or -1 if not found\n+     */\n+    public int lastIndexOf(StrMatcher matcher) {\n+        return lastIndexOf(matcher, size);\n+    }\n+\n+    /**\n+     * Searches the string builder using the matcher to find the last\n+     * match searching from the given index.\n+     * <p>\n+     * Matchers can be used to perform advanced searching behaviour.\n+     * For example you could write a matcher to find the character 'a'\n+     * followed by a number.\n+     *\n+     * @param matcher  the matcher to use, null returns -1\n+     * @param startIndex  the index to start at, invalid index rounded to edge\n+     * @return the last index matched, or -1 if not found\n+     */\n+    public int lastIndexOf(StrMatcher matcher, int startIndex) {\n+        startIndex = (startIndex >= size ? size - 1 : startIndex);\n+        if (matcher == null || startIndex < 0) {\n+            return -1;\n+        }\n+        char[] buf = buffer;\n+        int endIndex = startIndex + 1;\n+        for (int i = startIndex; i >= 0; i--) {\n+            if (matcher.isMatch(buf, i, 0, endIndex) > 0) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a tokenizer that can tokenize the contents of this builder.\n+     * <p>\n+     * This method allows the contents of this builder to be tokenized.\n+     * The tokenizer will be setup by default to tokenize on space, tab,\n+     * newline and formfeed (as per StringTokenizer). These values can be\n+     * changed on the tokenizer class, before retrieving the tokens.\n+     * <p>\n+     * The returned tokenizer is linked to this builder. You may intermix\n+     * calls to the buider and tokenizer within certain limits, however\n+     * there is no synchronization. Once the tokenizer has been used once,\n+     * it must be {@link StrTokenizer#reset() reset} to pickup the latest\n+     * changes in the builder. For example:\n+     * <pre>\n+     * StrBuilder b = new StrBuilder();\n+     * b.append(\"a b \");\n+     * StrTokenizer t = b.asTokenizer();\n+     * String[] tokens1 = t.getTokenArray();  // returns a,b\n+     * b.append(\"c d \");\n+     * String[] tokens2 = t.getTokenArray();  // returns a,b (c and d ignored)\n+     * t.reset();              // reset causes builder changes to be picked up\n+     * String[] tokens3 = t.getTokenArray();  // returns a,b,c,d\n+     * </pre>\n+     * In addition to simply intermixing appends and tokenization, you can also\n+     * call the set methods on the tokenizer to alter how it tokenizes. Just\n+     * remember to call reset when you want to pickup builder changes.\n+     * <p>\n+     * Calling {@link StrTokenizer#reset(String)} or {@link StrTokenizer#reset(char[])}\n+     * with a non-null value will break the link with the builder.\n+     *\n+     * @return a tokenizer that is linked to this builder\n+     */\n+    public StrTokenizer asTokenizer() {\n+        return new StrBuilderTokenizer();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the contents of this builder as a Reader.\n+     * <p>\n+     * This method allows the contents of the builder to be read\n+     * using any standard method that expects a Reader.\n+     * <p>\n+     * To use, simply create a <code>StrBuilder</code>, populate it with\n+     * data, call <code>asReader</code>, and then read away.\n+     * <p>\n+     * The internal character array is shared between the builder and the reader.\n+     * This allows you to append to the builder after creating the reader,\n+     * and the changes will be picked up.\n+     * Note however, that no synchronization occurs, so you must perform\n+     * all operations with the builder and the reader in one thread.\n+     * <p>\n+     * The returned reader supports marking, and ignores the flush method.\n+     *\n+     * @return a reader that reads from this builder\n+     */\n+    public Reader asReader() {\n+        return new StrBuilderReader();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets this builder as a Writer that can be written to.\n+     * <p>\n+     * This method allows you to populate the contents of the builder\n+     * using any standard method that takes a Writer.\n+     * <p>\n+     * To use, simply create a <code>StrBuilder</code>,\n+     * call <code>asWriter</code>, and populate away. The data is available\n+     * at any time using the methods of the <code>StrBuilder</code>.\n+     * <p>\n+     * The internal character array is shared between the builder and the writer.\n+     * This allows you to intermix calls that append to the builder and\n+     * write using the writer and the changes will be occur correctly.\n+     * Note however, that no synchronization occurs, so you must perform\n+     * all operations with the builder and the writer in one thread.\n+     * <p>\n+     * The returned writer ignores the close and flush methods.\n+     *\n+     * @return a writer that populates this builder\n+     */\n+    public Writer asWriter() {\n+        return new StrBuilderWriter();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+//    /**\n+//     * Gets a String version of the string builder by calling the internal\n+//     * constructor of String by reflection.\n+//     * <p>\n+//     * WARNING: You must not use the StrBuilder after calling this method\n+//     * as the buffer is now shared with the String object. To ensure this,\n+//     * the internal character array is set to null, so you will get\n+//     * NullPointerExceptions on all method calls.\n+//     *\n+//     * @return the builder as a String\n+//     */\n+//    public String toSharedString() {\n+//        try {\n+//            Constructor con = String.class.getDeclaredConstructor(\n+//                new Class[] {int.class, int.class, char[].class});\n+//            con.setAccessible(true);\n+//            char[] buffer = buf;\n+//            buf = null;\n+//            size = -1;\n+//            nullText = null;\n+//            return (String) con.newInstance(\n+//                new Object[] {new Integer(0), new Integer(size), buffer});\n+//            \n+//        } catch (Exception ex) {\n+//            ex.printStackTrace();\n+//            throw new UnsupportedOperationException(\"StrBuilder.toSharedString is unsupported: \" + ex.getMessage());\n+//        }\n+//    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks the contents of this builder against another to see if they\n+     * contain the same character content ignoring case.\n+     *\n+     * @param other  the object to check, null returns false\n+     * @return true if the builders contain the same characters in the same order\n+     */\n+    public boolean equalsIgnoreCase(StrBuilder other) {\n+        if (this == other) {\n+            return true;\n+        }\n+        if (this.size != other.size) {\n+            return false;\n+        }\n+        char thisBuf[] = this.buffer;\n+        char otherBuf[] = other.buffer;\n+        for (int i = size - 1; i >= 0; i--) {\n+            char c1 = thisBuf[i];\n+            char c2 = otherBuf[i];\n+            if (c1 != c2 && Character.toUpperCase(c1) != Character.toUpperCase(c2)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Checks the contents of this builder against another to see if they\n+     * contain the same character content.\n+     *\n+     * @param other  the object to check, null returns false\n+     * @return true if the builders contain the same characters in the same order\n+     */\n+    public boolean equals(StrBuilder other) {\n+        if (this == other) {\n+            return true;\n+        }\n+        if (this.size != other.size) {\n+            return false;\n+        }\n+        char thisBuf[] = this.buffer;\n+        char otherBuf[] = other.buffer;\n+        for (int i = size - 1; i >= 0; i--) {\n+            if (thisBuf[i] != otherBuf[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Checks the contents of this builder against another to see if they\n+     * contain the same character content.\n+     *\n+     * @param obj  the object to check, null returns false\n+     * @return true if the builders contain the same characters in the same order\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof StrBuilder) {\n+            return equals((StrBuilder) obj);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Gets a suitable hash code for this builder.\n+     *\n+     * @return a hash code\n+     */\n+    @Override\n+    public int hashCode() {\n+        char buf[] = buffer;\n+        int hash = 0;\n+        for (int i = size - 1; i >= 0; i--) {\n+            hash = 31 * hash + buf[i];\n+        }\n+        return hash;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a String version of the string builder, creating a new instance\n+     * each time the method is called.\n+     * <p>\n+     * Note that unlike StringBuffer, the string version returned is\n+     * independent of the string builder.\n+     *\n+     * @return the builder as a String\n+     */\n+    @Override\n+    public String toString() {\n+        return new String(buffer, 0, size);\n+    }\n+\n+    /**\n+     * Gets a StringBuffer version of the string builder, creating a\n+     * new instance each time the method is called.\n+     *\n+     * @return the builder as a StringBuffer\n+     */\n+    public StringBuffer toStringBuffer() {\n+        return new StringBuffer(size).append(buffer, 0, size);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Validates parameters defining a range of the builder.\n+     * \n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param endIndex  the end index, exclusive, must be valid except\n+     *  that if too large it is treated as end of string\n+     * @return the new string\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    protected int validateRange(int startIndex, int endIndex) {\n+        if (startIndex < 0) {\n+            throw new StringIndexOutOfBoundsException(startIndex);\n+        }\n+        if (endIndex > size) {\n+            endIndex = size;\n+        }\n+        if (startIndex > endIndex) {\n+            throw new StringIndexOutOfBoundsException(\"end < start\");\n+        }\n+        return endIndex;\n+    }\n+\n+    /**\n+     * Validates parameters defining a single index in the builder.\n+     * \n+     * @param index  the index, must be valid\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    protected void validateIndex(int index) {\n+        if (index < 0 || index > size) {\n+            throw new StringIndexOutOfBoundsException(index);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class to allow StrBuilder to operate as a tokenizer.\n+     */\n+    class StrBuilderTokenizer extends StrTokenizer {\n+\n+        StrBuilderTokenizer() {\n+            super();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        protected List<String> tokenize(char[] chars, int offset, int count) {\n+            if (chars == null) {\n+                return super.tokenize(StrBuilder.this.buffer, 0, StrBuilder.this.size());\n+            } else {\n+                return super.tokenize(chars, offset, count);\n+            }\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public String getContent() {\n+            String str = super.getContent();\n+            if (str == null) {\n+                return StrBuilder.this.toString();\n+            } else {\n+                return str;\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class to allow StrBuilder to operate as a writer.\n+     */\n+    class StrBuilderReader extends Reader {\n+        /** The current stream position. */\n+        private int pos;\n+        /** The last mark position. */\n+        private int mark;\n+\n+        StrBuilderReader() {\n+            super();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public void close() {\n+            // do nothing\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public int read() {\n+            if (ready() == false) {\n+                return -1;\n+            }\n+            return StrBuilder.this.charAt(pos++);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public int read(char b[], int off, int len) {\n+            if (off < 0 || len < 0 || off > b.length ||\n+                    (off + len) > b.length || (off + len) < 0) {\n+                throw new IndexOutOfBoundsException();\n+            }\n+            if (len == 0) {\n+                return 0;\n+            }\n+            if (pos >= StrBuilder.this.size()) {\n+                return -1;\n+            }\n+            if (pos + len > size()) {\n+                len = StrBuilder.this.size() - pos;\n+            }\n+            StrBuilder.this.getChars(pos, pos + len, b, off);\n+            pos += len;\n+            return len;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public long skip(long n) {\n+            if (pos + n > StrBuilder.this.size()) {\n+                n = StrBuilder.this.size() - pos;\n+            }\n+            if (n < 0) {\n+                return 0;\n+            }\n+            pos += n;\n+            return n;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public boolean ready() {\n+            return pos < StrBuilder.this.size();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public boolean markSupported() {\n+            return true;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public void mark(int readAheadLimit) {\n+            mark = pos;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public void reset() {\n+            pos = mark;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class to allow StrBuilder to operate as a writer.\n+     */\n+    class StrBuilderWriter extends Writer {\n+\n+        StrBuilderWriter() {\n+            super();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public void close() {\n+            // do nothing\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public void flush() {\n+            // do nothing\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public void write(int c) {\n+            StrBuilder.this.append((char) c);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public void write(char[] cbuf) {\n+            StrBuilder.this.append(cbuf);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public void write(char[] cbuf, int off, int len) {\n+            StrBuilder.this.append(cbuf, off, len);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public void write(String str) {\n+            StrBuilder.this.append(str);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public void write(String str, int off, int len) {\n+            StrBuilder.this.append(str, off, len);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/text/StrLookup.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.text;\n+\n+import java.util.Map;\n+\n+/**\n+ * Lookup a String key to a String value.\n+ * <p>\n+ * This class represents the simplest form of a string to string map.\n+ * It has a benefit over a map in that it can create the result on\n+ * demand based on the key.\n+ * <p>\n+ * This class comes complete with various factory methods.\n+ * If these do not suffice, you can subclass and implement your own matcher.\n+ * <p>\n+ * For example, it would be possible to implement a lookup that used the\n+ * key as a primary key, and looked up the value on demand from the database\n+ *\n+ * @author Apache Software Foundation\n+ * @since 2.2\n+ * @version $Id$\n+ */\n+public abstract class StrLookup<V> {\n+\n+    /**\n+     * Lookup that always returns null.\n+     */\n+    private static final StrLookup<String> NONE_LOOKUP;\n+    /**\n+     * Lookup that uses System properties.\n+     */\n+    private static final StrLookup<String> SYSTEM_PROPERTIES_LOOKUP;\n+    static {\n+        NONE_LOOKUP = new MapStrLookup<String>(null);\n+        StrLookup<String> lookup = null;\n+        try {\n+            final Map<?, ?> propMap = System.getProperties();\n+            @SuppressWarnings(\"unchecked\") // System property keys and values are always Strings\n+            final Map<String, String> properties = (Map<String, String>) propMap;\n+            lookup = new MapStrLookup<String>(properties);\n+        } catch (SecurityException ex) {\n+            lookup = NONE_LOOKUP;\n+        }\n+        SYSTEM_PROPERTIES_LOOKUP = lookup;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a lookup which always returns null.\n+     *\n+     * @return a lookup that always returns null, not null\n+     */\n+    public static StrLookup<?> noneLookup() {\n+        return NONE_LOOKUP;\n+    }\n+\n+    /**\n+     * Returns a lookup which uses {@link System#getProperties() System properties}\n+     * to lookup the key to value.\n+     * <p>\n+     * If a security manager blocked access to system properties, then null will\n+     * be returned from every lookup.\n+     * <p>\n+     * If a null key is used, this lookup will throw a NullPointerException.\n+     *\n+     * @return a lookup using system properties, not null\n+     */\n+    public static StrLookup<String> systemPropertiesLookup() {\n+        return SYSTEM_PROPERTIES_LOOKUP;\n+    }\n+\n+    /**\n+     * Returns a lookup which looks up values using a map.\n+     * <p>\n+     * If the map is null, then null will be returned from every lookup.\n+     * The map result object is converted to a string using toString().\n+     *\n+     * @param map  the map of keys to values, may be null\n+     * @return a lookup using the map, not null\n+     */\n+    public static <V> StrLookup<V> mapLookup(Map<String, V> map) {\n+        return new MapStrLookup<V>(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor.\n+     */\n+    protected StrLookup() {\n+        super();\n+    }\n+\n+    /**\n+     * Looks up a String key to a String value.\n+     * <p>\n+     * The internal implementation may use any mechanism to return the value.\n+     * The simplest implementation is to use a Map. However, virtually any\n+     * implementation is possible.\n+     * <p>\n+     * For example, it would be possible to implement a lookup that used the\n+     * key as a primary key, and looked up the value on demand from the database\n+     * Or, a numeric based implementation could be created that treats the key\n+     * as an integer, increments the value and return the result as a string -\n+     * converting 1 to 2, 15 to 16 etc.\n+     *\n+     * @param key  the key to be looked up, may be null\n+     * @return the matching value, null if no match\n+     */\n+    public abstract String lookup(String key);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Lookup implementation that uses a Map.\n+     */\n+    static class MapStrLookup<V> extends StrLookup<V> {\n+\n+        /** Map keys are variable names and value. */\n+        private final Map<String, V> map;\n+\n+        /**\n+         * Creates a new instance backed by a Map.\n+         *\n+         * @param map  the map of keys to values, may be null\n+         */\n+        MapStrLookup(Map<String, V> map) {\n+            this.map = map;\n+        }\n+\n+        /**\n+         * Looks up a String key to a String value using the map.\n+         * <p>\n+         * If the map is null, then null is returned.\n+         * The map result object is converted to a string using toString().\n+         *\n+         * @param key  the key to be looked up, may be null\n+         * @return the matching value, null if no match\n+         */\n+        @Override\n+        public String lookup(String key) {\n+            if (map == null) {\n+                return null;\n+            }\n+            Object obj = map.get(key);\n+            if (obj == null) {\n+                return null;\n+            }\n+            return obj.toString();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/text/StrMatcher.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.text;\n+\n+import java.util.Arrays;\n+\n+/**\n+ * A matcher class that can be queried to determine if a character array\n+ * portion matches.\n+ * <p>\n+ * This class comes complete with various factory methods.\n+ * If these do not suffice, you can subclass and implement your own matcher.\n+ *\n+ * @author Apache Software Foundation\n+ * @since 2.2\n+ * @version $Id$\n+ */\n+public abstract class StrMatcher {\n+\n+    /**\n+     * Matches the comma character.\n+     */\n+    private static final StrMatcher COMMA_MATCHER = new CharMatcher(',');\n+    /**\n+     * Matches the tab character.\n+     */\n+    private static final StrMatcher TAB_MATCHER = new CharMatcher('\\t');\n+    /**\n+     * Matches the space character.\n+     */\n+    private static final StrMatcher SPACE_MATCHER = new CharMatcher(' ');\n+    /**\n+     * Matches the same characters as StringTokenizer,\n+     * namely space, tab, newline, formfeed.\n+     */\n+    private static final StrMatcher SPLIT_MATCHER = new CharSetMatcher(\" \\t\\n\\r\\f\".toCharArray());\n+    /**\n+     * Matches the String trim() whitespace characters.\n+     */\n+    private static final StrMatcher TRIM_MATCHER = new TrimMatcher();\n+    /**\n+     * Matches the double quote character.\n+     */\n+    private static final StrMatcher SINGLE_QUOTE_MATCHER = new CharMatcher('\\'');\n+    /**\n+     * Matches the double quote character.\n+     */\n+    private static final StrMatcher DOUBLE_QUOTE_MATCHER = new CharMatcher('\"');\n+    /**\n+     * Matches the single or double quote character.\n+     */\n+    private static final StrMatcher QUOTE_MATCHER = new CharSetMatcher(\"'\\\"\".toCharArray());\n+    /**\n+     * Matches no characters.\n+     */\n+    private static final StrMatcher NONE_MATCHER = new NoMatcher();\n+\n+    // -----------------------------------------------------------------------\n+\n+    /**\n+     * Returns a matcher which matches the comma character.\n+     *\n+     * @return a matcher for a comma\n+     */\n+    public static StrMatcher commaMatcher() {\n+        return COMMA_MATCHER;\n+    }\n+\n+    /**\n+     * Returns a matcher which matches the tab character.\n+     *\n+     * @return a matcher for a tab\n+     */\n+    public static StrMatcher tabMatcher() {\n+        return TAB_MATCHER;\n+    }\n+\n+    /**\n+     * Returns a matcher which matches the space character.\n+     *\n+     * @return a matcher for a space\n+     */\n+    public static StrMatcher spaceMatcher() {\n+        return SPACE_MATCHER;\n+    }\n+\n+    /**\n+     * Matches the same characters as StringTokenizer,\n+     * namely space, tab, newline and formfeed.\n+     *\n+     * @return the split matcher\n+     */\n+    public static StrMatcher splitMatcher() {\n+        return SPLIT_MATCHER;\n+    }\n+\n+    /**\n+     * Matches the String trim() whitespace characters.\n+     *\n+     * @return the trim matcher\n+     */\n+    public static StrMatcher trimMatcher() {\n+        return TRIM_MATCHER;\n+    }\n+\n+    /**\n+     * Returns a matcher which matches the single quote character.\n+     *\n+     * @return a matcher for a single quote\n+     */\n+    public static StrMatcher singleQuoteMatcher() {\n+        return SINGLE_QUOTE_MATCHER;\n+    }\n+\n+    /**\n+     * Returns a matcher which matches the double quote character.\n+     *\n+     * @return a matcher for a double quote\n+     */\n+    public static StrMatcher doubleQuoteMatcher() {\n+        return DOUBLE_QUOTE_MATCHER;\n+    }\n+\n+    /**\n+     * Returns a matcher which matches the single or double quote character.\n+     *\n+     * @return a matcher for a single or double quote\n+     */\n+    public static StrMatcher quoteMatcher() {\n+        return QUOTE_MATCHER;\n+    }\n+\n+    /**\n+     * Matches no characters.\n+     *\n+     * @return a matcher that matches nothing\n+     */\n+    public static StrMatcher noneMatcher() {\n+        return NONE_MATCHER;\n+    }\n+\n+    /**\n+     * Constructor that creates a matcher from a character.\n+     *\n+     * @param ch  the character to match, must not be null\n+     * @return a new Matcher for the given char\n+     */\n+    public static StrMatcher charMatcher(char ch) {\n+        return new CharMatcher(ch);\n+    }\n+\n+    /**\n+     * Constructor that creates a matcher from a set of characters.\n+     *\n+     * @param chars  the characters to match, null or empty matches nothing\n+     * @return a new matcher for the given char[]\n+     */\n+    public static StrMatcher charSetMatcher(char[] chars) {\n+        if (chars == null || chars.length == 0) {\n+            return NONE_MATCHER;\n+        }\n+        if (chars.length == 1) {\n+            return new CharMatcher(chars[0]);\n+        }\n+        return new CharSetMatcher(chars);\n+    }\n+\n+    /**\n+     * Constructor that creates a matcher from a string representing a set of characters.\n+     *\n+     * @param chars  the characters to match, null or empty matches nothing\n+     * @return a new Matcher for the given characters\n+     */\n+    public static StrMatcher charSetMatcher(String chars) {\n+        if (chars == null || chars.length() == 0) {\n+            return NONE_MATCHER;\n+        }\n+        if (chars.length() == 1) {\n+            return new CharMatcher(chars.charAt(0));\n+        }\n+        return new CharSetMatcher(chars.toCharArray());\n+    }\n+\n+    /**\n+     * Constructor that creates a matcher from a string.\n+     *\n+     * @param str  the string to match, null or empty matches nothing\n+     * @return a new Matcher for the given String\n+     */\n+    public static StrMatcher stringMatcher(String str) {\n+        if (str == null || str.length() == 0) {\n+            return NONE_MATCHER;\n+        }\n+        return new StringMatcher(str);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor.\n+     */\n+    protected StrMatcher() {\n+        super();\n+    }\n+\n+    /**\n+     * Returns the number of matching characters, zero for no match.\n+     * <p>\n+     * This method is called to check for a match.\n+     * The parameter <code>pos</code> represents the current position to be\n+     * checked in the string <code>buffer</code> (a character array which must\n+     * not be changed).\n+     * The API guarantees that <code>pos</code> is a valid index for <code>buffer</code>.\n+     * <p>\n+     * The character array may be larger than the active area to be matched.\n+     * Only values in the buffer between the specifed indices may be accessed.\n+     * <p>\n+     * The matching code may check one character or many.\n+     * It may check characters preceeding <code>pos</code> as well as those\n+     * after, so long as no checks exceed the bounds specified.\n+     * <p>\n+     * It must return zero for no match, or a positive number if a match was found.\n+     * The number indicates the number of characters that matched.\n+     *\n+     * @param buffer  the text content to match against, do not change\n+     * @param pos  the starting position for the match, valid for buffer\n+     * @param bufferStart  the first active index in the buffer, valid for buffer\n+     * @param bufferEnd  the end index (exclusive) of the active buffer, valid for buffer\n+     * @return the number of matching characters, zero for no match\n+     */\n+    public abstract int isMatch(char[] buffer, int pos, int bufferStart, int bufferEnd);\n+\n+    /**\n+     * Returns the number of matching characters, zero for no match.\n+     * <p>\n+     * This method is called to check for a match.\n+     * The parameter <code>pos</code> represents the current position to be\n+     * checked in the string <code>buffer</code> (a character array which must\n+     * not be changed).\n+     * The API guarantees that <code>pos</code> is a valid index for <code>buffer</code>.\n+     * <p>\n+     * The matching code may check one character or many.\n+     * It may check characters preceeding <code>pos</code> as well as those after.\n+     * <p>\n+     * It must return zero for no match, or a positive number if a match was found.\n+     * The number indicates the number of characters that matched.\n+     *\n+     * @param buffer  the text content to match against, do not change\n+     * @param pos  the starting position for the match, valid for buffer\n+     * @return the number of matching characters, zero for no match\n+     * @since 2.4\n+     */\n+    public int isMatch(char[] buffer, int pos) {\n+        return isMatch(buffer, pos, 0, buffer.length);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Class used to define a set of characters for matching purposes.\n+     */\n+    static final class CharSetMatcher extends StrMatcher {\n+        /** The set of characters to match. */\n+        private final char[] chars;\n+\n+        /**\n+         * Constructor that creates a matcher from a character array.\n+         *\n+         * @param chars  the characters to match, must not be null\n+         */\n+        CharSetMatcher(char chars[]) {\n+            super();\n+            this.chars = chars.clone();\n+            Arrays.sort(this.chars);\n+        }\n+\n+        /**\n+         * Returns whether or not the given character matches.\n+         *\n+         * @param buffer  the text content to match against, do not change\n+         * @param pos  the starting position for the match, valid for buffer\n+         * @param bufferStart  the first active index in the buffer, valid for buffer\n+         * @param bufferEnd  the end index of the active buffer, valid for buffer\n+         * @return the number of matching characters, zero for no match\n+         */\n+        @Override\n+        public int isMatch(char[] buffer, int pos, int bufferStart, int bufferEnd) {\n+            return Arrays.binarySearch(chars, buffer[pos]) >= 0 ? 1 : 0;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Class used to define a character for matching purposes.\n+     */\n+    static final class CharMatcher extends StrMatcher {\n+        /** The character to match. */\n+        private final char ch;\n+\n+        /**\n+         * Constructor that creates a matcher that matches a single character.\n+         *\n+         * @param ch  the character to match\n+         */\n+        CharMatcher(char ch) {\n+            super();\n+            this.ch = ch;\n+        }\n+\n+        /**\n+         * Returns whether or not the given character matches.\n+         *\n+         * @param buffer  the text content to match against, do not change\n+         * @param pos  the starting position for the match, valid for buffer\n+         * @param bufferStart  the first active index in the buffer, valid for buffer\n+         * @param bufferEnd  the end index of the active buffer, valid for buffer\n+         * @return the number of matching characters, zero for no match\n+         */\n+        @Override\n+        public int isMatch(char[] buffer, int pos, int bufferStart, int bufferEnd) {\n+            return ch == buffer[pos] ? 1 : 0;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Class used to define a set of characters for matching purposes.\n+     */\n+    static final class StringMatcher extends StrMatcher {\n+        /** The string to match, as a character array. */\n+        private final char[] chars;\n+\n+        /**\n+         * Constructor that creates a matcher from a String.\n+         *\n+         * @param str  the string to match, must not be null\n+         */\n+        StringMatcher(String str) {\n+            super();\n+            chars = str.toCharArray();\n+        }\n+\n+        /**\n+         * Returns whether or not the given text matches the stored string.\n+         *\n+         * @param buffer  the text content to match against, do not change\n+         * @param pos  the starting position for the match, valid for buffer\n+         * @param bufferStart  the first active index in the buffer, valid for buffer\n+         * @param bufferEnd  the end index of the active buffer, valid for buffer\n+         * @return the number of matching characters, zero for no match\n+         */\n+        @Override\n+        public int isMatch(char[] buffer, int pos, int bufferStart, int bufferEnd) {\n+            int len = chars.length;\n+            if (pos + len > bufferEnd) {\n+                return 0;\n+            }\n+            for (int i = 0; i < chars.length; i++, pos++) {\n+                if (chars[i] != buffer[pos]) {\n+                    return 0;\n+                }\n+            }\n+            return len;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Class used to match no characters.\n+     */\n+    static final class NoMatcher extends StrMatcher {\n+\n+        /**\n+         * Constructs a new instance of <code>NoMatcher</code>.\n+         */\n+        NoMatcher() {\n+            super();\n+        }\n+\n+        /**\n+         * Always returns <code>false</code>.\n+         *\n+         * @param buffer  the text content to match against, do not change\n+         * @param pos  the starting position for the match, valid for buffer\n+         * @param bufferStart  the first active index in the buffer, valid for buffer\n+         * @param bufferEnd  the end index of the active buffer, valid for buffer\n+         * @return the number of matching characters, zero for no match\n+         */\n+        @Override\n+        public int isMatch(char[] buffer, int pos, int bufferStart, int bufferEnd) {\n+            return 0;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Class used to match whitespace as per trim().\n+     */\n+    static final class TrimMatcher extends StrMatcher {\n+\n+        /**\n+         * Constructs a new instance of <code>TrimMatcher</code>.\n+         */\n+        TrimMatcher() {\n+            super();\n+        }\n+\n+        /**\n+         * Returns whether or not the given character matches.\n+         *\n+         * @param buffer  the text content to match against, do not change\n+         * @param pos  the starting position for the match, valid for buffer\n+         * @param bufferStart  the first active index in the buffer, valid for buffer\n+         * @param bufferEnd  the end index of the active buffer, valid for buffer\n+         * @return the number of matching characters, zero for no match\n+         */\n+        @Override\n+        public int isMatch(char[] buffer, int pos, int bufferStart, int bufferEnd) {\n+            return buffer[pos] <= 32 ? 1 : 0;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/text/StrSubstitutor.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.text;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Substitutes variables within a string by values.\n+ * <p>\n+ * This class takes a piece of text and substitutes all the variables within it.\n+ * The default definition of a variable is <code>${variableName}</code>.\n+ * The prefix and suffix can be changed via constructors and set methods.\n+ * <p>\n+ * Variable values are typically resolved from a map, but could also be resolved\n+ * from system properties, or by supplying a custom variable resolver.\n+ * <p>\n+ * The simplest example is to use this class to replace Java System properties. For example:\n+ * <pre>\n+ * StrSubstitutor.replaceSystemProperties(\n+ *      \"You are running with java.version = ${java.version} and os.name = ${os.name}.\");\n+ * </pre>\n+ * <p>\n+ * Typical usage of this class follows the following pattern: First an instance is created\n+ * and initialized with the map that contains the values for the available variables.\n+ * If a prefix and/or suffix for variables should be used other than the default ones,\n+ * the appropriate settings can be performed. After that the <code>replace()</code>\n+ * method can be called passing in the source text for interpolation. In the returned\n+ * text all variable references (as long as their values are known) will be resolved.\n+ * The following example demonstrates this:\n+ * <pre>\n+ * Map valuesMap = HashMap();\n+ * valuesMap.put(&quot;animal&quot;, &quot;quick brown fox&quot;);\n+ * valuesMap.put(&quot;target&quot;, &quot;lazy dog&quot;);\n+ * String templateString = &quot;The ${animal} jumped over the ${target}.&quot;;\n+ * StrSubstitutor sub = new StrSubstitutor(valuesMap);\n+ * String resolvedString = sub.replace(templateString);\n+ * </pre>\n+ * yielding:\n+ * <pre>\n+ *      The quick brown fox jumped over the lazy dog.\n+ * </pre>\n+ * <p>\n+ * In addition to this usage pattern there are some static convenience methods that\n+ * cover the most common use cases. These methods can be used without the need of\n+ * manually creating an instance. However if multiple replace operations are to be\n+ * performed, creating and reusing an instance of this class will be more efficient.\n+ * <p>\n+ * Variable replacement works in a recursive way. Thus, if a variable value contains\n+ * a variable then that variable will also be replaced. Cyclic replacements are\n+ * detected and will cause an exception to be thrown.\n+ * <p>\n+ * Sometimes the interpolation's result must contain a variable prefix. As an example\n+ * take the following source text:\n+ * <pre>\n+ *   The variable ${${name}} must be used.\n+ * </pre>\n+ * Here only the variable's name refered to in the text should be replaced resulting\n+ * in the text (assuming that the value of the <code>name</code> variable is <code>x</code>):\n+ * <pre>\n+ *   The variable ${x} must be used.\n+ * </pre>\n+ * To achieve this effect there are two possibilities: Either set a different prefix\n+ * and suffix for variables which do not conflict with the result text you want to\n+ * produce. The other possibility is to use the escape character, by default '$'.\n+ * If this character is placed before a variable reference, this reference is ignored\n+ * and won't be replaced. For example:\n+ * <pre>\n+ *   The variable $${${name}} must be used.\n+ * </pre>\n+ *\n+ * @author Apache Software Foundation\n+ * @author Oliver Heger\n+ * @version $Id$\n+ * @since 2.2\n+ */\n+public class StrSubstitutor {\n+\n+    /**\n+     * Constant for the default escape character.\n+     */\n+    public static final char DEFAULT_ESCAPE = '$';\n+    /**\n+     * Constant for the default variable prefix.\n+     */\n+    public static final StrMatcher DEFAULT_PREFIX = StrMatcher.stringMatcher(\"${\");\n+    /**\n+     * Constant for the default variable suffix.\n+     */\n+    public static final StrMatcher DEFAULT_SUFFIX = StrMatcher.stringMatcher(\"}\");\n+\n+    /**\n+     * Stores the escape character.\n+     */\n+    private char escapeChar;\n+    /**\n+     * Stores the variable prefix.\n+     */\n+    private StrMatcher prefixMatcher;\n+    /**\n+     * Stores the variable suffix.\n+     */\n+    private StrMatcher suffixMatcher;\n+    /**\n+     * Variable resolution is delegated to an implementor of VariableResolver.\n+     */\n+    private StrLookup variableResolver;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces all the occurrences of variables in the given source object with\n+     * their matching values from the map.\n+     *\n+     * @param source  the source text containing the variables to substitute, null returns null\n+     * @param valueMap  the map with the values, may be null\n+     * @return the result of the replace operation\n+     */\n+    public static <V> String replace(Object source, Map<String, V> valueMap) {\n+        return new StrSubstitutor(valueMap).replace(source);\n+    }\n+\n+    /**\n+     * Replaces all the occurrences of variables in the given source object with\n+     * their matching values from the map. This method allows to specifiy a\n+     * custom variable prefix and suffix\n+     *\n+     * @param source  the source text containing the variables to substitute, null returns null\n+     * @param valueMap  the map with the values, may be null\n+     * @param prefix  the prefix of variables, not null\n+     * @param suffix  the suffix of variables, not null\n+     * @return the result of the replace operation\n+     * @throws IllegalArgumentException if the prefix or suffix is null\n+     */\n+    public static <V> String replace(Object source, Map<String, V> valueMap, String prefix, String suffix) {\n+        return new StrSubstitutor(valueMap, prefix, suffix).replace(source);\n+    }\n+\n+    /**\n+     * Replaces all the occurrences of variables in the given source object with\n+     * their matching values from the system properties.\n+     *\n+     * @param source  the source text containing the variables to substitute, null returns null\n+     * @return the result of the replace operation\n+     */\n+    public static String replaceSystemProperties(Object source) {\n+        return new StrSubstitutor(StrLookup.systemPropertiesLookup()).replace(source);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new instance with defaults for variable prefix and suffix\n+     * and the escaping character.\n+     */\n+    public StrSubstitutor() {\n+        this((StrLookup) null, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n+    }\n+\n+    /**\n+     * Creates a new instance and initializes it. Uses defaults for variable\n+     * prefix and suffix and the escaping character.\n+     *\n+     * @param valueMap  the map with the variables' values, may be null\n+     */\n+    public <V> StrSubstitutor(Map<String, V> valueMap) {\n+        this(StrLookup.mapLookup(valueMap), DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n+    }\n+\n+    /**\n+     * Creates a new instance and initializes it. Uses a default escaping character.\n+     *\n+     * @param valueMap  the map with the variables' values, may be null\n+     * @param prefix  the prefix for variables, not null\n+     * @param suffix  the suffix for variables, not null\n+     * @throws IllegalArgumentException if the prefix or suffix is null\n+     */\n+    public <V> StrSubstitutor(Map<String, V> valueMap, String prefix, String suffix) {\n+        this(StrLookup.mapLookup(valueMap), prefix, suffix, DEFAULT_ESCAPE);\n+    }\n+\n+    /**\n+     * Creates a new instance and initializes it.\n+     *\n+     * @param valueMap  the map with the variables' values, may be null\n+     * @param prefix  the prefix for variables, not null\n+     * @param suffix  the suffix for variables, not null\n+     * @param escape  the escape character\n+     * @throws IllegalArgumentException if the prefix or suffix is null\n+     */\n+    public <V> StrSubstitutor(Map<String, V> valueMap, String prefix, String suffix, char escape) {\n+        this(StrLookup.mapLookup(valueMap), prefix, suffix, escape);\n+    }\n+\n+    /**\n+     * Creates a new instance and initializes it.\n+     *\n+     * @param variableResolver  the variable resolver, may be null\n+     */\n+    public StrSubstitutor(StrLookup variableResolver) {\n+        this(variableResolver, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n+    }\n+\n+    /**\n+     * Creates a new instance and initializes it.\n+     *\n+     * @param variableResolver  the variable resolver, may be null\n+     * @param prefix  the prefix for variables, not null\n+     * @param suffix  the suffix for variables, not null\n+     * @param escape  the escape character\n+     * @throws IllegalArgumentException if the prefix or suffix is null\n+     */\n+    public StrSubstitutor(StrLookup variableResolver, String prefix, String suffix, char escape) {\n+        this.setVariableResolver(variableResolver);\n+        this.setVariablePrefix(prefix);\n+        this.setVariableSuffix(suffix);\n+        this.setEscapeChar(escape);\n+    }\n+\n+    /**\n+     * Creates a new instance and initializes it.\n+     *\n+     * @param variableResolver  the variable resolver, may be null\n+     * @param prefixMatcher  the prefix for variables, not null\n+     * @param suffixMatcher  the suffix for variables, not null\n+     * @param escape  the escape character\n+     * @throws IllegalArgumentException if the prefix or suffix is null\n+     */\n+    public StrSubstitutor(\n+            StrLookup variableResolver, StrMatcher prefixMatcher, StrMatcher suffixMatcher, char escape) {\n+        this.setVariableResolver(variableResolver);\n+        this.setVariablePrefixMatcher(prefixMatcher);\n+        this.setVariableSuffixMatcher(suffixMatcher);\n+        this.setEscapeChar(escape);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces all the occurrences of variables with their matching values\n+     * from the resolver using the given source string as a template.\n+     *\n+     * @param source  the string to replace in, null returns null\n+     * @return the result of the replace operation\n+     */\n+    public String replace(String source) {\n+        if (source == null) {\n+            return null;\n+        }\n+        StrBuilder buf = new StrBuilder(source);\n+        if (substitute(buf, 0, source.length()) == false) {\n+            return source;\n+        }\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Replaces all the occurrences of variables with their matching values\n+     * from the resolver using the given source string as a template.\n+     * <p>\n+     * Only the specified portion of the string will be processed.\n+     * The rest of the string is not processed, and is not returned.\n+     *\n+     * @param source  the string to replace in, null returns null\n+     * @param offset  the start offset within the array, must be valid\n+     * @param length  the length within the array to be processed, must be valid\n+     * @return the result of the replace operation\n+     */\n+    public String replace(String source, int offset, int length) {\n+        if (source == null) {\n+            return null;\n+        }\n+        StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n+        if (substitute(buf, 0, length) == false) {\n+            return source.substring(offset, offset + length);\n+        }\n+        return buf.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces all the occurrences of variables with their matching values\n+     * from the resolver using the given source array as a template.\n+     * The array is not altered by this method.\n+     *\n+     * @param source  the character array to replace in, not altered, null returns null\n+     * @return the result of the replace operation\n+     */\n+    public String replace(char[] source) {\n+        if (source == null) {\n+            return null;\n+        }\n+        StrBuilder buf = new StrBuilder(source.length).append(source);\n+        substitute(buf, 0, source.length);\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Replaces all the occurrences of variables with their matching values\n+     * from the resolver using the given source array as a template.\n+     * The array is not altered by this method.\n+     * <p>\n+     * Only the specified portion of the array will be processed.\n+     * The rest of the array is not processed, and is not returned.\n+     *\n+     * @param source  the character array to replace in, not altered, null returns null\n+     * @param offset  the start offset within the array, must be valid\n+     * @param length  the length within the array to be processed, must be valid\n+     * @return the result of the replace operation\n+     */\n+    public String replace(char[] source, int offset, int length) {\n+        if (source == null) {\n+            return null;\n+        }\n+        StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n+        substitute(buf, 0, length);\n+        return buf.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces all the occurrences of variables with their matching values\n+     * from the resolver using the given source buffer as a template.\n+     * The buffer is not altered by this method.\n+     *\n+     * @param source  the buffer to use as a template, not changed, null returns null\n+     * @return the result of the replace operation\n+     */\n+    public String replace(StringBuffer source) {\n+        if (source == null) {\n+            return null;\n+        }\n+        StrBuilder buf = new StrBuilder(source.length()).append(source);\n+        substitute(buf, 0, buf.length());\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Replaces all the occurrences of variables with their matching values\n+     * from the resolver using the given source buffer as a template.\n+     * The buffer is not altered by this method.\n+     * <p>\n+     * Only the specified portion of the buffer will be processed.\n+     * The rest of the buffer is not processed, and is not returned.\n+     *\n+     * @param source  the buffer to use as a template, not changed, null returns null\n+     * @param offset  the start offset within the array, must be valid\n+     * @param length  the length within the array to be processed, must be valid\n+     * @return the result of the replace operation\n+     */\n+    public String replace(StringBuffer source, int offset, int length) {\n+        if (source == null) {\n+            return null;\n+        }\n+        StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n+        substitute(buf, 0, length);\n+        return buf.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces all the occurrences of variables with their matching values\n+     * from the resolver using the given source builder as a template.\n+     * The builder is not altered by this method.\n+     *\n+     * @param source  the builder to use as a template, not changed, null returns null\n+     * @return the result of the replace operation\n+     */\n+    public String replace(StrBuilder source) {\n+        if (source == null) {\n+            return null;\n+        }\n+        StrBuilder buf = new StrBuilder(source.length()).append(source);\n+        substitute(buf, 0, buf.length());\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Replaces all the occurrences of variables with their matching values\n+     * from the resolver using the given source builder as a template.\n+     * The builder is not altered by this method.\n+     * <p>\n+     * Only the specified portion of the builder will be processed.\n+     * The rest of the builder is not processed, and is not returned.\n+     *\n+     * @param source  the builder to use as a template, not changed, null returns null\n+     * @param offset  the start offset within the array, must be valid\n+     * @param length  the length within the array to be processed, must be valid\n+     * @return the result of the replace operation\n+     */\n+    public String replace(StrBuilder source, int offset, int length) {\n+        if (source == null) {\n+            return null;\n+        }\n+        StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n+        substitute(buf, 0, length);\n+        return buf.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces all the occurrences of variables in the given source object with\n+     * their matching values from the resolver. The input source object is\n+     * converted to a string using <code>toString</code> and is not altered.\n+     *\n+     * @param source  the source to replace in, null returns null\n+     * @return the result of the replace operation\n+     */\n+    public String replace(Object source) {\n+        if (source == null) {\n+            return null;\n+        }\n+        StrBuilder buf = new StrBuilder().append(source);\n+        substitute(buf, 0, buf.length());\n+        return buf.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces all the occurrences of variables within the given source buffer\n+     * with their matching values from the resolver.\n+     * The buffer is updated with the result.\n+     *\n+     * @param source  the buffer to replace in, updated, null returns zero\n+     * @return true if altered\n+     */\n+    public boolean replaceIn(StringBuffer source) {\n+        if (source == null) {\n+            return false;\n+        }\n+        return replaceIn(source, 0, source.length());\n+    }\n+\n+    /**\n+     * Replaces all the occurrences of variables within the given source buffer\n+     * with their matching values from the resolver.\n+     * The buffer is updated with the result.\n+     * <p>\n+     * Only the specified portion of the buffer will be processed.\n+     * The rest of the buffer is not processed, but it is not deleted.\n+     *\n+     * @param source  the buffer to replace in, updated, null returns zero\n+     * @param offset  the start offset within the array, must be valid\n+     * @param length  the length within the buffer to be processed, must be valid\n+     * @return true if altered\n+     */\n+    public boolean replaceIn(StringBuffer source, int offset, int length) {\n+        if (source == null) {\n+            return false;\n+        }\n+        StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n+        if (substitute(buf, 0, length) == false) {\n+            return false;\n+        }\n+        source.replace(offset, offset + length, buf.toString());\n+        return true;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces all the occurrences of variables within the given source\n+     * builder with their matching values from the resolver.\n+     *\n+     * @param source  the builder to replace in, updated, null returns zero\n+     * @return true if altered\n+     */\n+    public boolean replaceIn(StrBuilder source) {\n+        if (source == null) {\n+            return false;\n+        }\n+        return substitute(source, 0, source.length());\n+    }\n+\n+    /**\n+     * Replaces all the occurrences of variables within the given source\n+     * builder with their matching values from the resolver.\n+     * <p>\n+     * Only the specified portion of the builder will be processed.\n+     * The rest of the builder is not processed, but it is not deleted.\n+     *\n+     * @param source  the builder to replace in, null returns zero\n+     * @param offset  the start offset within the array, must be valid\n+     * @param length  the length within the builder to be processed, must be valid\n+     * @return true if altered\n+     */\n+    public boolean replaceIn(StrBuilder source, int offset, int length) {\n+        if (source == null) {\n+            return false;\n+        }\n+        return substitute(source, offset, length);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Internal method that substitutes the variables.\n+     * <p>\n+     * Most users of this class do not need to call this method. This method will\n+     * be called automatically by another (public) method.\n+     * <p>\n+     * Writers of subclasses can override this method if they need access to\n+     * the substitution process at the start or end.\n+     *\n+     * @param buf  the string builder to substitute into, not null\n+     * @param offset  the start offset within the builder, must be valid\n+     * @param length  the length within the builder to be processed, must be valid\n+     * @return true if altered\n+     */\n+    protected boolean substitute(StrBuilder buf, int offset, int length) {\n+        return substitute(buf, offset, length, null) > 0;\n+    }\n+\n+    /**\n+     * Recursive handler for multiple levels of interpolation. This is the main\n+     * interpolation method, which resolves the values of all variable references\n+     * contained in the passed in text.\n+     *\n+     * @param buf  the string builder to substitute into, not null\n+     * @param offset  the start offset within the builder, must be valid\n+     * @param length  the length within the builder to be processed, must be valid\n+     * @param priorVariables  the stack keeping track of the replaced variables, may be null\n+     * @return the length change that occurs, unless priorVariables is null when the int\n+     *  represents a boolean flag as to whether any change occurred.\n+     */\n+    private int substitute(StrBuilder buf, int offset, int length, List<String> priorVariables) {\n+        StrMatcher prefixMatcher = getVariablePrefixMatcher();\n+        StrMatcher suffixMatcher = getVariableSuffixMatcher();\n+        char escape = getEscapeChar();\n+        \n+        boolean top = (priorVariables == null);\n+        boolean altered = false;\n+        int lengthChange = 0;\n+        char[] chars = buf.buffer;\n+        int bufEnd = offset + length;\n+        int pos = offset;\n+        while (pos < bufEnd) {\n+            int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n+            if (startMatchLen == 0) {\n+                pos++;\n+            } else {\n+                // found variable start marker\n+                if (pos > offset && chars[pos - 1] == escape) {\n+                    // escaped\n+                    buf.deleteCharAt(pos - 1);\n+                    chars = buf.buffer;  // in case buffer was altered\n+                    lengthChange--;\n+                    altered = true;\n+                    bufEnd--;\n+                } else {\n+                    // find suffix\n+                    int startPos = pos;\n+                    pos += startMatchLen;\n+                    int endMatchLen = 0;\n+                    while (pos < bufEnd) {\n+                        endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n+                        if (endMatchLen == 0) {\n+                            pos++;\n+                        } else {\n+                            // found variable end marker\n+                            String varName = new String(chars, startPos + startMatchLen, \n+                                                        pos - startPos - startMatchLen);\n+                            pos += endMatchLen;\n+                            int endPos = pos;\n+                            \n+                            // on the first call initialize priorVariables\n+                            if (priorVariables == null) {\n+                                priorVariables = new ArrayList<String>();\n+                                priorVariables.add(new String(chars, offset, length));\n+                            }\n+                            \n+                            // handle cyclic substitution\n+                            checkCyclicSubstitution(varName, priorVariables);\n+                            priorVariables.add(varName);\n+                            \n+                            // resolve the variable\n+                            String varValue = resolveVariable(varName, buf, startPos, endPos);\n+                            if (varValue != null) {\n+                                // recursive replace\n+                                int varLen = varValue.length();\n+                                buf.replace(startPos, endPos, varValue);\n+                                altered = true;\n+                                int change = substitute(buf, startPos, varLen, priorVariables);\n+                                change = change + (varLen - (endPos - startPos));\n+                                pos += change;\n+                                bufEnd += change;\n+                                lengthChange += change;\n+                                chars = buf.buffer;  // in case buffer was altered\n+                            }\n+                            \n+                            // remove variable from the cyclic stack\n+                            priorVariables.remove(priorVariables.size() - 1);\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        if (top) {\n+            return (altered ? 1 : 0);\n+        }\n+        return lengthChange;\n+    }\n+\n+    /**\n+     * Checks if the specified variable is already in the stack (list) of variables.\n+     *\n+     * @param varName  the variable name to check\n+     * @param priorVariables  the list of prior variables\n+     */\n+    private void checkCyclicSubstitution(String varName, List<String> priorVariables) {\n+        if (priorVariables.contains(varName) == false) {\n+            return;\n+        }\n+        StrBuilder buf = new StrBuilder(256);\n+        buf.append(\"Infinite loop in property interpolation of \");\n+        buf.append(priorVariables.remove(0));\n+        buf.append(\": \");\n+        buf.appendWithSeparators(priorVariables, \"->\");\n+        throw new IllegalStateException(buf.toString());\n+    }\n+\n+    /**\n+     * Internal method that resolves the value of a variable.\n+     * <p>\n+     * Most users of this class do not need to call this method. This method is\n+     * called automatically by the substitution process.\n+     * <p>\n+     * Writers of subclasses can override this method if they need to alter\n+     * how each substitution occurs. The method is passed the variable's name\n+     * and must return the corresponding value. This implementation uses the\n+     * {@link #getVariableResolver()} with the variable's name as the key.\n+     *\n+     * @param variableName  the name of the variable, not null\n+     * @param buf  the buffer where the substitution is occurring, not null\n+     * @param startPos  the start position of the variable including the prefix, valid\n+     * @param endPos  the end position of the variable including the suffix, valid\n+     * @return the variable's value or <b>null</b> if the variable is unknown\n+     */\n+    protected String resolveVariable(String variableName, StrBuilder buf, int startPos, int endPos) {\n+        StrLookup resolver = getVariableResolver();\n+        if (resolver == null) {\n+            return null;\n+        }\n+        return resolver.lookup(variableName);\n+    }\n+\n+    // Escape\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the escape character.\n+     *\n+     * @return the character used for escaping variable references\n+     */\n+    public char getEscapeChar() {\n+        return this.escapeChar;\n+    }\n+\n+    /**\n+     * Sets the escape character.\n+     * If this character is placed before a variable reference in the source\n+     * text, this variable will be ignored.\n+     *\n+     * @param escapeCharacter  the escape character (0 for disabling escaping)\n+     */\n+    public void setEscapeChar(char escapeCharacter) {\n+        this.escapeChar = escapeCharacter;\n+    }\n+\n+    // Prefix\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the variable prefix matcher currently in use.\n+     * <p>\n+     * The variable prefix is the characer or characters that identify the\n+     * start of a variable. This prefix is expressed in terms of a matcher\n+     * allowing advanced prefix matches.\n+     *\n+     * @return the prefix matcher in use\n+     */\n+    public StrMatcher getVariablePrefixMatcher() {\n+        return prefixMatcher;\n+    }\n+\n+    /**\n+     * Sets the variable prefix matcher currently in use.\n+     * <p>\n+     * The variable prefix is the characer or characters that identify the\n+     * start of a variable. This prefix is expressed in terms of a matcher\n+     * allowing advanced prefix matches.\n+     *\n+     * @param prefixMatcher  the prefix matcher to use, null ignored\n+     * @return this, to enable chaining\n+     * @throws IllegalArgumentException if the prefix matcher is null\n+     */\n+    public StrSubstitutor setVariablePrefixMatcher(StrMatcher prefixMatcher) {\n+        if (prefixMatcher == null) {\n+            throw new IllegalArgumentException(\"Variable prefix matcher must not be null!\");\n+        }\n+        this.prefixMatcher = prefixMatcher;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the variable prefix to use.\n+     * <p>\n+     * The variable prefix is the characer or characters that identify the\n+     * start of a variable. This method allows a single character prefix to\n+     * be easily set.\n+     *\n+     * @param prefix  the prefix character to use\n+     * @return this, to enable chaining\n+     */\n+    public StrSubstitutor setVariablePrefix(char prefix) {\n+        return setVariablePrefixMatcher(StrMatcher.charMatcher(prefix));\n+    }\n+\n+    /**\n+     * Sets the variable prefix to use.\n+     * <p>\n+     * The variable prefix is the characer or characters that identify the\n+     * start of a variable. This method allows a string prefix to be easily set.\n+     *\n+     * @param prefix  the prefix for variables, not null\n+     * @return this, to enable chaining\n+     * @throws IllegalArgumentException if the prefix is null\n+     */\n+    public StrSubstitutor setVariablePrefix(String prefix) {\n+       if (prefix == null) {\n+            throw new IllegalArgumentException(\"Variable prefix must not be null!\");\n+        }\n+        return setVariablePrefixMatcher(StrMatcher.stringMatcher(prefix));\n+    }\n+\n+    // Suffix\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the variable suffix matcher currently in use.\n+     * <p>\n+     * The variable suffix is the characer or characters that identify the\n+     * end of a variable. This suffix is expressed in terms of a matcher\n+     * allowing advanced suffix matches.\n+     *\n+     * @return the suffix matcher in use\n+     */\n+    public StrMatcher getVariableSuffixMatcher() {\n+        return suffixMatcher;\n+    }\n+\n+    /**\n+     * Sets the variable suffix matcher currently in use.\n+     * <p>\n+     * The variable suffix is the characer or characters that identify the\n+     * end of a variable. This suffix is expressed in terms of a matcher\n+     * allowing advanced suffix matches.\n+     *\n+     * @param suffixMatcher  the suffix matcher to use, null ignored\n+     * @return this, to enable chaining\n+     * @throws IllegalArgumentException if the suffix matcher is null\n+     */\n+    public StrSubstitutor setVariableSuffixMatcher(StrMatcher suffixMatcher) {\n+        if (suffixMatcher == null) {\n+            throw new IllegalArgumentException(\"Variable suffix matcher must not be null!\");\n+        }\n+        this.suffixMatcher = suffixMatcher;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the variable suffix to use.\n+     * <p>\n+     * The variable suffix is the characer or characters that identify the\n+     * end of a variable. This method allows a single character suffix to\n+     * be easily set.\n+     *\n+     * @param suffix  the suffix character to use\n+     * @return this, to enable chaining\n+     */\n+    public StrSubstitutor setVariableSuffix(char suffix) {\n+        return setVariableSuffixMatcher(StrMatcher.charMatcher(suffix));\n+    }\n+\n+    /**\n+     * Sets the variable suffix to use.\n+     * <p>\n+     * The variable suffix is the characer or characters that identify the\n+     * end of a variable. This method allows a string suffix to be easily set.\n+     *\n+     * @param suffix  the suffix for variables, not null\n+     * @return this, to enable chaining\n+     * @throws IllegalArgumentException if the suffix is null\n+     */\n+    public StrSubstitutor setVariableSuffix(String suffix) {\n+       if (suffix == null) {\n+            throw new IllegalArgumentException(\"Variable suffix must not be null!\");\n+        }\n+        return setVariableSuffixMatcher(StrMatcher.stringMatcher(suffix));\n+    }\n+\n+    // Resolver\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the VariableResolver that is used to lookup variables.\n+     *\n+     * @return the VariableResolver\n+     */\n+    public StrLookup getVariableResolver() {\n+        return this.variableResolver;\n+    }\n+\n+    /**\n+     * Sets the VariableResolver that is used to lookup variables.\n+     *\n+     * @param variableResolver  the VariableResolver\n+     */\n+    public void setVariableResolver(StrLookup variableResolver) {\n+        this.variableResolver = variableResolver;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/text/StrTokenizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.text;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+\n+/**\n+ * Tokenizes a string based based on delimiters (separators)\n+ * and supporting quoting and ignored character concepts.\n+ * <p>\n+ * This class can split a String into many smaller strings. It aims\n+ * to do a similar job to {@link java.util.StringTokenizer StringTokenizer},\n+ * however it offers much more control and flexibility including implementing\n+ * the <code>ListIterator</code> interface. By default, it is set up\n+ * like <code>StringTokenizer</code>.\n+ * <p>\n+ * The input String is split into a number of <i>tokens</i>.\n+ * Each token is separated from the next String by a <i>delimiter</i>.\n+ * One or more delimiter characters must be specified.\n+ * <p>\n+ * Each token may be surrounded by quotes.\n+ * The <i>quote</i> matcher specifies the quote character(s).\n+ * A quote may be escaped within a quoted section by duplicating itself.\n+ * <p>\n+ * Between each token and the delimiter are potentially characters that need trimming.\n+ * The <i>trimmer</i> matcher specifies these characters.\n+ * One usage might be to trim whitespace characters.\n+ * <p>\n+ * At any point outside the quotes there might potentially be invalid characters.\n+ * The <i>ignored</i> matcher specifies these characters to be removed.\n+ * One usage might be to remove new line characters.\n+ * <p>\n+ * Empty tokens may be removed or returned as null.\n+ * <pre>\n+ * \"a,b,c\"         - Three tokens \"a\",\"b\",\"c\"   (comma delimiter)\n+ * \" a, b , c \"    - Three tokens \"a\",\"b\",\"c\"   (default CSV processing trims whitespace)\n+ * \"a, \", b ,\", c\" - Three tokens \"a, \" , \" b \", \", c\" (quoted text untouched)\n+ * </pre>\n+ * <p>\n+ *\n+ * This tokenizer has the following properties and options:\n+ *\n+ * <table>\n+ *  <tr>\n+ *   <th>Property</th><th>Type</th><th>Default</th>\n+ *  </tr>\n+ *  <tr>\n+ *   <td>delim</td><td>CharSetMatcher</td><td>{ \\t\\n\\r\\f}</td>\n+ *  </tr>\n+ *  <tr>\n+ *   <td>quote</td><td>NoneMatcher</td><td>{}</td>\n+ *  </tr>\n+ *  <tr>\n+ *   <td>ignore</td><td>NoneMatcher</td><td>{}</td>\n+ *  </tr>\n+ *  <tr>\n+ *   <td>emptyTokenAsNull</td><td>boolean</td><td>false</td>\n+ *  </tr>\n+ *  <tr>\n+ *   <td>ignoreEmptyTokens</td><td>boolean</td><td>true</td>\n+ *  </tr>\n+ * </table>\n+ *\n+ * @author Apache Software Foundation\n+ * @author Matthew Inger\n+ * @author Gary D. Gregory\n+ * @since 2.2\n+ * @version $Id$\n+ */\n+public class StrTokenizer implements ListIterator<String>, Cloneable {\n+\n+    private static final StrTokenizer CSV_TOKENIZER_PROTOTYPE;\n+    private static final StrTokenizer TSV_TOKENIZER_PROTOTYPE;\n+    static {\n+        CSV_TOKENIZER_PROTOTYPE = new StrTokenizer();\n+        CSV_TOKENIZER_PROTOTYPE.setDelimiterMatcher(StrMatcher.commaMatcher());\n+        CSV_TOKENIZER_PROTOTYPE.setQuoteMatcher(StrMatcher.doubleQuoteMatcher());\n+        CSV_TOKENIZER_PROTOTYPE.setIgnoredMatcher(StrMatcher.noneMatcher());\n+        CSV_TOKENIZER_PROTOTYPE.setTrimmerMatcher(StrMatcher.trimMatcher());\n+        CSV_TOKENIZER_PROTOTYPE.setEmptyTokenAsNull(false);\n+        CSV_TOKENIZER_PROTOTYPE.setIgnoreEmptyTokens(false);\n+\n+        TSV_TOKENIZER_PROTOTYPE = new StrTokenizer();\n+        TSV_TOKENIZER_PROTOTYPE.setDelimiterMatcher(StrMatcher.tabMatcher());\n+        TSV_TOKENIZER_PROTOTYPE.setQuoteMatcher(StrMatcher.doubleQuoteMatcher());\n+        TSV_TOKENIZER_PROTOTYPE.setIgnoredMatcher(StrMatcher.noneMatcher());\n+        TSV_TOKENIZER_PROTOTYPE.setTrimmerMatcher(StrMatcher.trimMatcher());\n+        TSV_TOKENIZER_PROTOTYPE.setEmptyTokenAsNull(false);\n+        TSV_TOKENIZER_PROTOTYPE.setIgnoreEmptyTokens(false);\n+    }\n+\n+    /** The text to work on. */\n+    private char chars[];\n+    /** The parsed tokens */\n+    private String tokens[];\n+    /** The current iteration position */\n+    private int tokenPos;\n+\n+    /** The delimiter matcher */\n+    private StrMatcher delimMatcher = StrMatcher.splitMatcher();\n+    /** The quote matcher */\n+    private StrMatcher quoteMatcher = StrMatcher.noneMatcher();\n+    /** The ignored matcher */\n+    private StrMatcher ignoredMatcher = StrMatcher.noneMatcher();\n+    /** The trimmer matcher */\n+    private StrMatcher trimmerMatcher = StrMatcher.noneMatcher();\n+\n+    /** Whether to return empty tokens as null */\n+    private boolean emptyAsNull = false;\n+    /** Whether to ignore empty tokens */\n+    private boolean ignoreEmptyTokens = true;\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Returns a clone of <code>CSV_TOKENIZER_PROTOTYPE</code>.\n+     * \n+     * @return a clone of <code>CSV_TOKENIZER_PROTOTYPE</code>.\n+     */\n+    private static StrTokenizer getCSVClone() {\n+        return (StrTokenizer) CSV_TOKENIZER_PROTOTYPE.clone();\n+    }\n+\n+    /**\n+     * Gets a new tokenizer instance which parses Comma Separated Value strings\n+     * initializing it with the given input.  The default for CSV processing\n+     * will be trim whitespace from both ends (which can be overridden with\n+     * the setTrimmer method).\n+     * <p>\n+     * You must call a \"reset\" method to set the string which you want to parse.\n+     * @return a new tokenizer instance which parses Comma Separated Value strings\n+     */\n+    public static StrTokenizer getCSVInstance() {\n+        return getCSVClone();\n+    }\n+\n+    /**\n+     * Gets a new tokenizer instance which parses Comma Separated Value strings\n+     * initializing it with the given input.  The default for CSV processing\n+     * will be trim whitespace from both ends (which can be overridden with\n+     * the setTrimmer method).\n+     *\n+     * @param input  the text to parse\n+     * @return a new tokenizer instance which parses Comma Separated Value strings\n+     */\n+    public static StrTokenizer getCSVInstance(String input) {\n+        StrTokenizer tok = getCSVClone();\n+        tok.reset(input);\n+        return tok;\n+    }\n+\n+    /**\n+     * Gets a new tokenizer instance which parses Comma Separated Value strings\n+     * initializing it with the given input.  The default for CSV processing\n+     * will be trim whitespace from both ends (which can be overridden with\n+     * the setTrimmer method).\n+     *\n+     * @param input  the text to parse\n+     * @return a new tokenizer instance which parses Comma Separated Value strings\n+     */\n+    public static StrTokenizer getCSVInstance(char[] input) {\n+        StrTokenizer tok = getCSVClone();\n+        tok.reset(input);\n+        return tok;\n+    }\n+\n+    /**\n+     * Returns a clone of <code>TSV_TOKENIZER_PROTOTYPE</code>.\n+     * \n+     * @return a clone of <code>TSV_TOKENIZER_PROTOTYPE</code>.\n+     */\n+    private static StrTokenizer getTSVClone() {\n+        return (StrTokenizer) TSV_TOKENIZER_PROTOTYPE.clone();\n+    }\n+\n+\n+    /**\n+     * Gets a new tokenizer instance which parses Tab Separated Value strings.\n+     * The default for CSV processing will be trim whitespace from both ends\n+     * (which can be overridden with the setTrimmer method).\n+     * <p>\n+     * You must call a \"reset\" method to set the string which you want to parse.\n+     * @return a new tokenizer instance which parses Tab Separated Value strings.\n+     */\n+    public static StrTokenizer getTSVInstance() {\n+        return getTSVClone();\n+    }\n+\n+    /**\n+     * Gets a new tokenizer instance which parses Tab Separated Value strings.\n+     * The default for CSV processing will be trim whitespace from both ends\n+     * (which can be overridden with the setTrimmer method).\n+     * @param input  the string to parse\n+     * @return a new tokenizer instance which parses Tab Separated Value strings.\n+     */\n+    public static StrTokenizer getTSVInstance(String input) {\n+        StrTokenizer tok = getTSVClone();\n+        tok.reset(input);\n+        return tok;\n+    }\n+\n+    /**\n+     * Gets a new tokenizer instance which parses Tab Separated Value strings.\n+     * The default for CSV processing will be trim whitespace from both ends\n+     * (which can be overridden with the setTrimmer method).\n+     * @param input  the string to parse\n+     * @return a new tokenizer instance which parses Tab Separated Value strings.\n+     */\n+    public static StrTokenizer getTSVInstance(char[] input) {\n+        StrTokenizer tok = getTSVClone();\n+        tok.reset(input);\n+        return tok;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a tokenizer splitting on space, tab, newline and formfeed\n+     * as per StringTokenizer, but with no text to tokenize.\n+     * <p>\n+     * This constructor is normally used with {@link #reset(String)}.\n+     */\n+    public StrTokenizer() {\n+        super();\n+        this.chars = null;\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on space, tab, newline and formfeed\n+     * as per StringTokenizer.\n+     *\n+     * @param input  the string which is to be parsed\n+     */\n+    public StrTokenizer(String input) {\n+        super();\n+        if (input != null) {\n+            chars = input.toCharArray();\n+        } else {\n+            chars = null;\n+        }\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on the specified delimiter character.\n+     *\n+     * @param input  the string which is to be parsed\n+     * @param delim  the field delimiter character\n+     */\n+    public StrTokenizer(String input, char delim) {\n+        this(input);\n+        setDelimiterChar(delim);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on the specified delimiter string.\n+     *\n+     * @param input  the string which is to be parsed\n+     * @param delim  the field delimiter string\n+     */\n+    public StrTokenizer(String input, String delim) {\n+        this(input);\n+        setDelimiterString(delim);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting using the specified delimiter matcher.\n+     *\n+     * @param input  the string which is to be parsed\n+     * @param delim  the field delimiter matcher\n+     */\n+    public StrTokenizer(String input, StrMatcher delim) {\n+        this(input);\n+        setDelimiterMatcher(delim);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on the specified delimiter character\n+     * and handling quotes using the specified quote character.\n+     *\n+     * @param input  the string which is to be parsed\n+     * @param delim  the field delimiter character\n+     * @param quote  the field quoted string character\n+     */\n+    public StrTokenizer(String input, char delim, char quote) {\n+        this(input, delim);\n+        setQuoteChar(quote);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting using the specified delimiter matcher\n+     * and handling quotes using the specified quote matcher.\n+     *\n+     * @param input  the string which is to be parsed\n+     * @param delim  the field delimiter matcher\n+     * @param quote  the field quoted string matcher\n+     */\n+    public StrTokenizer(String input, StrMatcher delim, StrMatcher quote) {\n+        this(input, delim);\n+        setQuoteMatcher(quote);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on space, tab, newline and formfeed\n+     * as per StringTokenizer.\n+     *\n+     * @param input  the string which is to be parsed, not cloned\n+     */\n+    public StrTokenizer(char[] input) {\n+        super();\n+        this.chars = ArrayUtils.clone(input);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on the specified character.\n+     *\n+     * @param input  the string which is to be parsed, not cloned\n+     * @param delim the field delimiter character\n+     */\n+    public StrTokenizer(char[] input, char delim) {\n+        this(input);\n+        setDelimiterChar(delim);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on the specified string.\n+     *\n+     * @param input  the string which is to be parsed, not cloned\n+     * @param delim the field delimiter string\n+     */\n+    public StrTokenizer(char[] input, String delim) {\n+        this(input);\n+        setDelimiterString(delim);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting using the specified delimiter matcher.\n+     *\n+     * @param input  the string which is to be parsed, not cloned\n+     * @param delim  the field delimiter matcher\n+     */\n+    public StrTokenizer(char[] input, StrMatcher delim) {\n+        this(input);\n+        setDelimiterMatcher(delim);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting on the specified delimiter character\n+     * and handling quotes using the specified quote character.\n+     *\n+     * @param input  the string which is to be parsed, not cloned\n+     * @param delim  the field delimiter character\n+     * @param quote  the field quoted string character\n+     */\n+    public StrTokenizer(char[] input, char delim, char quote) {\n+        this(input, delim);\n+        setQuoteChar(quote);\n+    }\n+\n+    /**\n+     * Constructs a tokenizer splitting using the specified delimiter matcher\n+     * and handling quotes using the specified quote matcher.\n+     *\n+     * @param input  the string which is to be parsed, not cloned\n+     * @param delim  the field delimiter character\n+     * @param quote  the field quoted string character\n+     */\n+    public StrTokenizer(char[] input, StrMatcher delim, StrMatcher quote) {\n+        this(input, delim);\n+        setQuoteMatcher(quote);\n+    }\n+\n+    // API\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of tokens found in the String.\n+     *\n+     * @return the number of matched tokens\n+     */\n+    public int size() {\n+        checkTokenized();\n+        return tokens.length;\n+    }\n+\n+    /**\n+     * Gets the next token from the String.\n+     *\n+     * @return the next sequential token, or null when no more tokens are found\n+     */\n+    public String nextToken() {\n+        if (hasNext()) {\n+            return tokens[tokenPos++];\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets the previous token from the String.\n+     *\n+     * @return the previous sequential token, or null when no more tokens are found\n+     */\n+    public String previousToken() {\n+        if (hasPrevious()) {\n+            return tokens[--tokenPos];\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets a copy of the full token list as an independent modifiable array.\n+     *\n+     * @return the tokens as a String array\n+     */\n+    public String[] getTokenArray() {\n+        checkTokenized();\n+        return tokens.clone();\n+    }\n+\n+    /**\n+     * Gets a copy of the full token list as an independent modifiable list.\n+     *\n+     * @return the tokens as a String array\n+     */\n+    public List<String> getTokenList() {\n+        checkTokenized();\n+        List<String> list = new ArrayList<String>(tokens.length);\n+        for (String element : tokens) {\n+            list.add(element);\n+        }\n+        return list;\n+    }\n+\n+    /**\n+     * Resets this tokenizer, forgetting all parsing and iteration already completed.\n+     * <p>\n+     * This method allows the same tokenizer to be reused for the same String.\n+     *\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer reset() {\n+        tokenPos = 0;\n+        tokens = null;\n+        return this;\n+    }\n+\n+    /**\n+     * Reset this tokenizer, giving it a new input string to parse.\n+     * In this manner you can re-use a tokenizer with the same settings\n+     * on multiple input lines.\n+     *\n+     * @param input  the new string to tokenize, null sets no text to parse\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer reset(String input) {\n+        reset();\n+        if (input != null) {\n+            this.chars = input.toCharArray();\n+        } else {\n+            this.chars = null;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Reset this tokenizer, giving it a new input string to parse.\n+     * In this manner you can re-use a tokenizer with the same settings\n+     * on multiple input lines.\n+     *\n+     * @param input  the new character array to tokenize, not cloned, null sets no text to parse\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer reset(char[] input) {\n+        reset();\n+        this.chars = ArrayUtils.clone(input);\n+        return this;\n+    }\n+\n+    // ListIterator\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether there are any more tokens.\n+     *\n+     * @return true if there are more tokens\n+     */\n+    public boolean hasNext() {\n+        checkTokenized();\n+        return tokenPos < tokens.length;\n+    }\n+\n+    /**\n+     * Gets the next token. This method is equivalent to {@link #nextToken()}.\n+     *\n+     * @return the next String token\n+     */\n+    public String next() {\n+        if (hasNext()) {\n+            return tokens[tokenPos++];\n+        }\n+        throw new NoSuchElementException();\n+    }\n+\n+    /**\n+     * Gets the index of the next token to return.\n+     *\n+     * @return the next token index\n+     */\n+    public int nextIndex() {\n+        return tokenPos;\n+    }\n+\n+    /**\n+     * Checks whether there are any previous tokens that can be iterated to.\n+     *\n+     * @return true if there are previous tokens\n+     */\n+    public boolean hasPrevious() {\n+        checkTokenized();\n+        return tokenPos > 0;\n+    }\n+\n+    /**\n+     * Gets the token previous to the last returned token.\n+     *\n+     * @return the previous token\n+     */\n+    public String previous() {\n+        if (hasPrevious()) {\n+            return tokens[--tokenPos];\n+        }\n+        throw new NoSuchElementException();\n+    }\n+\n+    /**\n+     * Gets the index of the previous token.\n+     *\n+     * @return the previous token index\n+     */\n+    public int previousIndex() {\n+        return tokenPos - 1;\n+    }\n+\n+    /**\n+     * Unsupported ListIterator operation.\n+     *\n+     * @throws UnsupportedOperationException always\n+     */\n+    public void remove() {\n+        throw new UnsupportedOperationException(\"remove() is unsupported\");\n+    }\n+\n+    /**\n+     * Unsupported ListIterator operation.\n+     * @param obj this parameter ignored.\n+     * @throws UnsupportedOperationException always\n+     */\n+    public void set(String obj) {\n+        throw new UnsupportedOperationException(\"set() is unsupported\");\n+    }\n+\n+    /**\n+     * Unsupported ListIterator operation.\n+     * @param obj this parameter ignored.\n+     * @throws UnsupportedOperationException always\n+     */\n+    public void add(String obj) {\n+        throw new UnsupportedOperationException(\"add() is unsupported\");\n+    }\n+\n+    // Implementation\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks if tokenization has been done, and if not then do it.\n+     */\n+    private void checkTokenized() {\n+        if (tokens == null) {\n+            if (chars == null) {\n+                // still call tokenize as subclass may do some work\n+                List<String> split = tokenize(null, 0, 0);\n+                tokens = split.toArray(new String[split.size()]);\n+            } else {\n+                List<String> split = tokenize(chars, 0, chars.length);\n+                tokens = split.toArray(new String[split.size()]);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Internal method to performs the tokenization.\n+     * <p>\n+     * Most users of this class do not need to call this method. This method\n+     * will be called automatically by other (public) methods when required.\n+     * <p>\n+     * This method exists to allow subclasses to add code before or after the\n+     * tokenization. For example, a subclass could alter the character array,\n+     * offset or count to be parsed, or call the tokenizer multiple times on\n+     * multiple strings. It is also be possible to filter the results.\n+     * <p>\n+     * <code>StrTokenizer</code> will always pass a zero offset and a count\n+     * equal to the length of the array to this method, however a subclass\n+     * may pass other values, or even an entirely different array.\n+     * \n+     * @param chars  the character array being tokenized, may be null\n+     * @param offset  the start position within the character array, must be valid\n+     * @param count  the number of characters to tokenize, must be valid\n+     * @return the modifiable list of String tokens, unmodifiable if null array or zero count\n+     */\n+    protected List<String> tokenize(char[] chars, int offset, int count) {\n+        if (chars == null || count == 0) {\n+            return Collections.emptyList();\n+        }\n+        StrBuilder buf = new StrBuilder();\n+        List<String> tokens = new ArrayList<String>();\n+        int pos = offset;\n+        \n+        // loop around the entire buffer\n+        while (pos >= 0 && pos < count) {\n+            // find next token\n+            pos = readNextToken(chars, pos, count, buf, tokens);\n+            \n+            // handle case where end of string is a delimiter\n+            if (pos >= count) {\n+                addToken(tokens, \"\");\n+            }\n+        }\n+        return tokens;\n+    }\n+\n+    /**\n+     * Adds a token to a list, paying attention to the parameters we've set.\n+     *\n+     * @param list  the list to add to\n+     * @param tok  the token to add\n+     */\n+    private void addToken(List<String> list, String tok) {\n+        if (tok == null || tok.length() == 0) {\n+            if (isIgnoreEmptyTokens()) {\n+                return;\n+            }\n+            if (isEmptyTokenAsNull()) {\n+                tok = null;\n+            }\n+        }\n+        list.add(tok);\n+    }\n+\n+    /**\n+     * Reads character by character through the String to get the next token.\n+     *\n+     * @param chars  the character array being tokenized\n+     * @param start  the first character of field\n+     * @param len  the length of the character array being tokenized\n+     * @param workArea  a temporary work area\n+     * @param tokens  the list of parsed tokens\n+     * @return the starting position of the next field (the character\n+     *  immediately after the delimiter), or -1 if end of string found\n+     */\n+    private int readNextToken(char[] chars, int start, int len, StrBuilder workArea, List<String> tokens) {\n+        // skip all leading whitespace, unless it is the\n+        // field delimiter or the quote character\n+        while (start < len) {\n+            int removeLen = Math.max(\n+                    getIgnoredMatcher().isMatch(chars, start, start, len),\n+                    getTrimmerMatcher().isMatch(chars, start, start, len));\n+            if (removeLen == 0 ||\n+                getDelimiterMatcher().isMatch(chars, start, start, len) > 0 ||\n+                getQuoteMatcher().isMatch(chars, start, start, len) > 0) {\n+                break;\n+            }\n+            start += removeLen;\n+        }\n+        \n+        // handle reaching end\n+        if (start >= len) {\n+            addToken(tokens, \"\");\n+            return -1;\n+        }\n+        \n+        // handle empty token\n+        int delimLen = getDelimiterMatcher().isMatch(chars, start, start, len);\n+        if (delimLen > 0) {\n+            addToken(tokens, \"\");\n+            return start + delimLen;\n+        }\n+        \n+        // handle found token\n+        int quoteLen = getQuoteMatcher().isMatch(chars, start, start, len);\n+        if (quoteLen > 0) {\n+            return readWithQuotes(chars, start + quoteLen, len, workArea, tokens, start, quoteLen);\n+        }\n+        return readWithQuotes(chars, start, len, workArea, tokens, 0, 0);\n+    }\n+\n+    /**\n+     * Reads a possibly quoted string token.\n+     *\n+     * @param chars  the character array being tokenized\n+     * @param start  the first character of field\n+     * @param len  the length of the character array being tokenized\n+     * @param workArea  a temporary work area\n+     * @param tokens  the list of parsed tokens\n+     * @param quoteStart  the start position of the matched quote, 0 if no quoting\n+     * @param quoteLen  the length of the matched quote, 0 if no quoting\n+     * @return the starting position of the next field (the character\n+     *  immediately after the delimiter, or if end of string found,\n+     *  then the length of string\n+     */\n+    private int readWithQuotes(char[] chars, int start, int len, StrBuilder workArea, \n+                               List<String> tokens, int quoteStart, int quoteLen) \n+    {\n+        // Loop until we've found the end of the quoted\n+        // string or the end of the input\n+        workArea.clear();\n+        int pos = start;\n+        boolean quoting = (quoteLen > 0);\n+        int trimStart = 0;\n+        \n+        while (pos < len) {\n+            // quoting mode can occur several times throughout a string\n+            // we must switch between quoting and non-quoting until we\n+            // encounter a non-quoted delimiter, or end of string\n+            if (quoting) {\n+                // In quoting mode\n+                \n+                // If we've found a quote character, see if it's\n+                // followed by a second quote.  If so, then we need\n+                // to actually put the quote character into the token\n+                // rather than end the token.\n+                if (isQuote(chars, pos, len, quoteStart, quoteLen)) {\n+                    if (isQuote(chars, pos + quoteLen, len, quoteStart, quoteLen)) {\n+                        // matched pair of quotes, thus an escaped quote\n+                        workArea.append(chars, pos, quoteLen);\n+                        pos += (quoteLen * 2);\n+                        trimStart = workArea.size();\n+                        continue;\n+                    }\n+                    \n+                    // end of quoting\n+                    quoting = false;\n+                    pos += quoteLen;\n+                    continue;\n+                }\n+                \n+                // copy regular character from inside quotes\n+                workArea.append(chars[pos++]);\n+                trimStart = workArea.size();\n+                \n+            } else {\n+                // Not in quoting mode\n+                \n+                // check for delimiter, and thus end of token\n+                int delimLen = getDelimiterMatcher().isMatch(chars, pos, start, len);\n+                if (delimLen > 0) {\n+                    // return condition when end of token found\n+                    addToken(tokens, workArea.substring(0, trimStart));\n+                    return pos + delimLen;\n+                }\n+                \n+                // check for quote, and thus back into quoting mode\n+                if (quoteLen > 0) {\n+                    if (isQuote(chars, pos, len, quoteStart, quoteLen)) {\n+                        quoting = true;\n+                        pos += quoteLen;\n+                        continue;\n+                    }\n+                }\n+                \n+                // check for ignored (outside quotes), and ignore\n+                int ignoredLen = getIgnoredMatcher().isMatch(chars, pos, start, len);\n+                if (ignoredLen > 0) {\n+                    pos += ignoredLen;\n+                    continue;\n+                }\n+                \n+                // check for trimmed character\n+                // don't yet know if its at the end, so copy to workArea\n+                // use trimStart to keep track of trim at the end\n+                int trimmedLen = getTrimmerMatcher().isMatch(chars, pos, start, len);\n+                if (trimmedLen > 0) {\n+                    workArea.append(chars, pos, trimmedLen);\n+                    pos += trimmedLen;\n+                    continue;\n+                }\n+                \n+                // copy regular character from outside quotes\n+                workArea.append(chars[pos++]);\n+                trimStart = workArea.size();\n+            }\n+        }\n+        \n+        // return condition when end of string found\n+        addToken(tokens, workArea.substring(0, trimStart));\n+        return -1;\n+    }\n+\n+    /**\n+     * Checks if the characters at the index specified match the quote\n+     * already matched in readNextToken().\n+     *\n+     * @param chars  the character array being tokenized\n+     * @param pos  the position to check for a quote\n+     * @param len  the length of the character array being tokenized\n+     * @param quoteStart  the start position of the matched quote, 0 if no quoting\n+     * @param quoteLen  the length of the matched quote, 0 if no quoting\n+     * @return true if a quote is matched\n+     */\n+    private boolean isQuote(char[] chars, int pos, int len, int quoteStart, int quoteLen) {\n+        for (int i = 0; i < quoteLen; i++) {\n+            if ((pos + i) >= len || chars[pos + i] != chars[quoteStart + i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    // Delimiter\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the field delimiter matcher.\n+     *\n+     * @return the delimiter matcher in use\n+     */\n+    public StrMatcher getDelimiterMatcher() {\n+        return this.delimMatcher;\n+    }\n+\n+    /**\n+     * Sets the field delimiter matcher.\n+     * <p>\n+     * The delimitier is used to separate one token from another.\n+     *\n+     * @param delim  the delimiter matcher to use\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setDelimiterMatcher(StrMatcher delim) {\n+        if (delim == null) {\n+            this.delimMatcher = StrMatcher.noneMatcher();\n+        } else {\n+            this.delimMatcher = delim;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the field delimiter character.\n+     *\n+     * @param delim  the delimiter character to use\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setDelimiterChar(char delim) {\n+        return setDelimiterMatcher(StrMatcher.charMatcher(delim));\n+    }\n+\n+    /**\n+     * Sets the field delimiter string.\n+     *\n+     * @param delim  the delimiter string to use\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setDelimiterString(String delim) {\n+        return setDelimiterMatcher(StrMatcher.stringMatcher(delim));\n+    }\n+\n+    // Quote\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the quote matcher currently in use.\n+     * <p>\n+     * The quote character is used to wrap data between the tokens.\n+     * This enables delimiters to be entered as data.\n+     * The default value is '\"' (double quote).\n+     *\n+     * @return the quote matcher in use\n+     */\n+    public StrMatcher getQuoteMatcher() {\n+        return quoteMatcher;\n+    }\n+\n+    /**\n+     * Set the quote matcher to use.\n+     * <p>\n+     * The quote character is used to wrap data between the tokens.\n+     * This enables delimiters to be entered as data.\n+     *\n+     * @param quote  the quote matcher to use, null ignored\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setQuoteMatcher(StrMatcher quote) {\n+        if (quote != null) {\n+            this.quoteMatcher = quote;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the quote character to use.\n+     * <p>\n+     * The quote character is used to wrap data between the tokens.\n+     * This enables delimiters to be entered as data.\n+     *\n+     * @param quote  the quote character to use\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setQuoteChar(char quote) {\n+        return setQuoteMatcher(StrMatcher.charMatcher(quote));\n+    }\n+\n+    // Ignored\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the ignored character matcher.\n+     * <p>\n+     * These characters are ignored when parsing the String, unless they are\n+     * within a quoted region.\n+     * The default value is not to ignore anything.\n+     *\n+     * @return the ignored matcher in use\n+     */\n+    public StrMatcher getIgnoredMatcher() {\n+        return ignoredMatcher;\n+    }\n+\n+    /**\n+     * Set the matcher for characters to ignore.\n+     * <p>\n+     * These characters are ignored when parsing the String, unless they are\n+     * within a quoted region.\n+     *\n+     * @param ignored  the ignored matcher to use, null ignored\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setIgnoredMatcher(StrMatcher ignored) {\n+        if (ignored != null) {\n+            this.ignoredMatcher = ignored;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Set the character to ignore.\n+     * <p>\n+     * This character is ignored when parsing the String, unless it is\n+     * within a quoted region.\n+     *\n+     * @param ignored  the ignored character to use\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setIgnoredChar(char ignored) {\n+        return setIgnoredMatcher(StrMatcher.charMatcher(ignored));\n+    }\n+\n+    // Trimmer\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the trimmer character matcher.\n+     * <p>\n+     * These characters are trimmed off on each side of the delimiter\n+     * until the token or quote is found.\n+     * The default value is not to trim anything.\n+     *\n+     * @return the trimmer matcher in use\n+     */\n+    public StrMatcher getTrimmerMatcher() {\n+        return trimmerMatcher;\n+    }\n+\n+    /**\n+     * Sets the matcher for characters to trim.\n+     * <p>\n+     * These characters are trimmed off on each side of the delimiter\n+     * until the token or quote is found.\n+     *\n+     * @param trimmer  the trimmer matcher to use, null ignored\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setTrimmerMatcher(StrMatcher trimmer) {\n+        if (trimmer != null) {\n+            this.trimmerMatcher = trimmer;\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets whether the tokenizer currently returns empty tokens as null.\n+     * The default for this property is false.\n+     *\n+     * @return true if empty tokens are returned as null\n+     */\n+    public boolean isEmptyTokenAsNull() {\n+        return this.emptyAsNull;\n+    }\n+\n+    /**\n+     * Sets whether the tokenizer should return empty tokens as null.\n+     * The default for this property is false.\n+     *\n+     * @param emptyAsNull  whether empty tokens are returned as null\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setEmptyTokenAsNull(boolean emptyAsNull) {\n+        this.emptyAsNull = emptyAsNull;\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets whether the tokenizer currently ignores empty tokens.\n+     * The default for this property is true.\n+     *\n+     * @return true if empty tokens are not returned\n+     */\n+    public boolean isIgnoreEmptyTokens() {\n+        return ignoreEmptyTokens;\n+    }\n+\n+    /**\n+     * Sets whether the tokenizer should ignore and not return empty tokens.\n+     * The default for this property is true.\n+     *\n+     * @param ignoreEmptyTokens  whether empty tokens are not returned\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setIgnoreEmptyTokens(boolean ignoreEmptyTokens) {\n+        this.ignoreEmptyTokens = ignoreEmptyTokens;\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the String content that the tokenizer is parsing.\n+     *\n+     * @return the string content being parsed\n+     */\n+    public String getContent() {\n+        if (chars == null) {\n+            return null;\n+        }\n+        return new String(chars);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a new instance of this Tokenizer. The new instance is reset so\n+     * that it will be at the start of the token list.\n+     * If a {@link CloneNotSupportedException} is caught, return <code>null</code>.\n+     * \n+     * @return a new instance of this Tokenizer which has been reset.\n+     */\n+    @Override\n+    public Object clone() {\n+        try {\n+            return cloneReset();\n+        } catch (CloneNotSupportedException ex) {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of this Tokenizer. The new instance is reset so that\n+     * it will be at the start of the token list.\n+     * \n+     * @return a new instance of this Tokenizer which has been reset.\n+     * @throws CloneNotSupportedException if there is a problem cloning\n+     */\n+    Object cloneReset() throws CloneNotSupportedException {\n+        // this method exists to enable 100% test coverage\n+        StrTokenizer cloned = (StrTokenizer) super.clone();\n+        if (cloned.chars != null) {\n+            cloned.chars = cloned.chars.clone();\n+        }\n+        cloned.reset();\n+        return cloned;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the String content that the tokenizer is parsing.\n+     *\n+     * @return the string content being parsed\n+     */\n+    @Override\n+    public String toString() {\n+        if (tokens == null) {\n+            return \"StrTokenizer[not tokenized yet]\";\n+        }\n+        return \"StrTokenizer\" + getTokenList();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/AggregateTranslator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.text.translate;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+import org.apache.commons.lang3.ArrayUtils;\n+\n+/**\n+ * Executes a sequence of translators one after the other. Execution ends whenever \n+ * the first translator consumes codepoints from the input.\n+ * \n+ * @author Apache Software Foundation\n+ * @since 3.0\n+ */\n+public class AggregateTranslator extends CharSequenceTranslator {\n+\n+    private final CharSequenceTranslator[] translators;\n+\n+    /**\n+     * Specify the translators to be used at creation time. \n+     *\n+     * @param translators CharSequenceTranslator array to aggregate\n+     */\n+    public AggregateTranslator(CharSequenceTranslator... translators) {\n+        this.translators = ArrayUtils.clone(translators);\n+    }\n+\n+    /**\n+     * The first translator to consume codepoints from the input is the 'winner'. \n+     * Execution stops with the number of consumed codepoints being returned. \n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public int translate(CharSequence input, int index, Writer out) throws IOException {\n+        for (CharSequenceTranslator translator : translators) {\n+            int consumed = translator.translate(input, index, out);\n+            if(consumed != 0) {\n+                return consumed;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.text.translate;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.io.StringWriter;\n+import java.util.Locale;\n+\n+/**\n+ * An API for translating text. \n+ * Its core use is to escape and unescape text. Because escaping and unescaping \n+ * is completely contextual, the API does not present two separate signatures.\n+ * \n+ * @author Apache Software Foundation\n+ * @since 3.0\n+ */\n+public abstract class CharSequenceTranslator {\n+\n+    /**\n+     * Translate a set of codepoints, represented by an int index into a CharSequence, \n+     * into another set of codepoints. The number of codepoints consumed must be returned, \n+     * and the only IOExceptions thrown must be from interacting with the Writer so that \n+     * the top level API may reliable ignore StringWriter IOExceptions. \n+     *\n+     * @param input CharSequence that is being translated\n+     * @param index int representing the current point of translation\n+     * @param out Writer to translate the text to\n+     * @return int count of codepoints consumed\n+     * @throws IOException if and only if the Writer produces an IOException\n+     */\n+    public abstract int translate(CharSequence input, int index, Writer out) throws IOException;\n+\n+    /**\n+     * Helper for non-Writer usage. \n+     * @param input CharSequence to be translated\n+     * @return String output of translation\n+     */\n+    public final String translate(CharSequence input) {\n+        if (input == null) {\n+            return null;\n+        }\n+        try {\n+            StringWriter writer = new StringWriter(input.length() * 2);  // TODO: Make the 2 part of the API???\n+            translate(input, writer);\n+            return writer.toString();\n+        } catch (IOException ioe) {\n+            // this should never ever happen while writing to a StringWriter\n+            throw new RuntimeException(ioe);\n+        }\n+    }\n+\n+    // TODO: Point to CsvEscaper as a way to 'override'?\n+    /**\n+     * Translate an input onto a Writer. This is intentionally final as its algorithm is \n+     * tightly coupled with the abstract method of this class. \n+     *\n+     * @param input CharSequence that is being translated\n+     * @param out Writer to translate the text to\n+     * @throws IOException if and only if the Writer produces an IOException\n+     */\n+    public final void translate(CharSequence input, Writer out) throws IOException {\n+        if (out == null) {\n+            throw new IllegalArgumentException(\"The Writer must not be null\");\n+        }\n+        if (input == null) {\n+            return;\n+        }\n+        int sz = Character.codePointCount(input, 0, input.length());\n+        for (int i = 0; i < sz; i++) {\n+\n+            // consumed is the number of codepoints consumed\n+            int consumed = translate(input, i, out);\n+\n+            if(consumed == 0) { \n+                out.write( Character.toChars( Character.codePointAt(input, i) ) );\n+            } else {\n+                // contract with translators is that they have to understand codepoints and they just took care of a surrogate pair\n+                for(int j=0; j<consumed; j++) {\n+                    if(i < sz - 2) {\n+                        i += Character.charCount( Character.codePointAt(input, i) );\n+                    } else {\n+                        // If the String ends with a high surrogate, just add the 1 and don't worry about such things\n+                        i++;\n+                    }\n+                }\n+                // for loop will increment 1 anyway, so remove 1 to account for that\n+                i--;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Helper method to create a merger of this translator with another set of \n+     * translators. Useful in customizing the standard functionality.\n+     *\n+     * @param translators CharSequenceTranslator array of translators to merge with this one\n+     * @return CharSequenceTranslator merging this translator with the others\n+     */\n+    public final CharSequenceTranslator with(CharSequenceTranslator... translators) {\n+        CharSequenceTranslator[] newArray = new CharSequenceTranslator[translators.length + 1];\n+        newArray[0] = this;\n+        System.arraycopy(translators, 0, newArray, 1, translators.length);\n+        return new AggregateTranslator(newArray);\n+    }\n+\n+    /**\n+     * <p>Returns an upper case hexadecimal <code>String</code> for the given\n+     * character.</p>\n+     *\n+     * @param codepoint The codepoint to convert.\n+     * @return An upper case hexadecimal <code>String</code>\n+     */\n+    public static String hex(int codepoint) {\n+        return Integer.toHexString(codepoint).toUpperCase(Locale.ENGLISH);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/CodePointTranslator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.text.translate;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+/**\n+ * Helper subclass to CharSequenceTranslator to allow for translations that \n+ * will replace up to one character at a time.\n+ * \n+ * @author Apache Software Foundation\n+ * @since 3.0\n+ */\n+public abstract class CodePointTranslator extends CharSequenceTranslator {\n+\n+    /**\n+     * Implementation of translate that maps onto the abstract translate(int, Writer) method. \n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public final int translate(CharSequence input, int index, Writer out) throws IOException {\n+        int codepoint = Character.codePointAt(input, index);\n+        boolean consumed = translate(codepoint, out);\n+        if(consumed) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    /**\n+     * Translate the specified codepoint into another. \n+     * \n+     * @param codepoint int character input to translate\n+     * @param out Writer to optionally push the translated output to\n+     * @return boolean as to whether translation occurred or not\n+     * @throws IOException if and only if the Writer produces an IOException\n+     */\n+    public abstract boolean translate(int codepoint, Writer out) throws IOException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.text.translate;\n+\n+/**\n+ * Class holding various entity data for HTML and XML - generally for use with \n+ * the LookupTranslator.\n+ * All arrays are of length [*][2].\n+ *\n+ * @author Apache Software Foundation\n+ * @since 3.0\n+ */\n+public class EntityArrays {\n+\n+    public static String[][] ISO8859_1_ESCAPE() { return ISO8859_1_ESCAPE.clone(); }\n+    private static final String[][] ISO8859_1_ESCAPE = {\n+        {\"\\u00A0\", \"&nbsp;\"}, // non-breaking space\n+        {\"\\u00A1\", \"&iexcl;\"}, // inverted exclamation mark\n+        {\"\\u00A2\", \"&cent;\"}, // cent sign\n+        {\"\\u00A3\", \"&pound;\"}, // pound sign\n+        {\"\\u00A4\", \"&curren;\"}, // currency sign\n+        {\"\\u00A5\", \"&yen;\"}, // yen sign = yuan sign\n+        {\"\\u00A6\", \"&brvbar;\"}, // broken bar = broken vertical bar\n+        {\"\\u00A7\", \"&sect;\"}, // section sign\n+        {\"\\u00A8\", \"&uml;\"}, // diaeresis = spacing diaeresis\n+        {\"\\u00A9\", \"&copy;\"}, //  - copyright sign\n+        {\"\\u00AA\", \"&ordf;\"}, // feminine ordinal indicator\n+        {\"\\u00AB\", \"&laquo;\"}, // left-pointing double angle quotation mark = left pointing guillemet\n+        {\"\\u00AC\", \"&not;\"}, // not sign\n+        {\"\\u00AD\", \"&shy;\"}, // soft hyphen = discretionary hyphen\n+        {\"\\u00AE\", \"&reg;\"}, //  - registered trademark sign\n+        {\"\\u00AF\", \"&macr;\"}, // macron = spacing macron = overline = APL overbar\n+        {\"\\u00B0\", \"&deg;\"}, // degree sign\n+        {\"\\u00B1\", \"&plusmn;\"}, // plus-minus sign = plus-or-minus sign\n+        {\"\\u00B2\", \"&sup2;\"}, // superscript two = superscript digit two = squared\n+        {\"\\u00B3\", \"&sup3;\"}, // superscript three = superscript digit three = cubed\n+        {\"\\u00B4\", \"&acute;\"}, // acute accent = spacing acute\n+        {\"\\u00B5\", \"&micro;\"}, // micro sign\n+        {\"\\u00B6\", \"&para;\"}, // pilcrow sign = paragraph sign\n+        {\"\\u00B7\", \"&middot;\"}, // middle dot = Georgian comma = Greek middle dot\n+        {\"\\u00B8\", \"&cedil;\"}, // cedilla = spacing cedilla\n+        {\"\\u00B9\", \"&sup1;\"}, // superscript one = superscript digit one\n+        {\"\\u00BA\", \"&ordm;\"}, // masculine ordinal indicator\n+        {\"\\u00BB\", \"&raquo;\"}, // right-pointing double angle quotation mark = right pointing guillemet\n+        {\"\\u00BC\", \"&frac14;\"}, // vulgar fraction one quarter = fraction one quarter\n+        {\"\\u00BD\", \"&frac12;\"}, // vulgar fraction one half = fraction one half\n+        {\"\\u00BE\", \"&frac34;\"}, // vulgar fraction three quarters = fraction three quarters\n+        {\"\\u00BF\", \"&iquest;\"}, // inverted question mark = turned question mark\n+        {\"\\u00C0\", \"&Agrave;\"}, //  - uppercase A, grave accent\n+        {\"\\u00C1\", \"&Aacute;\"}, //  - uppercase A, acute accent\n+        {\"\\u00C2\", \"&Acirc;\"}, //  - uppercase A, circumflex accent\n+        {\"\\u00C3\", \"&Atilde;\"}, //  - uppercase A, tilde\n+        {\"\\u00C4\", \"&Auml;\"}, //  - uppercase A, umlaut\n+        {\"\\u00C5\", \"&Aring;\"}, //  - uppercase A, ring\n+        {\"\\u00C6\", \"&AElig;\"}, //  - uppercase AE\n+        {\"\\u00C7\", \"&Ccedil;\"}, //  - uppercase C, cedilla\n+        {\"\\u00C8\", \"&Egrave;\"}, //  - uppercase E, grave accent\n+        {\"\\u00C9\", \"&Eacute;\"}, //  - uppercase E, acute accent\n+        {\"\\u00CB\", \"&Ecirc;\"}, //  - uppercase E, circumflex accent\n+        {\"\\u00CC\", \"&Euml;\"}, //  - uppercase E, umlaut\n+        {\"\\u00CD\", \"&Igrave;\"}, //  - uppercase I, grave accent\n+        {\"\\u00CE\", \"&Iacute;\"}, //  - uppercase I, acute accent\n+        {\"\\u00CF\", \"&Icirc;\"}, //  - uppercase I, circumflex accent\n+        {\"\\u00D0\", \"&Iuml;\"}, //  - uppercase I, umlaut\n+        {\"\\u00D1\", \"&ETH;\"}, //  - uppercase Eth, Icelandic\n+        {\"\\u00D2\", \"&Ntilde;\"}, //  - uppercase N, tilde\n+        {\"\\u00D3\", \"&Ograve;\"}, //  - uppercase O, grave accent\n+        {\"\\u00D4\", \"&Oacute;\"}, //  - uppercase O, acute accent\n+        {\"\\u00D5\", \"&Ocirc;\"}, //  - uppercase O, circumflex accent\n+        {\"\\u00D6\", \"&Otilde;\"}, //  - uppercase O, tilde\n+        {\"\\u00D7\", \"&Ouml;\"}, //  - uppercase O, umlaut\n+        {\"\\u00D8\", \"&times;\"}, // multiplication sign\n+        {\"\\u00D9\", \"&Oslash;\"}, //  - uppercase O, slash\n+        {\"\\u00DA\", \"&Ugrave;\"}, //  - uppercase U, grave accent\n+        {\"\\u00DB\", \"&Uacute;\"}, //  - uppercase U, acute accent\n+        {\"\\u00DC\", \"&Ucirc;\"}, //  - uppercase U, circumflex accent\n+        {\"\\u00DD\", \"&Uuml;\"}, //  - uppercase U, umlaut\n+        {\"\\u00DE\", \"&Yacute;\"}, //  - uppercase Y, acute accent\n+        {\"\\u00DF\", \"&THORN;\"}, //  - uppercase THORN, Icelandic\n+        {\"\\u00E0\", \"&szlig;\"}, //  - lowercase sharps, German\n+        {\"\\u00E1\", \"&agrave;\"}, //  - lowercase a, grave accent\n+        {\"\\u00E2\", \"&aacute;\"}, //  - lowercase a, acute accent\n+        {\"\\u00E3\", \"&acirc;\"}, //  - lowercase a, circumflex accent\n+        {\"\\u00E4\", \"&atilde;\"}, //  - lowercase a, tilde\n+        {\"\\u00E5\", \"&auml;\"}, //  - lowercase a, umlaut\n+        {\"\\u00E5\", \"&aring;\"}, //  - lowercase a, ring\n+        {\"\\u00E6\", \"&aelig;\"}, //  - lowercase ae\n+        {\"\\u00E7\", \"&ccedil;\"}, //  - lowercase c, cedilla\n+        {\"\\u00E8\", \"&egrave;\"}, //  - lowercase e, grave accent\n+        {\"\\u00E9\", \"&eacute;\"}, //  - lowercase e, acute accent\n+        {\"\\u00EA\", \"&ecirc;\"}, //  - lowercase e, circumflex accent\n+        {\"\\u00EB\", \"&euml;\"}, //  - lowercase e, umlaut\n+        {\"\\u00EC\", \"&igrave;\"}, //  - lowercase i, grave accent\n+        {\"\\u00ED\", \"&iacute;\"}, //  - lowercase i, acute accent\n+        {\"\\u00EE\", \"&icirc;\"}, //  - lowercase i, circumflex accent\n+        {\"\\u00EF\", \"&iuml;\"}, //  - lowercase i, umlaut\n+        {\"\\u00F0\", \"&eth;\"}, //  - lowercase eth, Icelandic\n+        {\"\\u00F1\", \"&ntilde;\"}, //  - lowercase n, tilde\n+        {\"\\u00F3\", \"&ograve;\"}, //  - lowercase o, grave accent\n+        {\"\\u00F3\", \"&oacute;\"}, //  - lowercase o, acute accent\n+        {\"\\u00F4\", \"&ocirc;\"}, //  - lowercase o, circumflex accent\n+        {\"\\u00F5\", \"&otilde;\"}, //  - lowercase o, tilde\n+        {\"\\u00F6\", \"&ouml;\"}, //  - lowercase o, umlaut\n+        {\"\\u00F7\", \"&divide;\"}, // division sign\n+        {\"\\u00F8\", \"&oslash;\"}, //  - lowercase o, slash\n+        {\"\\u00F9\", \"&ugrave;\"}, //  - lowercase u, grave accent\n+        {\"\\u00FA\", \"&uacute;\"}, //  - lowercase u, acute accent\n+        {\"\\u00FB\", \"&ucirc;\"}, //  - lowercase u, circumflex accent\n+        {\"\\u00FC\", \"&uuml;\"}, //  - lowercase u, umlaut\n+        {\"\\u00FD\", \"&yacute;\"}, //  - lowercase y, acute accent\n+        {\"\\u00FE\", \"&thorn;\"}, //  - lowercase thorn, Icelandic\n+        {\"\\u00FF\", \"&yuml;\"}, //  - lowercase y, umlaut\n+    };\n+\n+    public static String[][] ISO8859_1_UNESCAPE() { return ISO8859_1_UNESCAPE.clone(); }\n+    private static final String[][] ISO8859_1_UNESCAPE = invert(ISO8859_1_ESCAPE);\n+\n+    // http://www.w3.org/TR/REC-html40/sgml/entities.html\n+    public static String[][] HTML40_EXTENDED_ESCAPE() { return HTML40_EXTENDED_ESCAPE.clone(); }\n+    private static final String[][] HTML40_EXTENDED_ESCAPE = {\n+        // <!-- Latin Extended-B -->\n+        {\"\\u0192\", \"&fnof;\"}, // latin small f with hook = function= florin, U+0192 ISOtech -->\n+        // <!-- Greek -->\n+        {\"\\u0391\", \"&Alpha;\"}, // greek capital letter alpha, U+0391 -->\n+        {\"\\u0392\", \"&Beta;\"}, // greek capital letter beta, U+0392 -->\n+        {\"\\u0393\", \"&Gamma;\"}, // greek capital letter gamma,U+0393 ISOgrk3 -->\n+        {\"\\u0394\", \"&Delta;\"}, // greek capital letter delta,U+0394 ISOgrk3 -->\n+        {\"\\u0395\", \"&Epsilon;\"}, // greek capital letter epsilon, U+0395 -->\n+        {\"\\u0396\", \"&Zeta;\"}, // greek capital letter zeta, U+0396 -->\n+        {\"\\u0397\", \"&Eta;\"}, // greek capital letter eta, U+0397 -->\n+        {\"\\u0398\", \"&Theta;\"}, // greek capital letter theta,U+0398 ISOgrk3 -->\n+        {\"\\u0399\", \"&Iota;\"}, // greek capital letter iota, U+0399 -->\n+        {\"\\u039A\", \"&Kappa;\"}, // greek capital letter kappa, U+039A -->\n+        {\"\\u039B\", \"&Lambda;\"}, // greek capital letter lambda,U+039B ISOgrk3 -->\n+        {\"\\u039C\", \"&Mu;\"}, // greek capital letter mu, U+039C -->\n+        {\"\\u039D\", \"&Nu;\"}, // greek capital letter nu, U+039D -->\n+        {\"\\u039E\", \"&Xi;\"}, // greek capital letter xi, U+039E ISOgrk3 -->\n+        {\"\\u039F\", \"&Omicron;\"}, // greek capital letter omicron, U+039F -->\n+        {\"\\u03A0\", \"&Pi;\"}, // greek capital letter pi, U+03A0 ISOgrk3 -->\n+        {\"\\u03A1\", \"&Rho;\"}, // greek capital letter rho, U+03A1 -->\n+        // <!-- there is no Sigmaf, and no U+03A2 character either -->\n+        {\"\\u03A3\", \"&Sigma;\"}, // greek capital letter sigma,U+03A3 ISOgrk3 -->\n+        {\"\\u03A4\", \"&Tau;\"}, // greek capital letter tau, U+03A4 -->\n+        {\"\\u03A5\", \"&Upsilon;\"}, // greek capital letter upsilon,U+03A5 ISOgrk3 -->\n+        {\"\\u03A6\", \"&Phi;\"}, // greek capital letter phi,U+03A6 ISOgrk3 -->\n+        {\"\\u03A7\", \"&Chi;\"}, // greek capital letter chi, U+03A7 -->\n+        {\"\\u03A8\", \"&Psi;\"}, // greek capital letter psi,U+03A8 ISOgrk3 -->\n+        {\"\\u03A9\", \"&Omega;\"}, // greek capital letter omega,U+03A9 ISOgrk3 -->\n+        {\"\\u03B1\", \"&alpha;\"}, // greek small letter alpha,U+03B1 ISOgrk3 -->\n+        {\"\\u03B2\", \"&beta;\"}, // greek small letter beta, U+03B2 ISOgrk3 -->\n+        {\"\\u03B3\", \"&gamma;\"}, // greek small letter gamma,U+03B3 ISOgrk3 -->\n+        {\"\\u03B4\", \"&delta;\"}, // greek small letter delta,U+03B4 ISOgrk3 -->\n+        {\"\\u03B5\", \"&epsilon;\"}, // greek small letter epsilon,U+03B5 ISOgrk3 -->\n+        {\"\\u03B6\", \"&zeta;\"}, // greek small letter zeta, U+03B6 ISOgrk3 -->\n+        {\"\\u03B7\", \"&eta;\"}, // greek small letter eta, U+03B7 ISOgrk3 -->\n+        {\"\\u03B8\", \"&theta;\"}, // greek small letter theta,U+03B8 ISOgrk3 -->\n+        {\"\\u03B9\", \"&iota;\"}, // greek small letter iota, U+03B9 ISOgrk3 -->\n+        {\"\\u03BA\", \"&kappa;\"}, // greek small letter kappa,U+03BA ISOgrk3 -->\n+        {\"\\u03BB\", \"&lambda;\"}, // greek small letter lambda,U+03BB ISOgrk3 -->\n+        {\"\\u03BC\", \"&mu;\"}, // greek small letter mu, U+03BC ISOgrk3 -->\n+        {\"\\u03BD\", \"&nu;\"}, // greek small letter nu, U+03BD ISOgrk3 -->\n+        {\"\\u03BE\", \"&xi;\"}, // greek small letter xi, U+03BE ISOgrk3 -->\n+        {\"\\u03BF\", \"&omicron;\"}, // greek small letter omicron, U+03BF NEW -->\n+        {\"\\u03C0\", \"&pi;\"}, // greek small letter pi, U+03C0 ISOgrk3 -->\n+        {\"\\u03C1\", \"&rho;\"}, // greek small letter rho, U+03C1 ISOgrk3 -->\n+        {\"\\u03C2\", \"&sigmaf;\"}, // greek small letter final sigma,U+03C2 ISOgrk3 -->\n+        {\"\\u03C3\", \"&sigma;\"}, // greek small letter sigma,U+03C3 ISOgrk3 -->\n+        {\"\\u03C4\", \"&tau;\"}, // greek small letter tau, U+03C4 ISOgrk3 -->\n+        {\"\\u03C5\", \"&upsilon;\"}, // greek small letter upsilon,U+03C5 ISOgrk3 -->\n+        {\"\\u03C6\", \"&phi;\"}, // greek small letter phi, U+03C6 ISOgrk3 -->\n+        {\"\\u03C7\", \"&chi;\"}, // greek small letter chi, U+03C7 ISOgrk3 -->\n+        {\"\\u03C8\", \"&psi;\"}, // greek small letter psi, U+03C8 ISOgrk3 -->\n+        {\"\\u03C9\", \"&omega;\"}, // greek small letter omega,U+03C9 ISOgrk3 -->\n+        {\"\\u03D1\", \"&thetasym;\"}, // greek small letter theta symbol,U+03D1 NEW -->\n+        {\"\\u03D2\", \"&upsih;\"}, // greek upsilon with hook symbol,U+03D2 NEW -->\n+        {\"\\u03D6\", \"&piv;\"}, // greek pi symbol, U+03D6 ISOgrk3 -->\n+        // <!-- General Punctuation -->\n+        {\"\\u2022\", \"&bull;\"}, // bullet = black small circle,U+2022 ISOpub -->\n+        // <!-- bullet is NOT the same as bullet operator, U+2219 -->\n+        {\"\\u2026\", \"&hellip;\"}, // horizontal ellipsis = three dot leader,U+2026 ISOpub -->\n+        {\"\\u2032\", \"&prime;\"}, // prime = minutes = feet, U+2032 ISOtech -->\n+        {\"\\u2033\", \"&Prime;\"}, // double prime = seconds = inches,U+2033 ISOtech -->\n+        {\"\\u203E\", \"&oline;\"}, // overline = spacing overscore,U+203E NEW -->\n+        {\"\\u2044\", \"&frasl;\"}, // fraction slash, U+2044 NEW -->\n+        // <!-- Letterlike Symbols -->\n+        {\"\\u2118\", \"&weierp;\"}, // script capital P = power set= Weierstrass p, U+2118 ISOamso -->\n+        {\"\\u2111\", \"&image;\"}, // blackletter capital I = imaginary part,U+2111 ISOamso -->\n+        {\"\\u211C\", \"&real;\"}, // blackletter capital R = real part symbol,U+211C ISOamso -->\n+        {\"\\u2122\", \"&trade;\"}, // trade mark sign, U+2122 ISOnum -->\n+        {\"\\u2135\", \"&alefsym;\"}, // alef symbol = first transfinite cardinal,U+2135 NEW -->\n+        // <!-- alef symbol is NOT the same as hebrew letter alef,U+05D0 although the\n+        // same glyph could be used to depict both characters -->\n+        // <!-- Arrows -->\n+        {\"\\u2190\", \"&larr;\"}, // leftwards arrow, U+2190 ISOnum -->\n+        {\"\\u2191\", \"&uarr;\"}, // upwards arrow, U+2191 ISOnum-->\n+        {\"\\u2192\", \"&rarr;\"}, // rightwards arrow, U+2192 ISOnum -->\n+        {\"\\u2193\", \"&darr;\"}, // downwards arrow, U+2193 ISOnum -->\n+        {\"\\u2194\", \"&harr;\"}, // left right arrow, U+2194 ISOamsa -->\n+        {\"\\u21B5\", \"&crarr;\"}, // downwards arrow with corner leftwards= carriage return, U+21B5 NEW -->\n+        {\"\\u21D0\", \"&lArr;\"}, // leftwards double arrow, U+21D0 ISOtech -->\n+        // <!-- ISO 10646 does not say that lArr is the same as the 'is implied by'\n+        // arrow but also does not have any other character for that function.\n+        // So ? lArr canbe used for 'is implied by' as ISOtech suggests -->\n+        {\"\\u21D1\", \"&uArr;\"}, // upwards double arrow, U+21D1 ISOamsa -->\n+        {\"\\u21D2\", \"&rArr;\"}, // rightwards double arrow,U+21D2 ISOtech -->\n+        // <!-- ISO 10646 does not say this is the 'implies' character but does not\n+        // have another character with this function so ?rArr can be used for\n+        // 'implies' as ISOtech suggests -->\n+        {\"\\u21D3\", \"&dArr;\"}, // downwards double arrow, U+21D3 ISOamsa -->\n+        {\"\\u21D4\", \"&hArr;\"}, // left right double arrow,U+21D4 ISOamsa -->\n+        // <!-- Mathematical Operators -->\n+        {\"\\u2200\", \"&forall;\"}, // for all, U+2200 ISOtech -->\n+        {\"\\u2202\", \"&part;\"}, // partial differential, U+2202 ISOtech -->\n+        {\"\\u2203\", \"&exist;\"}, // there exists, U+2203 ISOtech -->\n+        {\"\\u2205\", \"&empty;\"}, // empty set = null set = diameter,U+2205 ISOamso -->\n+        {\"\\u2207\", \"&nabla;\"}, // nabla = backward difference,U+2207 ISOtech -->\n+        {\"\\u2208\", \"&isin;\"}, // element of, U+2208 ISOtech -->\n+        {\"\\u2209\", \"&notin;\"}, // not an element of, U+2209 ISOtech -->\n+        {\"\\u220B\", \"&ni;\"}, // contains as member, U+220B ISOtech -->\n+        // <!-- should there be a more memorable name than 'ni'? -->\n+        {\"\\u220F\", \"&prod;\"}, // n-ary product = product sign,U+220F ISOamsb -->\n+        // <!-- prod is NOT the same character as U+03A0 'greek capital letter pi'\n+        // though the same glyph might be used for both -->\n+        {\"\\u2211\", \"&sum;\"}, // n-ary summation, U+2211 ISOamsb -->\n+        // <!-- sum is NOT the same character as U+03A3 'greek capital letter sigma'\n+        // though the same glyph might be used for both -->\n+        {\"\\u2122\", \"&minus;\"}, // minus sign, U+2212 ISOtech -->\n+        {\"\\u2217\", \"&lowast;\"}, // asterisk operator, U+2217 ISOtech -->\n+        {\"\\u221A\", \"&radic;\"}, // square root = radical sign,U+221A ISOtech -->\n+        {\"\\u221D\", \"&prop;\"}, // proportional to, U+221D ISOtech -->\n+        {\"\\u221E\", \"&infin;\"}, // infinity, U+221E ISOtech -->\n+        {\"\\u2220\", \"&ang;\"}, // angle, U+2220 ISOamso -->\n+        {\"\\u2227\", \"&and;\"}, // logical and = wedge, U+2227 ISOtech -->\n+        {\"\\u2228\", \"&or;\"}, // logical or = vee, U+2228 ISOtech -->\n+        {\"\\u2229\", \"&cap;\"}, // intersection = cap, U+2229 ISOtech -->\n+        {\"\\u222A\", \"&cup;\"}, // union = cup, U+222A ISOtech -->\n+        {\"\\u222B\", \"&int;\"}, // integral, U+222B ISOtech -->\n+        {\"\\u2234\", \"&there4;\"}, // therefore, U+2234 ISOtech -->\n+        {\"\\u223C\", \"&sim;\"}, // tilde operator = varies with = similar to,U+223C ISOtech -->\n+        // <!-- tilde operator is NOT the same character as the tilde, U+007E,although\n+        // the same glyph might be used to represent both -->\n+        {\"\\u2245\", \"&cong;\"}, // approximately equal to, U+2245 ISOtech -->\n+        {\"\\u2248\", \"&asymp;\"}, // almost equal to = asymptotic to,U+2248 ISOamsr -->\n+        {\"\\u2260\", \"&ne;\"}, // not equal to, U+2260 ISOtech -->\n+        {\"\\u2261\", \"&equiv;\"}, // identical to, U+2261 ISOtech -->\n+        {\"\\u2264\", \"&le;\"}, // less-than or equal to, U+2264 ISOtech -->\n+        {\"\\u2265\", \"&ge;\"}, // greater-than or equal to,U+2265 ISOtech -->\n+        {\"\\u2282\", \"&sub;\"}, // subset of, U+2282 ISOtech -->\n+        {\"\\u2283\", \"&sup;\"}, // superset of, U+2283 ISOtech -->\n+        // <!-- note that nsup, 'not a superset of, U+2283' is not covered by the\n+        // Symbol font encoding and is not included. Should it be, for symmetry?\n+        // It is in ISOamsn --> <!ENTITY nsub\", \"8836\"},\n+        // not a subset of, U+2284 ISOamsn -->\n+        {\"\\u2286\", \"&sube;\"}, // subset of or equal to, U+2286 ISOtech -->\n+        {\"\\u2287\", \"&supe;\"}, // superset of or equal to,U+2287 ISOtech -->\n+        {\"\\u2295\", \"&oplus;\"}, // circled plus = direct sum,U+2295 ISOamsb -->\n+        {\"\\u2297\", \"&otimes;\"}, // circled times = vector product,U+2297 ISOamsb -->\n+        {\"\\u22A5\", \"&perp;\"}, // up tack = orthogonal to = perpendicular,U+22A5 ISOtech -->\n+        {\"\\u22C5\", \"&sdot;\"}, // dot operator, U+22C5 ISOamsb -->\n+        // <!-- dot operator is NOT the same character as U+00B7 middle dot -->\n+        // <!-- Miscellaneous Technical -->\n+        {\"\\u2308\", \"&lceil;\"}, // left ceiling = apl upstile,U+2308 ISOamsc -->\n+        {\"\\u2309\", \"&rceil;\"}, // right ceiling, U+2309 ISOamsc -->\n+        {\"\\u230A\", \"&lfloor;\"}, // left floor = apl downstile,U+230A ISOamsc -->\n+        {\"\\u230B\", \"&rfloor;\"}, // right floor, U+230B ISOamsc -->\n+        {\"\\u2329\", \"&lang;\"}, // left-pointing angle bracket = bra,U+2329 ISOtech -->\n+        // <!-- lang is NOT the same character as U+003C 'less than' or U+2039 'single left-pointing angle quotation\n+        // mark' -->\n+        {\"\\u232A\", \"&rang;\"}, // right-pointing angle bracket = ket,U+232A ISOtech -->\n+        // <!-- rang is NOT the same character as U+003E 'greater than' or U+203A\n+        // 'single right-pointing angle quotation mark' -->\n+        // <!-- Geometric Shapes -->\n+        {\"\\u25CA\", \"&loz;\"}, // lozenge, U+25CA ISOpub -->\n+        // <!-- Miscellaneous Symbols -->\n+        {\"\\u2660\", \"&spades;\"}, // black spade suit, U+2660 ISOpub -->\n+        // <!-- black here seems to mean filled as opposed to hollow -->\n+        {\"\\u2663\", \"&clubs;\"}, // black club suit = shamrock,U+2663 ISOpub -->\n+        {\"\\u2665\", \"&hearts;\"}, // black heart suit = valentine,U+2665 ISOpub -->\n+        {\"\\u2666\", \"&diams;\"}, // black diamond suit, U+2666 ISOpub -->\n+\n+        // <!-- Latin Extended-A -->\n+        {\"\\u0152\", \"&OElig;\"}, // -- latin capital ligature OE,U+0152 ISOlat2 -->\n+        {\"\\u0153\", \"&oelig;\"}, // -- latin small ligature oe, U+0153 ISOlat2 -->\n+        // <!-- ligature is a misnomer, this is a separate character in some languages -->\n+        {\"\\u0160\", \"&Scaron;\"}, // -- latin capital letter S with caron,U+0160 ISOlat2 -->\n+        {\"\\u0161\", \"&scaron;\"}, // -- latin small letter s with caron,U+0161 ISOlat2 -->\n+        {\"\\u0178\", \"&Yuml;\"}, // -- latin capital letter Y with diaeresis,U+0178 ISOlat2 -->\n+        // <!-- Spacing Modifier Letters -->\n+        {\"\\u02C6\", \"&circ;\"}, // -- modifier letter circumflex accent,U+02C6 ISOpub -->\n+        {\"\\u02DC\", \"&tilde;\"}, // small tilde, U+02DC ISOdia -->\n+        // <!-- General Punctuation -->\n+        {\"\\u2002\", \"&ensp;\"}, // en space, U+2002 ISOpub -->\n+        {\"\\u2003\", \"&emsp;\"}, // em space, U+2003 ISOpub -->\n+        {\"\\u2009\", \"&thinsp;\"}, // thin space, U+2009 ISOpub -->\n+        {\"\\u200C\", \"&zwnj;\"}, // zero width non-joiner,U+200C NEW RFC 2070 -->\n+        {\"\\u200D\", \"&zwj;\"}, // zero width joiner, U+200D NEW RFC 2070 -->\n+        {\"\\u200E\", \"&lrm;\"}, // left-to-right mark, U+200E NEW RFC 2070 -->\n+        {\"\\u200F\", \"&rlm;\"}, // right-to-left mark, U+200F NEW RFC 2070 -->\n+        {\"\\u2013\", \"&ndash;\"}, // en dash, U+2013 ISOpub -->\n+        {\"\\u2014\", \"&mdash;\"}, // em dash, U+2014 ISOpub -->\n+        {\"\\u2018\", \"&lsquo;\"}, // left single quotation mark,U+2018 ISOnum -->\n+        {\"\\u2019\", \"&rsquo;\"}, // right single quotation mark,U+2019 ISOnum -->\n+        {\"\\u201A\", \"&sbquo;\"}, // single low-9 quotation mark, U+201A NEW -->\n+        {\"\\u201C\", \"&ldquo;\"}, // left double quotation mark,U+201C ISOnum -->\n+        {\"\\u201D\", \"&rdquo;\"}, // right double quotation mark,U+201D ISOnum -->\n+        {\"\\u201E\", \"&bdquo;\"}, // double low-9 quotation mark, U+201E NEW -->\n+        {\"\\u2020\", \"&dagger;\"}, // dagger, U+2020 ISOpub -->\n+        {\"\\u2021\", \"&Dagger;\"}, // double dagger, U+2021 ISOpub -->\n+        {\"\\u2030\", \"&permil;\"}, // per mille sign, U+2030 ISOtech -->\n+        {\"\\u2039\", \"&lsaquo;\"}, // single left-pointing angle quotation mark,U+2039 ISO proposed -->\n+        // <!-- lsaquo is proposed but not yet ISO standardized -->\n+        {\"\\u203A\", \"&rsaquo;\"}, // single right-pointing angle quotation mark,U+203A ISO proposed -->\n+        // <!-- rsaquo is proposed but not yet ISO standardized -->\n+        {\"\\u20AC\", \"&euro;\"}, // -- euro sign, U+20AC NEW -->\n+    };\n+\n+    public static String[][] HTML40_EXTENDED_UNESCAPE() { return HTML40_EXTENDED_UNESCAPE.clone(); }\n+    private static final String[][] HTML40_EXTENDED_UNESCAPE = invert(HTML40_EXTENDED_ESCAPE);\n+\n+    public static String[][] BASIC_ESCAPE() { return BASIC_ESCAPE.clone(); }\n+    private static final String[][] BASIC_ESCAPE = {\n+        {\"\\\"\", \"&quot;\"}, // \" - double-quote\n+        {\"&\", \"&amp;\"},   // & - ampersand\n+        {\"<\", \"&lt;\"},    // < - less-than\n+        {\">\", \"&gt;\"},    // > - greater-than\n+    };\n+\n+    public static String[][] BASIC_UNESCAPE() { return BASIC_UNESCAPE.clone(); }\n+    private static final String[][] BASIC_UNESCAPE = invert(BASIC_ESCAPE);\n+\n+    public static String[][] APOS_ESCAPE() { return APOS_ESCAPE.clone(); }\n+    private static final String[][] APOS_ESCAPE = {\n+        {\"'\", \"&apos;\"}, // XML apostrophe\n+    };\n+\n+    public static String[][] APOS_UNESCAPE() { return APOS_UNESCAPE.clone(); }\n+    private static final String[][] APOS_UNESCAPE = invert(APOS_ESCAPE);\n+\n+    public static String[][] JAVA_CTRL_CHARS_ESCAPE() { return JAVA_CTRL_CHARS_ESCAPE.clone(); }\n+    private static final String[][] JAVA_CTRL_CHARS_ESCAPE = {\n+        {\"\\b\", \"\\\\b\"},\n+        {\"\\n\", \"\\\\n\"},\n+        {\"\\t\", \"\\\\t\"},\n+        {\"\\f\", \"\\\\f\"},\n+        {\"\\r\", \"\\\\r\"}\n+    };\n+\n+    public static String[][] JAVA_CTRL_CHARS_UNESCAPE() { return JAVA_CTRL_CHARS_UNESCAPE.clone(); }\n+    private static final String[][] JAVA_CTRL_CHARS_UNESCAPE = invert(JAVA_CTRL_CHARS_ESCAPE);\n+\n+    /**\n+     * Used to invert an escape array into an unescape array\n+     * @param array String[][] to be inverted\n+     * @return String[][] inverted array\n+     */\n+    public static String[][] invert(String[][] array) {\n+        String[][] newarray = new String[array.length][2];\n+        for(int i = 0; i<array.length; i++) {\n+            newarray[i][0] = array[i][1];\n+            newarray[i][1] = array[i][0];\n+        }\n+        return newarray;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/LookupTranslator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.text.translate;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.util.HashMap;\n+\n+/**\n+ * Translates a value using a lookup table.\n+ * \n+ * @author Apache Software Foundation\n+ * @since 3.0\n+ */\n+// TODO: Replace with a RegexLookup? Performance test.\n+public class LookupTranslator extends CharSequenceTranslator {\n+\n+    private final HashMap<CharSequence, CharSequence> lookupMap;\n+    private final int shortest;\n+    private final int longest;\n+\n+    /**\n+     * Define the lookup table to be used in translation\n+     *\n+     * @param lookup CharSequence[][] table of size [*][2]\n+     */\n+    public LookupTranslator(CharSequence[][] lookup) {\n+        lookupMap = new HashMap<CharSequence, CharSequence>();\n+        int _shortest = Integer.MAX_VALUE;\n+        int _longest = 0;\n+        for(CharSequence[] seq : lookup) {\n+            this.lookupMap.put(seq[0], seq[1]);\n+            int sz = seq[0].length();\n+            if(sz < _shortest) {\n+                _shortest = sz;\n+            }\n+            if(sz > _longest) {\n+                _longest = sz;\n+            }\n+        }\n+        shortest = _shortest;\n+        longest = _longest;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public int translate(CharSequence input, int index, Writer out) throws IOException {\n+        int max = longest;\n+        if(index + longest > input.length()) {\n+            max = input.length() - index;\n+        }\n+        // descend so as to get a greedy algorithm\n+        for(int i=max; i >= shortest; i--) {\n+            CharSequence subSeq = input.subSequence(index, index + i);\n+            CharSequence result = lookupMap.get(subSeq);\n+            if(result != null) {\n+                out.write(result.toString());\n+                return i;\n+            }\n+        }\n+        return 0;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityEscaper.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.text.translate;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+/**\n+ * Translates codepoints to their XML numeric entity escaped value.\n+ * \n+ * @author Apache Software Foundation\n+ * @since 3.0\n+ */\n+public class NumericEntityEscaper extends CodePointTranslator {\n+\n+    private final int below;\n+    private final int above;\n+    private final boolean between;\n+\n+    private NumericEntityEscaper(int below, int above, boolean between) {\n+        this.below = below;\n+        this.above = above;\n+        this.between = between;\n+    }\n+\n+    public NumericEntityEscaper() { \n+        this(0, Integer.MAX_VALUE, true);\n+    }\n+\n+    public static NumericEntityEscaper below(int codepoint) {\n+        return outsideOf(codepoint, Integer.MAX_VALUE);\n+    }\n+\n+    public static NumericEntityEscaper above(int codepoint) {\n+        return outsideOf(0, codepoint);\n+    }\n+\n+    public static NumericEntityEscaper between(int codepointLow, int codepointHigh) {\n+        return new NumericEntityEscaper(codepointLow, codepointHigh, true);\n+    }\n+\n+    public static NumericEntityEscaper outsideOf(int codepointLow, int codepointHigh) {\n+        return new NumericEntityEscaper(codepointLow, codepointHigh, false);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean translate(int codepoint, Writer out) throws IOException {\n+        if(between) {\n+            if (codepoint < below || codepoint > above) {\n+                return false;\n+            }\n+        } else {\n+            if (codepoint >= below && codepoint <= above) {\n+                return false;\n+            }\n+        }\n+\n+        // TODO: if (codepoint > 0xffff) ?\n+        out.write(\"&#\");\n+        out.write(Integer.toString(codepoint, 10));\n+        out.write(';');\n+        return true;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.text.translate;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+/**\n+ * Translate XML numeric entities of the form &#[xX]?\\d+; to \n+ * the specific codepoint.\n+ * \n+ * @author Apache Software Foundation\n+ * @since 3.0\n+ */\n+public class NumericEntityUnescaper extends CharSequenceTranslator {\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public int translate(CharSequence input, int index, Writer out) throws IOException {\n+        // TODO: Protect from ArrayIndexOutOfBounds\n+        if(input.charAt(index) == '&' && input.charAt(index + 1) == '#') {\n+            int start = index + 2;\n+            boolean isHex = false;\n+\n+            char firstChar = input.charAt(start);\n+            if(firstChar == 'x' || firstChar == 'X') {\n+                start++;\n+                isHex = true;\n+            }\n+\n+            int end = start;\n+            while(input.charAt(end) != ';') {\n+                end++;\n+            }\n+\n+            int entityValue;\n+            try {\n+                if(isHex) {\n+                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n+                } else {\n+                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n+                }\n+            } catch(NumberFormatException nfe) {\n+                return 0;\n+            }\n+\n+            // TODO: if(entityValue > 0xFFFF) {\n+            out.write(entityValue);\n+            return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n+        }\n+        return 0;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/UnicodeEscaper.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.text.translate;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+/**\n+ * Translates codepoints to their unicode escaped value.\n+ * \n+ * @author Apache Software Foundation\n+ * @since 3.0\n+ */\n+public class UnicodeEscaper extends CodePointTranslator {\n+\n+    private final int below;\n+    private final int above;\n+    private final boolean between;\n+\n+    public UnicodeEscaper(){\n+        this(0, Integer.MAX_VALUE, true);\n+    }\n+\n+    private UnicodeEscaper(int below, int above, boolean between) {\n+        this.below = below;\n+        this.above = above;\n+        this.between = between;\n+    }\n+\n+    public static UnicodeEscaper below(int codepoint) {\n+        return outsideOf(codepoint, Integer.MAX_VALUE);\n+    }\n+\n+    public static UnicodeEscaper above(int codepoint) {\n+        return outsideOf(0, codepoint);\n+    }\n+\n+    public static UnicodeEscaper outsideOf(int codepointLow, int codepointHigh) {\n+        UnicodeEscaper escaper = new UnicodeEscaper(codepointLow, codepointHigh, false);\n+        return escaper;\n+    }\n+\n+    public static UnicodeEscaper between(int codepointLow, int codepointHigh) {\n+        UnicodeEscaper escaper = new UnicodeEscaper(codepointLow, codepointHigh, true);\n+        return escaper;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean translate(int codepoint, Writer out) throws IOException {\n+        if(between) {\n+            if (codepoint < below || codepoint > above) {\n+                return false;\n+            }\n+        } else {\n+            if (codepoint >= below && codepoint <= above) {\n+                return false;\n+            }\n+        }\n+\n+        // TODO: Handle potential + sign per various unicode escape implementations\n+        if (codepoint > 0xffff) {\n+            // TODO: Figure out what to do. Output as two unicodes?\n+            //       Does this make this a Java-specific output class?\n+            out.write(\"\\\\u\" + hex(codepoint));\n+        } else if (codepoint > 0xfff) {\n+            out.write(\"\\\\u\" + hex(codepoint));\n+        } else if (codepoint > 0xff) {\n+            out.write(\"\\\\u0\" + hex(codepoint));\n+        } else if (codepoint > 0xf) {\n+            out.write(\"\\\\u00\" + hex(codepoint));\n+        } else {\n+            out.write(\"\\\\u000\" + hex(codepoint));\n+        }\n+        return true;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/UnicodeUnescaper.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.text.translate;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+import java.util.EnumSet;\n+import java.util.Arrays;\n+\n+/**\n+ * Translates escaped unicode values of the form \\\\u+\\d\\d\\d\\d back to \n+ * unicode.\n+ * \n+ * @author Apache Software Foundation\n+ * @since 3.0\n+ */\n+public class UnicodeUnescaper extends CharSequenceTranslator {\n+\n+    public static enum OPTION { escapePlus }\n+\n+    // TODO: Create an OptionsSet class to hide some of the conditional logic below\n+    private final EnumSet<OPTION> options;\n+\n+    public UnicodeUnescaper(OPTION... options) {\n+        if(options.length > 0) {\n+            this.options = EnumSet.copyOf(Arrays.asList(options));\n+        } else {\n+            this.options = null;\n+        }\n+    }\n+\n+    public boolean isSet(OPTION opt) { \n+        return (options == null) ? false : options.contains(opt);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public int translate(CharSequence input, int index, Writer out) throws IOException {\n+        if(input.charAt(index) == '\\\\') {\n+            if( (index + 1 < input.length()) && input.charAt(index + 1) == 'u') {\n+                // consume optional additional 'u' chars\n+                int i=2;\n+                while( (index + i < input.length()) && input.charAt(index + i) == 'u') {\n+                    i++;\n+                }\n+\n+                // consume + symbol in \\\\u+0045\n+                if(isSet(OPTION.escapePlus)) {\n+                    if( (index + i < input.length()) && (input.charAt(index + i) == '+') ) {\n+                        i++;\n+                    }\n+                }\n+\n+                if( (index + i + 4 <= input.length()) ) {\n+                    // Get 4 hex digits\n+                    CharSequence unicode = input.subSequence(index + i, index + i + 4);\n+\n+                    try {\n+                        int value = Integer.parseInt(unicode.toString(), 16);\n+                        out.write((char) value);\n+                    } catch (NumberFormatException nfe) {\n+                        throw new IllegalArgumentException(\"Unable to parse unicode value: \" + unicode, nfe);\n+                    }\n+                    return i + 4;\n+                } else {\n+                    throw new IllegalArgumentException(\"Less than 4 hex digits in unicode value: '\" + \n+                                                       input.subSequence(index, input.length()) +\n+                                                       \"' due to end of CharSequence\");\n+                }\n+            }\n+        }\n+        return 0;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/time/DateFormatUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.time;\n+\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+/**\n+ * <p>Date and time formatting utilities and constants.</p>\n+ *\n+ * <p>Formatting is performed using the\n+ * {@link org.apache.commons.lang3.time.FastDateFormat} class.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author Apache Ant - DateUtils\n+ * @author <a href=\"mailto:sbailliez@apache.org\">Stephane Bailliez</a>\n+ * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class DateFormatUtils {\n+\n+    /**\n+     * ISO8601 formatter for date-time without time zone.\n+     * The format used is <tt>yyyy-MM-dd'T'HH:mm:ss</tt>.\n+     */\n+    public static final FastDateFormat ISO_DATETIME_FORMAT\n+            = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss\");\n+\n+    /**\n+     * ISO8601 formatter for date-time with time zone.\n+     * The format used is <tt>yyyy-MM-dd'T'HH:mm:ssZZ</tt>.\n+     */\n+    public static final FastDateFormat ISO_DATETIME_TIME_ZONE_FORMAT\n+            = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ssZZ\");\n+\n+    /**\n+     * ISO8601 formatter for date without time zone.\n+     * The format used is <tt>yyyy-MM-dd</tt>.\n+     */\n+    public static final FastDateFormat ISO_DATE_FORMAT\n+            = FastDateFormat.getInstance(\"yyyy-MM-dd\");\n+\n+    /**\n+     * ISO8601-like formatter for date with time zone.\n+     * The format used is <tt>yyyy-MM-ddZZ</tt>.\n+     * This pattern does not comply with the formal ISO8601 specification\n+     * as the standard does not allow a time zone  without a time.\n+     */\n+    public static final FastDateFormat ISO_DATE_TIME_ZONE_FORMAT\n+            = FastDateFormat.getInstance(\"yyyy-MM-ddZZ\");\n+\n+    /**\n+     * ISO8601 formatter for time without time zone.\n+     * The format used is <tt>'T'HH:mm:ss</tt>.\n+     */\n+    public static final FastDateFormat ISO_TIME_FORMAT\n+            = FastDateFormat.getInstance(\"'T'HH:mm:ss\");\n+\n+    /**\n+     * ISO8601 formatter for time with time zone.\n+     * The format used is <tt>'T'HH:mm:ssZZ</tt>.\n+     */\n+    public static final FastDateFormat ISO_TIME_TIME_ZONE_FORMAT\n+            = FastDateFormat.getInstance(\"'T'HH:mm:ssZZ\");\n+\n+    /**\n+     * ISO8601-like formatter for time without time zone.\n+     * The format used is <tt>HH:mm:ss</tt>.\n+     * This pattern does not comply with the formal ISO8601 specification\n+     * as the standard requires the 'T' prefix for times.\n+     */\n+    public static final FastDateFormat ISO_TIME_NO_T_FORMAT\n+            = FastDateFormat.getInstance(\"HH:mm:ss\");\n+\n+    /**\n+     * ISO8601-like formatter for time with time zone.\n+     * The format used is <tt>HH:mm:ssZZ</tt>.\n+     * This pattern does not comply with the formal ISO8601 specification\n+     * as the standard requires the 'T' prefix for times.\n+     */\n+    public static final FastDateFormat ISO_TIME_NO_T_TIME_ZONE_FORMAT\n+            = FastDateFormat.getInstance(\"HH:mm:ssZZ\");\n+\n+    /**\n+     * SMTP (and probably other) date headers.\n+     * The format used is <tt>EEE, dd MMM yyyy HH:mm:ss Z</tt> in US locale.\n+     */\n+    public static final FastDateFormat SMTP_DATETIME_FORMAT\n+            = FastDateFormat.getInstance(\"EEE, dd MMM yyyy HH:mm:ss Z\", Locale.US);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>DateFormatUtils instances should NOT be constructed in standard programming.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n+     */\n+    public DateFormatUtils() {\n+        super();\n+    }\n+\n+    /**\n+     * <p>Formats a date/time into a specific pattern using the UTC time zone.</p>\n+     * \n+     * @param millis  the date to format expressed in milliseconds\n+     * @param pattern  the pattern to use to format the date\n+     * @return the formatted date\n+     */\n+    public static String formatUTC(long millis, String pattern) {\n+        return format(new Date(millis), pattern, DateUtils.UTC_TIME_ZONE, null);\n+    }\n+\n+    /**\n+     * <p>Formats a date/time into a specific pattern using the UTC time zone.</p>\n+     * \n+     * @param date  the date to format\n+     * @param pattern  the pattern to use to format the date\n+     * @return the formatted date\n+     */\n+    public static String formatUTC(Date date, String pattern) {\n+        return format(date, pattern, DateUtils.UTC_TIME_ZONE, null);\n+    }\n+    \n+    /**\n+     * <p>Formats a date/time into a specific pattern using the UTC time zone.</p>\n+     * \n+     * @param millis  the date to format expressed in milliseconds\n+     * @param pattern  the pattern to use to format the date\n+     * @param locale  the locale to use, may be <code>null</code>\n+     * @return the formatted date\n+     */\n+    public static String formatUTC(long millis, String pattern, Locale locale) {\n+        return format(new Date(millis), pattern, DateUtils.UTC_TIME_ZONE, locale);\n+    }\n+\n+    /**\n+     * <p>Formats a date/time into a specific pattern using the UTC time zone.</p>\n+     * \n+     * @param date  the date to format\n+     * @param pattern  the pattern to use to format the date\n+     * @param locale  the locale to use, may be <code>null</code>\n+     * @return the formatted date\n+     */\n+    public static String formatUTC(Date date, String pattern, Locale locale) {\n+        return format(date, pattern, DateUtils.UTC_TIME_ZONE, locale);\n+    }\n+    \n+    /**\n+     * <p>Formats a date/time into a specific pattern.</p>\n+     * \n+     * @param millis  the date to format expressed in milliseconds\n+     * @param pattern  the pattern to use to format the date\n+     * @return the formatted date\n+     */\n+    public static String format(long millis, String pattern) {\n+        return format(new Date(millis), pattern, null, null);\n+    }\n+\n+    /**\n+     * <p>Formats a date/time into a specific pattern.</p>\n+     * \n+     * @param date  the date to format\n+     * @param pattern  the pattern to use to format the date\n+     * @return the formatted date\n+     */\n+    public static String format(Date date, String pattern) {\n+        return format(date, pattern, null, null);\n+    }\n+\n+    /**\n+     * <p>Formats a calendar into a specific pattern.</p>\n+     * \n+     * @param calendar  the calendar to format\n+     * @param pattern  the pattern to use to format the calendar\n+     * @return the formatted calendar\n+     * @see FastDateFormat#format(Calendar)\n+     * @since 2.4\n+     */\n+    public static String format(Calendar calendar, String pattern) {\n+        return format(calendar, pattern, null, null);\n+    }\n+    \n+    /**\n+     * <p>Formats a date/time into a specific pattern in a time zone.</p>\n+     * \n+     * @param millis  the time expressed in milliseconds\n+     * @param pattern  the pattern to use to format the date\n+     * @param timeZone  the time zone  to use, may be <code>null</code>\n+     * @return the formatted date\n+     */\n+    public static String format(long millis, String pattern, TimeZone timeZone) {\n+        return format(new Date(millis), pattern, timeZone, null);\n+    }\n+\n+    /**\n+     * <p>Formats a date/time into a specific pattern in a time zone.</p>\n+     * \n+     * @param date  the date to format\n+     * @param pattern  the pattern to use to format the date\n+     * @param timeZone  the time zone  to use, may be <code>null</code>\n+     * @return the formatted date\n+     */\n+    public static String format(Date date, String pattern, TimeZone timeZone) {\n+        return format(date, pattern, timeZone, null);\n+    }\n+\n+    /**\n+     * <p>Formats a calendar into a specific pattern in a time zone.</p>\n+     * \n+     * @param calendar  the calendar to format\n+     * @param pattern  the pattern to use to format the calendar\n+     * @param timeZone  the time zone  to use, may be <code>null</code>\n+     * @return the formatted calendar\n+     * @see FastDateFormat#format(Calendar)\n+     * @since 2.4\n+     */\n+    public static String format(Calendar calendar, String pattern, TimeZone timeZone) {\n+        return format(calendar, pattern, timeZone, null);\n+    }\n+\n+    /**\n+     * <p>Formats a date/time into a specific pattern in a locale.</p>\n+     * \n+     * @param millis  the date to format expressed in milliseconds\n+     * @param pattern  the pattern to use to format the date\n+     * @param locale  the locale to use, may be <code>null</code>\n+     * @return the formatted date\n+     */\n+    public static String format(long millis, String pattern, Locale locale) {\n+        return format(new Date(millis), pattern, null, locale);\n+    }\n+\n+    /**\n+     * <p>Formats a date/time into a specific pattern in a locale.</p>\n+     * \n+     * @param date  the date to format\n+     * @param pattern  the pattern to use to format the date\n+     * @param locale  the locale to use, may be <code>null</code>\n+     * @return the formatted date\n+     */\n+    public static String format(Date date, String pattern, Locale locale) {\n+        return format(date, pattern, null, locale);\n+    }\n+\n+    /**\n+     * <p>Formats a calendar into a specific pattern in a locale.</p>\n+     * \n+     * @param calendar  the calendar to format\n+     * @param pattern  the pattern to use to format the calendar\n+     * @param locale  the locale to use, may be <code>null</code>\n+     * @return the formatted calendar\n+     * @see FastDateFormat#format(Calendar)\n+     * @since 2.4\n+     */\n+    public static String format(Calendar calendar, String pattern, Locale locale) {\n+        return format(calendar, pattern, null, locale);\n+    }\n+\n+    /**\n+     * <p>Formats a date/time into a specific pattern in a time zone  and locale.</p>\n+     * \n+     * @param millis  the date to format expressed in milliseconds\n+     * @param pattern  the pattern to use to format the date\n+     * @param timeZone  the time zone  to use, may be <code>null</code>\n+     * @param locale  the locale to use, may be <code>null</code>\n+     * @return the formatted date\n+     */\n+    public static String format(long millis, String pattern, TimeZone timeZone, Locale locale) {\n+        return format(new Date(millis), pattern, timeZone, locale);\n+    }\n+\n+    /**\n+     * <p>Formats a date/time into a specific pattern in a time zone  and locale.</p>\n+     * \n+     * @param date  the date to format\n+     * @param pattern  the pattern to use to format the date\n+     * @param timeZone  the time zone  to use, may be <code>null</code>\n+     * @param locale  the locale to use, may be <code>null</code>\n+     * @return the formatted date\n+     */\n+    public static String format(Date date, String pattern, TimeZone timeZone, Locale locale) {\n+        FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);\n+        return df.format(date);\n+    }\n+\n+    /**\n+     * <p>Formats a calendar into a specific pattern in a time zone  and locale.</p>\n+     * \n+     * @param calendar  the calendar to format\n+     * @param pattern  the pattern to use to format the calendar\n+     * @param timeZone  the time zone  to use, may be <code>null</code>\n+     * @param locale  the locale to use, may be <code>null</code>\n+     * @return the formatted calendar\n+     * @see FastDateFormat#format(Calendar)\n+     * @since 2.4\n+     */\n+    public static String format(Calendar calendar, String pattern, TimeZone timeZone, Locale locale) {\n+        FastDateFormat df = FastDateFormat.getInstance(pattern, timeZone, locale);\n+        return df.format(calendar);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/time/DateUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.time;\n+\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.TimeZone;\n+\n+/**\n+ * <p>A suite of utilities surrounding the use of the\n+ * {@link java.util.Calendar} and {@link java.util.Date} object.</p>\n+ * \n+ * <p>DateUtils contains a lot of common methods considering manipulations\n+ * of Dates or Calendars. Some methods require some extra explanation.\n+ * The truncate, ceiling and round methods could be considered the Math.floor(),\n+ * Math.ceil() or Math.round versions for dates\n+ * This way date-fields will be ignored in bottom-up order.\n+ * As a complement to these methods we've introduced some fragment-methods.\n+ * With these methods the Date-fields will be ignored in top-down order.\n+ * Since a date without a year is not a valid date, you have to decide in what\n+ * kind of date-field you want your result, for instance milliseconds or days.\n+ * </p>\n+ *   \n+ *   \n+ *\n+ * @author Apache Software Foundation\n+ * @author <a href=\"mailto:sergek@lokitech.com\">Serge Knystautas</a>\n+ * @author Janek Bogucki\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @author Phil Steitz\n+ * @author Robert Scholte\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class DateUtils {\n+    \n+    /**\n+     * The UTC time zone  (often referred to as GMT).\n+     */\n+    public static final TimeZone UTC_TIME_ZONE = TimeZone.getTimeZone(\"GMT\");\n+    /**\n+     * Number of milliseconds in a standard second.\n+     * @since 2.1\n+     */\n+    public static final long MILLIS_PER_SECOND = 1000;\n+    /**\n+     * Number of milliseconds in a standard minute.\n+     * @since 2.1\n+     */\n+    public static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND;\n+    /**\n+     * Number of milliseconds in a standard hour.\n+     * @since 2.1\n+     */\n+    public static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE;\n+    /**\n+     * Number of milliseconds in a standard day.\n+     * @since 2.1\n+     */\n+    public static final long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR;\n+\n+    /**\n+     * This is half a month, so this represents whether a date is in the top\n+     * or bottom half of the month.\n+     */\n+    public final static int SEMI_MONTH = 1001;\n+\n+    private static final int[][] fields = {\n+            {Calendar.MILLISECOND},\n+            {Calendar.SECOND},\n+            {Calendar.MINUTE},\n+            {Calendar.HOUR_OF_DAY, Calendar.HOUR},\n+            {Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM \n+                /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */\n+            },\n+            {Calendar.MONTH, DateUtils.SEMI_MONTH},\n+            {Calendar.YEAR},\n+            {Calendar.ERA}};\n+\n+    /**\n+     * A week range, starting on Sunday.\n+     */\n+    public final static int RANGE_WEEK_SUNDAY = 1;\n+\n+    /**\n+     * A week range, starting on Monday.\n+     */\n+    public final static int RANGE_WEEK_MONDAY = 2;\n+\n+    /**\n+     * A week range, starting on the day focused.\n+     */\n+    public final static int RANGE_WEEK_RELATIVE = 3;\n+\n+    /**\n+     * A week range, centered around the day focused.\n+     */\n+    public final static int RANGE_WEEK_CENTER = 4;\n+\n+    /**\n+     * A month range, the week starting on Sunday.\n+     */\n+    public final static int RANGE_MONTH_SUNDAY = 5;\n+\n+    /**\n+     * A month range, the week starting on Monday.\n+     */\n+    public final static int RANGE_MONTH_MONDAY = 6;\n+    \n+    /**\n+     * Constant marker for truncating \n+     * @since 3.0\n+     */\n+    public final static int MODIFY_TRUNCATE = 0;\n+\n+    /**\n+     * Constant marker for rounding\n+     * @since 3.0\n+     */\n+    public final static int MODIFY_ROUND = 1;\n+    \n+    /**\n+     * Constant marker for ceiling\n+     * @since 3.0\n+     */\n+    public final static int MODIFY_CEILING= 2;\n+    \n+\n+    /**\n+     * <p><code>DateUtils</code> instances should NOT be constructed in\n+     * standard programming. Instead, the class should be used as\n+     * <code>DateUtils.parse(str);</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean\n+     * instance to operate.</p>\n+     */\n+    public DateUtils() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if two date objects are on the same day ignoring time.</p>\n+     *\n+     * <p>28 Mar 2002 13:45 and 28 Mar 2002 06:01 would return true.\n+     * 28 Mar 2002 13:45 and 12 Mar 2002 13:45 would return false.\n+     * </p>\n+     * \n+     * @param date1  the first date, not altered, not null\n+     * @param date2  the second date, not altered, not null\n+     * @return true if they represent the same day\n+     * @throws IllegalArgumentException if either date is <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isSameDay(Date date1, Date date2) {\n+        if (date1 == null || date2 == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        Calendar cal1 = Calendar.getInstance();\n+        cal1.setTime(date1);\n+        Calendar cal2 = Calendar.getInstance();\n+        cal2.setTime(date2);\n+        return isSameDay(cal1, cal2);\n+    }\n+\n+    /**\n+     * <p>Checks if two calendar objects are on the same day ignoring time.</p>\n+     *\n+     * <p>28 Mar 2002 13:45 and 28 Mar 2002 06:01 would return true.\n+     * 28 Mar 2002 13:45 and 12 Mar 2002 13:45 would return false.\n+     * </p>\n+     * \n+     * @param cal1  the first calendar, not altered, not null\n+     * @param cal2  the second calendar, not altered, not null\n+     * @return true if they represent the same day\n+     * @throws IllegalArgumentException if either calendar is <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isSameDay(Calendar cal1, Calendar cal2) {\n+        if (cal1 == null || cal2 == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        return (cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n+                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n+                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if two date objects represent the same instant in time.</p>\n+     *\n+     * <p>This method compares the long millisecond time of the two objects.</p>\n+     * \n+     * @param date1  the first date, not altered, not null\n+     * @param date2  the second date, not altered, not null\n+     * @return true if they represent the same millisecond instant\n+     * @throws IllegalArgumentException if either date is <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isSameInstant(Date date1, Date date2) {\n+        if (date1 == null || date2 == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        return date1.getTime() == date2.getTime();\n+    }\n+\n+    /**\n+     * <p>Checks if two calendar objects represent the same instant in time.</p>\n+     *\n+     * <p>This method compares the long millisecond time of the two objects.</p>\n+     * \n+     * @param cal1  the first calendar, not altered, not null\n+     * @param cal2  the second calendar, not altered, not null\n+     * @return true if they represent the same millisecond instant\n+     * @throws IllegalArgumentException if either date is <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isSameInstant(Calendar cal1, Calendar cal2) {\n+        if (cal1 == null || cal2 == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        return cal1.getTime().getTime() == cal2.getTime().getTime();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Checks if two calendar objects represent the same local time.</p>\n+     *\n+     * <p>This method compares the values of the fields of the two objects.\n+     * In addition, both calendars must be the same of the same type.</p>\n+     * \n+     * @param cal1  the first calendar, not altered, not null\n+     * @param cal2  the second calendar, not altered, not null\n+     * @return true if they represent the same millisecond instant\n+     * @throws IllegalArgumentException if either date is <code>null</code>\n+     * @since 2.1\n+     */\n+    public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n+        if (cal1 == null || cal2 == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n+                cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n+                cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n+                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n+                cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n+                cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n+                cal1.getClass() == cal2.getClass());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Parses a string representing a date by trying a variety of different parsers.</p>\n+     * \n+     * <p>The parse will try each parse pattern in turn.\n+     * A parse is only deemed successful if it parses the whole of the input string.\n+     * If no parse patterns match, a ParseException is thrown.</p>\n+     * The parser will be lenient toward the parsed date.\n+     * \n+     * @param str  the date to parse, not null\n+     * @param parsePatterns  the date format patterns to use, see SimpleDateFormat, not null\n+     * @return the parsed date\n+     * @throws IllegalArgumentException if the date string or pattern array is null\n+     * @throws ParseException if none of the date patterns were suitable (or there were none)\n+     */\n+    public static Date parseDate(String str, String[] parsePatterns) throws ParseException {\n+        return parseDateWithLeniency(str, parsePatterns, true);\n+    }\n+    \n+  //-----------------------------------------------------------------------\n+    /**\n+     * <p>Parses a string representing a date by trying a variety of different parsers.</p>\n+     * \n+     * <p>The parse will try each parse pattern in turn.\n+     * A parse is only deemed successful if it parses the whole of the input string.\n+     * If no parse patterns match, a ParseException is thrown.</p>\n+     * The parser parses strictly - it does not allow for dates such as \"February 942, 1996\". \n+     * \n+     * @param str  the date to parse, not null\n+     * @param parsePatterns  the date format patterns to use, see SimpleDateFormat, not null\n+     * @param lenient Specify whether or not date/time parsing is to be lenient.\n+     * @return the parsed date\n+     * @throws IllegalArgumentException if the date string or pattern array is null\n+     * @throws ParseException if none of the date patterns were suitable\n+     * @see java.util.Calender#isLenient()\n+     */\n+    public static Date parseDateStrictly(String str, String[] parsePatterns) throws ParseException {\n+        return parseDateWithLeniency(str, parsePatterns, false);\n+    }\n+    private static Date parseDateWithLeniency(String str, String[] parsePatterns,\n+\t\t\tboolean lenient) throws ParseException {\n+        if (str == null || parsePatterns == null) {\n+            throw new IllegalArgumentException(\"Date and Patterns must not be null\");\n+        }\n+        \n+        SimpleDateFormat parser = null;\n+        ParsePosition pos = new ParsePosition(0);\n+        for (int i = 0; i < parsePatterns.length; i++) {\n+\n+            String pattern = parsePatterns[i];\n+\n+            // LANG-530 - need to make sure 'ZZ' output doesn't get passed to SimpleDateFormat\n+            if (parsePatterns[i].endsWith(\"ZZ\")) {\n+                pattern = pattern.substring(0, pattern.length() - 1);\n+            }\n+            \n+            if (i == 0) {\n+                parser = new SimpleDateFormat(pattern);\n+                parser.setLenient(lenient);\n+            } else {\n+                parser.applyPattern(pattern); // cannot be null if i != 0\n+            }\n+            pos.setIndex(0);\n+\n+            String str2 = str;\n+            // LANG-530 - need to make sure 'ZZ' output doesn't hit SimpleDateFormat as it will ParseException\n+            if (parsePatterns[i].endsWith(\"ZZ\")) {\n+                str2 = str.replaceAll(\"([-+][0-9][0-9]):([0-9][0-9])$\", \"$1$2\"); \n+            }\n+\n+            Date date = parser.parse(str2, pos);\n+            if (date != null && pos.getIndex() == str2.length()) {\n+                return date;\n+            }\n+        }\n+        throw new ParseException(\"Unable to parse the date: \" + str, -1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a number of years to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount  the amount to add, may be negative\n+     * @return the new date object with the amount added\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public static Date addYears(Date date, int amount) {\n+        return add(date, Calendar.YEAR, amount);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a number of months to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount  the amount to add, may be negative\n+     * @return the new date object with the amount added\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public static Date addMonths(Date date, int amount) {\n+        return add(date, Calendar.MONTH, amount);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a number of weeks to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount  the amount to add, may be negative\n+     * @return the new date object with the amount added\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public static Date addWeeks(Date date, int amount) {\n+        return add(date, Calendar.WEEK_OF_YEAR, amount);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a number of days to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount  the amount to add, may be negative\n+     * @return the new date object with the amount added\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public static Date addDays(Date date, int amount) {\n+        return add(date, Calendar.DAY_OF_MONTH, amount);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a number of hours to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount  the amount to add, may be negative\n+     * @return the new date object with the amount added\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public static Date addHours(Date date, int amount) {\n+        return add(date, Calendar.HOUR_OF_DAY, amount);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a number of minutes to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount  the amount to add, may be negative\n+     * @return the new date object with the amount added\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public static Date addMinutes(Date date, int amount) {\n+        return add(date, Calendar.MINUTE, amount);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a number of seconds to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount  the amount to add, may be negative\n+     * @return the new date object with the amount added\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public static Date addSeconds(Date date, int amount) {\n+        return add(date, Calendar.SECOND, amount);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a number of milliseconds to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount  the amount to add, may be negative\n+     * @return the new date object with the amount added\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public static Date addMilliseconds(Date date, int amount) {\n+        return add(date, Calendar.MILLISECOND, amount);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param calendarField  the calendar field to add to\n+     * @param amount  the amount to add, may be negative\n+     * @return the new date object with the amount added\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    private static Date add(Date date, int calendarField, int amount) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        Calendar c = Calendar.getInstance();\n+        c.setTime(date);\n+        c.add(calendarField, amount);\n+        return c.getTime();\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the years field to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount the amount to set\n+     * @return a new Date object set with the specified value\n+     * @throws IllegalArgumentException if the date is null\n+     * @since 2.4\n+     */\n+    public static Date setYears(Date date, int amount) {\n+        return set(date, Calendar.YEAR, amount);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the months field to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount the amount to set\n+     * @return a new Date object set with the specified value\n+     * @throws IllegalArgumentException if the date is null\n+     * @since 2.4\n+     */\n+    public static Date setMonths(Date date, int amount) {\n+        return set(date, Calendar.MONTH, amount);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the day of month field to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount the amount to set\n+     * @return a new Date object set with the specified value\n+     * @throws IllegalArgumentException if the date is null\n+     * @since 2.4\n+     */\n+    public static Date setDays(Date date, int amount) {\n+        return set(date, Calendar.DAY_OF_MONTH, amount);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the hours field to a date returning a new object.  Hours range \n+     * from  0-23.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount the amount to set\n+     * @return a new Date object set with the specified value\n+     * @throws IllegalArgumentException if the date is null\n+     * @since 2.4\n+     */\n+    public static Date setHours(Date date, int amount) {\n+        return set(date, Calendar.HOUR_OF_DAY, amount);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the minute field to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount the amount to set\n+     * @return a new Date object set with the specified value\n+     * @throws IllegalArgumentException if the date is null\n+     * @since 2.4\n+     */\n+    public static Date setMinutes(Date date, int amount) {\n+        return set(date, Calendar.MINUTE, amount);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the seconds field to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount the amount to set\n+     * @return a new Date object set with the specified value\n+     * @throws IllegalArgumentException if the date is null\n+     * @since 2.4\n+     */\n+    public static Date setSeconds(Date date, int amount) {\n+        return set(date, Calendar.SECOND, amount);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the miliseconds field to a date returning a new object.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param amount the amount to set\n+     * @return a new Date object set with the specified value\n+     * @throws IllegalArgumentException if the date is null\n+     * @since 2.4\n+     */\n+    public static Date setMilliseconds(Date date, int amount) {\n+        return set(date, Calendar.MILLISECOND, amount);\n+    } \n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the specified field to a date returning a new object.  \n+     * This does not use a lenient calendar.\n+     * The original date object is unchanged.\n+     *\n+     * @param date  the date, not null\n+     * @param calendarField  the calendar field to set the amount to\n+     * @param amount the amount to set\n+     * @return a new Date object set with the specified value\n+     * @throws IllegalArgumentException if the date is null\n+     * @since 2.4\n+     */\n+    private static Date set(Date date, int calendarField, int amount) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        // getInstance() returns a new object, so this method is thread safe.\n+        Calendar c = Calendar.getInstance();\n+        c.setLenient(false);\n+        c.setTime(date);\n+        c.set(calendarField, amount);\n+        return c.getTime();\n+    }   \n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Round this date, leaving the field specified as the most\n+     * significant field.</p>\n+     *\n+     * <p>For example, if you had the datetime of 28 Mar 2002\n+     * 13:45:01.231, if this was passed with HOUR, it would return\n+     * 28 Mar 2002 14:00:00.000. If this was passed with MONTH, it\n+     * would return 1 April 2002 0:00:00.000.</p>\n+     * \n+     * <p>For a date in a timezone that handles the change to daylight\n+     * saving time, rounding to Calendar.HOUR_OF_DAY will behave as follows.\n+     * Suppose daylight saving time begins at 02:00 on March 30. Rounding a \n+     * date that crosses this time would produce the following values:\n+     * <ul>\n+     * <li>March 30, 2003 01:10 rounds to March 30, 2003 01:00</li>\n+     * <li>March 30, 2003 01:40 rounds to March 30, 2003 03:00</li>\n+     * <li>March 30, 2003 02:10 rounds to March 30, 2003 03:00</li>\n+     * <li>March 30, 2003 02:40 rounds to March 30, 2003 04:00</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param date  the date to work with\n+     * @param field  the field from <code>Calendar</code>\n+     *  or <code>SEMI_MONTH</code>\n+     * @return the rounded date\n+     * @throws IllegalArgumentException if the date is <code>null</code>\n+     * @throws ArithmeticException if the year is over 280 million\n+     */\n+    public static Date round(Date date, int field) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        Calendar gval = Calendar.getInstance();\n+        gval.setTime(date);\n+        modify(gval, field, MODIFY_ROUND);\n+        return gval.getTime();\n+    }\n+\n+    /**\n+     * <p>Round this date, leaving the field specified as the most\n+     * significant field.</p>\n+     *\n+     * <p>For example, if you had the datetime of 28 Mar 2002\n+     * 13:45:01.231, if this was passed with HOUR, it would return\n+     * 28 Mar 2002 14:00:00.000. If this was passed with MONTH, it\n+     * would return 1 April 2002 0:00:00.000.</p>\n+     * \n+     * <p>For a date in a timezone that handles the change to daylight\n+     * saving time, rounding to Calendar.HOUR_OF_DAY will behave as follows.\n+     * Suppose daylight saving time begins at 02:00 on March 30. Rounding a \n+     * date that crosses this time would produce the following values:\n+     * <ul>\n+     * <li>March 30, 2003 01:10 rounds to March 30, 2003 01:00</li>\n+     * <li>March 30, 2003 01:40 rounds to March 30, 2003 03:00</li>\n+     * <li>March 30, 2003 02:10 rounds to March 30, 2003 03:00</li>\n+     * <li>March 30, 2003 02:40 rounds to March 30, 2003 04:00</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param date  the date to work with\n+     * @param field  the field from <code>Calendar</code>\n+     *  or <code>SEMI_MONTH</code>\n+     * @return the rounded date (a different object)\n+     * @throws IllegalArgumentException if the date is <code>null</code>\n+     * @throws ArithmeticException if the year is over 280 million\n+     */\n+    public static Calendar round(Calendar date, int field) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        Calendar rounded = (Calendar) date.clone();\n+        modify(rounded, field, MODIFY_ROUND);\n+        return rounded;\n+    }\n+\n+    /**\n+     * <p>Round this date, leaving the field specified as the most\n+     * significant field.</p>\n+     *\n+     * <p>For example, if you had the datetime of 28 Mar 2002\n+     * 13:45:01.231, if this was passed with HOUR, it would return\n+     * 28 Mar 2002 14:00:00.000. If this was passed with MONTH, it\n+     * would return 1 April 2002 0:00:00.000.</p>\n+     * \n+     * <p>For a date in a timezone that handles the change to daylight\n+     * saving time, rounding to Calendar.HOUR_OF_DAY will behave as follows.\n+     * Suppose daylight saving time begins at 02:00 on March 30. Rounding a \n+     * date that crosses this time would produce the following values:\n+     * <ul>\n+     * <li>March 30, 2003 01:10 rounds to March 30, 2003 01:00</li>\n+     * <li>March 30, 2003 01:40 rounds to March 30, 2003 03:00</li>\n+     * <li>March 30, 2003 02:10 rounds to March 30, 2003 03:00</li>\n+     * <li>March 30, 2003 02:40 rounds to March 30, 2003 04:00</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param date  the date to work with, either Date or Calendar\n+     * @param field  the field from <code>Calendar</code>\n+     *  or <code>SEMI_MONTH</code>\n+     * @return the rounded date\n+     * @throws IllegalArgumentException if the date is <code>null</code>\n+     * @throws ClassCastException if the object type is not a <code>Date</code>\n+     *  or <code>Calendar</code>\n+     * @throws ArithmeticException if the year is over 280 million\n+     */\n+    public static Date round(Object date, int field) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        if (date instanceof Date) {\n+            return round((Date) date, field);\n+        } else if (date instanceof Calendar) {\n+            return round((Calendar) date, field).getTime();\n+        } else {\n+            throw new ClassCastException(\"Could not round \" + date);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Truncate this date, leaving the field specified as the most\n+     * significant field.</p>\n+     *\n+     * <p>For example, if you had the datetime of 28 Mar 2002\n+     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n+     * 2002 13:00:00.000.  If this was passed with MONTH, it would\n+     * return 1 Mar 2002 0:00:00.000.</p>\n+     * \n+     * @param date  the date to work with\n+     * @param field  the field from <code>Calendar</code>\n+     *  or <code>SEMI_MONTH</code>\n+     * @return the rounded date\n+     * @throws IllegalArgumentException if the date is <code>null</code>\n+     * @throws ArithmeticException if the year is over 280 million\n+     */\n+    public static Date truncate(Date date, int field) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        Calendar gval = Calendar.getInstance();\n+        gval.setTime(date);\n+        modify(gval, field, MODIFY_TRUNCATE);\n+        return gval.getTime();\n+    }\n+\n+    /**\n+     * <p>Truncate this date, leaving the field specified as the most\n+     * significant field.</p>\n+     *\n+     * <p>For example, if you had the datetime of 28 Mar 2002\n+     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n+     * 2002 13:00:00.000.  If this was passed with MONTH, it would\n+     * return 1 Mar 2002 0:00:00.000.</p>\n+     * \n+     * @param date  the date to work with\n+     * @param field  the field from <code>Calendar</code>\n+     *  or <code>SEMI_MONTH</code>\n+     * @return the rounded date (a different object)\n+     * @throws IllegalArgumentException if the date is <code>null</code>\n+     * @throws ArithmeticException if the year is over 280 million\n+     */\n+    public static Calendar truncate(Calendar date, int field) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        Calendar truncated = (Calendar) date.clone();\n+        modify(truncated, field, MODIFY_TRUNCATE);\n+        return truncated;\n+    }\n+\n+    /**\n+     * <p>Truncate this date, leaving the field specified as the most\n+     * significant field.</p>\n+     *\n+     * <p>For example, if you had the datetime of 28 Mar 2002\n+     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n+     * 2002 13:00:00.000.  If this was passed with MONTH, it would\n+     * return 1 Mar 2002 0:00:00.000.</p>\n+     * \n+     * @param date  the date to work with, either <code>Date</code>\n+     *  or <code>Calendar</code>\n+     * @param field  the field from <code>Calendar</code>\n+     *  or <code>SEMI_MONTH</code>\n+     * @return the rounded date\n+     * @throws IllegalArgumentException if the date\n+     *  is <code>null</code>\n+     * @throws ClassCastException if the object type is not a\n+     *  <code>Date</code> or <code>Calendar</code>\n+     * @throws ArithmeticException if the year is over 280 million\n+     */\n+    public static Date truncate(Object date, int field) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        if (date instanceof Date) {\n+            return truncate((Date) date, field);\n+        } else if (date instanceof Calendar) {\n+            return truncate((Calendar) date, field).getTime();\n+        } else {\n+            throw new ClassCastException(\"Could not truncate \" + date);\n+        }\n+    }\n+    \n+  //-----------------------------------------------------------------------\n+    /**\n+     * <p>Ceil this date, leaving the field specified as the most\n+     * significant field.</p>\n+     *\n+     * <p>For example, if you had the datetime of 28 Mar 2002\n+     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n+     * 2002 13:00:00.000.  If this was passed with MONTH, it would\n+     * return 1 Mar 2002 0:00:00.000.</p>\n+     * \n+     * @param date  the date to work with\n+     * @param field  the field from <code>Calendar</code>\n+     *  or <code>SEMI_MONTH</code>\n+     * @return the rounded date\n+     * @throws IllegalArgumentException if the date is <code>null</code>\n+     * @throws ArithmeticException if the year is over 280 million\n+     */\n+    public static Date ceiling(Date date, int field) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        Calendar gval = Calendar.getInstance();\n+        gval.setTime(date);\n+        modify(gval, field, MODIFY_CEILING);\n+        return gval.getTime();\n+    }\n+\n+    /**\n+     * <p>Ceil this date, leaving the field specified as the most\n+     * significant field.</p>\n+     *\n+     * <p>For example, if you had the datetime of 28 Mar 2002\n+     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n+     * 2002 13:00:00.000.  If this was passed with MONTH, it would\n+     * return 1 Mar 2002 0:00:00.000.</p>\n+     * \n+     * @param date  the date to work with\n+     * @param field  the field from <code>Calendar</code>\n+     *  or <code>SEMI_MONTH</code>\n+     * @return the rounded date (a different object)\n+     * @throws IllegalArgumentException if the date is <code>null</code>\n+     * @throws ArithmeticException if the year is over 280 million\n+     */\n+    public static Calendar ceiling(Calendar date, int field) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        Calendar ceiled = (Calendar) date.clone();\n+        modify(ceiled, field, MODIFY_CEILING);\n+        return ceiled;\n+    }\n+\n+    /**\n+     * <p>Ceil this date, leaving the field specified as the most\n+     * significant field.</p>\n+     *\n+     * <p>For example, if you had the datetime of 28 Mar 2002\n+     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n+     * 2002 13:00:00.000.  If this was passed with MONTH, it would\n+     * return 1 Mar 2002 0:00:00.000.</p>\n+     * \n+     * @param date  the date to work with, either <code>Date</code>\n+     *  or <code>Calendar</code>\n+     * @param field  the field from <code>Calendar</code>\n+     *  or <code>SEMI_MONTH</code>\n+     * @return the rounded date\n+     * @throws IllegalArgumentException if the date\n+     *  is <code>null</code>\n+     * @throws ClassCastException if the object type is not a\n+     *  <code>Date</code> or <code>Calendar</code>\n+     * @throws ArithmeticException if the year is over 280 million\n+     */\n+    public static Date ceiling(Object date, int field) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        if (date instanceof Date) {\n+            return ceiling((Date) date, field);\n+        } else if (date instanceof Calendar) {\n+            return ceiling((Calendar) date, field).getTime();\n+        } else {\n+            throw new ClassCastException(\"Could not find ceiling of for type: \" + date.getClass());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Internal calculation method.</p>\n+     * \n+     * @param val  the calendar\n+     * @param field  the field constant\n+     * @param modType  type to truncate, round or ceiling\n+     * @throws ArithmeticException if the year is over 280 million\n+     */\n+    private static void modify(Calendar val, int field, int modType) {\n+        if (val.get(Calendar.YEAR) > 280000000) {\n+            throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n+        }\n+        \n+        if (field == Calendar.MILLISECOND) {\n+            return;\n+        }\n+\n+        // ----------------- Fix for LANG-59 ---------------------- START ---------------\n+        // see http://issues.apache.org/jira/browse/LANG-59\n+        //\n+        // Manually truncate milliseconds, seconds and minutes, rather than using\n+        // Calendar methods.\n+\n+        Date date = val.getTime();\n+        long time = date.getTime();\n+        boolean done = false;\n+\n+        // truncate milliseconds\n+        int millisecs = val.get(Calendar.MILLISECOND);\n+        if (MODIFY_TRUNCATE == modType || millisecs < 500) {\n+            time = time - millisecs;\n+        }\n+        if (field == Calendar.SECOND) {\n+            done = true;\n+        }\n+\n+        // truncate seconds\n+        int seconds = val.get(Calendar.SECOND);\n+        if (!done && (MODIFY_TRUNCATE == modType || seconds < 30)) {\n+            time = time - (seconds * 1000L);\n+        }\n+        if (field == Calendar.MINUTE) {\n+            done = true;\n+        }\n+\n+        // truncate minutes\n+        int minutes = val.get(Calendar.MINUTE);\n+        if (!done && (MODIFY_TRUNCATE == modType || minutes < 30)) {\n+            time = time - (minutes * 60000L);\n+        }\n+\n+        // reset time\n+        if (date.getTime() != time) {\n+            date.setTime(time);\n+            val.setTime(date);\n+        }\n+        // ----------------- Fix for LANG-59 ----------------------- END ----------------\n+\n+        boolean roundUp = false;\n+        for (int i = 0; i < fields.length; i++) {\n+            for (int j = 0; j < fields[i].length; j++) {\n+                if (fields[i][j] == field) {\n+                    //This is our field... we stop looping\n+                    if (modType == MODIFY_CEILING || (modType == MODIFY_ROUND && roundUp)) {\n+                        if (field == DateUtils.SEMI_MONTH) {\n+                            //This is a special case that's hard to generalize\n+                            //If the date is 1, we round up to 16, otherwise\n+                            //  we subtract 15 days and add 1 month\n+                            if (val.get(Calendar.DATE) == 1) {\n+                                val.add(Calendar.DATE, 15);\n+                            } else {\n+                                val.add(Calendar.DATE, -15);\n+                                val.add(Calendar.MONTH, 1);\n+                            }\n+// ----------------- Fix for LANG-440 ---------------------- START ---------------\n+                        } else if (field == Calendar.AM_PM) {\n+                            // This is a special case\n+                            // If the time is 0, we round up to 12, otherwise\n+                            //  we subtract 12 hours and add 1 day\n+                            if (val.get(Calendar.HOUR_OF_DAY) == 0) {\n+                                val.add(Calendar.HOUR_OF_DAY, 12);\n+                            } else {\n+                                val.add(Calendar.HOUR_OF_DAY, -12);\n+                                val.add(Calendar.DATE, 1);\n+                            }\n+// ----------------- Fix for LANG-440 ---------------------- END ---------------\n+                        } else {\n+                            //We need at add one to this field since the\n+                            //  last number causes us to round up\n+                            val.add(fields[i][0], 1);\n+                        }\n+                    }\n+                    return;\n+                }\n+            }\n+            //We have various fields that are not easy roundings\n+            int offset = 0;\n+            boolean offsetSet = false;\n+            //These are special types of fields that require different rounding rules\n+            switch (field) {\n+                case DateUtils.SEMI_MONTH:\n+                    if (fields[i][0] == Calendar.DATE) {\n+                        //If we're going to drop the DATE field's value,\n+                        //  we want to do this our own way.\n+                        //We need to subtrace 1 since the date has a minimum of 1\n+                        offset = val.get(Calendar.DATE) - 1;\n+                        //If we're above 15 days adjustment, that means we're in the\n+                        //  bottom half of the month and should stay accordingly.\n+                        if (offset >= 15) {\n+                            offset -= 15;\n+                        }\n+                        //Record whether we're in the top or bottom half of that range\n+                        roundUp = offset > 7;\n+                        offsetSet = true;\n+                    }\n+                    break;\n+                case Calendar.AM_PM:\n+                    if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n+                        //If we're going to drop the HOUR field's value,\n+                        //  we want to do this our own way.\n+                        offset = val.get(Calendar.HOUR_OF_DAY);\n+                        if (offset >= 12) {\n+                            offset -= 12;\n+                        }\n+                        roundUp = offset >= 6;\n+                        offsetSet = true;\n+                    }\n+                    break;\n+            }\n+            if (!offsetSet) {\n+                int min = val.getActualMinimum(fields[i][0]);\n+                int max = val.getActualMaximum(fields[i][0]);\n+                //Calculate the offset from the minimum allowed value\n+                offset = val.get(fields[i][0]) - min;\n+                //Set roundUp if this is more than half way between the minimum and maximum\n+                roundUp = offset > ((max - min) / 2);\n+            }\n+            //We need to remove this field\n+            if (offset != 0) {\n+                val.set(fields[i][0], val.get(fields[i][0]) - offset);\n+            }\n+        }\n+        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n+\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>This constructs an <code>Iterator</code> over each day in a date\n+     * range defined by a focus date and range style.</p>\n+     *\n+     * <p>For instance, passing Thursday, July 4, 2002 and a\n+     * <code>RANGE_MONTH_SUNDAY</code> will return an <code>Iterator</code>\n+     * that starts with Sunday, June 30, 2002 and ends with Saturday, August 3,\n+     * 2002, returning a Calendar instance for each intermediate day.</p>\n+     *\n+     * <p>This method provides an iterator that returns Calendar objects.\n+     * The days are progressed using {@link Calendar#add(int, int)}.</p>\n+     *\n+     * @param focus  the date to work with, not null\n+     * @param rangeStyle  the style constant to use. Must be one of\n+     * {@link DateUtils#RANGE_MONTH_SUNDAY}, \n+     * {@link DateUtils#RANGE_MONTH_MONDAY},\n+     * {@link DateUtils#RANGE_WEEK_SUNDAY},\n+     * {@link DateUtils#RANGE_WEEK_MONDAY},\n+     * {@link DateUtils#RANGE_WEEK_RELATIVE},\n+     * {@link DateUtils#RANGE_WEEK_CENTER}\n+     * @return the date iterator, which always returns Calendar instances\n+     * @throws IllegalArgumentException if the date is <code>null</code>\n+     * @throws IllegalArgumentException if the rangeStyle is invalid\n+     */\n+    public static Iterator<Calendar> iterator(Date focus, int rangeStyle) {\n+        if (focus == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        Calendar gval = Calendar.getInstance();\n+        gval.setTime(focus);\n+        return iterator(gval, rangeStyle);\n+    }\n+\n+    /**\n+     * <p>This constructs an <code>Iterator</code> over each day in a date\n+     * range defined by a focus date and range style.</p>\n+     *\n+     * <p>For instance, passing Thursday, July 4, 2002 and a\n+     * <code>RANGE_MONTH_SUNDAY</code> will return an <code>Iterator</code>\n+     * that starts with Sunday, June 30, 2002 and ends with Saturday, August 3,\n+     * 2002, returning a Calendar instance for each intermediate day.</p>\n+     *\n+     * <p>This method provides an iterator that returns Calendar objects.\n+     * The days are progressed using {@link Calendar#add(int, int)}.</p>\n+     *\n+     * @param focus  the date to work with\n+     * @param rangeStyle  the style constant to use. Must be one of\n+     * {@link DateUtils#RANGE_MONTH_SUNDAY}, \n+     * {@link DateUtils#RANGE_MONTH_MONDAY},\n+     * {@link DateUtils#RANGE_WEEK_SUNDAY},\n+     * {@link DateUtils#RANGE_WEEK_MONDAY},\n+     * {@link DateUtils#RANGE_WEEK_RELATIVE},\n+     * {@link DateUtils#RANGE_WEEK_CENTER}\n+     * @return the date iterator\n+     * @throws IllegalArgumentException if the date is <code>null</code>\n+     * @throws IllegalArgumentException if the rangeStyle is invalid\n+     */\n+    public static Iterator<Calendar> iterator(Calendar focus, int rangeStyle) {\n+        if (focus == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        Calendar start = null;\n+        Calendar end = null;\n+        int startCutoff = Calendar.SUNDAY;\n+        int endCutoff = Calendar.SATURDAY;\n+        switch (rangeStyle) {\n+            case RANGE_MONTH_SUNDAY:\n+            case RANGE_MONTH_MONDAY:\n+                //Set start to the first of the month\n+                start = truncate(focus, Calendar.MONTH);\n+                //Set end to the last of the month\n+                end = (Calendar) start.clone();\n+                end.add(Calendar.MONTH, 1);\n+                end.add(Calendar.DATE, -1);\n+                //Loop start back to the previous sunday or monday\n+                if (rangeStyle == RANGE_MONTH_MONDAY) {\n+                    startCutoff = Calendar.MONDAY;\n+                    endCutoff = Calendar.SUNDAY;\n+                }\n+                break;\n+            case RANGE_WEEK_SUNDAY:\n+            case RANGE_WEEK_MONDAY:\n+            case RANGE_WEEK_RELATIVE:\n+            case RANGE_WEEK_CENTER:\n+                //Set start and end to the current date\n+                start = truncate(focus, Calendar.DATE);\n+                end = truncate(focus, Calendar.DATE);\n+                switch (rangeStyle) {\n+                    case RANGE_WEEK_SUNDAY:\n+                        //already set by default\n+                        break;\n+                    case RANGE_WEEK_MONDAY:\n+                        startCutoff = Calendar.MONDAY;\n+                        endCutoff = Calendar.SUNDAY;\n+                        break;\n+                    case RANGE_WEEK_RELATIVE:\n+                        startCutoff = focus.get(Calendar.DAY_OF_WEEK);\n+                        endCutoff = startCutoff - 1;\n+                        break;\n+                    case RANGE_WEEK_CENTER:\n+                        startCutoff = focus.get(Calendar.DAY_OF_WEEK) - 3;\n+                        endCutoff = focus.get(Calendar.DAY_OF_WEEK) + 3;\n+                        break;\n+                }\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"The range style \" + rangeStyle + \" is not valid.\");\n+        }\n+        if (startCutoff < Calendar.SUNDAY) {\n+            startCutoff += 7;\n+        }\n+        if (startCutoff > Calendar.SATURDAY) {\n+            startCutoff -= 7;\n+        }\n+        if (endCutoff < Calendar.SUNDAY) {\n+            endCutoff += 7;\n+        }\n+        if (endCutoff > Calendar.SATURDAY) {\n+            endCutoff -= 7;\n+        }\n+        while (start.get(Calendar.DAY_OF_WEEK) != startCutoff) {\n+            start.add(Calendar.DATE, -1);\n+        }\n+        while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) {\n+            end.add(Calendar.DATE, 1);\n+        }\n+        return new DateIterator(start, end);\n+    }\n+\n+    /**\n+     * <p>This constructs an <code>Iterator</code> over each day in a date\n+     * range defined by a focus date and range style.</p>\n+     *\n+     * <p>For instance, passing Thursday, July 4, 2002 and a\n+     * <code>RANGE_MONTH_SUNDAY</code> will return an <code>Iterator</code>\n+     * that starts with Sunday, June 30, 2002 and ends with Saturday, August 3,\n+     * 2002, returning a Calendar instance for each intermediate day.</p>\n+     *\n+     * @param focus  the date to work with, either\n+     *  <code>Date</code> or <code>Calendar</code>\n+     * @param rangeStyle  the style constant to use. Must be one of the range\n+     * styles listed for the {@link #iterator(Calendar, int)} method.\n+     * @return the date iterator\n+     * @throws IllegalArgumentException if the date\n+     *  is <code>null</code>\n+     * @throws ClassCastException if the object type is\n+     *  not a <code>Date</code> or <code>Calendar</code>\n+     */\n+    public static Iterator<?> iterator(Object focus, int rangeStyle) {\n+        if (focus == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        if (focus instanceof Date) {\n+            return iterator((Date) focus, rangeStyle);\n+        } else if (focus instanceof Calendar) {\n+            return iterator((Calendar) focus, rangeStyle);\n+        } else {\n+            throw new ClassCastException(\"Could not iterate based on \" + focus);\n+        }\n+    }\n+    \n+    /**\n+     * <p>Returns the number of milliseconds within the \n+     * fragment. All datefields greater than the fragment will be ignored.</p>\n+     * \n+     * <p>Asking the milliseconds of any date will only return the number of milliseconds\n+     * of the current second (resulting in a number between 0 and 999). This \n+     * method will retrieve the number of milliseconds for any fragment. \n+     * For example, if you want to calculate the number of milliseconds past today, \n+     * your fragment is Calendar.DATE or Calendar.DAY_OF_YEAR. The result will\n+     * be all milliseconds of the past hour(s), minutes(s) and second(s).</p>\n+     * \n+     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n+     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n+     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n+     * A fragment less than or equal to a SECOND field will return 0.</p> \n+     * \n+     * <p>\n+     * <ul>\n+     *  <li>January 1, 2008 7:15:10.538 with Calendar.SECOND as fragment will return 538</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.SECOND as fragment will return 538</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10538 (10*1000 + 538)</li>\n+     *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0\n+     *   (a millisecond cannot be split in milliseconds)</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param date the date to work with, not null\n+     * @param fragment the Calendar field part of date to calculate \n+     * @return number of milliseconds within the fragment of date\n+     * @throws IllegalArgumentException if the date is <code>null</code> or\n+     * fragment is not supported\n+     * @since 2.4\n+     */\n+    public static long getFragmentInMilliseconds(Date date, int fragment) {\n+        return getFragment(date, fragment, Calendar.MILLISECOND);    \n+    }\n+    \n+    /**\n+     * <p>Returns the number of seconds within the \n+     * fragment. All datefields greater than the fragment will be ignored.</p> \n+     * \n+     * <p>Asking the seconds of any date will only return the number of seconds\n+     * of the current minute (resulting in a number between 0 and 59). This \n+     * method will retrieve the number of seconds for any fragment. \n+     * For example, if you want to calculate the number of seconds past today, \n+     * your fragment is Calendar.DATE or Calendar.DAY_OF_YEAR. The result will\n+     * be all seconds of the past hour(s) and minutes(s).</p> \n+     * \n+     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n+     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n+     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n+     * A fragment less than or equal to a SECOND field will return 0.</p> \n+     * \n+     * <p>\n+     * <ul>\n+     *  <li>January 1, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10\n+     *   (equivalent to deprecated date.getSeconds())</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10\n+     *   (equivalent to deprecated date.getSeconds())</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 26110\n+     *   (7*3600 + 15*60 + 10)</li>\n+     *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0\n+     *   (a millisecond cannot be split in seconds)</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param date the date to work with, not null\n+     * @param fragment the Calendar field part of date to calculate \n+     * @return number of seconds within the fragment of date\n+     * @throws IllegalArgumentException if the date is <code>null</code> or\n+     * fragment is not supported\n+     * @since 2.4\n+     */\n+    public static long getFragmentInSeconds(Date date, int fragment) {\n+        return getFragment(date, fragment, Calendar.SECOND);\n+    }\n+    \n+    /**\n+     * <p>Returns the number of minutes within the \n+     * fragment. All datefields greater than the fragment will be ignored.</p> \n+     * \n+     * <p>Asking the minutes of any date will only return the number of minutes\n+     * of the current hour (resulting in a number between 0 and 59). This \n+     * method will retrieve the number of minutes for any fragment. \n+     * For example, if you want to calculate the number of minutes past this month, \n+     * your fragment is Calendar.MONTH. The result will be all minutes of the \n+     * past day(s) and hour(s).</p> \n+     * \n+     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n+     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n+     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n+     * A fragment less than or equal to a MINUTE field will return 0.</p> \n+     * \n+     * <p>\n+     * <ul>\n+     *  <li>January 1, 2008 7:15:10.538 with Calendar.HOUR_OF_DAY as fragment will return 15\n+     *   (equivalent to deprecated date.getMinutes())</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.HOUR_OF_DAY as fragment will return 15\n+     *   (equivalent to deprecated date.getMinutes())</li>\n+     *  <li>January 1, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 15</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 435 (7*60 + 15)</li>\n+     *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0\n+     *   (a millisecond cannot be split in minutes)</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param date the date to work with, not null\n+     * @param fragment the Calendar field part of date to calculate \n+     * @return number of minutes within the fragment of date\n+     * @throws IllegalArgumentException if the date is <code>null</code> or \n+     * fragment is not supported\n+     * @since 2.4\n+     */\n+    public static long getFragmentInMinutes(Date date, int fragment) {\n+        return getFragment(date, fragment, Calendar.MINUTE);\n+    }\n+    \n+    /**\n+     * <p>Returns the number of hours within the \n+     * fragment. All datefields greater than the fragment will be ignored.</p> \n+     * \n+     * <p>Asking the hours of any date will only return the number of hours\n+     * of the current day (resulting in a number between 0 and 23). This \n+     * method will retrieve the number of hours for any fragment. \n+     * For example, if you want to calculate the number of hours past this month, \n+     * your fragment is Calendar.MONTH. The result will be all hours of the \n+     * past day(s).</p> \n+     * \n+     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n+     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n+     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n+     * A fragment less than or equal to a HOUR field will return 0.</p> \n+     * \n+     * <p>\n+     * <ul>\n+     *  <li>January 1, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 7\n+     *   (equivalent to deprecated date.getHours())</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 7\n+     *   (equivalent to deprecated date.getHours())</li>\n+     *  <li>January 1, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 7</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 127 (5*24 + 7)</li>\n+     *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0\n+     *   (a millisecond cannot be split in hours)</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param date the date to work with, not null\n+     * @param fragment the Calendar field part of date to calculate \n+     * @return number of hours within the fragment of date\n+     * @throws IllegalArgumentException if the date is <code>null</code> or \n+     * fragment is not supported\n+     * @since 2.4\n+     */\n+    public static long getFragmentInHours(Date date, int fragment) {\n+        return getFragment(date, fragment, Calendar.HOUR_OF_DAY);\n+    }\n+    \n+    /**\n+     * <p>Returns the number of days within the \n+     * fragment. All datefields greater than the fragment will be ignored.</p> \n+     * \n+     * <p>Asking the days of any date will only return the number of days\n+     * of the current month (resulting in a number between 1 and 31). This \n+     * method will retrieve the number of days for any fragment. \n+     * For example, if you want to calculate the number of days past this year, \n+     * your fragment is Calendar.YEAR. The result will be all days of the \n+     * past month(s).</p> \n+     * \n+     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n+     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n+     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n+     * A fragment less than or equal to a DAY field will return 0.</p> \n+     *  \n+     * <p>\n+     * <ul>\n+     *  <li>January 28, 2008 with Calendar.MONTH as fragment will return 28\n+     *   (equivalent to deprecated date.getDay())</li>\n+     *  <li>February 28, 2008 with Calendar.MONTH as fragment will return 28\n+     *   (equivalent to deprecated date.getDay())</li>\n+     *  <li>January 28, 2008 with Calendar.YEAR as fragment will return 28</li>\n+     *  <li>February 28, 2008 with Calendar.YEAR as fragment will return 59</li>\n+     *  <li>January 28, 2008 with Calendar.MILLISECOND as fragment will return 0\n+     *   (a millisecond cannot be split in days)</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param date the date to work with, not null\n+     * @param fragment the Calendar field part of date to calculate \n+     * @return number of days  within the fragment of date\n+     * @throws IllegalArgumentException if the date is <code>null</code> or \n+     * fragment is not supported\n+     * @since 2.4\n+     */\n+    public static long getFragmentInDays(Date date, int fragment) {\n+        return getFragment(date, fragment, Calendar.DAY_OF_YEAR);\n+    }\n+\n+    /**\n+     * <p>Returns the number of milliseconds within the \n+     * fragment. All datefields greater than the fragment will be ignored.</p> \n+     * \n+     * <p>Asking the milliseconds of any date will only return the number of milliseconds\n+     * of the current second (resulting in a number between 0 and 999). This \n+     * method will retrieve the number of milliseconds for any fragment. \n+     * For example, if you want to calculate the number of seconds past today, \n+     * your fragment is Calendar.DATE or Calendar.DAY_OF_YEAR. The result will\n+     * be all seconds of the past hour(s), minutes(s) and second(s).</p> \n+     * \n+     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n+     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n+     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n+     * A fragment less than or equal to a MILLISECOND field will return 0.</p> \n+     * \n+     * <p>\n+     * <ul>\n+     *  <li>January 1, 2008 7:15:10.538 with Calendar.SECOND as fragment will return 538\n+     *   (equivalent to calendar.get(Calendar.MILLISECOND))</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.SECOND as fragment will return 538\n+     *   (equivalent to calendar.get(Calendar.MILLISECOND))</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10538\n+     *   (10*1000 + 538)</li>\n+     *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0\n+     *   (a millisecond cannot be split in milliseconds)</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param calendar the calendar to work with, not null\n+     * @param fragment the Calendar field part of calendar to calculate \n+     * @return number of milliseconds within the fragment of date\n+     * @throws IllegalArgumentException if the date is <code>null</code> or \n+     * fragment is not supported\n+     * @since 2.4\n+     */\n+  public static long getFragmentInMilliseconds(Calendar calendar, int fragment) {\n+    return getFragment(calendar, fragment, Calendar.MILLISECOND);\n+  }\n+    /**\n+     * <p>Returns the number of seconds within the \n+     * fragment. All datefields greater than the fragment will be ignored.</p> \n+     * \n+     * <p>Asking the seconds of any date will only return the number of seconds\n+     * of the current minute (resulting in a number between 0 and 59). This \n+     * method will retrieve the number of seconds for any fragment. \n+     * For example, if you want to calculate the number of seconds past today, \n+     * your fragment is Calendar.DATE or Calendar.DAY_OF_YEAR. The result will\n+     * be all seconds of the past hour(s) and minutes(s).</p> \n+     * \n+     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n+     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n+     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n+     * A fragment less than or equal to a SECOND field will return 0.</p> \n+     * \n+     * <p>\n+     * <ul>\n+     *  <li>January 1, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10\n+     *   (equivalent to calendar.get(Calendar.SECOND))</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.MINUTE as fragment will return 10\n+     *   (equivalent to calendar.get(Calendar.SECOND))</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 26110\n+     *   (7*3600 + 15*60 + 10)</li>\n+     *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0\n+     *   (a millisecond cannot be split in seconds)</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param calendar the calendar to work with, not null\n+     * @param fragment the Calendar field part of calendar to calculate \n+     * @return number of seconds within the fragment of date\n+     * @throws IllegalArgumentException if the date is <code>null</code> or \n+     * fragment is not supported\n+     * @since 2.4\n+     */\n+    public static long getFragmentInSeconds(Calendar calendar, int fragment) {\n+        return getFragment(calendar, fragment, Calendar.SECOND);\n+    }\n+    \n+    /**\n+     * <p>Returns the number of minutes within the \n+     * fragment. All datefields greater than the fragment will be ignored.</p> \n+     * \n+     * <p>Asking the minutes of any date will only return the number of minutes\n+     * of the current hour (resulting in a number between 0 and 59). This \n+     * method will retrieve the number of minutes for any fragment. \n+     * For example, if you want to calculate the number of minutes past this month, \n+     * your fragment is Calendar.MONTH. The result will be all minutes of the \n+     * past day(s) and hour(s).</p> \n+     * \n+     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n+     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n+     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n+     * A fragment less than or equal to a MINUTE field will return 0.</p> \n+     * \n+     * <p>\n+     * <ul>\n+     *  <li>January 1, 2008 7:15:10.538 with Calendar.HOUR_OF_DAY as fragment will return 15\n+     *   (equivalent to calendar.get(Calendar.MINUTES))</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.HOUR_OF_DAY as fragment will return 15\n+     *   (equivalent to calendar.get(Calendar.MINUTES))</li>\n+     *  <li>January 1, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 15</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 435 (7*60 + 15)</li>\n+     *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0\n+     *   (a millisecond cannot be split in minutes)</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param calendar the calendar to work with, not null\n+     * @param fragment the Calendar field part of calendar to calculate \n+     * @return number of minutes within the fragment of date\n+     * @throws IllegalArgumentException if the date is <code>null</code> or \n+     * fragment is not supported\n+     * @since 2.4\n+     */\n+    public static long getFragmentInMinutes(Calendar calendar, int fragment) {\n+        return getFragment(calendar, fragment, Calendar.MINUTE);\n+    }\n+    \n+    /**\n+     * <p>Returns the number of hours within the \n+     * fragment. All datefields greater than the fragment will be ignored.</p> \n+     * \n+     * <p>Asking the hours of any date will only return the number of hours\n+     * of the current day (resulting in a number between 0 and 23). This \n+     * method will retrieve the number of hours for any fragment. \n+     * For example, if you want to calculate the number of hours past this month, \n+     * your fragment is Calendar.MONTH. The result will be all hours of the \n+     * past day(s).</p> \n+     * \n+     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n+     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n+     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n+     * A fragment less than or equal to a HOUR field will return 0.</p> \n+     *  \n+     * <p>\n+     * <ul>\n+     *  <li>January 1, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 7\n+     *   (equivalent to calendar.get(Calendar.HOUR_OF_DAY))</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.DAY_OF_YEAR as fragment will return 7\n+     *   (equivalent to calendar.get(Calendar.HOUR_OF_DAY))</li>\n+     *  <li>January 1, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 7</li>\n+     *  <li>January 6, 2008 7:15:10.538 with Calendar.MONTH as fragment will return 127 (5*24 + 7)</li>\n+     *  <li>January 16, 2008 7:15:10.538 with Calendar.MILLISECOND as fragment will return 0\n+     *   (a millisecond cannot be split in hours)</li>\n+     * </ul>\n+     * </p>\n+     *  \n+     * @param calendar the calendar to work with, not null\n+     * @param fragment the Calendar field part of calendar to calculate \n+     * @return number of hours within the fragment of date\n+     * @throws IllegalArgumentException if the date is <code>null</code> or \n+     * fragment is not supported\n+     * @since 2.4\n+     */\n+    public static long getFragmentInHours(Calendar calendar, int fragment) {\n+        return getFragment(calendar, fragment, Calendar.HOUR_OF_DAY);\n+    }\n+    \n+    /**\n+     * <p>Returns the number of days within the \n+     * fragment. All datefields greater than the fragment will be ignored.</p> \n+     * \n+     * <p>Asking the days of any date will only return the number of days\n+     * of the current month (resulting in a number between 1 and 31). This \n+     * method will retrieve the number of days for any fragment. \n+     * For example, if you want to calculate the number of days past this year, \n+     * your fragment is Calendar.YEAR. The result will be all days of the \n+     * past month(s).</p> \n+     * \n+     * <p>Valid fragments are: Calendar.YEAR, Calendar.MONTH, both \n+     * Calendar.DAY_OF_YEAR and Calendar.DATE, Calendar.HOUR_OF_DAY, \n+     * Calendar.MINUTE, Calendar.SECOND and Calendar.MILLISECOND\n+     * A fragment less than or equal to a DAY field will return 0.</p> \n+     * \n+     * <p>\n+     * <ul>\n+     *  <li>January 28, 2008 with Calendar.MONTH as fragment will return 28\n+     *   (equivalent to calendar.get(Calendar.DAY_OF_MONTH))</li>\n+     *  <li>February 28, 2008 with Calendar.MONTH as fragment will return 28\n+     *   (equivalent to calendar.get(Calendar.DAY_OF_MONTH))</li>\n+     *  <li>January 28, 2008 with Calendar.YEAR as fragment will return 28\n+     *   (equivalent to calendar.get(Calendar.DAY_OF_YEAR))</li>\n+     *  <li>February 28, 2008 with Calendar.YEAR as fragment will return 59\n+     *   (equivalent to calendar.get(Calendar.DAY_OF_YEAR))</li>\n+     *  <li>January 28, 2008 with Calendar.MILLISECOND as fragment will return 0\n+     *   (a millisecond cannot be split in days)</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param calendar the calendar to work with, not null\n+     * @param fragment the Calendar field part of calendar to calculate \n+     * @return number of days within the fragment of date\n+     * @throws IllegalArgumentException if the date is <code>null</code> or \n+     * fragment is not supported\n+     * @since 2.4\n+     */\n+    public static long getFragmentInDays(Calendar calendar, int fragment) {\n+        return getFragment(calendar, fragment, Calendar.DAY_OF_YEAR);\n+    }\n+    \n+    /**\n+     * Date-version for fragment-calculation in any unit\n+     * \n+     * @param date the date to work with, not null\n+     * @param fragment the Calendar field part of date to calculate \n+     * @param unit Calendar field defining the unit\n+     * @return number of units within the fragment of the date\n+     * @throws IllegalArgumentException if the date is <code>null</code> or \n+     * fragment is not supported\n+     * @since 2.4\n+     */\n+    private static long getFragment(Date date, int fragment, int unit) {\n+        if(date == null) {\n+            throw  new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        Calendar calendar = Calendar.getInstance();\n+        calendar.setTime(date);\n+        return getFragment(calendar, fragment, unit);\n+    }\n+\n+    /**\n+     * Calendar-version for fragment-calculation in any unit\n+     * \n+     * @param calendar the calendar to work with, not null\n+     * @param fragment the Calendar field part of calendar to calculate \n+     * @param unit Calendar field defining the unit\n+     * @return number of units within the fragment of the calendar\n+     * @throws IllegalArgumentException if the date is <code>null</code> or \n+     * fragment is not supported\n+     * @since 2.4\n+     */\n+    private static long getFragment(Calendar calendar, int fragment, int unit) {\n+        if(calendar == null) {\n+            throw  new IllegalArgumentException(\"The date must not be null\"); \n+        }\n+        long millisPerUnit = getMillisPerUnit(unit);\n+        long result = 0;\n+        \n+        // Fragments bigger than a day require a breakdown to days\n+        switch (fragment) {\n+            case Calendar.YEAR:\n+                result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit;\n+                break;\n+            case Calendar.MONTH:\n+                result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit;\n+                break;\n+        }\n+\n+        switch (fragment) {\n+            // Number of days already calculated for these cases\n+            case Calendar.YEAR:\n+            case Calendar.MONTH:\n+            \n+            // The rest of the valid cases\n+            case Calendar.DAY_OF_YEAR:\n+            case Calendar.DATE:\n+                result += (calendar.get(Calendar.HOUR_OF_DAY) * MILLIS_PER_HOUR) / millisPerUnit;\n+                //$FALL-THROUGH$\n+            case Calendar.HOUR_OF_DAY:\n+                result += (calendar.get(Calendar.MINUTE) * MILLIS_PER_MINUTE) / millisPerUnit;\n+                //$FALL-THROUGH$\n+            case Calendar.MINUTE:\n+                result += (calendar.get(Calendar.SECOND) * MILLIS_PER_SECOND) / millisPerUnit;\n+                //$FALL-THROUGH$\n+            case Calendar.SECOND:\n+                result += (calendar.get(Calendar.MILLISECOND) * 1) / millisPerUnit;\n+                break;\n+            case Calendar.MILLISECOND: break;//never useful\n+                default: throw new IllegalArgumentException(\"The fragment \" + fragment + \" is not supported\");\n+        }\n+        return result;\n+    }\n+    \n+    /**\n+     * Returns the number of millis of a datefield, if this is a constant value\n+     * \n+     * @param unit A Calendar field which is a valid unit for a fragment\n+     * @return number of millis\n+     * @throws IllegalArgumentException if date can't be represented in millisenconds\n+     * @since 2.4 \n+     */\n+    private static long getMillisPerUnit(int unit) {\n+        long result = Long.MAX_VALUE;\n+        switch (unit) {\n+            case Calendar.DAY_OF_YEAR:\n+            case Calendar.DATE:\n+                result = MILLIS_PER_DAY;\n+                break;\n+            case Calendar.HOUR_OF_DAY:\n+                result = MILLIS_PER_HOUR;\n+                break;\n+            case Calendar.MINUTE:\n+                result = MILLIS_PER_MINUTE;\n+                break;\n+            case Calendar.SECOND:\n+                result = MILLIS_PER_SECOND;\n+                break;\n+            case Calendar.MILLISECOND:\n+                result = 1;\n+                break;\n+            default: throw new IllegalArgumentException(\"The unit \" + unit + \" cannot be represented is milleseconds\");\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * <p>Date iterator.</p>\n+     */\n+    static class DateIterator implements Iterator<Calendar> {\n+        private final Calendar endFinal;\n+        private final Calendar spot;\n+        \n+        /**\n+         * Constructs a DateIterator that ranges from one date to another. \n+         *\n+         * @param startFinal start date (inclusive)\n+         * @param endFinal end date (not inclusive)\n+         */\n+        DateIterator(Calendar startFinal, Calendar endFinal) {\n+            super();\n+            this.endFinal = endFinal;\n+            spot = startFinal;\n+            spot.add(Calendar.DATE, -1);\n+        }\n+\n+        /**\n+         * Has the iterator not reached the end date yet?\n+         *\n+         * @return <code>true</code> if the iterator has yet to reach the end date\n+         */\n+        public boolean hasNext() {\n+            return spot.before(endFinal);\n+        }\n+\n+        /**\n+         * Return the next calendar in the iteration\n+         *\n+         * @return Object calendar for the next date\n+         */\n+        public Calendar next() {\n+            if (spot.equals(endFinal)) {\n+                throw new NoSuchElementException();\n+            }\n+            spot.add(Calendar.DATE, 1);\n+            return (Calendar) spot.clone();\n+        }\n+\n+        /**\n+         * Always throws UnsupportedOperationException.\n+         * \n+         * @throws UnsupportedOperationException\n+         * @see java.util.Iterator#remove()\n+         */\n+        public void remove() {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/time/DurationFormatUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.time;\n+\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.TimeZone;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+/**\n+ * <p>Duration formatting utilities and constants. The following table describes the tokens \n+ * used in the pattern language for formatting. </p>\n+ * <table border=\"1\">\n+ *  <tr><th>character</th><th>duration element</th></tr>\n+ *  <tr><td>y</td><td>years</td></tr>\n+ *  <tr><td>M</td><td>months</td></tr>\n+ *  <tr><td>d</td><td>days</td></tr>\n+ *  <tr><td>H</td><td>hours</td></tr>\n+ *  <tr><td>m</td><td>minutes</td></tr>\n+ *  <tr><td>s</td><td>seconds</td></tr>\n+ *  <tr><td>S</td><td>milliseconds</td></tr>\n+ * </table>\n+ *\n+ * @author Apache Software Foundation\n+ * @author Apache Ant - DateUtils\n+ * @author <a href=\"mailto:sbailliez@apache.org\">Stephane Bailliez</a>\n+ * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig</a>\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @since 2.1\n+ * @version $Id$\n+ */\n+public class DurationFormatUtils {\n+\n+    /**\n+     * <p>DurationFormatUtils instances should NOT be constructed in standard programming.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n+     */\n+    public DurationFormatUtils() {\n+        super();\n+    }\n+\n+    /**\n+     * <p>Pattern used with <code>FastDateFormat</code> and <code>SimpleDateFormat</code>\n+     * for the ISO8601 period format used in durations.</p>\n+     * \n+     * @see org.apache.commons.lang3.time.FastDateFormat\n+     * @see java.text.SimpleDateFormat\n+     */\n+    public static final String ISO_EXTENDED_FORMAT_PATTERN = \"'P'yyyy'Y'M'M'd'DT'H'H'm'M's.S'S'\";\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Formats the time gap as a string.</p>\n+     * \n+     * <p>The format used is ISO8601-like:\n+     * <i>H</i>:<i>m</i>:<i>s</i>.<i>S</i>.</p>\n+     * \n+     * @param durationMillis  the duration to format\n+     * @return the time as a String\n+     */\n+    public static String formatDurationHMS(long durationMillis) {\n+        return formatDuration(durationMillis, \"H:mm:ss.SSS\");\n+    }\n+\n+    /**\n+     * <p>Formats the time gap as a string.</p>\n+     * \n+     * <p>The format used is the ISO8601 period format.</p>\n+     * \n+     * <p>This method formats durations using the days and lower fields of the\n+     * ISO format pattern, such as P7D6TH5M4.321S.</p>\n+     * \n+     * @param durationMillis  the duration to format\n+     * @return the time as a String\n+     */\n+    public static String formatDurationISO(long durationMillis) {\n+        return formatDuration(durationMillis, ISO_EXTENDED_FORMAT_PATTERN, false);\n+    }\n+\n+    /**\n+     * <p>Formats the time gap as a string, using the specified format, and padding with zeros and \n+     * using the default timezone.</p>\n+     * \n+     * <p>This method formats durations using the days and lower fields of the\n+     * format pattern. Months and larger are not used.</p>\n+     * \n+     * @param durationMillis  the duration to format\n+     * @param format  the way in which to format the duration\n+     * @return the time as a String\n+     */\n+    public static String formatDuration(long durationMillis, String format) {\n+        return formatDuration(durationMillis, format, true);\n+    }\n+\n+    /**\n+     * <p>Formats the time gap as a string, using the specified format.\n+     * Padding the left hand side of numbers with zeroes is optional and \n+     * the timezone may be specified.</p>\n+     * \n+     * <p>This method formats durations using the days and lower fields of the\n+     * format pattern. Months and larger are not used.</p>\n+     * \n+     * @param durationMillis  the duration to format\n+     * @param format  the way in which to format the duration\n+     * @param padWithZeros  whether to pad the left hand side of numbers with 0's\n+     * @return the time as a String\n+     */\n+    public static String formatDuration(long durationMillis, String format, boolean padWithZeros) {\n+\n+        Token[] tokens = lexx(format);\n+\n+        int days         = 0;\n+        int hours        = 0;\n+        int minutes      = 0;\n+        int seconds      = 0;\n+        int milliseconds = 0;\n+        \n+        if (Token.containsTokenWithValue(tokens, d) ) {\n+            days = (int) (durationMillis / DateUtils.MILLIS_PER_DAY);\n+            durationMillis = durationMillis - (days * DateUtils.MILLIS_PER_DAY);\n+        }\n+        if (Token.containsTokenWithValue(tokens, H) ) {\n+            hours = (int) (durationMillis / DateUtils.MILLIS_PER_HOUR);\n+            durationMillis = durationMillis - (hours * DateUtils.MILLIS_PER_HOUR);\n+        }\n+        if (Token.containsTokenWithValue(tokens, m) ) {\n+            minutes = (int) (durationMillis / DateUtils.MILLIS_PER_MINUTE);\n+            durationMillis = durationMillis - (minutes * DateUtils.MILLIS_PER_MINUTE);\n+        }\n+        if (Token.containsTokenWithValue(tokens, s) ) {\n+            seconds = (int) (durationMillis / DateUtils.MILLIS_PER_SECOND);\n+            durationMillis = durationMillis - (seconds * DateUtils.MILLIS_PER_SECOND);\n+        }\n+        if (Token.containsTokenWithValue(tokens, S) ) {\n+            milliseconds = (int) durationMillis;\n+        }\n+\n+        return format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);\n+    }\n+\n+    /**\n+     * <p>Formats an elapsed time into a plurialization correct string.</p>\n+     * \n+     * <p>This method formats durations using the days and lower fields of the\n+     * format pattern. Months and larger are not used.</p>\n+     * \n+     * @param durationMillis  the elapsed time to report in milliseconds\n+     * @param suppressLeadingZeroElements  suppresses leading 0 elements\n+     * @param suppressTrailingZeroElements  suppresses trailing 0 elements\n+     * @return the formatted text in days/hours/minutes/seconds\n+     */\n+    public static String formatDurationWords(\n+        long durationMillis,\n+        boolean suppressLeadingZeroElements,\n+        boolean suppressTrailingZeroElements) {\n+\n+        // This method is generally replacable by the format method, but \n+        // there are a series of tweaks and special cases that require \n+        // trickery to replicate.\n+        String duration = formatDuration(durationMillis, \"d' days 'H' hours 'm' minutes 's' seconds'\");\n+        if (suppressLeadingZeroElements) {\n+            // this is a temporary marker on the front. Like ^ in regexp.\n+            duration = \" \" + duration;\n+            String tmp = StringUtils.replaceOnce(duration, \" 0 days\", \"\");\n+            if (tmp.length() != duration.length()) {\n+                duration = tmp;\n+                tmp = StringUtils.replaceOnce(duration, \" 0 hours\", \"\");\n+                if (tmp.length() != duration.length()) {\n+                    duration = tmp;\n+                    tmp = StringUtils.replaceOnce(duration, \" 0 minutes\", \"\");\n+                    duration = tmp;\n+                    if (tmp.length() != duration.length()) {\n+                        duration = StringUtils.replaceOnce(tmp, \" 0 seconds\", \"\");\n+                    }\n+                }\n+            }\n+            if (duration.length() != 0) {\n+                // strip the space off again\n+                duration = duration.substring(1);\n+            }\n+        }\n+        if (suppressTrailingZeroElements) {\n+            String tmp = StringUtils.replaceOnce(duration, \" 0 seconds\", \"\");\n+            if (tmp.length() != duration.length()) {\n+                duration = tmp;\n+                tmp = StringUtils.replaceOnce(duration, \" 0 minutes\", \"\");\n+                if (tmp.length() != duration.length()) {\n+                    duration = tmp;\n+                    tmp = StringUtils.replaceOnce(duration, \" 0 hours\", \"\");\n+                    if (tmp.length() != duration.length()) {\n+                        duration = StringUtils.replaceOnce(tmp, \" 0 days\", \"\");\n+                    }\n+                }\n+            }\n+        }\n+        // handle plurals\n+        duration = \" \" + duration;\n+        duration = StringUtils.replaceOnce(duration, \" 1 seconds\", \" 1 second\");\n+        duration = StringUtils.replaceOnce(duration, \" 1 minutes\", \" 1 minute\");\n+        duration = StringUtils.replaceOnce(duration, \" 1 hours\", \" 1 hour\");\n+        duration = StringUtils.replaceOnce(duration, \" 1 days\", \" 1 day\");\n+        return duration.trim();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Formats the time gap as a string.</p>\n+     * \n+     * <p>The format used is the ISO8601 period format.</p>\n+     * \n+     * @param startMillis  the start of the duration to format\n+     * @param endMillis  the end of the duration to format\n+     * @return the time as a String\n+     */\n+    public static String formatPeriodISO(long startMillis, long endMillis) {\n+        return formatPeriod(startMillis, endMillis, ISO_EXTENDED_FORMAT_PATTERN, false, TimeZone.getDefault());\n+    }\n+\n+    /**\n+     * <p>Formats the time gap as a string, using the specified format.\n+     * Padding the left hand side of numbers with zeroes is optional.\n+     * \n+     * @param startMillis  the start of the duration\n+     * @param endMillis  the end of the duration\n+     * @param format  the way in which to format the duration\n+     * @return the time as a String\n+     */\n+    public static String formatPeriod(long startMillis, long endMillis, String format) {\n+        return formatPeriod(startMillis, endMillis, format, true, TimeZone.getDefault());\n+    }\n+\n+    /**\n+     * <p>Formats the time gap as a string, using the specified format.\n+     * Padding the left hand side of numbers with zeroes is optional and \n+     * the timezone may be specified. </p>\n+     *\n+     * <p>When calculating the difference between months/days, it chooses to \n+     * calculate months first. So when working out the number of months and \n+     * days between January 15th and March 10th, it choose 1 month and \n+     * 23 days gained by choosing January->February = 1 month and then \n+     * calculating days forwards, and not the 1 month and 26 days gained by \n+     * choosing March -> February = 1 month and then calculating days \n+     * backwards. </p>\n+     *\n+     * <p>For more control, the <a href=\"http://joda-time.sf.net/\">Joda-Time</a>\n+     * library is recommended.</p>\n+     * \n+     * @param startMillis  the start of the duration\n+     * @param endMillis  the end of the duration\n+     * @param format  the way in which to format the duration\n+     * @param padWithZeros whether to pad the left hand side of numbers with 0's\n+     * @param timezone the millis are defined in\n+     * @return the time as a String\n+     */\n+    public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n+            TimeZone timezone) {\n+\n+        // Used to optimise for differences under 28 days and \n+        // called formatDuration(millis, format); however this did not work \n+        // over leap years. \n+        // TODO: Compare performance to see if anything was lost by \n+        // losing this optimisation. \n+        \n+        Token[] tokens = lexx(format);\n+\n+        // timezones get funky around 0, so normalizing everything to GMT \n+        // stops the hours being off\n+        Calendar start = Calendar.getInstance(timezone);\n+        start.setTime(new Date(startMillis));\n+        Calendar end = Calendar.getInstance(timezone);\n+        end.setTime(new Date(endMillis));\n+\n+        // initial estimates\n+        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n+        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n+        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n+        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n+        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n+        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n+        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n+\n+        // each initial estimate is adjusted in case it is under 0\n+        while (milliseconds < 0) {\n+            milliseconds += 1000;\n+            seconds -= 1;\n+        }\n+        while (seconds < 0) {\n+            seconds += 60;\n+            minutes -= 1;\n+        }\n+        while (minutes < 0) {\n+            minutes += 60;\n+            hours -= 1;\n+        }\n+        while (hours < 0) {\n+            hours += 24;\n+            days -= 1;\n+        }\n+       \n+        if (Token.containsTokenWithValue(tokens, M)) {\n+            while (days < 0) {\n+                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n+                months -= 1;\n+                start.add(Calendar.MONTH, 1);\n+            }\n+\n+            while (months < 0) {\n+                months += 12;\n+                years -= 1;\n+            }\n+\n+            if (!Token.containsTokenWithValue(tokens, y) && years != 0) {\n+                while (years != 0) {\n+                    months += 12 * years;\n+                    years = 0;\n+                }\n+            }\n+        } else {\n+            // there are no M's in the format string\n+\n+            if( !Token.containsTokenWithValue(tokens, y) ) {\n+                int target = end.get(Calendar.YEAR);\n+                if (months < 0) {\n+                    // target is end-year -1\n+                    target -= 1;\n+                }\n+                \n+                while ( (start.get(Calendar.YEAR) != target)) {\n+                    days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n+                    \n+                    // Not sure I grok why this is needed, but the brutal tests show it is\n+                    if(start instanceof GregorianCalendar) {\n+                        if( (start.get(Calendar.MONTH) == Calendar.FEBRUARY) &&\n+                            (start.get(Calendar.DAY_OF_MONTH) == 29 ) )\n+                        {\n+                            days += 1;\n+                        }\n+                    }\n+                    \n+                    start.add(Calendar.YEAR, 1);\n+                    \n+                    days += start.get(Calendar.DAY_OF_YEAR);\n+                }\n+                \n+                years = 0;\n+            }\n+            \n+            while( start.get(Calendar.MONTH) != end.get(Calendar.MONTH) ) {\n+                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n+                start.add(Calendar.MONTH, 1);\n+            }\n+            \n+            months = 0;            \n+\n+            while (days < 0) {\n+                days += start.getActualMaximum(Calendar.DAY_OF_MONTH);\n+                months -= 1;\n+                start.add(Calendar.MONTH, 1);\n+            }\n+            \n+        }\n+\n+        // The rest of this code adds in values that \n+        // aren't requested. This allows the user to ask for the \n+        // number of months and get the real count and not just 0->11.\n+\n+        if (!Token.containsTokenWithValue(tokens, d)) {\n+            hours += 24 * days;\n+            days = 0;\n+        }\n+        if (!Token.containsTokenWithValue(tokens, H)) {\n+            minutes += 60 * hours;\n+            hours = 0;\n+        }\n+        if (!Token.containsTokenWithValue(tokens, m)) {\n+            seconds += 60 * minutes;\n+            minutes = 0;\n+        }\n+        if (!Token.containsTokenWithValue(tokens, s)) {\n+            milliseconds += 1000 * seconds;\n+            seconds = 0;\n+        }\n+\n+        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>The internal method to do the formatting.</p>\n+     * \n+     * @param tokens  the tokens\n+     * @param years  the number of years\n+     * @param months  the number of months\n+     * @param days  the number of days\n+     * @param hours  the number of hours\n+     * @param minutes  the number of minutes\n+     * @param seconds  the number of seconds\n+     * @param milliseconds  the number of millis\n+     * @param padWithZeros  whether to pad\n+     * @return the formatted string\n+     */\n+    static String format(Token[] tokens, int years, int months, int days, int hours, int minutes, int seconds,\n+            int milliseconds, boolean padWithZeros) {\n+        StringBuffer buffer = new StringBuffer();\n+        boolean lastOutputSeconds = false;\n+        int sz = tokens.length;\n+        for (int i = 0; i < sz; i++) {\n+            Token token = tokens[i];\n+            Object value = token.getValue();\n+            int count = token.getCount();\n+            if (value instanceof StringBuffer) {\n+                buffer.append(value.toString());\n+            } else {\n+                if (value == y) {\n+                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer\n+                            .toString(years));\n+                    lastOutputSeconds = false;\n+                } else if (value == M) {\n+                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer\n+                            .toString(months));\n+                    lastOutputSeconds = false;\n+                } else if (value == d) {\n+                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer\n+                            .toString(days));\n+                    lastOutputSeconds = false;\n+                } else if (value == H) {\n+                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer\n+                            .toString(hours));\n+                    lastOutputSeconds = false;\n+                } else if (value == m) {\n+                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer\n+                            .toString(minutes));\n+                    lastOutputSeconds = false;\n+                } else if (value == s) {\n+                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer\n+                            .toString(seconds));\n+                    lastOutputSeconds = true;\n+                } else if (value == S) {\n+                    if (lastOutputSeconds) {\n+                        milliseconds += 1000;\n+                        String str = padWithZeros\n+                                ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')\n+                                : Integer.toString(milliseconds);\n+                        buffer.append(str.substring(1));\n+                    } else {\n+                        buffer.append(padWithZeros\n+                                ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')\n+                                : Integer.toString(milliseconds));\n+                    }\n+                    lastOutputSeconds = false;\n+                }\n+            }\n+        }\n+        return buffer.toString();\n+    }\n+\n+    static final Object y = \"y\";\n+    static final Object M = \"M\";\n+    static final Object d = \"d\";\n+    static final Object H = \"H\";\n+    static final Object m = \"m\";\n+    static final Object s = \"s\";\n+    static final Object S = \"S\";\n+    \n+    /**\n+     * Parses a classic date format string into Tokens\n+     *\n+     * @param format to parse\n+     * @return array of Token[]\n+     */\n+    static Token[] lexx(String format) {\n+        char[] array = format.toCharArray();\n+        ArrayList<Token> list = new ArrayList<Token>(array.length);\n+\n+        boolean inLiteral = false;\n+        StringBuffer buffer = null;\n+        Token previous = null;\n+        int sz = array.length;\n+        for(int i=0; i<sz; i++) {\n+            char ch = array[i];\n+            if(inLiteral && ch != '\\'') {\n+                buffer.append(ch); // buffer can't be null if inLiteral is true\n+                continue;\n+            }\n+            Object value = null;\n+            switch(ch) {\n+                // TODO: Need to handle escaping of '\n+                case '\\'' : \n+                  if(inLiteral) {\n+                      buffer = null;\n+                      inLiteral = false;\n+                  } else {\n+                      buffer = new StringBuffer();\n+                      list.add(new Token(buffer));\n+                      inLiteral = true;\n+                  }\n+                  break;\n+                case 'y'  : value = y; break;\n+                case 'M'  : value = M; break;\n+                case 'd'  : value = d; break;\n+                case 'H'  : value = H; break;\n+                case 'm'  : value = m; break;\n+                case 's'  : value = s; break;\n+                case 'S'  : value = S; break;\n+                default   : \n+                  if(buffer == null) {\n+                      buffer = new StringBuffer();\n+                      list.add(new Token(buffer));\n+                  }\n+                  buffer.append(ch);\n+            }\n+\n+            if(value != null) {\n+                if(previous != null && previous.getValue() == value) {\n+                    previous.increment();\n+                } else {\n+                    Token token = new Token(value);\n+                    list.add(token); \n+                    previous = token;\n+                }\n+                buffer = null; \n+            }\n+        }\n+        return list.toArray( new Token[list.size()] );\n+    }\n+\n+    /**\n+     * Element that is parsed from the format pattern.\n+     */\n+    static class Token {\n+\n+        /**\n+         * Helper method to determine if a set of tokens contain a value\n+         *\n+         * @param tokens set to look in\n+         * @param value to look for\n+         * @return boolean <code>true</code> if contained\n+         */\n+        static boolean containsTokenWithValue(Token[] tokens, Object value) {\n+            int sz = tokens.length;\n+            for (int i = 0; i < sz; i++) {\n+                if (tokens[i].getValue() == value) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        private Object value;\n+        private int count;\n+\n+        /**\n+         * Wraps a token around a value. A value would be something like a 'Y'.\n+         *\n+         * @param value to wrap\n+         */\n+        Token(Object value) {\n+            this.value = value;\n+            this.count = 1;\n+        }\n+\n+        /**\n+         * Wraps a token around a repeated number of a value, for example it would \n+         * store 'yyyy' as a value for y and a count of 4.\n+         *\n+         * @param value to wrap\n+         * @param count to wrap\n+         */\n+        Token(Object value, int count) {\n+            this.value = value;\n+            this.count = count;\n+        }\n+\n+        /**\n+         * Adds another one of the value\n+         */\n+        void increment() { \n+            count++;\n+        }\n+\n+        /**\n+         * Gets the current number of values represented\n+         *\n+         * @return int number of values represented\n+         */\n+        int getCount() {\n+            return count;\n+        }\n+\n+        /**\n+         * Gets the particular value this token represents.\n+         * \n+         * @return Object value\n+         */\n+        Object getValue() {\n+            return value;\n+        }\n+\n+        /**\n+         * Supports equality of this Token to another Token.\n+         *\n+         * @param obj2 Object to consider equality of\n+         * @return boolean <code>true</code> if equal\n+         */\n+        @Override\n+        public boolean equals(Object obj2) {\n+            if (obj2 instanceof Token) {\n+                Token tok2 = (Token) obj2;\n+                if (this.value.getClass() != tok2.value.getClass()) {\n+                    return false;\n+                }\n+                if (this.count != tok2.count) {\n+                    return false;\n+                }\n+                if (this.value instanceof StringBuffer) {\n+                    return this.value.toString().equals(tok2.value.toString());\n+                } else if (this.value instanceof Number) {\n+                    return this.value.equals(tok2.value);\n+                } else {\n+                    return this.value == tok2.value;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        /**\n+         * Returns a hashcode for the token equal to the \n+         * hashcode for the token's value. Thus 'TT' and 'TTTT' \n+         * will have the same hashcode. \n+         *\n+         * @return The hashcode for the token\n+         */\n+        @Override\n+        public int hashCode() {\n+            return this.value.hashCode();\n+        }\n+\n+        /**\n+         * Represents this token as a String.\n+         *\n+         * @return String representation of the token\n+         */\n+        @Override\n+        public String toString() {\n+            return StringUtils.repeat(this.value.toString(), this.count);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.time;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.text.DateFormat;\n+import java.text.DateFormatSymbols;\n+import java.text.FieldPosition;\n+import java.text.Format;\n+import java.text.ParsePosition;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.TimeZone;\n+\n+import org.apache.commons.lang3.Validate;\n+\n+/**\n+ * <p>FastDateFormat is a fast and thread-safe version of\n+ * {@link java.text.SimpleDateFormat}.</p>\n+ * \n+ * <p>This class can be used as a direct replacement to\n+ * <code>SimpleDateFormat</code> in most formatting situations.\n+ * This class is especially useful in multi-threaded server environments.\n+ * <code>SimpleDateFormat</code> is not thread-safe in any JDK version,\n+ * nor will it be as Sun have closed the bug/RFE.\n+ * </p>\n+ *\n+ * <p>Only formatting is supported, but all patterns are compatible with\n+ * SimpleDateFormat (except time zones - see below).</p>\n+ *\n+ * <p>Java 1.4 introduced a new pattern letter, <code>'Z'</code>, to represent\n+ * time zones in RFC822 format (eg. <code>+0800</code> or <code>-1100</code>).\n+ * This pattern letter can be used here (on all JDK versions).</p>\n+ *\n+ * <p>In addition, the pattern <code>'ZZ'</code> has been made to represent\n+ * ISO8601 full format time zones (eg. <code>+08:00</code> or <code>-11:00</code>).\n+ * This introduces a minor incompatibility with Java 1.4, but at a gain of\n+ * useful functionality.</p>\n+ *\n+ * @author Apache Software Foundation\n+ * @author TeaTrove project\n+ * @author Brian S O'Neill\n+ * @author Sean Schofield\n+ * @author Gary Gregory\n+ * @author Nikolay Metchev\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class FastDateFormat extends Format {\n+    // A lot of the speed in this class comes from caching, but some comes\n+    // from the special int to StringBuffer conversion.\n+    //\n+    // The following produces a padded 2 digit number:\n+    //   buffer.append((char)(value / 10 + '0'));\n+    //   buffer.append((char)(value % 10 + '0'));\n+    //\n+    // Note that the fastest append to StringBuffer is a single char (used here).\n+    // Note that Integer.toString() is not called, the conversion is simply\n+    // taking the value and adding (mathematically) the ASCII value for '0'.\n+    // So, don't change this code! It works and is very fast.\n+    \n+    /**\n+     * Required for serialization support.\n+     * \n+     * @see java.io.Serializable\n+     */\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * FULL locale dependent date or time style.\n+     */\n+    public static final int FULL = DateFormat.FULL;\n+    /**\n+     * LONG locale dependent date or time style.\n+     */\n+    public static final int LONG = DateFormat.LONG;\n+    /**\n+     * MEDIUM locale dependent date or time style.\n+     */\n+    public static final int MEDIUM = DateFormat.MEDIUM;\n+    /**\n+     * SHORT locale dependent date or time style.\n+     */\n+    public static final int SHORT = DateFormat.SHORT;\n+    \n+    //@GuardedBy(\"this\")\n+    private static String cDefaultPattern; // lazily initialised by getInstance()\n+\n+    private static final Map<FastDateFormat, FastDateFormat> cInstanceCache = new HashMap<FastDateFormat, FastDateFormat>(7);\n+    private static final Map<Object, FastDateFormat> cDateInstanceCache = new HashMap<Object, FastDateFormat>(7);\n+    private static final Map<Object, FastDateFormat> cTimeInstanceCache = new HashMap<Object, FastDateFormat>(7);\n+    private static final Map<Object, FastDateFormat> cDateTimeInstanceCache = new HashMap<Object, FastDateFormat>(7);\n+    private static final Map<Object, String> cTimeZoneDisplayCache = new HashMap<Object, String>(7);\n+\n+    /**\n+     * The pattern.\n+     */\n+    private final String mPattern;\n+    /**\n+     * The time zone.\n+     */\n+    private final TimeZone mTimeZone;\n+    /**\n+     * Whether the time zone overrides any on Calendars.\n+     */\n+    private final boolean mTimeZoneForced;\n+    /**\n+     * The locale.\n+     */\n+    private final Locale mLocale;\n+    /**\n+     * Whether the locale overrides the default.\n+     */\n+    private final boolean mLocaleForced;\n+    /**\n+     * The parsed rules.\n+     */\n+    private transient Rule[] mRules;\n+    /**\n+     * The estimated maximum length.\n+     */\n+    private transient int mMaxLengthEstimate;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets a formatter instance using the default pattern in the\n+     * default locale.</p>\n+     * \n+     * @return a date/time formatter\n+     */\n+    public static FastDateFormat getInstance() {\n+        return getInstance(getDefaultPattern(), null, null);\n+    }\n+\n+    /**\n+     * <p>Gets a formatter instance using the specified pattern in the\n+     * default locale.</p>\n+     * \n+     * @param pattern  {@link java.text.SimpleDateFormat} compatible\n+     *  pattern\n+     * @return a pattern based date/time formatter\n+     * @throws IllegalArgumentException if pattern is invalid\n+     */\n+    public static FastDateFormat getInstance(String pattern) {\n+        return getInstance(pattern, null, null);\n+    }\n+\n+    /**\n+     * <p>Gets a formatter instance using the specified pattern and\n+     * time zone.</p>\n+     * \n+     * @param pattern  {@link java.text.SimpleDateFormat} compatible\n+     *  pattern\n+     * @param timeZone  optional time zone, overrides time zone of\n+     *  formatted date\n+     * @return a pattern based date/time formatter\n+     * @throws IllegalArgumentException if pattern is invalid\n+     */\n+    public static FastDateFormat getInstance(String pattern, TimeZone timeZone) {\n+        return getInstance(pattern, timeZone, null);\n+    }\n+\n+    /**\n+     * <p>Gets a formatter instance using the specified pattern and\n+     * locale.</p>\n+     * \n+     * @param pattern  {@link java.text.SimpleDateFormat} compatible\n+     *  pattern\n+     * @param locale  optional locale, overrides system locale\n+     * @return a pattern based date/time formatter\n+     * @throws IllegalArgumentException if pattern is invalid\n+     */\n+    public static FastDateFormat getInstance(String pattern, Locale locale) {\n+        return getInstance(pattern, null, locale);\n+    }\n+\n+    /**\n+     * <p>Gets a formatter instance using the specified pattern, time zone\n+     * and locale.</p>\n+     * \n+     * @param pattern  {@link java.text.SimpleDateFormat} compatible\n+     *  pattern\n+     * @param timeZone  optional time zone, overrides time zone of\n+     *  formatted date\n+     * @param locale  optional locale, overrides system locale\n+     * @return a pattern based date/time formatter\n+     * @throws IllegalArgumentException if pattern is invalid\n+     *  or <code>null</code>\n+     */\n+    public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {\n+        FastDateFormat emptyFormat = new FastDateFormat(pattern, timeZone, locale);\n+        FastDateFormat format = cInstanceCache.get(emptyFormat);\n+        if (format == null) {\n+            format = emptyFormat;\n+            format.init();  // convert shell format into usable one\n+            cInstanceCache.put(format, format);  // this is OK!\n+        }\n+        return format;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets a date formatter instance using the specified style in the\n+     * default time zone and locale.</p>\n+     * \n+     * @param style  date style: FULL, LONG, MEDIUM, or SHORT\n+     * @return a localized standard date formatter\n+     * @throws IllegalArgumentException if the Locale has no date\n+     *  pattern defined\n+     * @since 2.1\n+     */\n+    public static FastDateFormat getDateInstance(int style) {\n+        return getDateInstance(style, null, null);\n+    }\n+\n+    /**\n+     * <p>Gets a date formatter instance using the specified style and\n+     * locale in the default time zone.</p>\n+     * \n+     * @param style  date style: FULL, LONG, MEDIUM, or SHORT\n+     * @param locale  optional locale, overrides system locale\n+     * @return a localized standard date formatter\n+     * @throws IllegalArgumentException if the Locale has no date\n+     *  pattern defined\n+     * @since 2.1\n+     */\n+    public static FastDateFormat getDateInstance(int style, Locale locale) {\n+        return getDateInstance(style, null, locale);\n+    }\n+\n+    /**\n+     * <p>Gets a date formatter instance using the specified style and\n+     * time zone in the default locale.</p>\n+     * \n+     * @param style  date style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeZone  optional time zone, overrides time zone of\n+     *  formatted date\n+     * @return a localized standard date formatter\n+     * @throws IllegalArgumentException if the Locale has no date\n+     *  pattern defined\n+     * @since 2.1\n+     */\n+    public static FastDateFormat getDateInstance(int style, TimeZone timeZone) {\n+        return getDateInstance(style, timeZone, null);\n+    }\n+    /**\n+     * <p>Gets a date formatter instance using the specified style, time\n+     * zone and locale.</p>\n+     * \n+     * @param style  date style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeZone  optional time zone, overrides time zone of\n+     *  formatted date\n+     * @param locale  optional locale, overrides system locale\n+     * @return a localized standard date formatter\n+     * @throws IllegalArgumentException if the Locale has no date\n+     *  pattern defined\n+     */\n+    public static synchronized FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) {\n+        Object key = Integer.valueOf(style);\n+        if (timeZone != null) {\n+            key = new Pair(key, timeZone);\n+        }\n+\n+        if (locale == null) {\n+            locale = Locale.getDefault();\n+        }\n+\n+        key = new Pair(key, locale);\n+\n+        FastDateFormat format = cDateInstanceCache.get(key);\n+        if (format == null) {\n+            try {\n+                SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);\n+                String pattern = formatter.toPattern();\n+                format = getInstance(pattern, timeZone, locale);\n+                cDateInstanceCache.put(key, format);\n+                \n+            } catch (ClassCastException ex) {\n+                throw new IllegalArgumentException(\"No date pattern for locale: \" + locale);\n+            }\n+        }\n+        return format;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets a time formatter instance using the specified style in the\n+     * default time zone and locale.</p>\n+     * \n+     * @param style  time style: FULL, LONG, MEDIUM, or SHORT\n+     * @return a localized standard time formatter\n+     * @throws IllegalArgumentException if the Locale has no time\n+     *  pattern defined\n+     * @since 2.1\n+     */\n+    public static FastDateFormat getTimeInstance(int style) {\n+        return getTimeInstance(style, null, null);\n+    }\n+\n+    /**\n+     * <p>Gets a time formatter instance using the specified style and\n+     * locale in the default time zone.</p>\n+     * \n+     * @param style  time style: FULL, LONG, MEDIUM, or SHORT\n+     * @param locale  optional locale, overrides system locale\n+     * @return a localized standard time formatter\n+     * @throws IllegalArgumentException if the Locale has no time\n+     *  pattern defined\n+     * @since 2.1\n+     */\n+    public static FastDateFormat getTimeInstance(int style, Locale locale) {\n+        return getTimeInstance(style, null, locale);\n+    }\n+    \n+    /**\n+     * <p>Gets a time formatter instance using the specified style and\n+     * time zone in the default locale.</p>\n+     * \n+     * @param style  time style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeZone  optional time zone, overrides time zone of\n+     *  formatted time\n+     * @return a localized standard time formatter\n+     * @throws IllegalArgumentException if the Locale has no time\n+     *  pattern defined\n+     * @since 2.1\n+     */\n+    public static FastDateFormat getTimeInstance(int style, TimeZone timeZone) {\n+        return getTimeInstance(style, timeZone, null);\n+    }\n+    \n+    /**\n+     * <p>Gets a time formatter instance using the specified style, time\n+     * zone and locale.</p>\n+     * \n+     * @param style  time style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeZone  optional time zone, overrides time zone of\n+     *  formatted time\n+     * @param locale  optional locale, overrides system locale\n+     * @return a localized standard time formatter\n+     * @throws IllegalArgumentException if the Locale has no time\n+     *  pattern defined\n+     */\n+    public static synchronized FastDateFormat getTimeInstance(int style, TimeZone timeZone, Locale locale) {\n+        Object key = Integer.valueOf(style);\n+        if (timeZone != null) {\n+            key = new Pair(key, timeZone);\n+        }\n+        if (locale != null) {\n+            key = new Pair(key, locale);\n+        }\n+\n+        FastDateFormat format = cTimeInstanceCache.get(key);\n+        if (format == null) {\n+            if (locale == null) {\n+                locale = Locale.getDefault();\n+            }\n+\n+            try {\n+                SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getTimeInstance(style, locale);\n+                String pattern = formatter.toPattern();\n+                format = getInstance(pattern, timeZone, locale);\n+                cTimeInstanceCache.put(key, format);\n+            \n+            } catch (ClassCastException ex) {\n+                throw new IllegalArgumentException(\"No date pattern for locale: \" + locale);\n+            }\n+        }\n+        return format;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets a date/time formatter instance using the specified style\n+     * in the default time zone and locale.</p>\n+     * \n+     * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT\n+     * @return a localized standard date/time formatter\n+     * @throws IllegalArgumentException if the Locale has no date/time\n+     *  pattern defined\n+     * @since 2.1\n+     */\n+    public static FastDateFormat getDateTimeInstance(\n+            int dateStyle, int timeStyle) {\n+        return getDateTimeInstance(dateStyle, timeStyle, null, null);\n+    }\n+    \n+    /**\n+     * <p>Gets a date/time formatter instance using the specified style and\n+     * locale in the default time zone.</p>\n+     * \n+     * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT\n+     * @param locale  optional locale, overrides system locale\n+     * @return a localized standard date/time formatter\n+     * @throws IllegalArgumentException if the Locale has no date/time\n+     *  pattern defined\n+     * @since 2.1\n+     */\n+    public static FastDateFormat getDateTimeInstance(\n+            int dateStyle, int timeStyle, Locale locale) {\n+        return getDateTimeInstance(dateStyle, timeStyle, null, locale);\n+    }\n+    \n+    /**\n+     * <p>Gets a date/time formatter instance using the specified style and\n+     * time zone in the default locale.</p>\n+     * \n+     * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeZone  optional time zone, overrides time zone of\n+     *  formatted date\n+     * @return a localized standard date/time formatter\n+     * @throws IllegalArgumentException if the Locale has no date/time\n+     *  pattern defined\n+     * @since 2.1\n+     */\n+    public static FastDateFormat getDateTimeInstance(\n+            int dateStyle, int timeStyle, TimeZone timeZone) {\n+        return getDateTimeInstance(dateStyle, timeStyle, timeZone, null);\n+    }    \n+    /**\n+     * <p>Gets a date/time formatter instance using the specified style,\n+     * time zone and locale.</p>\n+     * \n+     * @param dateStyle  date style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeStyle  time style: FULL, LONG, MEDIUM, or SHORT\n+     * @param timeZone  optional time zone, overrides time zone of\n+     *  formatted date\n+     * @param locale  optional locale, overrides system locale\n+     * @return a localized standard date/time formatter\n+     * @throws IllegalArgumentException if the Locale has no date/time\n+     *  pattern defined\n+     */\n+    public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone,\n+            Locale locale) {\n+\n+        Object key = new Pair(Integer.valueOf(dateStyle), Integer.valueOf(timeStyle));\n+        if (timeZone != null) {\n+            key = new Pair(key, timeZone);\n+        }\n+        if (locale == null) {\n+            locale = Locale.getDefault();\n+        }\n+        key = new Pair(key, locale);\n+\n+        FastDateFormat format = cDateTimeInstanceCache.get(key);\n+        if (format == null) {\n+            try {\n+                SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle,\n+                        locale);\n+                String pattern = formatter.toPattern();\n+                format = getInstance(pattern, timeZone, locale);\n+                cDateTimeInstanceCache.put(key, format);\n+\n+            } catch (ClassCastException ex) {\n+                throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n+            }\n+        }\n+        return format;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the time zone display name, using a cache for performance.</p>\n+     * \n+     * @param tz  the zone to query\n+     * @param daylight  true if daylight savings\n+     * @param style  the style to use <code>TimeZone.LONG</code>\n+     *  or <code>TimeZone.SHORT</code>\n+     * @param locale  the locale to use\n+     * @return the textual name of the time zone\n+     */\n+    static synchronized String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Locale locale) {\n+        Object key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n+        String value = cTimeZoneDisplayCache.get(key);\n+        if (value == null) {\n+            // This is a very slow call, so cache the results.\n+            value = tz.getDisplayName(daylight, style, locale);\n+            cTimeZoneDisplayCache.put(key, value);\n+        }\n+        return value;\n+    }\n+\n+    /**\n+     * <p>Gets the default pattern.</p>\n+     * \n+     * @return the default pattern\n+     */\n+    private static synchronized String getDefaultPattern() {\n+        if (cDefaultPattern == null) {\n+            cDefaultPattern = new SimpleDateFormat().toPattern();\n+        }\n+        return cDefaultPattern;\n+    }\n+\n+    // Constructor\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Constructs a new FastDateFormat.</p>\n+     * \n+     * @param pattern  {@link java.text.SimpleDateFormat} compatible\n+     *  pattern\n+     * @param timeZone  time zone to use, <code>null</code> means use\n+     *  default for <code>Date</code> and value within for\n+     *  <code>Calendar</code>\n+     * @param locale  locale, <code>null</code> means use system\n+     *  default\n+     * @throws IllegalArgumentException if pattern is invalid or\n+     *  <code>null</code>\n+     */\n+    protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale) {\n+        super();\n+        if (pattern == null) {\n+            throw new IllegalArgumentException(\"The pattern must not be null\");\n+        }\n+        mPattern = pattern;\n+        \n+        mTimeZoneForced = (timeZone != null);\n+        if (timeZone == null) {\n+            timeZone = TimeZone.getDefault();\n+        }\n+        mTimeZone = timeZone;\n+        \n+        mLocaleForced = (locale != null);\n+        if (locale == null) {\n+            locale = Locale.getDefault();\n+        }\n+        mLocale = locale;\n+    }\n+\n+    /**\n+     * <p>Initializes the instance for first use.</p>\n+     */\n+    protected void init() {\n+        List<Rule> rulesList = parsePattern();\n+        mRules = rulesList.toArray(new Rule[rulesList.size()]);\n+\n+        int len = 0;\n+        for (int i=mRules.length; --i >= 0; ) {\n+            len += mRules[i].estimateLength();\n+        }\n+\n+        mMaxLengthEstimate = len;\n+    }\n+\n+    // Parse the pattern\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Returns a list of Rules given a pattern.</p>\n+     * \n+     * @return a <code>List</code> of Rule objects\n+     * @throws IllegalArgumentException if pattern is invalid\n+     */\n+    protected List<Rule> parsePattern() {\n+        DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n+        List<Rule> rules = new ArrayList<Rule>();\n+\n+        String[] ERAs = symbols.getEras();\n+        String[] months = symbols.getMonths();\n+        String[] shortMonths = symbols.getShortMonths();\n+        String[] weekdays = symbols.getWeekdays();\n+        String[] shortWeekdays = symbols.getShortWeekdays();\n+        String[] AmPmStrings = symbols.getAmPmStrings();\n+\n+        int length = mPattern.length();\n+        int[] indexRef = new int[1];\n+\n+        for (int i = 0; i < length; i++) {\n+            indexRef[0] = i;\n+            String token = parseToken(mPattern, indexRef);\n+            i = indexRef[0];\n+\n+            int tokenLen = token.length();\n+            if (tokenLen == 0) {\n+                break;\n+            }\n+\n+            Rule rule;\n+            char c = token.charAt(0);\n+\n+            switch (c) {\n+            case 'G': // era designator (text)\n+                rule = new TextField(Calendar.ERA, ERAs);\n+                break;\n+            case 'y': // year (number)\n+                if (tokenLen >= 4) {\n+                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n+                } else {\n+                    rule = TwoDigitYearField.INSTANCE;\n+                }\n+                break;\n+            case 'M': // month in year (text and number)\n+                if (tokenLen >= 4) {\n+                    rule = new TextField(Calendar.MONTH, months);\n+                } else if (tokenLen == 3) {\n+                    rule = new TextField(Calendar.MONTH, shortMonths);\n+                } else if (tokenLen == 2) {\n+                    rule = TwoDigitMonthField.INSTANCE;\n+                } else {\n+                    rule = UnpaddedMonthField.INSTANCE;\n+                }\n+                break;\n+            case 'd': // day in month (number)\n+                rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\n+                break;\n+            case 'h': // hour in am/pm (number, 1..12)\n+                rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\n+                break;\n+            case 'H': // hour in day (number, 0..23)\n+                rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\n+                break;\n+            case 'm': // minute in hour (number)\n+                rule = selectNumberRule(Calendar.MINUTE, tokenLen);\n+                break;\n+            case 's': // second in minute (number)\n+                rule = selectNumberRule(Calendar.SECOND, tokenLen);\n+                break;\n+            case 'S': // millisecond (number)\n+                rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\n+                break;\n+            case 'E': // day in week (text)\n+                rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\n+                break;\n+            case 'D': // day in year (number)\n+                rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\n+                break;\n+            case 'F': // day of week in month (number)\n+                rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\n+                break;\n+            case 'w': // week in year (number)\n+                rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\n+                break;\n+            case 'W': // week in month (number)\n+                rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\n+                break;\n+            case 'a': // am/pm marker (text)\n+                rule = new TextField(Calendar.AM_PM, AmPmStrings);\n+                break;\n+            case 'k': // hour in day (1..24)\n+                rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\n+                break;\n+            case 'K': // hour in am/pm (0..11)\n+                rule = selectNumberRule(Calendar.HOUR, tokenLen);\n+                break;\n+            case 'z': // time zone (text)\n+                if (tokenLen >= 4) {\n+                    rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.LONG);\n+                } else {\n+                    rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.SHORT);\n+                }\n+                break;\n+            case 'Z': // time zone (value)\n+                if (tokenLen == 1) {\n+                    rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n+                } else {\n+                    rule = TimeZoneNumberRule.INSTANCE_COLON;\n+                }\n+                break;\n+            case '\\'': // literal text\n+                String sub = token.substring(1);\n+                if (sub.length() == 1) {\n+                    rule = new CharacterLiteral(sub.charAt(0));\n+                } else {\n+                    rule = new StringLiteral(sub);\n+                }\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n+            }\n+\n+            rules.add(rule);\n+        }\n+\n+        return rules;\n+    }\n+\n+    /**\n+     * <p>Performs the parsing of tokens.</p>\n+     * \n+     * @param pattern  the pattern\n+     * @param indexRef  index references\n+     * @return parsed token\n+     */\n+    protected String parseToken(String pattern, int[] indexRef) {\n+        StringBuilder buf = new StringBuilder();\n+\n+        int i = indexRef[0];\n+        int length = pattern.length();\n+\n+        char c = pattern.charAt(i);\n+        if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n+            // Scan a run of the same character, which indicates a time\n+            // pattern.\n+            buf.append(c);\n+\n+            while (i + 1 < length) {\n+                char peek = pattern.charAt(i + 1);\n+                if (peek == c) {\n+                    buf.append(c);\n+                    i++;\n+                } else {\n+                    break;\n+                }\n+            }\n+        } else {\n+            // This will identify token as text.\n+            buf.append('\\'');\n+\n+            boolean inLiteral = false;\n+\n+            for (; i < length; i++) {\n+                c = pattern.charAt(i);\n+\n+                if (c == '\\'') {\n+                    if (i + 1 < length && pattern.charAt(i + 1) == '\\'') {\n+                        // '' is treated as escaped '\n+                        i++;\n+                        buf.append(c);\n+                    } else {\n+                        inLiteral = !inLiteral;\n+                    }\n+                } else if (!inLiteral &&\n+                         (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {\n+                    i--;\n+                    break;\n+                } else {\n+                    buf.append(c);\n+                }\n+            }\n+        }\n+\n+        indexRef[0] = i;\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * <p>Gets an appropriate rule for the padding required.</p>\n+     * \n+     * @param field  the field to get a rule for\n+     * @param padding  the padding required\n+     * @return a new rule with the correct padding\n+     */\n+    protected NumberRule selectNumberRule(int field, int padding) {\n+        switch (padding) {\n+        case 1:\n+            return new UnpaddedNumberField(field);\n+        case 2:\n+            return new TwoDigitNumberField(field);\n+        default:\n+            return new PaddedNumberField(field, padding);\n+        }\n+    }\n+\n+    // Format methods\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Formats a <code>Date</code>, <code>Calendar</code> or\n+     * <code>Long</code> (milliseconds) object.</p>\n+     * \n+     * @param obj  the object to format\n+     * @param toAppendTo  the buffer to append to\n+     * @param pos  the position - ignored\n+     * @return the buffer passed in\n+     */\n+    @Override\n+    public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n+        if (obj instanceof Date) {\n+            return format((Date) obj, toAppendTo);\n+        } else if (obj instanceof Calendar) {\n+            return format((Calendar) obj, toAppendTo);\n+        } else if (obj instanceof Long) {\n+            return format(((Long) obj).longValue(), toAppendTo);\n+        } else {\n+            throw new IllegalArgumentException(\"Unknown class: \" +\n+                (obj == null ? \"<null>\" : obj.getClass().getName()));\n+        }\n+    }\n+\n+    /**\n+     * <p>Formats a millisecond <code>long</code> value.</p>\n+     * \n+     * @param millis  the millisecond value to format\n+     * @return the formatted string\n+     * @since 2.1\n+     */\n+    public String format(long millis) {\n+        return format(new Date(millis));\n+    }\n+\n+    /**\n+     * <p>Formats a <code>Date</code> object.</p>\n+     * \n+     * @param date  the date to format\n+     * @return the formatted string\n+     */\n+    public String format(Date date) {\n+        Calendar c = new GregorianCalendar(mTimeZone);\n+        c.setTime(date);\n+        return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n+    }\n+\n+    /**\n+     * <p>Formats a <code>Calendar</code> object.</p>\n+     * \n+     * @param calendar  the calendar to format\n+     * @return the formatted string\n+     */\n+    public String format(Calendar calendar) {\n+        return format(calendar, new StringBuffer(mMaxLengthEstimate)).toString();\n+    }\n+\n+    /**\n+     * <p>Formats a milliseond <code>long</code> value into the\n+     * supplied <code>StringBuffer</code>.</p>\n+     * \n+     * @param millis  the millisecond value to format\n+     * @param buf  the buffer to format into\n+     * @return the specified string buffer\n+     * @since 2.1\n+     */\n+    public StringBuffer format(long millis, StringBuffer buf) {\n+        return format(new Date(millis), buf);\n+    }\n+\n+    /**\n+     * <p>Formats a <code>Date</code> object into the\n+     * supplied <code>StringBuffer</code>.</p>\n+     * \n+     * @param date  the date to format\n+     * @param buf  the buffer to format into\n+     * @return the specified string buffer\n+     */\n+    public StringBuffer format(Date date, StringBuffer buf) {\n+        Calendar c = new GregorianCalendar(mTimeZone);\n+        c.setTime(date);\n+        return applyRules(c, buf);\n+    }\n+\n+    /**\n+     * <p>Formats a <code>Calendar</code> object into the\n+     * supplied <code>StringBuffer</code>.</p>\n+     * \n+     * @param calendar  the calendar to format\n+     * @param buf  the buffer to format into\n+     * @return the specified string buffer\n+     */\n+    public StringBuffer format(Calendar calendar, StringBuffer buf) {\n+        if (mTimeZoneForced) {\n+            calendar.getTimeInMillis(); /// LANG-538\n+            calendar = (Calendar) calendar.clone();\n+            calendar.setTimeZone(mTimeZone);\n+        }\n+        return applyRules(calendar, buf);\n+    }\n+\n+    /**\n+     * <p>Performs the formatting by applying the rules to the\n+     * specified calendar.</p>\n+     * \n+     * @param calendar  the calendar to format\n+     * @param buf  the buffer to format into\n+     * @return the specified string buffer\n+     */\n+    protected StringBuffer applyRules(Calendar calendar, StringBuffer buf) {\n+        Rule[] rules = mRules;\n+        int len = mRules.length;\n+        for (int i = 0; i < len; i++) {\n+            rules[i].appendTo(buf, calendar);\n+        }\n+        return buf;\n+    }\n+\n+    // Parsing\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Parsing is not supported.</p>\n+     * \n+     * @param source  the string to parse\n+     * @param pos  the parsing position\n+     * @return <code>null</code> as not supported\n+     */\n+    @Override\n+    public Object parseObject(String source, ParsePosition pos) {\n+        pos.setIndex(0);\n+        pos.setErrorIndex(0);\n+        return null;\n+    }\n+    \n+    // Accessors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Gets the pattern used by this formatter.</p>\n+     * \n+     * @return the pattern, {@link java.text.SimpleDateFormat} compatible\n+     */\n+    public String getPattern() {\n+        return mPattern;\n+    }\n+\n+    /**\n+     * <p>Gets the time zone used by this formatter.</p>\n+     *\n+     * <p>This zone is always used for <code>Date</code> formatting.\n+     * If a <code>Calendar</code> is passed in to be formatted, the\n+     * time zone on that may be used depending on\n+     * {@link #getTimeZoneOverridesCalendar()}.</p>\n+     * \n+     * @return the time zone\n+     */\n+    public TimeZone getTimeZone() {\n+        return mTimeZone;\n+    }\n+\n+    /**\n+     * <p>Returns <code>true</code> if the time zone of the\n+     * calendar overrides the time zone of the formatter.</p>\n+     * \n+     * @return <code>true</code> if time zone of formatter\n+     *  overridden for calendars\n+     */\n+    public boolean getTimeZoneOverridesCalendar() {\n+        return mTimeZoneForced;\n+    }\n+\n+    /**\n+     * <p>Gets the locale used by this formatter.</p>\n+     * \n+     * @return the locale\n+     */\n+    public Locale getLocale() {\n+        return mLocale;\n+    }\n+\n+    /**\n+     * <p>Gets an estimate for the maximum string length that the\n+     * formatter will produce.</p>\n+     *\n+     * <p>The actual formatted length will almost always be less than or\n+     * equal to this amount.</p>\n+     * \n+     * @return the maximum formatted length\n+     */\n+    public int getMaxLengthEstimate() {\n+        return mMaxLengthEstimate;\n+    }\n+\n+    // Basics\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Compares two objects for equality.</p>\n+     * \n+     * @param obj  the object to compare to\n+     * @return <code>true</code> if equal\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof FastDateFormat == false) {\n+            return false;\n+        }\n+        FastDateFormat other = (FastDateFormat) obj;\n+        if (\n+            (mPattern == other.mPattern || mPattern.equals(other.mPattern)) &&\n+            (mTimeZone == other.mTimeZone || mTimeZone.equals(other.mTimeZone)) &&\n+            (mLocale == other.mLocale || mLocale.equals(other.mLocale)) &&\n+            (mTimeZoneForced == other.mTimeZoneForced) &&\n+            (mLocaleForced == other.mLocaleForced)\n+            ) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * <p>Returns a hashcode compatible with equals.</p>\n+     * \n+     * @return a hashcode compatible with equals\n+     */\n+    @Override\n+    public int hashCode() {\n+        int total = 0;\n+        total += mPattern.hashCode();\n+        total += mTimeZone.hashCode();\n+        total += (mTimeZoneForced ? 1 : 0);\n+        total += mLocale.hashCode();\n+        total += (mLocaleForced ? 1 : 0);\n+        return total;\n+    }\n+\n+    /**\n+     * <p>Gets a debugging string version of this formatter.</p>\n+     * \n+     * @return a debugging string\n+     */\n+    @Override\n+    public String toString() {\n+        return \"FastDateFormat[\" + mPattern + \"]\";\n+    }\n+\n+    // Serializing\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Create the object after serialization. This implementation reinitializes the \n+     * transient properties.\n+     *\n+     * @param in ObjectInputStream from which the object is being deserialized.\n+     * @throws IOException if there is an IO issue.\n+     * @throws ClassNotFoundException if a class cannot be found.\n+     */\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        init();\n+    }\n+    \n+    // Rules\n+    //-----------------------------------------------------------------------\n+    /**\n+     * <p>Inner class defining a rule.</p>\n+     */\n+    private interface Rule {\n+        /**\n+         * Returns the estimated lentgh of the result.\n+         * \n+         * @return the estimated length\n+         */\n+        int estimateLength();\n+        \n+        /**\n+         * Appends the value of the specified calendar to the output buffer based on the rule implementation.\n+         * \n+         * @param buffer the output buffer\n+         * @param calendar calendar to be appended\n+         */\n+        void appendTo(StringBuffer buffer, Calendar calendar);\n+    }\n+\n+    /**\n+     * <p>Inner class defining a numeric rule.</p>\n+     */\n+    private interface NumberRule extends Rule {\n+        /**\n+         * Appends the specified value to the output buffer based on the rule implementation.\n+         * \n+         * @param buffer the output buffer\n+         * @param value the value to be appended\n+         */\n+        void appendTo(StringBuffer buffer, int value);\n+    }\n+\n+    /**\n+     * <p>Inner class to output a constant single character.</p>\n+     */\n+    private static class CharacterLiteral implements Rule {\n+        private final char mValue;\n+\n+        /**\n+         * Constructs a new instance of <code>CharacterLiteral</code>\n+         * to hold the specified value.\n+         * \n+         * @param value the character literal\n+         */\n+        CharacterLiteral(char value) {\n+            mValue = value;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return 1;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            buffer.append(mValue);\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output a constant string.</p>\n+     */\n+    private static class StringLiteral implements Rule {\n+        private final String mValue;\n+\n+        /**\n+         * Constructs a new instance of <code>StringLiteral</code>\n+         * to hold the specified value.\n+         * \n+         * @param value the string literal\n+         */\n+        StringLiteral(String value) {\n+            mValue = value;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return mValue.length();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            buffer.append(mValue);\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output one of a set of values.</p>\n+     */\n+    private static class TextField implements Rule {\n+        private final int mField;\n+        private final String[] mValues;\n+\n+        /**\n+         * Constructs an instance of <code>TextField</code>\n+         * with the specified field and values.\n+         * \n+         * @param field the field\n+         * @param values the field values\n+         */\n+        TextField(int field, String[] values) {\n+            mField = field;\n+            mValues = values;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            int max = 0;\n+            for (int i=mValues.length; --i >= 0; ) {\n+                int len = mValues[i].length();\n+                if (len > max) {\n+                    max = len;\n+                }\n+            }\n+            return max;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            buffer.append(mValues[calendar.get(mField)]);\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output an unpadded number.</p>\n+     */\n+    private static class UnpaddedNumberField implements NumberRule {\n+        private final int mField;\n+\n+        /**\n+         * Constructs an instance of <code>UnpadedNumberField</code> with the specified field.\n+         * \n+         * @param field the field\n+         */\n+        UnpaddedNumberField(int field) {\n+            mField = field;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return 4;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            appendTo(buffer, calendar.get(mField));\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public final void appendTo(StringBuffer buffer, int value) {\n+            if (value < 10) {\n+                buffer.append((char)(value + '0'));\n+            } else if (value < 100) {\n+                buffer.append((char)(value / 10 + '0'));\n+                buffer.append((char)(value % 10 + '0'));\n+            } else {\n+                buffer.append(Integer.toString(value));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output an unpadded month.</p>\n+     */\n+    private static class UnpaddedMonthField implements NumberRule {\n+        static final UnpaddedMonthField INSTANCE = new UnpaddedMonthField();\n+\n+        /**\n+         * Constructs an instance of <code>UnpaddedMonthField</code>.\n+         *\n+         */\n+        UnpaddedMonthField() {\n+            super();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return 2;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            appendTo(buffer, calendar.get(Calendar.MONTH) + 1);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public final void appendTo(StringBuffer buffer, int value) {\n+            if (value < 10) {\n+                buffer.append((char)(value + '0'));\n+            } else {\n+                buffer.append((char)(value / 10 + '0'));\n+                buffer.append((char)(value % 10 + '0'));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output a padded number.</p>\n+     */\n+    private static class PaddedNumberField implements NumberRule {\n+        private final int mField;\n+        private final int mSize;\n+\n+        /**\n+         * Constructs an instance of <code>PaddedNumberField</code>.\n+         * \n+         * @param field the field\n+         * @param size size of the output field\n+         */\n+        PaddedNumberField(int field, int size) {\n+            if (size < 3) {\n+                // Should use UnpaddedNumberField or TwoDigitNumberField.\n+                throw new IllegalArgumentException();\n+            }\n+            mField = field;\n+            mSize = size;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return 4;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            appendTo(buffer, calendar.get(mField));\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public final void appendTo(StringBuffer buffer, int value) {\n+            if (value < 100) {\n+                for (int i = mSize; --i >= 2; ) {\n+                    buffer.append('0');\n+                }\n+                buffer.append((char)(value / 10 + '0'));\n+                buffer.append((char)(value % 10 + '0'));\n+            } else {\n+                int digits;\n+                if (value < 1000) {\n+                    digits = 3;\n+                } else {\n+                    Validate.isTrue(value > -1, \"Negative values should not be possible\", value);\n+                    digits = Integer.toString(value).length();\n+                }\n+                for (int i = mSize; --i >= digits; ) {\n+                    buffer.append('0');\n+                }\n+                buffer.append(Integer.toString(value));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output a two digit number.</p>\n+     */\n+    private static class TwoDigitNumberField implements NumberRule {\n+        private final int mField;\n+\n+        /**\n+         * Constructs an instance of <code>TwoDigitNumberField</code> with the specified field.\n+         * \n+         * @param field the field\n+         */\n+        TwoDigitNumberField(int field) {\n+            mField = field;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return 2;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            appendTo(buffer, calendar.get(mField));\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public final void appendTo(StringBuffer buffer, int value) {\n+            if (value < 100) {\n+                buffer.append((char)(value / 10 + '0'));\n+                buffer.append((char)(value % 10 + '0'));\n+            } else {\n+                buffer.append(Integer.toString(value));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output a two digit year.</p>\n+     */\n+    private static class TwoDigitYearField implements NumberRule {\n+        static final TwoDigitYearField INSTANCE = new TwoDigitYearField();\n+\n+        /**\n+         * Constructs an instance of <code>TwoDigitYearField</code>.\n+         */\n+        TwoDigitYearField() {\n+            super();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return 2;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            appendTo(buffer, calendar.get(Calendar.YEAR) % 100);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public final void appendTo(StringBuffer buffer, int value) {\n+            buffer.append((char)(value / 10 + '0'));\n+            buffer.append((char)(value % 10 + '0'));\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output a two digit month.</p>\n+     */\n+    private static class TwoDigitMonthField implements NumberRule {\n+        static final TwoDigitMonthField INSTANCE = new TwoDigitMonthField();\n+\n+        /**\n+         * Constructs an instance of <code>TwoDigitMonthField</code>.\n+         */\n+        TwoDigitMonthField() {\n+            super();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return 2;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            appendTo(buffer, calendar.get(Calendar.MONTH) + 1);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public final void appendTo(StringBuffer buffer, int value) {\n+            buffer.append((char)(value / 10 + '0'));\n+            buffer.append((char)(value % 10 + '0'));\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output the twelve hour field.</p>\n+     */\n+    private static class TwelveHourField implements NumberRule {\n+        private final NumberRule mRule;\n+\n+        /**\n+         * Constructs an instance of <code>TwelveHourField</code> with the specified\n+         * <code>NumberRule</code>.\n+         * \n+         * @param rule the rule\n+         */\n+        TwelveHourField(NumberRule rule) {\n+            mRule = rule;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return mRule.estimateLength();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            int value = calendar.get(Calendar.HOUR);\n+            if (value == 0) {\n+                value = calendar.getLeastMaximum(Calendar.HOUR) + 1;\n+            }\n+            mRule.appendTo(buffer, value);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, int value) {\n+            mRule.appendTo(buffer, value);\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output the twenty four hour field.</p>\n+     */\n+    private static class TwentyFourHourField implements NumberRule {\n+        private final NumberRule mRule;\n+\n+        /**\n+         * Constructs an instance of <code>TwentyFourHourField</code> with the specified\n+         * <code>NumberRule</code>.\n+         * \n+         * @param rule the rule\n+         */\n+        TwentyFourHourField(NumberRule rule) {\n+            mRule = rule;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return mRule.estimateLength();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            int value = calendar.get(Calendar.HOUR_OF_DAY);\n+            if (value == 0) {\n+                value = calendar.getMaximum(Calendar.HOUR_OF_DAY) + 1;\n+            }\n+            mRule.appendTo(buffer, value);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, int value) {\n+            mRule.appendTo(buffer, value);\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output a time zone name.</p>\n+     */\n+    private static class TimeZoneNameRule implements Rule {\n+        private final TimeZone mTimeZone;\n+        private final boolean mTimeZoneForced;\n+        private final Locale mLocale;\n+        private final int mStyle;\n+        private final String mStandard;\n+        private final String mDaylight;\n+\n+        /**\n+         * Constructs an instance of <code>TimeZoneNameRule</code> with the specified properties.\n+         * \n+         * @param timeZone the time zone\n+         * @param timeZoneForced if <code>true</code> the time zone is forced into standard and daylight\n+         * @param locale the locale\n+         * @param style the style\n+         */\n+        TimeZoneNameRule(TimeZone timeZone, boolean timeZoneForced, Locale locale, int style) {\n+            mTimeZone = timeZone;\n+            mTimeZoneForced = timeZoneForced;\n+            mLocale = locale;\n+            mStyle = style;\n+\n+            if (timeZoneForced) {\n+                mStandard = getTimeZoneDisplay(timeZone, false, style, locale);\n+                mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);\n+            } else {\n+                mStandard = null;\n+                mDaylight = null;\n+            }\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            if (mTimeZoneForced) {\n+                return Math.max(mStandard.length(), mDaylight.length());\n+            } else if (mStyle == TimeZone.SHORT) {\n+                return 4;\n+            } else {\n+                return 40;\n+            }\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            if (mTimeZoneForced) {\n+                if (mTimeZone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) {\n+                    buffer.append(mDaylight);\n+                } else {\n+                    buffer.append(mStandard);\n+                }\n+            } else {\n+                TimeZone timeZone = calendar.getTimeZone();\n+                if (timeZone.useDaylightTime() && calendar.get(Calendar.DST_OFFSET) != 0) {\n+                    buffer.append(getTimeZoneDisplay(timeZone, true, mStyle, mLocale));\n+                } else {\n+                    buffer.append(getTimeZoneDisplay(timeZone, false, mStyle, mLocale));\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * <p>Inner class to output a time zone as a number <code>+/-HHMM</code>\n+     * or <code>+/-HH:MM</code>.</p>\n+     */\n+    private static class TimeZoneNumberRule implements Rule {\n+        static final TimeZoneNumberRule INSTANCE_COLON = new TimeZoneNumberRule(true);\n+        static final TimeZoneNumberRule INSTANCE_NO_COLON = new TimeZoneNumberRule(false);\n+        \n+        final boolean mColon;\n+        \n+        /**\n+         * Constructs an instance of <code>TimeZoneNumberRule</code> with the specified properties.\n+         * \n+         * @param colon add colon between HH and MM in the output if <code>true</code>\n+         */\n+        TimeZoneNumberRule(boolean colon) {\n+            mColon = colon;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public int estimateLength() {\n+            return 5;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void appendTo(StringBuffer buffer, Calendar calendar) {\n+            int offset = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);\n+            \n+            if (offset < 0) {\n+                buffer.append('-');\n+                offset = -offset;\n+            } else {\n+                buffer.append('+');\n+            }\n+            \n+            int hours = offset / (60 * 60 * 1000);\n+            buffer.append((char)(hours / 10 + '0'));\n+            buffer.append((char)(hours % 10 + '0'));\n+            \n+            if (mColon) {\n+                buffer.append(':');\n+            }\n+            \n+            int minutes = offset / (60 * 1000) - 60 * hours;\n+            buffer.append((char)(minutes / 10 + '0'));\n+            buffer.append((char)(minutes % 10 + '0'));\n+        }            \n+    }\n+\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Inner class that acts as a compound key for time zone names.</p>\n+     */\n+    private static class TimeZoneDisplayKey {\n+        private final TimeZone mTimeZone;\n+        private final int mStyle;\n+        private final Locale mLocale;\n+\n+        /**\n+         * Constructs an instance of <code>TimeZoneDisplayKey</code> with the specified properties.\n+         *  \n+         * @param timeZone the time zone\n+         * @param daylight adjust the style for daylight saving time if <code>true</code>\n+         * @param style the timezone style\n+         * @param locale the timezone locale\n+         */\n+        TimeZoneDisplayKey(TimeZone timeZone,\n+                           boolean daylight, int style, Locale locale) {\n+            mTimeZone = timeZone;\n+            if (daylight) {\n+                style |= 0x80000000;\n+            }\n+            mStyle = style;\n+            mLocale = locale;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public int hashCode() {\n+            return mStyle * 31 + mLocale.hashCode();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if (obj instanceof TimeZoneDisplayKey) {\n+                TimeZoneDisplayKey other = (TimeZoneDisplayKey)obj;\n+                return\n+                    mTimeZone.equals(other.mTimeZone) &&\n+                    mStyle == other.mStyle &&\n+                    mLocale.equals(other.mLocale);\n+            }\n+            return false;\n+        }\n+    }\n+\n+    // ----------------------------------------------------------------------\n+    /**\n+     * <p>Helper class for creating compound objects.</p>\n+     *\n+     * <p>One use for this class is to create a hashtable key\n+     * out of multiple objects.</p>\n+     */\n+    private static class Pair {\n+        private final Object mObj1;\n+        private final Object mObj2;\n+\n+        /**\n+         * Constructs an instance of <code>Pair</code> to hold the specified objects.\n+         * @param obj1 one object in the pair\n+         * @param obj2 second object in the pair\n+         */\n+        public Pair(Object obj1, Object obj2) {\n+            mObj1 = obj1;\n+            mObj2 = obj2;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+\n+            if (!(obj instanceof Pair)) {\n+                return false;\n+            }\n+\n+            Pair key = (Pair)obj;\n+\n+            return\n+                (mObj1 == null ?\n+                 key.mObj1 == null : mObj1.equals(key.mObj1)) &&\n+                (mObj2 == null ?\n+                 key.mObj2 == null : mObj2.equals(key.mObj2));\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public int hashCode() {\n+            return\n+                (mObj1 == null ? 0 : mObj1.hashCode()) +\n+                (mObj2 == null ? 0 : mObj2.hashCode());\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public String toString() {\n+            return \"[\" + mObj1 + ':' + mObj2 + ']';\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/time/StopWatch.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang3.time;\n+\n+/**\n+ * <p>\n+ * <code>StopWatch</code> provides a convenient API for timings.\n+ * </p>\n+ * \n+ * <p>\n+ * To start the watch, call {@link #start()}. At this point you can:\n+ * </p>\n+ * <ul>\n+ * <li>{@link #split()} the watch to get the time whilst the watch continues in the background. {@link #unsplit()} will\n+ * remove the effect of the split. At this point, these three options are available again.</li>\n+ * <li>{@link #suspend()} the watch to pause it. {@link #resume()} allows the watch to continue. Any time between the\n+ * suspend and resume will not be counted in the total. At this point, these three options are available again.</li>\n+ * <li>{@link #stop()} the watch to complete the timing session.</li>\n+ * </ul>\n+ * \n+ * <p>\n+ * It is intended that the output methods {@link #toString()} and {@link #getTime()} should only be called after stop,\n+ * split or suspend, however a suitable result will be returned at other points.\n+ * </p>\n+ * \n+ * <p>\n+ * NOTE: As from v2.1, the methods protect against inappropriate calls. Thus you cannot now call stop before start,\n+ * resume before suspend or unsplit before split.\n+ * </p>\n+ * \n+ * <p>\n+ * 1. split(), suspend(), or stop() cannot be invoked twice<br />\n+ * 2. unsplit() may only be called if the watch has been split()<br />\n+ * 3. resume() may only be called if the watch has been suspend()<br />\n+ * 4. start() cannot be called twice without calling reset()\n+ * </p>\n+ * \n+ * @author Apache Software Foundation\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class StopWatch {\n+\n+    private static final long NANO_2_MILLIS = 1000000L;\n+\n+    // running states\n+    private static final int STATE_UNSTARTED = 0;\n+\n+    private static final int STATE_RUNNING = 1;\n+\n+    private static final int STATE_STOPPED = 2;\n+\n+    private static final int STATE_SUSPENDED = 3;\n+\n+    // split state\n+    private static final int STATE_UNSPLIT = 10;\n+\n+    private static final int STATE_SPLIT = 11;\n+\n+    /**\n+     * The current running state of the StopWatch.\n+     */\n+    private int runningState = STATE_UNSTARTED;\n+\n+    /**\n+     * Whether the stopwatch has a split time recorded.\n+     */\n+    private int splitState = STATE_UNSPLIT;\n+\n+    /**\n+     * The start time.\n+     */\n+    private long startTime;\n+\n+    /**\n+     * The start time in Millis - nanoTime is only for elapsed time so we \n+     * need to also store the currentTimeMillis to maintain the old \n+     * getStartTime API.\n+     */\n+    private long startTimeMillis;\n+\n+    /**\n+     * The stop time.\n+     */\n+    private long stopTime;\n+\n+    /**\n+     * <p>\n+     * Constructor.\n+     * </p>\n+     */\n+    public StopWatch() {\n+        super();\n+    }\n+\n+    /**\n+     * <p>\n+     * Start the stopwatch.\n+     * </p>\n+     * \n+     * <p>\n+     * This method starts a new timing session, clearing any previous values.\n+     * </p>\n+     * \n+     * @throws IllegalStateException\n+     *             if the StopWatch is already running.\n+     */\n+    public void start() {\n+        if (this.runningState == STATE_STOPPED) {\n+            throw new IllegalStateException(\"Stopwatch must be reset before being restarted. \");\n+        }\n+        if (this.runningState != STATE_UNSTARTED) {\n+            throw new IllegalStateException(\"Stopwatch already started. \");\n+        }\n+        this.startTime = System.nanoTime();\n+        this.startTimeMillis = System.currentTimeMillis();\n+        this.runningState = STATE_RUNNING;\n+    }\n+\n+    /**\n+     * <p>\n+     * Stop the stopwatch.\n+     * </p>\n+     * \n+     * <p>\n+     * This method ends a new timing session, allowing the time to be retrieved.\n+     * </p>\n+     * \n+     * @throws IllegalStateException\n+     *             if the StopWatch is not running.\n+     */\n+    public void stop() {\n+        if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n+            throw new IllegalStateException(\"Stopwatch is not running. \");\n+        }\n+        if (this.runningState == STATE_RUNNING) {\n+            this.stopTime = System.nanoTime();\n+        }\n+        this.runningState = STATE_STOPPED;\n+    }\n+\n+    /**\n+     * <p>\n+     * Resets the stopwatch. Stops it if need be.\n+     * </p>\n+     * \n+     * <p>\n+     * This method clears the internal values to allow the object to be reused.\n+     * </p>\n+     */\n+    public void reset() {\n+        this.runningState = STATE_UNSTARTED;\n+        this.splitState = STATE_UNSPLIT;\n+    }\n+\n+    /**\n+     * <p>\n+     * Split the time.\n+     * </p>\n+     * \n+     * <p>\n+     * This method sets the stop time of the watch to allow a time to be extracted. The start time is unaffected,\n+     * enabling {@link #unsplit()} to continue the timing from the original start point.\n+     * </p>\n+     * \n+     * @throws IllegalStateException\n+     *             if the StopWatch is not running.\n+     */\n+    public void split() {\n+        if (this.runningState != STATE_RUNNING) {\n+            throw new IllegalStateException(\"Stopwatch is not running. \");\n+        }\n+        this.stopTime = System.nanoTime();\n+        this.splitState = STATE_SPLIT;\n+    }\n+\n+    /**\n+     * <p>\n+     * Remove a split.\n+     * </p>\n+     * \n+     * <p>\n+     * This method clears the stop time. The start time is unaffected, enabling timing from the original start point to\n+     * continue.\n+     * </p>\n+     * \n+     * @throws IllegalStateException\n+     *             if the StopWatch has not been split.\n+     */\n+    public void unsplit() {\n+        if (this.splitState != STATE_SPLIT) {\n+            throw new IllegalStateException(\"Stopwatch has not been split. \");\n+        }\n+        this.splitState = STATE_UNSPLIT;\n+    }\n+\n+    /**\n+     * <p>\n+     * Suspend the stopwatch for later resumption.\n+     * </p>\n+     * \n+     * <p>\n+     * This method suspends the watch until it is resumed. The watch will not include time between the suspend and\n+     * resume calls in the total time.\n+     * </p>\n+     * \n+     * @throws IllegalStateException\n+     *             if the StopWatch is not currently running.\n+     */\n+    public void suspend() {\n+        if (this.runningState != STATE_RUNNING) {\n+            throw new IllegalStateException(\"Stopwatch must be running to suspend. \");\n+        }\n+        this.stopTime = System.nanoTime();\n+        this.runningState = STATE_SUSPENDED;\n+    }\n+\n+    /**\n+     * <p>\n+     * Resume the stopwatch after a suspend.\n+     * </p>\n+     * \n+     * <p>\n+     * This method resumes the watch after it was suspended. The watch will not include time between the suspend and\n+     * resume calls in the total time.\n+     * </p>\n+     * \n+     * @throws IllegalStateException\n+     *             if the StopWatch has not been suspended.\n+     */\n+    public void resume() {\n+        if (this.runningState != STATE_SUSPENDED) {\n+            throw new IllegalStateException(\"Stopwatch must be suspended to resume. \");\n+        }\n+        this.startTime += (System.nanoTime() - this.stopTime);\n+        this.runningState = STATE_RUNNING;\n+    }\n+\n+    /**\n+     * <p>\n+     * Get the time on the stopwatch.\n+     * </p>\n+     * \n+     * <p>\n+     * This is either the time between the start and the moment this method is called, or the amount of time between\n+     * start and stop.\n+     * </p>\n+     * \n+     * @return the time in milliseconds\n+     */\n+    public long getTime() {\n+        return getNanoTime() / NANO_2_MILLIS;\n+    }\n+    /**\n+     * <p>\n+     * Get the time on the stopwatch in nanoseconds.\n+     * </p>\n+     * \n+     * <p>\n+     * This is either the time between the start and the moment this method is called, or the amount of time between\n+     * start and stop.\n+     * </p>\n+     * \n+     * @return the time in nanoseconds\n+     * @since 3.0\n+     */\n+    public long getNanoTime() {\n+        if (this.runningState == STATE_STOPPED || this.runningState == STATE_SUSPENDED) {\n+            return this.stopTime - this.startTime;\n+        } else if (this.runningState == STATE_UNSTARTED) {\n+            return 0;\n+        } else if (this.runningState == STATE_RUNNING) {\n+            return System.nanoTime() - this.startTime;\n+        }\n+        throw new RuntimeException(\"Illegal running state has occured. \");\n+    }\n+\n+    /**\n+     * <p>\n+     * Get the split time on the stopwatch.\n+     * </p>\n+     * \n+     * <p>\n+     * This is the time between start and latest split.\n+     * </p>\n+     * \n+     * @return the split time in milliseconds\n+     * \n+     * @throws IllegalStateException\n+     *             if the StopWatch has not yet been split.\n+     * @since 2.1\n+     */\n+    public long getSplitTime() {\n+        return getSplitNanoTime() / NANO_2_MILLIS;\n+    }\n+    /**\n+     * <p>\n+     * Get the split time on the stopwatch in nanoseconds.\n+     * </p>\n+     * \n+     * <p>\n+     * This is the time between start and latest split.\n+     * </p>\n+     * \n+     * @return the split time in nanoseconds\n+     * \n+     * @throws IllegalStateException\n+     *             if the StopWatch has not yet been split.\n+     * @since 3.0\n+     */\n+    public long getSplitNanoTime() {\n+        if (this.splitState != STATE_SPLIT) {\n+            throw new IllegalStateException(\"Stopwatch must be split to get the split time. \");\n+        }\n+        return this.stopTime - this.startTime;\n+    }\n+\n+    /**\n+     * Returns the time this stopwatch was started.\n+     * \n+     * @return the time this stopwatch was started\n+     * @throws IllegalStateException\n+     *             if this StopWatch has not been started\n+     * @since 2.4\n+     */\n+    public long getStartTime() {\n+        if (this.runningState == STATE_UNSTARTED) {\n+            throw new IllegalStateException(\"Stopwatch has not been started\");\n+        }\n+        // System.nanoTime is for elapsed time\n+        return this.startTimeMillis;\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets a summary of the time that the stopwatch recorded as a string.\n+     * </p>\n+     * \n+     * <p>\n+     * The format used is ISO8601-like, <i>hours</i>:<i>minutes</i>:<i>seconds</i>.<i>milliseconds</i>.\n+     * </p>\n+     * \n+     * @return the time as a String\n+     */\n+    @Override\n+    public String toString() {\n+        return DurationFormatUtils.formatDurationHMS(getTime());\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets a summary of the split time that the stopwatch recorded as a string.\n+     * </p>\n+     * \n+     * <p>\n+     * The format used is ISO8601-like, <i>hours</i>:<i>minutes</i>:<i>seconds</i>.<i>milliseconds</i>.\n+     * </p>\n+     * \n+     * @return the split time as a String\n+     * @since 2.1\n+     */\n+    public String toSplitString() {\n+        return DurationFormatUtils.formatDurationHMS(getSplitTime());\n+    }\n+\n+}", "timestamp": 1262484686, "metainfo": ""}