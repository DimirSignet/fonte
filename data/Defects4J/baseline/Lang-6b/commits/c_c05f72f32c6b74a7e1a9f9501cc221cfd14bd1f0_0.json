{"sha": "c05f72f32c6b74a7e1a9f9501cc221cfd14bd1f0", "log": "LANG-816 - followup incorporating ggregory's doc suggestion, some doc fixes, addition of CONST_BYTE() and CONST_SHORT(), and Junit improvements to test doc examples and make sure CONST_BYTE() and CONST_SHORT() throw IllegalArgumentException as required.  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/ObjectUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/ObjectUtils.java\n      * This can prevent javac from inlining a constant\n      * field, e.g.,\n      *\n-     *  public final static boolean MAGIC_FLAG = CONST(true);\n+     * <pre>\n+     *     public final static boolean MAGIC_FLAG = ObjectUtils.CONST(true);\n+     * </pre>\n      *\n      * This way any jars that refer to this field do not\n      * have to recompile themselves if the field's value\n      * This can prevent javac from inlining a constant\n      * field, e.g.,\n      *\n-     *  public final static byte MAGIC_BYTE = CONST(127);\n+     * <pre>\n+     *     public final static byte MAGIC_BYTE = ObjectUtils.CONST((byte) 127);\n+     * </pre>\n      *\n      * This way any jars that refer to this field do not\n      * have to recompile themselves if the field's value\n      * This can prevent javac from inlining a constant\n      * field, e.g.,\n      *\n-     *  public final static byte MAGIC_CHAR = CONST('a');\n+     * <pre>\n+     *     public final static byte MAGIC_BYTE = ObjectUtils.CONST_BYTE(127);\n+     * </pre>\n+     *\n+     * This way any jars that refer to this field do not\n+     * have to recompile themselves if the field's value\n+     * changes at some future date.\n+     *\n+     * @param v the byte literal (as an int) value to return\n+     * @throws IllegalArgumentException if the value passed to v\n+     *         is larger than a byte, that is, smaller than -128 or\n+     *         larger than 127.\n+     * @return the byte v, unchanged\n+     */\n+    public static byte CONST_BYTE(final int v) throws IllegalArgumentException {\n+        if (v < Byte.MIN_VALUE || v > Byte.MAX_VALUE) {\n+            throw new IllegalArgumentException(\"Supplied value must be a valid byte literal between -128 and 127: [\" + v + \"]\");\n+        }\n+        return (byte) v;\n+    }\n+\n+    /**\n+     * This method returns the provided value unchanged.\n+     * This can prevent javac from inlining a constant\n+     * field, e.g.,\n+     *\n+     * <pre>\n+     *     public final static char MAGIC_CHAR = ObjectUtils.CONST('a');\n+     * </pre>\n      *\n      * This way any jars that refer to this field do not\n      * have to recompile themselves if the field's value\n      * This can prevent javac from inlining a constant\n      * field, e.g.,\n      *\n-     *  public final static byte MAGIC_SHORT = CONST(123);\n+     * <pre>\n+     *     public final static short MAGIC_SHORT = ObjectUtils.CONST((short) 123);\n+     * </pre>\n      *\n      * This way any jars that refer to this field do not\n      * have to recompile themselves if the field's value\n      * This can prevent javac from inlining a constant\n      * field, e.g.,\n      *\n-     *  public final static byte MAGIC_INT = CONST(123);\n+     * <pre>\n+     *     public final static short MAGIC_SHORT = ObjectUtils.CONST_SHORT(127);\n+     * </pre>\n+     *\n+     * This way any jars that refer to this field do not\n+     * have to recompile themselves if the field's value\n+     * changes at some future date.\n+     *\n+     * @param v the short literal (as an int) value to return\n+     * @throws IllegalArgumentException if the value passed to v\n+     *         is larger than a short, that is, smaller than -32768 or\n+     *         larger than 32767.\n+     * @return the byte v, unchanged\n+     */\n+    public static short CONST_SHORT(final int v) throws IllegalArgumentException {\n+        if (v < Short.MIN_VALUE || v > Short.MAX_VALUE) {\n+            throw new IllegalArgumentException(\"Supplied value must be a valid byte literal between -32768 and 32767: [\" + v + \"]\");\n+        }\n+        return (short) v;\n+    }\n+\n+\n+    /**\n+     * This method returns the provided value unchanged.\n+     * This can prevent javac from inlining a constant\n+     * field, e.g.,\n+     *\n+     * <pre>\n+     *     public final static int MAGIC_INT = ObjectUtils.CONST(123);\n+     * </pre>\n      *\n      * This way any jars that refer to this field do not\n      * have to recompile themselves if the field's value\n      * This can prevent javac from inlining a constant\n      * field, e.g.,\n      *\n-     *  public final static byte MAGIC_LONG = CONST(123L);\n+     * <pre>\n+     *     public final static long MAGIC_LONG = ObjectUtils.CONST(123L);\n+     * </pre>\n      *\n      * This way any jars that refer to this field do not\n      * have to recompile themselves if the field's value\n      * This can prevent javac from inlining a constant\n      * field, e.g.,\n      *\n-     *  public final static byte MAGIC_FLOAT = CONST(1.0f);\n+     * <pre>\n+     *     public final static float MAGIC_FLOAT = ObjectUtils.CONST(1.0f);\n+     * </pre>\n      *\n      * This way any jars that refer to this field do not\n      * have to recompile themselves if the field's value\n      * This can prevent javac from inlining a constant\n      * field, e.g.,\n      *\n-     *  public final static byte MAGIC_DOUBLE = CONST(1.0);\n+     * <pre>\n+     *     public final static double MAGIC_DOUBLE = ObjectUtils.CONST(1.0);\n+     * </pre>\n      *\n      * This way any jars that refer to this field do not\n      * have to recompile themselves if the field's value\n      * This can prevent javac from inlining a constant\n      * field, e.g.,\n      *\n-     *  public final static byte MAGIC_STRING = CONST(\"abc\");\n+     * <pre>\n+     *     public final static String MAGIC_STRING = ObjectUtils.CONST(\"abc\");\n+     * </pre>\n      *\n      * This way any jars that refer to this field do not\n      * have to recompile themselves if the field's value\n--- a/src/test/java/org/apache/commons/lang3/ObjectUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/ObjectUtilsTest.java\n         assertEquals(\"CONST(float)\", 3f, ObjectUtils.CONST(3f), 0);\n         assertEquals(\"CONST(double)\", 3.0, ObjectUtils.CONST(3.0), 0);\n         assertEquals(\"CONST(Object)\", \"abc\", ObjectUtils.CONST(\"abc\"));\n+\n+        // Make sure documentation examples from Javadoc all work\n+        // (this fixed a lot of my bugs when I these!)\n+        //\n+        // My bugs should be in a software engineering textbook\n+        // for \"Can you screw this up?\"  The answer is, yes,\n+        // you can even screw this up.  (When you == Julius)\n+        // .\n+        boolean MAGIC_FLAG = ObjectUtils.CONST(true);\n+        byte MAGIC_BYTE1 = ObjectUtils.CONST((byte) 127);\n+        byte MAGIC_BYTE2 = ObjectUtils.CONST_BYTE(127);\n+        char MAGIC_CHAR = ObjectUtils.CONST('a');\n+        short MAGIC_SHORT1 = ObjectUtils.CONST((short) 123);\n+        short MAGIC_SHORT2 = ObjectUtils.CONST_SHORT(127);\n+        int MAGIC_INT = ObjectUtils.CONST(123);\n+        long MAGIC_LONG1 = ObjectUtils.CONST(123L);\n+        long MAGIC_LONG2 = ObjectUtils.CONST(3);\n+        float MAGIC_FLOAT = ObjectUtils.CONST(1.0f);\n+        double MAGIC_DOUBLE = ObjectUtils.CONST(1.0);\n+        String MAGIC_STRING = ObjectUtils.CONST(\"abc\");\n+\n+        assertEquals(true, MAGIC_FLAG);\n+        assertEquals(127, MAGIC_BYTE1);\n+        assertEquals(127, MAGIC_BYTE2);\n+        assertEquals('a', MAGIC_CHAR);\n+        assertEquals(123, MAGIC_SHORT1);\n+        assertEquals(127, MAGIC_SHORT2);\n+        assertEquals(123, MAGIC_INT);\n+        assertEquals(123, MAGIC_LONG1);\n+        assertEquals(3, MAGIC_LONG2);\n+        assertEquals(1.0f, MAGIC_FLOAT, 0.0f);\n+        assertEquals(1.0, MAGIC_DOUBLE, 0.0);\n+        assertEquals(\"abc\", MAGIC_STRING);\n+\n+        try {\n+            ObjectUtils.CONST_BYTE(-129);\n+            fail(\"CONST_BYTE(-129): IllegalArgumentException should have been thrown.\");\n+        } catch (IllegalArgumentException iae) {\n+\n+        }\n+        try {\n+            ObjectUtils.CONST_BYTE(128);\n+            fail(\"CONST_BYTE(128): IllegalArgumentException should have been thrown.\");\n+        } catch (IllegalArgumentException iae) {\n+\n+        }\n+        try {\n+            ObjectUtils.CONST_SHORT(-32769);\n+            fail(\"CONST_SHORT(-32769): IllegalArgumentException should have been thrown.\");\n+        } catch (IllegalArgumentException iae) {\n+\n+        }\n+        try {\n+            ObjectUtils.CONST_BYTE(32768);\n+            fail(\"CONST_SHORT(32768): IllegalArgumentException should have been thrown.\");\n+        } catch (IllegalArgumentException iae) {\n+\n+        }\n+\n     }\n \n     /**", "timestamp": 1345785875, "metainfo": ""}