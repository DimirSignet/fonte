{"sha": "87880f2a63ffe6288b1e89d14c2eb8a6da1cbfb5", "log": "Add support for static field output.  Main points:   (1)  Deprecate in ReflectionToStringBuilder:  public static String toString(Object object, ToStringStyle style, boolean outputTransients, boolean outputStatics)  In favor of:  public static String toString(Object object, ToStringStyle style, boolean outputTransients, boolean outputStatics, Class reflectUpToClass)  (2) New convenience methods ReflectionToStringBuilder.toStringWithStatics.   ", "commit": "\n--- a/src/java/org/apache/commons/lang/builder/ReflectionToStringBuilder.java\n+++ b/src/java/org/apache/commons/lang/builder/ReflectionToStringBuilder.java\n  * @author Stephen Colebourne\n  * @author Pete Gieser\n  * @since 2.0\n- * @version $Id: ReflectionToStringBuilder.java,v 1.11 2003/09/07 14:32:34 psteitz Exp $\n+ * @version $Id: ReflectionToStringBuilder.java,v 1.12 2003/10/23 22:25:16 ggregory Exp $\n  */\n public class ReflectionToStringBuilder extends ToStringBuilder {\n \n      */\n     private static ThreadLocal registry = new ThreadLocal() {\n         protected synchronized Object initialValue() {\n-            // The HashSet implementation is not synchronized, \n-            // which is just what we need here. \n-            return new HashSet();\n+                // The HashSet implementation is not synchronized, \n+        // which is just what we need here. \n+    return new HashSet();\n         }\n     };\n \n     static void register(Object value) {\n         getRegistry().add(value);\n     }\n-    \n+\n     /**\n      * <p>This method uses reflection to build a suitable\n      * <code>toString</code> using the default <code>ToStringStyle</code>.\n      * @throws IllegalArgumentException if the Object is <code>null</code>\n      */\n     public static String toString(Object object) {\n-        return toString(object, null, false, null);\n+        return toString(object, null, false, false, null);\n     }\n \n     /**\n      *  <code>ToStringStyle</code> is <code>null</code>\n      */\n     public static String toString(Object object, ToStringStyle style) {\n-        return toString(object, style, false, null);\n+        return toString(object, style, false, false, null);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the Object is <code>null</code>\n      */\n     public static String toString(Object object, ToStringStyle style, boolean outputTransients) {\n-        return toString(object, style, outputTransients, null);\n+        return toString(object, style, outputTransients, false, null);\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to build a suitable\n+     * <code>toString</code>.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run\n+     * under a security manager, if the permissions are not set up correctly.\n+     * It is also not as efficient as testing explicitly.</p>\n+     *\n+     * <p>If the <code>outputTransients</code> is <code>true</code>,\n+     * transient fields will be output, otherwise they are ignored,\n+     * as they are likely derived fields, and not part of the value of the\n+     * Object.</p>\n+     *\n+     * <p>If the <code>outputStatics</code> is <code>true</code>,\n+     * static fields will be output, otherwise they are ignored.</p>\n+     *\n+     * <p>Static fields will not be included. Superclass fields will be appended.</p>\n+     *\n+     * <p>If the style is <code>null</code>, the default\n+     * <code>ToStringStyle</code> is used.</p>\n+     * \n+     * @param object  the Object to be output\n+     * @param style  the style of the <code>toString</code> to create,\n+     *  may be <code>null</code>\n+     * @param outputTransients  whether to include transient fields\n+     * @param outputStatics  whether to include transient fields\n+     * @return the String result\n+     * @throws IllegalArgumentException if the Object is <code>null</code>\n+     */\n+    public static String toString(Object object, ToStringStyle style, boolean outputTransients, boolean outputStatics) {\n+        return toString(object, style, outputTransients, outputStatics, null);\n+    }\n+\n+    /**\n+     * <p>This method uses reflection to build a suitable\n+     * <code>toString</code>.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run\n+     * under a security manager, if the permissions are not set up correctly.\n+     * It is also not as efficient as testing explicitly. </p>\n+     *\n+     * <p>If the <code>outputTransients</code> is <code>true</code>,\n+     * transient fields will be output, otherwise they are ignored,\n+     * as they are likely derived fields, and not part of the value of the\n+     * Object.</p>\n+     *\n+     * <p>If the <code>outputStatics</code> is <code>true</code>,\n+     * static fields will be output, otherwise they are ignored.</p>\n+     *\n+     * <p>Superclass fields will be appended up to and including the \n+     * specified superclass. A null superclass is treated as \n+     * <code>java.lang.Object</code>.</p>\n+     *\n+     * <p>If the style is <code>null</code>, the default\n+     * <code>ToStringStyle</code> is used.</p>\n+     * \n+     * @param object  the Object to be output\n+     * @param style  the style of the <code>toString</code> to create,\n+     *  may be <code>null</code>\n+     * @param outputTransients  whether to include transient fields\n+     * @param outputStatics  whether to include static fields\n+     * @param reflectUpToClass  the superclass to reflect up to (inclusive),\n+     *  may be <code>null</code>\n+     * @return the String result\n+     * @throws IllegalArgumentException if the Object is <code>null</code>\n+     */\n+    public static String toString(Object object, ToStringStyle style, boolean outputTransients, boolean outputStatics, Class reflectUpToClass) {\n+        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics).toString();\n     }\n \n     /**\n      *\n      * <p>If the style is <code>null</code>, the default\n      * <code>ToStringStyle</code> is used.</p>\n+     *\n+     * @deprecated Use {@link #toString(Object,ToStringStyle,boolean,boolean,Class)}\n      * \n      * @param object  the Object to be output\n      * @param style  the style of the <code>toString</code> to create,\n      * @return the String result\n      * @throws IllegalArgumentException if the Object is <code>null</code>\n      */\n-    public static String toString(\n-        Object object,\n-        ToStringStyle style,\n-        boolean outputTransients,\n-        Class reflectUpToClass) {\n+    public static String toString(Object object, ToStringStyle style, boolean outputTransients, Class reflectUpToClass) {\n         return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients).toString();\n+    }\n+\n+    /**\n+     * TODO: Is this convenience API really needed?\n+     * \n+     * <p>This method uses reflection to build a suitable\n+     * <code>toString</code> value which includes static fields.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run\n+     * under a security manager, if the permissions are not set up correctly.\n+     * It is also not as efficient as testing explicitly. </p>\n+     *\n+     * <p>Transient fields are not output.</p>\n+     *\n+     * <p>Superclass fields will be appended up to and including \n+     * <code>java.lang.Object</code>.</p>\n+     *\n+     * <p>The default <code>ToStringStyle</code> is used.</p>\n+     * \n+     * @param object  the Object to be output\n+     * @param reflectUpToClass  the superclass to reflect up to (inclusive),\n+     *  may be <code>null</code>\n+     * @return the String result\n+     * @throws IllegalArgumentException if the Object is <code>null</code>\n+     */\n+    public static Object toStringWithStatics(Object object) {\n+        return toString(object, null, false, true, null);\n+    }\n+\n+    /**\n+     * TODO: Is this convenience API really needed?\n+     * \n+     * <p>This method uses reflection to build a suitable\n+     * <code>toString</code> value which includes static fields.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run\n+     * under a security manager, if the permissions are not set up correctly.\n+     * It is also not as efficient as testing explicitly. </p>\n+     *\n+     * <p>Transient fields are not output.</p>\n+     *\n+     * <p>Superclass fields will be appended up to and including the specified superclass. \n+     * A null superclass is treated as <code>java.lang.Object</code>.</p>\n+     *\n+     * <p>The default <code>ToStringStyle</code> is used.</p>\n+     * \n+     * @param object  the Object to be output\n+     * @param reflectUpToClass  the superclass to reflect up to (inclusive),\n+     *  may be <code>null</code>\n+     * @return the String result\n+     * @throws IllegalArgumentException if the Object is <code>null</code>\n+     */\n+    public static Object toStringWithStatics(Object object, Class reflectUpToClass) {\n+        return toString(object, null, false, true, reflectUpToClass);\n+    }\n+\n+    /**\n+     * TODO: Is this convenience API really needed?\n+     * \n+     * <p>This method uses reflection to build a suitable\n+     * <code>toString</code> value which includes static fields.</p>\n+     *\n+     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n+     * fields. This means that it will throw a security exception if run\n+     * under a security manager, if the permissions are not set up correctly.\n+     * It is also not as efficient as testing explicitly. </p>\n+     *\n+     * <p>Transient fields are not output.</p>\n+     *\n+     * <p>Superclass fields will be appended up to and including the specified superclass. \n+     * A null superclass is treated as <code>java.lang.Object</code>.</p>\n+     *\n+     * <p>If the style is <code>null</code>, the default\n+     * <code>ToStringStyle</code> is used.</p>\n+     * \n+     * @param object  the Object to be output\n+     * @param style  the style of the <code>toString</code> to create,\n+     *  may be <code>null</code>\n+     * @param reflectUpToClass  the superclass to reflect up to (inclusive),\n+     *  may be <code>null</code>\n+     * @return the String result\n+     * @throws IllegalArgumentException if the Object is <code>null</code>\n+     */\n+    public static Object toStringWithStatics(Object object, ToStringStyle toStringStyle, Class reflectUpToClass) {\n+        return toString(object, toStringStyle, false, true, reflectUpToClass);\n     }\n \n     /**\n     static void unregister(Object value) {\n         getRegistry().remove(value);\n     }\n+\n+    /**\n+     * Whether or not to append static fields.\n+     */\n+    private boolean appendStatics = false;\n \n     /**\n      * Whether or not to append transient fields.\n \n     /**\n      * Constructor.\n+     * \n+     * @deprecated Use {@link #ReflectionToStringBuilder(Object,ToStringStyle,StringBuffer,Class,boolean,boolean)}.\n      * \n      * @param object  the Object to build a <code>toString</code> for,\n      *  must not be <code>null</code>\n     }\n \n     /**\n+     * Constructor.\n+     * \n+     * @param object  the Object to build a <code>toString</code> for,\n+     *  must not be <code>null</code>\n+     * @param style  the style of the <code>toString</code> to create,\n+     *  may be <code>null</code>\n+     * @param buffer  the <code>StringBuffer</code> to populate, may be\n+     *  <code>null</code>\n+     * @param reflectUpToClass  the superclass to reflect up to (inclusive),\n+     *  may be <code>null</code>\n+     * @param outputTransients  whether to include transient fields\n+     * @param outputStatics  whether to include static fields\n+     */\n+    public ReflectionToStringBuilder(\n+        Object object,\n+        ToStringStyle style,\n+        StringBuffer buffer,\n+        Class reflectUpToClass,\n+        boolean outputTransients,\n+        boolean outputStatics) {\n+        super(object, style, buffer);\n+        this.setUpToClass(reflectUpToClass);\n+        this.setAppendTransients(outputTransients);\n+        this.setAppendStatics(outputStatics);\n+    }\n+\n+    /**\n      * Returns whether or not to append the given <code>Field</code>.\n      * <ul>\n-     *  <li>Static fields are not appended.</li>\n      *  <li>Transient fields are appended only if {@link #isAppendTransients()} returns <code>true</code>.\n+     *  <li>Static fields are appended only if {@link #isAppendStatics()} returns <code>true</code>.\n      *  <li>Inner class fields are not appened.</li>\n      * </ul>\n      * @param field The Field to test.\n      * @return Whether or not to append the given <code>Field</code>.\n      */\n     protected boolean accept(Field field) {\n-        String fieldName = field.getName();\n-        return (fieldName.indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) == -1)\n-            && (this.isAppendTransients() || !Modifier.isTransient(field.getModifiers()))\n-            && (!Modifier.isStatic(field.getModifiers()));\n+        if (field.getName().indexOf(ClassUtils.INNER_CLASS_SEPARATOR_CHAR) != -1) {\n+            // Reject field from inner class.\n+            return false;\n+        }\n+        if (Modifier.isTransient(field.getModifiers()) && !this.isAppendTransients()) {\n+            // transients.\n+            return false;\n+        }\n+        if (Modifier.isStatic(field.getModifiers()) && !this.isAppendStatics()) {\n+            // transients.\n+            return false;\n+        }\n+        return true;\n     }\n \n     /**\n             this.unregisterObject();\n         }\n     }\n-    \n+\n     /**\n      * <p>Gets the last super class to stop appending fields for.</p>\n      * \n     }\n \n     /**\n+     * <p>Gets whether or not to append static fields.</p>\n+     * \n+     * @return Whether or not to append static fields.\n+     */\n+    public boolean isAppendStatics() {\n+        return this.appendStatics;\n+    }\n+\n+    /**\n      * <p>Gets whether or not to append transient fields.</p>\n      * \n      * @return Whether or not to append transient fields.\n     public boolean isAppendTransients() {\n         return this.appendTransients;\n     }\n-    \n+\n     /**\n      * <p>Append to the <code>toString</code> an <code>Object</code>\n      * array.</p>\n      */\n     void registerObject() {\n         register(this.getObject());\n+    }\n+\n+    /**\n+     * <p>Sets whether or not to append static fields.</p>\n+     * \n+     * @param appendStatics Whether or not to append static fields.\n+     */\n+    public void setAppendStatics(boolean appendStatics) {\n+        this.appendStatics = appendStatics;\n     }\n \n     /**\n--- a/src/java/org/apache/commons/lang/builder/ToStringBuilder.java\n+++ b/src/java/org/apache/commons/lang/builder/ToStringBuilder.java\n  * @author Gary Gregory\n  * @author Pete Gieser\n  * @since 1.0\n- * @version $Id: ToStringBuilder.java,v 1.29 2003/08/23 00:21:49 ggregory Exp $\n+ * @version $Id: ToStringBuilder.java,v 1.30 2003/10/23 22:25:16 ggregory Exp $\n  */\n public class ToStringBuilder {\n \n      * @see ReflectionToStringBuilder#toString(Object,ToStringStyle,boolean)\n      */\n     public static String reflectionToString(Object object, ToStringStyle style, boolean outputTransients) {\n-        return ReflectionToStringBuilder.toString(object, style, outputTransients, null);\n+        return ReflectionToStringBuilder.toString(object, style, outputTransients, false, null);\n     }\n \n     /**\n         ToStringStyle style,\n         boolean outputTransients,\n         Class reflectUpToClass) {\n-        return ReflectionToStringBuilder.toString(object, style, outputTransients, reflectUpToClass);\n+        return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass);\n     }\n \n     /**\n     }\n \n     /**\n+     * <p>Returns the <code>Object</code> being output.</p>\n+     * \n+     * @return The object being output.\n+     * @since 2.0\n+     */\n+    public Object getObject() {\n+        return object;\n+    }\n+\n+    /**\n      * <p>Gets the <code>StringBuffer</code> being populated.</p>\n      * \n      * @return the <code>StringBuffer</code> being populated\n         return buffer.toString();\n     }\n \n-    /**\n-     * <p>Returns the <code>Object</code> being output.</p>\n-     * \n-     * @return The object being output.\n-     * @since 2.0\n-     */\n-    public Object getObject() {\n-        return object;\n-    }\n-\n }\n--- a/src/test/org/apache/commons/lang/builder/ToStringBuilderTest.java\n+++ b/src/test/org/apache/commons/lang/builder/ToStringBuilderTest.java\n  * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n  * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n  * @author <a href=\"mailto:alex@apache.org\">Alex Chaffee</a>\n- * @version $Id: ToStringBuilderTest.java,v 1.10 2003/08/18 02:22:26 bayard Exp $\n+ * @version $Id: ToStringBuilderTest.java,v 1.11 2003/10/23 22:26:00 ggregory Exp $\n  */\n public class ToStringBuilderTest extends TestCase {\n \n         assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n     }\n \n+    public void testSimpleReflectionStatics() {\n+        SimpleReflectionStaticFieldsFixture instance1 = new SimpleReflectionStaticFieldsFixture();\n+        assertEquals(\n+            this.toBaseString(instance1) + \"[staticString=staticString,staticInt=12345]\",\n+            ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class));\n+        assertEquals(\n+            this.toBaseString(instance1) + \"[staticString=staticString,staticInt=12345]\",\n+            ReflectionToStringBuilder.toString(instance1, null, true, true, SimpleReflectionStaticFieldsFixture.class));\n+        assertEquals(\n+            this.toBaseString(instance1) + \"[staticString=staticString,staticInt=12345]\",\n+            ReflectionToStringBuilder.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class));\n+        assertEquals(\n+            this.toBaseString(instance1) + \"[staticString=staticString,staticInt=12345]\",\n+            ReflectionToStringBuilder.toStringWithStatics(instance1, SimpleReflectionStaticFieldsFixture.class));\n+    }\n+\n+    /**\n+     * Tests ReflectionToStringBuilder.toString() for statics.\n+     */\n+    public void testReflectionStatics() {\n+        ReflectionStaticFieldsFixture instance1 = new ReflectionStaticFieldsFixture();\n+        assertEquals(\n+            this.toBaseString(instance1) + \"[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890]\",\n+            ReflectionToStringBuilder.toString(instance1, null, false, true, ReflectionStaticFieldsFixture.class));\n+        assertEquals(\n+            this.toBaseString(instance1) + \"[staticString=staticString,staticInt=12345,staticTransientString=staticTransientString,staticTransientInt=54321,instanceString=instanceString,instanceInt=67890,transientString=transientString,transientInt=98765]\",\n+            ReflectionToStringBuilder.toString(instance1, null, true, true, ReflectionStaticFieldsFixture.class));\n+        assertEquals(\n+            this.toBaseString(instance1) + \"[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890]\",\n+            ReflectionToStringBuilder.toStringWithStatics(instance1, null, ReflectionStaticFieldsFixture.class));\n+        assertEquals(\n+            this.toBaseString(instance1) + \"[staticString=staticString,staticInt=12345,instanceString=instanceString,instanceInt=67890]\",\n+            ReflectionToStringBuilder.toStringWithStatics(instance1, ReflectionStaticFieldsFixture.class));\n+    }\n+\n+    /**\n+     * Tests ReflectionToStringBuilder.toString() for statics.\n+     */\n+    public void testInheritedReflectionStatics() {\n+        InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture();\n+        assertEquals(\n+            this.toBaseString(instance1) + \"[staticString2=staticString2,staticInt2=67890]\",\n+            ReflectionToStringBuilder.toString(instance1, null, false, true, InheritedReflectionStaticFieldsFixture.class));\n+        assertEquals(\n+            this.toBaseString(instance1) + \"[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]\",\n+            ReflectionToStringBuilder.toString(instance1, null, false, true, SimpleReflectionStaticFieldsFixture.class));\n+        assertEquals(\n+            this.toBaseString(instance1) + \"[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]\",\n+            ReflectionToStringBuilder.toStringWithStatics(instance1, null, SimpleReflectionStaticFieldsFixture.class));\n+        assertEquals(\n+            this.toBaseString(instance1) + \"[staticString2=staticString2,staticInt2=67890,staticString=staticString,staticInt=12345]\",\n+            ReflectionToStringBuilder.toStringWithStatics(instance1, SimpleReflectionStaticFieldsFixture.class));\n+    }\n+\n+    /**\n+     * Tests ReflectionToStringBuilder.toString() for statics.\n+     */\n+    class ReflectionStaticFieldsFixture {\n+        static final String staticString = \"staticString\";\n+        static final int staticInt = 12345;\n+        static final transient String staticTransientString = \"staticTransientString\";\n+        static final transient int staticTransientInt = 54321;\n+        String instanceString = \"instanceString\";\n+        int instanceInt = 67890;\n+        transient String transientString = \"transientString\";\n+        transient int transientInt = 98765;\n+    }\n+\n+    /**\n+     * Test fixture for ReflectionToStringBuilder.toString() for statics.\n+     */\n+    class SimpleReflectionStaticFieldsFixture {\n+        static final String staticString = \"staticString\";\n+        static final int staticInt = 12345;\n+    }\n+\n+    /**\n+     * Test fixture for ReflectionToStringBuilder.toString() for statics.\n+     */\n+    class InheritedReflectionStaticFieldsFixture extends SimpleReflectionStaticFieldsFixture {\n+        static final String staticString2 = \"staticString2\";\n+        static final int staticInt2 = 67890;\n+    }\n+\n }", "timestamp": 1066947960, "metainfo": ""}