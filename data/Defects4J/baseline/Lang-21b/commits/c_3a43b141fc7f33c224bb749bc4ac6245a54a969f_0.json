{"sha": "3a43b141fc7f33c224bb749bc4ac6245a54a969f", "log": "Fix split to use whitespace, remove StringTokenizer Performance tune some methods   ", "commit": "\n--- a/src/java/org/apache/commons/lang/StringUtils.java\n+++ b/src/java/org/apache/commons/lang/StringUtils.java\n import java.util.ArrayList;\n import java.util.Iterator;\n import java.util.List;\n-import java.util.StringTokenizer;\n \n import org.apache.commons.lang.math.NumberUtils;\n \n  * @author Arun Mammen Thomas\n  * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n  * @since 1.0\n- * @version $Id: StringUtils.java,v 1.64 2003/07/19 00:22:50 scolebourne Exp $\n+ * @version $Id: StringUtils.java,v 1.65 2003/07/19 18:09:33 scolebourne Exp $\n  */\n public class StringUtils {\n-\n+    // Performance testing notes (JDK 1.4, Jul03, scolebourne)\n+    // Whitespace:\n+    // Character.isWhitespace() is faster than WHITESPACE.indexOf()\n+    // where WHITESPACE is a string of all whitespace characters\n+    // \n+    // Character access:\n+    // String.charAt(n) versus toCharArray(), then array[n]\n+    // String.charAt(n) is about 15% worse for a 10K string\n+    // They are about equal for a length 50 string\n+    // String.charAt(n) is about 4 times better for a length 3 string\n+    // String.charAt(n) is best bet overall\n+    //\n+    // Append:\n+    // String.concat about twice as fast as StringBuffer.append\n+    // (not sure who tested this)\n+    \n     /**\n      * <p>The maximum size to which the padding constant(s) can expand.</p>\n      */\n      * <p>Used for efficient space padding. The length of each String expands as needed.</p>\n      */\n     private final static String[] padding = new String[Character.MAX_VALUE];\n-       // String.concat about twice as fast as StringBuffer.append\n \n     /**\n      * <p><code>StringUtils<code> instances should NOT be constructed in\n      *\n      * @see java.lang.String#trim()\n      * @param str  the String to be trimmed, may be null\n-     * @return the trimmed text, <code>null</code> if null String input\n+     * @return the trimmed string, <code>null</code> if null String input\n      */\n     public static String trim(String str) {\n         return (str == null ? null : str.trim());\n      * @see java.lang.String#trim()\n      * @param str  the String to be trimmed, may be null\n      * @return the trimmed String, \n-     *  <code>null</code> if a whitespace, empty or null String input\n+     *  <code>null</code> if only chars &lt;= 32, empty or null String input\n      */\n     public static String trimToNull(String str) {\n         String ts = trim(str);\n      *  \n      * @see java.lang.String#trim()\n      * @param str  the String to be trimmed, may be null\n-     * @return the trimmed String, or an empty String if null input\n+     * @return the trimmed String, or an empty String if <code>null</code> input\n      */\n     public static String trimToEmpty(String str) {\n         return (str == null ? \"\" : str.trim());\n         if (str == null) {\n             return null;\n         }\n-        StringBuffer buffer = new StringBuffer();\n         int sz = str.length();\n+        StringBuffer buffer = new StringBuffer(sz);\n         for (int i = 0; i < sz; i++) {\n             if (!Character.isWhitespace(str.charAt(i))) {\n                 buffer.append(str.charAt(i));\n      * separator.\n      * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n      *\n-     * <p>The separator is not included in the returned String array.</p>\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators are treated as one separator.</p>\n      * \n      * <p>A <code>null</code> input String returns <code>null</code>.</p>\n      *\n      * <pre>\n-     * StringUtils.split(null)      = null\n-     * StringUtils.split(\"abc def\") = [\"abc\", \"def\"]\n+     * StringUtils.split(null)       = null\n+     * StringUtils.split(\"\")         = []\n+     * StringUtils.split(\"abc def\")  = [\"abc\", \"def\"]\n+     * StringUtils.split(\"abc  def\") = [\"abc\", \"def\"]\n      * </pre>\n      * \n      * @param str  the String to parse, may be null\n     }\n \n     /**\n-     * <p>Splits the provided text into an array, using the specified separator.</p>\n+     * <p>Splits the provided text into an array, separator specified.\n+     * This is an alternative to using StringTokenizer.</p>\n      *\n      * <p>The separator is not included in the returned String array.\n-     * Adjacent separators will cause an empty String to be returned (\"\").</p>\n+     * Adjacent separators are treated as one separator.</p>\n      * \n      * <p>A <code>null</code> input String returns <code>null</code>.</p>\n      *\n      * <pre>\n-     * StringUtils.split(null, '.')      = null\n-     * StringUtils.split(\"a.b.c\", '.') = [\"a\", \"b\", \"c\"]\n-     * StringUtils.split(\"a..b.c\", '.') = [\"a\", \"\", \"b\", \"c\"]\n+     * StringUtils.split(null, '.')     = null\n+     * StringUtils.split(\"\", '.')       = []\n+     * StringUtils.split(\"a.b.c\", '.')  = [\"a\", \"b\", \"c\"]\n+     * StringUtils.split(\"a..b.c\", '.') = [\"a\", \"b\", \"c\"]\n      * StringUtils.split(\"a:b:c\", '.')  = [\"a:b:c\"]\n      * </pre>\n      * \n      * @return an array of parsed Strings, <code>null</code> if null String input\n      */\n     public static String[] split(String str, char separatorChar) {\n+        // Performance tuned for 2.0 (JDK1.4)\n+        \n         if (str == null) {\n             return null;\n         }\n-        char[] chars = str.toCharArray();\n+        int len = str.length();\n+        if (len == 0) {\n+            return ArrayUtils.EMPTY_STRING_ARRAY;\n+        }\n         List list = new ArrayList();\n-        int start = 0;\n-        for (int i = 0; i < chars.length; i++) {\n-            if (chars[i] == separatorChar) {\n-                list.add(str.substring(start, i));\n-                start = i + 1;\n-            }\n-        }\n-        list.add(str.substring(start));\n+        int i =0, start = 0;\n+        boolean match = false;\n+        while (i < len) {\n+            if (str.charAt(i) == separatorChar) {\n+                if (match) {\n+                    list.add(str.substring(start, i));\n+                    match = false;\n+                }\n+                start = ++i;\n+                continue;\n+            }\n+            match = true;\n+            i++;\n+        }\n+        if (match) {\n+            list.add(str.substring(start, i));\n+        }\n         return (String[]) list.toArray(new String[list.size()]);\n     }\n \n     /**\n-     * <p>Splits the provided text into an array, using the specified separators.</p>\n-     *\n-     * <p>The separator is not included in the returned String array.</p>\n+     * <p>Splits the provided text into an array, separators specified.\n+     * This is an alternative to using StringTokenizer.</p>\n+     *\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators are treated as one separator.</p>\n      * \n      * <p>A <code>null</code> input String returns <code>null</code>.\n      * A <code>null</code> separatorChars splits on whitespace.</p>\n      *\n      * <pre>\n      * StringUtils.split(null, null)      = null\n+     * StringUtils.split(\"\", null)        = []\n      * StringUtils.split(\"abc def\", null) = [\"abc\", \"def\"]\n      * StringUtils.split(\"abc def\", \" \")  = [\"abc\", \"def\"]\n+     * StringUtils.split(\"abc  def\", \" \") = [\"abc\", \"def\"]\n      * StringUtils.split(\"ab:cd:ef\", \":\") = [\"ab\", \"cd\", \"ef\"]\n      * </pre>\n      * \n     }\n \n     /**\n-     * <p>Splits the provided text into a array, based on a given separator.</p>\n-     *\n-     * <p>The separator is not included in the returned String array. The\n-     * maximum number of splits to perfom can be controlled. A <code>null</code>\n-     * separator will cause parsing to be on whitespace.</p>\n-     *\n-     * <p>This is useful for quickly splitting a String directly into\n-     * an array of tokens, instead of an enumeration of tokens (as\n-     * <code>StringTokenizer</code> does).</p>\n+     * <p>Splits the provided text into an array, separators specified.\n+     * This is an alternative to using StringTokenizer.</p>\n+     *\n+     * <p>The separator is not included in the returned String array.\n+     * Adjacent separators are treated as one separator.</p>\n      *\n      * <p>A <code>null</code> input String returns <code>null</code>.\n      * A <code>null</code> separatorChars splits on whitespace.</p>\n      * \n      * <pre>\n-     * StringUtils.split(null, null, 0)       = null\n-     * StringUtils.split(\"ab de fg\", null, 0) = [\"ab\", \"cd\", \"ef\"]\n-     * StringUtils.split(\"ab:cd:ef\", \":\", 0)  = [\"ab\", \"cd\", \"ef\"]\n-     * StringUtils.split(\"ab:cd:ef\", \":\", 2)  = [\"ab\", \"cdef\"]\n+     * StringUtils.split(null, null, 0)         = null\n+     * StringUtils.split(\"\", null, 0)           = []\n+     * StringUtils.split(\"ab de fg\", null, 0)   = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.split(\"ab   de fg\", null, 0) = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.split(\"ab:cd:ef\", \":\", 0)    = [\"ab\", \"cd\", \"ef\"]\n+     * StringUtils.split(\"ab:cd:ef\", \":\", 2)    = [\"ab\", \"cdef\"]\n      * </pre>\n      * \n      * @param str  the String to parse, may be null\n      * @param separatorChars  the characters used as the delimiters,\n      *  <code>null</code> splits on whitespace\n      * @param max  the maximum number of elements to include in the\n-     *  array. A zero or negative value implies no limit.\n+     *  array. A zero or negative value implies no limit\n      * @return an array of parsed Strings, <code>null</code> if null String input\n      */\n     public static String[] split(String str, String separatorChars, int max) {\n+        // Performance tuned for 2.0 (JDK1.4)\n+        // Direct code is quicker than StringTokenizer.\n+        // Also, StringTokenizer uses isSpace() not isWhitespace()\n+        \n         if (str == null) {\n             return null;\n         }\n-        StringTokenizer tok = null;\n+        int len = str.length();\n+        if (len == 0) {\n+            return ArrayUtils.EMPTY_STRING_ARRAY;\n+        }\n+        List list = new ArrayList();\n+        int sizePlus1 = 1;\n+        int i =0, start = 0;\n+        boolean match = false;\n         if (separatorChars == null) {\n-            // Null separator means we're using StringTokenizer's default\n-            // delimiter, which comprises all whitespace characters.\n-            \n-            // TODO: StringTokenizer uses isSpace() not isWhitespace()\n-            tok = new StringTokenizer(str);\n+            // Null separator means use whitespace\n+            while (i < len) {\n+                if (Character.isWhitespace(str.charAt(i))) {\n+                    if (match) {\n+                        if (sizePlus1++ == max) {\n+                            i = len;\n+                        }\n+                        list.add(str.substring(start, i));\n+                        match = false;\n+                    }\n+                    start = ++i;\n+                    continue;\n+                }\n+                match = true;\n+                i++;\n+            }\n+        } else if (separatorChars.length() == 1) {\n+            // Optimise 1 character case\n+            char sep = separatorChars.charAt(0);\n+            while (i < len) {\n+                if (str.charAt(i) == sep) {\n+                    if (match) {\n+                        if (sizePlus1++ == max) {\n+                            i = len;\n+                        }\n+                        list.add(str.substring(start, i));\n+                        match = false;\n+                    }\n+                    start = ++i;\n+                    continue;\n+                }\n+                match = true;\n+                i++;\n+            }\n         } else {\n-            tok = new StringTokenizer(str, separatorChars);\n-        }\n-\n-        int listSize = tok.countTokens();\n-        if (max > 0 && listSize > max) {\n-            listSize = max;\n-        }\n-\n-        String[] list = new String[listSize];\n-        int i = 0;\n-        int lastTokenBegin = 0;\n-        int lastTokenEnd = 0;\n-        while (tok.hasMoreTokens()) {\n-            if (max > 0 && i == listSize - 1) {\n-                // In the situation where we hit the max yet have\n-                // tokens left over in our input, the last list\n-                // element gets all remaining text.\n-                String endToken = tok.nextToken();\n-                lastTokenBegin = str.indexOf(endToken, lastTokenEnd);\n-                list[i] = str.substring(lastTokenBegin);\n-                break;\n-            } else {\n-                list[i] = tok.nextToken();\n-                lastTokenBegin = str.indexOf(list[i], lastTokenEnd);\n-                lastTokenEnd = lastTokenBegin + list[i].length();\n-            }\n-            i++;\n-        }\n-        return list;\n+            // standard case\n+            while (i < len) {\n+                if (separatorChars.indexOf(str.charAt(i)) >= 0) {\n+                    if (match) {\n+                        if (sizePlus1++ == max) {\n+                            i = len;\n+                        }\n+                        list.add(str.substring(start, i));\n+                        match = false;\n+                    }\n+                    start = ++i;\n+                    continue;\n+                }\n+                match = true;\n+                i++;\n+            }\n+        }\n+        if (match) {\n+            list.add(str.substring(start, i));\n+        }\n+        return (String[]) list.toArray(new String[list.size()]);\n     }\n \n     // Joining\n      *  <code>null</code> if null String input\n      */\n     public static String repeat(String str, int repeat) {\n+        // Performance tuned for 2.0 (JDK1.4)\n+        \n         if (str == null) {\n             return null;\n         }\n         if (repeat <= 0) {\n             return \"\";\n         }\n-        int inputLength = str.length();\n+        int inputLength;\n+        if (repeat == 1 || (inputLength = str.length()) == 0) {\n+            return str;\n+        }\n         if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return padding(repeat, str.charAt(0));\n         }\n \n-        char[] input = str.toCharArray();\n-        char[] output = new char[repeat * inputLength];\n+        int outputLength = inputLength * repeat;\n         switch (inputLength) {\n             case 1:\n-                char ch = input[0];\n+                char ch = str.charAt(0);\n+                char[] output1 = new char[outputLength];\n                 for (int i = repeat - 1; i >= 0; i--) {\n-                    output[i] = ch;\n+                    output1[i] = ch;\n                 }\n-                break;\n+                return new String(output1);\n             case 2:\n-                char ch0 = input[0];\n-                char ch1 = input[1];\n+                char ch0 = str.charAt(0);\n+                char ch1 = str.charAt(1);\n+                char[] output2 = new char[outputLength];\n                 for (int i = repeat * 2 - 2; i >= 0; i--,i--) {\n-                    output[i] = ch0;\n-                    output[i + 1] = ch1;\n+                    output2[i] = ch0;\n+                    output2[i + 1] = ch1;\n                 }\n-                break;\n+                return new String(output2);\n             default:\n-                for (int i = repeat - 1; i >= 0; i--) {\n-                    System.arraycopy(input, 0, output, i * inputLength, inputLength);\n-                }\n-                break;            \n-        }\n-        return new String(output);\n+                StringBuffer buf = new StringBuffer(outputLength);\n+                for (int i = 0; i < repeat; i++) {\n+                    buf.append(str);\n+                }        \n+                return buf.toString();\n+        }\n     }\n \n     /**\n      * This is similar to {@link String#trim()} but instead removes whitespace.\n      * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n      * \n-     * <p>If the input String is <code>null</code>, <code>null</code>\n-     * is returned.</p>\n+     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n      * \n      * <pre>\n      * StringUtils.strip(null)     = null\n      * This is similar to {@link String#trim()} but allows the characters\n      * to be stripped to be controlled.</p>\n      *\n-     * <p>If the input String is <code>null</code>, <code>null</code>\n-     * is returned.</p>\n+     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n      * \n      * <p>If the stripChars String is <code>null</code>, whitespace is\n      * stripped as defined by {@link Character#isWhitespace(char)}.\n     /**\n      * <p>Strips any of a set of characters from the start of a String.</p>\n      *\n-     * <p>If the input String is <code>null</code>, <code>null</code>\n-     * is returned.</p>\n+     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n      * \n      * <p>If the stripChars String is <code>null</code>, whitespace is\n      * stripped as defined by {@link Character#isWhitespace(char)}.</p>\n     /**\n      * <p>Strips any of a set of characters from the end of a String.</p>\n      *\n-     * <p>If the input String is <code>null</code>, <code>null</code>\n-     * is returned.</p>\n+     * <p>A <code>null</code> input String returns <code>null</code>.</p>\n      * \n      * <p>If the stripChars String is <code>null</code>, whitespace is\n      * stripped as defined by {@link Character#isWhitespace(char)}.</p>\n         }\n         StringBuffer buffer = new StringBuffer(strLen);\n         boolean whitespace = true;\n-        char[] strChars = str.toCharArray();\n         for (int i = 0; i < strLen; i++) {\n-            char ch = strChars[i];\n+            char ch = str.charAt(i);\n             if (Character.isWhitespace(ch)) {\n                 buffer.append(ch);\n                 whitespace = true;\n         }\n         StringBuffer buffer = new StringBuffer(strLen);\n         boolean whitespace = true;\n-        char[] strChars = str.toCharArray();\n         for (int i = 0; i < strLen; i++) {\n-            char ch = strChars[i];\n+            char ch = str.charAt(i);\n             if (Character.isWhitespace(ch)) {\n                 buffer.append(ch);\n                 whitespace = true;", "timestamp": 1058638173, "metainfo": ""}