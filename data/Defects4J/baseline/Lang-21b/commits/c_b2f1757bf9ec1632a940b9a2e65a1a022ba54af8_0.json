{"sha": "b2f1757bf9ec1632a940b9a2e65a1a022ba54af8", "log": "[LANG-362] Add ExtendedMessageFormat  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/text/ChoiceMetaFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import java.text.ChoiceFormat;\n+import java.text.FieldPosition;\n+import java.text.ParsePosition;\n+\n+/**\n+ * Stock \"choice\" MetaFormat.\n+ * \n+ * @see {@link ExtendedMessageFormat}\n+ * @author Matt Benson\n+ * @since 2.4\n+ * @version $Id$\n+ */\n+public class ChoiceMetaFormat extends MetaFormatSupport {\n+    private static final long serialVersionUID = 3802197832963795129L;\n+\n+    /**\n+     * Singleton-usable instance.\n+     */\n+    public static final ChoiceMetaFormat INSTANCE = new ChoiceMetaFormat();\n+\n+    /**\n+     * Create a new ChoiceMetaFormat.\n+     */\n+    public ChoiceMetaFormat() {\n+        super();\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer,\n+     *      java.text.FieldPosition)\n+     */\n+    public StringBuffer format(Object obj, StringBuffer toAppendTo,\n+            FieldPosition pos) {\n+        if (obj instanceof ChoiceFormat) {\n+            return toAppendTo.append(((ChoiceFormat) obj).toPattern());\n+        }\n+        throw new IllegalArgumentException(String.valueOf(obj));\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see java.text.Format#parseObject(java.lang.String,\n+     *      java.text.ParsePosition)\n+     */\n+    public Object parseObject(String source, ParsePosition pos) {\n+        int start = pos.getIndex();\n+        seekFormatElementEnd(source, pos);\n+        return new ChoiceFormat(source.substring(start, pos.getIndex()));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/text/DateMetaFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import java.text.DateFormat;\n+import java.util.Locale;\n+\n+/**\n+ * Stock \"date\" MetaFormat.\n+ * \n+ * @see {@link ExtendedMessageFormat}\n+ * @author Matt Benson\n+ * @since 2.4\n+ * @version $Id$\n+ */\n+public class DateMetaFormat extends DateMetaFormatSupport {\n+    private static final long serialVersionUID = -4732179430347600208L;\n+\n+    /**\n+     * Create a new DateMetaFormat.\n+     */\n+    public DateMetaFormat() {\n+        super();\n+    }\n+\n+    /**\n+     * Create a new DateMetaFormat.\n+     * \n+     * @param locale\n+     */\n+    public DateMetaFormat(Locale locale) {\n+        super(locale);\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.lang.text.AbstractDateMetaFormat#createSubformatInstance(int)\n+     */\n+    protected DateFormat createSubformatInstance(int style) {\n+        return DateFormat.getDateInstance(style, getLocale());\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/text/DateMetaFormatSupport.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import java.text.DateFormat;\n+import java.text.DateFormatSymbols;\n+import java.text.FieldPosition;\n+import java.text.Format;\n+import java.text.ParsePosition;\n+import java.text.SimpleDateFormat;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+/**\n+ * date/time metaFormat support.\n+ * @see {@link ExtendedMessageFormat}\n+ * @author Matt Benson\n+ * @since 2.4\n+ * @version $Id$\n+ */\n+public abstract class DateMetaFormatSupport extends MetaFormatSupport {\n+    /** \"Default\" subformat name */\n+    protected static final String DEFAULT = \"\";\n+\n+    /** \"Short\" subformat name */\n+    protected static final String SHORT = \"short\";\n+\n+    /** \"Medium\" subformat name */\n+    protected static final String MEDIUM = \"medium\";\n+\n+    /** \"Long\" subformat name */\n+    protected static final String LONG = \"long\";\n+\n+    /** \"Full\" subformat name */\n+    protected static final String FULL = \"full\";\n+\n+    private Locale locale;\n+    private boolean handlePatterns = true;\n+\n+    private transient boolean initialized;\n+    private transient Map styleMap;\n+    private transient Map inverseStyleMap;\n+    private transient Map subformats;\n+    private transient Map reverseSubformats;\n+    private transient DateFormatSymbols dateFormatSymbols;\n+\n+    /**\n+     * Create a new AbstractDateMetaFormat.\n+     */\n+    public DateMetaFormatSupport() {\n+        this(Locale.getDefault());\n+    }\n+\n+    /**\n+     * Create a new AbstractDateMetaFormat.\n+     * \n+     * @param locale\n+     */\n+    public DateMetaFormatSupport(Locale locale) {\n+        super();\n+        this.locale = locale;\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer,\n+     *      java.text.FieldPosition)\n+     */\n+    public StringBuffer format(Object obj, StringBuffer toAppendTo,\n+            FieldPosition pos) {\n+        String subformat = getSubformatName(obj);\n+        if (subformat != null) {\n+            return toAppendTo.append(subformat);\n+        }\n+        if (isHandlePatterns() && obj instanceof SimpleDateFormat) {\n+            SimpleDateFormat sdf = (SimpleDateFormat) obj;\n+            if (sdf.getDateFormatSymbols().equals(dateFormatSymbols)) {\n+                return toAppendTo.append(sdf.toPattern());\n+            }\n+        }\n+        throw new IllegalArgumentException(String.valueOf(obj));\n+    }\n+\n+    private String getSubformatName(Object subformat) {\n+        initialize();\n+        if (reverseSubformats.containsKey(subformat)) {\n+            return (String) inverseStyleMap.get(reverseSubformats\n+                    .get(subformat));\n+        }\n+        return null;\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see java.text.Format#parseObject(java.lang.String,\n+     *      java.text.ParsePosition)\n+     */\n+    public Object parseObject(String source, ParsePosition pos) {\n+        int start = pos.getIndex();\n+        seekFormatElementEnd(source, pos);\n+        if (pos.getErrorIndex() >= 0) {\n+            return null;\n+        }\n+        String subformat = source.substring(start, pos.getIndex()).trim();\n+        Object result = getSubformat(subformat);\n+        if (result != null) {\n+            return result;\n+        }\n+        if (isHandlePatterns()) {\n+            return new SimpleDateFormat(subformat, getLocale());\n+        }\n+        pos.setErrorIndex(start);\n+        return null;\n+    }\n+\n+    private Format getSubformat(String subformat) {\n+        initialize();\n+        if (!styleMap.containsKey(subformat)) {\n+            return null;\n+        }\n+        initialize();\n+        return (Format) subformats.get(styleMap.get(subformat));\n+    }\n+\n+    /**\n+     * Get the locale in use by this {@link DateMetaFormatSupport}.\n+     * \n+     * @return Locale\n+     */\n+    public Locale getLocale() {\n+        return locale;\n+    }\n+\n+    private synchronized void initialize() {\n+        if (!initialized) {\n+            styleMap = createStyleMap();\n+            inverseStyleMap = createInverseStyleMap();\n+            subformats = new HashMap();\n+            reverseSubformats = new HashMap();\n+            for (Iterator iter = styleMap.values().iterator(); iter.hasNext();) {\n+                Integer style = (Integer) iter.next();\n+                if (subformats.containsKey(style)) {\n+                    continue;\n+                }\n+                Format sf = createSubformatInstance(style.intValue());\n+                subformats.put(style, sf);\n+                if (inverseStyleMap.containsKey(style)) {\n+                    reverseSubformats.put(sf, style);\n+                }\n+            }\n+            dateFormatSymbols = new DateFormatSymbols(getLocale());\n+        }\n+        initialized = true;\n+    }\n+\n+    /**\n+     * Create a subformat for the given <code>DateFormat</code> style\n+     * constant.\n+     * \n+     * @param style\n+     * @return a DateFormat instance.\n+     */\n+    protected abstract DateFormat createSubformatInstance(int style);\n+\n+    /**\n+     * Get whether this metaformat can parse date/time pattern formats in\n+     * addition to named formats.\n+     * \n+     * @return boolean.\n+     */\n+    public boolean isHandlePatterns() {\n+        return handlePatterns;\n+    }\n+\n+    /**\n+     * Set whether this metaformat can parse date/time pattern formats in\n+     * addition to named formats.\n+     * \n+     * @param handlePatterns\n+     *            the boolean handlePatterns to set.\n+     * @return <code>this</code> for fluent usage.\n+     */\n+    public DateMetaFormatSupport setHandlePatterns(boolean handlePatterns) {\n+        this.handlePatterns = handlePatterns;\n+        return this;\n+    }\n+\n+    /**\n+     * Create the style map.\n+     * \n+     * @return Map\n+     */\n+    protected Map createStyleMap() {\n+        HashMap result = new HashMap();\n+        result.put(SHORT, new Integer(DateFormat.SHORT));\n+        result.put(MEDIUM, new Integer(DateFormat.MEDIUM));\n+        result.put(LONG, new Integer(DateFormat.LONG));\n+        result.put(FULL, new Integer(DateFormat.FULL));\n+        result.put(DEFAULT, new Integer(DateFormat.DEFAULT));\n+        return result;\n+    }\n+\n+    /**\n+     * Create the inverse style map.\n+     * \n+     * @return Map\n+     */\n+    protected Map createInverseStyleMap() {\n+        Map invertMe = createStyleMap();\n+        invertMe.remove(DEFAULT);\n+        return invert(invertMe);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/text/DefaultMetaFormatFactory.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import java.text.Format;\n+import java.text.ParsePosition;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.ArrayUtils;\n+import org.apache.commons.lang.Validate;\n+\n+/**\n+ * Factory methods to produce metaformat instances that behave like\n+ * java.text.MessageFormat.\n+ * \n+ * @author Matt Benson\n+ * @since 2.4\n+ * @version $Id$\n+ */\n+/* package-private */ class DefaultMetaFormatFactory {\n+\n+    /** Number key */\n+    public static final String NUMBER_KEY = \"number\";\n+\n+    /** Date key */\n+    public static final String DATE_KEY = \"date\";\n+\n+    /** Time key */\n+    public static final String TIME_KEY = \"time\";\n+\n+    /** Choice key */\n+    public static final String CHOICE_KEY = \"choice\";\n+\n+    private static final String[] NO_SUBFORMAT_KEYS = new String[] {\n+            NUMBER_KEY, DATE_KEY, TIME_KEY };\n+\n+    private static final String[] NO_PATTERN_KEYS = new String[] { NUMBER_KEY,\n+            DATE_KEY, TIME_KEY, CHOICE_KEY };\n+\n+    private static final String[] PATTERN_KEYS = new String[] { DATE_KEY,\n+            TIME_KEY };\n+\n+    private static class OrderedNameKeyedMetaFormat extends NameKeyedMetaFormat {\n+        private static final long serialVersionUID = -7688772075239431055L;\n+\n+        private List keys;\n+\n+        private OrderedNameKeyedMetaFormat(String[] names, Format[] formats) {\n+            super(createMap(names, formats));\n+            this.keys = Arrays.asList(names);\n+        }\n+\n+        private static Map createMap(String[] names, Format[] formats) {\n+            Validate.isTrue(ArrayUtils.isSameLength(names, formats));\n+            HashMap result = new HashMap(names.length);\n+            for (int i = 0; i < names.length; i++) {\n+                result.put(names[i], formats[i]);\n+            }\n+            return result;\n+        }\n+\n+        protected Iterator iterateKeys() {\n+            return keys.iterator();\n+        }\n+    }\n+\n+    /**\n+     * Get a default metaformat for the specified Locale.\n+     * \n+     * @param locale\n+     *            the Locale for the resulting Format instance.\n+     * @return Format\n+     */\n+    public static Format getFormat(final Locale locale) {\n+        Format nmf = new NumberMetaFormat(locale);\n+        Format dmf = new DateMetaFormat(locale).setHandlePatterns(false);\n+        Format tmf = new TimeMetaFormat(locale).setHandlePatterns(false);\n+\n+        return new MultiFormat(new Format[] {\n+                new OrderedNameKeyedMetaFormat(NO_SUBFORMAT_KEYS, new Format[] {\n+                        getDefaultFormat(nmf), getDefaultFormat(dmf),\n+                        getDefaultFormat(tmf) }),\n+                new OrderedNameKeyedMetaFormat(NO_PATTERN_KEYS, new Format[] {\n+                        nmf, dmf, tmf, ChoiceMetaFormat.INSTANCE }),\n+                new OrderedNameKeyedMetaFormat(PATTERN_KEYS,\n+                        new Format[] { new DateMetaFormat(locale),\n+                                new TimeMetaFormat(locale) }) });\n+    }\n+\n+    private static Format getDefaultFormat(Format metaformat) {\n+        ParsePosition pos = new ParsePosition(0);\n+        Object o = metaformat.parseObject(\"\", pos);\n+        return pos.getErrorIndex() < 0 ? (Format) o : null;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import java.text.Format;\n+import java.text.MessageFormat;\n+import java.text.ParsePosition;\n+import java.util.ArrayList;\n+import java.util.Locale;\n+\n+import org.apache.commons.lang.Validate;\n+\n+/**\n+ * Extends <code>MessageFormat</code> to allow pluggable/additional formatting\n+ * options for embedded format elements; requires a \"meta-format\", i.e. a\n+ * <code>Format</code> capable of parsing and formatting other\n+ * <code>Format</code>s.\n+ * \n+ * @author Matt Benson\n+ * @since 2.4\n+ * @version $Id$\n+ */\n+public class ExtendedMessageFormat extends MessageFormat {\n+    private static final long serialVersionUID = -2362048321261811743L;\n+\n+    /**\n+     * Get a default meta-format for the default Locale. This will produce\n+     * behavior identical to a <code>java.lang.MessageFormat</code> using the\n+     * default locale.\n+     * \n+     * @return Format\n+     */\n+    public static Format createDefaultMetaFormat() {\n+        return createDefaultMetaFormat(Locale.getDefault());\n+    }\n+\n+    /**\n+     * Get a default meta-format for the specified Locale. This will produce\n+     * behavior identical to a <code>java.lang.MessageFormat</code> using\n+     * <code>locale</code>.\n+     * \n+     * @param locale\n+     *            the Locale for the resulting Format instance.\n+     * @return Format\n+     */\n+    public static Format createDefaultMetaFormat(Locale locale) {\n+        return DefaultMetaFormatFactory.getFormat(locale);\n+    }\n+\n+    private static class Parser {\n+        private static final String ESCAPED_QUOTE = \"''\";\n+        private static final char START_FMT = ',';\n+        private static final char END_FE = '}';\n+        private static final char START_FE = '{';\n+        private static final char QUOTE = '\\'';\n+\n+        private String stripFormats(String pattern) {\n+            StringBuffer sb = new StringBuffer(pattern.length());\n+            ParsePosition pos = new ParsePosition(0);\n+            while (pos.getIndex() < pattern.length()) {\n+                switch (pattern.charAt(pos.getIndex())) {\n+                case QUOTE:\n+                    appendQuotedString(pattern, pos, sb, true);\n+                    break;\n+                case START_FE:\n+                    int start = pos.getIndex();\n+                    readArgumentIndex(pattern, next(pos));\n+                    sb.append(pattern, start, pos.getIndex());\n+                    if (pattern.charAt(pos.getIndex()) == START_FMT) {\n+                        eatFormat(pattern, next(pos));\n+                    }\n+                    if (pattern.charAt(pos.getIndex()) != END_FE) {\n+                        throw new IllegalArgumentException(\n+                                \"Unreadable format element at position \"\n+                                        + start);\n+                    }\n+                    // fall through\n+                default:\n+                    sb.append(pattern.charAt(pos.getIndex()));\n+                    next(pos);\n+                }\n+            }\n+            return sb.toString();\n+        }\n+\n+        private String insertFormats(String pattern, Format[] formats,\n+                Format metaFormat) {\n+            if (formats == null || formats.length == 0) {\n+                return pattern;\n+            }\n+            StringBuffer sb = new StringBuffer(pattern.length() * 2);\n+            ParsePosition pos = new ParsePosition(0);\n+            int fe = -1;\n+            while (pos.getIndex() < pattern.length()) {\n+                char c = pattern.charAt(pos.getIndex());\n+                switch (c) {\n+                case QUOTE:\n+                    appendQuotedString(pattern, pos, sb, false);\n+                    break;\n+                case START_FE:\n+                    fe++;\n+                    sb.append(START_FE).append(\n+                            readArgumentIndex(pattern, next(pos)));\n+                    if (formats[fe] != null) {\n+                        sb.append(START_FMT).append(\n+                                metaFormat.format(formats[fe]));\n+                    }\n+                    break;\n+                default:\n+                    sb.append(pattern.charAt(pos.getIndex()));\n+                    next(pos);\n+                }\n+            }\n+            return sb.toString();\n+        }\n+\n+        private Format[] parseFormats(String pattern, Format metaFormat) {\n+            ArrayList result = new ArrayList();\n+            ParsePosition pos = new ParsePosition(0);\n+            while (pos.getIndex() < pattern.length()) {\n+                switch (pattern.charAt(pos.getIndex())) {\n+                case QUOTE:\n+                    getQuotedString(pattern, next(pos), true);\n+                    break;\n+                case START_FE:\n+                    int start = pos.getIndex();\n+                    readArgumentIndex(pattern, next(pos));\n+                    if (pattern.charAt(pos.getIndex()) == START_FMT) {\n+                        seekNonWs(pattern, next(pos));\n+                        result.add(metaFormat.parseObject(pattern, pos));\n+                    }\n+                    seekNonWs(pattern, pos);\n+                    if (pattern.charAt(pos.getIndex()) != END_FE) {\n+                        throw new IllegalArgumentException(\n+                                \"Unreadable format element at position \"\n+                                        + start);\n+                    }\n+                    // fall through\n+                default:\n+                    next(pos);\n+                }\n+            }\n+            return (Format[]) result.toArray(new Format[result.size()]);\n+        }\n+\n+        private void seekNonWs(String pattern, ParsePosition pos) {\n+            int len = 0;\n+            char[] buffer = pattern.toCharArray();\n+            do {\n+                len = StrMatcher.splitMatcher().isMatch(buffer, pos.getIndex());\n+                pos.setIndex(pos.getIndex() + len);\n+            } while (len > 0 && pos.getIndex() < pattern.length());\n+        }\n+\n+        private ParsePosition next(ParsePosition pos) {\n+            pos.setIndex(pos.getIndex() + 1);\n+            return pos;\n+        }\n+\n+        private String readArgumentIndex(String pattern, ParsePosition pos) {\n+            int start = pos.getIndex();\n+            for (; pos.getIndex() < pattern.length(); next(pos)) {\n+                char c = pattern.charAt(pos.getIndex());\n+                if (c == START_FMT || c == END_FE) {\n+                    return pattern.substring(start, pos.getIndex());\n+                }\n+                if (!Character.isDigit(c)) {\n+                    throw new IllegalArgumentException(\n+                            \"Invalid format argument index at position \"\n+                                    + start);\n+                }\n+            }\n+            throw new IllegalArgumentException(\n+                    \"Unterminated format element at position \" + start);\n+        }\n+\n+        private StringBuffer appendQuotedString(String pattern,\n+                ParsePosition pos, StringBuffer appendTo, boolean escapingOn) {\n+            int start = pos.getIndex();\n+            if (escapingOn && pattern.charAt(start) == QUOTE) {\n+                return appendTo == null ? null : appendTo.append(QUOTE);\n+            }\n+            int lastHold = start;\n+            for (int i = pos.getIndex(); i < pattern.length(); i++) {\n+                if (escapingOn\n+                        && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n+                    appendTo.append(pattern, lastHold, pos.getIndex()).append(\n+                            QUOTE);\n+                    pos.setIndex(i + ESCAPED_QUOTE.length());\n+                    lastHold = pos.getIndex();\n+                    continue;\n+                }\n+                switch (pattern.charAt(pos.getIndex())) {\n+                case QUOTE:\n+                    next(pos);\n+                    return appendTo == null ? null : appendTo.append(pattern,\n+                            lastHold, pos.getIndex());\n+                default:\n+                    next(pos);\n+                }\n+            }\n+            throw new IllegalArgumentException(\n+                    \"Unterminated quoted string at position \" + start);\n+        }\n+\n+        private void getQuotedString(String pattern, ParsePosition pos,\n+                boolean escapingOn) {\n+            appendQuotedString(pattern, pos, null, escapingOn);\n+        }\n+\n+        private void eatFormat(String pattern, ParsePosition pos) {\n+            int start = pos.getIndex();\n+            int depth = 1;\n+            for (; pos.getIndex() < pattern.length(); next(pos)) {\n+                switch (pattern.charAt(pos.getIndex())) {\n+                case START_FE:\n+                    depth++;\n+                    break;\n+                case END_FE:\n+                    depth--;\n+                    if (depth == 0) {\n+                        return;\n+                    }\n+                    break;\n+                case QUOTE:\n+                    getQuotedString(pattern, pos, false);\n+                    break;\n+                }\n+            }\n+            throw new IllegalArgumentException(\n+                    \"Unterminated format element at position \" + start);\n+        }\n+    }\n+\n+    private static final Parser PARSER = new Parser();\n+\n+    private Format metaFormat;\n+    private String strippedPattern;\n+\n+    /**\n+     * Create a new ExtendedMessageFormat.\n+     * \n+     * @param pattern\n+     * @param metaFormat\n+     * @throws IllegalArgumentException\n+     *             if <code>metaFormat</code> is <code>null</code> or in\n+     *             case of a bad pattern.\n+     */\n+    public ExtendedMessageFormat(String pattern, Format metaFormat) {\n+        /*\n+         * We have to do some acrobatics here: the call to the super constructor\n+         * will invoke applyPattern(), but we don't want to apply the pattern\n+         * until we've installed our custom metaformat. So we check for that in\n+         * our (final) applyPattern implementation, and re-call at the end of\n+         * this constructor.\n+         */\n+        super(pattern);\n+        setMetaFormat(metaFormat);\n+        applyPattern(pattern);\n+    }\n+\n+    /**\n+     * Apply the specified pattern.\n+     * \n+     * @param pattern\n+     *            pattern String\n+     */\n+    public final void applyPattern(String pattern) {\n+        if (metaFormat == null) {\n+            return;\n+        }\n+        applyPatternPre(pattern);\n+        strippedPattern = PARSER.stripFormats(pattern);\n+        super.applyPattern(strippedPattern);\n+        setFormats(PARSER.parseFormats(pattern, metaFormat));\n+        applyPatternPost(pattern);\n+    }\n+\n+    /**\n+     * Pre-execution hook that allows subclasses to customize the behavior of\n+     * the final applyPattern implementation.\n+     * \n+     * @param pattern\n+     */\n+    protected void applyPatternPre(String pattern) {\n+        // noop\n+    }\n+\n+    /**\n+     * Post-execution hook that allows subclasses to customize the behavior of\n+     * the final applyPattern implementation.\n+     * \n+     * @param pattern\n+     */\n+    protected void applyPatternPost(String pattern) {\n+        // noop\n+    }\n+\n+    /**\n+     * Render the pattern from the current state of the\n+     * <code>ExtendedMessageFormat</code>.\n+     * \n+     * @return pattern String\n+     */\n+    public String toPattern() {\n+        return PARSER.insertFormats(strippedPattern, getFormats(), metaFormat);\n+    }\n+\n+    /**\n+     * Get the meta-format currently configured.\n+     * \n+     * @return Format.\n+     */\n+    public synchronized Format getMetaFormat() {\n+        return metaFormat;\n+    }\n+\n+    /**\n+     * Set the meta-format. Has no effect until a subsequent call to\n+     * {@link #applyPattern(String)}.\n+     * \n+     * @param metaFormat\n+     *            the Format metaFormat to set.\n+     */\n+    public synchronized void setMetaFormat(Format metaFormat) {\n+        Validate.notNull(metaFormat, \"metaFormat is null\");\n+        this.metaFormat = metaFormat;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/text/MetaFormatSupport.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import java.text.FieldPosition;\n+import java.text.Format;\n+import java.text.ParsePosition;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+/**\n+ * metaFormat support.\n+ * \n+ * @see {@link ExtendedMessageFormat}\n+ * @author Matt Benson\n+ * @since 2.4\n+ * @version $Id$\n+ */\n+public abstract class MetaFormatSupport extends Format {\n+\n+    private static final char END_FE = '}';\n+    private static final char START_FE = '{';\n+    private static final char QUOTE = '\\'';\n+\n+    /**\n+     * Invert the specified Map.\n+     * \n+     * @param map\n+     *            the Map to invert.\n+     * @return a new Map instance.\n+     * @throws NullPointerException\n+     *             if <code>map</code> is <code>null</code>.\n+     */\n+    protected Map invert(Map map) {\n+        Map result = new HashMap(map.size());\n+        for (Iterator iter = map.entrySet().iterator(); iter.hasNext();) {\n+            Map.Entry entry = (Map.Entry) iter.next();\n+            result.put(entry.getValue(), entry.getKey());\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Find the end of the subformat.\n+     * \n+     * @param source\n+     * @param pos\n+     */\n+    protected void seekFormatElementEnd(String source, ParsePosition pos) {\n+        int depth = 1;\n+        boolean quote = false;\n+        for (; pos.getIndex() < source.length(); next(pos)) {\n+            switch (source.charAt(pos.getIndex())) {\n+            case QUOTE:\n+                quote ^= true;\n+                break;\n+            case START_FE:\n+                depth += quote ? 0 : 1;\n+                break;\n+            case END_FE:\n+                depth -= quote ? 0 : 1;\n+                if (depth == 0) {\n+                    return;\n+                }\n+                break;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Advance the parse index by 1.\n+     * \n+     * @param pos\n+     *            the ParsePosition to advance.\n+     * @return <code>pos</code>\n+     */\n+    protected ParsePosition next(ParsePosition pos) {\n+        pos.setIndex(pos.getIndex() + 1);\n+        return pos;\n+    }\n+\n+    // provide default javadoc >;)\n+    /**\n+     * Parse an object from the specified String and ParsePosition. If an error\n+     * occurs <code>pos.getErrorIndex()</code> will contain a value >= zero,\n+     * indicating the index at which the parse error occurred.\n+     * \n+     * @param source\n+     *            String to parse\n+     * @param pos\n+     *            ParsePosition marking index into <code>source</code>\n+     * @return Object parsed\n+     */\n+    public abstract Object parseObject(String source, ParsePosition pos);\n+\n+    /**\n+     * Format the specified object, appending to the given StringBuffer, and\n+     * optionally respecting the specified FieldPosition.\n+     * \n+     * @param obj\n+     *            the object to format\n+     * @param toAppendTo\n+     *            the StringBuffer to which the formatted object should be\n+     *            appended\n+     * @param pos\n+     *            FieldPosition associated with <code>obj</code>\n+     * @return <code>toAppendTo</code>\n+     * @throws NullPointerException\n+     *             if <code>toAppendTo</code> or <code>pos</code> is\n+     *             <code>null</code>\n+     * @throws IllegalArgumentException\n+     *             if unable to format <code>obj</code>\n+     */\n+    public abstract StringBuffer format(Object obj, StringBuffer toAppendTo,\n+            FieldPosition pos);\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/text/NameKeyedMetaFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import java.text.FieldPosition;\n+import java.text.Format;\n+import java.text.ParsePosition;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.ObjectUtils;\n+\n+/**\n+ * Basic metaFormat that requires enough configuration information to\n+ * parse/format other Formats for use by ExtendedMessageFormat.\n+ * \n+ * @see {@link ExtendedMessageFormat}\n+ * @author Matt Benson\n+ * @since 2.4\n+ * @version $Id$\n+ */\n+public class NameKeyedMetaFormat extends MetaFormatSupport {\n+    private static final long serialVersionUID = 5963121202601122213L;\n+\n+    private static final char TRIGGER_END = '}';\n+    private static final char TRIGGER_SUBFORMAT = ',';\n+\n+    /**\n+     * Provides a builder with a fluent interface. Example:\n+     * <p>\n+     * <code>\n+     * <pre>\n+     * NameKeyedMetaFormat nkmf = new NameKeyedMetaFormat.Builder().put(&quot;foo&quot;,\n+     *         new FooFormat()).put(&quot;bar&quot;, new BarFormat())\n+     *         .put(&quot;baz&quot;, new BazFormat()).toNameKeyedMetaFormat();\n+     * </pre></code>\n+     * </p>\n+     */\n+    public static class Builder {\n+        private HashMap keyedFormats = new HashMap();\n+\n+        /**\n+         * Add the specified format with the specified string key.\n+         * \n+         * @param key\n+         * @param format\n+         * @return\n+         */\n+        public Builder put(String key, Format format) {\n+            keyedFormats.put(key, format);\n+            return this;\n+        }\n+\n+        /**\n+         * Render the {@link NameKeyedMetaFormat} instance from this Builder.\n+         * \n+         * @return NameKeyedMetaFormat\n+         */\n+        public NameKeyedMetaFormat toNameKeyedMetaFormat() {\n+            return new NameKeyedMetaFormat(keyedFormats);\n+        }\n+    }\n+\n+    private Map/* <String, Format> */keyedFormats = new HashMap();\n+\n+    /**\n+     * Create a new NameKeyedMetaFormat.\n+     */\n+    public NameKeyedMetaFormat(Map keyedFormats) {\n+        this.keyedFormats = keyedFormats;\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.lang.text.MetaFormatSupport#format(java.lang.Object,\n+     *      java.lang.StringBuffer, java.text.FieldPosition)\n+     */\n+    public StringBuffer format(Object obj, StringBuffer toAppendTo,\n+            FieldPosition pos) {\n+        int start = toAppendTo.length();\n+        // first try to match a sans-subformat format:\n+        for (Iterator iter = iterateKeys(); iter.hasNext();) {\n+            Object key = iter.next();\n+            if (ObjectUtils.equals(keyedFormats.get(key), obj)) {\n+                return toAppendTo.append(key);\n+            }\n+        }\n+        // now try again with subformats:\n+        for (Iterator iter = iterateKeys(); iter.hasNext();) {\n+            Object key = iter.next();\n+            try {\n+                ((Format) keyedFormats.get(key)).format(obj, toAppendTo, pos);\n+                if (toAppendTo.length() > start) {\n+                    toAppendTo.insert(start, ',');\n+                }\n+                return toAppendTo.insert(start, key);\n+            } catch (Exception e) {\n+                continue;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Cannot format \" + obj);\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.lang.text.MetaFormatSupport#parseObject(java.lang.String,\n+     *      java.text.ParsePosition)\n+     */\n+    public Object parseObject(String source, ParsePosition pos) {\n+        int start = pos.getIndex();\n+        boolean subformat = false;\n+        for (; pos.getIndex() < source.length(); next(pos)) {\n+            char c = source.charAt(pos.getIndex());\n+            if (c == TRIGGER_SUBFORMAT) {\n+                subformat = true;\n+                break;\n+            }\n+            if (c == TRIGGER_END) {\n+                break;\n+            }\n+        }\n+        String key = source.substring(start, pos.getIndex());\n+        Format format = (Format) keyedFormats.get(key);\n+        if (format == null) {\n+            format = (Format) keyedFormats.get(key.trim());\n+            if (format == null) {\n+                pos.setErrorIndex(start);\n+                return null;\n+            }\n+        }\n+        if (subformat) {\n+            return format.parseObject(source, next(pos));\n+        }\n+        return format;\n+    }\n+\n+    /**\n+     * Extension point to alter the iteration order of the delegate format keys.\n+     * \n+     * @return Iterator.\n+     */\n+    protected Iterator iterateKeys() {\n+        return keyedFormats.keySet().iterator();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/text/NumberMetaFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.text.FieldPosition;\n+import java.text.NumberFormat;\n+import java.text.ParsePosition;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+/**\n+ * Stock \"number\" MetaFormat.\n+ * \n+ * @see {@link ExtendedMessageFormat}\n+ * @author Matt Benson\n+ * @since 2.4\n+ * @version $Id$\n+ */\n+public class NumberMetaFormat extends MetaFormatSupport {\n+    private static final long serialVersionUID = -5876397363537288952L;\n+    private static final String DEFAULT = \"\";\n+    private static final String INTEGER = \"integer\";\n+    private static final String CURRENCY = \"currency\";\n+    private static final String PERCENT = \"percent\";\n+\n+    private Locale locale;\n+\n+    private transient Map subformats;\n+    private transient Map reverseSubformats;\n+    private transient DecimalFormatSymbols decimalFormatSymbols;\n+\n+    /**\n+     * Create a new NumberMetaFormat.\n+     */\n+    public NumberMetaFormat() {\n+        this(Locale.getDefault());\n+    }\n+\n+    /**\n+     * Create a new NumberMetaFormat.\n+     * \n+     * @param locale\n+     */\n+    public NumberMetaFormat(Locale locale) {\n+        super();\n+        this.locale = locale;\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.lang.text.AbstractMetaFormat#format(java.lang.Object,\n+     *      java.lang.StringBuffer, java.text.FieldPosition)\n+     */\n+    public StringBuffer format(Object obj, StringBuffer toAppendTo,\n+            FieldPosition pos) {\n+        initialize();\n+        String subformat = (String) reverseSubformats.get(obj);\n+        if (subformat != null) {\n+            return toAppendTo.append(subformat);\n+        }\n+        if (obj instanceof DecimalFormat) {\n+            DecimalFormat df = (DecimalFormat) obj;\n+            if (df.getDecimalFormatSymbols().equals(decimalFormatSymbols)) {\n+                return toAppendTo.append(df.toPattern());\n+            }\n+        }\n+        throw new IllegalArgumentException();\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see java.text.Format#parseObject(java.lang.String,\n+     *      java.text.ParsePosition)\n+     */\n+    public Object parseObject(String source, ParsePosition pos) {\n+        int start = pos.getIndex();\n+        seekFormatElementEnd(source, pos);\n+        if (pos.getErrorIndex() >= 0) {\n+            return null;\n+        }\n+        String subformat = source.substring(start, pos.getIndex()).trim();\n+        initialize();\n+        Object result = subformats.get(subformat);\n+        if (result != null) {\n+            return result;\n+        }\n+        return new DecimalFormat(subformat, decimalFormatSymbols);\n+    }\n+\n+    /**\n+     * Get the locale in use by this <code>NumberMetaFormat</code>.\n+     * \n+     * @return Locale\n+     */\n+    public Locale getLocale() {\n+        return locale;\n+    }\n+\n+    private synchronized void initialize() {\n+        if (subformats == null) {\n+            subformats = new HashMap();\n+            subformats.put(DEFAULT, NumberFormat.getInstance(getLocale()));\n+            subformats.put(INTEGER, NumberFormat\n+                    .getIntegerInstance(getLocale()));\n+            subformats.put(CURRENCY, NumberFormat\n+                    .getCurrencyInstance(getLocale()));\n+            subformats.put(PERCENT, NumberFormat\n+                    .getPercentInstance(getLocale()));\n+\n+            reverseSubformats = invert(subformats);\n+            decimalFormatSymbols = new DecimalFormatSymbols(getLocale());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/text/TimeMetaFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import java.text.DateFormat;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+/**\n+ * Stock \"time\" MetaFormat.\n+ * \n+ * @see {@link ExtendedMessageFormat}\n+ * @author Matt Benson\n+ * @since 2.4\n+ * @version $Id$\n+ */\n+public class TimeMetaFormat extends DateMetaFormatSupport {\n+    private static final long serialVersionUID = -4959095416302142342L;\n+\n+    /**\n+     * Create a new TimeMetaFormat.\n+     */\n+    public TimeMetaFormat() {\n+        super();\n+    }\n+\n+    /**\n+     * Create a new NumberMetaFormat.\n+     * \n+     * @param locale\n+     */\n+    public TimeMetaFormat(Locale locale) {\n+        super(locale);\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.lang.text.AbstractDateMetaFormat#createSubformatInstance(int)\n+     */\n+    protected DateFormat createSubformatInstance(int style) {\n+        return DateFormat.getTimeInstance(style, getLocale());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.lang.text.AbstractDateMetaFormat#createReverseStyleMap()\n+     */\n+    protected Map createInverseStyleMap() {\n+        Map invertMe = createStyleMap();\n+        invertMe.remove(DEFAULT);\n+        invertMe.remove(FULL);\n+        return invert(invertMe);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/text/AbstractMessageFormatTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import java.text.DateFormat;\n+import java.text.MessageFormat;\n+import java.util.Calendar;\n+import java.util.GregorianCalendar;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Abstract testcase to verify behavior of default-configuration\n+ * ExtendedMessageFormat vs. MessageFormat.\n+ * \n+ * @author Matt Benson\n+ * @since 2.4\n+ * @version $Id$\n+ */\n+public abstract class AbstractMessageFormatTest extends TestCase {\n+    protected static final Object[] NUMBERS = { new Double(0.1),\n+            new Double(1.1), new Double(2.1) };\n+\n+    protected static final Object[] DATES = {\n+            new GregorianCalendar(1970, Calendar.JANUARY, 01, 0, 15, 20)\n+                    .getTime(),\n+            new GregorianCalendar(1970, Calendar.FEBRUARY, 02, 12, 30, 35)\n+                    .getTime(),\n+            new GregorianCalendar(1970, Calendar.MARCH, 03, 18, 45, 50)\n+                    .getTime() };\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see junit.framework.TestCase#setUp()\n+     */\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    protected abstract MessageFormat createMessageFormat(String pattern);\n+\n+    protected void doAssertions(String expected, String pattern, Object[] args) {\n+        doAssertions(expected, pattern, args, pattern);\n+    }\n+\n+    protected void doAssertions(String expected, String pattern, Object[] args,\n+            String toPattern) {\n+        MessageFormat f = createMessageFormat(pattern);\n+        assertEquals(expected, f.format(args));\n+        assertEquals(toPattern, f.toPattern());\n+    }\n+\n+    public void testPlain() {\n+        StringBuffer pattern = new StringBuffer();\n+        for (int i = 0; i < NUMBERS.length; i++) {\n+            if (i > 0) {\n+                pattern.append(\"; \");\n+            }\n+            pattern.append(\"Object \").append(i).append(\": \").append(NUMBERS[i]);\n+        }\n+        String p = pattern.toString();\n+        doAssertions(p, p, NUMBERS);\n+    }\n+\n+    public void testSimple() {\n+        doAssertions(\"Object 0: 0.1; Object 1: 1.1; Object 2: 2.1\",\n+                \"Object 0: {0}; Object 1: {1}; Object 2: {2}\", NUMBERS);\n+    }\n+\n+    public void testNumber() {\n+        doAssertions(\n+                \"Number 0: 0.1; Number 1: 1.1; Number 2: 2.1\",\n+                \"Number 0: {0,number}; Number 1: {1,number}; Number 2: {2,number}\",\n+                NUMBERS);\n+    }\n+\n+    public void testNumberLooseFormatting() {\n+        doAssertions(\n+                \"Number 0: 0.1; Number 1: 1.1; Number 2: 2.1\",\n+                \"Number 0: {0, number }; Number 1: {1, number }; Number 2: {2, number }\",\n+                NUMBERS,\n+                \"Number 0: {0,number}; Number 1: {1,number}; Number 2: {2,number}\");\n+    }\n+\n+    public void testInteger() {\n+        doAssertions(\n+                \"Number 0: 0; Number 1: 1; Number 2: 2\",\n+                \"Number 0: {0,number,integer}; Number 1: {1,number,integer}; Number 2: {2,number,integer}\",\n+                NUMBERS);\n+    }\n+\n+    public void testIntegerLooseFormatting() {\n+        doAssertions(\n+                \"Number 0: 0; Number 1: 1; Number 2: 2\",\n+                \"Number 0: {0, number , integer }; Number 1: {1, number , integer }; Number 2: {2, number , integer }\",\n+                NUMBERS,\n+                \"Number 0: {0,number,integer}; Number 1: {1,number,integer}; Number 2: {2,number,integer}\");\n+    }\n+\n+    public void testCurrency() {\n+        doAssertions(\n+                \"Number 0: $0.10; Number 1: $1.10; Number 2: $2.10\",\n+                \"Number 0: {0,number,currency}; Number 1: {1,number,currency}; Number 2: {2,number,currency}\",\n+                NUMBERS);\n+    }\n+\n+    public void testPercent() {\n+        doAssertions(\n+                \"Number 0: 10%; Number 1: 110%; Number 2: 210%\",\n+                \"Number 0: {0,number,percent}; Number 1: {1,number,percent}; Number 2: {2,number,percent}\",\n+                NUMBERS);\n+    }\n+\n+    public void testNumberPattern() {\n+        doAssertions(\n+                \"Number 0: 000.100; Number 1: 001.100; Number 2: 002.100\",\n+                \"Number 0: {0,number,#000.000}; Number 1: {1,number,#000.000}; Number 2: {2,number,#000.000}\",\n+                NUMBERS);\n+    }\n+\n+    public void testDate() {\n+        doAssertions(\n+                \"Date 0: Jan 1, 1970; Date 1: Feb 2, 1970; Date 2: Mar 3, 1970\",\n+                \"Date 0: {0,date}; Date 1: {1,date}; Date 2: {2,date}\", DATES);\n+    }\n+\n+    public void testDateLooseFormatting() {\n+        doAssertions(\n+                \"Date 0: Jan 1, 1970; Date 1: Feb 2, 1970; Date 2: Mar 3, 1970\",\n+                \"Date 0: {0, date }; Date 1: {1, date }; Date 2: {2,  date  }\",\n+                DATES, \"Date 0: {0,date}; Date 1: {1,date}; Date 2: {2,date}\");\n+    }\n+\n+    public void testShortDate() {\n+        doAssertions(\n+                \"Date 0: 1/1/70; Date 1: 2/2/70; Date 2: 3/3/70\",\n+                \"Date 0: {0,date,short}; Date 1: {1,date,short}; Date 2: {2,date,short}\",\n+                DATES);\n+    }\n+\n+    public void testShortDateLooseFormatting() {\n+        doAssertions(\n+                \"Date 0: 1/1/70; Date 1: 2/2/70; Date 2: 3/3/70\",\n+                \"Date 0: {0, date , short }; Date 1: {1,  date  , short }; Date 2: {2, date ,  short  }\",\n+                DATES,\n+                \"Date 0: {0,date,short}; Date 1: {1,date,short}; Date 2: {2,date,short}\");\n+    }\n+\n+    public void testMediumDate() {\n+        doAssertions(\n+                \"Date 0: Jan 1, 1970; Date 1: Feb 2, 1970; Date 2: Mar 3, 1970\",\n+                \"Date 0: {0,date,medium}; Date 1: {1,date,medium}; Date 2: {2,date,medium}\",\n+                DATES, \"Date 0: {0,date}; Date 1: {1,date}; Date 2: {2,date}\");\n+    }\n+\n+    public void testLongDate() {\n+        doAssertions(\n+                \"Date 0: January 1, 1970; Date 1: February 2, 1970; Date 2: March 3, 1970\",\n+                \"Date 0: {0,date,long}; Date 1: {1,date,long}; Date 2: {2,date,long}\",\n+                DATES);\n+    }\n+\n+    public void testFullDate() {\n+        doAssertions(\n+                \"Date 0: Thursday, January 1, 1970; Date 1: Monday, February 2, 1970; Date 2: Tuesday, March 3, 1970\",\n+                \"Date 0: {0,date,full}; Date 1: {1,date,full}; Date 2: {2,date,full}\",\n+                DATES);\n+    }\n+\n+    public void testDatePattern() {\n+        doAssertions(\n+                \"Date 0: AD1970.1; Date 1: AD1970.33; Date 2: AD1970.62\",\n+                \"Date 0: {0,date,Gyyyy.D}; Date 1: {1,date,Gyyyy.D}; Date 2: {2,date,Gyyyy.D}\",\n+                DATES);\n+    }\n+\n+    public void testTime() {\n+        doAssertions(\n+                \"Time 0: 12:15:20 AM; Time 1: 12:30:35 PM; Time 2: 6:45:50 PM\",\n+                \"Time 0: {0,time}; Time 1: {1,time}; Time 2: {2,time}\", DATES);\n+    }\n+\n+    public void testShortTime() {\n+        doAssertions(\n+                \"Time 0: 12:15 AM; Time 1: 12:30 PM; Time 2: 6:45 PM\",\n+                \"Time 0: {0,time,short}; Time 1: {1,time,short}; Time 2: {2,time,short}\",\n+                DATES);\n+    }\n+\n+    public void testMediumTime() {\n+        doAssertions(\n+                \"Time 0: 12:15:20 AM; Time 1: 12:30:35 PM; Time 2: 6:45:50 PM\",\n+                \"Time 0: {0,time,medium}; Time 1: {1,time,medium}; Time 2: {2,time,medium}\",\n+                DATES, \"Time 0: {0,time}; Time 1: {1,time}; Time 2: {2,time}\");\n+    }\n+\n+    public void testLongTime() {\n+        DateFormat df = DateFormat.getTimeInstance(DateFormat.LONG);\n+        StringBuffer expected = new StringBuffer();\n+        for (int i = 0; i < DATES.length; i++) {\n+            if (i > 0) {\n+                expected.append(\"; \");\n+            }\n+            expected.append(\"Time \").append(i).append(\": \").append(\n+                    df.format(DATES[i]));\n+        }\n+        doAssertions(\n+                expected.toString(),\n+                \"Time 0: {0,time,long}; Time 1: {1,time,long}; Time 2: {2,time,long}\",\n+                DATES);\n+    }\n+\n+    public void testFullTime() {\n+        DateFormat df = DateFormat.getTimeInstance(DateFormat.FULL);\n+        StringBuffer expected = new StringBuffer();\n+        for (int i = 0; i < DATES.length; i++) {\n+            if (i > 0) {\n+                expected.append(\"; \");\n+            }\n+            expected.append(\"Time \").append(i).append(\": \").append(\n+                    df.format(DATES[i]));\n+        }\n+        doAssertions(\n+                expected.toString(),\n+                \"Time 0: {0,time,full}; Time 1: {1,time,full}; Time 2: {2,time,full}\",\n+                DATES,\n+                \"Time 0: {0,time,long}; Time 1: {1,time,long}; Time 2: {2,time,long}\");\n+    }\n+\n+    public void testTimePattern() {\n+        doAssertions(\n+                \"Time 0: AM01520; Time 1: PM123035; Time 2: PM184550\",\n+                \"Time 0: {0,time,aHms}; Time 1: {1,time,aHms}; Time 2: {2,time,aHms}\",\n+                DATES,\n+                \"Time 0: {0,date,aHms}; Time 1: {1,date,aHms}; Time 2: {2,date,aHms}\");\n+    }\n+\n+    public void testChoice() {\n+        String choice = \"0.0#x|1.0#y|2.0#z\";\n+        StringBuffer pattern = new StringBuffer();\n+        for (int i = 0; i < 3; i++) {\n+            if (i > 0) {\n+                pattern.append(\"; \");\n+            }\n+            pattern.append(\"Choice \").append(i).append(\": {\").append(i).append(\n+                    \",choice,\").append(choice).append(\"}\");\n+        }\n+        doAssertions(\"Choice 0: x; Choice 1: y; Choice 2: z\", pattern\n+                .toString(), NUMBERS);\n+    }\n+\n+    public void testChoiceLooseFormatting() {\n+        String choice = \"0.0#x |1.0#y |2.0#z \";\n+        StringBuffer pattern = new StringBuffer();\n+        for (int i = 0; i < 3; i++) {\n+            if (i > 0) {\n+                pattern.append(\"; \");\n+            }\n+            pattern.append(\"Choice \").append(i).append(\": {\").append(i).append(\n+                    \",choice,\").append(choice).append(\"}\");\n+        }\n+        doAssertions(\"Choice 0: x ; Choice 1: y ; Choice 2: z \", pattern\n+                .toString(), NUMBERS);\n+    }\n+\n+    public void testChoiceRecursive() {\n+        String choice = \"0.0#{0}|1.0#{1}|2.0#{2}\";\n+        StringBuffer pattern = new StringBuffer();\n+        for (int i = 0; i < 3; i++) {\n+            if (i > 0) {\n+                pattern.append(\"; \");\n+            }\n+            pattern.append(\"Choice \").append(i).append(\": {\").append(i).append(\n+                    \",choice,\").append(choice).append(\"}\");\n+        }\n+        doAssertions(\"Choice 0: 0.1; Choice 1: 1.1; Choice 2: 2.1\", pattern\n+                .toString(), NUMBERS);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/text/ExtendedMessageFormatBaselineTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import java.text.MessageFormat;\n+import java.util.Locale;\n+\n+/**\n+ * Baseline tests for {@link ExtendedMessageFormat}\n+ * \n+ * @author Matt Benson\n+ * @since 2.4\n+ * @version $Id$\n+ */\n+public class ExtendedMessageFormatBaselineTest extends AbstractMessageFormatTest {\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.lang.text.AbstractMessageFormatTest#createMessageFormat(java.lang.String)\n+     */\n+    protected MessageFormat createMessageFormat(String pattern) {\n+        return new ExtendedMessageFormat(pattern, ExtendedMessageFormat.createDefaultMetaFormat(Locale.US));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/text/MessageFormatExtensionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import java.text.FieldPosition;\n+import java.text.Format;\n+import java.text.MessageFormat;\n+import java.text.ParsePosition;\n+import java.util.Calendar;\n+import java.util.GregorianCalendar;\n+import java.util.Locale;\n+\n+/**\n+ * Extension tests for {@link ExtendedMessageFormat}\n+ * \n+ * @author Matt Benson\n+ * @since 2.4\n+ * @version $Id$\n+ */\n+public class MessageFormatExtensionTest extends AbstractMessageFormatTest {\n+\n+    static class ProperNameCapitalizationFormat extends Format {\n+        private static final long serialVersionUID = -6081911520622186866L;\n+        private static final StrMatcher MATCH = StrMatcher\n+                .charSetMatcher(\" ,.\");\n+\n+        /*\n+         * (non-Javadoc)\n+         * \n+         * @see java.text.Format#format(java.lang.Object,\n+         *      java.lang.StringBuffer, java.text.FieldPosition)\n+         */\n+        public StringBuffer format(Object obj, StringBuffer toAppendTo,\n+                FieldPosition fpos) {\n+            char[] buffer = String.valueOf(obj).toCharArray();\n+            ParsePosition pos = new ParsePosition(0);\n+            while (pos.getIndex() < buffer.length) {\n+                char c = buffer[pos.getIndex()];\n+                if (Character.isLowerCase(c)) {\n+                    c = Character.toUpperCase(c);\n+                }\n+                if (Character.isUpperCase(c)) {\n+                    toAppendTo.append(c);\n+                    next(pos);\n+                }\n+                int start = pos.getIndex();\n+                seekDelimiter(buffer, pos);\n+                toAppendTo.append(new String(buffer, start, pos.getIndex()\n+                        - start).toLowerCase());\n+            }\n+            return toAppendTo;\n+        }\n+\n+        /**\n+         * Unable to do much; return the String.\n+         */\n+        public Object parseObject(String source, ParsePosition pos) {\n+            return source.substring(pos.getIndex());\n+        }\n+\n+        private static void seekDelimiter(char[] buffer, ParsePosition pos) {\n+            for (; pos.getIndex() < buffer.length\n+                    && MATCH.isMatch(buffer, pos.getIndex()) == 0; next(pos))\n+                ;\n+            if (pos.getIndex() >= buffer.length) {\n+                return;\n+            }\n+            int len = 0;\n+            do {\n+                len = MATCH.isMatch(buffer, pos.getIndex());\n+                pos.setIndex(pos.getIndex() + len);\n+            } while (len > 0 && pos.getIndex() < buffer.length);\n+        }\n+\n+        private static void next(ParsePosition pos) {\n+            pos.setIndex(pos.getIndex() + 1);\n+        }\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.lang.text.AbstractMessageFormatTest#createMessageFormat(java.lang.String)\n+     */\n+    protected MessageFormat createMessageFormat(String pattern) {\n+        return new ExtendedMessageFormat(pattern, new MultiFormat.Builder()\n+                .add(ExtendedMessageFormat.createDefaultMetaFormat(Locale.US)).add(\n+                        new NameKeyedMetaFormat.Builder().put(\"properName\",\n+                                new ProperNameCapitalizationFormat())\n+                                .toNameKeyedMetaFormat()).toMultiFormat());\n+    }\n+\n+    public void testProperName() {\n+        doAssertions(\"John Q. Public; John Q. Public\",\n+                \"{0,properName}; {1,properName}\", new String[] {\n+                        \"JOHN Q. PUBLIC\", \"john q. public\" });\n+    }\n+\n+    public void testMixed() {\n+        doAssertions(\"John Q. Public was born on Thursday, January 1, 1970.\",\n+                \"{0,properName} was born on {1,date,full}.\", new Object[] {\n+                        \"john q. public\",\n+                        new GregorianCalendar(1970, Calendar.JANUARY, 01, 0,\n+                                15, 20).getTime() });\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/text/MessageFormatTest.java\n+package org.apache.commons.lang.text;\n+\n+import java.text.MessageFormat;\n+import java.util.Locale;\n+\n+/**\n+ * Baseline tests for java.text.MessageFormat.\n+ * \n+ * @author Matt Benson\n+ * @since 2.4\n+ * @version $Id$\n+ */\n+public class MessageFormatTest extends AbstractMessageFormatTest {\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.lang.text.AbstractMessageFormatTest#createMessageFormat(java.lang.String)\n+     */\n+    protected MessageFormat createMessageFormat(String pattern) {\n+        return new MessageFormat(pattern, Locale.US);\n+    }\n+}\n--- a/src/test/org/apache/commons/lang/text/TextTestSuite.java\n+++ b/src/test/org/apache/commons/lang/text/TextTestSuite.java\n         suite.addTest(StrSubstitutorTest.suite());\n         suite.addTest(StrTokenizerTest.suite());\n         suite.addTestSuite(MultiFormatTest.class);\n+        suite.addTestSuite(MessageFormatTest.class);\n+        suite.addTestSuite(ExtendedMessageFormatBaselineTest.class);\n+        suite.addTestSuite(MessageFormatExtensionTest.class);\n         return suite;\n     }\n ", "timestamp": 1193756814, "metainfo": ""}