{"sha": "bc495033c834eeaaa1810eeebfbc65431ac1e48d", "log": "Adding BasicThreadFactory class. Same as Oliver's original patch in LANG-582, with an @since 3.0 added  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/lang3/concurrent/BasicThreadFactory.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.concurrent;\n+\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * <p>\n+ * An implementation of the {@code ThreadFactory} interface that provides some\n+ * configuration options for the threads it creates.\n+ * </p>\n+ * <p>\n+ * A {@code ThreadFactory} is used for instance by an {@code ExecutorService} to\n+ * create the threads it uses for executing tasks. In many cases users do not\n+ * have to care about a {@code ThreadFactory} because the default one used by an\n+ * {@code ExecutorService} will do. However, if there are special requirements\n+ * for the threads, a custom {@code ThreadFactory} has to be created.\n+ * </p>\n+ * <p>\n+ * This class provides some frequently needed configuration options for the\n+ * threads it creates. These are the following:\n+ * <ul>\n+ * <li>A name pattern for the threads created by this factory can be specified.\n+ * This is often useful if an application uses multiple executor services for\n+ * different purposes. If the names of the threads used by these services have\n+ * meaningful names, log output or exception traces can be much easier to read.\n+ * Naming patterns are <em>format strings</em> as used by the {@code\n+ * String.format()} method. The string can contain the place holder {@code %d}\n+ * which will be replaced by the number of the current thread ({@code\n+ * ThreadFactoryImpl} keeps a counter of the threads it has already created).\n+ * For instance, the naming pattern {@code \"My %d. worker thread\"} will result\n+ * in thread names like {@code \"My 1. worker thread\"}, {@code\n+ * \"My 2. worker thread\"} and so on.</li>\n+ * <li>A flag whether the threads created by this factory should be daemon\n+ * threads. This can impact the exit behavior of the current Java application\n+ * because the JVM shuts down if there are only daemon threads running.</li>\n+ * <li>The priority of the thread. Here an integer value can be provided. The\n+ * {@code java.lang.Thread} class defines constants for valid ranges of priority\n+ * values.</li>\n+ * <li>The {@code UncaughtExceptionHandler} for the thread. This handler is\n+ * called if an uncaught exception occurs within the thread.</li>\n+ * </ul>\n+ * </p>\n+ * <p>\n+ * {@code BasicThreadFactory} wraps another thread factory which actually\n+ * creates new threads. The configuration options are set on the threads created\n+ * by the wrapped thread factory. On construction time the factory to be wrapped\n+ * can be specified. If none is provided, a default {@code ThreadFactory} is\n+ * used.\n+ * </p>\n+ * <p>\n+ * Instances of {@code BasicThreadFactory} are not created directly, but the\n+ * nested {@code Builder} class is used for this purpose. Using the builder only\n+ * the configuration options an application is interested in need to be set. The\n+ * following example shows how a {@code BasicThreadFactory} is created and\n+ * installed in an {@code ExecutorService}:\n+ *\n+ * <pre>\n+ * // Create a factory that produces daemon threads with a naming pattern and\n+ * // a priority\n+ * BasicThreadFactory factory = new BasicThreadFactory.Builder()\n+ *     .namingPattern(&quot;workerthread-%d&quot;)\n+ *     .daemon(true)\n+ *     .priority(Thread.MAX_PRIORITY)\n+ *     .build();\n+ * // Create an executor service for single-threaded execution\n+ * ExecutorService exec = Executors.newSingleThreadExecutor(factory);\n+ * </pre>\n+ * </p>\n+ *\n+ * @version $Id: $\n+ * @since 3.0\n+ */\n+public class BasicThreadFactory implements ThreadFactory {\n+    /** A counter for the threads created by this factory. */\n+    private final AtomicLong threadCounter;\n+\n+    /** Stores the wrapped factory. */\n+    private final ThreadFactory wrappedFactory;\n+\n+    /** Stores the uncaught exception handler. */\n+    private final Thread.UncaughtExceptionHandler uncaughtExceptionHandler;\n+\n+    /** Stores the naming pattern for newly created threads. */\n+    private final String namingPattern;\n+\n+    /** Stores the priority. */\n+    private final Integer priority;\n+\n+    /** Stores the daemon status flag. */\n+    private final Boolean daemonFlag;\n+\n+    /**\n+     * Creates a new instance of {@code ThreadFactoryImpl} and configures it\n+     * from the specified {@code Builder} object.\n+     *\n+     * @param builder the {@code Builder} object\n+     */\n+    private BasicThreadFactory(Builder builder) {\n+        if (builder.wrappedFactory == null) {\n+            wrappedFactory = Executors.defaultThreadFactory();\n+        } else {\n+            wrappedFactory = builder.wrappedFactory;\n+        }\n+\n+        namingPattern = builder.namingPattern;\n+        priority = builder.priority;\n+        daemonFlag = builder.daemonFlag;\n+        uncaughtExceptionHandler = builder.exceptionHandler;\n+\n+        threadCounter = new AtomicLong();\n+    }\n+\n+    /**\n+     * Returns the wrapped {@code ThreadFactory}. This factory is used for\n+     * actually creating threads. This method never returns <b>null</b>. If no\n+     * {@code ThreadFactory} was passed when this object was created, a default\n+     * thread factory is returned.\n+     *\n+     * @return the wrapped {@code ThreadFactory}\n+     */\n+    public final ThreadFactory getWrappedFactory() {\n+        return wrappedFactory;\n+    }\n+\n+    /**\n+     * Returns the naming pattern for naming newly created threads. Result can\n+     * be <b>null</b> if no naming pattern was provided.\n+     *\n+     * @return the naming pattern\n+     */\n+    public final String getNamingPattern() {\n+        return namingPattern;\n+    }\n+\n+    /**\n+     * Returns the daemon flag. This flag determines whether newly created\n+     * threads should be daemon threads. If <b>true</b>, this factory object\n+     * calls {@code setDaemon(true)} on the newly created threads. Result can be\n+     * <b>null</b> if no daemon flag was provided at creation time.\n+     *\n+     * @return the daemon flag\n+     */\n+    public final Boolean getDaemonFlag() {\n+        return daemonFlag;\n+    }\n+\n+    /**\n+     * Returns the priority of the threads created by this factory. Result can\n+     * be <b>null</b> if no priority was specified.\n+     *\n+     * @return the priority for newly created threads\n+     */\n+    public final Integer getPriority() {\n+        return priority;\n+    }\n+\n+    /**\n+     * Returns the {@code UncaughtExceptionHandler} for the threads created by\n+     * this factory. Result can be <b>null</b> if no handler was provided.\n+     *\n+     * @return the {@code UncaughtExceptionHandler}\n+     */\n+    public final Thread.UncaughtExceptionHandler getUncaughtExceptionHandler() {\n+        return uncaughtExceptionHandler;\n+    }\n+\n+    /**\n+     * Returns the number of threads this factory has already created. This\n+     * class maintains an internal counter that is incremented each time the\n+     * {@link #newThread(Runnable)} method is invoked.\n+     *\n+     * @return the number of threads created by this factory\n+     */\n+    public long getThreadCount() {\n+        return threadCounter.get();\n+    }\n+\n+    /**\n+     * Creates a new thread. This implementation delegates to the wrapped\n+     * factory for creating the thread. Then, on the newly created thread the\n+     * corresponding configuration options are set.\n+     *\n+     * @param r the {@code Runnable} to be executed by the new thread\n+     * @return the newly created thread\n+     */\n+    public Thread newThread(Runnable r) {\n+        Thread t = getWrappedFactory().newThread(r);\n+        initializeThread(t);\n+\n+        return t;\n+    }\n+\n+    /**\n+     * Initializes the specified thread. This method is called by\n+     * {@link #newThread(Runnable)} after a new thread has been obtained from\n+     * the wrapped thread factory. It initializes the thread according to the\n+     * options set for this factory.\n+     *\n+     * @param t the thread to be initialized\n+     */\n+    private void initializeThread(Thread t) {\n+        long count = threadCounter.incrementAndGet();\n+\n+        if (getNamingPattern() != null) {\n+            t.setName(String.format(getNamingPattern(), count));\n+        }\n+\n+        if (getUncaughtExceptionHandler() != null) {\n+            t.setUncaughtExceptionHandler(getUncaughtExceptionHandler());\n+        }\n+\n+        if (getPriority() != null) {\n+            t.setPriority(getPriority().intValue());\n+        }\n+\n+        if (getDaemonFlag() != null) {\n+            t.setDaemon(getDaemonFlag().booleanValue());\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * A <em>builder</em> class for creating instances of {@code\n+     * BasicThreadFactory}.\n+     * </p>\n+     * <p>\n+     * Using this builder class instances of {@code BasicThreadFactory} can be\n+     * created and initialized. The class provides methods that correspond to\n+     * the configuration options supported by {@code BasicThreadFactory}. Method\n+     * chaining is supported. Refer to the documentation of {@code\n+     * BasicThreadFactory} for a usage example.\n+     * </p>\n+     *\n+     * @version $Id: $\n+     */\n+    public static class Builder {\n+        /** The wrapped factory. */\n+        private ThreadFactory wrappedFactory;\n+\n+        /** The uncaught exception handler. */\n+        private Thread.UncaughtExceptionHandler exceptionHandler;\n+\n+        /** The naming pattern. */\n+        private String namingPattern;\n+\n+        /** The priority. */\n+        private Integer priority;\n+\n+        /** The daemon flag. */\n+        private Boolean daemonFlag;\n+\n+        /**\n+         * Sets the {@code ThreadFactory} to be wrapped by the new {@code\n+         * BasicThreadFactory}.\n+         *\n+         * @param factory the wrapped {@code ThreadFactory} (must not be\n+         * <b>null</b>)\n+         * @return a reference to this {@code Builder}\n+         * @throws NullPointerException if the passed in {@code ThreadFactory}\n+         * is <b>null</b>\n+         */\n+        public Builder wrappedFactory(ThreadFactory factory) {\n+            if (factory == null) {\n+                throw new NullPointerException(\n+                        \"Wrapped ThreadFactory must not be null!\");\n+            }\n+\n+            wrappedFactory = factory;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the naming pattern to be used by the new {@code\n+         * BasicThreadFactory}.\n+         *\n+         * @param pattern the naming pattern (must not be <b>null</b>)\n+         * @return a reference to this {@code Builder}\n+         * @throws NullPointerException if the naming pattern is <b>null</b>\n+         */\n+        public Builder namingPattern(String pattern) {\n+            if (pattern == null) {\n+                throw new NullPointerException(\n+                        \"Naming pattern must not be null!\");\n+            }\n+\n+            namingPattern = pattern;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the daemon flag for the new {@code BasicThreadFactory}. If this\n+         * flag is set to <b>true</b> the new thread factory will create daemon\n+         * threads.\n+         *\n+         * @param f the value of the daemon flag\n+         * @return a reference to this {@code Builder}\n+         */\n+        public Builder daemon(boolean f) {\n+            daemonFlag = Boolean.valueOf(f);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the priority for the threads created by the new {@code\n+         * BasicThreadFactory}.\n+         *\n+         * @param prio the priority\n+         * @return a reference to this {@code Builder}\n+         */\n+        public Builder priority(int prio) {\n+            priority = Integer.valueOf(prio);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the uncaught exception handler for the threads created by the\n+         * new {@code BasicThreadFactory}.\n+         *\n+         * @param handler the {@code UncaughtExceptionHandler} (must not be\n+         * <b>null</b>)\n+         * @return a reference to this {@code Builder}\n+         * @throws NullPointerException if the exception handler is <b>null</b>\n+         */\n+        public Builder uncaughtExceptionHandler(\n+                Thread.UncaughtExceptionHandler handler) {\n+            if (handler == null) {\n+                throw new NullPointerException(\n+                        \"Uncaught exception handler must not be null!\");\n+            }\n+\n+            exceptionHandler = handler;\n+            return this;\n+        }\n+\n+        /**\n+         * Resets this builder. All configuration options are set to default\n+         * values. Note: If the {@link #build()} method was called, it is not\n+         * necessary to call {@code reset()} explicitly because this is done\n+         * automatically.\n+         */\n+        public void reset() {\n+            wrappedFactory = null;\n+            exceptionHandler = null;\n+            namingPattern = null;\n+            priority = null;\n+            daemonFlag = null;\n+        }\n+\n+        /**\n+         * Creates a new {@code BasicThreadFactory} with all configuration\n+         * options that have been specified by calling methods on this builder.\n+         * After creating the factory {@link #reset()} is called.\n+         *\n+         * @return the new {@code BasicThreadFactory}\n+         */\n+        public BasicThreadFactory build() {\n+            BasicThreadFactory factory = new BasicThreadFactory(this);\n+            reset();\n+            return factory;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/lang3/concurrent/BasicThreadFactoryTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang3.concurrent;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNotSame;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.concurrent.ThreadFactory;\n+\n+import org.easymock.EasyMock;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ * Test class for {@code BasicThreadFactory}.\n+ *\n+ * @version $Id: $\n+ */\n+public class BasicThreadFactoryTest {\n+    /** Constant for the test naming pattern. */\n+    private static final String PATTERN = \"testThread-%d\";\n+\n+    /** The builder for creating a thread factory. */\n+    private BasicThreadFactory.Builder builder;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        builder = new BasicThreadFactory.Builder();\n+    }\n+\n+    /**\n+     * Tests the default options of a thread factory.\n+     *\n+     * @param factory the factory to be checked\n+     */\n+    private void checkFactoryDefaults(BasicThreadFactory factory) {\n+        assertNull(\"Got a naming pattern\", factory.getNamingPattern());\n+        assertNull(\"Got an exception handler\", factory\n+                .getUncaughtExceptionHandler());\n+        assertNull(\"Got a priority\", factory.getPriority());\n+        assertNull(\"Got a daemon flag\", factory.getDaemonFlag());\n+        assertNotNull(\"No wrapped factory\", factory.getWrappedFactory());\n+    }\n+\n+    /**\n+     * Tests the default values used by the builder.\n+     */\n+    @Test\n+    public void testBuildDefaults() {\n+        BasicThreadFactory factory = builder.build();\n+        checkFactoryDefaults(factory);\n+    }\n+\n+    /**\n+     * Tries to set a null naming pattern.\n+     */\n+    @Test(expected = NullPointerException.class)\n+    public void testBuildNamingPatternNull() {\n+        builder.namingPattern(null);\n+    }\n+\n+    /**\n+     * Tries to set a null wrapped factory.\n+     */\n+    @Test(expected = NullPointerException.class)\n+    public void testBuildWrappedFactoryNull() {\n+        builder.wrappedFactory(null);\n+    }\n+\n+    /**\n+     * Tries to set a null exception handler.\n+     */\n+    @Test(expected = NullPointerException.class)\n+    public void testBuildUncaughtExceptionHandlerNull() {\n+        builder.uncaughtExceptionHandler(null);\n+    }\n+\n+    /**\n+     * Tests the reset() method of the builder.\n+     */\n+    @Test\n+    public void testBuilderReset() {\n+        ThreadFactory wrappedFactory = EasyMock.createMock(ThreadFactory.class);\n+        Thread.UncaughtExceptionHandler exHandler = EasyMock\n+                .createMock(Thread.UncaughtExceptionHandler.class);\n+        EasyMock.replay(wrappedFactory, exHandler);\n+        builder.namingPattern(PATTERN).daemon(true).priority(\n+                Thread.MAX_PRIORITY).uncaughtExceptionHandler(exHandler)\n+                .wrappedFactory(wrappedFactory);\n+        builder.reset();\n+        BasicThreadFactory factory = builder.build();\n+        checkFactoryDefaults(factory);\n+        assertNotSame(\"Wrapped factory not reset\", wrappedFactory, factory\n+                .getWrappedFactory());\n+        EasyMock.verify(wrappedFactory, exHandler);\n+    }\n+\n+    /**\n+     * Tests whether reset() is automatically called after build().\n+     */\n+    @Test\n+    public void testBuilderResetAfterBuild() {\n+        builder.wrappedFactory(EasyMock.createNiceMock(ThreadFactory.class))\n+                .namingPattern(PATTERN).daemon(true).build();\n+        checkFactoryDefaults(builder.build());\n+    }\n+\n+    /**\n+     * Tests whether the naming pattern is applied to new threads.\n+     */\n+    @Test\n+    public void testNewThreadNamingPattern() {\n+        ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);\n+        Runnable r = EasyMock.createMock(Runnable.class);\n+        final int count = 12;\n+        for (int i = 0; i < count; i++) {\n+            EasyMock.expect(wrapped.newThread(r)).andReturn(new Thread());\n+        }\n+        EasyMock.replay(wrapped, r);\n+        BasicThreadFactory factory = builder.wrappedFactory(wrapped)\n+                .namingPattern(PATTERN).build();\n+        for (int i = 0; i < count; i++) {\n+            Thread t = factory.newThread(r);\n+            assertEquals(\"Wrong thread name\", String.format(PATTERN, Long\n+                    .valueOf(i + 1)), t.getName());\n+            assertEquals(\"Wrong thread count\", i + 1, factory.getThreadCount());\n+        }\n+        EasyMock.verify(wrapped, r);\n+    }\n+\n+    /**\n+     * Tests whether the thread name is not modified if no naming pattern is\n+     * set.\n+     */\n+    @Test\n+    public void testNewThreadNoNamingPattern() {\n+        ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);\n+        Runnable r = EasyMock.createMock(Runnable.class);\n+        final String name = \"unchangedThreadName\";\n+        Thread t = new Thread(name);\n+        EasyMock.expect(wrapped.newThread(r)).andReturn(t);\n+        EasyMock.replay(wrapped, r);\n+        BasicThreadFactory factory = builder.wrappedFactory(wrapped).build();\n+        assertSame(\"Wrong thread\", t, factory.newThread(r));\n+        assertEquals(\"Name was changed\", name, t.getName());\n+        EasyMock.verify(wrapped, r);\n+    }\n+\n+    /**\n+     * Helper method for testing whether the daemon flag is taken into account.\n+     *\n+     * @param flag the value of the flag\n+     */\n+    private void checkDaemonFlag(boolean flag) {\n+        ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);\n+        Runnable r = EasyMock.createMock(Runnable.class);\n+        Thread t = new Thread();\n+        EasyMock.expect(wrapped.newThread(r)).andReturn(t);\n+        EasyMock.replay(wrapped, r);\n+        BasicThreadFactory factory = builder.wrappedFactory(wrapped).daemon(\n+                flag).build();\n+        assertSame(\"Wrong thread\", t, factory.newThread(r));\n+        assertEquals(\"Wrong daemon flag\", flag, t.isDaemon());\n+        EasyMock.verify(wrapped, r);\n+    }\n+\n+    /**\n+     * Tests whether daemon threads can be created.\n+     */\n+    @Test\n+    public void testNewThreadDaemonTrue() {\n+        checkDaemonFlag(true);\n+    }\n+\n+    /**\n+     * Tests whether the daemon status of new threads can be turned off.\n+     */\n+    @Test\n+    public void testNewThreadDaemonFalse() {\n+        checkDaemonFlag(false);\n+    }\n+\n+    /**\n+     * Tests whether the daemon flag is not touched on newly created threads if\n+     * it is not specified.\n+     */\n+    @Test\n+    public void testNewThreadNoDaemonFlag() {\n+        ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);\n+        Runnable r1 = EasyMock.createMock(Runnable.class);\n+        Runnable r2 = EasyMock.createMock(Runnable.class);\n+        Thread t1 = new Thread();\n+        Thread t2 = new Thread();\n+        t1.setDaemon(true);\n+        EasyMock.expect(wrapped.newThread(r1)).andReturn(t1);\n+        EasyMock.expect(wrapped.newThread(r2)).andReturn(t2);\n+        EasyMock.replay(wrapped, r1, r2);\n+        BasicThreadFactory factory = builder.wrappedFactory(wrapped).build();\n+        assertSame(\"Wrong thread 1\", t1, factory.newThread(r1));\n+        assertTrue(\"No daemon thread\", t1.isDaemon());\n+        assertSame(\"Wrong thread 2\", t2, factory.newThread(r2));\n+        assertFalse(\"A daemon thread\", t2.isDaemon());\n+        EasyMock.verify(wrapped, r1, r2);\n+    }\n+\n+    /**\n+     * Tests whether the priority is set on newly created threads.\n+     */\n+    @Test\n+    public void testNewThreadPriority() {\n+        ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);\n+        Runnable r = EasyMock.createMock(Runnable.class);\n+        Thread t = new Thread();\n+        EasyMock.expect(wrapped.newThread(r)).andReturn(t);\n+        EasyMock.replay(wrapped, r);\n+        final int priority = Thread.NORM_PRIORITY + 1;\n+        BasicThreadFactory factory = builder.wrappedFactory(wrapped).priority(\n+                priority).build();\n+        assertSame(\"Wrong thread\", t, factory.newThread(r));\n+        assertEquals(\"Wrong priority\", priority, t.getPriority());\n+        EasyMock.verify(wrapped, r);\n+    }\n+\n+    /**\n+     * Tests whether the original priority is not changed if no priority is\n+     * specified.\n+     */\n+    @Test\n+    public void testNewThreadNoPriority() {\n+        ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);\n+        Runnable r = EasyMock.createMock(Runnable.class);\n+        final int orgPriority = Thread.NORM_PRIORITY + 1;\n+        Thread t = new Thread();\n+        t.setPriority(orgPriority);\n+        EasyMock.expect(wrapped.newThread(r)).andReturn(t);\n+        EasyMock.replay(wrapped, r);\n+        BasicThreadFactory factory = builder.wrappedFactory(wrapped).build();\n+        assertSame(\"Wrong thread\", t, factory.newThread(r));\n+        assertEquals(\"Wrong priority\", orgPriority, t.getPriority());\n+        EasyMock.verify(wrapped, r);\n+    }\n+\n+    /**\n+     * Tests whether the exception handler is set if one is provided.\n+     */\n+    @Test\n+    public void testNewThreadExHandler() {\n+        ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);\n+        Runnable r = EasyMock.createMock(Runnable.class);\n+        Thread.UncaughtExceptionHandler handler = EasyMock\n+                .createMock(Thread.UncaughtExceptionHandler.class);\n+        Thread t = new Thread();\n+        EasyMock.expect(wrapped.newThread(r)).andReturn(t);\n+        EasyMock.replay(wrapped, r, handler);\n+        BasicThreadFactory factory = builder.wrappedFactory(wrapped)\n+                .uncaughtExceptionHandler(handler).build();\n+        assertSame(\"Wrong thread\", t, factory.newThread(r));\n+        assertEquals(\"Wrong exception handler\", handler, t\n+                .getUncaughtExceptionHandler());\n+        EasyMock.verify(wrapped, r, handler);\n+    }\n+\n+    /**\n+     * Tests whether the original exception hander is not touched if none is\n+     * specified.\n+     */\n+    @Test\n+    public void testNewThreadNoExHandler() {\n+        ThreadFactory wrapped = EasyMock.createMock(ThreadFactory.class);\n+        Runnable r = EasyMock.createMock(Runnable.class);\n+        Thread.UncaughtExceptionHandler handler = EasyMock\n+                .createMock(Thread.UncaughtExceptionHandler.class);\n+        Thread t = new Thread();\n+        t.setUncaughtExceptionHandler(handler);\n+        EasyMock.expect(wrapped.newThread(r)).andReturn(t);\n+        EasyMock.replay(wrapped, r, handler);\n+        BasicThreadFactory factory = builder.wrappedFactory(wrapped).build();\n+        assertSame(\"Wrong thread\", t, factory.newThread(r));\n+        assertEquals(\"Wrong exception handler\", handler, t\n+                .getUncaughtExceptionHandler());\n+        EasyMock.verify(wrapped, r, handler);\n+    }\n+}", "timestamp": 1267066384, "metainfo": ""}