{"sha": "9800f287d158e2dc40594698ddce8d486d292873", "log": "use builder APIs for AnnotationUtils.toString()  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/AnnotationUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/AnnotationUtils.java\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.util.Arrays;\n-import java.util.Iterator;\n+\n+import org.apache.commons.lang3.builder.ToStringBuilder;\n+import org.apache.commons.lang3.builder.ToStringStyle;\n \n /**\n  * Helper methods for working with {@link Annotation}s.\n  * @version $Id$\n  */\n public class AnnotationUtils {\n+    private static final ToStringStyle TO_STRING_STYLE = new ToStringStyle() {\n+        /** Serialization version */\n+        private static final long serialVersionUID = 1L;\n+\n+        {\n+            setDefaultFullDetail(true);\n+            setArrayContentDetail(true);\n+            setUseClassName(true);\n+            setUseShortClassName(true);\n+            setUseIdentityHashCode(false);\n+            setContentStart(\"(\");\n+            setContentEnd(\")\");\n+            setFieldSeparator(\", \");\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        protected String getShortClassName(java.lang.Class<?> cls) {\n+            Class<? extends Annotation> annotationType = null;\n+            for (Class<?> iface : ClassUtils.getAllInterfaces(cls)) {\n+                if (Annotation.class.isAssignableFrom(iface)) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    //because we just checked the assignability\n+                    Class<? extends Annotation> found = (Class<? extends Annotation>) iface;\n+                    annotationType = found;\n+                    break;\n+                }\n+            }\n+            return new StringBuilder(annotationType == null ? null : annotationType.getName())\n+                    .insert(0, '@').toString();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        protected void appendDetail(StringBuffer buffer, String fieldName, Object value) {\n+            if (value instanceof Annotation) {\n+                value = AnnotationUtils.toString((Annotation) value);\n+            }\n+            super.appendDetail(buffer, fieldName, value);\n+        }\n+\n+    };\n \n     /**\n      * <p><code>AnnotationUtils</code> instances should NOT be constructed in\n      * @return String\n      */\n     public static String toString(final Annotation a) {\n-        return new StringBuilder(a.annotationType().getName()).insert(0, '@').append('(')\n-                .append(StringUtils.join(new Iterable<String>() {\n-\n-                    public Iterator<String> iterator() {\n-                        final Method[] methods = a.annotationType().getDeclaredMethods();\n-                        return new Iterator<String>() {\n-                            int pos = 0;\n-\n-                            public boolean hasNext() {\n-                                return pos < methods.length;\n-                            }\n-\n-                            public String next() {\n-                                Method m = methods[pos++];\n-                                try {\n-                                    return new StringBuilder(m.getName()).append('=')\n-                                            .append(m.invoke(a)).toString();\n-                                } catch (Exception e) {\n-                                    throw new RuntimeException(e);\n-                                }\n-                            }\n-\n-                            public void remove() {\n-                                throw new UnsupportedOperationException();\n-                            }\n-\n-                        };\n-                    }\n-\n-                }, \", \")).append(')').toString();\n+        ToStringBuilder builder = new ToStringBuilder(a, TO_STRING_STYLE);\n+        for (Method m : a.annotationType().getDeclaredMethods()) {\n+            if (m.getParameterTypes().length > 0) {\n+                continue; //wtf?\n+            }\n+            try {\n+                builder.append(m.getName(), m.invoke(a));\n+            } catch (RuntimeException e) {\n+                throw e;\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+        return builder.build();\n     }\n \n     //besides modularity, this has the advantage of autoboxing primitives:", "timestamp": 1285094814, "metainfo": ""}