{"sha": "c41b8c8ca37a0ac20474475fac00581514547810", "log": "Applying Jason Madden's patch from LANG-334 to provide enums.Enum with optimized thread safety. As Jason's used this in production I think it's fair to use it rather than the simpler Collections.synchronizedMap(..). I've also applied the patch to the enum.Enum  ", "commit": "\n--- a/src/java/org/apache/commons/lang/enum/Enum.java\n+++ b/src/java/org/apache/commons/lang/enum/Enum.java\n     /**\n      * <code>Map</code>, key of class name, value of <code>Entry</code>.\n      */\n-    private static final Map cEnumClasses = new WeakHashMap();\n+    private static Map cEnumClasses\n+        // LANG-334: To avoid exposing a mutating map,\n+        // we copy it each time we add to it. This is cheaper than\n+        // using a synchronized map since we are almost entirely reads\n+        = new WeakHashMap();\n     \n     /**\n      * The string representation of the Enum.\n         if (ok == false) {\n             throw new IllegalArgumentException(\"getEnumClass() must return a superclass of this class\");\n         }\n-        \n-        // create entry\n-        Entry entry = (Entry) cEnumClasses.get(enumClass);\n-        if (entry == null) {\n-            entry = createEntry(enumClass);\n-            cEnumClasses.put(enumClass, entry);\n+\n+        Entry entry;\n+        synchronized( Enum.class ) { // LANG-334\n+            // create entry\n+            entry = (Entry) cEnumClasses.get(enumClass);\n+            if (entry == null) {\n+                entry = createEntry(enumClass);\n+                Map myMap = new WeakHashMap( cEnumClasses );\n+                myMap.put(enumClass, entry);\n+                cEnumClasses = myMap;\n+            }\n         }\n         if (entry.map.containsKey(name)) {\n             throw new IllegalArgumentException(\"The Enum name must be unique, '\" + name + \"' has already been added\");\n--- a/src/java/org/apache/commons/lang/enums/Enum.java\n+++ b/src/java/org/apache/commons/lang/enums/Enum.java\n     /**\n      * <code>Map</code>, key of class name, value of <code>Entry</code>.\n      */\n-    private static final Map cEnumClasses = new WeakHashMap();\n+    private static Map cEnumClasses\n+        // LANG-334: To avoid exposing a mutating map,\n+        // we copy it each time we add to it. This is cheaper than\n+        // using a synchronized map since we are almost entirely reads\n+        = new WeakHashMap();\n     \n     /**\n      * The string representation of the Enum.\n          * <p>Restrictive constructor.</p>\n          */\n         protected Entry() {\n-          super();\n+            super();\n         }\n     }\n \n         if (ok == false) {\n             throw new IllegalArgumentException(\"getEnumClass() must return a superclass of this class\");\n         }\n-        \n-        // create entry\n-        Entry entry = (Entry) cEnumClasses.get(enumClass);\n-        if (entry == null) {\n-            entry = createEntry(enumClass);\n-            cEnumClasses.put(enumClass, entry);\n+\n+        Entry entry;\n+        synchronized( Enum.class ) { // LANG-334\n+            // create entry\n+            entry = (Entry) cEnumClasses.get(enumClass);\n+            if (entry == null) {\n+                entry = createEntry(enumClass);\n+                Map myMap = new WeakHashMap( cEnumClasses );\n+                myMap.put(enumClass, entry);\n+                cEnumClasses = myMap;\n+            }\n         }\n         if (entry.map.containsKey(name)) {\n             throw new IllegalArgumentException(\"The Enum name must be unique, '\" + name + \"' has already been added\");", "timestamp": 1188987229, "metainfo": ""}