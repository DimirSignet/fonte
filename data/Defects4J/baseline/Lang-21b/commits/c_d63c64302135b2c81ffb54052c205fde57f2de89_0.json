{"sha": "d63c64302135b2c81ffb54052c205fde57f2de89", "log": "Add Identifier generators to Lang from Util   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/util/IdentifierUtils.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.util;\n+\n+import java.io.Serializable;\n+import java.util.Random;\n+\n+import org.apache.commons.lang.functor.Factory;\n+import org.apache.commons.lang.functor.FactoryException;\n+/**\n+ * <p><code>IdentifierUtils</code> provides a number of different identifier\n+ * reference implementations.</p>\n+ * \n+ * <p>All the identifer factories are serializable and synchronized. The\n+ * factories all implement the <i>functor</i> \n+ * {@link org.apache.commons.lang.functor.Factory Factory} interface</p>\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id: IdentifierUtils.java,v 1.1 2002/12/29 21:35:04 scolebourne Exp $\n+ */\n+public class IdentifierUtils {\n+\n+    /**\n+     * <p>Singleton instance of the\n+     * <code>LongIdentifierFactory</code>.</p>\n+     * \n+     * <p>The singleton instance will wrap, so in a long-lived server, the id\n+     * may be duplicated.</p>\n+     * \n+     * <p>The objects returned are:</p>\n+     * <ul>\n+     * <li>new Long(0L)\n+     * <li>new Long(1L)\n+     * <li>new Long(2L)\n+     * <li>...\n+     * </ul>\n+\t */\n+    public static final Factory LONG_IDENTIFIER_FACTORY = new LongIdentifierFactory(true, 0L);\n+    /**\n+     * <p>Singleton instance of the <code>StringNumericIdentifierFactory</code>.\n+     * </p>\n+     * \n+     * <p>The singleton instance will wrap, so in a long-lived server, the id\n+     * may be duplicated.</p>\n+     * \n+     * <p>The objects returned are:</p>\n+     * <ul>\n+     * <li>\"0\"\n+     * <li>\"1\"\n+     * <li>\"2\"\n+     * <li>...\n+     * </ul>\n+     */\n+    public static final Factory STRING_NUMERIC_IDENTIFIER_FACTORY = new StringNumericIdentifierFactory(true, 0L);\n+    /**\n+     * <p>Singleton instance of the\n+     * <code>StringAlphanumericIdentifierFactory</code>.</p>\n+     * \n+     * <p>The singleton instance will wrap, so in a long-lived server, the id\n+     * may be duplicated. However, the length is 15 in base-36, so thats a\n+     * lot of identifiers.</p>\n+     * \n+     * <p>The objects returned are:</p>\n+     * <ul>\n+     * <li>\"000000000000001\"\n+     * <li>\"000000000000002\"\n+     * <li>\"000000000000003\"\n+     * <li>...\n+     * <li>\"00000000000000y\"\n+     * <li>\"00000000000000z\"\n+     * <li>\"000000000000010\"\n+     * <li>\"000000000000011\"\n+     * <li>...\n+     * <li>\"00000000000001z\"\n+     * <li>\"000000000000020\"\n+     * <li>...\n+     * </ul>\n+     */\n+    public static final Factory STRING_ALPHANUMERIC_IDENTIFIER_FACTORY = new StringAlphanumericIdentifierFactory(true, 15);\n+    /**\n+     * <p>Singleton instance of the\n+     * <code>StringSessionIdentifierFactory</code>.</p>\n+     * \n+     * <p>The singleton instance may produce duplicates in a long-lived server,\n+     * but its unlikely.</p>\n+     * \n+     * <p>The objects returned are 10 or more base-36 digits.</p>\n+     */\n+    public static final Factory STRING_SESSION_IDENTIFIER_FACTORY = new StringSessionIdentifierFactory();\n+\n+    //---------------------------------------------------------------------------------\n+    \n+    /**\n+     * <p><code>IdentifierUtils</code> instances should NOT be constructed in\n+     * standard programming.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n+     */\n+    public IdentifierUtils() {\n+        super();\n+    }\n+\n+    //---------------------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the next identifier using the singleton instance of the\n+     * Long factory.\n+     * </p>\n+     * \n+     * <p>The singleton instance will wrap, so in a long-lived server, the id\n+     * may be duplicated.</p>\n+     * \n+     * @return a new identifier\n+     */\n+    public static Long nextLongIdentifier() {\n+        return (Long) LONG_IDENTIFIER_FACTORY.create();\n+    }\n+\n+    /**\n+     * <p>Gets a new identifier factory that returns a series of Long objects\n+     * increasing in size.</p>\n+     * \n+     * <p>The factory will wrap when the maximum <code>long</code> is\n+     * reached and return negative numbers. It will start from zero.</p>\n+     * \n+     * @return a new identifier factory\n+     */\n+    public static Factory longIdentifierFactory() {\n+        return new LongIdentifierFactory(true, 0L);\n+    }\n+\n+    /**\n+     * <p>Gets a new identifier factory that returns a series of Long objects\n+     * increasing in size.</p>\n+     * \n+     * @param wrap  should the factory wrap when it reaches the maximum \n+     *  long value (or throw an exception)\n+     * @param initialValue  the initial long value to start at\n+     * @return a new identifier factory\n+     */\n+    public static Factory longIdentifierFactory(boolean wrap, long initialValue) {\n+        return new LongIdentifierFactory(wrap, initialValue);\n+    }\n+    \n+    //---------------------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the next identifier using the singleton instance of the\n+     * String Numeric factory.\n+     * </p>\n+     * \n+     * <p>The singleton instance will wrap, so in a long-lived server, the id\n+     * may be duplicated.</p>\n+     * \n+     * @return a new identifier\n+     */\n+    public static String nextStringNumericIdentifier() {\n+        return (String) STRING_NUMERIC_IDENTIFIER_FACTORY.create();\n+    }\n+\n+    /**\n+     * <p>Gets a new identifier factory that returns a series of String objects\n+     * representing numbers increasing in size.</p>\n+     * \n+     * <p>The factory will wrap when the maximum <code>long</code> is\n+     * reached and return negative numbers. It will start from zero.</p>\n+     * \n+     * @return a new identifier factory\n+     */\n+    public static Factory stringNumericIdentifierFactory() {\n+        return new StringNumericIdentifierFactory(true, 0L);\n+    }\n+\n+    /**\n+     * <p>Gets a new identifier factory that returns a series of String objects\n+     * representing numbers increasing in size.</p>\n+     * \n+     * @param wrap  should the factory wrap when it reaches the maximum \n+     *  long value (or throw an exception)\n+     * @param initialValue  the initial long value to start at\n+     * @return a new identifier factory\n+     */\n+    public static Factory stringNumericIdentifierFactory(boolean wrap, long initialValue) {\n+        return new StringNumericIdentifierFactory(wrap, initialValue);\n+    }\n+    \n+    //---------------------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the next identifier using the singleton instance of the\n+     * String Alphanumeric factory.\n+     * </p>\n+     * \n+     * <p>The singleton instance will wrap, so in a long-lived server, the id\n+     * may be duplicated.</p>\n+     * \n+     * @return a new identifier\n+     */\n+    public static String nextStringAlphanumericIdentifier() {\n+        return (String) STRING_ALPHANUMERIC_IDENTIFIER_FACTORY.create();\n+    }\n+\n+    /**\n+     * <p>Gets a new identifier factory that returns a series of String objects\n+     * representing numbers increasing in size in base-36.</p>\n+     * \n+     * <p>The factory will wrap when the maximum size (15) is reached.</p>\n+     * \n+     * @return a new identifier factory\n+     */\n+    public static Factory stringAlphanumericIdentifierFactory() {\n+        return new StringAlphanumericIdentifierFactory(true, 15);\n+    }\n+\n+    /**\n+     * <p>Gets a new identifier factory that returns a series of String objects\n+     * representing numbers increasing in size in base-36.</p>\n+     * \n+     * @param wrap  should the factory wrap when it reaches the maximum \n+     *  size (or throw an exception)\n+     * @param size  the number of characters the id should fill\n+     * @return a new identifier factory\n+     */\n+    public static Factory stringAlphanumericIdentifierFactory(boolean wrap, int size) {\n+        return new StringAlphanumericIdentifierFactory(wrap, size);\n+    }\n+    \n+    //---------------------------------------------------------------------------------\n+    \n+    /**\n+     * <p>Gets the next identifier using the singleton instance of the\n+     * String Session factory.\n+     * </p>\n+     * \n+     * <p>The singleton instance is not guaranteed to be unique (although its\n+     * pretty unlikely), so in a long- lived server, the id may be duplicated.\n+     * </p>\n+     * \n+     * @return a new identifier\n+     */\n+    public static String nextStringSessionIdentifier() {\n+        return (String) STRING_SESSION_IDENTIFIER_FACTORY.create();\n+    }\n+\n+    /**\n+     * <p>Gets a new identifier factory that returns a series of String objects\n+     * that appear to be random and are suitable for use as session identifiers.\n+     * </p>\n+     * \n+     * <p>The generation routine is based on a random number and a counter\n+     * within a 2 second time interval.</p>\n+     * \n+     * @return a new identifier factory\n+     */\n+    public static Factory stringSessionIdentifierFactory() {\n+        return new StringSessionIdentifierFactory();\n+    }\n+\n+    //---------------------------------------------------------------------------------\n+\n+    /**\n+     * <code>LongIdentifierFactory</code> is an Identifier Factory\n+     * that generates an incrementing number as a Long object.\n+     *\n+     * @author Stephen Colebourne\n+     */\n+    private static class LongIdentifierFactory implements Factory, Serializable {\n+    \n+        /** Should the counter wrap. */\n+        private final boolean wrap;\n+        /** The counter. */\n+        private long count = 0;\n+    \n+        /**\n+         * Constructor.\n+         * \n+         * @param wrap  should the factory wrap when it reaches the maximum \n+         *  long value (or throw an exception)\n+         * @param initialValue  the initial long value to start at\n+         */\n+        private LongIdentifierFactory(boolean wrap, long initialValue) {\n+            super();\n+            this.wrap = wrap;\n+            this.count = initialValue;\n+        }\n+\n+        /**\n+         * Create a new identifier.\n+         * \n+         * @return a new identifier as a Long\n+         */\n+        public Object create() {\n+            long value = 0;\n+            if (wrap) {\n+                synchronized (this) {\n+                    value = count++;\n+                }\n+            } else {\n+                synchronized (this) {\n+                    if (count == Long.MAX_VALUE) {\n+                        throw new FactoryException(\"The maximum number of identifiers has been reached\");\n+                    }\n+                    value = count++;\n+                }\n+            }\n+            return new Long(value);\n+        }\n+    }\n+\n+    //---------------------------------------------------------------------------------\n+\n+    /**\n+     * <code>StringNumericIdentifierFactory</code> is an Identifier Factory\n+     * that generates an incrementing number as a String object.\n+     *\n+     * @author Stephen Colebourne\n+     */\n+    private static class StringNumericIdentifierFactory implements Factory, Serializable {\n+    \n+        /** Should the counter wrap. */\n+        private final boolean wrap;\n+        /** The counter. */\n+        private long count = 0;\n+        \n+        /**\n+         * Constructor.\n+         * \n+         * @param wrap  should the factory wrap when it reaches the maximum \n+         *  long value (or throw an exception)\n+         * @param initialValue  the initial long value to start at\n+         */\n+        private StringNumericIdentifierFactory(boolean wrap, long initialValue) {\n+            super();\n+            this.wrap = wrap;\n+            this.count = initialValue;\n+        }\n+\n+        /**\n+         * Create a new identifier.\n+         * \n+         * @return a new identifier as a String\n+         */\n+        public Object create() {\n+            long value = 0;\n+            if (wrap) {\n+                synchronized (this) {\n+                    value = count++;\n+                }\n+            } else {\n+                synchronized (this) {\n+                    if (count == Long.MAX_VALUE) {\n+                        throw new FactoryException(\"The maximum number of identifiers has been reached\");\n+                    }\n+                    value = count++;\n+                }\n+            }\n+            return Long.toString(value);\n+        }\n+\n+    }\n+    \n+    //---------------------------------------------------------------------------------\n+\n+    /**\n+     * <code>StringAlphanumericIdentifierFactory</code> is an Identifier Factory\n+     * that generates an incrementing incrementing number in base 36 as a String\n+     * object.\n+     *\n+     * @author Stephen Colebourne\n+     */\n+    private static class StringAlphanumericIdentifierFactory implements Factory, Serializable {\n+    \n+        /** Should the counter wrap. */\n+        private final boolean wrap;\n+        /** The counter. */\n+        private char[] count = null;\n+        \n+        /**\n+         * Constructor.\n+         * \n+         * @param wrap  should the factory wrap when it reaches the maximum \n+         *  long value (or throw an exception)\n+         * @param size  the size of the identifier\n+         */\n+        private StringAlphanumericIdentifierFactory(boolean wrap, int size) {\n+            super();\n+            this.wrap = wrap;\n+            if (size < 1) {\n+                throw new IllegalArgumentException(\"The size must be at least one\");\n+            }\n+            this.count = new char[size];\n+            for (int i = 0; i < size; i++) {\n+                count[i] = '0';  // zero\n+            }\n+        }\n+\n+        /**\n+         * Create a new identifier.\n+         * \n+         * @return a new identifier as a String\n+         */\n+        public synchronized Object create() {\n+            for (int i = count.length - 1; i >= 0; i--) {\n+                switch (count[i]) {\n+                    case 122:  // z\n+                    count[i] = '0';\n+                    if (i == 0 && wrap == false) {\n+                        throw new FactoryException(\"The maximum number of identifiers has been reached\");\n+                    }\n+                    break;\n+                    \n+                    case 57:  // 9\n+                    count[i] = 'a';\n+                    i = -1;\n+                    break;\n+                    \n+                    default:\n+                    count[i]++;\n+                    i = -1;\n+                    break;\n+                }\n+            }\n+            return new String(count);\n+        }\n+\n+    }\n+    \n+    //---------------------------------------------------------------------------------\n+    \n+    /**\n+     * <p><code>StringSessionIdentifierFactory</code> is an Identifier\n+     * Factory that generates an alphanumeric 10+ character identifier. The\n+     * exact length depends on the number of ids requested per time period.</p>\n+     * \n+     * <p>Originally designed for JServ sessions. Uses synchronized count and\n+     * time to ensure uniqueness. Not guaranteed unique across JVMs, but\n+     * fairly safe none the less.</p>\n+     *\n+     * @author Jon S. Stevens\n+     * @author Neeme Praks\n+     * @author Stephen Colebourne\n+     */\n+    private static class StringSessionIdentifierFactory implements Factory, Serializable {\n+\n+        /**\n+         * We want to have a random string with a length of 6 characters.\n+         * Since we encode it base-36, we modulo the random number with\n+         * this value.\n+         */\n+        private static final long MAX_RANDOM_LEN = 2176782336L; // 36 ** 6\n+        /**\n+         * The identifier must be unique within the typical lifespan of a\n+         * session; the value can roll over after that.  3 characters:\n+         * (this means a roll over after over a day, which is much larger\n+         * than a typical lifespan).\n+         */\n+        private static final long MAX_TIME_SECTION_LEN = 46656L; // 36 ** 3\n+        /**\n+         * Milliseconds between different tics.  The 3-character time\n+         * string has a new value every 2 seconds.\n+         */\n+        private static final long TIC_DIFFERENCE = 2000;\n+        \n+        /** The incrementing counter. */\n+        private int counter = 0;\n+        /** The last time. */\n+        private long lastTimeValue = 0;\n+        /** The randmonizer. */\n+        private Random randomizer = new Random();\n+\n+        /**\n+         * Constructor.\n+         */\n+        private StringSessionIdentifierFactory() {\n+            super();\n+        }\n+\n+        /**\n+         * Create a new identifier. Only guaranteed unique within\n+         * this JVM, but fairly safe for cross JVM usage as well.\n+         * \n+         * <p>Format of identifier is\n+         * [6 chars random][3 chars time][1+ chars count]</p>\n+         * \n+         * @return a new identifier as a Long\n+         */\n+        public Object create() {\n+            // Random value\n+            //--------------\n+            long currentRandom = randomizer.nextLong();\n+            if (currentRandom < 0) {\n+                currentRandom = -currentRandom;\n+            }\n+            // force value into 6 char range, and add to pad with zeros\n+            // this gives a length of 7, when converted to base 36, and\n+            // the first character (always 1 from the add) is dropped\n+            currentRandom %= MAX_RANDOM_LEN;\n+            currentRandom += MAX_RANDOM_LEN;\n+\n+            long currentTimeValue = 0;\n+            int currentCount = 0;\n+        \n+            synchronized (this) {\n+                // Time\n+                //--------------\n+                currentTimeValue = (System.currentTimeMillis() / TIC_DIFFERENCE);\n+    \n+                // force value into 3 char range, and add to pad with zeros\n+                // this gives a length of 4, when converted to base 36, and\n+                // the first character (always 1 from the add) is dropped\n+                currentTimeValue %= MAX_TIME_SECTION_LEN;\n+                currentTimeValue += MAX_TIME_SECTION_LEN;\n+    \n+                // Count\n+                //--------------\n+                // Make the string unique by appending the count since last\n+                // time flip.\n+    \n+                // Count sessions only within tics (so the 'real' counter\n+                // isn't exposed to the public).\n+                if (lastTimeValue != currentTimeValue) {\n+                    lastTimeValue = currentTimeValue;\n+                    counter = 0;\n+                }\n+                currentCount = counter++;\n+            }\n+\n+            // build string        \n+            //--------------\n+            StringBuffer id = new StringBuffer(15);\n+            id.append(Long.toString(currentRandom, 36).substring(1));  // 6 chars\n+            id.append(Long.toString(currentTimeValue, 36).substring(1));  // 3 chars\n+            id.append(Long.toString(currentCount, 36));  // 1+ chars\n+            return id.toString();\n+        }\n+\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/util/IdentifierUtilsTest.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.util;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.lang.functor.Factory;\n+import org.apache.commons.lang.functor.FactoryException;\n+/**\n+ * Tests the org.apache.commons.lang.util.IdentifierUtils class.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id: IdentifierUtilsTest.java,v 1.1 2002/12/29 21:35:03 scolebourne Exp $\n+ */\n+public class IdentifierUtilsTest extends junit.framework.TestCase {\n+\n+    /**\n+     * Construct\n+     */\n+    public IdentifierUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * Return class aa a test suite.\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(IdentifierUtilsTest.class);\n+        suite.setName(\"IdentifierUtils Tests\");\n+        return suite;\n+    }\n+\n+    //--------------------------------------------------------------------------\n+\n+    public void testLongIncrementing() {\n+        Factory f = IdentifierUtils.LONG_IDENTIFIER_FACTORY;\n+        assertEquals(new Long(0), f.create());\n+        assertEquals(new Long(1), f.create());\n+        assertEquals(new Long(2), f.create());\n+        assertEquals(new Long(3), f.create());\n+        assertEquals(new Long(4), IdentifierUtils.nextLongIdentifier());\n+        assertEquals(new Long(5), f.create());\n+        assertEquals(new Long(6), IdentifierUtils.nextLongIdentifier());\n+        assertEquals(new Long(7), IdentifierUtils.nextLongIdentifier());\n+    }\n+\n+    public void testLongIncrementingNoArgs() {\n+        Factory f = IdentifierUtils.longIdentifierFactory();\n+        assertEquals(new Long(0), f.create());\n+        assertEquals(new Long(1), f.create());\n+        assertTrue(f != IdentifierUtils.LONG_IDENTIFIER_FACTORY);\n+    }\n+\n+    public void testLongIncrementingInit() {\n+        Factory f = IdentifierUtils.longIdentifierFactory(true, 100);\n+        assertEquals(new Long(100), f.create());\n+        assertEquals(new Long(101), f.create());\n+    }\n+\n+    public void testLongIncrementingWrap() {\n+        Factory f = IdentifierUtils.longIdentifierFactory(true, Long.MAX_VALUE);\n+        assertEquals(new Long(Long.MAX_VALUE), f.create());\n+        assertEquals(new Long(Long.MIN_VALUE), f.create());\n+    }\n+\n+    public void testLongIncrementingNoWrap() {\n+        Factory f = IdentifierUtils.longIdentifierFactory(false, Long.MAX_VALUE);\n+        try {\n+            f.create();\n+            fail();\n+        } catch (FactoryException ex) {}\n+    }\n+\n+    //--------------------------------------------------------------------------\n+\n+    public void testStringNumericLong() {\n+        Factory f = IdentifierUtils.STRING_NUMERIC_IDENTIFIER_FACTORY;\n+        assertEquals(\"0\", f.create());\n+        assertEquals(\"1\", f.create());\n+        assertEquals(\"2\", f.create());\n+        assertEquals(\"3\", f.create());\n+        assertEquals(\"4\", IdentifierUtils.nextStringNumericIdentifier());\n+        assertEquals(\"5\", f.create());\n+        assertEquals(\"6\", IdentifierUtils.nextStringNumericIdentifier());\n+        assertEquals(\"7\", IdentifierUtils.nextStringNumericIdentifier());\n+    }\n+\n+    public void testStringNumericNoArgs() {\n+        Factory f = IdentifierUtils.stringNumericIdentifierFactory();\n+        assertEquals(\"0\", f.create());\n+        assertEquals(\"1\", f.create());\n+        assertTrue(f != IdentifierUtils.STRING_NUMERIC_IDENTIFIER_FACTORY);\n+    }\n+\n+    public void testStringNumericInit() {\n+        Factory f = IdentifierUtils.stringNumericIdentifierFactory(true, 100);\n+        assertEquals(\"100\", f.create());\n+        assertEquals(\"101\", f.create());\n+    }\n+\n+    public void testStringNumericWrap() {\n+        Factory f = IdentifierUtils.stringNumericIdentifierFactory(true, Long.MAX_VALUE);\n+        assertEquals(Long.toString(Long.MAX_VALUE), f.create());\n+        assertEquals(Long.toString(Long.MIN_VALUE), f.create());\n+    }\n+\n+    public void testStringNumericNoWrap() {\n+        Factory f = IdentifierUtils.stringNumericIdentifierFactory(false, Long.MAX_VALUE);\n+        try {\n+            f.create();\n+            fail();\n+        } catch (FactoryException ex) { }\n+    }\n+\n+    //--------------------------------------------------------------------------\n+\n+    public void testStringAlphanumeric() {\n+        Factory f = IdentifierUtils.STRING_ALPHANUMERIC_IDENTIFIER_FACTORY;\n+        assertEquals(\"000000000000001\", f.create());\n+        assertEquals(\"000000000000002\", f.create());\n+        assertEquals(\"000000000000003\", f.create());\n+        assertEquals(\"000000000000004\", f.create());\n+        assertEquals(\"000000000000005\", f.create());\n+        assertEquals(\"000000000000006\", f.create());\n+        assertEquals(\"000000000000007\", f.create());\n+        assertEquals(\"000000000000008\", f.create());\n+        assertEquals(\"000000000000009\", f.create());\n+        assertEquals(\"00000000000000a\", f.create());\n+        assertEquals(\"00000000000000b\", f.create());\n+        assertEquals(\"00000000000000c\", f.create());\n+        assertEquals(\"00000000000000d\", IdentifierUtils.nextStringAlphanumericIdentifier());\n+        assertEquals(\"00000000000000e\", f.create());\n+        assertEquals(\"00000000000000f\", f.create());\n+        assertEquals(\"00000000000000g\", f.create());\n+        assertEquals(\"00000000000000h\", f.create());\n+        assertEquals(\"00000000000000i\", f.create());\n+        assertEquals(\"00000000000000j\", f.create());\n+        assertEquals(\"00000000000000k\", f.create());\n+        assertEquals(\"00000000000000l\", f.create());\n+        assertEquals(\"00000000000000m\", f.create());\n+        assertEquals(\"00000000000000n\", f.create());\n+        assertEquals(\"00000000000000o\", f.create());\n+        assertEquals(\"00000000000000p\", f.create());\n+        assertEquals(\"00000000000000q\", f.create());\n+        assertEquals(\"00000000000000r\", f.create());\n+        assertEquals(\"00000000000000s\", f.create());\n+        assertEquals(\"00000000000000t\", f.create());\n+        assertEquals(\"00000000000000u\", f.create());\n+        assertEquals(\"00000000000000v\", f.create());\n+        assertEquals(\"00000000000000w\", f.create());\n+        assertEquals(\"00000000000000x\", f.create());\n+        assertEquals(\"00000000000000y\", f.create());\n+        assertEquals(\"00000000000000z\", f.create());\n+        assertEquals(\"000000000000010\", f.create());\n+        assertEquals(\"000000000000011\", f.create());\n+        assertEquals(\"000000000000012\", f.create());\n+        assertEquals(\"000000000000013\", f.create());\n+    }\n+\n+    public void testLongAlphanumericNoArgs() {\n+        Factory f = IdentifierUtils.stringAlphanumericIdentifierFactory();\n+        assertEquals(\"000000000000001\", f.create());\n+        assertEquals(\"000000000000002\", f.create());\n+        assertTrue(f != IdentifierUtils.STRING_ALPHANUMERIC_IDENTIFIER_FACTORY);\n+    }\n+\n+    public void testStringAlphanumericWrap() {\n+        Factory f = IdentifierUtils.stringAlphanumericIdentifierFactory(true, 1);\n+        assertEquals(\"1\", f.create());\n+        assertEquals(\"2\", f.create());\n+        assertEquals(\"3\", f.create());\n+        assertEquals(\"4\", f.create());\n+        assertEquals(\"5\", f.create());\n+        assertEquals(\"6\", f.create());\n+        assertEquals(\"7\", f.create());\n+        assertEquals(\"8\", f.create());\n+        assertEquals(\"9\", f.create());\n+        assertEquals(\"a\", f.create());\n+        assertEquals(\"b\", f.create());\n+        assertEquals(\"c\", f.create());\n+        assertEquals(\"d\", f.create());\n+        assertEquals(\"e\", f.create());\n+        assertEquals(\"f\", f.create());\n+        assertEquals(\"g\", f.create());\n+        assertEquals(\"h\", f.create());\n+        assertEquals(\"i\", f.create());\n+        assertEquals(\"j\", f.create());\n+        assertEquals(\"k\", f.create());\n+        assertEquals(\"l\", f.create());\n+        assertEquals(\"m\", f.create());\n+        assertEquals(\"n\", f.create());\n+        assertEquals(\"o\", f.create());\n+        assertEquals(\"p\", f.create());\n+        assertEquals(\"q\", f.create());\n+        assertEquals(\"r\", f.create());\n+        assertEquals(\"s\", f.create());\n+        assertEquals(\"t\", f.create());\n+        assertEquals(\"u\", f.create());\n+        assertEquals(\"v\", f.create());\n+        assertEquals(\"w\", f.create());\n+        assertEquals(\"x\", f.create());\n+        assertEquals(\"y\", f.create());\n+        assertEquals(\"z\", f.create());\n+        assertEquals(\"0\", f.create());\n+    }\n+\n+    public void testStringAlphanumericNoWrap() {\n+        Factory f = IdentifierUtils.stringAlphanumericIdentifierFactory(false, 1);\n+        assertEquals(\"1\", f.create());\n+        assertEquals(\"2\", f.create());\n+        assertEquals(\"3\", f.create());\n+        assertEquals(\"4\", f.create());\n+        assertEquals(\"5\", f.create());\n+        assertEquals(\"6\", f.create());\n+        assertEquals(\"7\", f.create());\n+        assertEquals(\"8\", f.create());\n+        assertEquals(\"9\", f.create());\n+        assertEquals(\"a\", f.create());\n+        assertEquals(\"b\", f.create());\n+        assertEquals(\"c\", f.create());\n+        assertEquals(\"d\", f.create());\n+        assertEquals(\"e\", f.create());\n+        assertEquals(\"f\", f.create());\n+        assertEquals(\"g\", f.create());\n+        assertEquals(\"h\", f.create());\n+        assertEquals(\"i\", f.create());\n+        assertEquals(\"j\", f.create());\n+        assertEquals(\"k\", f.create());\n+        assertEquals(\"l\", f.create());\n+        assertEquals(\"m\", f.create());\n+        assertEquals(\"n\", f.create());\n+        assertEquals(\"o\", f.create());\n+        assertEquals(\"p\", f.create());\n+        assertEquals(\"q\", f.create());\n+        assertEquals(\"r\", f.create());\n+        assertEquals(\"s\", f.create());\n+        assertEquals(\"t\", f.create());\n+        assertEquals(\"u\", f.create());\n+        assertEquals(\"v\", f.create());\n+        assertEquals(\"w\", f.create());\n+        assertEquals(\"x\", f.create());\n+        assertEquals(\"y\", f.create());\n+        assertEquals(\"z\", f.create());\n+        try {\n+            f.create();\n+            fail();\n+        } catch (FactoryException ex) {}\n+    }\n+\n+    //--------------------------------------------------------------------------\n+\n+    public void testStringSession() {\n+        Factory f = IdentifierUtils.STRING_SESSION_IDENTIFIER_FACTORY;\n+        assertTrue(f != IdentifierUtils.stringSessionIdentifierFactory());\n+        \n+        String a = (String) f.create();\n+        String b = (String) IdentifierUtils.nextStringSessionIdentifier();\n+        assertTrue(a.length() >= 10);\n+        assertTrue(b.length() >= 10);\n+        // could fail, but unlikely\n+        assertTrue(a.substring(6, 9) != b.substring(6, 9));\n+        assertEquals(\"0\", a.substring(9));\n+        assertEquals(\"1\", b.substring(9));\n+    }\n+\n+    //--------------------------------------------------------------------------\n+\n+}\n--- a/src/test/org/apache/commons/lang/util/UtilTestSuite.java\n+++ b/src/test/org/apache/commons/lang/util/UtilTestSuite.java\n  * Test suite for the Util package.\n  *\n  * @author <a href=\"mailto:bayard@apache.org\">Henri Yandell</a>\n- * @version $Id: UtilTestSuite.java,v 1.1 2002/12/18 02:50:36 bayard Exp $\n+ * @version $Id: UtilTestSuite.java,v 1.2 2002/12/29 21:35:03 scolebourne Exp $\n  */\n public class UtilTestSuite extends TestCase {\n     \n         TestSuite suite = new TestSuite();\n         suite.setName(\"Commons-Lang-Util Tests\");\n         suite.addTest(BitFieldTest.suite());\n+        suite.addTest(IdentifierUtilsTest.suite());\n         return suite;\n     }\n }", "timestamp": 1041197704, "metainfo": ""}