{"sha": "b599b59994c31af6ddb61a1acdcb7fde37f0786f", "log": "comments, a spelling correction, some ws  ", "commit": "\n--- a/src/java/org/apache/commons/lang/ClassUtils.java\n+++ b/src/java/org/apache/commons/lang/ClassUtils.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * <p>This class handles invalid <code>null</code> inputs as best it can.\n  * Each method documents its behaviour in more detail.</p>\n  *\n- * <p>The notion of a <code>canonical name</code> includes the human \n- * readable name for the type, for example <code>int[]</code>. The \n- * non-canonical method variants work with the JVM names, such as \n+ * <p>The notion of a <code>canonical name</code> includes the human\n+ * readable name for the type, for example <code>int[]</code>. The\n+ * non-canonical method variants work with the JVM names, such as\n  * <code>[I</code>. </p>\n  *\n  * @author Stephen Colebourne\n      * Maps an abbreviation used in array class names to corresponding primitive class name.\n      */\n     private static Map reverseAbbreviationMap = new HashMap();\n-    \n+\n     /**\n      * Add primitive type abbreviation to maps of abbreviations.\n-     * \n+     *\n      * @param primitive Canonical name of primitive type\n      * @param abbreviation Corresponding abbreviation of primitive type\n      */\n         abbreviationMap.put(primitive, abbreviation);\n         reverseAbbreviationMap.put(abbreviation, primitive);\n     }\n-    \n+\n     /**\n      * Feed abbreviation maps\n      */\n      * @param toClassArray  the array of Classes to try to assign into, may be <code>null</code>\n      * @return <code>true</code> if assignment possible\n      */\n+    //TODO when we bump the major version we should default autoboxing to true on platforms >= 1.5\n     public static boolean isAssignable(Class[] classArray, Class[] toClassArray) {\n         return isAssignable(classArray, toClassArray, false);\n     }\n      * @param toClass  the Class to try to assign into, returns false if null\n      * @return <code>true</code> if assignment possible\n      */\n+    //TODO when we bump the major version we should default autoboxing to true on platforms >= 1.5\n     public static boolean isAssignable(Class cls, Class toClass) {\n         return isAssignable(cls, toClass, false);\n     }\n      * @see #wrapperToPrimitive(Class)\n      * @since 2.4\n      */\n-    public static Class[] wrappersToPrimitives(Class[] classes) {        \n+    public static Class[] wrappersToPrimitives(Class[] classes) {\n         if (classes == null) {\n             return null;\n         }\n     // Public method\n     // ----------------------------------------------------------------------\n     /**\n-     * <p>Returns the desired Method much like <code>Class.getMethod</code>, however \n-     * it ensures that the returned Method is from a public class or interface and not \n-     * from an anonymous inner class. This means that the Method is invokable and \n-     * doesn't fall foul of Java bug \n+     * <p>Returns the desired Method much like <code>Class.getMethod</code>, however\n+     * it ensures that the returned Method is from a public class or interface and not\n+     * from an anonymous inner class. This means that the Method is invokable and\n+     * doesn't fall foul of Java bug\n      * <a href=\"http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4071957\">4071957</a>).\n      *\n      *  <code><pre>Set set = Collections.unmodifiableSet(...);\n      * @throws NoSuchMethodException if the method is not found in the given class\n      *  or if the metothod doen't conform with the requirements\n      */\n-    public static Method getPublicMethod(Class cls, String methodName, Class parameterTypes[]) \n+    public static Method getPublicMethod(Class cls, String methodName, Class parameterTypes[])\n             throws SecurityException, NoSuchMethodException {\n-        \n+\n         Method declaredMethod = cls.getMethod(methodName, parameterTypes);\n         if (Modifier.isPublic(declaredMethod.getDeclaringClass().getModifiers())) {\n             return declaredMethod;\n         }\n-        \n+\n         List candidateClasses = new ArrayList();\n         candidateClasses.addAll(getAllInterfaces(cls));\n         candidateClasses.addAll(getAllSuperclasses(cls));\n-        \n+\n         for (Iterator it = candidateClasses.iterator(); it.hasNext(); ) {\n             Class candidateClass = (Class) it.next();\n             if (!Modifier.isPublic(candidateClass.getModifiers())) {\n                 return candidateMethod;\n             }\n         }\n-        \n+\n         throw new NoSuchMethodException(\"Can't find a public method for \" +\n                 methodName + \" \" + ArrayUtils.toString(parameterTypes));\n     }\n      * <li><code>getCanonicalName(\"java.lang.String\") = \"java.lang.String\"</code></li>\n      * </ul>\n      * </p>\n-     * \n+     *\n      * @param className the name of class\n      * @return canonical form of class name\n      * @since 2.4", "timestamp": 1236785247, "metainfo": ""}