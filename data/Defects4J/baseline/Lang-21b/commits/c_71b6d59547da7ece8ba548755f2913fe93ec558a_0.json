{"sha": "71b6d59547da7ece8ba548755f2913fe93ec558a", "log": "Tab police (and trailing spaces)  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/CharSequenceUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/CharSequenceUtils.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n \n /**\n  * Null-safe CharSequence utility methods.\n- * \n+ *\n  * @author Gary Gregory\n  */\n public class CharSequenceUtils {\n \n-\t/**\n-\t * Gets a CharSequence length or <code>0</code> if the CharSequence is\n-\t * <code>null</code>.\n-\t * \n-\t * @param cs\n-\t *            a CharSequence or <code>null</code>\n-\t * @return CharSequence length or <code>0</code> if the CharSequence is\n-\t *         <code>null</code>.\n-\t * @since 3.0\n-\t */\n-\tpublic static int length(CharSequence cs) {\n-\t\treturn cs == null ? 0 : cs.length();\n-\t}\n+    /**\n+     * Gets a CharSequence length or <code>0</code> if the CharSequence is\n+     * <code>null</code>.\n+     *\n+     * @param cs\n+     *            a CharSequence or <code>null</code>\n+     * @return CharSequence length or <code>0</code> if the CharSequence is\n+     *         <code>null</code>.\n+     * @since 3.0\n+     */\n+    public static int length(CharSequence cs) {\n+        return cs == null ? 0 : cs.length();\n+    }\n \n-\t/**\n-\t * Returns a new <code>CharSequence</code> that is a subsequence of this\n-\t * sequence starting with the <code>char</code> value at the specified\n-\t * index. The length (in <code>char</code>s) of the returned sequence is\n-\t * <code>length() - start</code>, so if <code>start == end</code> then an\n-\t * empty sequence is returned. </p>\n-\t * \n-\t * @param cs\n-\t *            the specified subsequence, may be null\n-\t * @param start\n-\t *            the start index, inclusive\n-\t * @return a new subsequence or null\n-\t * \n-\t * @throws IndexOutOfBoundsException\n-\t *             if <code>start</code> is negative or if <code>start</code> is\n-\t *             greater than <code>length()</code>\n-\t * @since 3.0\n-\t */\n-\tpublic static CharSequence subSequence(CharSequence cs, int start) {\n-\t\treturn cs == null ? null : cs.subSequence(start, cs.length());\n-\t}\n+    /**\n+     * Returns a new <code>CharSequence</code> that is a subsequence of this\n+     * sequence starting with the <code>char</code> value at the specified\n+     * index. The length (in <code>char</code>s) of the returned sequence is\n+     * <code>length() - start</code>, so if <code>start == end</code> then an\n+     * empty sequence is returned. </p>\n+     *\n+     * @param cs\n+     *            the specified subsequence, may be null\n+     * @param start\n+     *            the start index, inclusive\n+     * @return a new subsequence or null\n+     *\n+     * @throws IndexOutOfBoundsException\n+     *             if <code>start</code> is negative or if <code>start</code> is\n+     *             greater than <code>length()</code>\n+     * @since 3.0\n+     */\n+    public static CharSequence subSequence(CharSequence cs, int start) {\n+        return cs == null ? null : cs.subSequence(start, cs.length());\n+    }\n }\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n      * StringUtils.stripAccents(\"control\")           = \"control\"\n      * StringUtils.stripAccents(\"&ecute;clair\")      = \"eclair\"\n      * </pre>\n-     * \n+     *\n      * @param input String to be stripped\n      * @return String without accents on the text\n      *\n      * <p>\n      * Checks if the CharSequence contains any character in the given set of characters.\n      * </p>\n-     * \n+     *\n      * <p>\n      * A <code>null</code> CharSequence will return <code>false</code>. A <code>null</code> search CharSequence will return\n      * <code>false</code>.\n      * </p>\n-     * \n+     *\n      * <pre>\n      * StringUtils.containsAny(null, *)            = false\n      * StringUtils.containsAny(\"\", *)              = false\n      * StringUtils.containsAny(\"zzabyycdxx\", \"by\") = true\n      * StringUtils.containsAny(\"aba\",\"z\")          = false\n      * </pre>\n-     * \n+     *\n      * @param cs\n      *            the CharSequence to check, may be null\n      * @param searchChars\n         }\n         if (list.isEmpty()) {\n             return null;\n-        } \n+        }\n         return list.toArray(new String [list.size()]);\n     }\n \n      * @return an array of parsed Strings, <code>null</code> if null String input\n      * @since 2.4\n      */\n-    private static String[] splitByWholeSeparatorWorker(String str, String separator, int max, \n-                                                        boolean preserveAllTokens) \n+    private static String[] splitByWholeSeparatorWorker(String str, String separator, int max,\n+                                                        boolean preserveAllTokens)\n     {\n         if (str == null) {\n             return null;\n     // -----------------------------------------------------------------------\n     /**\n      * <p>Splits the provided text into an array, using whitespace as the\n-     * separator, preserving all tokens, including empty tokens created by \n+     * separator, preserving all tokens, including empty tokens created by\n      * adjacent separators. This is an alternative to using StringTokenizer.\n      * Whitespace is defined by {@link Character#isWhitespace(char)}.</p>\n      *\n     }\n \n     /**\n-     * Performs the logic for the <code>split</code> and \n+     * Performs the logic for the <code>split</code> and\n      * <code>splitPreserveAllTokens</code> methods that do not return a\n      * maximum array length.\n      *\n     }\n \n     /**\n-     * <p>Splits the provided text into an array, separators specified, \n+     * <p>Splits the provided text into an array, separators specified,\n      * preserving all tokens, including empty tokens created by adjacent\n      * separators. This is an alternative to using StringTokenizer.</p>\n      *\n \n     /**\n      * <p>Splits the provided text into an array with a maximum length,\n-     * separators specified, preserving all tokens, including empty tokens \n+     * separators specified, preserving all tokens, including empty tokens\n      * created by adjacent separators.</p>\n      *\n      * <p>The separator is not included in the returned String array.\n     }\n \n     /**\n-     * Performs the logic for the <code>split</code> and \n-     * <code>splitPreserveAllTokens</code> methods that return a maximum array \n+     * Performs the logic for the <code>split</code> and\n+     * <code>splitPreserveAllTokens</code> methods that return a maximum array\n      * length.\n      *\n      * @param str  the String to parse, may be <code>null</code>\n     /**\n      * <p>Splits a String by Character type as returned by\n      * <code>java.lang.Character.getType(char)</code>. Groups of contiguous\n-     * characters of the same type are returned as complete tokens. \n+     * characters of the same type are returned as complete tokens.\n      * <pre>\n      * StringUtils.splitByCharacterType(null)         = null\n      * StringUtils.splitByCharacterType(\"\")           = []\n      * <code>Character.UPPERCASE_LETTER</code>, if any, immediately\n      * preceding a token of type <code>Character.LOWERCASE_LETTER</code>\n      * will belong to the following token rather than to the preceding, if any,\n-     * <code>Character.UPPERCASE_LETTER</code> token. \n+     * <code>Character.UPPERCASE_LETTER</code> token.\n      * <pre>\n      * StringUtils.splitByCharacterTypeCamelCase(null)         = null\n      * StringUtils.splitByCharacterTypeCamelCase(\"\")           = []\n      * the character of type <code>Character.UPPERCASE_LETTER</code>, if any,\n      * immediately preceding a token of type <code>Character.LOWERCASE_LETTER</code>\n      * will belong to the following token rather than to the preceding, if any,\n-     * <code>Character.UPPERCASE_LETTER</code> token. \n+     * <code>Character.UPPERCASE_LETTER</code> token.\n      * @param str the String to split, may be <code>null</code>\n      * @param camelCase whether to use so-called \"camel-case\" for letter types\n      * @return an array of parsed Strings, <code>null</code> if null String input\n      * <p>\n      * Replaces all occurrences of Strings within another String.\n      * </p>\n-     * \n+     *\n      * <p>\n      * A <code>null</code> reference passed to this method is a no-op, or if\n      * any \"search string\" or \"string to replace\" is null, that replace will be\n      * ignored. This will not repeat. For repeating replaces, call the\n      * overloaded method.\n      * </p>\n-     * \n+     *\n      * <pre>\n      *  StringUtils.replaceEach(null, *, *)        = null\n      *  StringUtils.replaceEach(\"\", *, *)          = \"\"\n      *  (example of how it does not repeat)\n      *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"})  = \"dcte\"\n      * </pre>\n-     * \n+     *\n      * @param text\n      *            text to search and replace in, no-op if null\n      * @param searchList\n      * <p>\n      * Replaces all occurrences of Strings within another String.\n      * </p>\n-     * \n+     *\n      * <p>\n      * A <code>null</code> reference passed to this method is a no-op, or if\n      * any \"search string\" or \"string to replace\" is null, that replace will be\n      * ignored. This will not repeat. For repeating replaces, call the\n      * overloaded method.\n      * </p>\n-     * \n+     *\n      * <pre>\n      *  StringUtils.replaceEach(null, *, *, *) = null\n      *  StringUtils.replaceEach(\"\", *, *, *) = \"\"\n      *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, true) = IllegalArgumentException\n      *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, false) = \"dcabe\"\n      * </pre>\n-     * \n+     *\n      * @param text\n      *            text to search and replace in, no-op if null\n      * @param searchList\n      * <p>\n      * Replaces all occurrences of Strings within another String.\n      * </p>\n-     * \n+     *\n      * <p>\n      * A <code>null</code> reference passed to this method is a no-op, or if\n      * any \"search string\" or \"string to replace\" is null, that replace will be\n-     * ignored. \n+     * ignored.\n      * </p>\n-     * \n+     *\n      * <pre>\n      *  StringUtils.replaceEach(null, *, *, *) = null\n      *  StringUtils.replaceEach(\"\", *, *, *) = \"\"\n      *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"t\"}, true) = \"tcte\"\n      *  StringUtils.replaceEach(\"abcde\", new String[]{\"ab\", \"d\"}, new String[]{\"d\", \"ab\"}, *) = IllegalArgumentException\n      * </pre>\n-     * \n+     *\n      * @param text\n      *            text to search and replace in, no-op if null\n      * @param searchList\n      *            the Strings to search for, no-op if null\n      * @param replacementList\n      *            the Strings to replace them with, no-op if null\n-     * @param repeat if true, then replace repeatedly \n+     * @param repeat if true, then replace repeatedly\n      *       until there are no more possible replacements or timeToLive < 0\n      * @param timeToLive\n      *            if less than 0 then there is a circular reference and endless\n      *             and/or size 0)\n      * @since 2.4\n      */\n-    private static String replaceEach(String text, String[] searchList, String[] replacementList, \n-                                      boolean repeat, int timeToLive) \n+    private static String replaceEach(String text, String[] searchList, String[] replacementList,\n+                                      boolean repeat, int timeToLive)\n     {\n \n         // mchyzer Performance note: This creates very few new objects (one major goal)\n         // let me know if there are performance requests, we can create a harness to measure\n \n-        if (text == null || text.length() == 0 || searchList == null || \n-            searchList.length == 0 || replacementList == null || replacementList.length == 0) \n+        if (text == null || text.length() == 0 || searchList == null ||\n+            searchList.length == 0 || replacementList == null || replacementList.length == 0)\n         {\n             return text;\n         }\n         // index of replace array that will replace the search string found\n         // NOTE: logic duplicated below START\n         for (int i = 0; i < searchLength; i++) {\n-            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n-                searchList[i].length() == 0 || replacementList[i] == null) \n+            if (noMoreMatchesForReplIndex[i] || searchList[i] == null ||\n+                searchList[i].length() == 0 || replacementList[i] == null)\n             {\n                 continue;\n             }\n             // find the next earliest match\n             // NOTE: logic mostly duplicated above START\n             for (int i = 0; i < searchLength; i++) {\n-                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n-                    searchList[i].length() == 0 || replacementList[i] == null) \n+                if (noMoreMatchesForReplIndex[i] || searchList[i] == null ||\n+                    searchList[i].length() == 0 || replacementList[i] == null)\n                 {\n                     continue;\n                 }\n      * <a href=\"http://www.unicode.org/glossary/#supplementary_character\">Unicode Supplementary Characters</a>\n      * as they require a pair of <code>char</code>s to be represented.\n      * If you are needing to support full I18N of your applications\n-     * consider using {@link #repeat(String, int)} instead. \n+     * consider using {@link #repeat(String, int)} instead.\n      * </p>\n      *\n      * @param repeat  number of times to repeat delim\n         }\n     }\n \n-\t/**\n-\t * Gets a CharSequence length or <code>0</code> if the CharSequence is\n-\t * <code>null</code>.\n-\t * \n-\t * @param cs\n-\t *            a CharSequence or <code>null</code>\n-\t * @return CharSequence length or <code>0</code> if the CharSequence is\n-\t *         <code>null</code>.\n-\t * @since 2.4\n-\t * @deprecated See {@link CharSequenceUtils#length(CharSequence)}\n-\t */\n-\tpublic static int length(CharSequence cs) {\n-\t\treturn CharSequenceUtils.length(cs);\n-\t}\n-    \n+    /**\n+     * Gets a CharSequence length or <code>0</code> if the CharSequence is\n+     * <code>null</code>.\n+     *\n+     * @param cs\n+     *            a CharSequence or <code>null</code>\n+     * @return CharSequence length or <code>0</code> if the CharSequence is\n+     *         <code>null</code>.\n+     * @since 2.4\n+     * @deprecated See {@link CharSequenceUtils#length(CharSequence)}\n+     */\n+    public static int length(CharSequence cs) {\n+        return CharSequenceUtils.length(cs);\n+    }\n+\n     // Centering\n     //-----------------------------------------------------------------------\n     /**\n \n     /**\n      * <p>Checks if the CharSequence contains only ASCII printable characters.</p>\n-     * \n+     *\n      * <p><code>null</code> will return <code>false</code>.\n      * An empty CharSequence (length()=0) will return <code>true</code>.</p>\n-     * \n+     *\n      * <pre>\n      * StringUtils.isAsciiPrintable(null)     = false\n      * StringUtils.isAsciiPrintable(\"\")       = true\n         if (str == null) {\n             return null;\n         }\n-\t\treturn new StringBuilder(str).reverse().toString();\n+        return new StringBuilder(str).reverse().toString();\n     }\n \n     /**\n             offset = str.length() - (maxWidth - 3);\n         }\n         final String abrevMarker = \"...\";\n-\t\tif (offset <= 4) {\n+        if (offset <= 4) {\n             return str.substring(0, maxWidth - 3) + abrevMarker;\n         }\n         if (maxWidth < 7) {\n         }\n         return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n     }\n-    \n+\n     /**\n      * <p>Abbreviates a String to the length passed, replacing the middle characters with the supplied\n      * replacement String.</p>\n         if (isEmpty(str) || isEmpty(middle)) {\n             return str;\n         }\n-      \n+\n         if (length >= str.length() || length < (middle.length()+2)) {\n             return str;\n         }\n         int targetSting = length-middle.length();\n         int startOffset = targetSting/2+targetSting%2;\n         int endOffset = str.length()-targetSting/2;\n-        \n+\n         StringBuilder builder = new StringBuilder(length);\n         builder.append(str.substring(0,startOffset));\n         builder.append(middle);\n         builder.append(str.substring(endOffset));\n-        \n+\n         return builder.toString();\n     }\n \n         }\n         return firstDiff;\n     }\n-    \n-    /**\n-     * <p>Compares all Strings in an array and returns the initial sequence of \n+\n+    /**\n+     * <p>Compares all Strings in an array and returns the initial sequence of\n      * characters that is common to all of them.</p>\n      *\n      * <p>For example,\n      *\n      * @param strs  array of String objects, entries may be null\n      * @return the initial sequence of characters that are common to all Strings\n-     * in the array; empty String if the array is null, the elements are all null \n-     * or if there is no common prefix. \n+     * in the array; empty String if the array is null, the elements are all null\n+     * or if there is no common prefix.\n      * @since 2.4\n      */\n     public static String getCommonPrefix(String[] strs) {\n             // we found a common initial character sequence\n             return strs[0].substring(0, smallestIndexOfDiff);\n         }\n-    }  \n-    \n+    }\n+\n     // Misc\n     //-----------------------------------------------------------------------\n     /**\n         }\n \n         /*\n-           The difference between this impl. and the previous is that, rather \n-           than creating and retaining a matrix of size s.length()+1 by t.length()+1, \n+           The difference between this impl. and the previous is that, rather\n+           than creating and retaining a matrix of size s.length()+1 by t.length()+1,\n            we maintain two single-dimensional arrays of length s.length()+1.  The first, d,\n            is the 'current working' distance array that maintains the newest distance cost\n            counts as we iterate through the characters of String s.  Each time we increment\n            the index of String t we are comparing, d is copied to p, the second int[].  Doing so\n-           allows us to retain the previous cost counts as required by the algorithm (taking \n+           allows us to retain the previous cost counts as required by the algorithm (taking\n            the minimum of the cost count to the left, up one, and diagonally up and to the left\n-           of the current cost count being calculated).  (Note that the arrays aren't really \n-           copied anymore, just switched...this is clearly much better than cloning an array \n+           of the current cost count being calculated).  (Note that the arrays aren't really\n+           copied anymore, just switched...this is clearly much better than cloning an array\n            or doing a System.arraycopy() each time  through the outer loop.)\n \n-           Effectively, the difference between the two implementations is this one does not \n+           Effectively, the difference between the two implementations is this one does not\n            cause an out of memory condition when calculating the LD over two very large strings.\n          */\n \n \n         if (n > m) {\n             // swap the input strings to consume less memory\n-        \tCharSequence tmp = s;\n+            CharSequence tmp = s;\n             s = t;\n             t = tmp;\n             n = m;\n             d = _d;\n         }\n \n-        // our last action in the above loop was to switch d and p, so p now \n+        // our last action in the above loop was to switch d and p, so p now\n         // actually has the most recent cost counts\n         return p[n];\n     }\n         }\n         return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length());\n     }\n-    \n+\n     /**\n      * <p>Check if a String starts with any of an array of specified strings.</p>\n-     * \n+     *\n      * <pre>\n      * StringUtils.startsWithAny(null, null)      = false\n      * StringUtils.startsWithAny(null, new String[] {\"abc\"})  = false\n--- a/src/test/java/org/apache/commons/lang3/CharSequenceUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/CharSequenceUtilsTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n \n /**\n  * Tests CharSequenceUtils\n- * \n+ *\n  * @author Gary Gregory\n  */\n public class CharSequenceUtilsTest extends TestCase {\n \n-\tpublic void testLength_CharBuffer() {\n-\t\tAssert.assertEquals(0, CharSequenceUtils.length(CharBuffer.wrap(\"\")));\n-\t\tAssert.assertEquals(1, CharSequenceUtils.length(CharBuffer.wrap(\"A\")));\n-\t\tAssert.assertEquals(1, CharSequenceUtils.length(CharBuffer.wrap(\" \")));\n-\t\tAssert.assertEquals(8, CharSequenceUtils.length(CharBuffer.wrap(\"ABCDEFGH\")));\n-\t}\n+    public void testLength_CharBuffer() {\n+        Assert.assertEquals(0, CharSequenceUtils.length(CharBuffer.wrap(\"\")));\n+        Assert.assertEquals(1, CharSequenceUtils.length(CharBuffer.wrap(\"A\")));\n+        Assert.assertEquals(1, CharSequenceUtils.length(CharBuffer.wrap(\" \")));\n+        Assert.assertEquals(8, CharSequenceUtils.length(CharBuffer.wrap(\"ABCDEFGH\")));\n+    }\n \n-\tpublic void testLength_String() {\n-\t\tAssert.assertEquals(0, CharSequenceUtils.length(null));\n-\t\tAssert.assertEquals(0, CharSequenceUtils.length(\"\"));\n-\t\tAssert.assertEquals(1, CharSequenceUtils.length(\"A\"));\n-\t\tAssert.assertEquals(1, CharSequenceUtils.length(\" \"));\n-\t\tAssert.assertEquals(8, CharSequenceUtils.length(\"ABCDEFGH\"));\n-\t}\n+    public void testLength_String() {\n+        Assert.assertEquals(0, CharSequenceUtils.length(null));\n+        Assert.assertEquals(0, CharSequenceUtils.length(\"\"));\n+        Assert.assertEquals(1, CharSequenceUtils.length(\"A\"));\n+        Assert.assertEquals(1, CharSequenceUtils.length(\" \"));\n+        Assert.assertEquals(8, CharSequenceUtils.length(\"ABCDEFGH\"));\n+    }\n \n-\tpublic void testLength_StringBuffer() {\n-\t\tAssert.assertEquals(0, CharSequenceUtils.length(new StringBuffer(\"\")));\n-\t\tAssert.assertEquals(1, CharSequenceUtils.length(new StringBuffer(\"A\")));\n-\t\tAssert.assertEquals(1, CharSequenceUtils.length(new StringBuffer(\" \")));\n-\t\tAssert.assertEquals(8, CharSequenceUtils.length(new StringBuffer(\"ABCDEFGH\")));\n-\t}\n+    public void testLength_StringBuffer() {\n+        Assert.assertEquals(0, CharSequenceUtils.length(new StringBuffer(\"\")));\n+        Assert.assertEquals(1, CharSequenceUtils.length(new StringBuffer(\"A\")));\n+        Assert.assertEquals(1, CharSequenceUtils.length(new StringBuffer(\" \")));\n+        Assert.assertEquals(8, CharSequenceUtils.length(new StringBuffer(\"ABCDEFGH\")));\n+    }\n \n-\tpublic void testLength_StringBuilder() {\n-\t\tAssert.assertEquals(0, CharSequenceUtils.length(new StringBuilder(\"\")));\n-\t\tAssert.assertEquals(1, CharSequenceUtils.length(new StringBuilder(\"A\")));\n-\t\tAssert.assertEquals(1, CharSequenceUtils.length(new StringBuilder(\" \")));\n-\t\tAssert.assertEquals(8, CharSequenceUtils.length(new StringBuilder(\"ABCDEFGH\")));\n-\t}\n+    public void testLength_StringBuilder() {\n+        Assert.assertEquals(0, CharSequenceUtils.length(new StringBuilder(\"\")));\n+        Assert.assertEquals(1, CharSequenceUtils.length(new StringBuilder(\"A\")));\n+        Assert.assertEquals(1, CharSequenceUtils.length(new StringBuilder(\" \")));\n+        Assert.assertEquals(8, CharSequenceUtils.length(new StringBuilder(\"ABCDEFGH\")));\n+    }\n \n-\tpublic void testSubSequence() {\n-\t\t//\n-\t\t// null input\n-\t\t//\n-\t\tAssert.assertEquals(null, CharSequenceUtils.subSequence(null, -1));\n-\t\tAssert.assertEquals(null, CharSequenceUtils.subSequence(null, 0));\n-\t\tAssert.assertEquals(null, CharSequenceUtils.subSequence(null, 1));\n-\t\t//\n-\t\t// non-null input\n-\t\t//\n-\t\tAssert.assertEquals(StringUtils.EMPTY, CharSequenceUtils.subSequence(StringUtils.EMPTY, 0));\n-\t\tAssert.assertEquals(\"012\", CharSequenceUtils.subSequence(\"012\", 0));\n-\t\tAssert.assertEquals(\"12\", CharSequenceUtils.subSequence(\"012\", 1));\n-\t\tAssert.assertEquals(\"2\", CharSequenceUtils.subSequence(\"012\", 2));\n-\t\tAssert.assertEquals(StringUtils.EMPTY, CharSequenceUtils.subSequence(\"012\", 3));\n-\t\t//\n-\t\t// Exception expected\n-\t\t//\n-\t\ttry {\n-\t\t\tAssert.assertEquals(null, CharSequenceUtils.subSequence(StringUtils.EMPTY, -1));\n-\t\t\tAssert.fail(\"Expected \" + IndexOutOfBoundsException.class.getName());\n-\t\t} catch (IndexOutOfBoundsException e) {\n-\t\t\t// Expected\n-\t\t}\n-\t\ttry {\n-\t\t\tAssert.assertEquals(null, CharSequenceUtils.subSequence(StringUtils.EMPTY, 1));\n-\t\t\tAssert.fail(\"Expected \" + IndexOutOfBoundsException.class.getName());\n-\t\t} catch (IndexOutOfBoundsException e) {\n-\t\t\t// Expected\n-\t\t}\n-\t}\n+    public void testSubSequence() {\n+        //\n+        // null input\n+        //\n+        Assert.assertEquals(null, CharSequenceUtils.subSequence(null, -1));\n+        Assert.assertEquals(null, CharSequenceUtils.subSequence(null, 0));\n+        Assert.assertEquals(null, CharSequenceUtils.subSequence(null, 1));\n+        //\n+        // non-null input\n+        //\n+        Assert.assertEquals(StringUtils.EMPTY, CharSequenceUtils.subSequence(StringUtils.EMPTY, 0));\n+        Assert.assertEquals(\"012\", CharSequenceUtils.subSequence(\"012\", 0));\n+        Assert.assertEquals(\"12\", CharSequenceUtils.subSequence(\"012\", 1));\n+        Assert.assertEquals(\"2\", CharSequenceUtils.subSequence(\"012\", 2));\n+        Assert.assertEquals(StringUtils.EMPTY, CharSequenceUtils.subSequence(\"012\", 3));\n+        //\n+        // Exception expected\n+        //\n+        try {\n+            Assert.assertEquals(null, CharSequenceUtils.subSequence(StringUtils.EMPTY, -1));\n+            Assert.fail(\"Expected \" + IndexOutOfBoundsException.class.getName());\n+        } catch (IndexOutOfBoundsException e) {\n+            // Expected\n+        }\n+        try {\n+            Assert.assertEquals(null, CharSequenceUtils.subSequence(StringUtils.EMPTY, 1));\n+            Assert.fail(\"Expected \" + IndexOutOfBoundsException.class.getName());\n+        } catch (IndexOutOfBoundsException e) {\n+            // Expected\n+        }\n+    }\n \n }\n--- a/src/test/java/org/apache/commons/lang3/StringUtilsEqualsIndexOfTest.java\n+++ b/src/test/java/org/apache/commons/lang3/StringUtilsEqualsIndexOfTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n      */\n     private static final String CharU20000 = \"\\uD840\\uDC00\";\n     /**\n-\t * Supplementary character U+20001\n-\t * See http://java.sun.com/developer/technicalArticles/Intl/Supplementary/\n-\t */\n-\tprivate static final String CharU20001 = \"\\uD840\\uDC01\";\n+     * Supplementary character U+20001\n+     * See http://java.sun.com/developer/technicalArticles/Intl/Supplementary/\n+     */\n+    private static final String CharU20001 = \"\\uD840\\uDC01\";\n     /**\n      * Incomplete supplementary character U+20000, high surrogate only.\n      * See http://java.sun.com/developer/technicalArticles/Intl/Supplementary/\n      */\n     private static final String CharUSuppCharHigh = \"\\uDC00\";\n-\t\n+\n     /**\n      * Incomplete supplementary character U+20000, low surrogate only.\n      * See http://java.sun.com/developer/technicalArticles/Intl/Supplementary/\n \n     private static final String FOOBAR = \"foobar\";\n \n-\tprivate static final String[] FOOBAR_SUB_ARRAY = new String[] {\"ob\", \"ba\"};\n-\t\n+    private static final String[] FOOBAR_SUB_ARRAY = new String[] {\"ob\", \"ba\"};\n+\n     public StringUtilsEqualsIndexOfTest(String name) {\n         super(name);\n     }\n         assertFalse(StringUtils.containsAny(null, (String) null));\n         assertFalse(StringUtils.containsAny(null, \"\"));\n         assertFalse(StringUtils.containsAny(null, \"ab\"));\n-        \n+\n         assertFalse(StringUtils.containsAny(\"\", (String) null));\n         assertFalse(StringUtils.containsAny(\"\", \"\"));\n         assertFalse(StringUtils.containsAny(\"\", \"ab\"));\n-        \n-        assertFalse(StringUtils.containsAny(\"zzabyycdxx\", (String) null)); \n-        assertFalse(StringUtils.containsAny(\"zzabyycdxx\", \"\")); \n-        assertTrue(StringUtils.containsAny(\"zzabyycdxx\", \"za\")); \n+\n+        assertFalse(StringUtils.containsAny(\"zzabyycdxx\", (String) null));\n+        assertFalse(StringUtils.containsAny(\"zzabyycdxx\", \"\"));\n+        assertTrue(StringUtils.containsAny(\"zzabyycdxx\", \"za\"));\n         assertTrue(StringUtils.containsAny(\"zzabyycdxx\", \"by\"));\n         assertFalse(StringUtils.containsAny(\"ab\", \"z\"));\n     }\n \n         Locale[] locales = { Locale.ENGLISH, new Locale(\"tr\"), Locale.getDefault() };\n \n-        String[][] tdata = { \n+        String[][] tdata = {\n             { \"i\", \"I\" },\n             { \"I\", \"i\" },\n             { \"\\u03C2\", \"\\u03C3\" },\n             { \"\\u03A3\", \"\\u03C3\" },\n         };\n \n-        String[][] fdata = { \n+        String[][] fdata = {\n             { \"\\u00DF\", \"SS\" },\n         };\n \n \n     public void testContainsIgnoreCase_StringString() {\n         assertFalse(StringUtils.containsIgnoreCase(null, null));\n-        \n+\n         // Null tests\n         assertFalse(StringUtils.containsIgnoreCase(null, \"\"));\n         assertFalse(StringUtils.containsIgnoreCase(null, \"a\"));\n         assertFalse(StringUtils.containsIgnoreCase(null, \"abc\"));\n-        \n+\n         assertFalse(StringUtils.containsIgnoreCase(\"\", null));\n         assertFalse(StringUtils.containsIgnoreCase(\"a\", null));\n         assertFalse(StringUtils.containsIgnoreCase(\"abc\", null));\n-        \n+\n         // Match len = 0\n         assertTrue(StringUtils.containsIgnoreCase(\"\", \"\"));\n         assertTrue(StringUtils.containsIgnoreCase(\"a\", \"\"));\n         assertFalse(StringUtils.containsIgnoreCase(\"\", \"A\"));\n         assertTrue(StringUtils.containsIgnoreCase(\"a\", \"A\"));\n         assertTrue(StringUtils.containsIgnoreCase(\"abc\", \"A\"));\n-        \n+\n         // Match len > 1\n         assertFalse(StringUtils.containsIgnoreCase(\"\", \"abc\"));\n         assertFalse(StringUtils.containsIgnoreCase(\"a\", \"abc\"));\n         assertEquals(-1, CharU20001.indexOf(CharUSuppCharHigh));\n         assertEquals(true, StringUtils.containsNone(CharU20001, CharUSuppCharHigh));\n         assertEquals(0, CharU20001.indexOf(CharUSuppCharLow));\n-        assertEquals(false, StringUtils.containsNone(CharU20001, CharUSuppCharLow));        \n+        assertEquals(false, StringUtils.containsNone(CharU20001, CharUSuppCharLow));\n     }\n \n     /**\n         assertEquals(5, StringUtils.indexOf(\"aabaabaa\", \"b\", 3));\n         assertEquals(-1, StringUtils.indexOf(\"aabaabaa\", \"b\", 9));\n         assertEquals(2, StringUtils.indexOf(\"aabaabaa\", \"b\", -1));\n-        assertEquals(2,StringUtils.indexOf(\"aabaabaa\", \"\", 2)); \n+        assertEquals(2,StringUtils.indexOf(\"aabaabaa\", \"\", 2));\n     }\n \n     public void testIndexOfAny_StringCharArray() {\n         assertEquals(-1, StringUtils.indexOfAny(null, (char[]) null));\n         assertEquals(-1, StringUtils.indexOfAny(null, new char[0]));\n         assertEquals(-1, StringUtils.indexOfAny(null, new char[] {'a','b'}));\n-        \n+\n         assertEquals(-1, StringUtils.indexOfAny(\"\", (char[]) null));\n         assertEquals(-1, StringUtils.indexOfAny(\"\", new char[0]));\n         assertEquals(-1, StringUtils.indexOfAny(\"\", new char[] {'a','b'}));\n-        \n-        assertEquals(-1, StringUtils.indexOfAny(\"zzabyycdxx\", (char[]) null)); \n-        assertEquals(-1, StringUtils.indexOfAny(\"zzabyycdxx\", new char[0])); \n-        assertEquals(0, StringUtils.indexOfAny(\"zzabyycdxx\", new char[] {'z','a'})); \n+\n+        assertEquals(-1, StringUtils.indexOfAny(\"zzabyycdxx\", (char[]) null));\n+        assertEquals(-1, StringUtils.indexOfAny(\"zzabyycdxx\", new char[0]));\n+        assertEquals(0, StringUtils.indexOfAny(\"zzabyycdxx\", new char[] {'z','a'}));\n         assertEquals(3, StringUtils.indexOfAny(\"zzabyycdxx\", new char[] {'b','y'}));\n         assertEquals(-1, StringUtils.indexOfAny(\"ab\", new char[] {'z'}));\n     }\n         assertEquals(0, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20000.toCharArray()));\n         assertEquals(2, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20001.toCharArray()));\n         assertEquals(0, StringUtils.indexOfAny(CharU20000, CharU20000.toCharArray()));\n-        assertEquals(-1, StringUtils.indexOfAny(CharU20000, CharU20001.toCharArray()));    \n+        assertEquals(-1, StringUtils.indexOfAny(CharU20000, CharU20001.toCharArray()));\n     }\n \n     public void testIndexOfAny_StringString() {\n         assertEquals(-1, StringUtils.indexOfAny(null, (String) null));\n         assertEquals(-1, StringUtils.indexOfAny(null, \"\"));\n         assertEquals(-1, StringUtils.indexOfAny(null, \"ab\"));\n-        \n+\n         assertEquals(-1, StringUtils.indexOfAny(\"\", (String) null));\n         assertEquals(-1, StringUtils.indexOfAny(\"\", \"\"));\n         assertEquals(-1, StringUtils.indexOfAny(\"\", \"ab\"));\n-        \n-        assertEquals(-1, StringUtils.indexOfAny(\"zzabyycdxx\", (String) null)); \n-        assertEquals(-1, StringUtils.indexOfAny(\"zzabyycdxx\", \"\")); \n-        assertEquals(0, StringUtils.indexOfAny(\"zzabyycdxx\", \"za\")); \n+\n+        assertEquals(-1, StringUtils.indexOfAny(\"zzabyycdxx\", (String) null));\n+        assertEquals(-1, StringUtils.indexOfAny(\"zzabyycdxx\", \"\"));\n+        assertEquals(0, StringUtils.indexOfAny(\"zzabyycdxx\", \"za\"));\n         assertEquals(3, StringUtils.indexOfAny(\"zzabyycdxx\", \"by\"));\n         assertEquals(-1, StringUtils.indexOfAny(\"ab\", \"z\"));\n     }\n         assertEquals(0, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20000));\n         assertEquals(2, StringUtils.indexOfAny(CharU20000 + CharU20001, CharU20001));\n         assertEquals(0, StringUtils.indexOfAny(CharU20000, CharU20000));\n-        assertEquals(-1, StringUtils.indexOfAny(CharU20000, CharU20001));    \n+        assertEquals(-1, StringUtils.indexOfAny(CharU20000, CharU20001));\n     }\n \n     public void testIndexOfAnyBut_StringCharArray() {\n         assertEquals(-1, StringUtils.indexOfAnyBut(null, (char[]) null));\n         assertEquals(-1, StringUtils.indexOfAnyBut(null, new char[0]));\n         assertEquals(-1, StringUtils.indexOfAnyBut(null, new char[] {'a','b'}));\n-        \n+\n         assertEquals(-1, StringUtils.indexOfAnyBut(\"\", (char[]) null));\n         assertEquals(-1, StringUtils.indexOfAnyBut(\"\", new char[0]));\n         assertEquals(-1, StringUtils.indexOfAnyBut(\"\", new char[] {'a','b'}));\n-        \n+\n         assertEquals(-1, StringUtils.indexOfAnyBut(\"zzabyycdxx\", (char[]) null));\n         assertEquals(-1, StringUtils.indexOfAnyBut(\"zzabyycdxx\", new char[0]));\n-        assertEquals(3, StringUtils.indexOfAnyBut(\"zzabyycdxx\", new char[] {'z','a'})); \n-        assertEquals(0, StringUtils.indexOfAnyBut(\"zzabyycdxx\", new char[] {'b','y'})); \n+        assertEquals(3, StringUtils.indexOfAnyBut(\"zzabyycdxx\", new char[] {'z','a'}));\n+        assertEquals(0, StringUtils.indexOfAnyBut(\"zzabyycdxx\", new char[] {'b','y'}));\n         assertEquals(0, StringUtils.indexOfAnyBut(\"ab\", new char[] {'z'}));\n     }\n-    \n+\n     public void testIndexOfAnyBut_StringCharArrayWithSupplementaryChars() {\n         assertEquals(2, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20000.toCharArray()));\n         assertEquals(0, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20001.toCharArray()));\n         assertEquals(-1, StringUtils.indexOfAnyBut(CharU20000, CharU20000.toCharArray()));\n-        assertEquals(0, StringUtils.indexOfAnyBut(CharU20000, CharU20001.toCharArray()));        \n-    }\n-    \n+        assertEquals(0, StringUtils.indexOfAnyBut(CharU20000, CharU20001.toCharArray()));\n+    }\n+\n     public void testIndexOfAnyBut_StringString() {\n         assertEquals(-1, StringUtils.indexOfAnyBut(null, (String) null));\n         assertEquals(-1, StringUtils.indexOfAnyBut(null, \"\"));\n         assertEquals(-1, StringUtils.indexOfAnyBut(null, \"ab\"));\n-        \n+\n         assertEquals(-1, StringUtils.indexOfAnyBut(\"\", (String) null));\n         assertEquals(-1, StringUtils.indexOfAnyBut(\"\", \"\"));\n         assertEquals(-1, StringUtils.indexOfAnyBut(\"\", \"ab\"));\n-        \n-        assertEquals(-1, StringUtils.indexOfAnyBut(\"zzabyycdxx\", (String) null)); \n-        assertEquals(-1, StringUtils.indexOfAnyBut(\"zzabyycdxx\", \"\")); \n-        assertEquals(3, StringUtils.indexOfAnyBut(\"zzabyycdxx\", \"za\")); \n+\n+        assertEquals(-1, StringUtils.indexOfAnyBut(\"zzabyycdxx\", (String) null));\n+        assertEquals(-1, StringUtils.indexOfAnyBut(\"zzabyycdxx\", \"\"));\n+        assertEquals(3, StringUtils.indexOfAnyBut(\"zzabyycdxx\", \"za\"));\n         assertEquals(0, StringUtils.indexOfAnyBut(\"zzabyycdxx\", \"by\"));\n         assertEquals(0, StringUtils.indexOfAnyBut(\"ab\", \"z\"));\n     }\n-    \n+\n     public void testIndexOfAnyBut_StringStringWithSupplementaryChars() {\n         assertEquals(2, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20000));\n         assertEquals(0, StringUtils.indexOfAnyBut(CharU20000 + CharU20001, CharU20001));\n         assertEquals(-1, StringUtils.indexOfAnyBut(CharU20000, CharU20000));\n-        assertEquals(0, StringUtils.indexOfAnyBut(CharU20000, CharU20001));        \n+        assertEquals(0, StringUtils.indexOfAnyBut(CharU20000, CharU20001));\n     }\n \n     public void testIndexOfIgnoreCase_String() {\n         assertEquals(0, StringUtils.lastIndexOfIgnoreCase(\"aab\", \"AAB\"));\n     }\n \n-\tpublic void testLastIndexOfIgnoreCase_StringInt() {\n+    public void testLastIndexOfIgnoreCase_StringInt() {\n         assertEquals(-1, StringUtils.lastIndexOfIgnoreCase(null, null, 0));\n         assertEquals(-1, StringUtils.lastIndexOfIgnoreCase(null, null, -1));\n         assertEquals(-1, StringUtils.lastIndexOfIgnoreCase(null, \"\", 0));\n         assertEquals(0, StringUtils.lastIndexOfIgnoreCase(\"aabaabaa\", \"A\", 0));\n         assertEquals(1, StringUtils.lastIndexOfIgnoreCase(\"aab\", \"AB\", 1));\n     }\n-\t\n+\n     public void testLastOrdinalIndexOf() {\n         assertEquals(-1, StringUtils.lastOrdinalIndexOf(null, \"*\", 42) );\n         assertEquals(-1, StringUtils.lastOrdinalIndexOf(\"*\", null, 42) );\n         assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", Integer.MIN_VALUE));\n         assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", Integer.MIN_VALUE));\n         assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", Integer.MIN_VALUE));\n-        \n+\n         assertEquals(-1, StringUtils.ordinalIndexOf(null, null, -1));\n         assertEquals(-1, StringUtils.ordinalIndexOf(\"\", null, -1));\n         assertEquals(-1, StringUtils.ordinalIndexOf(\"\", \"\", -1));\n         assertEquals(5, StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", 2));\n         assertEquals(4, StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", 2));\n         assertEquals(0, StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", 2));\n-        \n+\n         assertEquals(-1, StringUtils.ordinalIndexOf(null, null, Integer.MAX_VALUE));\n         assertEquals(-1, StringUtils.ordinalIndexOf(\"\", null, Integer.MAX_VALUE));\n         assertEquals(0, StringUtils.ordinalIndexOf(\"\", \"\", Integer.MAX_VALUE));\n         assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"b\", Integer.MAX_VALUE));\n         assertEquals(-1, StringUtils.ordinalIndexOf(\"aabaabaa\", \"ab\", Integer.MAX_VALUE));\n         assertEquals(0, StringUtils.ordinalIndexOf(\"aabaabaa\", \"\", Integer.MAX_VALUE));\n-        \n+\n         assertEquals(-1, StringUtils.ordinalIndexOf(\"aaaaaaaaa\", \"a\", 0));\n         assertEquals(0, StringUtils.ordinalIndexOf(\"aaaaaaaaa\", \"a\", 1));\n         assertEquals(1, StringUtils.ordinalIndexOf(\"aaaaaaaaa\", \"a\", 2));", "timestamp": 1268706840, "metainfo": ""}