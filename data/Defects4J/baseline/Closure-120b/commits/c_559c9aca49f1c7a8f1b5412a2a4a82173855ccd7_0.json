{"sha": "559c9aca49f1c7a8f1b5412a2a4a82173855ccd7", "log": "A few more performance improvements in PeepholeMinimizeConditions. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=47556985", "commit": "\n--- a/src/com/google/javascript/jscomp/PeepholeMinimizeConditions.java\n+++ b/src/com/google/javascript/jscomp/PeepholeMinimizeConditions.java\n \n import com.google.common.base.Preconditions;\n import com.google.common.base.Predicate;\n-import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.ImmutableList;\n import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n    */\n   private Node tryMinimizeExprResult(Node node) {\n     Node originalCond = node.getFirstChild();\n+    Node placeholder = IR.script();\n+    node.replaceChild(originalCond, placeholder);\n     MinimizedCondition minCond = (aggressiveMinimization) ?\n         MinimizedCondition.fromConditionNode(originalCond) :\n           MinimizedCondition.unoptimized(originalCond);\n         minCond.getShorterRepresentation(false);\n     if (mNode.node.isNot()) {\n       // Remove the leading NOT in the EXPR_RESULT.\n-      node.replaceChild(originalCond, mNode.node.removeFirstChild());\n+      node.replaceChild(placeholder, mNode.node.removeFirstChild());\n       reportCodeChange();\n     } else {\n-      maybeReplaceNode(originalCond, mNode);\n+      replaceNode(placeholder, mNode);\n     }\n     return node;\n   }\n    */\n   private Node tryMinimizeHook(Node n) {\n     Node originalCond = n.getFirstChild();\n+    Node placeholder = IR.script();\n+    n.replaceChild(originalCond, placeholder);\n     MinimizedCondition minCond = (aggressiveMinimization) ?\n         MinimizedCondition.fromConditionNode(originalCond) :\n           MinimizedCondition.unoptimized(originalCond);\n         minCond.getShorterRepresentation(false);\n     if (mNode.node.isNot()) {\n       // Swap the HOOK\n-      Node thenBranch = originalCond.getNext();\n-      n.replaceChild(originalCond, mNode.node.removeFirstChild());\n+      Node thenBranch = n.getFirstChild().getNext();\n+      n.replaceChild(placeholder, mNode.node.removeFirstChild());\n       n.removeChild(thenBranch);\n       n.addChildToBack(thenBranch);\n       reportCodeChange();\n     } else {\n-      maybeReplaceNode(originalCond, mNode);\n+      replaceNode(placeholder, mNode);\n     }\n     return n;\n   }\n \n     Node thenBranch = originalCond.getNext();\n     Node elseBranch = thenBranch.getNext();\n+\n+    Node placeholder = IR.script().srcref(originalCond);\n+    n.replaceChild(originalCond, placeholder);\n \n     MinimizedCondition.MeasuredNode unnegatedCond;\n     MinimizedCondition.MeasuredNode shortCond;\n           originalCond, 0, false);\n       shortCond = unnegatedCond;\n     }\n+    originalCond = null;\n \n     if (elseBranch == null) {\n       if (isFoldableExpressBlock(thenBranch)) {\n           // Keep opportunities for CollapseProperties such as\n           // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n           // until CollapseProperties has been run.\n+          replaceNode(placeholder, unnegatedCond);\n           return n;\n         }\n \n           // there is no immediate code size win. However, two extra pair of\n           // {}, we would have to think twice. (unless we know for sure the\n           // we can further optimize its parent.\n-          maybeReplaceNode(originalCond, shortCond);\n+          replaceNode(placeholder, shortCond);\n           return n;\n         }\n \n-        n.removeChild(originalCond);\n+        n.removeChild(placeholder);\n         Node and = IR.and(shortCond.node, expr.removeFirstChild()).srcref(n);\n         Node newExpr = NodeUtil.newExpr(and);\n         parent.replaceChild(n, newExpr);\n                   IR.and(\n                       unnegatedCond.node,\n                       innerCond.detachFromParent())\n-                      .srcref(originalCond));\n+                      .srcref(placeholder));\n               n.addChildrenToBack(innerThenBranch.detachFromParent());\n               reportCodeChange();\n               // Not worth trying to fold the current IF-ELSE into && because\n           }\n         }\n       }\n-      maybeReplaceNode(originalCond, unnegatedCond);\n+      replaceNode(placeholder, unnegatedCond);\n       return n;\n     }\n \n     // if(!x)foo();else bar(); -> if(x)bar();else foo();\n     // An additional set of curly braces isn't worth it.\n     if (shortCond.node.isNot() && !consumesDanglingElse(elseBranch)) {\n-      n.replaceChild(originalCond, shortCond.node.removeFirstChild());\n+      n.replaceChild(placeholder, shortCond.node.removeFirstChild());\n       n.removeChild(thenBranch);\n       n.addChildToBack(thenBranch);\n       reportCodeChange();\n     if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n       Node thenExpr = getBlockReturnExpression(thenBranch);\n       Node elseExpr = getBlockReturnExpression(elseBranch);\n-      n.removeChild(originalCond);\n+      n.removeChild(placeholder);\n       thenExpr.detachFromParent();\n       elseExpr.detachFromParent();\n \n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n               !mayEffectMutableState(lhs) &&\n-              (!mayHaveSideEffects(originalCond) ||\n+              (!mayHaveSideEffects(unnegatedCond.node) ||\n                   (thenOp.isAssign() && thenOp.getFirstChild().isName()))) {\n \n-            n.removeChild(originalCond);\n+            n.removeChild(placeholder);\n             Node assignName = thenOp.removeFirstChild();\n             Node thenExpr = thenOp.removeFirstChild();\n             Node elseExpr = elseOp.getLastChild();\n         }\n       }\n       // if(x)foo();else bar(); -> x?foo():bar()\n-      n.removeChild(originalCond);\n+      n.removeChild(placeholder);\n       thenOp.detachFromParent();\n       elseOp.detachFromParent();\n       Node expr = IR.exprResult(\n           && name1.getString().equals(maybeName2.getString())) {\n         Node thenExpr = name1.removeChildren();\n         Node elseExpr = elseAssign.getLastChild().detachFromParent();\n-        originalCond.detachFromParent();\n+        placeholder.detachFromParent();\n         Node hookNode = IR.hook(shortCond.node, thenExpr, elseExpr)\n                             .srcref(n);\n         var.detachFromParent();\n           && maybeName1.getString().equals(name2.getString())) {\n         Node thenExpr = thenAssign.getLastChild().detachFromParent();\n         Node elseExpr = name2.removeChildren();\n-        originalCond.detachFromParent();\n+        placeholder.detachFromParent();\n         Node hookNode = IR.hook(shortCond.node, thenExpr, elseExpr)\n                             .srcref(n);\n         var.detachFromParent();\n       }\n     }\n \n-    maybeReplaceNode(originalCond, unnegatedCond);\n+    replaceNode(placeholder, unnegatedCond);\n     return n;\n   }\n \n   private Node tryMinimizeCondition(Node n) {\n     n = performConditionSubstitutions(n);\n     if (aggressiveMinimization) {\n+      Node placeholder = IR.script();\n+      n.getParent().replaceChild(n, placeholder);\n       MinimizedCondition minCond = MinimizedCondition.fromConditionNode(n);\n-      return maybeReplaceNode(n, minCond.getShorterRepresentation(true));\n+      return replaceNode(placeholder,\n+          minCond.getShorterRepresentation(true));\n     } else {\n       return n;\n     }\n   }\n \n-  private Node maybeReplaceNode(Node lhs, MinimizedCondition.MeasuredNode rhs) {\n-    if (!rhs.changed) {\n-      return lhs;\n-    }\n-    // Removed for performance reasons.\n-    // Preconditions.checkState(!lhs.isEquivalentTo(rhs.node));\n+  private Node replaceNode(Node lhs, MinimizedCondition.MeasuredNode rhs) {\n     Node parent = lhs.getParent();\n     parent.replaceChild(lhs, rhs.node);\n-    reportCodeChange();\n+    if (rhs.changed) {\n+      reportCodeChange();\n+    }\n     return rhs.node;\n   }\n \n       }\n \n       private MeasuredNode negate() {\n-        return addNot().change();\n-      }\n-\n-      private MeasuredNode change() {\n-        this.changed = true;\n-        return this;\n-      }\n-\n-      private MeasuredNode addNot() {\n+        this.change();\n         int complementOperator;\n         switch (node.getType()) {\n           default:\n-            node = new Node(Token.NOT, node).srcref(node);\n-            length += estimateCostOneLevel(node);\n-            return this;\n+            return this.addNot();\n           // Otherwise a binary operator with a complement.\n           case Token.EQ:\n             complementOperator = Token.NE;\n         }\n         // Clone entire tree and just change operator.\n         node.setType(complementOperator);\n+        return this;\n+      }\n+\n+      private MeasuredNode change() {\n         this.changed = true;\n+        return this;\n+      }\n+\n+      private MeasuredNode addNot() {\n+        node = new Node(Token.NOT, node).srcref(node);\n+        length += estimateCostOneLevel(node);\n         return this;\n       }\n \n       negative = n.change();\n     }\n \n+    static MinimizedCondition fromConditionNode(Node n) {\n+      switch (n.getType()) {\n+        case Token.NOT:\n+        case Token.AND:\n+        case Token.OR:\n+        case Token.HOOK:\n+        case Token.COMMA:\n+          return computeMinimizedCondition(n);\n+        default:\n+          return unoptimized(n);\n+      }\n+    }\n+\n     /** Minimize the condition at the given node.\n      *\n      *  @param n The conditional expression tree to minimize.\n-     *   This may be still connected to a tree and will be cloned as necessary.\n+     *   This must be removed from the tree before being passed in connected.\n      *  @return A MinimizedCondition object representing that tree.\n      */\n-    static MinimizedCondition fromConditionNode(Node n) {\n+    private static MinimizedCondition computeMinimizedCondition(Node n) {\n+      Preconditions.checkArgument(n.getParent() == null);\n       switch (n.getType()) {\n         case Token.NOT: {\n-          MinimizedCondition subtree = fromConditionNode(n.getFirstChild());\n-          ImmutableSet<MeasuredNode> positiveAsts = ImmutableSet.of(\n+          MinimizedCondition subtree =\n+              computeMinimizedCondition(n.getFirstChild().detachFromParent());\n+          ImmutableList<MeasuredNode> positiveAsts = ImmutableList.of(\n               subtree.positive.cloneTree().addNot(),\n               subtree.negative.cloneTree());\n-          ImmutableSet<MeasuredNode> negativeAsts = ImmutableSet.of(\n+          ImmutableList<MeasuredNode> negativeAsts = ImmutableList.of(\n               subtree.negative.negate(),\n               subtree.positive);\n           return new MinimizedCondition(\n         case Token.OR: {\n           int opType = n.getType();\n           int complementType = opType == Token.AND ? Token.OR : Token.AND;\n-          MinimizedCondition leftSubtree = fromConditionNode(n.getFirstChild());\n-          MinimizedCondition rightSubtree = fromConditionNode(n.getLastChild());\n-          ImmutableSet<MeasuredNode> positiveAsts = ImmutableSet.of(\n+          MinimizedCondition leftSubtree =\n+              computeMinimizedCondition(n.getFirstChild().detachFromParent());\n+          MinimizedCondition rightSubtree =\n+              computeMinimizedCondition(n.getLastChild().detachFromParent());\n+          ImmutableList<MeasuredNode> positiveAsts = ImmutableList.of(\n               MeasuredNode.addNode(new Node(opType).srcref(n),\n                   leftSubtree.positive.cloneTree(),\n                   rightSubtree.positive.cloneTree()),\n               MeasuredNode.addNode(new Node(complementType).srcref(n),\n                   leftSubtree.negative.cloneTree(),\n                   rightSubtree.negative.cloneTree()).negate());\n-          ImmutableSet<MeasuredNode> negativeAsts = ImmutableSet.of(\n+          ImmutableList<MeasuredNode> negativeAsts = ImmutableList.of(\n               MeasuredNode.addNode(new Node(opType).srcref(n),\n                   leftSubtree.positive,\n                   rightSubtree.positive).negate(),\n           Node cond = n.getFirstChild();\n           Node thenNode = cond.getNext();\n           Node elseNode = thenNode.getNext();\n-          MinimizedCondition thenSubtree = fromConditionNode(thenNode);\n-          MinimizedCondition elseSubtree = fromConditionNode(elseNode);\n+          MinimizedCondition thenSubtree =\n+              computeMinimizedCondition(thenNode.detachFromParent());\n+          MinimizedCondition elseSubtree =\n+              computeMinimizedCondition(elseNode.detachFromParent());\n           MeasuredNode posTree = MeasuredNode.addNode(\n               new Node(Token.HOOK, cond.cloneTree()).srcref(n),\n               thenSubtree.positive,\n         }\n         case Token.COMMA: {\n           Node lhs = n.getFirstChild();\n-          MinimizedCondition rhsSubtree = fromConditionNode(lhs.getNext());\n+          MinimizedCondition rhsSubtree =\n+              computeMinimizedCondition(lhs.getNext().detachFromParent());\n           MeasuredNode posTree = MeasuredNode.addNode(\n               new Node(Token.COMMA, lhs.cloneTree()).srcref(n),\n               rhsSubtree.positive);\n               rhsSubtree.negative);\n           return new MinimizedCondition(posTree, negTree);\n         }\n-        default:\n-          return unoptimized(n);\n-      }\n-    }\n-\n+        default: {\n+          MeasuredNode pos = new MeasuredNode(n, 0, false);\n+          MeasuredNode neg = pos.cloneTree().negate();\n+          return new MinimizedCondition(pos, neg);\n+        }\n+      }\n+    }\n+\n+    /** Return a MeasuredNode of the given condition node, without minimizing\n+     * the result.\n+    *\n+    *  @param n The conditional expression tree to minimize.\n+    *   This must be removed from the tree before being passed in connected.\n+    *  @return A MinimizedCondition object representing that tree.\n+    */\n     static MinimizedCondition unoptimized(Node n) {\n-      MeasuredNode pos = new MeasuredNode(n.cloneTree(), 0, false);\n-      MeasuredNode neg = pos.cloneTree().negate();\n+      Preconditions.checkArgument(n.getParent() == null);\n+      MeasuredNode pos = new MeasuredNode(n, 0, false);\n+      // In the unoptimized case, we want to always return the positive side,\n+      // so we set the negative side to a SCRIPT node (never valid inside an\n+      // expression) with an unreasonably high length so that it's never chosen.\n+      MeasuredNode neg = new MeasuredNode(IR.script(), Integer.MAX_VALUE, true);\n       return new MinimizedCondition(pos, neg);\n-    }\n-\n-    Node getNode() {\n-      return positive.node;\n-    }\n-\n-    Node getNegatedNode() {\n-      return negative.node;\n     }\n \n     /** Return the shorter representation of the original condition node.\n      *    to that passed to #fromConditionNode().\n      */\n     MeasuredNode getShorterRepresentation(boolean countLeadingNot) {\n-     if (countLeadingNot || positive.length <= negative.length) {\n+     if (countLeadingNot || positive.node.isNot()\n+         || positive.length <= negative.length) {\n        return positive;\n      } else {\n-       return negative.negate();\n+       return negative.addNot();\n      }\n     }\n \n--- a/test/com/google/javascript/jscomp/CompilerTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java\n             \"even though nothing changed\",\n             hasCodeChanged);\n       } else {\n-        assertTrue(\"compiler.reportCodeChange() should have been called\",\n-            hasCodeChanged);\n+        assertTrue(\"compiler.reportCodeChange() should have been called.\"\n+            + \"\\nOriginal: \" + mainRootClone.toStringTree()\n+            + \"\\nNew: \" + mainRoot.toStringTree(), hasCodeChanged);\n       }\n \n       // Check correctness of the changed-scopes-only traversal\n--- a/test/com/google/javascript/jscomp/PeepholeMinimizeConditionsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeMinimizeConditionsTest.java\n   public void minimizeCond(String input, String positive, String negative) {\n     Node inputNode = parseExpr(input);\n     MinimizedCondition result = PeepholeMinimizeConditions\n-        .MinimizedCondition.fromConditionNode(inputNode);\n+        .MinimizedCondition.fromConditionNode(inputNode.detachFromParent());\n     Node positiveNode = parseExpr(positive);\n     Node negativeNode = parseExpr(negative);\n-    if (!result.getNode().isEquivalentTo(positiveNode)) {\n-      fail(\"Not equal:\\n\" + result.getNode().toStringTree()\n+    // With counting the leading NOT node:\n+    Node positiveResult = result.getShorterRepresentation(true).node;\n+    // Without counting the leading NOT node:\n+    Node negativeResult = result.getShorterRepresentation(false).node;\n+    if (!positiveResult.isEquivalentTo(positiveNode)) {\n+      fail(\"Not equal:\\n\" + positiveResult.toStringTree()\n           + \"and:\\n\" + positiveNode.toStringTree());\n     }\n-    if (!result.getNegatedNode().isEquivalentTo(negativeNode)) {\n-      fail(\"Not equal:\\n\" + result.getNegatedNode().toStringTree()\n+    if (!negativeResult.isEquivalentTo(negativeNode)) {\n+      fail(\"Not equal:\\n\" + negativeResult.toStringTree()\n           + \"and:\\n\" + negativeNode.toStringTree());\n     }\n   }\n \n   public void testTryMinimizeCondition1() {\n-    minimizeCond(\"x\", \"x\", \"!x\");\n+    minimizeCond(\"x\", \"x\", \"x\");\n   }\n \n   public void testTryMinimizeCondition2() {\n-    minimizeCond(\"!x\", \"!x\", \"x\");\n+    minimizeCond(\"!x\", \"!x\", \"!x\");\n   }\n \n   public void testTryMinimizeCondition3() {\n-    minimizeCond(\"x || y\", \"x || y\", \"!x && !y\");\n+    minimizeCond(\"!(x || y)\", \"!x && !y\", \"!(x || y)\");\n   }\n \n   public void testTryMinimizeCondition4() {\n-    minimizeCond(\"x && y\", \"x && y\", \"!x || !y\");\n+    minimizeCond(\"!(x && y)\", \"!x || !y\", \"!(x && y)\");\n   }\n \n   public void testTryMinimizeCondition5() {\n-    minimizeCond(\"w && x && y && z\", \"w && x && y && z\", \"!(w && x && y && z)\");\n+    minimizeCond(\"!(x && y && z)\", \"!(x && y && z)\", \"!(x && y && z)\");\n   }\n \n   public void testMinimizeCondDemorgan() {\n     minimizeCond(\"x && (y===2 || !f()) && (y===3 || !h())\",\n         \"x && !((y!==2 && f()) || (y!==3 && h()))\",\n-        \"!x || (y!==2 && f()) || (y!==3 && h())\");\n+        \"!(!x || (y!==2 && f()) || (y!==3 && h()))\");\n   }\n \n   public void testMinimizeForCondition() {", "timestamp": 1370389603, "metainfo": ""}