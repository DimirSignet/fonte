{"sha": "16a9c4d210fea92c24ff05aa2d6767e3f5ceb362", "log": "Change @template to be a repeatable JSDoc tag.  R=nicksantos DELTA=67  (18 added, 6 deleted, 43 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4910   ", "commit": "\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n   private boolean isConstructor = false;\n   private boolean isInterface = false;\n   private Node parametersNode = null;\n-  private String templateTypeName = null;\n+  private ImmutableList<String> templateTypeNames = ImmutableList.of();\n \n   static final DiagnosticType EXTENDS_WITHOUT_TYPEDEF = DiagnosticType.warning(\n       \"JSC_EXTENDS_WITHOUT_TYPEDEF\",\n       returnTypeInferred = false;\n     }\n \n-    if (templateTypeName != null &&\n+    if (!templateTypeNames.isEmpty() &&\n         returnType != null &&\n         returnType.restrictByNotNullOrUndefined().isTemplateType()) {\n       reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n         parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n       }\n \n-      if (templateTypeName != null &&\n+      if (!templateTypeNames.isEmpty() &&\n           parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n         if (foundTemplateType) {\n           reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n       }\n     }\n \n-    if (templateTypeName != null && !foundTemplateType) {\n+    if (!templateTypeNames.isEmpty() && !foundTemplateType) {\n       reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n     }\n \n    */\n   FunctionTypeBuilder inferTemplateTypeName(@Nullable JSDocInfo info) {\n     if (info != null) {\n-      templateTypeName = info.getTemplateTypeName();\n-      typeRegistry.setTemplateTypeName(templateTypeName);\n+      templateTypeNames = info.getTemplateTypeNames();\n+      typeRegistry.setTemplateTypeNames(templateTypeNames);\n     }\n     return this;\n   }\n           .withParamsNode(parametersNode)\n           .withReturnType(returnType, returnTypeInferred)\n           .withTypeOfThis(thisType)\n-          .withTemplateName(templateTypeName)\n+          .withTemplateNames(templateTypeNames)\n           .build();\n       maybeSetBaseType(fnType);\n     }\n       fnType.setExtendedInterfaces(extendedInterfaces);\n     }\n \n-    typeRegistry.clearTemplateTypeName();\n+    typeRegistry.clearTemplateTypeNames();\n \n     return fnType;\n   }\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n   private void updateTypeOfThisOnClosure(Node n, FunctionType fnType) {\n     // TODO(user): Make the template logic more general.\n \n-    if (fnType.getTemplateTypeName() == null) {\n+    if (fnType.getTemplateTypeNames().isEmpty()) {\n       return;\n     }\n \n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n package com.google.javascript.jscomp.parsing;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.base.Splitter;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n \n                 case TEMPLATE:\n                   ExtractionInfo templateInfo = extractSingleLineBlock();\n-                  String templateTypeName = templateInfo.string;\n-\n-                  if (templateTypeName.length() == 0) {\n+                  List<String> names = Lists.newArrayList(\n+                      Splitter.on(',')\n+                          .trimResults()\n+                          .split(templateInfo.string));\n+\n+                  if (names.size() == 0 || names.get(0).length() == 0) {\n                     parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                           stream.getLineno(), stream.getCharno());\n-                  } else if (!jsdocBuilder.recordTemplateTypeName(\n-                      templateTypeName)) {\n+                  } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {\n                     parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                         stream.getLineno(), stream.getCharno());\n                   }\n--- a/src/com/google/javascript/rhino/JSDocInfo.java\n+++ b/src/com/google/javascript/rhino/JSDocInfo.java\n     List<JSTypeExpression> implementedInterfaces = null;\n     Map<String, JSTypeExpression> parameters = null;\n     List<JSTypeExpression> thrownTypes = null;\n-    String templateTypeName = null;\n+    ImmutableList<String> templateTypeNames = null;\n \n     // Other information\n     String description = null;\n    * Declares a template type name. Template type names are described using the\n    * {@code @template} annotation.\n    *\n-   * @param templateTypeName the template type name.\n-   */\n-  boolean declareTemplateTypeName(String templateTypeName) {\n+   * @param templateTypeNames the template type name.\n+   */\n+  boolean declareTemplateTypeNames(List<String> templateTypeNames) {\n     lazyInitInfo();\n \n-    if (info.templateTypeName != null) {\n+    if (info.templateTypeNames != null) {\n       return false;\n     }\n \n-    info.templateTypeName = templateTypeName;\n+    info.templateTypeNames = ImmutableList.copyOf(templateTypeNames);\n     return true;\n   }\n \n   }\n \n   /** Gets the template type name. */\n-  public String getTemplateTypeName() {\n-    if (info == null) {\n-      return null;\n-    }\n-    return info.templateTypeName;\n+  public ImmutableList<String> getTemplateTypeNames() {\n+    if (info == null || info.templateTypeNames == null) {\n+      return ImmutableList.of();\n+    }\n+    return info.templateTypeNames;\n   }\n \n   /**\n--- a/src/com/google/javascript/rhino/JSDocInfoBuilder.java\n+++ b/src/com/google/javascript/rhino/JSDocInfoBuilder.java\n package com.google.javascript.rhino;\n \n import com.google.javascript.rhino.JSDocInfo.Visibility;\n-import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.StaticSourceFile;\n \n+import java.util.List;\n import java.util.Set;\n \n /**\n    * @return {@code true} if the template type name was recorded and\n    *     {@code false} if a template type name was already defined.\n    */\n-  public boolean recordTemplateTypeName(String name) {\n-    if (currentInfo.declareTemplateTypeName(name)) {\n+  public boolean recordTemplateTypeNames(List<String> names) {\n+    if (currentInfo.declareTemplateTypeNames(names)) {\n       populated = true;\n       return true;\n     } else {\n--- a/src/com/google/javascript/rhino/jstype/FunctionBuilder.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionBuilder.java\n \n package com.google.javascript.rhino.jstype;\n \n+import com.google.common.collect.ImmutableList;\n import com.google.javascript.rhino.Node;\n \n /**\n   private Node parametersNode = null;\n   private JSType returnType = null;\n   private ObjectType typeOfThis = null;\n-  private String templateTypeName = null;\n+  private ImmutableList<String> templateTypeNames = ImmutableList.of();\n   private boolean inferredReturnType = false;\n   private boolean isConstructor = false;\n   private boolean isNativeType = false;\n   }\n \n   /** Set the template name. */\n-  public FunctionBuilder withTemplateName(String templateTypeName) {\n-    this.templateTypeName = templateTypeName;\n+  public FunctionBuilder withTemplateNames(\n+      ImmutableList<String> templateTypeNames) {\n+    this.templateTypeNames = templateTypeNames;\n     return this;\n   }\n \n     this.parametersNode = otherType.getParametersNode();\n     this.returnType = otherType.getReturnType();\n     this.typeOfThis = otherType.getTypeOfThis();\n-    this.templateTypeName = otherType.getTemplateTypeName();\n+    this.templateTypeNames = otherType.getTemplateTypeNames();\n     this.isConstructor = otherType.isConstructor();\n     this.isNativeType = otherType.isNativeObjectType();\n     return this;\n   public FunctionType build() {\n     return new FunctionType(registry, name, sourceNode,\n         new ArrowType(registry, parametersNode, returnType, inferredReturnType),\n-        typeOfThis, templateTypeName, isConstructor, isNativeType);\n+        typeOfThis, templateTypeNames, isConstructor, isNativeType);\n   }\n }\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n \n import static com.google.javascript.rhino.jstype.JSTypeNative.OBJECT_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE;\n+\n import com.google.common.base.Preconditions;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n   /**\n    * The template type name. May be {@code null}.\n    */\n-  private String templateTypeName;\n+  private final ImmutableList<String> templateTypeNames;\n \n   /** Creates an instance for a function that might be a constructor. */\n   FunctionType(JSTypeRegistry registry, String name, Node source,\n       ArrowType arrowType, ObjectType typeOfThis,\n-      String templateTypeName,  boolean isConstructor, boolean nativeType) {\n+      ImmutableList<String> templateTypeNames,\n+      boolean isConstructor, boolean nativeType) {\n     super(registry, name,\n         registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE),\n         nativeType);\n           registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE);\n     }\n     this.call = arrowType;\n-    this.templateTypeName = templateTypeName;\n+    this.templateTypeNames = templateTypeNames != null\n+        ? templateTypeNames : ImmutableList.<String>of();\n   }\n \n   /** Creates an instance for a function that is an interface. */\n     this.call = new ArrowType(registry, new Node(Token.PARAM_LIST), null);\n     this.kind = Kind.INTERFACE;\n     this.typeOfThis = new InstanceObjectType(registry, this);\n+    this.templateTypeNames = ImmutableList.of();\n   }\n \n   /** Creates an instance for a function that is an interface. */\n   /**\n    * Gets the template type name.\n    */\n-  public String getTemplateTypeName() {\n-    return templateTypeName;\n+  public ImmutableList<String> getTemplateTypeNames() {\n+    return templateTypeNames;\n   }\n \n   @Override\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n   private boolean lastGeneration = true;\n \n   // The template type name.\n-  private String templateTypeName;\n-\n-  // The template type.\n-  private TemplateType templateType;\n+  private Map<String, TemplateType> templateTypes = Maps.newHashMap();\n \n   private final boolean tolerateUndefinedValues;\n \n   public JSType getType(String jsTypeName) {\n     // TODO(user): Push every local type name out of namesToTypes so that\n     // NamedType#resolve is correct.\n-    if (jsTypeName.equals(templateTypeName)) {\n+    TemplateType templateType = templateTypes.get(jsTypeName);\n+    if (templateType != null) {\n       return templateType;\n     }\n     return namesToTypes.get(jsTypeName);\n   /**\n    * Sets the template type name.\n    */\n-  public void setTemplateTypeName(String name) {\n-    templateTypeName = name;\n-    templateType = new TemplateType(this, name);\n+  public void setTemplateTypeNames(List<String> names) {\n+    Preconditions.checkNotNull(names);\n+    for (String name : names) {\n+      templateTypes.put(name, new TemplateType(this, name));\n+    }\n   }\n \n   /**\n    * Clears the template type name.\n    */\n-  public void clearTemplateTypeName() {\n-    templateTypeName = null;\n-    templateType = null;\n+  public void clearTemplateTypeNames() {\n+    templateTypes.clear();\n   }\n }\n--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n   public void testParserWithTemplateDuplicated() {\n     parse(\"@template T\\n@template V */\",\n         \"Bad type annotation. @template tag at most once\");\n+  }\n+\n+  public void testParserWithTwoTemplates() {\n+    parse(\"@template T,V */\");\n   }\n \n   public void testWhitelistedNewAnnotations() {", "timestamp": 1338498642, "metainfo": ""}