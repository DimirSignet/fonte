{"sha": "6d00ac1a68612aade8a19d7ecc9b180f00ae5234", "log": "Change on 2010/05/27 by johnlenz          Cleanup some import, unused code, and javadoc warnings.          R=acleung         DELTA=167  (3 added, 119 deleted, 45 changed)  Change on 2010/05/27 by nicksantos          Use a new heuristic for CheckGlobalThis.         Fixes closure-compiler issue 144.         i *think* this is the right behavior, because it more closely         maps to how we infer \"this\" types in type-checking, but there         may be cases i haven't thought of.          R=johnlenz,acleung         DELTA=57  (51 added, 0 deleted, 6 changed)    Revision created by MOE tool push_codebase. MOE_MIGRATION=14003   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n    * exists.\n    *\n    * @param options The options to the Compiler.\n-   * @param path The path of the generated file for which the source map was\n-   *        created.\n    */\n   private void outputSourceMap(B options)\n       throws IOException {\n--- a/src/com/google/javascript/jscomp/CheckGlobalThis.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalThis.java\n  * Checks for certain uses of the {@code this} keyword that are considered\n  * unsafe because they are likely to reference the global {@code this} object\n  * unintentionally.\n- * \n+ *\n  * <p>A use of {@code this} is considered unsafe if it's on the left side of an\n- * assignment and not inside one of the following:\n+ * assignment or a property access, and not inside one of the following:\n  * <ol>\n  * <li>a prototype method\n  * <li>a function annotated with {@code @constructor}\n  * <li>a function annotated with {@code @this}.\n+ * <li>a function where there's no logical place to put a\n+ *     {@code this} annotation.\n  * </ol>\n  *\n  * <p>Note that this check does not track assignments of {@code this} to\n \n   private final AbstractCompiler compiler;\n   private final CheckLevel level;\n-\n+  \n   /**\n    * If {@code assignLhsChild != null}, then the node being traversed is\n    * a descendant of the first child of an ASSIGN node. assignLhsChild's\n    * is encountered, there is no reason to traverse non global contexts.\n    */\n   public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    \n+\n     if (n.getType() == Token.FUNCTION) {\n       // Don't traverse functions that are constructors or have the @this\n       // annotation.\n       if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n         return false;\n       }\n+\n+      // Don't traverse functions unless they would normally\n+      // be able to have a @this annotation associated with them. e.g.,\n+      // var a = function() { }; // or\n+      // function a() {} // or\n+      // a.x = function() {};\n+      int pType = parent.getType();\n+      if (!(pType == Token.BLOCK ||\n+            pType == Token.SCRIPT ||\n+            pType == Token.NAME ||\n+            pType == Token.ASSIGN)) {\n+        return false;\n+      }\n     }\n-    \n+\n     if (parent != null && parent.getType() == Token.ASSIGN) {\n       Node lhs = parent.getFirstChild();\n       Node rhs = lhs.getNext();\n         }\n       }\n     }\n-    \n+\n     return true;\n   }\n \n   public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (assignLhsChild != null && n.getType() == Token.THIS) {\n+    if (n.getType() == Token.THIS && shouldReportThis(n, parent)) {\n       compiler.report(t.makeError(n, level, GLOBAL_THIS));\n     }\n     if (n == assignLhsChild) {\n       assignLhsChild = null;\n     }\n+  }\n+\n+  private boolean shouldReportThis(Node n, Node parent) {\n+    if (assignLhsChild != null) {\n+      // Always report a THIS on the left side of an assign.\n+      return true;\n+    }\n+\n+    // Also report a THIS with a property access.\n+    return parent != null && NodeUtil.isGet(parent);\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/CodingConvention.java\n+++ b/src/com/google/javascript/jscomp/CodingConvention.java\n import com.google.javascript.rhino.jstype.ObjectType;\n \n import java.util.Collection;\n-import java.util.Collections;\n import java.util.List;\n \n /**\n--- a/src/com/google/javascript/jscomp/DefaultCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/DefaultCodingConvention.java\n  */\n package com.google.javascript.jscomp;\n \n-import com.google.javascript.jscomp.CodingConvention.AssertionFunctionSpec;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n--- a/src/com/google/javascript/jscomp/JSModuleGraph.java\n+++ b/src/com/google/javascript/jscomp/JSModuleGraph.java\n    * a symbol that is not required until a later module, then that\n    * file will be moved to the later module.\n    *\n-   * @param The original list of sources. Used to ensure that the sort\n+   * @param inputs The original list of sources. Used to ensure that the sort\n    *     is stable.\n    * @return The sorted list of sources.\n    */\n--- a/src/com/google/javascript/jscomp/JsMessageExtractor.java\n+++ b/src/com/google/javascript/jscomp/JsMessageExtractor.java\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n-import com.google.common.collect.Sets;\n import com.google.javascript.rhino.Node;\n \n import java.io.IOException;\n--- a/src/com/google/javascript/jscomp/LinkedFlowScope.java\n+++ b/src/com/google/javascript/jscomp/LinkedFlowScope.java\n     return cache.getSlot(name);\n   }\n \n-  /** @inheritDoc */\n   @Override\n   public StaticSlot<JSType> getOwnSlot(String name) {\n     throw new UnsupportedOperationException();\n--- a/src/com/google/javascript/jscomp/SanityCheck.java\n+++ b/src/com/google/javascript/jscomp/SanityCheck.java\n \n import com.google.common.base.Preconditions;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n \n /**\n  * A compiler pass that verifies the structure of the AST conforms\n--- a/src/com/google/javascript/jscomp/SourceFile.java\n+++ b/src/com/google/javascript/jscomp/SourceFile.java\n     /**\n      * Gets a reader for the code in this source file.\n      */\n+    @Override\n     public Reader getCodeReader() throws IOException {\n       if (hasSourceInMemory()) {\n         return super.getCodeReader();\n--- a/src/com/google/javascript/jscomp/Tracer.java\n+++ b/src/com/google/javascript/jscomp/Tracer.java\n   static final int MAX_TRACE_SIZE = 1000;\n \n   /**\n-   * For unit testing. Can't use {@link com.google.common.time} because\n+   * For unit testing. Can't use {@link com.google.common.time.Clock} because\n    * this code is in base and has minimal dependencies.\n    */\n   static interface InternalClock {\n--- a/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n   }\n \n   /**\n-   * @param node A node for a function for which to generate a type annotation\n+   * @param fnNode A node for a function for which to generate a type annotation\n    */\n   private String getFunctionAnnotation(Node fnNode) {\n     Preconditions.checkState(fnNode.getType() == Token.FUNCTION);\n--- a/src/com/google/javascript/jscomp/deps/DependencyInfo.java\n+++ b/src/com/google/javascript/jscomp/deps/DependencyInfo.java\n package com.google.javascript.jscomp.deps;\n \n import java.util.Collection;\n-import java.util.Collections;\n-import java.util.List;\n \n /**\n  * A data structure for JS dependency information for a single .js file.\n--- a/src/com/google/javascript/jscomp/deps/DepsFileParser.java\n+++ b/src/com/google/javascript/jscomp/deps/DepsFileParser.java\n package com.google.javascript.jscomp.deps;\n \n import com.google.common.base.CharMatcher;\n-import com.google.common.base.Charsets;\n import com.google.common.collect.Lists;\n-import com.google.common.io.Files;\n import com.google.javascript.jscomp.ErrorManager;\n \n-import java.io.File;\n import java.io.FileReader;\n import java.io.IOException;\n import java.io.Reader;\n--- a/src/com/google/javascript/jscomp/deps/JsFileLineParser.java\n+++ b/src/com/google/javascript/jscomp/deps/JsFileLineParser.java\n import java.io.BufferedReader;\n import java.io.IOException;\n import java.io.Reader;\n-import java.io.StringReader;\n import java.util.List;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n--- a/src/com/google/javascript/jscomp/deps/JsFileParser.java\n+++ b/src/com/google/javascript/jscomp/deps/JsFileParser.java\n package com.google.javascript.jscomp.deps;\n \n import com.google.common.base.CharMatcher;\n-import com.google.common.base.Charsets;\n import com.google.common.collect.Lists;\n-import com.google.common.io.Files;\n import com.google.javascript.jscomp.ErrorManager;\n \n-import java.io.BufferedReader;\n-import java.io.File;\n import java.io.FileReader;\n import java.io.IOException;\n import java.io.Reader;\n--- a/src/com/google/javascript/jscomp/deps/SimpleDependencyInfo.java\n+++ b/src/com/google/javascript/jscomp/deps/SimpleDependencyInfo.java\n package com.google.javascript.jscomp.deps;\n \n import com.google.common.base.Objects;\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.Lists;\n \n import java.util.Collection;\n import java.util.Collections;\n--- a/src/com/google/javascript/jscomp/deps/SortedDependencies.java\n+++ b/src/com/google/javascript/jscomp/deps/SortedDependencies.java\n import java.util.Map;\n import java.util.PriorityQueue;\n import java.util.Set;\n-import java.util.SortedSet;\n-import java.util.TreeSet;\n \n /**\n  * A sorted list of inputs with dependency information. Uses a stable\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n       this.string = string;\n       this.token = token;\n     }\n-\n-    public String getString() {\n-      return string;\n-    }\n-\n-    public JsDocToken getToken() {\n-      return token;\n-    }\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/parsing/ParserRunner.java\n+++ b/src/com/google/javascript/jscomp/parsing/ParserRunner.java\n import com.google.javascript.jscomp.mozilla.rhino.Parser;\n import com.google.javascript.jscomp.mozilla.rhino.ast.AstRoot;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.jstype.JSTypeRegistry;\n \n import java.io.IOException;\n import java.util.ResourceBundle;\n--- a/src/com/google/javascript/rhino/jstype/FunctionPrototypeType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionPrototypeType.java\n \n package com.google.javascript.rhino.jstype;\n \n-import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.jstype.ObjectType;\n-\n-import java.util.List;\n-import java.util.Set;\n \n /**\n  * Represents the prototype of a {@link FunctionType}.\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n \n import static com.google.javascript.rhino.jstype.JSTypeNative.U2U_CONSTRUCTOR_TYPE;\n \n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.base.Objects;\n import com.google.common.base.Preconditions;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterables;\n     return super.resolveInternal(t, scope);\n   }\n \n-  // A helper method for creating arrow types.\n-  private ArrowType createArrowType(Node parameters, JSType returnType) {\n-    return registry.createArrowType(parameters, returnType);\n-  }\n-\n   @Override\n   public String toDebugHashCodeString() {\n     if (this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) {\n--- a/src/com/google/javascript/rhino/jstype/InstanceObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/InstanceObjectType.java\n \n \n import com.google.common.base.Preconditions;\n-import com.google.javascript.rhino.ErrorReporter;\n-\n-import java.util.List;\n-import java.util.Set;\n \n /**\n  * An object type that is an instance of some function constructor.\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n \n   /**\n    * The type registry has three modes, which control how type ASTs are\n-   * converted to types in {@link @createFromTypeNodes}.\n+   * converted to types in {@link #createFromTypeNodes}.\n    */\n   public static enum ResolveMode {\n     /**\n--- a/src/com/google/javascript/rhino/jstype/NamedType.java\n+++ b/src/com/google/javascript/rhino/jstype/NamedType.java\n     this.charno = charno;\n   }\n \n+  @Override\n   void forgiveUnknownNames() {\n     forgiving = true;\n   }\n--- a/src/com/google/javascript/rhino/jstype/ObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ObjectType.java\n import static com.google.javascript.rhino.jstype.TernaryValue.FALSE;\n import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN;\n \n-import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Sets;\n import com.google.javascript.rhino.JSDocInfo;\n \n import java.util.HashSet;\n-import java.util.List;\n import java.util.Set;\n \n /**\n--- a/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.JSDocInfo;\n \n-import java.util.List;\n import java.util.Set;\n \n /**\n--- a/src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java\n+++ b/src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java\n package com.google.javascript.rhino.jstype;\n \n import com.google.common.collect.ImmutableMap;\n-import com.google.common.collect.Maps;\n-\n-import java.util.Map;\n \n /**\n  * A builder for record types.\n--- a/src/com/google/javascript/rhino/jstype/UnresolvedTypeExpression.java\n+++ b/src/com/google/javascript/rhino/jstype/UnresolvedTypeExpression.java\n \n import com.google.common.base.Preconditions;\n import com.google.javascript.rhino.ErrorReporter;\n-import com.google.javascript.rhino.JSTypeExpression;\n import com.google.javascript.rhino.Node;\n \n /**\n--- a/test/com/google/javascript/jscomp/CheckGlobalThisTest.java\n+++ b/test/com/google/javascript/jscomp/CheckGlobalThisTest.java\n   private void testFailure(String js) {\n     test(js, null, CheckGlobalThis.GLOBAL_THIS);\n   }\n-  \n+\n   public void testGlobalThis1() throws Exception {\n     testSame(\"var a = this;\");\n   }\n   public void testGlobalThis4() {\n     testFailure(\"this['foo'] = 5;\");\n   }\n-  \n+\n   public void testGlobalThis5() {\n     testFailure(\"(a = this).foo = 4;\");\n   }\n-  \n+\n   public void testGlobalThis6() {\n     testSame(\"a = this;\");\n+  }\n+\n+  public void testGlobalThis7() {\n+    testFailure(\"var a = this.foo;\");\n   }\n \n   public void testStaticFunction1() {\n   }\n \n   public void testStaticFunction6() {\n-    testFailure(\"function a() { return function() { this = 8; } }\");\n+    testSame(\"function a() { return function() { this = 8; } }\");\n   }\n \n   public void testStaticFunction7() {\n-    testFailure(\"var a = function() { return function() { this = 8; } }\");\n+    testSame(\"var a = function() { return function() { this = 8; } }\");\n+  }\n+\n+  public void testStaticFunction8() {\n+    testFailure(\"var a = function() { return this.foo; };\");\n   }\n \n   public void testConstructor1() {\n   }\n \n   public void testStaticMethod2() {\n-    testFailure(\"a.b = function() { return function() { this.m2 = 5; } }\");\n+    testSame(\"a.b = function() { return function() { this.m2 = 5; } }\");\n   }\n \n   public void testStaticMethod3() {\n-    testFailure(\"a.b.c = function() { return function() { this.m2 = 5; } }\");\n+    testSame(\"a.b.c = function() { return function() { this.m2 = 5; } }\");\n   }\n \n   public void testMethodInStaticFunction() {\n         \"    function myself() {\" +\n         \"      function andI() { this.m2 = 5; } } } }\");\n   }\n+\n+  public void testInnerFunction1() {\n+    testFailure(\"function f() { function g() { return this.x; } }\");\n+  }\n+\n+  public void testInnerFunction2() {\n+    testFailure(\"function f() { var g = function() { return this.x; } }\");\n+  }\n+\n+  public void testInnerFunction3() {\n+    testFailure(\n+        \"function f() { var x = {}; x.y = function() { return this.x; } }\");\n+  }\n+\n+  public void testInnerFunction4() {\n+    testSame(\n+        \"function f() { var x = {}; x.y(function() { return this.x; }); }\");\n+  }\n }\n--- a/test/com/google/javascript/jscomp/CompilerTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.CodeChangeHandler.RecentChange;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.testing.BaseJSTypeTestCase;\n \n import junit.framework.TestCase;\n--- a/test/com/google/javascript/jscomp/ConcreteTypeTest.java\n+++ b/test/com/google/javascript/jscomp/ConcreteTypeTest.java\n       return registry;\n     }\n \n-    /** @inheritDoc */\n+    /** {@inheritDoc} */\n     public ConcreteFunctionType createConcreteFunction(\n         Node decl, StaticScope<ConcreteType> parent) {\n       ConcreteFunctionType funcType = functionByDeclaration.get(decl);\n       return funcType;\n     }\n \n-    /** @inheritDoc */\n+    /** {@inheritDoc} */\n     public ConcreteInstanceType createConcreteInstance(\n         ObjectType instanceType) {\n       ConcreteInstanceType instType = instanceByJSType.get(instanceType);\n       return instType;\n     }\n \n-    /** @inheritDoc */\n+    /** {@inheritDoc} */\n     public ConcreteFunctionType getConcreteFunction(FunctionType functionType) {\n       return functionByJSType.get(functionType);\n     }\n \n-    /** @inheritDoc */\n+    /** {@inheritDoc} */\n     public ConcreteInstanceType getConcreteInstance(ObjectType instanceType) {\n       return instanceByJSType.get(instanceType);\n     }\n \n-    /** @inheritDoc */\n+    /** {@inheritDoc} */\n     public StaticScope<ConcreteType> createFunctionScope(\n         Node decl, StaticScope<ConcreteType> parent) {\n       FakeScope scope = new FakeScope((FakeScope) parent);\n       return scope;\n     }\n \n-    /** @inheritDoc */\n+    /** {@inheritDoc} */\n     public StaticScope<ConcreteType> createInstanceScope(\n         ObjectType instanceType) {\n       FakeScope parentScope = null;\n       this.parent = parent;\n     }\n \n-    /** @inheritDoc */\n+    /** {@inheritDoc} */\n     public StaticScope<ConcreteType> getParentScope() { return parent; }\n \n-    /** @inheritDoc */\n+    /** {@inheritDoc} */\n     public StaticSlot<ConcreteType> getOwnSlot(String name) {\n       return slots.get(name);\n     }\n \n-    /** @inheritDoc */\n+    /** {@inheritDoc} */\n     public StaticSlot<ConcreteType> getSlot(String name) {\n       if (slots.containsKey(name)) {\n         return slots.get(name);\n       }\n     }\n \n-    /** @inheritDoc */\n+    /** {@inheritDoc} */\n     public ConcreteType getTypeOfThis() { return ConcreteType.ALL; }\n \n     void addSlot(String name) {\n       this.name = name;\n     }\n \n-    /* @inheritDoc */\n+    /* {@inheritDoc} */\n     public String getName() { return name; }\n \n-    /* @inheritDoc */\n+    /* {@inheritDoc} */\n     public ConcreteType getType() { return ConcreteType.ALL; }\n \n-    /* @inheritDoc */\n+    /* {@inheritDoc} */\n     public boolean isTypeInferred() { return true; }\n   }\n }\n--- a/test/com/google/javascript/jscomp/DataFlowAnalysisTest.java\n+++ b/test/com/google/javascript/jscomp/DataFlowAnalysisTest.java\n      * Constructor.\n      *\n      * @param isTop To define if the lattice is top.\n-     * @param constMap A map from name to constant variable.\n-     */\n-    ConstPropLatticeElement(\n-        boolean isTop, Map<Variable, Integer> constMap) {\n-      this.isTop = isTop;\n-      this.constMap = constMap;\n-    }\n-\n+     */\n     ConstPropLatticeElement(boolean isTop) {\n       this.isTop = isTop;\n       this.constMap = Maps.newHashMap();\n--- a/test/com/google/javascript/jscomp/InferJSDocInfoTest.java\n+++ b/test/com/google/javascript/jscomp/InferJSDocInfoTest.java\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n-import com.google.javascript.rhino.jstype.JSTypeNative;\n-import com.google.javascript.rhino.jstype.JSTypeRegistry;\n import com.google.javascript.rhino.jstype.ObjectType;\n \n import java.util.Deque;\n // assertions about type information.\n public class InferJSDocInfoTest extends CompilerTestCase {\n \n-  private JSTypeRegistry registry;\n   private Scope globalScope;\n \n   @Override\n \n   @Override\n   public CompilerPass getProcessor(final Compiler compiler) {\n-    registry = compiler.getTypeRegistry();\n     return new CompilerPass() {\n       public void process(Node externs, Node root) {\n         ScopeCreator scopeCreator =\n     }\n     return null;\n   }\n-\n-  private JSType getNativeType(JSTypeNative type) {\n-    return registry.getNativeType(type);\n-  }\n-\n-  private ObjectType getNativeObjectType(JSTypeNative type) {\n-    return (ObjectType) registry.getNativeType(type);\n-  }\n }\n--- a/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n \n package com.google.javascript.rhino.jstype;\n \n-import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.testing.BaseJSTypeTestCase;\n \n \n--- a/test/com/google/javascript/rhino/jstype/JSTypeRegistryTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeRegistryTest.java\n import com.google.javascript.rhino.testing.Asserts;\n \n import junit.framework.TestCase;\n-\n \n /**\n  * Tests {@link JSTypeRegistry}.\n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n   }\n \n   /**\n-   * Tests {@link JSTypeRegistry#getGreatestSubtypeWithProperty(JSType)}.\n+   * Tests\n+   * {@link JSTypeRegistry#getGreatestSubtypeWithProperty(JSType, String)}.\n    */\n   public void testGreatestSubtypeWithProperty() {\n     ObjectType foo = registry.createObjectType(\"foo\", null, OBJECT_TYPE);\n     return registry.createArrowType(params);\n   }\n \n-  private ArrowType createArrowType(Node params, JSType retType) {\n-    return registry.createArrowType(params, retType);\n-  }\n-\n   private void assertTypeEquals(JSType a, JSType b) {\n     Asserts.assertTypeEquals(a, b);\n   }", "timestamp": 1275023910, "metainfo": ""}