{"sha": "7e9b8336568ea7f05c33e1b58eb67fa6d4eee756", "log": "Support chrome-team's style of defining prototypes. Fixes issue 537  R=acleung DELTA=149  (127 added, 19 deleted, 3 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3173   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n       String propName = n.getLastChild().getString();\n       Preconditions.checkArgument(qName != null && ownerName != null);\n \n-      // Function prototypes are special.\n-      // It's a common JS idiom to do:\n-      // F.prototype = { ... };\n-      // So if F does not have an explicitly declared super type,\n-      // allow F.prototype to be redefined arbitrarily.\n-      if (\"prototype\".equals(propName)) {\n-        Var qVar = scope.getVar(qName);\n-        if (qVar != null) {\n-          if (!qVar.isTypeInferred()) {\n-            // Just ignore assigns to declared prototypes.\n-            return;\n-          }\n-          if (qVar.getScope() == scope) {\n-            scope.undeclare(qVar);\n-          }\n-        }\n-      }\n-\n       // Precedence of type information on GETPROPs:\n       // 1) @type annnotation / @enum annotation\n       // 2) ASSIGN to FUNCTION literal\n       if (valueType == null && rhsValue != null) {\n         // Determining type for #5\n         valueType = rhsValue.getJSType();\n+      }\n+      // Function prototypes are special.\n+      // It's a common JS idiom to do:\n+      // F.prototype = { ... };\n+      // So if F does not have an explicitly declared super type,\n+      // allow F.prototype to be redefined arbitrarily.\n+      if (\"prototype\".equals(propName)) {\n+        Var qVar = scope.getVar(qName);\n+        if (qVar != null) {\n+          // If the programmer has declared that F inherits from Super,\n+          // and they assign F.prototype to an object literal,\n+          // then they are responsible for making sure that the object literal's\n+          // implicit prototype is set up appropriately. We just obey\n+          // the @extends tag.\n+          ObjectType qVarType = ObjectType.cast(qVar.getType());\n+          if (qVarType != null &&\n+              rhsValue != null &&\n+              rhsValue.getType() == Token.OBJECTLIT) {\n+            typeRegistry.resetImplicitPrototype(\n+                rhsValue.getJSType(), qVarType.getImplicitPrototype());\n+          } else if (!qVar.isTypeInferred()) {\n+            // If the programmer has declared that F inherits from Super,\n+            // and they assign F.prototype to some arbitrary expression,\n+            // there's not much we can do. We just ignore the expression,\n+            // and hope they've annotated their code in a way to tell us\n+            // what props are going to be on that prototype.\n+            return;\n+          }\n+          if (qVar.getScope() == scope) {\n+            scope.undeclare(qVar);\n+          }\n+        }\n       }\n \n       if (valueType == null) {\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n     //\n     // In the second case, we just use the anonymous object as the prototype.\n     if (baseType.hasReferenceName() ||\n-        baseType.isUnknownType() ||\n         isNativeObjectType() ||\n         baseType.isFunctionPrototypeType() ||\n         !(baseType instanceof PrototypeObjectType)) {\n       return false;\n     }\n \n-    boolean replacedPrototype = prototype != null;\n+    PrototypeObjectType oldPrototype = this.prototype;\n+    boolean replacedPrototype = oldPrototype != null;\n+\n     this.prototype = prototype;\n     this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n     this.prototype.setOwnerFunction(this);\n+\n+    if (oldPrototype != null) {\n+      // Disassociating the old prototype makes this easier to debug--\n+      // we don't have to worry about two prototypes running around.\n+      oldPrototype.setOwnerFunction(null);\n+    }\n \n     if (isConstructor() || isInterface()) {\n       FunctionType superClass = getSuperClassConstructor();\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n   }\n \n   /**\n+   * Set the implicit prototype if it's possible to do so.\n+   * @return True if we were able to set the implicit prototype successfully,\n+   *     false if it was not possible to do so for some reason. There are\n+   *     a few different reasons why this could fail: for example, numbers\n+   *     can't be implicit prototypes, and we don't want to change the implicit\n+   *     prototype if other classes have already subclassed this one.\n+   */\n+  public boolean resetImplicitPrototype(\n+      JSType type, ObjectType newImplicitProto) {\n+    if (type instanceof PrototypeObjectType) {\n+      PrototypeObjectType poType = (PrototypeObjectType) type;\n+      if (!poType.hasCachedValues()) {\n+        poType.setImplicitPrototype(newImplicitProto);\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n    * Create an anonymous object type for a native type.\n    */\n   ObjectType createNativeAnonymousObjectType() {\n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n   }\n \n   void setOwnerFunction(FunctionType type) {\n-    Preconditions.checkState(ownerFunction == null);\n+    Preconditions.checkState(ownerFunction == null || type == null);\n     ownerFunction = type;\n   }\n \n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"actual parameter 1 of g does not match formal parameter\\n\" +\n         \"found   : Array\\n\" +\n         \"required: number\");\n+  }\n+\n+  public void testIssue537a() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"Foo.prototype = {method: function() {}};\" +\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @extends {Foo}\\n\" +\n+        \" */\\n\" +\n+        \"function Bar() {\" +\n+        \"  Foo.call(this);\" +\n+        \"  if (this.baz()) this.method(1);\" +\n+        \"}\" +\n+        \"Bar.prototype = {\" +\n+        \"  baz: function() {\" +\n+        \"    return true;\" +\n+        \"  }\" +\n+        \"};\" +\n+        \"Bar.prototype.__proto__ = Foo.prototype;\",\n+        \"Function Foo.prototype.method: called with 1 argument(s). \" +\n+        \"Function requires at least 0 argument(s) \" +\n+        \"and no more than 0 argument(s).\");\n+  }\n+\n+  public void testIssue537b() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"Foo.prototype = {method: function() {}};\" +\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @extends {Foo}\\n\" +\n+        \" */\\n\" +\n+        \"function Bar() {\" +\n+        \"  Foo.call(this);\" +\n+        \"  if (this.baz(1)) this.method();\" +\n+        \"}\" +\n+        \"Bar.prototype = {\" +\n+        \"  baz: function() {\" +\n+        \"    return true;\" +\n+        \"  }\" +\n+        \"};\" +\n+        \"Bar.prototype.__proto__ = Foo.prototype;\",\n+        \"Function Bar.prototype.baz: called with 1 argument(s). \" +\n+        \"Function requires at least 0 argument(s) \" +\n+        \"and no more than 0 argument(s).\");\n+  }\n+\n+  public void testIssue537c() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @extends {Foo}\\n\" +\n+        \" */\\n\" +\n+        \"function Bar() {\" +\n+        \"  Foo.call(this);\" +\n+        \"  if (this.baz2()) alert(1);\" +\n+        \"}\" +\n+        \"Bar.prototype = {\" +\n+        \"  baz: function() {\" +\n+        \"    return true;\" +\n+        \"  }\" +\n+        \"};\" +\n+        \"Bar.prototype.__proto__ = Foo.prototype;\",\n+        \"Property baz2 never defined on Bar\");\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n         RhinoErrorReporter.TYPE_PARSE_ERROR);\n     ObjectType x = (ObjectType) findNameType(\"x\", globalScope);\n     assertEquals(\"Foo\", x.toString());\n+    assertEquals(\"Foo.prototype\", x.getImplicitPrototype().toString());\n     assertTrue(x.getImplicitPrototype().hasOwnProperty(\"bar\"));\n-    assertEquals(\"number\", x.getPropertyType(\"bar\").toString());\n+    assertEquals(\"?\", x.getPropertyType(\"bar\").toString());\n     assertTrue(x.isPropertyTypeInferred(\"bar\"));\n   }\n ", "timestamp": 1314844259, "metainfo": ""}