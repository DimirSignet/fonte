{"sha": "e646ff31da3e0fce713c24415360ce754db33a37", "log": "Introduce the concept of a source map \"concat\", to model source files be concat'd together.  R=acleung DELTA=185  (165 added, 7 deleted, 13 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1959   ", "commit": "\n--- a/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java\n+++ b/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java\n import org.json.JSONObject;\n \n import java.util.ArrayList;\n-import java.util.List;\n \n /**\n  * Class for parsing version 3 of the SourceMap format, as produced by the\n   private String[] names;\n   private int lineCount;\n   // Slots in the lines list will be null if the line does not have any entries.\n-  private List<ArrayList<Entry>> lines = null;\n+  private ArrayList<ArrayList<Entry>> lines = null;\n \n   public SourceMapConsumerV3() {\n \n       return name;\n     }\n   }\n+\n+  static interface EntryVisitor {\n+    void visit(String sourceName,\n+               String symbolName,\n+               FilePosition sourceStartPosition,\n+               FilePosition startPosition,\n+               FilePosition endPosition);\n+  }\n+\n+  public void visitMappings(EntryVisitor visitor) {\n+    boolean pending = false;\n+    String sourceName = null;\n+    String symbolName = null;\n+    FilePosition sourceStartPosition = null;\n+    FilePosition startPosition = null;\n+\n+    final int lineCount = lines.size();\n+    for (int i = 0; i < lineCount; i++) {\n+      ArrayList<Entry> line = lines.get(i);\n+      if (line != null) {\n+        final int entryCount = line.size();\n+        for (int j = 0; j < entryCount; j++) {\n+          Entry entry = line.get(j);\n+          if (pending) {\n+            FilePosition endPosition = new FilePosition(\n+                i, entry.getGeneratedColumn());\n+            visitor.visit(\n+                sourceName,\n+                symbolName,\n+                sourceStartPosition,\n+                startPosition,\n+                endPosition);\n+            pending = false;\n+          }\n+\n+          if (entry.getSourceFileId() != UNMAPPED) {\n+            pending = true;\n+            sourceName = sources[entry.getSourceFileId()];\n+            symbolName = (entry.getNameId() != UNMAPPED)\n+                ? names[entry.getNameId()] : null;\n+            sourceStartPosition = new FilePosition(\n+                entry.getSourceLine(), entry.getSourceColumn());\n+            startPosition = new FilePosition(\n+                i, entry.getGeneratedColumn());\n+          }\n+        }\n+      }\n+    }\n+  }\n }\n--- a/src/com/google/debugging/sourcemap/SourceMapGeneratorV3.java\n+++ b/src/com/google/debugging/sourcemap/SourceMapGeneratorV3.java\n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n+import com.google.debugging.sourcemap.SourceMapConsumerV3.EntryVisitor;\n \n import java.io.IOException;\n import java.util.ArrayDeque;\n \n     lastMapping = mapping;\n     mappings.add(mapping);\n+  }\n+\n+  class ConsumerEntryVisitor implements EntryVisitor {\n+\n+    @Override\n+    public void visit(\n+        String sourceName, String symbolName,\n+        FilePosition sourceStartPosition,\n+        FilePosition startPosition, FilePosition endPosition) {\n+      addMapping(sourceName, symbolName,\n+          sourceStartPosition, startPosition, endPosition);\n+    }\n+  }\n+\n+  public void mergeMapSection(int line, int column, String mapSectionContents)\n+      throws SourceMapParseException {\n+     setStartingPosition(line, column);\n+     SourceMapConsumerV3 section = new SourceMapConsumerV3();\n+     section.parse(mapSectionContents);\n+     section.visitMappings(new ConsumerEntryVisitor());\n   }\n \n   /**\n--- a/test/com/google/debugging/sourcemap/SourceMapGeneratorV3Test.java\n+++ b/test/com/google/debugging/sourcemap/SourceMapGeneratorV3Test.java\n \n package com.google.debugging.sourcemap;\n \n+import com.google.common.collect.Maps;\n import com.google.javascript.jscomp.SourceMap;\n import com.google.javascript.jscomp.SourceMap.Format;\n+\n+import java.io.IOException;\n+import java.util.LinkedHashMap;\n \n \n /**\n     assertEquals(files1, files2);\n   }\n \n+  public void testSourceMapMerging() throws Exception {\n+    final String INPUT1 = \"file1\";\n+    final String INPUT2 = \"file2\";\n+    LinkedHashMap<String, String> inputs = Maps.newLinkedHashMap();\n+    inputs.put(INPUT1, \"var __FOO__ = 1;\");\n+    inputs.put(INPUT2, \"var __BAR__ = 2;\");\n+    RunResult result1 = compile(inputs.get(INPUT1), INPUT1);\n+    RunResult result2 = compile(inputs.get(INPUT2), INPUT2);\n+\n+    StringBuilder output = new StringBuilder();\n+    FilePosition offset = appendAndCount(output, result1.generatedSource);\n+    output.append(result2.generatedSource);\n+\n+    SourceMapGeneratorV3 generator = new SourceMapGeneratorV3();\n+\n+    generator.mergeMapSection(0, 0, result1.sourceMapFileContent);\n+    generator.mergeMapSection(offset.getLine(), offset.getColumn(),\n+        result2.sourceMapFileContent);\n+\n+    StringBuilder mapContents = new StringBuilder();\n+    generator.appendTo(mapContents, \"out.js\");\n+\n+    check(inputs, output.toString(), mapContents.toString());\n+  }\n+\n+  FilePosition appendAndCount(Appendable out, String js) throws IOException {\n+    int line = 0, column = 0;\n+    for (int i = 0; i < js.length(); i++) {\n+      if (js.charAt(i) == '\\n') {\n+        line++;\n+        column = 0;\n+      } else {\n+        column++;\n+      }\n+    }\n+    out.append(js);\n+    return new FilePosition(line, column);\n+  }\n \n }\n--- a/test/com/google/debugging/sourcemap/SourceMapTestCase.java\n+++ b/test/com/google/debugging/sourcemap/SourceMapTestCase.java\n import junit.framework.TestCase;\n \n import java.io.IOException;\n+import java.util.LinkedHashMap;\n import java.util.Map;\n+import java.util.Map.Entry;\n \n /**\n  * @author johnlenz@google.com (John Lenz)\n     }\n \n   protected static class Token {\n-      String tokenName;\n-      FilePosition position;\n+      final String tokenName;\n+      final String inputName;\n+      final FilePosition position;\n+      Token(String tokenName, String inputName, FilePosition position) {\n+        this.tokenName = tokenName;\n+        this.inputName = inputName;\n+        this.position = position;\n+      }\n     }\n \n   @Override\n    * Finds the all the __XX__ tokens in the given Javascript\n    * string.\n    */\n-  private Map<String, Token> findTokens(String js) {\n+  private Map<String, Token> findTokens(Map<String, String> inputs) {\n     Map<String, Token> tokens = Maps.newLinkedHashMap();\n+\n+    for (Entry<String, String> entry : inputs.entrySet()) {\n+      findTokens(tokens, entry.getKey(), entry.getValue());\n+    }\n+\n+    return tokens;\n+  }\n+\n+  /**\n+   * Finds the all the __XX__ tokens in the given Javascript\n+   * string.\n+   */\n+  private Map<String, Token> findTokens(String src) {\n+    Map<String, Token> tokens = Maps.newLinkedHashMap();\n+\n+    findTokens(tokens, \"\", src);\n+\n+    return tokens;\n+  }\n+\n+  /**\n+   * Finds the all the __XX__ tokens in the given Javascript\n+   * string.\n+   */\n+  private Map<String, Token> findTokens(\n+    Map<String, Token> tokens, String inputName, String js) {\n \n     int currentLine = 0;\n     int positionOffset = 0;\n         }\n \n         if (tokenName.length() > 0) {\n-          Token token = new Token();\n-          token.tokenName = tokenName;\n           int currentPosition = i - positionOffset;\n-          token.position = new FilePosition(currentLine, currentPosition);\n+          Token token = new Token(\n+              tokenName, inputName,\n+              new FilePosition(currentLine, currentPosition));\n           tokens.put(tokenName, token);\n         }\n \n   abstract SourceMapConsumer getSourceMapConsumer();\n \n   protected void compileAndCheck(String js) {\n-    RunResult result = compile(js);\n-\n+    String inputName = \"testcode\";\n+    RunResult result = compile(js, inputName);\n+    check(inputName, js, result.generatedSource, result.sourceMapFileContent);\n+  }\n+\n+  protected void check(\n+      String inputName, String input, String output,\n+      String sourceMapFileContent) {\n+    Map<String, String> inputMap = new LinkedHashMap<String,String>();\n+    inputMap.put(inputName, input);\n+    check(inputMap, output, sourceMapFileContent);\n+  }\n+\n+  protected void check(\n+      Map<String,String> originalInputs, String generatedSource,\n+      String sourceMapFileContent) {\n     // Find all instances of the __XXX__ pattern in the original\n     // source code.\n-    Map<String, Token> originalTokens = findTokens(js);\n+    Map<String, Token> originalTokens = findTokens(originalInputs);\n \n     // Find all instances of the __XXX__ pattern in the generated\n     // source code.\n-    Map<String, Token> resultTokens = findTokens(result.generatedSource);\n+    Map<String, Token> resultTokens = findTokens(generatedSource);\n \n     // Ensure that the generated instances match via the source map\n     // to the original source code.\n \n     SourceMapConsumer reader = getSourceMapConsumer();\n     try {\n-      reader.parse(result.sourceMapFileContent);\n+      reader.parse(sourceMapFileContent);\n     } catch (SourceMapParseException e) {\n       throw new RuntimeException(\"unexpected exception\", e);\n     }\n       // Find the associated token in the input source.\n       Token inputToken = originalTokens.get(token.tokenName);\n       assertNotNull(inputToken);\n+      assertEquals(mapping.getOriginalFile(), inputToken.inputName);\n \n       // Ensure that the map correctly points to the token (we add 1\n       // to normalize versus the Rhino line number indexing scheme).\n     }\n   }\n \n-  private RunResult compile(String js) {\n-    return compile(js, \"testcode\");\n-  }\n-\n-  private RunResult compile(String js, String fileName) {\n+  protected RunResult compile(String js, String fileName) {\n     return compile(js, fileName, null, null);\n   }\n ", "timestamp": 1305841038, "metainfo": ""}