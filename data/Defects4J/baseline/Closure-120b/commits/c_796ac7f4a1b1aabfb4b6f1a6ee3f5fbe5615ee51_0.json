{"sha": "796ac7f4a1b1aabfb4b6f1a6ee3f5fbe5615ee51", "log": "Refactor StatementFusion to allow fusing of arbitrary statements with comma's. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=44623872", "commit": "\n--- a/src/com/google/javascript/jscomp/StatementFusion.java\n+++ b/src/com/google/javascript/jscomp/StatementFusion.java\n \n   @Override\n   Node optimizeSubtree(Node n) {\n+    // TODO(user): canFuseIntoOnestatement needs to be rewritten to\n+    // allow more aggressve use of comma's.\n+\n     // The block of a function body always need { }.\n     if (!n.getParent().isFunction() && canFuseIntoOneStatement(n)) {\n-      fuseIntoOneStatement(n);\n+      Node start = n.getFirstChild();\n+      Node end = n.getChildBefore(n.getLastChild());\n+      Node result = fuseIntoOneStatement(n, start, end);\n+      fuseExpressionIntoControlFlowStatement(result, n.getLastChild());\n       reportCodeChange();\n     }\n     return n;\n     return false;\n   }\n \n-  private void fuseIntoOneStatement(Node block) {\n-    Node cur = block.removeFirstChild();\n-\n-    // Starts building a tree.\n-    Node commaTree = cur.removeFirstChild();\n-\n-\n-    while (block.hasMoreThanOneChild()) {\n-      Node next = block.removeFirstChild().removeFirstChild();\n-      commaTree = fuseExpressionIntoExpression(commaTree, next);\n+  /**\n+   * Given a block, fuse a list of statements with comma's.\n+   *\n+   * @param parent The parent that contains the statements.\n+   * @param first The first statement to fuse (inclusive)\n+   * @param last The last statement to fuse (inclusive)\n+   * @return A single statement that contains all the fused statement as one.\n+   */\n+  private Node fuseIntoOneStatement(Node parent, Node first, Node last) {\n+    // Nothing to fuse if there is only one statement.\n+    if (first == last) {\n+      return first;\n     }\n \n-    Preconditions.checkState(block.hasOneChild());\n-    Node last = block.getLastChild();\n+    // Step one: Create a comma tree that contains all the statements.\n+    Node commaTree = first.removeFirstChild();\n+    Node onePastLast = last.getNext();\n+\n+    Node next = null;\n+    for (Node cur = first.getNext(); cur != onePastLast; cur = next) {\n+      commaTree = fuseExpressionIntoExpression(\n+          commaTree, cur.removeFirstChild());\n+      next = cur.getNext();\n+      parent.removeChild(cur);\n+    }\n+\n+    // Step two: The last EXPR_RESULT will now hold the comma tree with all\n+    // the fused statements.\n+    first.addChildToBack(commaTree);\n+    return first;\n+  }\n+\n+  private void fuseExpressionIntoControlFlowStatement(\n+      Node before, Node control) {\n+    Preconditions.checkArgument(before.isExprResult(),\n+        \"before must be expression result\");\n \n     // Now we are just left with two statements. The comma tree of the first\n     // n - 1 statements (which can be used in an expression) and the last\n     // statement. We perform specific fusion based on the last statement's type.\n-    switch(last.getType()) {\n+    switch(control.getType()) {\n       case Token.IF:\n       case Token.RETURN:\n       case Token.THROW:\n       case Token.SWITCH:\n       case Token.EXPR_RESULT:\n-        fuseExpresssonIntoFirstChild(commaTree, last);\n+        before.getParent().removeChild(before);\n+        fuseExpresssonIntoFirstChild(before.removeFirstChild(), control);\n         return;\n       case Token.FOR:\n-        if (NodeUtil.isForIn(last)) {\n-          fuseExpresssonIntoSecondChild(commaTree, last);\n+        before.getParent().removeChild(before);\n+        if (NodeUtil.isForIn(control)) {\n+          fuseExpresssonIntoSecondChild(before.removeFirstChild(), control);\n         }\n         return;\n       default:", "timestamp": 1364598558, "metainfo": ""}