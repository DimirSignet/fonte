{"sha": "b53207c1f8477fb28dfaa94add349cfc21ad5ba0", "log": "Implement inline jsdocs, as described in the public jsdoc wiki This does not actually use the types yet for any type-checking. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=42548438", "commit": "\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n     return irNode;\n   }\n \n+  /**\n+   * Parameter NAMEs are special, because they can have inline type docs\n+   * attached.\n+   *\n+   * function f(/** string &#42;/ x) {}\n+   * annotates 'x' as a string.\n+   *\n+   * @see http://code.google.com/p/jsdoc-toolkit/wiki/InlineDocs\n+   */\n+  private Node transformParameter(AstNode node) {\n+    Node irNode = justTransform(node);\n+    Comment comment = node.getJsDocNode();\n+    if (comment != null) {\n+      JSDocInfo info = parseInlineTypeDoc(comment, irNode);\n+      if (info != null) {\n+        irNode.setJSDocInfo(info);\n+      }\n+    }\n+    setSourceInfo(irNode, node);\n+    return irNode;\n+  }\n+\n   private Node transformNameAsString(Name node) {\n     Node irNode = transformDispatcher.processName(node, true);\n     JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n     jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo);\n     jsdocParser.parse();\n     return jsdocParser;\n+  }\n+\n+  /**\n+   * Parses inline type info.\n+   */\n+  private JSDocInfo parseInlineTypeDoc(Comment node, Node irNode) {\n+    String comment = node.getValue();\n+    int lineno = node.getLineno();\n+    int position = node.getAbsolutePosition();\n+\n+    // The JsDocInfoParser expects the comment without the initial '/**'.\n+    int numOpeningChars = 3;\n+    JsDocInfoParser parser =\n+      new JsDocInfoParser(\n+          new JsDocTokenStream(comment.substring(numOpeningChars),\n+                               lineno,\n+                               position2charno(position) + numOpeningChars),\n+          node,\n+          irNode,\n+          config,\n+          errorReporter);\n+    return parser.parseInlineTypeDoc();\n   }\n \n   // Set the length on the node if we're in IDE mode.\n \n       lp.setCharno(position2charno(lparenCharno));\n       for (AstNode param : functionNode.getParams()) {\n-        Node paramNode = transform(param);\n+        Node paramNode = transformParameter(param);\n         // When in ideMode Rhino can generate a param list with only a single\n         // ErrorNode. This is transformed into an EMPTY node. Drop this node in\n         // ideMode to keep the AST in a valid state.\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n \n   private String getSourceName() {\n     return sourceFile == null ? null : sourceFile.getName();\n+  }\n+\n+  public JSDocInfo parseInlineTypeDoc() {\n+    Node typeAst = parseAndRecordTypeNode(next());\n+    JSTypeExpression expr = createJSTypeExpression(typeAst);\n+    if (expr != null) {\n+      jsdocBuilder.recordType(expr);\n+      return retrieveAndResetParsedJSDocInfo();\n+    }\n+    return null;\n   }\n \n   /**\n    * @param token The current token.\n    * @return The type expression found or null if none.\n    */\n-  private Node parseAndRecordTypeNode(JsDocToken token) {\n+  Node parseAndRecordTypeNode(JsDocToken token) {\n     return parseAndRecordTypeNode(token, token == JsDocToken.LC);\n   }\n \n    * Constructs a new {@code JSTypeExpression}.\n    * @param n A node. May be null.\n    */\n-  private JSTypeExpression createJSTypeExpression(Node n) {\n+  JSTypeExpression createJSTypeExpression(Node n) {\n     return n == null ? null :\n         new JSTypeExpression(n, getSourceName());\n   }\n--- a/test/com/google/javascript/jscomp/parsing/ParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/ParserTest.java\n     assertEquals(Token.EXPR_RESULT, exprCall.getType());\n     assertNull(exprCall.getNext().getJSDocInfo());\n     assertNotNull(exprCall.getFirstChild().getJSDocInfo());\n+  }\n+\n+  public void testJSDocAttachment17() {\n+    Node fn = parse(\"function f(/** string */ x) {}\").getFirstChild();\n+    assertTrue(fn.isFunction());\n+\n+    JSDocInfo info =\n+        fn.getFirstChild().getNext().getFirstChild().getJSDocInfo();\n+    assertNotNull(info);\n+    assertTypeEquals(STRING_TYPE, info.getType());\n+  }\n+\n+  public void testJSDocAttachment18() {\n+    Node fn = parse(\"function f(/** {string} */ x) {}\").getFirstChild();\n+    assertTrue(fn.isFunction());\n+\n+    JSDocInfo info =\n+        fn.getFirstChild().getNext().getFirstChild().getJSDocInfo();\n+    assertNotNull(info);\n+    assertTypeEquals(STRING_TYPE, info.getType());\n   }\n \n   public void testIncorrectJSDocDoesNotAlterJSParsing1() throws Exception {\n   }\n \n   public void testValidTypeAnnotation3() {\n-    // These two we don't currently support in the type checker but\n+    // This one we don't currently support in the type checker but\n     // we would like to.\n     parse(\"try {} catch (/** @type {Error} */ e) {}\");\n-    parse(\"function f(/** @type {string} */ a) {}\");\n   }\n \n   /**", "timestamp": 1360871008, "metainfo": ""}