{"sha": "83d03ec5c8b7c49896841a9386bec0f75d2697a5", "log": "Change on 2010/06/24 by johnlenz          Add support to ant task for manage dependencies.         Fixes issue 188.          R=nicksantos         DELTA=7  (7 added, 0 deleted, 0 changed)  Change on 2010/06/24 by johnlenz          Add character set encoding support to the ant task.         Fixes issue 186.          R=nicksantos         DELTA=27  (24 added, 0 deleted, 3 changed)  Change on 2010/06/24 by elnatan          Refactored: rewrote while loop as for-each loop          R=nicksantos         DELTA=7  (0 added, 5 deleted, 2 changed)  Change on 2010/06/24 by nicksantos          Add IE's imeMode to the externs file, so that we can enable/disable         IMEs.          R=shanbhag         DELTA=6  (6 added, 0 deleted, 0 changed)  Change on 2010/06/24 by nicksantos          the answer to your question about         inferring param types and return types is yes. :)          R=rjfioravanti         DELTA=21  (21 added, 0 deleted, 0 changed)  Change on 2010/06/24 by cindylau          Add experimental.cookies API to Chrome Extensions externs file.          R=acleung         DELTA=70  (70 added, 0 deleted, 0 changed)  Change on 2010/06/24 by nicksantos          don't fold numbers when they get really big.         SanityCheck is upset because large numbers cause non-determinism         in compile jobs, due to fixed-point rounding errors.          R=acleung         DELTA=12  (11 added, 0 deleted, 1 changed)  Revision created by MOE tool push_codebase. MOE_MIGRATION=37004   ", "commit": "\n--- a/src/com/google/javascript/jscomp/ExternExportsPass.java\n+++ b/src/com/google/javascript/jscomp/ExternExportsPass.java\n      */\n     private Node createExternFunction(Node exportedFunction) {\n       List<Node> externParameters = Lists.newLinkedList();\n-      Node actualParameterIterator = NodeUtil.getFnParameters(exportedFunction)\n-        .getFirstChild();\n-      \n-      while (actualParameterIterator != null) {\n-        externParameters.add(actualParameterIterator.cloneNode());\n-        \n-        actualParameterIterator = actualParameterIterator.getNext();\n+      for (Node param : NodeUtil.getFnParameters(exportedFunction).children()) {\n+        externParameters.add(param.cloneNode());\n       }\n       \n       Node externFunction = NodeUtil.newFunctionNode(\"\", externParameters, \n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n   static final DiagnosticType FRACTIONAL_BITWISE_OPERAND = DiagnosticType.error(\n       \"JSC_FRACTIONAL_BITWISE_OPERAND\",\n       \"Fractional bitwise operand: {0}\");\n+\n+  private static final double MAX_FOLD_NUMBER = Math.pow(2, 53);\n   \n   @Override\n   Node optimizeSubtree(Node subtree) {\n \n       // length of the left and right value plus 1 byte for the operator.\n       if (String.valueOf(result).length() <=\n-          String.valueOf(lval).length() + String.valueOf(rval).length() + 1) {\n+          String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&\n+\n+          // Do not try to fold arithmetic for numbers > 2^53. After that\n+          // point, fixed-point math starts to break down and become inaccurate.\n+          Math.abs(result) <= MAX_FOLD_NUMBER) {\n         Node newNumber = Node.newNumber(result);\n         n.getParent().replaceChild(n, newNumber);\n         reportCodeChange();\n--- a/src/com/google/javascript/jscomp/ant/CompileTask.java\n+++ b/src/com/google/javascript/jscomp/ant/CompileTask.java\n \n import com.google.common.collect.Lists;\n import com.google.common.io.LimitInputStream;\n+import com.google.javascript.jscomp.CommandLineRunner;\n import com.google.javascript.jscomp.CompilationLevel;\n import com.google.javascript.jscomp.Compiler;\n import com.google.javascript.jscomp.CompilerOptions;\n import org.apache.tools.ant.types.FileList;\n \n import java.io.File;\n-import java.io.FileWriter;\n+import java.io.FileOutputStream;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.io.OutputStreamWriter;\n+import java.nio.charset.Charset;\n import java.util.List;\n import java.util.logging.Level;\n import java.util.zip.ZipEntry;\n     extends Task {\n   private WarningLevel warningLevel;\n   private boolean debugOptions;\n+  private String encoding = \"UTF-8\";\n+  private String outputEncoding = \"UTF-8\"; \n   private CompilationLevel compilationLevel;\n   private boolean customExternsOnly;\n+  private boolean manageDependencies;\n   private File outputFile;\n   private final List<FileList> externFileLists;\n   private final List<FileList> sourceFileLists;\n     this.debugOptions = false;\n     this.compilationLevel = CompilationLevel.SIMPLE_OPTIMIZATIONS;\n     this.customExternsOnly = false;\n+    this.manageDependencies = false;\n     this.externFileLists = Lists.newLinkedList();\n     this.sourceFileLists = Lists.newLinkedList();\n   }\n     }\n   }\n \n+  public void setManageDependencies(boolean value) {\n+    this.manageDependencies = value;\n+  }\n+\n   /**\n    * Use only custom externs.\n    */\n    */\n   public void setOutput(File value) {\n     this.outputFile = value;\n+  }\n+\n+  /** \n+   * Set input file encoding \n+   */\n+  public void setEncoding(String encoding) {\n+    this.encoding = encoding;\n+  }\n+\n+  /** \n+   * Set output file encoding \n+   */\n+  public void setOutputEncoding(String outputEncoding) {\n+    this.outputEncoding = outputEncoding;\n   }\n \n   /**\n     }\n \n     this.warningLevel.setOptionsForWarningLevel(options);\n+    options.setManageClosureDependencies(manageDependencies);\n     return options;\n   }\n \n     File baseDir = fileList.getDir(getProject());\n \n     for (String included : fileList.getFiles(getProject())) {\n-      files.add(JSSourceFile.fromFile(new File(baseDir, included)));\n+      files.add(JSSourceFile.fromFile(new File(baseDir, included),\n+          Charset.forName(encoding)));\n     }\n \n     return files;\n     }\n \n     try {\n-      FileWriter out = new FileWriter(this.outputFile);\n+      OutputStreamWriter out = new OutputStreamWriter(\n+          new FileOutputStream(this.outputFile), outputEncoding);\n       out.append(source);\n+      out.flush();\n       out.close();\n     } catch (IOException e) {\n       throw new BuildException(e);\n         Project.MSG_DEBUG);\n   }\n }\n+\n--- a/test/com/google/javascript/jscomp/FoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/FoldConstantsTest.java\n     foldSame(\"var x; foo:{x = 3;}\");\n     foldSame(\"var x; foo:x = 3;\");\n   }\n+\n+  public void testShortCircuitLargeNumberFolding() {\n+    fold(\"var b = 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000;\",\n+         \"var b = 1000000000000000 * 1000 * 1000;\");\n+  }\n }\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"}\",\n         \"inconsistent return type\\n\" +\n         \"found   : (number|undefined)\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testInferredReturn7() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"/** @param {number} x */ Foo.prototype.bar = function(x) {};\" +\n+        \"Foo.prototype.bar = function(x) { return 3; };\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: undefined\");\n+  }\n+\n+  public void testInferredParam1() throws Exception {\n+    testTypes(\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"/** @param {number} x */ Foo.prototype.bar = function(x) {};\" +\n+        \"/** @param {string} x */ function f(x) {}\" +\n+        \"Foo.prototype.bar = function(y) { f(y); };\",\n+        \"actual parameter 1 of f does not match formal parameter\\n\" +\n+        \"found   : number\\n\" +\n         \"required: string\");\n   }\n ", "timestamp": 1277433386, "metainfo": ""}