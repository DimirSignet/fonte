{"sha": "4bbd3393dab8fdd079f0f0c1d84569685c36d0e8", "log": "Side-effect analysis improvements fixes issue 1004 R=blickly,johnlenz", "commit": "\n--- a/src/com/google/javascript/jscomp/MarkNoSideEffectCalls.java\n+++ b/src/com/google/javascript/jscomp/MarkNoSideEffectCalls.java\n         return;\n       }\n \n+      boolean maybeFunction = false;\n       for (Definition def : definitions) {\n         Node lValue = def.getLValue();\n         Preconditions.checkNotNull(lValue);\n-        if (!noSideEffectFunctionNames.contains(lValue) &&\n-            definitionTypeContainsFunctionType(def)) {\n-          return;\n-        }\n-      }\n-\n-      node.setSideEffectFlags(Node.NO_SIDE_EFFECTS);\n+        if (definitionTypeContainsFunctionType(def)) {\n+          maybeFunction = true;\n+          if (!noSideEffectFunctionNames.contains(lValue)) {\n+            return;\n+          }\n+        }\n+      }\n+\n+      if (maybeFunction) {\n+        node.setSideEffectFlags(Node.NO_SIDE_EFFECTS);\n+      }\n     }\n   }\n }\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n       return false;\n     }\n \n+    if (callNode.isOnlyModifiesArgumentsCall() &&\n+        allArgsUnescapedLocal(callNode)) {\n+      return false;\n+    }\n+\n     Node nameNode = callNode.getFirstChild();\n     if (nameNode.isName() &&\n         CONSTRUCTORS_WITHOUT_SIDE_EFFECTS.contains(nameNode.getString())) {\n     }\n \n     if (callNode.isNoSideEffectsCall()) {\n+      return false;\n+    }\n+\n+    if (callNode.isOnlyModifiesArgumentsCall() &&\n+        allArgsUnescapedLocal(callNode)) {\n       return false;\n     }\n \n       default:\n         return false;\n     }\n+  }\n+\n+  static boolean allArgsUnescapedLocal(Node callOrNew) {\n+    for (Node arg = callOrNew.getFirstChild().getNext();\n+         arg != null; arg = arg.getNext()) {\n+      if (!evaluatesToLocalValue(arg)) {\n+        return false;\n+      }\n+    }\n+    return true;\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/OptimizeParameters.java\n+++ b/src/com/google/javascript/jscomp/OptimizeParameters.java\n \n   private void optimizeCallSite(\n       SimpleDefinitionFinder defFinder, List<Parameter> parameters, Node call) {\n+    boolean mayMutateArgs = call.mayMutateArguments();\n+    boolean mayMutateGlobalsOrThrow = call.mayMutateGlobalStateOrThrow();\n     for (int index = parameters.size() - 1; index >= 0; index--) {\n       Parameter p = parameters.get(index);\n       if (p.shouldRemove()) {\n         eliminateCallParamAt(defFinder, p, call, index);\n+\n+        if (mayMutateArgs && !mayMutateGlobalsOrThrow &&\n+            // We want to cover both global-state arguments, and\n+            // expressions that might throw exceptions.\n+            // We're deliberately conservative here b/c it's\n+            // difficult to test all the edge cases.\n+            !NodeUtil.isImmutableValue(p.getArg())) {\n+          mayMutateGlobalsOrThrow = true;\n+          call.setSideEffectFlags(\n+              new Node.SideEffectFlags(call.getSideEffectFlags())\n+              .setMutatesGlobalState());\n+        }\n       }\n     }\n   }\n--- a/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n+++ b/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n           FunctionInformation functionInfo =\n               functionSideEffectMap.get(def.getRValue());\n           Preconditions.checkNotNull(functionInfo);\n-          // TODO(johnlenz): set the arguments separately from the\n-          // global state flag.\n           if (functionInfo.mutatesGlobalState()) {\n             flags.setMutatesGlobalState();\n+          }\n+\n+          if (functionInfo.mutatesArguments()) {\n+            flags.setMutatesArguments();\n           }\n \n           if (functionInfo.functionThrows) {\n \n       for (Iterator<Var> i = t.getScope().getVars(); i.hasNext();) {\n         Var v = i.next();\n+\n+        boolean param = v.getParentNode().isParamList();\n+        if (param &&\n+            !sideEffectInfo.blacklisted.contains(v) &&\n+            sideEffectInfo.taintedLocals.contains(v)) {\n+          sideEffectInfo.setTaintsArguments();\n+          continue;\n+        }\n+\n         boolean localVar = false;\n         // Parameters and catch values come can from other scopes.\n         if (v.getParentNode().isVar()) {\n         changed = true;\n       }\n \n+      if (!caller.mutatesGlobalState() && callee.mutatesArguments() &&\n+          !NodeUtil.allArgsUnescapedLocal(callSite)) {\n+        // TODO(nicksantos): We should track locals in the caller\n+        // and using that to be more precise. See testMutatesArguments3.\n+        caller.setTaintsGlobalState();\n+        changed = true;\n+      }\n+\n       if (callee.mutatesThis()) {\n         // Side effects only propagate via regular calls.\n         // Calling a constructor that modifies \"this\" has no side effects.\n      * Returns true if function mutates global state.\n      */\n     boolean mutatesGlobalState() {\n-      // TODO(johnlenz): track arguments separately.\n+      return taintsGlobalState || taintsUnknown;\n+    }\n+\n+\n+    /**\n+     * Returns true if function mutates its arguments.\n+     */\n+    boolean mutatesArguments() {\n       return taintsGlobalState || taintsArguments || taintsUnknown;\n     }\n \n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n   }\n \n   /**\n+   * @return Whether the only side-effect is \"modifies arguments\"\n+   */\n+  public boolean isOnlyModifiesArgumentsCall() {\n+    return areBitFlagsSet(\n+        getSideEffectFlags() & Node.NO_SIDE_EFFECTS,\n+        Node.FLAG_GLOBAL_STATE_UNMODIFIED\n+            | Node.FLAG_THIS_UNMODIFIED\n+            | Node.FLAG_NO_THROWS);\n+  }\n+\n+  /**\n    * Returns true if this node is a function or constructor call that\n    * has no side effects.\n    */\n    */\n   public boolean isLocalResultCall() {\n     return areBitFlagsSet(getSideEffectFlags(), FLAG_LOCAL_RESULTS);\n+  }\n+\n+  /** Returns true if this is a new/call that may mutate its arguments. */\n+  public boolean mayMutateArguments() {\n+    return !areBitFlagsSet(getSideEffectFlags(), FLAG_ARGUMENTS_UNMODIFIED);\n+  }\n+\n+  /** Returns true if this is a new/call that may mutate global state or throw. */\n+  public boolean mayMutateGlobalStateOrThrow() {\n+    return !areBitFlagsSet(getSideEffectFlags(),\n+        FLAG_GLOBAL_STATE_UNMODIFIED | FLAG_NO_THROWS);\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n         \"try { new Function('this is an error'); } catch(a) { alert('x'); }\");\n   }\n \n+  public void testSideEffectIntegration() {\n+    args.add(\"--compilation_level=ADVANCED_OPTIMIZATIONS\");\n+    test(\"/** @constructor */\" +\n+         \"var Foo = function() {};\" +\n+\n+         \"Foo.prototype.blah = function() {\" +\n+         \"  Foo.bar_(this)\" +\n+         \"};\" +\n+\n+         \"Foo.bar_ = function(f) {\" +\n+         \"  f.x = 5;\" +\n+         \"};\" +\n+\n+         \"var y = new Foo();\" +\n+\n+         \"Foo.bar_({});\" +\n+\n+         // We used to strip this too\n+         // due to bad side-effect propagation.\n+         \"y.blah();\" +\n+\n+         \"alert(y);\",\n+         \"var a = new function(){}; a.a = 5; alert(a);\");\n+  }\n+\n   public void testDebugFlag1() {\n     args.add(\"--compilation_level=SIMPLE_OPTIMIZATIONS\");\n     args.add(\"--debug=false\");\n--- a/test/com/google/javascript/jscomp/CompilerTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java\n    */\n   private boolean markNoSideEffects = false;\n \n+  /**\n+   * Whether the PureFunctionIdentifier pass runs before the pass being tested\n+   */\n+  private boolean computeSideEffects = false;\n+\n   /** The most recently used Compiler instance. */\n   private Compiler lastCompiler;\n \n    *\n    * @see MarkNoSideEffectCalls\n    */\n+  // TODO(nicksantos): This pass doesn't get run anymore. It should be removed.\n   void enableMarkNoSideEffects() {\n     markNoSideEffects  = true;\n+  }\n+\n+  /**\n+   * Run the PureFunctionIdentifier pass before running the test pass.\n+   *\n+   * @see MarkNoSideEffectCalls\n+   */\n+  void enableComputeSideEffects() {\n+    computeSideEffects  = true;\n   }\n \n   /**\n         // Only run the normalize pass once, if asked.\n         if (normalizeEnabled && i == 0) {\n           normalizeActualCode(compiler, externsRoot, mainRoot);\n+        }\n+\n+        if (computeSideEffects && i == 0) {\n+          PureFunctionIdentifier.Driver mark =\n+              new PureFunctionIdentifier.Driver(compiler, null, false);\n+          mark.process(externsRoot, mainRoot);\n         }\n \n         if (markNoSideEffects && i == 0) {\n--- a/test/com/google/javascript/jscomp/IntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/IntegrationTest.java\n         \"alert(\\\"hi\\\")\");\n   }\n \n+  public void testAddFunctionProperties1() throws Exception {\n+    String source =\n+        \"var Foo = {};\" +\n+        \"var addFuncProp = function(o) {\" +\n+        \"  o.f = function() {}\" +\n+        \"};\" +\n+        \"addFuncProp(Foo);\" +\n+        \"alert(Foo.f());\";\n+    String expected =\n+        \"alert(void 0);\";\n+    CompilerOptions options = createCompilerOptions();\n+    CompilationLevel.ADVANCED_OPTIMIZATIONS\n+        .setOptionsForCompilationLevel(options);\n+    options.setRenamingPolicy(\n+        VariableRenamingPolicy.OFF, PropertyRenamingPolicy.OFF);\n+    test(options, source, expected);\n+  }\n+\n+  public void testAddFunctionProperties2() throws Exception {\n+    String source =\n+        \"/** @constructor */ function F() {}\" +\n+        \"var x = new F();\" +\n+        \"/** @this {F} */\" +\n+        \"function g() { this.bar = function() { alert(3); }; }\" +\n+        \"g.call(x);\" +\n+        \"x.bar();\";\n+    String expected =\n+        \"var x = new function() {};\" +\n+        \"/** @this {F} */\" +\n+        \"(function () { this.bar = function() { alert(3); }; }).call(x);\" +\n+        \"x.bar();\";\n+\n+    CompilerOptions options = createCompilerOptions();\n+    CompilationLevel.ADVANCED_OPTIMIZATIONS\n+        .setOptionsForCompilationLevel(options);\n+    options.setRenamingPolicy(\n+        VariableRenamingPolicy.OFF, PropertyRenamingPolicy.OFF);\n+    test(options, source, expected);\n+  }\n+\n+  public void testAddFunctionProperties3() throws Exception {\n+    String source =\n+        \"/** @constructor */ function F() {}\" +\n+        \"var x = new F();\" +\n+        \"/** @this {F} */\" +\n+        \"function g(y) { y.bar = function() { alert(3); }; }\" +\n+        \"g(x);\" +\n+        \"x.bar();\";\n+    String expected =\n+        \"var x = new function() {};\" +\n+        \"/** @this {F} */\" +\n+        \"(function (y) { y.bar = function() { alert(3); }; })(x);\" +\n+        \"x.bar();\";\n+\n+    CompilerOptions options = createCompilerOptions();\n+    CompilationLevel.ADVANCED_OPTIMIZATIONS\n+        .setOptionsForCompilationLevel(options);\n+    options.setRenamingPolicy(\n+        VariableRenamingPolicy.OFF, PropertyRenamingPolicy.OFF);\n+    test(options, source, expected);\n+  }\n+\n+  public void testAddFunctionProperties4() throws Exception {\n+    String source =\n+        \"/** @constructor */\" +\n+        \"var Foo = function() {};\" +\n+        \"var goog = {};\" +\n+        \"goog.addSingletonGetter = function(o) {\" +\n+        \"  o.f = function() {\" +\n+        \"    o.i = new o;\" +\n+        \"  };\" +\n+        \"};\" +\n+        \"goog.addSingletonGetter(Foo);\" +\n+        \"alert(Foo.f());\";\n+    String expected =\n+        \"function Foo(){} Foo.f=function(){Foo.i=new Foo}; alert(Foo.f());\";\n+\n+    CompilerOptions options = createCompilerOptions();\n+    CompilationLevel.ADVANCED_OPTIMIZATIONS\n+        .setOptionsForCompilationLevel(options);\n+    options.setRenamingPolicy(\n+        VariableRenamingPolicy.OFF, PropertyRenamingPolicy.OFF);\n+    test(options, source, expected);\n+  }\n+\n   public void testCoaleseVariables() {\n     CompilerOptions options = createCompilerOptions();\n \n         \"/** @const */ a.b.c = {};\" +\n         \"a.b.c.MyType;\" +\n         \"a.b.c.myFunc = function(x) {};\");\n-  }\n-\n-  public void testAddFunctionProperties1() throws Exception {\n-    String source =\n-        \"/** @constructor */ function F() {}\" +\n-        \"var x = new F();\" +\n-        \"/** @this {F} */\" +\n-        \"function g() { this.bar = function() { alert(3); }; }\" +\n-        \"g.call(x);\" +\n-        \"x.bar();\";\n-    String expected =\n-        \"var x = new function() {};\" +\n-        \"/** @this {F} */\" +\n-        \"(function () { this.bar = function() { alert(3); }; }).call(x);\" +\n-        \"x.bar();\";\n-\n-    CompilerOptions options = createCompilerOptions();\n-    CompilationLevel.ADVANCED_OPTIMIZATIONS\n-        .setOptionsForCompilationLevel(options);\n-    options.setRenamingPolicy(\n-        VariableRenamingPolicy.OFF, PropertyRenamingPolicy.OFF);\n-    test(options, source, expected);\n-  }\n-\n-  public void testAddFunctionProperties2() throws Exception {\n-    String source =\n-        \"/** @constructor */ function F() {}\" +\n-        \"var x = new F();\" +\n-        \"/** @this {F} */\" +\n-        \"function g(y) { y.bar = function() { alert(3); }; }\" +\n-        \"g(x);\" +\n-        \"x.bar();\";\n-    String expected =\n-        \"var x = new function() {};\" +\n-        \"/** @this {F} */\" +\n-        \"(function (y) { y.bar = function() { alert(3); }; })(x);\" +\n-        \"x.bar();\";\n-\n-    CompilerOptions options = createCompilerOptions();\n-    CompilationLevel.ADVANCED_OPTIMIZATIONS\n-        .setOptionsForCompilationLevel(options);\n-    options.setRenamingPolicy(\n-        VariableRenamingPolicy.OFF, PropertyRenamingPolicy.OFF);\n-    test(options, source, expected);\n   }\n \n   public void testCodingConvention() {\n--- a/test/com/google/javascript/jscomp/MarkNoSideEffectCallsTest.java\n+++ b/test/com/google/javascript/jscomp/MarkNoSideEffectCallsTest.java\n          null, INVALID_NO_SIDE_EFFECT_ANNOTATION);\n   }\n \n+  public void testCallNumber() throws Exception {\n+    testMarkCalls(\"\", \"var x = 1; x();\",\n+                  ImmutableList.<String>of());\n+  }\n+\n   void testMarkCalls(String source, List<String> expected) {\n     testMarkCalls(\"\", source, expected);\n   }\n--- a/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java\n+++ b/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java\n   }\n \n   public void testAnnotationInExterns_new10() throws Exception {\n-    // While \"externObjSEThisMethod2\" only modifies it arguments\n-    // and the arguments are known local values, we don't\n-    // yet connect the dots, and \"f\" is consider to have\n-    // global side-effects.\n     checkMarkedCalls(\n         \"function f() {\" +\n         \"  new externObjSEThis().externObjSEThisMethod2('') \" +\n         \"};\" +\n         \"f();\",\n-        ImmutableList.<String>of(\"externObjSEThis\"));\n+        ImmutableList.<String>of(\n+            \"externObjSEThis\", \"NEW STRING externObjSEThisMethod2\", \"f\"));\n   }\n \n   public void testAnnotationInExterns1() throws Exception {\n   public void testUnaryOperators5() throws Exception {\n     checkMarkedCalls(\"function f(x) {x.foo++}\" +\n                      \"f({foo : 0})\",\n-                     ImmutableList.<String>of());\n+                     ImmutableList.<String>of(\"f\"));\n   }\n \n   public void testDeleteOperator1() throws Exception {\n         \"f(); g()\";\n \n     checkMarkedCalls(source, ImmutableList.<String>of(\"A\", \"A\", \"f\"));\n+  }\n+\n+  public void testMutatesArguments1() throws Exception {\n+    String source = \"function f(x) { x.y = 1; }\\n\" +\n+        \"f({});\";\n+    checkMarkedCalls(source, ImmutableList.<String>of(\"f\"));\n+  }\n+\n+  public void testMutatesArguments2() throws Exception {\n+    String source = \"function f(x) { x.y = 1; }\\n\" +\n+        \"f(window);\";\n+    checkMarkedCalls(source, ImmutableList.<String>of());\n+  }\n+\n+  public void testMutatesArguments3() throws Exception {\n+    // We could do better here with better side-effect propagation.\n+    String source = \"function f(x) { x.y = 1; }\\n\" +\n+        \"function g(x) { f(x); }\\n\" +\n+        \"g({});\";\n+    checkMarkedCalls(source, ImmutableList.<String>of());\n+  }\n+\n+  public void testMutatesArguments4() throws Exception {\n+    String source = \"function f(x) { x.y = 1; }\\n\" +\n+        \"function g(x) { f({}); x.y = 1; }\\n\" +\n+        \"g({});\";\n+    checkMarkedCalls(source, ImmutableList.<String>of(\"f\", \"g\"));\n+  }\n+\n+  public void testMutatesArgumentsArray1() throws Exception {\n+    // We could be smarter here.\n+    String source = \"function f(x) { arguments[0] = 1; }\\n\" +\n+        \"f({});\";\n+    checkMarkedCalls(source, ImmutableList.<String>of());\n+  }\n+\n+  public void testMutatesArgumentsArray2() throws Exception {\n+    // We could be smarter here.\n+    String source = \"function f(x) { arguments[0].y = 1; }\\n\" +\n+        \"f({});\";\n+    checkMarkedCalls(source, ImmutableList.<String>of());\n+  }\n+\n+  public void testMutatesArgumentsArray3() throws Exception {\n+    String source = \"function f(x) { arguments[0].y = 1; }\\n\" +\n+        \"f(x);\";\n+    checkMarkedCalls(source, ImmutableList.<String>of());\n   }\n \n   public void testCallFunctionFOrG() throws Exception {\n--- a/test/com/google/javascript/jscomp/UnreachableCodeEliminationTest.java\n+++ b/test/com/google/javascript/jscomp/UnreachableCodeEliminationTest.java\n \n   @Override public void setUp() throws Exception {\n     super.setUp();\n+    enableComputeSideEffects();\n     removeNoOpStatements = true;\n   }\n \n     testSame(\"function f() {b:try{throw 9} finally {\" +\n              \"switch(x) {case 1: break b} } return 1;}\");\n   }\n+\n+  public void testIssue1001() throws Exception {\n+    test(\"function f(x) { x.property = 3; } f({})\",\n+         \"function f(x) { x.property = 3; }\");\n+    test(\"function f(x) { x.property = 3; } new f({})\",\n+         \"function f(x) { x.property = 3; }\");\n+  }\n }", "timestamp": 1370060336, "metainfo": ""}