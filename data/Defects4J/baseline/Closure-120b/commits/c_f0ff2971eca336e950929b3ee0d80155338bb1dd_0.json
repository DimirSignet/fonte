{"sha": "f0ff2971eca336e950929b3ee0d80155338bb1dd", "log": "Cruft removal: remove some unused locals and parameters.  R=dimvar DELTA=336 (6 added, 108 deleted, 222 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=6092   ", "commit": "\n--- a/src/com/google/debugging/sourcemap/SourceMapConsumerV1.java\n+++ b/src/com/google/debugging/sourcemap/SourceMapConsumerV1.java\n       LineFragment myLineFragment = null;\n \n       JSONArray charArray = new JSONArray(currentLine);\n-      int numOffsets = charArray.length();\n       int lastID = -1;\n       int startID = Integer.MIN_VALUE;\n       List<Byte> currentOffsets = Lists.newArrayList();\n--- a/src/com/google/debugging/sourcemap/SourceMapGeneratorV3.java\n+++ b/src/com/google/debugging/sourcemap/SourceMapGeneratorV3.java\n     // Renumber used mappings and keep track of the last line.\n     int id = 0;\n     int maxLine = 0;\n-    int sourceId = 0;\n-    int nameId = 0;\n     for (Mapping m : mappings) {\n       if (m.used) {\n         m.id = id++;\n     appendFieldStart(out, \"sections\");\n     out.append(\"[\\n\");\n     boolean first = true;\n-    int line = 0, column = 0;\n     for (SourceMapSection section : sections) {\n       if (first) {\n         first = false;\n     public void visit(Mapping m, int line, int col, int nextLine, int nextCol)\n       throws IOException {\n \n-      int id = (m != null) ? m.id : UNMAPPED;\n-\n       if (previousLine != line) {\n         previousColumn = 0;\n       }\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n     return compiler.getDiagnosticGroups();\n   }\n \n-  /** No longer does anything. */\n-  @Deprecated\n-  protected void initOptionsFromFlags(CompilerOptions options) {}\n-\n   /**\n    * A helper function for creating the dependency options object.\n    */\n       }\n \n       // Output the variable and property name maps if requested.\n-      outputNameMaps(options);\n+      outputNameMaps();\n \n       // Output the manifest and bundle files if requested.\n       outputManifest();\n    * Outputs the variable and property name maps for the specified compiler if\n    * the proper FLAGS are set.\n    */\n-  private void outputNameMaps(B options) throws FlagUsageException,\n+  private void outputNameMaps() throws FlagUsageException,\n       IOException {\n \n     String propertyMapOutputPath = null;\n     if (config.outputModuleDependencies != null &&\n         config.outputModuleDependencies != \"\") {\n       Writer out = fileNameToOutputWriter2(config.outputModuleDependencies);\n-      printModuleGraphJsonTo(compiler.getDegenerateModuleGraph(), out);\n+      printModuleGraphJsonTo(out);\n       out.close();\n     }\n   }\n    * Prints the current module graph as JSON.\n    */\n   @VisibleForTesting\n-  void printModuleGraphJsonTo(JSModuleGraph graph,\n-      Appendable out) throws IOException {\n+  void printModuleGraphJsonTo(Appendable out) throws IOException {\n     out.append(compiler.getDegenerateModuleGraph().toJson().toString());\n   }\n \n--- a/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n+++ b/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n       if (lValue == null ||\n           lValue.getParent() == null ||\n           lValue.getParent().getParent() == null ||\n-          !(NodeUtil.isObjectLitKey(lValue, lValue.getParent()) ||\n+          !(NodeUtil.isObjectLitKey(lValue) ||\n             NodeUtil.isExprAssign(lValue.getParent().getParent()))) {\n         return null;\n       }\n--- a/src/com/google/javascript/jscomp/AstChangeProxy.java\n+++ b/src/com/google/javascript/jscomp/AstChangeProxy.java\n       Node block = IR.block();\n       for (Node newChild : replacements) {\n         newChild.copyInformationFrom(node);\n-        Node oldParent = newChild.getParent();\n         block.addChildToBack(newChild);\n       }\n-\n       parent.replaceChild(node, block);\n-\n     } else {\n       for (Node newChild : replacements) {\n         newChild.copyInformationFrom(node);\n-        Node oldParent = newChild.getParent();\n         parent.addChildBefore(newChild, node);\n       }\n       parent.removeChild(node);\n-\n     }\n     notifyOfRemoval(node);\n   }\n--- a/src/com/google/javascript/jscomp/CheckAccessControls.java\n+++ b/src/com/google/javascript/jscomp/CheckAccessControls.java\n     if (!t.inGlobalScope()) {\n       Node n = t.getScopeRoot();\n       Node parent = n.getParent();\n-      if (isDeprecatedFunction(n, parent)) {\n+      if (isDeprecatedFunction(n)) {\n         deprecatedDepth++;\n       }\n \n   public void exitScope(NodeTraversal t) {\n     if (!t.inGlobalScope()) {\n       Node n = t.getScopeRoot();\n-      Node parent = n.getParent();\n-      if (isDeprecatedFunction(n, parent)) {\n+      if (isDeprecatedFunction(n)) {\n         deprecatedDepth--;\n       }\n \n \n   /**\n    * Checks if a constructor is trying to override a final class.\n-   * @param t The current traversal.\n-   * @param name The name node.\n    */\n   private void checkFinalClassOverrides(NodeTraversal t, Node fn, Node parent) {\n     JSType type = fn.getJSType().toMaybeFunctionType();\n   /**\n    * Returns whether this is a function node annotated as deprecated.\n    */\n-  private static boolean isDeprecatedFunction(Node n, Node parent) {\n+  private static boolean isDeprecatedFunction(Node n) {\n     if (n.isFunction()) {\n       JSType type = n.getJSType();\n       if (type != null) {\n--- a/src/com/google/javascript/jscomp/CheckGlobalThis.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalThis.java\n \n       // Don't traverse functions that are getting lent to a prototype.\n       Node gramps = parent.getParent();\n-      if (NodeUtil.isObjectLitKey(parent, gramps)) {\n+      if (NodeUtil.isObjectLitKey(parent)) {\n         JSDocInfo maybeLends = gramps.getJSDocInfo();\n         if (maybeLends != null &&\n             maybeLends.getLendsName() != null &&\n \n     if (parent != null && parent.isAssign()) {\n       Node lhs = parent.getFirstChild();\n-      Node rhs = lhs.getNext();\n \n       if (n == lhs) {\n         // Always traverse the left side of the assignment. To handle\n \n   @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isThis() && shouldReportThis(n, parent)) {\n+    if (n.isThis() && shouldReportThis(n)) {\n       compiler.report(t.makeError(n, GLOBAL_THIS));\n     }\n     if (n == assignLhsChild) {\n     }\n   }\n \n-  private boolean shouldReportThis(Node n, Node parent) {\n+  private boolean shouldReportThis(Node n) {\n+    Node parent = n.getParent();\n     if (assignLhsChild != null) {\n       // Always report a THIS on the left side of an assign.\n       return true;\n--- a/src/com/google/javascript/jscomp/CheckMissingGetCssName.java\n+++ b/src/com/google/javascript/jscomp/CheckMissingGetCssName.java\n       String s = n.getString();\n \n       for (blacklist.reset(s); blacklist.find();) {\n-        if (insideGetCssNameCall(n, parent)) {\n+        if (insideGetCssNameCall(n)) {\n           continue;\n         }\n-        if (insideGetUniqueIdCall(n, parent)) {\n+        if (insideGetUniqueIdCall(n)) {\n           continue;\n         }\n-        if (insideAssignmentToIdConstant(n, parent)) {\n+        if (insideAssignmentToIdConstant(n)) {\n           continue;\n         }\n         compiler.report(t.makeError(n, level, MISSING_GETCSSNAME,\n   }\n \n   /** Returns whether the node is an argument of a goog.getCssName call. */\n-  private boolean insideGetCssNameCall(Node n, Node parent) {\n+  private boolean insideGetCssNameCall(Node n) {\n+    Node parent = n.getParent();\n     return parent.isCall() &&\n         GET_CSS_NAME_FUNCTION.equals(\n             parent.getFirstChild().getQualifiedName());\n    * a unique id (the last part of the qualified name matches\n    * GET_UNIQUE_ID_FUNCTION).\n    */\n-  private boolean insideGetUniqueIdCall(Node n, Node parent) {\n+  private boolean insideGetUniqueIdCall(Node n) {\n+    Node parent = n.getParent();\n     String name = parent.isCall() ?\n         parent.getFirstChild().getQualifiedName() : null;\n \n    * Returns whether the node is the right hand side of an assignment or\n    * initialization of a variable named *_ID of *_ID_.\n    */\n-  private boolean insideAssignmentToIdConstant(Node n, Node parent) {\n+  private boolean insideAssignmentToIdConstant(Node n) {\n+    Node parent = n.getParent();\n     if (parent.isAssign()) {\n       String qname = parent.getFirstChild().getQualifiedName();\n       return qname != null && isIdName(qname);\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n       // 2) References inside a complex assign. (a = x.y = 0). These are\n       //    called TWIN references, because they show up twice in the\n       //    reference list. Only collapse the set, not the alias.\n-      if (!NodeUtil.isObjectLitKey(r.node, rParent) &&\n+      if (!NodeUtil.isObjectLitKey(r.node) &&\n           (r.getTwin() == null || r.isSet())) {\n         flattenNameRef(alias, r.node, rParent, originalName);\n       }\n     // proceeding. In the OBJLIT case, we don't need to do anything.\n     int nType = n.getType();\n     boolean isQName = nType == Token.NAME || nType == Token.GETPROP;\n-    boolean isObjKey = NodeUtil.isObjectLitKey(n, n.getParent());\n+    boolean isObjKey = NodeUtil.isObjectLitKey(n);\n     Preconditions.checkState(isObjKey || isQName);\n     if (isQName) {\n       for (int i = 1; i < depth && n.hasChildren(); i++) {\n     Node parent = ref.node.getParent();\n     Node gramps = parent.getParent();\n     Node greatGramps = gramps.getParent();\n-    Node greatGreatGramps = greatGramps.getParent();\n \n     if (rvalue != null && rvalue.isFunction()) {\n       checkForHosedThisReferences(rvalue, refName.docInfo, refName);\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n     Preconditions.checkState(currentTracer != null,\n         \"Tracer should not be null at the end of a pass.\");\n     stopTracer(currentTracer, currentPassName);\n-    String passToCheck = currentPassName;\n     currentPassName = null;\n     currentTracer = null;\n \n--- a/src/com/google/javascript/jscomp/CrossModuleCodeMotion.java\n+++ b/src/com/google/javascript/jscomp/CrossModuleCodeMotion.java\n     final JSModule module;\n     final Node node;\n \n-    Declaration(JSModule module, Node node, Node parent, Node gramps) {\n+    Declaration(JSModule module, Node node) {\n       this.module = module;\n       this.node = node;\n     }\n       case Token.VAR:\n         if (canMoveValue(name.getFirstChild())) {\n           return info.addDeclaration(\n-              new Declaration(t.getModule(), name, parent, gramps));\n+              new Declaration(t.getModule(), name));\n         }\n         return false;\n \n       case Token.FUNCTION:\n         if (NodeUtil.isFunctionDeclaration(parent)) {\n           return info.addDeclaration(\n-              new Declaration(t.getModule(), name, parent, gramps));\n+              new Declaration(t.getModule(), name));\n         }\n         return false;\n \n             if (currentParent.isExprResult() &&\n                 canMoveValue(current.getLastChild())) {\n               return info.addDeclaration(\n-                  new Declaration(t.getModule(), current, currentParent,\n-                      currentParent.getParent()));\n+                  new Declaration(t.getModule(), current));\n             }\n           } else {\n             return false;\n           if (relationship != null &&\n               name.getString().equals(relationship.subclassName)) {\n             return info.addDeclaration(\n-                new Declaration(t.getModule(), parent, gramps,\n-                    gramps.getParent()));\n+                new Declaration(t.getModule(), parent));\n           }\n         }\n         return false;\n--- a/src/com/google/javascript/jscomp/DefinitionsRemover.java\n+++ b/src/com/google/javascript/jscomp/DefinitionsRemover.java\n       }\n     } else if (parent.isAssign() && parent.getFirstChild() == n) {\n       return new AssignmentDefinition(parent, isExtern);\n-    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n+    } else if (NodeUtil.isObjectLitKey(n)) {\n       return new ObjectLiteralPropertyDefinition(parent, n, n.getFirstChild(),\n           isExtern);\n     } else if (parent.isParamList()) {\n       }\n     } else if (parent.isAssign() && parent.getFirstChild() == n) {\n       return true;\n-    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n+    } else if (NodeUtil.isObjectLitKey(n)) {\n       return true;\n     } else if (parent.isParamList()) {\n       return true;\n--- a/src/com/google/javascript/jscomp/DisambiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/DisambiguateProperties.java\n       addInvalidatingType(mis.typeB, mis.src);\n     }\n \n-    StaticScope<T> scope = typeSystem.getRootScope();\n     NodeTraversal.traverse(compiler, externs, new FindExternProperties());\n     NodeTraversal.traverse(compiler, root, new FindRenameableProperties());\n     renameProperties();\n       if (type.isUnionType()) {\n         Set<JSType> types = Sets.newHashSet(type);\n         for (JSType alt : type.toMaybeUnionType().getAlternates()) {\n+          // TODO(johnlenz): shouldn't we use \"alt\" here?\n           types.addAll(getTypesToSkipForTypeNonUnion(type));\n         }\n         return ImmutableSet.copyOf(types);\n--- a/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n+++ b/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n     } else {\n       Node parent = nonconditionalExpr.getParent();\n       boolean needResult = !parent.isExprResult();\n-      Node extractedConditional = extractConditional(\n-          nonconditionalExpr, exprInjectionPoint, needResult);\n+      extractConditional(nonconditionalExpr, exprInjectionPoint, needResult);\n     }\n   }\n \n     }\n \n     // Never try to decompose an object literal key.\n-    Preconditions.checkState(!NodeUtil.isObjectLitKey(n, n.getParent()));\n+    Preconditions.checkState(!NodeUtil.isObjectLitKey(n));\n \n     // Decompose the children in reverse evaluation order.  This simplifies\n     // determining if the any of the children following have side-effects.\n             ? DecompositionType.DECOMPOSABLE\n             : DecompositionType.MOVABLE;\n       }\n-\n-      int parentType = parent.getType();\n \n       if (isConditionalOp(parent)) {\n         // Only the first child is always executed, otherwise it must be\n--- a/src/com/google/javascript/jscomp/ExternExportsPass.java\n+++ b/src/com/google/javascript/jscomp/ExternExportsPass.java\n         return;\n       }\n \n-      /* We must get the JSDocInfo from the function's type since the function\n-       * itself does not have an associated JSDocInfo node.\n-       */\n-      JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();\n-\n       JSType returnType = functionType.getReturnType();\n \n       /* It is OK if a constructor doesn't have a return type */\n--- a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n+++ b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.ControlFlowGraph.AbstractCfgNodeTraversalCallback;\n import com.google.javascript.jscomp.ControlFlowGraph.Branch;\n-import com.google.javascript.jscomp.DataFlowAnalysis.FlowState;\n import com.google.javascript.jscomp.MustBeReachingVariableDef.Definition;\n-import com.google.javascript.jscomp.MustBeReachingVariableDef.MustDef;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;\n import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n         // Not a CFG node.\n         return;\n       }\n-      FlowState<MustDef> state = graphNode.getAnnotation();\n-      final MustDef defs = state.getIn();\n       final Node cfgNode = n;\n       AbstractCfgNodeTraversalCallback gatherCb =\n           new AbstractCfgNodeTraversalCallback() {\n         }\n       }\n \n-      getDefinition(getDefCfgNode(), null);\n-      getNumUseInUseCfgNode(useCfgNode, null);\n+      getDefinition(getDefCfgNode());\n+      getNumUseInUseCfgNode(useCfgNode);\n \n       // Definition was not found.\n       if (def == null) {\n      *\n      * @param n A node that has a corresponding CFG node in the CFG.\n      */\n-    private void getDefinition(Node n, Node parent) {\n+    private void getDefinition(Node n) {\n       AbstractCfgNodeTraversalCallback gatherCb =\n         new AbstractCfgNodeTraversalCallback() {\n \n      * Computes the number of uses of the variable varName and store it in\n      * numUseWithinUseCfgNode.\n      */\n-    private void getNumUseInUseCfgNode(Node n, Node parant) {\n+    private void getNumUseInUseCfgNode(Node n) {\n \n       AbstractCfgNodeTraversalCallback gatherCb =\n           new AbstractCfgNodeTraversalCallback() {\n--- a/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\n \n     // Add temp names for arguments that don't have named parameters in the\n     // called function.\n-    int anonArg = 0;\n     while (cArg != null) {\n       String uniquePlaceholder =\n         getUniqueAnonymousParameterName(safeNameIdSupplier);\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n     Set<String> allJsDocParams = (info == null) ?\n         Sets.<String>newHashSet() :\n         Sets.newHashSet(info.getParameterNames());\n-    boolean foundTemplateType = false;\n     boolean isVarArgs = false;\n     for (Node arg : argsParent.children()) {\n       String argumentName = arg.getString();\n--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n         }\n       }\n \n-      if (parent != null && NodeUtil.isObjectLitKey(n, parent)) {\n+      if (parent != null && NodeUtil.isObjectLitKey(n)) {\n         // Object literal keys have no prefix that's referenced directly per\n         // key, so we're done.\n         return true;\n     boolean isSimpleStubDeclaration() {\n       if (getRefs().size() == 1) {\n         Ref ref = refs.get(0);\n-        JSDocInfo info = ref.node.getJSDocInfo();\n         if (ref.node.getParent() != null &&\n             ref.node.getParent().isExprResult()) {\n           return true;\n--- a/src/com/google/javascript/jscomp/IgnoreCajaProperties.java\n+++ b/src/com/google/javascript/jscomp/IgnoreCajaProperties.java\n         Node tmp = IR.name(\n             \"JSCompiler_IgnoreCajaProperties_\" + counter++);\n         n.addChildToFront(IR.var(tmp));\n-        Node assignment;\n         Node ifBody;\n \n         // Construct the body of the if statement.\n--- a/src/com/google/javascript/jscomp/InlineFunctions.java\n+++ b/src/com/google/javascript/jscomp/InlineFunctions.java\n       return;  // Nothing left to do.\n     }\n     resolveInlineConflicts();\n-    decomposeExpressions(fnNames);\n+    decomposeExpressions();\n     NodeTraversal.traverse(compiler, root,\n         new CallVisitor(\n             fns, anonFns, new Inline(injector, specializationState)));\n       String fnName = fn.getName();\n       Node fnNode = fs.getSafeFnNode();\n \n-      Node newCode = injector.inline(t, callNode, fnName, fnNode, mode);\n+      injector.inline(t, callNode, fnName, fnNode, mode);\n       t.getCompiler().reportCodeChange();\n       t.getCompiler().addToDebugLog(\"Inlined function: \" + fn.getName());\n     }\n    * For any call-site that needs it, prepare the call-site for inlining\n    * by rewriting the containing expression.\n    */\n-  private void decomposeExpressions(Set<String> fnNames) {\n-    ExpressionDecomposer decomposer = new ExpressionDecomposer(\n-        compiler, compiler.getUniqueNameIdSupplier(), fnNames);\n-\n+  private void decomposeExpressions() {\n     for (FunctionState fs : fns.values()) {\n       if (fs.canInline()) {\n         for (Reference ref : fs.getReferences()) {\n--- a/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n+++ b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n           // that it refers to, since they will have been moved around.\n           staleVars.add(v);\n \n-          Reference declaration = referenceInfo.references.get(0);\n           Reference init = referenceInfo.getInitializingReference();\n \n           // Split up the object into individual variables if the object\n           // is never referenced directly in full.\n-          splitObject(v, declaration, init, referenceInfo);\n+          splitObject(v, init, referenceInfo);\n         }\n       }\n     }\n      * Splits up the object literal into individual variables, and\n      * updates all uses.\n      */\n-    private void splitObject(Var v, Reference declaration,\n-                             Reference init,\n+    private void splitObject(Var v, Reference init,\n                              ReferenceCollection referenceInfo) {\n       // First figure out the FULL set of possible keys, so that they\n       // can all be properly set as necessary.\n--- a/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java\n+++ b/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java\n         } else {\n           // for(x in y) {...}\n           Node lhs = n.getFirstChild();\n-          Node rhs = lhs.getNext();\n           if (lhs.isVar()) {\n             // for(var x in y) {...}\n             lhs = lhs.getLastChild();\n--- a/src/com/google/javascript/jscomp/MarkNoSideEffectCalls.java\n+++ b/src/com/google/javascript/jscomp/MarkNoSideEffectCalls.java\n         List<Node> nameNodes = Lists.newArrayList();\n         nameNodes.add(node.getFirstChild());\n \n-        Node nameNode = null;\n-\n         if (parent.isName()) {\n           Node gramp = parent.getParent();\n           if (gramp.isVar() &&\n--- a/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java\n+++ b/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java\n           resultMap.put(var, null);\n           continue;\n         }\n-\n-        Node aNode = aDef.node;\n \n         if (b.reachingDef.containsKey(var)) {\n           Definition bDef = b.reachingDef.get(var);\n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n             JsName nameInfo = getName(nameNode.getString(), true);\n             recordSet(nameInfo.name, nameNode);\n           }\n-        } else if (NodeUtil.isObjectLitKey(n, parent)) {\n+        } else if (NodeUtil.isObjectLitKey(n)) {\n           NameInformation ns = createNameInformation(t, n);\n           if (ns != null) {\n             recordSet(ns.name, n);\n       // can be an alias to global object.\n       // Here we add a alias to the general \"global\" object\n       // to act as a placeholder for the actual (unnamed) value.\n-      if (maybeHiddenAlias(name, n)) {\n+      if (maybeHiddenAlias(n)) {\n         recordAlias(name, WINDOW);\n       }\n \n      * prevent the removal of the function and its dependent values, but won't\n      * prevent the alias' removal.\n      */\n-    private boolean maybeHiddenAlias(String name, Node n) {\n+    private boolean maybeHiddenAlias(Node n) {\n       Node parent = n.getParent();\n       if (NodeUtil.isVarOrSimpleAssignLhs(n, parent)) {\n         Node rhs = (parent.isVar())\n           name = \"\";\n         }\n         rootNameNode = rootNameNode.getFirstChild();\n-      } else if (NodeUtil.isObjectLitKey(\n-          rootNameNode, rootNameNode.getParent())) {\n+      } else if (NodeUtil.isObjectLitKey(rootNameNode)) {\n         name = \".\" + rootNameNode.getString() + name;\n \n         // Check if this is an object literal assigned to something.\n--- a/src/com/google/javascript/jscomp/NameReferenceGraphConstruction.java\n+++ b/src/com/google/javascript/jscomp/NameReferenceGraphConstruction.java\n         // we're probably going to get an unknown type here.\n         JSType type = getType(root);\n \n-        Node gParent = parent.getParent();\n-        Node ggParent = gParent.getParent();\n         if (parent.isAssign() &&\n             NodeUtil.isPrototypeProperty(parent.getFirstChild())) {\n           pushContainingFunction(\n               recordPrototypePropDefinition(t, parent.getFirstChild(), type,\n-                  parent, gParent, ggParent));\n+                  parent));\n         } else {\n           pushContainingFunction(\n               recordStaticNameDefinition(\n-                t, name, type, root, parent, gParent, root.getLastChild()));\n+                t, name, type, root, root.getLastChild()));\n         }\n       }\n     }\n               rhs.isGetProp()) {\n             if (NodeUtil.isPrototypeProperty(lhs)) {\n               Name name = recordPrototypePropDefinition(\n-                  t, lhs, getType(rhs), n, parent, parent.getParent());\n+                  t, lhs, getType(rhs), n);\n               name.setAliased(true);\n             }\n           }\n     }\n \n     private Name recordStaticNameDefinition(NodeTraversal t, String name,\n-        JSType type, Node n, Node parent, Node gParent, Node rValue) {\n+        JSType type, Node n, Node rValue) {\n       if (getNamedContainingFunction() != graph.MAIN) {\n         // TODO(user): if A.B() defines A.C(), there is a dependence from\n         // A.C() -> A.B(). However, this is not important in module code motion\n       if (type.isConstructor()) {\n         return recordClassConstructorOrInterface(\n             name, type.toMaybeFunctionType(),\n-            n, parent, parent.getParent(), rValue);\n+            n, rValue);\n       } else {\n         Name symbol = graph.defineNameIfNotExists(name, isExtern);\n         symbol.setType(type);\n      */\n     private Name recordPrototypePropDefinition(\n         NodeTraversal t, Node qName, JSType type,\n-        @Nullable Node assign, @Nullable Node parent, @Nullable Node gParent) {\n+        @Nullable Node assign) {\n       JSType constructor = getType(NodeUtil.getPrototypeClassName(qName));\n       FunctionType classType = null;\n       String className = null;\n       }\n       // In case we haven't seen the function yet.\n       recordClassConstructorOrInterface(\n-          className, classType, null, null, null, null);\n+          className, classType, null, null);\n \n       String qNameStr = className + \".prototype.\" +\n           NodeUtil.getPrototypePropertyName(qName);\n      * the properties and prototype properties of this name in the graph.\n      */\n     private Name recordClassConstructorOrInterface(\n-        String name, FunctionType type, @Nullable Node n, @Nullable Node parent,\n-        @Nullable Node gParent, @Nullable Node rhs) {\n+        String name, FunctionType type, @Nullable Node n, @Nullable Node rhs) {\n       Preconditions.checkArgument(type.isConstructor() || type.isInterface());\n       Name symbol = graph.defineNameIfNotExists(name, isExtern);\n       if (rhs != null) {\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n   static String arrayToString(Node literal) {\n     Node first = literal.getFirstChild();\n     StringBuilder result = new StringBuilder();\n-    int nextSlot = 0;\n-    int nextSkipSlot = 0;\n     for (Node n = first; n != null; n = n.getNext()) {\n       String childValue = getArrayElementStringValue(n);\n       if (childValue == null) {\n         result.append(',');\n       }\n       result.append(childValue);\n-\n-      nextSlot++;\n     }\n     return result.toString();\n   }\n    * (e.g. key1 in {key1: value1, key2: value2}).\n    *\n    * @param node A node\n-   * @param parent The node's parent\n-   */\n-  static boolean isObjectLitKey(Node node, Node parent) {\n+   */\n+  static boolean isObjectLitKey(Node node) {\n     switch (node.getType()) {\n       case Token.STRING_KEY:\n       case Token.GETTER_DEF:\n       CodingConvention convention, Node node, Node parent) {\n     if (parent.isGetProp() && node == parent.getLastChild()) {\n       return convention.isConstantKey(node.getString());\n-    } else if (isObjectLitKey(node, parent)) {\n+    } else if (isObjectLitKey(node)) {\n       return convention.isConstantKey(node.getString());\n     } else if (node.isName()) {\n       return convention.isConstant(node.getString());\n         return getBestJSDocInfo(parent);\n       } else if (parent.isAssign()) {\n         return parent.getJSDocInfo();\n-      } else if (isObjectLitKey(parent, parent.getParent())) {\n+      } else if (isObjectLitKey(parent)) {\n         return parent.getJSDocInfo();\n       } else if (parent.isFunction()) {\n         return parent.getJSDocInfo();\n       return parent;\n     } else if (parent.isAssign()) {\n       return parent.getFirstChild();\n-    } else if (isObjectLitKey(parent, parent.getParent())) {\n+    } else if (isObjectLitKey(parent)) {\n       return parent;\n     } else if (\n         (parent.isHook() && parent.getFirstChild() != n) ||\n     if (lValue == null || lValue.getParent() == null) {\n       return null;\n     }\n-    if (isObjectLitKey(lValue, lValue.getParent())) {\n+    if (isObjectLitKey(lValue)) {\n       return getBestLValue(lValue.getParent());\n     } else if (isGet(lValue)) {\n       return lValue.getFirstChild();\n     if (lValue == null || lValue.getParent() == null) {\n       return null;\n     }\n-    if (isObjectLitKey(lValue, lValue.getParent())) {\n+    if (isObjectLitKey(lValue)) {\n       Node owner = getBestLValue(lValue.getParent());\n       if (owner != null) {\n         String ownerName = getBestLValueName(owner);\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n \n     @Override\n     public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-      doStatementNormalizations(t, n, parent);\n+      doStatementNormalizations(t, n);\n \n       return true;\n     }\n       // There are only two cases where a string token\n       // may be a variable reference: The right side of a GETPROP\n       // or an OBJECTLIT key.\n-      boolean isObjLitKey = NodeUtil.isObjectLitKey(n, parent);\n+      boolean isObjLitKey = NodeUtil.isObjectLitKey(n);\n       boolean isProperty = isObjLitKey ||\n           (parent.isGetProp() &&\n            parent.getLastChild() == n);\n      * Do normalizations that introduce new siblings or parents.\n      */\n     private void doStatementNormalizations(\n-        NodeTraversal t, Node n, Node parent) {\n+        NodeTraversal t, Node n) {\n       if (n.isLabel()) {\n         normalizeLabels(n);\n       }\n--- a/src/com/google/javascript/jscomp/OptimizeParameters.java\n+++ b/src/com/google/javascript/jscomp/OptimizeParameters.java\n    * @return true if a parameter has been removed.\n    */\n   private boolean eliminateParamsAfter(Node function, int argIndex) {\n-    boolean paramRemoved = false;\n-\n     Node formalArgPtr = function.getFirstChild().getNext().getFirstChild();\n     while (argIndex != 0 && formalArgPtr != null) {\n       formalArgPtr = formalArgPtr.getNext();\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n   }\n \n   private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n-    Node parent = n.getParent();\n     // If GETPROP/GETELEM is used as assignment target the array literal is\n     // acting as a temporary we can't fold it here:\n     //    \"[][0] += 1\"\n--- a/src/com/google/javascript/jscomp/PhaseOptimizer.java\n+++ b/src/com/google/javascript/jscomp/PhaseOptimizer.java\n           \"Already a pass with name '%s' in this loop\", name);\n       myNames.add(name);\n       myPasses.add(new NamedPass(factory));\n-    }\n-\n-    /**\n-     * Gets the pass names, in order.\n-     */\n-    private List<String> getPassOrder() {\n-      List<String> order = Lists.newArrayList();\n-      for (NamedPass pass : myPasses) {\n-        order.add(pass.name);\n-      }\n-      return order;\n     }\n \n     @Override\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n         break;\n \n       case Token.EXPR_RESULT:\n-        handleTypedefDefinition(t, n, parent);\n+        handleTypedefDefinition(t, n);\n         break;\n \n       case Token.FUNCTION:\n    * @param n EXPR_RESULT node.\n    */\n   private void handleTypedefDefinition(\n-      NodeTraversal t, Node n, Node parent) {\n+      NodeTraversal t, Node n) {\n     JSDocInfo info = n.getFirstChild().getJSDocInfo();\n     if (t.inGlobalScope() && info != null && info.hasTypedefType()) {\n       String name = n.getFirstChild().getQualifiedName();\n--- a/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n+++ b/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n         FunctionType functionType = JSType.toMaybeFunctionType(jstype);\n         if (functionType != null) {\n           JSType jstypeReturn = functionType.getReturnType();\n-          if (isLocalValueType(jstypeReturn, true)) {\n+          if (isLocalValueType(jstypeReturn)) {\n             knownLocalResult = true;\n           }\n         }\n     /**\n      * @return Whether the jstype is something known to be a local value.\n      */\n-    private boolean isLocalValueType(JSType jstype, boolean recurse) {\n+    private boolean isLocalValueType(JSType jstype) {\n       Preconditions.checkNotNull(jstype);\n       JSType subtype =  jstype.getGreatestSubtype(\n           compiler.getTypeRegistry().getNativeType(JSTypeNative.OBJECT_TYPE));\n             // null or undefined. We don't need to worry about this with a\n             // direct method call because null and undefined don't have any\n             // properties.\n-            String name = objectNode.getString();\n \n             // TODO(nicksantos): Turn this back on when locals-tracking\n             // is fixed. See testLocalizedSideEffects11.\n--- a/src/com/google/javascript/jscomp/RemoveTryCatch.java\n+++ b/src/com/google/javascript/jscomp/RemoveTryCatch.java\n           break;\n \n         case Token.RETURN:\n-          boolean isInTryBlock = false;\n           for (Node anc = parent;\n                anc != null && !anc.isFunction();\n                anc = anc.getParent()) {\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n         if (isModifiableCallSite(site)) {\n           Node arg = getArgumentForCallOrNewOrDotCall(site, argIndex);\n           if (arg != null) {\n-            Node argParent = arg.getParent();\n             // Even if we can't change the signature in general we can always\n             // remove an unused value off the end of the parameter list.\n             if (canModifyAllSites\n    * assignments to those variables as well.\n    */\n   private void removeUnreferencedVars() {\n-    CodingConvention convention = codingConvention;\n-\n     for (Iterator<Var> it = maybeUnreferenced.iterator(); it.hasNext(); ) {\n       Var var = it.next();\n \n--- a/src/com/google/javascript/jscomp/RenameVars.java\n+++ b/src/com/google/javascript/jscomp/RenameVars.java\n     }\n \n     // Rename the locals!\n-    int count = 0;\n     for (Node n : localNameNodes) {\n       String newName = getNewLocalName(n);\n       if (newName != null) {\n         n.setString(newName);\n         changed = true;\n       }\n-      count++;\n     }\n \n     if (changed) {\n--- a/src/com/google/javascript/jscomp/ScopedAliases.java\n+++ b/src/com/google/javascript/jscomp/ScopedAliases.java\n       Scope scope = t.getScope();\n       for (Var v : scope.getVarIterable()) {\n         Node n = v.getNode();\n-        int type = n.getType();\n         Node parent = n.getParent();\n         if (parent.isVar() &&\n             n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n--- a/src/com/google/javascript/jscomp/ShadowVariables.java\n+++ b/src/com/google/javascript/jscomp/ShadowVariables.java\n         }\n \n         // Try to look for the best shadow for the current candidate.\n-        Assignment bestShadow = findBestShadow(s, var);\n+        Assignment bestShadow = findBestShadow(s);\n         if (bestShadow == null) {\n           continue;\n         }\n      * @returns An assignment that can be used as a shadow for a local variable\n      *     in the scope defined by curScopeRoot.\n      */\n-    private Assignment findBestShadow(Scope curScope, Var candidate) {\n+    private Assignment findBestShadow(Scope curScope) {\n       // Search for the candidate starting from the most used local.\n       for (Assignment assignment : varsByFrequency) {\n         if (assignment.oldName.startsWith(RenameVars.LOCAL_VAR_PREFIX)) {\n--- a/src/com/google/javascript/jscomp/SimpleDefinitionFinder.java\n+++ b/src/com/google/javascript/jscomp/SimpleDefinitionFinder.java\n         return parent;\n       } else if (parent.isAssign()) {\n         return parent.getFirstChild();\n-      } else if (NodeUtil.isObjectLitKey(parent, parent.getParent())) {\n+      } else if (NodeUtil.isObjectLitKey(parent)) {\n         return parent;\n       }\n     }\n--- a/src/com/google/javascript/jscomp/SourceMap.java\n+++ b/src/com/google/javascript/jscomp/SourceMap.java\n             || node.isFunction()\n             || node.isName()\n             || NodeUtil.isGet(node)\n-            || NodeUtil.isObjectLitKey(node, node.getParent())\n+            || NodeUtil.isObjectLitKey(node)\n             || (node.isString() && NodeUtil.isGet(node.getParent()));\n       }\n     };\n--- a/src/com/google/javascript/jscomp/SpecializeModule.java\n+++ b/src/com/google/javascript/jscomp/SpecializeModule.java\n \n       original.removeChildren();\n \n-      List<Node> specializedChildren = Lists.newLinkedList();\n-\n       while (specialized.getFirstChild() != null) {\n         original.addChildToBack(specialized.removeFirstChild());\n       }\n          // anything with prototype property requires no dummy declaration\n          // fix-ups afterward.\n          if (block != null) {\n-           Node originalRoot = specializedInputRootsByOriginal.get(block);\n            block.addChildrenToBack(originalInfo.generateDummyDeclaration());\n          }\n        }\n--- a/src/com/google/javascript/jscomp/StripCode.java\n+++ b/src/com/google/javascript/jscomp/StripCode.java\n       Node key = n.getFirstChild();\n       while (key != null) {\n         if (isStripName(key.getString())) {\n-          Node value = key.getFirstChild();\n           Node next = key.getNext();\n           n.removeChild(key);\n           key = next;\n--- a/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\n       scope = new Scope(parent, n);\n     }\n \n-    scanRoot(n, parent);\n+    scanRoot(n);\n \n     inputId = null;\n     Scope returnedScope = scope;\n     return returnedScope;\n   }\n \n-  private void scanRoot(Node n, Scope parent) {\n+  private void scanRoot(Node n) {\n     if (n.isFunction()) {\n       if (inputId == null) {\n         inputId = NodeUtil.getInputId(n);\n       }\n \n       // Body\n-      scanVars(body, n);\n+      scanVars(body);\n     } else {\n       // It's the global block\n       Preconditions.checkState(scope.getParent() == null);\n-      scanVars(n, null);\n+      scanVars(n);\n     }\n   }\n \n   /**\n    * Scans and gather variables declarations under a Node\n    */\n-  private void scanVars(Node n, Node parent) {\n+  private void scanVars(Node n) {\n     switch (n.getType()) {\n       case Token.VAR:\n         // Declare all variables. e.g. var x = 1, y, z;\n         final Node block = var.getNext();\n \n         declareVar(var);\n-        scanVars(block, n);\n+        scanVars(block);\n         return;  // only one child to scan\n \n       case Token.SCRIPT:\n       for (Node child = n.getFirstChild();\n            child != null;) {\n         Node next = child.getNext();\n-        scanVars(child, n);\n+        scanVars(child);\n         child = next;\n       }\n     }\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n     JSType leftType = getJSType(lvalue);\n     if (lvalue.isQualifiedName()) {\n       // variable with inferred type case\n-      JSType rvalueType = getJSType(assign.getLastChild());\n       Var var = t.getScope().getVar(lvalue.getQualifiedName());\n       if (var != null) {\n         if (var.isTypeInferred()) {\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n    */\n   private FlowScope traverseCatch(Node catchNode, FlowScope scope) {\n     Node name = catchNode.getFirstChild();\n-    String varName = name.getString();\n     JSType type;\n     // If the catch expression name was declared in the catch use that type,\n     // otherwise use \"unknown\".\n         NodeUtil.getBestLValue(n));\n     for (Node name = n.getFirstChild(); name != null;\n          name = name.getNext()) {\n-      Node value = name.getFirstChild();\n       String memberName = NodeUtil.getObjectLitKeyName(name);\n       if (memberName != null) {\n         JSType rawValueType =  name.getFirstChild().getJSType();\n       fnType = n.getFirstChild().getJSType().toMaybeFunctionType();\n     }\n     updateTypeOfParameters(n, fnType);\n-    updateBind(n, fnType);\n+    updateBind(n);\n   }\n \n   /**\n    * When \"bind\" is called on a function, we infer the type of the returned\n    * \"bound\" function by looking at the number of parameters in the call site.\n    */\n-  private void updateBind(Node n, FunctionType fnType) {\n+  private void updateBind(Node n) {\n     CodingConvention.Bind bind =\n         compiler.getCodingConvention().describeFunctionBind(n, true);\n     if (bind == null) {\n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n     Var newVar = var;\n     boolean allowDupe = false;\n     if (n.isGetProp() ||\n-        NodeUtil.isObjectLitKey(n, parent)) {\n+        NodeUtil.isObjectLitKey(n)) {\n       JSDocInfo info = n.getJSDocInfo();\n       if (info == null) {\n         info = parent.getJSDocInfo();\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n \n     @Override\n     public void visit(NodeTraversal t, Node node, Node parent) {\n-      Node nameNode = null;\n       switch (node.getType()) {\n         case Token.VAR:\n           for (Node child = node.getFirstChild();\n \n       switch (n.getType()) {\n         case Token.CALL:\n-          checkForClassDefiningCalls(t, n, parent);\n+          checkForClassDefiningCalls(t, n);\n           checkForCallingConventionDefiningCalls(n, delegateCallingConventions);\n           break;\n \n \n         if (keyType != null && objLitType != null && declareOnOwner) {\n           // Declare this property on its object literal.\n-          boolean isExtern = keyNode.isFromExterns();\n           objLitType.defineDeclaredProperty(memberName, keyType, keyNode);\n         }\n       }\n      * Extracts type information from either the {@code @type} tag or from\n      * the {@code @return} and {@code @param} tags.\n      */\n-    private JSType getDeclaredTypeInAnnotation(String sourceName,\n-        Node node, JSDocInfo info) {\n+    private JSType getDeclaredTypeInAnnotation(Node node, JSDocInfo info) {\n       JSType jsType = null;\n-      Node objNode =\n-          node.isGetProp() ? node.getFirstChild() :\n-          NodeUtil.isObjectLitKey(node, node.getParent()) ? node.getParent() :\n-          null;\n       if (info != null) {\n         if (info.hasType()) {\n           jsType = info.getType().evaluate(scope, typeRegistry);\n         return true;\n       }\n       if (lValue != null &&\n-          NodeUtil.isObjectLitKey(lValue, lValue.getParent())) {\n+          NodeUtil.isObjectLitKey(lValue)) {\n         return false;\n       }\n       return scope.isGlobal() || !type.isReturnTypeInferred();\n         Node fnRoot = isFnLiteral ? rValue : null;\n         Node parametersNode = isFnLiteral ?\n             rValue.getFirstChild().getNext() : null;\n-        Node fnBlock = isFnLiteral ? parametersNode.getNext() : null;\n \n         if (info != null && info.hasType()) {\n           JSType type = info.getType().evaluate(scope, typeRegistry);\n \n       // The input may be null if we are working with a AST snippet. So read\n       // the extern info from the node.\n-      boolean isExtern = n.isFromExterns();\n       Var newVar = null;\n \n       // declared in closest scope?\n     private JSType getDeclaredType(String sourceName, JSDocInfo info,\n         Node lValue, @Nullable Node rValue) {\n       if (info != null && info.hasType()) {\n-        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n+        return getDeclaredTypeInAnnotation(lValue, info);\n       } else if (rValue != null && rValue.isFunction() &&\n           shouldUseFunctionLiteralType(\n               JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {\n \n       // Check if this is constant, and if it has a known type.\n       if (isConstantSymbol(info, lValue)) {\n-        JSType knownType = null;\n         if (rValue != null) {\n           JSDocInfo rValueInfo = rValue.getJSDocInfo();\n           if (rValueInfo != null && rValueInfo.hasType()) {\n         }\n       }\n \n-      return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n+      return getDeclaredTypeInAnnotation(lValue, info);\n     }\n \n     private FunctionType getFunctionType(@Nullable Var v) {\n      * Because JS has no 'native' syntax for defining classes,\n      * this is often very coding-convention dependent and business-logic heavy.\n      */\n-    private void checkForClassDefiningCalls(\n-        NodeTraversal t, Node n, Node parent) {\n+    private void checkForClassDefiningCalls(NodeTraversal t, Node n) {\n       SubclassRelationship relationship =\n           codingConvention.getClassesDefinedByCall(n);\n       if (relationship != null) {\n         iifeArgumentNode = functionNode.getNext();\n       }\n \n-      Node body = astParameters.getNext();\n       FunctionType functionType =\n           JSType.toMaybeFunctionType(functionNode.getJSType());\n       if (functionType != null) {\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n         FunctionParamBuilder paramBuilder = new FunctionParamBuilder(this);\n \n         if (current.getType() == Token.PARAM_LIST) {\n-          Node args = current.getFirstChild();\n           for (Node arg = current.getFirstChild(); arg != null;\n                arg = arg.getNext()) {\n             if (arg.getType() == Token.ELLIPSIS) {\n--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n         \"var x = 3;\", \"var y = 5;\", \"var z = 7;\", \"var a = 9;\"});\n \n     StringBuilder builder = new StringBuilder();\n-    lastCommandLineRunner.printModuleGraphJsonTo(\n-        lastCompiler.getModuleGraph(), builder);\n+    lastCommandLineRunner.printModuleGraphJsonTo(builder);\n     assertTrue(builder.toString().indexOf(\"transitive-dependencies\") != -1);\n   }\n \n--- a/test/com/google/javascript/jscomp/NodeUtilTest.java\n+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java\n   }\n \n   private void testIsObjectLiteralKey(Node node, boolean expected) {\n-    assertEquals(expected, NodeUtil.isObjectLitKey(node, node.getParent()));\n+    assertEquals(expected, NodeUtil.isObjectLitKey(node));\n   }\n \n   public void testGetFunctionName1() throws Exception {", "timestamp": 1357676153, "metainfo": ""}