{"sha": "44ebf6062655dc55d0569c80ce7806100435fba0", "log": "Extends TemplatizedType to handle any number of template types, and removes IndexedType. Converts Array and Object to the new generic templatized type system.  R=dimvar,nicksantos,johnlenz,tylerg DELTA=544 (273 added, 143 deleted, 128 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=6255   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeRegistry.OBJECT_ELEMENT_TEMPLATE;\n+import static com.google.javascript.rhino.jstype.JSTypeRegistry.OBJECT_INDEX_TEMPLATE;\n \n import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n import com.google.javascript.rhino.jstype.ModificationVisitor;\n import com.google.javascript.rhino.jstype.ObjectType;\n-import com.google.javascript.rhino.jstype.TemplatizedType;\n+import com.google.javascript.rhino.jstype.TemplateTypeMap;\n import com.google.javascript.rhino.jstype.StaticSlot;\n import com.google.javascript.rhino.jstype.TemplateType;\n import com.google.javascript.rhino.jstype.UnionType;\n               JSType iterKeyType = getNativeType(STRING_TYPE);\n               ObjectType objType = getJSType(obj).dereference();\n               JSType objIndexType = objType == null ?\n-                  null : objType.getIndexType();\n+                  null : objType.getTemplateTypeMap().getTemplateType(OBJECT_INDEX_TEMPLATE);\n               if (objIndexType != null && !objIndexType.isUnknownType()) {\n                 JSType narrowedKeyType =\n                     iterKeyType.getGreatestSubtype(objIndexType);\n             argFunctionType.getParameters(), resolvedTypes);\n       }\n     } else if (paramType.isTemplatizedType()) {\n-      TemplatizedType paramObjectType = paramType.toMaybeTemplatizedType();\n-      JSType typeParameter = paramObjectType.getTemplateType();\n-      Preconditions.checkNotNull(typeParameter);\n-      if (typeParameter != null) {\n-        // @param {Array.<T>}\n-        ObjectType argObjectType = argType\n-            .restrictByNotNullOrUndefined()\n-            .collapseUnion()\n-            .toMaybeTemplatizedType();\n-        if (argObjectType != null && argObjectType.isSubtype(paramType)) {\n-          JSType argTypeParameter = argObjectType.getTemplateType();\n-          Preconditions.checkNotNull(argTypeParameter);\n+      // @param {Array.<T>}\n+      ObjectType referencedParamType = paramType\n+          .toMaybeTemplatizedType()\n+          .getReferencedType();\n+      JSType argObjectType = argType\n+          .restrictByNotNullOrUndefined()\n+          .collapseUnion();\n+\n+      if (argObjectType.isSubtype(referencedParamType)) {\n+        // If the argument type is a subtype of the parameter type, resolve any\n+        // template types amongst their templatized types.\n+        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n+        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n+        for (String key : paramTypeMap.getTemplateKeys()) {\n           maybeResolveTemplatedType(\n-              typeParameter, argTypeParameter, resolvedTypes);\n+              paramTypeMap.getTemplateType(key),\n+              argTypeMap.getTemplateType(key),\n+              resolvedTypes);\n         }\n       }\n     }\n \n   private FlowScope traverseGetElem(Node n, FlowScope scope) {\n     scope = traverseChildren(n, scope);\n-    ObjectType objType = ObjectType.cast(\n-        getJSType(n.getFirstChild()).restrictByNotNullOrUndefined());\n-    if (objType != null) {\n-      JSType type = objType.getTemplateType();\n-      if (type != null) {\n-        n.setJSType(type);\n-      }\n+    JSType type = getJSType(n.getFirstChild()).restrictByNotNullOrUndefined();\n+    TemplateTypeMap typeMap = type.getTemplateTypeMap();\n+    if (typeMap.hasTemplateType(OBJECT_ELEMENT_TEMPLATE)) {\n+      n.setJSType(typeMap.getTemplateType(OBJECT_ELEMENT_TEMPLATE));\n     }\n     return dereferencePointer(n.getFirstChild(), scope);\n   }\n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n import static com.google.javascript.rhino.jstype.JSTypeNative.STRING_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.UNKNOWN_TYPE;\n import static com.google.javascript.rhino.jstype.JSTypeNative.VOID_TYPE;\n+import static com.google.javascript.rhino.jstype.JSTypeRegistry.OBJECT_INDEX_TEMPLATE;\n \n import com.google.common.base.Objects;\n import com.google.common.base.Preconditions;\n       expectStringOrNumber(t, indexNode, indexType, \"property access\");\n     } else {\n       ObjectType dereferenced = objType.dereference();\n-      if (dereferenced != null && dereferenced.getIndexType() != null) {\n-        expectCanAssignTo(t, indexNode, indexType, dereferenced.getIndexType(),\n+      if (dereferenced != null && dereferenced\n+          .getTemplateTypeMap()\n+          .hasTemplateKey(OBJECT_INDEX_TEMPLATE)) {\n+        expectCanAssignTo(t, indexNode, indexType, dereferenced\n+            .getTemplateTypeMap().getTemplateType(OBJECT_INDEX_TEMPLATE),\n             \"restricted index type\");\n       } else if (dereferenced != null && dereferenced.isArrayType()) {\n         expectNumber(t, indexNode, indexType, \"array access\");\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n    * This is a trickier check than pure equality, because it has to properly\n    * handle unknown types. See {@code EquivalenceMethod} for more info.\n    *\n-   * @see <a href=\"http://www.youtube.com/watch?v=_RpSv3HjpEw\">Unknown\n-   *     unknowns</a>\n+   * @see <a href=\"http://www.youtube.com/watch?v=_RpSv3HjpEw\">Unknown unknowns</a>\n    */\n   public final boolean differsFrom(JSType that) {\n     return !checkEquivalenceHelper(that, EquivalenceMethod.DATA_FLOW);\n           that.toMaybeRecordType(), eqMethod);\n     }\n \n-    TemplatizedType thisParamType = toMaybeTemplatizedType();\n-    TemplatizedType thatParamType = that.toMaybeTemplatizedType();\n-    if (thisParamType != null || thatParamType != null) {\n-      // Check if one type is templatized, but the other is not.\n-      boolean paramsMatch = false;\n-      if (thisParamType != null && thatParamType != null) {\n-        paramsMatch = thisParamType.getTemplateType().checkEquivalenceHelper(\n-            thatParamType.getTemplateType(), eqMethod);\n-      } else if (eqMethod == EquivalenceMethod.IDENTITY) {\n-        paramsMatch = false;\n-      } else {\n-        // If one of the type parameters is unknown, but the other is not,\n-        // then we consider these the same for the purposes of data flow\n-        // and invariance.\n-        paramsMatch = true;\n-      }\n-\n-      JSType thisRootType = thisParamType == null ?\n-          this : thisParamType.getReferencedTypeInternal();\n-      JSType thatRootType = thatParamType == null ?\n-          that : thatParamType.getReferencedTypeInternal();\n-      return paramsMatch &&\n-          thisRootType.checkEquivalenceHelper(thatRootType, eqMethod);\n+    if (!getTemplateTypeMap().checkEquivalenceHelper(\n+        that.getTemplateTypeMap(), eqMethod)) {\n+      return false;\n     }\n \n     if (isNominalType() && that.isNominalType()) {\n \n     // templatized types.\n     if (thisType.isTemplatizedType()) {\n-      return thisType.toMaybeTemplatizedType().isTemplatizedSubtypeOf(\n-          thatType);\n+      return !areIncompatibleArrays(thisType, thatType) &&\n+          thisType.toMaybeTemplatizedType().getReferencedType().isSubtype(\n+              thatType);\n+    }\n+    if (thatType.isTemplatizedType()) {\n+      if (!isExemptFromTemplateTypeInvariance(thatType) &&\n+          !thisType.getTemplateTypeMap().checkEquivalenceHelper(\n+              thatType.getTemplateTypeMap(), EquivalenceMethod.IDENTITY)) {\n+        return false;\n+      }\n     }\n \n     // proxy types\n           ((ProxyObjectType) thatType).getReferencedTypeInternal());\n     }\n     return false;\n+  }\n+\n+  /**\n+   * Determines if two types are incompatible Arrays, meaning that their element\n+   * template types are not subtypes of one another.\n+   */\n+  private static boolean areIncompatibleArrays(JSType type1, JSType type2) {\n+    ObjectType type1Obj = type1.toObjectType();\n+    ObjectType type2Obj = type2.toObjectType();\n+    if (type1Obj == null || type2Obj == null) {\n+      return false;\n+    }\n+\n+    if (!\"Array\".equals(type1Obj.getReferenceName()) ||\n+        !\"Array\".equals(type2Obj.getReferenceName())) {\n+      return false;\n+    }\n+\n+    String templateKey = JSTypeRegistry.OBJECT_ELEMENT_TEMPLATE;\n+    JSType elemType1 = type1.getTemplateTypeMap().getTemplateType(templateKey);\n+    JSType elemType2 = type2.getTemplateTypeMap().getTemplateType(templateKey);\n+    return !elemType1.isSubtype(elemType2) && !elemType2.isSubtype(elemType1);\n+  }\n+\n+  /**\n+   * Determines if the specified type is exempt from standard invariant\n+   * templatized typing rules.\n+   */\n+  static boolean isExemptFromTemplateTypeInvariance(JSType type) {\n+    ObjectType objType = type.toObjectType();\n+    return objType == null ||\n+        \"Array\".equals(objType.getReferenceName()) ||\n+        \"Object\".equals(objType.getReferenceName());\n   }\n \n   /**\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n   private static final long serialVersionUID = 1L;\n \n   /**\n+   * The template variable corresponding to the property key type of the built-\n+   * in Javascript object.\n+   */\n+  public static final String OBJECT_INDEX_TEMPLATE = \"Object#Key\";\n+\n+  /**\n+   * The template variable corresponding to the property value type for\n+   * Javascript Objects and Arrays.\n+   */\n+  public static final String OBJECT_ELEMENT_TEMPLATE = \"Object#Element\";\n+\n+  /**\n    * The UnionTypeBuilder caps the maximum number of alternate types it\n    * remembers and then defaults to \"?\" (unknown type). By default this max\n    * is 20, but it's very easy for the same property to appear on more than 20\n     FunctionType OBJECT_FUNCTION_TYPE =\n         new FunctionType(this, \"Object\", null,\n             createArrowType(createOptionalParameters(ALL_TYPE), UNKNOWN_TYPE),\n-            null, null, true, true);\n+            null,\n+            createTemplateTypeMap(ImmutableList.of(\n+                OBJECT_INDEX_TEMPLATE, OBJECT_ELEMENT_TEMPLATE), null),\n+            true, true);\n \n     OBJECT_FUNCTION_TYPE.setPrototype(TOP_LEVEL_PROTOTYPE, null);\n     registerNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE, OBJECT_FUNCTION_TYPE);\n     FunctionType ARRAY_FUNCTION_TYPE =\n       new FunctionType(this, \"Array\", null,\n           createArrowType(createParametersWithVarArgs(ALL_TYPE), null),\n-          null, null, true, true);\n+          null,\n+          createTemplateTypeMap(ImmutableList.of(\n+              OBJECT_ELEMENT_TEMPLATE), null),\n+          true, true);\n     ARRAY_FUNCTION_TYPE.getInternalArrowType().returnType =\n         ARRAY_FUNCTION_TYPE.getInstanceType();\n \n         new TemplateTypeMap(this, templateKeys, templateValues);\n   }\n \n-  /*\n-   * Creates a templatized type.\n+  /**\n+   * Creates a templatized instance of the specified type.  Only ObjectTypes\n+   * can currently be templatized; extend the logic in this function when\n+   * more types can be templatized.\n+   * @param baseType the type to be templatized.\n+   * @param templatizedTypes a list of the template JSTypes. Will be matched by\n+   *     list order to the template keys on the base type.\n    */\n   public TemplatizedType createTemplatizedType(\n-      ObjectType objectType, JSType parameterType) {\n-    return new TemplatizedType(this, objectType, parameterType);\n+      ObjectType baseType, ImmutableList<JSType> templatizedTypes) {\n+    // Only ObjectTypes can currently be templatized; extend this logic when\n+    // more types can be templatized.\n+    return new TemplatizedType(this, baseType, templatizedTypes);\n+  }\n+\n+  /**\n+   * Creates a templatized instance of the specified type.  Only ObjectTypes\n+   * can currently be templatized; extend the logic in this function when\n+   * more types can be templatized.\n+   * @param baseType the type to be templatized.\n+   * @param templatizedTypes a list of the template JSTypes. Will be matched by\n+   *     list order to the template keys on the base type.\n+   */\n+  public TemplatizedType createTemplatizedType(\n+      ObjectType baseType, JSType... templatizedTypes) {\n+    return createTemplatizedType(\n+        baseType, ImmutableList.copyOf(templatizedTypes));\n   }\n \n   /**\n         if ((namedType instanceof ObjectType) &&\n             !(nonNullableTypeNames.contains(n.getString()))) {\n           Node typeList = n.getFirstChild();\n-          if (typeList != null &&\n-              (\"Array\".equals(n.getString()) ||\n-               \"Object\".equals(n.getString()))) {\n-            JSType templateType =\n-                createFromTypeNodesInternal(\n-                    typeList.getLastChild(), sourceName, scope);\n-            namedType = new TemplatizedType(\n-                this, (ObjectType) namedType, templateType);\n-            if (typeList.hasMoreThanOneChild()) {\n-              JSType indexType =\n-                  createFromTypeNodesInternal(\n-                      typeList.getFirstChild(), sourceName, scope);\n-              namedType = new IndexedType(\n-                  this, (ObjectType) namedType, indexType);\n+          int nAllowedTypes =\n+              namedType.getTemplateTypeMap().numUnfilledTemplateKeys();\n+          if (typeList != null && nAllowedTypes > 0) {\n+            // Templatized types.\n+            ImmutableList.Builder<JSType> templateTypes =\n+                ImmutableList.builder();\n+\n+            // Special case for Object, where Object.<X> implies Object.<?,X>.\n+            if (n.getString().equals(\"Object\") &&\n+                typeList.getFirstChild() == typeList.getLastChild()) {\n+              templateTypes.add(getNativeType(UNKNOWN_TYPE));\n             }\n+\n+            int templateNodeIndex = 0;\n+            for (Node templateNode : typeList.getFirstChild().siblings()) {\n+              // Don't parse more templatized type nodes than the type can\n+              // accommodate. This is because some existing clients have\n+              // template annotations on non-templatized classes, for instance:\n+              //   goog.structs.Set.<SomeType>\n+              // The problem in these cases is that the previously-unparsed\n+              // SomeType is not actually a valid type. To prevent these clients\n+              // from seeing unknown type errors, we explicitly don't parse\n+              // these types.\n+              // TODO(user): Address this issue by removing bad template\n+              // annotations on non-templatized classes.\n+              if (++templateNodeIndex > nAllowedTypes) {\n+                break;\n+              }\n+              templateTypes.add(createFromTypeNodesInternal(\n+                  templateNode, sourceName, scope));\n+            }\n+            namedType = createTemplatizedType(\n+                (ObjectType) namedType, templateTypes.build());\n+            Preconditions.checkNotNull(namedType);\n           }\n           return createDefaultObjectUnion(namedType);\n         } else {\n--- a/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\n+++ b/src/com/google/javascript/rhino/jstype/ModificationVisitor.java\n \n package com.google.javascript.rhino.jstype;\n \n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n import com.google.javascript.rhino.Node;\n \n \n   @Override\n   public JSType caseTemplatizedType(TemplatizedType type) {\n-    ObjectType genericType = ObjectType.cast(\n-        type.getReferencedTypeInternal().visit(this));\n-    JSType paramType = type.getTemplateType().visit(this);\n-    if (type.getReferencedTypeInternal() != genericType\n-        || type.getTemplateType() != paramType) {\n-      type = registry.createTemplatizedType(genericType, paramType);\n+    boolean changed = false;\n+    ObjectType beforeBaseType = type.getReferencedType();\n+    ObjectType afterBaseType = ObjectType.cast(beforeBaseType.visit(this));\n+    if (beforeBaseType != afterBaseType) {\n+      changed = true;\n+    }\n+\n+    ImmutableList.Builder<JSType> builder = ImmutableList.builder();\n+    for (JSType beforeTemplateType : type.getTemplateTypes()) {\n+      JSType afterTemplateType = beforeTemplateType.visit(this);\n+      if (beforeTemplateType != afterTemplateType) {\n+        changed = true;\n+      }\n+      builder.add(afterTemplateType);\n+    }\n+\n+    if (changed) {\n+      type = registry.createTemplatizedType(afterBaseType, builder.build());\n     }\n     return type;\n   }\n--- a/src/com/google/javascript/rhino/jstype/ObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ObjectType.java\n import static com.google.javascript.rhino.jstype.TernaryValue.FALSE;\n import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN;\n \n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Sets;\n    * Gets the declared default element type.\n    * @see TemplatizedType\n    */\n-  public JSType getTemplateType() {\n-    return null;\n-  }\n-\n-  /**\n-   * Gets the declared default index type.\n-   * @see IndexedType\n-   */\n-  public JSType getIndexType() {\n+  public ImmutableList<JSType> getTemplateTypes() {\n     return null;\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n \n package com.google.javascript.rhino.jstype;\n \n+import com.google.common.collect.ImmutableList;\n import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n   }\n \n   @Override\n-  public JSType getTemplateType() {\n+  public ImmutableList<JSType> getTemplateTypes() {\n     return referencedObjType == null ? null :\n-        referencedObjType.getTemplateType();\n-  }\n-\n-  @Override\n-  public JSType getIndexType() {\n-    return referencedObjType == null ? null :\n-        referencedObjType.getIndexType();\n+        referencedObjType.getTemplateTypes();\n   }\n \n   @Override\n--- a/src/com/google/javascript/rhino/jstype/TemplatizedType.java\n+++ b/src/com/google/javascript/rhino/jstype/TemplatizedType.java\n \n package com.google.javascript.rhino.jstype;\n \n+import com.google.common.base.Joiner;\n import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n \n /**\n- * An object type with a declared default element type, such as\n+ * An object type with declared template types, such as\n  * <code>Array.<string></code>.\n- *\n- * // TODO(user): Define the subtyping relation for templatized types. Also,\n- * take templatized type into account for equality.\n  *\n  */\n public final class TemplatizedType extends ProxyObjectType {\n   private static final long serialVersionUID = 1L;\n \n-  final JSType templateType;\n+  final ImmutableList<JSType> templateTypes;\n \n   TemplatizedType(\n-      JSTypeRegistry registry, ObjectType objectType, JSType templateType) {\n-    super(registry, objectType);\n-    this.templateType = templateType;\n-  }\n+      JSTypeRegistry registry, ObjectType objectType,\n+      ImmutableList<JSType> templateTypes) {\n+    super(registry, objectType, objectType.getTemplateTypeMap().extendValues(\n+        templateTypes));\n \n-  @Override\n-  public JSType getTemplateType() {\n-    return templateType;\n+    // Cache which template keys were filled, and what JSTypes they were filled\n+    // with.\n+    ImmutableList<String> filledTemplateKeys =\n+        objectType.getTemplateTypeMap().getUnfilledTemplateKeys();\n+    ImmutableList.Builder<JSType> builder = ImmutableList.builder();\n+    for (String filledTemplateKey : filledTemplateKeys) {\n+      builder.add(getTemplateTypeMap().getTemplateType(filledTemplateKey));\n+    }\n+    this.templateTypes = builder.build();\n   }\n \n   @Override\n   String toStringHelper(boolean forAnnotations) {\n-    String result = super.toStringHelper(forAnnotations);\n-    return result + \".<\" + templateType.toStringHelper(forAnnotations) + \">\";\n+    String typeString = super.toStringHelper(forAnnotations);\n+\n+    if (!templateTypes.isEmpty()) {\n+      typeString += \".<\" + Joiner.on(\",\").join(templateTypes) + \">\";\n+    }\n+\n+    return typeString;\n   }\n \n   @Override\n   }\n \n   @Override\n-  public boolean hasAnyTemplateTypesInternal() {\n-    return super.hasAnyTemplateTypes() || templateType.hasAnyTemplateTypes();\n+  public ImmutableList<JSType> getTemplateTypes() {\n+    return templateTypes;\n   }\n \n-  @Override\n+  //@Override\n   public boolean isSubtype(JSType that) {\n     return isSubtypeHelper(this, that);\n-  }\n-\n-  boolean isTemplatizedSubtypeOf(JSType thatType) {\n-    if (thatType.isTemplatizedType()) {\n-      JSType thisParameter = this.templateType;\n-      JSType thatParameter = thatType.toMaybeTemplatizedType().templateType;\n-      // Currently, there is no way to declare a templatized type so we have\n-      // no way to determine if the type parameters are in anyway related.\n-      //\n-      // Right now we fallback to the raw type relationship if the raw types\n-      // are different. This is not great, and we'll figure out a better\n-      // solution later.\n-      if (this.wrapsSameRawType(thatType)) {\n-        return (thisParameter.isSubtype(thatParameter)\n-            || thatParameter.isSubtype(thisParameter));\n-      }\n-    }\n-\n-    return this.getReferencedTypeInternal().isSubtype(thatType);\n   }\n \n   boolean wrapsSameRawType(JSType that) {\n     TemplatizedType that = rawThat.toMaybeTemplatizedType();\n     Preconditions.checkNotNull(that);\n \n-    if (this.templateType.isEquivalentTo(that.templateType)) {\n+    if (getTemplateTypeMap().checkEquivalenceHelper(\n+        that.getTemplateTypeMap(), EquivalenceMethod.INVARIANT)) {\n       return this;\n     }\n \n     // equivalent to the raw type.\n     return getReferencedObjTypeInternal();\n   }\n+\n+  @Override\n+  public TemplateTypeMap getTemplateTypeMap() {\n+    return templateTypeMap;\n+  }\n+\n+  @Override\n+  public boolean hasAnyTemplateTypesInternal() {\n+    return templateTypeMap.hasAnyTemplateTypesInternal();\n+  }\n+\n+  /**\n+   * @return The referenced ObjectType wrapped by this TemplatizedType.\n+   */\n+  public ObjectType getReferencedType() {\n+    return getReferencedObjTypeInternal();\n+  }\n }\n--- a/src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionTypeBuilder.java\n                 TemplatizedType templatizedCurrent = current.toMaybeTemplatizedType();\n \n                 if (templatizedCurrent.wrapsSameRawType(templatizedAlternate)) {\n-                  JSType currentTypeParameter = templatizedCurrent.getTemplateType();\n-                  if (currentTypeParameter.isEquivalentTo(templatizedCurrent)) {\n+                  if (alternate.getTemplateTypeMap().checkEquivalenceHelper(\n+                      current.getTemplateTypeMap(),\n+                      EquivalenceMethod.IDENTITY)) {\n                     // case 8\n                     return this;\n                   } else {\n--- a/src/com/google/javascript/rhino/testing/BaseJSTypeTestCase.java\n+++ b/src/com/google/javascript/rhino/testing/BaseJSTypeTestCase.java\n \n package com.google.javascript.rhino.testing;\n \n+import com.google.common.collect.ImmutableList;\n import com.google.javascript.rhino.JSTypeExpression;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.jstype.FunctionBuilder;\n import com.google.javascript.rhino.jstype.JSTypeNative;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n import com.google.javascript.rhino.jstype.ObjectType;\n+import com.google.javascript.rhino.jstype.RecordTypeBuilder;\n import com.google.javascript.rhino.jstype.TemplatizedType;\n-import com.google.javascript.rhino.jstype.RecordTypeBuilder;\n \n import junit.framework.TestCase;\n \n     return registry.createOptionalType(type);\n   }\n \n-  protected JSType createTemplatizedType(\n-      ObjectType type, JSType typeParameter) {\n-    return registry.createTemplatizedType(type, typeParameter);\n+  protected TemplatizedType createTemplatizedType(\n+      ObjectType baseType, ImmutableList<JSType> templatizedTypes) {\n+    return registry.createTemplatizedType(baseType, templatizedTypes);\n+  }\n+\n+  protected TemplatizedType createTemplatizedType(\n+      ObjectType baseType, JSType... templatizedType) {\n+    return createTemplatizedType(\n+        baseType, ImmutableList.copyOf(templatizedType));\n   }\n \n   /**\n   protected final void assertTypeNotEquals(String msg, JSType a, JSType b) {\n     Asserts.assertTypeNotEquals(msg, a, b);\n   }\n-\n-  protected final TemplatizedType templatize(ObjectType objType, JSType t) {\n-    return registry.createTemplatizedType(objType, t);\n-  }\n }\n--- a/test/com/google/javascript/jscomp/TypeInferenceTest.java\n+++ b/test/com/google/javascript/jscomp/TypeInferenceTest.java\n \n   public void testFor5() {\n     assuming(\"y\", templatize(\n-        getNativeObjectType(ARRAY_TYPE), getNativeType(NUMBER_TYPE)));\n+        getNativeObjectType(ARRAY_TYPE),\n+        ImmutableList.of(getNativeType(NUMBER_TYPE))));\n     inFunction(\n         \"var x = null; for (var i = 0; i < y.length; i++) { x = y[i]; }\");\n     verify(\"x\", createNullableType(NUMBER_TYPE));\n     return registry.getNativeType(t);\n   }\n \n-  private JSType templatize(ObjectType objType, JSType t) {\n+  private JSType templatize(ObjectType objType, ImmutableList<JSType> t) {\n     return registry.createTemplatizedType(objType, t);\n   }\n }\n--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n \n package com.google.javascript.jscomp.parsing;\n \n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.parsing.Config.LanguageMode;\n import com.google.javascript.jscomp.testing.TestErrorReporter;\n import com.google.javascript.rhino.head.ast.AstRoot;\n import com.google.javascript.rhino.head.ast.Comment;\n import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.jstype.JSTypeRegistry;\n import com.google.javascript.rhino.jstype.ObjectType;\n import com.google.javascript.rhino.jstype.SimpleSourceFile;\n import com.google.javascript.rhino.jstype.StaticSourceFile;\n \n   public void testParseTemplatizedType1() throws Exception {\n     JSDocInfo info = parse(\"@type !Array.<number> */\");\n-    assertTypeEquals(templatize(ARRAY_TYPE, NUMBER_TYPE), info.getType());\n+    assertTypeEquals(\n+        createTemplatizedType(ARRAY_TYPE, NUMBER_TYPE), info.getType());\n   }\n \n   public void testParseTemplatizedType2() throws Exception {\n     JSDocInfo info = parse(\"@type {!Array.<number>}*/\");\n-    assertTypeEquals(templatize(ARRAY_TYPE, NUMBER_TYPE), info.getType());\n+    assertTypeEquals(\n+        createTemplatizedType(ARRAY_TYPE, NUMBER_TYPE), info.getType());\n   }\n \n   public void testParseTemplatizedType3() throws Exception {\n     JSDocInfo info = parse(\"@type !Array.<(number,null)>*/\");\n     assertTypeEquals(\n-        templatize(ARRAY_TYPE, createUnionType(NUMBER_TYPE, NULL_TYPE)),\n+        createTemplatizedType(ARRAY_TYPE,\n+            createUnionType(NUMBER_TYPE, NULL_TYPE)),\n         info.getType());\n   }\n \n   public void testParseTemplatizedType4() throws Exception {\n     JSDocInfo info = parse(\"@type {!Array.<(number|null)>}*/\");\n     assertTypeEquals(\n-        templatize(ARRAY_TYPE, createUnionType(NUMBER_TYPE, NULL_TYPE)),\n+        createTemplatizedType(ARRAY_TYPE,\n+            createUnionType(NUMBER_TYPE, NULL_TYPE)),\n         info.getType());\n   }\n \n   public void testParseTemplatizedType5() throws Exception {\n     JSDocInfo info = parse(\"@type {!Array.<Array.<(number|null)>>}*/\");\n     assertTypeEquals(\n-        templatize(ARRAY_TYPE,\n+        createTemplatizedType(ARRAY_TYPE,\n             createUnionType(NULL_TYPE,\n-                templatize(ARRAY_TYPE,\n+                createTemplatizedType(ARRAY_TYPE,\n                     createUnionType(NUMBER_TYPE, NULL_TYPE)))),\n         info.getType());\n   }\n   public void testParseTemplatizedType6() throws Exception {\n     JSDocInfo info = parse(\"@type {!Array.<!Array.<(number|null)>>}*/\");\n     assertTypeEquals(\n-        templatize(ARRAY_TYPE,\n-            templatize(ARRAY_TYPE,\n+        createTemplatizedType(ARRAY_TYPE,\n+            createTemplatizedType(ARRAY_TYPE,\n                 createUnionType(NUMBER_TYPE, NULL_TYPE))),\n         info.getType());\n   }\n   public void testParseTemplatizedType7() throws Exception {\n     JSDocInfo info = parse(\"@type {!Array.<function():Date>}*/\");\n     assertTypeEquals(\n-        templatize(ARRAY_TYPE,\n+        createTemplatizedType(ARRAY_TYPE,\n             registry.createFunctionType(\n                 createUnionType(DATE_TYPE, NULL_TYPE))),\n         info.getType());\n   public void testParseTemplatizedType8() throws Exception {\n     JSDocInfo info = parse(\"@type {!Array.<function():!Date>}*/\");\n     assertTypeEquals(\n-        templatize(ARRAY_TYPE,\n+        createTemplatizedType(ARRAY_TYPE,\n             registry.createFunctionType(DATE_TYPE)),\n         info.getType());\n   }\n   public void testParseTemplatizedType9() throws Exception {\n     JSDocInfo info = parse(\"@type {!Array.<Date|number>}*/\");\n     assertTypeEquals(\n-        templatize(ARRAY_TYPE,\n+        createTemplatizedType(ARRAY_TYPE,\n             createUnionType(DATE_TYPE, NUMBER_TYPE, NULL_TYPE)),\n         info.getType());\n   }\n   public void testParseTemplatizedType10() throws Exception {\n     JSDocInfo info = parse(\"@type {!Array.<Date|number|boolean>}*/\");\n     assertTypeEquals(\n-        templatize(ARRAY_TYPE,\n+        createTemplatizedType(ARRAY_TYPE,\n             createUnionType(DATE_TYPE, NUMBER_TYPE, BOOLEAN_TYPE, NULL_TYPE)),\n         info.getType());\n   }\n   public void testParseTemplatizedType11() throws Exception {\n     JSDocInfo info = parse(\"@type {!Object.<number>}*/\");\n     assertTypeEquals(\n-        templatize(OBJECT_TYPE, NUMBER_TYPE),\n+        createTemplatizedType(\n+            OBJECT_TYPE, ImmutableList.of(UNKNOWN_TYPE, NUMBER_TYPE)),\n         info.getType());\n-    assertParameterTypeEquals(NUMBER_TYPE, info.getType());\n+    assertTemplatizedTypeEquals(\n+        JSTypeRegistry.OBJECT_ELEMENT_TEMPLATE, NUMBER_TYPE, info.getType());\n   }\n \n   public void testParseTemplatizedType12() throws Exception {\n     JSDocInfo info = parse(\"@type {!Object.<string,number>}*/\");\n     assertTypeEquals(\n-        templatize(OBJECT_TYPE, NUMBER_TYPE), info.getType());\n-    assertParameterTypeEquals(NUMBER_TYPE, info.getType());\n-    assertIndexTypeEquals(STRING_TYPE, info.getType());\n+        createTemplatizedType(\n+            OBJECT_TYPE, ImmutableList.of(STRING_TYPE, NUMBER_TYPE)),\n+        info.getType());\n+    assertTemplatizedTypeEquals(\n+        JSTypeRegistry.OBJECT_ELEMENT_TEMPLATE, NUMBER_TYPE, info.getType());\n+    assertTemplatizedTypeEquals(\n+        JSTypeRegistry.OBJECT_INDEX_TEMPLATE, STRING_TYPE, info.getType());\n   }\n \n   public void testParseTemplatizedType13() throws Exception {\n     JSDocInfo info = parse(\"@type !Array.<?> */\");\n-    assertTypeEquals(templatize(ARRAY_TYPE, UNKNOWN_TYPE), info.getType());\n+    assertTypeEquals(\n+        createTemplatizedType(ARRAY_TYPE, UNKNOWN_TYPE), info.getType());\n   }\n \n   public void testParseUnionType1() throws Exception {\n   public void testParseUnionType4() throws Exception {\n     JSDocInfo info = parse(\"@type {(Array.<boolean>,null)}*/\");\n     assertTypeEquals(createUnionType(\n-        templatize(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), info.getType());\n+        createTemplatizedType(\n+            ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), info.getType());\n   }\n \n   public void testParseUnionType5() throws Exception {\n     JSDocInfo info = parse(\"@type {(null, Array.<boolean>)}*/\");\n     assertTypeEquals(createUnionType(\n-        templatize(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), info.getType());\n+        createTemplatizedType(\n+            ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), info.getType());\n   }\n \n   public void testParseUnionType6() throws Exception {\n     JSDocInfo info = parse(\"@type {Array.<boolean>|null}*/\");\n     assertTypeEquals(createUnionType(\n-        templatize(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), info.getType());\n+        createTemplatizedType(\n+            ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), info.getType());\n   }\n \n   public void testParseUnionType7() throws Exception {\n     JSDocInfo info = parse(\"@type {null|Array.<boolean>}*/\");\n     assertTypeEquals(createUnionType(\n-        templatize(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), info.getType());\n+        createTemplatizedType(\n+            ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), info.getType());\n   }\n \n   public void testParseUnionType8() throws Exception {\n     JSDocInfo info = parse(\"@type {null||Array.<boolean>}*/\");\n     assertTypeEquals(createUnionType(\n-        templatize(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), info.getType());\n+        createTemplatizedType(\n+            ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), info.getType());\n   }\n \n   public void testParseUnionType9() throws Exception {\n     JSDocInfo info = parse(\"@type {Array.<boolean>||null}*/\");\n     assertTypeEquals(createUnionType(\n-        templatize(ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), info.getType());\n+        createTemplatizedType(\n+            ARRAY_TYPE, BOOLEAN_TYPE), NULL_TYPE), info.getType());\n   }\n \n   public void testParseUnionType10() throws Exception {\n   public void testParseNullableModifiers2() throws Exception {\n     JSDocInfo info = parse(\"@type {!Array.<string?>}*/\");\n     assertTypeEquals(\n-        templatize(ARRAY_TYPE, createUnionType(STRING_TYPE, NULL_TYPE)),\n+        createTemplatizedType(\n+            ARRAY_TYPE, createUnionType(STRING_TYPE, NULL_TYPE)),\n         info.getType());\n   }\n \n   public void testParseNullableModifiers3() throws Exception {\n     JSDocInfo info = parse(\"@type {Array.<boolean>?}*/\");\n     assertTypeEquals(\n-        createNullableType(templatize(ARRAY_TYPE, BOOLEAN_TYPE)),\n+        createNullableType(createTemplatizedType(ARRAY_TYPE, BOOLEAN_TYPE)),\n         info.getType());\n   }\n \n \n   public void testParseNewline2() throws Exception {\n     JSDocInfo info = parse(\"@type !Array.<\\n* number\\n* > */\");\n-    assertTypeEquals(templatize(ARRAY_TYPE, NUMBER_TYPE), info.getType());\n+    assertTypeEquals(\n+        createTemplatizedType(ARRAY_TYPE, NUMBER_TYPE), info.getType());\n   }\n \n   public void testParseNewline3() throws Exception {\n     JSDocInfo info = parse(\"@type !Array.<(number,\\n* null)>*/\");\n     assertTypeEquals(\n-        templatize(ARRAY_TYPE, createUnionType(NUMBER_TYPE, NULL_TYPE)),\n+        createTemplatizedType(\n+            ARRAY_TYPE, createUnionType(NUMBER_TYPE, NULL_TYPE)),\n         info.getType());\n   }\n \n   public void testParseNewline4() throws Exception {\n     JSDocInfo info = parse(\"@type !Array.<(number|\\n* null)>*/\");\n     assertTypeEquals(\n-        templatize(ARRAY_TYPE, createUnionType(NUMBER_TYPE, NULL_TYPE)),\n+        createTemplatizedType(\n+            ARRAY_TYPE, createUnionType(NUMBER_TYPE, NULL_TYPE)),\n         info.getType());\n   }\n \n   public void testParseNewline5() throws Exception {\n     JSDocInfo info = parse(\"@type !Array.<function(\\n* )\\n* :\\n* Date>*/\");\n     assertTypeEquals(\n-        templatize(ARRAY_TYPE,\n+        createTemplatizedType(ARRAY_TYPE,\n             registry.createFunctionType(\n                 createUnionType(DATE_TYPE, NULL_TYPE))),\n         info.getType());\n     JSDocInfo info =\n         parse(\"@return {null|string|Array.<boolean>}*/\");\n     assertTypeEquals(\n-        createUnionType(templatize(ARRAY_TYPE, BOOLEAN_TYPE),\n+        createUnionType(createTemplatizedType(ARRAY_TYPE, BOOLEAN_TYPE),\n             NULL_TYPE, STRING_TYPE),\n         info.getReturnType());\n   }\n     JSDocInfo info =\n         parse(\"@returns {null|(string,Array.<boolean>)}*/\");\n     assertTypeEquals(\n-        createUnionType(templatize(ARRAY_TYPE, BOOLEAN_TYPE),\n+        createUnionType(createTemplatizedType(ARRAY_TYPE, BOOLEAN_TYPE),\n             NULL_TYPE, STRING_TYPE),\n         info.getReturnType());\n   }\n     JSDocInfo info =\n         parse(\"@return {((null||Array.<boolean>,string),boolean)}*/\");\n     assertTypeEquals(\n-        createUnionType(templatize(ARRAY_TYPE, BOOLEAN_TYPE),\n+        createUnionType(createTemplatizedType(ARRAY_TYPE, BOOLEAN_TYPE),\n             NULL_TYPE, STRING_TYPE, BOOLEAN_TYPE),\n         info.getReturnType());\n   }\n   }\n \n   public void testParseImplementsGenerics() throws Exception {\n-    // we ignore things inside <> for now\n+    // For types that are not templatized, <> annotations are ignored.\n     List<JSTypeExpression> interfaces =\n         parse(\"@implements {SomeInterface.<*>} */\")\n         .getImplementedInterfaces();\n     return new JsDocTokenStream(source, 0);\n   }\n \n-  private void assertParameterTypeEquals(JSType expected, JSTypeExpression te) {\n-    assertEquals(expected, ((ObjectType) resolve(te)).getTemplateType());\n-  }\n-\n-  private void assertIndexTypeEquals(JSType expected, JSTypeExpression te) {\n-    assertEquals(expected, ((ObjectType) resolve(te)).getIndexType());\n+  private void assertTemplatizedTypeEquals(String key, JSType expected,\n+                                           JSTypeExpression te) {\n+    assertEquals(\n+        expected, resolve(te).getTemplateTypeMap().getTemplateType(key));\n   }\n }\n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n         JSType.getLeastSupertype(ARRAY_TYPE, arrayOfString));\n \n     assertEquals(\n-        \"(Array|Object.<string>)\",\n+        \"(Array|Object.<string,?>)\",\n         JSType.getLeastSupertype(objectOfString, ARRAY_TYPE).toString());\n     assertEquals(\n-        \"(Array|Object.<string>)\",\n+        \"(Array|Object.<string,?>)\",\n         JSType.getLeastSupertype(ARRAY_TYPE, objectOfString).toString());\n \n     assertEquals(\n         JSType.getLeastSupertype(arrayOfString, arrayOfString));\n \n     assertEquals(\n-        \"(Array.<string>|Object.<string>)\",\n+        \"(Array.<string>|Object.<string,?>)\",\n         JSType.getLeastSupertype(objectOfString, arrayOfString).toString());\n     assertEquals(\n-        \"(Array.<string>|Object.<string>)\",\n+        \"(Array.<string>|Object.<string,?>)\",\n         JSType.getLeastSupertype(arrayOfString, objectOfString).toString());\n \n     assertTypeEquals(\n     assertTrue(\n         new TemplateType(registry, \"T\")\n             .hasAnyTemplateTypes());\n-    assertFalse(\n-        ARRAY_TYPE\n-            .hasAnyTemplateTypes());\n+    assertFalse(ARRAY_TYPE.hasAnyTemplateTypes());\n \n     assertTrue(\n-        registry.createTemplatizedType(\n-            ARRAY_TYPE, new TemplateType(registry, \"T\"))\n+        createTemplatizedType(ARRAY_TYPE, new TemplateType(registry, \"T\"))\n             .hasAnyTemplateTypes());\n     assertFalse(\n-        registry.createTemplatizedType(\n-            ARRAY_TYPE, STRING_TYPE)\n-            .hasAnyTemplateTypes());\n+        createTemplatizedType(ARRAY_TYPE, STRING_TYPE).hasAnyTemplateTypes());\n \n     assertTrue(\n         new FunctionBuilder(registry)\n         registry.createUnionType(\n             NULL_TYPE, ARRAY_TYPE, STRING_TYPE)\n             .hasAnyTemplateTypes());\n+  }\n+\n+  public void testTemplatizedType() throws Exception {\n+    FunctionType templatizedCtor = registry.createConstructorType(\n+        \"TestingType\", null, null, UNKNOWN_TYPE, ImmutableList.of(\"A\", \"B\"));\n+    JSType templatizedInstance = registry.createTemplatizedType(\n+        templatizedCtor.getInstanceType(),\n+        ImmutableList.of(NUMBER_TYPE, STRING_TYPE));\n+\n+    TemplateTypeMap templateTypeMap = templatizedInstance.getTemplateTypeMap();\n+    assertTrue(templateTypeMap.hasTemplateKey(\"A\"));\n+    assertTrue(templateTypeMap.hasTemplateKey(\"B\"));\n+    assertFalse(templateTypeMap.hasTemplateKey(\"C\"));\n+\n+    assertEquals(NUMBER_TYPE, templateTypeMap.getTemplateType(\"A\"));\n+    assertEquals(STRING_TYPE, templateTypeMap.getTemplateType(\"B\"));\n+    assertEquals(UNKNOWN_TYPE, templateTypeMap.getTemplateType(\"C\"));\n+\n+    assertEquals(\"TestingType.<number,string>\", templatizedInstance.toString());\n+  }\n+\n+  public void testPartiallyTemplatizedType() throws Exception {\n+    FunctionType templatizedCtor = registry.createConstructorType(\n+        \"TestingType\", null, null, UNKNOWN_TYPE, ImmutableList.of(\"A\", \"B\"));\n+    JSType templatizedInstance = registry.createTemplatizedType(\n+        templatizedCtor.getInstanceType(),\n+        ImmutableList.of(NUMBER_TYPE));\n+\n+    TemplateTypeMap templateTypeMap = templatizedInstance.getTemplateTypeMap();\n+    assertTrue(templateTypeMap.hasTemplateKey(\"A\"));\n+    assertTrue(templateTypeMap.hasTemplateKey(\"B\"));\n+    assertFalse(templateTypeMap.hasTemplateKey(\"C\"));\n+\n+    assertEquals(NUMBER_TYPE, templateTypeMap.getTemplateType(\"A\"));\n+    assertEquals(UNKNOWN_TYPE, templateTypeMap.getTemplateType(\"B\"));\n+    assertEquals(UNKNOWN_TYPE, templateTypeMap.getTemplateType(\"C\"));\n+\n+    assertEquals(\"TestingType.<number,?>\", templatizedInstance.toString());\n   }\n \n   public void testCanCastTo() {\n--- a/test/com/google/javascript/rhino/jstype/TemplatizedTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/TemplatizedTypeTest.java\n \n package com.google.javascript.rhino.jstype;\n \n+import com.google.common.collect.ImmutableList;\n import com.google.javascript.rhino.testing.BaseJSTypeTestCase;\n \n public class TemplatizedTypeTest extends BaseJSTypeTestCase {\n   @Override\n   public void setUp() throws Exception {\n     super.setUp();\n-  }\n-\n-  @Override\n-  protected TemplatizedType createTemplatizedType(\n-      ObjectType objectType, JSType templateType) {\n-    return registry.createTemplatizedType(objectType, templateType);\n   }\n \n   /**\n     assertTrue(arrOfNumber.isSubtype(objType));\n     assertFalse(objType.isSubtype(arrOfNumber));\n   }\n+\n+  public void testCustomTemplatizedType() throws Exception {\n+    FunctionType ctor = registry.createConstructorType(\n+        \"Foo\", null, null, null, ImmutableList.of(\"T\", \"U\"));\n+    ObjectType baseType = ctor.getInstanceType();\n+\n+    JSType templatizedType1 = registry.createTemplatizedType(\n+        baseType, ImmutableList.of(STRING_TYPE, NUMBER_TYPE));\n+    JSType templatizedType2 = registry.createTemplatizedType(\n+        baseType, ImmutableList.of(STRING_TYPE, ALL_TYPE));\n+    JSType templatizedType3 = registry.createTemplatizedType(\n+        baseType, ImmutableList.of(STRING_TYPE, UNKNOWN_TYPE));\n+    JSType templatizedType4 = registry.createTemplatizedType(\n+        baseType, ImmutableList.<JSType>of(UNKNOWN_TYPE, UNKNOWN_TYPE));\n+\n+    assertTrue(templatizedType1.isSubtype(baseType));\n+    assertTrue(templatizedType2.isSubtype(baseType));\n+    assertTrue(templatizedType3.isSubtype(baseType));\n+    assertTrue(templatizedType4.isSubtype(baseType));\n+\n+    assertFalse(templatizedType1.isEquivalentTo(baseType));\n+    assertFalse(templatizedType2.isEquivalentTo(baseType));\n+    assertFalse(templatizedType3.isEquivalentTo(baseType));\n+    assertTrue(templatizedType4.isEquivalentTo(baseType));\n+\n+    assertFalse(baseType.isSubtype(templatizedType1));\n+    assertFalse(baseType.isSubtype(templatizedType2));\n+    assertFalse(baseType.isSubtype(templatizedType3));\n+    assertTrue(baseType.isSubtype(templatizedType4));\n+\n+    assertFalse(templatizedType1.isSubtype(templatizedType2));\n+    assertFalse(templatizedType2.isSubtype(templatizedType1));\n+\n+    assertFalse(templatizedType2.isSubtype(templatizedType3));\n+    assertFalse(templatizedType3.isSubtype(templatizedType2));\n+  }\n }", "timestamp": 1360012243, "metainfo": ""}