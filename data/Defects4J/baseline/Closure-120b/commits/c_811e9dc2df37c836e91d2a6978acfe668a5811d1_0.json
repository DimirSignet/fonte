{"sha": "811e9dc2df37c836e91d2a6978acfe668a5811d1", "log": "Improve performance of MinimizeConditions  This approach caches the length estimates in the computed trees rather than recomputing them needlessly. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=46466819", "commit": "\n--- a/src/com/google/javascript/jscomp/PeepholeMinimizeConditions.java\n+++ b/src/com/google/javascript/jscomp/PeepholeMinimizeConditions.java\n    *  provides ways to access minimized versions of both of those ASTs.\n    */\n   static class MinimizedCondition {\n-    private final Node positive;\n-    private final Node negative;\n-\n-    private MinimizedCondition(Node p, Node n) {\n-      Preconditions.checkArgument(p.getParent() == null);\n-      Preconditions.checkArgument(n.getParent() == null);\n+    static class MeasuredNode {\n+      Node node;\n+      int length;\n+\n+      MeasuredNode(Node n, int len) {\n+        node = n;\n+        length = len;\n+      }\n+\n+      private MeasuredNode negate() {\n+        int complementOperator;\n+        switch (node.getType()) {\n+          default:\n+            node = new Node(Token.NOT, node).srcref(node);\n+            length += estimateCostOneLevel(node);\n+            return this;\n+          case Token.NOT:\n+            length -= estimateCostOneLevel(node);\n+            node = node.removeFirstChild();\n+            return this;\n+          // Otherwise a binary operator with a complement.\n+          case Token.EQ:\n+            complementOperator = Token.NE;\n+            break;\n+          case Token.NE:\n+            complementOperator = Token.EQ;\n+            break;\n+          case Token.SHEQ:\n+            complementOperator = Token.SHNE;\n+            break;\n+          case Token.SHNE:\n+            complementOperator = Token.SHEQ;\n+            break;\n+        }\n+        // Clone entire tree and just change operator.\n+        node.setType(complementOperator);\n+        return this;\n+      }\n+\n+      /** Estimate the number of characters in the textual representation of\n+       *  the given node and that will be devoted to negation or parentheses.\n+       *  Since these are the only characters that flipping a condition\n+       *  according to De Morgan's rule can affect, these are the only ones\n+       *  we count.\n+       *  Not nodes are counted by the NOT node itself, whereas\n+       *  parentheses around an expression are counted by the parent node.\n+       *  @param n The node to be checked.\n+       *  @return The number of negations and parentheses in the node.\n+       */\n+      private static int estimateCostOneLevel(Node n) {\n+        int cost = 0;\n+        if (n.isNot()) {\n+          cost++;  // A negation is needed.\n+        }\n+        int parentPrecedence = NodeUtil.precedence(n.getType());\n+        for (Node child = n.getFirstChild();\n+            child != null; child = child.getNext()) {\n+          if (isLowerPrecedence(child, parentPrecedence)) {\n+            cost += 2;  // A pair of parenthesis is needed.\n+          }\n+        }\n+        return cost;\n+      }\n+\n+      MeasuredNode cloneTree() {\n+        return new MeasuredNode(node.cloneTree(), length);\n+      }\n+\n+      static MeasuredNode addNode(int opType, Node infoSource,\n+          MeasuredNode l, MeasuredNode r) {\n+        Node newNode = new Node(opType, l.node, r.node).srcref(infoSource);\n+        int newCost = estimateCostOneLevel(newNode) + l.length + r.length;\n+        return new MeasuredNode(newNode, newCost);\n+      }\n+    }\n+    private final MeasuredNode positive;\n+    private final MeasuredNode negative;\n+\n+    private MinimizedCondition(MeasuredNode p, MeasuredNode n) {\n+      //Preconditions.checkArgument(p.getParent() == null);\n+      //Preconditions.checkArgument(n.getParent() == null);\n       positive = p;\n       negative = n;\n     }\n       switch (n.getType()) {\n         case Token.NOT: {\n           MinimizedCondition subtree = fromConditionNode(n.getFirstChild());\n-          ImmutableSet<Node> positiveAsts = ImmutableSet.of(\n-              negate(subtree.positive.cloneTree()),\n+          ImmutableSet<MeasuredNode> positiveAsts = ImmutableSet.of(\n+              subtree.positive.cloneTree().negate(),\n               subtree.negative.cloneTree());\n-          ImmutableSet<Node> negativeAsts = ImmutableSet.of(\n-              negate(subtree.negative),\n+          ImmutableSet<MeasuredNode> negativeAsts = ImmutableSet.of(\n+              subtree.negative.negate(),\n               subtree.positive);\n           return new MinimizedCondition(\n               Collections.min(positiveAsts, AST_LENGTH_COMPARATOR),\n           int complementType = opType == Token.AND ? Token.OR : Token.AND;\n           MinimizedCondition leftSubtree = fromConditionNode(n.getFirstChild());\n           MinimizedCondition rightSubtree = fromConditionNode(n.getLastChild());\n-          ImmutableSet<Node> positiveAsts = ImmutableSet.of(\n-              new Node(opType,\n+          ImmutableSet<MeasuredNode> positiveAsts = ImmutableSet.of(\n+              MeasuredNode.addNode(opType, n,\n                   leftSubtree.positive.cloneTree(),\n-                  rightSubtree.positive.cloneTree()).srcref(n),\n-              negate(new Node(complementType,\n+                  rightSubtree.positive.cloneTree()),\n+              MeasuredNode.addNode(complementType, n,\n                   leftSubtree.negative.cloneTree(),\n-                  rightSubtree.negative.cloneTree()).srcref(n)));\n-          ImmutableSet<Node> negativeAsts = ImmutableSet.of(\n-              negate(new Node(opType,\n+                  rightSubtree.negative.cloneTree()).negate());\n+          ImmutableSet<MeasuredNode> negativeAsts = ImmutableSet.of(\n+              MeasuredNode.addNode(opType, n,\n                   leftSubtree.positive,\n-                  rightSubtree.positive).srcref(n)),\n-              new Node(complementType,\n+                  rightSubtree.positive).negate(),\n+              MeasuredNode.addNode(complementType, n,\n                   leftSubtree.negative,\n-                  rightSubtree.negative).srcref(n));\n+                  rightSubtree.negative));\n           return new MinimizedCondition(\n               Collections.min(positiveAsts, AST_LENGTH_COMPARATOR),\n               Collections.min(negativeAsts, AST_LENGTH_COMPARATOR));\n         }\n         default:\n-          return new MinimizedCondition(n.cloneTree(), negate(n.cloneTree()));\n+          MeasuredNode pos = new MeasuredNode(n.cloneTree(), 0);\n+          MeasuredNode neg = pos.cloneTree().negate();\n+          return new MinimizedCondition(pos, neg);\n       }\n     }\n \n     Node getNode() {\n-      return positive;\n+      return positive.node;\n     }\n \n     Node getNegatedNode() {\n-      return negative;\n+      return negative.node;\n     }\n \n     int getLength() {\n-      return length(positive);\n+      return positive.length;\n     }\n \n     int getNegativeLength() {\n-      return length(negative);\n+      return negative.length;\n     }\n \n     /** Return the shorter representation of the original condition node.\n      }\n     }\n \n-    private static Node negate(Node node) {\n-      Preconditions.checkArgument(node.getParent() == null);\n-      int complementOperator;\n-      switch (node.getType()) {\n-        default:\n-          return new Node(Token.NOT, node).srcref(node);\n-        case Token.NOT:\n-          return node.removeFirstChild();\n-        // Otherwise a binary operator with a complement.\n-        case Token.EQ:\n-          complementOperator = Token.NE;\n-          break;\n-        case Token.NE:\n-          complementOperator = Token.EQ;\n-          break;\n-        case Token.SHEQ:\n-          complementOperator = Token.SHNE;\n-          break;\n-        case Token.SHNE:\n-          complementOperator = Token.SHEQ;\n-          break;\n-      }\n-      // Clone entire tree and just change operator.\n-      node.setType(complementOperator);\n-      return node;\n-    }\n-\n-    private static final Comparator<Node> AST_LENGTH_COMPARATOR =\n-        new Comparator<Node>() {\n+    private static final Comparator<MeasuredNode> AST_LENGTH_COMPARATOR =\n+        new Comparator<MeasuredNode>() {\n       @Override\n-      public int compare(Node o1, Node o2) {\n-        return length(o1) - length(o2);\n+      public int compare(MeasuredNode o1, MeasuredNode o2) {\n+        return o1.length - o2.length;\n       }\n     };\n-\n-    /** Return the number of characters in the textual representation of\n-     *  the given tree that will be devoted to negation, or parentheses.\n-     *  Since these are the only characters that flipping a condition\n-     *  according to De Morgan's rule can affect, these are the only ones\n-     *  we count.\n-     *  @param node The tree whose length should be checked.\n-     *  @return The number of negations and parentheses in the tree.\n-     */\n-    static int length(Node node) {\n-      int result = 0;\n-      if (node.isNot()) {\n-        result++;  // One negation needed.\n-      }\n-      for (Node n = node.getFirstChild(); n != null; n = n.getNext()) {\n-        if (NodeUtil.precedenceWithDefault(n.getType())\n-            < NodeUtil.precedenceWithDefault(node.getType())) {\n-          result += 2;  // One pair of parentheses needed.\n-        }\n-        result += length(n);\n-      }\n-      return result;\n-    }\n \n   }\n ", "timestamp": 1368488197, "metainfo": ""}