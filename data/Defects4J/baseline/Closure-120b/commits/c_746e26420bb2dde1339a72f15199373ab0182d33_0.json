{"sha": "746e26420bb2dde1339a72f15199373ab0182d33", "log": "Inline some methods to save stack space, particularly for expressions with loads of COMMAs  R=acleung DELTA=77  (41 added, 17 deleted, 19 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4194   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n           \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n           opstr, childCount);\n       int p = NodeUtil.precedence(type);\n-      addLeftExpr(first, p, context);\n+      addExpr(first, p, context);\n       cc.addOp(opstr, true);\n \n       // For right-hand-side of operations, only pass context if it's\n           addIdentifier(n.getString());\n           cc.addOp(\"=\", true);\n           if (first.isComma()) {\n-            addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n+            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n           } else {\n             // Add expression, consider nearby code at lowest level of\n             // precedence.\n \n       case Token.COMMA:\n         Preconditions.checkState(childCount == 2);\n-        addList(first, false, context);\n+\n+        // We could use addList recursively here, but sometimes we produce\n+        // very deeply nested commas and run out of stack space, so we\n+        // just unroll the recursion.\n+        //\n+        // We assume COMMA nodes are left-recursive.\n+        Node firstNonComma = n.getFirstChild();\n+        while (firstNonComma.getType() == Token.COMMA) {\n+          firstNonComma = firstNonComma.getFirstChild();\n+        }\n+\n+        addExpr(firstNonComma, 0, context);\n+\n+        Node current = firstNonComma;\n+        do {\n+          current = current.getParent();\n+          cc.listSeparator();\n+          addExpr(current.getFirstChild().getNext(), 0, Context.OTHER);\n+        } while (current != n);\n+\n         break;\n \n       case Token.NUMBER:\n         // All of these unary operators are right-associative\n         Preconditions.checkState(childCount == 1);\n         cc.addOp(NodeUtil.opToStrNoFail(type), false);\n-        addExpr(first, NodeUtil.precedence(type));\n+        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n         break;\n       }\n \n           cc.addNumber(-n.getFirstChild().getDouble());\n         } else {\n           cc.addOp(NodeUtil.opToStrNoFail(type), false);\n-          addExpr(first, NodeUtil.precedence(type));\n+          addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n         }\n \n         break;\n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n-        addLeftExpr(first, p + 1, context);\n+        addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n-        addExpr(first.getNext(), 1);\n+        addExpr(first.getNext(), 1, Context.OTHER);\n         cc.addOp(\":\", true);\n-        addExpr(last, 1);\n+        addExpr(last, 1, Context.OTHER);\n         break;\n       }\n \n         if (needsParens) {\n           add(\"(\");\n         }\n-        addLeftExpr(first, NodeUtil.precedence(type), context);\n+        addExpr(first, NodeUtil.precedence(type), context);\n         if (needsParens) {\n           add(\")\");\n         }\n         Preconditions.checkState(\n             childCount == 2,\n             \"Bad GETELEM: expected 2 children but got %s\", childCount);\n-        addLeftExpr(first, NodeUtil.precedence(type), context);\n+        addExpr(first, NodeUtil.precedence(type), context);\n         add(\"[\");\n         add(first.getNext());\n         add(\"]\");\n         // A non-zero post-prop value indicates a post inc/dec, default of zero\n         // is a pre-inc/dec.\n         if (postProp != 0) {\n-          addLeftExpr(first, NodeUtil.precedence(type), context);\n+          addExpr(first, NodeUtil.precedence(type), context);\n           cc.addOp(o, false);\n         } else {\n           cc.addOp(o, false);\n         if (isIndirectEval(first)\n             || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n           add(\"(0,\");\n-          addExpr(first, NodeUtil.precedence(Token.COMMA));\n+          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n           add(\")\");\n         } else {\n-          addLeftExpr(first, NodeUtil.precedence(type), context);\n+          addExpr(first, NodeUtil.precedence(type), context);\n         }\n         add(\"(\");\n         addList(first.getNext());\n             first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n           precedence = NodeUtil.precedence(first.getType()) + 1;\n         }\n-        addExpr(first, precedence);\n+        addExpr(first, precedence, Context.OTHER);\n \n         // '()' is optional when no arguments are present\n         Node next = first.getNext();\n               if (!Double.isNaN(d)) {\n                 cc.addNumber(d);\n               } else {\n-                addExpr(c, 1);\n+                addExpr(c, 1, Context.OTHER);\n               }\n             }\n             add(\":\");\n-            addExpr(c.getFirstChild(), 1);\n+            addExpr(c.getFirstChild(), 1, Context.OTHER);\n           }\n         }\n         add(\"}\");\n     }\n   }\n \n-  /**\n-   * Adds a node at the left-hand side of an expression. Unlike\n-   * {@link #addExpr(Node,int)}, this preserves information about the context.\n-   *\n-   * The left side of an expression is special because in the JavaScript\n-   * grammar, certain tokens may be parsed differently when they are at\n-   * the beginning of a statement. For example, \"{}\" is parsed as a block,\n-   * but \"{'x': 'y'}\" is parsed as an object literal.\n-   */\n-  void addLeftExpr(Node n, int minPrecedence, Context context) {\n-    addExpr(n, minPrecedence, context);\n-  }\n-\n-  void addExpr(Node n, int minPrecedence) {\n-    addExpr(n, minPrecedence, Context.OTHER);\n-  }\n-\n   private void addExpr(Node n, int minPrecedence, Context context) {\n     if ((NodeUtil.precedence(n.getType()) < minPrecedence) ||\n         ((context == Context.IN_FOR_INIT_CLAUSE) &&\n     for (Node n = firstInList; n != null; n = n.getNext()) {\n       boolean isFirst = n == firstInList;\n       if (isFirst) {\n-        addLeftExpr(n, isArrayOrFunctionArgument ? 1 : 0, lhsContext);\n+        addExpr(n, isArrayOrFunctionArgument ? 1 : 0, lhsContext);\n       } else {\n         cc.listSeparator();\n-        addExpr(n, isArrayOrFunctionArgument ? 1 : 0);\n+        addExpr(n, isArrayOrFunctionArgument ? 1 : 0, Context.OTHER);\n       }\n     }\n   }\n       if (n != firstInList) {\n         cc.listSeparator();\n       }\n-      addExpr(n, 1);\n+      addExpr(n, 1, Context.OTHER);\n       lastWasEmpty = n.isEmpty();\n     }\n \n--- a/test/com/google/javascript/jscomp/CodePrinterTest.java\n+++ b/test/com/google/javascript/jscomp/CodePrinterTest.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.base.Joiner;\n+import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.CompilerOptions.LanguageMode;\n import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n import junit.framework.TestCase;\n+\n+import java.util.List;\n \n public class CodePrinterTest extends TestCase {\n   static Node parse(String js) {\n   public void testIssue5746867() {\n     assertPrint(\"var a = { '$\\\\\\\\' : 5 };\", \"var a={\\\"$\\\\\\\\\\\":5}\");\n   }\n+\n+  public void testManyCommas() {\n+    int numCommas = 10000;\n+    List<String> numbers = Lists.newArrayList(\"0\", \"1\");\n+    Node current = new Node(Token.COMMA, Node.newNumber(0), Node.newNumber(1));\n+    for (int i = 2; i < numCommas; i++) {\n+      current = new Node(Token.COMMA, current);\n+\n+      // 1000 is printed as 1E3, and screws up our test.\n+      int num = i % 1000;\n+      numbers.add(String.valueOf(num));\n+      current.addChildToBack(Node.newNumber(num));\n+    }\n+\n+    String expected = Joiner.on(\",\").join(numbers);\n+    String actual = printNode(current).replace(\"\\n\", \"\");\n+    assertEquals(expected, actual);\n+  }\n }", "timestamp": 1328747307, "metainfo": ""}