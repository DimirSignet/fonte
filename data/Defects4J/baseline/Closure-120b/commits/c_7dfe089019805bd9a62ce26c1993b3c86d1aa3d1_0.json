{"sha": "7dfe089019805bd9a62ce26c1993b3c86d1aa3d1", "log": "Introduce an ast validator.  R=acleung DELTA=823  (823 added, 0 deleted, 0 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1314   ", "commit": "\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/AstValidator.java\n+/*\n+ * Copyright 2011 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+/**\n+ * This class walks the AST and validates that the structure is correct.\n+ *\n+ * @author johnlenz@google.com (John Lenz)\n+ */\n+public class AstValidator implements CompilerPass {\n+\n+  // Possible enhancements:\n+  // * verify NAME, LABEL_NAME, GETPROP property name and unquoted\n+  // object-literal keys are valid javascript identifiers.\n+  // * optionally verify every node has source location information.\n+  // * optionally verify every node has an assigned JSType\n+  //\n+\n+  interface ViolationHandler {\n+    void handleViolation(String message, Node n);\n+  }\n+\n+  private final ViolationHandler violationHandler;\n+\n+  AstValidator(ViolationHandler handler) {\n+    this.violationHandler = handler;\n+  }\n+\n+  AstValidator() {\n+    this.violationHandler = new ViolationHandler() {\n+      @Override\n+      public void handleViolation(String message, Node n) {\n+        throw new IllegalStateException(\n+            message + \" Reference node \" + n.toString());\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public void process(Node externs, Node root) {\n+    if (externs != null) {\n+      validateCodeRoot(externs);\n+    }\n+    if (root != null) {\n+      validateCodeRoot(root);\n+    }\n+  }\n+\n+  public void validateRoot(Node n) {\n+    validateNodeType(Token.BLOCK, n);\n+    validateIsSynthetic(n);\n+    validateChildCount(n, 2);\n+    validateCodeRoot(n.getFirstChild());\n+    validateCodeRoot(n.getLastChild());\n+  }\n+\n+  public void validateCodeRoot(Node n) {\n+    validateNodeType(Token.BLOCK, n);\n+    validateIsSynthetic(n);\n+    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n+      validateScript(c);\n+    }\n+  }\n+\n+  public void validateScript(Node n) {\n+    validateNodeType(Token.SCRIPT, n);\n+    validateIsSynthetic(n);\n+    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n+      validateStatement(c);\n+    }\n+  }\n+\n+  public void validateStatement(Node n) {\n+    switch (n.getType()) {\n+      case Token.LABEL:\n+        validateLabel(n);\n+        return;\n+      case Token.BLOCK:\n+        validateBlock(n);\n+        return;\n+      case Token.FUNCTION:\n+        validateFunctionStatement(n);\n+        return;\n+      case Token.WITH:\n+        validateWith(n);\n+        return;\n+      case Token.FOR:\n+        validateFor(n);\n+        return;\n+      case Token.WHILE:\n+        validateWhile(n);\n+        return;\n+      case Token.DO:\n+        validateDo(n);\n+        return;\n+      case Token.SWITCH:\n+        validateSwitch(n);\n+        return;\n+      case Token.IF:\n+        validateIf(n);\n+        return;\n+      case Token.VAR:\n+        validateVar(n);\n+        return;\n+      case Token.EXPR_RESULT:\n+        validateExprStmt(n);\n+        return;\n+      case Token.RETURN:\n+        validateReturn(n);\n+        return;\n+      case Token.THROW:\n+        validateThrow(n);\n+        return;\n+      case Token.TRY:\n+        validateTry(n);\n+        return;\n+      case Token.BREAK:\n+        validateBreak(n);\n+        return;\n+      case Token.CONTINUE:\n+        validateContinue(n);\n+        return;\n+      case Token.EMPTY:\n+        return;\n+      default:\n+        violation(\"Expected statement but was \"\n+            + Node.tokenToName(n.getType()) + \".\", n);\n+    }\n+  }\n+\n+  public void validateExpression(Node n) {\n+    switch (n.getType()) {\n+      // Childless expressions\n+      case Token.FALSE:\n+      case Token.NULL:\n+      case Token.THIS:\n+      case Token.TRUE:\n+        validateChildless(n);\n+        return;\n+\n+      // General uniary ops\n+      case Token.DELPROP:\n+      case Token.POS:\n+      case Token.NEG:\n+      case Token.NOT:\n+      case Token.INC:\n+      case Token.DEC:\n+      case Token.TYPEOF:\n+      case Token.VOID:\n+      case Token.BITNOT:\n+        validateUnaryOp(n);\n+        return;\n+\n+      // General binary ops\n+      case Token.COMMA:\n+      case Token.OR:\n+      case Token.AND:\n+      case Token.BITOR:\n+      case Token.BITXOR:\n+      case Token.BITAND:\n+      case Token.EQ:\n+      case Token.NE:\n+      case Token.SHEQ:\n+      case Token.SHNE:\n+      case Token.LT:\n+      case Token.GT:\n+      case Token.LE:\n+      case Token.GE:\n+      case Token.INSTANCEOF:\n+      case Token.IN:\n+      case Token.LSH:\n+      case Token.RSH:\n+      case Token.URSH:\n+      case Token.SUB:\n+      case Token.ADD:\n+      case Token.MUL:\n+      case Token.MOD:\n+      case Token.DIV:\n+        validateBinaryOp(n);\n+        return;\n+\n+      // Assignments\n+      case Token.ASSIGN:\n+      case Token.ASSIGN_BITOR:\n+      case Token.ASSIGN_BITXOR:\n+      case Token.ASSIGN_BITAND:\n+      case Token.ASSIGN_LSH:\n+      case Token.ASSIGN_RSH:\n+      case Token.ASSIGN_URSH:\n+      case Token.ASSIGN_ADD:\n+      case Token.ASSIGN_SUB:\n+      case Token.ASSIGN_MUL:\n+      case Token.ASSIGN_DIV:\n+      case Token.ASSIGN_MOD:\n+        validateAssignmentExpression(n);\n+        return;\n+\n+      case Token.HOOK:\n+        validateTrinaryOp(n);\n+        return;\n+\n+      // Node types that require special handling\n+      case Token.STRING:\n+        validateString(n);\n+        return;\n+\n+      case Token.NUMBER:\n+        validateNumber(n);\n+        return;\n+\n+      case Token.NAME:\n+        validateName(n);\n+        return;\n+\n+      case Token.GETELEM:\n+        validateBinaryOp(n);\n+        return;\n+\n+      case Token.GETPROP:\n+        validateGetProp(n);\n+        return;\n+\n+      case Token.ARRAYLIT:\n+        validateArrayLit(n);\n+        return;\n+\n+      case Token.OBJECTLIT:\n+        validateObjectLit(n);\n+        return;\n+\n+      case Token.REGEXP:\n+        validateRegExpLit(n);\n+        return;\n+\n+      case Token.CALL:\n+        validateCall(n);\n+        return;\n+\n+      case Token.NEW:\n+        validateNew(n);\n+        return;\n+\n+      case Token.FUNCTION:\n+        validateFunctionExpression(n);\n+        return;\n+\n+      default:\n+        violation(\"Expected expression but was \"\n+            + Node.tokenToName(n.getType()), n);\n+    }\n+  }\n+\n+  private void validateBlock(Node n) {\n+    validateNodeType(Token.BLOCK, n);\n+    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n+      validateStatement(c);\n+    }\n+  }\n+\n+  private void validateSyntheticBlock(Node n) {\n+    validateNodeType(Token.BLOCK, n);\n+    validateIsSynthetic(n);\n+    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n+      validateStatement(c);\n+    }\n+  }\n+\n+  private void validateIsSynthetic(Node n) {\n+    if (!n.getBooleanProp(Node.SYNTHETIC_BLOCK_PROP)) {\n+      violation(\"Missing 'synthetic block' annotation.\", n);\n+    }\n+  }\n+\n+  private void validateLabel(Node n) {\n+    validateNodeType(Token.LABEL, n);\n+    validateChildCount(n, 2);\n+    validateLabelName(n.getFirstChild());\n+    validateStatement(n.getLastChild());\n+  }\n+\n+  private void validateLabelName(Node n) {\n+    validateNodeType(Token.LABEL_NAME, n);\n+    validateNonEmptyString(n);\n+    validateChildCount(n, 0);\n+  }\n+\n+  private void validateNonEmptyString(Node n) {\n+    validateNonNullString(n);\n+    if (n.getString().isEmpty()) {\n+      violation(\"Expected non-empty string.\", n);\n+    }\n+  }\n+\n+  private void validateNonNullString(Node n) {\n+    if (n.getString() == null) {\n+      violation(\"Expected non-null string.\", n);\n+    }\n+  }\n+\n+  private void validateName(Node n) {\n+    validateNodeType(Token.NAME, n);\n+    validateNonEmptyString(n);\n+    validateChildCount(n, 0);\n+  }\n+\n+  private void validateOptionalName(Node n) {\n+    validateNodeType(Token.NAME, n);\n+    validateNonNullString(n);\n+    validateChildCount(n, 0);\n+  }\n+\n+  private void validateFunctionStatement(Node n) {\n+    validateNodeType(Token.FUNCTION, n);\n+    validateChildCount(n, 3);\n+    validateName(n.getFirstChild());\n+    validateParameters(n.getChildAtIndex(1));\n+    validateBlock(n.getLastChild());\n+  }\n+\n+  private void validateFunctionExpression(Node n) {\n+    validateNodeType(Token.FUNCTION, n);\n+    validateChildCount(n, 3);\n+    validateOptionalName(n.getFirstChild());\n+    validateParameters(n.getChildAtIndex(1));\n+    validateBlock(n.getLastChild());\n+  }\n+\n+  private void validateParameters(Node n) {\n+    validateNodeType(Token.LP, n);\n+    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n+      validateName(c);\n+    }\n+  }\n+\n+  private void validateCall(Node n) {\n+    validateNodeType(Token.CALL, n);\n+    validateMinimumChildCount(n, 1);\n+    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n+      validateExpression(c);\n+    }\n+  }\n+\n+  private void validateNew(Node n) {\n+    validateNodeType(Token.NEW, n);\n+    validateMinimumChildCount(n, 1);\n+    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n+      validateExpression(c);\n+    }\n+  }\n+\n+  private void validateVar(Node n) {\n+    validateNodeType(Token.VAR, n);\n+    this.validateMinimumChildCount(n, 1);\n+    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n+      // Don't use the validateName here as the NAME is allowed to have\n+      // a child.\n+      validateNodeType(Token.NAME, c);\n+      validateNonEmptyString(c);\n+      validateMaximumChildCount(c, 1);\n+      if (c.hasChildren()) {\n+        validateExpression(c.getFirstChild());\n+      }\n+    }\n+  }\n+\n+  private void validateFor(Node n) {\n+    validateNodeType(Token.FOR, n);\n+    validateMinimumChildCount(n, 3);\n+    validateMaximumChildCount(n, 4);\n+    if (NodeUtil.isForIn(n)) {\n+      // FOR-IN\n+      validateChildCount(n, 3);\n+      validateVarOrAssignmentTarget(n.getFirstChild());\n+      validateExpression(n.getChildAtIndex(1));\n+    } else {\n+      // FOR\n+      validateChildCount(n, 4);\n+      validateVarOrOptionalExpression(n.getFirstChild());\n+      validateOptionalExpression(n.getChildAtIndex(1));\n+      validateOptionalExpression(n.getChildAtIndex(2));\n+    }\n+    validateBlock(n.getLastChild());\n+  }\n+\n+  private void validateVarOrOptionalExpression(Node n) {\n+    if (n.getType() == Token.VAR) {\n+      validateVar(n);\n+    } else {\n+      validateOptionalExpression(n);\n+    }\n+  }\n+\n+  private void validateVarOrAssignmentTarget(Node n) {\n+    if (n.getType() == Token.VAR) {\n+      // Only one NAME can be declared for FOR-IN expressions.\n+      this.validateChildCount(n, 1);\n+      validateVar(n);\n+    } else {\n+      validateAssignmentTarget(n);\n+    }\n+  }\n+\n+  private void validateWith(Node n) {\n+    validateNodeType(Token.WITH, n);\n+    validateChildCount(n, 2);\n+    validateExpression(n.getFirstChild());\n+    validateBlock(n.getLastChild());\n+  }\n+\n+  private void validateWhile(Node n) {\n+    validateNodeType(Token.WHILE, n);\n+    validateChildCount(n, 2);\n+    validateExpression(n.getFirstChild());\n+    validateBlock(n.getLastChild());\n+  }\n+\n+  private void validateDo(Node n) {\n+    validateNodeType(Token.DO, n);\n+    validateChildCount(n, 2);\n+    validateBlock(n.getFirstChild());\n+    validateExpression(n.getLastChild());\n+  }\n+\n+  private void validateIf(Node n) {\n+    validateNodeType(Token.IF, n);\n+    validateMinimumChildCount(n, 2);\n+    validateMaximumChildCount(n, 3);\n+    validateExpression(n.getFirstChild());\n+    validateBlock(n.getChildAtIndex(1));\n+    if (n.getChildCount() == 3) {\n+      validateBlock(n.getLastChild());\n+    }\n+  }\n+\n+  private void validateExprStmt(Node n) {\n+    validateNodeType(Token.EXPR_RESULT, n);\n+    validateChildCount(n, 1);\n+    validateExpression(n.getFirstChild());\n+  }\n+\n+  private void validateReturn(Node n) {\n+    validateNodeType(Token.RETURN, n);\n+    validateMaximumChildCount(n, 1);\n+    if (n.hasChildren()) {\n+      validateExpression(n.getFirstChild());\n+    }\n+  }\n+\n+  private void validateThrow(Node n) {\n+    validateNodeType(Token.THROW, n);\n+    validateChildCount(n, 1);\n+    validateExpression(n.getFirstChild());\n+  }\n+\n+  private void validateBreak(Node n) {\n+    validateNodeType(Token.BREAK, n);\n+    validateMaximumChildCount(n, 1);\n+    if (n.hasChildren()) {\n+      validateLabelName(n.getFirstChild());\n+    }\n+  }\n+\n+  private void validateContinue(Node n) {\n+    validateNodeType(Token.CONTINUE, n);\n+    validateMaximumChildCount(n, 1);\n+    if (n.hasChildren()) {\n+      validateLabelName(n.getFirstChild());\n+    }\n+  }\n+\n+  private void validateTry(Node n) {\n+    validateNodeType(Token.TRY, n);\n+    validateMinimumChildCount(n, 2);\n+    validateMaximumChildCount(n, 3);\n+    validateBlock(n.getFirstChild());\n+\n+    boolean seenCatchOrFinally = false;\n+\n+    // Validate catch\n+    Node catches = n.getChildAtIndex(1);\n+    validateNodeType(Token.BLOCK, catches);\n+    validateMaximumChildCount(catches, 1);\n+    if (catches.hasChildren()) {\n+      validateCatch(catches.getFirstChild());\n+      seenCatchOrFinally = true;\n+    }\n+\n+    // Validate finally\n+    if (n.getChildCount() == 3) {\n+      validateBlock(n.getLastChild());\n+      seenCatchOrFinally = true;\n+    }\n+\n+    if (!seenCatchOrFinally) {\n+      violation(\"Missing catch or finally for try statement.\", n);\n+    }\n+  }\n+\n+  private void validateCatch(Node n) {\n+    validateNodeType(Token.CATCH, n);\n+    validateChildCount(n, 2);\n+    validateName(n.getFirstChild());\n+    validateBlock(n.getLastChild());\n+  }\n+\n+  private void validateSwitch(Node n) {\n+    validateNodeType(Token.SWITCH, n);\n+    validateMinimumChildCount(n, 1);\n+    validateExpression(n.getFirstChild());\n+    int defaults = 0;\n+    for (Node c = n.getFirstChild().getNext(); c != null; c = c.getNext()) {\n+      validateSwitchMember(n.getLastChild());\n+      if (c.getType() == Token.DEFAULT) {\n+        defaults++;\n+      }\n+    }\n+    if (defaults > 1) {\n+      violation(\"Expected at most 1 'default' in switch but was \"\n+          + defaults, n);\n+    }\n+  }\n+\n+  private void validateSwitchMember(Node n) {\n+    switch (n.getType()) {\n+      case Token.CASE:\n+        validateCase(n);\n+        return;\n+      case Token.DEFAULT:\n+        validateDefault(n);\n+        return;\n+      default:\n+        violation(\"Expected switch member but was \"\n+            + Node.tokenToName(n.getType()), n);\n+    }\n+  }\n+\n+  private void validateDefault(Node n) {\n+    validateNodeType(Token.DEFAULT, n);\n+    validateChildCount(n, 1);\n+    validateSyntheticBlock(n.getLastChild());\n+  }\n+\n+  private void validateCase(Node n) {\n+    validateNodeType(Token.CASE, n);\n+    validateChildCount(n, 2);\n+    validateExpression(n.getFirstChild());\n+    validateSyntheticBlock(n.getLastChild());\n+  }\n+\n+  private void validateOptionalExpression(Node n) {\n+    if (n.getType() == Token.EMPTY) {\n+      validateChildless(n);\n+    } else {\n+      validateExpression(n);\n+    }\n+  }\n+\n+  private void validateChildless(Node n) {\n+    validateChildCount(n, 0);\n+  }\n+\n+  private void validateAssignmentExpression(Node n) {\n+    validateChildCount(n, 2);\n+    validateAssignmentTarget(n.getFirstChild());\n+    validateExpression(n.getLastChild());\n+  }\n+\n+  private void validateAssignmentTarget(Node n) {\n+    switch (n.getType()) {\n+      case Token.NAME:\n+      case Token.GETELEM:\n+      case Token.GETPROP:\n+        validateExpression(n);\n+        return;\n+      default:\n+        violation(\"Expected assignment target expression but was \"\n+            + Node.tokenToName(n.getType()), n);\n+    }\n+  }\n+\n+  private void validateGetProp(Node n) {\n+    validateNodeType(Token.GETPROP, n);\n+    validateChildCount(n, 2);\n+    validateExpression(n.getFirstChild());\n+    Node prop = n.getLastChild();\n+    validateNodeType(Token.STRING, prop);\n+    validateNonEmptyString(prop);\n+  }\n+\n+  private void validateRegExpLit(Node n) {\n+    validateNodeType(Token.REGEXP, n);\n+    validateMinimumChildCount(n, 1);\n+    validateMaximumChildCount(n, 2);\n+    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n+      validateString(c);\n+    }\n+  }\n+\n+  private void validateString(Node n) {\n+    validateNodeType(Token.STRING, n);\n+    validateChildCount(n, 0);\n+    try {\n+      // Validate that getString doesn't throw\n+      n.getString();\n+    } catch (UnsupportedOperationException e) {\n+      violation(\"Invalid STRING node.\", n);\n+    }\n+  }\n+\n+  private void validateNumber(Node n) {\n+    validateNodeType(Token.NUMBER, n);\n+    validateChildCount(n, 0);\n+    try {\n+      // Validate that getDouble doesn't throw\n+      n.getDouble();\n+    } catch (UnsupportedOperationException e) {\n+      violation(\"Invalid NUMBER node.\", n);\n+    }\n+  }\n+\n+  private void validateArrayLit(Node n) {\n+    validateNodeType(Token.ARRAYLIT, n);\n+    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n+      // EMPTY is allowed to represent empty slots.\n+      validateOptionalExpression(c);\n+    }\n+  }\n+\n+  private void validateObjectLit(Node n) {\n+    validateNodeType(Token.OBJECTLIT, n);\n+    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n+      validateObjectLitKey(c);\n+    }\n+  }\n+\n+  private void validateObjectLitKey(Node n) {\n+    switch (n.getType()) {\n+      case Token.GET:\n+        validateObjectLitGetKey(n);\n+        return;\n+      case Token.SET:\n+        validateObjectLitSetKey(n);\n+        return;\n+      case Token.STRING:\n+        validateObjectLitStringKey(n);\n+        return;\n+      default:\n+        violation(\"Expected object literal key expression but was \"\n+              + Node.tokenToName(n.getType()), n);\n+    }\n+  }\n+\n+  private void validateObjectLitGetKey(Node n) {\n+    validateNodeType(Token.GET, n);\n+    validateChildCount(n, 1);\n+    validateObjectLiteralKeyName(n);\n+    Node function = n.getFirstChild();\n+    validateFunctionExpression(function);\n+    // objlit get functions must be nameless, and must have zero parameters.\n+    if (!function.getFirstChild().getString().isEmpty()) {\n+      violation(\"Expected unnamed function expression.\", n);\n+    }\n+    Node functionParams = function.getChildAtIndex(1);\n+    if (functionParams.hasChildren()) {\n+      violation(\"get methods must not have parameters.\", n);\n+    }\n+  }\n+\n+  private void validateObjectLitSetKey(Node n) {\n+    validateNodeType(Token.SET, n);\n+    validateChildCount(n, 1);\n+    validateObjectLiteralKeyName(n);\n+    Node function = n.getFirstChild();\n+    validateFunctionExpression(function);\n+    // objlit set functions must be nameless, and must have 1 parameter.\n+    if (!function.getFirstChild().getString().isEmpty()) {\n+      violation(\"Expected unnamed function expression.\", n);\n+    }\n+    Node functionParams = function.getChildAtIndex(1);\n+    if (!functionParams.hasOneChild()) {\n+      violation(\"set methods must have exactly one parameter.\", n);\n+    }\n+  }\n+\n+  private void validateObjectLitStringKey(Node n) {\n+    validateNodeType(Token.STRING, n);\n+    validateChildCount(n, 1);\n+    validateObjectLiteralKeyName(n);\n+    validateExpression(n.getFirstChild());\n+  }\n+\n+  private void validateObjectLiteralKeyName(Node n) {\n+    if (n.isQuotedString()) {\n+      try {\n+        // Validate that getString doesn't throw\n+        n.getString();\n+      } catch (UnsupportedOperationException e) {\n+        violation(\"getString failed for\" + Node.tokenToName(n.getType()), n);\n+      }\n+    } else {\n+      validateNonEmptyString(n);\n+    }\n+  }\n+\n+  private void validateUnaryOp(Node n) {\n+    validateChildCount(n, 1);\n+    validateExpression(n.getFirstChild());\n+  }\n+\n+  private void validateBinaryOp(Node n) {\n+    validateChildCount(n, 2);\n+    validateExpression(n.getFirstChild());\n+    validateExpression(n.getLastChild());\n+  }\n+\n+  private void validateTrinaryOp(Node n) {\n+    validateChildCount(n, 3);\n+    Node first = n.getFirstChild();\n+    validateExpression(first);\n+    validateExpression(first.getNext());\n+    validateExpression(n.getLastChild());\n+  }\n+\n+  private void violation(String message, Node n) {\n+    violationHandler.handleViolation(message, n);\n+  }\n+\n+  private void validateNodeType(int type, Node n) {\n+    if (n.getType() != type) {\n+      violation(\n+          \"Expected \" + Node.tokenToName(type) + \" but was \"\n+              + Node.tokenToName(n.getType()), n);\n+    }\n+  }\n+\n+  private void validateChildCount(Node n, int i) {\n+    boolean valid = false;\n+    if (i == 0) {\n+      valid = !n.hasChildren();\n+    } else if (i == 1) {\n+      valid = n.hasOneChild();\n+    } else {\n+      valid = (n.getChildCount() == i);\n+    }\n+    if (!valid) {\n+      violation(\n+          \"Expected \" + i + \" children, but was \"\n+              + n.getChildCount(), n);\n+    }\n+  }\n+\n+  private void validateMinimumChildCount(Node n, int i) {\n+    boolean valid = false;\n+    if (i == 1) {\n+      valid = n.hasChildren();\n+    } else if (i == 2) {\n+      valid = n.hasMoreThanOneChild();\n+    } else {\n+      valid = n.getChildCount() >= i;\n+    }\n+\n+    if (!valid) {\n+      violation(\n+          \"Expected at least \" + i + \" children, but was \"\n+              + n.getChildCount(), n);\n+    }\n+  }\n+\n+  private void validateMaximumChildCount(Node n, int i) {\n+    boolean valid = false;\n+    if (i == 1) {\n+      valid = !n.hasMoreThanOneChild();\n+    } else {\n+      valid = n.getChildCount() <= i;\n+    }\n+    if (!valid) {\n+      violation(\n+          \"Expected no more than \" + i + \" children, but was \"\n+              + n.getChildCount(), n);\n+    }\n+  }\n+}\n--- a/test/com/google/javascript/jscomp/CompilerTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java\n   private boolean allowExternsChanges = false;\n \n   /**\n+   * Whether the AST should be validated.\n+   */\n+  private boolean astValidationEnabled = true;\n+\n+  /**\n    * Constructs a test.\n    *\n    * @param externs Externs JS as a string\n    */\n   void enableMarkNoSideEffects() {\n     markNoSideEffects  = true;\n+  }\n+\n+  /**\n+   * Whether to allow Validate the AST after each run of the pass.\n+   */\n+  protected void enableAstValidation(boolean validate) {\n+    astValidationEnabled = validate;\n   }\n \n   /** Returns a newly created TypeCheck. */\n     assertTrue(\"Unexpected parse error(s): \" +\n         Joiner.on(\"\\n\").join(compiler.getErrors()), root != null);\n \n+    if (astValidationEnabled) {\n+      (new AstValidator()).validateRoot(root);\n+    }\n     Node externsRoot = root.getFirstChild();\n     Node mainRoot = root.getLastChild();\n \n         recentChange.reset();\n \n         getProcessor(compiler).process(externsRoot, mainRoot);\n+        if (astValidationEnabled) {\n+          (new AstValidator()).validateRoot(root);\n+        }\n         if (checkLineNumbers) {\n           (new LineNumberCheck(compiler)).process(externsRoot, mainRoot);\n         }\n--- a/test/com/google/javascript/jscomp/VarCheckTest.java\n+++ b/test/com/google/javascript/jscomp/VarCheckTest.java\n   @Override\n   protected void setUp() throws Exception {\n     super.setUp();\n+    // Setup value set by individual tests to the appropriate defaults.\n     super.allowExternsChanges(true);\n+    super.enableAstValidation(true);\n     strictModuleDepErrorLevel = CheckLevel.OFF;\n     externValidationErrorLevel = null;\n     sanityCheck = false;\n   }\n \n   public void testInvalidFunctionDecl1() {\n+    // This test deliberately sets up an invalid AST.\n+    super.enableAstValidation(false);\n+\n     final CompilerTestCase testcase = this;\n \n     // A compiler pass that create invalid function names.", "timestamp": 1302540774, "metainfo": ""}