{"sha": "8578db7bd1ef4b45d58dcee2d5fb08f408e80002", "log": "Disambiguate properties runs after normalization, update the tests so they run that way too.  R=nicksantos DELTA=81  (35 added, 16 deleted, 30 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5743   ", "commit": "\n--- a/src/com/google/javascript/jscomp/DisambiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/DisambiguateProperties.java\n import static com.google.common.base.Preconditions.checkState;\n \n import com.google.common.base.Joiner;\n+import com.google.common.base.Preconditions;\n import com.google.common.collect.HashMultimap;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.LinkedHashMultimap;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Multimap;\n import com.google.common.collect.Sets;\n+import com.google.javascript.jscomp.AbstractCompiler.LifeCycleStage;\n import com.google.javascript.jscomp.ConcreteType.ConcreteFunctionType;\n import com.google.javascript.jscomp.ConcreteType.ConcreteInstanceType;\n import com.google.javascript.jscomp.ConcreteType.ConcreteUnionType;\n \n   @Override\n   public void process(Node externs, Node root) {\n+    Preconditions.checkState(\n+        compiler.getLifeCycleStage() == LifeCycleStage.NORMALIZED);\n     for (TypeMismatch mis : compiler.getTypeValidator().getMismatches()) {\n       addInvalidatingType(mis.typeA, mis.src);\n       addInvalidatingType(mis.typeB, mis.src);\n--- a/test/com/google/javascript/jscomp/CompilerTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java\n \n     BaseJSTypeTestCase.addNativeProperties(compiler.getTypeRegistry());\n \n-    test(compiler, new String[] { expected }, error, warning, description);\n+    test(compiler, maybeCreateArray(expected), error, warning, description);\n+  }\n+\n+  private String[] maybeCreateArray(String expected) {\n+    if (expected != null) {\n+      return new String[] { expected };\n+    }\n+    return null;\n   }\n \n   /**\n       // Verify the symbol table.\n       ErrorManager symbolTableErrorManager =\n           new BlackHoleErrorManager(compiler);\n-      Node expectedRoot = parseExpectedJs(expected);\n-      expectedRoot.detachFromParent();\n+      Node expectedRoot = null;\n+      if (expected != null) {\n+        expectedRoot = parseExpectedJs(expected);\n+        expectedRoot.detachFromParent();\n+      }\n \n       JSError[] stErrors = symbolTableErrorManager.getErrors();\n       if (expectedSymbolTableError != null) {\n             hasCodeChanged);\n       }\n \n-      if (compareAsTree) {\n-        String explanation = expectedRoot.checkTreeEquals(mainRoot);\n-        assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n-            \"\\nResult: \" + compiler.toSource(mainRoot) +\n-            \"\\n\" + explanation, explanation);\n-      } else if (expected != null) {\n-        assertEquals(\n-            Joiner.on(\"\").join(expected), compiler.toSource(mainRoot));\n+      if (expected != null) {\n+        if (compareAsTree) {\n+          String explanation = expectedRoot.checkTreeEquals(mainRoot);\n+          assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n+              \"\\nResult: \" + compiler.toSource(mainRoot) +\n+              \"\\n\" + explanation, explanation);\n+        } else if (expected != null) {\n+          assertEquals(\n+              Joiner.on(\"\").join(expected), compiler.toSource(mainRoot));\n+        }\n       }\n \n       // Verify normalization is not invalidated.\n--- a/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/DisambiguatePropertiesTest.java\n  */\n package com.google.javascript.jscomp;\n \n-import com.google.common.base.Joiner;\n-import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Multimap;\n import com.google.common.collect.Sets;\n-import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.jstype.JSTypeNative;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n   }\n \n   @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    super.enableNormalize(true);\n+    super.enableTypeCheck(CheckLevel.WARNING);\n+  }\n+\n+  @Override\n   public CompilerPass getProcessor(final Compiler compiler) {\n-    final TypeCheck checker = new TypeCheck(compiler,\n-        new SemanticReverseAbstractInterpreter(\n-            compiler.getCodingConvention(), compiler.getTypeRegistry()),\n-        compiler.getTypeRegistry());\n \n     return new CompilerPass() {\n       @Override\n       public void process(Node externs, Node root) {\n-        checker.processForTesting(externs, root);\n-\n         Map<String, CheckLevel> propertiesToErrorFor =\n             Maps.<String, CheckLevel>newHashMap();\n         propertiesToErrorFor.put(\"foobar\", CheckLevel.ERROR);\n         + \"function Foo() {}\\n\"\n         + \"function Bar() {}\\n\"\n         + \"Bar.prototype.Bar_prototype$a;\\n\"\n-        + \"function foo(foo) {\\n\"\n-        + \"  var x = foo.Bar_prototype$a;\\n\"\n+        + \"function foo(foo$$1) {\\n\"\n+        + \"  var x = foo$$1.Bar_prototype$a;\\n\"\n         + \"}\\n\";\n     testSets(false, externs, js, result, \"{a=[[Bar.prototype]]}\");\n   }\n         + \"Top.prototype.f = function() {};\"\n         + \"/** @constructor \\n@extends Top*/ function Foo() {}\\n\"\n         + \"goog.inherits(Foo, Top);\\n\"\n+        + \"/** @override */\\n\"\n         + \"Foo.prototype.f = function() {\"\n         + \"  Foo.superClass_.f();\"\n         + \"};\\n\"\n         + \"/** @constructor \\n* @extends Foo */ function Bar() {}\\n\"\n         + \"goog.inherits(Bar, Foo);\\n\"\n+        + \"/** @override */\\n\"\n         + \"Bar.prototype.f = function() {\"\n         + \"  Bar.superClass_.f();\"\n         + \"};\\n\"\n         + \"var i = new Bar;\\n\" // Make I invalidating\n         + \"/** @constructor \\n @implements I \\n @implements I2 */\"\n         + \"function Foo() {};\\n\"\n+        + \"/** @override */\\n\"\n         + \"Foo.prototype.a = 0;\\n\"\n         + \"(new Foo).a = 0;\"\n         + \"/** @interface */ function I() {};\\n\"\n         + \"I.prototype.a;\\n\";\n-    testSets(false, js, \"{}\");\n-    testSets(true, js, \"{}\");\n+    testSets(false, js, \"{}\", TypeValidator.TYPE_MISMATCH_WARNING);\n+    testSets(true, js, \"{}\", TypeValidator.TYPE_MISMATCH_WARNING);\n   }\n \n   public void testMultipleInterfaces() {\n         + \"I2.prototype.a;\\n\"\n         + \"/** @constructor \\n @implements I \\n @implements I2 */\"\n         + \"function Foo() {};\\n\"\n+        + \"/** @override */\"\n         + \"Foo.prototype.a = 0;\\n\"\n         + \"(new Foo).a = 0\";\n     testSets(false, js, \"{a=[[Foo.prototype, I2.prototype]]}\");\n         + \"/** @interface \\n @extends I */ function I2() {};\\n\"\n         + \"/** @constructor \\n @implements I2 */\"\n         + \"function Foo() {};\\n\"\n+        + \"/** @override */\\n\"\n         + \"Foo.prototype.a = 0;\\n\"\n         + \"(new Foo).a = 0\";\n     testSets(false, js, \"{a=[[Foo.prototype, I.prototype]]}\");\n    * <p>The format for the set of types for fields is:\n    * {field=[[Type1, Type2]]}\n    */\n-  @SuppressWarnings(\"unchecked\")\n   private void testSets(boolean runTightenTypes, String js, String fieldTypes) {\n     this.runTightenTypes = runTightenTypes;\n-    Compiler compiler = new Compiler();\n-    CompilerOptions options = new CompilerOptions();\n-    compiler.init(\n-        ImmutableList.of(SourceFile.fromCode(\"externs\", \"\")),\n-        ImmutableList.of(SourceFile.fromCode(\"testcode\", js)),\n-        options);\n-\n-    Node root = compiler.parseInputs();\n-    assertTrue(\"Unexpected parse error(s): \" +\n-        Joiner.on(\"\\n\").join(compiler.getErrors()), root != null);\n-\n-    Node externsRoot = root.getFirstChild();\n-    Node mainRoot = externsRoot.getNext();\n-    getProcessor(compiler).process(externsRoot, mainRoot);\n-\n+    test(js, null, null, null);\n+    assertEquals(fieldTypes, mapToString(lastPass.getRenamedTypesForTesting()));\n+  }\n+\n+  /**\n+   * Compiles the code and checks that the set of types for each field matches\n+   * the expected value.\n+   *\n+   * <p>The format for the set of types for fields is:\n+   * {field=[[Type1, Type2]]}\n+   */\n+  private void testSets(boolean runTightenTypes, String js, String fieldTypes,\n+      DiagnosticType warning) {\n+    this.runTightenTypes = runTightenTypes;\n+    test(js, null, null, warning);\n     assertEquals(fieldTypes, mapToString(lastPass.getRenamedTypesForTesting()));\n   }\n ", "timestamp": 1351884009, "metainfo": ""}