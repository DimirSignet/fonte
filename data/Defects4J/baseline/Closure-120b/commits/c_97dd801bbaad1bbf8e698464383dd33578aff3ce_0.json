{"sha": "97dd801bbaad1bbf8e698464383dd33578aff3ce", "log": "Add type properties to the symbol table.  R=acleung DELTA=451  (408 added, 12 deleted, 31 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3136   ", "commit": "\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n     }\n \n     symbolTable.fillNamespaceReferences();\n+    symbolTable.fillPropertySymbols(this, externsRoot, jsRoot);\n \n     return symbolTable;\n   }\n--- a/src/com/google/javascript/jscomp/SymbolTable.java\n+++ b/src/com/google/javascript/jscomp/SymbolTable.java\n import com.google.common.base.Preconditions;\n import com.google.common.collect.HashBasedTable;\n import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n import com.google.common.collect.Table;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n \n import javax.annotation.Nullable;\n \n  * this symbol table that indexes symbols or references by the desired lookup\n  * key.\n  *\n- * By design, this symbol table conflates \"type Foo\" with \"the constructor\n- * that creates objects of type Foo\" when looking up types. JSCompiler\n- * internally treats these as distinct objects, but we assume that most\n- * clients will not care about the distinction.\n+ * By design, when this symbol table creates symbols for types, it tries\n+ * to mimic the symbol table you would get in an OO language. For example,\n+ * the \"type Foo\" and \"the constructor that creates objects of type Foo\"\n+ * are the same symbol. The types of \"Foo.prototype\" and \"new Foo()\" also\n+ * have the same symbol. Although JSCompiler internally treats these as\n+ * distinct symbols, we assume that most clients will not care about\n+ * the distinction.\n  *\n  * @see #addSymbolsFrom For more information on how to write plugins for this\n  *    symbol table.\n   private final Table<Node, String, Symbol> symbols = HashBasedTable.create();\n \n   /**\n-   * All scopes in the program, uniquely identified by the node where\n+   * All syntactic scopes in the program, uniquely identified by the node where\n    * they're declared.\n    */\n   private final Map<Node, SymbolScope> scopes = Maps.newHashMap();\n    * scope.\n    */\n   public Symbol getSymbolForScope(SymbolScope scope) {\n+    if (scope.isPropertyScope()) {\n+      JSType type = scope.getTypeOfThis();\n+      if (type != null) {\n+        if (type.isNominalConstructor()) {\n+          return getSymbolDeclaredBy(type.toMaybeFunctionType());\n+        } else if (type.isFunctionPrototypeType()) {\n+          return getSymbolForInstancesOf(\n+              ((ObjectType) type).getOwnerFunction());\n+        }\n+      }\n+      return null;\n+    }\n+\n     Node rootNode = scope.getRootNode();\n     if (rootNode.getType() != Token.FUNCTION) {\n       return null;\n    * this will return the constructors for Array and Date.\n    */\n   public Iterable<Symbol> getAllSymbolsForTypeOf(Symbol sym) {\n-    return getAllSymbolsForType(sym.getType(), sym.scope);\n+    return getAllSymbolsForType(sym.getType());\n+  }\n+\n+  /**\n+   * Returns the global scope.\n+   */\n+  public SymbolScope getGlobalScope() {\n+    return globalScope;\n   }\n \n   /**\n         globalScope : getEnclosingScope(source)).getSlot(name);\n   }\n \n-  private List<Symbol> getAllSymbolsForType(\n-      JSType type, SymbolScope scope) {\n+  /**\n+   * Gets the symbol for the prototype if this is the symbol for a constructor\n+   * or interface.\n+   */\n+  public Symbol getSymbolForInstancesOf(Symbol sym) {\n+    FunctionType fn = sym.getFunctionType();\n+    if (fn != null && fn.isNominalConstructor()) {\n+      return getSymbolForInstancesOf(fn);\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Gets the symbol for the prototype of the given constructor or interface.\n+   */\n+  public Symbol getSymbolForInstancesOf(FunctionType fn) {\n+    Preconditions.checkState(fn.isConstructor() || fn.isInterface());\n+    ObjectType pType = fn.getPrototype();\n+    String name = pType.getReferenceName();\n+    if (name == null || globalScope == null) {\n+      return null;\n+    }\n+\n+    Node source = fn.getSource();\n+    return (source == null ?\n+        globalScope : getEnclosingScope(source)).getSlot(name);\n+  }\n+\n+  /**\n+   * Gets all symbols associated with the given type.\n+   * For union types, this may be multiple symbols.\n+   */\n+  public List<Symbol> getAllSymbolsForType(JSType type) {\n     if (type == null) {\n       return ImmutableList.of();\n     }\n+\n     UnionType unionType = type.toMaybeUnionType();\n     if (unionType != null) {\n       List<Symbol> result = Lists.newArrayListWithExpectedSize(2);\n       for (JSType alt : unionType.getAlternates()) {\n-        result.addAll(getAllSymbolsForType(alt, scope));\n+        // Our type system never has nested unions.\n+        Symbol altSym = getOnlySymbolForType(alt);\n+        if (altSym != null) {\n+          result.add(altSym);\n+        }\n       }\n       return result;\n+    }\n+    Symbol result = getOnlySymbolForType(type);\n+    return result == null\n+        ? ImmutableList.<Symbol>of() : ImmutableList.of(result);\n+  }\n+\n+  /**\n+   * Gets all symbols associated with the given type.\n+   * If there are more that one symbol associated with the given type,\n+   * return null.\n+   */\n+  private Symbol getOnlySymbolForType(JSType type) {\n+    if (type == null) {\n+      return null;\n     }\n \n     FunctionType fnType = type.toMaybeFunctionType();\n     if (fnType != null) {\n-      Symbol result = globalScope.getSlot(\"Function\");\n-      return result == null ?\n-          ImmutableList.<Symbol>of() : ImmutableList.of(result);\n+      return globalScope.getSlot(\"Function\");\n     }\n \n     ObjectType objType = type.toObjectType();\n     if (objType != null) {\n       String name = objType.getReferenceName();\n-      Symbol result = scope.getSlot(\n+\n+      FunctionType ctor = objType.getConstructor();\n+      Node sourceNode = ctor == null ? null : ctor.getSource();\n+      SymbolScope scope = sourceNode == null\n+          ? globalScope : getEnclosingScope(sourceNode);\n+\n+      return scope.getSlot(\n           (name == null || !objType.isInstanceType())\n           ? \"Object\" : name);\n-      return result == null\n-          ? ImmutableList.<Symbol>of() : ImmutableList.of(result);\n     }\n \n     // TODO(nicksantos): Create symbols for value types (number, string).\n-    return ImmutableList.of();\n+    return null;\n   }\n \n   public String toDebugString() {\n         // If we have a declaration node, we can ensure the symbol is declared.\n         mySymbol = symbols.get(declNode, name);\n         if (mySymbol == null) {\n-          mySymbol = new Symbol(\n-              name,\n-              otherSymbol.getType(),\n-              otherSymbol.isTypeInferred(),\n-              myScope);\n-          symbols.put(declNode, name, mySymbol);\n-          myScope.ownSymbols.put(name, mySymbol);\n-\n-          mySymbol.setDeclaration(new Reference(mySymbol, declNode));\n+          mySymbol = copySymbolTo(otherSymbol, myScope);\n         }\n       } else {\n         // If we don't have a declaration node, we won't be able to declare\n           mySymbol.defineReferenceAt(otherRef.getNode());\n         }\n       }\n+    }\n+  }\n+\n+  private Symbol copySymbolTo(StaticSlot<JSType> sym, SymbolScope scope) {\n+    return declareSymbol(\n+        sym.getName(), sym.getType(), sym.isTypeInferred(), scope,\n+        // All symbols must have declaration nodes.\n+        Preconditions.checkNotNull(sym.getDeclaration().getNode()));\n+  }\n+\n+  private Symbol declareSymbol(\n+      String name, JSType type, boolean inferred,\n+      SymbolScope scope, Node declNode) {\n+    Symbol symbol = new Symbol(name, type, inferred, scope);\n+    symbols.put(declNode, name, symbol);\n+\n+    Symbol replacedSymbol = scope.ownSymbols.put(name, symbol);\n+    Preconditions.checkState(replacedSymbol == null);\n+\n+    symbol.setDeclaration(new Reference(symbol, declNode));\n+    return symbol;\n+  }\n+\n+  private void removeSymbol(Symbol s) {\n+    SymbolScope scope = getScope(s);\n+    if (scope.ownSymbols.remove(s.getName()) != s) {\n+      throw new IllegalStateException(\"Symbol not found in scope \" + s);\n+    }\n+    if (symbols.remove(s.getDeclaration().getNode(), s.getName()) != s) {\n+      throw new IllegalStateException(\"Symbol not found in table \" + s);\n     }\n   }\n \n   }\n \n   /**\n+   * Create symbols and references for all properites of types in\n+   * this symbol table.\n+   *\n+   * This gets a little bit tricky, because of the way this symbol table\n+   * conflates \"type Foo\" and \"the constructor of type Foo\". So if you\n+   * have:\n+   *\n+   * <code>\n+   * SymbolTable symbolTale = for(\"var x = new Foo();\");\n+   * Symbol x = symbolTable.getGlobalScope().getSlot(\"x\");\n+   * Symbol type = symbolTable.getOnlySymbolForType(x.getType());\n+   * </code>\n+   *\n+   * Then type.getPropertyScope() will have the properties of the\n+   * constructor \"Foo\". To get the properties of instances of \"Foo\",\n+   * you will need to call:\n+   *\n+   * <code>\n+   * Symbol instance = symbolTable.getSymbolForInstancesOf(type);\n+   * </code>\n+   *\n+   * As described at the top of this file, notice that \"new Foo()\" and\n+   * \"Foo.prototype\" are represented by the same symbol.\n+   */\n+  void fillPropertySymbols(\n+      AbstractCompiler compiler, Node externs, Node root) {\n+    // Collect all ctors and interface ctors.\n+    // We need to create these lists first, so that we don't end up\n+    // mutating the symbol table while we're creating new symbols.\n+    List<Symbol> types = Lists.newArrayList();\n+    List<Symbol> instances = Lists.newArrayList();\n+    for (Symbol sym : getAllSymbols()) {\n+      FunctionType t = sym.getFunctionType();\n+      if (t != null && t.isNominalConstructor()) {\n+        types.add(sym);\n+\n+        Symbol instance = getSymbolForInstancesOf(t);\n+        if (instance != null) {\n+          instances.add(instance);\n+        }\n+      }\n+    }\n+\n+    // Create symbols for their properties.\n+    for (Symbol s : Iterables.concat(types, instances)) {\n+      createPropertyScopeFor(s);\n+    }\n+\n+    (new PropertyRefCollector(compiler)).process(externs, root);\n+  }\n+\n+  private void createPropertyScopeFor(Symbol s) {\n+    // In order to build a property scope for s, we will need to build\n+    // a property scope for all its implicit prototypes first. This means\n+    // that sometimes we will already have built its property scope\n+    // for a previous symbol.\n+    if (s.propertyScope != null) {\n+      return;\n+    }\n+\n+    SymbolScope parentPropertyScope = null;\n+    ObjectType type = s.getType().toObjectType();\n+    ObjectType proto = type.getParentScope();\n+    if (proto != null && proto != type && proto.getConstructor() != null) {\n+      Symbol parentSymbol = getSymbolForInstancesOf(proto.getConstructor());\n+      if (parentSymbol != null) {\n+        createPropertyScopeFor(parentSymbol);\n+        parentPropertyScope = parentSymbol.getPropertyScope();\n+      }\n+    }\n+\n+    ObjectType instanceType = type;\n+    Iterable<String> propNames = type.getOwnPropertyNames();\n+    if (instanceType.isFunctionPrototypeType()) {\n+      // Merge the properties of \"Foo.prototype\" and \"new Foo()\" together.\n+      instanceType =\n+          ((ObjectType) instanceType)\n+          .getOwnerFunction().getInstanceType();\n+      Set<String> set = Sets.newHashSet(propNames);\n+      Iterables.addAll(set, instanceType.getOwnPropertyNames());\n+      propNames = set;\n+    }\n+\n+    s.propertyScope = new SymbolScope(null, parentPropertyScope, type);\n+    for (String propName : propNames) {\n+      StaticSlot<JSType> newProp = instanceType.getSlot(propName);\n+      if (newProp.getDeclaration() == null) {\n+        // Skip properties without declarations. We won't know how to index\n+        // them, because we index things by node.\n+        continue;\n+      }\n+\n+      // We have symbol tables that do not do type analysis. They just try\n+      // to build a complete index of all objects in the program. So we might\n+      // already have symbols for things like \"Foo.bar\". If this happens,\n+      // throw out the old symbol and use the type-based symbol.\n+      Symbol oldProp = getScope(s).getSlot(s.getName() + \".\" + propName);\n+      if (oldProp != null) {\n+        removeSymbol(oldProp);\n+      }\n+\n+      copySymbolTo(newProp, s.propertyScope);\n+    }\n+  }\n+\n+  /**\n    * Given a scope from another symbol table, returns the {@code SymbolScope}\n    * rooted at the same node. Creates one if it doesn't exist yet.\n    */\n \n     private final SymbolScope scope;\n \n+    private SymbolScope propertyScope = null;\n+\n     private Reference declaration = null;\n \n     Symbol(String name, JSType type, boolean inferred, SymbolScope scope) {\n     @Override\n     public Reference getDeclaration() {\n       return declaration;\n+    }\n+\n+    public FunctionType getFunctionType() {\n+      return JSType.toMaybeFunctionType(getType());\n     }\n \n     void defineReferenceAt(Node n) {\n     public String getSourceFileName() {\n       Node n = getDeclarationNode();\n       return n == null ? null : n.getSourceFileName();\n+    }\n+\n+    public SymbolScope getPropertyScope() {\n+      return propertyScope;\n     }\n \n     @Override\n     }\n \n     public boolean isGlobalScope() {\n-      return getParentScope() == null;\n+      return getParentScope() == null && getRootNode() != null;\n+    }\n+\n+    public boolean isPropertyScope() {\n+      return getRootNode() == null;\n+    }\n+  }\n+\n+  private class PropertyRefCollector\n+      extends NodeTraversal.AbstractPostOrderCallback\n+      implements CompilerPass {\n+    private final AbstractCompiler compiler;\n+\n+    PropertyRefCollector(AbstractCompiler compiler) {\n+      this.compiler = compiler;\n+    }\n+\n+    @Override\n+    public void process(Node externs, Node root) {\n+      NodeTraversal.traverseRoots(\n+          compiler,\n+          Lists.newArrayList(externs, root),\n+          this);\n+    }\n+\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      if (n.getType() == Token.GETPROP) {\n+        JSType owner = n.getFirstChild().getJSType();\n+        if (owner == null) {\n+          return;\n+        }\n+\n+        String propName = n.getLastChild().getString();\n+        if (owner.isNominalConstructor()) {\n+          Symbol sym = getSymbolDeclaredBy(owner.toMaybeFunctionType());\n+          if (sym == null || sym.getPropertyScope() == null) {\n+            // This will happen in some rare cases where there are no\n+            // extern declarations for built-in types (like Function).\n+            return;\n+          }\n+\n+          Symbol prop = sym.getPropertyScope().getSlot(propName);\n+          if (prop != null) {\n+            prop.defineReferenceAt(n);\n+          }\n+        } else {\n+          for (Symbol ctor : getAllSymbolsForType(owner)) {\n+            Symbol sym = getSymbolForInstancesOf(ctor);\n+            if (sym != null) {\n+              Symbol prop = sym.getPropertyScope().getSlot(propName);\n+              if (prop != null) {\n+                prop.defineReferenceAt(n);\n+              }\n+            }\n+          }\n+        }\n+      }\n     }\n   }\n }\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n    */\n   public boolean isNominalType() {\n     return false;\n+  }\n+\n+  /**\n+   * Whether this type is the original constructor of a nominal type.\n+   * Does not include structural constructors.\n+   */\n+  public final boolean isNominalConstructor() {\n+    return (isConstructor() || isInterface()) &&\n+        toMaybeFunctionType().getInstanceType().isNominalType();\n   }\n \n   /**\n--- a/src/com/google/javascript/rhino/jstype/ObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ObjectType.java\n   public Node getRootNode() { return null; }\n \n   @Override\n-  public StaticScope<JSType> getParentScope() {\n+  public ObjectType getParentScope() {\n     return getImplicitPrototype();\n   }\n \n--- a/test/com/google/javascript/jscomp/SymbolTableTest.java\n+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java\n   }\n \n   public void testNamespacedReferences() throws Exception {\n+    // Because the type of goog is anonymous, we build its properties into\n+    // the global scope.\n     SymbolTable table = createSymbolTable(\n         \"var goog = {};\" +\n         \"goog.dom = {};\" +\n     Symbol googDomHelper = getGlobalVar(table, \"goog.dom.DomHelper\");\n     assertNotNull(googDomHelper);\n     assertEquals(1, Iterables.size(table.getReferences(googDomHelper)));\n+  }\n+\n+  public void testRemovalOfNamespacedReferencesOfProperties()\n+      throws Exception {\n+    SymbolTable table = createSymbolTable(\n+        \"/** @constructor */ var DomHelper = function(){};\" +\n+        \"/** method */ DomHelper.method = function() {};\");\n+\n+    Symbol domHelper = getGlobalVar(table, \"DomHelper\");\n+    assertNotNull(domHelper);\n+\n+    Symbol domHelperNamespacedMethod = getGlobalVar(table, \"DomHelper.method\");\n+    assertNull(domHelperNamespacedMethod);\n+\n+    Symbol domHelperMethod = domHelper.getPropertyScope().getSlot(\"method\");\n+    assertNotNull(domHelperMethod);\n   }\n \n   public void testGoogScopeReferences() throws Exception {\n         foo,\n         table.getSymbolDeclaredBy(\n             foo.getType().toMaybeFunctionType()));\n+  }\n+\n+  public void testStaticMethodReferences() throws Exception {\n+    SymbolTable table = createSymbolTable(\n+        \"/** @constructor */ var DomHelper = function(){};\" +\n+        \"/** method */ DomHelper.method = function() {};\" +\n+        \"function f() { var x = DomHelper; x.method() + x.method(); }\");\n+\n+    Symbol method =\n+        getGlobalVar(table, \"DomHelper\").getPropertyScope().getSlot(\"method\");\n+    assertEquals(\n+        3, Iterables.size(table.getReferences(method)));\n+  }\n+\n+  public void testMethodReferences() throws Exception {\n+    SymbolTable table = createSymbolTable(\n+        \"/** @constructor */ var DomHelper = function(){};\" +\n+        \"/** method */ DomHelper.prototype.method = function() {};\" +\n+        \"function f() { \" +\n+        \"  (new DomHelper()).method(); (new DomHelper()).method(); };\");\n+\n+    Symbol method =\n+        getGlobalVar(table, \"DomHelper.prototype\")\n+        .getPropertyScope().getSlot(\"method\");\n+    assertEquals(\n+        3, Iterables.size(table.getReferences(method)));\n+  }\n+\n+  public void testFieldReferences() throws Exception {\n+    SymbolTable table = createSymbolTable(\n+        \"/** @constructor */ var DomHelper = function(){\" +\n+        \"  /** @type {number} */ this.field = 3;\" +\n+        \"};\" +\n+        \"function f() { \" +\n+        \"  return (new DomHelper()).field + (new DomHelper()).field; };\");\n+\n+    Symbol field =\n+        getGlobalVar(table, \"DomHelper.prototype\")\n+        .getPropertyScope().getSlot(\"field\");\n+    assertEquals(\n+        3, Iterables.size(table.getReferences(field)));\n+  }\n+\n+  public void testUndeclaredFieldReferences() throws Exception {\n+    // We do not currently create symbol table entries for undeclared fields,\n+    // but this may change in the future.\n+    SymbolTable table = createSymbolTable(\n+        \"/** @constructor */ var DomHelper = function(){};\" +\n+        \"DomHelper.prototype.method = function() { \" +\n+        \"  this.field = 3;\" +\n+        \"  return x.field;\" +\n+        \"}\");\n+\n+    Symbol field =\n+        getGlobalVar(table, \"DomHelper.prototype\")\n+        .getPropertyScope().getSlot(\"field\");\n+    assertNull(field);\n+  }\n+\n+  public void testPrototypeReferences() throws Exception {\n+    SymbolTable table = createSymbolTable(\n+        \"/** @constructor */ function DomHelper() {}\" +\n+        \"DomHelper.prototype.method = function() {};\");\n+    Symbol prototype =\n+        getGlobalVar(table, \"DomHelper.prototype\");\n+    assertNotNull(prototype);\n+\n+    List<Reference> refs = Lists.newArrayList(table.getReferences(prototype));\n+\n+    // One of the refs is implicit in the declaration of the function.\n+    assertEquals(2, refs.size());\n+  }\n+\n+  public void testPrototypeReferences2() throws Exception {\n+    SymbolTable table = createSymbolTable(\n+        \"/** @constructor */\\n\"\n+        + \"function Snork() {}\\n\"\n+        + \"Snork.prototype.baz = 3;\\n\");\n+    Symbol prototype =\n+        getGlobalVar(table, \"Snork.prototype\");\n+    assertNotNull(prototype);\n+\n+    List<Reference> refs = Lists.newArrayList(table.getReferences(prototype));\n+\n+    // TODO(nicksantos): This is a bug and should be fixed.\n+    // It has to do with some weirdness with how prototypes are handled\n+    // in our type system.\n+    assertEquals(1, refs.size());\n   }\n \n   private Symbol getGlobalVar(SymbolTable table, String name) {", "timestamp": 1314289430, "metainfo": ""}