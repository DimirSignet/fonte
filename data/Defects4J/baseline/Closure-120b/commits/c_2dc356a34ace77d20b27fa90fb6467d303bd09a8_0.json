{"sha": "2dc356a34ace77d20b27fa90fb6467d303bd09a8", "log": "Follow up on code review comments: preserve souce information during normalization. (John) R=nick DELTA=28  (22 added, 0 deleted, 6 changed)  Revision created by MOE tool push_codebase. MOE_MIGRATION=   ", "commit": "\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n    * @return Newly created EXPR node with the child as subexpression.\n    */\n   public static Node newExpr(Node child) {\n-    return new Node(Token.EXPR_RESULT, child);\n+    Node expr = new Node(Token.EXPR_RESULT, child);\n+    expr.copyInformationFrom(child);\n+    return expr;\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n           if (CONVERT_WHILE_TO_FOR) {\n             Node expr = n.getFirstChild();\n             n.setType(Token.FOR);\n-            n.addChildBefore(new Node(Token.EMPTY), expr);\n-            n.addChildAfter(new Node(Token.EMPTY), expr);\n+            Node empty = new Node(Token.EMPTY);\n+            empty.copyInformationFrom(n);\n+            n.addChildBefore(empty, expr);\n+            n.addChildAfter(empty.cloneNode(), expr);\n             reportCodeChange(\"WHILE node\");\n           }\n           break;\n           return;\n         default:\n           Node block = new Node(Token.BLOCK);\n+          block.copyInformationFrom(last);\n           n.replaceChild(last, block);\n           block.addChildToFront(last);\n           reportCodeChange(\"LABEL normalization\");\n             if (!NodeUtil.isForIn(c)\n                 && c.getFirstChild().getType() != Token.EMPTY) {\n               Node init = c.getFirstChild();\n-              c.replaceChild(init, new Node(Token.EMPTY));\n+              Node empty = new Node(Token.EMPTY);\n+              empty.copyInformationFrom(c);\n+              c.replaceChild(init, empty);\n \n               Node newStatement;\n               // Only VAR statements, and expressions are allowed,\n         Node value = n.getFirstChild();\n         n.removeChild(value);\n         Node replacement = new Node(Token.ASSIGN, n, value);\n-        gramps.replaceChild(parent, new Node(Token.EXPR_RESULT, replacement));\n+        replacement.copyInformationFrom(parent);\n+        gramps.replaceChild(parent, NodeUtil.newExpr(replacement));\n       } else {\n         // It is an empty reference remove it.\n         if (NodeUtil.isStatementBlock(gramps)) {\n           gramps.replaceChild(parent, n);\n         } else {\n           Preconditions.checkState(gramps.getType() == Token.LABEL);\n-          gramps.replaceChild(parent, new Node(Token.EMPTY));\n+          // We should never get here. LABELs with a single VAR statement should\n+          // already have been normalized to have a BLOCK.\n+          throw new IllegalStateException(\"Unexpected LABEL\");\n         }\n       }\n       reportCodeChange(\"Duplicate VAR declaration\");\n--- a/src/com/google/javascript/jscomp/PrepareAst.java\n+++ b/src/com/google/javascript/jscomp/PrepareAst.java\n         if (NodeUtil.isControlStructureCodeBlock(n,c) &&\n             c.getType() != Token.BLOCK) {\n           Node newBlock = new Node(Token.BLOCK);\n+          newBlock.copyInformationFrom(n);\n           n.replaceChild(c, newBlock);\n           if (c.getType() != Token.EMPTY) {\n             newBlock.addChildrenToFront(c);\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n           prev.addChildToBack(cur);\n         }\n         cur.addChildToBack(transform(label));\n+\n+        cur.setLineno(label.getLineno());\n+        int clauseAbsolutePosition =\n+            position2charno(label.getAbsolutePosition());\n+        cur.setCharno(clauseAbsolutePosition);\n+\n         prev = cur;\n         cur = new Node(Token.LABEL);\n       }\n--- a/test/com/google/javascript/jscomp/NodeTypeNormalizerTest.java\n+++ b/test/com/google/javascript/jscomp/NodeTypeNormalizerTest.java\n  */\n public class NodeTypeNormalizerTest extends CompilerTestCase {\n \n+  public NodeTypeNormalizerTest() {\n+    super.enableLineNumberCheck(true);\n+  }\n+\n   @Override\n   public CompilerPass getProcessor(Compiler compiler) {\n     return null; // unused\n--- a/test/com/google/javascript/jscomp/NormalizeTest.java\n+++ b/test/com/google/javascript/jscomp/NormalizeTest.java\n \n   public NormalizeTest() {\n     super(EXTERNS);\n+    super.enableLineNumberCheck(true);\n   }\n \n   @Override", "timestamp": 1269379623, "metainfo": ""}