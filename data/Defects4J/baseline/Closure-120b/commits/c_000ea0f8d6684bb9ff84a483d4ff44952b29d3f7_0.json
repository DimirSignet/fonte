{"sha": "000ea0f8d6684bb9ff84a483d4ff44952b29d3f7", "log": "Automated g4 rollback of changelist 50726739.  *** Reason for rollback ***  Wants to move back to early iteration of the CL.  *** Original change description ***  Fix inlining bug in https://code.google.com/p/closure-compiler/issues/detail?id=1053 ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=50728194", "commit": "\n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n       // reference data is out of sync. We're better off just waiting for\n       // the next pass.)\n       if (!maybeModifiedArguments &&\n-          !staleVars.contains(v) &&\n-          referenceInfo.isWellDefined() &&\n-          referenceInfo.isAssignedOnceInLifetime() &&\n-          // Inlining the variable based solely on well-defined and assigned\n-          // once is *NOT* correct. We relax the correctness requirement if\n-          // the variable is declared constant.\n-          (isInlineableDeclaredConstant(v, referenceInfo) ||\n-           referenceInfo.isOnlyAssignmentSameScopeAsDeclaration())) {\n+          !staleVars.contains(v) && referenceInfo.isWellDefined() &&\n+          referenceInfo.isAssignedOnceInLifetime()) {\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n           Node nameNode = refs.get(i).getNode();\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n       if (ref == null) {\n         return false;\n       }\n-      \n+\n       // Make sure this assignment is not in a loop.\n       for (BasicBlock block = ref.getBasicBlock();\n            block != null; block = block.getParent()) {\n           break;\n         } else if (block.isLoop) {\n           return false;\n-        }\n-      }\n-\n-      return true;\n-    }\n-    \n-    /**\n-     * @return Whether the variable is only assigned a value once for its\n-     *     lifetime.\n-     */\n-    boolean isOnlyAssignmentSameScopeAsDeclaration() {\n-      Reference ref = getOneAndOnlyAssignment();\n-      Preconditions.checkNotNull(ref);\n-      \n-      // Make sure the declaration is the same scope as the assignment.\n-      // Otherwise, the variable can be assigned multiple times and possibly\n-      // with a different variable.\n-      for (BasicBlock block = ref.getBasicBlock();\n-           block != null; block = block.getParent()) {\n-        if (block.isFunction) {\n-          if (ref.getSymbol().getScope() != ref.scope) {\n-            return false;\n-          }\n         }\n       }\n \n--- a/test/com/google/javascript/jscomp/InlineVariablesTest.java\n+++ b/test/com/google/javascript/jscomp/InlineVariablesTest.java\n         \"F.prototype.inc = function() { this.a++; return 10; };\" +\n         \"F.prototype.bar = function() { var x = this.inc(); this.a += x; };\");\n   }\n-\n-  public void testExternalIssue1053() {\n-    testSame(\n-        \"var u; function f() { u = Random(); var x = u; f(); alert(x===u)}\");\n-  }\n }", "timestamp": 1376348930, "metainfo": ""}