{"sha": "d6f92e5de267c39d29182cfa89b2f01b7710b607", "log": "Make sure that properties are not defined on objects before they're defined Fixes issue 312.  R=acleung DELTA=97  (72 added, 5 deleted, 20 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1676   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CheckGlobalNames.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalNames.java\n   static final DiagnosticType UNDEFINED_NAME_WARNING = DiagnosticType.warning(\n       \"JSC_UNDEFINED_NAME\",\n       \"{0} is never defined\");\n+\n+  static final DiagnosticType NAME_DEFINED_LATE_WARNING =\n+      DiagnosticType.warning(\n+          \"JSC_NAME_DEFINED_LATE\",\n+          \"{0} is not defined yet, so properties cannot be defined on it\");\n \n   static final DiagnosticType STRICT_MODULE_DEP_QNAME =\n       DiagnosticType.disabled(\n     // If the name is not defined, emit warnings for each reference. While\n     // we're looking through each reference, check all the module dependencies.\n     Ref declaration = name.declaration;\n-    if (!isDefined) {\n-      if (declaration != null) {\n-        reportRefToUndefinedName(name, declaration);\n-      }\n+    Name parent = name.parent;\n+    if (isDefined &&\n+        declaration != null &&\n+        parent != null &&\n+        parent.declaration != null &&\n+        parent.localSets == 0 &&\n+        parent.declaration.preOrderIndex > declaration.preOrderIndex) {\n+      compiler.report(\n+          JSError.make(declaration.source.getName(), declaration.node,\n+              NAME_DEFINED_LATE_WARNING, parent.fullName()));\n     }\n \n     JSModuleGraph moduleGraph = compiler.getModuleGraph();\n     for (Ref ref : name.getRefs()) {\n-      if (ref == name.declaration) {\n-        continue;\n-      }\n-\n       if (!isDefined) {\n         reportRefToUndefinedName(name, ref);\n       } else {\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n \n   private static class NullAliasTransformationHandler\n       implements AliasTransformationHandler, Serializable {\n+    private static final long serialVersionUID = 0L;\n \n     private static final AliasTransformation NULL_ALIAS_TRANSFORMATION =\n         new NullAliasTransformation();\n \n     private static class NullAliasTransformation\n         implements AliasTransformation, Serializable {\n+      private static final long serialVersionUID = 0L;\n+\n       @Override\n       public void addAlias(String alias, String definition) {\n       }\n--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n import com.google.common.base.Predicate;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n-import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n   private boolean inExterns;\n   private Scope externsScope;\n   private boolean generated = false;\n+\n+  /**\n+   * Each reference has an index in post-order.\n+   * Notice that some nodes are represented by 2 Ref objects, so\n+   * this index is not necessarily unique.\n+   */\n+  private int currentPreOrderIndex = 0;\n \n   /** Global namespace tree */\n   private List<Name> globalNames = new ArrayList<Name>();\n   /**\n    * Builds a tree representation of the global namespace. Omits prototypes.\n    */\n-  private class BuildGlobalNamespace extends AbstractPostOrderCallback {\n+  private class BuildGlobalNamespace implements NodeTraversal.Callback {\n \n     private final Predicate<Node> nodeFilter;\n \n     }\n \n     @Override\n-    public void visit(NodeTraversal t, Node n, Node parent) {\n+    public void visit(NodeTraversal t, Node n, Node parent) {}\n+\n+    /** Collect the references in pre-order. */\n+    @Override\n+    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n+      collect(t, n, parent);\n+      return true;\n+    }\n+\n+    public void collect(NodeTraversal t, Node n, Node parent) {\n       if (nodeFilter != null && !nodeFilter.apply(n)) {\n         return;\n       }\n       Name nameObj = getOrCreateName(name);\n       nameObj.type = type;\n \n-      Ref set = new Ref(t, n, Ref.Type.SET_FROM_GLOBAL);\n+      Ref set = new Ref(t, n, Ref.Type.SET_FROM_GLOBAL,\n+          currentPreOrderIndex++);\n       nameObj.addRef(set);\n \n       if (isNestedAssign(parent)) {\n         // This assignment is both a set and a get that creates an alias.\n-        Ref get = new Ref(t, n, Ref.Type.ALIASING_GET);\n+        Ref get = new Ref(t, n, Ref.Type.ALIASING_GET,\n+            currentPreOrderIndex++);\n         nameObj.addRef(get);\n         Ref.markTwins(set, get);\n       } else if (isConstructorOrEnumDeclaration(n, parent)) {\n       if (maybeHandlePrototypePrefix(t, n, parent, name)) return;\n \n       Name node = getOrCreateName(name);\n-      Ref set = new Ref(t, n, Ref.Type.SET_FROM_LOCAL);\n+      Ref set = new Ref(t, n, Ref.Type.SET_FROM_LOCAL, currentPreOrderIndex++);\n       node.addRef(set);\n \n       if (isNestedAssign(parent)) {\n         // This assignment is both a set and a get that creates an alias.\n-        Ref get = new Ref(t, n, Ref.Type.ALIASING_GET);\n+        Ref get = new Ref(t, n, Ref.Type.ALIASING_GET, currentPreOrderIndex++);\n         node.addRef(get);\n         Ref.markTwins(set, get);\n       }\n       Name node = getOrCreateName(name);\n \n       // No need to look up additional ancestors, since they won't be used.\n-      node.addRef(new Ref(t, n, type));\n+      node.addRef(new Ref(t, n, type, currentPreOrderIndex++));\n     }\n \n     /**\n     final Type type;\n     final CompilerInput source;\n     final Scope scope;\n+    final int preOrderIndex;\n \n     /**\n      * Certain types of references are actually double-refs. For example,\n     /**\n      * Creates a reference at the current node.\n      */\n-    Ref(NodeTraversal t, Node name, Type type) {\n+    Ref(NodeTraversal t, Node name, Type type, int index) {\n       this.node = name;\n       this.source = t.getInput();\n       this.type = type;\n       this.scope = t.getScope();\n-    }\n-\n-    private Ref(Ref original, Type type) {\n+      this.preOrderIndex = index;\n+    }\n+\n+    private Ref(Ref original, Type type, int index) {\n       this.node = original.node;\n       this.source = original.source;\n       this.type = type;\n       this.scope = original.scope;\n-    }\n-\n-    private Ref(Type type) {\n+      this.preOrderIndex = index;\n+    }\n+\n+    private Ref(Type type, int index) {\n       this.type = type;\n       this.source = null;\n       this.scope = null;\n+      this.preOrderIndex = index;\n     }\n \n     JSModule getModule() {\n      * a different class.\n      */\n     Ref cloneAndReclassify(Type type) {\n-      return new Ref(this, type);\n+      return new Ref(this, type, this.preOrderIndex);\n     }\n \n     static Ref createRefForTesting(Type type) {\n-      return new Ref(type);\n+      return new Ref(type, -1);\n     }\n   }\n }\n--- a/test/com/google/javascript/jscomp/CheckGlobalNamesTest.java\n+++ b/test/com/google/javascript/jscomp/CheckGlobalNamesTest.java\n \n package com.google.javascript.jscomp;\n \n+import static com.google.javascript.jscomp.CheckGlobalNames.NAME_DEFINED_LATE_WARNING;\n import static com.google.javascript.jscomp.CheckGlobalNames.UNDEFINED_NAME_WARNING;\n import static com.google.javascript.jscomp.CheckGlobalNames.STRICT_MODULE_DEP_QNAME;\n \n         NAMES\n     ), UNDEFINED_NAME_WARNING);\n   }\n+\n+  public void testLateDefinedName1() {\n+    testSame(\"x.y = {}; var x = {};\", NAME_DEFINED_LATE_WARNING);\n+  }\n+\n+  public void testLateDefinedName2() {\n+    testSame(\"var x = {}; x.y.z = {}; x.y = {};\", NAME_DEFINED_LATE_WARNING);\n+  }\n+\n+  public void testLateDefinedName3() {\n+    testSame(\"var x = {}; x.y.z = {}; x.y = {z: {}};\",\n+        NAME_DEFINED_LATE_WARNING);\n+  }\n+\n+  public void testLateDefinedName4() {\n+    testSame(\"var x = {}; x.y.z.bar = {}; x.y = {z: {}};\",\n+        NAME_DEFINED_LATE_WARNING);\n+  }\n+\n+  public void testOkLateDefinedName1() {\n+    testSame(\"function f() { x.y = {}; } var x = {};\");\n+  }\n+\n+  public void testOkLateDefinedName2() {\n+    testSame(\"var x = {}; function f() { x.y.z = {}; } x.y = {};\");\n+  }\n+\n+  public void testPathologicalCaseThatsOkAnyway() {\n+    testSame(\n+        \"var x = {};\" +\n+        \"switch (x) { \" +\n+        \"  default: x.y.z = {}; \" +\n+        \"  case (x.y = {}): break;\" +\n+        \"}\", NAME_DEFINED_LATE_WARNING);\n+  }\n }", "timestamp": 1304033356, "metainfo": ""}