{"sha": "e33e925eea3a8e4de958864e531e1adc4da62e18", "log": "Change on 2010/06/14 by johnlenz          Remove unneed parenthese from hook expressions.          R=acleung         DELTA=76  (20 added, 4 deleted, 52 changed)  Change on 2010/06/14 by johnlenz          Fix non-determinisim.          R=jschorr         DELTA=5  (3 added, 0 deleted, 2 changed)  Change on 2010/06/15 by nicksantos          fix a regression caused by a change in the ordering in which         constant folding is done.         parts of PeepholeSubstituteAlternateSyntax will crash if they         see a NEG node with a NUMBER child.         They were assuming that FoldConstants would fold these into one node.          R=dcc,acleung         DELTA=153  (70 added, 6 deleted, 77 changed)  Change on 2010/06/15 by johnlenz          More debug diffing improvements: convert unique globally unique names         to locally unique names for reproduciblity.          R=acleung         DELTA=222  (44 added, 7 deleted, 171 changed)  Change on 2010/06/15 by nicksantos          Add the @nocompile annotation as a signal that this file should         be dropped silently if it gets pulled into a --manage_closure_dependencies         build.          R=bowdidge,gboyer         DELTA=82  (60 added, 1 deleted, 21 changed)  Change on 2010/06/15 by dcc          Refactor FoldConstants dead code removal into PeepholeRemoveDeadCode.          R=acleung         DELTA=744  (403 added, 307 deleted, 34 changed)  Change on 2010/06/15 by dcc          ExternExports test now emits type annotation for exported externs.                 - Changed ExternExportsPass to generate the externs as an AST and then print         to a String rather than ad hoc with a StringBuilder.                 - Changed TypedCodeGenerator to generate '*' (AllType) for parameters with unknown types rather than '?' (UnknownType) since '?' is not valid JSDoc.          R=acleung         DELTA=643  (496 added, 66 deleted, 81 changed)  Change on 2010/06/16 by johnlenz          Tweak to PureFunctionIndentifier to propagate the side-effects for         anonymous function expressions like: (Date.now||function(){return         +new Date})()          R=avd         DELTA=42  (39 added, 0 deleted, 3 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=29010   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CheckMissingReturn.java\n+++ b/src/com/google/javascript/jscomp/CheckMissingReturn.java\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.JSTypeNative;\n+import com.google.javascript.rhino.jstype.TernaryValue;\n \n /**\n  * Checks functions for missing return statements. Return statements are only\n         // constants. We DO have a full blown ReverseAbstractInterupter and\n         // type system that can evaluate some impressions' boolean value but\n         // for now we will keep this pass lightweight.\n-        if (condition != null && NodeUtil.isLiteralValue(condition) ) {\n-          return NodeUtil.getBooleanValue(condition) ==\n-            (Branch.ON_TRUE == branch);\n+        if (condition != null) {\n+          TernaryValue val = NodeUtil.getBooleanValue(condition);\n+          if (val != TernaryValue.UNKNOWN) {\n+            return val.toBoolean(true) == (Branch.ON_TRUE == branch);\n+          }\n         }\n       }\n       return true;\n--- a/src/com/google/javascript/jscomp/CheckUnreachableCode.java\n+++ b/src/com/google/javascript/jscomp/CheckUnreachableCode.java\n import com.google.javascript.jscomp.graph.GraphReachability.EdgeTuple;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.TernaryValue;\n \n /**\n  * Use {@link ControlFlowGraph} and {@link GraphReachability} to inform user\n     this.compiler = compiler;\n     this.level = level;\n   }\n-  \n+\n   @Override\n   public void enterScope(NodeTraversal t) {\n     new GraphReachability<Node, ControlFlowGraph.Branch>(\n     }\n     return true;\n   }\n-  \n+\n   @Override\n   public void exitScope(NodeTraversal t) {\n   }\n   @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n   }\n-  \n+\n   private final class ReachablePredicate implements\n       Predicate<EdgeTuple<Node, ControlFlowGraph.Branch>> {\n \n       }\n       Node predecessor = input.sourceNode;\n       Node condition = NodeUtil.getConditionExpression(predecessor);\n-      \n+\n       // TODO(user): Handle more complicated expression like true == true,\n       // etc....\n-      if (condition != null && NodeUtil.isImmutableValue(condition)) {\n-        return NodeUtil.getBooleanValue(condition) ==\n-            (branch == Branch.ON_TRUE);\n+      if (condition != null) {\n+        TernaryValue val = NodeUtil.getBooleanValue(condition);\n+        if (val != TernaryValue.UNKNOWN) {\n+          return val.toBoolean(true) == (branch == Branch.ON_TRUE);\n+        }\n       }\n       return true;\n     }\n   }\n-}\n+}\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n         int p = NodeUtil.precedence(type);\n         addLeftExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n-        addExpr(first.getNext(), p);\n+        addExpr(first.getNext(), 1);\n         cc.addOp(\":\", true);\n-        addExpr(last, p);\n+        addExpr(last, 1);\n         break;\n       }\n \n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter;\n import com.google.javascript.jscomp.parsing.Config;\n import com.google.javascript.jscomp.parsing.ParserRunner;\n+import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n         }\n       }\n \n-      // Check if externs files need to be lifted.\n-      boolean liftedExterns = false;\n+      // Check if inputs need to be rebuilt from modules.\n+      boolean staleInputs = false;\n       for (CompilerInput input : inputs) {\n         Node n = input.getAstRoot(this);\n         if (hasErrors()) {\n           continue;\n         }\n \n-        if (n.getJSDocInfo() != null && n.getJSDocInfo().isExterns()) {\n-          // If the input file is explicitly marked as an externs file, then\n-          // assume the programmer made a mistake and throw it into\n-          // the externs pile anyways.\n-          externsRoot.addChildToBack(n);\n-          input.setIsExtern(true);\n-\n-          // TODO(nicksantos): We need a better mechanism to make sure\n-          // changes to the inputs array get reflected in JSModules.\n-          input.getModule().remove(input);\n-\n-          externs.add(input);\n-          liftedExterns = true;\n-        }\n-      }\n-\n-      if (liftedExterns) {\n+        if (n.getJSDocInfo() != null) {\n+          JSDocInfo info = n.getJSDocInfo();\n+          if (info.isExterns()) {\n+            // If the input file is explicitly marked as an externs file, then\n+            // assume the programmer made a mistake and throw it into\n+            // the externs pile anyways.\n+            externsRoot.addChildToBack(n);\n+            input.setIsExtern(true);\n+\n+            input.getModule().remove(input);\n+\n+            externs.add(input);\n+            staleInputs = true;\n+          } else if (info.isNoCompile()) {\n+            input.getModule().remove(input);\n+            staleInputs = true;\n+          }\n+        }\n+      }\n+\n+      if (staleInputs) {\n         fillEmptyModules(modules);\n         rebuildInputsFromModules();\n       }\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Charsets;\n import com.google.common.base.Preconditions;\n-import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n   };\n \n   /** Various peephole optimizations. */\n-  private static final PassFactory peepholeOptimizations =\n+  static final PassFactory peepholeOptimizations =\n       new PassFactory(\"peepholeOptimizations\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n-\n-      ImmutableSet<AbstractPeepholeOptimization> optimizations =\n-        ImmutableSet.<AbstractPeepholeOptimization>of(\n-            new PeepholeSubstituteAlternateSyntax());\n-\n-      final PeepholeOptimizationsPass peepholePass =\n-          new PeepholeOptimizationsPass(compiler, optimizations);\n-\n-      return peepholePass;\n+      return new PeepholeOptimizationsPass(compiler,\n+            new PeepholeSubstituteAlternateSyntax(),\n+            new PeepholeRemoveDeadCode());\n     }\n   };\n \n--- a/src/com/google/javascript/jscomp/DefinitionsRemover.java\n+++ b/src/com/google/javascript/jscomp/DefinitionsRemover.java\n \n     if (NodeUtil.isVarDeclaration(n) && n.hasChildren()) {\n       return new VarDefinition(n);\n-    } else if(NodeUtil.isFunction(parent) && parent.getFirstChild() == n) {\n+    } else if (NodeUtil.isFunction(parent) && parent.getFirstChild() == n) {\n       if (!NodeUtil.isFunctionExpression(parent)) {\n         return new NamedFunctionDefinition(parent);\n       } else if (!n.getString().equals(\"\")) {\n--- a/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n+++ b/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Preconditions;\n import com.google.common.base.Supplier;\n+import com.google.javascript.jscomp.MakeDeclaredNamesUnique.ContextualRenamer;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n     return newCall;\n   }\n \n-  private String tempNamePrefix = \"JSCompiler_temp_\";\n+  private String tempNamePrefix = \"JSCompiler_temp\";\n \n   /**\n    * Allow the temp name to be overriden to make tests more readable.\n    * Create a unique temp name.\n    */\n   private String getTempValueName(){\n-    return tempNamePrefix + safeNameIdSupplier.get();\n+    return tempNamePrefix + ContextualRenamer.UNIQUE_ID_SEPARATOR\n+        + safeNameIdSupplier.get();\n   }\n \n   /**\n    * Create a constant unique temp name.\n    */\n   private String getTempConstantValueName(){\n-    String sName = tempNamePrefix + \"const_\" + safeNameIdSupplier.get();\n-    this.knownConstants.add(sName);\n-    return sName;\n+    String name = tempNamePrefix + \"_const\"\n+        + ContextualRenamer.UNIQUE_ID_SEPARATOR\n+        + safeNameIdSupplier.get();\n+    this.knownConstants.add(name);\n+    return name;\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/ExternExportsPass.java\n+++ b/src/com/google/javascript/jscomp/ExternExportsPass.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Joiner;\n+import com.google.common.base.Preconditions;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n-\n+import com.google.javascript.rhino.jstype.FunctionType;\n+import com.google.javascript.rhino.jstype.JSType;\n \n import java.util.Comparator;\n import java.util.List;\n  * for later consumption.\n  *\n *\n+ * @author dcc@google.com (Devin Coughlin)\n  */\n-class ExternExportsPass extends NodeTraversal.AbstractPostOrderCallback\n+final class ExternExportsPass extends NodeTraversal.AbstractPostOrderCallback\n     implements CompilerPass {\n \n+  static final DiagnosticType EXPORTED_FUNCTION_UNKNOWN_PARAMETER_TYPE =\n+    DiagnosticType.warning(\n+        \"JSC_EXPORTED_FUNCTION_UNKNOWN_PARAMETER_TYPE\",\n+        \"Unable to determine type of parameter {0} for exported function {1}\");\n+  \n+  static final DiagnosticType EXPORTED_FUNCTION_UNKNOWN_RETURN_TYPE =\n+    DiagnosticType.warning(\n+        \"JSC_EXPORTED_FUNCTION_UNKNOWN_RETURN_TYPE\",\n+        \"Unable to determine return type for exported function {0}\");\n+  \n   /** The exports found. */\n   private final List<Export> exports;\n \n   /** The parent compiler. */\n   private final AbstractCompiler compiler;\n \n-  /** The builder which holds the externs generated. */\n-  private final StringBuilder sb;\n+  /** The AST root which holds the externs generated. */\n+  private final Node externsRoot;\n \n   /** A mapping of internal paths to exported paths. */\n   private final Map<String, String> mappedPaths;\n \n   /** A list of exported paths. */\n-  private final List<String> paths;\n+  private final Set<String> alreadyExportedPaths;\n \n   private abstract class Export {\n-\n+    protected final String symbolName;\n+    protected final Node value;\n+\n+    Export(String symbolName, Node value) {\n+      this.symbolName = symbolName;\n+      this.value = value;\n+    }\n+        \n     /**\n      * Generates the externs representation of this export and appends\n-     * it to the parent pass's builder.\n-     */\n-    abstract void generateExterns();\n+     * it to the externsRoot AST.\n+     */\n+    void generateExterns() {\n+      appendExtern(getExportedPath(), getFunctionValue(value));    \n+    }\n \n     /**\n      * Returns the path exported by this export.\n      */\n     abstract String getExportedPath();\n-\n+    \n     /**\n-     * Appends all paths necessary for the path to be declared.\n-     * For example, for \"a.b.c\", the paths \"a\", \"a.b\" and \"a.b.c\"\n-     * will be appended (if they have not already).\n-     */\n-    protected void appendInferredPaths(String path) {\n-      // We wrap in a list here so we have an Iterable for the\n-      // Iterables lib.\n+     * Appends the exported function and all paths necessary for the path to be\n+     * declared. For example, for a property \"a.b.c\", the initializers for\n+     * paths \"a\", \"a.b\" will be appended (if they have not already) and a.b.c\n+     * will be initialized with the exported version of the function:\n+     * <pre>\n+     * var a = {};\n+     * a.b = {};\n+     * a.b.c = function(x,y) { }\n+     * </pre>\n+     */\n+    protected void appendExtern(String path, Node functionToExport) {\n+      List<String> pathPrefixes = computePathPrefixes(path);\n+      \n+      for (int i = 0; i < pathPrefixes.size(); ++i) {  \n+        String pathPrefix = pathPrefixes.get(i);\n+        \n+        /* The complete path (the last path prefix) must be emitted and\n+         * it gets initialized to the externed version of the value.\n+         */      \n+        boolean isCompletePathPrefix = (i == pathPrefixes.size() - 1);\n+           \n+        boolean skipPathPrefix = pathPrefix.endsWith(\".prototype\")\n+            || (alreadyExportedPaths.contains(pathPrefix) \n+                && !isCompletePathPrefix);\n+          \n+        if (!skipPathPrefix) {\n+           Node initializer;\n+                \n+          /* Namespaces get initialized to {}, functions to\n+           * externed versions of their value, and if we can't\n+           * figure out where the value came from we initialize\n+           * it to {}.\n+           * \n+           * Since externs are always exported in sorted order,\n+           * we know that if we export a.b = function() {} and later \n+           * a.b.c = function then a.b will always be in alreadyExportedPaths\n+           * when we emit a.b.c and thus we will never overwrite the function\n+           * exported for a.b with a namespace.\n+           */\n+           \n+          if (isCompletePathPrefix && functionToExport != null) {\n+            initializer = createExternFunction(functionToExport);\n+          } else {\n+            initializer = new Node(Token.OBJECTLIT);\n+          }\n+          \n+          appendPathDefinition(pathPrefix, initializer);        \n+        }      \n+      }\n+    }\n+ \n+    /** \n+     * Computes a list of the path prefixes constructed from the components\n+     * of the path.\n+     * <pre>\n+     * E.g., if the path is:\n+     *      \"a.b.c\"\n+     * then then path prefixes will be\n+     *    [\"a\",\"a.b\",\"a.b.c\"]:\n+     * </pre>\n+     */\n+    private List<String> computePathPrefixes(String path) {\n       List<String> pieces = Lists.newArrayList(path.split(\"\\\\.\"));\n-\n-      // For each path prefix, append.\n-      for (int i = 0; i < pieces.size(); ++i) {\n-\n-        String cPath = Joiner.on(\".\").join(Iterables.limit(pieces, i + 1));\n-\n-        // Actually append the path if it is needed (i.e. it is not\n-        // already present OR it is the path given to the method).\n-        if (i == pieces.size() - 1 || !paths.contains(cPath)) {\n-          if (i == 0) {\n-            sb.append(\"var \");\n-          }\n-\n-          sb.append(cPath);\n-\n-          if (i < pieces.size() - 1) {\n-            sb.append(\";\\n\");\n-          }\n-\n-          paths.add(cPath);\n+      \n+      List<String> pathPrefixes = Lists.newArrayList();\n+      \n+      for (int i = 0; i < pieces.size(); i++) {\n+        pathPrefixes.add(Joiner.on(\".\").join(Iterables.limit(pieces, i + 1)));\n+      }\n+      \n+      return pathPrefixes;\n+    }\n+    \n+    private void appendPathDefinition(String path, Node initializer) {\n+      Node pathDefinition;\n+      \n+      if (!path.contains(\".\")) {\n+        pathDefinition = NodeUtil.newVarNode(path, initializer);\n+      } else {\n+        Node qualifiedPath = NodeUtil.newQualifiedNameNode(path, -1, -1);\n+        pathDefinition = NodeUtil.newExpr(new Node(Token.ASSIGN, qualifiedPath,\n+            initializer));\n+      } \n+      \n+      externsRoot.addChildToBack(pathDefinition);\n+      \n+      alreadyExportedPaths.add(path);\n+    }\n+    \n+    /**\n+     * Given a function to export, create the empty function that\n+     * will be put in the externs file. This extern function should have\n+     * the same type as the original function and the same parameter\n+     * name but no function body.\n+     * \n+     * We create a warning here if the the function to export is missing\n+     * parameter or return types.\n+     */\n+    private Node createExternFunction(Node exportedFunction) {   \n+      checkForFunctionsWithUnknownTypes(exportedFunction);\n+      \n+      List<Node> externParameters = Lists.newLinkedList();\n+      Node actualParameterIterator = NodeUtil.getFnParameters(exportedFunction)\n+        .getFirstChild();\n+      \n+      while (actualParameterIterator != null) {\n+        externParameters.add(actualParameterIterator.cloneNode());\n+        \n+        actualParameterIterator = actualParameterIterator.getNext();\n+      }\n+      \n+      Node externFunction = NodeUtil.newFunctionNode(\"\", externParameters, \n+          new Node(Token.BLOCK), -1, -1);      \n+      externFunction.setJSType(exportedFunction.getJSType());\n+      \n+      return externFunction;\n+    }\n+    \n+    /**\n+     * Warn the user if there is an exported function for which a parameter\n+     * or return type is unknown.\n+     */\n+    private void checkForFunctionsWithUnknownTypes(Node function) {\n+      Preconditions.checkArgument(NodeUtil.isFunction(function));\n+      \n+      /* We must get the JSDocInfo from the function's type since the function\n+       * itself does not have an associated JSDocInfo node.\n+       */\n+      JSDocInfo functionJSDocInfo = function.getJSType().getJSDocInfo();\n+      \n+      FunctionType functionType = (FunctionType) function.getJSType();\n+      \n+      JSType returnType = functionType.getReturnType();\n+      \n+      /* It is OK if a constructor doesn't have a return type */\n+      if (!functionType.isConstructor() && \n+          (returnType == null || returnType.isUnknownType())) {\n+        reportUnknownReturnType(function);\n+      }\n+      \n+      /* We can't just use the function's type's getParameters() to get the\n+       * parameter nodes because the nodes returned from that method\n+       * do not have names or locations. Similarly, the function's AST parameter\n+       * nodes do not have JSTypes(). So we walk both lists of parameter nodes \n+       * in lock step getting parameter names from the first and types from the\n+       * second.\n+       */    \n+      Node astParameterIterator = NodeUtil.getFnParameters(function)\n+        .getFirstChild();\n+           \n+      Node typeParameterIterator = functionType.getParametersNode()\n+        .getFirstChild();\n+      \n+      while (astParameterIterator != null) {\n+        JSType parameterType = typeParameterIterator.getJSType();\n+        \n+        if (parameterType == null || parameterType.isUnknownType()) {\n+          reportUnknownParameterType(function, astParameterIterator);\n         }\n-      }\n-    }\n-\n-\n+        \n+        astParameterIterator = astParameterIterator.getNext();\n+        typeParameterIterator = typeParameterIterator.getNext();\n+      }\n+    }\n+    \n+    private void reportUnknownParameterType(Node function, Node parameter) {\n+      compiler.report(JSError.make(NodeUtil.getSourceName(function),\n+          parameter, CheckLevel.WARNING, \n+          EXPORTED_FUNCTION_UNKNOWN_PARAMETER_TYPE,\n+          NodeUtil.getFunctionName(function), parameter.getString()));\n+    }\n+    \n+    private void reportUnknownReturnType(Node function) {\n+      compiler.report(JSError.make(NodeUtil.getSourceName(function),\n+          function, CheckLevel.WARNING, EXPORTED_FUNCTION_UNKNOWN_RETURN_TYPE,\n+          NodeUtil.getFunctionName(function)));\n+    }\n+    \n     /**\n      * If the given value is a qualified name which refers\n      * a function, the function's node is returned. Otherwise,\n      * {@code null} is returned.\n      */\n-    protected Node getFunctionValue(Node value) {\n+    protected Node getFunctionValue(Node qualifiedNameNode) {\n       String qualifiedName = value.getQualifiedName();\n \n       if (qualifiedName == null) {\n       }\n \n       Node definitionParent = definitionMap.get(qualifiedName);\n-      Node definition = definitionParent.getLastChild();\n+      Node definition;\n+      \n+      switch(definitionParent.getType()) {\n+        case Token.ASSIGN:\n+          definition = definitionParent.getLastChild();\n+          break;\n+        case Token.VAR:\n+          definition = definitionParent.getLastChild().getLastChild();\n+          break;\n+        default:\n+            return null;\n+      }\n \n       if (definition.getType() != Token.FUNCTION) {\n         return null;\n       }\n \n       return definition;\n-    }\n-\n-\n-    /**\n-     * Appends the given function definition to the builder.\n-     */\n-    protected void appendFunctionValue(Node definition) {\n-      sb.append(\" = \");\n-      sb.append(\"function(\");\n-\n-      // Add the parameters.\n-      Node parameters = definition.getFirstChild().getNext();\n-\n-      int i = 0;\n-      for (Node current = parameters.getFirstChild();\n-           current != null;\n-           current = current.getNext()) {\n-\n-        if (i > 0) {\n-          sb.append(\", \");\n-        }\n-\n-        sb.append(current.getString());\n-\n-        ++i;\n-      }\n-\n-      sb.append(\") {}\");\n     }\n   }\n \n    * A symbol export.\n    */\n   private class SymbolExport extends Export {\n-    private final String symbolName;\n-    private final Node value;\n \n     public SymbolExport(String symbolName, Node value) {\n-      this.symbolName = symbolName;\n-      this.value = value;\n-\n+      super(symbolName, value);\n+      \n       String qualifiedName = value.getQualifiedName();\n \n       if (qualifiedName != null) {\n     @Override\n     String getExportedPath() {\n       return symbolName;\n-    }\n-\n-    @Override\n-    void generateExterns() {\n-      appendInferredPaths(symbolName);\n-\n-      Node functionValue = getFunctionValue(value);\n-\n-      if (functionValue != null) {\n-        appendFunctionValue(functionValue);\n-      }\n-\n-      sb.append(\";\\n\");\n     }\n   }\n \n    */\n   private class PropertyExport extends Export {\n     private final String exportPath;\n-    private final String symbolName;\n-    private final Node value;\n \n     public PropertyExport(String exportPath, String symbolName, Node value) {\n+      super(symbolName, value);\n+      \n       this.exportPath = exportPath;\n-      this.symbolName = symbolName;\n-      this.value = value;\n     }\n \n     @Override\n       }\n \n       return exportPath + \".\" + symbolName;\n-    }\n-\n-    @Override\n-    void generateExterns() {\n-      String exportedPath = getExportedPath();\n-\n-      appendInferredPaths(exportedPath);\n-\n-      Node functionValue = getFunctionValue(value);\n-\n-      if (functionValue != null) {\n-        appendFunctionValue(functionValue);\n-      }\n-\n-      sb.append(\";\\n\");\n     }\n   }\n \n     this.exports = Lists.newArrayList();\n     this.compiler = compiler;\n     this.definitionMap = Maps.newHashMap();\n-    this.sb = new StringBuilder();\n-    this.paths = Lists.newArrayList();\n+    this.externsRoot = new Node(Token.BLOCK);\n+    this.externsRoot.setIsSyntheticBlock(true);\n+    this.alreadyExportedPaths = Sets.newHashSet();\n     this.mappedPaths = Maps.newHashMap();\n   }\n \n    * Returns the generated externs.\n    */\n   public String getGeneratedExterns() {\n-    return sb.toString();\n+    CodePrinter.Builder builder = new CodePrinter.Builder(externsRoot)\n+      .setPrettyPrint(false).setOutputTypes(true);\n+    \n+    return builder.build();\n   }\n \n   @Override\n \n       case Token.NAME:\n       case Token.GETPROP:\n-        if (parent.getType() == Token.ASSIGN) {\n+        if (parent.getType() == Token.ASSIGN || parent.getType() == Token.VAR) {\n           definitionMap.put(n.getQualifiedName(), parent);\n         }\n \n--- a/src/com/google/javascript/jscomp/FoldConstants.java\n+++ b/src/com/google/javascript/jscomp/FoldConstants.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n-import com.google.common.base.Predicates;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.TernaryValue;\n \n import java.util.List;\n \n   public void visit(NodeTraversal t, Node n, Node parent) {\n     int type = n.getType();\n \n-    if (type == Token.BLOCK) {\n-      tryFoldBlock(t, n, parent);\n-      return;\n-    }\n-\n     Node left = n.getFirstChild();\n     if (left == null) {\n       return;\n           return;\n         }\n \n-        if (!NodeUtil.isLiteralValue(left)) {\n+        TernaryValue leftVal = NodeUtil.getBooleanValue(left);\n+        if (leftVal == TernaryValue.UNKNOWN) {\n           return;\n         }\n \n         switch (type) {\n           case Token.NOT:\n-            int result = NodeUtil.getBooleanValue(left) ? Token.FALSE :\n-                         Token.TRUE;\n+            int result = leftVal.toBoolean(true) ? Token.FALSE : Token.TRUE;           \n             parent.replaceChild(n, new Node(result));\n             t.getCompiler().reportCodeChange();\n             break;\n       }\n     }\n \n-    if (type == Token.IF || type == Token.HOOK) {\n-      tryFoldHookIf(t, n, parent);\n-      return;\n-    }\n-\n-    if (type == Token.DO) {\n-      tryFoldDo(t, n, parent);\n-      return;\n-    }\n-\n-    if (type == Token.WHILE) {\n-      tryFoldWhile(t, n, parent);\n-      return;\n-    }\n-\n-    if (type == Token.FOR) {\n-      Node condition = NodeUtil.getConditionExpression(n);\n-      if (condition != null) {\n-        this.tryFoldForCondition(condition, n);\n-      }\n-\n-      tryFoldFor(t, n, parent);\n-      return;\n-    }\n-\n     if (type == Token.AND ||\n         type == Token.OR) {\n       tryFoldAndOr(t, n, left, right, parent);\n     if (type == Token.CALL) {\n       tryFoldStringJoin(t, n, left, right, parent);\n       tryFoldStringIndexOf(t, n, left, right, parent);\n-      return;\n-    }\n-\n-    if (type == Token.COMMA) {\n-      tryFoldComma(t, n, left, right, parent);\n       return;\n     }\n \n     }\n   }\n \n-  private void tryFoldComma(\n-      NodeTraversal t, Node n, Node left, Node right, Node parent) {\n-    // If the left side does nothing replace the comma with the result.\n-    if (!NodeUtil.mayHaveSideEffects(left)) {\n-      // Fold it!\n-      n.removeChild(right);\n-      parent.replaceChild(n, right);\n-      t.getCompiler().reportCodeChange();\n-    } else {\n-      if (parent.getType() == Token.EXPR_RESULT) {\n-        // split comma\n-        n.detachChildren();\n-        // Replace the original expression with the left operand.\n-        parent.replaceChild(n, left);\n-        // Add the right expression afterward.\n-        Node newStatement = new Node(Token.EXPR_RESULT, right);\n-        newStatement.copyInformationFrom(n);\n-        parent.getParent().addChildAfter(newStatement, parent);\n-        t.getCompiler().reportCodeChange();\n-      }\n-    }\n-  }\n-\n   private void error(NodeTraversal t, DiagnosticType diagnostic, Node n) {\n     t.getCompiler().report(t.makeError(n, diagnostic, n.toString()));\n   }\n   }\n \n   /**\n-   * Try removing unneeded block nodes and their useless children\n-   */\n-  void tryFoldBlock(NodeTraversal t, Node n, Node parent) {\n-    // Remove any useless children\n-    for (Node c = n.getFirstChild(); c != null; ) {\n-      Node next = c.getNext();  // save c.next, since 'c' may be removed\n-      if (!NodeUtil.mayHaveSideEffects(c)) {\n-        n.removeChild(c);  // lazy kids\n-        t.getCompiler().reportCodeChange();\n-      }\n-      c = next;\n-    }\n-\n-    if (n.isSyntheticBlock() || parent == null) {\n-      return;\n-    }\n-\n-    // Try to remove the block.\n-    if (NodeUtil.tryMergeBlock(n)) {\n-      t.getCompiler().reportCodeChange();\n-    }\n-  }\n-\n-  /**\n-   * Try folding :? (hook) and IF nodes by removing dead branches.\n-   * @return were any changes performed?\n-   */\n-  boolean tryFoldHookIf(NodeTraversal t, Node n, Node parent) {\n-    int type = n.getType();\n-    Node cond = n.getFirstChild();\n-    Node thenBody = cond.getNext();\n-    Node elseBody = thenBody.getNext();\n-\n-    boolean changes = false;\n-\n-    if (type == Token.IF) {\n-      // if (x) { .. } else { } --> if (x) { ... }\n-      if (elseBody != null && !NodeUtil.mayHaveSideEffects(elseBody)) {\n-        n.removeChild(elseBody);\n-        elseBody = null;\n-        t.getCompiler().reportCodeChange();\n-        changes = true;\n-      }\n-\n-      // if (x) { } else { ... } --> if (!x) { ... }\n-      if (!NodeUtil.mayHaveSideEffects(thenBody) && elseBody != null) {\n-        n.removeChild(elseBody);\n-        n.replaceChild(thenBody, elseBody);\n-        Node notCond = new Node(Token.NOT);\n-        n.replaceChild(cond, notCond);\n-        notCond.addChildToFront(cond);\n-        cond = notCond;\n-        thenBody = cond.getNext();\n-        elseBody = null;\n-        t.getCompiler().reportCodeChange();\n-        changes = true;\n-      }\n-\n-      // if (x()) { }\n-      if (!NodeUtil.mayHaveSideEffects(thenBody) && elseBody == null) {\n-        if (NodeUtil.mayHaveSideEffects(cond)) {\n-          // x() has side effects, just leave the condition on its own.\n-          n.removeChild(cond);\n-          parent.replaceChild(n, NodeUtil.newExpr(cond));\n-        } else {\n-          // x() has no side effects, the whole tree is useless now.\n-          NodeUtil.removeChild(parent, n);\n-        }\n-        t.getCompiler().reportCodeChange();\n-        return true; // The if has been removed. There is nothing to do.\n-      }\n-    } else {\n-      Preconditions.checkState(type == Token.HOOK);\n-      if (NodeUtil.isExpressionNode(parent)) {\n-        // Try to remove useless nodes.\n-        if (!NodeUtil.mayHaveSideEffects(thenBody)) {\n-          // x?void 0:y --> if(!x)y\n-          Node ifNode = new Node(Token.IF);\n-          if (cond.getType() == Token.NOT) {\n-            Node expr = cond.getFirstChild();\n-            cond.removeChild(expr);\n-            ifNode.addChildToBack(expr);\n-          } else {\n-            Node not = new Node(Token.NOT).copyInformationFrom(cond);\n-            n.removeChild(cond);\n-            not.addChildToBack(cond);\n-            ifNode.addChildToBack(not);\n-          }\n-\n-          n.removeChild(elseBody);\n-          ifNode.addChildToBack(\n-              new Node(Token.BLOCK, NodeUtil.newExpr(elseBody))\n-                  .copyInformationFrom(elseBody));\n-          parent.getParent().replaceChild(parent, ifNode);\n-          t.getCompiler().reportCodeChange();\n-          return true;\n-        } else if (!NodeUtil.mayHaveSideEffects(elseBody)) {\n-          // x?y:void 0 --> if(x)y\n-          Node ifNode = new Node(Token.IF);\n-          n.removeChild(cond);\n-          ifNode.addChildToBack(cond);\n-          n.removeChild(thenBody);\n-\n-          ifNode.addChildToBack(\n-              new Node(Token.BLOCK, NodeUtil.newExpr(thenBody))\n-                  .copyInformationFrom(thenBody));\n-          parent.getParent().replaceChild(parent, ifNode);\n-          t.getCompiler().reportCodeChange();\n-          return true;\n-        }\n-      }\n-    }\n-\n-    // Try transforms that apply to both IF and HOOK.\n-    if (!NodeUtil.isLiteralValue(cond)) {\n-      return changes;  // We can't remove branches otherwise!\n-    }\n-\n-    boolean condTrue = NodeUtil.getBooleanValue(cond);\n-\n-    if (n.getChildCount() == 2) {\n-      Preconditions.checkState(type == Token.IF);\n-\n-      if (condTrue) {\n-        // Replace \"if (true) { X }\" with \"X\".\n-        Node thenStmt = n.getFirstChild().getNext();\n-        n.removeChild(thenStmt);\n-        parent.replaceChild(n, thenStmt);\n-        t.getCompiler().reportCodeChange();\n-      } else {\n-        // Replace \"if (false) { X }\" with empty node.\n-        NodeUtil.redeclareVarsInsideBranch(n);\n-        NodeUtil.removeChild(parent, n);\n-        t.getCompiler().reportCodeChange();\n-      }\n-    } else {\n-      // Replace \"if (true) { X } else { Y }\" with X, or\n-      // replace \"if (false) { X } else { Y }\" with Y.\n-      Node firstBranch = n.getFirstChild().getNext();\n-      Node secondBranch = firstBranch.getNext();\n-      Node branch = condTrue ? firstBranch : secondBranch;\n-      Node notBranch = condTrue ? secondBranch : firstBranch;\n-      NodeUtil.redeclareVarsInsideBranch(notBranch);\n-      n.removeChild(branch);\n-      parent.replaceChild(n, branch);\n-      t.getCompiler().reportCodeChange();\n-    }\n-    return true;\n-  }\n-   \n-  /**\n+\n    * Try to fold a AND/OR node.\n    */\n   void tryFoldAndOr(NodeTraversal t, Node n, Node left, Node right,\n     Node result = null;\n \n     int type = n.getType();\n-    if (NodeUtil.isLiteralValue(left)) {\n-      boolean lval = NodeUtil.getBooleanValue(left);\n+   \n+    TernaryValue leftVal = NodeUtil.getBooleanValue(left);\n+\n+    if (leftVal != TernaryValue.UNKNOWN) {\n+      boolean lval = leftVal.toBoolean(true);\n \n       // (TRUE || x) => TRUE (also, (3 || x) => 3)\n       // (FALSE && x) => FALSE\n         // (TRUE && x) => x\n         result = right;\n       }\n-    } else if (NodeUtil.isLiteralValue(right)) {\n+    } else {\n+      TernaryValue rightVal = NodeUtil.getBooleanValue(right);\n+      if (rightVal != TernaryValue.UNKNOWN) {\n+  \n       // Note: We cannot always fold when the constant is on the\n       // right, because the typed value of the expression will depend\n       // on the type of the constant on the right, even if the boolean\n       if (pt == Token.IF || pt == Token.WHILE || pt == Token.DO ||\n           (pt == Token.FOR && NodeUtil.getConditionExpression(parent) == n) ||\n           (pt == Token.HOOK && parent.getFirstChild() == n)) {\n-        boolean rval = NodeUtil.getBooleanValue(right);\n+        boolean rval = rightVal.toBoolean(true);\n \n         // (x || FALSE) => x\n         // (x && TRUE) => x\n           if (!NodeUtil.mayHaveSideEffects(left)) {\n             result = right;\n           }\n+        }\n         }\n       }\n     }\n     parent.replaceChild(n, literalNode);\n     t.getCompiler().reportCodeChange();\n     return true;\n-  }\n-\n-  /**\n-   * Removes WHILEs that always evaluate to false.\n-   */\n-  void tryFoldWhile(NodeTraversal t, Node n, Node parent) {\n-    Preconditions.checkArgument(n.getType() == Token.WHILE);\n-    Node cond = NodeUtil.getConditionExpression(n);\n-    if (!NodeUtil.isLiteralValue(cond) || NodeUtil.getBooleanValue(cond)) {\n-      return;\n-    }\n-    NodeUtil.redeclareVarsInsideBranch(n);\n-    NodeUtil.removeChild(parent, n);\n-    t.getCompiler().reportCodeChange();\n-  }\n-\n-  /**\n-   * Removes FORs that always evaluate to false.\n-   */\n-  void tryFoldFor(NodeTraversal t, Node n, Node parent) {\n-    Preconditions.checkArgument(n.getType() == Token.FOR);\n-    // This is not a FOR-IN loop\n-    if (n.getChildCount() != 4) return;\n-    // There isn't an initializer\n-    if (n.getFirstChild().getType() != Token.EMPTY) return;\n-\n-    Node cond = NodeUtil.getConditionExpression(n);\n-    if (!NodeUtil.isLiteralValue(cond) || NodeUtil.getBooleanValue(cond)) {\n-      return;\n-    }\n-    NodeUtil.redeclareVarsInsideBranch(n);\n-    NodeUtil.removeChild(parent, n);\n-    t.getCompiler().reportCodeChange();\n-  }\n-\n-  /**\n-   * Removes DOs that always evaluate to false. This leaves the\n-   * statements that were in the loop in a BLOCK node.\n-   * The block will be removed in a later pass, if possible.\n-   */\n-  void tryFoldDo(NodeTraversal t, Node n, Node parent) {\n-    Preconditions.checkArgument(n.getType() == Token.DO);\n-\n-    Node cond = NodeUtil.getConditionExpression(n);\n-    if (!NodeUtil.isLiteralValue(cond) || NodeUtil.getBooleanValue(cond)) {\n-      return;\n-    }\n-\n-    // TODO(johnlenz): The do-while can be turned into a label with\n-    // named breaks and the label optimized away (maybe).\n-    if (hasBreakOrContinue(n)) {\n-      return;\n-    }\n-\n-    Preconditions.checkState(\n-        NodeUtil.isControlStructureCodeBlock(n, n.getFirstChild()));\n-    Node block = n.removeFirstChild();\n-\n-    parent.replaceChild(n, block);\n-    t.getCompiler().reportCodeChange();\n-  }\n-\n-  /**\n-   *\n-   */\n-  boolean hasBreakOrContinue(Node n) {\n-    // TODO(johnlenz): This is overkill as named breaks may refer to outer\n-    // loops or labels, and any break my refer to an inner loop.\n-    // More generally, this check may be more expensive than we like.\n-    return NodeUtil.has(\n-        n,\n-        Predicates.<Node>or(\n-            new NodeUtil.MatchNodeType(Token.BREAK),\n-            new NodeUtil.MatchNodeType(Token.CONTINUE)),\n-        new NodeUtil.MatchNotFunction());\n-  }\n-\n-  /**\n-   * Remove always true loop conditions.\n-   */\n-  private void tryFoldForCondition(Node n, Node parent) {\n-    if (NodeUtil.isLiteralValue(n)) {\n-      boolean result = NodeUtil.getBooleanValue(n);\n-      if (result) {\n-        parent.replaceChild(n, new Node(Token.EMPTY));\n-        compiler.reportCodeChange();\n-      }\n-    }\n+\n   } \n }\n+\n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n import com.google.common.base.Supplier;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.ExpressionDecomposer.DecompositionType;\n+import com.google.javascript.jscomp.MakeDeclaredNamesUnique.ContextualRenamer;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n       InliningMode mode, boolean referencesThis, boolean containsFunctions) {\n     // TODO(johnlenz): This function takes too many parameter, without\n     // context.  Modify the API to take a structure describing the function.\n-    \n+\n     // Allow direct function calls or \"fn.call\" style calls.\n     if (!isSupportedCallType(callNode)) {\n       return CanInlineResult.NO;\n    * Parameter names will be name unique when at a later time.\n    */\n   private String getUniqueResultName() {\n-    return \"JSCompiler_inline_result_\" + safeNameIdSupplier.get();\n+    return \"JSCompiler_inline_result\"\n+        + ContextualRenamer.UNIQUE_ID_SEPARATOR + safeNameIdSupplier.get();\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\n+++ b/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\n     }\n \n     /**\n-     * Rename vars for the current scope, and merge any referenced \n+     * Rename vars for the current scope, and merge any referenced\n      * names into the parent scope reference set.\n      */\n     public void exitScope(NodeTraversal t) {\n      */\n     void handleScopeVar(Var v) {\n       String name  = v.getName();\n-      if (containsSeparator(name)) {\n-        String newName = getOrginalName(name);\n-        // Check if the new name is valid and if it would cause conflicts.\n-        if (TokenStream.isJSIdentifier(newName) &&\n-            !referencedNames.contains(newName) && \n-            !newName.equals(ARGUMENTS)) {\n-          referencedNames.remove(name);\n-          // Adding a reference to the new name to prevent either the parent\n-          // scopes or the current scope renaming another var to this new name.\n-          referencedNames.add(newName);\n-          List<Node> references = nameMap.get(name);\n-          Preconditions.checkState(references != null);\n-          for (Node n : references) {\n-            Preconditions.checkState(n.getType() == Token.NAME);\n-            n.setString(newName);\n-          }\n-          compiler.reportCodeChange();\n+      if (containsSeparator(name) && !getOrginalName(name).isEmpty()) {\n+        String newName = findReplacementName(name);\n+        referencedNames.remove(name);\n+        // Adding a reference to the new name to prevent either the parent\n+        // scopes or the current scope renaming another var to this new name.\n+        referencedNames.add(newName);\n+        List<Node> references = nameMap.get(name);\n+        Preconditions.checkState(references != null);\n+        for (Node n : references) {\n+          Preconditions.checkState(n.getType() == Token.NAME);\n+          n.setString(newName);\n         }\n+        compiler.reportCodeChange();\n         nameMap.remove(name);\n       }\n+    }\n+ \n+    /**\n+     * Find a name usable in the local scope.\n+     */\n+    private String findReplacementName(String name) {\n+      String original = getOrginalName(name);\n+      String newName = original;\n+      int i = 0;\n+      while (!isValidName(newName)) {\n+        newName = original + \n+            ContextualRenamer.UNIQUE_ID_SEPARATOR + String.valueOf(i++);\n+      }\n+      return newName;\n+    }\n+\n+    /**\n+     * @return Whether the name is valid to use in the local scope.\n+     */\n+    private boolean isValidName(String name) {\n+      if (TokenStream.isJSIdentifier(name) &&\n+          !referencedNames.contains(name) &&\n+          !name.equals(ARGUMENTS)) {\n+        return true;\n+      }\n+      return false;\n     }\n \n     @Override\n--- a/src/com/google/javascript/jscomp/MethodCompilerPass.java\n+++ b/src/com/google/javascript/jscomp/MethodCompilerPass.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.LinkedHashMultimap;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Multimap;\n import com.google.common.collect.Sets;\n   /** List of property names that may not be methods */\n   final Set<String> nonMethodProperties = Sets.newHashSet();\n \n+  // Use a linked map here to keep the output deterministic.  Otherwise,\n+  // the choice of method bodies is random when multiple identical definitions\n+  // are found which causes problems in the source maps.\n   final Multimap<String, Node> methodDefinitions =\n-      HashMultimap.create();\n+      LinkedHashMultimap.create();\n \n   final AbstractCompiler compiler;\n \n--- a/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n+++ b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n import com.google.javascript.jscomp.AbstractCompiler;\n import com.google.javascript.jscomp.CompilerPass;\n import com.google.javascript.jscomp.NodeTraversal;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.NodeUtil;\n-import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.TernaryValue;\n \n /**\n  * Transform the structure of the AST so that the number of explicit exits\n             NodeUtil.getLoopCodeBlock(n), Token.CONTINUE, null);\n \n         Node cond = NodeUtil.getConditionExpression(n);\n-        if (NodeUtil.isLiteralValue(cond) && !NodeUtil.getBooleanValue(cond)) {\n+        if (NodeUtil.getBooleanValue(cond) == TernaryValue.FALSE) {\n           // Normally, we wouldn't be able to optimize BREAKs inside a loop\n           // but as we know the condition will always false, we can treat them\n           // as we would a CONTINUE.\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.TokenStream;\n+import com.google.javascript.rhino.jstype.TernaryValue;\n \n import java.util.Arrays;\n import java.util.Collection;\n    *\n    * @throws IllegalArgumentException If {@code n} is not a literal value\n    */\n-  static boolean getBooleanValue(Node n) {\n+  static TernaryValue getBooleanValue(Node n) {\n     switch (n.getType()) {\n       case Token.STRING:\n-        return n.getString().length() > 0;\n+        return TernaryValue.forBoolean(n.getString().length() > 0);\n \n       case Token.NUMBER:\n-        return n.getDouble() != 0;\n+        return TernaryValue.forBoolean(n.getDouble() != 0);\n \n       case Token.NULL:\n       case Token.FALSE:\n       case Token.VOID:\n-        return false;\n+        return TernaryValue.FALSE;\n \n       case Token.NAME:\n         String name = n.getString();\n             || \"NaN\".equals(name)) {\n           // We assume here that programs don't change the value of the keyword\n           // undefined to something other than the value undefined.\n-          return false;\n+          return TernaryValue.FALSE;\n         } else if (\"Infinity\".equals(name)) {\n-          return true;\n+          return TernaryValue.TRUE;\n         }\n         break;\n \n       case Token.ARRAYLIT:\n       case Token.OBJECTLIT:\n       case Token.REGEXP:\n-        return true;\n-    }\n-    throw new IllegalArgumentException(\"Non-literal value: \" + n);\n+        return TernaryValue.TRUE;\n+    }\n+\n+    return TernaryValue.UNKNOWN;\n   }\n \n \n--- a/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\n+++ b/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\n       ImmutableSet<AbstractPeepholeOptimization> optimizations) {\n     this.compiler = compiler;\n     this.peepholeOptimizations = optimizations;\n+  }\n+  \n+  /**\n+   * Creates a peephole optimization pass that runs the given\n+   * optimizations.\n+   */\n+  PeepholeOptimizationsPass(AbstractCompiler compiler, \n+      AbstractPeepholeOptimization... optimizations) {\n+    this(compiler, ImmutableSet.copyOf(optimizations));     \n   }\n   \n   public AbstractCompiler getCompiler() {\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n+/*\n+ * Copyright 2004 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Predicates;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.TernaryValue;\n+\n+/**\n+ * Peephole optimization to remove useless code such as IF's with false\n+ * guard conditions, comma operator left hand sides with no side effects, etc.\n+ *\n+*\n+*\n+ */\n+public class PeepholeRemoveDeadCode extends AbstractPeepholeOptimization {\n+\n+  // TODO(dcc): Some (all) of these can probably be better achieved\n+  // using the control flow graph (like CheckUnreachableCode). \n+  // There is an existing CFG pass (UnreachableCodeElimination) that\n+  // could be changed to use code from CheckUnreachableCode to do this.\n+  \n+  @Override\n+  Node optimizeSubtree(Node subtree) {   \n+    switch(subtree.getType()) {\n+      case Token.COMMA:\n+        return tryFoldComma(subtree);\n+      case Token.BLOCK:\n+        return tryFoldBlock(subtree);       \n+      case Token.IF:\n+      case Token.HOOK:\n+        return tryFoldHookIf(subtree);      \n+      case Token.WHILE:\n+        return tryFoldWhile(subtree);\n+       case Token.FOR: {\n+          Node condition = NodeUtil.getConditionExpression(subtree);\n+          if (condition != null) {\n+            tryFoldForCondition(condition);\n+          }\n+        }\n+        return tryFoldFor(subtree);\n+      case Token.DO:\n+        return tryFoldDo(subtree);\n+        default:\n+          return subtree;\n+    }    \n+  }\n+  \n+  private Node tryFoldComma(Node n) {\n+    // If the left side does nothing replace the comma with the result.\n+    \n+    Node parent = n.getParent();\n+    Node left = n.getFirstChild();\n+    Node right = left.getNext();\n+    \n+    if (!NodeUtil.mayHaveSideEffects(left)) {\n+      // Fold it!\n+      n.removeChild(right);\n+      parent.replaceChild(n, right);\n+      reportCodeChange();\n+      return right;\n+    } else {\n+      if (parent.getType() == Token.EXPR_RESULT) {\n+        // split comma\n+        n.detachChildren();\n+        // Replace the original expression with the left operand.\n+        parent.replaceChild(n, left);\n+        // Add the right expression afterward.\n+        Node newStatement = new Node(Token.EXPR_RESULT, right);\n+        newStatement.copyInformationFrom(n);\n+        \n+        //This modifies outside the subtree, which is not\n+        //desirable in a peephole optimization.\n+        parent.getParent().addChildAfter(newStatement, parent);\n+        reportCodeChange();\n+        return left;\n+      }\n+    }\n+    \n+    return n;\n+  }\n+\n+  /**\n+   * Try removing unneeded block nodes and their useless children\n+   */\n+  Node tryFoldBlock(Node n) {\n+    // TODO(dcc): Make sure this is also applied in the global scope \n+    // (i.e. with Token.SCRIPT) parents \n+    // Remove any useless children\n+    for (Node c = n.getFirstChild(); c != null; ) {\n+      Node next = c.getNext();  // save c.next, since 'c' may be removed\n+      if (!NodeUtil.mayHaveSideEffects(c)) {\n+        n.removeChild(c);  // lazy kids\n+        reportCodeChange();\n+      }\n+      c = next;\n+    }\n+\n+    if (n.isSyntheticBlock() ||  n.getParent() == null) {\n+      return n;\n+    }\n+\n+    // Try to remove the block.\n+    if (NodeUtil.tryMergeBlock(n)) {\n+      reportCodeChange();\n+      return null;\n+    }\n+    \n+    return n;\n+  }\n+ \n+  /**\n+   * Try folding :? (hook) and IF nodes by removing dead branches.\n+   * @return the replacement node, if changed, or the original if not\n+   */\n+  private Node tryFoldHookIf(Node n) {\n+    Node parent = n.getParent();\n+    int type = n.getType();\n+    Node cond = n.getFirstChild();\n+    Node thenBody = cond.getNext();\n+    Node elseBody = thenBody.getNext();\n+\n+    boolean changes = false;\n+\n+    if (type == Token.IF) {\n+      // if (x) { .. } else { } --> if (x) { ... }\n+      if (elseBody != null && !NodeUtil.mayHaveSideEffects(elseBody)) {\n+        n.removeChild(elseBody);\n+        elseBody = null;\n+        reportCodeChange();\n+        changes = true;\n+      }\n+\n+      // if (x) { } else { ... } --> if (!x) { ... }\n+      if (!NodeUtil.mayHaveSideEffects(thenBody) && elseBody != null) {\n+        n.removeChild(elseBody);\n+        n.replaceChild(thenBody, elseBody);\n+        Node notCond = new Node(Token.NOT);\n+        n.replaceChild(cond, notCond);\n+        notCond.addChildToFront(cond);\n+        cond = notCond;\n+        thenBody = cond.getNext();\n+        elseBody = null;\n+        reportCodeChange();\n+        changes = true;\n+      }\n+\n+      // if (x()) { }\n+      if (!NodeUtil.mayHaveSideEffects(thenBody) && elseBody == null) {\n+        if (NodeUtil.mayHaveSideEffects(cond)) {\n+          // x() has side effects, just leave the condition on its own.\n+          n.removeChild(cond);\n+          Node replacement = NodeUtil.newExpr(cond);\n+          parent.replaceChild(n, replacement);\n+          reportCodeChange();\n+          return replacement;\n+        } else {\n+          // x() has no side effects, the whole tree is useless now.\n+          NodeUtil.removeChild(parent, n);\n+          reportCodeChange();\n+          return null;\n+        }\n+      }\n+    } else {\n+      Preconditions.checkState(type == Token.HOOK);\n+      if (NodeUtil.isExpressionNode(parent)) {\n+        // Try to remove useless nodes.\n+        if (!NodeUtil.mayHaveSideEffects(thenBody)) {\n+          // x?void 0:y --> if(!x)y\n+          Node ifNode = new Node(Token.IF);\n+          if (cond.getType() == Token.NOT) {\n+            Node expr = cond.getFirstChild();\n+            cond.removeChild(expr);\n+            ifNode.addChildToBack(expr);\n+          } else {\n+            Node not = new Node(Token.NOT).copyInformationFrom(cond);\n+            n.removeChild(cond);\n+            not.addChildToBack(cond);\n+            ifNode.addChildToBack(not);\n+          }\n+\n+          n.removeChild(elseBody);\n+          ifNode.addChildToBack(\n+              new Node(Token.BLOCK, NodeUtil.newExpr(elseBody))\n+                  .copyInformationFrom(elseBody));\n+          \n+          //This modifies outside the subtree, which is not\n+          //desirable in a peephole optimization.\n+          parent.getParent().replaceChild(parent, ifNode);\n+          reportCodeChange();\n+          return ifNode;\n+        } else if (!NodeUtil.mayHaveSideEffects(elseBody)) {\n+          // x?y:void 0 --> if(x)y\n+          Node ifNode = new Node(Token.IF);\n+          n.removeChild(cond);\n+          ifNode.addChildToBack(cond);\n+          n.removeChild(thenBody);\n+\n+          ifNode.addChildToBack(\n+              new Node(Token.BLOCK, NodeUtil.newExpr(thenBody))\n+                  .copyInformationFrom(thenBody));\n+          \n+          //This modifies outside the subtree, which is not\n+          //desirable in a peephole optimization.\n+          parent.getParent().replaceChild(parent, ifNode);\n+          reportCodeChange();\n+          return ifNode;\n+        }\n+      }\n+    }\n+\n+    // Try transforms that apply to both IF and HOOK.\n+    if (!NodeUtil.isLiteralValue(cond)) {\n+      return n;  // We can't remove branches otherwise!\n+    }\n+\n+    TernaryValue condValue = NodeUtil.getBooleanValue(cond);\n+    if (condValue == TernaryValue.UNKNOWN) {\n+      return n;  // We can't remove branches otherwise!\n+    }\n+\n+    boolean condTrue = condValue.toBoolean(true);\n+    if (n.getChildCount() == 2) {\n+      Preconditions.checkState(type == Token.IF);\n+\n+      if (condTrue) {\n+        // Replace \"if (true) { X }\" with \"X\".\n+        Node thenStmt = n.getFirstChild().getNext();\n+        n.removeChild(thenStmt);\n+        parent.replaceChild(n, thenStmt);\n+        reportCodeChange();\n+        return thenStmt;\n+      } else {\n+        // Replace \"if (false) { X }\" with empty node.\n+        NodeUtil.redeclareVarsInsideBranch(n);\n+        NodeUtil.removeChild(parent, n);\n+        reportCodeChange();\n+        return null;\n+      }\n+    } else {\n+      // Replace \"if (true) { X } else { Y }\" with X, or\n+      // replace \"if (false) { X } else { Y }\" with Y.\n+      Node firstBranch = n.getFirstChild().getNext();\n+      Node secondBranch = firstBranch.getNext();\n+      Node branch = condTrue ? firstBranch : secondBranch;\n+      Node notBranch = condTrue ? secondBranch : firstBranch;\n+      NodeUtil.redeclareVarsInsideBranch(notBranch);\n+      n.removeChild(branch);\n+      parent.replaceChild(n, branch);\n+      reportCodeChange();\n+      return branch;\n+    }\n+  }\n+  \n+  /**\n+   * Removes WHILEs that always evaluate to false.\n+   */\n+  Node tryFoldWhile(Node n) {\n+    Preconditions.checkArgument(n.getType() == Token.WHILE);\n+    Node cond = NodeUtil.getConditionExpression(n);\n+    if (NodeUtil.getBooleanValue(cond) != TernaryValue.FALSE) {\n+      return n;\n+    }\n+    NodeUtil.redeclareVarsInsideBranch(n);\n+    NodeUtil.removeChild(n.getParent(), n);\n+    reportCodeChange();\n+    \n+    return null;\n+  }\n+  \n+  /**\n+   * Removes FORs that always evaluate to false.\n+   */\n+  Node tryFoldFor(Node n) {\n+    Preconditions.checkArgument(n.getType() == Token.FOR);    \n+    // This is not a FOR-IN loop\n+    if (n.getChildCount() != 4) {\n+      return n;\n+    }\n+    // There isn't an initializer\n+    if (n.getFirstChild().getType() != Token.EMPTY) {\n+      return n;\n+    }\n+\n+    Node cond = NodeUtil.getConditionExpression(n);\n+    if (NodeUtil.getBooleanValue(cond) != TernaryValue.FALSE) {\n+      return n;\n+    }\n+    \n+    NodeUtil.redeclareVarsInsideBranch(n);\n+    NodeUtil.removeChild(n.getParent(), n);\n+    reportCodeChange();\n+    return null;\n+  }\n+  \n+  /**\n+   * Removes DOs that always evaluate to false. This leaves the\n+   * statements that were in the loop in a BLOCK node.\n+   * The block will be removed in a later pass, if possible.\n+   */\n+  Node tryFoldDo(Node n) {\n+    Preconditions.checkArgument(n.getType() == Token.DO);\n+\n+    Node cond = NodeUtil.getConditionExpression(n);\n+    if (NodeUtil.getBooleanValue(cond) != TernaryValue.FALSE) {\n+      return n;\n+    }\n+\n+    // TODO(johnlenz): The do-while can be turned into a label with\n+    // named breaks and the label optimized away (maybe).\n+    if (hasBreakOrContinue(n)) {\n+      return n;\n+    }\n+\n+    Preconditions.checkState(\n+        NodeUtil.isControlStructureCodeBlock(n, n.getFirstChild()));\n+    Node block = n.removeFirstChild();\n+\n+    n.getParent().replaceChild(n, block);\n+    reportCodeChange();\n+    \n+    return n;\n+  }\n+  \n+  /**\n+   *\n+   */\n+  boolean hasBreakOrContinue(Node n) {\n+    // TODO(johnlenz): This is overkill as named breaks may refer to outer\n+    // loops or labels, and any break my refer to an inner loop.\n+    // More generally, this check may be more expensive than we like.\n+    return NodeUtil.has(\n+        n,\n+        Predicates.<Node>or(\n+            new NodeUtil.MatchNodeType(Token.BREAK),\n+            new NodeUtil.MatchNodeType(Token.CONTINUE)),\n+        new NodeUtil.MatchNotFunction());\n+  }\n+\n+  /**\n+   * Remove always true loop conditions.\n+   */\n+  private void tryFoldForCondition(Node forCondition) {\n+    if (NodeUtil.getBooleanValue(forCondition) == TernaryValue.TRUE) { \n+      forCondition.getParent().replaceChild(forCondition,\n+          new Node(Token.EMPTY));\n+      reportCodeChange();     \n+    }\n+  } \n+}\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n import com.google.common.base.Predicate;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.TernaryValue;\n \n import java.util.regex.Pattern;\n \n     Node parent = n.getParent();\n     \n     Node cond = n.getFirstChild();\n+    \n+    /* If the condition is a literal, we'll let other\n+     * optimizations try to remove useless code.\n+     */\n+    if (NodeUtil.isLiteralValue(cond)) {\n+      return n;\n+    }\n+    \n     Node thenBranch = cond.getNext();\n     Node elseBranch = thenBranch.getNext();\n \n         break;\n \n       default:\n-        // if(true) --> if(1)\n-        if (NodeUtil.isLiteralValue(n)) {\n-          boolean result = NodeUtil.getBooleanValue(n);\n+        // while(true) --> while(1)\n+        TernaryValue nVal = NodeUtil.getBooleanValue(n);\n+        if (nVal != TernaryValue.UNKNOWN) {\n+          boolean result = nVal.toBoolean(true);\n           int equivalentResult = result ? 1 : 0;\n           return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n         }\n     }\n     return false;\n   }\n-}\n+}\n--- a/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n+++ b/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n       } else {\n         return null;\n       }\n+    } else if (NodeUtil.isFunctionExpression(name)) {\n+      // The anonymous function reference is also the definition.\n+      return Lists.newArrayList(\n+          (Definition)\n+              new DefinitionsRemover.FunctionExpressionDefinition(name));     \n     } else {\n       return null;\n     }\n--- a/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n         // Bail out if the paramNode is not there.\n         if (paramNode == null) {\n           break;\n-        }\n-        sb.append(\" * @param {\" + n.getJSType() + \"} \");\n+        }             \n+        sb.append(\" * @param {\" + getParameterNodeJSDocType(n) + \"} \");\n         sb.append(paramNode.getString());\n         sb.append(\"\\n\");\n         paramNode = paramNode.getNext();\n     sb.append(\" */\\n\");\n     return sb.toString();\n   }\n+  \n+  /**\n+   * Creates a JSDoc-suitable String representation the type of a parameter.\n+   * \n+   * @param parameterNode The parameter node. \n+   */\n+  private String getParameterNodeJSDocType(Node parameterNode) {\n+    JSType parameterType = parameterNode.getJSType();\n+    String typeString;\n+    \n+    // Emit unknown types as '*' (AllType) since '?' (UnknownType) is not\n+    // a valid JSDoc type.\n+    if (parameterType.isUnknownType()) {\n+      typeString = \"*\";\n+    } else {     \n+      // Fix-up optional and vararg parameters to match JSDoc type language\n+      if (parameterNode.isOptionalArg()) {\n+        typeString = parameterType.restrictByNotNullOrUndefined() + \"=\";\n+      } else if (parameterNode.isVarArgs()) {\n+        typeString = \"...\" + parameterType.restrictByNotNullOrUndefined();\n+      } else {\n+        typeString = parameterType.toString();\n+      }\n+    }\n+    \n+    return typeString;\n+  }\n }\n--- a/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n+++ b/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n       return;\n     }\n     // Removes TRYs that had its CATCH removed and/or empty FINALLY.\n+    // TODO(dcc): Move the parts of this that don't require a control flow\n+    // graph to PeepholeRemoveDeadCode\n     if (n.getType() == Token.TRY) {\n       Node body = n.getFirstChild();\n       Node catchOrFinallyBlock = body.getNext();\n--- a/src/com/google/javascript/jscomp/parsing/Annotation.java\n+++ b/src/com/google/javascript/jscomp/parsing/Annotation.java\n   JAVA_DISPATCH,\n   LICENSE, // same as preserve\n   NO_ALIAS,\n+  NO_COMPILE,\n   NO_SHADOW,\n   NO_SIDE_EFFECTS,\n   NO_TYPE_CHECK,\n       put(\"javadispatch\", Annotation.JAVA_DISPATCH).\n       put(\"license\", Annotation.LICENSE).\n       put(\"noalias\", Annotation.NO_ALIAS).\n+      put(\"nocompile\", Annotation.NO_COMPILE).\n       put(\"noshadow\", Annotation.NO_SHADOW).\n       put(\"nosideeffects\", Annotation.NO_SIDE_EFFECTS).\n       put(\"notypecheck\", Annotation.NO_TYPE_CHECK).\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n                   token = eatTokensUntilEOL();\n                   continue retry;\n \n+                case NO_COMPILE:\n+                  if (!jsdocBuilder.recordNoCompile()) {\n+                    parser.addWarning(\"msg.jsdoc.nocompile\",\n+                        stream.getLineno(), stream.getCharno());\n+                  }\n+                  token = eatTokensUntilEOL();\n+                  continue retry;\n+\n                 case NO_TYPE_CHECK:\n                   if (!jsdocBuilder.recordNoTypeCheck()) {\n                     parser.addWarning(\"msg.jsdoc.nocheck\",\n--- a/src/com/google/javascript/rhino/JSDocInfo.java\n+++ b/src/com/google/javascript/rhino/JSDocInfo.java\n   private static final int MASK_NOSIDEEFFECTS = 0x00004000; // @nosideeffects\n   private static final int MASK_EXTERNS       = 0x00008000; // @externs\n   private static final int MASK_JAVADISPATCH  = 0x00010000; // @javadispath\n+  private static final int MASK_NOCOMPILE     = 0x00020000; // @nocompile\n \n   // 3 bit type field stored in the top 3 bits of the most significant\n   // nibble.\n     setFlag(value, MASK_JAVADISPATCH);\n   }\n \n+  void setNoCompile(boolean value) {\n+    setFlag(value, MASK_NOCOMPILE);\n+  }\n+\n   private void setFlag(boolean value, int mask) {\n     if (value) {\n       bitset |= mask;\n     return getFlag(MASK_JAVADISPATCH);\n   }\n \n+  /**\n+   * Returns whether the {@code @nocompile} annotation is present on this\n+   * {@link JSDocInfo}.\n+   */\n+  public boolean isNoCompile() {\n+    return getFlag(MASK_NOCOMPILE);\n+  }\n+\n   private boolean getFlag(int mask) {\n     return (bitset & mask) != 0x00;\n   }\n--- a/src/com/google/javascript/rhino/JSDocInfoBuilder.java\n+++ b/src/com/google/javascript/rhino/JSDocInfoBuilder.java\n    */\n   public boolean isPopulatedWithFileOverview() {\n     return isPopulated() &&\n-        (currentInfo.hasFileOverview() || currentInfo.isExterns());\n+        (currentInfo.hasFileOverview() || currentInfo.isExterns() ||\n+         currentInfo.isNoCompile());\n   }\n \n   /**\n \n   /**\n    * Records that the {@link JSDocInfo} being built should have its\n+   * {@link JSDocInfo#isNoCompilek()} flag set to {@code true}.\n+   *\n+   * @return {@code true} if the no compile flag was recorded and {@code false}\n+   *     if it was already recorded\n+   */\n+  public boolean recordNoCompile() {\n+    if (!currentInfo.isNoCompile()) {\n+      currentInfo.setNoCompile(true);\n+      populated = true;\n+      return true;\n+    } else {\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * Records that the {@link JSDocInfo} being built should have its\n    * {@link JSDocInfo#isNoTypeCheck()} flag set to {@code true}.\n    *\n    * @return {@code true} if the no check flag was recorded and {@code false}\n--- a/src/com/google/javascript/rhino/jstype/TernaryValue.java\n+++ b/src/com/google/javascript/rhino/jstype/TernaryValue.java\n    *     unknown</pre>\n    */\n   public abstract boolean toBoolean(boolean unknown);\n+\n+  /**\n+   * Gets the TernaryValue for the given boolean.\n+   */\n+  public static TernaryValue forBoolean(boolean val) {\n+    return val ? TernaryValue.TRUE : TernaryValue.FALSE;\n+  }\n }\n--- a/test/com/google/javascript/jscomp/CodePrinterTest.java\n+++ b/test/com/google/javascript/jscomp/CodePrinterTest.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.common.collect.ImmutableList;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n import junit.framework.TestCase;\n-\n-import java.util.List;\n \n public class CodePrinterTest extends TestCase {\n   static Node parse(String js) {\n     assertPrint(\"if(x){;;function y(){};;}\", \"if(x){function y(){}}\");\n   }\n \n+  public void testHook() {\n+    assertPrint(\"a ? b = 1 : c = 2\", \"a?b=1:c=2\");\n+    assertPrint(\"x = a ? b = 1 : c = 2\", \"x=a?b=1:c=2\");\n+    assertPrint(\"(x = a) ? b = 1 : c = 2\", \"(x=a)?b=1:c=2\");\n+\n+    assertPrint(\"x, a ? b = 1 : c = 2\", \"x,a?b=1:c=2\");\n+    assertPrint(\"x, (a ? b = 1 : c = 2)\", \"x,a?b=1:c=2\");\n+    assertPrint(\"(x, a) ? b = 1 : c = 2\", \"(x,a)?b=1:c=2\");\n+\n+    assertPrint(\"a ? (x, b) : c = 2\", \"a?(x,b):c=2\");\n+    assertPrint(\"a ? b = 1 : (x,c)\", \"a?b=1:(x,c)\");\n+\n+    assertPrint(\"a ? b = 1 : c = 2 + x\", \"a?b=1:c=2+x\");\n+    assertPrint(\"(a ? b = 1 : c = 2) + x\", \"(a?b=1:c=2)+x\");\n+    assertPrint(\"a ? b = 1 : (c = 2) + x\", \"a?b=1:(c=2)+x\");\n+\n+    assertPrint(\"a ? (b?1:2) : 3\", \"a?b?1:2:3\");\n+  }\n+\n   public void testPrintInOperatorInForLoop() {\n     // Check for in expression in for's init expression.\n     // Check alone, with + (higher precedence), with ?: (lower precedence),\n   }\n \n   private void assertPrint(String js, String expected) {\n+    parse(expected); // validate the expected string is valid js\n     assertEquals(expected,\n         parsePrint(js, false, CodePrinter.DEFAULT_LINE_LENGTH_THRESHOLD));\n   }\n         \"/**\\n * @constructor\\n */\\nvar x = function() {\\n}\");\n   }\n \n+  public void testEmitUnknownParamTypesAsAllType() {\n+    assertTypeAnnotations(\n+        \"var a = function(x) {}\",\n+        \"/**\\n\" +\n+        \" * @param {*} x\\n\" +\n+        \" */\\n\" + \n+        \"var a = function(x) {\\n}\");\n+  }\n+  \n+  public void testOptionalTypesAnnotation() {\n+    assertTypeAnnotations(\n+        \"/**\\n\" +\n+        \" * @param {string=} x \\n\" +\n+        \" */\\n\" +\n+        \"var a = function(x) {}\",\n+        \"/**\\n\" +\n+        \" * @param {string=} x\\n\" +\n+        \" */\\n\" +\n+        \"var a = function(x) {\\n}\");\n+  }\n+  \n+  public void testVariableArgumentsTypesAnnotation() {\n+    assertTypeAnnotations(\n+        \"/**\\n\" +\n+        \" * @param {...string} x \\n\" +\n+        \" */\\n\" +\n+        \"var a = function(x) {}\",\n+        \"/**\\n\" +\n+        \" * @param {...string} x\\n\" +\n+        \" */\\n\" +\n+        \"var a = function(x) {\\n}\");\n+  }\n+  \n   public void testTempConstructor() {\n     assertTypeAnnotations(\n         \"var x = function() {\\n/**\\n * @constructor\\n */\\nfunction t1() {}\\n\" +\n   }\n \n   public void testParsePrintParse() {\n-    List<String> parsePrintParseTestCases = ImmutableList.of(\n-        \"3;\",\n-        \"var a = b;\",\n-        \"var x, y, z;\",\n-        \"try { foo() } catch(e) { bar() }\",\n-        \"try { foo() } catch(e) { bar() } finally { stuff() }\",\n-        \"try { foo() } finally { stuff() }\",\n-        \"throw 'me'\",\n-        \"function foo(a) { return a + 4; }\",\n-        \"function foo() { return; }\",\n-        \"var a = function(a, b) { foo(); return a + b; }\",\n-        \"b = [3, 4, 'paul', \\\"Buchhe it\\\",,5];\",\n-        \"v = (5, 6, 7, 8)\",\n-        \"d = 34.0; x = 0; y = .3; z = -22\",\n-        \"d = -x; t = !x + ~y;\",\n-        \"'hi'; /* just a test */ stuff(a,b) \\n foo(); // and another \\n bar();\",\n-        \"a = b++ + ++c; a = b++-++c; a = - --b; a = - ++b;\",\n-        \"a++; b= a++; b = ++a; b = a--; b = --a; a+=2; b-=5\",\n-        \"a = (2 + 3) * 4;\",\n-        \"a = 1 + (2 + 3) + 4;\",\n-        \"x = a ? b : c; x = a ? (b,3,5) : (foo(),bar());\",\n-        \"a = b | c || d ^ e && f & !g != h << i <= j < k >>> l > m * n % !o\",\n-        \"a == b; a != b; a === b; a == b == a; (a == b) == a; a == (b == a);\",\n-        \"if (a > b) a = b; if (b < 3) a = 3; else c = 4;\",\n-        \"if (a == b) { a++; } if (a == 0) { a++; } else { a --; }\",\n-        \"for (var i in a) b += i;\",\n-        \"for (var i = 0; i < 10; i++){ b /= 2; if (b == 2)break;else continue;}\",\n-        \"for (x = 0; x < 10; x++) a /= 2;\",\n-        \"for (;;) a++;\",\n-        \"while(true) { blah(); }while(true) blah();\",\n-        \"do stuff(); while(a>b);\",\n-        \"[0, null, , true, false, this];\",\n-        \"s.replace(/absc/, 'X').replace(/ab/gi, 'Y');\",\n-        \"new Foo; new Bar(a, b,c);\",\n-        \"with(foo()) { x = z; y = t; } with(bar()) a = z;\",\n-        \"delete foo['bar']; delete foo;\",\n-        \"var x = { 'a':'paul', 1:'3', 2:(3,4) };\",\n-        \"switch(a) { case 2: case 3: { stuff(); break; }\" +\n-        \"case 4: morestuff(); break; default: done();}\",\n-        \"x = foo['bar'] + foo['my stuff'] + foo[bar] + f.stuff;\",\n-        \"a.v = b.v; x['foo'] = y['zoo'];\",\n-        \"'test' in x; 3 in x; a in x;\",\n-        \"'foo\\\"bar' + \\\"foo'c\\\" + 'stuff\\\\n and \\\\\\\\more'\",\n-        \"x.__proto__;\");\n-\n-    for (String testCase : parsePrintParseTestCases) {\n-      Node parse1 = parse(testCase);\n-      Node parse2 = parse(new CodePrinter.Builder(parse1).build());\n-      assertTrue(testCase, parse1.checkTreeEqualsSilent(parse2));\n-    }\n+    testReparse(\"3;\");\n+    testReparse(\"var a = b;\");\n+    testReparse(\"var x, y, z;\");\n+    testReparse(\"try { foo() } catch(e) { bar() }\");\n+    testReparse(\"try { foo() } catch(e) { bar() } finally { stuff() }\");\n+    testReparse(\"try { foo() } finally { stuff() }\");\n+    testReparse(\"throw 'me'\");\n+    testReparse(\"function foo(a) { return a + 4; }\");\n+    testReparse(\"function foo() { return; }\");\n+    testReparse(\"var a = function(a, b) { foo(); return a + b; }\");\n+    testReparse(\"b = [3, 4, 'paul', \\\"Buchhe it\\\",,5];\");\n+    testReparse(\"v = (5, 6, 7, 8)\");\n+    testReparse(\"d = 34.0; x = 0; y = .3; z = -22\");\n+    testReparse(\"d = -x; t = !x + ~y;\");\n+    testReparse(\"'hi'; /* just a test */ stuff(a,b) \\n foo(); // and another \\n bar();\");\n+    testReparse(\"a = b++ + ++c; a = b++-++c; a = - --b; a = - ++b;\");\n+    testReparse(\"a++; b= a++; b = ++a; b = a--; b = --a; a+=2; b-=5\");\n+    testReparse(\"a = (2 + 3) * 4;\");\n+    testReparse(\"a = 1 + (2 + 3) + 4;\");\n+    testReparse(\"x = a ? b : c; x = a ? (b,3,5) : (foo(),bar());\");\n+    testReparse(\"a = b | c || d ^ e && f & !g != h << i <= j < k >>> l > m * n % !o\");\n+    testReparse(\"a == b; a != b; a === b; a == b == a; (a == b) == a; a == (b == a);\");\n+    testReparse(\"if (a > b) a = b; if (b < 3) a = 3; else c = 4;\");\n+    testReparse(\"if (a == b) { a++; } if (a == 0) { a++; } else { a --; }\");\n+    testReparse(\"for (var i in a) b += i;\");\n+    testReparse(\"for (var i = 0; i < 10; i++){ b /= 2; if (b == 2)break;else continue;}\");\n+    testReparse(\"for (x = 0; x < 10; x++) a /= 2;\");\n+    testReparse(\"for (;;) a++;\");\n+    testReparse(\"while(true) { blah(); }while(true) blah();\");\n+    testReparse(\"do stuff(); while(a>b);\");\n+    testReparse(\"[0, null, , true, false, this];\");\n+    testReparse(\"s.replace(/absc/, 'X').replace(/ab/gi, 'Y');\");\n+    testReparse(\"new Foo; new Bar(a, b,c);\");\n+    testReparse(\"with(foo()) { x = z; y = t; } with(bar()) a = z;\");\n+    testReparse(\"delete foo['bar']; delete foo;\");\n+    testReparse(\"var x = { 'a':'paul', 1:'3', 2:(3,4) };\");\n+    testReparse(\"switch(a) { case 2: case 3: { stuff(); break; }\" +\n+        \"case 4: morestuff(); break; default: done();}\");\n+    testReparse(\"x = foo['bar'] + foo['my stuff'] + foo[bar] + f.stuff;\");\n+    testReparse(\"a.v = b.v; x['foo'] = y['zoo'];\");\n+    testReparse(\"'test' in x; 3 in x; a in x;\");\n+    testReparse(\"'foo\\\"bar' + \\\"foo'c\\\" + 'stuff\\\\n and \\\\\\\\more'\");\n+    testReparse(\"x.__proto__;\");\n+  }\n+  \n+  private void testReparse(String code) {\n+    Node parse1 = parse(code);\n+    Node parse2 = parse(new CodePrinter.Builder(parse1).build());\n+    assertTrue(code, parse1.checkTreeEqualsSilent(parse2));\n   }\n \n   public void testDoLoopIECompatiblity() {\n--- a/test/com/google/javascript/jscomp/CreateSyntheticBlocksTest.java\n+++ b/test/com/google/javascript/jscomp/CreateSyntheticBlocksTest.java\n         NodeTraversal.traverse(compiler, js, new FoldConstants(compiler));\n         NodeTraversal.traverse(compiler, js, new MinimizeExitPoints(compiler));\n         NodeTraversal.traverse(compiler, js, new FoldConstants(compiler));\n+                \n+        new PeepholeOptimizationsPass(compiler, new \n+            PeepholeRemoveDeadCode()).process(externs, js);\n+        \n         new Denormalize(compiler).process(externs, js);\n       }\n     };\n--- a/test/com/google/javascript/jscomp/ExpresssionDecomposerTest.java\n+++ b/test/com/google/javascript/jscomp/ExpresssionDecomposerTest.java\n \n   public void testMoveExpression1() {\n     // There isn't a reason to do this, but it works.\n-    helperMoveExpression(\"foo()\", \"foo\", \"var temp_0 = foo(); temp_0;\");\n+    helperMoveExpression(\"foo()\", \"foo\", \"var temp$$0 = foo(); temp$$0;\");\n   }\n \n   public void testMoveExpression2() {\n     helperMoveExpression(\n         \"x = foo()\",\n         \"foo\",\n-        \"var temp_0 = foo(); x = temp_0;\");\n+        \"var temp$$0 = foo(); x = temp$$0;\");\n   }\n \n   public void testMoveExpression3() {\n     helperMoveExpression(\n         \"var x = foo()\",\n         \"foo\",\n-        \"var temp_0 = foo(); var x = temp_0;\");\n+        \"var temp$$0 = foo(); var x = temp$$0;\");\n   }\n \n   public void testMoveExpression4() {\n     helperMoveExpression(\n         \"if(foo()){}\",\n         \"foo\",\n-        \"var temp_0 = foo(); if (temp_0);\");\n+        \"var temp$$0 = foo(); if (temp$$0);\");\n   }\n \n   public void testMoveExpression5() {\n     helperMoveExpression(\n         \"switch(foo()){}\",\n         \"foo\",\n-        \"var temp_0 = foo(); switch(temp_0){}\");\n+        \"var temp$$0 = foo(); switch(temp$$0){}\");\n   }\n \n   public void testMoveExpression6() {\n     helperMoveExpression(\n         \"switch(1 + foo()){}\",\n         \"foo\",\n-        \"var temp_0 = foo(); switch(1 + temp_0){}\");\n+        \"var temp$$0 = foo(); switch(1 + temp$$0){}\");\n   }\n \n   public void testMoveExpression7() {\n     helperMoveExpression(\n         \"function (){ return foo();}\",\n         \"foo\",\n-        \"function (){ var temp_0 = foo(); return temp_0;}\");\n+        \"function (){ var temp$$0 = foo(); return temp$$0;}\");\n   }\n \n   public void testMoveExpression8() {\n     helperMoveExpression(\n         \"x = foo() && 1\",\n         \"foo\",\n-        \"var temp_0 = foo(); x = temp_0 && 1\");\n+        \"var temp$$0 = foo(); x = temp$$0 && 1\");\n   }\n \n   public void testMoveExpression9() {\n     helperMoveExpression(\n         \"x = foo() || 1\",\n         \"foo\",\n-        \"var temp_0 = foo(); x = temp_0 || 1\");\n+        \"var temp$$0 = foo(); x = temp$$0 || 1\");\n   }\n \n   public void testMoveExpression10() {\n     helperMoveExpression(\n         \"x = foo() ? 0 : 1\",\n         \"foo\",\n-        \"var temp_0 = foo(); x = temp_0 ? 0 : 1\");\n+        \"var temp$$0 = foo(); x = temp$$0 ? 0 : 1\");\n   }\n \n   /* Decomposition tests. */\n     helperExposeExpression(\n         \"x = 0 && foo()\",\n         \"foo\",\n-        \"var temp_0; if (temp_0 = 0) temp_0 = foo(); x = temp_0;\");\n+        \"var temp$$0; if (temp$$0 = 0) temp$$0 = foo(); x = temp$$0;\");\n   }\n \n   public void testExposeExpression2() {\n     helperExposeExpression(\n         \"x = 1 || foo()\",\n         \"foo\",\n-        \"var temp_0; if (temp_0 = 1); else temp_0 = foo(); x = temp_0;\");\n+        \"var temp$$0; if (temp$$0 = 1); else temp$$0 = foo(); x = temp$$0;\");\n   }\n \n   public void testExposeExpression3() {\n     helperExposeExpression(\n         \"var x = 1 ? foo() : 0\",\n         \"foo\",\n-        \"var temp_0; if (1) temp_0 = foo(); else temp_0 = 0;var x = temp_0;\");\n+        \"var temp$$0;\" +\n+        \" if (1) temp$$0 = foo(); else temp$$0 = 0;var x = temp$$0;\");\n   }\n \n   public void testExposeExpression4() {\n     helperExposeExpression(\n         \"x = goo() && foo()\",\n         \"foo\",\n-        \"var temp_0; if (temp_0 = goo()) temp_0 = foo(); x = temp_0;\");\n+        \"var temp$$0; if (temp$$0 = goo()) temp$$0 = foo(); x = temp$$0;\");\n   }\n \n   public void testExposeExpression6() {\n     helperExposeExpression(\n         \"var x = 1 + (goo() && foo())\",\n         \"foo\",\n-        \"var temp_0; if (temp_0 = goo()) temp_0 = foo();\" +\n-        \"var x = 1 + temp_0;\");\n+        \"var temp$$0; if (temp$$0 = goo()) temp$$0 = foo();\" +\n+        \"var x = 1 + temp$$0;\");\n   }\n \n   public void testExposeExpression7() {\n     helperExposeExpression(\n         \"if(goo() && foo());\",\n         \"foo\",\n-        \"var temp_0;\" +\n-        \"if (temp_0 = goo()) temp_0 = foo();\" +\n-        \"if(temp_0);\");\n+        \"var temp$$0;\" +\n+        \"if (temp$$0 = goo()) temp$$0 = foo();\" +\n+        \"if(temp$$0);\");\n   }\n \n   public void testExposeExpression8() {\n     helperExposeExpression(\n         \"switch(goo() && foo()){}\",\n         \"foo\",\n-        \"var temp_0;\" +\n-        \"if (temp_0 = goo()) temp_0 = foo();\" +\n-        \"switch(temp_0){}\");\n+        \"var temp$$0;\" +\n+        \"if (temp$$0 = goo()) temp$$0 = foo();\" +\n+        \"switch(temp$$0){}\");\n   }\n \n   public void testExposeExpression9() {\n     helperExposeExpression(\n         \"switch(1 + goo() + foo()){}\",\n         \"foo\",\n-        \"var temp_const_0 = 1 + goo();\" +\n-        \"switch(temp_const_0 + foo()){}\");\n+        \"var temp_const$$0 = 1 + goo();\" +\n+        \"switch(temp_const$$0 + foo()){}\");\n   }\n \n   public void testExposeExpression10() {\n         \"function (){ return goo() && foo();}\",\n         \"foo\",\n         \"function (){\" +\n-          \"var temp_0; if (temp_0 = goo()) temp_0 = foo();\" +\n-          \"return temp_0;\" +\n+          \"var temp$$0; if (temp$$0 = goo()) temp$$0 = foo();\" +\n+          \"return temp$$0;\" +\n          \"}\");\n   }\n \n     helperExposeExpression(\n         \"if (goo(1, goo(2), (1 ? foo() : 0)));\",\n         \"foo\",\n-        \"var temp_const_1 = goo;\" +\n-        \"var temp_const_0 = goo(2);\" +\n-        \"var temp_2;\" +\n-        \"if (1) temp_2 = foo(); else temp_2 = 0;\" +\n-        \"if (temp_const_1(1, temp_const_0, temp_2));\");\n+        \"var temp_const$$1 = goo;\" +\n+        \"var temp_const$$0 = goo(2);\" +\n+        \"var temp$$2;\" +\n+        \"if (1) temp$$2 = foo(); else temp$$2 = 0;\" +\n+        \"if (temp_const$$1(1, temp_const$$0, temp$$2));\");\n   }\n \n   // Simple name on LHS of assignment-op.\n     helperExposeExpression(\n         \"var x = 0; x += foo() + 1\",\n         \"foo\",\n-        \"var x = 0; var temp_const_0 = x;\" +\n-        \"x = temp_const_0 + (foo() + 1);\");\n+        \"var x = 0; var temp_const$$0 = x;\" +\n+        \"x = temp_const$$0 + (foo() + 1);\");\n \n     helperExposeExpression(\n         \"var x = 0; y = (x += foo()) + x\",\n         \"foo\",\n-        \"var x = 0; var temp_const_0 = x;\" +\n-        \"y = (x = temp_const_0 + foo()) + x\");\n+        \"var x = 0; var temp_const$$0 = x;\" +\n+        \"y = (x = temp_const$$0 + foo()) + x\");\n   }\n \n   // Structure on LHS of assignment-op.\n     helperExposeExpression(\n         \"var x = {}; x.a += foo() + 1\",\n         \"foo\",\n-        \"var x = {}; var temp_const_0 = x; var temp_const_1 = temp_const_0.a;\" +\n-        \"temp_const_0.a = temp_const_1 + (foo() + 1);\");\n+        \"var x = {}; var temp_const$$0 = x;\" +\n+        \"var temp_const$$1 = temp_const$$0.a;\" +\n+        \"temp_const$$0.a = temp_const$$1 + (foo() + 1);\");\n \n     helperExposeExpression(\n         \"var x = {}; y = (x.a += foo()) + x.a\",\n         \"foo\",\n-        \"var x = {}; var temp_const_0 = x; var temp_const_1 = temp_const_0.a;\" +\n-        \"y = (temp_const_0.a = temp_const_1 + foo()) + x.a\");\n+        \"var x = {}; var temp_const$$0 = x;\" +\n+        \"var temp_const$$1 = temp_const$$0.a;\" +\n+        \"y = (temp_const$$0.a = temp_const$$1 + foo()) + x.a\");\n   }\n \n   // Constant object on LHS of assignment-op.\n         \"var XX = {};\\n\" +\n         \"XX.a += foo() + 1\",\n         \"foo\",\n-        \"var XX = {}; var temp_const_0 = XX.a;\" +\n-        \"XX.a = temp_const_0 + (foo() + 1);\");\n+        \"var XX = {}; var temp_const$$0 = XX.a;\" +\n+        \"XX.a = temp_const$$0 + (foo() + 1);\");\n \n     helperExposeExpression(\n         \"var XX = {}; y = (XX.a += foo()) + XX.a\",\n         \"foo\",\n-        \"var XX = {}; var temp_const_0 = XX.a;\" +\n-        \"y = (XX.a = temp_const_0 + foo()) + XX.a\");\n+        \"var XX = {}; var temp_const$$0 = XX.a;\" +\n+        \"y = (XX.a = temp_const$$0 + foo()) + XX.a\");\n   }\n \n   // Function all on LHS of assignment-op.\n         \"var x = {}; goo().a += foo() + 1\",\n         \"foo\",\n         \"var x = {};\" +\n-        \"var temp_const_0 = goo();\" +\n-        \"var temp_const_1 = temp_const_0.a;\" +\n-        \"temp_const_0.a = temp_const_1 + (foo() + 1);\");\n+        \"var temp_const$$0 = goo();\" +\n+        \"var temp_const$$1 = temp_const$$0.a;\" +\n+        \"temp_const$$0.a = temp_const$$1 + (foo() + 1);\");\n \n     helperExposeExpression(\n         \"var x = {}; y = (goo().a += foo()) + goo().a\",\n         \"foo\",\n         \"var x = {};\" +\n-        \"var temp_const_0 = goo();\" +\n-        \"var temp_const_1 = temp_const_0.a;\" +\n-        \"y = (temp_const_0.a = temp_const_1 + foo()) + goo().a\");\n+        \"var temp_const$$0 = goo();\" +\n+        \"var temp_const$$1 = temp_const$$0.a;\" +\n+        \"y = (temp_const$$0.a = temp_const$$1 + foo()) + goo().a\");\n   }\n \n   // Test mulitple levels\n         \"var x = {}; goo().a.b += foo() + 1\",\n         \"foo\",\n         \"var x = {};\" +\n-        \"var temp_const_0 = goo().a;\" +\n-        \"var temp_const_1 = temp_const_0.b;\" +\n-        \"temp_const_0.b = temp_const_1 + (foo() + 1);\");\n+        \"var temp_const$$0 = goo().a;\" +\n+        \"var temp_const$$1 = temp_const$$0.b;\" +\n+        \"temp_const$$0.b = temp_const$$1 + (foo() + 1);\");\n \n     helperExposeExpression(\n         \"var x = {}; y = (goo().a.b += foo()) + goo().a\",\n         \"foo\",\n         \"var x = {};\" +\n-        \"var temp_const_0 = goo().a;\" +\n-        \"var temp_const_1 = temp_const_0.b;\" +\n-        \"y = (temp_const_0.b = temp_const_1 + foo()) + goo().a\");\n+        \"var temp_const$$0 = goo().a;\" +\n+        \"var temp_const$$1 = temp_const$$0.b;\" +\n+        \"y = (temp_const$$0.b = temp_const$$1 + foo()) + goo().a\");\n   }\n \n   /** Test case helpers. */\n     }\n     ExpressionDecomposer decomposer = new ExpressionDecomposer(\n         compiler, compiler.getUniqueNameIdSupplier(), knownConstants);\n-    decomposer.setTempNamePrefix(\"temp_\");\n+    decomposer.setTempNamePrefix(\"temp\");\n     Node expectedRoot = parse(compiler, expectedResult);\n     Node tree = parse(compiler, code);\n     assertNotNull(tree);\n \n     ExpressionDecomposer decomposer = new ExpressionDecomposer(\n         compiler, compiler.getUniqueNameIdSupplier(), knownConstants);\n-    decomposer.setTempNamePrefix(\"temp_\");\n+    decomposer.setTempNamePrefix(\"temp\");\n     Node expectedRoot = parse(compiler, expectedResult);\n     Node tree = parse(compiler, code);\n     assertNotNull(tree);\n--- a/test/com/google/javascript/jscomp/ExternExportsPassTest.java\n+++ b/test/com/google/javascript/jscomp/ExternExportsPassTest.java\n *\n  */\n public class ExternExportsPassTest extends TestCase {\n-  private static final JSSourceFile[] EXTERNS = {\n-      JSSourceFile.fromCode(\"externs\", \"\")\n-  };\n \n   public void testExportSymbol() throws Exception {\n     compileAndCheck(\"var a = {}; a.b = {}; a.b.c = function(d, e, f) {};\" +\n                     \"goog.exportSymbol('foobar', a.b.c)\",\n-                    \"var foobar = function(d, e, f) {};\\n\");\n+                    \"/**\\n\" +\n+                    \" * @param {*} d\\n\" +\n+                    \" * @param {*} e\\n\" +\n+                    \" * @param {*} f\\n\" +\n+                    \" */\\n\" +\n+                    \"var foobar = function(d, e, f) {\\n}\");\n+  }\n+  \n+  public void testExportSymbolDefinedInVar() throws Exception {\n+    compileAndCheck(\"var a = function(d, e, f) {};\" +\n+                    \"goog.exportSymbol('foobar', a)\",\n+                    \"/**\\n\" +\n+                    \" * @param {*} d\\n\" +\n+                    \" * @param {*} e\\n\" +\n+                    \" * @param {*} f\\n\" +\n+                    \" */\\n\" +\n+                    \"var foobar = function(d, e, f) {\\n}\");\n   }\n \n   public void testExportProperty() throws Exception {\n     compileAndCheck(\"var a = {}; a.b = {}; a.b.c = function(d, e, f) {};\" +\n                     \"goog.exportProperty(a.b, 'cprop', a.b.c)\",\n-                    \"var a;\\na.b;\\na.b.cprop = function(d, e, f) {};\\n\");\n+                    \"var a = {};\\n\" +\n+                    \"a.b = {};\\n\" +\n+                    \"/**\\n\" +\n+                    \" * @param {*} d\\n\" +\n+                    \" * @param {*} e\\n\" +\n+                    \" * @param {*} f\\n\" +\n+                    \" */\\n\" +\n+                    \"a.b.cprop = function(d, e, f) {\\n}\");\n   }\n \n   public void testExportMultiple() throws Exception {\n                     \"goog.exportProperty(a.b, 'c', a.b.c);\" +\n                     \"goog.exportProperty(a.b.prototype, 'c', a.b.prototype.c);\",\n \n-                    \"var a;\\n\" +\n-                    \"a.b = function(p1) {};\\n\" +\n-                    \"a.b.c = function(d, e, f) {};\\n\" +\n-                    \"a.b.prototype;\\n\" +\n-                    \"a.b.prototype.c = function(g, h, i) {};\\n\");\n-  }\n-\n+                    \"var a = {};\\n\" +\n+                    \"/**\\n\" +\n+                    \" * @param {*} p1\\n\" +\n+                    \" */\\n\" +\n+                    \"a.b = function(p1) {\\n};\\n\" +\n+                    \"/**\\n\" +\n+                    \" * @param {*} d\\n\" +\n+                    \" * @param {*} e\\n\" +\n+                    \" * @param {*} f\\n\" +\n+                    \" */\\n\" +\n+                    \"a.b.c = function(d, e, f) {\\n};\\n\" +\n+                    \"/**\\n\" +\n+                    \" * @param {*} g\\n\" +\n+                    \" * @param {*} h\\n\" +\n+                    \" * @param {*} i\\n\" +\n+                    \" */\\n\" +\n+                    \"a.b.prototype.c = function(g, h, i) {\\n}\");\n+  }\n+  \n   public void testExportMultiple2() throws Exception {\n     compileAndCheck(\"var a = {}; a.b = function(p1) {}; \" +\n                     \"a.b.c = function(d, e, f) {};\" +\n                     \"goog.exportProperty(a.b, 'c', a.b.c);\" +\n                     \"goog.exportProperty(a.b.prototype, 'c', a.b.prototype.c);\",\n \n-                    \"var hello;\\n\" +\n-                    \"hello.b;\\n\" +\n-                    \"hello.b.c = function(d, e, f) {};\\n\" +\n-                    \"hello.b.prototype;\\n\" +\n-                    \"hello.b.prototype.c = function(g, h, i) {};\\n\");\n-  }\n-\n+                    \"var hello = {};\\n\" +\n+                    \"hello.b = {};\\n\" +\n+                    \"/**\\n\" +\n+                    \" * @param {*} d\\n\" +\n+                    \" * @param {*} e\\n\" +\n+                    \" * @param {*} f\\n\" +\n+                    \" */\\n\" +\n+                    \"hello.b.c = function(d, e, f) {\\n};\\n\" +\n+                    \"/**\\n\" +\n+                    \" * @param {*} g\\n\" +\n+                    \" * @param {*} h\\n\" +\n+                    \" * @param {*} i\\n\" +\n+                    \" */\\n\" +\n+                    \"hello.b.prototype.c = function(g, h, i) {\\n}\");\n+  }\n \n   public void testExportMultiple3() throws Exception {\n     compileAndCheck(\"var a = {}; a.b = function(p1) {}; \" +\n                     \"goog.exportSymbol('prefix', a.b);\" +\n                     \"goog.exportProperty(a.b, 'c', a.b.c);\",\n \n-                    \"var prefix = function(p1) {};\\n\" +\n-                    \"prefix.c = function(d, e, f) {};\\n\");\n-  }\n-\n+                    \"/**\\n\" +\n+                    \" * @param {*} p1\\n\" +\n+                    \" */\\n\" +\n+                    \"var prefix = function(p1) {\\n};\\n\" +\n+                    \"/**\\n\" +\n+                    \" * @param {*} d\\n\" +\n+                    \" * @param {*} e\\n\" +\n+                    \" * @param {*} f\\n\" +\n+                    \" */\\n\" +\n+                    \"prefix.c = function(d, e, f) {\\n}\");\n+  }\n \n   public void testExportNonStaticSymbol() throws Exception {\n     compileAndCheck(\"var a = {}; a.b = {}; var d = {}; a.b.c = d;\" +\n                     \"goog.exportSymbol('foobar', a.b.c)\",\n-                    \"var foobar;\\n\");\n+                    \"var foobar = {}\");\n   }\n \n   public void testExportNonStaticSymbol2() throws Exception {\n     compileAndCheck(\"var a = {}; a.b = {}; var d = null; a.b.c = d;\" +\n                     \"goog.exportSymbol('foobar', a.b.c())\",\n-                    \"var foobar;\\n\");\n-  }\n-\n-  public void testExportNonexistantProperty() throws Exception {\n+                    \"var foobar = {}\");\n+  }\n+\n+  public void testExportNonexistentProperty() throws Exception {\n     compileAndCheck(\"var a = {}; a.b = {}; a.b.c = function(d, e, f) {};\" +\n                     \"goog.exportProperty(a.b, 'none', a.b.none)\",\n-                    \"var a;\\n\" +\n-                    \"a.b;\\n\" +\n-                    \"a.b.none;\\n\");\n-  }\n-\n-\n+                    \"var a = {};\\n\" +\n+                    \"a.b = {};\\n\" +\n+                    \"a.b.none = {}\");\n+  }\n+\n+  public void testExportSymbolWithTypeAnnotation() {\n+    \n+    compileAndCheck(\"var internalName;\\n\" +\n+                    \"/**\\n\" +\n+                    \" * @param {string} param1\\n\" +\n+                    \" * @param {number} param2\\n\" +\n+                    \" * @return {string}\\n\" +\n+                    \" */\\n\" +  \n+                    \"internalName = function(param1, param2) {\" +\n+                      \"return param1 + param2;\" +\n+                    \"};\" +\n+                    \"goog.exportSymbol('externalName', internalName)\",\n+                    \"/**\\n\" +\n+                    \" * @param {string} param1\\n\" +\n+                    \" * @param {number} param2\\n\" +\n+                    \" * @return {string}\\n\" +\n+                    \" */\\n\" + \n+                    \"var externalName = function(param1, param2) {\\n}\");\n+  }\n+\n+  public void testExportSymbolWithConstructor() {\n+    compileAndCheck(\"var internalName;\\n\" +\n+                    \"/**\\n\" +\n+                    \" * @constructor\\n\" +\n+                    \" */\\n\" +  \n+                    \"internalName = function() {\" +\n+                    \"};\" +\n+                    \"goog.exportSymbol('externalName', internalName)\",\n+                    \"/**\\n\" +\n+                    \" * @constructor\\n\" +\n+                    \" */\\n\" + \n+                    \"var externalName = function() {\\n}\");\n+  }\n+  \n+  public void testExportFunctionWithOptionalArguments() {\n+    compileAndCheck(\"var internalName;\\n\" +\n+        \"/**\\n\" +\n+        \" * @param {number=} a\\n\" +\n+        \" */\\n\" +  \n+        \"internalName = function(a) {\" +\n+        \"  return 6;\\n\" +\n+        \"};\" +\n+        \"goog.exportSymbol('externalName', internalName)\",\n+        \"/**\\n\" +\n+        \" * @param {number=} a\\n\" +\n+        \" */\\n\" + \n+        \"var externalName = function(a) {\\n}\");\n+  }\n+  \n+  public void testExportFunctionWithVariableArguments() {\n+    compileAndCheck(\"var internalName;\\n\" +\n+        \"/**\\n\" +\n+        \" * @param {...number} a\\n\" +\n+        \" * @return {number}\\n\" + \n+        \" */\\n\" +  \n+        \"internalName = function(a) {\" +\n+        \"  return 6;\\n\" +\n+        \"};\" +\n+        \"goog.exportSymbol('externalName', internalName)\",\n+        \"/**\\n\" +\n+        \" * @param {...number} a\\n\" +\n+        \" * @return {number}\\n\" +\n+        \" */\\n\" + \n+        \"var externalName = function(a) {\\n}\");\n+  }\n+  \n+  /** If we export a property with \"prototype\" as a path component, there\n+    * is no need to emit the initializer for prototype because every namespace\n+    * has one automatically.\n+    */  \n+  public void testExportDontEmitPrototypePathPrefix() { \n+    compileAndCheck(\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" */\\n\" +\n+        \"var Foo = function() {};\" +\n+        \"/**\\n\" +\n+        \" * @return {number}\\n\" +\n+        \" */\\n\" +\n+        \"Foo.prototype.m = function() {return 6;};\\n\" +\n+        \"goog.exportSymbol('Foo', Foo);\\n\" +\n+        \"goog.exportProperty(Foo.prototype, 'm', Foo.prototype.m);\",\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" */\\n\" +\n+        \"var Foo = function() {\\n};\\n\" +\n+        \"/**\\n\" +\n+        \" * @return {number}\\n\" +\n+        \" */\\n\" +\n+        \"Foo.prototype.m = function() {\\n}\"\n+    );  \n+  }\n+  \n+  /**\n+   * Test the workflow of creating an externs file for a library\n+   * via the export pass and then using that externs file in a client.\n+   * \n+   * There should be no warnings in the client if the library includes\n+   * type information for the exported functions and the client uses them \n+   * correctly.\n+   */\n+  public void testUseExportsAsExterns() {  \n+    String librarySource = \n+    \"/**\\n\" +\n+    \" * @param {number} a\\n\" +\n+    \" * @constructor\\n\" +\n+    \" */\\n\" +  \n+    \"var InternalName = function(a) {\" +\n+    \"};\" +\n+    \"goog.exportSymbol('ExternalName', InternalName)\";\n+       \n+    String clientSource = \n+      \"var a = new ExternalName(6);\\n\" +\n+      \"/**\\n\" +\n+      \" * @param {ExternalName} x\\n\" +\n+      \" */\\n\" +\n+      \"var b = function(x) {};\";\n+    \n+    Result libraryCompileResult = compileAndExportExterns(librarySource); \n+    \n+    assertEquals(0, libraryCompileResult.warnings.length);\n+    assertEquals(0, libraryCompileResult.errors.length);\n+    \n+    String generatedExterns = libraryCompileResult.externExport;\n+    \n+    Result clientCompileResult = compileAndExportExterns(clientSource, \n+        generatedExterns);\n+    \n+    assertEquals(0, clientCompileResult.warnings.length);\n+    assertEquals(0, clientCompileResult.errors.length);\n+  }\n+  \n+  public void testWarnOnExportFunctionWithUnknownReturnType() {\n+    String librarySource = \n+      \"var InternalName = function() {\" +\n+      \"  return 6;\" +\n+      \"};\" +\n+      \"goog.exportSymbol('ExternalName', InternalName)\";\n+         \n+      Result libraryCompileResult = compileAndExportExterns(librarySource); \n+      \n+      assertEquals(1, libraryCompileResult.warnings.length);\n+      assertEquals(0, libraryCompileResult.errors.length);\n+  }\n+  \n+  public void testDontWarnOnExportConstructorWithUnknownReturnType() {\n+    String librarySource = \n+      \"/**\\n\" +\n+      \" * @constructor\\n\" +\n+      \" */\\n \" +\n+      \"var InternalName = function() {\" +\n+      \"};\" +\n+      \"goog.exportSymbol('ExternalName', InternalName)\";\n+         \n+      Result libraryCompileResult = compileAndExportExterns(librarySource); \n+      \n+      assertEquals(0, libraryCompileResult.warnings.length);\n+      assertEquals(0, libraryCompileResult.errors.length);\n+  }\n+   \n   private void compileAndCheck(String js, String expected) {\n-    System.err.println(compile(js));\n-    assertEquals(expected, compile(js));\n-  }\n-\n-  private String compile(String js) {\n+    Result result = compileAndExportExterns(js);\n+    \n+    assertEquals(expected, result.externExport);\n+  }\n+  \n+  public void testWarnOnExportFunctionWithUnknownParameterTypes() {\n+    /* This source is missing types for the b and c parameters */\n+    String librarySource = \n+      \"/**\\n\" +\n+      \" * @param {number} a\\n\" +\n+      \" * @return {number}\" +\n+      \" */\\n \" +\n+      \"var InternalName = function(a,b,c) {\" +\n+      \"  return 6;\" +\n+      \"};\" +\n+      \"goog.exportSymbol('ExternalName', InternalName)\";\n+         \n+      Result libraryCompileResult = compileAndExportExterns(librarySource); \n+      \n+      assertEquals(2, libraryCompileResult.warnings.length);\n+      assertEquals(0, libraryCompileResult.errors.length);\n+  }\n+  \n+  private Result compileAndExportExterns(String js) {\n+    return compileAndExportExterns(js, \"\");\n+  }\n+  \n+  /**\n+   * Compiles the passed in javascript with the passed in externs and returns\n+   * the new externs exported by the this pass.\n+   * \n+   * @param js the source to be compiled\n+   * @param externs the externs the {@code js} source needs\n+   * @return the externs generated from {@code js}\n+   */ \n+  private Result compileAndExportExterns(String js, String externs) {\n     Compiler compiler = new Compiler();\n     CompilerOptions options = new CompilerOptions();\n     options.externExportsPath = \"externs.js\";\n     // Turn on IDE mode to get rid of optimizations.\n     options.ideMode = true;\n \n+    /* Check types so we can make sure our exported externs have\n+     * type information.\n+     */  \n+    options.checkSymbols = true;\n+    options.checkTypes = true;\n+    \n     JSSourceFile[] inputs = {\n       JSSourceFile.fromCode(\"testcode\",\n                             \"var goog = {};\" +\n                             js)\n     };\n \n-    Result result = compiler.compile(EXTERNS, inputs, options);\n+    JSSourceFile[] externFiles = {\n+        JSSourceFile.fromCode(\"externs\", externs)\n+    };\n+    \n+    Result result = compiler.compile(externFiles, inputs, options);\n \n     assertTrue(result.success);\n \n-    return result.externExport;\n+    return result;\n   }\n }\n--- a/test/com/google/javascript/jscomp/FoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/FoldConstantsTest.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.common.collect.ImmutableSet;\n import com.google.javascript.rhino.Node;\n \n public class FoldConstantsTest extends CompilerTestCase {\n+  private boolean runFoldConstantsFirst = true;\n \n   // TODO(user): Remove this when we no longer need to do string comparison.\n   private FoldConstantsTest(boolean compareAsTree) {\n   public CompilerPass getProcessor(final Compiler compiler) {\n     return new CompilerPass() {\n       public void process(Node externs, Node js) {\n+        if (runFoldConstantsFirst) {\n+          runFoldConstants(externs, js);\n+          runPeepholePasses(externs, js);\n+        } else {\n+          runPeepholePasses(externs, js);\n+          runFoldConstants(externs, js);\n+        }\n+      }\n+\n+      private void runFoldConstants(Node externs, Node js) {\n         NodeTraversal.traverse(compiler, js, new FoldConstants(compiler));\n-\n+      }\n+\n+      private void runPeepholePasses(Node externs, Node js) {\n         /* TODO(dcc): For now we run all remaining FoldConstants tests under\n          * both the FoldConstants pass and the new PeepholeOptimizationPass,\n          * since many remaining FoldConstants tests rely on functionality\n          * Those that genuinely need to test combinations of different\n          * Peephole passes will be moved to AbstractPeepholeOptimizationTest.\n          */\n-\n-        ImmutableSet<AbstractPeepholeOptimization> peepholeOptimizations =\n-          ImmutableSet.<AbstractPeepholeOptimization>of(\n-              new PeepholeSubstituteAlternateSyntax());\n-\n         PeepholeOptimizationsPass peepholePass =\n-            new PeepholeOptimizationsPass(compiler, peepholeOptimizations);\n+            new PeepholeOptimizationsPass(compiler,\n+                new PeepholeSubstituteAlternateSyntax(),\n+                new PeepholeRemoveDeadCode());\n \n         peepholePass.process(externs, js);\n       }\n   }\n \n   void foldSame(String js) {\n+    runFoldConstantsFirst = true;\n     testSame(js);\n+    runFoldConstantsFirst = false;\n+    testSame(js);\n+    runFoldConstantsFirst = true;\n   }\n \n   void fold(String js, String expected) {\n+    runFoldConstantsFirst = true;\n     test(js, expected);\n+    runFoldConstantsFirst = false;\n+    test(js, expected);\n+    runFoldConstantsFirst = true;\n   }\n \n   void fold(String js, String expected, DiagnosticType warning) {\n+    runFoldConstantsFirst = true;\n     test(js, expected, warning);\n+    runFoldConstantsFirst = false;\n+    test(js, expected, warning);\n+    runFoldConstantsFirst = true;\n   }\n \n   // TODO(user): This is same as fold() except it uses string comparison. Any\n     fold(\"x = 3 || x\", \"x = 3\");\n     fold(\"x = false || 0\", \"x = 0\");\n \n-    fold(\"if(x && true) z()\", \"x&&z()\");\n-    fold(\"if(x && false) z()\", \"\");\n+    test(\"if(x && true) z()\", \"x&&z()\");\n+    test(\"if(x && false) z()\", \"\");\n     fold(\"if(x || 3) z()\", \"z()\");\n     fold(\"if(x || false) z()\", \"x&&z()\");\n-    fold(\"if(x==y && false) z()\", \"\");\n+    test(\"if(x==y && false) z()\", \"\");\n \n     // This would be foldable, but it isn't detected, because 'if' isn't\n     // the parent of 'x || 3'. Cf. FoldConstants.tryFoldAndOr().\n \n   public void testFoldUselessDo() {\n     fold(\"do { foo() } while(false);\", \"foo()\");\n-    fold(\"do { foo() } while(!true);\", \"foo()\");\n+    test(\"do { foo() } while(!true);\", \"foo()\");\n     fold(\"do { foo() } while(void 0);\", \"foo()\");\n     fold(\"do { foo() } while(undefined);\", \"foo()\");\n     fold(\"do { foo() } while(!false);\", \"do { foo() } while(1);\");\n     foldSame(\"do { foo(); break; } while(0)\");\n \n     // Make sure proper empty nodes are inserted.\n-    fold(\"if(foo())do {foo()} while(false) else bar()\", \"foo()?foo():bar()\");\n+    test(\"if(foo())do {foo()} while(false) else bar()\", \"foo()?foo():bar()\");\n   }\n \n   public void testMinimizeCondition() {\n   }\n \n   public void testMinimizeExpr() {\n-    fold(\"!!true\", \"0\");\n+    test(\"!!true\", \"0\");\n     fold(\"!!x\", \"x\");\n-    fold(\"!(!x&&!y)\", \"!x&&!y\");\n+    test(\"!(!x&&!y)\", \"!x&&!y\");\n     fold(\"x||!!y\", \"x||y\");\n     fold(\"!(!!x&&y)\", \"x&&y\");\n   }\n       }\n     };\n \n-    oneRepetitiontest.fold(\"x ? x() : void 0\", \"x&&x();\");\n+    oneRepetitiontest.test(\"x ? x() : void 0\", \"x&&x();\");\n     oneRepetitiontest.foldSame(\"y = x ? x() : void 0\");\n   }\n \n     fold(\"var x = new Error('20')\", \"var x = Error(\\\"20\\\")\");\n     fold(\"var x = new Array('20')\", \"var x = Array(\\\"20\\\")\");\n   }\n+\n+  public void testFoldNegativeBug() {\n+    fold(\"(-3);\", \"1;\");\n+  }\n }\n--- a/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n+++ b/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n         \"function foo(a){return true;}; \" +\n         \"function x() { if (foo(1)) throw 'test'; }\",\n         \"function foo(a){return true;}; \" +\n-        \"function x() { {var JSCompiler_inline_result_0; \" +\n-        \"JSCompiler_inline_result_0=true;}\" +\n-        \"if (JSCompiler_inline_result_0) throw 'test'; }\",\n+        \"function x() { {var JSCompiler_inline_result$$0; \" +\n+        \"JSCompiler_inline_result$$0=true;}\" +\n+        \"if (JSCompiler_inline_result$$0) throw 'test'; }\",\n         \"foo\", INLINE_BLOCK);\n   }\n \n         \"function foo(a){return true;}; \" +\n         \"function x() { return foo(1); }\",\n         \"function foo(a){return true;}; \" +\n-        \"function x() { {var JSCompiler_inline_result_0; \" +\n-        \"JSCompiler_inline_result_0=true;}\" +\n-        \"return JSCompiler_inline_result_0; }\",\n+        \"function x() { {var JSCompiler_inline_result$$0; \" +\n+        \"JSCompiler_inline_result$$0=true;}\" +\n+        \"return JSCompiler_inline_result$$0; }\",\n         \"foo\", INLINE_BLOCK);\n   }\n \n         \"function foo(a){return true;}; \" +\n         \"function x() { switch(foo(1)) { default:break; } }\",\n         \"function foo(a){return true;}; \" +\n-        \"function x() { {var JSCompiler_inline_result_0; \" +\n-        \"JSCompiler_inline_result_0=true;}\" +\n-        \"switch(JSCompiler_inline_result_0) { default:break; } }\",\n+        \"function x() { {var JSCompiler_inline_result$$0; \" +\n+        \"JSCompiler_inline_result$$0=true;}\" +\n+        \"switch(JSCompiler_inline_result$$0) { default:break; } }\",\n         \"foo\", INLINE_BLOCK);\n   }\n \n         \"function foo(a){return true;}; \" +\n         \"function x() {foo(1)?0:1 }\",\n         \"function foo(a){return true;}; \" +\n-        \"function x() { {var JSCompiler_inline_result_0; \" +\n-        \"JSCompiler_inline_result_0=true;}\" +\n-        \"JSCompiler_inline_result_0?0:1 }\",\n+        \"function x() { {var JSCompiler_inline_result$$0; \" +\n+        \"JSCompiler_inline_result$$0=true;}\" +\n+        \"JSCompiler_inline_result$$0?0:1 }\",\n         \"foo\", INLINE_BLOCK);\n   }\n \n         \"function foo(a){return true;}; \" +\n         \"function x() {foo(1)&&1 }\",\n         \"function foo(a){return true;}; \" +\n-        \"function x() { {var JSCompiler_inline_result_0; \" +\n-        \"JSCompiler_inline_result_0=true;}\" +\n-        \"JSCompiler_inline_result_0&&1 }\",\n+        \"function x() { {var JSCompiler_inline_result$$0; \" +\n+        \"JSCompiler_inline_result$$0=true;}\" +\n+        \"JSCompiler_inline_result$$0&&1 }\",\n         \"foo\", INLINE_BLOCK);\n   }\n \n         \"function foo(a){return true;}; \" +\n         \"function x() {1 + foo(1) }\",\n         \"function foo(a){return true;}; \" +\n-        \"function x() { {var JSCompiler_inline_result_0; \" +\n-        \"JSCompiler_inline_result_0=true;}\" +\n-        \"1 + JSCompiler_inline_result_0 }\",\n+        \"function x() { {var JSCompiler_inline_result$$0; \" +\n+        \"JSCompiler_inline_result$$0=true;}\" +\n+        \"1 + JSCompiler_inline_result$$0 }\",\n         \"foo\", INLINE_BLOCK);\n   }\n \n         \"function foo(a){return true;}; \" +\n         \"function x() {foo(1) && 1 }\",\n         \"function foo(a){return true;}; \" +\n-        \"function x() { {var JSCompiler_inline_result_0; \" +\n-        \"JSCompiler_inline_result_0=true;}\" +\n-        \"JSCompiler_inline_result_0&&1 }\",\n+        \"function x() { {var JSCompiler_inline_result$$0; \" +\n+        \"JSCompiler_inline_result$$0=true;}\" +\n+        \"JSCompiler_inline_result$$0&&1 }\",\n         \"foo\", INLINE_BLOCK);\n   }\n \n         \"function foo(a){return true;}; \" +\n         \"function x() {1 + foo(1) }\",\n         \"function foo(a){return true;}; \" +\n-        \"function x() { {var JSCompiler_inline_result_0; \" +\n-        \"JSCompiler_inline_result_0=true;}\" +\n-        \"1 + JSCompiler_inline_result_0 }\",\n+        \"function x() { {var JSCompiler_inline_result$$0; \" +\n+        \"JSCompiler_inline_result$$0=true;}\" +\n+        \"1 + JSCompiler_inline_result$$0 }\",\n         \"foo\", INLINE_BLOCK);\n   }\n \n         \"function foo(a){return true;}; \" +\n         \"function x() {var b = 1 + foo(1)}\",\n         \"function foo(a){return true;}; \" +\n-        \"function x() { {var JSCompiler_inline_result_0; \" +\n-        \"JSCompiler_inline_result_0=true;}\" +\n-        \"var b = 1 + JSCompiler_inline_result_0 }\",\n+        \"function x() { {var JSCompiler_inline_result$$0; \" +\n+        \"JSCompiler_inline_result$$0=true;}\" +\n+        \"var b = 1 + JSCompiler_inline_result$$0 }\",\n         \"foo\", INLINE_BLOCK);\n   }\n \n //         \"function x() {var b; b += 1 + foo(1) }\",\n //         \"function foo(a){return true;}; \" +\n //         \"function x() {var b;\" +\n-//         \"{var JSCompiler_inline_result_0; \" +\n-//         \"JSCompiler_inline_result_0=true;}\" +\n-//         \"b += 1 + JSCompiler_inline_result_0 }\",\n+//         \"{var JSCompiler_inline_result$$0; \" +\n+//         \"JSCompiler_inline_result$$0=true;}\" +\n+//         \"b += 1 + JSCompiler_inline_result$$0 }\",\n //         \"foo\", INLINE_BLOCK);\n //   }\n \n         \"function foo(a){return true;}; \" +\n         \"function x() {a:foo(1)?0:1 }\",\n         \"function foo(a){return true;}; \" +\n-        \"function x() { a:{{var JSCompiler_inline_result_0; \" +\n-        \"JSCompiler_inline_result_0=true;}\" +\n-        \"JSCompiler_inline_result_0?0:1 }}\",\n+        \"function x() { a:{{var JSCompiler_inline_result$$0; \" +\n+        \"JSCompiler_inline_result$$0=true;}\" +\n+        \"JSCompiler_inline_result$$0?0:1 }}\",\n         \"foo\", INLINE_BLOCK);\n   }\n \n         \"function foo(a){return true;}; \" +\n         \"function x() { goo() + (1?foo(1):1) }\",\n         \"function foo(a){return true;}; \" +\n-        \"function x() { var JSCompiler_temp_const_0=goo();\" +\n-            \"var JSCompiler_temp_1;\" +\n+        \"function x() { var JSCompiler_temp_const$$0=goo();\" +\n+            \"var JSCompiler_temp$$1;\" +\n             \"if(1) {\" +\n-            \"  {JSCompiler_temp_1=true;} \" +\n+            \"  {JSCompiler_temp$$1=true;} \" +\n             \"} else {\" +\n-            \"  JSCompiler_temp_1=1;\" +\n+            \"  JSCompiler_temp$$1=1;\" +\n             \"}\" +\n-            \"JSCompiler_temp_const_0 + JSCompiler_temp_1\" +\n+            \"JSCompiler_temp_const$$0 + JSCompiler_temp$$1\" +\n             \"}\",\n         \"foo\", INLINE_BLOCK, true);\n   }\n         \"var z = {};\" +\n         \"function foo(a){z = {};return true;}; \" +\n         \"function x() {\" +\n-            \"var JSCompiler_temp_const_0=z;\" +\n+            \"var JSCompiler_temp_const$$0=z;\" +\n             \"{\" +\n-             \"var JSCompiler_inline_result_1;\" +\n+             \"var JSCompiler_inline_result$$1;\" +\n              \"z= {};\" +\n-             \"JSCompiler_inline_result_1 = true;\" +\n+             \"JSCompiler_inline_result$$1 = true;\" +\n             \"}\" +\n-            \"JSCompiler_temp_const_0.gack = JSCompiler_inline_result_1;\" +\n+            \"JSCompiler_temp_const$$0.gack = JSCompiler_inline_result$$1;\" +\n         \"}\",\n         \"foo\", INLINE_BLOCK, true);\n   }\n         \"var z = {};\" +\n         \"function foo(a){z = {};return true;}; \" +\n         \"function x() {\" +\n-            \"var JSCompiler_temp_const_0=z;\" +\n+            \"var JSCompiler_temp_const$$0=z;\" +\n             \"{\" +\n-             \"var JSCompiler_inline_result_1;\" +\n+             \"var JSCompiler_inline_result$$1;\" +\n              \"z= {};\" +\n-             \"JSCompiler_inline_result_1 = true;\" +\n+             \"JSCompiler_inline_result$$1 = true;\" +\n             \"}\" +\n-            \"JSCompiler_temp_const_0.gack = JSCompiler_inline_result_1;\" +\n+            \"JSCompiler_temp_const$$0.gack = JSCompiler_inline_result$$1;\" +\n         \"}\",\n         \"foo\", INLINE_BLOCK, true);\n   }\n         \"var z = {};\" +\n         \"function foo(a){z = {};return true;}; \" +\n         \"function x() {\" +\n-            \"var JSCompiler_temp_const_1=z;\" +\n-            \"var JSCompiler_temp_const_0=bar();\" +\n+            \"var JSCompiler_temp_const$$1=z;\" +\n+            \"var JSCompiler_temp_const$$0=bar();\" +\n             \"{\" +\n-             \"var JSCompiler_inline_result_2;\" +\n+             \"var JSCompiler_inline_result$$2;\" +\n              \"z= {};\" +\n-             \"JSCompiler_inline_result_2 = true;\" +\n+             \"JSCompiler_inline_result$$2 = true;\" +\n             \"}\" +\n-            \"JSCompiler_temp_const_1[JSCompiler_temp_const_0] = \" +\n-                \"JSCompiler_inline_result_2;\" +\n+            \"JSCompiler_temp_const$$1[JSCompiler_temp_const$$0] = \" +\n+                \"JSCompiler_inline_result$$2;\" +\n         \"}\",\n         \"foo\", INLINE_BLOCK, true);\n   }\n         \"var z = {};\" +\n         \"function foo(a){z = {};return true;}; \" +\n         \"function x() {\" +\n-            \"var JSCompiler_temp_const_0=z.y.x;\" +\n+            \"var JSCompiler_temp_const$$0=z.y.x;\" +\n             \"{\" +\n-             \"var JSCompiler_inline_result_1;\" +\n+             \"var JSCompiler_inline_result$$1;\" +\n              \"z= {};\" +\n-             \"JSCompiler_inline_result_1 = true;\" +\n+             \"JSCompiler_inline_result$$1 = true;\" +\n             \"}\" +\n-            \"JSCompiler_temp_const_0.gack = JSCompiler_inline_result_1;\" +\n+            \"JSCompiler_temp_const$$0.gack = JSCompiler_inline_result$$1;\" +\n         \"}\",\n         \"foo\", INLINE_BLOCK, true);\n   }\n         \"function foo(){return _g;}; \" +\n         \"function x() {1 + foo()() }\",\n         \"function foo(){return _g;}; \" +\n-        \"function x() { {var JSCompiler_inline_result_0; \" +\n-        \"JSCompiler_inline_result_0=_g;}\" +\n-        \"1 + JSCompiler_inline_result_0() }\",\n+        \"function x() { {var JSCompiler_inline_result$$0; \" +\n+        \"JSCompiler_inline_result$$0=_g;}\" +\n+        \"1 + JSCompiler_inline_result$$0() }\",\n         \"foo\", INLINE_BLOCK);\n   }\n \n //         \"/** @nosideeffects */ function foo(){return true;}; \" +\n //         \"function x() {1 + _g(foo()) }\",\n //         \"function foo(){return true;}; \" +\n-//         \"function x() { {var JSCompiler_inline_result_0; \" +\n-//         \"JSCompiler_inline_result_0=true;}\" +\n-//         \"1 + _g(JSCompiler_inline_result_0) }\",\n+//         \"function x() { {var JSCompiler_inline_result$$0; \" +\n+//         \"JSCompiler_inline_result$$0=true;}\" +\n+//         \"1 + _g(JSCompiler_inline_result$$0) }\",\n //         \"foo\", INLINE_BLOCK);\n //   }\n \n \n         \"function foo(){return _g;}; \" +\n         \"function x() {\" +\n-        \"  {var JSCompiler_inline_result_0; JSCompiler_inline_result_0=_g;}\" +\n-        \"  var CONSTANT_RESULT = JSCompiler_inline_result_0;\" +\n+        \"  {var JSCompiler_inline_result$$0; JSCompiler_inline_result$$0=_g;}\" +\n+        \"  var CONSTANT_RESULT = JSCompiler_inline_result$$0;\" +\n         \"}\",\n         \"foo\", INLINE_BLOCK);\n   }\n--- a/test/com/google/javascript/jscomp/GatherSideEffectSubexpressionsCallbackTest.java\n+++ b/test/com/google/javascript/jscomp/GatherSideEffectSubexpressionsCallbackTest.java\n     checkKeepSimplifiedHookExpr(hook,\n                                 true,\n                                 true,\n-                                ImmutableList.of(\"foo?(bar=0):(baz=0)\"));\n+                                ImmutableList.of(\"foo?bar=0:baz=0\"));\n   }\n \n   public void testIllegalArgumentIfNotHook() throws Exception {\n--- a/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n+++ b/test/com/google/javascript/jscomp/InlineFunctionsTest.java\n \n   public void testComplexInlineInExpresssions2() {\n     test(\"function f(){a()}c=z=f()\",\n-         \"{var JSCompiler_inline_result_0;a();}\" +\n-         \"c=z=JSCompiler_inline_result_0\");\n+         \"{var JSCompiler_inline_result$$0;a();}\" +\n+         \"c=z=JSCompiler_inline_result$$0\");\n   }\n \n   public void testComplexInlineInExpresssions3() {\n     test(\"function f(){a()}c=f()=z\",\n-        \"{var JSCompiler_inline_result_0;a();}\" +\n-        \"c=JSCompiler_inline_result_0=z\");\n+        \"{var JSCompiler_inline_result$$0;a();}\" +\n+        \"c=JSCompiler_inline_result$$0=z\");\n   }\n \n   public void testComplexInlineInExpresssions4() {\n     test(\"function f(){a()}if(z=f());\",\n-        \"{var JSCompiler_inline_result_0;a();}\" +\n-        \"if(z=JSCompiler_inline_result_0);\");\n+        \"{var JSCompiler_inline_result$$0;a();}\" +\n+        \"if(z=JSCompiler_inline_result$$0);\");\n   }\n \n   public void testComplexInlineInExpresssions5() {\n     test(\"function f(){a()}if(z.y=f());\",\n-         \"var JSCompiler_temp_const_0=z;\" +\n-         \"{var JSCompiler_inline_result_1;a()}\" +\n-         \"if(JSCompiler_temp_const_0.y=JSCompiler_inline_result_1);\");\n+         \"var JSCompiler_temp_const$$0=z;\" +\n+         \"{var JSCompiler_inline_result$$1;a()}\" +\n+         \"if(JSCompiler_temp_const$$0.y=JSCompiler_inline_result$$1);\");\n   }\n \n   public void testComplexNoInline1() {\n   public void testDecomposePlusEquals() {\n     test(\"function f(){a=1;return 1} var x = 1; x += f()\",\n         \"var x = 1;\" +\n-        \"var JSCompiler_temp_const_0 = x;\" +\n-        \"{var JSCompiler_inline_result_1; a=1; JSCompiler_inline_result_1=1}\" +\n-        \"x = JSCompiler_temp_const_0 + JSCompiler_inline_result_1;\");\n+        \"var JSCompiler_temp_const$$0 = x;\" +\n+        \"{var JSCompiler_inline_result$$1; a=1; JSCompiler_inline_result$$1=1}\" +\n+        \"x = JSCompiler_temp_const$$0 + JSCompiler_inline_result$$1;\");\n   }\n \n   public void testDecomposeFunctionExpressionInCall() {\n            \"}()\\n\" +\n         \");\",\n         \"{\" +\n-        \"var JSCompiler_inline_result_0;\" +\n+        \"var JSCompiler_inline_result$$0;\" +\n         \"var ret$$inline_2={};\\n\" +\n         \"ret$$inline_2[ONE]='a';\\n\" +\n         \"ret$$inline_2[TWO]='b';\\n\" +\n-        \"JSCompiler_inline_result_0 = ret$$inline_2;\\n\" +\n+        \"JSCompiler_inline_result$$0 = ret$$inline_2;\\n\" +\n         \"}\" +\n         \"{\" +\n-        \"descriptions_=JSCompiler_inline_result_0;\" +\n+        \"descriptions_=JSCompiler_inline_result$$0;\" +\n         \"}\"\n         );\n   }\n--- a/test/com/google/javascript/jscomp/MakeDeclaredNamesUniqueTest.java\n+++ b/test/com/google/javascript/jscomp/MakeDeclaredNamesUniqueTest.java\n     invert = true;\n     test(\n         \"var a;function foo(){var a$$inline_1; a = 1}\",\n-        \"var a;function foo(){var a$$inline_1; a = 1}\");\n+        \"var a;function foo(){var a$$0; a = 1}\");\n     test(\n         \"var a;function foo(){var a$$inline_1;}\",\n         \"var a;function foo(){var a;}\");\n \n     invert = true;\n \n-    testSameInFunction(\n-        \"var e; try { } catch(e$$1) {e$$1;}; try { } catch(e$$2) {e$$2;}\");\n-    testSameInFunction(\n-        \"var e; try { } catch(e$$1) {e$$1; try { } catch(e$$2) {e$$2;} };\");\n-    testSameInFunction(\n-        \"try { } catch(e) {e;}; try { } catch(e$$1) {e$$1;};var e$$2;\");\n-    testSameInFunction(\n-        \"try { } catch(e) {e; try { } catch(e$$1) {e$$1;} };var e$$2\");\n+    testInFunction(\n+        \"var e; try { } catch(e$$0) {e$$0;}; try { } catch(e$$1) {e$$1;}\",\n+        \"var e; try { } catch(e$$2) {e$$2;}; try { } catch(e$$0) {e$$0;}\");\n+    testInFunction(\n+        \"var e; try { } catch(e$$1) {e$$1; try { } catch(e$$2) {e$$2;} };\",\n+        \"var e; try { } catch(e$$0) {e$$0; try { } catch(e$$1) {e$$1;} };\");\n+    testInFunction(\n+        \"try { } catch(e) {e;}; try { } catch(e$$1) {e$$1;};var e$$2;\",\n+        \"try { } catch(e) {e;}; try { } catch(e$$0) {e$$0;};var e$$1;\");\n+    testInFunction(\n+        \"try { } catch(e) {e; try { } catch(e$$1) {e$$1;} };var e$$2\",\n+        \"try { } catch(e) {e; try { } catch(e$$0) {e$$0;} };var e$$1\");\n   }\n \n   public void testArguments() {\n     // Set the test type\n     this.useDefaultRenamer = true;\n \n-    invert = true;\n     // Don't distinguish between \"arguments\", it can't be made unique.\n     testSameWithInversion(\n         \"function foo(){var arguments;function bar(){var arguments;}}\");\n+\n+    invert = true;\n+    \n     // Don't introduce new references to arguments, it is special.\n-    testSameWithInversion(\n-        \"function foo(){var arguments$$1;}\");\n+    test(\n+        \"function foo(){var arguments$$1;}\",\n+        \"function foo(){var arguments$$0;}\");\n   }\n \n   public void testMakeLocalNamesUniqueWithoutContext() {\n   public void testOnlyInversion() {\n     invert = true;\n     test(\"function f(a, a$$1) {}\",\n-         \"function f(a, a$$1) {}\");\n+         \"function f(a, a$$0) {}\");\n     test(\"function f(a$$1, b$$2) {}\",\n          \"function f(a, b) {}\");\n     test(\"function f(a$$1, a$$2) {}\",\n-         \"function f(a, a$$2) {}\");\n+         \"function f(a, a$$0) {}\");\n     testSame(\"try { } catch(e) {e;}; try { } catch(e$$1) {e$$1;}\");\n     testSame(\"try { } catch(e) {e; try { } catch(e$$1) {e$$1;} }; \");\n     testSame(\"var a$$1;\");\n \n   public void testOnlyInversion2() {\n     invert = true;\n-    testSame(\"function () {\" +\n-        \"try { } catch(e) {e;}; try { } catch(e$$1) {e$$1;}}\");\n+    test(\"function () {try { } catch(e) {e;}; try { } catch(e$$0) {e$$0;}}\",\n+        \"function () {try { } catch(e) {e;}; try { } catch(e$$1) {e$$1;}}\");\n   }\n \n   public void testOnlyInversion3() {\n         \"  }\" +\n         \"}\",\n         \"function x1() {\" +\n-        \"  var a$$1;\" +\n+        \"  var a$$0;\" +\n         \"  function x2() {\" +\n         \"    var a;\" +\n         \"  }\" +\n     invert = true;\n     test(\n         \"function x1() {\" +\n-        \"  var a$$1;\" +\n+        \"  var a$$0;\" +\n         \"  function x2() {\" +\n-        \"    var a;a$$1++\" +\n+        \"    var a;a$$0++\" +\n         \"  }\" +\n         \"}\",\n         \"function x1() {\" +\n--- a/test/com/google/javascript/jscomp/NodeUtilTest.java\n+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java\n import com.google.common.collect.Sets;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.TernaryValue;\n \n import junit.framework.TestCase;\n \n   }\n \n   public void testGetBooleanValue() {\n-    assertTrue(NodeUtil.getBooleanValue(getNode(\"true\")));\n-    assertTrue(NodeUtil.getBooleanValue(getNode(\"10\")));\n-    assertTrue(NodeUtil.getBooleanValue(getNode(\"'0'\")));\n-    assertTrue(NodeUtil.getBooleanValue(getNode(\"/a/\")));\n-    assertTrue(NodeUtil.getBooleanValue(getNode(\"{}\")));\n-    assertTrue(NodeUtil.getBooleanValue(getNode(\"[]\")));\n-    assertFalse(NodeUtil.getBooleanValue(getNode(\"false\")));\n-    assertFalse(NodeUtil.getBooleanValue(getNode(\"null\")));\n-    assertFalse(NodeUtil.getBooleanValue(getNode(\"0\")));\n-    assertFalse(NodeUtil.getBooleanValue(getNode(\"''\")));\n-    assertFalse(NodeUtil.getBooleanValue(getNode(\"undefined\")));\n-    assertFalse(NodeUtil.getBooleanValue(getNode(\"void 0\")));\n+    assertBooleanTrue(\"true\");\n+    assertBooleanTrue(\"10\");\n+    assertBooleanTrue(\"'0'\");\n+    assertBooleanTrue(\"/a/\");\n+    assertBooleanTrue(\"{}\");\n+    assertBooleanTrue(\"[]\");\n+    assertBooleanFalse(\"false\");\n+    assertBooleanFalse(\"null\");\n+    assertBooleanFalse(\"0\");\n+    assertBooleanFalse(\"''\");\n+    assertBooleanFalse(\"undefined\");\n+    assertBooleanFalse(\"void 0\");\n+    assertBooleanUnknown(\"b\");\n+    assertBooleanUnknown(\"-'0.0'\");\n+  }\n+\n+  private void assertBooleanTrue(String val) {\n+    assertEquals(TernaryValue.TRUE, NodeUtil.getBooleanValue(getNode(val)));\n+  }\n+\n+  private void assertBooleanFalse(String val) {\n+    assertEquals(TernaryValue.FALSE, NodeUtil.getBooleanValue(getNode(val)));\n+  }\n+\n+  private void assertBooleanUnknown(String val) {\n+    assertEquals(TernaryValue.UNKNOWN, NodeUtil.getBooleanValue(getNode(val)));\n   }\n \n   public void testGetStringValue() {\n--- a/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java\n+++ b/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java\n  */\n public class PureFunctionIdentifierTest extends CompilerTestCase {\n   List<String> noSideEffectCalls = Lists.newArrayList();\n-  \n+\n   boolean regExpHaveSideEffects = true;\n \n   private static String kExterns =\n         \"REGEXP STRING exec\", \"k\"));\n   }\n \n+  public void testAnonymousFunction1() throws Exception {\n+    String source = \"(function (){})();\";\n+\n+    checkMarkedCalls(source, ImmutableList.<String>of(\n+        \"FUNCTION\"));\n+  }\n+\n+  public void testAnonymousFunction2() throws Exception {\n+    String source = \"(Error || function (){})();\";\n+\n+    checkMarkedCalls(source, ImmutableList.<String>of(\n+        \"(Error || FUNCTION)\"));\n+  }\n+  \n+  public void testAnonymousFunction3() throws Exception {\n+    String source = \"var a = (Error || function (){})();\";\n+\n+    checkMarkedCalls(source, ImmutableList.<String>of(\n+        \"(Error || FUNCTION)\"));\n+  }  \n+\n+  // Indirect complex function definitions aren't yet supported.\n+  public void testAnonymousFunction4() throws Exception {\n+    String source = \"var a = (Error || function (){});\" +\n+                    \"a();\";\n+\n+    // This should be \"(Error || FUNCTION)\" but isn't.\n+    checkMarkedCalls(source, ImmutableList.<String>of());\n+  }  \n+  \n   public void testInvalidAnnotation1() throws Exception {\n     test(\"/** @nosideeffects */ function foo() {}\",\n          null, INVALID_NO_SIDE_EFFECT_ANNOTATION);\n       } else {\n         String result = node.getQualifiedName();\n         if (result == null) {\n-          result = node.getFirstChild().toString(false, false, false);\n-          result += \" \" + node.getLastChild().toString(false, false, false);\n+          if (node.getType() == Token.FUNCTION) {\n+            result = node.toString(false, false, false).trim();\n+          } else {\n+            result = node.getFirstChild().toString(false, false, false);\n+            result += \" \" + node.getLastChild().toString(false, false, false);\n+          }\n         }\n         return result;\n       }\n--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n \n   public void testParseJavaDispatch3() throws Exception {\n     assertNull(parseFileOverview(\"@javadispatch*/\"));\n+  }\n+\n+  public void testParseNoCompile1() throws Exception {\n+    assertTrue(parseFileOverview(\"@nocompile*/\").isNoCompile());\n+  }\n+\n+  public void testParseNoCompile2() throws Exception {\n+    parseFileOverview(\"@nocompile\\n@nocompile*/\", \"extra @nocompile tag\");\n   }\n \n   public void testBugAnnotation() throws Exception {\n       \"* @mods \\n\" +\n       \"* @name \\n\" +\n       \"* @namespace \\n\" +\n+      \"* @nocompile \\n\" +\n       \"* @property \\n\" +\n       \"* @requires \\n\" +\n       \"* @since \\n\" +", "timestamp": 1276716808, "metainfo": ""}