{"sha": "10363af9bd27d8c7ec9e4ef09eb46e96626feceb", "log": "Make dead-code elimination go to a fixpt.  R=acleung DELTA=91 (32 added, 18 deleted, 41 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=6136   ", "commit": "\n--- a/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n+++ b/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;\n import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n-import com.google.javascript.jscomp.graph.GraphReachability;\n import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\n import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\n+import com.google.javascript.jscomp.graph.GraphReachability;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n  *    being initialized.\n  *\n  */\n+\n+// TODO(user): Besides dead code after returns, this pass removes useless live\n+// code such as breaks/continues/returns and stms w/out side effects.\n+// These things don't require reachability info, consider making them their own\n+// pass or putting them in some other, more related pass.\n+\n class UnreachableCodeElimination extends AbstractPostOrderCallback\n     implements CompilerPass, ScopedCallback  {\n   private static final Logger logger =\n \n   private final AbstractCompiler compiler;\n   private final boolean removeNoOpStatements;\n+  private boolean codeChanged;\n \n   UnreachableCodeElimination(AbstractCompiler compiler,\n       boolean removeNoOpStatements) {\n   @Override\n   public void exitScope(NodeTraversal t) {\n     Scope scope = t.getScope();\n+    Node root = scope.getRootNode();\n \n     // Computes the control flow graph.\n     ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, false);\n-    cfa.process(null, scope.getRootNode());\n+    cfa.process(null, root);\n     ControlFlowGraph<Node> cfg = cfa.getCfg();\n \n     new GraphReachability<Node, ControlFlowGraph.Branch>(cfg)\n         .compute(cfg.getEntry().getValue());\n \n-    Node root = scope.getRootNode();\n     if (scope.isLocal()) {\n       root = root.getLastChild();\n     }\n-    NodeTraversal.traverse(\n-        compiler, root, new EliminationPass(cfg));\n+\n+    do {\n+      codeChanged = false;\n+      NodeTraversal.traverse(compiler, root, new EliminationPass(cfg));\n+    } while (codeChanged);\n   }\n \n   @Override\n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (parent == null) {\n-        return;\n-      }\n-      if (n.isFunction() || n.isScript()) {\n-        return;\n-      }\n-\n+      if (parent == null || n.isFunction() || n.isScript()) {\n+        return;\n+      }\n       DiGraphNode<Node, Branch> gNode = cfg.getDirectedGraphNode(n);\n       if (gNode == null) { // Not in CFG.\n         return;\n         removeDeadExprStatementSafely(n);\n         return;\n       }\n-\n       tryRemoveUnconditionalBranching(n);\n     }\n \n      * Tries to remove n if it is an unconditional branch node (break, continue,\n      * or return) and the target of n is the same as the the follow of n.\n      * That is, if removing n preserves the control flow. Also if n targets\n-     * another unconditional branch, this function will recursively try to remove\n-     * the target branch as well. The reason why we want to cascade this removal\n-     * is because we only run this pass once. If we have code such as\n+     * another unconditional branch, this function will recursively try to\n+     * remove the target branch as well. The reason why we want to cascade this\n+     * removal is because we only run this pass once. If we have code such as\n      *\n      * break -> break -> break\n      *\n-     * where all 3 breaks are useless, then the order of removal matters. When we\n-     * first look at the first break, we see that it branches to the 2nd break.\n-     * However, if we remove the last break, the 2nd break becomes useless and\n-     * finally the first break becomes useless as well.\n+     * where all 3 breaks are useless, then the order of removal matters. When\n+     * we first look at the first break, we see that it branches to the 2nd\n+     * break. However, if we remove the last break, the 2nd break becomes\n+     * useless and finally the first break becomes useless as well.\n      *\n      * @return The target of this jump. If the target is also useless jump,\n      *     the target of that useless jump recursively.\n      */\n     @SuppressWarnings(\"fallthrough\")\n-    private Node tryRemoveUnconditionalBranching(Node n) {\n+    private void tryRemoveUnconditionalBranching(Node n) {\n       /*\n        * For each unconditional branching control flow node, check to see\n        * if the ControlFlowAnalysis.computeFollowNode of that node is same as\n \n       // If n is null the target is the end of the function, nothing to do.\n       if (n == null) {\n-         return n;\n+         return;\n       }\n \n       DiGraphNode<Node, Branch> gNode = cfg.getDirectedGraphNode(n);\n \n       if (gNode == null) {\n-        return n;\n+        return;\n       }\n \n       switch (n.getType()) {\n           }\n         case Token.BREAK:\n         case Token.CONTINUE:\n-\n           // We are looking for a control flow changing statement that always\n           // branches to the same node. If after removing it control still\n           // branches to the same node, it is safe to remove.\n-          List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n+          List<DiGraphEdge<Node, Branch>> outEdges = gNode.getOutEdges();\n           if (outEdges.size() == 1 &&\n-              // If there is a next node, there is no chance this jump is useless.\n+              // If there is a next node, this jump is not useless.\n               (n.getNext() == null || n.getNext().isFunction())) {\n \n-            Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);\n+            Preconditions.checkState(\n+                outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n             if (nextCfgNode == fallThrough) {\n-              removeDeadExprStatementSafely(n);\n-              return fallThrough;\n+              removeNode(n);\n             }\n           }\n       }\n-      return n;\n     }\n \n     private Node computeFollowing(Node n) {\n \n     private void removeDeadExprStatementSafely(Node n) {\n       Node parent = n.getParent();\n-      if (n.isEmpty() ||\n-          (n.isBlock() && !n.hasChildren())) {\n+      if (n.isEmpty() || (n.isBlock() && !n.hasChildren())) {\n         // Not always trivial to remove, let FoldConstants work its magic later.\n         return;\n       }\n       }\n \n       switch (n.getType()) {\n-        // Removing an unreachable DO node is messy because it means we still have\n-        // to execute one iteration. If the DO's body has breaks in the middle, it\n-        // can get even more tricky and code size might actually increase.\n+        // Removing an unreachable DO node is messy b/c it means we still have\n+        // to execute one iteration. If the DO's body has breaks in the middle,\n+        // it can get even more tricky and code size might actually increase.\n         case Token.DO:\n           return;\n \n         case Token.BLOCK:\n           // BLOCKs are used in several ways including wrapping CATCH\n           // blocks in TRYs\n-          if (parent.isTry()) {\n-            if (NodeUtil.isTryCatchNodeContainer(n)) {\n-              return;\n-            }\n+          if (parent.isTry() && NodeUtil.isTryCatchNodeContainer(n)) {\n+            return;\n           }\n           break;\n \n           break;\n       }\n \n-\n       if (n.isVar() && !n.getFirstChild().hasChildren()) {\n-        // Very Edge case, Consider this:\n+        // Very unlikely case, Consider this:\n         // File 1: {throw 1}\n         // File 2: {var x}\n         // The node var x is unreachable in the global scope.\n         return;\n       }\n \n+      removeNode(n);\n+    }\n+\n+    private void removeNode(Node n) {\n+      codeChanged = true;\n       NodeUtil.redeclareVarsInsideBranch(n);\n       compiler.reportCodeChange();\n       if (logger.isLoggable(Level.FINE)) {\n         logger.fine(\"Removing \" + n.toString());\n       }\n-\n       NodeUtil.removeChild(n.getParent(), n);\n     }\n   }\n--- a/test/com/google/javascript/jscomp/UnreachableCodeEliminationTest.java\n+++ b/test/com/google/javascript/jscomp/UnreachableCodeEliminationTest.java\n     test(\"try {var x = 1} catch (e) {e()} finally {x()}\",\n         \" try {var x = 1}                 finally {x()}\");\n     test(\"try {var x = 1} catch (e) {e()} finally {}\",\n-        \"try {var x = 1} finally {}\");\n+        \" try {var x = 1} finally {}\");\n     testSame(\"try {var x = 1} finally {x()}\");\n     testSame(\"try {var x = 1} finally {}\");\n     test(\"function f() {return; try{var x = 1}catch(e){} }\",\n              \" case 'a': return; default: alert(1)}}\");\n   }\n \n-  public void testUnlessUnconditionalContinue() {\n+  public void testUselessUnconditionalContinue() {\n     test(\"for(;1;) {continue}\", \" for(;1;) {}\");\n     test(\"for(;0;) {continue}\", \" for(;0;) {}\");\n \n     test(\"do { continue } while(1);\", \"do {  } while(1);\");\n   }\n \n-  public void testUnlessUnconditonalBreak() {\n+  public void testUselessUnconditonalBreak() {\n     test(\"switch (a) { case 'a': break }\", \"switch (a) { case 'a': }\");\n     test(\"switch (a) { case 'a': break; case foo(): }\",\n          \"switch (a) { case 'a':        case foo(): }\");\n     testSame(\"for(;1;) { break }\");\n   }\n \n-  public void testCascadedRemovalOfUnlessUnconditonalJumps() {\n+  // These tests all require the analysis to go to a fixpoint in order to pass\n+  public void testIteratedRemoval() {\n     test(\"switch (a) { case 'a': break; case 'b': break; case 'c': break }\",\n-         \"switch (a) { case 'a': break; case 'b': case 'c': }\");\n-    // Only one break removed per pass.\n-    test(\"switch (a) { case 'a': break; case 'b': case 'c': }\",\n-         \"switch (a) { case 'a': case 'b': case 'c': }\");\n+        \" switch (a) { case 'a': case 'b': case 'c': }\");\n \n     test(\"function foo() {\" +\n-      \"  switch (a) { case 'a':return; case 'b':return; case 'c':return }}\",\n-      \"function foo() { switch (a) { case 'a':return; case 'b': case 'c': }}\");\n-    test(\"function foo() {\" +\n-      \"  switch (a) { case 'a':return; case 'b': case 'c': }}\",\n-      \"function foo() { switch (a) { case 'a': case 'b': case 'c': }}\");\n-\n-    testSame(\"function foo() {\" +\n-             \"switch (a) { case 'a':return 2; case 'b':return 1}}\");\n+        \"  switch (a) { case 'a':return; case 'b':return; case 'c':return }}\",\n+        \" function foo() { switch (a) { case 'a': case 'b': case 'c': }}\");\n+\n+    test(\"for (;;) {\\n\" +\n+        \"   switch (a) {\\n\" +\n+        \"   case 'a': continue;\\n\" +\n+        \"   case 'b': continue;\\n\" +\n+        \"   case 'c': continue;\\n\" +\n+        \"   }\\n\" +\n+        \" }\",\n+        \" for (;;) { switch (a) { case 'a': case 'b': case 'c': } }\");\n+\n+    test(\"function foo() { if (x) { return; } if (x) { return; } x; }\",\n+        \" function foo() {}\");\n+\n+    test(\"var x; \\n\" +\n+        \" out: { \\n\" +\n+        \"   try { break out; } catch (e) { break out; } \\n\" +\n+        \"   x = undefined; \\n\" +\n+        \" }\",\n+        \" var x; out: {}\");\n   }\n \n   public void testIssue311() {", "timestamp": 1358206813, "metainfo": ""}