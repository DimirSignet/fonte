{"sha": "0f70487944b9b934abbbc2d32c323398da2cdbe8", "log": "Make the performance tracker a little more useful.  R=acleung DELTA=252  (194 added, 6 deleted, 52 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4311   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n import com.google.common.collect.Sets;\n import com.google.common.io.Files;\n import com.google.javascript.jscomp.CompilerOptions.TweakProcessing;\n+import com.google.javascript.jscomp.PerformanceTracker.Stats;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.TokenStream;\n import com.google.protobuf.CodedOutputStream;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+import java.util.Map.Entry;\n import java.util.logging.Level;\n \n /**\n         // Output the source map if requested.\n         outputSourceMap(options, config.jsOutputFile);\n       } else {\n-        parsedModuleWrappers = parseModuleWrappers(config.moduleWrapper, modules);\n+        parsedModuleWrappers = parseModuleWrappers(\n+            config.moduleWrapper, modules);\n         maybeCreateDirsForPath(config.moduleOutputPathPrefix);\n \n         // If the source map path is in fact a pattern for each\n       // Output the manifest and bundle files if requested.\n       outputManifest();\n       outputBundle();\n+\n+      if (options.tracer.isOn()) {\n+        outputTracerReport();\n+      }\n     }\n \n     // return 0 if no errors, the error count otherwise\n     return Math.min(result.errors.length, 0x7f);\n+  }\n+\n+  private void outputTracerReport() {\n+    OutputStreamWriter output = new OutputStreamWriter(this.err);\n+    try {\n+      int runtime = 0;\n+      int runs = 0;\n+      int changes = 0;\n+      int diff = 0;\n+      int gzDiff = 0;\n+\n+      // header\n+      output.write(\"Summary:\\n\");\n+      output.write(\"pass,runtime,runs,chancingRuns,reduction,gzReduction\\n\");\n+      Map<String, Stats> runtimeMap = compiler.tracker.getStats();\n+      for (Entry<String, Stats> entry : runtimeMap.entrySet()) {\n+        String key = entry.getKey();\n+        Stats stats = entry.getValue();\n+\n+        output.write(key);\n+        output.write(\",\");\n+        output.write(String.valueOf(stats.runtime));\n+        runtime += stats.runtime;\n+        output.write(\",\");\n+        output.write(String.valueOf(stats.runs));\n+        runs += stats.runs;\n+        output.write(\",\");\n+        output.write(String.valueOf(stats.changes));\n+        changes += stats.changes;\n+        output.write(\",\");\n+        output.write(String.valueOf(stats.diff));\n+        diff += stats.diff;\n+        output.write(\",\");\n+        output.write(String.valueOf(stats.gzDiff));\n+        gzDiff += stats.gzDiff;\n+        output.write(\"\\n\");\n+      }\n+      output.write(\"TOTAL\");\n+      output.write(\",\");\n+      output.write(String.valueOf(runtime));\n+      output.write(\",\");\n+      output.write(String.valueOf(runs));\n+      output.write(\",\");\n+      output.write(String.valueOf(changes));\n+      output.write(\",\");\n+      output.write(String.valueOf(diff));\n+      output.write(\",\");\n+      output.write(String.valueOf(gzDiff));\n+      output.write(\"\\n\");\n+      output.write(\"\\n\");\n+\n+      output.write(\"Log:\\n\");\n+      output.write(\n+          \"pass,runtime,runs,chancingRuns,reduction,gzReduction,size,gzSize\\n\");\n+      List<Stats> runtimeLog = compiler.tracker.getLog();\n+      for (Stats stats : runtimeLog) {\n+        output.write(stats.pass);\n+        output.write(\",\");\n+        output.write(String.valueOf(stats.runtime));\n+        output.write(\",\");\n+        output.write(String.valueOf(stats.runs));\n+        output.write(\",\");\n+        output.write(String.valueOf(stats.changes));\n+        output.write(\",\");\n+        output.write(String.valueOf(stats.diff));\n+        output.write(\",\");\n+        output.write(String.valueOf(stats.gzDiff));\n+        output.write(\",\");\n+        output.write(String.valueOf(stats.size));\n+        output.write(\",\");\n+        output.write(String.valueOf(stats.gzSize));\n+        output.write(\"\\n\");\n+      }\n+      output.write(\"\\n\");\n+      output.close();\n+    } catch (IOException e) {\n+      e.printStackTrace();\n+    }\n   }\n \n   /**\n    * Converts a file name into a Writer taking in account the output charset.\n    * Returns null if the file name is null.\n    */\n-  private Writer fileNameToLegacyOutputWriter(String fileName) throws IOException {\n+  private Writer fileNameToLegacyOutputWriter(String fileName)\n+      throws IOException {\n     if (fileName == null) {\n       return null;\n     }\n     /**\n      * Set whether to transform AMD to Common JS modules.\n      */\n-    CommandLineConfig setTransformAMDToCJSModules(boolean transformAMDToCJSModules) {\n+    CommandLineConfig setTransformAMDToCJSModules(\n+        boolean transformAMDToCJSModules) {\n       this.transformAMDToCJSModules = transformAMDToCJSModules;\n       return this;\n     }\n     /**\n      * Sets whether to process Common JS modules.\n      */\n-    CommandLineConfig setProcessCommonJSModules(boolean processCommonJSModules) {\n+    CommandLineConfig setProcessCommonJSModules(\n+        boolean processCommonJSModules) {\n       this.processCommonJSModules = processCommonJSModules;\n       return this;\n     }\n     /**\n      * Sets the Common JS module path prefix.\n      */\n-    CommandLineConfig setCommonJSModulePathPrefix(String commonJSModulePathPrefix) {\n+    CommandLineConfig setCommonJSModulePathPrefix(\n+        String commonJSModulePathPrefix) {\n       this.commonJSModulePathPrefix = commonJSModulePathPrefix;\n       return this;\n     }\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n import com.google.common.collect.Maps;\n import com.google.javascript.jscomp.CompilerOptions.DevMode;\n import com.google.javascript.jscomp.CompilerOptions.LanguageMode;\n-import com.google.javascript.jscomp.CompilerOptions.TracerMode;\n import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.jscomp.deps.SortedDependencies.CircularDependencyException;\n     externAndJsRoot.setIsSyntheticBlock(true);\n \n     if (options.tracer.isOn()) {\n-      tracker = new PerformanceTracker(jsRoot,\n-          options.tracer == TracerMode.ALL);\n+      tracker = new PerformanceTracker(jsRoot, options.tracer);\n       addChangeHandler(tracker.getCodeChangeHandler());\n     }\n \n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n   boolean collapseObjectLiterals;\n \n   public void setCollapseObjectLiterals(boolean enabled) {\n-    collapseObjectLiterals = true;\n+    collapseObjectLiterals = enabled;\n   }\n \n   /** Flattens multi-level property names on extern types (e.g. String$f = x) */\n   }\n \n   TracerMode tracer;\n+\n+  public TracerMode getTracerMode() {\n+    return tracer;\n+  }\n \n   public void setTracerMode(TracerMode mode) {\n     tracer = mode;\n \n   public static enum TracerMode {\n     ALL,  // Collect all timing and size metrics.\n-    FAST, // Collect all timing and size metrics, except gzipped size.\n+    RAW_SIZE, // Collect all timing and size metrics, except gzipped size.\n+    TIMING_ONLY, // Collect timing metrics only.\n     OFF;  // Collect no timing and size metrics.\n \n     boolean isOn() {\n--- a/src/com/google/javascript/jscomp/PerformanceTracker.java\n+++ b/src/com/google/javascript/jscomp/PerformanceTracker.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.javascript.jscomp.CodeChangeHandler.RecentChange;\n+import com.google.javascript.jscomp.CompilerOptions.TracerMode;\n import com.google.javascript.rhino.Node;\n \n import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n import java.util.ArrayDeque;\n import java.util.Deque;\n+import java.util.List;\n import java.util.Map;\n import java.util.zip.GZIPOutputStream;\n \n public class PerformanceTracker {\n \n   private final Node jsRoot;\n+  private final boolean trackSize;\n   private final boolean trackGzippedSize;\n \n   // Keeps track of AST changes and computes code size estimation\n \n   private Deque<String> currentRunningPass = new ArrayDeque<String>();\n \n-  /** Maps pass name to total time spend. */\n-  private final Map<String, Long> runtimeRecord = Maps.newHashMap();\n-\n-  /** Maps pass name to total size reduction. */\n-  private final Map<String, Integer> codeSizeRecord = Maps.newHashMap();\n-\n-  /** Maps pass name to total size reduction. */\n-  private final Map<String, Integer> zippedCodeSizeRecord = Maps.newHashMap();\n-\n-  PerformanceTracker(Node jsRoot, boolean trackGzippedSize) {\n+  /** Summary stats by pass name. */\n+  private final Map<String, Stats> summary = Maps.newHashMap();\n+\n+  /** Stats for each run of a compiler pass. */\n+  private final List<Stats> log = Lists.newArrayList();\n+\n+\n+  public static class Stats {\n+    public Stats(String pass) {\n+      this.pass = pass;\n+    }\n+    public final String pass;\n+    public long runtime = 0;\n+    public int runs = 0;\n+    public int changes = 0;\n+    public int diff = 0;\n+    public int gzDiff = 0;\n+    public int size = 0;\n+    public int gzSize = 0;\n+  }\n+\n+  PerformanceTracker(Node jsRoot, TracerMode mode) {\n     this.jsRoot = jsRoot;\n-    this.trackGzippedSize = trackGzippedSize;\n+    switch (mode) {\n+      case TIMING_ONLY:\n+        this.trackSize = false;\n+        this.trackGzippedSize = false;\n+        break;\n+\n+      case RAW_SIZE:\n+        this.trackSize = true;\n+        this.trackGzippedSize = false;\n+        break;\n+\n+      case ALL:\n+        this.trackSize = true;\n+        this.trackGzippedSize = true;\n+        break;\n+\n+      case OFF:\n+      default:\n+        throw new UnsupportedOperationException();\n+    }\n   }\n \n   CodeChangeHandler getCodeChangeHandler() {\n     if (!passName.equals(currentPassName)) {\n       throw new RuntimeException(passName + \" is not running.\");\n     }\n-    Long total = runtimeRecord.get(passName);\n-    if (total == null) {\n-      total = 0L;\n-    }\n-    total = total.longValue() + result;\n-    runtimeRecord.put(passName, total);\n-\n+\n+    CodeSizeEstimatePrinter printer = null;\n+    if (codeChange.hasCodeChanged() && (trackSize || trackGzippedSize)) {\n+      printer = estimateCodeSize(jsRoot);\n+    }\n+\n+    Stats logStats = new Stats(currentPassName);\n+    log.add(logStats);\n+    updateStats(logStats, result, printer);\n+\n+    Stats summaryStats = summary.get(passName);\n+    if (summaryStats == null) {\n+      summaryStats = new Stats(passName);\n+      summary.put(passName, summaryStats);\n+    }\n+    updateStats(summaryStats, result, printer);\n+\n+    if (printer != null) {\n+      if (trackSize) {\n+        curCodeSizeEstimate = printer.calcSize();\n+      }\n+      if (trackGzippedSize) {\n+        curZippedCodeSizeEstimate = printer.calcZippedSize();\n+      }\n+    }\n+  }\n+\n+  private void updateStats(Stats stats,\n+      long result, CodeSizeEstimatePrinter printer) {\n+    stats.runtime += result;\n+    stats.runs += 1;\n     if (codeChange.hasCodeChanged()) {\n-      CodeSizeEstimatePrinter printer = estimateCodeSize(jsRoot);\n-      curCodeSizeEstimate = recordSizeChange(curCodeSizeEstimate,\n-          printer.calcSize(), passName, codeSizeRecord);\n-      curZippedCodeSizeEstimate = recordSizeChange(curZippedCodeSizeEstimate,\n-          printer.calcZippedSize(), passName, zippedCodeSizeRecord);\n+      stats.changes += 1;\n+    }\n+\n+    if (printer != null) {\n+      recordSizeChange(\n+          curCodeSizeEstimate, printer.calcSize(), stats);\n+      recordGzSizeChange(\n+          curZippedCodeSizeEstimate, printer.calcZippedSize(), stats);\n     }\n   }\n \n   /**\n    * Record the size change in the given record for that given pass.\n-   *\n-   * @return The new estimated size.\n-   */\n-  private static int recordSizeChange(int oldSize, int newSize, String passName,\n-      Map<String, Integer> record) {\n+   */\n+  private static void recordSizeChange(int oldSize, int newSize, Stats record) {\n     if (oldSize != -1) {\n       int delta = oldSize - newSize;\n-      Integer reduction = record.get(passName);\n       if (delta > 0) {\n-        if (reduction == null) {\n-          reduction = delta;\n-        } else {\n-          reduction = reduction + delta;\n-        }\n-        record.put(passName, reduction);\n-      }\n-    }\n-    return newSize;\n-  }\n-\n+        record.diff += delta;\n+      }\n+    }\n+    if (newSize != -1) {\n+      record.size = newSize;\n+    }\n+  }\n+\n+  /**\n+   * Record the gzip size change in the given record for that given pass.\n+   */\n+  private static void recordGzSizeChange(\n+      int oldSize, int newSize, Stats record) {\n+    if (oldSize != -1) {\n+      int delta = oldSize - newSize;\n+      if (delta > 0) {\n+        record.gzDiff += delta;\n+      }\n+    }\n+    if (newSize != -1) {\n+      record.gzSize = newSize;\n+    }\n+  }\n \n   public ImmutableMap<String, Long> getRuntimeRecord() {\n-    return ImmutableMap.copyOf(runtimeRecord);\n+    ImmutableMap.Builder<String, Long> builder =\n+        new ImmutableMap.Builder<String, Long>();\n+    for (Map.Entry<String, Stats> entry : summary.entrySet()) {\n+      builder.put(entry.getKey(), entry.getValue().runtime);\n+    }\n+    return builder.build();\n+  }\n+\n+  public ImmutableMap<String, Stats> getStats() {\n+    return ImmutableMap.copyOf(summary);\n+  }\n+\n+  public ImmutableList<Stats> getLog() {\n+    return ImmutableList.copyOf(log);\n   }\n \n   public ImmutableMap<String, Integer> getCodeSizeRecord() {\n-    return ImmutableMap.copyOf(codeSizeRecord);\n+    ImmutableMap.Builder<String, Integer> builder =\n+      new ImmutableMap.Builder<String, Integer>();\n+    for (Map.Entry<String, Stats> entry : summary.entrySet()) {\n+      builder.put(entry.getKey(), entry.getValue().diff);\n+    }\n+    return builder.build();\n   }\n \n   public ImmutableMap<String, Integer> getZippedCodeSizeRecord() {\n-    return ImmutableMap.copyOf(zippedCodeSizeRecord);\n+    ImmutableMap.Builder<String, Integer> builder =\n+      new ImmutableMap.Builder<String, Integer>();\n+    for (Map.Entry<String, Stats> entry : summary.entrySet()) {\n+      builder.put(entry.getKey(), entry.getValue().gzDiff);\n+    }\n+    return builder.build();\n   }\n \n   private final CodeSizeEstimatePrinter estimateCodeSize(Node root) {\n--- a/test/com/google/javascript/jscomp/PhaseOptimizerTest.java\n+++ b/test/com/google/javascript/jscomp/PhaseOptimizerTest.java\n package com.google.javascript.jscomp;\n \n import com.google.common.collect.Lists;\n+import com.google.javascript.jscomp.CompilerOptions.TracerMode;\n import com.google.javascript.jscomp.PhaseOptimizer.Loop;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n     passesRun.clear();\n     compiler = new Compiler();\n     compiler.initCompilerOptionsIfTesting();\n-    tracker = new PerformanceTracker(new Node(Token.BLOCK), false);\n+    tracker = new PerformanceTracker(\n+        new Node(Token.BLOCK), TracerMode.TIMING_ONLY);\n     optimizer = new PhaseOptimizer(compiler, tracker, null);\n   }\n ", "timestamp": 1330644224, "metainfo": ""}