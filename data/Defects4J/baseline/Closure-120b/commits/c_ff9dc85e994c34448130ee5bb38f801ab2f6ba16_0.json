{"sha": "ff9dc85e994c34448130ee5bb38f801ab2f6ba16", "log": "Protect appearently side-effect free code from removal. Fixes issue 64 Fixes issue 398  R=nicksantos DELTA=256  (218 added, 11 deleted, 27 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4091   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCompiler.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompiler.java\n    */\n   abstract GlobalVarReferenceMap getGlobalVarReferences();\n \n+  /**\n+   * @return a CompilerInput that can be modified to add addition extern\n+   * definitions;\n+   */\n+  abstract CompilerInput getSynthesizedExternsInput();\n }\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.CheckLevel;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.rhino.IR;\n+import com.google.javascript.rhino.JSDocInfoBuilder;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n+\n+import java.util.List;\n \n /**\n  * Checks for non side effecting statements such as\n  * and generates warnings.\n  *\n  */\n-final class CheckSideEffects extends AbstractPostOrderCallback {\n+final class CheckSideEffects extends AbstractPostOrderCallback\n+    implements HotSwapCompilerPass {\n \n   static final DiagnosticType USELESS_CODE_ERROR = DiagnosticType.warning(\n       \"JSC_USELESS_CODE\",\n       \"Suspicious code. {0}\");\n \n+  static final String PROTECTOR_FN = \"JSCOMPILER_PRESERVE\";\n+\n   private final CheckLevel level;\n \n-  CheckSideEffects(CheckLevel level) {\n+  private final List<Node> problemNodes = Lists.newArrayList();\n+\n+  private final AbstractCompiler compiler;\n+\n+  private final boolean protectSideEffectFreeCode;\n+\n+  CheckSideEffects(AbstractCompiler compiler, CheckLevel level,\n+      boolean protectSideEffectFreeCode) {\n+    this.compiler = compiler;\n     this.level = level;\n+    this.protectSideEffectFreeCode = protectSideEffectFreeCode;\n+  }\n+\n+  @Override\n+  public void process(Node externs, Node root) {\n+    NodeTraversal.traverse(compiler, root, this);\n+\n+    // Code with hidden side-effect code is common, for example\n+    // accessing \"el.offsetWidth\" forces a reflow in browsers, to allow this\n+    // will still allowing local dead code removal in general,\n+    // protect the \"side-effect free\" code in the source.\n+    //\n+    if (protectSideEffectFreeCode) {\n+      protectSideEffects();\n+    }\n+  }\n+\n+  @Override\n+  public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n+    NodeTraversal.traverse(compiler, scriptRoot, this);\n   }\n \n   @Override\n       return;\n     }\n \n-    if (parent == null)\n+    if (parent == null) {\n       return;\n+    }\n \n     int pt = parent.getType();\n     if (pt == Token.COMMA) {\n \n       t.getCompiler().report(\n           t.makeError(n, level, USELESS_CODE_ERROR, msg));\n+      // TODO(johnlenz): determine if it is necessary to\n+      // try to protect side-effect free statements as well.\n+      if (!NodeUtil.isStatement(n)) {\n+        problemNodes.add(n);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Protect side-effect free nodes by making them parameters\n+   * to a extern function call.  This call will be removed\n+   * after all the optimizations passes have run.\n+   */\n+  private void protectSideEffects() {\n+    if (!problemNodes.isEmpty()) {\n+      addExtern();\n+      for (Node n : problemNodes) {\n+        Node name = IR.name(PROTECTOR_FN).srcref(n);\n+        name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        Node replacement = IR.call(name).srcref(n);\n+        replacement.putBooleanProp(Node.FREE_CALL, true);\n+        n.getParent().replaceChild(n, replacement);\n+        replacement.addChildToBack(n);\n+      }\n+      compiler.reportCodeChange();\n+    }\n+  }\n+\n+  private void addExtern() {\n+    Node name = IR.name(PROTECTOR_FN);\n+    name.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+    Node var = IR.var(name);\n+    // Add \"@noalias\" so we can strip the method when AliasExternals is enabled.\n+    JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n+    builder.recordNoAlias();\n+    var.setJSDocInfo(builder.build(var));\n+    CompilerInput input = compiler.getSynthesizedExternsInput();\n+    input.getAstRoot(compiler).addChildrenToBack(var);\n+    compiler.reportCodeChange();\n+  }\n+\n+  /**\n+   * Remove side-effect sync functions.\n+   */\n+  static class StripProtection extends AbstractPostOrderCallback implements CompilerPass {\n+\n+    private final AbstractCompiler compiler;\n+\n+    StripProtection(AbstractCompiler compiler) {\n+      this.compiler = compiler;\n+    }\n+\n+    @Override\n+    public void process(Node externs, Node root) {\n+      NodeTraversal.traverse(compiler, root, this);\n+    }\n+\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      if (n.isCall()) {\n+        Node target = n.getFirstChild();\n+        // TODO(johnlenz): add this to the coding convention\n+        // so we can remove goog.reflect.sinkValue as well.\n+        if (target.isName() && target.getString().equals(PROTECTOR_FN)) {\n+          Node expr = n.getLastChild();\n+          n.detachChildren();\n+          parent.replaceChild(n, expr);\n+        }\n+      }\n     }\n   }\n }\n--- a/src/com/google/javascript/jscomp/CompilationLevel.java\n+++ b/src/com/google/javascript/jscomp/CompilationLevel.java\n     options.optimizeArgumentsArray = true;\n     options.setRemoveUnusedVariables(Reach.LOCAL_ONLY);\n     options.collapseObjectLiterals = true;\n+    options.protectHiddenSideEffects = true;\n \n     // Allows annotations that are not standard.\n     options.setWarningLevel(DiagnosticGroups.NON_STANDARD_JSDOC,\n     options.removeDeadCode = true;\n     options.optimizeArgumentsArray = true;\n     options.collapseObjectLiterals = true;\n+    options.protectHiddenSideEffects = true;\n \n     // All the advance optimizations.\n     options.removeClosureAsserts = true;\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n   private final List<CodeChangeHandler> codeChangeHandlers =\n       Lists.<CodeChangeHandler>newArrayList();\n \n+  /** Name of the synthetic input that holds synthesized externs. */\n+  static final String SYNTHETIC_EXTERNS = \"{SyntheticVarsDeclar}\";\n+\n+  private CompilerInput synthesizedExternsInput = null;\n+\n   @Override\n   void addChangeHandler(CodeChangeHandler handler) {\n     codeChangeHandlers.add(handler);\n     return globalRefMap;\n   }\n \n+  @Override\n+  CompilerInput getSynthesizedExternsInput() {\n+    if (synthesizedExternsInput == null) {\n+      synthesizedExternsInput = newExternInput(SYNTHETIC_EXTERNS);\n+    }\n+    return synthesizedExternsInput;\n+  }\n+\n }\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n    * Whether the named objects types included 'undefined' by default.\n    */\n   boolean looseTypes;\n+\n+  /**\n+   * When set, assume that apparently side-effect free code is meaningful.\n+   */\n+  boolean protectHiddenSideEffects;\n+\n+  /**\n+   * When enabled, assume that apparently side-effect free code is meaningful.\n+   */\n+  public void setProtectHiddenSideEffects(boolean enable) {\n+    this.protectHiddenSideEffects = enable;\n+  }\n \n   /**\n    * Data holder Alias Transformation information accumulated during a compile.\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n       return checks;\n     }\n \n+    checks.add(checkSideEffects);\n+\n     if (options.checkSuspiciousCode ||\n         options.enables(DiagnosticGroups.GLOBAL_THIS) ||\n         options.enables(DiagnosticGroups.DEBUGGER_STATEMENT_PRESENT)) {\n       passes.add(rescopeGlobalSymbols);\n     }\n \n+    passes.add(stripSideEffectProtection);\n+\n     // Safety checks\n     passes.add(sanityCheckAst);\n     passes.add(sanityCheckVars);\n   /**\n    * Checks for code that is probably wrong (such as stray expressions).\n    */\n+  final HotSwapPassFactory checkSideEffects =\n+      new HotSwapPassFactory(\"checkSideEffects\", true) {\n+\n+    @Override\n+    protected HotSwapCompilerPass createInternal(final AbstractCompiler\n+        compiler) {\n+      // The current approach to protecting \"hidden\" side-effects is to\n+      // wrap them in a function call that is stripped later, this shouldn't\n+      // be done in IDE mode where AST changes may be unexpected.\n+      boolean protectHiddenSideEffects =\n+          options.protectHiddenSideEffects && !options.ideMode;\n+      return new CheckSideEffects(compiler,\n+          options.checkSuspiciousCode ? CheckLevel.WARNING : CheckLevel.OFF,\n+              protectHiddenSideEffects);\n+    }\n+  };\n+\n+  /**\n+   * Checks for code that is probably wrong (such as stray expressions).\n+   */\n+  final PassFactory stripSideEffectProtection =\n+      new PassFactory(\"stripSideEffectProtection\", true) {\n+\n+    @Override\n+    protected CompilerPass createInternal(final AbstractCompiler\n+        compiler) {\n+      return new CheckSideEffects.StripProtection(compiler);\n+    }\n+  };\n+\n+  /**\n+   * Checks for code that is probably wrong (such as stray expressions).\n+   */\n   // TODO(bolinfest): Write a CompilerPass for this.\n   final HotSwapPassFactory suspiciousCode =\n       new HotSwapPassFactory(\"suspiciousCode\", true) {\n       List<Callback> sharedCallbacks = Lists.newArrayList();\n       if (options.checkSuspiciousCode) {\n         sharedCallbacks.add(new CheckAccidentalSemicolon(CheckLevel.WARNING));\n-        sharedCallbacks.add(new CheckSideEffects(CheckLevel.WARNING));\n       }\n \n       if (options.enables(DiagnosticGroups.GLOBAL_THIS)) {\n--- a/src/com/google/javascript/jscomp/SymbolTable.java\n+++ b/src/com/google/javascript/jscomp/SymbolTable.java\n   private boolean isGoodRefToAdd(@Nullable StaticReference<JSType> ref) {\n     return ref != null && ref.getNode() != null\n         && ref.getNode().getStaticSourceFile() != null\n-        && !VarCheck.SYNTHETIC_VARS_DECLAR.equals(\n+        && !Compiler.SYNTHETIC_EXTERNS.equals(\n             ref.getNode().getStaticSourceFile().getName());\n   }\n \n--- a/src/com/google/javascript/jscomp/VarCheck.java\n+++ b/src/com/google/javascript/jscomp/VarCheck.java\n  */\n class VarCheck extends AbstractPostOrderCallback implements\n     HotSwapCompilerPass {\n-  /** Name of the synthetic script that holds undefined variables. */\n-  static final String SYNTHETIC_VARS_DECLAR = \"{SyntheticVarsDeclar}\";\n \n   static final DiagnosticType UNDEFINED_VAR_ERROR = DiagnosticType.error(\n       \"JSC_UNDEFINED_VARIABLE\",\n       \"JSC_UNDEFINED_EXTERN_VAR_ERROR\",\n       \"name {0} is not undefined in the externs.\");\n \n-  private CompilerInput synthesizedExternsInput = null;\n   private Node synthesizedExternsRoot = null;\n \n   // Vars that still need to be declared in externs. These will be declared\n \n   /** Lazily create a \"new\" externs input for undeclared variables. */\n   private CompilerInput getSynthesizedExternsInput() {\n-    if (synthesizedExternsInput == null) {\n-      synthesizedExternsInput =\n-          compiler.newExternInput(SYNTHETIC_VARS_DECLAR);\n-    }\n-    return synthesizedExternsInput;\n+    return compiler.getSynthesizedExternsInput();\n   }\n \n   /** Lazily create a \"new\" externs root for undeclared variables. */\n--- a/test/com/google/javascript/jscomp/CheckSideEffectsTest.java\n+++ b/test/com/google/javascript/jscomp/CheckSideEffectsTest.java\n public class CheckSideEffectsTest extends CompilerTestCase {\n   public CheckSideEffectsTest() {\n     this.parseTypeInfo = true;\n+    allowExternsChanges(true);\n+  }\n+\n+  @Override\n+  protected int getNumRepetitions() {\n+    return 1;\n   }\n \n   @Override\n   protected CompilerPass getProcessor(Compiler compiler) {\n-    return new CombinedCompilerPass(compiler,\n-        new CheckSideEffects(CheckLevel.ERROR));\n+    return new CheckSideEffects(compiler, CheckLevel.WARNING, true);\n   }\n \n-  public void test(String js, DiagnosticType error) {\n-    test(js, error == null ? js : null, error);\n+  @Override\n+  public void test(String js, String expected, DiagnosticType warning) {\n+    test(js, expected, null, warning);\n+  }\n+\n+  public void test(String js, DiagnosticType warning) {\n+    test(js, js, null, warning);\n   }\n \n   final DiagnosticType e = CheckSideEffects.USELESS_CODE_ERROR;\n \n   public void testUselessCode() {\n     test(\"function f(x) { if(x) return; }\", ok);\n-    test(\"function f(x) { if(x); }\", e);\n+    test(\"function f(x) { if(x); }\", \"function f(x) { if(x); }\", e);\n \n     test(\"if(x) x = y;\", ok);\n-    test(\"if(x) x == bar();\", e);\n+    test(\"if(x) x == bar();\", \"if(x) JSCOMPILER_PRESERVE(x == bar());\", e);\n \n     test(\"x = 3;\", ok);\n-    test(\"x == 3;\", e);\n+    test(\"x == 3;\", \"JSCOMPILER_PRESERVE(x == 3);\", e);\n \n     test(\"var x = 'test'\", ok);\n-    test(\"var x = 'test'\\n'str'\", e);\n+    test(\"var x = 'test'\\n'str'\",\n+         \"var x = 'test'\\nJSCOMPILER_PRESERVE('str')\", e);\n \n     test(\"\", ok);\n     test(\"foo();;;;bar();;;;\", ok);\n \n     test(\"var a, b; a = 5, b = 6\", ok);\n-    test(\"var a, b; a = 5, b == 6\", e);\n-    test(\"var a, b; a = (5, 6)\", e);      // the 5 has no side-effects\n+    test(\"var a, b; a = 5, b == 6\",\n+         \"var a, b; a = 5, JSCOMPILER_PRESERVE(b == 6)\", e);\n+    test(\"var a, b; a = (5, 6)\",\n+         \"var a, b; a = (JSCOMPILER_PRESERVE(5), 6)\", e);\n     test(\"var a, b; a = (b = 7, 6)\", ok);\n     test(\"function x(){}\\nfunction f(a, b){}\\nf(1,(x(), 2));\", ok);\n-    test(\"function x(){}\\nfunction f(a, b){}\\nf(1,(2, 3));\", e);\n+    test(\"function x(){}\\nfunction f(a, b){}\\nf(1,(2, 3));\",\n+         \"function x(){}\\nfunction f(a, b){}\\n\" +\n+         \"f(1,(JSCOMPILER_PRESERVE(2), 3));\", e);\n   }\n \n   public void testUselessCodeInFor() {\n     test(\"for(var x = 0; x < 100; x++) { foo(x) }\", ok);\n     test(\"for(; true; ) { bar() }\", ok);\n     test(\"for(foo(); true; foo()) { bar() }\", ok);\n-    test(\"for(void 0; true; foo()) { bar() }\", e);\n-    test(\"for(foo(); true; void 0) { bar() }\", e);\n+    test(\"for(void 0; true; foo()) { bar() }\",\n+         \"for(JSCOMPILER_PRESERVE(void 0); true; foo()) { bar() }\", e);\n+    test(\"for(foo(); true; void 0) { bar() }\",\n+         \"for(foo(); true; JSCOMPILER_PRESERVE(void 0)) { bar() }\", e);\n \n     test(\"for(foo in bar) { foo() }\", ok);\n     test(\"for (i = 0; el = el.previousSibling; i++) {}\", ok);\n   }\n \n   public void testTypeAnnotations() {\n-    test(\"x;\", e);\n-    test(\"a.b.c.d;\", e);\n+    test(\"x;\", \"JSCOMPILER_PRESERVE(x);\", e);\n+    test(\"a.b.c.d;\", \"JSCOMPILER_PRESERVE(a.b.c.d);\", e);\n     test(\"/** @type Number */ a.b.c.d;\", ok);\n     test(\"if (true) { /** @type Number */ a.b.c.d; }\", ok);\n \n-    test(\"function A() { this.foo; }\", e);\n+    test(\"function A() { this.foo; }\",\n+         \"function A() { JSCOMPILER_PRESERVE(this.foo); }\", e);\n     test(\"function A() { /** @type Number */ this.foo; }\", ok);\n   }\n \n   public void testJSDocComments() {\n     test(\"function A() { /** This is a jsdoc comment */ this.foo; }\", ok);\n-    test(\"function A() { /* This is a normal comment */ this.foo; }\", e);\n+    test(\"function A() { /* This is a normal comment */ this.foo; }\",\n+         \"function A() { \" +\n+         \" /* This is a normal comment */ JSCOMPILER_PRESERVE(this.foo); }\", e);\n   }\n \n   public void testIssue80() {\n     test(\"(0, eval)('alert');\", ok);\n-    test(\"(0, foo)('alert');\", e);\n+    test(\"(0, foo)('alert');\", \"(JSCOMPILER_PRESERVE(0), foo)('alert');\", e);\n   }\n \n   public void testIsue504() {\n-    test(\"void f();\", e);\n-    assertEquals(\n-        \"Suspicious code. The result of the 'void' operator is not being used.\",\n-        getLastCompiler().getErrorManager().getErrors()[0].description);\n+    test(\"void f();\", \"JSCOMPILER_PRESERVE(void f());\", null, e,\n+        \"Suspicious code. The result of the 'void' operator is not being used.\");\n   }\n }\n--- a/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CommandLineRunnerTest.java\n         + \"/** @constructor */ function Window() {}\\n\"\n         + \"/** @type {string} */ Window.prototype.name;\\n\"\n         + \"/** @type {Window} */ var window;\"\n+        + \"/** @constructor */ function Element() {}\"\n+        + \"Element.prototype.offsetWidth;\"\n         + \"/** @nosideeffects */ function noSideEffects() {}\")\n   );\n \n          \"}\");\n   }\n \n+  public void testHiddenSideEffect() {\n+    args.add(\"--compilation_level=ADVANCED_OPTIMIZATIONS\");\n+    test(\"element.offsetWidth;\",\n+         \"element.offsetWidth\", CheckSideEffects.USELESS_CODE_ERROR);\n+  }\n+\n   public void testIssue504() {\n     args.add(\"--compilation_level=ADVANCED_OPTIMIZATIONS\");\n     test(\"void function() { alert('hi'); }();\",\n-         \"alert('hi');\", CheckSideEffects.USELESS_CODE_ERROR);\n+         \"alert('hi');void 0\", CheckSideEffects.USELESS_CODE_ERROR);\n   }\n \n   public void testIssue601() {", "timestamp": 1326492432, "metainfo": ""}