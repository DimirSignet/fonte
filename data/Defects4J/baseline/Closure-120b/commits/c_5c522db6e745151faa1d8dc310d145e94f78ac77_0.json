{"sha": "5c522db6e745151faa1d8dc310d145e94f78ac77", "log": "Refactor CollapseProperties and GlobalNamespace to avoid having to do retraversals of scopes when scanning for new global references. Instead take advantage of parent pointers and go directly to the nodes in question. Reduces the runtime of CollapseProperties 500-750ms in my tests. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=47108208", "commit": "\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n import com.google.common.base.Predicates;\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n-import com.google.common.collect.Sets;\n+import com.google.javascript.jscomp.GlobalNamespace.AstChange;\n import com.google.javascript.jscomp.GlobalNamespace.Name;\n import com.google.javascript.jscomp.GlobalNamespace.Ref;\n import com.google.javascript.jscomp.GlobalNamespace.Ref.Type;\n import java.util.Deque;\n import java.util.List;\n import java.util.Map;\n-import java.util.Set;\n \n /**\n  * Flattens global objects/namespaces by replacing each '.' with '$' in\n     }\n   }\n \n-  private void inlineAliases(GlobalNamespace namespace) {\n-    // inline names until we reach a fixed point.\n-    do {} while (inlineAliasesOnce(namespace));\n-  }\n-\n   /**\n    * For each qualified name N in the global scope, we check if:\n    * (a) No ancestor of N is ever aliased or assigned an unknown value type.\n    * If (a) and (b) and (d) are true, then inline the alias if possible (if\n    * it is assigned exactly once unconditionally).\n    * @see InlineVariables\n-   * @return Whether any work still needs to be done.\n-   */\n-  private boolean inlineAliasesOnce(GlobalNamespace namespace) {\n-    int deferredCount = 0;\n-\n+   */\n+  private void inlineAliases(GlobalNamespace namespace) {\n     // Invariant: All the names in the worklist meet condition (a).\n     Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n \n-    Set<Node> newNodes = Sets.newHashSet();\n-\n     while (!workList.isEmpty()) {\n       Name name = workList.pop();\n-      boolean inlinedGlobalAliasToCurrentName = false;\n \n       // Don't attempt to inline a getter or setter property as a variable.\n       if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n           } else if (ref.type == Type.ALIASING_GET\n               && ref.scope.isGlobal()\n               && ref.getTwin() == null) {  // ignore aliases in chained assignments\n-            if (inlineGlobalAliasIfPossible(ref, namespace, newNodes)) {\n+            if (inlineGlobalAliasIfPossible(ref, namespace)) {\n               name.removeRef(ref);\n-              inlinedGlobalAliasToCurrentName = true;\n             }\n           }\n         }\n       }\n \n-      // * Check if {@code name} has any aliases left after the\n+      // Check if {@code name} has any aliases left after the\n       // local-alias-inlining above.\n-      // * Defer checking for inline-able aliases of properties of the current\n-      // name if global aliases were inlined as they may have created new\n-      // references to these properties\n-      if (!inlinedGlobalAliasToCurrentName &&\n-          (name.type == Name.Type.OBJECTLIT ||\n+      if ((name.type == Name.Type.OBJECTLIT ||\n            name.type == Name.Type.FUNCTION) &&\n           name.aliasingGets == 0 && name.props != null) {\n         // All of {@code name}'s children meet condition (a), so they can be\n         // added to the worklist.\n         workList.addAll(name.props);\n       }\n-\n-      if (inlinedGlobalAliasToCurrentName) {\n-        deferredCount++;\n-      }\n-    }\n-\n-    if (!newNodes.isEmpty()) {\n-      // Inlining the variable may have introduced new references\n-      // to descendants of {@code name}. So those need to be collected now.\n-      namespace.scanNewNodes(newNodes);\n-    }\n-\n-    return deferredCount > 0;\n+    }\n   }\n \n   /**\n    * meet these same requirements.\n    *\n    * @param alias The alias to inline\n-   * @param newNodes nodes added when replaces aliases.\n    * @return Whether the alias was inlined.\n    */\n   private boolean inlineGlobalAliasIfPossible(\n-      Ref alias, GlobalNamespace namespace, Set<Node> newNodes) {\n+      Ref alias, GlobalNamespace namespace) {\n     // Ensure that the alias is assigned to global name at that the\n     // declaration.\n \n       if (target != null) {\n         Name name = namespace.getSlot(target);\n         if (name != null && isInlinableGlobalAlias(name)) {\n+          List<AstChange> newNodes = Lists.newArrayList();\n+\n           List<Ref> refs = Lists.newArrayList(name.getRefs());\n           for (Ref ref : refs) {\n             switch (ref.type) {\n                 Node newNode = alias.node.cloneTree();\n                 Node node = ref.node;\n                 node.getParent().replaceChild(node, newNode);\n-                newNodes.add(newNode);\n+                newNodes.add(new AstChange(ref.module, ref.scope, newNode));\n                 name.removeRef(ref);\n                 break;\n               default:\n           aliasParent.replaceChild(alias.node, IR.nullNode());\n           compiler.reportCodeChange();\n \n-          // NOTE: It is too expensive to scan for aliases in global scope\n-          // immediately, so we defer it and check for them all at once at\n-          // the end of the pass.\n+          // Inlining the variable may have introduced new references\n+          // to descendants of {@code name}. So those need to be collected now.\n+          namespace.scanNewNodes(newNodes);\n \n           return true;\n         }\n    * @param newNodes Expression nodes that have been updated.\n    */\n   private void rewriteAliasProps(\n-      Name name, Node value, int depth, Set<Node> newNodes) {\n+      Name name, Node value, int depth, List<AstChange> newNodes) {\n     if (name.props != null) {\n       Preconditions.checkState(!\n           value.getQualifiedName().equals(name.getFullName()));\n           Preconditions.checkState(target.isGetProp() || target.isName());\n           target.getParent().replaceChild(target, value.cloneTree());\n           prop.removeRef(ref);\n-          newNodes.add(ref.node);\n+          // Rescan the expression root.\n+          newNodes.add(new AstChange(ref.module, ref.scope, ref.node));\n         }\n       }\n     }\n       (new NodeTraversal(compiler, collector)).traverseAtScope(scope);\n \n       ReferenceCollection aliasRefs = collector.getReferences(aliasVar);\n+      List<AstChange> newNodes = Lists.newArrayList();\n       if (aliasRefs.isWellDefined()\n           && aliasRefs.firstReferenceIsAssigningDeclaration()\n           && aliasRefs.isAssignedOnceInLifetime()) {\n         // The alias is well-formed, so do the inlining now.\n         int size = aliasRefs.references.size();\n-        Set<Node> newNodes = Sets.newHashSetWithExpectedSize(size - 1);\n         for (int i = 1; i < size; i++) {\n           ReferenceCollectingCallback.Reference aliasRef =\n               aliasRefs.references.get(i);\n \n           Node newNode = alias.node.cloneTree();\n           aliasRef.getParent().replaceChild(aliasRef.getNode(), newNode);\n-          newNodes.add(newNode);\n+          newNodes.add(new AstChange(\n+              getRefModule(aliasRef), aliasRef.getScope(), newNode));\n         }\n \n         // just set the original alias to null.\n \n         // Inlining the variable may have introduced new references\n         // to descendants of {@code name}. So those need to be collected now.\n-        namespace.scanNewNodes(alias.scope, newNodes);\n+        namespace.scanNewNodes(newNodes);\n         return true;\n       }\n     }\n \n     return false;\n+  }\n+\n+  JSModule getRefModule(ReferenceCollectingCallback.Reference ref) {\n+    CompilerInput input  = compiler.getInput(ref.getInputId());\n+    return input == null ? null : input.getModule();\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n   private final Node externsRoot;\n   private boolean inExterns;\n   private Scope externsScope;\n-  private Scope globalScope;\n   private boolean generated = false;\n \n   /**\n   }\n \n   /**\n+   * A simple data class that contains the information necessary to inspect\n+   * a node for changes to the global namespace.\n+   */\n+  static class AstChange {\n+    final JSModule module;\n+    final Scope scope;\n+    final Node node;\n+\n+    AstChange(JSModule module, Scope scope, Node node) {\n+      this.module = module;\n+      this.scope = scope;\n+      this.node = node;\n+    }\n+  }\n+\n+  /**\n    * If the client adds new nodes to the AST, scan these new nodes\n    * to see if they've added any references to the global namespace.\n-   * @param scope The scope to scan.\n    * @param newNodes New nodes to check.\n    */\n-  void scanNewNodes(Scope scope, Set<Node> newNodes) {\n-    NodeTraversal t = new NodeTraversal(compiler,\n-        new BuildGlobalNamespace(new NodeFilter(newNodes)));\n-    t.traverseAtScope(scope);\n-  }\n-\n-  void scanNewNodes(Set<Node> newNodes) {\n-    scanNewNodes(globalScope, newNodes);\n-  }\n-\n-  /**\n-   * A filter that looks for qualified names that contain one of the nodes\n-   * in the given set.\n-   */\n-  private static class NodeFilter implements Predicate<Node> {\n-    private final Set<Node> newNodes;\n-\n-    NodeFilter(Set<Node> newNodes) {\n-      this.newNodes = newNodes;\n-    }\n-\n-    @Override\n-    public boolean apply(Node n) {\n-      if (NodeUtil.isObjectLitKey(n)) {\n-        return newNodes.contains(n);\n-      }\n-\n-      if (!n.isQualifiedName()) {\n-        return false;\n-      }\n-\n-      Node current;\n-      for (current = n;\n-           current.isGetProp();\n-           current = current.getFirstChild()) {\n-        if (newNodes.contains(current)) {\n-          return true;\n-        }\n-      }\n-\n-      return current.isName() && newNodes.contains(current);\n-    }\n+  void scanNewNodes(List<AstChange> newNodes) {\n+    BuildGlobalNamespace builder = new BuildGlobalNamespace();\n+\n+    for (AstChange info : newNodes) {\n+      if (!info.node.isQualifiedName() && !NodeUtil.isObjectLitKey(info.node)) {\n+        continue;\n+      }\n+      scanFromNode(builder, info.module, info.scope, info.node);\n+    }\n+  }\n+\n+  private void scanFromNode(\n+    BuildGlobalNamespace builder, JSModule module, Scope scope, Node n) {\n+    // Check affected parent nodes first.\n+    if (n.isName() || n.isGetProp()) {\n+      scanFromNode(builder, module, scope, n.getParent());\n+    }\n+    builder.collect(module, scope, n);\n   }\n \n   /**\n    */\n   private class BuildGlobalNamespace implements NodeTraversal.Callback {\n \n-    private final Predicate<Node> nodeFilter;\n-\n     BuildGlobalNamespace() {\n-      this(null);\n-    }\n-\n-    /**\n-     * Builds a global namespace, but only visits nodes that match the\n-     * given filter.\n-     */\n-    BuildGlobalNamespace(Predicate<Node> nodeFilter) {\n-      this.nodeFilter = nodeFilter;\n     }\n \n     @Override\n     /** Collect the references in pre-order. */\n     @Override\n     public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-      collect(t, n, parent);\n-      return true;\n-    }\n-\n-    public void collect(NodeTraversal t, Node n, Node parent) {\n-      if (nodeFilter != null && !nodeFilter.apply(n)) {\n-        return;\n-      }\n-\n       // If we are traversing the externs, then we save a pointer to the scope\n       // generated by them, so that we can do lookups in it later.\n       if (externsRoot != null && n == externsRoot) {\n         externsScope = t.getScope();\n       }\n \n-      if (root != null && n == root) {\n-        globalScope = t.getScope();\n-      }\n-\n+      collect(t.getModule(), t.getScope(), n);\n+\n+      return true;\n+    }\n+\n+    public void collect(JSModule module, Scope scope, Node n) {\n+      Node parent = n.getParent();\n \n       String name;\n       boolean isSet = false;\n       }\n \n       // We are only interested in global names.\n-      Scope scope = t.getScope();\n       if (!isGlobalNameReference(name, scope)) {\n         return;\n       }\n \n       if (isSet) {\n         if (isGlobalScope(scope)) {\n-          handleSetFromGlobal(t, n, parent, name, isPropAssign, type);\n+          handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);\n         } else {\n-          handleSetFromLocal(t, n, parent, name);\n+          handleSetFromLocal(module, scope, n, parent, name);\n         }\n       } else {\n-        handleGet(t, n, parent, name);\n+        handleGet(module, scope, n, parent, name);\n       }\n     }\n \n      * Updates our representation of the global namespace to reflect an\n      * assignment to a global name in global scope.\n      *\n-     * @param t The traversal\n+     * @param module the current module\n+     * @param scope the current scope\n      * @param n The node currently being visited\n      * @param parent {@code n}'s parent\n      * @param name The global name (e.g. \"a\" or \"a.b.c.d\")\n      *     assignment of the form <code>a.b.c = ...;</code>\n      * @param type The type of the value that the name is being assigned\n      */\n-    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n-                             boolean isPropAssign, Name.Type type) {\n-      if (maybeHandlePrototypePrefix(t, n, parent, name)) {\n+    void handleSetFromGlobal(JSModule module, Scope scope,\n+        Node n, Node parent, String name,\n+        boolean isPropAssign, Name.Type type) {\n+      if (maybeHandlePrototypePrefix(module, scope, n, parent, name)) {\n         return;\n       }\n \n       Name nameObj = getOrCreateName(name);\n       nameObj.type = type;\n \n-      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n+      Ref set = new Ref(module, scope, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n           currentPreOrderIndex++);\n       nameObj.addRef(set);\n \n       if (isNestedAssign(parent)) {\n         // This assignment is both a set and a get that creates an alias.\n-        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n+        Ref get = new Ref(module, scope, n, nameObj, Ref.Type.ALIASING_GET,\n             currentPreOrderIndex++);\n         nameObj.addRef(get);\n         Ref.markTwins(set, get);\n      * Updates our representation of the global namespace to reflect an\n      * assignment to a global name in a local scope.\n      *\n-     * @param t The traversal\n+     * @param module The current module\n+     * @param scope The current scope\n      * @param n The node currently being visited\n      * @param parent {@code n}'s parent\n      * @param name The global name (e.g. \"a\" or \"a.b.c.d\")\n      */\n-    void handleSetFromLocal(NodeTraversal t, Node n, Node parent,\n+    void handleSetFromLocal(JSModule module, Scope scope, Node n, Node parent,\n                             String name) {\n-      if (maybeHandlePrototypePrefix(t, n, parent, name)) {\n+      if (maybeHandlePrototypePrefix(module, scope, n, parent, name)) {\n         return;\n       }\n \n       Name nameObj = getOrCreateName(name);\n-      Ref set = new Ref(t, n, nameObj,\n+      Ref set = new Ref(module, scope, n, nameObj,\n           Ref.Type.SET_FROM_LOCAL, currentPreOrderIndex++);\n       nameObj.addRef(set);\n \n       if (isNestedAssign(parent)) {\n         // This assignment is both a set and a get that creates an alias.\n-        Ref get = new Ref(t, n, nameObj,\n+        Ref get = new Ref(module, scope, n, nameObj,\n             Ref.Type.ALIASING_GET, currentPreOrderIndex++);\n         nameObj.addRef(get);\n         Ref.markTwins(set, get);\n      * Updates our representation of the global namespace to reflect a read\n      * of a global name.\n      *\n-     * @param t The traversal\n+     * @param module The current module\n+     * @param scope The current scope\n      * @param n The node currently being visited\n      * @param parent {@code n}'s parent\n      * @param name The global name (e.g. \"a\" or \"a.b.c.d\")\n      */\n-    void handleGet(NodeTraversal t, Node n, Node parent, String name) {\n-      if (maybeHandlePrototypePrefix(t, n, parent, name)) {\n+    void handleGet(JSModule module, Scope scope,\n+        Node n, Node parent, String name) {\n+      if (maybeHandlePrototypePrefix(module, scope, n, parent, name)) {\n         return;\n       }\n \n             // alias is not getting created for this name if the result is used\n             // in a boolean context or assigned to the same name\n             // (e.g. var a = a || {}).\n-            type = determineGetTypeForHookOrBooleanExpr(t, parent, name);\n+            type = determineGetTypeForHookOrBooleanExpr(module, scope, parent, name);\n             break;\n           case Token.HOOK:\n             if (n != parent.getFirstChild()) {\n               // This node is y or z in (x?y:z). We only know that an alias is\n               // not getting created for this name if the result is assigned to\n               // the same name (e.g. var a = a ? a : {}).\n-              type = determineGetTypeForHookOrBooleanExpr(t, parent, name);\n+              type = determineGetTypeForHookOrBooleanExpr(module, scope, parent, name);\n             }\n             break;\n           case Token.DELPROP:\n         }\n       }\n \n-      handleGet(t, n, parent, name, type);\n+      handleGet(module, scope, n, parent, name, type);\n     }\n \n     /**\n      * Determines whether the result of a hook (x?y:z) or boolean expression\n      * (x||y) or (x&&y) is assigned to a specific global name.\n      *\n-     * @param t The traversal\n+     * @param module The current module\n+     * @param scope The current scope\n      * @param parent The parent of the current node in the traversal. This node\n      *     should already be known to be a HOOK, AND, or OR node.\n      * @param name A name that is already known to be global in the current\n      *     {@link Ref.Type#ALIASING_GET}\n      */\n     Ref.Type determineGetTypeForHookOrBooleanExpr(\n-        NodeTraversal t, Node parent, String name) {\n+        JSModule module, Scope scope, Node parent, String name) {\n       Node prev = parent;\n       for (Node anc : parent.getAncestors()) {\n         switch (anc.getType()) {\n      * Updates our representation of the global namespace to reflect a read\n      * of a global name.\n      *\n-     * @param t The current node traversal\n+     * @param module The current module\n+     * @param scope The current scope\n      * @param n The node currently being visited\n      * @param parent {@code n}'s parent\n      * @param name The global name (e.g. \"a\" or \"a.b.c.d\")\n      * @param type The reference type\n      */\n-    void handleGet(NodeTraversal t, Node n, Node parent,\n+    void handleGet(JSModule module, Scope scope, Node n, Node parent,\n         String name, Ref.Type type) {\n       Name nameObj = getOrCreateName(name);\n \n       // No need to look up additional ancestors, since they won't be used.\n-      nameObj.addRef(new Ref(t, n, nameObj, type, currentPreOrderIndex++));\n+      nameObj.addRef(\n+          new Ref(module, scope, n, nameObj, type, currentPreOrderIndex++));\n     }\n \n     /**\n      * of a global name's longest prefix before the \"prototype\" property if the\n      * name includes the \"prototype\" property. Does nothing otherwise.\n      *\n-     * @param t The current node traversal\n+     * @param module The current module\n+     * @param scope The current scope\n      * @param n The node currently being visited\n      * @param parent {@code n}'s parent\n      * @param name The global name (e.g. \"a\" or \"a.b.c.d\")\n      * @return Whether the name was handled\n      */\n-    boolean maybeHandlePrototypePrefix(NodeTraversal t, Node n, Node parent,\n-        String name) {\n+    boolean maybeHandlePrototypePrefix(JSModule module, Scope scope,\n+        Node n, Node parent, String name) {\n       // We use a string-based approach instead of inspecting the parse tree\n       // to avoid complexities with object literals, possibly nested, beneath\n       // assignments.\n         n = n.getFirstChild();\n       }\n \n-      handleGet(t, n, parent, prefix, Ref.Type.PROTOTYPE_GET);\n+      handleGet(module, scope, n, parent, prefix, Ref.Type.PROTOTYPE_GET);\n       return true;\n     }\n \n     /**\n      * Creates a reference at the current node.\n      */\n-    Ref(NodeTraversal t, Node node, Name name, Type type, int index) {\n+    Ref(JSModule module, Scope scope, Node node, Name name, Type type, int index) {\n       this.node = node;\n       this.name = name;\n-      this.module = t.getInput() == null ? null : t.getInput().getModule();\n+      this.module = module;\n       this.source = node.getStaticSourceFile();\n       this.type = type;\n-      this.scope = t.getScope();\n+      this.scope = scope;\n       this.preOrderIndex = index;\n     }\n ", "timestamp": 1369437663, "metainfo": ""}