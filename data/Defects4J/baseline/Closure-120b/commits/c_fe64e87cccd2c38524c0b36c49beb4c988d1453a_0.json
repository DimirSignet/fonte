{"sha": "fe64e87cccd2c38524c0b36c49beb4c988d1453a", "log": "Never rename a variable named \"$super\", because the Prototype library uses this to do magic.  Better dead assignment elimination.  Emit an error if you declare a parameter twice.  Don't do anonymous function collapsing by default.    ", "commit": "\n--- a/src/com/google/javascript/jscomp/CodingConvention.java\n+++ b/src/com/google/javascript/jscomp/CodingConvention.java\n    * exported, or externally referenceable.\n    *\n    * @param name A global variable or function name.\n+   * @param local {@code true} if the name is a local variable.\n    * @return {@code true} if the name should be considered exported.\n+   */\n+  public boolean isExported(String name, boolean local);\n+  \n+  /**\n+   * Should be isExported(name, true) || isExported(name, false);\n    */\n   public boolean isExported(String name);\n \n--- a/src/com/google/javascript/jscomp/CompilationLevel.java\n+++ b/src/com/google/javascript/jscomp/CompilationLevel.java\n     options.deadAssignmentElimination = true;\n     options.extractPrototypeMemberDeclarations = true;\n     options.collapseVariableDeclarations = true;\n-    options.collapseAnonymousFunctions = true;\n     options.convertToDottedProperties = true;\n     options.labelRenaming = true;\n     options.removeDeadCode = true;\n     options.deadAssignmentElimination = true;\n     options.extractPrototypeMemberDeclarations = true;\n     options.collapseVariableDeclarations = true;\n-    options.collapseAnonymousFunctions = true;\n     options.convertToDottedProperties = true;\n     options.rewriteFunctionExpressions = true;\n     options.labelRenaming = true;\n     options.propertyRenaming = PropertyRenamingPolicy.ALL_UNQUOTED;\n     options.removeUnusedPrototypeProperties = true;\n     options.removeUnusedPrototypePropertiesInExterns = true;\n+    options.collapseAnonymousFunctions = true;\n     options.collapseProperties = true;\n     options.rewriteFunctionExpressions = true;\n     options.devirtualizePrototypeMethods = true;\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n import com.google.common.base.Tracer;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n-import com.google.common.flags.Flag;\n-import com.google.common.flags.FlagSpec;\n import com.google.javascript.jscomp.CompilerOptions.DevMode;\n import com.google.javascript.jscomp.CompilerOptions.TracerMode;\n import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter;\n *\n  */\n public class Compiler extends AbstractCompiler {\n-  @FlagSpec(help = \"As part of the aliasing pass, outputs all strings and \" +\n-                   \"the number of times they were used in the application to \" +\n-                   \"the server log.\")\n-  public static final Flag<Boolean> FLAG_output_js_string_usage =\n-      Flag.value(false);\n-\n   CompilerOptions options_ = createDefaultOptions();\n \n   private PassConfig passes = null;\n       aliasStrings(options_.aliasableStrings,\n                    options_.aliasAllStrings,\n                    options_.aliasStringsBlacklist,\n-                   FLAG_output_js_string_usage.get());\n+                   options_.outputJsStringUsage);\n     }\n \n     if (options_.aliasExternals) {\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n    * to aliasableStrings)\n    */\n   public boolean aliasAllStrings;\n+\n+  /** Print string usage as part of the compilation log. */\n+  boolean outputJsStringUsage;\n \n   /** Converts quoted property accesses to dot syntax (a['b'] -> a.b) */\n   public boolean convertToDottedProperties;\n     aliasableStrings = Collections.emptySet();\n     aliasStringsBlacklist = \"\";\n     aliasAllStrings = false;\n+    outputJsStringUsage = false;\n     convertToDottedProperties = false;\n     rewriteFunctionExpressions = false;\n     optimizeParameters = false;\n--- a/src/com/google/javascript/jscomp/ControlFlowGraph.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowGraph.java\n       if (parent == null) {\n         return true;\n       }\n-      switch (parent.getType()) {\n-        case Token.BLOCK:\n-        case Token.SCRIPT:\n-        case Token.TRY:\n-        case Token.FINALLY:\n-          return false;\n-        case Token.FUNCTION:\n-          return n == parent.getFirstChild().getNext();\n-        case Token.WHILE:\n-        case Token.DO:\n-        case Token.IF:\n-          return NodeUtil.getConditionExpression(parent) == n;\n-        case Token.FOR:\n-          if (parent.getChildCount() == 4) {\n-            return NodeUtil.getConditionExpression(parent) == n;\n-          } else {\n-            return n != parent.getLastChild();\n-          }\n-        case Token.SWITCH:\n-        case Token.CASE:\n-        case Token.CATCH:\n-        case Token.WITH:\n-          return n == parent.getFirstChild();\n-\n-        default:\n-          return true;\n-      }\n+      return !isEnteringNewCfgNode(n);\n+    }\n+  }\n+  \n+  /**\n+   * @return True if n should be represented by a new CFG node in the control\n+   * flow graph.\n+   */\n+  public static boolean isEnteringNewCfgNode(Node n) {\n+    Node parent = n.getParent();\n+    switch (parent.getType()) {\n+      case Token.BLOCK:\n+      case Token.SCRIPT:\n+      case Token.TRY:\n+      case Token.FINALLY:\n+        return true;\n+      case Token.FUNCTION:\n+        // A function node represents the start of a function where the name\n+        // is bleed into the local scope and parameters has been assigned\n+        // to the formal argument names. The node includes the name of the\n+        // function and the LP list since we assume the whole set up process\n+        // is atomic without change in control flow. The next change of\n+        // control is going into the function's body represent by the second\n+        // child.\n+        return n != parent.getFirstChild().getNext();\n+      case Token.WHILE:\n+      case Token.DO:\n+      case Token.IF:\n+        // Theses control structure is represented by its node that holds the\n+        // condition. Each of them is a branch node based on its condition.\n+        return NodeUtil.getConditionExpression(parent) != n;\n+        \n+      case Token.FOR:\n+        // The FOR(;;) node differs from other control structure in that\n+        // it has a initialization and a increment statement. Those\n+        // two statements have its corresponding CFG nodes to represent them.\n+        // The FOR node represents the condition check for each iteration.\n+        // That way the following:\n+        // for(var x = 0; x < 10; x++) { } has a graph that is isomorphic to\n+        // var x = 0; while(x<10) {  x++; }\n+        if (parent.getChildCount() == 4) {\n+          return NodeUtil.getConditionExpression(parent) != n;\n+        } else {\n+          return n == parent.getLastChild();\n+        }\n+      case Token.SWITCH:\n+      case Token.CASE:\n+      case Token.CATCH:\n+      case Token.WITH:\n+        return n != parent.getFirstChild();\n+      default:\n+        return false;\n     }\n   }\n }\n--- a/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n+++ b/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n import com.google.javascript.rhino.Token;\n \n import java.util.List;\n-import java.util.logging.Logger;\n \n /**\n  * Removes local variable assignments that are useless based on information from\n \n   private final AbstractCompiler compiler;\n   private LiveVariablesAnalysis liveness;\n-  private static final Logger logger =\n-    Logger.getLogger(DeadAssignmentsElimination.class.getName());\n \n   public DeadAssignmentsElimination(AbstractCompiler compiler) {\n     this.compiler = compiler;\n         case Token.IF:\n         case Token.WHILE:\n         case Token.DO:\n-          tryRemoveAssignment(t, NodeUtil.getConditionExpression(n), n, state);\n+          tryRemoveAssignment(t, NodeUtil.getConditionExpression(n), state);\n           continue;\n         case Token.FOR:\n           if (n.getChildCount() == 4) {\n             tryRemoveAssignment(\n-                t, NodeUtil.getConditionExpression(n), n, state);\n-            tryRemoveAssignment(\n-                t, n.getFirstChild().getNext().getNext(), n, state);\n+                t, NodeUtil.getConditionExpression(n), state);\n           }\n           continue;\n         case Token.SWITCH:\n         case Token.CASE:\n         case Token.RETURN:\n           if (n.hasChildren()) {\n-            tryRemoveAssignment(t, n.getFirstChild(), n, state);\n+            tryRemoveAssignment(t, n.getFirstChild(), state);\n           }\n           continue;\n         // TODO(user): case Token.VAR: Remove var a=1;a=2;.....\n       }\n       \n-      if (NodeUtil.isExpressionNode(n)) {\n-        tryRemoveAssignment(t, n.getFirstChild(), n, state);\n-      }\n-    }\n-  }\n-\n+      tryRemoveAssignment(t, n, state);\n+    }\n+  }\n+\n+  private void tryRemoveAssignment(NodeTraversal t, Node n,\n+      FlowState<LiveVariableLattice> state) {\n+    tryRemoveAssignment(t, n, n, state);\n+  }\n+  \n   /**\n    * Determines if any local variables are dead after the instruction {@code n}\n    * and are assigned within the subtree of {@code n}. Removes those assignments\n    * if there are any.\n    *\n    * @param n Target instruction.\n-   * @param parent Parent of {@code n}.\n+   * @param exprRoot The CFG node where the liveness information in state is\n+   *     still correct.\n    * @param state The liveness information at {@code n}.\n    */\n-  private void tryRemoveAssignment(NodeTraversal t, Node n, Node parent,\n+  private void tryRemoveAssignment(NodeTraversal t, Node n, Node exprRoot,\n       FlowState<LiveVariableLattice> state) {\n-    if (NodeUtil.isAssign(n)) {\n+\n+    // TODO(user): Add implemenation to handle x++ and ++x by replacing\n+    // them with x or x+1 respectively.\n+    if (NodeUtil.isAssignmentOp(n)) {\n+\n       Node lhs = n.getFirstChild();\n+      Node rhs = lhs.getNext();\n+      \n+      // Recurse first. Example: dead_x = dead_y = 1; We try to clean up dead_y\n+      // first.\n+      if (rhs != null) {\n+        tryRemoveAssignment(t, rhs, exprRoot, state);\n+        rhs = lhs.getNext();\n+      }\n+\n       Scope scope = t.getScope();\n       if (!NodeUtil.isName(lhs)) {\n         return; // Not a local variable assignment.\n       if (state.getOut().isLive(var)) {\n         return; // Variable not dead.\n       }\n-      if (state.getIn().isLive(var)) {\n-        // Oddly, the variable is killed here but it is also live before it.\n+      if (state.getIn().isLive(var) &&\n+          isVariableStillLiveWithinExpression(n, exprRoot, var.name)) {\n+        // The variable is killed here but it is also live before it.\n         // This is possible if we have say:\n         //    if (X = a && a = C) {..} ; .......; a = S;\n         // In this case we are safe to remove \"a = C\" because it is dead.\n         // of GEN sets when we recurse here.\n         return;\n       }\n-      Node rhs = n.getLastChild();\n-      // Now we are at a dead local variable assignment.\n-      logger.info(\"Removing dead assignemnt to \" + name + \" in \"\n-          + t.getSourceName() + \" line \" + n.getLineno());\n-      n.removeChild(rhs);\n-      parent.replaceChild(n, rhs);\n+      \n+      if (NodeUtil.isAssign(n)) {\n+        n.removeChild(rhs);\n+        n.getParent().replaceChild(n, rhs);\n+      } else if (NodeUtil.isAssignmentOp(n)) {\n+        n.removeChild(rhs);\n+        n.removeChild(lhs);\n+        Node op = new Node(NodeUtil.getOpFromAssignmentOp(n), lhs, rhs);\n+        n.getParent().replaceChild(n, op);\n+      } else {\n+        // TODO(user): this is where the code that handles dead x++ and x--\n+        // should go.\n+        \n+        // Not reachable.\n+        Preconditions.checkState(false, \"Unknow statement\");\n+      }\n+      \n       compiler.reportCodeChange();\n       return;\n \n     } else {\n       for (Node c = n.getFirstChild(); c != null;) {\n         Node next = c.getNext();\n-        tryRemoveAssignment(t, c, n, state);\n+        if (!ControlFlowGraph.isEnteringNewCfgNode(c)) {\n+          tryRemoveAssignment(t, c, exprRoot, state);\n+        }\n         c = next;\n       }\n       return;\n     }\n   }\n+  \n+  /**\n+   * Given a variable, node n in the tree and a sub-tree denoted by exprRoot as\n+   * the root, this function returns true if there exists a read of that\n+   * variable before a write to that variable that is on the right side of n.\n+   * \n+   * For example, suppose the node is x = 1:\n+   * \n+   * y = 1, x = 1; // false, there is no reads at all.\n+   * y = 1, x = 1, print(x) // true, there is a read right of n.\n+   * y = 1, x = 1, x = 2, print(x) // false, there is a read right of n but \n+   *                               // it is after a write.\n+   * \n+   * @param n The current node we should look at.\n+   * @param exprRoot The node\n+   */\n+  private boolean isVariableStillLiveWithinExpression(\n+      Node n, Node exprRoot, String variable) {\n+    while (n != exprRoot) {\n+      for(Node sibling = n.getNext(); sibling != null;\n+          sibling = sibling.getNext()) {\n+        if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {\n+          VariableLiveness state = readVariableBeforeKilling(sibling, variable);\n+          \n+          // If we see a READ or KILL there is no need to continue.\n+          if (state == VariableLiveness.READ) {\n+            return true;\n+          } else if (state == VariableLiveness.KILL) {\n+            return false;\n+          }\n+        }\n+      }\n+      n = n.getParent();\n+    }\n+    return false;\n+  }\n+  \n+  // The current liveness of the variable\n+  private enum VariableLiveness {\n+    MAYBE_LIVE, // May be still live in the current expression tree.\n+    READ, // Known there is a read left of it.\n+    KILL, // Known there is a write before any read.\n+  }\n+\n+  /**\n+   * Give an expression and a variable. It returns READ, if the right-most\n+   * reference of that variable is a read. It returns KILL, if the right-most\n+   * reference of that variable is an assignment. It returns MAY_LIVE otherwise.\n+   * \n+   * This need to be a pre-order traversal so we cannot use the normal node\n+   * traversals.\n+   */\n+  private VariableLiveness readVariableBeforeKilling(Node n, String variable) {\n+    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n+      if (NodeUtil.isLhs(n, n.getParent())) {\n+        return VariableLiveness.KILL;\n+      } else {\n+        return VariableLiveness.READ;\n+      }\n+    }\n+    for (Node child = n.getFirstChild();\n+        child != null; child = child.getNext()) {\n+      if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\n+        VariableLiveness state = readVariableBeforeKilling(child, variable);\n+        if (state != VariableLiveness.MAYBE_LIVE) {\n+          return state;\n+        }\n+      }\n+    }\n+    return VariableLiveness.MAYBE_LIVE;\n+  }\n }\n--- a/src/com/google/javascript/jscomp/DefaultCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/DefaultCodingConvention.java\n   }\n \n   @Override\n+  public boolean isExported(String name, boolean local) {\n+    return local && name.startsWith(\"$super\");\n+  }\n+  \n+  @Override\n   public boolean isExported(String name) {\n-    return false;\n+    return isExported(name, false) || isExported(name, true);\n   }\n \n   @Override\n--- a/src/com/google/javascript/jscomp/GoogleCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/GoogleCodingConvention.java\n    * considered exported.\n    */\n   @Override\n-  public boolean isExported(String name) {\n-    return name.startsWith(\"_\");\n+  public boolean isExported(String name, boolean local) {\n+    return !local && name.startsWith(\"_\");\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java\n+++ b/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.collect.HashMultimap;\n import com.google.common.collect.Multimap;\n-import com.google.common.collect.Multimaps;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.ControlFlowGraph.Branch;\n import com.google.javascript.jscomp.Scope.Var;\n     final Multimap<Var, Node> mayUseMap;\n \n     public ReachingUses() {\n-      mayUseMap = Multimaps.newHashMultimap();\n+      mayUseMap = HashMultimap.create();\n     }\n \n     /**\n      * @param other The constructed object is a replicated copy of this element.\n      */\n     public ReachingUses(ReachingUses other) {\n-      mayUseMap = Multimaps.newHashMultimap(other.mayUseMap);\n+      mayUseMap = HashMultimap.create(other.mayUseMap);\n     }\n \n     @Override\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n     }\n     return false;\n   }\n+  \n+  static int getOpFromAssignmentOp(Node n) {\n+    switch (n.getType()){\n+      case Token.ASSIGN_BITOR:\n+        return Token.BITOR;\n+      case Token.ASSIGN_BITXOR:\n+        return Token.BITXOR;\n+      case Token.ASSIGN_BITAND:\n+        return Token.BITAND;\n+      case Token.ASSIGN_LSH:\n+        return Token.LSH;\n+      case Token.ASSIGN_RSH:\n+        return Token.RSH;\n+      case Token.ASSIGN_URSH:\n+        return Token.URSH;\n+      case Token.ASSIGN_ADD:\n+        return Token.ADD;\n+      case Token.ASSIGN_SUB:\n+        return Token.SUB;\n+      case Token.ASSIGN_MUL:\n+        return Token.MUL;\n+      case Token.ASSIGN_DIV:\n+        return Token.DIV;\n+      case Token.ASSIGN_MOD:\n+        return Token.MOD;\n+    }\n+    throw new IllegalArgumentException(\"Not an assiment op\");\n+  }\n \n   static boolean isExpressionNode(Node n) {\n     return n.getType() == Token.EXPR_RESULT;\n--- a/src/com/google/javascript/jscomp/OptimizeArgumentsArray.java\n+++ b/src/com/google/javascript/jscomp/OptimizeArgumentsArray.java\n       // We have something like arguments[x] where x is not a constant. That\n       // means at least one of the access is not known.\n       if (index.getType() != Token.NUMBER) {\n-        continue;\n+        // TODO(user): Its possible not to give up just yet. The type\n+        // inference did a 'semi value propagation'. If we know that string\n+        // is never a subclass of the type of the index. We'd know that\n+        // it is never 'callee'.\n+        return false; // Give up.\n       }\n \n       // Replace the highest index if we see an access that has a higher index\n--- a/src/com/google/javascript/jscomp/RenameVars.java\n+++ b/src/com/google/javascript/jscomp/RenameVars.java\n    * Determines whether a variable name is okay to rename.\n    */\n   private boolean okToRenameVar(String name, boolean isLocal) {\n-    return isLocal || !compiler.getCodingConvention().isExported(name);\n+    return !compiler.getCodingConvention().isExported(name, isLocal);\n   }\n }\n--- a/src/com/google/javascript/jscomp/RhinoErrorReporter.java\n+++ b/src/com/google/javascript/jscomp/RhinoErrorReporter.java\n   static final DiagnosticType TRAILING_COMMA =\n       DiagnosticType.error(\"JSC_TRAILING_COMMA\", \"Parse error. {0}\");\n \n-  static final DiagnosticType BAD_JSDOC_ANNOTATION = \n+  static final DiagnosticType DUPLICATE_PARAM =\n+      DiagnosticType.error(\"JSC_DUPLICATE_PARAM\", \"Parse error. {0}\");\n+\n+  static final DiagnosticType BAD_JSDOC_ANNOTATION =\n     DiagnosticType.warning(\"JSC_BAD_JSDOC_ANNOTATION\", \"Parse error. {0}\");\n-  \n+\n   // A map of Rhino messages to their DiagnosticType.\n   private final Map<String, DiagnosticType> typeMap;\n \n   private RhinoErrorReporter(AbstractCompiler compiler) {\n     this.compiler = compiler;\n     typeMap = ImmutableMap.of(\n-        \n+\n         // Extra @fileoverview\n         replacePlaceHolders(\n             ScriptRuntime.getMessage0(\"msg.jsdoc.fileoverview.extra\")),\n         EXTRA_FILEOVERVIEW,\n-        \n+\n         // Trailing comma\n         replacePlaceHolders(\n             com.google.javascript.jscomp.mozilla.rhino.ScriptRuntime\n               .getMessage0(\"msg.extra.trailing.comma\")),\n         TRAILING_COMMA,\n-    \n+\n+        // Duplicate parameter\n+        replacePlaceHolders(\n+            com.google.javascript.jscomp.mozilla.rhino.ScriptRuntime\n+              .getMessage0(\"msg.dup.parms\")),\n+        DUPLICATE_PARAM,\n+\n         // Unknown @annotations.\n         replacePlaceHolders(ScriptRuntime.getMessage0(\"msg.bad.jsdoc.tag\")),\n         BAD_JSDOC_ANNOTATION);\n--- a/src/com/google/javascript/jscomp/WarningLevel.java\n+++ b/src/com/google/javascript/jscomp/WarningLevel.java\n     // new one once it is default in command line JSCompiler.\n     options.checkUndefinedProperties = CheckLevel.OFF;\n     options.checkUnusedPropertiesEarly = false;\n+    options.checkUnreachableCode = CheckLevel.WARNING;\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/CompilerRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CompilerRunnerTest.java\n  */\n public class CompilerRunnerTest extends TestCase {\n \n+  private Compiler lastCompiler = null;\n+\n   /** Externs for the test */\n   private final JSSourceFile[] externs = new JSSourceFile[] {\n     JSSourceFile.fromCode(\"externs\",\n   @Override\n   public void setUp() {\n     Flags.disableStateCheckingForTest();\n+    lastCompiler = null;\n   }\n \n   @Override\n     AbstractCompilerRunner.FLAG_jscomp_error.setForTest(\n         Lists.newArrayList(\"missingProperties\"));\n     test(\"var x = {}; var y = x.bar;\", TypeCheck.INEXISTENT_PROPERTY);\n+  }\n+\n+  public void testDuplicateParams() {\n+    test(\"function (a, a) {}\", RhinoErrorReporter.DUPLICATE_PARAM);\n+    assertTrue(lastCompiler.hasHaltingErrors());\n   }\n \n   private void testSame(String original) {\n   private Compiler compile(String[] original) {\n     CompilerRunner runner = new CompilerRunner(new String[] {});\n     Compiler compiler = runner.createCompiler();\n+    lastCompiler = compiler;\n     JSSourceFile[] inputs = new JSSourceFile[original.length];\n     for (int i = 0; i < original.length; i++) {\n       inputs[i] = JSSourceFile.fromCode(\"input\" + i, original[i]);\n--- a/test/com/google/javascript/jscomp/DeadAssignmentsEliminationTest.java\n+++ b/test/com/google/javascript/jscomp/DeadAssignmentsEliminationTest.java\n \n     inFunction(\"var x,y; if( (x=1)+(y=2) > 3){}\",\n         \"var x,y; if( 1+2 > 3){}\");\n-\n+  }\n+\n+  public void testUsedAsConditionsInSwitchStatements() {\n     inFunction(\"var x; switch(x=1){}\",\"var x; switch(1){}\");\n     inFunction(\"var x; switch(x){case(x=1):break;}\",\n         \"var x; switch(x){case(1):break;}\");\n+    \n+    inFunction(\"var x,y; switch(y) { case (x += 1): break; case (x): break;}\");\n+    \n+    inFunction(\"var x,y; switch(y) { case (x = 1): break; case (2): break;}\",\n+               \"var x,y; switch(y) { case (1): break; case (2): break;}\");\n+    inFunction(\"var x,y; switch(y) { case (x+=1): break; case (x=2): break;}\",\n+               \"var x,y; switch(y) { case (x+1): break; case (2): break;}\");\n   }\n \n   public void testAssignmentInReturn() {\n    */\n   public void testAssignAndReadInCondition() {\n     inFunction(\"var a, b; if ((a = 1) && (b = a)) {b}\");\n-    // But we missed an opportunity here.\n-    inFunction(\"var a, b; if ((b = a) && (a = 1)) {b}\");\n+    inFunction(\"var a, b; if ((b = a) && (a = 1)) {b}\",\n+               \"var a, b; if ((b = a) && (1)) {b}\");\n   }\n \n   public void testParameters() {\n     inFunction(\"var x = 0; print(x); x = 1; var y = function(){}; y()\");\n   }\n \n+  public void testSelfReAssignment() {\n+    inFunction(\"var x; x = x;\", \"var x; x\");\n+  }\n+  \n+  public void testSelfIncrement() {\n+    inFunction(\"var x; x = x + 1;\", \"var x; x + 1\");\n+  }\n+  \n+  public void testAssignmentOp() {\n+    // We have remove constant expressions that cleans this one up.\n+    inFunction(\"var x; x += foo()\", \"var x; x + foo()\");\n+  }\n+  \n+  public void testAssignmentOpUsedAsLhs() {\n+    inFunction(\"var x,y; y = x += foo(); print(y)\",\n+               \"var x,y; y = x +  foo(); print(y)\");\n+  }\n+  \n+  public void testAssignmentOpUsedAsCondition() {    \n+    inFunction(\"var x; if(x += foo()) {}\",\n+               \"var x; if(x +  foo()) {}\");\n+\n+    inFunction(\"var x; if((x += foo()) > 1) {}\",\n+               \"var x; if((x +  foo()) > 1) {}\");\n+    \n+    // Not in a while because this happens every loop.\n+    inFunction(\"var x; while((x += foo()) > 1) {}\");\n+    \n+    inFunction(\"var x; for(;--x;){}\");\n+    inFunction(\"var x; for(;x--;){}\");\n+    inFunction(\"var x; for(;x -= 1;){}\");\n+    inFunction(\"var x; for(;x = 0;){}\", \"var x; for(;0;){}\");\n+    \n+    inFunction(\"var x; for(;;--x){}\");\n+    inFunction(\"var x; for(;;x--){}\");\n+    inFunction(\"var x; for(;;x -= 1){}\");\n+    inFunction(\"var x; for(;;x = 0){}\", \"var x; for(;;0){}\");\n+    \n+    // TODO(user): Add support of INC and DEC.\n+    inFunction(\"var x; for(--x;;){}\");\n+    inFunction(\"var x; for(x--;;){}\");\n+    inFunction(\"var x; for(x -= 1;;){}\", \"var x; for(x - 1;;){}\");\n+    inFunction(\"var x; for(x = 0;;){}\", \"var x; for(0;;){}\");\n+  }\n+  \n+  public void testDeadIncrement() {\n+    // TODO(user): Optimize this.\n+    inFunction(\"var x; x ++\");\n+    inFunction(\"var x; x --\");\n+  }\n+  \n+  public void testDeadButAlivePartiallyWithinTheExpression() {\n+    inFunction(\"var x; x = 100, print(x), x = 101;\",\n+               \"var x; x = 100, print(x),     101;\");\n+    inFunction(\"var x; x = 100, print(x), print(x), x = 101;\",\n+               \"var x; x = 100, print(x), print(x),     101;\");\n+    inFunction(\"var x; x = 100, print(x), x = 0, print(x), x = 101;\",\n+               \"var x; x = 100, print(x), x = 0, print(x),     101;\");\n+  }\n+  \n+  public void testMutipleDeadAssignmentsButAlivePartiallyWithinTheExpression() {\n+    inFunction(\"var x; x = 1, x = 2, x = 3, x = 4, x = 5,\" + \n+               \"  print(x), x = 0, print(x), x = 101;\",\n+               \n+               \"var x; 1, 2, 3, 4, x = 5, print(x), x = 0, print(x), 101;\");\n+  }\n+  \n+\n+  public void testDeadPartiallyWithinTheExpression() {\n+    // Sadly, this is not covered. We don't suspect this would happend too\n+    // often.\n+    inFunction(\"var x; x = 100, x = 101; print(x);\");\n+  }\n+  \n+  public void testAssignmentChain() {\n+    inFunction(\"var a,b,c,d,e; a = b = c = d = e = 1\",\n+               \"var a,b,c,d,e; 1\");\n+    inFunction(\"var a,b,c,d,e; a = b = c = d = e = 1; print(c)\",\n+               \"var a,b,c,d,e;         c = 1        ; print(c)\");\n+    inFunction(\"var a,b,c,d,e; a = b = c = d = e = 1; print(a + e)\",\n+               \"var a,b,c,d,e; a =             e = 1; print(a + e)\");\n+    inFunction(\"var a,b,c,d,e; a = b = c = d = e = 1; print(b + d)\",\n+               \"var a,b,c,d,e;     b =     d     = 1; print(b + d)\");\n+    inFunction(\"var a,b,c,d,e; a = b = c = d = e = 1; print(a + b + d + e)\",\n+               \"var a,b,c,d,e; a = b =     d = e = 1; print(a + b + d + e)\");\n+    inFunction(\"var a,b,c,d,e; a = b = c = d = e = 1; print(a+b+c+d+e)\");\n+  }\n+  \n+  public void testAssignmentOpChain() {\n+    inFunction(\"var a,b,c,d,e; a = b = c += d = e = 1\",\n+               \"var a,b,c,d,e;         c + 1\");\n+    inFunction(\"var a,b,c,d,e; a = b = c += d = e = 1;  print(e)\",\n+               \"var a,b,c,d,e;         c +     (e = 1); print(e)\");\n+    inFunction(\"var a,b,c,d,e; a = b = c += d = e = 1;  print(d)\",\n+               \"var a,b,c,d,e;         c + (d = 1)  ;   print(d)\");\n+    inFunction(\"var a,b,c,d,e; a = b = c += d = e = 1;  print(a)\",\n+               \"var a,b,c,d,e; a =     c +          1;  print(a)\");\n+  }\n+  \n+  public void testIncDecInSubExpressions() {\n+    inFunction(\"var a; a = 1, a++; a\");\n+  }\n+  \n+  public void testNestedReassignments() {\n+    inFunction(\"var a; a = (a = 1)\", \"var a; 1\");\n+    inFunction(\"var a; a = (a *= 2)\", \"var a; a*2\");\n+    \n+    // TODO(user): ++ not supported.\n+    \n+    // Note a = (a++) is not same as a++. Only if 'a' is dead.\n+    inFunction(\"var a; a = (a++)\", \"var a; a++\");\n+    inFunction(\"var a; a = (++a)\", \"var a; ++a\");\n+    \n+    inFunction(\"var a; a = (b = (a = 1))\", \"var a; b = 1\");\n+    inFunction(\"var a; a = (b = (a *= 2))\", \"var a; b = a * 2\");\n+    inFunction(\"var a; a = (b = (a++))\", \"var a; b=a++\");\n+    inFunction(\"var a; a = (b = (++a))\", \"var a; b=++a\");\n+    \n+    // Include b as local.\n+    inFunction(\"var a,b; a = (b = (a = 1))\", \"var a,b; 1\");\n+    inFunction(\"var a,b; a = (b = (a *= 2))\", \"var a,b; a * 2\");\n+    inFunction(\"var a,b; a = (b = (a++))\", \"var a,b; a++\");\n+    inFunction(\"var a,b; a = (b = (++a))\", \"var a,b; ++a\");\n+    \n+    inFunction(\"var a; a += (a++)\", \"var a; a+a++\");\n+    inFunction(\"var a; a += (++a)\", \"var a; a+ ++a\");\n+    \n+    // Include b as local.\n+    inFunction(\"var a,b; a += (b = (a = 1))\", \"var a,b; a + 1\");\n+    inFunction(\"var a,b; a += (b = (a *= 2))\", \"var a,b; a + (a * 2)\");\n+    inFunction(\"var a,b; a += (b = (a++))\", \"var a,b; a + a++\");\n+    inFunction(\"var a,b; a += (b = (++a))\", \"var a,b; a+(++a)\"); \n+  }\n+  \n+  public void testIncrementalReassignmentInForLoops() {\n+    inFunction(\"for(;x+=1;x+=1) {}\");\n+    inFunction(\"for(;x;x+=1){}\");\n+    inFunction(\"for(;x+=1;){foo(x)}\");\n+    inFunction(\"for(;1;x+=1){foo(x)}\");\n+  }\n+  \n   private void inFunction(String src) {\n     inFunction(src, src);\n   }\n--- a/test/com/google/javascript/jscomp/OptimizeArgumentsArrayTest.java\n+++ b/test/com/google/javascript/jscomp/OptimizeArgumentsArrayTest.java\n        + \"  {alert(r0 + r1 + opt_1 + opt_2 + p1); }\");\n   }\n \n-  public void testNotAllIndexKnown() {\n-    test(\"function foo(  ) {alert(arguments[0] + arguments[x]);}\",\n-         \"function foo(p0) {alert(          p0 + arguments[x]);}\");\n-  }\n-\n   public void testInnerFunctions() {\n     test(\"function f() { function b(  ) { arguments[0]  }}\",\n          \"function f() { function b(p0) {            p0 }}\");\n   public void testNoOptimizationWhenGetProp() {\n     testSame(\"function f() { arguments[0]; arguments.size }\");\n   }\n+  \n+  public void testNoOptimizationWhenIndexIsNotNumberConstant() {\n+    testSame(\"function f() { arguments[0]; arguments['callee'].length}\");\n+    testSame(\"function f() { arguments[0]; arguments.callee.length}\");\n+    testSame(\n+        \"function f() { arguments[0]; var x = 'callee'; arguments[x].length}\");\n+  }\n }\n--- a/test/com/google/javascript/jscomp/RenameVarsTest.java\n+++ b/test/com/google/javascript/jscomp/RenameVarsTest.java\n   private boolean withClosurePass = false;\n   private boolean localRenamingOnly = false;\n   private boolean preserveAnonymousFunctionNames = false;\n-\n+  private boolean useGoogleCodingConvention = true;\n+\n+  @Override\n+  protected CodingConvention getCodingConvention() {\n+    if (useGoogleCodingConvention) {\n+      return new GoogleCodingConvention();\n+    } else {\n+      return new DefaultCodingConvention();\n+    }\n+  }\n+  \n   @Override\n   protected CompilerPass getProcessor(Compiler compiler) {\n     if (withClosurePass) {\n     test(\"var goog, a, b; goog.exportSymbol(a, b);\",\n          \"var a, b, c; a.exportSymbol(b, c);\");\n   }\n+  \n+  public void testDollarSignSuperExport() {\n+    useGoogleCodingConvention = false;\n+    // See http://code.google.com/p/closure-compiler/issues/detail?id=32\n+    test(\"var x = function($super,duper,$fantastic){}\",\n+         \"var c = function($super,    a,        b){}\");\n+    \n+    localRenamingOnly = false;\n+    test(\"var $super = 1\", \"var a = 1\");\n+\n+    useGoogleCodingConvention = true;\n+    test(\"var x = function($super,duper,$fantastic){}\",\n+         \"var d = function(a,     b,    c        ){}\");\n+  }\n \n   private void testRenameMapUsingOldMap(String input, String expected,\n                                         VariableMap expectedMap) {\n--- a/test/com/google/javascript/jscomp/SimpleDefinitionFinderTest.java\n+++ b/test/com/google/javascript/jscomp/SimpleDefinitionFinderTest.java\n \n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Multiset;\n-import com.google.common.collect.Multisets;\n import com.google.common.collect.Sets;\n+import com.google.common.collect.TreeMultiset;\n import com.google.javascript.jscomp.DefinitionsRemover.Definition;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.Node;\n         sb.append(\" \");\n         sb.append(node.getQualifiedName());\n         sb.append(\" -> \");\n-        Multiset<String> defstrs = Multisets.newTreeMultiset();\n+        Multiset<String> defstrs = TreeMultiset.create();\n         for (Definition def : defs) {\n           Node rValue = def.getRValue();\n           if (rValue != null) {", "timestamp": 1258503689, "metainfo": ""}