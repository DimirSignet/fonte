{"sha": "643bd6436989e7a957ccefeed8ea5ecc8e84a748", "log": "Infer properties of anonymous objects  R=zhuyi DELTA=106  (98 added, 6 deleted, 2 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1996   ", "commit": "\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n       if (functionType instanceof FunctionType) {\n         FunctionType fnType = (FunctionType) functionType;\n         n.setJSType(fnType.getReturnType());\n-        updateTypeOfParametersOnClosure(n, fnType);\n+        updateTypeOfParameters(n, fnType);\n         updateTypeOfThisOnClosure(n, fnType);\n       } else if (functionType.equals(getNativeType(CHECKED_UNKNOWN_TYPE))) {\n         n.setJSType(getNativeType(CHECKED_UNKNOWN_TYPE));\n    * For functions with function parameters, type inference will set the type of\n    * a function literal argument from the function parameter type.\n    */\n-  private void updateTypeOfParametersOnClosure(Node n, FunctionType fnType) {\n+  private void updateTypeOfParameters(Node n, FunctionType fnType) {\n     int i = 0;\n     int childCount = n.getChildCount();\n     for (Node iParameter : fnType.getParameters()) {\n+      if (i + 1 >= childCount) {\n+        // TypeCheck#visitParametersList will warn so we bail.\n+        return;\n+      }\n+\n       JSType iParameterType = iParameter.getJSType();\n+      Node iArgument = n.getChildAtIndex(i + 1);\n+      JSType iArgumentType = getJSType(iArgument);\n+      inferPropertyTypesToMatchConstraint(iArgumentType, iParameterType);\n+\n       if (iParameterType instanceof FunctionType) {\n         FunctionType iParameterFnType = (FunctionType) iParameterType;\n \n-        if (i + 1 >= childCount) {\n-          // TypeCheck#visitParametersList will warn so we bail.\n-          return;\n-        }\n-        Node iArgument = n.getChildAtIndex(i + 1);\n-        JSType iArgumentType = getJSType(iArgument);\n         if (iArgument.getType() == Token.FUNCTION &&\n             iArgumentType instanceof FunctionType &&\n             iArgument.getJSDocInfo() == null) {\n   }\n \n   /**\n+   * Suppose X is an object with inferred properties.\n+   * Suppose also that X is used in a way where it would only type-check\n+   * correctly if some of those properties are widened.\n+   * Then we should be polite and automatically widen X's properties for him.\n+   *\n+   * For a concrete example, consider:\n+   * param x {{prop: (number|undefined)}}\n+   * function f(x) {}\n+   * f({});\n+   *\n+   * If we give the anonymous object an inferred property of (number|undefined),\n+   * then this code will type-check appropriately.\n+   */\n+  private void inferPropertyTypesToMatchConstraint(\n+      JSType type, JSType constraint) {\n+    ObjectType constraintObj =\n+        ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n+    if (constraintObj != null && constraintObj.isRecordType()) {\n+      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n+      for (String prop : constraintObj.getOwnPropertyNames()) {\n+        JSType propType = constraintObj.getPropertyType(prop);\n+        if (objType != null && !objType.isPropertyTypeDeclared(prop)) {\n+          JSType typeToInfer = propType;\n+          if (!objType.hasProperty(prop)) {\n+            typeToInfer = registry.createUnionType(\n+                getNativeType(VOID_TYPE), propType);\n+          }\n+          objType.defineInferredProperty(prop, typeToInfer, false, null);\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n    * If we access a property of a symbol, then that symbol is not\n    * null or undefined.\n    */\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"/** @type { {impossibleProperty} } */ var y = new ActiveXObject();\");\n   }\n \n+  public void testRecordType1() throws Exception {\n+    testTypes(\n+        \"/** @param {{prop: number}} x */\" +\n+        \"function f(x) {}\" +\n+        \"f({});\",\n+        \"actual parameter 1 of f does not match formal parameter\\n\" +\n+        \"found   : {prop: (number|undefined)}\\n\" +\n+        \"required: {prop: number}\");\n+  }\n+\n+  public void testRecordType2() throws Exception {\n+    testTypes(\n+        \"/** @param {{prop: (number|undefined)}} x */\" +\n+        \"function f(x) {}\" +\n+        \"f({});\");\n+  }\n+\n+  public void testRecordType3() throws Exception {\n+    testTypes(\n+        \"/** @param {{prop: number}} x */\" +\n+        \"function f(x) {}\" +\n+        \"f({prop: 'x'});\",\n+        \"actual parameter 1 of f does not match formal parameter\\n\" +\n+        \"found   : {prop: (number|string)}\\n\" +\n+        \"required: {prop: number}\");\n+  }\n+\n+  public void testRecordType4() throws Exception {\n+    // Notice that we do not do flow-based inference on the object type:\n+    // We don't try to prove that x.prop may not be string until x\n+    // gets passed to g.\n+    testClosureTypesMultipleWarnings(\n+        \"/** @param {{prop: (number|undefined)}} x */\" +\n+        \"function f(x) {}\" +\n+        \"/** @param {{prop: (string|undefined)}} x */\" +\n+        \"function g(x) {}\" +\n+        \"var x = {}; f(x); g(x);\",\n+        Lists.newArrayList(\n+            \"actual parameter 1 of f does not match formal parameter\\n\" +\n+            \"found   : {prop: (number|string|undefined)}\\n\" +\n+            \"required: {prop: (number|undefined)}\",\n+            \"actual parameter 1 of g does not match formal parameter\\n\" +\n+            \"found   : {prop: (number|string|undefined)}\\n\" +\n+            \"required: {prop: (string|undefined)}\"));\n+  }\n+\n+  public void testRecordType5() throws Exception {\n+    testTypes(\n+        \"/** @param {{prop: (number|undefined)}} x */\" +\n+        \"function f(x) {}\" +\n+        \"/** @param {{otherProp: (string|undefined)}} x */\" +\n+        \"function g(x) {}\" +\n+        \"var x = {}; f(x); g(x);\");\n+  }\n+\n   public void testDuplicateRecordFields1() throws Exception {\n     testTypes(\"/**\"\n          + \"* @param {{x:string, x:number}} a\"", "timestamp": 1306165032, "metainfo": ""}