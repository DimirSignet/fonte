{"sha": "3b97e5e4212c769daa22a96094ed19b4658c8760", "log": "When expanding goog.scope aliases in type expressions, do not expand the alias until previous aliases have been expanded. fixes issue 772  R=johnlenz DELTA=49  (39 added, 1 deleted, 9 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=5126   ", "commit": "\n--- a/src/com/google/javascript/jscomp/ScopedAliases.java\n+++ b/src/com/google/javascript/jscomp/ScopedAliases.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.base.Preconditions;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n   }\n \n   private class AliasedTypeNode implements AliasUsage {\n-    private final Node aliasReference;\n-\n-    private final String correctedType;\n-\n-    AliasedTypeNode(Node aliasReference, String correctedType) {\n-      this.aliasReference = aliasReference;\n-      this.correctedType = correctedType;\n+    private final Node typeReference;\n+    private final Node aliasDefinition;\n+    private final String aliasName;\n+\n+    AliasedTypeNode(Node typeReference, Node aliasDefinition,\n+        String aliasName) {\n+      this.typeReference = typeReference;\n+      this.aliasDefinition = aliasDefinition;\n+      this.aliasName = aliasName;\n     }\n \n     @Override\n     public void applyAlias() {\n-      aliasReference.setString(correctedType);\n+      String typeName = typeReference.getString();\n+      String aliasExpanded =\n+          Preconditions.checkNotNull(aliasDefinition.getQualifiedName());\n+      Preconditions.checkState(typeName.startsWith(aliasName));\n+      typeReference.setString(typeName.replaceFirst(aliasName, aliasExpanded));\n     }\n   }\n \n         Var aliasVar = aliases.get(baseName);\n         if (aliasVar != null) {\n           Node aliasedNode = aliasVar.getInitialValue();\n-          aliasUsages.add(new AliasedTypeNode(typeNode,\n-              aliasedNode.getQualifiedName() + name.substring(endIndex)));\n+          aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode, baseName));\n         }\n       }\n \n--- a/test/com/google/javascript/jscomp/IntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/IntegrationTest.java\n         \"\");\n   }\n \n+  public void testIssue772() throws Exception {\n+    CompilerOptions options = createCompilerOptions();\n+    options.closurePass = true;\n+    options.checkTypes = true;\n+    test(\n+        options,\n+        \"/** @const */ var a = {};\" +\n+        \"/** @const */ a.b = {};\" +\n+        \"/** @const */ a.b.c = {};\" +\n+        \"goog.scope(function() {\" +\n+        \"  var b = a.b;\" +\n+        \"  var c = b.c;\" +\n+        \"  /** @typedef {string} */\" +\n+        \"  c.MyType;\" +\n+        \"  /** @param {c.MyType} x The variable. */\" +\n+        \"  c.myFunc = function(x) {};\" +\n+        \"});\",\n+        \"/** @const */ var a = {};\" +\n+        \"/** @const */ a.b = {};\" +\n+        \"/** @const */ a.b.c = {};\" +\n+        \"a.b.c.MyType;\" +\n+        \"a.b.c.myFunc = function(x) {};\");\n+  }\n+\n   public void testCodingConvention() {\n     Compiler compiler = new Compiler();\n     compiler.initOptions(new CompilerOptions());\n--- a/test/com/google/javascript/jscomp/ScopedAliasesTest.java\n+++ b/test/com/google/javascript/jscomp/ScopedAliasesTest.java\n         \"var x = goog.Timer;\",\n         \"/** @param draggable */ types.actual;\"\n         + \"/** @param draggable */ types.expected;\");\n+  }\n+\n+  public void testIssue772() {\n+    testTypes(\n+        \"var b = a.b;\" +\n+        \"var c = b.c;\",\n+        \"/** @param {c.MyType} x */ types.actual;\" +\n+        \"/** @param {a.b.c.MyType} x */ types.expected;\");\n   }\n \n   // TODO(robbyw): What if it's recursive?  var goog = goog.dom;", "timestamp": 1341850716, "metainfo": ""}