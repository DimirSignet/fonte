{"sha": "d34e8be041cb7fbdfa1f45f663de15396e3ce13a", "log": "Ant: support <define/> replacements Contributed by jhansche Fixes issue 567  R=bolinfest    ", "commit": "\n--- a/src/com/google/javascript/jscomp/ant/CompileTask.java\n+++ b/src/com/google/javascript/jscomp/ant/CompileTask.java\n import org.apache.tools.ant.Project;\n import org.apache.tools.ant.Task;\n import org.apache.tools.ant.types.FileList;\n+import org.apache.tools.ant.types.Parameter;\n import org.apache.tools.ant.types.Path;\n \n import java.io.File;\n   private boolean replaceProperties;\n   private String replacePropertiesPrefix;\n   private File outputFile;\n+  private final List<Parameter> defineParams;\n   private final List<FileList> externFileLists;\n   private final List<FileList> sourceFileLists;\n   private final List<Path> sourcePaths;\n     this.generateExports = false;\n     this.replaceProperties = false;\n     this.replacePropertiesPrefix = \"closure.define.\";\n+    this.defineParams = Lists.newLinkedList();\n     this.externFileLists = Lists.newLinkedList();\n     this.sourceFileLists = Lists.newLinkedList();\n     this.sourcePaths = Lists.newLinkedList();\n   }\n \n   /**\n-   * Whether to replace @define lines with properties\n+   * Whether to replace {@code @define} lines with properties\n    */\n   public void setReplaceProperties(boolean value) {\n     this.replaceProperties = value;\n       convertPropertiesMap(options);\n     }\n \n+    convertDefineParameters(options);\n+\n     return options;\n   }\n \n+  /**\n+   * Creates a new {@code <define/>} nested element. Supports name and value\n+   * attribtues.\n+   */\n+  public Parameter createDefine() {\n+    Parameter param = new Parameter();\n+    defineParams.add(param);\n+    return param;\n+  }\n+\n+  /**\n+   * Converts {@code <define/>} nested elements into Compiler {@code @define}\n+   * replacements. Note: unlike project properties, {@code <define/>} elements\n+   * do not need to be named starting with the replacement prefix.\n+   */\n+  private void convertDefineParameters(CompilerOptions options) {\n+    for (Parameter p : defineParams) {\n+      String key = p.getName();\n+      Object value = p.getValue();\n+\n+      if (!setDefine(options, key, value)) {\n+        log(\"Unexpected @define value for name=\" + key + \"; value=\" + value);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Converts project properties beginning with the replacement prefix\n+   * into Compiler {@code @define} replacements.\n+   *\n+   * @param options\n+   */\n   private void convertPropertiesMap(CompilerOptions options) {\n     Map<String, Object> props = getProject().getProperties();\n     for (Map.Entry<String, Object> entry : props.entrySet()) {\n       if (key.startsWith(replacePropertiesPrefix)) {\n         key = key.substring(replacePropertiesPrefix.length());\n \n-        if (value instanceof String) {\n-          final boolean isTrue = \"true\".equals(value);\n-          final boolean isFalse = \"false\".equals(value);\n-\n-          if (isTrue || isFalse) {\n-            options.setDefineToBooleanLiteral(key, isTrue);\n-          } else {\n-            try {\n-              double dblTemp = Double.parseDouble((String) value);\n-              options.setDefineToDoubleLiteral(key, dblTemp);\n-            } catch (NumberFormatException nfe) {\n-              // Not a number, assume string\n-              options.setDefineToStringLiteral(key, (String) value);\n-            }\n-          }\n-        } else if (value instanceof Boolean) {\n-          options.setDefineToBooleanLiteral(key, (Boolean) value);\n-        } else if (value instanceof Integer) {\n-          options.setDefineToNumberLiteral(key, (Integer) value);\n-        } else if (value instanceof Double) {\n-          options.setDefineToDoubleLiteral(key, (Double) value);\n-        } else {\n+        if (!setDefine(options, key, value)) {\n           log(\"Unexpected property value for key=\" + key + \"; value=\" + value);\n         }\n       }\n     }\n+  }\n+\n+  /**\n+   * Maps Ant-style values (e.g., from Properties) into expected\n+   * Closure {@code @define} literals\n+   *\n+   * @return True if the {@code @define} replacement succeeded, false if\n+   *         the variable's value could not be mapped properly.\n+   */\n+  private boolean setDefine(CompilerOptions options,\n+      String key, Object value) {\n+    boolean success = false;\n+\n+    if (value instanceof String) {\n+      final boolean isTrue = \"true\".equals(value);\n+      final boolean isFalse = \"false\".equals(value);\n+\n+      if (isTrue || isFalse) {\n+        options.setDefineToBooleanLiteral(key, isTrue);\n+      } else {\n+        try {\n+          double dblTemp = Double.parseDouble((String) value);\n+          options.setDefineToDoubleLiteral(key, dblTemp);\n+        } catch (NumberFormatException nfe) {\n+          // Not a number, assume string\n+          options.setDefineToStringLiteral(key, (String) value);\n+        }\n+      }\n+\n+      success = true;\n+    } else if (value instanceof Boolean) {\n+      options.setDefineToBooleanLiteral(key, (Boolean) value);\n+      success = true;\n+    } else if (value instanceof Integer) {\n+      options.setDefineToNumberLiteral(key, (Integer) value);\n+      success = true;\n+    } else if (value instanceof Double) {\n+      options.setDefineToDoubleLiteral(key, (Double) value);\n+      success = true;\n+    }\n+\n+    return success;\n   }\n \n   private Compiler createCompiler(CompilerOptions options) {", "timestamp": 1318023282, "metainfo": ""}