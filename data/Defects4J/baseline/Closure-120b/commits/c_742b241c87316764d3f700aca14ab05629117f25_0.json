{"sha": "742b241c87316764d3f700aca14ab05629117f25", "log": "Merge remote-tracking branch 'GoogleCode/master'", "commit": "\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n    * Infer the template type from the doc info.\n    */\n   FunctionTypeBuilder inferTemplateTypeName(\n-      @Nullable JSDocInfo info) {\n+      @Nullable JSDocInfo info, JSType ownerType) {\n     if (info != null &&  !info.getTemplateTypeNames().isEmpty()) {\n       ImmutableList.Builder<TemplateType> builder = ImmutableList.builder();\n       for (String key : info.getTemplateTypeNames()) {\n     } else {\n       templateTypeNames = ImmutableList.of();\n     }\n-    typeRegistry.setTemplateTypeNames(templateTypeNames);\n+\n+    ImmutableList<TemplateType> keys = templateTypeNames;\n+    if (ownerType != null) {\n+      ImmutableList<TemplateType> ownerTypeKeys =\n+          ownerType.getTemplateTypeMap().getTemplateKeys();\n+      if (!ownerTypeKeys.isEmpty()) {\n+        ImmutableList.Builder<TemplateType> builder = ImmutableList.builder();\n+        builder.addAll(templateTypeNames);\n+        builder.addAll(ownerTypeKeys);\n+        keys = builder.build();\n+      }\n+    }\n+\n+    if (!keys.isEmpty()) {\n+      typeRegistry.setTemplateTypeNames(keys);\n+    }\n     return this;\n   }\n \n       fnType = getOrCreateConstructor();\n     } else if (isInterface) {\n       fnType = typeRegistry.createInterfaceType(\n-          fnName, contents.getSourceNode());\n+          fnName, contents.getSourceNode(), classTypeParameterNames);\n       if (getScopeDeclaredIn().isGlobal() && !fnName.isEmpty()) {\n         typeRegistry.declareType(fnName, fnType.getInstanceType());\n       }\n--- a/src/com/google/javascript/jscomp/RhinoErrorReporter.java\n+++ b/src/com/google/javascript/jscomp/RhinoErrorReporter.java\n import com.google.common.collect.ImmutableMap;\n import com.google.javascript.jscomp.CheckLevel;\n import com.google.javascript.rhino.ErrorReporter;\n-import com.google.javascript.rhino.ScriptRuntime;\n+import com.google.javascript.rhino.SimpleErrorReporter;\n \n import java.util.Map;\n import java.util.Map.Entry;\n             DUPLICATE_PARAM)\n \n         // Unknown @annotations.\n-        .put(replacePlaceHolders(ScriptRuntime.getMessage0(\"msg.bad.jsdoc.tag\")),\n+        .put(replacePlaceHolders(\n+            SimpleErrorReporter.getMessage0(\"msg.bad.jsdoc.tag\")),\n             BAD_JSDOC_ANNOTATION)\n \n         .put(Pattern.compile(\"^Type annotations are not allowed here.*\"),\n--- a/src/com/google/javascript/jscomp/StatementFusion.java\n+++ b/src/com/google/javascript/jscomp/StatementFusion.java\n   }\n \n   // exp1, exp1\n-  private static Node fuseExpressionIntoExpression(Node exp1, Node exp2) {\n+  protected static Node fuseExpressionIntoExpression(Node exp1, Node exp2) {\n     Node comma = new Node(Token.COMMA, exp1);\n     comma.copyInformationFrom(exp2);\n \n     }\n   }\n \n-  private static void fuseExpresssonIntoFirstChild(Node exp, Node stmt) {\n+  protected static void fuseExpresssonIntoFirstChild(Node exp, Node stmt) {\n     Node val = stmt.removeFirstChild();\n     Node comma = fuseExpressionIntoExpression(exp, val);\n     stmt.addChildToFront(comma);\n   }\n \n-  private static void fuseExpresssonIntoSecondChild(Node exp, Node stmt) {\n+  protected static void fuseExpresssonIntoSecondChild(Node exp, Node stmt) {\n     Node val = stmt.removeChildAfter(stmt.getFirstChild());\n     Node comma = fuseExpressionIntoExpression(exp, val);\n     stmt.addChildAfter(comma, stmt.getFirstChild());\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n     switch (n.getType()) {\n       case Token.CAST:\n         Node expr = n.getFirstChild();\n-        ensureTyped(t, n, getJSType(expr));\n-\n-        // If the cast, tightens the type apply it, so it is available post\n-        // normalization.\n+        JSType exprType = getJSType(expr);\n         JSType castType = getJSType(n);\n-        JSType exprType = getJSType(expr);\n-        if (castType.isSubtype(exprType)) {\n+\n+        // TODO(johnlenz): determine if we can limit object literals in some\n+        // way.\n+        if (!expr.isObjectLit()) {\n+          validator.expectCanCast(t, n, castType, exprType);\n+        }\n+        ensureTyped(t, n, castType);\n+\n+        if (castType.isSubtype(exprType) || expr.isObjectLit()) {\n           expr.setJSType(castType);\n         }\n         break;\n     Preconditions.checkState(!n.isFunction() ||\n             type.isFunctionType() ||\n             type.isUnknownType());\n+    // TODO(johnlenz): this seems like a strange place to check \"@implicitCast\"\n     JSDocInfo info = n.getJSDocInfo();\n     if (info != null) {\n-      if (info.hasType()) {\n-        // TODO(johnlenz): Change this so that we only look for casts on CAST\n-        // nodes one the misplaced type annotation warning is on by default and\n-        // people have been given a chance to fix them.  As is, this is here\n-        // simply for legacy casts.\n-        JSType infoType = info.getType().evaluate(t.getScope(), typeRegistry);\n-        validator.expectCanCast(t, n, infoType, type);\n-        type = infoType;\n-      }\n-\n       if (info.isImplicitCast() && !inExterns) {\n         String propName = n.isGetProp() ?\n             n.getLastChild().getString() : \"(missing)\";\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n \n       case Token.CAST:\n         scope = traverseChildren(n, scope);\n-        break;\n-    }\n-\n-    // TODO(johnlenz): remove this after the CAST node change has shaken out.\n-    if (!n.isFunction()) {\n-      JSDocInfo info = n.getJSDocInfo();\n-      if (info != null && info.hasType()) {\n-        JSType castType = info.getType().evaluate(syntacticScope, registry);\n-\n-        // A stubbed type declaration on a qualified name should take\n-        // effect for all subsequent accesses of that name,\n-        // so treat it the same as an assign to that name.\n-        if (n.isQualifiedName() &&\n-            n.getParent().isExprResult()) {\n-          updateScopeForTypeChange(scope, n, n.getJSType(), castType);\n-        }\n-\n-        n.setJSType(castType);\n-      }\n+        JSDocInfo info = n.getJSDocInfo();\n+        if (info != null && info.hasType()) {\n+          n.setJSType(info.getType().evaluate(syntacticScope, registry));\n+        }\n+        break;\n     }\n \n     return scope;\n     }\n   }\n \n+  private static class TemplateTypeMapReplacer extends ModificationVisitor {\n+    private final TemplateTypeMap replacements;\n+    boolean madeChanges = false;\n+\n+    TemplateTypeMapReplacer(\n+        JSTypeRegistry registry, TemplateTypeMap replacements) {\n+      super(registry);\n+      this.replacements = replacements;\n+    }\n+\n+    @Override\n+    public JSType caseTemplateType(TemplateType type) {\n+      if (replacements.hasTemplateKey(type)) {\n+        madeChanges = true;\n+        JSType replacement = replacements.getTemplateType(type);\n+        return replacements.getTemplateType(type);\n+      } else {\n+        return type;\n+      }\n+    }\n+  }\n+\n   /**\n    * For functions with function(this: T, ...) and T as parameters, type\n    * inference will set the type of this on a function literal argument to the\n       JSType foundType = objType.findPropertyType(propName);\n       if (foundType != null) {\n         propertyType = foundType;\n+      }\n+    }\n+\n+    if (propertyType != null && objType != null) {\n+      JSType restrictedObjType = objType.restrictByNotNullOrUndefined();\n+      if (restrictedObjType.isTemplatizedType()\n+          && propertyType.hasAnyTemplateTypes()) {\n+        TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n+        TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n+            registry, typeMap);\n+        propertyType = propertyType.visit(replacer);\n       }\n     }\n \n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n       \"found   : {1}\\n\" +\n       \"required: {2}\";\n \n-  // TODO(johnlenz): reenable this after after the next release.\n   static final DiagnosticType INVALID_CAST =\n-      DiagnosticType.disabled(\"JSC_INVALID_CAST\",\n+      DiagnosticType.warning(\"JSC_INVALID_CAST\",\n           \"invalid cast - must be a subtype or supertype\\n\" +\n           \"from: {0}\\n\" +\n           \"to  : {1}\");\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n import com.google.javascript.rhino.jstype.ObjectType;\n import com.google.javascript.rhino.jstype.Property;\n+import com.google.javascript.rhino.jstype.TemplateType;\n \n import java.util.Iterator;\n import java.util.List;\n       JSType jsType = null;\n       if (info != null) {\n         if (info.hasType()) {\n+\n+          ImmutableList<TemplateType> ownerTypeKeys = ImmutableList.of();\n+          Node ownerNode = NodeUtil.getBestLValueOwner(node);\n+          String ownerName = NodeUtil.getBestLValueName(ownerNode);\n+          ObjectType ownerType = null;\n+          if (ownerName != null) {\n+            Var ownerVar = scope.getVar(ownerName);\n+            if (ownerVar != null) {\n+              ownerType = getPrototypeOwnerType(\n+                  ObjectType.cast(ownerVar.getType()));\n+              if (ownerType != null) {\n+                ownerTypeKeys =\n+                    ownerType.getTemplateTypeMap().getTemplateKeys();\n+              }\n+            }\n+          }\n+\n+          if (!ownerTypeKeys.isEmpty()) {\n+            typeRegistry.setTemplateTypeNames(ownerTypeKeys);\n+          }\n+\n           jsType = info.getType().evaluate(scope, typeRegistry);\n+\n+          if (!ownerTypeKeys.isEmpty()) {\n+            typeRegistry.clearTemplateTypeNames();\n+          }\n         } else if (FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n           String fnName = node.getQualifiedName();\n           jsType = createFunctionTypeFromNodes(\n             overriddenType = findOverriddenFunction(ownerType, propName);\n           }\n \n+          ObjectType prototypeOwner = getPrototypeOwnerType(ownerType);\n+\n           FunctionTypeBuilder builder =\n               new FunctionTypeBuilder(name, compiler, errorRoot, sourceName,\n                   scope)\n               .setContents(getFunctionAnalysisResults(fnRoot))\n               .inferFromOverriddenFunction(overriddenType, parametersNode)\n-              .inferTemplateTypeName(info)\n+              .inferTemplateTypeName(info, prototypeOwner)\n               .inferReturnType(info)\n               .inferInheritance(info);\n \n \n       // all done\n       return functionType;\n+    }\n+\n+    private ObjectType getPrototypeOwnerType(ObjectType ownerType) {\n+      if (ownerType != null && ownerType.isFunctionPrototypeType()) {\n+        return ownerType.getOwnerFunction();\n+      }\n+      return null;\n     }\n \n     /**\n         }\n \n         member.getFirstChild().setJSType(thisType);\n+\n+        // TODO: We are evaluating these values in the wrong scope:\n+        // https://code.google.com/p/closure-compiler/issues/detail?id=926\n+        JSType thisObjectType = thisType.toObjectType();\n+        if (thisObjectType != null) {\n+          ImmutableList<TemplateType> keys =\n+              thisObjectType.getTemplateTypeMap().getTemplateKeys();\n+          typeRegistry.setTemplateTypeNames(keys);\n+        }\n+\n         JSType jsType = getDeclaredType(info, member, value);\n+\n+        if (thisObjectType != null) {\n+          typeRegistry.clearTemplateTypeNames();\n+        }\n+\n         Node name = member.getLastChild();\n         if (jsType != null &&\n             (name.isName() || name.isString()) &&\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n   private Node maybeInjectCastNode(AstNode node, JSDocInfo info, Node irNode) {\n     if (node.getType() == com.google.javascript.rhino.head.Token.LP\n         && node instanceof ParenthesizedExpression\n-        && info.hasType()\n-        // TODO(johnlenz): for now, attach object literal type directly.\n-        && !irNode.isObjectLit()) {\n+        && info.hasType()) {\n       irNode = newNode(Token.CAST, irNode);\n     }\n     return irNode;\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n import com.google.javascript.rhino.JSDocInfoBuilder;\n import com.google.javascript.rhino.JSTypeExpression;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.ScriptRuntime;\n+import com.google.javascript.rhino.SimpleErrorReporter;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.head.ErrorReporter;\n import com.google.javascript.rhino.head.ast.Comment;\n   private class ErrorReporterParser {\n     void addParserWarning(String messageId, String messageArg, int lineno,\n         int charno) {\n-      errorReporter.warning(ScriptRuntime.getMessage1(messageId, messageArg),\n+      errorReporter.warning(\n+          SimpleErrorReporter.getMessage1(messageId, messageArg),\n           getSourceName(), lineno, null, charno);\n     }\n \n     void addParserWarning(String messageId, int lineno, int charno) {\n-      errorReporter.warning(ScriptRuntime.getMessage0(messageId),\n+      errorReporter.warning(SimpleErrorReporter.getMessage0(messageId),\n           getSourceName(), lineno, null, charno);\n     }\n \n                     int charno) {\n       errorReporter.warning(\n           \"Bad type annotation. \" +\n-          ScriptRuntime.getMessage1(messageId, messageArg),\n+          SimpleErrorReporter.getMessage1(messageId, messageArg),\n           getSourceName(), lineno, null, charno);\n     }\n \n     void addTypeWarning(String messageId, int lineno, int charno) {\n       errorReporter.warning(\n           \"Bad type annotation. \" +\n-          ScriptRuntime.getMessage0(messageId),\n+          SimpleErrorReporter.getMessage0(messageId),\n           getSourceName(), lineno, null, charno);\n     }\n   }\n--- a/src/com/google/javascript/rhino/SimpleErrorReporter.java\n+++ b/src/com/google/javascript/rhino/SimpleErrorReporter.java\n \n package com.google.javascript.rhino;\n \n+import java.text.MessageFormat;\n import java.util.ArrayList;\n import java.util.List;\n+import java.util.Locale;\n+import java.util.ResourceBundle;\n \n /**\n  * A simple {@link ErrorReporter} that collects warnings and errors and makes\n       buf.append(')');\n       return buf.toString();\n     }\n+\n+    public static String getMessage0(String messageId) {\n+      return getMessage(messageId, null);\n+    }\n+\n+    public static String getMessage1(String messageId, Object arg1) {\n+      Object[] arguments = {arg1};\n+      return getMessage(messageId, arguments);\n+    }\n+\n+    static String getMessage(String messageId, Object[] arguments) {\n+      final String defaultResource\n+          = \"rhino_ast.java.com.google.javascript.rhino.Messages\";\n+\n+      Locale locale = Locale.getDefault();\n+\n+      // ResourceBundle does caching.\n+      ResourceBundle rb = ResourceBundle.getBundle(defaultResource, locale);\n+\n+      String formatString;\n+      try {\n+          formatString = rb.getString(messageId);\n+      } catch (java.util.MissingResourceException mre) {\n+          throw new RuntimeException\n+              (\"no message resource found for message property \" + messageId);\n+      }\n+\n+      /*\n+       * It's OK to format the string, even if 'arguments' is null;\n+       * we need to format it anyway, to make double ''s collapse to\n+       * single 's.\n+       */\n+      MessageFormat formatter = new MessageFormat(formatString);\n+      return formatter.format(arguments);\n+    }\n+\n }\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n   }\n \n   /** Creates an instance for a function that is an interface. */\n-  private FunctionType(JSTypeRegistry registry, String name, Node source) {\n+  private FunctionType(JSTypeRegistry registry, String name, Node source,\n+      TemplateTypeMap typeParameters) {\n     super(registry, name,\n-        registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE));\n+        registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE),\n+        false, typeParameters);\n     setPrettyPrint(true);\n \n     Preconditions.checkArgument(source == null ||\n \n   /** Creates an instance for a function that is an interface. */\n   static FunctionType forInterface(\n-      JSTypeRegistry registry, String name, Node source) {\n-    return new FunctionType(registry, name, source);\n+      JSTypeRegistry registry, String name, Node source,\n+      TemplateTypeMap typeParameters) {\n+    return new FunctionType(registry, name, source, typeParameters);\n   }\n \n   @Override\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.ScriptRuntime;\n+import com.google.javascript.rhino.SimpleErrorReporter;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.RecordTypeBuilder.RecordProperty;\n \n    */\n   public JSType getType(StaticScope<JSType> scope, String jsTypeName,\n       String sourceName, int lineno, int charno) {\n-    JSType type = getType(jsTypeName);\n+    // Resolve template type names\n+    JSType type = null;\n+    JSType thisType = null;\n+    if (scope != null && scope.getTypeOfThis() != null) {\n+      thisType = scope.getTypeOfThis().toObjectType();\n+    }\n+    if (thisType != null) {\n+      type = thisType.getTemplateTypeMap().getTemplateTypeKeyByName(jsTypeName);\n+      if (type != null) {\n+        Preconditions.checkState(type.isTemplateType(), \"expected:\" + type);\n+        return type;\n+      }\n+    }\n+\n+    type = getType(jsTypeName);\n     if (type == null) {\n       // TODO(user): Each instance should support named type creation using\n       // interning.\n    * @param source the node defining this function. Its type\n    *     ({@link Node#getType()}) must be {@link Token#FUNCTION}.\n    */\n-  public FunctionType createInterfaceType(String name, Node source) {\n-    return FunctionType.forInterface(this, name, source);\n+  public FunctionType createInterfaceType(String name, Node source,\n+      ImmutableList<String> typeParameters) {\n+    return createInterfaceTypeInternal(name, source,\n+        createTemplateMapKeys(typeParameters));\n+  }\n+\n+  private FunctionType createInterfaceTypeInternal(String name, Node source,\n+      ImmutableList<TemplateType> typeParameters) {\n+    return FunctionType.forInterface(this, name, source,\n+        createTemplateTypeMap(typeParameters, null));\n   }\n \n   public TemplateType createTemplateType(String name) {\n                   .restrictByNotNullOrUndefined());\n           if (thisType == null) {\n             reporter.warning(\n-                ScriptRuntime.getMessage0(\n+                SimpleErrorReporter.getMessage0(\n                     current.getType() == Token.THIS ?\n                     \"msg.jsdoc.function.thisnotobject\" :\n                     \"msg.jsdoc.function.newnotobject\"),\n                 boolean addSuccess = paramBuilder.addOptionalParams(type);\n                 if (!addSuccess) {\n                   reporter.warning(\n-                      ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"),\n+                      SimpleErrorReporter.getMessage0(\n+                          \"msg.jsdoc.function.varargs\"),\n                       sourceName, arg.getLineno(), arg.getCharno());\n                 }\n               } else {\n--- a/test/com/google/javascript/jscomp/IntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/IntegrationTest.java\n     WarningLevel warnings = WarningLevel.VERBOSE;\n     warnings.setOptionsForWarningLevel(options);\n \n-    int numAdds = 4750;\n+    int numAdds = 4500;\n     StringBuilder original = new StringBuilder(\"var x = 0\");\n     for (int i = 0; i < numAdds; i++) {\n       original.append(\" + 1\");\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n           \"var x = /** @type {Object|number} */ (\" +\n           \"  {/** @type {string} */ foo: 3});\" +\n         \"}\",\n-        \"assignment to property foo of Object\\n\" +\n+        \"assignment to property foo of {foo: string}\\n\" +\n         \"found   : number\\n\" +\n         \"required: string\");\n   }\n     // Mostly verifying that rhino actually understands these JsDocs.\n     testTypes(\"/** @constructor */ function Foo() {} \\n\" +\n         \"/** @type {Foo} */ var x = /** @type {Foo} */ ({})\");\n-  }\n-\n-  public void testCast18() throws Exception {\n-    // Mostly verifying that legacy annotations are applied\n-    // despite the parser warning.\n-    testTypes(\"/** @constructor */ function Foo() {} \\n\" +\n-        \"/** @type {Foo} */ var x = (/** @type {Foo} */ {})\",\n-        \"Type annotations are not allowed here. \" +\n-        \"Are you missing parentheses?\");\n-\n-    // Not really encourage because of possible ambiguity but it works.\n-    testTypes(\"/** @constructor */ function Foo() {} \\n\" +\n-        \"/** @type {Foo} */ var x = /** @type {Foo} */ {}\",\n-        \"Type annotations are not allowed here. \" +\n-        \"Are you missing parentheses?\");\n   }\n \n   public void testCast19() throws Exception {\n         \"required: Object\");\n   }\n \n+  public void testTemplateType9() throws Exception {\n+    // verify interface type parameters are recognised.\n+    testTypes(\n+        \"/** @interface \\n\" +\n+        \" * @classTemplate S,T\\n\" +\n+        \" */\\n\" +\n+        \"function Bar() {}\\n\" +\n+        \"/**\" +\n+        \" * @param {Bar.<T>} bar \\n\" +\n+        \" * @return {T} \\n\" +\n+        \" * @template T\\n\" +\n+        \" */\\n\" +\n+        \"function fn(bar) {}\\n\" +\n+        \"/** @param {Bar.<number>} bar */ function g(bar) {\" +\n+        \"  /** @type {!Object} */ var x = fn(bar);\" +\n+        \"}\",\n+        \"initializing variable\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: Object\");\n+  }\n+\n   public void disable_testBadTemplateType4() throws Exception {\n     // TODO(johnlenz): Add a check for useless of template types.\n     // Unless there are at least two references to a Template type in\n--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n         findNameType(\"result\", globalScope).toString());\n   }\n \n+  public void testClassTemplateType1() {\n+    // Verify that template types used in method signature are resolved.\n+    testSame(\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @classTemplate T\\n\" +\n+        \" */\\n\" +\n+        \"function C() {};\\n\" +\n+        \"\" +\n+        \"/** @return {T} */\\n\" +\n+        \"C.prototype.method = function() {}\\n\" +\n+        \"\" +\n+        \"/** @type {C.<string>} */ var x = new C();\\n\" +\n+        \"var result = x.method();\\n\");\n+    assertEquals(\"string\", findNameType(\"result\", globalScope).toString());\n+  }\n+\n+  public void testClassTemplateType2() {\n+    // Verify that template types used in method signature on namespaced\n+    // objects are resolved.\n+    testSame(\n+        \"/** @const */ var ns = {};\" +\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @classTemplate T\\n\" +\n+        \" */\\n\" +\n+        \"ns.C = function() {};\\n\" +\n+        \"\" +\n+        \"/** @return {T} */\\n\" +\n+        \"ns.C.prototype.method = function() {}\\n\" +\n+        \"\" +\n+        \"/** @type {ns.C.<string>} */ var x = new ns.C();\\n\" +\n+        \"var result = x.method();\\n\");\n+    assertEquals(\"string\", findNameType(\"result\", globalScope).toString());\n+  }\n+\n+  public void testClassTemplateType3() {\n+    // Verify that template types used for instance properties are recognized.\n+    testSame(\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @classTemplate T\\n\" +\n+        \" */\\n\" +\n+        \"function C() {\\n\" +\n+        \"  /** @type {T} */\\n\" +\n+        \"  this.foo;\" +\n+        \"};\\n\" +\n+        \"\" +\n+        \"/** @type {C.<string>} */ var x = new C();\\n\" +\n+        \"var result = x.foo;\\n\");\n+    assertEquals(\"string\", findNameType(\"result\", globalScope).toString());\n+  }\n+\n+  public void testClassTemplateType4() {\n+    // Verify that template types used for instance properties are recognized.\n+    testSame(\n+        \"/** @const */ var ns = {};\" +\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @classTemplate T\\n\" +\n+        \" */\\n\" +\n+        \"ns.C = function() {\\n\" +\n+        \"  /** @type {T} */\\n\" +\n+        \"  this.foo;\" +\n+        \"};\\n\" +\n+        \"\" +\n+        \"/** @type {ns.C.<string>} */ var x = new ns.C();\\n\" +\n+        \"var result = x.foo;\\n\");\n+    assertEquals(\"string\", findNameType(\"result\", globalScope).toString());\n+  }\n+\n+  public void testClassTemplateType5() {\n+    // Verify that template types used for prototype properties in stub\n+    // declarations are recognized.\n+    testSame(\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @classTemplate T\\n\" +\n+        \" */\\n\" +\n+        \"function C() {\\n\" +\n+        \"};\\n\" +\n+        \"\" +\n+        \"/** @type {T} */\" +\n+        \"C.prototype.foo;\\n\" +\n+        \"\" +\n+        \"/** @type {C.<string>} */ var x = new C();\\n\" +\n+        \"var result = x.foo;\\n\");\n+    assertEquals(\"string\", findNameType(\"result\", globalScope).toString());\n+  }\n+\n+  public void testClassTemplateType6() {\n+    // Verify that template types used for prototype properties in assignment\n+    // expressions are recognized.\n+    testSame(\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @classTemplate T\\n\" +\n+        \" */\\n\" +\n+        \"function C() {\\n\" +\n+        \"};\\n\" +\n+        \"\" +\n+        \"/** @type {T} */\" +\n+        \"C.prototype.foo = 1;\\n\" +\n+        \"\" +\n+        \"/** @type {C.<string>} */ var x = new C();\\n\" +\n+        \"var result = x.foo;\\n\");\n+    assertEquals(\"string\", findNameType(\"result\", globalScope).toString());\n+  }\n+\n+  public void testClassTemplateType7() {\n+    // Verify that template types used in prototype methods are recognized.\n+    testSame(\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @classTemplate T\\n\" +\n+        \" */\\n\" +\n+        \"function C() {};\\n\" +\n+        \"\" +\n+        \"C.prototype.method = function() {\\n\" +\n+        \"  /** @type {T} */ var local;\" +\n+        \"}\\n\");\n+    assertEquals(\"T\", findNameType(\"local\", lastLocalScope).toString());\n+  }\n+\n+  public void testClassTemplateType8() {\n+    // Verify that template types used in casts are recognized.\n+    testSame(\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @classTemplate T\\n\" +\n+        \" */\\n\" +\n+        \"function C() {};\\n\" +\n+        \"\" +\n+        \"C.prototype.method = function() {\\n\" +\n+        \"  var local = /** @type {T} */ (x);\" +\n+        \"}\\n\");\n+    assertEquals(\"T\", findNameType(\"local\", lastLocalScope).toString());\n+  }\n+\n   public void testClosureParameterTypesWithoutJSDoc() {\n     testSame(\n         \"/**\\n\" +\n--- a/test/com/google/javascript/jscomp/parsing/ParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/ParserTest.java\n \n   private static final String MISSING_GT_MESSAGE =\n       \"Bad type annotation. \" +\n-      com.google.javascript.rhino.ScriptRuntime.getMessage0(\n+      com.google.javascript.rhino.SimpleErrorReporter.getMessage0(\n           \"msg.jsdoc.missing.gt\");\n \n   private static final String MISPLACED_TYPE_ANNOTATION =\n--- a/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n   }\n \n   public void testSubtypeWithInterfaceThisType() {\n-    FunctionType iface = registry.createInterfaceType(\"I\", null);\n+    FunctionType iface = registry.createInterfaceType(\"I\", null,\n+        ImmutableList.<String>of());\n     FunctionType ifaceReturnBoolean = new FunctionBuilder(registry)\n         .withParamsNode(registry.createParameters())\n         .withTypeOfThis(iface.getInstanceType())\n   }\n \n   public void testInterfacePrototypeChain1() {\n-    FunctionType iface = registry.createInterfaceType(\"I\", null);\n+    FunctionType iface = registry.createInterfaceType(\"I\", null,\n+        ImmutableList.<String>of());\n     assertTypeEquals(\n         iface.getPrototype(),\n         iface.getInstanceType().getImplicitPrototype());\n   }\n \n   public void testInterfacePrototypeChain2() {\n-    FunctionType iface = registry.createInterfaceType(\"I\", null);\n+    FunctionType iface = registry.createInterfaceType(\"I\", null,\n+        ImmutableList.<String>of());\n     iface.getPrototype().defineDeclaredProperty(\n         \"numberProp\", NUMBER_TYPE, null);\n \n-    FunctionType subIface = registry.createInterfaceType(\"SubI\", null);\n+    FunctionType subIface = registry.createInterfaceType(\"SubI\", null,\n+        ImmutableList.<String>of());\n     subIface.setExtendedInterfaces(\n         Lists.<ObjectType>newArrayList(iface.getInstanceType()));\n     assertTypeEquals(\n   }\n \n   public void testSetImplementsOnInterface() {\n-    FunctionType iface = registry.createInterfaceType(\"I\", null);\n-    FunctionType subIface = registry.createInterfaceType(\"SubI\", null);\n+    FunctionType iface = registry.createInterfaceType(\"I\", null,\n+        ImmutableList.<String>of());\n+    FunctionType subIface = registry.createInterfaceType(\"SubI\", null,\n+        ImmutableList.<String>of());\n     try {\n       subIface.setImplementedInterfaces(\n           ImmutableList.of(iface.getInstanceType()));\n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n     subclassCtor.setPrototypeBasedOn(unresolvedNamedType);\n     subclassOfUnresolvedNamedType = subclassCtor.getInstanceType();\n \n-    interfaceType = FunctionType.forInterface(registry, \"Interface\", null);\n+    interfaceType = FunctionType.forInterface(registry, \"Interface\", null,\n+        registry.createTemplateTypeMap(null, null));\n     interfaceInstType = interfaceType.getInstanceType();\n \n     subInterfaceType = FunctionType.forInterface(\n-        registry, \"SubInterface\", null);\n+        registry, \"SubInterface\", null,\n+        registry.createTemplateTypeMap(null, null));\n     subInterfaceType.setExtendedInterfaces(\n         Lists.<ObjectType>newArrayList(interfaceInstType));\n     subInterfaceInstType = subInterfaceType.getInstanceType();\n--- a/src/com/google/javascript/jscomp/ExpandJqueryAliases.java\n+++ b/src/com/google/javascript/jscomp/ExpandJqueryAliases.java\n \n     Node fn = n.getLastChild();\n     if (fn != null) {\n-      n.replaceChild(fn, IR.string(\"prototype\"));\n+      n.replaceChild(fn, IR.string(\"prototype\").srcref(fn));\n       compiler.reportCodeChange();\n     }\n   }\n \n       Node fnc = IR.function(IR.name(\"\").srcref(n),\n           IR.paramList().srcref(n),\n-          fncBlock);\n-      n.replaceChild(callTarget, fnc);\n-      n.putBooleanProp(Node.FREE_CALL, true);\n+          fncBlock).srcref(n);\n+\n+      // add an explicit \"call\" statement so that we can maintain\n+      // the same reference for \"this\"\n+      Node newCallTarget = IR.getprop(\n+          fnc, IR.string(\"call\").srcref(n)).srcref(n);\n+      n.replaceChild(callTarget, newCallTarget);\n+      n.putBooleanProp(Node.FREE_CALL, false);\n \n       // remove any other pre-existing call arguments\n-      while(fnc.getNext() != null) {\n-        n.removeChildAfter(fnc);\n-      }\n+      while(newCallTarget.getNext() != null) {\n+        n.removeChildAfter(newCallTarget);\n+      }\n+      n.addChildToBack(IR.thisNode().srcref(n));\n     }\n     compiler.reportCodeChange();\n   }\n--- a/test/com/google/javascript/jscomp/ExpandJqueryAliasesTest.java\n+++ b/test/com/google/javascript/jscomp/ExpandJqueryAliasesTest.java\n     // Test extend call where first argument includes a method call\n     testSame(setupCode+\"obj2.meth=function() { return { a:{} }; };\" +\n         \"jQuery.extend(obj2.meth().a, {a: 'test'});\");\n+\n+    // Test extend call where returned object is used\n+    test(setupCode + \"obj2 = jQuery.extend(obj2, {a:'test', \" +\n+        \"b:'test2'});\",\n+        setupCode + \"obj2 = function() {obj2 = obj2 || {}; \" + \n+        \"obj2.a = 'test';obj2.b = 'test2';return obj2;}.call(this);\");\n   }\n \n   public void testJqueryExpandedEachExpansion() {", "timestamp": 1363000088, "metainfo": ""}