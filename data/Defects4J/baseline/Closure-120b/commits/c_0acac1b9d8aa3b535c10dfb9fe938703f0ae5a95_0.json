{"sha": "0acac1b9d8aa3b535c10dfb9fe938703f0ae5a95", "log": "Add a compiler pass to instrument memory allocations caused by calls to new, object literals, array literals, and function expressions. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=44271412", "commit": "\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n \n   /** Move top-level function declarations to the top */\n   public boolean moveFunctionDeclarations;\n+\n+  /** Instrument / Intercept memory allocations. */\n+  private boolean instrumentMemoryAllocations;\n \n   /** Instrumentation template to use with #recordFunctionInformation */\n   public String instrumentationTemplate;\n     tweakProcessing = TweakProcessing.OFF;\n     tweakReplacements = Maps.newHashMap();\n     moveFunctionDeclarations = false;\n-    instrumentationTemplate = null;\n     appNameStr = \"\";\n     recordFunctionInformation = false;\n     generateExports = false;\n     replaceStringsPlaceholderToken = \"\";\n     replaceStringsReservedStrings = Collections.emptySet();\n     propertyInvalidationErrors = Maps.newHashMap();\n+\n+    // Instrumentation\n+    instrumentationTemplate = null;\n+    instrumentMemoryAllocations = false;\n \n     // Output\n     printInputDelimiter = false;\n    */\n   public void setCommonJSModulePathPrefix(String commonJSModulePathPrefix) {\n     this.commonJSModulePathPrefix = commonJSModulePathPrefix;\n+  }\n+\n+  /**\n+   * @return Whether memory allocations are instrumented.\n+   */\n+  public boolean getInstrumentMemoryAllocations() {\n+    return instrumentMemoryAllocations;\n+  }\n+\n+  /**\n+   * Sets the option to instrument memory allocations.\n+   */\n+  public void setInstrumentMemoryAllocations(\n+      boolean instrumentMemoryAllocations) {\n+    this.instrumentMemoryAllocations = instrumentMemoryAllocations;\n   }\n \n \n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n \n     if (options.instrumentationTemplate != null) {\n       passes.add(instrumentFunctions);\n+    }\n+\n+    // Instrument calls to memory allocations\n+    if (options.getInstrumentMemoryAllocations()) {\n+      passes.add(instrumentMemoryAllocations);\n     }\n \n     if (options.variableRenaming != VariableRenamingPolicy.ALL) {\n       };\n     }\n   };\n+\n+  /** Adds instrumentation for memory allocations. */\n+  final PassFactory instrumentMemoryAllocations =\n+      new PassFactory(\"instrumentMemoryAllocations\", true) {\n+        @Override\n+        protected CompilerPass create(final AbstractCompiler compiler) {\n+          return new InstrumentMemoryAllocPass(compiler);\n+        }\n+      };\n \n   /**\n    * Create a no-op pass that can only run once. Used to break up loops.\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/InstrumentMemoryAllocPass.java\n+/*\n+ * Copyright 2013 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.rhino.IR;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.JSType;\n+\n+/**\n+ * This code implements the instrumentation pass over the AST\n+ * to instrument all object allocations. This methodology should help \n+ * identify allocation hotspots and potential for object reuse, with\n+ * the goal to reduce memory footprint and GC pressure.\n+ *\n+ * We are tracking object allocations via new(), array literals, object\n+ * literals, and function expressions. This does not cover factory methods\n+ * like Object.create or document.createElement but could be expanded to\n+ * track those.\n+ */\n+class InstrumentMemoryAllocPass implements CompilerPass {\n+\n+  final AbstractCompiler compiler;\n+\n+  private static int newSiteId = 1; // 0 is reserved for 'total'\n+\n+  static final String JS_INSTRUMENT_ALLOCATION_CODE =\n+      \"var __allocStats; \\n\" +\n+      \"var __alloc = function(obj, sourcePosition, id, typeName) { \\n\" +\n+      \"  if (!__allocStats) { \\n\" +\n+      \"    __allocStats = { \\n\" +\n+      \"      reset: function() { \\n\" +\n+      \"        this.counts = [{ type:typeName, line:'total', count:0 }]; \\n\" +\n+      \"      }, \\n\" +\n+      \"      report: function(opt_n) { \\n\" +\n+      \"        this.counts.filter(function(x) { \\n\" +\n+      \"          return x; \\n\" +\n+      \"        }).sort(function(a, b) { \\n\" +\n+      \"          return b.count - a.count; \\n\" +\n+      \"        }).splice(0, opt_n || 50).reverse().forEach(function (x) { \\n\" +\n+      \"          if (window.console) { \\n\" +\n+      \"            window.console.log(x.count + ' (' + x.type + ') : ' + x.line); \\n\" +\n+      \"          } \\n\" +\n+      \"        }); \\n\" +\n+      \"      } \\n\" +\n+      \"    }; \\n\" +\n+      \"    __allocStats.reset(); \\n\" +\n+      \"    if (window.parent) { \\n\" +\n+      \"      window.parent['__allocStats'] = __allocStats; \\n\" +\n+      \"    } \\n\" +\n+      \"  } \\n\" +\n+      \"  if (!__allocStats.counts[id]) { \\n\" +\n+      \"    __allocStats.counts[id] = { type:typeName, line:sourcePosition, count:0 }; \\n\" +\n+      \"  } \\n\" +\n+      \"  __allocStats.counts[0].count++; \\n\" +\n+      \"  __allocStats.counts[id].count++; \\n\" +\n+      \"  return obj;\\n\" +\n+      \"}; \\n\"\n+      ;\n+\n+  /**\n+   * @param compiler the compiler which generates the AST.\n+   */\n+  public InstrumentMemoryAllocPass(AbstractCompiler compiler) {\n+    this.compiler = compiler;\n+  }\n+\n+  /**\n+   * Creates the library code for this instrumentation - a compiled\n+   * version of above __alloc implementation.\n+   */\n+  private Node getInstrumentAllocationCode() {\n+    return compiler.parseSyntheticCode(JS_INSTRUMENT_ALLOCATION_CODE);\n+  }\n+\n+  @Override\n+  public void process(Node externsNode, Node rootNode) {\n+    if (rootNode.hasChildren()) {\n+      NodeTraversal.traverse(compiler, rootNode, new Traversal());\n+      NodeTraversal.traverse(\n+          compiler, rootNode, new PrepareAst.PrepareAnnotations());\n+\n+      Node firstScript = rootNode.getFirstChild();\n+      Preconditions.checkState(firstScript.isScript());\n+\n+      compiler.getNodeForCodeInsertion(null).addChildrenToFront(\n+          getInstrumentAllocationCode().removeChildren());\n+      compiler.reportCodeChange();\n+    }\n+  }\n+\n+  private Node getTypeString(Node currentNode){\n+    if (currentNode.getType() == Token.NEW) {\n+      JSType type = currentNode.getFirstChild().getJSType();\n+      String typeName = (type != null) ? type.getDisplayName() : \"Unknown\";\n+      return IR.string(\"new \" + typeName);\n+    }\n+\n+    return\n+        currentNode.getType() == Token.ARRAYLIT ? IR.string(\"Array\") :\n+        currentNode.getType() == Token.OBJECTLIT ? IR.string(\"Object\") :\n+        currentNode.getType() == Token.FUNCTION ? IR.string(\"Function\") :\n+        IR.string(\"Unknown\");\n+  }\n+\n+  /**\n+   * Find instances of:\n+   *  - calls to new\n+   *  - object literals\n+   *  - array literals\n+   *  - a function (expression)\n+   *\n+   * All of these are known to result in memory allocations.\n+   * \"Intercept\" these with a call to our own __alloc for book keeping.\n+   */\n+  private class Traversal extends AbstractPostOrderCallback {\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      if (n.isNew() ||\n+          n.getType() == Token.ARRAYLIT ||\n+          n.getType() == Token.OBJECTLIT ||\n+          NodeUtil.isFunctionExpression(n)) {\n+\n+        Node instrumentAllocation = IR.call(\n+            IR.name(\"__alloc\"),\n+            n.cloneTree(),\n+            IR.string(n.getSourceFileName() + \":\" + n.getLineno()),\n+            IR.number(newSiteId++),\n+            getTypeString(n));\n+\n+        parent.replaceChild(n, instrumentAllocation);\n+      }\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/InstrumentMemoryAllocPassTest.java\n+/*\n+ * Copyright 2013 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+/**\n+ * Unit tests for {@link InstrumentMemoryAllocPass}.\n+ * Note: The order of test execution matters because the instrumentation\n+ * uniquely identifies memory allocation sites. Thus, the order is fixed by\n+ * combining tests into a single method.\n+ */\n+public class InstrumentMemoryAllocPassTest extends CompilerTestCase {\n+\n+  public InstrumentMemoryAllocPassTest() {\n+    super();\n+    enableLineNumberCheck(false);\n+  }\n+\n+  @Override\n+  protected CompilerPass getProcessor(Compiler compiler) {\n+    return new InstrumentMemoryAllocPass(compiler);\n+  }\n+\n+  @Override\n+  protected int getNumRepetitions() {\n+    // This pass is not idempotent so run once.\n+    return 1;\n+  }\n+\n+  @Override\n+  protected CompilerOptions getOptions() {\n+    CompilerOptions options = new CompilerOptions();\n+    options.setInstrumentMemoryAllocations(true);\n+    return getOptions(options);\n+  }\n+\n+  public void testNoAllocation() {\n+    test(\n+        \"var v\",\n+        InstrumentMemoryAllocPass.JS_INSTRUMENT_ALLOCATION_CODE + \"var v\");\n+  }\n+\n+  public void testNoStringInstrumentation() {\n+    test(\n+        \"var s = 'a' + 'b'\",\n+        InstrumentMemoryAllocPass.JS_INSTRUMENT_ALLOCATION_CODE\n+            + \"var s=\\\"a\\\"+\\\"b\\\"\");\n+  }\n+\n+  public void testAllocations() {\n+    test(\n+        \"var o = {}\",\n+        InstrumentMemoryAllocPass.JS_INSTRUMENT_ALLOCATION_CODE\n+            + \"var o=__alloc({},\\\"testcode:1\\\",1,\\\"Object\\\")\");\n+\n+    test(\n+        \"var a = []\",\n+        InstrumentMemoryAllocPass.JS_INSTRUMENT_ALLOCATION_CODE\n+            + \"var a=__alloc([],\\\"testcode:1\\\",2,\\\"Array\\\")\");\n+\n+    test(\n+        \"var f = function() {}\",\n+        InstrumentMemoryAllocPass.JS_INSTRUMENT_ALLOCATION_CODE\n+            + \"var f=__alloc(function(){},\\\"testcode:1\\\",3,\\\"Function\\\")\");\n+  }\n+}\n--- a/test/com/google/javascript/jscomp/IntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/IntegrationTest.java\n     options.generateExports = true;\n     test(options, \"/** @export */ function f() {}\",\n          \"/** @export */ function f() {} goog.exportSymbol('f', f);\");\n+  }\n+\n+  public void testInstrumentMemoryAllocationPassOff() {\n+    testSame(createCompilerOptions(),\n+        \"var obj = new Object(); \" +\n+        \"var o = {}; \" +\n+        \"var a = []; \" +\n+        \"var f = function() {};\" +\n+        \"var s = 'a' + 'b'\");\n+  }\n+\n+  public void testInstrumentMemoryAllocationPassOn() {\n+    CompilerOptions options = createCompilerOptions();\n+    options.setInstrumentMemoryAllocations(true);\n+    test(options,\n+        \"var obj = new Object(); \" +\n+        \"var o = {}; \" +\n+        \"var a = []; \" +\n+        \"var f = function() {};\" +\n+        \"var s = 'a' + 'b'\",\n+\n+        InstrumentMemoryAllocPass.JS_INSTRUMENT_ALLOCATION_CODE + \n+        \"var obj=__alloc(new Object(),\\\"i0:1\\\",4,\\\"new Unknown\\\");\" +\n+        \"var o=__alloc({},\\\"i0:1\\\",5,\\\"Object\\\");\" +\n+        \"var a=__alloc([],\\\"i0:1\\\",6,\\\"Array\\\");\" +\n+        \"var f=__alloc(function() {},\\\"i0:1\\\",7,\\\"Function\\\");\" +\n+        \"var s=\\\"a\\\"+\\\"b\\\";\");\n   }\n \n   public void testAngularPassOff() {", "timestamp": 1363910523, "metainfo": ""}