{"sha": "bd87d240fbeaf8d00c0869b3625d1ba982beb566", "log": "Resolve classTemplate parameter names for simple use cases. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=43455814", "commit": "\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n    * Infer the template type from the doc info.\n    */\n   FunctionTypeBuilder inferTemplateTypeName(\n-      @Nullable JSDocInfo info) {\n+      @Nullable JSDocInfo info, JSType ownerType) {\n     if (info != null &&  !info.getTemplateTypeNames().isEmpty()) {\n       ImmutableList.Builder<TemplateType> builder = ImmutableList.builder();\n       for (String key : info.getTemplateTypeNames()) {\n     } else {\n       templateTypeNames = ImmutableList.of();\n     }\n-    typeRegistry.setTemplateTypeNames(templateTypeNames);\n+\n+    ImmutableList<TemplateType> keys = templateTypeNames;\n+    if (ownerType != null) {\n+      ImmutableList<TemplateType> ownerTypeKeys =\n+          ownerType.getTemplateTypeMap().getTemplateKeys();\n+      if (!ownerTypeKeys.isEmpty()) {\n+        ImmutableList.Builder<TemplateType> builder = ImmutableList.builder();\n+        builder.addAll(templateTypeNames);\n+        builder.addAll(ownerTypeKeys);\n+        keys = builder.build();\n+      }\n+    }\n+\n+    if (!keys.isEmpty()) {\n+      typeRegistry.setTemplateTypeNames(keys);\n+    }\n     return this;\n   }\n \n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n     }\n   }\n \n+  private static class TemplateTypeMapReplacer extends ModificationVisitor {\n+    private final TemplateTypeMap replacements;\n+    boolean madeChanges = false;\n+\n+    TemplateTypeMapReplacer(\n+        JSTypeRegistry registry, TemplateTypeMap replacements) {\n+      super(registry);\n+      this.replacements = replacements;\n+    }\n+\n+    @Override\n+    public JSType caseTemplateType(TemplateType type) {\n+      if (replacements.hasTemplateKey(type)) {\n+        madeChanges = true;\n+        JSType replacement = replacements.getTemplateType(type);\n+        return replacements.getTemplateType(type);\n+      } else {\n+        return type;\n+      }\n+    }\n+  }\n+\n   /**\n    * For functions with function(this: T, ...) and T as parameters, type\n    * inference will set the type of this on a function literal argument to the\n       JSType foundType = objType.findPropertyType(propName);\n       if (foundType != null) {\n         propertyType = foundType;\n+      }\n+    }\n+\n+    if (propertyType != null && objType != null) {\n+      JSType restrictedObjType = objType.restrictByNotNullOrUndefined();\n+      if (restrictedObjType.isTemplatizedType()\n+          && propertyType.hasAnyTemplateTypes()) {\n+        TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n+        TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n+            registry, typeMap);\n+        propertyType = propertyType.visit(replacer);\n       }\n     }\n \n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n import com.google.javascript.rhino.jstype.ObjectType;\n import com.google.javascript.rhino.jstype.Property;\n+import com.google.javascript.rhino.jstype.TemplateType;\n \n import java.util.Iterator;\n import java.util.List;\n       JSType jsType = null;\n       if (info != null) {\n         if (info.hasType()) {\n+\n+          ImmutableList<TemplateType> ownerTypeKeys = ImmutableList.of();\n+          Node ownerNode = NodeUtil.getBestLValueOwner(node);\n+          String ownerName = NodeUtil.getBestLValueName(ownerNode);\n+          ObjectType ownerType = null;\n+          if (ownerName != null) {\n+            Var ownerVar = scope.getVar(ownerName);\n+            if (ownerVar != null) {\n+              ownerType = getPrototypeOwnerType(\n+                  ObjectType.cast(ownerVar.getType()));\n+              if (ownerType != null) {\n+                ownerTypeKeys =\n+                    ownerType.getTemplateTypeMap().getTemplateKeys();\n+              }\n+            }\n+          }\n+\n+          if (!ownerTypeKeys.isEmpty()) {\n+            typeRegistry.setTemplateTypeNames(ownerTypeKeys);\n+          }\n+\n           jsType = info.getType().evaluate(scope, typeRegistry);\n+\n+          if (!ownerTypeKeys.isEmpty()) {\n+            typeRegistry.clearTemplateTypeNames();\n+          }\n         } else if (FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n           String fnName = node.getQualifiedName();\n           jsType = createFunctionTypeFromNodes(\n             overriddenType = findOverriddenFunction(ownerType, propName);\n           }\n \n+          ObjectType prototypeOwner = getPrototypeOwnerType(ownerType);\n+\n           FunctionTypeBuilder builder =\n               new FunctionTypeBuilder(name, compiler, errorRoot, sourceName,\n                   scope)\n               .setContents(getFunctionAnalysisResults(fnRoot))\n               .inferFromOverriddenFunction(overriddenType, parametersNode)\n-              .inferTemplateTypeName(info)\n+              .inferTemplateTypeName(info, prototypeOwner)\n               .inferReturnType(info)\n               .inferInheritance(info);\n \n \n       // all done\n       return functionType;\n+    }\n+\n+    private ObjectType getPrototypeOwnerType(ObjectType ownerType) {\n+      if (ownerType != null && ownerType.isFunctionPrototypeType()) {\n+        return ownerType.getOwnerFunction();\n+      }\n+      return null;\n     }\n \n     /**\n         }\n \n         member.getFirstChild().setJSType(thisType);\n+\n+        // TODO: We are evaluating these values in the wrong scope:\n+        // https://code.google.com/p/closure-compiler/issues/detail?id=926\n+        JSType thisObjectType = thisType.toObjectType();\n+        if (thisObjectType != null) {\n+          ImmutableList<TemplateType> keys =\n+              thisObjectType.getTemplateTypeMap().getTemplateKeys();\n+          typeRegistry.setTemplateTypeNames(keys);\n+        }\n+\n         JSType jsType = getDeclaredType(info, member, value);\n+\n+        if (thisObjectType != null) {\n+          typeRegistry.clearTemplateTypeNames();\n+        }\n+\n         Node name = member.getLastChild();\n         if (jsType != null &&\n             (name.isName() || name.isString()) &&\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n    */\n   public JSType getType(StaticScope<JSType> scope, String jsTypeName,\n       String sourceName, int lineno, int charno) {\n-    JSType type = getType(jsTypeName);\n+    // Resolve template type names\n+    JSType type = null;\n+    JSType thisType = null;\n+    if (scope != null && scope.getTypeOfThis() != null) {\n+      thisType = scope.getTypeOfThis().toObjectType();\n+    }\n+    if (thisType != null) {\n+      type = thisType.getTemplateTypeMap().getTemplateTypeKeyByName(jsTypeName);\n+      if (type != null) {\n+        Preconditions.checkState(type.isTemplateType(), \"expected:\" + type);\n+        return type;\n+      }\n+    }\n+\n+    type = getType(jsTypeName);\n     if (type == null) {\n       // TODO(user): Each instance should support named type creation using\n       // interning.\n--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n         findNameType(\"result\", globalScope).toString());\n   }\n \n+  public void testClassTemplateType1() {\n+    // Verify that template types used in method signature are resolved.\n+    testSame(\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @classTemplate T\\n\" +\n+        \" */\\n\" +\n+        \"function C() {};\\n\" +\n+        \"\" +\n+        \"/** @return {T} */\\n\" +\n+        \"C.prototype.method = function() {}\\n\" +\n+        \"\" +\n+        \"/** @type {C.<string>} */ var x = new C();\\n\" +\n+        \"var result = x.method();\\n\");\n+    assertEquals(\"string\", findNameType(\"result\", globalScope).toString());\n+  }\n+\n+  public void testClassTemplateType2() {\n+    // Verify that template types used in method signature on namespaced\n+    // objects are resolved.\n+    testSame(\n+        \"/** @const */ var ns = {};\" +\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @classTemplate T\\n\" +\n+        \" */\\n\" +\n+        \"ns.C = function() {};\\n\" +\n+        \"\" +\n+        \"/** @return {T} */\\n\" +\n+        \"ns.C.prototype.method = function() {}\\n\" +\n+        \"\" +\n+        \"/** @type {ns.C.<string>} */ var x = new ns.C();\\n\" +\n+        \"var result = x.method();\\n\");\n+    assertEquals(\"string\", findNameType(\"result\", globalScope).toString());\n+  }\n+\n+  public void testClassTemplateType3() {\n+    // Verify that template types used for instance properties are recognized.\n+    testSame(\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @classTemplate T\\n\" +\n+        \" */\\n\" +\n+        \"function C() {\\n\" +\n+        \"  /** @type {T} */\\n\" +\n+        \"  this.foo;\" +\n+        \"};\\n\" +\n+        \"\" +\n+        \"/** @type {C.<string>} */ var x = new C();\\n\" +\n+        \"var result = x.foo;\\n\");\n+    assertEquals(\"string\", findNameType(\"result\", globalScope).toString());\n+  }\n+\n+  public void testClassTemplateType4() {\n+    // Verify that template types used for instance properties are recognized.\n+    testSame(\n+        \"/** @const */ var ns = {};\" +\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @classTemplate T\\n\" +\n+        \" */\\n\" +\n+        \"ns.C = function() {\\n\" +\n+        \"  /** @type {T} */\\n\" +\n+        \"  this.foo;\" +\n+        \"};\\n\" +\n+        \"\" +\n+        \"/** @type {ns.C.<string>} */ var x = new ns.C();\\n\" +\n+        \"var result = x.foo;\\n\");\n+    assertEquals(\"string\", findNameType(\"result\", globalScope).toString());\n+  }\n+\n+  public void testClassTemplateType5() {\n+    // Verify that template types used for prototype properties in stub\n+    // declarations are recognized.\n+    testSame(\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @classTemplate T\\n\" +\n+        \" */\\n\" +\n+        \"function C() {\\n\" +\n+        \"};\\n\" +\n+        \"\" +\n+        \"/** @type {T} */\" +\n+        \"C.prototype.foo;\\n\" +\n+        \"\" +\n+        \"/** @type {C.<string>} */ var x = new C();\\n\" +\n+        \"var result = x.foo;\\n\");\n+    assertEquals(\"string\", findNameType(\"result\", globalScope).toString());\n+  }\n+\n+  public void testClassTemplateType6() {\n+    // Verify that template types used for prototype properties in assignment\n+    // expressions are recognized.\n+    testSame(\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @classTemplate T\\n\" +\n+        \" */\\n\" +\n+        \"function C() {\\n\" +\n+        \"};\\n\" +\n+        \"\" +\n+        \"/** @type {T} */\" +\n+        \"C.prototype.foo = 1;\\n\" +\n+        \"\" +\n+        \"/** @type {C.<string>} */ var x = new C();\\n\" +\n+        \"var result = x.foo;\\n\");\n+    assertEquals(\"string\", findNameType(\"result\", globalScope).toString());\n+  }\n+\n+  public void testClassTemplateType7() {\n+    // Verify that template types used in prototype methods are recognized.\n+    testSame(\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @classTemplate T\\n\" +\n+        \" */\\n\" +\n+        \"function C() {};\\n\" +\n+        \"\" +\n+        \"C.prototype.method = function() {\\n\" +\n+        \"  /** @type {T} */ var local;\" +\n+        \"}\\n\");\n+    assertEquals(\"T\", findNameType(\"local\", lastLocalScope).toString());\n+  }\n+\n+  public void testClassTemplateType8() {\n+    // Verify that template types used in casts are recognized.\n+    testSame(\n+        \"/**\\n\" +\n+        \" * @constructor\\n\" +\n+        \" * @classTemplate T\\n\" +\n+        \" */\\n\" +\n+        \"function C() {};\\n\" +\n+        \"\" +\n+        \"C.prototype.method = function() {\\n\" +\n+        \"  var local = /** @type {T} */ (x);\" +\n+        \"}\\n\");\n+    assertEquals(\"T\", findNameType(\"local\", lastLocalScope).toString());\n+  }\n+\n   public void testClosureParameterTypesWithoutJSDoc() {\n     testSame(\n         \"/**\\n\" +", "timestamp": 1362616260, "metainfo": ""}