{"sha": "8e0f4d9d79358a723f3dd5e52b8b33d2afd21bed", "log": "Allow collapse properties to collapse simple global aliases. This prevents the generation of bad code in these cases. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=46889045", "commit": "\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n     globalNames = namespace.getNameForest();\n     checkNamespaces();\n \n-    for (Name n : globalNames) {\n-      flattenReferencesToCollapsibleDescendantNames(n, n.getBaseName());\n+    for (Name name : globalNames) {\n+      flattenReferencesToCollapsibleDescendantNames(name, name.getBaseName());\n     }\n \n     // We collapse property definitions after collapsing property references\n     // because this step can alter the parse tree above property references,\n     // invalidating the node ancestry stored with each reference.\n-    for (Name n : globalNames) {\n-      collapseDeclarationOfNameAndDescendants(n, n.getBaseName());\n-    }\n+    for (Name name : globalNames) {\n+      collapseDeclarationOfNameAndDescendants(name, name.getBaseName());\n+    }\n+  }\n+\n+  private void inlineAliases(GlobalNamespace namespace) {\n+    // inline names until we reach a fixed point.\n+    do {} while (inlineAliasesOnce(namespace));\n   }\n \n   /**\n    *     (If N = \"a.b.c\", \"a\" and \"a.b\" are never aliased).\n    * (b) N has exactly one write, and it lives in the global scope.\n    * (c) N is aliased in a local scope.\n+   * (d) N is aliased in global scope\n    *\n    * If (a) is true, then GlobalNamespace must know all the writes to N.\n    * If (a) and (b) are true, then N cannot change during the execution of\n    * If (a) and (b) and (c) are true, then the alias can be inlined if the\n    *    alias obeys the usual rules for how we decide whether a variable is\n    *    inlineable.\n+   * If (a) and (b) and (d) are true, then inline the alias if possible (if\n+   * it is assigned exactly once unconditionally).\n    * @see InlineVariables\n-   */\n-  private void inlineAliases(GlobalNamespace namespace) {\n+   * @return Whether any work still needs to be done.\n+   */\n+  private boolean inlineAliasesOnce(GlobalNamespace namespace) {\n+    int deferredCount = 0;\n+\n     // Invariant: All the names in the worklist meet condition (a).\n     Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n+\n+    Set<Node> newNodes = Sets.newHashSet();\n+\n     while (!workList.isEmpty()) {\n       Name name = workList.pop();\n+      boolean inlinedGlobalAliasToCurrentName = false;\n \n       // Don't attempt to inline a getter or setter property as a variable.\n       if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n         for (Ref ref : refs) {\n           if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n             // {@code name} meets condition (c). Try to inline it.\n+            // TODO(johnlenz): consider picking up new aliases at the end\n+            // of the pass instead of immediately like we do for global\n+            // inlines.\n             if (inlineAliasIfPossible(ref, namespace)) {\n               name.removeRef(ref);\n             }\n+          } else if (ref.type == Type.ALIASING_GET\n+              && ref.scope.isGlobal()\n+              && ref.getTwin() == null) {  // ignore aliases in chained assignments\n+            if (inlineGlobalAliasIfPossible(ref, namespace, newNodes)) {\n+              name.removeRef(ref);\n+              inlinedGlobalAliasToCurrentName = true;\n+            }\n           }\n         }\n       }\n \n-      // Check if {@code name} has any aliases left after the\n+      // * Check if {@code name} has any aliases left after the\n       // local-alias-inlining above.\n-      if ((name.type == Name.Type.OBJECTLIT ||\n+      // * Defer checking for inline-able aliases of properties of the current\n+      // name if global aliases were inlined as they may have created new\n+      // references to these properties\n+      if (!inlinedGlobalAliasToCurrentName &&\n+          (name.type == Name.Type.OBJECTLIT ||\n            name.type == Name.Type.FUNCTION) &&\n           name.aliasingGets == 0 && name.props != null) {\n         // All of {@code name}'s children meet condition (a), so they can be\n         // added to the worklist.\n         workList.addAll(name.props);\n       }\n-    }\n+\n+      if (inlinedGlobalAliasToCurrentName) {\n+        deferredCount++;\n+      }\n+    }\n+\n+    if (!newNodes.isEmpty()) {\n+      // Inlining the variable may have introduced new references\n+      // to descendants of {@code name}. So those need to be collected now.\n+      namespace.scanNewNodes(newNodes);\n+    }\n+\n+    return deferredCount > 0;\n+  }\n+\n+  /**\n+   * Attempt to inline an global alias of a global name. This requires that\n+   * the name is well defined: assigned unconditionally, assigned exactly once.\n+   * It is assumed that, the name for which it is an alias must already\n+   * meet these same requirements.\n+   *\n+   * @param alias The alias to inline\n+   * @param newNodes nodes added when replaces aliases.\n+   * @return Whether the alias was inlined.\n+   */\n+  private boolean inlineGlobalAliasIfPossible(\n+      Ref alias, GlobalNamespace namespace, Set<Node> newNodes) {\n+    // Ensure that the alias is assigned to global name at that the\n+    // declaration.\n+\n+    Node aliasParent = alias.node.getParent();\n+    if (aliasParent.isAssign() && NodeUtil.isExecutedExactlyOnce(aliasParent)) {\n+      String target = aliasParent.getFirstChild().getQualifiedName();\n+      if (target != null) {\n+        Name name = namespace.getSlot(target);\n+        if (name != null && isInlinableGlobalAlias(name)) {\n+          List<Ref> refs = Lists.newArrayList(name.getRefs());\n+          for (Ref ref : refs) {\n+            switch (ref.type) {\n+              case SET_FROM_GLOBAL:\n+                continue;\n+              case DIRECT_GET:\n+              case ALIASING_GET:\n+                Node newNode = alias.node.cloneTree();\n+                Node node = ref.node;\n+                node.getParent().replaceChild(node, newNode);\n+                newNodes.add(newNode);\n+                name.removeRef(ref);\n+                break;\n+              default:\n+                throw new IllegalStateException();\n+            }\n+          }\n+\n+          rewriteAliasProps(name, alias.node, 0, newNodes);\n+\n+          // just set the original alias to null.\n+          aliasParent.replaceChild(alias.node, IR.nullNode());\n+          compiler.reportCodeChange();\n+\n+          // NOTE: It is too expensive to scan for aliases in global scope\n+          // immediately, so we defer it and check for them all at once at\n+          // the end of the pass.\n+\n+          return true;\n+        }\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * @param name The Name whose properties references should be updated.\n+   * @param value The value to use when rewriting.\n+   * @param depth The chain depth.\n+   * @param newNodes Expression nodes that have been updated.\n+   */\n+  private void rewriteAliasProps(\n+      Name name, Node value, int depth, Set<Node> newNodes) {\n+    if (name.props != null) {\n+      Preconditions.checkState(!\n+          value.getQualifiedName().equals(name.getFullName()));\n+\n+      for (Name prop : name.props) {\n+        rewriteAliasProps(prop, value, depth + 1, newNodes);\n+\n+        List<Ref> refs = Lists.newArrayList(prop.getRefs());\n+        for (Ref ref : refs) {\n+          Node target = ref.node;\n+          for (int i = 0; i <= depth; i++) {\n+            if (target.isGetProp()) {\n+              target = target.getFirstChild();\n+            } else if (NodeUtil.isObjectLitKey(target)) {\n+              // Object literal key definitions are a little trickier, as we\n+              // need to find the assignment target\n+              Node gparent = target.getParent().getParent();\n+              if (gparent.isAssign()) {\n+                target = gparent.getFirstChild();\n+              } else {\n+                Preconditions.checkState(NodeUtil.isObjectLitKey(gparent));\n+                target = gparent;\n+              }\n+            } else {\n+              throw new IllegalStateException(\n+                  \"unexpected: \" + target.toString());\n+            }\n+          }\n+          Preconditions.checkState(target.isGetProp() || target.isName());\n+          target.getParent().replaceChild(target, value.cloneTree());\n+          prop.removeRef(ref);\n+          newNodes.add(ref.node);\n+        }\n+      }\n+    }\n+  }\n+\n+  private boolean isInlinableGlobalAlias(Name name) {\n+    // Only simple aliases with direct usage are inlinable.\n+    if (name.inExterns || name.globalSets != 1 || name.localSets != 0\n+        || !name.canCollapse()) {\n+      return false;\n+    }\n+\n+    // Only allow inlining of simple references.\n+    for (Ref ref : name.getRefs()) {\n+      switch (ref.type) {\n+        case SET_FROM_GLOBAL:\n+          // Expect one global set\n+          continue;\n+        case SET_FROM_LOCAL:\n+          throw new IllegalStateException();\n+        case ALIASING_GET:\n+        case DIRECT_GET:\n+          continue;\n+        case PROTOTYPE_GET:\n+        case CALL_GET:\n+        case DELETE_PROP:\n+          return false;\n+        default:\n+          throw new IllegalStateException();\n+      }\n+    }\n+    return true;\n   }\n \n   private boolean inlineAliasIfPossible(Ref alias, GlobalNamespace namespace) {\n--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n   private final Node externsRoot;\n   private boolean inExterns;\n   private Scope externsScope;\n+  private Scope globalScope;\n   private boolean generated = false;\n \n   /**\n     t.traverseAtScope(scope);\n   }\n \n+  void scanNewNodes(Set<Node> newNodes) {\n+    scanNewNodes(globalScope, newNodes);\n+  }\n+\n   /**\n    * A filter that looks for qualified names that contain one of the nodes\n    * in the given set.\n \n     @Override\n     public boolean apply(Node n) {\n+      if (NodeUtil.isObjectLitKey(n)) {\n+        return newNodes.contains(n);\n+      }\n+\n       if (!n.isQualifiedName()) {\n         return false;\n       }\n       if (externsRoot != null && n == externsRoot) {\n         externsScope = t.getScope();\n       }\n+\n+      if (root != null && n == root) {\n+        globalScope = t.getScope();\n+      }\n+\n \n       String name;\n       boolean isSet = false;\n    * node and its ancestors that may be affected.\n    */\n   static class Ref implements StaticReference<JSType> {\n+\n+    // Note: we are more aggressive about collapsing @enum and @constructor\n+    // declarations than implied here, see Name#canCollapse\n     enum Type {\n       SET_FROM_GLOBAL,\n       SET_FROM_LOCAL,\n--- a/test/com/google/javascript/jscomp/CollapsePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/CollapsePropertiesTest.java\n          \"var a$b$c = function(){}; a$b$c();\");\n   }\n \n-  public void testFunctionAlias() {\n-    test(\"var a = {}; a.b = {}; a.b.c = function(){}; a.b.d = a.b.c;\",\n-         \"var a$b$c = function(){}; var a$b$d = a$b$c;\");\n+  public void testFunctionAlias1() {\n+    test(\"var a = {}; a.b = {}; a.b.c = function(){}; a.b.d = a.b.c;a.b.d=null\",\n+         \"var a$b$c = function(){}; var a$b$d = a$b$c;a$b$d=null;\");\n+  }\n+\n+  public void testFunctionAlias2() {\n+    test(\"var a = {}; a.b = {}; a.b.c = function(){}; a.b.d = a.b.c;use(a.b.d)\",\n+         \"var a$b$c = function(){}; var a$b$d = null;use(a$b$c);\");\n   }\n \n   public void testCallToRedefinedFunction() {\n     // This verifies that replacements are done in the right order. Collapsing\n     // the l-value in an assignment affects the parse tree immediately above\n     // the r-value, so we update all rvalues before any lvalues.\n-    test(\"var a = {b: 0}; a.c = a.b;\", \"var a$b = 0; var a$c = a$b;\");\n+    test(\"var a = {b: 0}; a.c = a.b;a.c = null\",\n+         \"var a$b = 0; var a$c = a$b;a$c = null\");\n   }\n \n   public void testCallOnUndefinedProperty() {\n     assertTrue(varNode.isVar());\n     assertTrue(varNode.getJSDocInfo().isConstructor());\n   }\n+\n+  public void testTypeDefAlias1() {\n+    test(\n+        \"/** @constructor */ var D = function() {};\\n\" +\n+        \"/** @constructor */ D.L = function() {};\\n\" +\n+        \"/** @type {D.L} */ D.L.A = new D.L();\\n\" +\n+        \"\\n\" +\n+        \"/** @const */ var M = {};\\n\" +\n+        \"/** @typedef {D.L} */ M.L = D.L;\\n\" +\n+        \"\\n\" +\n+        \"use(M.L.A);\",\n+\n+        \"var D = function() {};\\n\" +\n+        \"var D$L = function() {};\\n\" +\n+        \"var D$L$A = new D$L();\\n\" +\n+        \"var M$L = null\\n\" +\n+        \"use(D$L$A);\");\n+  }\n+\n+  public void testTypeDefAlias2() {\n+    // TODO(johnlenz): make CollapseProperties safer around aliases of\n+    // functions and object literals.  Currently, this pass trades correctness\n+    // for code size.  We should able to create a safer compromise by teaching\n+    // the pass about goog.inherits and similiar calls.\n+    test(\n+        \"/** @constructor */ var D = function() {};\\n\" +\n+        \"/** @constructor */ D.L = function() {};\\n\" +\n+        \"/** @type {D.L} */ D.L.A = new D.L();\\n\" +\n+        \"\\n\" +\n+        \"/** @const */ var M = {};\\n\" +\n+        \"if (random) { /** @typedef {D.L} */ M.L = D.L; }\\n\" +\n+        \"\\n\" +\n+        \"use(M.L);\\n\" +\n+        \"use(M.L.A);\\n\",\n+\n+        \"var D = function() {};\\n\" +\n+        \"var D$L = function() {};\\n\" +\n+        \"var D$L$A = new D$L();\\n\" +\n+        \"if (random) { var M$L = D$L; }\\n\" +\n+        \"use(M$L);\\n\" +\n+        \"use(M$L.A);\");\n+  }\n+\n+  public void testGlobalAliasWithProperties1() {\n+    test(\"var ns = {}; \" +\n+        \"/** @constructor */ ns.Foo = function() {};\\n\" +\n+        \"/** @enum {number} */ ns.Foo.EventType = {A:1, B:2};\" +\n+        \"/** @constructor */ ns.Bar = ns.Foo;\\n\" +\n+        \"var x = function() {use(ns.Bar.EventType.A)};\\n\" +\n+        \"use(x);\",\n+        \"var ns$Foo = function(){};\" +\n+        \"var ns$Foo$EventType$A = 1;\" +\n+        \"var ns$Foo$EventType$B = 2;\" +\n+        \"var ns$Bar = null;\" +\n+        \"var x = function(){use(ns$Foo$EventType$A)};\" +\n+        \"use(x);\");\n+  }\n+\n+  public void testGlobalAliasWithProperties2() {\n+    // Reassignment of properties was necessary to prevent invalid code in\n+    // previous iterations of this optimization.  Verify we don't break\n+    // code like this.  Now it causes a back-off of the collapsing because\n+    // the value is assigned more than once.\n+    test(\"var ns = {}; \" +\n+        \"/** @constructor */ ns.Foo = function() {};\\n\" +\n+        \"/** @enum {number} */ ns.Foo.EventType = {A:1, B:2};\" +\n+        \"/** @constructor */ ns.Bar = ns.Foo;\\n\" +\n+        \"/** @enum {number} */ ns.Bar.EventType = ns.Foo.EventType;\\n\" +\n+        \"var x = function() {use(ns.Bar.EventType.A)};\\n\" +\n+        \"use(x)\",\n+        \"var ns$Foo = function(){};\" +\n+        \"var ns$Foo$EventType = {A:1, B:2};\" +\n+        \"var ns$Bar = null;\" +\n+        \"ns$Foo$EventType = ns$Foo$EventType;\\n\" +\n+        \"var x = function(){use(ns$Foo$EventType.A)};\" +\n+        \"use(x);\");\n+  }\n+\n+  public void testGlobalAliasWithProperties3() {\n+    test(\"var ns = {}; \" +\n+        \"/** @constructor */ ns.Foo = function() {};\\n\" +\n+        \"/** @enum {number} */ ns.Foo.EventType = {A:1, B:2};\" +\n+        \"/** @constructor */ ns.Bar = ns.Foo;\\n\" +\n+        \"/** @enum {number} */ ns.Bar.Other = {X:1, Y:2};\\n\" +\n+        \"var x = function() {use(ns.Bar.Other.X)};\\n\" +\n+        \"use(x)\",\n+        \"var ns$Foo=function(){};\" +\n+        \"var ns$Foo$EventType$A=1;\" +\n+        \"var ns$Foo$EventType$B=2;\" +\n+        \"var ns$Bar=null;\" +\n+        \"var ns$Foo$Other$X=1;\" +\n+        \"var ns$Foo$Other$Y=2;\" +\n+        \"var x=function(){use(ns$Foo$Other$X)};\" +\n+        \"use(x)\\n\");\n+  }\n+\n+  public void testGlobalAliasWithProperties4() {\n+    testSame(\"\" +\n+        \"var nullFunction = function(){};\\n\" +\n+        \"var blob = {};\\n\" +\n+        \"blob.init = nullFunction;\\n\" +\n+        \"use(blob)\");\n+  }\n+\n+  public void testGlobalAliasWithProperties5() {\n+    testSame(\n+        \"/** @constructor */ var blob = function() {}\",\n+        \"var nullFunction = function(){};\\n\" +\n+        \"blob.init = nullFunction;\\n\" +\n+        \"use(blob.init)\",\n+        null);\n+  }\n }", "timestamp": 1369092237, "metainfo": ""}