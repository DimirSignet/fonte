{"sha": "9de5e9b4671773bb3f2d5932e57c1b4186b9b777", "log": "Change on 2010/06/30 15:06:33 by johnlenz  \tAdd a diagnostic group so that projects with weird externs can opt-out of the stricter extern checks.  \tR=nicksantos \tDELTA=54  (52 added, 0 deleted, 2 changed)  Change on 2010/06/30 17:56:51 by johnlenz  \tRevert warning levels until after a release is put out to control them.  \tR=nicksantos \tDELTA=4  (2 added, 0 deleted, 2 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=47002   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCompiler.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompiler.java\n    *     properties.\n    */\n   abstract void setHasRegExpGlobalReferences(boolean references);\n-  \n+\n   /**\n    * @return Whether the AST constains references to the RegExp global object\n    *     properties.\n    */\n   abstract boolean hasRegExpGlobalReferences();\n+\n+  /**\n+   * @return The error level the given error object will be reported at.\n+   */\n+  abstract CheckLevel getErrorLevel(JSError error);\n }\n--- a/src/com/google/javascript/jscomp/AbstractMessageFormatter.java\n+++ b/src/com/google/javascript/jscomp/AbstractMessageFormatter.java\n   private String maybeColorize(String text, Color color) {\n     if (!colorize) return text;\n \n-    return color.getControlCharacter() + \n+    return color.getControlCharacter() +\n         text + Color.RESET.getControlCharacter();\n   }\n }\n--- a/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\n+++ b/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\n  * An abstract class whose implementations run peephole optimizations:\n  * optimizations that look at a small section of code and either remove\n  * that code (if it is not needed) or replaces it with smaller code.\n- * \n+ *\n *\n  */\n abstract class AbstractPeepholeOptimization {\n-   \n+\n   private NodeTraversal currentTraversal;\n-  \n-  /** \n-   * Given a node to optimize and a traversal, optimize the node. Subclasses \n+\n+  /**\n+   * Given a node to optimize and a traversal, optimize the node. Subclasses\n    * should override to provide their own peephole optimization.\n-   * \n-   * @param subtree The subtree that will be optimized. \n+   *\n+   * @param subtree The subtree that will be optimized.\n    * @return The new version of the subtree (or null if the subtree or one of\n    * its parents was removed from the AST). If the subtree has not changed,\n    * this method must return {@code subtree}.\n-   */  \n+   */\n   abstract Node optimizeSubtree(Node subtree);\n \n-  /** \n-   * Helper method for reporting an error to the compiler when applying a \n+  /**\n+   * Helper method for reporting an error to the compiler when applying a\n    * peephole optimization.\n-   * \n+   *\n    * @param diagnostic The error type\n    * @param n The node for which the error should be reported\n-   */ \n+   */\n   protected void error(DiagnosticType diagnostic, Node n) {\n     JSError error = currentTraversal.makeError(n, diagnostic, n.toString());\n     currentTraversal.getCompiler().report(error);\n   }\n-  \n-  /** \n-   * Helper method for telling the compiler that something has changed. \n-   * Subclasses must call these if they have changed the AST. \n+\n+  /**\n+   * Helper method for telling the compiler that something has changed.\n+   * Subclasses must call these if they have changed the AST.\n    */\n   protected void reportCodeChange() {\n     Preconditions.checkNotNull(currentTraversal);\n     currentTraversal.getCompiler().reportCodeChange();\n   }\n-  \n+\n   /**\n    * Are the nodes equal for the purpose of inlining?\n    * If type aware optimizations are on, type equality is checked.\n     Preconditions.checkNotNull(currentTraversal);\n     return currentTraversal.getCompiler().areNodesEqualForInlining(n1, n2);\n   }\n-  \n+\n   /**\n    *  Is the current AST normalized? (e.g. has the Normalize pass been run\n-   *  and has the Denormalize pass not yet been run?) \n+   *  and has the Denormalize pass not yet been run?)\n    */\n   protected boolean isASTNormalized() {\n     Preconditions.checkNotNull(currentTraversal);\n     Preconditions.checkNotNull(currentTraversal.getCompiler());\n-    \n+\n     return currentTraversal.getCompiler().isNormalized();\n   }\n-  \n+\n   /**\n-   * Informs the optimization that a traversal will begin.  \n+   * Informs the optimization that a traversal will begin.\n    */\n   void beginTraversal(NodeTraversal traversal) {\n     currentTraversal = traversal;\n   }\n-  \n+\n   /**\n    * Informs the optimization that a traversal has completed.\n    */\n--- a/src/com/google/javascript/jscomp/AnalyzeNameReferences.java\n+++ b/src/com/google/javascript/jscomp/AnalyzeNameReferences.java\n  *\n  * The two pieces of information will be annotated to {@link NameReferenceGraph}\n  * by {@link NameInfo} objects.\n- * \n+ *\n  * This is an analysis based on {@link AnalyzeNameReferences} using the more\n  * accurate graph and will soon replace it.\n- * \n+ *\n *\n  */\n class AnalyzeNameReferences implements CompilerPass {\n   private NameReferenceGraph graph;\n   private final JSModuleGraph moduleGraph;\n   private final AbstractCompiler compiler;\n-  \n+\n   AnalyzeNameReferences(AbstractCompiler compiler) {\n     this.compiler = compiler;\n     this.moduleGraph = compiler.getModuleGraph();\n   public NameReferenceGraph getGraph() {\n     return graph;\n   }\n-  \n+\n   private class PropagateReferences implements EdgeCallback<Name, Reference> {\n     public boolean traverseEdge(Name start, Reference edge, Name dest) {\n       NameInfo startInfo = getInfo(start);\n     }\n     return info;\n   }\n-  \n+\n   final class NameInfo implements Annotation {\n     private boolean referenced = false;\n     private JSModule deepestCommonModuleRef = null;\n     boolean isReferenced() {\n       return referenced;\n     }\n-    \n+\n     /**\n      * Returns the deepest common module of all the references to this\n      * property.\n--- a/src/com/google/javascript/jscomp/CheckGlobalThis.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalThis.java\n \n   private final AbstractCompiler compiler;\n   private final CheckLevel level;\n-  \n+\n   /**\n    * If {@code assignLhsChild != null}, then the node being traversed is\n    * a descendant of the first child of an ASSIGN node. assignLhsChild's\n     if (parent != null && parent.getType() == Token.ASSIGN) {\n       Node lhs = parent.getFirstChild();\n       Node rhs = lhs.getNext();\n-      \n+\n       if (n == lhs) {\n         // Always traverse the left side of the assignment. To handle\n         // nested assignments properly (e.g., (a = this).property = c;),\n--- a/src/com/google/javascript/jscomp/CheckPathsBetweenNodes.java\n+++ b/src/com/google/javascript/jscomp/CheckPathsBetweenNodes.java\n   private static final Annotation GRAY = new Annotation() {};\n   // Finished visiting.\n   private static final Annotation BLACK = new Annotation() {};\n-  \n+\n   private final DiGraph<N, E> graph;\n   private final DiGraphNode<N, E> start;\n   private final DiGraphNode<N, E> end;\n     this.edgePredicate = edgePredicate;\n     this.inclusive = inclusive;\n   }\n-  \n+\n   /**\n    * Inclusive check.\n    */\n       Predicate<DiGraphEdge<N, E>> edgePredicate) {\n     this(graph, a, b, nodePredicate, edgePredicate, true);\n   }\n-  \n+\n \n   /**\n    * @return true iff all paths contain at least one node that satisfy the\n     tearDown();\n     return result;\n   }\n-  \n+\n   /**\n    * @return true iff some paths contain at least one node that satisfy the\n    *     predicate\n     graph.pushEdgeAnnotations();\n     discoverBackEdges(this.start);\n   }\n-  \n+\n   private void tearDown() {\n     graph.popNodeAnnotations();\n     graph.popEdgeAnnotations();\n   }\n-  \n+\n   private void discoverBackEdges(DiGraphNode<N, E> u) {\n     u.setAnnotation(GRAY);\n     for (DiGraphEdge<N, E> e : u.getOutEdges()) {\n     }\n     return true;\n   }\n-  \n+\n   /**\n    * Verify that some non-looping paths from {@code a} to {@code b} pass\n    * through at least one node where {@code nodePredicate} is true.\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n         return isOneExactlyFunctionOrDo(labeledStatement);\n       } else {\n         // For labels with block children, we need to ensure that a\n-        // labeled FUNCTION or DO isn't generated when extraneous BLOCKs \n-        // are skipped. \n-        if (getNonEmptyChildCount(n, 2) == 1) { \n+        // labeled FUNCTION or DO isn't generated when extraneous BLOCKs\n+        // are skipped.\n+        if (getNonEmptyChildCount(n, 2) == 1) {\n           return isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n));\n         } else {\n           // Either a empty statement or an block with more than one child,\n--- a/src/com/google/javascript/jscomp/CodingConvention.java\n+++ b/src/com/google/javascript/jscomp/CodingConvention.java\n    * annotation.\n    */\n   public boolean isConstantKey(String keyName);\n-  \n+\n   /**\n    * This checks that a given {@code key} may be used as a key for an enum.\n    *\n \n     /**\n      * Returns the type for a type assertion, or null if the function asserts\n-     * that the node must not be null or undefined. \n+     * that the node must not be null or undefined.\n      */\n     public JSTypeNative getAssertedType() {\n       return assertedType;\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n     }\n   }\n \n+  @Override\n+  public CheckLevel getErrorLevel(JSError error) {\n+    Preconditions.checkNotNull(options);\n+    WarningsGuard guards = options.getWarningsGuard();\n+    if (guards == null) {\n+      return error.level;\n+    } else {\n+      return guards.level(error);\n+    }\n+  }\n+\n   /**\n    * Report an internal error.\n    */\n--- a/src/com/google/javascript/jscomp/CompilerPass.java\n+++ b/src/com/google/javascript/jscomp/CompilerPass.java\n  * the root node of the parsed JS tree, as well as the\n  * root node of the external JS tree (used to provide a public API\n  * and prevent renaming of system functions).</p>\n- * \n+ *\n  * <p>Use this class to support testing with BaseCompilerTest</p>\n  *\n *\n--- a/src/com/google/javascript/jscomp/ControlFlowGraph.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowGraph.java\n       return !isEnteringNewCfgNode(n);\n     }\n   }\n-  \n+\n   /**\n    * @return True if n should be represented by a new CFG node in the control\n    * flow graph.\n         // Theses control structure is represented by its node that holds the\n         // condition. Each of them is a branch node based on its condition.\n         return NodeUtil.getConditionExpression(parent) != n;\n-        \n+\n       case Token.FOR:\n         // The FOR(;;) node differs from other control structure in that\n         // it has a initialization and a increment statement. Those\n         // for(var x = 0; x < 10; x++) { } has a graph that is isomorphic to\n         // var x = 0; while(x<10) {  x++; }\n         if (NodeUtil.isForIn(parent)) {\n-          return n == parent.getLastChild(); \n+          return n == parent.getLastChild();\n         } else {\n           return NodeUtil.getConditionExpression(parent) != n;\n         }\n--- a/src/com/google/javascript/jscomp/DiagnosticGroups.java\n+++ b/src/com/google/javascript/jscomp/DiagnosticGroups.java\n           new DiagnosticGroup(VarCheck.STRICT_MODULE_DEP_ERROR,\n                               CheckGlobalNames.STRICT_MODULE_DEP_QNAME));\n \n+  public static DiagnosticGroup EXTERNS_VALIDATION =\n+    DiagnosticGroups.registerGroup(\"externsValidation\",\n+          new DiagnosticGroup(VarCheck.NAME_REFERENCE_IN_EXTERNS_ERROR,\n+                              VarCheck.UNDEFINED_EXTERN_VAR_ERROR));\n+\n   public static DiagnosticGroup UNKNOWN_DEFINES =\n     DiagnosticGroups.registerGroup(\"unknownDefines\",\n           new DiagnosticGroup(ProcessDefines.UNKNOWN_DEFINE_WARNING));\n--- a/src/com/google/javascript/jscomp/ExternExportsPass.java\n+++ b/src/com/google/javascript/jscomp/ExternExportsPass.java\n     DiagnosticType.warning(\n         \"JSC_EXPORTED_FUNCTION_UNKNOWN_PARAMETER_TYPE\",\n         \"Unable to determine type of parameter {0} for exported function {1}\");\n-  \n+\n   static final DiagnosticType EXPORTED_FUNCTION_UNKNOWN_RETURN_TYPE =\n     DiagnosticType.warning(\n         \"JSC_EXPORTED_FUNCTION_UNKNOWN_RETURN_TYPE\",\n         \"Unable to determine return type for exported function {0}\");\n-  \n+\n   /** The exports found. */\n   private final List<Export> exports;\n \n       this.symbolName = symbolName;\n       this.value = value;\n     }\n-        \n+\n     /**\n      * Generates the externs representation of this export and appends\n      * it to the externsRoot AST.\n      */\n     void generateExterns() {\n-      appendExtern(getExportedPath(), getFunctionValue(value));    \n+      appendExtern(getExportedPath(), getFunctionValue(value));\n     }\n \n     /**\n      * Returns the path exported by this export.\n      */\n     abstract String getExportedPath();\n-    \n+\n     /**\n      * Appends the exported function and all paths necessary for the path to be\n      * declared. For example, for a property \"a.b.c\", the initializers for\n      */\n     protected void appendExtern(String path, Node functionToExport) {\n       List<String> pathPrefixes = computePathPrefixes(path);\n-      \n-      for (int i = 0; i < pathPrefixes.size(); ++i) {  \n+\n+      for (int i = 0; i < pathPrefixes.size(); ++i) {\n         String pathPrefix = pathPrefixes.get(i);\n-        \n+\n         /* The complete path (the last path prefix) must be emitted and\n          * it gets initialized to the externed version of the value.\n-         */      \n+         */\n         boolean isCompletePathPrefix = (i == pathPrefixes.size() - 1);\n-           \n+\n         boolean skipPathPrefix = pathPrefix.endsWith(\".prototype\")\n-            || (alreadyExportedPaths.contains(pathPrefix) \n+            || (alreadyExportedPaths.contains(pathPrefix)\n                 && !isCompletePathPrefix);\n-          \n+\n         if (!skipPathPrefix) {\n            Node initializer;\n-                \n+\n           /* Namespaces get initialized to {}, functions to\n            * externed versions of their value, and if we can't\n            * figure out where the value came from we initialize\n            * it to {}.\n-           * \n+           *\n            * Since externs are always exported in sorted order,\n-           * we know that if we export a.b = function() {} and later \n+           * we know that if we export a.b = function() {} and later\n            * a.b.c = function then a.b will always be in alreadyExportedPaths\n            * when we emit a.b.c and thus we will never overwrite the function\n            * exported for a.b with a namespace.\n            */\n-           \n+\n           if (isCompletePathPrefix && functionToExport != null) {\n             initializer = createExternFunction(functionToExport);\n           } else {\n             initializer = new Node(Token.OBJECTLIT);\n           }\n-          \n-          appendPathDefinition(pathPrefix, initializer);        \n-        }      \n-      }\n-    }\n- \n-    /** \n+\n+          appendPathDefinition(pathPrefix, initializer);\n+        }\n+      }\n+    }\n+\n+    /**\n      * Computes a list of the path prefixes constructed from the components\n      * of the path.\n      * <pre>\n      */\n     private List<String> computePathPrefixes(String path) {\n       List<String> pieces = Lists.newArrayList(path.split(\"\\\\.\"));\n-      \n+\n       List<String> pathPrefixes = Lists.newArrayList();\n-      \n+\n       for (int i = 0; i < pieces.size(); i++) {\n         pathPrefixes.add(Joiner.on(\".\").join(Iterables.limit(pieces, i + 1)));\n       }\n-      \n+\n       return pathPrefixes;\n     }\n-    \n+\n     private void appendPathDefinition(String path, Node initializer) {\n       Node pathDefinition;\n-      \n+\n       if (!path.contains(\".\")) {\n         pathDefinition = NodeUtil.newVarNode(path, initializer);\n       } else {\n         Node qualifiedPath = NodeUtil.newQualifiedNameNode(path, -1, -1);\n         pathDefinition = NodeUtil.newExpr(new Node(Token.ASSIGN, qualifiedPath,\n             initializer));\n-      } \n-      \n+      }\n+\n       externsRoot.addChildToBack(pathDefinition);\n-      \n+\n       alreadyExportedPaths.add(path);\n     }\n-    \n+\n     /**\n      * Given a function to export, create the empty function that\n      * will be put in the externs file. This extern function should have\n      * the same type as the original function and the same parameter\n      * name but no function body.\n-     * \n+     *\n      * We create a warning here if the the function to export is missing\n      * parameter or return types.\n      */\n       for (Node param : NodeUtil.getFnParameters(exportedFunction).children()) {\n         externParameters.add(param.cloneNode());\n       }\n-      \n-      Node externFunction = NodeUtil.newFunctionNode(\"\", externParameters, \n+\n+      Node externFunction = NodeUtil.newFunctionNode(\"\", externParameters,\n           new Node(Token.BLOCK), -1, -1);\n-      \n-      checkForFunctionsWithUnknownTypes(exportedFunction);    \n+\n+      checkForFunctionsWithUnknownTypes(exportedFunction);\n       externFunction.setJSType(exportedFunction.getJSType());\n-      \n+\n       return externFunction;\n     }\n-    \n+\n     /**\n      * Warn the user if there is an exported function for which a parameter\n      * or return type is unknown.\n      */\n     private void checkForFunctionsWithUnknownTypes(Node function) {\n       Preconditions.checkArgument(NodeUtil.isFunction(function));\n-      \n+\n       FunctionType functionType = (FunctionType) function.getJSType();\n-      \n+\n       if (functionType == null) {\n         // No type information is available (CheckTypes was probably not run)\n         // so just bail.\n         return;\n       }\n-      \n+\n       /* We must get the JSDocInfo from the function's type since the function\n        * itself does not have an associated JSDocInfo node.\n        */\n       JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();\n-        \n+\n       JSType returnType = functionType.getReturnType();\n-      \n+\n       /* It is OK if a constructor doesn't have a return type */\n-      if (!functionType.isConstructor() && \n+      if (!functionType.isConstructor() &&\n           (returnType == null || returnType.isUnknownType())) {\n         reportUnknownReturnType(function);\n       }\n-      \n+\n       /* We can't just use the function's type's getParameters() to get the\n        * parameter nodes because the nodes returned from that method\n        * do not have names or locations. Similarly, the function's AST parameter\n-       * nodes do not have JSTypes(). So we walk both lists of parameter nodes \n+       * nodes do not have JSTypes(). So we walk both lists of parameter nodes\n        * in lock step getting parameter names from the first and types from the\n        * second.\n-       */    \n+       */\n       Node astParameterIterator = NodeUtil.getFnParameters(function)\n         .getFirstChild();\n-           \n+\n       Node typeParameterIterator = functionType.getParametersNode()\n         .getFirstChild();\n-      \n+\n       while (astParameterIterator != null) {\n         JSType parameterType = typeParameterIterator.getJSType();\n-        \n+\n         if (parameterType == null || parameterType.isUnknownType()) {\n           reportUnknownParameterType(function, astParameterIterator);\n         }\n-        \n+\n         astParameterIterator = astParameterIterator.getNext();\n         typeParameterIterator = typeParameterIterator.getNext();\n       }\n     }\n-    \n+\n     private void reportUnknownParameterType(Node function, Node parameter) {\n       compiler.report(JSError.make(NodeUtil.getSourceName(function),\n-          parameter, CheckLevel.WARNING, \n+          parameter, CheckLevel.WARNING,\n           EXPORTED_FUNCTION_UNKNOWN_PARAMETER_TYPE,\n           NodeUtil.getFunctionName(function), parameter.getString()));\n     }\n-    \n+\n     private void reportUnknownReturnType(Node function) {\n       compiler.report(JSError.make(NodeUtil.getSourceName(function),\n           function, CheckLevel.WARNING, EXPORTED_FUNCTION_UNKNOWN_RETURN_TYPE,\n           NodeUtil.getFunctionName(function)));\n     }\n-    \n+\n     /**\n      * If the given value is a qualified name which refers\n      * a function, the function's node is returned. Otherwise,\n \n       Node definitionParent = definitionMap.get(qualifiedName);\n       Node definition;\n-      \n+\n       switch(definitionParent.getType()) {\n         case Token.ASSIGN:\n           definition = definitionParent.getLastChild();\n \n     public SymbolExport(String symbolName, Node value) {\n       super(symbolName, value);\n-      \n+\n       String qualifiedName = value.getQualifiedName();\n \n       if (qualifiedName != null) {\n \n     public PropertyExport(String exportPath, String symbolName, Node value) {\n       super(symbolName, value);\n-      \n+\n       this.exportPath = exportPath;\n     }\n \n   public String getGeneratedExterns() {\n     CodePrinter.Builder builder = new CodePrinter.Builder(externsRoot)\n       .setPrettyPrint(false).setOutputTypes(true);\n-    \n+\n     return builder.build();\n   }\n \n--- a/src/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarations.java\n+++ b/src/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarations.java\n \n     Node var = NodeUtil.newVarNode(prototypeAlias, null)\n         .copyInformationFromForTree(injectionPoint);\n-    \n+\n     injectionPoint.addChildrenToFront(var);\n \n     // Go through all extraction instances and extract each of them.\n       delta = PER_EXTRACTION_INSTANCE_OVERHEAD + PER_PROTOTYPE_MEMBER_DELTA;\n \n       for (Node cur = head.node.getNext(); cur != null; cur = cur.getNext()) {\n-        \n+\n         // We can skip over any named functions because they have no effect on\n         // the control flow. In fact, they are lifted to the beginning of the\n         // block. This happens a lot when devirtualization breaks the whole\n         if (NodeUtil.isFunction(cur)) {\n           continue;\n         }\n-        \n+\n         PrototypeMemberDeclaration prototypeMember =\n             PrototypeMemberDeclaration.extractDeclaration(cur);\n         if (prototypeMember == null || !head.isSameClass(prototypeMember)) {\n--- a/src/com/google/javascript/jscomp/FindExportableNodes.java\n+++ b/src/com/google/javascript/jscomp/FindExportableNodes.java\n    * they are encountered.\n    */\n   private final LinkedHashMap<String, GenerateNodeContext> exports;\n-  \n+\n   private final AbstractCompiler compiler;\n-  \n+\n   public FindExportableNodes(AbstractCompiler compiler) {\n     this.compiler = compiler;\n     this.exports = Maps.newLinkedHashMap();\n       }\n     }\n   }\n-  \n+\n   public LinkedHashMap<String, GenerateNodeContext> getExports() {\n     return exports;\n   }\n--- a/src/com/google/javascript/jscomp/IgnoreCajaProperties.java\n+++ b/src/com/google/javascript/jscomp/IgnoreCajaProperties.java\n \n /**\n  * Caja is a system that rewrites web content (JavaScript, CSS, HTML)\n- * into web content that is safe to inline directly into a page.  \n+ * into web content that is safe to inline directly into a page.\n  * The rewritten (\"cajoled\") code runs in the presence of a JS library\n  * that adds some properties to Object.prototype.  Because JS does not\n  * yet (until ES5) allow programmers to mark properties as DontEnum,\n class IgnoreCajaProperties implements CompilerPass {\n \n   final AbstractCompiler compiler;\n-  \n+\n   // Counts the number of temporary variables introduced.\n   int counter;\n- \n+\n   public IgnoreCajaProperties(AbstractCompiler compiler) {\n     this.compiler = compiler;\n     this.counter = 0;\n   }\n- \n+\n   @Override\n   public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root, new Traversal());\n   }\n- \n+\n   private class Traversal extends AbstractPostOrderCallback {\n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n         n.removeChild(body);\n         Node key = n.getFirstChild();\n         n.removeChild(key);\n-        Node tmp = Node.newString(Token.NAME, \n+        Node tmp = Node.newString(Token.NAME,\n             \"JSCompiler_IgnoreCajaProperties_\" + counter++);\n         n.addChildToFront(new Node(Token.VAR, tmp));\n         Node assignment;\n \n         // Construct the body of the if statement.\n         if (key.getType() == Token.VAR) {\n-          // for (var key in x) { body; } \n-          // => \n+          // for (var key in x) { body; }\n+          // =>\n           // for (var tmp in x) {\n           //   if (!tmp.match(/___$/)) {\n           //     var key;\n               new Node(\n                   Token.EXPR_RESULT,\n                   new Node(\n-                    Token.ASSIGN, \n-                    key.getFirstChild().cloneNode(), \n+                    Token.ASSIGN,\n+                    key.getFirstChild().cloneNode(),\n                     tmp.cloneTree())),\n               body);\n         } else {\n-          // for (key in x) { body; } \n-          // => \n+          // for (key in x) { body; }\n+          // =>\n           // for (var tmp in x) {\n           //   if (!tmp.match(/___$/)) {\n           //     key = tmp;\n               new Node(\n                   Token.EXPR_RESULT,\n                   new Node(\n-                    Token.ASSIGN, \n-                    key, \n+                    Token.ASSIGN,\n+                    key,\n                     tmp.cloneTree())),\n               body);\n-        }          \n+        }\n \n         // Construct the new body of the for loop.\n         Node newBody = new Node(\n-            Token.BLOCK, \n+            Token.BLOCK,\n             new Node(\n-                Token.IF, \n+                Token.IF,\n                 new Node(\n-                    Token.NOT, \n+                    Token.NOT,\n                     new Node(\n-                        Token.CALL, \n+                        Token.CALL,\n                         new Node(\n-                            Token.GETPROP, \n-                            tmp.cloneTree(), \n-                            Node.newString(\"match\")), \n+                            Token.GETPROP,\n+                            tmp.cloneTree(),\n+                            Node.newString(\"match\")),\n                         new Node(\n-                            Token.REGEXP, \n-                            Node.newString(\"___$\")))), \n+                            Token.REGEXP,\n+                            Node.newString(\"___$\")))),\n                 ifBody));\n         n.addChildToBack(newBody);\n         compiler.reportCodeChange();\n--- a/src/com/google/javascript/jscomp/InlineFunctions.java\n+++ b/src/com/google/javascript/jscomp/InlineFunctions.java\n     Node block = NodeUtil.getFunctionBody(fnNode);\n     return NodeUtil.getFnParameters(fnNode).hasChildren()\n         || NodeUtil.has(\n-             block, \n-             new NodeUtil.MatchDeclaration(), \n+             block,\n+             new NodeUtil.MatchDeclaration(),\n              new NodeUtil.MatchShallowStatement());\n   }\n \n--- a/src/com/google/javascript/jscomp/InvocationsCallback.java\n+++ b/src/com/google/javascript/jscomp/InvocationsCallback.java\n \n /**\n  * Traversal callback that finds method invocations of the form\n- * \n+ *\n  * <pre>\n  * call\n  *   getprop\n  *     string\n  *   ...\n  * </pre>\n- * \n+ *\n  * and invokes a method defined by subclasses for processing these invocations.\n- * \n+ *\n *\n  */\n abstract class InvocationsCallback extends AbstractPostOrderCallback {\n \n   /**\n    * Called for each callnode that is a method invocation.\n-   * \n+   *\n    * @param callNode node of type call\n    * @param parent parent of callNode\n    * @param callName name of method invoked by first child of call\n--- a/src/com/google/javascript/jscomp/JsAst.java\n+++ b/src/com/google/javascript/jscomp/JsAst.java\n     root = null;\n     // While we're at it, clear out any saved text in the source file on\n     // the assumption that if we're dumping the parse tree, then we probably\n-    // assume regenerating everything else is a smart idea also. \n+    // assume regenerating everything else is a smart idea also.\n     sourceFile.clearCachedSource();\n   }\n \n--- a/src/com/google/javascript/jscomp/LatticeElement.java\n+++ b/src/com/google/javascript/jscomp/LatticeElement.java\n \n /**\n  * A lattice element.\n- * \n+ *\n *\n  */\n interface LatticeElement {\n--- a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n+++ b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n       }\n       b.append(\": \");\n     }\n-    \n+\n     b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n     b.append(\" - \");\n \n--- a/src/com/google/javascript/jscomp/NameGenerator.java\n+++ b/src/com/google/javascript/jscomp/NameGenerator.java\n   /** Generate short name with this first character */\n   static final char[] FIRST_CHAR =\n     \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$\".toCharArray();\n-  \n+\n   /** These appear after after the first character */\n   static final char[] NONFIRST_CHAR =\n     \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789$\"\n   static char[] reserveCharacters(char[] chars, char[] reservedCharacters) {\n     if (reservedCharacters == null || reservedCharacters.length == 0) {\n       return chars;\n-    }    \n+    }\n     Set<Character> charSet = Sets.newLinkedHashSet(Chars.asList(chars));\n     for (char reservedCharacter : reservedCharacters) {\n       charSet.remove(reservedCharacter);\n   String generateNextName() {\n     while (true) {\n       String name = prefix;\n-      \n+\n       int i = nameCount;\n-      \n+\n       if (name.isEmpty()) {\n         int pos = i % firstChars.length;\n         name += firstChars[pos];\n       }\n \n       nameCount++;\n-      \n+\n       // Make sure it's not a JS keyword or reserved name.\n       if (TokenStream.isKeyword(name) || reservedNames.contains(name)) {\n         continue;\n       }\n-      \n+\n       return name;\n     }\n   }\n--- a/src/com/google/javascript/jscomp/OptimizeParameters.java\n+++ b/src/com/google/javascript/jscomp/OptimizeParameters.java\n \n   private final AbstractCompiler compiler;\n   private NameReferenceGraph nameGraph;\n- \n+\n   OptimizeParameters(AbstractCompiler compiler, NameReferenceGraph nameGraph) {\n     this.compiler = compiler;\n     this.nameGraph = nameGraph;\n       c.process(externs, root);\n       nameGraph = c.getNameReferenceGraph();\n     }\n-    \n-    for (DiGraphNode<Name, Reference> node : \n+\n+    for (DiGraphNode<Name, Reference> node :\n         nameGraph.getDirectedGraphNodes()) {\n       Name name = node.getValue();\n       if (name.canChangeSignature()) {\n-        List<DiGraphEdge<Name, Reference>> edges = node.getInEdges();        \n+        List<DiGraphEdge<Name, Reference>> edges = node.getInEdges();\n         tryEliminateConstantArgs(name, edges);\n         tryEliminateOptionalArgs(name, edges);\n       }\n     }\n   }\n-  \n+\n   /**\n    * Removes any optional parameters if no callers specifies it as an argument.\n-   * @param name The name of the function to optimize. \n+   * @param name The name of the function to optimize.\n    * @param edges All the references to this name.\n    */\n   private void tryEliminateOptionalArgs(Name name,\n       List<DiGraphEdge<Name, Reference>> edges) {\n-    \n+\n     // Count the maximum number of arguments passed into this function all\n     // all points of the program.\n     int maxArgs = -1;\n   }\n \n   /**\n-   * Eliminate parameters if they are always constant. \n-   * \n+   * Eliminate parameters if they are always constant.\n+   *\n    * function foo(a, b) {...}\n    * foo(1,2);\n    * foo(1,3)\n    * becomes\n    * function foo(b) { var a = 1 ... }\n    * foo(2);\n-   * foo(3); \n-   * \n-   * @param name The name of the function to optimize. \n+   * foo(3);\n+   *\n+   * @param name The name of the function to optimize.\n    * @param edges All the references to this name.\n    */\n   private void tryEliminateConstantArgs(Name name,\n       List<DiGraphEdge<Name, Reference>> edges) {\n-    \n+\n     List<Parameter> parameters = Lists.newArrayList();\n     boolean firstCall = true;\n-    \n+\n     // Build a list of parameters to remove\n     for (DiGraphEdge<Name, Reference> refEdge : edges) {\n       Reference ref = refEdge.getValue();\n       Node call = ref.parent;\n-      \n+\n       if (isCallSite(ref)) {\n         Node cur = call.getFirstChild();\n         if (firstCall) {\n-          // Use the first call to construct a list of parameters of the \n+          // Use the first call to construct a list of parameters of the\n           // function.\n           buildParameterList(parameters, cur);\n           firstCall = false;\n         }\n       }\n     }\n-    \n+\n     // Remove the constant parameters in all the calls\n     for (DiGraphEdge<Name, Reference> refEdge : edges) {\n       Reference ref = refEdge.getValue();\n       Node call = ref.parent;\n-      \n+\n       if (isCallSite(ref)) {\n         optimizeCallSite(parameters, call);\n       }\n     }\n-    \n+\n     // Remove the constant parameters in the definitions and add it as a local\n     // variable.\n     for (Definition definition : name.getDeclarations()) {\n     }\n   }\n \n-  private void optimizeFunctionDefinition(List<Parameter> parameters, \n+  private void optimizeFunctionDefinition(List<Parameter> parameters,\n       Node function) {\n     for (int index = parameters.size() - 1; index >= 0; index--) {\n       if (parameters.get(index).shouldRemove()) {\n         Node paramName = eliminateFunctionParamAt(function, index);\n         if (paramName != null) {\n-          addVariableToFunction(function, paramName, \n+          addVariableToFunction(function, paramName,\n               parameters.get(index).getArg());\n         }\n       }\n       }\n     }\n   }\n-  \n+\n   /**\n    * @param ref A reference to a function.\n-   * @return true, if it's safe to optimize this function. \n+   * @return true, if it's safe to optimize this function.\n    */\n   private boolean isCallSite(Reference ref) {\n     Node call = ref.parent;\n-    // We need to make sure we're dealing with a call to the function we're \n+    // We need to make sure we're dealing with a call to the function we're\n     // optimizing. If the the first child of the parent is not the site, this\n-    // is a nested call and it's a call to another function. \n+    // is a nested call and it's a call to another function.\n     return isCallOrNew(call) && call.getFirstChild() == ref.site;\n   }\n \n   /**\n    * Return true if the node can be considered a call. For the purpose of this\n    * class, the new operator is considered a call since it can be optimized\n-   * in the same way. \n+   * in the same way.\n    * @param node A node\n    * @return True if the node is a call.\n    */\n   private boolean isCallOrNew(Node node) {\n     return NodeUtil.isCall(node) || NodeUtil.isNew(node);\n   }\n-  \n-  /**\n-   * Node equality as intended by the this pass. \n+\n+  /**\n+   * Node equality as intended by the this pass.\n    * @param n1 A node\n    * @param n2 A node\n-   * @return true if both node are considered equal for the purposes of this \n-   * class, false otherwise. \n+   * @return true if both node are considered equal for the purposes of this\n+   * class, false otherwise.\n    */\n   private boolean nodesAreEqual(Node n1, Node n2) {\n     return NodeUtil.isImmutableValue(n1) && NodeUtil.isImmutableValue(n2) &&\n         n1.checkTreeEqualsSilent(n2);\n   }\n-  \n-  /**\n-   * Simple container class that keeps tracks of a parameter and whether it \n+\n+  /**\n+   * Simple container class that keeps tracks of a parameter and whether it\n    * should be removed.\n    */\n   private static class Parameter {\n     private final Node arg;\n     private boolean shouldRemove;\n-    \n+\n     public Parameter(Node arg, boolean shouldRemove) {\n       this.shouldRemove = shouldRemove;\n       this.arg = arg;\n     }\n-    \n+\n     public Node getArg() {\n       return arg;\n     }\n     public boolean shouldRemove() {\n       return shouldRemove;\n     }\n-    \n+\n     public void setShouldRemove(boolean value) {\n       shouldRemove = value;\n     }\n   }\n \n   /**\n-   * Adds a variable to the top of a function block. \n+   * Adds a variable to the top of a function block.\n    * @param function A function node.\n-   * @param varName The name of the variable. \n-   * @param value The initial value of the variable. \n+   * @param varName The name of the variable.\n+   * @param value The initial value of the variable.\n    */\n   private void addVariableToFunction(Node function, Node varName, Node value) {\n-    Preconditions.checkArgument(NodeUtil.isFunction(function), \n+    Preconditions.checkArgument(NodeUtil.isFunction(function),\n         \"Node must be a function.\");\n- \n+\n     Node block = function.getLastChild();\n-    Preconditions.checkArgument(block.getType() == Token.BLOCK, \n+    Preconditions.checkArgument(block.getType() == Token.BLOCK,\n         \"Node must be a block.\");\n-    \n-    Node newVar = NodeUtil.newVarNode(varName.getQualifiedName(), \n+\n+    Node newVar = NodeUtil.newVarNode(varName.getQualifiedName(),\n         value.cloneTree());\n     block.addChildToFront(newVar);\n     compiler.reportCodeChange();\n   }\n-  \n+\n   /**\n    * Removes all formal parameters starting at argIndex.\n    * @return true if a parameter has been removed.\n    */\n   private boolean eliminateParamsAfter(Node function, int argIndex) {\n-    \n+\n     boolean paramRemoved = false;\n-    \n+\n     Node formalArgPtr = function.getFirstChild().getNext().getFirstChild();\n     while (argIndex != 0 && formalArgPtr != null) {\n       formalArgPtr = formalArgPtr.getNext();\n       paramRemoved = true;\n       formalArgPtr = next;\n     }\n-    \n+\n     return paramRemoved;\n   }\n-  \n-  /**\n-   * Given the first argument of a function or call, this removes the nth \n-   * argument of the function or call. \n-   * @param firstArg The first arg of the call or function. \n+\n+  /**\n+   * Given the first argument of a function or call, this removes the nth\n+   * argument of the function or call.\n+   * @param firstArg The first arg of the call or function.\n    * @param argIndex the index of the arg to remove.\n    * @return the node of the removed argument.\n    */\n   private Node getArgumentAtIndex(Node firstArg, int argIndex) {\n     Node formalArgPtr = firstArg;\n-    while (argIndex != 0 && formalArgPtr != null) { \n+    while (argIndex != 0 && formalArgPtr != null) {\n       formalArgPtr = formalArgPtr.getNext();\n       argIndex--;\n     }\n     return formalArgPtr;\n   }\n-  \n-  /**\n-   * Eliminates the parameter from a function definition. \n+\n+  /**\n+   * Eliminates the parameter from a function definition.\n    * @param function The function node\n    * @param argIndex The index of the the argument to remove.\n-   * @return The Node of the argument removed. \n+   * @return The Node of the argument removed.\n    */\n   private Node eliminateFunctionParamAt(Node function, int argIndex) {\n-    Preconditions.checkArgument(NodeUtil.isFunction(function), \n+    Preconditions.checkArgument(NodeUtil.isFunction(function),\n         \"Node must be a function.\");\n-    \n+\n     Node formalArgPtr = getArgumentAtIndex(\n         function.getFirstChild().getNext().getFirstChild(), argIndex);\n-    \n+\n     if (formalArgPtr != null) {\n       function.getFirstChild().getNext().removeChild(formalArgPtr);\n     }\n     return formalArgPtr;\n   }\n-  \n-  /**\n-   * Eliminates the parameter from a function call. \n+\n+  /**\n+   * Eliminates the parameter from a function call.\n    * @param call The function call node\n    * @param argIndex The index of the the argument to remove.\n-   * @return The Node of the argument removed. \n+   * @return The Node of the argument removed.\n    */\n   private Node eliminateCallParamAt(Node call, int argIndex) {\n     Preconditions.checkArgument(isCallOrNew(call), \"Node must be a call.\");\n-    \n+\n     Node formalArgPtr = getArgumentAtIndex(\n         call.getFirstChild().getNext(), argIndex);\n-    \n+\n     if (formalArgPtr != null) {\n       call.removeChild(formalArgPtr);\n       compiler.reportCodeChange();\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n       \"Fractional bitwise operand: {0}\");\n \n   private static final double MAX_FOLD_NUMBER = Math.pow(2, 53);\n-  \n+\n   @Override\n   Node optimizeSubtree(Node subtree) {\n     switch(subtree.getType()) {\n       case Token.CALL:\n         return tryFoldKnownMethods(subtree);\n-        \n+\n       case Token.TYPEOF:\n         return tryFoldTypeof(subtree);\n-        \n+\n       case Token.NOT:\n       case Token.NEG:\n       case Token.BITNOT:\n         return tryFoldUnaryOperator(subtree);\n-        \n+\n       default:\n         return tryFoldBinaryOperator(subtree);\n     }\n   }\n-  \n+\n   private Node tryFoldBinaryOperator(Node subtree) {\n     Node left = subtree.getFirstChild();\n-    \n+\n     if (left == null) {\n       return subtree;\n     }\n-    \n+\n     Node right = left.getNext();\n-    \n+\n     if (right == null) {\n       return subtree;\n     }\n-    \n+\n     // If we've reached here, node is truly a binary operator.\n     switch(subtree.getType()) {\n       case Token.GETPROP:\n         return tryFoldGetProp(subtree, left, right);\n-        \n+\n       case Token.GETELEM:\n         return tryFoldGetElem(subtree, left, right);\n-        \n+\n       case Token.INSTANCEOF:\n         return tryFoldInstanceof(subtree, left, right);\n-        \n+\n       case Token.AND:\n       case Token.OR:\n-        return tryFoldAndOr(subtree, left, right);    \n-        \n+        return tryFoldAndOr(subtree, left, right);\n+\n       case Token.BITAND:\n       case Token.BITOR:\n         return tryFoldBitAndOr(subtree, left, right);\n       case Token.RSH:\n       case Token.URSH:\n         return tryFoldShift(subtree, left, right);\n-        \n+\n       case Token.ASSIGN:\n         return tryFoldAssign(subtree, left, right);\n \n       case Token.ADD:\n         return tryFoldAdd(subtree, left, right);\n-        \n+\n       case Token.SUB:\n       case Token.MUL:\n       case Token.DIV:\n         return tryFoldArithmetic(subtree, left, right);\n-        \n+\n       case Token.LT:\n       case Token.GT:\n       case Token.LE:\n       case Token.SHEQ:\n       case Token.SHNE:\n         return tryFoldComparison(subtree, left, right);\n-        \n+\n       default:\n         return subtree;\n     }\n   }\n-  \n+\n   /**\n    * Folds 'typeof(foo)' if foo is a literal, e.g.\n    * typeof(\"bar\") --> \"string\"\n     if (argumentNode == null || !NodeUtil.isLiteralValue(argumentNode)) {\n       return originalTypeofNode;\n     }\n-    \n+\n     String typeNameString = null;\n \n     switch (argumentNode.getType()) {\n       case Token.ARRAYLIT:\n         typeNameString = \"object\";\n         break;\n-      case Token.NAME:          \n+      case Token.NAME:\n         // We assume here that programs don't change the value of the\n         // keyword undefined to something other than the value undefined.\n         if (\"undefined\".equals(argumentNode.getString())) {\n       Node newNode = Node.newString(typeNameString);\n       originalTypeofNode.getParent().replaceChild(originalTypeofNode, newNode);\n       reportCodeChange();\n-      \n+\n       return newNode;\n     }\n-  \n+\n     return originalTypeofNode;\n   }\n-  \n+\n   private Node tryFoldUnaryOperator(Node n) {\n     Preconditions.checkState(n.hasOneChild());\n \n     Node left = n.getFirstChild();\n     Node parent = n.getParent();\n-    \n+\n     if (left == null) {\n       return n;\n     }\n-    \n+\n     // TODO(dcc): Just dropping the unary op makes some tests\n     // (e.g. PeepholeIntegration.testMinimizeExpr) very confusing because it\n     // leads to transformations like \"!!true\" --> \"!false\" --> \"false\".\n     // Do we really need to do this here?\n-    \n+\n     if (NodeUtil.isExpressionNode(parent)) {\n       // If the value isn't used, then just throw\n       // away the operator\n \n     switch (n.getType()) {\n       case Token.NOT:\n-        int result = leftVal.toBoolean(true) ? Token.FALSE : Token.TRUE;           \n+        int result = leftVal.toBoolean(true) ? Token.FALSE : Token.TRUE;\n         Node replacementNode = new Node(result);\n         parent.replaceChild(n, replacementNode);\n         reportCodeChange();\n           }\n \n           double negNum = -left.getDouble();\n-          \n+\n           Node negNumNode = Node.newNumber(negNum);\n           parent.replaceChild(n, negNumNode);\n           reportCodeChange();\n           // user because they can't be doing anything good\n           error(NEGATING_A_NON_NUMBER_ERROR, left);\n           return n;\n-        }    \n+        }\n         default:\n           return n;\n     }\n   }\n-  \n-  /**\n-   * Try to fold {@code left instanceof right} into {@code true} \n+\n+  /**\n+   * Try to fold {@code left instanceof right} into {@code true}\n    * or {@code false}.\n    */\n   private Node tryFoldInstanceof(Node n, Node left, Node right) {\n     Preconditions.checkArgument(n.getType() == Token.INSTANCEOF);\n-     \n+\n     // TODO(johnlenz) Use type information if available to fold\n     // instanceof.\n     if (NodeUtil.isLiteralValue(left)\n         && !NodeUtil.mayHaveSideEffects(right)) {\n-      \n+\n       Node replacementNode = null;\n-      \n+\n       if (NodeUtil.isImmutableValue(left)) {\n         // Non-object types are never instances.\n         replacementNode = new Node(Token.FALSE);\n           && \"Object\".equals(right.getString())) {\n         replacementNode = new Node(Token.TRUE);\n       }\n-      \n+\n       if (replacementNode != null) {\n         n.getParent().replaceChild(n, replacementNode);\n         reportCodeChange();\n         return replacementNode;\n-      }     \n-    }\n-    \n+      }\n+    }\n+\n     return n;\n   }\n-  \n+\n   private Node tryFoldAssign(Node n, Node left, Node right) {\n     Preconditions.checkArgument(n.getType() == Token.ASSIGN);\n \n     Node newNode = new Node(newType,\n         left.detachFromParent(), right.getLastChild().detachFromParent());\n     n.getParent().replaceChild(n, newNode);\n-    \n+\n     reportCodeChange();\n-    \n+\n     return newNode;\n   }\n-  \n+\n   /**\n    * Try to fold a AND/OR node.\n    */\n   private Node tryFoldAndOr(Node n, Node left, Node right) {\n     Node parent = n.getParent();\n-    \n+\n     Node result = null;\n \n     int type = n.getType();\n-   \n+\n     TernaryValue leftVal = NodeUtil.getBooleanValue(left);\n \n     if (leftVal != TernaryValue.UNKNOWN) {\n     } else {\n       TernaryValue rightVal = NodeUtil.getBooleanValue(right);\n       if (rightVal != TernaryValue.UNKNOWN) {\n-  \n+\n       // Note: We cannot always fold when the constant is on the\n       // right, because the typed value of the expression will depend\n       // on the type of the constant on the right, even if the boolean\n       n.removeChild(result);\n       parent.replaceChild(n, result);\n       reportCodeChange();\n-      \n+\n       return result;\n     } else {\n       return n;\n     }\n   }\n-  \n+\n   /**\n    * Expressions such as [foo() + 'a' + 'b'] generate parse trees\n    * where no node has two const children ((foo() + 'a') + 'b'), so\n       if (lr.getType() != Token.STRING) {\n         return n;\n       }\n-      \n+\n       String leftString = NodeUtil.getStringValue(lr);\n       String rightString = NodeUtil.getStringValue(right);\n       if (leftString != null && rightString != null) {\n         reportCodeChange();\n       }\n     }\n-    \n+\n     return n;\n   }\n \n       // Try arithmetic add\n       return tryFoldArithmetic(n, left, right);\n     }\n-    \n+\n     return n;\n   }\n-  \n+\n   /**\n    * Try to fold arithmetic binary operators\n    */\n    }\n     return n;\n   }\n-   \n+\n   private Node tryFoldAdd(Node node, Node left, Node right) {\n     Preconditions.checkArgument(node.getType() == Token.ADD);\n-    \n+\n     if (NodeUtil.isLiteralValue(left) && NodeUtil.isLiteralValue(right)) {\n       // 6 + 7\n       return tryFoldAddConstant(node, left, right);\n       return tryFoldLeftChildAdd(node, left, right);\n     }\n   }\n-  \n+\n   /**\n    * Try to fold arithmetic binary operators\n    */\n   private Node tryFoldBitAndOr(Node n, Node left, Node right) {\n     Preconditions.checkArgument(n.getType() == Token.BITAND\n         || n.getType() == Token.BITOR);\n-    \n+\n     if (left.getType() == Token.NUMBER &&\n         right.getType() == Token.NUMBER) {\n       double resultDouble;\n         default:\n           throw new Error(\"Unknown bitwise operator\");\n       }\n-      \n+\n       Node newNumber = Node.newNumber(resultDouble);\n       n.getParent().replaceChild(n, newNumber);\n       reportCodeChange();\n     }\n-    \n+\n     return n;\n   }\n-  \n+\n   /**\n    * Try to fold shift operations\n    */\n           throw new AssertionError(\"Unknown shift operator: \" +\n               Node.tokenToName(n.getType()));\n       }\n-      \n+\n       Node newNumber = Node.newNumber(result);\n       n.getParent().replaceChild(n, newNumber);\n       reportCodeChange();\n-      \n+\n       return newNumber;\n     }\n-    \n+\n     return n;\n   }\n-  \n+\n   /**\n    * Try to fold comparison nodes, e.g ==\n    */\n         return n;\n       }\n     }\n-    \n+\n     int op = n.getType();\n     boolean result;\n \n     Node newNode = new Node(result ? Token.TRUE : Token.FALSE);\n     n.getParent().replaceChild(n, newNode);\n     reportCodeChange();\n-    \n+\n     return newNode;\n   }\n-  \n+\n   private Node tryFoldKnownMethods(Node subtree) {\n     // For now we only support .join() and .indexOf()\n-    \n+\n     subtree = tryFoldStringJoin(subtree);\n-    \n+\n     if (subtree.getType() == Token.CALL) {\n       subtree = tryFoldStringIndexOf(subtree);\n     }\n-    \n+\n     return subtree;\n   }\n-  \n+\n   /**\n    * Try to evaluate String.indexOf/lastIndexOf:\n    *     \"abcdef\".indexOf(\"bc\") -> 1\n    */\n   private Node tryFoldStringIndexOf(Node n) {\n     Preconditions.checkArgument(n.getType() == Token.CALL);\n-    \n+\n     Node left = n.getFirstChild();\n-    \n+\n     if (left == null) {\n       return n;\n     }\n-    \n+\n     Node right = left.getNext();\n-    \n+\n     if (right == null) {\n       return n;\n     }\n-    \n+\n     if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n       return n;\n     }\n     n.getParent().replaceChild(n, newNode);\n \n     reportCodeChange();\n-    \n+\n     return newNode;\n   }\n \n    */\n   private Node tryFoldStringJoin(Node n) {\n     Node left = n.getFirstChild();\n-    \n+\n     if (left == null) {\n       return n;\n     }\n-    \n+\n     Node right = left.getNext();\n-    \n+\n     if (right == null) {\n       return n;\n     }\n-    \n+\n     if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n       return n;\n     }\n           // If the Node is not a string literal, ensure that\n           // it is coerced to a string.\n           Node replacement = new Node(Token.ADD,\n-              Node.newString(\"\").copyInformationFrom(right), \n+              Node.newString(\"\").copyInformationFrom(right),\n               foldedStringNode);\n           foldedStringNode = replacement;\n         }\n         reportCodeChange();\n         break;\n     }\n-   \n+\n     return n;\n   }\n \n    */\n   private Node tryFoldGetElem(Node n, Node left, Node right) {\n     Preconditions.checkArgument(n.getType() == Token.GETELEM);\n- \n+\n     if (left.getType() == Token.ARRAYLIT) {\n \n       if (right.getType() != Token.NUMBER) {\n     }\n     return n;\n   }\n-  \n+\n   /**\n    * Try to fold array-length. e.g [1, 2, 3].length ==> 3, [x, y].length ==> 2\n    */\n   private Node tryFoldGetProp(Node n, Node left, Node right) {\n     Preconditions.checkArgument(n.getType() == Token.GETPROP);\n- \n+\n     if (right.getType() == Token.STRING &&\n         right.getString().equals(\"length\")) {\n       int knownLength = -1;\n       Node lengthNode = Node.newNumber(knownLength);\n       n.getParent().replaceChild(n, lengthNode);\n       reportCodeChange();\n-      \n+\n       return lengthNode;\n     }\n-    \n+\n     return n;\n   }\n-  \n+\n }\n--- a/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n+++ b/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n public class PeepholeRemoveDeadCode extends AbstractPeepholeOptimization {\n \n   // TODO(dcc): Some (all) of these can probably be better achieved\n-  // using the control flow graph (like CheckUnreachableCode). \n+  // using the control flow graph (like CheckUnreachableCode).\n   // There is an existing CFG pass (UnreachableCodeElimination) that\n   // could be changed to use code from CheckUnreachableCode to do this.\n-  \n+\n   @Override\n-  Node optimizeSubtree(Node subtree) {   \n+  Node optimizeSubtree(Node subtree) {\n     switch(subtree.getType()) {\n       case Token.COMMA:\n         return tryFoldComma(subtree);\n       case Token.BLOCK:\n-        return tryFoldBlock(subtree);       \n+        return tryFoldBlock(subtree);\n       case Token.IF:\n       case Token.HOOK:\n-        return tryFoldHookIf(subtree);      \n+        return tryFoldHookIf(subtree);\n       case Token.WHILE:\n         return tryFoldWhile(subtree);\n        case Token.FOR: {\n         return tryFoldDo(subtree);\n         default:\n           return subtree;\n-    }    \n-  }\n-  \n+    }\n+  }\n+\n   private Node tryFoldComma(Node n) {\n     // If the left side does nothing replace the comma with the result.\n-    \n+\n     Node parent = n.getParent();\n     Node left = n.getFirstChild();\n     Node right = left.getNext();\n-    \n+\n     if (!NodeUtil.mayHaveSideEffects(left)) {\n       // Fold it!\n       n.removeChild(right);\n         // Add the right expression afterward.\n         Node newStatement = new Node(Token.EXPR_RESULT, right);\n         newStatement.copyInformationFrom(n);\n-        \n+\n         //This modifies outside the subtree, which is not\n         //desirable in a peephole optimization.\n         parent.getParent().addChildAfter(newStatement, parent);\n         return left;\n       }\n     }\n-    \n+\n     return n;\n   }\n \n    * Try removing unneeded block nodes and their useless children\n    */\n   Node tryFoldBlock(Node n) {\n-    // TODO(dcc): Make sure this is also applied in the global scope \n-    // (i.e. with Token.SCRIPT) parents \n+    // TODO(dcc): Make sure this is also applied in the global scope\n+    // (i.e. with Token.SCRIPT) parents\n     // Remove any useless children\n     for (Node c = n.getFirstChild(); c != null; ) {\n       Node next = c.getNext();  // save c.next, since 'c' may be removed\n       reportCodeChange();\n       return null;\n     }\n-    \n+\n     return n;\n   }\n- \n+\n   /**\n    * Try folding :? (hook) and IF nodes by removing dead branches.\n    * @return the replacement node, if changed, or the original if not\n           ifNode.addChildToBack(\n               new Node(Token.BLOCK, NodeUtil.newExpr(elseBody))\n                   .copyInformationFrom(elseBody));\n-          \n+\n           //This modifies outside the subtree, which is not\n           //desirable in a peephole optimization.\n           parent.getParent().replaceChild(parent, ifNode);\n           ifNode.addChildToBack(\n               new Node(Token.BLOCK, NodeUtil.newExpr(thenBody))\n                   .copyInformationFrom(thenBody));\n-          \n+\n           //This modifies outside the subtree, which is not\n           //desirable in a peephole optimization.\n           parent.getParent().replaceChild(parent, ifNode);\n       return branch;\n     }\n   }\n-  \n+\n   /**\n    * Removes WHILEs that always evaluate to false.\n    */\n     NodeUtil.redeclareVarsInsideBranch(n);\n     NodeUtil.removeChild(n.getParent(), n);\n     reportCodeChange();\n-    \n+\n     return null;\n   }\n-  \n+\n   /**\n    * Removes FORs that always evaluate to false.\n    */\n   Node tryFoldFor(Node n) {\n-    Preconditions.checkArgument(n.getType() == Token.FOR);    \n+    Preconditions.checkArgument(n.getType() == Token.FOR);\n     // This is not a FOR-IN loop\n     if (n.getChildCount() != 4) {\n       return n;\n     if (NodeUtil.getBooleanValue(cond) != TernaryValue.FALSE) {\n       return n;\n     }\n-    \n+\n     NodeUtil.redeclareVarsInsideBranch(n);\n     NodeUtil.removeChild(n.getParent(), n);\n     reportCodeChange();\n     return null;\n   }\n-  \n+\n   /**\n    * Removes DOs that always evaluate to false. This leaves the\n    * statements that were in the loop in a BLOCK node.\n \n     n.getParent().replaceChild(n, block);\n     reportCodeChange();\n-    \n+\n     return n;\n   }\n-  \n+\n   /**\n    *\n    */\n    * Remove always true loop conditions.\n    */\n   private void tryFoldForCondition(Node forCondition) {\n-    if (NodeUtil.getBooleanValue(forCondition) == TernaryValue.TRUE) { \n+    if (NodeUtil.getBooleanValue(forCondition) == TernaryValue.TRUE) {\n       forCondition.getParent().replaceChild(forCondition,\n           new Node(Token.EMPTY));\n-      reportCodeChange();     \n-    }\n-  } \n+      reportCodeChange();\n+    }\n+  }\n }\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n import java.util.regex.Pattern;\n \n /**\n- * A peephole optimization that minimizes code by simplifying conditional \n+ * A peephole optimization that minimizes code by simplifying conditional\n  * expressions, replacing IFs with HOOKs, replacing object constructors\n  * with literals, and simplifying returns.\n- * \n+ *\n *\n *\n  */\n-public class PeepholeSubstituteAlternateSyntax \n+public class PeepholeSubstituteAlternateSyntax\n   extends AbstractPeepholeOptimization {\n \n   private static final int AND_PRECEDENCE = NodeUtil.precedence(Token.AND);\n     DiagnosticType.error(\n         \"JSC_INVALID_REGULAR_EXPRESSION_FLAGS\",\n         \"Invalid flags to RegExp constructor: {0}\");\n-  \n+\n   static final Predicate<Node> DONT_TRAVERSE_FUNCTIONS_PREDICATE\n       = new Predicate<Node>() {\n     @Override\n       return input.getType() != Token.FUNCTION;\n     }\n   };\n-  \n+\n   /**\n    * Tries apply our various peephole minimizations on the passed in node.\n    */\n   public Node optimizeSubtree(Node node) {\n     switch(node.getType()) {\n       case Token.RETURN:\n-        return tryReduceReturn(node);  \n-        \n+        return tryReduceReturn(node);\n+\n       case Token.NOT:\n         return tryMinimizeNot(node);\n-        \n+\n       case Token.IF:\n         tryMinimizeCondition(node.getFirstChild());\n-        return tryMinimizeIf(node);   \n-        \n+        return tryMinimizeIf(node);\n+\n       case Token.EXPR_RESULT:\n         tryMinimizeCondition(node.getFirstChild());\n         return node;\n-        \n+\n       case Token.HOOK:\n         tryMinimizeCondition(node.getFirstChild());\n         return node;\n-        \n+\n       case Token.WHILE:\n       case Token.DO:\n       case Token.FOR:\n           tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n         }\n         return node;\n-        \n+\n       case Token.NEW:\n         node = tryFoldStandardConstructors(node);\n         if (node.getType() != Token.CALL) {\n         // convert a NEW node into a CALL node\n       case Token.CALL:\n         return tryFoldLiteralConstructor(node);\n-        \n+\n       default:\n           return node; //Nothing changed\n     }\n   }\n-  \n+\n   /**\n    * Reduce \"return undefined\" or \"return void 0\" to simply \"return\".\n-   * \n+   *\n    * Returns the replacement for n, or the original if no change was made.\n    */\n   private Node tryReduceReturn(Node n) {\n             break;\n       }\n     }\n-    \n+\n     return n;\n   }\n-  \n+\n   /**\n    * Try to minimize NOT nodes such as !(x==y).\n-   * \n+   *\n    * Returns the replacement for n or the original if no change was made\n    */\n   private Node tryMinimizeNot(Node n) {\n     Node parent = n.getParent();\n-    \n+\n     Node notChild = n.getFirstChild();\n     // negative operator of the current one : == -> != for instance.\n     int complementOperator;\n     reportCodeChange();\n     return newOperator;\n   }\n-  \n+\n   /**\n    * Try turning IF nodes into smaller HOOKs\n-   * \n+   *\n    * Returns the replacement for n or the original if no replacement was\n    * necessary.\n    */\n   private Node tryMinimizeIf(Node n) {\n-    \n+\n     Node parent = n.getParent();\n-    \n+\n     Node cond = n.getFirstChild();\n-    \n+\n     /* If the condition is a literal, we'll let other\n      * optimizations try to remove useless code.\n      */\n     if (NodeUtil.isLiteralValue(cond)) {\n       return n;\n     }\n-    \n+\n     Node thenBranch = cond.getNext();\n     Node elseBranch = thenBranch.getNext();\n \n         Node newExpr = NodeUtil.newExpr(and);\n         parent.replaceChild(n, newExpr);\n         reportCodeChange();\n-        \n+\n         return newExpr;\n       }\n \n       return n;\n     }\n-   \n+\n     /* TODO(dcc) This modifies the siblings of n, which is undesirable for a\n      * peephole optimization. This should probably get moved to another pass.\n      */\n             Node expr = NodeUtil.newExpr(assign);\n             parent.replaceChild(n, expr);\n             reportCodeChange();\n-            \n+\n             return expr;\n           }\n         } else if (NodeUtil.isCall(thenOp)) {\n           Node expr = NodeUtil.newExpr(hookNode);\n           parent.replaceChild(n, expr);\n           reportCodeChange();\n-          \n+\n           return expr;\n         }\n       }\n         name2.addChildrenToBack(hookNode);\n         parent.replaceChild(n, var);\n         reportCodeChange();\n-        \n+\n         return var;\n       }\n     }\n-    \n+\n     return n;\n   }\n-  \n+\n   /**\n    * Try to remove duplicate statements from IF blocks. For example:\n    *\n \n     return false;\n   }\n- \n+\n   /**\n    * @return The expression node.\n    */\n     Preconditions.checkState(isVarBlock(n));\n     return n.getFirstChild();\n   }\n-  \n+\n   /**\n    * Does a statement consume a 'dangling else'? A statement consumes\n    * a 'dangling else' if an 'else' token following the statement\n       }\n     }\n   }\n-  \n+\n   /**\n    * Does the expression contain an operator with lower precedence than\n    * the argument?\n    */\n   private boolean isLowerPrecedenceInExpression(Node n,\n-      final int precedence) {  \n+      final int precedence) {\n     Predicate<Node> isLowerPrecedencePredicate = new Predicate<Node>() {\n       @Override\n       public boolean apply(Node input) {\n         return NodeUtil.precedence(input.getType()) < precedence;\n       }\n     };\n-    \n+\n     return NodeUtil.has(n, isLowerPrecedencePredicate,\n         DONT_TRAVERSE_FUNCTIONS_PREDICATE);\n   }\n    * Does the expression contain a property assignment?\n    */\n   private boolean isPropertyAssignmentInExpression(Node n) {\n-    Predicate<Node> isPropertyAssignmentInExpressionPredicate = \n+    Predicate<Node> isPropertyAssignmentInExpressionPredicate =\n         new Predicate<Node>() {\n       @Override\n       public boolean apply(Node input) {\n-        return (input.getType() == Token.GETPROP && \n+        return (input.getType() == Token.GETPROP &&\n             input.getParent().getType() == Token.ASSIGN);\n       }\n     };\n-    \n+\n     return NodeUtil.has(n, isPropertyAssignmentInExpressionPredicate,\n         DONT_TRAVERSE_FUNCTIONS_PREDICATE);\n   }\n    *   !!x     --> x\n    * Thus:\n    *   !(x&&!y) --> !x||!!y --> !x||y\n-   *   \n+   *\n    *   Returns the replacement for n, or the original if no change was made\n    */\n   private Node tryMinimizeCondition(Node n) {\n     Node parent = n.getParent();\n-    \n+\n     switch (n.getType()) {\n       case Token.NOT:\n         Node first = n.getFirstChild();\n               reportCodeChange();\n \n               // The child has moved up, to minimize it recurse.\n-              \n+\n               return tryMinimizeCondition(n);\n             }\n           case Token.AND:\n       tryMinimizeCondition(c);\n       c = next;\n     }\n-    \n+\n     return n;\n   }\n-  \n+\n   /**\n    * Replaces a node with a number node if the new number node is not equivalent\n    * to the current node.\n-   * \n+   *\n    * Returns the replacement for n if it was replaced, otherwise returns n.\n    */\n   private Node maybeReplaceChildWithNumber(Node n, Node parent, int num) {\n     if (!newNode.isEquivalentTo(n)) {\n       parent.replaceChild(n, newNode);\n       reportCodeChange();\n-      \n+\n       return newNode;\n     }\n-    \n+\n     return n;\n   }\n-  \n+\n   private static final ImmutableSet<String> STANDARD_OBJECT_CONSTRUCTORS =\n     // String, Number, and Boolean functions return non-object types, whereas\n     // new String, new Number, and new Boolean return object types, so don't\n       \"RegExp\",\n       \"Error\"\n       );\n-  \n+\n   /**\n    * Fold \"new Object()\" to \"Object()\".\n    */\n   private Node tryFoldStandardConstructors(Node n) {\n     Preconditions.checkState(n.getType() == Token.NEW);\n-    \n+\n     // If name normalization has been run then we know that\n     // new Object() does in fact refer to what we think it is\n     // and not some custom-defined Object().\n         }\n       }\n     }\n-    \n+\n     return n;\n   }\n-  \n+\n   /**\n    * Replaces a new Array or Object node with an object literal, unless the\n    * call to Array or Object is to a local function with the same name.\n   private Node tryFoldLiteralConstructor(Node n) {\n     Preconditions.checkArgument(n.getType() == Token.CALL\n         || n.getType() == Token.NEW);\n-  \n+\n     Node constructorNameNode = n.getFirstChild();\n-    \n+\n     Node newLiteralNode = null;\n \n     // We require the AST to be normalized to ensure that, say,\n           n.getParent().replaceChild(n, newLiteralNode);\n           reportCodeChange();\n           return newLiteralNode;\n-        }   \n+        }\n       }\n     }\n     return n;\n-  } \n+  }\n \n   private static enum FoldArrayAction {\n     NOT_SAFE_TO_FOLD, SAFE_TO_FOLD_WITH_ARGS, SAFE_TO_FOLD_WITHOUT_ARGS}\n    * Checks if it is safe to fold Array() constructor into []. It can be\n    * obviously done, if the initial constructor has either no arguments or\n    * at least two. The remaining case may be unsafe since Array(number)\n-   * actually reserves memory for an empty array which contains number elements. \n+   * actually reserves memory for an empty array which contains number elements.\n    */\n   private FoldArrayAction isSafeToFoldArrayConstructor(Node arg) {\n     FoldArrayAction action = FoldArrayAction.NOT_SAFE_TO_FOLD;\n     return action;\n   }\n \n-  private Node tryFoldRegularExpressionConstructor(Node n) { \n+  private Node tryFoldRegularExpressionConstructor(Node n) {\n     Node parent = n.getParent();\n     Node constructor = n.getFirstChild();\n     Node pattern = constructor.getNext();  // e.g.  ^foobar$\n     if (!isASTNormalized()) {\n       return n;\n     }\n-    \n+\n     if (null == pattern || (null != flags && null != flags.getNext())) {\n       // too few or too many arguments\n       return n;\n     sb.append(s, pos, s.length());\n     return Node.newString(sb.toString()).copyInformationFrom(n);\n   }\n-  \n+\n   /**\n    * true if the javascript string would contain a unicode escape when written\n    * out as the body of a regular expression literal.\n--- a/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n+++ b/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n       // The anonymous function reference is also the definition.\n       return Lists.newArrayList(\n           (Definition)\n-              new DefinitionsRemover.FunctionExpressionDefinition(name));     \n+              new DefinitionsRemover.FunctionExpressionDefinition(name));\n     } else {\n       return null;\n     }\n--- a/src/com/google/javascript/jscomp/RemoveConstantExpressionsParallel.java\n+++ b/src/com/google/javascript/jscomp/RemoveConstantExpressionsParallel.java\n \n /**\n  * Execute {@link RemoveConstantExpressions} in parallel.\n- * \n+ *\n *\n  */\n final class RemoveConstantExpressionsParallel implements CompilerPass {\n   private final AbstractCompiler compiler;\n \n   private final int numThreads;\n-  \n+\n   RemoveConstantExpressionsParallel(AbstractCompiler compiler, int numThreads) {\n     this.compiler = compiler;\n     this.numThreads = numThreads;\n   }\n-  \n+\n   RemoveConstantExpressionsParallel(AbstractCompiler compiler) {\n     this(compiler, Runtime.getRuntime().availableProcessors());\n   }\n     // Estimate the number of CPU needed.\n     AstParallelizer splitter = AstParallelizer\n       .createNewFileLevelAstParallelizer(root);\n-      \n+\n     // Clean supply of RemoveConstantRValuesCallback.\n     Supplier<Task> supplier = new Supplier<Task>() {\n       @Override\n--- a/src/com/google/javascript/jscomp/RenameVars.java\n+++ b/src/com/google/javascript/jscomp/RenameVars.java\n \n   /** List of local NAME nodes */\n   private final ArrayList<Node> localNameNodes = new ArrayList<Node>();\n-  \n+\n   /**\n    * Maps a name node to its pseudo name, null if we are not generating so\n    * there will not no overhead unless we are debugging.\n       if (pseudoNameMap != null) {\n         recordPseudoName(n);\n       }\n-      \n+\n       if (local) {\n         // Local var: assign a new name\n         String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n--- a/src/com/google/javascript/jscomp/SourceAst.java\n+++ b/src/com/google/javascript/jscomp/SourceAst.java\n    */\n   public void setSourceFile(SourceFile file);\n }\n-\n--- a/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/SyntacticScopeCreator.java\n         // scope modeling.\n         compiler.report(\n             JSError.make(sourceName, nodeWithLineNumber,\n-                VAR_ARGUMENTS_SHADOWED_ERROR));        \n+                VAR_ARGUMENTS_SHADOWED_ERROR));\n       }\n     }\n   }\n--- a/src/com/google/javascript/jscomp/Tracer.java\n+++ b/src/com/google/javascript/jscomp/Tracer.java\n         break;\n     }\n   }\n-  \n+\n   /**\n    * Adds a new tracing statistic to a trace\n    *\n         }\n         etime = e.eventTime();\n       }\n-      // Minimum is 3 to preserve an indent even when max is small. \n+      // Minimum is 3 to preserve an indent even when max is small.\n       return Math.max(3, numDigits(max_time));\n     }\n   }\n--- a/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/TypedCodeGenerator.java\n   @Override\n   void add(Node n, Context context) {\n     Node parent = n.getParent();\n-    if (parent != null \n+    if (parent != null\n         && (parent.getType() == Token.BLOCK\n             || parent.getType() == Token.SCRIPT)) {\n       if (n.getType() == Token.FUNCTION) {\n         // Bail out if the paramNode is not there.\n         if (paramNode == null) {\n           break;\n-        }             \n+        }\n         sb.append(\" * @param {\" + getParameterNodeJSDocType(n) + \"} \");\n         sb.append(paramNode.getString());\n         sb.append(\"\\n\");\n \n     // Constructor/interface\n     if (funType.isConstructor() || funType.isInterface()) {\n-      \n+\n       FunctionType superConstructor = funType.getSuperClassConstructor();\n-      \n+\n       if (superConstructor != null) {\n         ObjectType superInstance =\n           funType.getSuperClassConstructor().getInstanceType();\n     sb.append(\" */\\n\");\n     return sb.toString();\n   }\n-  \n+\n   /**\n    * Creates a JSDoc-suitable String representation the type of a parameter.\n-   * \n-   * @param parameterNode The parameter node. \n+   *\n+   * @param parameterNode The parameter node.\n    */\n   private String getParameterNodeJSDocType(Node parameterNode) {\n     JSType parameterType = parameterNode.getJSType();\n     String typeString;\n-    \n+\n     // Emit unknown types as '*' (AllType) since '?' (UnknownType) is not\n     // a valid JSDoc type.\n     if (parameterType.isUnknownType()) {\n       typeString = \"*\";\n-    } else {     \n+    } else {\n       // Fix-up optional and vararg parameters to match JSDoc type language\n       if (parameterNode.isOptionalArg()) {\n         typeString = parameterType.restrictByNotNullOrUndefined() + \"=\";\n         typeString = parameterType.toString();\n       }\n     }\n-    \n+\n     return typeString;\n   }\n }\n--- a/src/com/google/javascript/jscomp/VarCheck.java\n+++ b/src/com/google/javascript/jscomp/VarCheck.java\n       \"module {1}\");\n \n   static final DiagnosticType NAME_REFERENCE_IN_EXTERNS_ERROR =\n-    DiagnosticType.error(\n+    DiagnosticType.warning(\n       \"JSC_NAME_REFERENCE_IN_EXTERNS\",\n       \"accessing name {0} in externs has no effect\");\n \n   static final DiagnosticType UNDEFINED_EXTERN_VAR_ERROR =\n-    DiagnosticType.error(\n+    DiagnosticType.disabled(\n       \"JSC_UNDEFINED_EXTERN_VAR_ERROR\",\n       \"name {0} is not undefined in the externs.\");\n \n   // Whether this is the post-processing sanity check.\n   private final boolean sanityCheck;\n \n+  // Whether extern checks emit error.\n+  private boolean strictExternCheck;\n+\n   VarCheck(AbstractCompiler compiler) {\n     this(compiler, false);\n   }\n \n   VarCheck(AbstractCompiler compiler, boolean sanityCheck) {\n     this.compiler = compiler;\n+    this.strictExternCheck = compiler.getErrorLevel(\n+        JSError.make(\"\", 0, 0, UNDEFINED_EXTERN_VAR_ERROR)) == CheckLevel.ERROR;\n     this.sanityCheck = sanityCheck;\n   }\n \n         // current scope.\n       } else {\n         // The extern checks are stricter, don't report a second error.\n-        if (!t.getInput().isExtern()) {\n+        if (!strictExternCheck || !t.getInput().isExtern()) {\n           t.report(n, UNDEFINED_VAR_ERROR, varName);\n         }\n \n--- a/src/com/google/javascript/jscomp/ant/CompileTask.java\n+++ b/src/com/google/javascript/jscomp/ant/CompileTask.java\n   private WarningLevel warningLevel;\n   private boolean debugOptions;\n   private String encoding = \"UTF-8\";\n-  private String outputEncoding = \"UTF-8\"; \n+  private String outputEncoding = \"UTF-8\";\n   private CompilationLevel compilationLevel;\n   private boolean customExternsOnly;\n   private boolean manageDependencies;\n     this.outputFile = value;\n   }\n \n-  /** \n-   * Set input file encoding \n+  /**\n+   * Set input file encoding\n    */\n   public void setEncoding(String encoding) {\n     this.encoding = encoding;\n   }\n \n-  /** \n-   * Set output file encoding \n+  /**\n+   * Set output file encoding\n    */\n   public void setOutputEncoding(String outputEncoding) {\n     this.outputEncoding = outputEncoding;\n         Project.MSG_DEBUG);\n   }\n }\n-\n--- a/src/com/google/javascript/jscomp/graph/UnionFind.java\n+++ b/src/com/google/javascript/jscomp/graph/UnionFind.java\n  */\n public interface UnionFind<E> {\n \n-  /** \n-   * Adds the given element to a new set if it is not already in a set. \n-   * \n-   * @throws UnsupportedOperationException if the add operation is not \n-   *     supported by this union-find. \n+  /**\n+   * Adds the given element to a new set if it is not already in a set.\n+   *\n+   * @throws UnsupportedOperationException if the add operation is not\n+   *     supported by this union-find.\n    */\n   public void add(E e);\n \n    * Unions the equivalence classes of {@code a} and {@code b} and returns the\n    * representative of the resulting equivalence class.  The elements will be\n    * added if they are not already present.\n-   * \n-   * @throws UnsupportedOperationException if the add operation is not \n-   *     supported by this union-find. \n+   *\n+   * @throws UnsupportedOperationException if the add operation is not\n+   *     supported by this union-find.\n    */\n   public E union(E a, E b);\n \n    * Returns true if {@code a} and {@code b} belong to the same equivalence\n    * class.\n    *\n-   * @throws IllegalArgumentException if any argument is not an element of this \n+   * @throws IllegalArgumentException if any argument is not an element of this\n    *     structure.\n    */\n   public boolean areEquivalent(E a, E b);\n--- a/src/com/google/javascript/rhino/ErrorReporter.java\n+++ b/src/com/google/javascript/rhino/ErrorReporter.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n--- a/src/com/google/javascript/rhino/JSDocInfo.java\n+++ b/src/com/google/javascript/rhino/JSDocInfo.java\n       }\n     }\n \n-    return nodes;    \n+    return nodes;\n   }\n }\n--- a/src/com/google/javascript/rhino/ObjToIntMap.java\n+++ b/src/com/google/javascript/rhino/ObjToIntMap.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n--- a/src/com/google/javascript/rhino/Parser.java\n+++ b/src/com/google/javascript/rhino/Parser.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n--- a/src/com/google/javascript/rhino/SimpleErrorReporter.java\n+++ b/src/com/google/javascript/rhino/SimpleErrorReporter.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n  * file under either the MPL or the GPL.\n  *\n  * ***** END LICENSE BLOCK ***** */\n- \n+\n package com.google.javascript.rhino;\n \n import java.util.ArrayList;\n     {\n         return warnings;\n     }\n-  \n+\n     private String formatDetailedMessage(\n         String message, String sourceName, int line, String lineSource,\n         int lineOffset)\n--- a/src/com/google/javascript/rhino/SourcePosition.java\n+++ b/src/com/google/javascript/rhino/SourcePosition.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n  * file under either the MPL or the GPL.\n  *\n  * ***** END LICENSE BLOCK ***** */\n- \n+\n package com.google.javascript.rhino;\n \n /**\n--- a/src/com/google/javascript/rhino/Token.java\n+++ b/src/com/google/javascript/rhino/Token.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n         SETCONST       = 150,\n         SETCONSTVAR    = 151,\n         DEBUGGER       = 152,\n-        \n+\n         // JSCompiler introduced tokens\n         LABEL_NAME     = 153,\n-        \n+\n         LAST_TOKEN     = 153,\n \n         // JSDoc-only tokens\n           case QMARK:           return \"QMARK\";\n           case ELLIPSIS:        return \"ELLIPSIS\";\n           case BANG:            return \"BANG\";\n-          case VOID:            return \"VOID\"; \n+          case VOID:            return \"VOID\";\n           case EQUALS:          return \"EQUALS\";\n         }\n \n--- a/src/com/google/javascript/rhino/TokenStream.java\n+++ b/src/com/google/javascript/rhino/TokenStream.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n--- a/src/com/google/javascript/rhino/UintMap.java\n+++ b/src/com/google/javascript/rhino/UintMap.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n--- a/src/com/google/javascript/rhino/jstype/AllType.java\n+++ b/src/com/google/javascript/rhino/jstype/AllType.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n  * file under either the MPL or the GPL.\n  *\n  * ***** END LICENSE BLOCK ***** */\n- \n+\n package com.google.javascript.rhino.jstype;\n \n import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN;\n--- a/src/com/google/javascript/rhino/jstype/BooleanLiteralSet.java\n+++ b/src/com/google/javascript/rhino/jstype/BooleanLiteralSet.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n  * file under either the MPL or the GPL.\n  *\n  * ***** END LICENSE BLOCK ***** */\n- \n+\n package com.google.javascript.rhino.jstype;\n \n /**\n--- a/src/com/google/javascript/rhino/jstype/EnumElementType.java\n+++ b/src/com/google/javascript/rhino/jstype/EnumElementType.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n  * file under either the MPL or the GPL.\n  *\n  * ***** END LICENSE BLOCK ***** */\n- \n+\n package com.google.javascript.rhino.jstype;\n \n \n--- a/src/com/google/javascript/rhino/jstype/EnumType.java\n+++ b/src/com/google/javascript/rhino/jstype/EnumType.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n  * file under either the MPL or the GPL.\n  *\n  * ***** END LICENSE BLOCK ***** */\n- \n+\n package com.google.javascript.rhino.jstype;\n \n import static com.google.javascript.rhino.jstype.TernaryValue.FALSE;\n--- a/src/com/google/javascript/rhino/jstype/ErrorFunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/ErrorFunctionType.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n  * file under either the MPL or the GPL.\n  *\n  * ***** END LICENSE BLOCK ***** */\n- \n+\n package com.google.javascript.rhino.jstype;\n \n import static com.google.javascript.rhino.jstype.JSTypeNative.ALL_TYPE;\n--- a/src/com/google/javascript/rhino/jstype/IndexedType.java\n+++ b/src/com/google/javascript/rhino/jstype/IndexedType.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n  * file under either the MPL or the GPL.\n  *\n  * ***** END LICENSE BLOCK ***** */\n- \n+\n package com.google.javascript.rhino.jstype;\n \n /**\n--- a/src/com/google/javascript/rhino/jstype/InstanceObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/InstanceObjectType.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n  * file under either the MPL or the GPL.\n  *\n  * ***** END LICENSE BLOCK ***** */\n- \n+\n package com.google.javascript.rhino.jstype;\n \n \n   public Iterable<ObjectType> getCtorImplementedInterfaces() {\n     return getConstructor().getImplementedInterfaces();\n   }\n-  \n+\n   // The owner will always be a resolved type, so there's no need to set\n   // the constructor in resolveInternal.\n   // (it would lead to infinite loops if we did).\n--- a/src/com/google/javascript/rhino/jstype/NullType.java\n+++ b/src/com/google/javascript/rhino/jstype/NullType.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n  * file under either the MPL or the GPL.\n  *\n  * ***** END LICENSE BLOCK ***** */\n- \n+\n package com.google.javascript.rhino.jstype;\n \n import static com.google.javascript.rhino.jstype.TernaryValue.FALSE;\n--- a/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n  * file under either the MPL or the GPL.\n  *\n  * ***** END LICENSE BLOCK ***** */\n- \n+\n package com.google.javascript.rhino.jstype;\n \n import com.google.javascript.rhino.ErrorReporter;\n--- a/src/com/google/javascript/rhino/jstype/RecordType.java\n+++ b/src/com/google/javascript/rhino/jstype/RecordType.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n  * file under either the MPL or the GPL.\n  *\n  * ***** END LICENSE BLOCK ***** */\n- \n+\n package com.google.javascript.rhino.jstype;\n \n import com.google.javascript.rhino.ErrorReporter;\n--- a/src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java\n+++ b/src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n  * file under either the MPL or the GPL.\n  *\n  * ***** END LICENSE BLOCK ***** */\n- \n+\n package com.google.javascript.rhino.jstype;\n \n import com.google.common.collect.ImmutableMap;\n--- a/src/com/google/javascript/rhino/jstype/StaticScope.java\n+++ b/src/com/google/javascript/rhino/jstype/StaticScope.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n  * file under either the MPL or the GPL.\n  *\n  * ***** END LICENSE BLOCK ***** */\n- \n+\n package com.google.javascript.rhino.jstype;\n \n /**\n--- a/src/com/google/javascript/rhino/jstype/StaticSlot.java\n+++ b/src/com/google/javascript/rhino/jstype/StaticSlot.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n  * file under either the MPL or the GPL.\n  *\n  * ***** END LICENSE BLOCK ***** */\n- \n+\n package com.google.javascript.rhino.jstype;\n \n /**\n--- a/src/com/google/javascript/rhino/jstype/TernaryValue.java\n+++ b/src/com/google/javascript/rhino/jstype/TernaryValue.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n  * file under either the MPL or the GPL.\n  *\n  * ***** END LICENSE BLOCK ***** */\n- \n+\n package com.google.javascript.rhino.jstype;\n \n /**\n--- a/src/com/google/javascript/rhino/jstype/Visitor.java\n+++ b/src/com/google/javascript/rhino/jstype/Visitor.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n  * file under either the MPL or the GPL.\n  *\n  * ***** END LICENSE BLOCK ***** */\n- \n+\n package com.google.javascript.rhino.jstype;\n \n \n--- a/src/com/google/javascript/rhino/jstype/VoidType.java\n+++ b/src/com/google/javascript/rhino/jstype/VoidType.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n  * file under either the MPL or the GPL.\n  *\n  * ***** END LICENSE BLOCK ***** */\n- \n+\n package com.google.javascript.rhino.jstype;\n \n import static com.google.javascript.rhino.jstype.TernaryValue.FALSE;\n--- a/src/com/google/javascript/rhino/testing/TestErrorReporter.java\n+++ b/src/com/google/javascript/rhino/testing/TestErrorReporter.java\n-/* \n+/*\n  *\n  * ***** BEGIN LICENSE BLOCK *****\n  * Version: MPL 1.1/GPL 2.0\n  * file under either the MPL or the GPL.\n  *\n  * ***** END LICENSE BLOCK ***** */\n- \n+\n package com.google.javascript.rhino.testing;\n \n import com.google.javascript.rhino.ErrorReporter;\n--- a/test/com/google/javascript/jscomp/AliasExternalsTest.java\n+++ b/test/com/google/javascript/jscomp/AliasExternalsTest.java\n \n   public void testNewOperator() {\n     test(\"var x;new x(window);window;window;window;window;window\",\n-        \n+\n          \"var GLOBAL_window=window; var x;\" +\n          \"  new x(GLOBAL_window);GLOBAL_window;GLOBAL_window;\" +\n          \"  GLOBAL_window;GLOBAL_window;GLOBAL_window\");\n   }\n-  \n+\n   /**\n    * Test the standard replacement for GETPROP\n    */\n--- a/test/com/google/javascript/jscomp/AstParallelizerTest.java\n+++ b/test/com/google/javascript/jscomp/AstParallelizerTest.java\n \n /**\n  * Unit tests for {@link AstParallelizer}.\n- * \n+ *\n *\n  */\n public class AstParallelizerTest extends TestCase {\n \n   private static final String HOLDER = AstParallelizer.TEMP_NAME;\n-  \n+\n   public void testNoSplit() {\n     splitFunctions(\"\", \"\");\n     splitFunctions(\"var x\", \"var x\");\n   public void testSplitNamedFuntion() {\n     splitFunctions(\"function foo() { foo() } foo()\",\n                    \"function \" + HOLDER + \"() {} foo()\",\n-                   \"function foo() { foo() }\"); \n+                   \"function foo() { foo() }\");\n   }\n-  \n+\n \n   public void testSplitNamedFuntionWithArgs() {\n     splitFunctions(\"function foo(x) { foo(1) } foo(1)\",\n                    \"function \" + HOLDER + \"() {} foo(1)\",\n-                   \"function foo(x) { foo(1) }\"); \n+                   \"function foo(x) { foo(1) }\");\n   }\n \n   public void testSplitAnonFuntion() {\n     splitFunctions(\"var foo = function(x) { foo(1) }; foo(1)\",\n                    \"var foo = function \" + HOLDER + \"() {}; foo(1)\",\n-                   \"function(x) { foo(1) }\"); \n+                   \"function(x) { foo(1) }\");\n   }\n-  \n+\n   public void testSplitInplaceCall() {\n     splitFunctions(\"(function() { print('hi') })()\",\n                    \"(function \" + HOLDER + \"() {})()\",\n-                   \"function() { print('hi') }\"); \n+                   \"function() { print('hi') }\");\n   }\n-  \n+\n   public void testSplitMupltiFuntions() {\n-    splitFunctions(\"var foo = function(x) { foo(1) }; foo();\" + \n+    splitFunctions(\"var foo = function(x) { foo(1) }; foo();\" +\n                    \"var bar = function(x,y) { bar(1,2) }; bar(1,2)\",\n                    // Output Root\n                    \"var foo = function \" + HOLDER + \"() {}; foo();\" +\n                    // foo\n                    \"function(x) { foo(1) }\",\n                    // bar\n-                   \"function(x,y) { bar(1,2) }\"); \n+                   \"function(x,y) { bar(1,2) }\");\n   }\n-  \n+\n   public void testInnerFunctions() {\n     splitFunctions(\"var foo = function() {var bar = function() {}}\",\n                    \"var foo = function \" + HOLDER + \"() {}\",\n     splitFiles(new String[] {\n         \"var a\", \"var b\", \"var c\", \"var d\", \"function e() {}\"});\n   }\n-  \n+\n   /**\n    * Splits at function level with {@link AstParallelizer#split()}, verify the\n    * output matches what is expected and then verify\n     Compiler compiler = new Compiler();\n     Node orginal = compiler.parseTestCode(input);\n     Node root = orginal.cloneTree();\n-    AstParallelizer parallelizer = \n+    AstParallelizer parallelizer =\n       AstParallelizer.createNewFunctionLevelAstParallelizer(root, true);\n     List<Node> forest = parallelizer.split();\n     assertEquals(output.length, forest.size());\n       Node tree = compiler.parseTestCode(output[i++]);\n       assertEquals(compiler.toSource(tree), compiler.toSource(n));\n     }\n-    \n+\n     parallelizer.join();\n     assertTrue(orginal.checkTreeEqualsSilent(root));\n   }\n-  \n+\n   private void splitFiles(String[] input) {\n     Compiler compiler = new Compiler();\n     JSSourceFile[] files = new JSSourceFile[input.length];\n-    \n+\n     for (int i = 0; i < files.length; i ++) {\n       files[i] = JSSourceFile.fromCode(\"file\" + i, input[i]);\n     }\n     Node orginal = compiler.getRoot();\n     Node root = orginal.cloneTree();\n \n-    AstParallelizer parallelizer = \n+    AstParallelizer parallelizer =\n       AstParallelizer.createNewFileLevelAstParallelizer(root);\n     List<Node> forest = parallelizer.split();\n     assertEquals(input.length, forest.size());\n       Node tree = compiler.parseTestCode(input[i++]);\n       assertEquals(compiler.toSource(tree), compiler.toSource(n));\n     }\n-    \n+\n     parallelizer.join();\n     assertTrue(orginal.checkTreeEqualsSilent(root));\n   }\n--- a/test/com/google/javascript/jscomp/CheckPathsBetweenNodesTest.java\n+++ b/test/com/google/javascript/jscomp/CheckPathsBetweenNodesTest.java\n   }\n \n   private static final Predicate<String> FALSE = Predicates.alwaysFalse();\n-  \n+\n   private static final Predicate<DiGraphEdge<String, String>> ALL_EDGE =\n       Predicates.alwaysTrue();\n \n     assertGood(createTest(g, \"a\", \"e\", Predicates.equalTo(\"e\"), ALL_EDGE));\n     assertBad(createTest(g, \"a\", \"e\", Predicates.equalTo(\"f\"), ALL_EDGE));\n   }\n-  \n+\n   /**\n    * Tests another graph with cycles. The topology of this graph was inspired\n    * by a control flow graph that was being incorrectly analyzed by an early\n     g.createDirectedGraphNode(\"b\");\n     g.createDirectedGraphNode(\"c\");\n     g.createDirectedGraphNode(\"d\");\n-    \n+\n     g.connect(\"a\", \"-\", \"b\");\n     g.connect(\"b\", \"-\", \"c\");\n     g.connect(\"c\", \"-\", \"b\");\n     g.connect(\"b\", \"-\", \"d\");\n-    \n+\n     assertGood(createTest(g, \"a\", \"d\", Predicates.equalTo(\"a\"), ALL_EDGE));\n     assertBad(createTest(g, \"a\", \"d\", Predicates.equalTo(\"z\"), ALL_EDGE));\n   }\n-  \n+\n   /**\n    * Tests another graph with cycles. The topology of this graph was inspired\n    * by a control flow graph that was being incorrectly analyzed by an early\n     g.createDirectedGraphNode(\"b\");\n     g.createDirectedGraphNode(\"c\");\n     g.createDirectedGraphNode(\"d\");\n-    \n+\n     g.connect(\"a\", \"-\", \"b\");\n     g.connect(\"b\", \"-\", \"c\");\n     g.connect(\"c\", \"-\", \"b\");\n     g.connect(\"b\", \"-\", \"d\");\n     g.connect(\"c\", \"-\", \"d\");\n-    \n+\n     assertGood(createTest(g, \"a\", \"d\", Predicates.equalTo(\"a\"), ALL_EDGE));\n     assertBad(createTest(g, \"a\", \"d\", Predicates.equalTo(\"z\"), ALL_EDGE));\n   }\n \n-  \n+\n   /**\n    * Much of the tests are done by testing all paths. We quickly verified\n    * that some paths are indeed correct for the some path case.\n     g.connect(\"a\", \"-\", \"c\");\n     g.connect(\"b\", \"-\", \"d\");\n     g.connect(\"c\", \"-\", \"d\");\n-    \n+\n     assertTrue(createTest(g, \"a\", \"d\", Predicates.equalTo(\"b\"), ALL_EDGE)\n         .somePathsSatisfyPredicate());\n     assertTrue(createTest(g, \"a\", \"d\", Predicates.equalTo(\"c\"), ALL_EDGE)\n     assertFalse(createTest(g, \"a\", \"d\", Predicates.equalTo(\"NONE\"), ALL_EDGE)\n         .somePathsSatisfyPredicate());\n   }\n-  \n+\n   public void testSomePath2() {\n     // No Paths between nodes, by definition, always false.\n     DiGraph<String, String> g = new LinkedDirectedGraph<String, String>();\n     assertTrue(createTest(g, \"a\", \"b\", Predicates.equalTo(\"a\"), ALL_EDGE)\n         .somePathsSatisfyPredicate());\n   }\n-  \n+\n   public void testNonInclusive() {\n     // No Paths between nodes, by definition, always false.\n     DiGraph<String, String> g = new LinkedDirectedGraph<String, String>();\n   private static <N, E> void assertGood(CheckPathsBetweenNodes<N, E> test) {\n     assertTrue(test.allPathsSatisfyPredicate());\n   }\n-  \n+\n   private static <N, E> void assertBad(CheckPathsBetweenNodes<N, E> test) {\n     assertFalse(test.allPathsSatisfyPredicate());\n   }\n         graph.getDirectedGraphNode(entry), graph.getDirectedGraphNode(exit),\n         nodePredicate, edgePredicate);\n   }\n-  \n+\n   private static CheckPathsBetweenNodes<String, String>\n       createNonInclusiveTest(\n         DiGraph<String, String> graph,\n         graph.getDirectedGraphNode(entry), graph.getDirectedGraphNode(exit),\n         nodePredicate, edgePredicate, false);\n   }\n-  \n+\n   private static Predicate<DiGraphEdge<String, String>>\n       edgeIs(final Object val) {\n     return new Predicate<DiGraphEdge<String, String>>() {\n--- a/test/com/google/javascript/jscomp/CollapseVariableDeclarationsTest.java\n+++ b/test/com/google/javascript/jscomp/CollapseVariableDeclarationsTest.java\n     testSame(\"a.b = a.c = a.x; if (a.c) {}\");\n     testSame(\"a.b = a.c = a.x; if (a.b) {}\");\n   }\n-  \n+\n   public void testBug2072343() {\n     testSame(\"a = a.x;a = a.x\");\n     testSame(\"a = a.x;b = a.x\");\n--- a/test/com/google/javascript/jscomp/CombinedCompilerPassTest.java\n+++ b/test/com/google/javascript/jscomp/CombinedCompilerPassTest.java\n *\n  */\n public class CombinedCompilerPassTest extends TestCase  {\n-  \n+\n   private Compiler compiler;\n \n-  /** \n+  /**\n    * Returns a Node tree with the post-order traversal a b c d e f g h i j k l m\n    * and the in-order traversal m d a b c h e f g l i j k:\n-   * \n+   *\n    *                                   m\n    *                         ,---------|---------.\n    *                         d         h         l\n    *                      ,--|--.   ,--|--.   ,--|--.\n    *                      a  b  c   e  f  g   i  j  k\n-   * \n+   *\n    */\n   private static Node createPostOrderAlphabet() {\n     Node a = Node.newString(\"a\");\n     Node k = Node.newString(\"k\");\n     Node l = Node.newString(\"l\");\n     Node m = Node.newString(\"m\");\n-    \n+\n     d.addChildToBack(a);\n     d.addChildToBack(b);\n     d.addChildToBack(c);\n-    \n+\n     h.addChildrenToBack(e);\n     h.addChildrenToBack(f);\n     h.addChildrenToBack(g);\n-    \n+\n     l.addChildToBack(i);\n     l.addChildToBack(j);\n     l.addChildToBack(k);\n-    \n+\n     m.addChildToBack(d);\n     m.addChildToBack(h);\n     m.addChildToBack(l);\n-    \n+\n     return m;\n   }\n-  \n+\n   @Override\n   public void setUp() throws Exception {\n     super.setUp();\n     compiler = new Compiler();\n   }\n-  \n+\n   /**\n    * Concatenates contents of string nodes encountered in pre-order\n    * and post-order traversals. Abbreviates traversals by ignoring subtrees\n     private StringBuffer visited = new StringBuffer();\n     private StringBuffer shouldTraversed = new StringBuffer();\n     private Set<String> ignoring = Sets.newHashSet();\n-    \n+\n     ConcatTraversal ignore(String s) {\n       ignoring.add(s);\n       return this;\n     }\n-    \n+\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       assertEquals(Token.STRING, n.getType());\n       visited.append(n.getString());\n     }\n-    \n-    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) { \n+\n+    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n       assertEquals(Token.STRING, n.getType());\n       shouldTraversed.append(n.getString());\n       return !ignoring.contains(n.getString());\n     }\n-    \n+\n     /** Returns strings concatenated during post-order traversal. */\n     String getVisited() {\n       return visited.toString();\n     }\n-    \n+\n     /** Returns strings concatenated during pre-order traversal. */\n     String getShouldTraversed() {\n       return shouldTraversed.toString();\n     }\n-    \n+\n     Collection<String> getIgnoring() {\n       return ignoring;\n     }\n   }\n-  \n+\n   /**\n    * Collection of data for a traversal test. Contains the traversal callback\n    * and the exepcted pre- and post-order traversal results.\n       this.expectedVisited = expectedVisited;\n       this.shouldTraverseExpected = shouldTraverseExpected;\n     }\n-    \n+\n     ConcatTraversal getTraversal() {\n       return traversal;\n     }\n-    \n+\n     void checkResults() {\n       assertEquals(\"ConcatTraversal ignoring \" +\n                    traversal.getIgnoring().toString() +\n                    \" has unexpected visiting order\",\n                    expectedVisited, traversal.getVisited());\n-      \n+\n       assertEquals(\"ConcatTraversal ignoring \" +\n                    traversal.getIgnoring().toString() +\n                    \" has unexpected traversal order\",\n                    shouldTraverseExpected, traversal.getShouldTraversed());\n     }\n   }\n-  \n+\n   private static List<TestHelper> createStringTests() {\n     List<TestHelper> tests = Lists.newArrayList();\n-    \n+\n     tests.add(new TestHelper(\n         new ConcatTraversal(), \"abcdefghijklm\", \"mdabchefglijk\"));\n-    \n+\n     tests.add(new TestHelper(\n         new ConcatTraversal().ignore(\"d\"), \"efghijklm\", \"mdhefglijk\"));\n-    \n+\n     tests.add(new TestHelper(\n         new ConcatTraversal().ignore(\"f\"), \"abcdeghijklm\", \"mdabchefglijk\"));\n-    \n+\n     tests.add(new TestHelper(new ConcatTraversal().ignore(\"m\"), \"\", \"m\"));\n-    \n+\n     return tests;\n   }\n-   \n+\n   public void testIndividualPasses() {\n     for (TestHelper test : createStringTests()) {\n       CombinedCompilerPass pass =\n       test.checkResults();\n     }\n   }\n-   \n+\n   public void testCombinedPasses() {\n     List<TestHelper> tests  = createStringTests();\n     Callback[] callbacks = new Callback[tests.size()];\n       test.checkResults();\n     }\n   }\n-  \n+\n   /**\n    * Records the scopes visited during an AST traversal. Abbreviates traversals\n    * by ignoring subtrees rooted with specified NAME nodes.\n    */\n   private static class ScopeRecordingCallback implements ScopedCallback {\n-    \n+\n     Set<Node> visitedScopes = Sets.newHashSet();\n     Set<String> ignoring = Sets.newHashSet();\n-    \n+\n     void ignore(String name) {\n       ignoring.add(name);\n     }\n-    \n+\n     @Override\n     public void enterScope(NodeTraversal t) {\n       visitedScopes.add(t.getScopeRoot());\n     public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n       return n.getType() != Token.NAME || !ignoring.contains(n.getString());\n     }\n-    \n+\n     Set<Node> getVisitedScopes() {\n       return visitedScopes;\n     }\n \n     @Override\n-    public void exitScope(NodeTraversal t) {  \n-    }\n-\n-    @Override\n-    public void visit(NodeTraversal t, Node n, Node parent) {     \n-    }\n-    \n-  }\n-  \n+    public void exitScope(NodeTraversal t) {\n+    }\n+\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+    }\n+\n+  }\n+\n   public void testScopes() {\n     Node root =\n         compiler.parseTestCode(\"var y = function() { var x = function() { };}\");\n-    \n+\n     ScopeRecordingCallback c1 = new ScopeRecordingCallback();\n     c1.ignore(\"y\");\n     ScopeRecordingCallback c2 = new ScopeRecordingCallback();\n     c2.ignore(\"x\");\n     ScopeRecordingCallback c3 = new ScopeRecordingCallback();\n-    \n+\n     CombinedCompilerPass pass = new CombinedCompilerPass(compiler, c1, c2, c3);\n     pass.process(null, root);\n-    \n+\n     assertEquals(1, c1.getVisitedScopes().size());\n     assertEquals(2, c2.getVisitedScopes().size());\n     assertEquals(3, c3.getVisitedScopes().size());\n--- a/test/com/google/javascript/jscomp/CompilerTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java\n       assertEquals(\"There should be one error. \" + errors,\n           1, compiler.getErrorCount());\n       assertEquals(errors, error, compiler.getErrors()[0].getType());\n+\n+      if (warning != null) {\n+        String warnings = \"\";\n+        for (JSError actualError : compiler.getWarnings()) {\n+          warnings += actualError.description + \"\\n\";\n+        }\n+        assertEquals(\"There should be one warning. \" + warnings,\n+            1, compiler.getWarningCount());\n+        assertEquals(warnings, warning, compiler.getWarnings()[0].getType());\n+      }\n     }\n   }\n \n--- a/test/com/google/javascript/jscomp/ControlFlowAnalysisTest.java\n+++ b/test/com/google/javascript/jscomp/ControlFlowAnalysisTest.java\n     ControlFlowGraph<Node> cfg = createCfg(src, true);\n     assertCrossEdge(cfg, Token.EXPR_RESULT, Token.BLOCK, Branch.ON_EX);\n   }\n-  \n+\n   public void testSynBlock() {\n     String src = \"START(); var x; END()\";\n     ControlFlowGraph<Node> cfg = createCfg(src, true);\n     assertDownEdge(cfg, Token.BLOCK, Token.EXPR_RESULT, Branch.SYN_BLOCK);\n   }\n-  \n+\n   public void testPartialTraversalOfScope() {\n     Compiler compiler = new Compiler();\n     ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, true);\n--- a/test/com/google/javascript/jscomp/CreateSyntheticBlocksTest.java\n+++ b/test/com/google/javascript/jscomp/CreateSyntheticBlocksTest.java\n         new CreateSyntheticBlocks(compiler, START_MARKER, END_MARKER).process(\n             externs, js);\n         NodeTraversal.traverse(compiler, js, new MinimizeExitPoints(compiler));\n-                \n-        new PeepholeOptimizationsPass(compiler, new \n+\n+        new PeepholeOptimizationsPass(compiler, new\n             PeepholeRemoveDeadCode()).process(externs, js);\n-        \n+\n         new Denormalize(compiler).process(externs, js);\n       }\n     };\n--- a/test/com/google/javascript/jscomp/DataFlowAnalysisTest.java\n+++ b/test/com/google/javascript/jscomp/DataFlowAnalysisTest.java\n     List<ConstPropLatticeElement> branchedFlowThrough(Instruction node,\n         ConstPropLatticeElement input) {\n       List<ConstPropLatticeElement> result = Lists.newArrayList();\n-      List<DiGraphEdge<Instruction, Branch>> outEdges = \n+      List<DiGraphEdge<Instruction, Branch>> outEdges =\n         getCfg().getOutEdges(node);\n       if (node.isArithmetic()) {\n         assertTrue(outEdges.size() < 2);\n--- a/test/com/google/javascript/jscomp/ExternExportsPassTest.java\n+++ b/test/com/google/javascript/jscomp/ExternExportsPassTest.java\n   private void setRunCheckTypes(boolean shouldRunCheckTypes) {\n     runCheckTypes = shouldRunCheckTypes;\n   }\n-  \n+\n   @Override\n   public void setUp() throws Exception {\n     super.setUp();\n-    \n+\n     setRunCheckTypes(true);\n   }\n-  \n+\n   public void testExportSymbol() throws Exception {\n     compileAndCheck(\"var a = {}; a.b = {}; a.b.c = function(d, e, f) {};\" +\n                     \"goog.exportSymbol('foobar', a.b.c)\",\n                     \" */\\n\" +\n                     \"var foobar = function(d, e, f) {\\n}\");\n   }\n-  \n+\n   public void testExportSymbolDefinedInVar() throws Exception {\n     compileAndCheck(\"var a = function(d, e, f) {};\" +\n                     \"goog.exportSymbol('foobar', a)\",\n                     \" */\\n\" +\n                     \"a.b.prototype.c = function(g, h, i) {\\n}\");\n   }\n-  \n+\n   public void testExportMultiple2() throws Exception {\n     compileAndCheck(\"var a = {}; a.b = function(p1) {}; \" +\n                     \"a.b.c = function(d, e, f) {};\" +\n   }\n \n   public void testExportSymbolWithTypeAnnotation() {\n-    \n+\n     compileAndCheck(\"var internalName;\\n\" +\n                     \"/**\\n\" +\n                     \" * @param {string} param1\\n\" +\n                     \" * @param {number} param2\\n\" +\n                     \" * @return {string}\\n\" +\n-                    \" */\\n\" +  \n+                    \" */\\n\" +\n                     \"internalName = function(param1, param2) {\" +\n                       \"return param1 + param2;\" +\n                     \"};\" +\n                     \" * @param {string} param1\\n\" +\n                     \" * @param {number} param2\\n\" +\n                     \" * @return {string}\\n\" +\n-                    \" */\\n\" + \n+                    \" */\\n\" +\n                     \"var externalName = function(param1, param2) {\\n}\");\n   }\n \n     // ExternExportsPass should not emit annotations\n     // if there is no type information available.\n     setRunCheckTypes(false);\n-    \n+\n     compileAndCheck(\"var internalName;\\n\" +\n                     \"/**\\n\" +\n                     \" * @param {string} param1\\n\" +\n                     \" * @param {number} param2\\n\" +\n                     \" * @return {string}\\n\" +\n-                    \" */\\n\" +  \n+                    \" */\\n\" +\n                     \"internalName = function(param1, param2) {\" +\n                       \"return param1 + param2;\" +\n                     \"};\" +\n                     \"goog.exportSymbol('externalName', internalName)\",\n                     \"var externalName = function(param1, param2) {\\n}\");\n   }\n-  \n+\n   public void testExportSymbolWithConstructor() {\n     compileAndCheck(\"var internalName;\\n\" +\n                     \"/**\\n\" +\n                     \" * @constructor\\n\" +\n-                    \" */\\n\" +  \n+                    \" */\\n\" +\n                     \"internalName = function() {\" +\n                     \"};\" +\n                     \"goog.exportSymbol('externalName', internalName)\",\n                     \"/**\\n\" +\n                     \" * @return {undefined}\\n\" +\n                     \" * @constructor\\n\" +\n-                    \" */\\n\" + \n+                    \" */\\n\" +\n                     \"var externalName = function() {\\n}\");\n   }\n-  \n+\n   public void testExportSymbolWithConstructorWithoutTypeCheck() {\n     // For now, skipping type checking should prevent generating\n     // annotations of any kind, so, e.g., @constructor is not preserved.\n     // This is probably not ideal, but since JSDocInfo for functions is attached\n     // to JSTypes and not Nodes (and no JSTypes are created when checkTypes\n     // is false), we don't really have a choice.\n-    \n+\n     setRunCheckTypes(false);\n-    \n+\n     compileAndCheck(\"var internalName;\\n\" +\n                     \"/**\\n\" +\n                     \" * @constructor\\n\" +\n-                    \" */\\n\" +  \n+                    \" */\\n\" +\n                     \"internalName = function() {\" +\n                     \"};\" +\n                     \"goog.exportSymbol('externalName', internalName)\",\n                     \"var externalName = function() {\\n}\");\n   }\n-  \n+\n   public void testExportFunctionWithOptionalArguments() {\n     compileAndCheck(\"var internalName;\\n\" +\n         \"/**\\n\" +\n         \" * @param {number=} a\\n\" +\n-        \" */\\n\" +  \n+        \" */\\n\" +\n         \"internalName = function(a) {\" +\n         \"  return 6;\\n\" +\n         \"};\" +\n         \"goog.exportSymbol('externalName', internalName)\",\n         \"/**\\n\" +\n         \" * @param {number=} a\\n\" +\n-        \" */\\n\" + \n+        \" */\\n\" +\n         \"var externalName = function(a) {\\n}\");\n   }\n-  \n+\n   public void testExportFunctionWithVariableArguments() {\n     compileAndCheck(\"var internalName;\\n\" +\n         \"/**\\n\" +\n         \" * @param {...number} a\\n\" +\n-        \" * @return {number}\\n\" + \n-        \" */\\n\" +  \n+        \" * @return {number}\\n\" +\n+        \" */\\n\" +\n         \"internalName = function(a) {\" +\n         \"  return 6;\\n\" +\n         \"};\" +\n         \"/**\\n\" +\n         \" * @param {...number} a\\n\" +\n         \" * @return {number}\\n\" +\n-        \" */\\n\" + \n+        \" */\\n\" +\n         \"var externalName = function(a) {\\n}\");\n   }\n-  \n+\n   /** If we export a property with \"prototype\" as a path component, there\n     * is no need to emit the initializer for prototype because every namespace\n     * has one automatically.\n-    */  \n-  public void testExportDontEmitPrototypePathPrefix() { \n+    */\n+  public void testExportDontEmitPrototypePathPrefix() {\n     compileAndCheck(\n         \"/**\\n\" +\n         \" * @constructor\\n\" +\n         \" * @return {number}\\n\" +\n         \" */\\n\" +\n         \"Foo.prototype.m = function() {\\n}\"\n-    );  \n-  }\n-  \n+    );\n+  }\n+\n   /**\n    * Test the workflow of creating an externs file for a library\n    * via the export pass and then using that externs file in a client.\n-   * \n+   *\n    * There should be no warnings in the client if the library includes\n-   * type information for the exported functions and the client uses them \n+   * type information for the exported functions and the client uses them\n    * correctly.\n    */\n-  public void testUseExportsAsExterns() {  \n-    String librarySource = \n+  public void testUseExportsAsExterns() {\n+    String librarySource =\n     \"/**\\n\" +\n     \" * @param {number} a\\n\" +\n     \" * @constructor\\n\" +\n-    \" */\\n\" +  \n+    \" */\\n\" +\n     \"var InternalName = function(a) {\" +\n     \"};\" +\n     \"goog.exportSymbol('ExternalName', InternalName)\";\n-       \n-    String clientSource = \n+\n+    String clientSource =\n       \"var a = new ExternalName(6);\\n\" +\n       \"/**\\n\" +\n       \" * @param {ExternalName} x\\n\" +\n       \" */\\n\" +\n       \"var b = function(x) {};\";\n-    \n-    Result libraryCompileResult = compileAndExportExterns(librarySource); \n-    \n+\n+    Result libraryCompileResult = compileAndExportExterns(librarySource);\n+\n     assertEquals(0, libraryCompileResult.warnings.length);\n     assertEquals(0, libraryCompileResult.errors.length);\n-    \n+\n     String generatedExterns = libraryCompileResult.externExport;\n-    \n-    Result clientCompileResult = compileAndExportExterns(clientSource, \n+\n+    Result clientCompileResult = compileAndExportExterns(clientSource,\n         generatedExterns);\n-    \n+\n     assertEquals(0, clientCompileResult.warnings.length);\n     assertEquals(0, clientCompileResult.errors.length);\n   }\n-  \n+\n   public void testWarnOnExportFunctionWithUnknownReturnType() {\n-    String librarySource = \n+    String librarySource =\n       \"var InternalName = function() {\" +\n       \"  return 6;\" +\n       \"};\" +\n       \"goog.exportSymbol('ExternalName', InternalName)\";\n-         \n-      Result libraryCompileResult = compileAndExportExterns(librarySource); \n-      \n+\n+      Result libraryCompileResult = compileAndExportExterns(librarySource);\n+\n       assertEquals(1, libraryCompileResult.warnings.length);\n       assertEquals(0, libraryCompileResult.errors.length);\n   }\n-  \n+\n   public void testDontWarnOnExportConstructorWithUnknownReturnType() {\n-    String librarySource = \n+    String librarySource =\n       \"/**\\n\" +\n       \" * @constructor\\n\" +\n       \" */\\n \" +\n       \"var InternalName = function() {\" +\n       \"};\" +\n       \"goog.exportSymbol('ExternalName', InternalName)\";\n-         \n-      Result libraryCompileResult = compileAndExportExterns(librarySource); \n-      \n+\n+      Result libraryCompileResult = compileAndExportExterns(librarySource);\n+\n       assertEquals(0, libraryCompileResult.warnings.length);\n       assertEquals(0, libraryCompileResult.errors.length);\n   }\n-   \n+\n   private void compileAndCheck(String js, String expected) {\n     Result result = compileAndExportExterns(js);\n-    \n+\n     assertEquals(expected, result.externExport);\n   }\n-  \n+\n   public void testWarnOnExportFunctionWithUnknownParameterTypes() {\n     /* This source is missing types for the b and c parameters */\n-    String librarySource = \n+    String librarySource =\n       \"/**\\n\" +\n       \" * @param {number} a\\n\" +\n       \" * @return {number}\" +\n       \"  return 6;\" +\n       \"};\" +\n       \"goog.exportSymbol('ExternalName', InternalName)\";\n-         \n-      Result libraryCompileResult = compileAndExportExterns(librarySource); \n-      \n+\n+      Result libraryCompileResult = compileAndExportExterns(librarySource);\n+\n       assertEquals(2, libraryCompileResult.warnings.length);\n       assertEquals(0, libraryCompileResult.errors.length);\n   }\n-  \n+\n   private Result compileAndExportExterns(String js) {\n     return compileAndExportExterns(js, \"\");\n   }\n-  \n+\n   /**\n    * Compiles the passed in javascript with the passed in externs and returns\n    * the new externs exported by the this pass.\n-   * \n+   *\n    * @param js the source to be compiled\n    * @param externs the externs the {@code js} source needs\n    * @return the externs generated from {@code js}\n-   */ \n+   */\n   private Result compileAndExportExterns(String js, String externs) {\n     Compiler compiler = new Compiler();\n     CompilerOptions options = new CompilerOptions();\n \n     /* Check types so we can make sure our exported externs have\n      * type information.\n-     */  \n+     */\n     options.checkSymbols = true;\n     options.checkTypes = runCheckTypes;\n-    \n+\n     JSSourceFile[] inputs = {\n       JSSourceFile.fromCode(\"testcode\",\n                             \"var goog = {};\" +\n     JSSourceFile[] externFiles = {\n         JSSourceFile.fromCode(\"externs\", externs)\n     };\n-    \n+\n     Result result = compiler.compile(externFiles, inputs, options);\n \n     assertTrue(result.success);\n--- a/test/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarationsTest.java\n+++ b/test/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarationsTest.java\n         \"b.y.f = 1;\" +\n         \"b.y.g = 1;\");\n   }\n-  \n+\n   public void testWithDevirtualization() {\n     extract(\n         \"x.prototype.a = 1;\" +\n         \"x.prototype.e = 1;\" +\n         \"x.prototype.f = 1;\" +\n         \"x.prototype.g = 1;\",\n-        \n+\n         loadPrototype(\"x\") +\n         TMP + \".a = 1;\" +\n         TMP + \".b = 1;\" +\n         TMP + \".e = 1;\" +\n         TMP + \".f = 1;\" +\n         TMP + \".g = 1;\");\n-    \n+\n     extract(\n         \"x.prototype.a = 1;\" +\n         \"x.prototype.b = 1;\" +\n         \"x.prototype.f = 1;\" +\n         \"function devirtualize3() { }\" +\n         \"x.prototype.g = 1;\",\n-        \n+\n         loadPrototype(\"x\") +\n         TMP + \".a = 1;\" +\n         TMP + \".b = 1;\" +\n--- a/test/com/google/javascript/jscomp/LiveVariableAnalysisTest.java\n+++ b/test/com/google/javascript/jscomp/LiveVariableAnalysisTest.java\n     assertNotEscaped(\"var a;function b(){};a()\", \"a\");\n     assertNotEscaped(\"var a;function f(){function b(){}}a()\", \"a\");\n     assertNotEscaped(\"var a;function b(){var a;a()};a()\", \"a\");\n-    \n+\n     // Escaped by exporting.\n     assertEscaped(\"var _x\", \"_x\");\n   }\n--- a/test/com/google/javascript/jscomp/MaybeReachingVariableUseTest.java\n+++ b/test/com/google/javascript/jscomp/MaybeReachingVariableUseTest.java\n   private MaybeReachingVariableUse useDef = null;\n   private Node def = null;\n   private List<Node> uses = null;\n-  \n+\n   /*\n    * The test cases consist of a short code snipplet that has an instruction\n    * labeled with D and one or more with label starting with U. When assertMatch\n    * is called, the test suite verifies that all the uses with label starting\n    * with U is reachable to the definition label at D.\n    */\n-  \n+\n   public void testStraightLine() {\n     assertMatch(\"D:var x=1; U: x\");\n     assertMatch(\"var x; D:x=1; U: x\");\n     assertNotMatch(\"U:x; D:var x = 1\");\n     assertMatch(\"D: var x = 1; var y = 2; y; U:x\");\n   }\n-  \n+\n   public void testIf() {\n     assertMatch(\"var x; if(a){ D:x=1 }else { x=2 }; U:x\");\n     assertMatch(\"var x; if(a){ x=1 }else { D:x=2 }; U:x\");\n     assertMatch(\"D:var x=1; if(a){ U1: x }else { U2: x };\");\n   }\n-  \n+\n   public void testLoops() {\n     assertMatch(\"var x=0; while(a){ D:x=1 }; U:x\");\n     assertMatch(\"var x=0; for(;;) { D:x=1 }; U:x\");\n     assertMatch(\"D: var x=0; var y=0; (y=1)&&((y=2)||(x=1)); U:x\");\n     assertMatch(\"D: var x=0; var y=0; (y=0)&&(x=1); U:x\");\n   }\n-  \n+\n   public void testUseAndDefInSameInstruction() {\n     assertNotMatch(\"D:var x=0; U:x=1,x\");\n     assertMatch(\"D:var x=0; U:x,x=1\");\n     assertMatch(\"var x=0; D:foo() ? x=1 : bar(); U:x\");\n     assertMatch(\"var x=0; D:foo() ? x=1 : x=2; U:x\");\n   }\n-  \n+\n   public void testAssignmentOps() {\n     assertNotMatch(\"D: var x = 0; U: x = 100\");\n     assertMatch(\"D: var x = 0; U: x += 100\");\n     assertMatch(\"D: var x = 0; U: x -= 100\");\n   }\n-  \n+\n   public void testInc() {\n     assertMatch(\"D: var x = 0; U:x++\");\n     assertMatch(\"var x = 0; D:x++; U:x\");\n--- a/test/com/google/javascript/jscomp/MustBeReachingVariableDefTest.java\n+++ b/test/com/google/javascript/jscomp/MustBeReachingVariableDefTest.java\n   private MustBeReachingVariableDef defUse = null;\n   private Node def = null;\n   private Node use = null;\n-  \n+\n   public static final String EXTERNS = \"var goog = {}\";\n \n   public void testStraightLine() {\n   public void testMergeDefinitions() {\n     assertNotMatch(\"var x,y; D: y = x + x; if(x) { x = 1 }; U:y\");\n   }\n-  \n+\n   public void testMergesWithOneDefinition() {\n     assertNotMatch(\n         \"var x,y; while(y) { if (y) { print(x) } else { D: x = 1 } } U:x\");\n   }\n-  \n+\n   public void testRedefinitionUsingItself() {\n     assertMatch(\"var x = 1; D: x = x + 1; U:x;\");\n     assertNotMatch(\"var x = 1; D: x = x + 1; x = 1; U:x;\");\n     assertMatch(\"var x, a, b; D: x = a, x = b; a = 1; U: x\");\n     assertNotMatch(\"var x, a, b; D: x = a, x = b; b = 1; U: x\");\n   }\n-    \n+\n   public void testExterns() {\n     assertNotMatch(\"D: goog = {}; U: goog\");\n   }\n     assertMatch(\"var x = 0; D: x *= 1; U: x\");\n     assertNotMatch(\"D: var x = 0; x += 1; U: x\");\n   }\n-  \n+\n   public void testIncAndDec() {\n     assertMatch(\"var x; D: x++; U: x\");\n     assertMatch(\"var x; D: x--; U: x\");\n \n   public void testFunctionParams1() {\n     computeDefUse(\"if (param2) { D: param1 = 1; U: param1 }\");\n-    assertSame(def, defUse.getDef(\"param1\", use));  \n+    assertSame(def, defUse.getDef(\"param1\", use));\n   }\n-  \n+\n   public void testFunctionParams2() {\n     computeDefUse(\"if (param2) { D: param1 = 1} U: param1\");\n     assertNotSame(def, defUse.getDef(\"param1\", use));\n   }\n-  \n+\n   /**\n    * The use of x at U: is the definition of x at D:.\n    */\n     computeDefUse(src);\n     assertSame(def, defUse.getDef(\"x\", use));\n   }\n-  \n+\n   /**\n    * The use of x at U: is not the definition of x at D:.\n    */\n     computeDefUse(src);\n     assertNotSame(def, defUse.getDef(\"x\", use));\n   }\n-  \n+\n   /**\n    * Computes reaching definition on given source.\n    */\n--- a/test/com/google/javascript/jscomp/ParallelCompilerPassTest.java\n+++ b/test/com/google/javascript/jscomp/ParallelCompilerPassTest.java\n \n /**\n  * Unit tests for {@link ParallelCompilerPass}.\n- * \n+ *\n  * The correctness of ParallelCompilerPass depends largely on the Task so this\n  * class is here for a quick sanity test purpose. At the very least, it verifies\n  * that all the worker terminates and no dead lock exists in the test cases.\n- * \n+ *\n *\n  */\n public class ParallelCompilerPassTest extends TestCase {\n-  \n+\n   public void testNoFunction() {\n     replace(\"\\\"foo\\\"\");\n     replace(\"var foo\");\n   }\n-  \n+\n   public void testOneFunction() {\n     replace(\"\\\"foo\\\";function foo(){\\\"foo\\\"}\");\n   }\n-  \n+\n   public void testTwoFunctions() {\n     replace(\"\\\"foo\\\";function f1(){\\\"foo\\\"}function f2(){\\\"foo\\\"}\");\n   }\n-  \n+\n   public void testInnerFunctions() {\n     replace(\"\\\"foo\\\";function f1(){\\\"foo\\\";function f2(){\\\"foo\\\"}}\");\n   }\n-  \n+\n   public void testManyFunctions() {\n     StringBuffer sb = new StringBuffer(\"\\\"foo\\\";\");\n     for (int i = 0; i < 20; i++) {\n \n   private void replace(String input) {\n     String replace = input.replaceAll(\"foo\", \"bar\");\n-    \n+\n     final Compiler compiler = new Compiler();\n-    \n+\n     int[] threadCounts = new int[]{1 , 2 , 4};\n-    \n+\n     for (int threadCount : threadCounts) {\n       Node tree = compiler.parseTestCode(input);\n-      \n+\n       AstParallelizer splitter = AstParallelizer\n           .createNewFunctionLevelAstParallelizer(tree, true);\n-      \n+\n       Supplier<Task> supplier = new Supplier<Task>() {\n         @Override\n         public Task get() {\n           return new ReplaceStrings(compiler);\n-        }      \n+        }\n       };\n-      \n+\n       ParallelCompilerPass pass = new ParallelCompilerPass(\n           compiler, splitter, supplier, threadCount);\n       pass.process(null, tree);\n       assertEquals(replace, compiler.toSource(tree));\n     }\n   }\n-  \n+\n   /**\n    * Replace all occurrences of \"foo\" with \"bar\".\n    */\n   private static class ReplaceStrings implements Task {\n     private final Result result = new Result();\n     private final AbstractCompiler compiler;\n-    \n+\n     private ReplaceStrings(AbstractCompiler compiler) {\n       this.compiler = compiler;\n     }\n             }\n       });\n       return result;\n-    }    \n+    }\n   }\n }\n--- a/test/com/google/javascript/jscomp/PeepholeOptimizationsPassTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeOptimizationsPassTest.java\n \n /**\n  * Unit tests for PeepholeOptimizationsPass.\n- * \n+ *\n *\n  */\n public class PeepholeOptimizationsPassTest extends CompilerTestCase {\n     /*\n      * We need to make sure that: 1) We are only traversing the AST once 2) For\n      * each node, we visit the optimizations in the client-supplied order\n-     * \n+     *\n      * To test this, we create two fake optimizations that each make an entry in\n      * the visitationLog when they are passed a name node to optimize.\n-     * \n+     *\n      * Each entry is of the form nameX where 'name' is the name of the name node\n      * visited and X is the identity of the optimization (1 or 2 in this case).\n      * After the pass is run, we verify the correct ordering by querying the\n      * log.\n-     * \n+     *\n      * Using a log, rather than, say, transforming nodes, allows us to ensure\n      * not only that we are visiting each node but that our visits occur in the\n      * right order (i.e. we need to make sure we're not traversing the entire\n \n     final List<String> visitationLog = Lists.newArrayList();\n \n-    AbstractPeepholeOptimization note1Applied = \n+    AbstractPeepholeOptimization note1Applied =\n         new AbstractPeepholeOptimization() {\n       @Override\n       public Node optimizeSubtree(Node node) {\n       }\n     };\n \n-    AbstractPeepholeOptimization note2Applied = \n+    AbstractPeepholeOptimization note2Applied =\n         new AbstractPeepholeOptimization() {\n       @Override\n       public Node optimizeSubtree(Node node) {\n \n     currentPeepholePasses =\n       ImmutableSet.<AbstractPeepholeOptimization>of(note1Applied, note2Applied);\n-    \n+\n     test(\"var x; var y\", \"var x; var y\");\n \n     /*\n    * A peephole optimization that, given a subtree consisting of a VAR node,\n    * removes children of that node named \"x\".\n    */\n-  private static class RemoveNodesNamedXUnderVarOptimization \n+  private static class RemoveNodesNamedXUnderVarOptimization\n       extends AbstractPeepholeOptimization {\n     @Override\n     public Node optimizeSubtree(Node node) {\n    * A peephole optimization that, given a subtree consisting of a name node\n    * named \"x\" removes that node.\n    */\n-  private static class RemoveNodesNamedXOptimization \n+  private static class RemoveNodesNamedXOptimization\n       extends AbstractPeepholeOptimization {\n     @Override\n     public Node optimizeSubtree(Node node) {\n    * A peephole optimization that, given a subtree consisting of a name node\n    * named \"x\" whose parent is a VAR node, removes the parent VAR node.\n    */\n-  private static class RemoveParentVarsForNodesNamedX \n+  private static class RemoveParentVarsForNodesNamedX\n       extends AbstractPeepholeOptimization {\n     @Override\n     public Node optimizeSubtree(Node node) {\n   }\n \n   public void testOptimizationRemovingSubtreeChild() {\n-    currentPeepholePasses = ImmutableSet.<AbstractPeepholeOptimization>of(new \n+    currentPeepholePasses = ImmutableSet.<AbstractPeepholeOptimization>of(new\n           RemoveNodesNamedXUnderVarOptimization());\n-    \n+\n     test(\"var x,y;\", \"var y;\");\n     test(\"var y,x;\", \"var y;\");\n     test(\"var x,y,x;\", \"var y;\");\n   }\n \n   public void testOptimizationRemovingSubtree() {\n-    currentPeepholePasses = ImmutableSet.<AbstractPeepholeOptimization>of(new \n+    currentPeepholePasses = ImmutableSet.<AbstractPeepholeOptimization>of(new\n           RemoveNodesNamedXOptimization());\n-    \n+\n     test(\"var x,y;\", \"var y;\");\n     test(\"var y,x;\", \"var y;\");\n     test(\"var x,y,x;\", \"var y;\");\n   }\n \n   public void testOptimizationRemovingSubtreeParent() {\n-    currentPeepholePasses = ImmutableSet.<AbstractPeepholeOptimization>of(new \n+    currentPeepholePasses = ImmutableSet.<AbstractPeepholeOptimization>of(new\n           RemoveParentVarsForNodesNamedX());\n-  \n+\n     test(\"var x; var y\", \"var y\");\n   }\n \n     currentPeepholePasses = ImmutableSet.<AbstractPeepholeOptimization>of(\n           new RemoveNodesNamedXOptimization(),\n           new RemoveParentVarsForNodesNamedX());\n-    \n+\n     test(\"var x,y; var z;\", \"var y; var z;\");\n   }\n \n     currentPeepholePasses = ImmutableSet.<AbstractPeepholeOptimization>of(\n           new RenameYToX(),\n           new RemoveParentVarsForNodesNamedX());\n-    \n+\n     test(\"var y; var z;\", \"var z;\");\n   }\n }\n--- a/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java\n+++ b/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java\n     checkMarkedCalls(source, ImmutableList.<String>of(\n         \"(Error || FUNCTION)\"));\n   }\n-  \n+\n   public void testAnonymousFunction3() throws Exception {\n     String source = \"var a = (Error || function (){})();\";\n \n     checkMarkedCalls(source, ImmutableList.<String>of(\n         \"(Error || FUNCTION)\"));\n-  }  \n+  }\n \n   // Indirect complex function definitions aren't yet supported.\n   public void testAnonymousFunction4() throws Exception {\n \n     // This should be \"(Error || FUNCTION)\" but isn't.\n     checkMarkedCalls(source, ImmutableList.<String>of());\n-  }  \n-  \n+  }\n+\n   public void testInvalidAnnotation1() throws Exception {\n     test(\"/** @nosideeffects */ function foo() {}\",\n          null, INVALID_NO_SIDE_EFFECT_ANNOTATION);\n--- a/test/com/google/javascript/jscomp/VarCheckTest.java\n+++ b/test/com/google/javascript/jscomp/VarCheckTest.java\n   private CheckLevel strictModuleDepErrorLevel;\n   private boolean sanityCheck = false;\n \n+  private CheckLevel externValidationpErrorLevel;\n+\n   public VarCheckTest() {\n     super(EXTERNS);\n   }\n   protected void setUp() throws Exception {\n     super.setUp();\n     strictModuleDepErrorLevel = CheckLevel.OFF;\n+    externValidationpErrorLevel = CheckLevel.ERROR;\n     sanityCheck = false;\n   }\n \n     CompilerOptions options = super.getOptions();\n     options.setWarningLevel(DiagnosticGroups.STRICT_MODULE_DEP_CHECK,\n         strictModuleDepErrorLevel);\n+    options.setWarningLevel(DiagnosticGroups.EXTERNS_VALIDATION,\n+        externValidationpErrorLevel);\n     return options;\n   }\n \n   }\n \n   public void testPropReferenceInExterns1() {\n+    externValidationpErrorLevel = CheckLevel.ERROR;\n     testSame(\"asdf.foo;\", \"var asdf;\",\n         VarCheck.UNDEFINED_EXTERN_VAR_ERROR, true);\n   }\n \n   public void testPropReferenceInExterns2() {\n+    externValidationpErrorLevel = CheckLevel.ERROR;\n     testSame(\"asdf.foo;\", \"\",\n         VarCheck.UNDEFINED_EXTERN_VAR_ERROR, true);\n+  }\n+\n+  public void testPropReferenceInExterns3() {\n+    externValidationpErrorLevel = CheckLevel.WARNING;\n+    test(\"asdf.foo;\", \"\", \"\",\n+        VarCheck.UNDEFINED_VAR_ERROR, VarCheck.UNDEFINED_EXTERN_VAR_ERROR);\n+\n+    externValidationpErrorLevel = CheckLevel.OFF;\n+    test(\"asdf.foo;\", \"\", \"\",\n+        VarCheck.UNDEFINED_VAR_ERROR, null);\n   }\n \n   public void testVarInWithBlock() {\n     Node expected = compiler.parseTestCode(expectedExtern);\n     assertFalse(compiler.hasErrors());\n \n-    (new VarCheck(compiler, sanityCheck)).process(externs, root);\n+    (new VarCheck(compiler, sanityCheck))\n+        .process(externs, root);\n     if (!sanityCheck) {\n       (new VariableTestCheck(compiler)).process(externs, root);\n     }\n--- a/test/com/google/javascript/jscomp/VariableReferenceCheckTest.java\n+++ b/test/com/google/javascript/jscomp/VariableReferenceCheckTest.java\n   public void testNonHoistedFunction7() {\n     assertUndeclared(\"function g() { if (false) { f(); function f() {} }}\");\n   }\n-  \n-  \n+\n+\n   public void testNonHoistedRecursiveFunction1() {\n     assertNoWarning(\"if (false) { function f() { f(); }}\");\n   }\n--- a/test/com/google/javascript/jscomp/graph/GraphReachabilityTest.java\n+++ b/test/com/google/javascript/jscomp/graph/GraphReachabilityTest.java\n \n /**\n  * Tests for {@link GraphReachability}.\n- * \n+ *\n *\n  */\n public class GraphReachabilityTest extends TestCase {\n   GraphReachability<String, String> reachability = null;\n   DiGraph<String, String> graph = null;\n-  \n+\n   public void testSimple() {\n     graph = new LinkedDirectedGraph<String, String>();\n     graph.createNode(\"A\");\n     reachability = new GraphReachability<String, String>(graph);\n     reachability.compute(\"A\");\n     assertReachable(\"A\");\n-    \n+\n     graph.createNode(\"B\");\n     reachability = new GraphReachability<String, String>(graph);\n     reachability.compute(\"A\");\n     assertReachable(\"A\");\n     assertNotReachable(\"B\");\n-    \n+\n     graph.connect(\"A\", \"--->\", \"B\");\n     reachability = new GraphReachability<String, String>(graph);\n     reachability.compute(\"B\");\n     assertNotReachable(\"A\");\n     assertReachable(\"B\");\n-    \n+\n     graph.connect(\"B\", \"--->\", \"A\");\n     reachability = new GraphReachability<String, String>(graph);\n     reachability.compute(\"B\");\n     assertReachable(\"A\");\n     assertReachable(\"B\");\n-    \n+\n     graph.createNode(\"C\");\n     reachability = new GraphReachability<String, String>(graph);\n     reachability.compute(\"A\");\n     assertReachable(\"C\");\n     assertReachable(\"D\");\n   }\n-  \n+\n   public void assertReachable(String s) {\n     assertSame(s + \" should be reachable\", graph.getNode(s).getAnnotation(),\n         GraphReachability.REACHABLE);\n   }\n-  \n+\n   public void assertNotReachable(String s) {\n     assertNotSame(s + \" should not be reachable\",\n         graph.getNode(s).getAnnotation(), GraphReachability.REACHABLE);\n--- a/test/com/google/javascript/jscomp/graph/StandardUnionFindTest.java\n+++ b/test/com/google/javascript/jscomp/graph/StandardUnionFindTest.java\n \n     Collection<Set<String>> classes = union.allEquivalenceClasses();\n     assertEquals(3, classes.size());\n-    assertContentsAnyOrder(classes, \n+    assertContentsAnyOrder(classes,\n         ImmutableSet.of(\"A\", \"B\", \"C\"),\n         ImmutableSet.of(\"D\", \"E\"),\n         ImmutableSet.of(\"F\"));\n     assertEquals(ImmutableSet.of(\"A\", \"B\", \"C\", \"D\", \"E\"), elements);\n     assertFalse(elements.contains(\"F\"));\n   }\n-  \n+\n   public void testCopy() {\n     union.union(\"A\", \"B\");\n     union.union(\"B\", \"Z\");\n       // Expected.\n     }\n   }\n-  \n+\n   public void testCheckEquivalent() {\n     union.union(\"A\", \"B\");\n     union.add(\"C\");\n       // Expected.\n     }\n   }\n-  \n+\n   /**\n    * Asserts that {@code actual} contains precisely the elements\n    * {@code expected}, in any order.  Both collections may contain", "timestamp": 1277995119, "metainfo": ""}