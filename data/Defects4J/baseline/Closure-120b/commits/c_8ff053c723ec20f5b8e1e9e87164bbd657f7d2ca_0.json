{"sha": "8ff053c723ec20f5b8e1e9e87164bbd657f7d2ca", "log": "Compile jobs must be deterministic, so module and input sorts must be stable. Eventually, this will all get moved into a separate sorting class under jscomp.deps, but i wanted to make it easier to see the changes to the algorithm in this cl. (Nick) R=Kevin DELTA=158  (74 added, 35 deleted, 49 changed)  Add Error.stackTraceLimit. Yay secret v8 apis. (Nick) R=Zach DELTA=21  (21 added, 0 deleted, 0 changed)  Revision created by MOE tool push_codebase. MOE_MIGRATION=   ", "commit": "\n--- a/src/com/google/javascript/jscomp/JSModule.java\n+++ b/src/com/google/javascript/jscomp/JSModule.java\n package com.google.javascript.jscomp;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.HashMultiset;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Multimaps;\n+import com.google.common.collect.Multiset;\n import com.google.common.collect.Sets;\n \n import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n+import java.util.PriorityQueue;\n import java.util.Set;\n-\n \n /**\n  * A JavaScript module has a unique name, consists of a list of compiler inputs,\n    * Puts the JS files into a topologically sorted order by their dependencies.\n    */\n   public void sortInputsByDeps(Compiler compiler) {\n+    final Map<String, CompilerInput> provides = Maps.newHashMap();\n     // Collect all symbols provided in these files.\n-    final Map<String, CompilerInput> provides = Maps.newHashMap();\n     for (CompilerInput input : inputs) {\n       for (String provide : input.getProvides(compiler)) {\n         provides.put(provide, input);\n       }\n     }\n \n-    // Put the files into topologically sorted order by their requires.\n-    // NOTE: This will leave the list unchanged if the files are already\n-    //       topologically sorted.  This is important to apps whose dependencies\n-    //       are incomplete.\n-    List<CompilerInput> list = Lists.newArrayList();\n-    Set<CompilerInput> set = Sets.newHashSet();\n-    for (CompilerInput input : inputs) {\n-      addInputAndDeps(input, provides, compiler, list, set,\n-                      Sets.<CompilerInput>newHashSet());\n-    }\n-\n-    // Update the JSModule to this order.\n-    Preconditions.checkState(inputs.size() == list.size());\n+    // Get the direct dependencies.\n+    final Multimap<CompilerInput, CompilerInput> deps =\n+        HashMultimap.create();\n+    for (CompilerInput input : inputs) {\n+      for (String req : input.getRequires(compiler)) {\n+        CompilerInput dep = provides.get(req);\n+        if (dep != null) {\n+          deps.put(input, dep);\n+        }\n+      }\n+    }\n+\n+    // Sort the JSModule in this order.\n+    List<CompilerInput> sortedList = topologicalStableSort(\n+        inputs, deps);\n     inputs.clear();\n-    inputs.addAll(list);\n+    inputs.addAll(sortedList);\n   }\n \n   /**\n    * the modules do not properly specify all dependencies.\n    */\n   public static JSModule[] sortJsModules(Collection<JSModule> modules) {\n-    List<JSModule> list = Lists.newArrayList();\n-    Set<JSModule> set = Sets.newHashSet();\n+    final Multimap<JSModule, JSModule> deps = HashMultimap.create();\n     for (JSModule module : modules) {\n-      addModuleAndDeps(module, list, set, Sets.<JSModule>newHashSet());\n-    }\n-    return list.toArray(new JSModule[list.size()]);\n-  }\n-\n-  /**\n-   * Adds the given input and its deps to the given list and set, if they are\n-   * not already added, placing dependencies before dependants.\n-   */\n-  private static void addInputAndDeps(\n-      CompilerInput input, Map<String, CompilerInput> provides,\n-      Compiler compiler, List<CompilerInput> list, Set<CompilerInput> set,\n-      Set<CompilerInput> inProgress) {\n-    if (!set.contains(input)) {\n-      if (inProgress.contains(input)) {\n-        throw new IllegalArgumentException(\n-            \"Circular dependency involving input: \" + input.getName());\n-      }\n-      inProgress.add(input);\n-\n-      for (String require : input.getRequires(compiler)) {\n-        if (provides.containsKey(require)) {\n-          addInputAndDeps(provides.get(require), provides, compiler, list, set,\n-                          inProgress);\n+      for (JSModule dep : module.getDependencies()) {\n+        deps.put(module, dep);\n+      }\n+    }\n+\n+    // Sort the JSModule in this order.\n+    List<JSModule> sortedList = topologicalStableSort(\n+        Lists.newArrayList(modules), deps);\n+    return sortedList.toArray(new JSModule[sortedList.size()]);\n+  }\n+\n+  private static <T> List<T> topologicalStableSort(\n+      List<T> items, Multimap<T, T> deps) {\n+    final Map<T, Integer> originalIndex = Maps.newHashMap();\n+    for (int i = 0; i < items.size(); i++) {\n+      originalIndex.put(items.get(i), i);\n+    }\n+\n+    PriorityQueue<T> inDegreeZero = new PriorityQueue<T>(items.size(),\n+        new Comparator<T>() {\n+      @Override\n+      public int compare(T a, T b) {\n+        return originalIndex.get(a).intValue() -\n+            originalIndex.get(b).intValue();\n+      }\n+    });\n+    List<T> result = Lists.newArrayList();\n+\n+    Multiset<T> inDegree = HashMultiset.create();\n+    Multimap<T, T> reverseDeps = ArrayListMultimap.create();\n+    Multimaps.invertFrom(deps, reverseDeps);\n+\n+    // First, add all the inputs with in-degree 0.\n+    for (T item : items) {\n+      Collection<T> itemDeps = deps.get(item);\n+      inDegree.add(item, itemDeps.size());\n+      if (itemDeps.isEmpty()) {\n+        inDegreeZero.add(item);\n+      }\n+    }\n+\n+    // Then, iterate to a fixed point over the reverse dependency graph.\n+    while (!inDegreeZero.isEmpty()) {\n+      T item = inDegreeZero.remove();\n+      result.add(item);\n+      for (T inWaiting : reverseDeps.get(item)) {\n+        inDegree.remove(inWaiting, 1);\n+        if (inDegree.count(inWaiting) == 0) {\n+          inDegreeZero.add(inWaiting);\n         }\n       }\n-\n-      list.add(input);\n-      set.add(input);\n-    }\n-  }\n-\n-  /**\n-   * Adds the given module and its deps to the given list and set, if they are\n-   * not already added, placing dependencies before dependants.\n-   */\n-  private static void addModuleAndDeps(\n-      JSModule module, List<JSModule> list, Set<JSModule> set,\n-      Set<JSModule> inProgress) {\n-    if (!set.contains(module)) {\n-      if (inProgress.contains(module)) {\n-        throw new IllegalArgumentException(\n-            \"Circular dependency involving module: \" + module.getName());\n-      }\n-      inProgress.add(module);\n-\n-      for (JSModule dep : module.getDependencies()) {\n-        addModuleAndDeps(dep, list, set, inProgress);\n-      }\n-\n-      list.add(module);\n-      set.add(module);\n-    }\n+    }\n+\n+    return result;\n   }\n }\n--- a/test/com/google/javascript/jscomp/JSModuleTest.java\n+++ b/test/com/google/javascript/jscomp/JSModuleTest.java\n   }\n \n   public void testSortInputs() {\n+    CompilerInput a = new CompilerInput(\n+        JSSourceFile.fromCode(\"a.js\",\n+            \"goog.require('b');goog.require('c')\"));\n+    CompilerInput b = new CompilerInput(\n+        JSSourceFile.fromCode(\"b.js\",\n+            \"goog.provide('b');goog.require('d')\"));\n+    CompilerInput c = new CompilerInput(\n+        JSSourceFile.fromCode(\"c.js\",\n+            \"goog.provide('c');goog.require('d')\"));\n+    CompilerInput d = new CompilerInput(\n+        JSSourceFile.fromCode(\"d.js\",\n+            \"goog.provide('d')\"));\n+\n+    // Independent modules.\n+    CompilerInput e = new CompilerInput(\n+        JSSourceFile.fromCode(\"e.js\",\n+            \"goog.provide('e')\"));\n+    CompilerInput f = new CompilerInput(\n+        JSSourceFile.fromCode(\"f.js\",\n+            \"goog.provide('f')\"));\n+\n+    assertSortedInputs(\n+        ImmutableList.of(d, b, c, a),\n+        ImmutableList.of(a, b, c, d));\n+    assertSortedInputs(\n+        ImmutableList.of(d, b, c, a),\n+        ImmutableList.of(d, b, c, a));\n+    assertSortedInputs(\n+        ImmutableList.of(d, c, b, a),\n+        ImmutableList.of(d, c, b, a));\n+    assertSortedInputs(\n+        ImmutableList.of(d, b, c, a),\n+        ImmutableList.of(d, a, b, c));\n+  }\n+\n+  private void assertSortedInputs(\n+      List<CompilerInput> expected, List<CompilerInput> shuffled) {\n     JSModule mod = new JSModule(\"mod\");\n-    mod.add(JSSourceFile.fromCode(\"a.js\",\n-        \"goog.require('b');goog.require('c')\"));\n-    mod.add(JSSourceFile.fromCode(\"b.js\",\n-        \"goog.provide('b');goog.require('d')\"));\n-    mod.add(JSSourceFile.fromCode(\"c.js\",\n-        \"goog.provide('c');goog.require('d')\"));\n-    mod.add(JSSourceFile.fromCode(\"d.js\",\n-        \"goog.provide('d')\"));\n+    for (CompilerInput input : shuffled) {\n+      input.setModule(null);\n+      mod.add(input);\n+    }\n     Compiler compiler = new Compiler(System.err);\n     compiler.initCompilerOptionsIfTesting();\n     mod.sortInputsByDeps(compiler);\n \n-    assertEquals(4, mod.getInputs().size());\n-    assertEquals(\"d.js\", mod.getInputs().get(0).getSourceFile().getName());\n-    assertEquals(\"b.js\", mod.getInputs().get(1).getSourceFile().getName());\n-    assertEquals(\"c.js\", mod.getInputs().get(2).getSourceFile().getName());\n-    assertEquals(\"a.js\", mod.getInputs().get(3).getSourceFile().getName());\n+    assertEquals(expected, mod.getInputs());\n   }\n \n   public void testSortJsModules() {\n             ImmutableList.of(mod1, mod3, mod2, mod4))));\n \n     // one out of order:\n-    assertEquals(ImmutableList.of(mod1, mod2, mod3, mod4),\n+    assertEquals(ImmutableList.of(mod1, mod3, mod2, mod4),\n         Arrays.asList(JSModule.sortJsModules(\n             ImmutableList.of(mod4, mod3, mod2, mod1))));\n     assertEquals(ImmutableList.of(mod1, mod3, mod2, mod4),\n             ImmutableList.of(mod3, mod1, mod2, mod4))));\n \n     // more out of order:\n-    assertEquals(ImmutableList.of(mod1, mod2, mod3, mod4),\n+    assertEquals(ImmutableList.of(mod1, mod3, mod2, mod4),\n         Arrays.asList(JSModule.sortJsModules(\n             ImmutableList.of(mod4, mod3, mod1, mod2))));\n   }", "timestamp": 1269449306, "metainfo": ""}