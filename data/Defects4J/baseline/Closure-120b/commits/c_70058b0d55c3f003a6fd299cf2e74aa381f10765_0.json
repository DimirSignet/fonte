{"sha": "70058b0d55c3f003a6fd299cf2e74aa381f10765", "log": "Show source of unknown type. Fixes issue 957. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=44902554", "commit": "\n--- a/src/com/google/javascript/jscomp/CompilerOptions.java\n+++ b/src/com/google/javascript/jscomp/CompilerOptions.java\n     reportMissingOverride = level;\n   }\n \n-  CheckLevel reportUnknownTypes;\n-\n-  /** Flags a warning for every node whose type could not be determined. */\n-  public void setReportUnknownTypes(CheckLevel level) {\n-    reportUnknownTypes = level;\n-  }\n-\n   /** Checks for missing goog.require() calls **/\n   public CheckLevel checkRequires;\n \n     checkTypes = false;\n     tightenTypes = false;\n     reportMissingOverride = CheckLevel.OFF;\n-    reportUnknownTypes = CheckLevel.OFF;\n     checkRequires = CheckLevel.OFF;\n     checkProvides = CheckLevel.OFF;\n     checkGlobalNamesLevel = CheckLevel.OFF;\n--- a/src/com/google/javascript/jscomp/DiagnosticGroupWarningsGuard.java\n+++ b/src/com/google/javascript/jscomp/DiagnosticGroupWarningsGuard.java\n public class DiagnosticGroupWarningsGuard extends WarningsGuard {\n   private static final long serialVersionUID = 1L;\n \n-  final DiagnosticGroup group;\n-  final CheckLevel level;\n+  private final DiagnosticGroup group;\n+  private final CheckLevel level;\n \n   public DiagnosticGroupWarningsGuard(\n       DiagnosticGroup group, CheckLevel level) {\n         }\n       }\n     }\n-\n     return false;\n   }\n \n--- a/src/com/google/javascript/jscomp/DiagnosticGroups.java\n+++ b/src/com/google/javascript/jscomp/DiagnosticGroups.java\n   // to parser/ParserConfig.properties\n   static final String DIAGNOSTIC_GROUP_NAMES =\n       \"accessControls, ambiguousFunctionDecl, checkRegExp, \" +\n-      \"checkTypes, checkVars, const, constantProperty, deprecated, \" +\n-      \"duplicateMessage, \" +\n+      \"checkStructDictInheritance, checkTypes, checkVars, const, \" +\n+      \"constantProperty, deprecated, duplicateMessage, \" +\n       \"es5Strict, externsValidation, fileoverviewTags, globalThis, \" +\n       \"internetExplorerChecks, invalidCasts, misplacedTypeAnnotation, \" +\n       \"missingProperties, \" +\n-      \"nonStandardJsDocs, suspiciousCode, strictModuleDepCheck, \" +\n-      \"typeInvalidation, \" +\n+      \"nonStandardJsDocs, reportUnknownTypes, suspiciousCode, \" +\n+      \"strictModuleDepCheck, typeInvalidation, \" +\n       \"undefinedNames, undefinedVars, unknownDefines, uselessCode, \" +\n       \"visibility\";\n \n           TypeValidator.ALL_DIAGNOSTICS,\n           TypeCheck.ALL_DIAGNOSTICS);\n \n-  public static final DiagnosticGroup CHECK_STRUCT_DICT_INHERITENCE =\n-      DiagnosticGroups.registerGroup(\"checkStructDictInheritence\",\n+  public static final DiagnosticGroup REPORT_UNKNOWN_TYPES =\n+      DiagnosticGroups.registerGroup(\"reportUnknownTypes\",\n+          TypeCheck.UNKNOWN_EXPR_TYPE);\n+\n+  public static final DiagnosticGroup CHECK_STRUCT_DICT_INHERITANCE =\n+      DiagnosticGroups.registerGroup(\"checkStructDictInheritance\",\n           TypeCheck.CONFLICTING_SHAPE_TYPE);\n \n   public static final DiagnosticGroup CHECK_VARIABLES =\n--- a/src/com/google/javascript/jscomp/PassConfig.java\n+++ b/src/com/google/javascript/jscomp/PassConfig.java\n         compiler.getTypeRegistry(),\n         topScope,\n         typedScopeCreator,\n-        options.reportMissingOverride,\n-        options.reportUnknownTypes)\n+        options.reportMissingOverride)\n         .reportMissingProperties(options.enables(\n             DiagnosticGroup.forType(TypeCheck.INEXISTENT_PROPERTY)));\n   }\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n           \"property {0} is already defined by the {1} extended interface\");\n \n   static final DiagnosticType UNKNOWN_EXPR_TYPE =\n-      DiagnosticType.warning(\"JSC_UNKNOWN_EXPR_TYPE\",\n+      DiagnosticType.disabled(\"JSC_UNKNOWN_EXPR_TYPE\",\n           \"could not determine the type of this expression\");\n \n   static final DiagnosticType UNRESOLVED_TYPE =\n           \"ILLEGAL_OBJLIT_KEY\",\n           \"Illegal key, the object literal is a {0}\");\n \n+  // If a diagnostic is disabled by default, do not add it in this list\n+  // TODO(user): Either INEXISTENT_PROPERTY shouldn't be here, or we should\n+  // change DiagnosticGroups.setWarningLevel to not accidentally enable it.\n   static final DiagnosticGroup ALL_DIAGNOSTICS = new DiagnosticGroup(\n       DETERMINISTIC_TEST,\n       DETERMINISTIC_TEST_NO_RESULT,\n       HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,\n       UNKNOWN_OVERRIDE,\n       INTERFACE_METHOD_OVERRIDE,\n-      UNKNOWN_EXPR_TYPE,\n       UNRESOLVED_TYPE,\n       WRONG_ARGUMENT_COUNT,\n       ILLEGAL_IMPLICIT_CAST,\n   private MemoizedScopeCreator scopeCreator;\n \n   private final CheckLevel reportMissingOverride;\n-  private final CheckLevel reportUnknownTypes;\n+  private final boolean reportUnknownTypes;\n \n   // This may be expensive, so don't emit these warnings if they're\n   // explicitly turned off.\n       JSTypeRegistry typeRegistry,\n       Scope topScope,\n       MemoizedScopeCreator scopeCreator,\n-      CheckLevel reportMissingOverride,\n-      CheckLevel reportUnknownTypes) {\n+      CheckLevel reportMissingOverride) {\n     this.compiler = compiler;\n     this.validator = compiler.getTypeValidator();\n     this.reverseInterpreter = reverseInterpreter;\n     this.topScope = topScope;\n     this.scopeCreator = scopeCreator;\n     this.reportMissingOverride = reportMissingOverride;\n-    this.reportUnknownTypes = reportUnknownTypes;\n+    this.reportUnknownTypes = ((Compiler) compiler).getOptions().enables(\n+        DiagnosticGroups.REPORT_UNKNOWN_TYPES);\n     this.inferJSDocInfo = new InferJSDocInfo(compiler);\n   }\n \n   public TypeCheck(AbstractCompiler compiler,\n       ReverseAbstractInterpreter reverseInterpreter,\n       JSTypeRegistry typeRegistry,\n-      CheckLevel reportMissingOverride,\n-      CheckLevel reportUnknownTypes) {\n+      CheckLevel reportMissingOverride) {\n     this(compiler, reverseInterpreter, typeRegistry, null, null,\n-        reportMissingOverride, reportUnknownTypes);\n+        reportMissingOverride);\n   }\n \n   TypeCheck(AbstractCompiler compiler,\n       ReverseAbstractInterpreter reverseInterpreter,\n       JSTypeRegistry typeRegistry) {\n     this(compiler, reverseInterpreter, typeRegistry, null, null,\n-         CheckLevel.WARNING, CheckLevel.OFF);\n+         CheckLevel.WARNING);\n   }\n \n   /** Turn on the missing property check. Returns this for easy chaining. */\n     if (type == null) {\n       nullCount++;\n     } else if (type.isUnknownType()) {\n-      if (reportUnknownTypes.isOn()) {\n-        compiler.report(\n-            t.makeError(n, reportUnknownTypes, UNKNOWN_EXPR_TYPE));\n+      if (reportUnknownTypes) {\n+        compiler.report(t.makeError(n, UNKNOWN_EXPR_TYPE));\n       }\n       unknownCount++;\n     } else {\n--- a/test/com/google/javascript/jscomp/CompilerTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java\n         new SemanticReverseAbstractInterpreter(compiler.getCodingConvention(),\n             compiler.getTypeRegistry());\n \n-    return new TypeCheck(compiler, rai, compiler.getTypeRegistry(),\n-        level, CheckLevel.OFF);\n+    return new TypeCheck(compiler, rai, compiler.getTypeRegistry(), level);\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/LooseTypeCheckTest.java\n         compiler,\n         new SemanticReverseAbstractInterpreter(\n             compiler.getCodingConvention(), registry),\n-        registry, topScope, scopeCreator, CheckLevel.WARNING, CheckLevel.OFF)\n+        registry, topScope, scopeCreator, CheckLevel.WARNING)\n         .process(null, second);\n \n     assertEquals(1, compiler.getWarningCount());\n--- a/test/com/google/javascript/jscomp/RemoveUnusedNamesTest.java\n+++ b/test/com/google/javascript/jscomp/RemoveUnusedNamesTest.java\n                 compiler.getCodingConvention(),\n                 compiler.getTypeRegistry()),\n             compiler.getTypeRegistry(),\n-            CheckLevel.ERROR,\n             CheckLevel.ERROR).processForTesting(externs, root);\n \n         new RemoveUnusedNames(\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         compiler,\n         new SemanticReverseAbstractInterpreter(\n             compiler.getCodingConvention(), registry),\n-        registry, topScope, scopeCreator, CheckLevel.WARNING, CheckLevel.OFF)\n+        registry, topScope, scopeCreator, CheckLevel.WARNING)\n         .process(null, second);\n \n     assertEquals(1, compiler.getWarningCount());\n         \"some(g());\\n\");\n   }\n \n+  public void testUnknownTypeReport() throws Exception {\n+    compiler.getOptions().setWarningLevel(DiagnosticGroups.REPORT_UNKNOWN_TYPES,\n+        CheckLevel.WARNING);\n+    testTypes(\"function id(x) { return x; }\",\n+        \"could not determine the type of this expression\");\n+  }\n+\n+  public void testUnknownTypeDisabledByDefault() throws Exception {\n+    testTypes(\"function id(x) { return x; }\");\n+  }\n+\n   public void testTemplatizedTypeSubtypes2() throws Exception {\n     JSType arrayOfNumber = createTemplatizedType(\n         ARRAY_TYPE, NUMBER_TYPE);\n         new SemanticReverseAbstractInterpreter(\n             compiler.getCodingConvention(), registry),\n         registry,\n-        reportMissingOverrides,\n-        CheckLevel.OFF);\n+        reportMissingOverrides);\n   }\n \n   void testTypes(String js, String[] warnings) throws Exception {", "timestamp": 1365184411, "metainfo": ""}