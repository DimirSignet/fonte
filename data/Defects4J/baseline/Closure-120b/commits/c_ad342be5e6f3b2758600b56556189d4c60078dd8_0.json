{"sha": "ad342be5e6f3b2758600b56556189d4c60078dd8", "log": "Add custom dispose methods to CheckEventfulDisposal pass.  Adds extra JSDoc tag to specify which parameters of a function will get disposed of: /** * @param x * @param y * @disposes x *// function disp(x,y) { ... goog.dispose(x); ... };  Allows specifying names of already defined parameters or '*' for a function that disposes all its parameters. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=48456782", "commit": "\n--- a/src/com/google/javascript/jscomp/CheckEventfulObjectDisposal.java\n+++ b/src/com/google/javascript/jscomp/CheckEventfulObjectDisposal.java\n import com.google.javascript.rhino.JSDocInfo.Visibility;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n import com.google.javascript.rhino.jstype.ObjectType;\n import com.google.javascript.rhino.jstype.UnionType;\n \n+import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n   // Eventful types\n   private Set<JSType> eventfulTypes;\n \n-  // Dispose methods is a map from regex to argument disposed/all arguments disposed.\n-  private Map<String, int[]> disposeMethods;\n+  /*\n+   * Dispose methods is a map from regex to argument disposed/all arguments disposed.\n+   * Note: it is assumed that at most one regex match will occur per disposeMethod call.\n+   */\n+  private Map<String, List<Integer>> disposeMethods;\n   // Member used to signify all arguments should be disposed.\n-  public static int[] disposeAll;\n+  public static final int DISPOSE_ALL = -1;\n \n   private final AbstractCompiler compiler;\n   private final JSTypeRegistry typeRegistry;\n    * @param argumentsThatAreDisposed An array of integers (ideally sorted) that specifies\n    *   the arguments of the function being disposed\n    */\n-  private void addDisposeCall(String pattern, int[] argumentsThatAreDisposed) {\n+  private void addDisposeCall(String pattern, List<Integer> argumentsThatAreDisposed) {\n     this.disposeMethods.put(pattern, argumentsThatAreDisposed);\n   }\n \n     this.disposeMethods = Maps.newHashMap();\n \n     // Initialize disposeMethods hashmap\n-    this.addDisposeCall(\"goog.dispose\", new int[]{0});\n-    this.addDisposeCall(\"goog.disposeAll\", disposeAll);\n-    this.addDisposeCall(\".push\", new int[]{0});\n-    this.addDisposeCall(\".add\", disposeAll);\n+    this.addDisposeCall(\"goog.dispose\", new ArrayList<Integer>(Arrays.asList(0)));\n+    this.addDisposeCall(\"goog.disposeAll\", new ArrayList<Integer>(Arrays.asList(DISPOSE_ALL)));\n+    this.addDisposeCall(\".push\", new ArrayList<Integer>(Arrays.asList(0)));\n+    this.addDisposeCall(\".add\", new ArrayList<Integer>(Arrays.asList(DISPOSE_ALL)));\n   }\n \n \n       // Call to function known to dispose arguments\n       for (String disposeMethod : disposeMethods.keySet()) {\n         if (property.matches(disposeMethod)) {\n-          int[] disposeArguments = disposeMethods.get(disposeMethod);\n-\n-          // Dispose all arguments?\n-          if (disposeArguments == disposeAll) {\n-            for (Node t = first.getNext(); t != null; t = t.getNext()) {\n+          List<Integer> disposeArguments = disposeMethods.get(disposeMethod);\n+\n+          // Dispose specific arguments only\n+          Node t = first.getNext();\n+          int tsArgument = 0;\n+          for (Integer disposeArgument : disposeArguments) {\n+            // Dispose all arguments?\n+            if (disposeArgument == DISPOSE_ALL) {\n+              for (Node tt = first.getNext(); tt != null; tt = tt.getNext()) {\n+                ret.add(tt);\n+              }\n+              break;\n+            }\n+\n+            // The current item pointed to by t is beyond that requested in\n+            // current array element.\n+            if (tsArgument > disposeArgument) {\n+              t = first.getNext();\n+              tsArgument = 0;\n+            }\n+            for (; tsArgument < disposeArgument && t != null; ++tsArgument) {\n+              t = t.getNext();\n+            }\n+            if (tsArgument == disposeArgument && t != null) {\n               ret.add(t);\n             }\n-          } else {\n-            // Dispose specific arguments only\n-            Node t = first.getNext();\n-            int tsArgument = 0;\n-            for (int index : disposeArguments) {\n-              // The current item pointed to by t is beyond that requested in\n-              // current array element.\n-              if (tsArgument > disposeArguments[index]) {\n-                t = first.getNext();\n-                tsArgument = 0;\n-              }\n-              for (; tsArgument < disposeArguments[index] && t != null; ++tsArgument) {\n-                t = t.getNext();\n-              }\n-              if (tsArgument == disposeArguments[index] && t != null) {\n-                ret.add(t);\n-              }\n-            }\n-          }\n+          }\n+\n+          return ret;\n         }\n       }\n \n      */\n     private JSType dereference(JSType type) {\n       return type == null ? null : type.dereference();\n+    }\n+\n+    /*\n+     * Check function definitions to add custom dispose methods.\n+     */\n+    public void isFunction(NodeTraversal t, Node n) {\n+      Preconditions.checkArgument(n.isFunction());\n+      JSDocInfo jsDocInfo = NodeUtil.getFunctionJSDocInfo(n);\n+\n+      // Function annotated to dispose of\n+      if (jsDocInfo != null && jsDocInfo.isDisposes()) {\n+        JSType type = n.getJSType();\n+        if (type == null || type.isUnknownType()) {\n+          return;\n+        }\n+\n+        FunctionType funType = type.toMaybeFunctionType();\n+        Node paramNode = NodeUtil.getFunctionParameters(n).getFirstChild();\n+        List<Integer> positionalDisposedParameters = Lists.newArrayList();\n+\n+        if (jsDocInfo.disposesOf(\"*\")) {\n+          positionalDisposedParameters.add(DISPOSE_ALL);\n+        } else {\n+          // Param types\n+          int index = 0;\n+          for (Node p : funType.getParameters()) {\n+              // Bail out if the paramNode is not there.\n+              if (paramNode == null) {\n+                break;\n+              }\n+              if (jsDocInfo.disposesOf(paramNode.getString())) {\n+                positionalDisposedParameters.add(index);\n+              }\n+              paramNode = paramNode.getNext();\n+              index++;\n+          }\n+        }\n+        addDisposeCall(NodeUtil.getFunctionName(n), positionalDisposedParameters);\n+      }\n     }\n \n     /*\n         case Token.CALL:\n           isCall(t, n);\n           break;\n+        case Token.FUNCTION:\n+          isFunction(t, n);\n+          break;\n         case Token.NEW:\n           isNew(t, n, parent);\n           break;\n--- a/src/com/google/javascript/jscomp/parsing/Annotation.java\n+++ b/src/com/google/javascript/jscomp/parsing/Annotation.java\n   DEPRECATED,\n   DESC,\n   DICT,\n+  DISPOSES,\n   ENUM,\n   EXTENDS,\n   EXTERNS,\n       put(\"deprecated\", Annotation.DEPRECATED).\n       put(\"desc\", Annotation.DESC).\n       put(\"dict\", Annotation.DICT).\n+      put(\"disposes\", Annotation.DISPOSES).\n       put(\"enum\", Annotation.ENUM).\n       put(\"export\", Annotation.EXPORT).\n       put(\"expose\", Annotation.EXPOSE).\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n           }\n           return eatTokensUntilEOL();\n \n+        case DISPOSES: {\n+          ExtractionInfo templateInfo = extractSingleLineBlock();\n+          List<String> names = Lists.newArrayList(\n+              Splitter.on(',')\n+                  .trimResults()\n+                  .split(templateInfo.string));\n+\n+          if (names.size() == 0 || names.get(0).length() == 0) {\n+            parser.addTypeWarning(\"msg.jsdoc.disposeparameter.missing\",\n+                  stream.getLineno(), stream.getCharno());\n+          } else if (!jsdocBuilder.recordDisposesParameter(names)) {\n+            parser.addTypeWarning(\"msg.jsdoc.disposeparameter.error\",\n+                stream.getLineno(), stream.getCharno());\n+          }\n+\n+          token = templateInfo.token;\n+          return token;\n+        }\n+\n         case VERSION:\n           ExtractionInfo versionInfo = extractSingleLineBlock();\n           String version = versionInfo.string;\n--- a/src/com/google/javascript/rhino/JSDocInfo.java\n+++ b/src/com/google/javascript/rhino/JSDocInfo.java\n     Map<String, JSTypeExpression> parameters = null;\n     List<JSTypeExpression> thrownTypes = null;\n     ImmutableList<String> templateTypeNames = null;\n+    Set<String> disposedParameters = null;\n \n     // Other information\n     String description = null;\n   }\n \n   /**\n+   * Returns whether JSDoc is annotated with {@code @disposes} annotation.\n+   */\n+  public boolean isDisposes() {\n+    return (info == null) ? false : info.disposedParameters != null;\n+  }\n+\n+  boolean setDisposedParameter(String parameterName) {\n+    lazyInitInfo();\n+    // Lazily initialize disposedParameters\n+    if (info.disposedParameters == null) {\n+      info.disposedParameters = Sets.newHashSet();\n+    }\n+\n+    if (info.disposedParameters.contains(parameterName)) {\n+      return false;\n+    } else {\n+      info.disposedParameters.add(parameterName);\n+      return true;\n+    }\n+  }\n+\n+  /**\n+   * Return whether the function disposes of specified parameter.\n+   */\n+  public boolean disposesOf(String parameterName) {\n+    return isDisposes() && info.disposedParameters.contains(parameterName);\n+  }\n+\n+  /**\n    * Gets the description specified by the {@code @license} annotation.\n    */\n   public String getLicense() {\n--- a/src/com/google/javascript/rhino/JSDocInfoBuilder.java\n+++ b/src/com/google/javascript/rhino/JSDocInfoBuilder.java\n   }\n \n   /**\n+   * Returns whether current JSDoc is annotated with {@code @disposes}.\n+   */\n+  public boolean isDisposesRecorded() {\n+    return currentInfo.isDisposes();\n+  }\n+\n+  /**\n+   * Records a parameter that gets disposed.\n+   *\n+   * @return {@code true} if all the parameters was recorded and\n+   *     {@code false} if a parameter with the same name was already defined\n+   */\n+  public boolean recordDisposesParameter(List<String> parameterNames) {\n+    for (String parameterName : parameterNames) {\n+      if ((currentInfo.hasParameter(parameterName) ||\n+          parameterName.equals(\"*\")) &&\n+          currentInfo.setDisposedParameter(parameterName)) {\n+        populated = true;\n+      } else {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  /**\n    * Whether the current doc info has other type tags, like\n    * {@code @param} or {@code @return} or {@code @type} or etc.\n    */\n--- a/test/com/google/javascript/jscomp/CheckEventfulObjectDisposalTest.java\n+++ b/test/com/google/javascript/jscomp/CheckEventfulObjectDisposalTest.java\n     testSame(js, CheckEventfulObjectDisposal.OVERWRITE_PRIVATE_EVENTFUL_OBJECT, true);\n   }\n \n-  /*\n-   // TODO(user): update & enable when custom dispose call API is implemented\n-  public void testCustomDispose() {\n-    policy = CheckEventfulObjectDisposal.DisposalCheckingPolicy.AGGRESSIVE;\n-    customDispose = Maps.newHashMap();\n-    customDispose.put(\"helpers.disp\", new int[]{0});\n-    String js = CLOSURE_DEFS\n-        + \"helpers.disp = function(todispose, ctx) {\"\n+  public void testCustomDispose1() {\n+    policy = CheckEventfulObjectDisposal.DisposalCheckingPolicy.AGGRESSIVE;\n+    String js = CLOSURE_DEFS\n+        + \"/** @param todispose\\n @param ctx\\n @disposes todispose\\n */\"\n+        + \"customDispose = function(todispose, ctx) {\"\n         + \" ctx.registerDisposable(todispose);\"\n         + \" return todispose;\"\n         + \"};\"\n-        + \"var x = helpers.disp(new goog.events.EventHandler(), OBJ);\"\n+        + \"var x = new goog.events.EventHandler();\"\n+        + \"customDispose(x, OBJ);\";\n+    testSame(js);\n+  }\n+\n+  public void testCustomDispose2() {\n+    policy = CheckEventfulObjectDisposal.DisposalCheckingPolicy.AGGRESSIVE;\n+    String js = CLOSURE_DEFS\n+        + \"/** @param todispose\\n @param ctx\\n @disposes *\\n */\"\n+        + \"customDispose = function(todispose, ctx) {\"\n+        + \" ctx.registerDisposable(todispose);\"\n+        + \" return todispose;\"\n+        + \"};\"\n+        + \"var x = new goog.events.EventHandler();\"\n         + \"var y = new goog.events.EventHandler();\"\n-        + \"helpers.disp(y, OBJ);\";\n-    testSame(js);\n-  }\n-  */\n+        + \"customDispose(x, y);\";\n+    testSame(js);\n+  }\n+\n+  public void testCustomDispose3() {\n+    policy = CheckEventfulObjectDisposal.DisposalCheckingPolicy.AGGRESSIVE;\n+    String js = CLOSURE_DEFS\n+        + \"/** @param todispose\\n @param ctx\\n @disposes todispose\\n */\"\n+        + \"customDispose = function(todispose, ctx) {\"\n+        + \" ctx.registerDisposable(todispose);\"\n+        + \" return todispose;\"\n+        + \"};\"\n+        + \"var x = new goog.events.EventHandler();\"\n+        + \"customDispose(OBJ, x);\";\n+    testSame(js, CheckEventfulObjectDisposal.EVENTFUL_OBJECT_PURELY_LOCAL, true);\n+  }\n }\n--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n     parse(\"@wizaction \\n@wizaction*/\", \"extra @wizaction tag\");\n   }\n \n+  public void testParseDisposes1() throws Exception {\n+    assertTrue(parse(\"@param x \\n * @disposes x */\").isDisposes());\n+  }\n+\n+  public void testParseDisposes2() throws Exception {\n+    parse(\"@param x \\n * @disposes */\",\n+        true, \"Bad type annotation. @disposes tag missing parameter name\");\n+  }\n+\n+  public void testParseDisposes3() throws Exception {\n+    assertTrue(parse(\"@param x \\n @param y\\n * @disposes x, y */\").isDisposes());\n+  }\n+\n+  public void testParseDisposesUnknown() throws Exception {\n+    parse(\"@param x \\n * @disposes x,y */\",\n+        true,\n+        \"Bad type annotation. @disposes parameter unknown or parameter specified multiple times\");\n+  }\n+\n+  public void testParseDisposesMultiple() throws Exception {\n+    parse(\"@param x \\n * @disposes x,x */\",\n+        true,\n+        \"Bad type annotation. @disposes parameter unknown or parameter specified multiple times\");\n+  }\n+\n+  public void testParseDisposesAll1() throws Exception {\n+    assertTrue(parse(\"@param x \\n * @disposes * */\").isDisposes());\n+  }\n+\n+  public void testParseDisposesAll2() throws Exception {\n+    assertTrue(parse(\"@param x \\n * @disposes x,* */\").isDisposes());\n+  }\n+\n+  public void testParseDisposesAll3() throws Exception {\n+    parse(\"@param x \\n * @disposes *, * */\",\n+        true,\n+        \"Bad type annotation. @disposes parameter unknown or parameter specified multiple times\");\n+  }\n+\n   public void testTextExtents() {\n     parse(\"@return {@code foo} bar \\n *    baz. */\",\n         true, \"Bad type annotation. type not recognized due to syntax error\");", "timestamp": 1372185663, "metainfo": ""}