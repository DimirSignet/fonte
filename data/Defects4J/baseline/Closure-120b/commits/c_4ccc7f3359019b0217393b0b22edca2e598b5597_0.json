{"sha": "4ccc7f3359019b0217393b0b22edca2e598b5597", "log": "Change the default coding convention from GoogleCodingConvention to ClosureCodingConvention, as external projects using the Java API end up with the wrong one.  Touch up the unit tests where they are expecting the other.  R=nicksantos DELTA=26  (24 added, 0 deleted, 2 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=165   ", "commit": "\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n   private final StringBuilder debugLog = new StringBuilder();\n \n   /** Detects Google-specific coding conventions. */\n-  CodingConvention defaultCodingConvention = new GoogleCodingConvention();\n+  CodingConvention defaultCodingConvention = new ClosureCodingConvention();\n \n   private JSTypeRegistry typeRegistry;\n   private Config parserConfig = null;\n--- a/test/com/google/javascript/jscomp/CompilerTypeTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTypeTestCase.java\n     CompilerOptions options = new CompilerOptions();\n     options.setWarningLevel(\n         DiagnosticGroups.MISSING_PROPERTIES, CheckLevel.WARNING);\n+    options.setCodingConvention(getCodingConvention());\n     return options;\n+  }\n+\n+  protected CodingConvention getCodingConvention() {\n+    return new GoogleCodingConvention();\n   }\n \n   @Override\n--- a/test/com/google/javascript/jscomp/ExpressionDecomposerTest.java\n+++ b/test/com/google/javascript/jscomp/ExpressionDecomposerTest.java\n   // Constant object on LHS of assignment-op.\n   public void testExposePlusEquals3() {\n     helperExposeExpression(\n-        \"var XX = {};\\n\" +\n+        \"/** @const */ var XX = {};\\n\" +\n         \"XX.a += foo() + 1\",\n         \"foo\",\n         \"var XX = {}; var temp_const$$0 = XX.a;\" +\n         \"var temp_const$$1 = temp_const$$0.b;\" +\n         \"y = (temp_const$$0.b = temp_const$$1 + foo()) + goo().a\");\n   }\n-  \n+\n   public void testExposeObjectLit1() {\n     // Validate that getter and setters methods are see as side-effect\n-    // free and that values can move past them.  We don't need to be \n+    // free and that values can move past them.  We don't need to be\n     // concerned with exposing the getter or setter here but the\n     // decomposer does not have a method of exposing properties only variables.\n     helperMoveExpression(\n     Compiler compiler = new Compiler();\n     CompilerOptions options = new CompilerOptions();\n     options.languageIn = LanguageMode.ECMASCRIPT5;\n+    options.setCodingConvention(new GoogleCodingConvention());\n     compiler.initOptions(options);\n     return compiler;\n   }\n-  \n+\n   private static Node findCall(Node n, String name) {\n     return findCall(n, name, 1);\n   }\n--- a/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n+++ b/test/com/google/javascript/jscomp/FunctionInjectorTest.java\n     };\n \n     CompilerOptions options = new CompilerOptions();\n+    options.setCodingConvention(new GoogleCodingConvention());\n     compiler.init(externsInputs, new JSSourceFile[] {\n         JSSourceFile.fromCode(\"code\", code) }, options);\n     Node parseRoot = compiler.parseInputs();\n--- a/test/com/google/javascript/jscomp/LiveVariableAnalysisTest.java\n+++ b/test/com/google/javascript/jscomp/LiveVariableAnalysisTest.java\n \n   private static LiveVariablesAnalysis computeLiveness(String src) {\n     Compiler compiler = new Compiler();\n+    CompilerOptions options = new CompilerOptions();\n+    options.setCodingConvention(new GoogleCodingConvention());\n+    compiler.initOptions(options);\n     src = \"function _FUNCTION(param1, param2){\" + src + \"}\";\n     Node n = compiler.parseTestCode(src).removeFirstChild();\n     Node script = new Node(Token.SCRIPT, n);", "timestamp": 1292873769, "metainfo": ""}