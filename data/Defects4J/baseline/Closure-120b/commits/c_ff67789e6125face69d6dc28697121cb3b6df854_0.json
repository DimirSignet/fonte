{"sha": "ff67789e6125face69d6dc28697121cb3b6df854", "log": "Fix a bunch of bugs in marker generation, and add lots of inline assertions to prevent this from regressing. Right now, Grok has a bunch of checks to work around these bugs, and we would like to get rid of them.  R=jschorr,tylerg DELTA=272  (134 added, 14 deleted, 124 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3268   ", "commit": "\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n     int startCharno = stream.getCharno();\n \n     Node typeNode = parseParamTypeExpressionAnnotation(token);\n-    int endCharno = stream.getCharno();\n-\n-    jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endCharno,\n-        true);\n+    if (typeNode != null) {\n+      int endLineno = stream.getLineno();\n+      int endCharno = stream.getCharno();\n+\n+      jsdocBuilder.markTypeNode(typeNode, lineno, startCharno,\n+          endLineno, endCharno, true);\n+    }\n     return typeNode;\n   }\n \n       typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n     }\n \n-    int endCharno = stream.getCharno();\n-\n-    jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endCharno,\n-        matchingLC);\n+    if (typeNode != null) {\n+      int endLineno = stream.getLineno();\n+      int endCharno = stream.getCharno();\n+\n+      jsdocBuilder.markTypeNode(\n+          typeNode, lineno, startCharno, endLineno, endCharno, matchingLC);\n+    }\n \n     return typeNode;\n   }\n--- a/src/com/google/javascript/rhino/JSDocInfo.java\n+++ b/src/com/google/javascript/rhino/JSDocInfo.java\n \n package com.google.javascript.rhino;\n \n+import com.google.common.base.Preconditions;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Lists;\n   }\n \n   /**\n+   * A piece of information in a marker containing a position with a string\n+   * that has no leading or trailing whitespace.\n+   */\n+  static class TrimmedStringPosition extends StringPosition {\n+    @Override public void setItem(String item) {\n+      Preconditions.checkArgument(\n+          item.charAt(0) != ' ' &&\n+          item.charAt(item.length() - 1) != ' ',\n+          \"String has leading or trailing whitespace\");\n+      super.setItem(item);\n+    }\n+  }\n+\n+  /**\n    * A piece of information in a marker containing a position with a type.\n    */\n   public static class TypePosition extends SourcePosition<Node> {\n-    public boolean hasBrackets = false;\n+    private boolean brackets = false;\n+\n+    /** Returns whether the type has curly braces around it. */\n+    public boolean hasBrackets() {\n+      return brackets;\n+    }\n+\n+    void setHasBrackets(boolean newVal) {\n+      brackets = newVal;\n+    }\n   }\n \n   /**\n    * if documentation collection is turned on.\n    */\n   public static final class Marker {\n-    public StringPosition annotation = null;\n-    public StringPosition name = null;\n-    public StringPosition description = null;\n-    public TypePosition type = null;\n+    private TrimmedStringPosition annotation = null;\n+    private TrimmedStringPosition name = null;\n+    private StringPosition description = null;\n+    private TypePosition type = null;\n+\n+    /**\n+     * Gets the position info for the annotation name (e.g., \"@see\").\n+     */\n+    public StringPosition getAnnotation() {\n+      return annotation;\n+    }\n+\n+    void setAnnotation(TrimmedStringPosition p) {\n+      annotation = p;\n+    }\n+\n+    /**\n+     * Gets the position info for parameter name of a @param tag.\n+     */\n+    public StringPosition getName() {\n+      return name;\n+    }\n+\n+    void setName(TrimmedStringPosition p) {\n+      name = p;\n+    }\n+\n+    /**\n+     * Gets the position info for the description part of a block tag.\n+     */\n+    public StringPosition getDescription() {\n+      return description;\n+    }\n+\n+    void setDescription(StringPosition p) {\n+      description = p;\n+    }\n+\n+    /**\n+     * Gets the position info for the type expression of a block tag.\n+     */\n+    public TypePosition getType() {\n+      return type;\n+    }\n+\n+    void setType(TypePosition p) {\n+      type = p;\n+    }\n   }\n \n   private LazilyInitializedInfo info = null;\n \n   /** Gets the list of all markers for the documentation in this JSDoc. */\n   public Collection<Marker> getMarkers() {\n-    return documentation == null ? null : documentation.markers;\n+    return documentation == null\n+        ? ImmutableList.<Marker>of() : documentation.markers;\n   }\n \n   /** Gets the template type name. */\n--- a/src/com/google/javascript/rhino/JSDocInfoBuilder.java\n+++ b/src/com/google/javascript/rhino/JSDocInfoBuilder.java\n     JSDocInfo.Marker marker = currentInfo.addMarker();\n \n     if (marker != null) {\n-      marker.annotation = new JSDocInfo.StringPosition();\n-      marker.annotation.setItem(annotation);\n-      marker.annotation.setPositionInformation(lineno, charno, lineno,\n-                                               charno + annotation.length());\n+      JSDocInfo.TrimmedStringPosition position =\n+          new JSDocInfo.TrimmedStringPosition();\n+      position.setItem(annotation);\n+      position.setPositionInformation(lineno, charno, lineno,\n+          charno + annotation.length());\n+      marker.setAnnotation(position);\n+      populated = true;\n     }\n \n     currentMarker = marker;\n   public void markText(String text, int startLineno, int startCharno,\n       int endLineno, int endCharno) {\n     if (currentMarker != null) {\n-      currentMarker.description = new JSDocInfo.StringPosition();\n-      currentMarker.description.setItem(text);\n-      currentMarker.description.setPositionInformation(startLineno, startCharno,\n-                                                       endLineno, endCharno);\n+      JSDocInfo.StringPosition position = new JSDocInfo.StringPosition();\n+      position.setItem(text);\n+      position.setPositionInformation(startLineno, startCharno,\n+          endLineno, endCharno);\n+      currentMarker.setDescription(position);\n     }\n   }\n \n    * Adds a type declaration to the current marker.\n    */\n   public void markTypeNode(Node typeNode, int lineno, int startCharno,\n-      int endCharno, boolean hasLC) {\n+      int endLineno, int endCharno, boolean hasLC) {\n     if (currentMarker != null) {\n-      currentMarker.type = new JSDocInfo.TypePosition();\n-      currentMarker.type.setItem(typeNode);\n-      currentMarker.type.hasBrackets = hasLC;\n-      currentMarker.type.setPositionInformation(lineno, startCharno,\n-                                                lineno, endCharno);\n+      JSDocInfo.TypePosition position = new JSDocInfo.TypePosition();\n+      position.setItem(typeNode);\n+      position.setHasBrackets(hasLC);\n+      position.setPositionInformation(lineno, startCharno,\n+          endLineno, endCharno);\n+      currentMarker.setType(position);\n     }\n   }\n \n    */\n   public void markName(String name, int lineno, int charno) {\n     if (currentMarker != null) {\n-      currentMarker.name = new JSDocInfo.StringPosition();\n-      currentMarker.name.setItem(name);\n-      currentMarker.name.setPositionInformation(lineno, charno,\n-                                                lineno, charno + name.length());\n+      JSDocInfo.TrimmedStringPosition position =\n+          new JSDocInfo.TrimmedStringPosition();\n+      position.setItem(name);\n+      position.setPositionInformation(lineno, charno,\n+          lineno, charno + name.length());\n+      currentMarker.setName(position);\n     }\n   }\n \n--- a/src/com/google/javascript/rhino/SourcePosition.java\n+++ b/src/com/google/javascript/rhino/SourcePosition.java\n    */\n   public void setPositionInformation(int startLineno, int startCharno,\n                                      int endLineno, int endCharno) {\n+    if (startLineno == endLineno) {\n+      if (startCharno >= endCharno) {\n+        throw new IllegalStateException(\n+            \"Recorded bad position information\\n\" +\n+            \"start-char: \" + startCharno + \"\\n\" +\n+            \"end-char: \" + endCharno);\n+      }\n+    } else {\n+      if (startLineno > endLineno) {\n+        throw new IllegalStateException(\n+            \"Recorded bad position information\\n\" +\n+            \"start-line: \" + startLineno + \"\\n\" +\n+            \"end-line: \" + endLineno);\n+      }\n+    }\n+\n     this.startLineno = startLineno;\n     this.startCharno = startCharno;\n     this.endLineno = endLineno;\n--- a/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/IRFactoryTest.java\n   private void assertMarkerPosition(Node n, int lineno, int charno) {\n     int count = 0;\n     for (JSDocInfo.Marker marker : n.getJSDocInfo().getMarkers()) {\n-      assertEquals(lineno, marker.annotation.getStartLine());\n-      assertEquals(charno, marker.annotation.getPositionOnStartLine());\n+      assertEquals(lineno, marker.getAnnotation().getStartLine());\n+      assertEquals(charno, marker.getAnnotation().getPositionOnStartLine());\n       count++;\n     }\n     assertEquals(1, count);\n--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n         assertAnnotationMarker(jsdoc, \"return\", 0, 0);\n     assertDocumentationInMarker(returnDoc,\n         \"some long multiline description\", 13, 2, 15);\n-    assertEquals(8, returnDoc.type.getPositionOnStartLine());\n-    assertEquals(12, returnDoc.type.getPositionOnEndLine());\n+    assertEquals(8, returnDoc.getType().getPositionOnStartLine());\n+    assertEquals(12, returnDoc.getType().getPositionOnEndLine());\n   }\n \n   public void testParseWithMarkers4() throws Exception {\n \n     assertNameInMarker(\n         assertAnnotationMarker(jsdoc, \"param\", 0, 0),\n-        \"name\", 18);\n+        \"name\", 0, 18);\n   }\n \n   public void testParseWithMarkerNames2() throws Exception {\n     assertTypeInMarker(\n         assertNameInMarker(\n             assertAnnotationMarker(jsdoc, \"param\", 0, 0, 0),\n-            \"name\", 18),\n-        \"SomeType\", 7, true);\n+            \"name\", 0, 18),\n+        \"SomeType\", 0, 7, 0, 16, true);\n \n     assertTypeInMarker(\n         assertNameInMarker(\n             assertAnnotationMarker(jsdoc, \"param\", 1, 2, 1),\n-            \"anothername\", 23),\n-        \"AnotherType\", 9, true);\n+            \"anothername\", 1, 23),\n+        \"AnotherType\", 1, 9, 1, 21, true);\n+  }\n+\n+  public void testParseWithMarkerNames3() throws Exception {\n+    JSDocInfo jsdoc = parse(\n+        \"@param {Some.Long.Type.\\n *  Name} name somedescription */\", true);\n+\n+    assertTypeInMarker(\n+        assertNameInMarker(\n+            assertAnnotationMarker(jsdoc, \"param\", 0, 0, 0),\n+            \"name\", 1, 10),\n+        \"Some.Long.Type.Name\", 0, 7, 1, 8, true);\n   }\n \n   public void testParseWithoutMarkerName() throws Exception {\n     JSDocInfo jsdoc = parse(\"@author helloworld*/\", true);\n-    assertNull(assertAnnotationMarker(jsdoc, \"author\", 0, 0).name);\n+    assertNull(assertAnnotationMarker(jsdoc, \"author\", 0, 0).getName());\n   }\n \n   public void testParseWithMarkerType() throws Exception {\n \n     assertTypeInMarker(\n         assertAnnotationMarker(jsdoc, \"extends\", 0, 0),\n-        \"FooBar\", 9, true);\n+        \"FooBar\", 0, 9, 0, 16, true);\n   }\n \n   public void testParseWithMarkerType2() throws Exception {\n \n     assertTypeInMarker(\n         assertAnnotationMarker(jsdoc, \"extends\", 0, 0),\n-        \"FooBar\", 9, false);\n+        \"FooBar\", 0, 9, 0, 15, false);\n   }\n \n   public void testTypeTagConflict1() throws Exception {\n                                                        int startCharno,\n                                                        int endLineno,\n                                                        int endCharno) {\n-    assertTrue(marker.description != null);\n-    assertEquals(description, marker.description.getItem());\n+    assertTrue(marker.getDescription() != null);\n+    assertEquals(description, marker.getDescription().getItem());\n \n     // Match positional information.\n-    assertEquals(marker.annotation.getStartLine(),\n-                 marker.description.getStartLine());\n-    assertEquals(startCharno, marker.description.getPositionOnStartLine());\n-    assertEquals(endLineno, marker.description.getEndLine());\n-    assertEquals(endCharno, marker.description.getPositionOnEndLine());\n+    assertEquals(marker.getAnnotation().getStartLine(),\n+                 marker.getDescription().getStartLine());\n+    assertEquals(startCharno, marker.getDescription().getPositionOnStartLine());\n+    assertEquals(endLineno, marker.getDescription().getEndLine());\n+    assertEquals(endCharno, marker.getDescription().getPositionOnEndLine());\n \n     return marker;\n   }\n    *     to have brackets.\n    * @return The marker, for chaining purposes.\n    */\n-  private JSDocInfo.Marker assertTypeInMarker(JSDocInfo.Marker marker,\n-                                            String typeName, int startCharno,\n-                                            boolean hasBrackets) {\n-\n-    assertTrue(marker.type != null);\n-    assertTrue(marker.type.getItem().getType() == Token.STRING);\n+  private JSDocInfo.Marker assertTypeInMarker(\n+      JSDocInfo.Marker marker, String typeName,\n+      int startLineno, int startCharno, int endLineno, int endCharno,\n+      boolean hasBrackets) {\n+\n+    assertTrue(marker.getType() != null);\n+    assertTrue(marker.getType().getItem().getType() == Token.STRING);\n \n     // Match the name and brackets information.\n-    String foundName = marker.type.getItem().getString();\n+    String foundName = marker.getType().getItem().getString();\n \n     assertEquals(typeName, foundName);\n-    assertEquals(hasBrackets, marker.type.hasBrackets);\n+    assertEquals(hasBrackets, marker.getType().hasBrackets());\n \n     // Match position information.\n-    assertEquals(startCharno, marker.type.getPositionOnStartLine());\n-\n-    int endCharno = startCharno + foundName.length();\n-\n-    if (hasBrackets) {\n-      endCharno += 1;\n-    }\n-\n-    assertEquals(endCharno, marker.type.getPositionOnEndLine());\n-    assertEquals(marker.annotation.getStartLine(), marker.type.getStartLine());\n-    assertEquals(marker.annotation.getStartLine(), marker.type.getEndLine());\n+    assertEquals(startCharno, marker.getType().getPositionOnStartLine());\n+    assertEquals(endCharno, marker.getType().getPositionOnEndLine());\n+    assertEquals(startLineno, marker.getType().getStartLine());\n+    assertEquals(endLineno, marker.getType().getEndLine());\n \n     return marker;\n   }\n    * @return The marker, for chaining purposes.\n    */\n   private JSDocInfo.Marker assertNameInMarker(JSDocInfo.Marker marker,\n-                                            String name, int startCharno) {\n-    assertTrue(marker.name != null);\n-    assertEquals(name, marker.name.getItem());\n-\n-    assertEquals(startCharno, marker.name.getPositionOnStartLine());\n+      String name, int startLine, int startCharno) {\n+    assertTrue(marker.getName() != null);\n+    assertEquals(name, marker.getName().getItem());\n+\n+    assertEquals(startCharno, marker.getName().getPositionOnStartLine());\n     assertEquals(startCharno + name.length(),\n-                 marker.name.getPositionOnEndLine());\n-\n-    assertEquals(marker.annotation.getStartLine(), marker.name.getStartLine());\n-    assertEquals(marker.annotation.getStartLine(), marker.name.getEndLine());\n+                 marker.getName().getPositionOnEndLine());\n+\n+    assertEquals(startLine, marker.getName().getStartLine());\n+    assertEquals(startLine, marker.getName().getEndLine());\n \n     return marker;\n   }\n     int counter = 0;\n \n     for (JSDocInfo.Marker marker : markers) {\n-      if (marker.annotation != null) {\n-        if (annotationName.equals(marker.annotation.getItem())) {\n+      if (marker.getAnnotation() != null) {\n+        if (annotationName.equals(marker.getAnnotation().getItem())) {\n \n           if (counter == index) {\n-            assertEquals(startLineno, marker.annotation.getStartLine());\n+            assertEquals(startLineno, marker.getAnnotation().getStartLine());\n             assertEquals(startCharno,\n-                         marker.annotation.getPositionOnStartLine());\n-            assertEquals(startLineno, marker.annotation.getEndLine());\n+                         marker.getAnnotation().getPositionOnStartLine());\n+            assertEquals(startLineno, marker.getAnnotation().getEndLine());\n             assertEquals(startCharno + annotationName.length(),\n-                         marker.annotation.getPositionOnEndLine());\n+                         marker.getAnnotation().getPositionOnEndLine());\n \n             return marker;\n           }", "timestamp": 1316013488, "metainfo": ""}