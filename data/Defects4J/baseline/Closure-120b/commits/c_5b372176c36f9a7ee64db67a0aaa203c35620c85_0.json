{"sha": "5b372176c36f9a7ee64db67a0aaa203c35620c85", "log": "fix a bug in how side-effect call sites are marked up fixes issue 1008 R=blickly", "commit": "\n--- a/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n+++ b/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n \n           if (!callNode.isNew()) {\n             if (functionInfo.taintsThis) {\n-              flags.setMutatesThis();\n+              // A FunctionInfo for \"f\" maps to both \"f()\" and \"f.call()\" nodes.\n+              if (isCallOrApply(callNode)) {\n+                flags.setMutatesArguments();\n+              } else {\n+                flags.setMutatesThis();\n+              }\n             }\n           }\n \n         // Side effects only propagate via regular calls.\n         // Calling a constructor that modifies \"this\" has no side effects.\n         if (!callSite.isNew()) {\n-          Node objectNode = getCallThisObject(callSite);\n+          // Notice that we're using \"mutatesThis\" from the callee\n+          // FunctionInfo. If the call site is actually a .call or .apply, then\n+          // the \"this\" is going to be one of its arguments.\n+          boolean isCallOrApply = isCallOrApply(callSite);\n+          Node objectNode = isCallOrApply ?\n+              callSite.getFirstChild().getNext() :\n+              callSite.getFirstChild().getFirstChild();\n           if (objectNode != null && objectNode.isName()\n-              && !isCallOrApply(callSite)) {\n+              && !isCallOrApply) {\n             // Exclude \".call\" and \".apply\" as the value may still be\n             // null or undefined. We don't need to worry about this with a\n             // direct method call because null and undefined don't have any\n             }\n           } else if (objectNode != null\n               && NodeUtil.evaluatesToLocalValue(objectNode)\n-              && !isCallOrApply(callSite)) {\n+              && !isCallOrApply) {\n             // Modifying 'this' on a known local object doesn't change any\n             // significant state.\n             // TODO(johnlenz): We can improve this by including literal values\n     }\n   }\n \n-  /**\n-   * Analyze a call site and extract the node that will be act as\n-   * \"this\" inside the call, which is either the object part of the\n-   * qualified function name, the first argument to the call in the\n-   * case of \".call\" and \".apply\" or null if object is not specified\n-   * in either of those ways.\n-   *\n-   * @return node that will act as \"this\" for the call.\n-   */\n-  private static Node getCallThisObject(Node callSite) {\n-    Node callTarget = callSite.getFirstChild();\n-    if (!NodeUtil.isGet(callTarget)) {\n-\n-      // \"this\" is not specified explicitly; call modifies global \"this\".\n-      return null;\n-    }\n-\n-    String propString = callTarget.getLastChild().getString();\n-    if (propString.equals(\"call\") || propString.equals(\"apply\")) {\n-      return callTarget.getNext();\n-    } else {\n-      return callTarget.getFirstChild();\n-    }\n-  }\n-\n   private static boolean isCallOrApply(Node callSite) {\n-    Node callTarget = callSite.getFirstChild();\n-    if (NodeUtil.isGet(callTarget)) {\n-      String propString = callTarget.getLastChild().getString();\n-      if (propString.equals(\"call\") || propString.equals(\"apply\")) {\n-        return true;\n-      }\n-    }\n-    return false;\n+    return NodeUtil.isFunctionObjectCall(callSite) ||\n+      NodeUtil.isFunctionObjectApply(callSite);\n   }\n \n   /**\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n     }\n \n     /** All side-effect occur and the returned results are non-local. */\n-    public void setAllFlags() {\n+    public SideEffectFlags setAllFlags() {\n       value = Node.SIDE_EFFECTS_ALL;\n+      return this;\n     }\n \n     /** No side-effects occur and the returned results are local. */\n-    public void clearAllFlags() {\n+    public SideEffectFlags clearAllFlags() {\n       value = Node.NO_SIDE_EFFECTS | Node.FLAG_LOCAL_RESULTS;\n+      return this;\n     }\n \n     public boolean areAllFlagsSet() {\n       value |= Node.NO_SIDE_EFFECTS;\n     }\n \n-    public void setMutatesGlobalState() {\n+    public SideEffectFlags setMutatesGlobalState() {\n       // Modify global means everything must be assumed to be modified.\n       removeFlag(Node.FLAG_GLOBAL_STATE_UNMODIFIED);\n       removeFlag(Node.FLAG_ARGUMENTS_UNMODIFIED);\n       removeFlag(Node.FLAG_THIS_UNMODIFIED);\n-    }\n-\n-    public void setThrows() {\n+      return this;\n+    }\n+\n+    public SideEffectFlags setThrows() {\n       removeFlag(Node.FLAG_NO_THROWS);\n-    }\n-\n-    public void setMutatesThis() {\n+      return this;\n+    }\n+\n+    public SideEffectFlags setMutatesThis() {\n       removeFlag(Node.FLAG_THIS_UNMODIFIED);\n-    }\n-\n-    public void setMutatesArguments() {\n+      return this;\n+    }\n+\n+    public SideEffectFlags setMutatesArguments() {\n       removeFlag(Node.FLAG_ARGUMENTS_UNMODIFIED);\n-    }\n-\n-    public void setReturnsTainted() {\n+      return this;\n+    }\n+\n+    public SideEffectFlags setReturnsTainted() {\n       removeFlag(Node.FLAG_LOCAL_RESULTS);\n+      return this;\n     }\n \n     private void removeFlag(int flag) {\n--- a/test/com/google/javascript/jscomp/IntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/IntegrationTest.java\n         \"/** @const */ a.b.c = {};\" +\n         \"a.b.c.MyType;\" +\n         \"a.b.c.myFunc = function(x) {};\");\n+  }\n+\n+  public void testAddFunctionProperties1() throws Exception {\n+    String source =\n+        \"/** @constructor */ function F() {}\" +\n+        \"var x = new F();\" +\n+        \"/** @this {F} */\" +\n+        \"function g() { this.bar = function() { alert(3); }; }\" +\n+        \"g.call(x);\" +\n+        \"x.bar();\";\n+    String expected =\n+        \"var x = new function() {};\" +\n+        \"/** @this {F} */\" +\n+        \"(function () { this.bar = function() { alert(3); }; }).call(x);\" +\n+        \"x.bar();\";\n+\n+    CompilerOptions options = createCompilerOptions();\n+    CompilationLevel.ADVANCED_OPTIMIZATIONS\n+        .setOptionsForCompilationLevel(options);\n+    options.setRenamingPolicy(\n+        VariableRenamingPolicy.OFF, PropertyRenamingPolicy.OFF);\n+    test(options, source, expected);\n+  }\n+\n+  public void testAddFunctionProperties2() throws Exception {\n+    String source =\n+        \"/** @constructor */ function F() {}\" +\n+        \"var x = new F();\" +\n+        \"/** @this {F} */\" +\n+        \"function g(y) { y.bar = function() { alert(3); }; }\" +\n+        \"g(x);\" +\n+        \"x.bar();\";\n+    String expected =\n+        \"var x = new function() {};\" +\n+        \"/** @this {F} */\" +\n+        \"(function (y) { y.bar = function() { alert(3); }; })(x);\" +\n+        \"x.bar();\";\n+\n+    CompilerOptions options = createCompilerOptions();\n+    CompilationLevel.ADVANCED_OPTIMIZATIONS\n+        .setOptionsForCompilationLevel(options);\n+    options.setRenamingPolicy(\n+        VariableRenamingPolicy.OFF, PropertyRenamingPolicy.OFF);\n+    test(options, source, expected);\n   }\n \n   public void testCodingConvention() {\n--- a/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java\n+++ b/test/com/google/javascript/jscomp/PureFunctionIdentifierTest.java\n     checkMarkedCalls(source, ImmutableList.<String>of());\n   }\n \n+  public void testFunctionProperties1() throws Exception {\n+    String source =\n+        \"/** @constructor */\" +\n+        \"function F() {}\" +\n+        \"function g() {\" +\n+        \"  this.bar = function() { alert(3); };\" +\n+        \"}\" +\n+        \"var x = new F();\" +\n+        \"g.call(x);\" +\n+        \"x.bar();\";\n+    checkMarkedCalls(source, ImmutableList.<String>of(\"F\"));\n+\n+    Node lastRoot = getLastCompiler().getRoot();\n+    Node call = findQualifiedNameNode(\"g.call\", lastRoot).getParent();\n+    assertEquals(\n+        new Node.SideEffectFlags()\n+        .clearAllFlags().setMutatesArguments().valueOf(),\n+        call.getSideEffectFlags());\n+  }\n+\n   public void testInvalidAnnotation1() throws Exception {\n     test(\"/** @nosideeffects */ function foo() {}\",\n          null, INVALID_NO_SIDE_EFFECT_ANNOTATION);", "timestamp": 1369802070, "metainfo": ""}