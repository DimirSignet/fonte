{"sha": "de306603cfe39c64672539af78bb74a10439e1b3", "log": "When regenerating the global scope, grab the types of things that were inferred in previous compiler passes, so that we don't need to run type inference of the global scope again  R=bashir DELTA=116  (77 added, 18 deleted, 21 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1805   ", "commit": "\n--- a/src/com/google/javascript/jscomp/MemoizedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/MemoizedScopeCreator.java\n     }\n     return scope;\n   }\n+\n+  public Scope getScopeIfMemoized(Node n) {\n+    return scopes.get(n);\n+  }\n }\n--- a/src/com/google/javascript/jscomp/PassConfig.java\n+++ b/src/com/google/javascript/jscomp/PassConfig.java\n package com.google.javascript.jscomp;\n \n import com.google.common.collect.Iterables;\n+import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.jscomp.graph.GraphvizGraph;\n import com.google.javascript.jscomp.graph.LinkedDirectedGraph;\n import com.google.javascript.rhino.Node;\n \n import java.io.Serializable;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n    * Regenerates the top scope.\n    */\n   void regenerateGlobalTypedScope(AbstractCompiler compiler, Node root) {\n+    MemoizedScopeCreator oldScopeCreator = typedScopeCreator;\n     typedScopeCreator =\n         new MemoizedScopeCreator(new TypedScopeCreator(compiler));\n     topScope = typedScopeCreator.createScope(root, null);\n+\n+    if (oldScopeCreator != null) {\n+      Scope oldTopScope = oldScopeCreator.getScopeIfMemoized(root);\n+      if (oldTopScope != null) {\n+        // For each variable declared with the VAR keyword, we want to grab\n+        // its old inferred type.\n+        //\n+        // This is purely a heuristic. There are probably better ones we\n+        // can use to increase the accuracy (like checking if a variable\n+        // has been modified in the current script).\n+        Iterator<Var> varIt =\n+            topScope.getDeclarativelyUnboundVarsWithoutTypes();\n+        while (varIt.hasNext()) {\n+          Var newVar = varIt.next();\n+          Var oldVar = oldTopScope.getVar(newVar.getName());\n+          if (oldVar != null) {\n+            newVar.setType(oldVar.getType());\n+          }\n+        }\n+      }\n+    }\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/Scope.java\n+++ b/src/com/google/javascript/jscomp/Scope.java\n import static com.google.javascript.rhino.jstype.JSTypeNative.GLOBAL_THIS;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.base.Predicate;\n+import com.google.common.collect.Iterators;\n import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n \n   private Var arguments;\n \n+  private static final Predicate<Var> DECLARATIVELY_UNBOUND_VARS_WITHOUT_TYPES =\n+      new Predicate<Var>() {\n+    @Override public boolean apply(Var var) {\n+      return var.getParentNode() != null &&\n+          var.getType() == null && // no declared type\n+          var.getParentNode().getType() == Token.VAR &&\n+          !var.isExtern();\n+    }\n+  };\n+\n   /** Stores info about a variable */\n   public static class Var implements StaticSlot<JSType> {\n     /** name */\n \n     /**\n      * Gets this variable's type. To know whether this type has been inferred,\n-     * see {@code #isInferred()}.\n+     * see {@code #isTypeInferred()}.\n      */\n     public JSType getType() {\n       return type;\n \n     @Override\n     public String toString() {\n-      return \"Scope.Var \" + name;\n+      return \"Scope.Var \" + name + \"{\" + type + \"}\";\n     }\n   }\n \n   public boolean isLocal() {\n     return !isGlobal();\n   }\n+\n+  /**\n+   * Gets all variables declared with \"var\" but without declared types attached.\n+   */\n+  public Iterator<Var> getDeclarativelyUnboundVarsWithoutTypes() {\n+    return Iterators.filter(\n+        getVars(), DECLARATIVELY_UNBOUND_VARS_WITHOUT_TYPES);\n+  }\n }\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n       }\n     }\n \n-    Iterator<Var> varIt = functionScope.getVars();\n+    // For each local variable declared with the VAR keyword, the entry\n+    // type is VOID.\n+    Iterator<Var> varIt =\n+        functionScope.getDeclarativelyUnboundVarsWithoutTypes();\n     while (varIt.hasNext()) {\n       Var var = varIt.next();\n       if (this.unflowableVarNames.contains(var.getName())) {\n         continue;\n       }\n \n-      // For each local variable declared with the VAR keyword, the entry\n-      // type is VOID.\n-      if (var.getParentNode() != null &&\n-          var.getType() == null && // no declared type\n-          var.getParentNode().getType() == Token.VAR &&\n-          !var.isExtern()) {\n-        this.functionScope.inferSlotType(\n-            var.getName(), getNativeType(VOID_TYPE));\n-      }\n+      this.functionScope.inferSlotType(\n+          var.getName(), getNativeType(VOID_TYPE));\n     }\n \n     this.bottomScope = LinkedFlowScope.createEntryLattice(", "timestamp": 1304983944, "metainfo": ""}