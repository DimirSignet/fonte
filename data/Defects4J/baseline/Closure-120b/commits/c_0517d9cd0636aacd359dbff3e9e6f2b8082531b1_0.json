{"sha": "0517d9cd0636aacd359dbff3e9e6f2b8082531b1", "log": "Fix bug in scope-change reporting in InlineFunctions. Fix bug to run the scope-change sanity check during loops only. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=45005173", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCompiler.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompiler.java\n   // If false, the pass will analyze all functions, even those that didn't\n   // change since the last time it ran.\n   // Intended for use by the compiler only; not accessed by compiler users.\n-  protected boolean analyzeChangedFunsOnly = true;\n+  protected boolean analyzeChangedScopesOnly = true;\n \n   // TODO(nicksantos): Decide if all of these are really necessary.\n   // Many of them are just accessors that should be passed to the\n \n   /**\n    * Report code changes.\n+   *\n+   * Passes should call reportCodeChange when they alter the JS tree. This is\n+   * verified by CompilerTestCase. This allows us to optimize to a fixed point.\n    */\n   public abstract void reportCodeChange();\n \n   abstract boolean hasScopeChanged(Node n);\n \n   /** Passes that do cross-scope modifications use this (eg, InlineVariables) */\n-  abstract void reportChangeToScope(Node n);\n-\n-  /** Returns the containing function (or the top level node) for n */\n-  abstract Node getEnclosingScope(Node n);\n+  abstract void reportChangeToEnclosingScope(Node n);\n \n   /**\n    * Returns true if compiling in IDE mode.\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n \n   @Override\n   boolean hasScopeChanged(Node n) {\n+    if (!analyzeChangedScopesOnly || phaseOptimizer == null) {\n+      return true;\n+    }\n+    return phaseOptimizer.hasScopeChanged(n);\n+  }\n+\n+  @Override\n+  void reportChangeToEnclosingScope(Node n) {\n     if (phaseOptimizer != null) {\n-      return phaseOptimizer.hasScopeChanged(n);\n-    }\n-    return true;\n-  }\n-\n-  @Override\n-  void reportChangeToScope(Node n) {\n-    if (phaseOptimizer != null) {\n-      phaseOptimizer.reportChangeToScope(n);\n+      phaseOptimizer.reportChangeToEnclosingScope(n);\n       phaseOptimizer.startCrossScopeReporting();\n       reportCodeChange();\n       phaseOptimizer.endCrossScopeReporting();\n     this.phaseOptimizer = po;\n   }\n \n-  @Override\n-  Node getEnclosingScope(Node n) {\n-    while (n != jsRoot && n.getParent() != null) {\n-      n = n.getParent();\n-      if (n.isFunction()) {\n-        return n;\n-      }\n-    }\n-    return n;\n-  }\n-\n-  /**\n-   * All passes should call reportCodeChange() when they alter\n-   * the JS tree structure. This is verified by CompilerTestCase.\n-   * This allows us to optimize to a fixed point.\n-   */\n   @Override\n   public void reportCodeChange() {\n     for (CodeChangeHandler handler : codeChangeHandlers) {\n--- a/src/com/google/javascript/jscomp/InlineFunctions.java\n+++ b/src/com/google/javascript/jscomp/InlineFunctions.java\n \n     @Override\n     public void remove() {\n-      compiler.reportChangeToScope(fn);\n+      compiler.reportChangeToEnclosingScope(fn);\n       NodeUtil.removeChild(fn.getParent(), fn);\n     }\n \n \n     @Override\n     public void remove() {\n-      compiler.reportChangeToScope(var);\n+      compiler.reportChangeToEnclosingScope(var);\n       NodeUtil.removeChild(var.getParent(), var);\n     }\n \n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n       boolean isFunctionDeclaration = NodeUtil.isFunctionDeclaration(value);\n \n       // decl and ref may be in different scopes, report change for both\n-      compiler.reportChangeToScope(compiler.getEnclosingScope(decl.getNode()));\n-      compiler.reportChangeToScope(compiler.getEnclosingScope(ref.getNode()));\n+      compiler.reportChangeToEnclosingScope(decl.getNode());\n+      compiler.reportChangeToEnclosingScope(ref.getNode());\n \n       inlineValue(v, ref, value.detachFromParent());\n       if (decl != init) {\n       Node varNode = decl.getParent();\n       Node grandparent = decl.getGrandparent();\n \n-      compiler.reportChangeToScope(compiler.getEnclosingScope(decl.getNode()));\n+      compiler.reportChangeToEnclosingScope(decl.getNode());\n       varNode.removeChild(decl.getNode());\n       // Remove var node if empty\n       if (!varNode.hasChildren()) {\n      *     to re-parent.\n      */\n     private void inlineValue(Var v, Reference ref, Node value) {\n-      compiler.reportChangeToScope(compiler.getEnclosingScope(ref.getNode()));\n+      compiler.reportChangeToEnclosingScope(ref.getNode());\n       if (ref.isSimpleAssignmentToName()) {\n         // This is the initial assignment.\n         ref.getGrandparent().replaceChild(ref.getParent(), value);\n--- a/src/com/google/javascript/jscomp/PhaseOptimizer.java\n+++ b/src/com/google/javascript/jscomp/PhaseOptimizer.java\n    * Add the pass generated by the given factory to the compile sequence.\n    * This pass will be run once.\n    */\n+  @VisibleForTesting\n   void addOneTimePass(PassFactory factory) {\n     passes.add(new NamedPass(factory));\n   }\n   private void maybeSanityCheck(Node externs, Node root) {\n     if (sanityCheck != null) {\n       sanityCheck.create(compiler).process(externs, root);\n-      NodeUtil.verifyScopeChanges(mtoc, jsRoot, true);\n-      setSanityCheckState();\n+      if (inLoop) {\n+        NodeUtil.verifyScopeChanges(mtoc, jsRoot, true);\n+        setSanityCheckState();\n+      }\n     }\n   }\n \n   void setScope(Node n) {\n     // NodeTraversal causes setScope calls outside loops; ignore them.\n     if (inLoop) {\n-      currentScope = n.isFunction() ? n : compiler.getEnclosingScope(n);\n+      currentScope = n.isFunction() ? n : getEnclosingScope(n);\n     }\n   }\n \n         || n.getChangeTime() > timeOfLastRun;\n   }\n \n-  void reportChangeToScope(Node n) {\n+  private Node getEnclosingScope(Node n) {\n+    while (n != jsRoot && n.getParent() != null) {\n+      n = n.getParent();\n+      if (n.isFunction()) {\n+        return n;\n+      }\n+    }\n+    return n;\n+  }\n+\n+  void reportChangeToEnclosingScope(Node n) {\n     lastChange = timestamp;\n-    n.setChangeTime(timestamp);\n+    getEnclosingScope(n).setChangeTime(timestamp);\n     // Every code change happens at a different time\n     timestamp++;\n   }\n--- a/test/com/google/javascript/jscomp/MultiPassTest.java\n+++ b/test/com/google/javascript/jscomp/MultiPassTest.java\n public class MultiPassTest extends CompilerTestCase {\n   private List<PassFactory> passes;\n \n-  public MultiPassTest() {}\n+  public MultiPassTest() {\n+    enableNormalize();\n+  }\n \n   protected CompilerPass getProcessor(Compiler compiler) {\n     PhaseOptimizer po = new PhaseOptimizer(compiler, null, null);\n     addPeephole();\n     test(\"function f() { var x = 1; return x + 5; }\",\n         \"function f() { return 6; }\");\n+  }\n+\n+  public void testInlineFunctionsAndPeephole() {\n+    passes = Lists.newLinkedList();\n+    addInlineFunctions();\n+    addPeephole();\n+    test(\"function f() { return 1; }\" +\n+        \"function g() { return f(); }\" +\n+        \"function h() { return g(); } var n = h();\",\n+        \"var n = 1\");\n   }\n \n   public void testInlineVarsAndDeadCodeElim() {\n       });\n   }\n \n+  private void addInlineFunctions() {\n+    passes.add(new PassFactory(\"inlineFunctions\", false) {\n+        @Override\n+        protected CompilerPass create(AbstractCompiler compiler) {\n+          return new InlineFunctions(compiler,\n+              compiler.getUniqueNameIdSupplier(), true, true, true, true, true);\n+        }\n+      });\n+  }\n+\n   private void addPeephole() {\n     passes.add(new PassFactory(\"peepholeOptimizations\", false) {\n         @Override", "timestamp": 1365474035, "metainfo": ""}