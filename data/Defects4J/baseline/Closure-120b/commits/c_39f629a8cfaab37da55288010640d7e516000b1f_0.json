{"sha": "39f629a8cfaab37da55288010640d7e516000b1f", "log": "Replace calls of the form \"Node.getType() != Token.XX\" with \"!Node.isXX()\" calls.  R=nicksantos   Revision created by MOE tool push_codebase. MOE_MIGRATION=3706   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\n+++ b/src/com/google/javascript/jscomp/AbstractPeepholeOptimization.java\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Preconditions;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n \n /**\n  * An abstract class whose implementations run peephole optimizations:\n   @VisibleForTesting\n   static Node validateResult(Node n) {\n     done: {\n-      if (n != null && n.getType() != Token.SCRIPT\n-          && (n.getType() != Token.BLOCK || !n.isSyntheticBlock())) {\n+      if (n != null && !n.isScript()\n+          && (!n.isBlock() || !n.isSyntheticBlock())) {\n         for (Node parent : n.getAncestors()) {\n           if (parent.isScript()) {\n             break done;\n--- a/src/com/google/javascript/jscomp/AliasKeywords.java\n+++ b/src/com/google/javascript/jscomp/AliasKeywords.java\n    * Does the given node define one of our aliases?\n    */\n   private boolean isAliasDefinition(Node n) {\n-    if (n.getType() != Token.NAME) {\n+    if (!n.isName()) {\n       return false;\n     }\n \n--- a/src/com/google/javascript/jscomp/AliasStrings.java\n+++ b/src/com/google/javascript/jscomp/AliasStrings.java\n   @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n     if (n.isString() &&\n-        parent.getType() != Token.GETPROP &&\n-        parent.getType() != Token.REGEXP &&\n+        !parent.isGetProp() &&\n+        !parent.isRegExp() &&\n         !NodeUtil.isObjectLitKey(n, parent)) {\n \n       String str = n.getString();\n--- a/src/com/google/javascript/jscomp/ChainCalls.java\n+++ b/src/com/google/javascript/jscomp/ChainCalls.java\n import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n \n import java.util.Collection;\n import java.util.List;\n \n       for (DiGraphEdge<Node, Branch> s : cfg.getImplicitReturn().getInEdges()) {\n         Node exitNode = s.getSource().getValue();\n-        if (exitNode.getType() != Token.RETURN ||\n+        if (!exitNode.isReturn() ||\n             exitNode.getFirstChild() == null ||\n-            exitNode.getFirstChild().getType() != Token.THIS) {\n+            !exitNode.getFirstChild().isThis()) {\n           badFunctionNodes.add(t.getScopeRoot());\n           return;\n         }\n       }\n \n       Node callNode = n.getFirstChild();\n-      if (callNode.getType() != Token.CALL) {\n+      if (!callNode.isCall()) {\n         return;\n       }\n \n       Node getPropNode = callNode.getFirstChild();\n-      if (getPropNode.getType() != Token.GETPROP) {\n+      if (!getPropNode.isGetProp()) {\n         return;\n       }\n \n       }\n \n       Node nextNode = n.getNext();\n-      if (nextNode == null ||\n-          nextNode.getType() != Token.EXPR_RESULT) {\n+      if (nextNode == null || !nextNode.isExprResult()) {\n         return;\n       }\n \n       Node nextCallNode = nextNode.getFirstChild();\n-      if (nextCallNode.getType() != Token.CALL) {\n+      if (!nextCallNode.isCall()) {\n         return;\n       }\n \n       Node nextGetPropNode = nextCallNode.getFirstChild();\n-      if (nextGetPropNode.getType() != Token.GETPROP) {\n+      if (!nextGetPropNode.isGetProp()) {\n         return;\n       }\n \n--- a/src/com/google/javascript/jscomp/CheckAccessControls.java\n+++ b/src/com/google/javascript/jscomp/CheckAccessControls.java\n     Node parent = getprop.getParent();\n     boolean isDelete = parent.getType() == Token.DELPROP;\n     if (!(NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == getprop)\n-        && (parent.getType() != Token.INC) && (parent.getType() != Token.DEC)\n+        && !parent.isInc() && !parent.isDec()\n         && !isDelete) {\n       return;\n     }\n    * We may want to revisit this if we decide to make the restrictions tighter.\n    */\n   private static boolean isValidPrivateConstructorAccess(Node parent) {\n-    return parent.getType() != Token.NEW;\n+    return !parent.isNew();\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/CheckMissingGetCssName.java\n+++ b/src/com/google/javascript/jscomp/CheckMissingGetCssName.java\n \n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n   @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n     if (n.isString() &&\n-        parent.getType() != Token.GETPROP &&\n-        parent.getType() != Token.REGEXP &&\n+        !parent.isGetProp() &&\n+        !parent.isRegExp() &&\n         !NodeUtil.isObjectLitKey(n, parent)) {\n       String s = n.getString();\n \n--- a/src/com/google/javascript/jscomp/CheckMissingReturn.java\n+++ b/src/com/google/javascript/jscomp/CheckMissingReturn.java\n import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.JSTypeNative;\n    */\n   private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg) {\n     for (DiGraphEdge<Node, Branch> s : cfg.getImplicitReturn().getInEdges()) {\n-      if (s.getSource().getValue().getType() != Token.RETURN) {\n+      if (!s.getSource().getValue().isReturn()) {\n         return false;\n       }\n     }\n--- a/src/com/google/javascript/jscomp/CheckRequiresForConstructors.java\n+++ b/src/com/google/javascript/jscomp/CheckRequiresForConstructors.java\n \n     @Override\n     public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-      return parent == null || parent.getType() != Token.SCRIPT ||\n+      return parent == null || !parent.isScript() ||\n           !t.getInput().isExtern();\n     }\n \n \n       // We only consider programmer-defined constructors that are\n       // global variables, or are defined on global variables.\n-      if (nameNode.getType() != Token.NAME) {\n+      if (!nameNode.isName()) {\n         return;\n       }\n \n--- a/src/com/google/javascript/jscomp/CheckUnreachableCode.java\n+++ b/src/com/google/javascript/jscomp/CheckUnreachableCode.java\n import com.google.javascript.jscomp.graph.GraphReachability;\n import com.google.javascript.jscomp.graph.GraphReachability.EdgeTuple;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.TernaryValue;\n \n /**\n       // be executed early) or some rhino bug.\n       if (n.getLineno() != -1 &&\n           // Allow spurious semi-colons and spurious breaks.\n-          n.getType() != Token.EMPTY && n.getType() != Token.BREAK) {\n+          !n.isEmpty() && !n.isBreak()) {\n         compiler.report(t.makeError(n, level, UNREACHABLE_CODE));\n         // From now on, we are going to assume the user fixed the error and not\n         // give more warning related to code section reachable from this node.\n--- a/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n     }\n \n     Node objectNode = typeNode.getNext();\n-    if (objectNode.getType() != Token.OBJECTLIT) {\n+    if (!objectNode.isObjectLit()) {\n       // TODO(johnlenz): The coding convention should not be performing checks.\n       t.getCompiler().report(JSError.make(t.getSourceName(), callNode,\n                                           OBJECTLIT_EXPECTED));\n     // It would be nice to be able to identify a fn.bind call\n     // but that requires knowing the type of \"fn\".\n \n-    if (n.getType() != Token.CALL) {\n+    if (!n.isCall()) {\n       return null;\n     }\n \n--- a/src/com/google/javascript/jscomp/ClosureOptimizePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ClosureOptimizePrimitives.java\n           callNode.removeChild(keyNode);\n           callNode.removeChild(valueNode);\n \n-          if (keyNode.getType() != Token.STRING) {\n+          if (!keyNode.isString()) {\n             keyNode = Node.newString(NodeUtil.getStringValue(keyNode))\n                 .copyInformationFrom(keyNode);\n           }\n     Node curParam = firstParam;\n     while (curParam != null) {\n       // All keys must be strings or numbers.\n-      if (curParam.getType() != Token.STRING &&\n-          curParam.getType() != Token.NUMBER) {\n+      if (!curParam.isString() && !curParam.isNumber()) {\n         return false;\n       }\n       curParam = curParam.getNext();\n--- a/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n+++ b/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n             .copyInformationFrom(name);\n \n         // We don't need to wrapped it with EXPR node if it is within a FOR.\n-        if (parent.getType() != Token.FOR) {\n+        if (!parent.isFor()) {\n           assign = NodeUtil.newExpr(assign);\n         }\n         parent.replaceChild(var, assign);\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n       }\n \n       case Token.REGEXP:\n-        if (first.getType() != Token.STRING ||\n-            last.getType() != Token.STRING) {\n+        if (!first.isString() ||\n+            !last.isString()) {\n           throw new Error(\"Expected children to be strings\");\n         }\n \n         Preconditions.checkState(childCount <= 1);\n         add(\"continue\");\n         if (childCount == 1) {\n-          if (first.getType() != Token.LABEL_NAME) {\n+          if (!first.isLabelName()) {\n             throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n           }\n           add(\" \");\n         Preconditions.checkState(childCount <= 1);\n         add(\"break\");\n         if (childCount == 1) {\n-          if (first.getType() != Token.LABEL_NAME) {\n+          if (!first.isLabelName()) {\n             throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n           }\n           add(\" \");\n \n       case Token.LABEL:\n         Preconditions.checkState(childCount == 2);\n-        if (first.getType() != Token.LABEL_NAME) {\n+        if (!first.isLabelName()) {\n           throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n         }\n         add(first);\n       Node n, Context context, boolean allowNonBlockChild) {\n     Node nodeToProcess = n;\n \n-    if (!allowNonBlockChild && n.getType() != Token.BLOCK) {\n+    if (!allowNonBlockChild && !n.isBlock()) {\n       throw new Error(\"Missing BLOCK child.\");\n     }\n \n   private boolean isOneExactlyFunctionOrDo(Node n) {\n     if (n.isLabel()) {\n       Node labeledStatement = n.getLastChild();\n-      if (labeledStatement.getType() != Token.BLOCK) {\n+      if (!labeledStatement.isBlock()) {\n         return isOneExactlyFunctionOrDo(labeledStatement);\n       } else {\n         // For labels with block children, we need to ensure that a\n     for (; c != null && i < maxCount; c = c.getNext()) {\n       if (c.isBlock()) {\n         i += getNonEmptyChildCount(c, maxCount-i);\n-      } else if (c.getType() != Token.EMPTY) {\n+      } else if (!c.isEmpty()) {\n         i++;\n       }\n     }\n         if (result != null) {\n           return result;\n         }\n-      } else if (c.getType() != Token.EMPTY) {\n+      } else if (!c.isEmpty()) {\n         return c;\n       }\n     }\n--- a/src/com/google/javascript/jscomp/CodingConventions.java\n+++ b/src/com/google/javascript/jscomp/CodingConventions.java\n package com.google.javascript.jscomp;\n \n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.FunctionType;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n import com.google.javascript.rhino.jstype.ObjectType;\n       // It would be nice to be able to identify a fn.bind call\n       // but that requires knowing the type of \"fn\".\n \n-      if (n.getType() != Token.CALL) {\n+      if (!n.isCall()) {\n         return null;\n       }\n \n--- a/src/com/google/javascript/jscomp/CollapseAnonymousFunctions.java\n+++ b/src/com/google/javascript/jscomp/CollapseAnonymousFunctions.java\n import com.google.common.base.Preconditions;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n \n /**\n  * Collapses anonymous function expressions into named function declarations,\n   private class Callback extends AbstractPostOrderCallback {\n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() != Token.VAR) {\n+      if (!n.isVar()) {\n         return;\n       }\n \n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n \n       Node current = gramps;\n       Node currentParent = gramps.getParent();\n-      for (; currentParent.getType() != Token.SCRIPT &&\n-             currentParent.getType() != Token.BLOCK;\n+      for (; !currentParent.isScript() &&\n+             !currentParent.isBlock();\n            current = currentParent,\n            currentParent = currentParent.getParent()) {}\n \n       // this object literal's child names wouldn't be collapsible.) The only\n       // reason that we don't eliminate them entirely is the off chance that\n       // their values are expressions that have side effects.\n-      boolean isJsIdentifier = key.getType() != Token.NUMBER &&\n+      boolean isJsIdentifier = !key.isNumber() &&\n                                TokenStream.isJSIdentifier(key.getString());\n       String propName = isJsIdentifier ?\n           key.getString() : String.valueOf(++arbitraryNameCounter);\n--- a/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java\n+++ b/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java\n       }\n \n       // Only care about var nodes\n-      if (n.getType() != Token.VAR && !canBeRedeclared(n, t.getScope())) return;\n+      if (!n.isVar() && !canBeRedeclared(n, t.getScope())) return;\n \n       // If we've already looked at this node, skip it\n       if (nodesToCollapse.contains(n)) return;\n--- a/src/com/google/javascript/jscomp/CompilerInput.java\n+++ b/src/com/google/javascript/jscomp/CompilerInput.java\n import com.google.javascript.jscomp.deps.JsFileParser;\n import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import java.io.IOException;\n import java.util.Collection;\n import java.util.Collections;\n         }\n         return;\n       } else if (parent != null &&\n-          parent.getType() != Token.EXPR_RESULT &&\n-          parent.getType() != Token.SCRIPT) {\n+          !parent.isExprResult() &&\n+          !parent.isScript()) {\n         return;\n       }\n \n--- a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n    */\n   static Node getExceptionHandler(Node n) {\n     for (Node cur = n;\n-        cur.getType() != Token.SCRIPT && cur.getType() != Token.FUNCTION;\n+        !cur.isScript() && !cur.isFunction();\n         cur = cur.getParent()) {\n       Node catchNode = getCatchHandlerForBlock(cur);\n       if (catchNode != null) {\n--- a/src/com/google/javascript/jscomp/CreateSyntheticBlocks.java\n+++ b/src/com/google/javascript/jscomp/CreateSyntheticBlocks.java\n   private class Callback extends AbstractPostOrderCallback {\n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() != Token.CALL\n-          || n.getFirstChild().getType() != Token.NAME) {\n+      if (!n.isCall() || !n.getFirstChild().isName()) {\n         return;\n       }\n \n       String callName = callTarget.getString();\n \n       if (startMarkerName.equals(callName)) {\n-        if (parent.getType() != Token.EXPR_RESULT) {\n+        if (!parent.isExprResult()) {\n           compiler.report(\n               t.makeError(n, INVALID_MARKER_USAGE, startMarkerName));\n           return;\n       }\n \n       Node endMarkerNode = parent;\n-      if (endMarkerNode.getType() != Token.EXPR_RESULT) {\n+      if (!endMarkerNode.isExprResult()) {\n         compiler.report(\n             t.makeError(n, INVALID_MARKER_USAGE, endMarkerName));\n         return;\n--- a/src/com/google/javascript/jscomp/CrossModuleCodeMotion.java\n+++ b/src/com/google/javascript/jscomp/CrossModuleCodeMotion.java\n             // VAR Nodes are normalized to have only one child.\n             Node declParent = decl.node.getParent();\n             Preconditions.checkState(\n-                declParent.getType() != Token.VAR || declParent.hasOneChild(),\n+                !declParent.isVar() || declParent.hasOneChild(),\n                 \"AST not normalized.\");\n \n             // Remove it\n \n   @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() != Token.NAME) {\n+    if (!n.isName()) {\n       return;\n     }\n \n--- a/src/com/google/javascript/jscomp/DefinitionsRemover.java\n+++ b/src/com/google/javascript/jscomp/DefinitionsRemover.java\n           \"AST should be normalized first\");\n       Node parent = var.getParent();\n       Node rValue = name.removeFirstChild();\n-      Preconditions.checkState(parent.getType() != Token.FOR);\n+      Preconditions.checkState(!parent.isFor());\n       parent.replaceChild(var, NodeUtil.newExpr(rValue));\n     }\n \n--- a/src/com/google/javascript/jscomp/ExportTestFunctions.java\n+++ b/src/com/google/javascript/jscomp/ExportTestFunctions.java\n           }\n         }\n       } else if (NodeUtil.isExprAssign(parent) &&\n-            n.getLastChild().getType() != Token.ASSIGN) {\n+            !n.getLastChild().isAssign()) {\n         // Check for a test method assignment.\n         Node grandparent = parent.getParent();\n         if (grandparent != null && grandparent.isScript()) {\n      * @param node\n      */\n     private boolean isVarDeclaredFunction(Node node) {\n-      if (node.getType() != Token.VAR) {\n+      if (!node.isVar()) {\n         return false;\n       }\n       Node grandchild = node.getFirstChild().getFirstChild();\n--- a/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n+++ b/src/com/google/javascript/jscomp/ExpressionDecomposer.java\n       // Node extractedCall = extractExpression(decomposition, expressionRoot);\n     } else {\n       Node parent = nonconditionalExpr.getParent();\n-      boolean needResult = parent.getType() != Token.EXPR_RESULT;\n+      boolean needResult = !parent.isExprResult();\n       Node extractedConditional = extractConditional(\n           nonconditionalExpr, exprInjectionPoint, needResult);\n     }\n     //    t1.foo = t1.foo + 2;\n     if (isLhsOfAssignOp && NodeUtil.isGet(expr)) {\n       for (Node n : expr.children()) {\n-        if (n.getType() != Token.STRING && !isConstantName(n, knownConstants)) {\n+        if (!n.isString() && !isConstantName(n, knownConstants)) {\n           Node extractedNode = extractExpression(n, injectionPoint);\n           if (firstExtractedNode == null) {\n             firstExtractedNode = extractedNode;\n--- a/src/com/google/javascript/jscomp/ExternExportsPass.java\n+++ b/src/com/google/javascript/jscomp/ExternExportsPass.java\n             return null;\n       }\n \n-      if (definition.getType() != Token.FUNCTION) {\n+      if (!definition.isFunction()) {\n         return null;\n       }\n \n \n         // Only handle function calls. This avoids assignments\n         // that do not export items directly.\n-        if (parent.getType() != Token.CALL) {\n+        if (!parent.isCall()) {\n           return;\n         }\n \n \n     // Confirm the arguments are the expected types. If they are not,\n     // then we have an export that we cannot statically identify.\n-    if (nameArg.getType() != Token.STRING) {\n+    if (!nameArg.isString()) {\n       return;\n     }\n \n       return;\n     }\n \n-    if (nameArg.getType() != Token.STRING) {\n+    if (!nameArg.isString()) {\n       return;\n     }\n \n--- a/src/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarations.java\n+++ b/src/com/google/javascript/jscomp/ExtractPrototypeMemberDeclarations.java\n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n \n-      if (n.getType() != Token.SCRIPT && n.getType() != Token.BLOCK) {\n+      if (!n.isScript() && !n.isBlock()) {\n         return;\n       }\n \n--- a/src/com/google/javascript/jscomp/FindExportableNodes.java\n+++ b/src/com/google/javascript/jscomp/FindExportableNodes.java\n           Node grandparent = parent.getParent();\n           if (grandparent != null && grandparent.isScript() &&\n               parent.isExprResult() &&\n-              n.getLastChild().getType() != Token.ASSIGN) {\n+              !n.getLastChild().isAssign()) {\n             export = n.getFirstChild().getQualifiedName();\n             context = new GenerateNodeContext(n, grandparent, parent);\n           }\n         case Token.VAR:\n           if (parent.isScript()) {\n             if (n.getFirstChild().hasChildren() &&\n-                n.getFirstChild().getFirstChild().getType() != Token.ASSIGN) {\n+                !n.getFirstChild().getFirstChild().isAssign()) {\n               export = n.getFirstChild().getString();\n               context = new GenerateNodeContext(n, parent, n);\n             }\n--- a/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionArgumentInjector.java\n       Node replacementTemplate = replacements.get(node.getString());\n       if (replacementTemplate != null) {\n         // This should not be replacing declared names.\n-        Preconditions.checkState(parent.getType() != Token.FUNCTION\n-            || parent.getType() != Token.VAR\n-            || parent.getType() != Token.CATCH);\n+        Preconditions.checkState(!parent.isFunction()\n+            || !parent.isVar()\n+            || !parent.isCatch());\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n     } else if (replaceThis && node.isThis()) {\n       Node replacementTemplate = replacements.get(THIS_MARKER);\n       Preconditions.checkNotNull(replacementTemplate);\n-      if (replacementTemplate.getType() != Token.THIS) {\n+      if (!replacementTemplate.isThis()) {\n         // The name may need to be replaced more than once,\n         // so we need to clone the node.\n         Node replacement = replacementTemplate.cloneTree();\n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n    * @return Whether the call is of a type that is supported.\n    */\n   private boolean isSupportedCallType(Node callNode) {\n-    if (callNode.getFirstChild().getType() != Token.NAME) {\n+    if (!callNode.getFirstChild().isName()) {\n       if (NodeUtil.isFunctionObjectCall(callNode)) {\n         if (!assumeStrictThis) {\n           Node thisValue = callNode.getFirstChild().getNext();\n-          if (thisValue == null || thisValue.getType() != Token.THIS) {\n+          if (thisValue == null || !thisValue.isThis()) {\n             return false;\n           }\n         }\n     // Functions called via 'call' and 'apply' have a this-object as\n     // the first parameter, but this is not part of the called function's\n     // parameter list.\n-    if (callNode.getFirstChild().getType() != Token.NAME) {\n+    if (!callNode.getFirstChild().isName()) {\n       if (NodeUtil.isFunctionObjectCall(callNode)) {\n         // TODO(johnlenz): Support replace this with a value.\n-        if (cArg == null || cArg.getType() != Token.THIS) {\n+        if (cArg == null || !cArg.isThis()) {\n           return CanInlineResult.NO;\n         }\n         cArg = cArg.getNext();\n--- a/src/com/google/javascript/jscomp/FunctionRewriter.java\n+++ b/src/com/google/javascript/jscomp/FunctionRewriter.java\n \n       Node propName = getGetPropertyName(node);\n       if (propName != null) {\n-        if (propName.getType() != Token.STRING) {\n+        if (!propName.isString()) {\n           throw new IllegalStateException(\n               \"Expected STRING, got \" + Token.name(propName.getType()));\n         }\n \n       Node propName = getSetPropertyName(node);\n       if (propName != null) {\n-        if (propName.getType() != Token.STRING) {\n+        if (!propName.isString()) {\n           throw new IllegalStateException(\n               \"Expected STRING, got \" + Token.name(propName.getType()));\n         }\n--- a/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\n+++ b/src/com/google/javascript/jscomp/FunctionToBlockMutator.java\n             // has side effects.\n \n             Node value = entry.getValue();\n-            if (value.getType() != Token.THIS\n+            if (!value.isThis()\n                 && (referencesThis\n                     || NodeUtil.mayHaveSideEffects(value, compiler))) {\n               String newName = getUniqueThisName();\n--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n           //   NAME (gramps)\n           //     OBJLIT (parent)\n           //       STRING (n)\n-          if (greatGramps == null ||\n-              greatGramps.getType() != Token.VAR) {\n+          if (greatGramps == null || !greatGramps.isVar()) {\n             return null;\n           }\n           name = gramps.getString();\n--- a/src/com/google/javascript/jscomp/GlobalVarReferenceMap.java\n+++ b/src/com/google/javascript/jscomp/GlobalVarReferenceMap.java\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.InputId;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n    */\n   void updateGlobalVarReferences(Map<Var, ReferenceCollection>\n       refMapPatch, Node root) {\n-    if (refMap == null || root.getType() != Token.SCRIPT) {\n+    if (refMap == null || !root.isScript()) {\n       resetGlobalVarReferences(refMapPatch);\n       return;\n     }\n--- a/src/com/google/javascript/jscomp/InferJSDocInfo.java\n+++ b/src/com/google/javascript/jscomp/InferJSDocInfo.java\n         }\n \n         // Only allow JSDoc on VARs, function declarations, and assigns.\n-        if (parent.getType() != Token.VAR &&\n+        if (!parent.isVar() &&\n             !NodeUtil.isFunctionDeclaration(parent) &&\n             !(parent.isAssign() &&\n               n == parent.getFirstChild())) {\n--- a/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n+++ b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n         }\n \n         // We're looking for object literal assignments only.\n-        if (val.getType() != Token.OBJECTLIT) {\n+        if (!val.isObjectLit()) {\n           return false;\n         }\n \n--- a/src/com/google/javascript/jscomp/InlineSimpleMethods.java\n+++ b/src/com/google/javascript/jscomp/InlineSimpleMethods.java\n    * and for which the right side is a string.\n    */\n   private static boolean isPropertyTree(Node expectedGetprop) {\n-    if (expectedGetprop.getType() != Token.GETPROP) {\n+    if (!expectedGetprop.isGetProp()) {\n       return false;\n     }\n \n     Node leftChild = expectedGetprop.getFirstChild();\n-    if (leftChild.getType() != Token.THIS &&\n+    if (!leftChild.isThis() &&\n         !isPropertyTree(leftChild)) {\n       return false;\n     }\n     }\n \n     Node expectedReturn = expectedBlock.getFirstChild();\n-    if (expectedReturn.getType() != Token.RETURN) {\n+    if (!expectedReturn.isReturn()) {\n       return null;\n     }\n \n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceMap;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n       }\n \n       // Determine if we should really inline a String or not.\n-      return value.getType() != Token.STRING ||\n+      return !value.isString() ||\n           isStringWorthInlining(var, refInfo.references);\n     }\n \n       // VAR declarations and EXPR_RESULT don't need the value, but other\n       // ASSIGN expressions parents do.\n       if (declaration != initialization &&\n-          initialization.getGrandparent().getType() != Token.EXPR_RESULT) {\n+          !initialization.getGrandparent().isExprResult()) {\n         return false;\n       }\n \n      */\n     private boolean isValidDeclaration(Reference declaration) {\n       return (declaration.getParent().isVar()\n-          && declaration.getGrandparent().getType() != Token.FOR)\n+          && !declaration.getGrandparent().isFor())\n           || NodeUtil.isFunctionDeclaration(declaration.getParent());\n     }\n \n \n         boolean isImmutableValueWorthInlining =\n             NodeUtil.isImmutableValue(value) &&\n-            (value.getType() != Token.STRING ||\n+            (!value.isString() ||\n                 isStringWorthInlining(v, refInfo.references));\n         boolean isInlinableThisAlias =\n             value.isThis() &&\n--- a/src/com/google/javascript/jscomp/InstrumentFunctions.java\n+++ b/src/com/google/javascript/jscomp/InstrumentFunctions.java\n \n     @Override\n     public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-      return n.getType() != Token.FUNCTION;\n+      return !n.isFunction();\n     }\n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() != Token.RETURN) {\n+      if (!n.isReturn()) {\n         return;\n       }\n \n       for (DiGraphNode<Node, Branch> pred :\n         cfg.getDirectedPredNodes(returnPathsParent)) {\n         Node n = pred.getValue();\n-        if (n.getType() != Token.RETURN) {\n+        if (!n.isReturn()) {\n           return false;\n         }\n       }\n   private class InstrumentCallback extends AbstractPostOrderCallback {\n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() != Token.FUNCTION) {\n+      if (!n.isFunction()) {\n         return;\n       }\n \n--- a/src/com/google/javascript/jscomp/InvocationsCallback.java\n+++ b/src/com/google/javascript/jscomp/InvocationsCallback.java\n \n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n \n /**\n  * Traversal callback that finds method invocations of the form\n \n   @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() != Token.CALL) {\n+    if (!n.isCall()) {\n       return;\n     }\n \n     Node function = n.getFirstChild();\n \n-    if (function.getType() != Token.GETPROP) {\n+    if (!function.isGetProp()) {\n       return;\n     }\n \n     Node nameNode = function.getFirstChild().getNext();\n \n     // Don't care about numerical or variable indexes\n-    if (nameNode.getType() != Token.STRING) {\n+    if (!nameNode.isString()) {\n       return;\n     }\n \n--- a/src/com/google/javascript/jscomp/JsMessageVisitor.java\n+++ b/src/com/google/javascript/jscomp/JsMessageVisitor.java\n         isVar = false;\n \n         Node getProp = node.getFirstChild();\n-        if (getProp.getType() != Token.GETPROP) {\n+        if (!getProp.isGetProp()) {\n           return;\n         }\n \n         case Token.BLOCK:\n           // Build the message's value by examining the return statement\n           Node returnNode = fnChild.getFirstChild();\n-          if (returnNode.getType() != Token.RETURN) {\n+          if (!returnNode.isReturn()) {\n             throw new MalformedException(\"RETURN node expected; found: \"\n                 + getReadableTokenName(returnNode), returnNode);\n           }\n   private void extractFromCallNode(Builder builder,\n       Node node) throws MalformedException {\n     // Check the function being called\n-    if (node.getType() != Token.CALL) {\n+    if (!node.isCall()) {\n       throw new MalformedException(\n           \"Message must be initialized using \" + MSG_FUNCTION_NAME +\n           \" function.\", node);\n     Set<String> phNames = Sets.newHashSet();\n     if (objLitNode != null) {\n       // Register the placeholder names\n-      if (objLitNode.getType() != Token.OBJECTLIT) {\n+      if (!objLitNode.isObjectLit()) {\n         throw new MalformedException(\"OBJLIT node expected\", objLitNode);\n       }\n       for (Node aNode = objLitNode.getFirstChild(); aNode != null;\n            aNode = aNode.getNext()) {\n-        if (aNode.getType() != Token.STRING) {\n+        if (!aNode.isString()) {\n           throw new MalformedException(\"STRING node expected as OBJLIT key\",\n               aNode);\n         }\n--- a/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java\n+++ b/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java\n   }\n \n   private boolean isArgumentsName(Node n) {\n-    if (n.getType() != Token.NAME ||\n+    if (!n.isName()||\n         !n.getString().equals(ARGUMENT_ARRAY_ALIAS) ||\n         jsScope.isDeclared(ARGUMENT_ARRAY_ALIAS, false)) {\n       return false;\n--- a/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\n+++ b/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java\n       // If the contextual renamer is being used the starting context can not\n       // be a function.\n       Preconditions.checkState(\n-          declarationRoot.getType() != Token.FUNCTION ||\n+          !declarationRoot.isFunction() ||\n           !(rootRenamer instanceof ContextualRenamer));\n       Preconditions.checkState(t.inGlobalScope());\n       renamer = rootRenamer;\n       renamer = nameStack.peek().forChildScope();\n     }\n \n-    if (declarationRoot.getType() != Token.FUNCTION) {\n+    if (!declarationRoot.isFunction()) {\n       // Add the block declarations\n       findDeclaredNames(declarationRoot, null, renamer);\n     }\n     // Do a shallow traversal, so don't traverse into function declarations,\n     // except for the name of the function itself.\n     if (parent == null\n-        || parent.getType() != Token.FUNCTION\n+        || !parent.isFunction()\n         || n == parent.getFirstChild()) {\n       if (NodeUtil.isVarDeclaration(n)) {\n         renamer.addDeclaredName(n.getString());\n--- a/src/com/google/javascript/jscomp/MethodCompilerPass.java\n+++ b/src/com/google/javascript/jscomp/MethodCompilerPass.java\n         case Token.GETELEM: {\n           Node dest = n.getFirstChild().getNext();\n \n-          if (dest.getType() != Token.STRING) {\n+          if (!dest.isString()) {\n             return;\n           }\n \n--- a/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n+++ b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n     // TODO(johnlenz): The last case of SWITCH statement?\n \n     // The rest assumes a block with at least one child, bail on anything else.\n-    if (n.getType() != Token.BLOCK || n.getLastChild() == null) {\n+    if (!n.isBlock() || n.getLastChild() == null) {\n       return;\n     }\n \n--- a/src/com/google/javascript/jscomp/MoveFunctionDeclarations.java\n+++ b/src/com/google/javascript/jscomp/MoveFunctionDeclarations.java\n import com.google.common.collect.Maps;\n import com.google.javascript.jscomp.NodeTraversal.Callback;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n   @Override\n   public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n     Node gramps = n.getAncestor(2);\n-    return gramps == null || gramps.getType() != Token.SCRIPT;\n+    return gramps == null || !gramps.isScript();\n   }\n \n   @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (parent == null ||\n-        parent.getType() != Token.SCRIPT) {\n+    if (parent == null || !parent.isScript()) {\n       return;\n     }\n \n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n       newReplacements.add(valueExpr);\n       changeProxy.replaceWith(\n           parent, n, collapseReplacements(newReplacements));\n-    } else if (n.isAssign() && parent.getType() != Token.FOR) {\n+    } else if (n.isAssign() && !parent.isFor()) {\n       // assignment appears in a RHS expression.  we have already\n       // considered names in the assignment's RHS as being referenced;\n       // replace the assignment with its RHS.\n--- a/src/com/google/javascript/jscomp/NodeTraversal.java\n+++ b/src/com/google/javascript/jscomp/NodeTraversal.java\n         Node parent) {\n       // We do want to traverse the name of a named function, but we don't\n       // want to traverse the arguments or body.\n-      return parent == null || parent.getType() != Token.FUNCTION ||\n+      return parent == null || !parent.isFunction() ||\n           n == parent.getFirstChild();\n     }\n   }\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n                 insertBeforeParent.addChildBefore(newStatement, insertBefore);\n                 reportCodeChange(\"FOR-IN var declaration\");\n               }\n-            } else if (c.getFirstChild().getType() != Token.EMPTY) {\n+            } else if (!c.getFirstChild().isEmpty()) {\n               Node init = c.getFirstChild();\n               Node empty = new Node(Token.EMPTY);\n               empty.copyInformationFrom(c);\n--- a/src/com/google/javascript/jscomp/ObjectPropertyStringPostprocess.java\n+++ b/src/com/google/javascript/jscomp/ObjectPropertyStringPostprocess.java\n   private class Callback extends AbstractPostOrderCallback {\n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() != Token.NEW) {\n+      if (!n.isNew()) {\n         return;\n       }\n \n--- a/src/com/google/javascript/jscomp/ObjectPropertyStringPreprocess.java\n+++ b/src/com/google/javascript/jscomp/ObjectPropertyStringPreprocess.java\n \n   private void addExternDeclaration(Node externs, Node declarationStmt) {\n     Node script = externs.getLastChild();\n-    if (script == null || script.getType() != Token.SCRIPT) {\n+    if (script == null || !script.isScript()) {\n       script = new Node(Token.SCRIPT);\n       script.setIsSyntheticBlock(true);\n       externs.addChildToBack(script);\n       // Rewrite \"new goog.testing.ObjectPropertyString(foo, 'bar')\" to\n       // \"new goog.testing.ObjectPropertyString(window, foo.bar)\" and\n       // issues errors if bad arguments are encountered.\n-      if (n.getType() != Token.NEW) {\n+      if (!n.isNew()) {\n         return;\n       }\n \n       }\n \n       Node secondArgument = firstArgument.getNext();\n-      if (secondArgument.getType() != Token.STRING) {\n+      if (!secondArgument.isString()) {\n         compiler.report(t.makeError(secondArgument,\n             STRING_LITERAL_EXPECTED_ERROR,\n             Token.name(secondArgument.getType())));\n--- a/src/com/google/javascript/jscomp/OptimizeArgumentsArray.java\n+++ b/src/com/google/javascript/jscomp/OptimizeArgumentsArray.java\n       // Bail on anything but argument[c] access where c is a constant.\n       // TODO(user): We might not need to bail out all the time, there might\n       // be more cases that we can cover.\n-      if (getElem.getType() != Token.GETELEM) {\n+      if (!getElem.isGetElem()) {\n         return false;\n       }\n \n \n       // We have something like arguments[x] where x is not a constant. That\n       // means at least one of the access is not known.\n-      if (index.getType() != Token.NUMBER) {\n+      if (!index.isNumber()) {\n         // TODO(user): Its possible not to give up just yet. The type\n         // inference did a 'semi value propagation'. If we know that string\n         // is never a subclass of the type of the index. We'd know that\n       Node index = ref.getNext();\n \n       // Skip if it is unknown.\n-      if (index.getType() != Token.NUMBER) {\n+      if (!index.isNumber()) {\n         continue;\n       }\n       int value = (int) index.getDouble();\n--- a/src/com/google/javascript/jscomp/PeepholeCollectPropertyAssignments.java\n+++ b/src/com/google/javascript/jscomp/PeepholeCollectPropertyAssignments.java\n \n   @Override\n   Node optimizeSubtree(Node subtree) {\n-    if (subtree.getType() != Token.SCRIPT\n-        && subtree.getType() != Token.BLOCK) {\n+    if (!subtree.isScript() && !subtree.isBlock()) {\n       return subtree;\n     }\n \n     // and start processing there.\n     for (Node child = subtree.getFirstChild();\n          child != null; child = child.getNext()) {\n-      if (child.getType() != Token.VAR && !NodeUtil.isExprAssign(child)) {\n+      if (!child.isVar() && !NodeUtil.isExprAssign(child)) {\n         continue;\n       }\n       if (!isPropertyAssignmentToName(child.getNext())) {\n \n       Preconditions.checkState(child.hasOneChild());\n       Node name = getName(child);\n-      if (name.getType() != Token.NAME) {\n+      if (!name.isName()) {\n         // The assignment target is not a simple name.\n         continue;\n       }\n \n     // to a property...\n     Node lhs = expr.getFirstChild();\n-    if (lhs.getType() != Token.GETELEM && lhs.getType() != Token.GETPROP) {\n+    if (!NodeUtil.isGet(lhs)) {\n       return false;\n     }\n \n     // of a variable.\n     Node obj = lhs.getFirstChild();\n-    if (obj.getType() != Token.NAME) {\n+    if (!obj.isName()) {\n       return false;\n     }\n \n \n     Node lhs = assignment.getFirstChild();\n     Node rhs = lhs.getNext();\n-    if (lhs.getType() != Token.GETELEM) {\n+    if (!lhs.isGetElem()) {\n       return false;\n     }\n     Node obj = lhs.getFirstChild();\n     Node property = obj.getNext();\n     // The left hand side must have a numeric index\n-    if (property.getType() != Token.NUMBER) {\n+    if (!property.isNumber()) {\n       return false;\n     }\n     // that is a valid array index\n     } else {\n       // An out of order assignment.  Allow it if it's a hole.\n       Node currentValue = arrayLiteral.getChildAtIndex(index);\n-      if (currentValue.getType() != Token.EMPTY) {\n+      if (!currentValue.isEmpty()) {\n         // We've already collected a value for this index.\n         return false;\n       }\n \n     // The property must be statically known.\n     if (lhs.isGetElem()\n-        && (property.getType() != Token.STRING\n-            && property.getType() != Token.NUMBER)) {\n+        && (!property.isString()\n+            && !property.isNumber())) {\n       return false;\n     }\n \n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n \n   private Node tryReduceVoid(Node n) {\n     Node child = n.getFirstChild();\n-    if (child.getType() != Token.NUMBER || child.getDouble() != 0.0) {\n+    if (!child.isNumber() || child.getDouble() != 0.0) {\n       if (!mayHaveSideEffects(n)) {\n         n.replaceChild(child, Node.newNumber(0));\n         reportCodeChange();\n         || n.isAdd());\n \n     Preconditions.checkState(\n-        n.getType() != Token.ADD || !NodeUtil.mayBeString(n));\n+        !n.isAdd()|| !NodeUtil.mayBeString(n));\n \n     // Use getNumberValue to handle constants like \"NaN\" and \"Infinity\"\n     // other values are converted to numbers elsewhere.\n         break;\n \n       case Token.THIS:\n-        if (right.getType() != Token.THIS) {\n+        if (!right.isThis()) {\n           return n;\n         }\n         switch (op) {\n     Preconditions.checkArgument(n.isNew());\n \n     Node objectType = n.getFirstChild();\n-    if (objectType.getType() != Token.NAME) {\n+    if (!objectType.isName()) {\n       return n;\n     }\n \n       return n;\n     }\n \n-    if (right.getType() != Token.NUMBER) {\n+    if (!right.isNumber()) {\n       // Sometimes people like to use complex expressions to index into\n       // arrays, or strings to index into array methods.\n       return n;\n   private Node tryFoldObjectPropAccess(Node n, Node left, Node right) {\n     Preconditions.checkArgument(NodeUtil.isGet(n));\n \n-    if (left.getType() != Token.OBJECTLIT || right.getType() != Token.STRING) {\n+    if (!left.isObjectLit() || !right.isString()) {\n       return n;\n     }\n \n--- a/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n+++ b/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n     Node cond = init.getNext();\n     Node increment = cond.getNext();\n \n-    if (init.getType() != Token.EMPTY && init.getType() != Token.VAR) {\n+    if (!init.isEmpty() && !init.isVar()) {\n       init = trySimplifyUnusedResult(init, false);\n     }\n \n-    if (increment.getType() != Token.EMPTY) {\n+    if (!increment.isEmpty()) {\n       increment = trySimplifyUnusedResult(increment, false);\n     }\n \n     // There is an initializer skip it\n-    if (n.getFirstChild().getType() != Token.EMPTY) {\n+    if (!n.getFirstChild().isEmpty()) {\n       return n;\n     }\n \n--- a/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java\n+++ b/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java\n     Node stringNode = callTarget.getFirstChild();\n     Node functionName = stringNode.getNext();\n \n-    if ((stringNode.getType() != Token.STRING) ||\n-        (functionName.getType() != Token.STRING)) {\n+    if ((!stringNode.isString()) ||\n+        (!functionName.isString())) {\n       return subtree;\n     }\n \n       }\n \n       // Third-argument and non-numeric second arg are problematic. Discard.\n-      if ((secondArg.getNext() != null) ||\n-          (secondArg.getType() != Token.NUMBER)) {\n+      if (secondArg.getNext() != null || !secondArg.isNumber()) {\n         return n;\n       } else {\n         double tmpRadix = secondArg.getDouble();\n     int fromIndex = isIndexOf ? 0 : lstring.length();\n     if (secondArg != null) {\n       // Third-argument and non-numeric second arg are problematic. Discard.\n-      if ((secondArg.getNext() != null) ||\n-          (secondArg.getType() != Token.NUMBER)) {\n+      if (secondArg.getNext() != null || !secondArg.isNumber()) {\n         return n;\n       } else {\n         fromIndex = (int) secondArg.getDouble();\n     Node arrayNode = callTarget.getFirstChild();\n     Node functionName = arrayNode.getNext();\n \n-    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n+    if (!arrayNode.isArrayLit() ||\n         !functionName.getString().equals(\"join\")) {\n       return n;\n     }\n           return n;\n         }\n         arrayNode.detachChildren();\n-        if (foldedStringNode.getType() != Token.STRING) {\n+        if (!foldedStringNode.isString()) {\n           // If the Node is not a string literal, ensure that\n           // it is coerced to a string.\n           Node replacement = new Node(Token.ADD,\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n       = new Predicate<Node>() {\n     @Override\n     public boolean apply(Node input) {\n-      return input.getType() != Token.FUNCTION;\n+      return !input.isFunction();\n     }\n   };\n \n \n       case Token.NEW:\n         node = tryFoldStandardConstructors(node);\n-        if (node.getType() != Token.CALL) {\n+        if (!node.isCall()) {\n           return node;\n         }\n         // Fall through on purpose because tryFoldStandardConstructors() may\n     Node right = n.getLastChild();\n \n     if (parent.isExprResult()\n-        && parent.getParent().getType() != Token.LABEL) {\n+        && !parent.getParent().isLabel()) {\n       // split comma\n       n.detachChildren();\n       // Replace the original expression with the left operand.\n               // Check special case when such transformation cannot reduce\n               // due to the added ()\n               // It only occurs when both of expressions are not NOT expressions\n-              if (leftParent.getType() != Token.NOT\n-                  && rightParent.getType() != Token.NOT) {\n+              if (!leftParent.isNot()\n+                  && !rightParent.isNot()) {\n                 // If an expression has higher precendence than && or ||,\n                 // but lower precedence than NOT, an additional () is needed\n                 // Thus we do not preceed\n   private Node tryMinimizeArrayLiteral(Node n) {\n     boolean allStrings = true;\n     for (Node cur = n.getFirstChild(); cur != null; cur = cur.getNext()) {\n-      if (cur.getType() != Token.STRING) {\n+      if (!cur.isString()) {\n         allStrings = false;\n       }\n     }\n--- a/src/com/google/javascript/jscomp/PrepareAst.java\n+++ b/src/com/google/javascript/jscomp/PrepareAst.java\n    */\n   private void normalizeBlocks(Node n) {\n     if (NodeUtil.isControlStructure(n)\n-        && n.getType() != Token.LABEL\n-        && n.getType() != Token.SWITCH) {\n+        && !n.isLabel()\n+        && !n.isSwitch()) {\n       for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n         if (NodeUtil.isControlStructureCodeBlock(n,c) &&\n-            c.getType() != Token.BLOCK) {\n+            !c.isBlock()) {\n           Node newBlock = new Node(Token.BLOCK, n.getLineno(), n.getCharno());\n           newBlock.copyInformationFrom(n);\n           n.replaceChild(c, newBlock);\n-          if (c.getType() != Token.EMPTY) {\n+          if (!c.isEmpty()) {\n             newBlock.addChildrenToFront(c);\n           } else {\n             newBlock.setWasEmptyNode(true);\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n \n       case Token.GETPROP:\n         if (n.getFirstChild().isName() &&\n-            parent.getType() != Token.CALL &&\n-            parent.getType() != Token.ASSIGN &&\n+            !parent.isCall() &&\n+            !parent.isAssign() &&\n             \"goog.base\".equals(n.getQualifiedName())) {\n           reportBadBaseClassUse(t, n, \"May only be called directly.\");\n         }\n \n     Node callee = n.getFirstChild();\n     Node thisArg = callee.getNext();\n-    if (thisArg == null || thisArg.getType() != Token.THIS) {\n+    if (thisArg == null || !thisArg.isThis()) {\n       reportBadBaseClassUse(t, n, \"First argument must be 'this'.\");\n       return;\n     }\n     } else {\n       // Handle methods.\n       Node methodNameNode = thisArg.getNext();\n-      if (methodNameNode == null || methodNameNode.getType() != Token.STRING) {\n+      if (methodNameNode == null || !methodNameNode.isString()) {\n         reportBadBaseClassUse(t, n, \"Second argument must name a method.\");\n         return;\n       }\n       for (Node key = arg.getFirstChild(); key != null;\n           key = key.getNext()) {\n         Node value = key.getFirstChild();\n-        if (key.getType() != Token.STRING\n+        if (!key.isString()\n             || value == null\n-            || value.getType() != Token.STRING) {\n+            || !value.isString()) {\n           compiler.report(\n               t.makeError(n,\n                   NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR));\n     DiagnosticType diagnostic = null;\n     if (firstArg == null) {\n       diagnostic = NULL_ARGUMENT_ERROR;\n-    } else if (firstArg.getType() != Token.OBJECTLIT) {\n+    } else if (!firstArg.isObjectLit()) {\n       diagnostic = EXPECTED_OBJECTLIT_ERROR;\n     } else if (firstArg.getNext() != null) {\n       Node secondArg = firstArg.getNext();\n-      if (secondArg.getType() != Token.STRING) {\n+      if (!secondArg.isString()) {\n         diagnostic = EXPECTED_STRING_ERROR;\n       } else if (secondArg.getNext() != null) {\n         diagnostic = TOO_MANY_ARGUMENTS_ERROR;\n--- a/src/com/google/javascript/jscomp/ProcessTweaks.java\n+++ b/src/com/google/javascript/jscomp/ProcessTweaks.java\n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() != Token.CALL) {\n+      if (!n.isCall()) {\n         return;\n       }\n \n \n       // Ensure the first parameter (the tweak ID) is a string literal.\n       Node tweakIdNode = n.getFirstChild().getNext();\n-      if (tweakIdNode.getType() != Token.STRING) {\n+      if (!tweakIdNode.isString()) {\n         compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n         return;\n       }\n--- a/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n+++ b/src/com/google/javascript/jscomp/PureFunctionIdentifier.java\n       }\n \n       if (!NodeUtil.nodeTypeMayHaveSideEffects(node)\n-          && node.getType() != Token.RETURN) {\n+          && !node.isReturn()) {\n         return;\n       }\n \n       if (callee.mutatesThis()) {\n         // Side effects only propagate via regular calls.\n         // Calling a constructor that modifies \"this\" has no side effects.\n-        if (callSite.getType() != Token.NEW) {\n+        if (!callSite.isNew()) {\n           Node objectNode = getCallThisObject(callSite);\n           if (objectNode != null && objectNode.isName()\n               && !isCallOrApply(callSite)) {\n--- a/src/com/google/javascript/jscomp/RecordFunctionInformation.java\n+++ b/src/com/google/javascript/jscomp/RecordFunctionInformation.java\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import java.util.Comparator;\n import java.util.TreeSet;\n \n \n   @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() != Token.FUNCTION) {\n+    if (!n.isFunction()) {\n       return;\n     }\n \n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n       // VAR is the only type of variable declaration that may not initialize\n       // its variable. Catch blocks, named functions, and parameters all do.\n       return isDeclaration() &&\n-          getParent().getType() != Token.VAR ||\n+          !getParent().isVar() ||\n           nameNode.getFirstChild() != null;\n     }\n \n--- a/src/com/google/javascript/jscomp/RemoveTryCatch.java\n+++ b/src/com/google/javascript/jscomp/RemoveTryCatch.java\n         case Token.RETURN:\n           boolean isInTryBlock = false;\n           for (Node anc = parent;\n-               anc != null && anc.getType() != Token.FUNCTION;\n+               anc != null && !anc.isFunction();\n                anc = anc.getParent()) {\n             if (anc.isTry()) {\n               tryNodesContainingReturnStatements.add(anc);\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n             } else {\n               // replace the node in the arg with 0\n               if (!NodeUtil.mayHaveSideEffects(arg, compiler)\n-                  && (arg.getType() != Token.NUMBER || arg.getDouble() != 0)) {\n+                  && (!arg.isNumber() || arg.getDouble() != 0)) {\n                 toReplaceWithZero.add(arg);\n               }\n             }\n       this.isPropertyAssign = isPropertyAssign;\n \n       this.mayHaveSecondarySideEffects =\n-          assignNode.getParent().getType() != Token.EXPR_RESULT ||\n+          !assignNode.getParent().isExprResult() ||\n           NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) ||\n           NodeUtil.mayHaveSideEffects(assignNode.getLastChild());\n     }\n \n         // Aggregate any expressions in GETELEMs.\n         for (Node current = assignNode.getFirstChild();\n-             current.getType() != Token.NAME;\n+             !current.isName();\n              current = current.getFirstChild()) {\n           if (current.isGetElem()) {\n             replacement = new Node(Token.COMMA,\n--- a/src/com/google/javascript/jscomp/RenameProperties.java\n+++ b/src/com/google/javascript/jscomp/RenameProperties.java\n      */\n     private void countCallCandidates(NodeTraversal t, Node callNode) {\n       Node firstArg = callNode.getFirstChild().getNext();\n-      if (firstArg.getType() != Token.STRING) {\n+      if (!firstArg.isString()) {\n         t.report(callNode, BAD_CALL);\n         return;\n       }\n--- a/src/com/google/javascript/jscomp/RenameVars.java\n+++ b/src/com/google/javascript/jscomp/RenameVars.java\n import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n import com.google.javascript.jscomp.Scope.Var;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import java.util.ArrayList;\n import java.util.Comparator;\n import java.util.HashMap;\n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() != Token.NAME) {\n+      if (!n.isName()) {\n         return;\n       }\n \n--- a/src/com/google/javascript/jscomp/ReplaceCssNames.java\n+++ b/src/com/google/javascript/jscomp/ReplaceCssNames.java\n \n             Node second = first.getNext();\n \n-            if (second.getType() != Token.STRING) {\n+            if (!second.isString()) {\n               compiler.report(t.makeError(n, STRING_LITERAL_EXPECTED_ERROR,\n                   Token.name(second.getType())));\n             } else if (first.isString()) {\n--- a/src/com/google/javascript/jscomp/ReplaceIdGenerators.java\n+++ b/src/com/google/javascript/jscomp/ReplaceIdGenerators.java\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n-\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n   private class ReplaceGenerators extends AbstractPostOrderCallback {\n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() != Token.CALL) {\n+      if (!n.isCall()) {\n         return;\n       }\n \n--- a/src/com/google/javascript/jscomp/RescopeGlobalSymbols.java\n+++ b/src/com/google/javascript/jscomp/RescopeGlobalSymbols.java\n   private class RewriteScopeCallback extends AbstractPostOrderCallback {\n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() != Token.NAME) {\n+      if (!n.isName()) {\n         return;\n       }\n       String name = n.getString();\n       AbstractShallowStatementCallback {\n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() != Token.VAR) {\n+      if (!n.isVar()) {\n         return;\n       }\n       List<Node> commas = new ArrayList<Node>();\n--- a/src/com/google/javascript/jscomp/RuntimeTypeCheck.java\n+++ b/src/com/google/javascript/jscomp/RuntimeTypeCheck.java\n     }\n \n     private Node findEnclosingConstructorDeclaration(Node n) {\n-      while (n.getParent().getType() != Token.SCRIPT &&\n-          n.getParent().getType() != Token.BLOCK) {\n+      while (!n.getParent().isScript() && !n.getParent().isBlock()) {\n         n = n.getParent();\n       }\n       return n;\n--- a/src/com/google/javascript/jscomp/SideEffectsAnalysis.java\n+++ b/src/com/google/javascript/jscomp/SideEffectsAnalysis.java\n         // or an increment/decrement\n \n         boolean nonSimpleAssign =\n-          NodeUtil.isAssignmentOp(parent) && parent.getType() != Token.ASSIGN;\n+          NodeUtil.isAssignmentOp(parent) && !parent.isAssign();\n \n         return (nonSimpleAssign\n             || parent.isDec()\n--- a/src/com/google/javascript/jscomp/StatementFusion.java\n+++ b/src/com/google/javascript/jscomp/StatementFusion.java\n \n   private static boolean canFuseIntoOneStatement(Node block) {\n     // Fold only statement block. NOT scripts block.\n-    if (block.getType() != Token.BLOCK) {\n+    if (!block.isBlock()) {\n       return false;\n     }\n \n--- a/src/com/google/javascript/jscomp/StrictModeCheck.java\n+++ b/src/com/google/javascript/jscomp/StrictModeCheck.java\n       if (!noCajaChecks && key.getString().endsWith(\"__\")) {\n         t.report(key, ILLEGAL_NAME);\n       }\n-      if (key.getType() != Token.SETTER_DEF) {\n+      if (!key.isSetterDef()) {\n         // normal property and getter cases\n         if (getters.contains(key.getString())) {\n           t.report(key, DUPLICATE_OBJECT_KEY);\n           getters.add(key.getString());\n         }\n       }\n-      if (key.getType() != Token.GETTER_DEF) {\n+      if (!key.isGetterDef()) {\n         // normal property and setter cases\n         if (setters.contains(key.getString())) {\n           t.report(key, DUPLICATE_OBJECT_KEY);\n--- a/src/com/google/javascript/jscomp/StripCode.java\n+++ b/src/com/google/javascript/jscomp/StripCode.java\n       //   ... (arguments)\n \n       Node function = n.getFirstChild();\n-      if (function == null || function.getType() != Token.GETPROP) {\n+      if (function == null || !function.isGetProp()) {\n         // We are only interested in calls on object references that are\n         // properties. We don't need to eliminate method calls on variables\n         // that are getting removed, since that's already done by the code\n--- a/src/com/google/javascript/jscomp/SymbolTable.java\n+++ b/src/com/google/javascript/jscomp/SymbolTable.java\n       return globalScope.getSlot(GLOBAL_THIS);\n     }\n \n-    if (rootNode.getType() != Token.FUNCTION) {\n+    if (!rootNode.isFunction()) {\n       return null;\n     }\n \n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n.getType() != Token.THIS) {\n+      if (!n.isThis()) {\n         return;\n       }\n \n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n       case Token.PARAM_LIST:\n         // If this is under a FUNCTION node, it is a parameter list and can be\n         // ignored here.\n-        if (parent.getType() != Token.FUNCTION) {\n+        if (!parent.isFunction()) {\n           ensureTyped(t, n, getJSType(n.getFirstChild()));\n         } else {\n           typeable = false;\n    */\n   private void ensureTyped(NodeTraversal t, Node n, JSType type) {\n     // Make sure FUNCTION nodes always get function type.\n-    Preconditions.checkState(n.getType() != Token.FUNCTION ||\n+    Preconditions.checkState(!n.isFunction() ||\n             type.isFunctionType() ||\n             type.isUnknownType());\n     JSDocInfo info = n.getJSDocInfo();\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n         scope = traverseCatch(n, scope);\n         break;\n     }\n-    if (n.getType() != Token.FUNCTION) {\n+    if (!n.isFunction()) {\n       JSDocInfo info = n.getJSDocInfo();\n       if (info != null && info.hasType()) {\n         JSType castType = info.getType().evaluate(syntacticScope, registry);\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n \n       // We do want to traverse the name of a named function, but we don't\n       // want to traverse the arguments or body.\n-      boolean descend = parent == null || parent.getType() != Token.FUNCTION ||\n+      boolean descend = parent == null || !parent.isFunction() ||\n           n == parent.getFirstChild() || parent == scope.getRootNode();\n \n       if (descend) {\n         // if the node is not a member expression, or\n         // if the member expression is not of the form: this.someProperty.\n         if (info == null ||\n-            member.getType() != Token.GETPROP ||\n-            member.getFirstChild().getType() != Token.THIS) {\n+            !member.isGetProp() ||\n+            !member.getFirstChild().isThis()) {\n           return;\n         }\n \n--- a/src/com/google/javascript/jscomp/VarCheck.java\n+++ b/src/com/google/javascript/jscomp/VarCheck.java\n \n   @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() != Token.NAME) {\n+    if (!n.isName()) {\n       return;\n     }\n \n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n     return this.getType() == Token.BLOCK;\n   }\n \n+  public boolean isBreak() {\n+    return this.getType() == Token.BREAK;\n+  }\n+\n   public boolean isCall() {\n     return this.getType() == Token.CALL;\n   }\n     return this.getType() == Token.COMMA;\n   }\n \n+  public boolean isContinue() {\n+    return this.getType() == Token.CONTINUE;\n+  }\n+\n   public boolean isDec() {\n     return this.getType() == Token.DEC;\n   }\n--- a/test/com/google/javascript/jscomp/CombinedCompilerPassTest.java\n+++ b/test/com/google/javascript/jscomp/CombinedCompilerPassTest.java\n \n     @Override\n     public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-      return n.getType() != Token.NAME || !ignoring.contains(n.getString());\n+      return !n.isName() || !ignoring.contains(n.getString());\n     }\n \n     Set<Node> getVisitedScopes() {\n--- a/test/com/google/javascript/jscomp/VarCheckTest.java\n+++ b/test/com/google/javascript/jscomp/VarCheckTest.java\n import com.google.common.collect.Lists;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.Token;\n \n \n public class VarCheckTest extends CompilerTestCase {\n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n           if (n.isName() && !parent.isFunction()\n-              && parent.getType() != Token.LABEL) {\n+              && !parent.isLabel()) {\n             assertTrue(\"Variable \" + n.getString() + \" should have be declared\",\n                 t.getScope().isDeclared(n.getString(), true));\n           }", "timestamp": 1321323210, "metainfo": ""}