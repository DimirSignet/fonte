{"sha": "af4b8d4a2da7996f15b405f523ee8b31a0fbf021", "log": "Make subtyping of Functions with this:SomeInterface more lenient  R=johnlenz DELTA=59  (55 added, 0 deleted, 4 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1207088   ", "commit": "\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n       // for aliasing constructors. Let's punt on all this for now.\n       // TODO(nicksantos): fix this.\n       FunctionType other = (FunctionType) that;\n-      return (this.isConstructor() || other.isConstructor() ||\n-              other.typeOfThis.isSubtype(this.typeOfThis) ||\n-              this.typeOfThis.isSubtype(other.typeOfThis)) &&\n-          this.call.isSubtype(other.call);\n+      boolean treatThisTypesAsCovariant =\n+        // If either one of these is a ctor, skip 'this' checking.\n+        this.isConstructor() || other.isConstructor() ||\n+\n+        // An interface 'this'-type is non-restrictive.\n+        // In practical terms, if C implements I, and I has a method m,\n+        // then any m doesn't necessarily have to C#m's 'this'\n+        // type doesn't need to match I.\n+        (other.typeOfThis.getConstructor() != null &&\n+             other.typeOfThis.getConstructor().isInterface()) ||\n+\n+        // If one of the 'this' types is covariant of the other,\n+        // then we'll treat them as covariant (see comment above).\n+        other.typeOfThis.isSubtype(this.typeOfThis) ||\n+        this.typeOfThis.isSubtype(other.typeOfThis);\n+      return treatThisTypesAsCovariant && this.call.isSubtype(other.call);\n     }\n \n     return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n           \"Parse error. Unknown type Super\",\n           \"property foo not defined on any superclass of Sub\"\n         });\n+  }\n+\n+  public void testInterfaceInheritanceCheck9() throws Exception {\n+    testTypes(\n+        \"/** @interface */ function I() {}\" +\n+        \"/** @return {number} */ I.prototype.bar = function() {};\" +\n+        \"/** @constructor */ function F() {}\" +\n+        \"/** @return {number} */ F.prototype.bar = function() {return 3; };\" +\n+        \"/** @return {number} */ F.prototype.foo = function() {return 3; };\" +\n+        \"/** @constructor \\n * @extends {F} \\n * @implements {I} */ \" +\n+        \"function G() {}\" +\n+        \"/** @return {string} */ function f() { return new G().bar(); }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testInterfaceInheritanceCheck10() throws Exception {\n+    testTypes(\n+        \"/** @interface */ function I() {}\" +\n+        \"/** @return {number} */ I.prototype.bar = function() {};\" +\n+        \"/** @constructor */ function F() {}\" +\n+        \"/** @return {number} */ F.prototype.foo = function() {return 3; };\" +\n+        \"/** @constructor \\n * @extends {F} \\n * @implements {I} */ \" +\n+        \"function G() {}\" +\n+        \"/** @return {number} \\n * @override */ G.prototype.bar = G.prototype.foo;\" +\n+        \"/** @return {string} */ function f() { return new G().bar(); }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n   }\n \n   public void testInterfacePropertyNotImplemented() throws Exception {\n--- a/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n         \"function (...[*]): None\", twoNumbers, oneNumber);\n   }\n \n+  public void testSubtypeWithInterfaceThisType() {\n+    FunctionType iface = registry.createInterfaceType(\"I\", null);\n+    FunctionType ifaceReturnBoolean = new FunctionBuilder(registry)\n+        .withParamsNode(registry.createParameters())\n+        .withTypeOfThis(iface.getInstanceType())\n+        .withReturnType(BOOLEAN_TYPE).build();\n+    FunctionType objReturnBoolean = new FunctionBuilder(registry)\n+        .withParamsNode(registry.createParameters())\n+        .withTypeOfThis(OBJECT_TYPE)\n+        .withReturnType(BOOLEAN_TYPE).build();\n+    assertTrue(objReturnBoolean.canAssignTo(ifaceReturnBoolean));\n+  }\n+\n   private void assertLeastSupertype(String s, JSType t1, JSType t2) {\n     assertEquals(s, t1.getLeastSupertype(t2).toString());\n     assertEquals(s, t2.getLeastSupertype(t1).toString());", "timestamp": 1289934199, "metainfo": ""}