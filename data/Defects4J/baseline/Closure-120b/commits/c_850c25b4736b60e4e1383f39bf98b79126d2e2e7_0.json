{"sha": "850c25b4736b60e4e1383f39bf98b79126d2e2e7", "log": "Add PeepholeMinimizeConditions pass.  This is split from the condition minimization logic in PeepholeSubstituteAlternateSyntax. ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=46298141", "commit": "\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n     protected CompilerPass create(AbstractCompiler compiler) {\n       final boolean late = false;\n       return new PeepholeOptimizationsPass(compiler,\n+            new PeepholeMinimizeConditions(late),\n             new PeepholeSubstituteAlternateSyntax(late),\n             new PeepholeReplaceKnownMethods(late),\n             new PeepholeRemoveDeadCode(),\n       return new PeepholeOptimizationsPass(compiler,\n             new StatementFusion(),\n             new PeepholeRemoveDeadCode(),\n+            new PeepholeMinimizeConditions(late),\n             new PeepholeSubstituteAlternateSyntax(late),\n             new PeepholeReplaceKnownMethods(late),\n             new PeepholeFoldConstants(late),\n--- a/src/com/google/javascript/jscomp/ExpandJqueryAliases.java\n+++ b/src/com/google/javascript/jscomp/ExpandJqueryAliases.java\n     // Passes, such as StatementFusion, are omitted for this reason.\n     final boolean late = false;\n     this.peepholePasses = new PeepholeOptimizationsPass(compiler,\n+        new PeepholeMinimizeConditions(late),\n         new PeepholeSubstituteAlternateSyntax(late),\n         new PeepholeReplaceKnownMethods(late),\n         new PeepholeRemoveDeadCode(),\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n     }\n \n     // Note: Right hand side folding is handled by\n-    // PeepholeSubstituteAlternateSyntax#tryMinimizeCondition\n+    // PeepholeMinimizeConditions#tryMinimizeCondition\n \n     if (result != null) {\n       // Fold it!\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/PeepholeMinimizeConditions.java\n+/*\n+ * Copyright 2010 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Predicate;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.javascript.rhino.IR;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.TernaryValue;\n+\n+import java.util.Collections;\n+import java.util.Comparator;\n+\n+/**\n+ * A peephole optimization that minimizes conditional expressions\n+ * according to De Morgan's laws.\n+ * Also rewrites conditional statements as expressions by replacing them\n+ * with HOOKs and short-circuit binary operators.\n+ *\n+ * Based on PeepholeSubstituteAlternateSyntax by\n+ */\n+class PeepholeMinimizeConditions\n+  extends AbstractPeepholeOptimization {\n+\n+  private static final int AND_PRECEDENCE = NodeUtil.precedence(Token.AND);\n+  private static final int OR_PRECEDENCE = NodeUtil.precedence(Token.OR);\n+\n+  private final boolean late;\n+\n+  static final Predicate<Node> DONT_TRAVERSE_FUNCTIONS_PREDICATE\n+      = new Predicate<Node>() {\n+    @Override\n+    public boolean apply(Node input) {\n+      return !input.isFunction();\n+    }\n+  };\n+\n+  /**\n+   * @param late When late is false, this mean we are currently running before\n+   * most of the other optimizations. In this case we would avoid optimizations\n+   * that would make the code harder to analyze (such as using string splitting,\n+   * merging statements with commas, etc). When this is true, we would\n+   * do anything to minimize for size.\n+   */\n+  PeepholeMinimizeConditions(boolean late) {\n+    this.late = late;\n+  }\n+\n+  /**\n+   * Tries apply our various peephole minimizations on the passed in node.\n+   */\n+  @Override\n+  @SuppressWarnings(\"fallthrough\")\n+  public Node optimizeSubtree(Node node) {\n+    switch(node.getType()) {\n+      case Token.RETURN: {\n+        Node result = tryRemoveRedundantExit(node);\n+        if (result != node) {\n+          return result;\n+        }\n+        result = tryReplaceExitWithBreak(node);\n+        if (result != node) {\n+          return result;\n+        }\n+        return tryReduceReturn(node);\n+      }\n+\n+      case Token.THROW: {\n+        Node result = tryRemoveRedundantExit(node);\n+        if (result != node) {\n+          return result;\n+        }\n+        return tryReplaceExitWithBreak(node);\n+      }\n+\n+      // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps\n+      // with MinimizeExitPoints.\n+\n+      case Token.NOT:\n+        tryMinimizeCondition(node.getFirstChild(), true);\n+        return tryMinimizeNot(node);\n+\n+      case Token.IF:\n+        tryMinimizeCondition(node.getFirstChild(), false);\n+        return tryMinimizeIf(node);\n+\n+      case Token.EXPR_RESULT:\n+        tryMinimizeCondition(node.getFirstChild(), true);\n+        return node;\n+\n+      case Token.HOOK:\n+        tryMinimizeCondition(node.getFirstChild(), false);\n+        return tryMinimizeHook(node);\n+\n+      case Token.WHILE:\n+      case Token.DO:\n+        tryMinimizeCondition(NodeUtil.getConditionExpression(node), true);\n+        return node;\n+\n+      case Token.FOR:\n+        if (!NodeUtil.isForIn(node)) {\n+          tryJoinForCondition(node);\n+          tryMinimizeCondition(NodeUtil.getConditionExpression(node), true);\n+        }\n+        return node;\n+\n+      case Token.BLOCK:\n+        return tryReplaceIf(node);\n+\n+      default:\n+        return node; //Nothing changed\n+    }\n+  }\n+\n+  private void tryJoinForCondition(Node n) {\n+    if (!late) {\n+      return;\n+    }\n+\n+    Node block = n.getLastChild();\n+    Node maybeIf = block.getFirstChild();\n+    if (maybeIf != null && maybeIf.isIf()) {\n+      Node maybeBreak = maybeIf.getChildAtIndex(1).getFirstChild();\n+      if (maybeBreak != null && maybeBreak.isBreak()\n+          && !maybeBreak.hasChildren()) {\n+\n+        // Preserve the IF ELSE expression is there is one.\n+        if (maybeIf.getChildCount() == 3) {\n+          block.replaceChild(maybeIf,\n+              maybeIf.getLastChild().detachFromParent());\n+        } else {\n+          block.removeFirstChild();\n+        }\n+\n+        Node ifCondition = maybeIf.removeFirstChild();\n+        Node fixedIfCondition = IR.not(ifCondition)\n+            .srcref(ifCondition);\n+\n+        // OK, join the IF expression with the FOR expression\n+        Node forCondition = NodeUtil.getConditionExpression(n);\n+        if (forCondition.isEmpty()) {\n+          n.replaceChild(forCondition, fixedIfCondition);\n+        } else {\n+          Node replacement = new Node(Token.AND);\n+          n.replaceChild(forCondition, replacement);\n+          replacement.addChildToBack(forCondition);\n+          replacement.addChildToBack(fixedIfCondition);\n+        }\n+\n+        reportCodeChange();\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Use \"return x?1:2;\" in place of \"if(x)return 1;return 2;\"\n+   */\n+  private Node tryReplaceIf(Node n) {\n+\n+    for (Node child = n.getFirstChild();\n+         child != null; child = child.getNext()){\n+      if (child.isIf()){\n+        Node cond = child.getFirstChild();\n+        Node thenBranch = cond.getNext();\n+        Node elseBranch = thenBranch.getNext();\n+        Node nextNode = child.getNext();\n+\n+        if (nextNode != null && elseBranch == null\n+            && isReturnBlock(thenBranch)\n+            && nextNode.isIf()) {\n+          Node nextCond = nextNode.getFirstChild();\n+          Node nextThen = nextCond.getNext();\n+          Node nextElse = nextThen.getNext();\n+          if (thenBranch.isEquivalentToTyped(nextThen)) {\n+            // Transform\n+            //   if (x) return 1; if (y) return 1;\n+            // to\n+            //   if (x||y) return 1;\n+            child.detachFromParent();\n+            child.detachChildren();\n+            Node newCond = new Node(Token.OR, cond);\n+            nextNode.replaceChild(nextCond, newCond);\n+            newCond.addChildToBack(nextCond);\n+            reportCodeChange();\n+          } else if (nextElse != null\n+              && thenBranch.isEquivalentToTyped(nextElse)) {\n+            // Transform\n+            //   if (x) return 1; if (y) foo() else return 1;\n+            // to\n+            //   if (!x&&y) foo() else return 1;\n+            child.detachFromParent();\n+            child.detachChildren();\n+            Node newCond = new Node(Token.AND,\n+                IR.not(cond).srcref(cond));\n+            nextNode.replaceChild(nextCond, newCond);\n+            newCond.addChildToBack(nextCond);\n+            reportCodeChange();\n+          }\n+        } else if (nextNode != null && elseBranch == null &&\n+            isReturnBlock(thenBranch) && isReturnExpression(nextNode)) {\n+          Node thenExpr = null;\n+          // if(x)return; return 1 -> return x?void 0:1\n+          if (isReturnExpressBlock(thenBranch)) {\n+            thenExpr = getBlockReturnExpression(thenBranch);\n+            thenExpr.detachFromParent();\n+          } else {\n+            thenExpr = NodeUtil.newUndefinedNode(child);\n+          }\n+\n+          Node elseExpr = nextNode.getFirstChild();\n+\n+          cond.detachFromParent();\n+          elseExpr.detachFromParent();\n+\n+          Node returnNode = IR.returnNode(\n+                                IR.hook(cond, thenExpr, elseExpr)\n+                                    .srcref(child));\n+          n.replaceChild(child, returnNode);\n+          n.removeChild(nextNode);\n+          reportCodeChange();\n+        } else if (elseBranch != null && statementMustExitParent(thenBranch)) {\n+          child.removeChild(elseBranch);\n+          n.addChildAfter(elseBranch, child);\n+          reportCodeChange();\n+        }\n+      }\n+    }\n+    return n;\n+  }\n+\n+  private boolean statementMustExitParent(Node n) {\n+    switch (n.getType()) {\n+      case Token.THROW:\n+      case Token.RETURN:\n+        return true;\n+      case Token.BLOCK:\n+        if (n.hasChildren()) {\n+          Node child = n.getLastChild();\n+          return statementMustExitParent(child);\n+        }\n+        return false;\n+      // TODO(johnlenz): handle TRY/FINALLY\n+      case Token.FUNCTION:\n+      default:\n+        return false;\n+    }\n+  }\n+\n+  /**\n+   * Reduce \"return undefined\" or \"return void 0\" to simply \"return\".\n+   *\n+   * @return The original node, maybe simplified.\n+   */\n+  private Node tryReduceReturn(Node n) {\n+    Node result = n.getFirstChild();\n+\n+    if (result != null) {\n+      switch (result.getType()) {\n+        case Token.VOID:\n+          Node operand = result.getFirstChild();\n+          if (!mayHaveSideEffects(operand)) {\n+            n.removeFirstChild();\n+            reportCodeChange();\n+          }\n+          break;\n+        case Token.NAME:\n+          String name = result.getString();\n+          if (name.equals(\"undefined\")) {\n+            n.removeFirstChild();\n+            reportCodeChange();\n+          }\n+          break;\n+      }\n+    }\n+\n+    return n;\n+  }\n+\n+  /**\n+   * Replace duplicate exits in control structures.  If the node following\n+   * the exit node expression has the same effect as exit node, the node can\n+   * be replaced or removed.\n+   * For example:\n+   *   \"while (a) {return f()} return f();\" ==> \"while (a) {break} return f();\"\n+   *   \"while (a) {throw 'ow'} throw 'ow';\" ==> \"while (a) {break} throw 'ow';\"\n+   *\n+   * @param n An follow control exit expression (a THROW or RETURN node)\n+   * @return The replacement for n, or the original if no change was made.\n+   */\n+  private Node tryReplaceExitWithBreak(Node n) {\n+    Node result = n.getFirstChild();\n+\n+    // Find the enclosing control structure, if any, that a \"break\" would exit\n+    // from.\n+    Node breakTarget = n;\n+    for (; !ControlFlowAnalysis.isBreakTarget(breakTarget, null /* no label */);\n+        breakTarget = breakTarget.getParent()) {\n+      if (breakTarget.isFunction() || breakTarget.isScript()) {\n+        // No break target.\n+        return n;\n+      }\n+    }\n+\n+    Node follow = ControlFlowAnalysis.computeFollowNode(breakTarget);\n+\n+    // Skip pass all the finally blocks because both the break and return will\n+    // also trigger all the finally blocks. However, the order of execution is\n+    // slightly changed. Consider:\n+    //\n+    // return a() -> finally { b() } -> return a()\n+    //\n+    // which would call a() first. However, changing the first return to a\n+    // break will result in calling b().\n+\n+    Node prefinallyFollows = follow;\n+    follow = skipFinallyNodes(follow);\n+\n+    if (prefinallyFollows != follow) {\n+      // There were finally clauses\n+      if (!isPure(result)) {\n+        // Can't defer the exit\n+        return n;\n+      }\n+    }\n+\n+    if (follow == null && (n.isThrow() || result != null)) {\n+      // Can't complete remove a throw here or a return with a result.\n+      return n;\n+    }\n+\n+    // When follow is null, this mean the follow of a break target is the\n+    // end of a function. This means a break is same as return.\n+    if (follow == null || areMatchingExits(n, follow)) {\n+      Node replacement = IR.breakNode();\n+      n.getParent().replaceChild(n, replacement);\n+      this.reportCodeChange();\n+      return replacement;\n+    }\n+\n+    return n;\n+  }\n+\n+  /**\n+   * Remove duplicate exits.  If the node following the exit node expression\n+   * has the same effect as exit node, the node can be removed.\n+   * For example:\n+   *   \"if (a) {return f()} return f();\" ==> \"if (a) {} return f();\"\n+   *   \"if (a) {throw 'ow'} throw 'ow';\" ==> \"if (a) {} throw 'ow';\"\n+   *\n+   * @param n An follow control exit expression (a THROW or RETURN node)\n+   * @return The replacement for n, or the original if no change was made.\n+   */\n+  private Node tryRemoveRedundantExit(Node n) {\n+    Node exitExpr = n.getFirstChild();\n+\n+    Node follow = ControlFlowAnalysis.computeFollowNode(n);\n+\n+    // Skip pass all the finally blocks because both the fall through and return\n+    // will also trigger all the finally blocks.\n+    Node prefinallyFollows = follow;\n+    follow = skipFinallyNodes(follow);\n+    if (prefinallyFollows != follow) {\n+      // There were finally clauses\n+      if (!isPure(exitExpr)) {\n+        // Can't replace the return\n+        return n;\n+      }\n+    }\n+\n+    if (follow == null && (n.isThrow() || exitExpr != null)) {\n+      // Can't complete remove a throw here or a return with a result.\n+      return n;\n+    }\n+\n+    // When follow is null, this mean the follow of a break target is the\n+    // end of a function. This means a break is same as return.\n+    if (follow == null || areMatchingExits(n, follow)) {\n+      n.detachFromParent();\n+      reportCodeChange();\n+      return null;\n+    }\n+\n+    return n;\n+  }\n+\n+  /**\n+   * @return Whether the expression does not produces and can not be affected\n+   * by side-effects.\n+   */\n+  boolean isPure(Node n) {\n+    return n == null\n+        || (!NodeUtil.canBeSideEffected(n)\n+            && !mayHaveSideEffects(n));\n+  }\n+\n+  /**\n+   * @return n or the node following any following finally nodes.\n+   */\n+  Node skipFinallyNodes(Node n) {\n+    while (n != null && NodeUtil.isTryFinallyNode(n.getParent(), n)) {\n+      n = ControlFlowAnalysis.computeFollowNode(n);\n+    }\n+    return n;\n+  }\n+\n+  /**\n+   * Check whether one exit can be replaced with another. Verify:\n+   * 1) They are identical expressions\n+   * 2) If an exception is possible that the statements, the original\n+   * and the potential replacement are in the same exception handler.\n+   */\n+  boolean areMatchingExits(Node nodeThis, Node nodeThat) {\n+    return nodeThis.isEquivalentTo(nodeThat)\n+        && (!isExceptionPossible(nodeThis)\n+            || getExceptionHandler(nodeThis) == getExceptionHandler(nodeThat));\n+  }\n+\n+  boolean isExceptionPossible(Node n) {\n+    // TODO(johnlenz): maybe use ControlFlowAnalysis.mayThrowException?\n+    Preconditions.checkState(n.isReturn()\n+        || n.isThrow());\n+    return n.isThrow()\n+        || (n.hasChildren()\n+            && !NodeUtil.isLiteralValue(n.getLastChild(), true));\n+  }\n+\n+  Node getExceptionHandler(Node n) {\n+    return ControlFlowAnalysis.getExceptionHandler(n);\n+  }\n+\n+  /**\n+   * Try to minimize NOT nodes such as !(x==y).\n+   *\n+   * Returns the replacement for n or the original if no change was made\n+   */\n+  private Node tryMinimizeNot(Node n) {\n+    Node parent = n.getParent();\n+\n+    Node notChild = n.getFirstChild();\n+    // negative operator of the current one : == -> != for instance.\n+    int complementOperator;\n+    switch (notChild.getType()) {\n+      case Token.EQ:\n+        complementOperator = Token.NE;\n+        break;\n+      case Token.NE:\n+        complementOperator = Token.EQ;\n+        break;\n+      case Token.SHEQ:\n+        complementOperator = Token.SHNE;\n+        break;\n+      case Token.SHNE:\n+        complementOperator = Token.SHEQ;\n+        break;\n+      // GT, GE, LT, LE are not handled in this because !(x<NaN) != x>=NaN.\n+      default:\n+        return n;\n+    }\n+    Node newOperator = n.removeFirstChild();\n+    newOperator.setType(complementOperator);\n+    parent.replaceChild(n, newOperator);\n+    reportCodeChange();\n+    return newOperator;\n+  }\n+\n+  /**\n+   * Try flipping HOOKs that have negated conditions.\n+   *\n+   * Returns the replacement for n or the original if no replacement was\n+   * necessary.\n+   */\n+  private Node tryMinimizeHook(Node n) {\n+    Node cond = n.getFirstChild();\n+    if (cond.isNot()) {\n+      Node thenBranch = cond.getNext();\n+      n.replaceChild(cond, cond.removeFirstChild());\n+      n.removeChild(thenBranch);\n+      n.addChildToBack(thenBranch);\n+      reportCodeChange();\n+    }\n+    return n;\n+  }\n+\n+  /**\n+   * Try turning IF nodes into smaller HOOKs\n+   *\n+   * Returns the replacement for n or the original if no replacement was\n+   * necessary.\n+   */\n+  private Node tryMinimizeIf(Node n) {\n+\n+    Node parent = n.getParent();\n+\n+    Node cond = n.getFirstChild();\n+\n+    /* If the condition is a literal, we'll let other\n+     * optimizations try to remove useless code.\n+     */\n+    if (NodeUtil.isLiteralValue(cond, true)) {\n+      return n;\n+    }\n+\n+    Node thenBranch = cond.getNext();\n+    Node elseBranch = thenBranch.getNext();\n+\n+    if (elseBranch == null) {\n+      if (isFoldableExpressBlock(thenBranch)) {\n+        Node expr = getBlockExpression(thenBranch);\n+        if (!late && isPropertyAssignmentInExpression(expr)) {\n+          // Keep opportunities for CollapseProperties such as\n+          // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n+          // until CollapseProperties has been run.\n+          return n;\n+        }\n+\n+        if (cond.isNot()) {\n+          // if(!x)bar(); -> x||bar();\n+          if (isLowerPrecedence(cond.getFirstChild(), OR_PRECEDENCE) &&\n+              isLowerPrecedence(expr.getFirstChild(),\n+                  OR_PRECEDENCE)) {\n+            // It's not okay to add two sets of parentheses.\n+            return n;\n+          }\n+\n+          Node or = IR.or(\n+              cond.removeFirstChild(),\n+              expr.removeFirstChild()).srcref(n);\n+          Node newExpr = NodeUtil.newExpr(or);\n+          parent.replaceChild(n, newExpr);\n+          reportCodeChange();\n+\n+          return newExpr;\n+        }\n+\n+        // if(x)foo(); -> x&&foo();\n+        if (isLowerPrecedence(cond, AND_PRECEDENCE) &&\n+            isLowerPrecedence(expr.getFirstChild(),\n+                AND_PRECEDENCE)) {\n+          // One additional set of parentheses is worth the change even if\n+          // there is no immediate code size win. However, two extra pair of\n+          // {}, we would have to think twice. (unless we know for sure the\n+          // we can further optimize its parent.\n+          return n;\n+        }\n+\n+        n.removeChild(cond);\n+        Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n+        Node newExpr = NodeUtil.newExpr(and);\n+        parent.replaceChild(n, newExpr);\n+        reportCodeChange();\n+\n+        return newExpr;\n+      } else {\n+\n+        // Try to combine two IF-ELSE\n+        if (NodeUtil.isStatementBlock(thenBranch) &&\n+            thenBranch.hasOneChild()) {\n+          Node innerIf = thenBranch.getFirstChild();\n+\n+          if (innerIf.isIf()) {\n+            Node innerCond = innerIf.getFirstChild();\n+            Node innerThenBranch = innerCond.getNext();\n+            Node innerElseBranch = innerThenBranch.getNext();\n+\n+            if (innerElseBranch == null &&\n+                 !(isLowerPrecedence(cond, AND_PRECEDENCE) &&\n+                   isLowerPrecedence(innerCond, AND_PRECEDENCE))) {\n+              n.detachChildren();\n+              n.addChildToBack(\n+                  IR.and(\n+                      cond,\n+                      innerCond.detachFromParent())\n+                      .srcref(cond));\n+              n.addChildrenToBack(innerThenBranch.detachFromParent());\n+              reportCodeChange();\n+              // Not worth trying to fold the current IF-ELSE into && because\n+              // the inner IF-ELSE wasn't able to be folded into && anyways.\n+              return n;\n+            }\n+          }\n+        }\n+      }\n+\n+      return n;\n+    }\n+\n+    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a\n+     * peephole optimization. This should probably get moved to another pass.\n+     */\n+    tryRemoveRepeatedStatements(n);\n+\n+    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n+    // An additional set of curly braces isn't worth it.\n+    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n+      n.replaceChild(cond, cond.removeFirstChild());\n+      n.removeChild(thenBranch);\n+      n.addChildToBack(thenBranch);\n+      reportCodeChange();\n+      return n;\n+    }\n+\n+    // if(x)return 1;else return 2; -> return x?1:2;\n+    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n+      Node thenExpr = getBlockReturnExpression(thenBranch);\n+      Node elseExpr = getBlockReturnExpression(elseBranch);\n+      n.removeChild(cond);\n+      thenExpr.detachFromParent();\n+      elseExpr.detachFromParent();\n+\n+      // note - we ignore any cases with \"return;\", technically this\n+      // can be converted to \"return undefined;\" or some variant, but\n+      // that does not help code size.\n+      Node returnNode = IR.returnNode(\n+                            IR.hook(cond, thenExpr, elseExpr)\n+                                .srcref(n));\n+      parent.replaceChild(n, returnNode);\n+      reportCodeChange();\n+      return returnNode;\n+    }\n+\n+    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n+    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n+\n+    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n+      Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n+      Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n+      if (thenOp.getType() == elseOp.getType()) {\n+        // if(x)a=1;else a=2; -> a=x?1:2;\n+        if (NodeUtil.isAssignmentOp(thenOp)) {\n+          Node lhs = thenOp.getFirstChild();\n+          if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n+              // if LHS has side effects, don't proceed [since the optimization\n+              // evaluates LHS before cond]\n+              // NOTE - there are some circumstances where we can\n+              // proceed even if there are side effects...\n+              !mayEffectMutableState(lhs) &&\n+              (!mayHaveSideEffects(cond) ||\n+                  (thenOp.isAssign() && thenOp.getFirstChild().isName()))) {\n+\n+            n.removeChild(cond);\n+            Node assignName = thenOp.removeFirstChild();\n+            Node thenExpr = thenOp.removeFirstChild();\n+            Node elseExpr = elseOp.getLastChild();\n+            elseOp.removeChild(elseExpr);\n+\n+            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n+            Node assign = new Node(thenOp.getType(), assignName, hookNode)\n+                              .srcref(thenOp);\n+            Node expr = NodeUtil.newExpr(assign);\n+            parent.replaceChild(n, expr);\n+            reportCodeChange();\n+\n+            return expr;\n+          }\n+        }\n+      }\n+      // if(x)foo();else bar(); -> x?foo():bar()\n+      n.removeChild(cond);\n+      thenOp.detachFromParent();\n+      elseOp.detachFromParent();\n+      Node expr = IR.exprResult(\n+          IR.hook(cond, thenOp, elseOp).srcref(n));\n+      parent.replaceChild(n, expr);\n+      reportCodeChange();\n+      return expr;\n+    }\n+\n+    boolean thenBranchIsVar = isVarBlock(thenBranch);\n+    boolean elseBranchIsVar = isVarBlock(elseBranch);\n+\n+    // if(x)var y=1;else y=2  ->  var y=x?1:2\n+    if (thenBranchIsVar && elseBranchIsExpressionBlock &&\n+        getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n+\n+      Node var = getBlockVar(thenBranch);\n+      Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n+\n+      Node name1 = var.getFirstChild();\n+      Node maybeName2 = elseAssign.getFirstChild();\n+\n+      if (name1.hasChildren()\n+          && maybeName2.isName()\n+          && name1.getString().equals(maybeName2.getString())) {\n+        Node thenExpr = name1.removeChildren();\n+        Node elseExpr = elseAssign.getLastChild().detachFromParent();\n+        cond.detachFromParent();\n+        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n+                            .srcref(n);\n+        var.detachFromParent();\n+        name1.addChildrenToBack(hookNode);\n+        parent.replaceChild(n, var);\n+        reportCodeChange();\n+        return var;\n+      }\n+\n+    // if(x)y=1;else var y=2  ->  var y=x?1:2\n+    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&\n+        getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n+\n+      Node var = getBlockVar(elseBranch);\n+      Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n+\n+      Node maybeName1 = thenAssign.getFirstChild();\n+      Node name2 = var.getFirstChild();\n+\n+      if (name2.hasChildren()\n+          && maybeName1.isName()\n+          && maybeName1.getString().equals(name2.getString())) {\n+        Node thenExpr = thenAssign.getLastChild().detachFromParent();\n+        Node elseExpr = name2.removeChildren();\n+        cond.detachFromParent();\n+        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n+                            .srcref(n);\n+        var.detachFromParent();\n+        name2.addChildrenToBack(hookNode);\n+        parent.replaceChild(n, var);\n+        reportCodeChange();\n+\n+        return var;\n+      }\n+    }\n+\n+    return n;\n+  }\n+\n+  /**\n+   * Try to remove duplicate statements from IF blocks. For example:\n+   *\n+   * if (a) {\n+   *   x = 1;\n+   *   return true;\n+   * } else {\n+   *   x = 2;\n+   *   return true;\n+   * }\n+   *\n+   * becomes:\n+   *\n+   * if (a) {\n+   *   x = 1;\n+   * } else {\n+   *   x = 2;\n+   * }\n+   * return true;\n+   *\n+   * @param n The IF node to examine.\n+   */\n+  private void tryRemoveRepeatedStatements(Node n) {\n+    Preconditions.checkState(n.isIf());\n+\n+    Node parent = n.getParent();\n+    if (!NodeUtil.isStatementBlock(parent)) {\n+      // If the immediate parent is something like a label, we\n+      // can't move the statement, so bail.\n+      return;\n+    }\n+\n+    Node cond = n.getFirstChild();\n+    Node trueBranch = cond.getNext();\n+    Node falseBranch = trueBranch.getNext();\n+    Preconditions.checkNotNull(trueBranch);\n+    Preconditions.checkNotNull(falseBranch);\n+\n+    while (true) {\n+      Node lastTrue = trueBranch.getLastChild();\n+      Node lastFalse = falseBranch.getLastChild();\n+      if (lastTrue == null || lastFalse == null\n+          || !areNodesEqualForInlining(lastTrue, lastFalse)) {\n+        break;\n+      }\n+      lastTrue.detachFromParent();\n+      lastFalse.detachFromParent();\n+      parent.addChildAfter(lastTrue, n);\n+      reportCodeChange();\n+    }\n+  }\n+\n+  /**\n+   * @return Whether the node is a block with a single statement that is\n+   *     an expression.\n+   */\n+  private static boolean isFoldableExpressBlock(Node n) {\n+    if (n.isBlock()) {\n+      if (n.hasOneChild()) {\n+        Node maybeExpr = n.getFirstChild();\n+        if (maybeExpr.isExprResult()) {\n+          // IE has a bug where event handlers behave differently when\n+          // their return value is used vs. when their return value is in\n+          // an EXPR_RESULT. It's pretty freaking weird. See:\n+          // http://code.google.com/p/closure-compiler/issues/detail?id=291\n+          // We try to detect this case, and not fold EXPR_RESULTs\n+          // into other expressions.\n+          if (maybeExpr.getFirstChild().isCall()) {\n+            Node calledFn = maybeExpr.getFirstChild().getFirstChild();\n+\n+            // We only have to worry about methods with an implicit 'this'\n+            // param, or this doesn't happen.\n+            if (calledFn.isGetElem()) {\n+              return false;\n+            } else if (calledFn.isGetProp() &&\n+                       calledFn.getLastChild().getString().startsWith(\"on\")) {\n+              return false;\n+            }\n+          }\n+\n+          return true;\n+        }\n+        return false;\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * @return The expression node.\n+   */\n+  private static Node getBlockExpression(Node n) {\n+    Preconditions.checkState(isFoldableExpressBlock(n));\n+    return n.getFirstChild();\n+  }\n+\n+  /**\n+   * @return Whether the node is a block with a single statement that is\n+   *     an return with or without an expression.\n+   */\n+  private static boolean isReturnBlock(Node n) {\n+    if (n.isBlock()) {\n+      if (n.hasOneChild()) {\n+        Node first = n.getFirstChild();\n+        return first.isReturn();\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * @return Whether the node is a block with a single statement that is\n+   *     an return.\n+   */\n+  private static boolean isReturnExpressBlock(Node n) {\n+    if (n.isBlock()) {\n+      if (n.hasOneChild()) {\n+        Node first = n.getFirstChild();\n+        if (first.isReturn()) {\n+          return first.hasOneChild();\n+        }\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * @return Whether the node is a single return statement.\n+   */\n+  private static boolean isReturnExpression(Node n) {\n+    if (n.isReturn()) {\n+      return n.hasOneChild();\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * @return The expression that is part of the return.\n+   */\n+  private static Node getBlockReturnExpression(Node n) {\n+    Preconditions.checkState(isReturnExpressBlock(n));\n+    return n.getFirstChild().getFirstChild();\n+  }\n+\n+  /**\n+   * @return Whether the node is a block with a single statement that is\n+   *     a VAR declaration of a single variable.\n+   */\n+  private static boolean isVarBlock(Node n) {\n+    if (n.isBlock()) {\n+      if (n.hasOneChild()) {\n+        Node first = n.getFirstChild();\n+        if (first.isVar()) {\n+          return first.hasOneChild();\n+        }\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  /**\n+   * @return The var node.\n+   */\n+  private static Node getBlockVar(Node n) {\n+    Preconditions.checkState(isVarBlock(n));\n+    return n.getFirstChild();\n+  }\n+\n+  /**\n+   * Does a statement consume a 'dangling else'? A statement consumes\n+   * a 'dangling else' if an 'else' token following the statement\n+   * would be considered by the parser to be part of the statement.\n+   */\n+  private static boolean consumesDanglingElse(Node n) {\n+    while (true) {\n+      switch (n.getType()) {\n+        case Token.IF:\n+          if (n.getChildCount() < 3) {\n+            return true;\n+          }\n+          // This IF node has no else clause.\n+          n = n.getLastChild();\n+          continue;\n+        case Token.WITH:\n+        case Token.WHILE:\n+        case Token.FOR:\n+          n = n.getLastChild();\n+          continue;\n+        default:\n+          return false;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Whether the node type has lower precedence than \"precedence\"\n+   */\n+  private static boolean isLowerPrecedence(Node n, final int precedence) {\n+    return NodeUtil.precedence(n.getType()) < precedence;\n+  }\n+\n+  /**\n+   * Does the expression contain a property assignment?\n+   */\n+  private static boolean isPropertyAssignmentInExpression(Node n) {\n+    Predicate<Node> isPropertyAssignmentInExpressionPredicate =\n+        new Predicate<Node>() {\n+      @Override\n+      public boolean apply(Node input) {\n+        return (input.isGetProp() &&\n+            input.getParent().isAssign());\n+      }\n+    };\n+\n+    return NodeUtil.has(n, isPropertyAssignmentInExpressionPredicate,\n+        DONT_TRAVERSE_FUNCTIONS_PREDICATE);\n+  }\n+\n+  private Node tryMinimizeCondition(Node n, boolean countLeadingNot) {\n+    n = tryMinimizeConditionOld(n);\n+    return demorganMinimizeCondition(n, countLeadingNot);\n+  }\n+\n+  /**\n+   *  Minimize the given conditional node according to De Morgan's Laws.\n+   *    !(x && !y)  ==> !x || y\n+   *    (!a || !b || !c || !d)  ==>  !(a && b && c && d)\n+   *  etc.\n+   *\n+   * @param countLeadingNot When this is false, do not count a leading\n+   *  NOT in doing the minimization. i.e. Allow minimizations such as:\n+   *    (!x || !y || z)  ==>  !(x && y && !z)\n+   *  This is useful in contexts such as IFs or HOOKs where subsequent\n+   *  optimizations can efficiently deal with leading NOTs.\n+   *\n+   * @param n The conditional node.\n+   * @return The minimized version of n, or n if no minimization was possible.\n+   */\n+  private Node demorganMinimizeCondition(Node n, boolean countLeadingNot) {\n+    MinimizedCondition minCond = MinimizedCondition.fromConditionNode(n);\n+    if (countLeadingNot ||\n+         minCond.getLength() <= minCond.getNegativeLength()) {\n+      return maybeReplaceNode(n, minCond.getNode());\n+    } else {\n+      return maybeReplaceNode(n,\n+          new Node(Token.NOT, minCond.getNegatedNode()));\n+    }\n+  }\n+\n+  private Node maybeReplaceNode(Node lhs, Node rhs) {\n+    if (lhs.isEquivalentTo(rhs)) {\n+      return lhs;\n+    }\n+    Node parent = lhs.getParent();\n+    parent.replaceChild(lhs, rhs);\n+    reportCodeChange();\n+    return rhs;\n+  }\n+\n+  /** A class that represents a minimized conditional expression.\n+   *  Depending on the context, either the original conditional, or the\n+   *  negation of the original conditional may be needed, so this class\n+   *  provides ways to access minimized versions of both of those ASTs.\n+   */\n+  static class MinimizedCondition {\n+    private final Node positive;\n+    private final Node negative;\n+\n+    private MinimizedCondition(Node p, Node n) {\n+      Preconditions.checkArgument(p.getParent() == null);\n+      Preconditions.checkArgument(n.getParent() == null);\n+      positive = p;\n+      negative = n;\n+    }\n+\n+    /** Minimize the condition at the given node.\n+     *\n+     *  @param n The conditional expression tree to minimize.\n+     *   This may be still connected to a tree and will be cloned as necessary.\n+     *  @return A MinimizedCondition object representing that tree.\n+     */\n+    static MinimizedCondition fromConditionNode(Node n) {\n+      switch (n.getType()) {\n+        case Token.NOT: {\n+          MinimizedCondition subtree = fromConditionNode(n.getFirstChild());\n+          ImmutableSet<Node> positiveAsts = ImmutableSet.of(\n+              negate(subtree.positive.cloneTree()),\n+              subtree.negative.cloneTree());\n+          ImmutableSet<Node> negativeAsts = ImmutableSet.of(\n+              negate(subtree.negative),\n+              subtree.positive);\n+          return new MinimizedCondition(\n+              Collections.min(positiveAsts, AST_LENGTH_COMPARATOR),\n+              Collections.min(negativeAsts, AST_LENGTH_COMPARATOR));\n+        }\n+        case Token.AND:\n+        case Token.OR: {\n+          int opType = n.getType();\n+          int complementType = opType == Token.AND ? Token.OR : Token.AND;\n+          MinimizedCondition leftSubtree = fromConditionNode(n.getFirstChild());\n+          MinimizedCondition rightSubtree = fromConditionNode(n.getLastChild());\n+          ImmutableSet<Node> positiveAsts = ImmutableSet.of(\n+              new Node(opType,\n+                  leftSubtree.positive.cloneTree(),\n+                  rightSubtree.positive.cloneTree()).srcref(n),\n+              negate(new Node(complementType,\n+                  leftSubtree.negative.cloneTree(),\n+                  rightSubtree.negative.cloneTree()).srcref(n)));\n+          ImmutableSet<Node> negativeAsts = ImmutableSet.of(\n+              negate(new Node(opType,\n+                  leftSubtree.positive,\n+                  rightSubtree.positive).srcref(n)),\n+              new Node(complementType,\n+                  leftSubtree.negative,\n+                  rightSubtree.negative).srcref(n));\n+          return new MinimizedCondition(\n+              Collections.min(positiveAsts, AST_LENGTH_COMPARATOR),\n+              Collections.min(negativeAsts, AST_LENGTH_COMPARATOR));\n+        }\n+        default:\n+          return new MinimizedCondition(n.cloneTree(), negate(n.cloneTree()));\n+      }\n+    }\n+\n+    Node getNode() {\n+      return positive;\n+    }\n+\n+    Node getNegatedNode() {\n+      return negative;\n+    }\n+\n+    int getLength() {\n+      return length(positive);\n+    }\n+\n+    int getNegativeLength() {\n+      return length(negative);\n+    }\n+\n+    private static Node negate(Node node) {\n+      Preconditions.checkArgument(node.getParent() == null);\n+      int complementOperator;\n+      switch (node.getType()) {\n+        default:\n+          return new Node(Token.NOT, node).srcref(node);\n+        case Token.NOT:\n+          return node.removeFirstChild();\n+        // Otherwise a binary operator with a complement.\n+        case Token.EQ:\n+          complementOperator = Token.NE;\n+          break;\n+        case Token.NE:\n+          complementOperator = Token.EQ;\n+          break;\n+        case Token.SHEQ:\n+          complementOperator = Token.SHNE;\n+          break;\n+        case Token.SHNE:\n+          complementOperator = Token.SHEQ;\n+          break;\n+      }\n+      // Clone entire tree and just change operator.\n+      node.setType(complementOperator);\n+      return node;\n+    }\n+\n+    private static final Comparator<Node> AST_LENGTH_COMPARATOR =\n+        new Comparator<Node>() {\n+      @Override\n+      public int compare(Node o1, Node o2) {\n+        return length(o1) - length(o2);\n+      }\n+    };\n+\n+    /** Return the number of characters in the textual representation of\n+     *  the given tree that will be devoted to negation, or parentheses.\n+     *  Since these are the only characters that flipping a condition\n+     *  according to De Morgan's rule can affect, these are the only ones\n+     *  we count.\n+     *  @param node The tree whose length should be checked.\n+     *  @return The number of negations and parentheses in the tree.\n+     */\n+    static int length(Node node) {\n+      int result = 0;\n+      if (node.isNot()) {\n+        result++;  // One negation needed.\n+      }\n+      for (Node n = node.getFirstChild(); n != null; n = n.getNext()) {\n+        if (NodeUtil.precedenceWithDefault(n.getType())\n+            < NodeUtil.precedenceWithDefault(node.getType())) {\n+          result += 2;  // One pair of parentheses needed.\n+        }\n+        result += length(n);\n+      }\n+      return result;\n+    }\n+\n+  }\n+\n+  /**\n+   * Try to minimize conditions expressions, as there are additional\n+   * assumptions that can be made when it is known that the final result\n+   * is a boolean.\n+   *\n+   * The following transformations are done recursively:\n+   *   !(x||y) --> !x&&!y\n+   *   !(x&&y) --> !x||!y\n+   *   !!x     --> x\n+   * Thus:\n+   *   !(x&&!y) --> !x||!!y --> !x||y\n+   *\n+   *   Returns the replacement for n, or the original if no change was made\n+   */\n+  private Node tryMinimizeConditionOld(Node n) {\n+    Node parent = n.getParent();\n+\n+    switch (n.getType()) {\n+      case Token.OR:\n+      case Token.AND: {\n+        Node left = n.getFirstChild();\n+        Node right = n.getLastChild();\n+\n+        // Because the expression is in a boolean context minimize\n+        // the children, this can't be done in the general case.\n+        left = tryMinimizeConditionOld(left);\n+        right = tryMinimizeConditionOld(right);\n+\n+        // Remove useless conditionals\n+        // Handle four cases:\n+        //   x || false --> x\n+        //   x || true  --> true\n+        //   x && true --> x\n+        //   x && false  --> false\n+        TernaryValue rightVal = NodeUtil.getPureBooleanValue(right);\n+        if (NodeUtil.getPureBooleanValue(right) != TernaryValue.UNKNOWN) {\n+          int type = n.getType();\n+          Node replacement = null;\n+          boolean rval = rightVal.toBoolean(true);\n+\n+          // (x || FALSE) => x\n+          // (x && TRUE) => x\n+          if (type == Token.OR && !rval ||\n+              type == Token.AND && rval) {\n+            replacement = left;\n+          } else if (!mayHaveSideEffects(left)) {\n+            replacement = right;\n+          }\n+\n+          if (replacement != null) {\n+            n.detachChildren();\n+            parent.replaceChild(n, replacement);\n+            reportCodeChange();\n+            return replacement;\n+          }\n+        }\n+        return n;\n+      }\n+\n+      case Token.HOOK: {\n+        Node condition = n.getFirstChild();\n+        Node trueNode = n.getFirstChild().getNext();\n+        Node falseNode = n.getLastChild();\n+\n+        // Because the expression is in a boolean context minimize\n+        // the result children, this can't be done in the general case.\n+        // The condition is handled in the general case in #optimizeSubtree\n+        trueNode = tryMinimizeConditionOld(trueNode);\n+        falseNode = tryMinimizeConditionOld(falseNode);\n+\n+        // Handle four cases:\n+        //   x ? true : false --> x\n+        //   x ? false : true --> !x\n+        //   x ? true : y     --> x || y\n+        //   x ? y : false    --> x && y\n+        Node replacement = null;\n+        TernaryValue trueNodeVal = NodeUtil.getPureBooleanValue(trueNode);\n+        TernaryValue falseNodeVal = NodeUtil.getPureBooleanValue(falseNode);\n+        if (trueNodeVal == TernaryValue.TRUE\n+            && falseNodeVal == TernaryValue.FALSE) {\n+          // Remove useless conditionals, keep the condition\n+          condition.detachFromParent();\n+          replacement = condition;\n+        } else if (trueNodeVal == TernaryValue.FALSE\n+            && falseNodeVal == TernaryValue.TRUE) {\n+          // Remove useless conditionals, keep the condition\n+          condition.detachFromParent();\n+          replacement = IR.not(condition);\n+        } else if (trueNodeVal == TernaryValue.TRUE) {\n+          // Remove useless true case.\n+          n.detachChildren();\n+          replacement = IR.or(condition, falseNode);\n+        } else if (falseNodeVal == TernaryValue.FALSE) {\n+          // Remove useless false case\n+          n.detachChildren();\n+          replacement = IR.and(condition, trueNode);\n+        }\n+\n+        if (replacement != null) {\n+          parent.replaceChild(n, replacement);\n+          n = replacement;\n+          reportCodeChange();\n+        }\n+\n+        return n;\n+      }\n+\n+      default:\n+        // while(true) --> while(1)\n+        TernaryValue nVal = NodeUtil.getPureBooleanValue(n);\n+        if (nVal != TernaryValue.UNKNOWN) {\n+          boolean result = nVal.toBoolean(true);\n+          int equivalentResult = result ? 1 : 0;\n+          return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n+        }\n+        // We can't do anything else currently.\n+        return n;\n+    }\n+  }\n+\n+  /**\n+   * Replaces a node with a number node if the new number node is not equivalent\n+   * to the current node.\n+   *\n+   * Returns the replacement for n if it was replaced, otherwise returns n.\n+   */\n+  private Node maybeReplaceChildWithNumber(Node n, Node parent, int num) {\n+    Node newNode = IR.number(num);\n+    if (!newNode.isEquivalentTo(n)) {\n+      parent.replaceChild(n, newNode);\n+      reportCodeChange();\n+\n+      return newNode;\n+    }\n+\n+    return n;\n+  }\n+\n+}\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n \n import com.google.common.base.Joiner;\n import com.google.common.base.Preconditions;\n-import com.google.common.base.Predicate;\n import com.google.common.collect.ImmutableSet;\n import com.google.javascript.jscomp.CodingConvention.Bind;\n import com.google.javascript.rhino.IR;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n-import com.google.javascript.rhino.jstype.TernaryValue;\n-\n-import java.util.Collections;\n-import java.util.Comparator;\n+\n import java.util.regex.Pattern;\n \n /**\n class PeepholeSubstituteAlternateSyntax\n   extends AbstractPeepholeOptimization {\n \n-  private static final int AND_PRECEDENCE = NodeUtil.precedence(Token.AND);\n-  private static final int OR_PRECEDENCE = NodeUtil.precedence(Token.OR);\n   private static final CodeGenerator REGEXP_ESCAPER =\n       CodeGenerator.forCostEstimation(\n           null /* blow up if we try to produce code */);\n     DiagnosticType.warning(\n         \"JSC_INVALID_REGULAR_EXPRESSION_FLAGS\",\n         \"Invalid flags to RegExp constructor: {0}\");\n-\n-  static final Predicate<Node> DONT_TRAVERSE_FUNCTIONS_PREDICATE\n-      = new Predicate<Node>() {\n-    @Override\n-    public boolean apply(Node input) {\n-      return !input.isFunction();\n-    }\n-  };\n \n   /**\n    * @param late When late is false, this mean we are currently running before\n   @SuppressWarnings(\"fallthrough\")\n   public Node optimizeSubtree(Node node) {\n     switch(node.getType()) {\n-      case Token.RETURN: {\n-        Node result = tryRemoveRedundantExit(node);\n-        if (result != node) {\n-          return result;\n-        }\n-        result = tryReplaceExitWithBreak(node);\n-        if (result != node) {\n-          return result;\n-        }\n-        return tryReduceReturn(node);\n-      }\n-\n-      case Token.THROW: {\n-        Node result = tryRemoveRedundantExit(node);\n-        if (result != node) {\n-          return result;\n-        }\n-        return tryReplaceExitWithBreak(node);\n-      }\n-\n-      // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps\n-      // with MinimizeExitPoints.\n-\n-      case Token.NOT:\n-        tryMinimizeCondition(node.getFirstChild(), true);\n-        return tryMinimizeNot(node);\n-\n-      case Token.IF:\n-        tryMinimizeCondition(node.getFirstChild(), false);\n-        return tryMinimizeIf(node);\n-\n-      case Token.EXPR_RESULT:\n-        tryMinimizeCondition(node.getFirstChild(), true);\n-        return node;\n-\n-      case Token.HOOK:\n-        tryMinimizeCondition(node.getFirstChild(), false);\n-        return tryMinimizeHook(node);\n-\n-      case Token.WHILE:\n-      case Token.DO:\n-        tryMinimizeCondition(NodeUtil.getConditionExpression(node), true);\n-        return node;\n-\n-      case Token.FOR:\n-        if (!NodeUtil.isForIn(node)) {\n-          tryJoinForCondition(node);\n-          tryMinimizeCondition(NodeUtil.getConditionExpression(node), true);\n-        }\n-        return node;\n-\n       case Token.TRUE:\n       case Token.FALSE:\n         return reduceTrueFalse(node);\n       case Token.NAME:\n         return tryReplaceUndefined(node);\n \n-      case Token.BLOCK:\n-        return tryReplaceIf(node);\n-\n       case Token.ARRAYLIT:\n         return tryMinimizeArrayLiteral(node);\n \n       default:\n         return node; //Nothing changed\n-    }\n-  }\n-\n-  private void tryJoinForCondition(Node n) {\n-    if (!late) {\n-      return;\n-    }\n-\n-    Node block = n.getLastChild();\n-    Node maybeIf = block.getFirstChild();\n-    if (maybeIf != null && maybeIf.isIf()) {\n-      Node maybeBreak = maybeIf.getChildAtIndex(1).getFirstChild();\n-      if (maybeBreak != null && maybeBreak.isBreak()\n-          && !maybeBreak.hasChildren()) {\n-\n-        // Preserve the IF ELSE expression is there is one.\n-        if (maybeIf.getChildCount() == 3) {\n-          block.replaceChild(maybeIf,\n-              maybeIf.getLastChild().detachFromParent());\n-        } else {\n-          block.removeFirstChild();\n-        }\n-\n-        Node ifCondition = maybeIf.removeFirstChild();\n-        Node fixedIfCondition = IR.not(ifCondition)\n-            .srcref(ifCondition);\n-\n-        // OK, join the IF expression with the FOR expression\n-        Node forCondition = NodeUtil.getConditionExpression(n);\n-        if (forCondition.isEmpty()) {\n-          n.replaceChild(forCondition, fixedIfCondition);\n-        } else {\n-          Node replacement = new Node(Token.AND);\n-          n.replaceChild(forCondition, replacement);\n-          replacement.addChildToBack(forCondition);\n-          replacement.addChildToBack(fixedIfCondition);\n-        }\n-\n-        reportCodeChange();\n-      }\n     }\n   }\n \n   }\n \n   /**\n-   * Use \"return x?1:2;\" in place of \"if(x)return 1;return 2;\"\n-   */\n-  private Node tryReplaceIf(Node n) {\n-\n-    for (Node child = n.getFirstChild();\n-         child != null; child = child.getNext()){\n-      if (child.isIf()){\n-        Node cond = child.getFirstChild();\n-        Node thenBranch = cond.getNext();\n-        Node elseBranch = thenBranch.getNext();\n-        Node nextNode = child.getNext();\n-\n-        if (nextNode != null && elseBranch == null\n-            && isReturnBlock(thenBranch)\n-            && nextNode.isIf()) {\n-          Node nextCond = nextNode.getFirstChild();\n-          Node nextThen = nextCond.getNext();\n-          Node nextElse = nextThen.getNext();\n-          if (thenBranch.isEquivalentToTyped(nextThen)) {\n-            // Transform\n-            //   if (x) return 1; if (y) return 1;\n-            // to\n-            //   if (x||y) return 1;\n-            child.detachFromParent();\n-            child.detachChildren();\n-            Node newCond = new Node(Token.OR, cond);\n-            nextNode.replaceChild(nextCond, newCond);\n-            newCond.addChildToBack(nextCond);\n-            reportCodeChange();\n-          } else if (nextElse != null\n-              && thenBranch.isEquivalentToTyped(nextElse)) {\n-            // Transform\n-            //   if (x) return 1; if (y) foo() else return 1;\n-            // to\n-            //   if (!x&&y) foo() else return 1;\n-            child.detachFromParent();\n-            child.detachChildren();\n-            Node newCond = new Node(Token.AND,\n-                IR.not(cond).srcref(cond));\n-            nextNode.replaceChild(nextCond, newCond);\n-            newCond.addChildToBack(nextCond);\n-            reportCodeChange();\n-          }\n-        } else if (nextNode != null && elseBranch == null &&\n-            isReturnBlock(thenBranch) && isReturnExpression(nextNode)) {\n-          Node thenExpr = null;\n-          // if(x)return; return 1 -> return x?void 0:1\n-          if (isReturnExpressBlock(thenBranch)) {\n-            thenExpr = getBlockReturnExpression(thenBranch);\n-            thenExpr.detachFromParent();\n-          } else {\n-            thenExpr = NodeUtil.newUndefinedNode(child);\n-          }\n-\n-          Node elseExpr = nextNode.getFirstChild();\n-\n-          cond.detachFromParent();\n-          elseExpr.detachFromParent();\n-\n-          Node returnNode = IR.returnNode(\n-                                IR.hook(cond, thenExpr, elseExpr)\n-                                    .srcref(child));\n-          n.replaceChild(child, returnNode);\n-          n.removeChild(nextNode);\n-          reportCodeChange();\n-        } else if (elseBranch != null && statementMustExitParent(thenBranch)) {\n-          child.removeChild(elseBranch);\n-          n.addChildAfter(elseBranch, child);\n-          reportCodeChange();\n-        }\n-      }\n-    }\n-    return n;\n-  }\n-\n-  private boolean statementMustExitParent(Node n) {\n-    switch (n.getType()) {\n-      case Token.THROW:\n-      case Token.RETURN:\n-        return true;\n-      case Token.BLOCK:\n-        if (n.hasChildren()) {\n-          Node child = n.getLastChild();\n-          return statementMustExitParent(child);\n-        }\n-        return false;\n-      // TODO(johnlenz): handle TRY/FINALLY\n-      case Token.FUNCTION:\n-      default:\n-        return false;\n-    }\n-  }\n-\n-  /**\n    * Use \"void 0\" in place of \"undefined\"\n    */\n   private Node tryReplaceUndefined(Node n) {\n     return n;\n   }\n \n-  /**\n-   * Reduce \"return undefined\" or \"return void 0\" to simply \"return\".\n-   *\n-   * @return The original node, maybe simplified.\n-   */\n-  private Node tryReduceReturn(Node n) {\n-    Node result = n.getFirstChild();\n-\n-    if (result != null) {\n-      switch (result.getType()) {\n-        case Token.VOID:\n-          Node operand = result.getFirstChild();\n-          if (!mayHaveSideEffects(operand)) {\n-            n.removeFirstChild();\n-            reportCodeChange();\n-          }\n-          break;\n-        case Token.NAME:\n-          String name = result.getString();\n-          if (name.equals(\"undefined\")) {\n-            n.removeFirstChild();\n-            reportCodeChange();\n-          }\n-          break;\n-      }\n-    }\n-\n-    return n;\n-  }\n-\n-  /**\n-   * Replace duplicate exits in control structures.  If the node following\n-   * the exit node expression has the same effect as exit node, the node can\n-   * be replaced or removed.\n-   * For example:\n-   *   \"while (a) {return f()} return f();\" ==> \"while (a) {break} return f();\"\n-   *   \"while (a) {throw 'ow'} throw 'ow';\" ==> \"while (a) {break} throw 'ow';\"\n-   *\n-   * @param n An follow control exit expression (a THROW or RETURN node)\n-   * @return The replacement for n, or the original if no change was made.\n-   */\n-  private Node tryReplaceExitWithBreak(Node n) {\n-    Node result = n.getFirstChild();\n-\n-    // Find the enclosing control structure, if any, that a \"break\" would exit\n-    // from.\n-    Node breakTarget = n;\n-    for (; !ControlFlowAnalysis.isBreakTarget(breakTarget, null /* no label */);\n-        breakTarget = breakTarget.getParent()) {\n-      if (breakTarget.isFunction() || breakTarget.isScript()) {\n-        // No break target.\n-        return n;\n-      }\n-    }\n-\n-    Node follow = ControlFlowAnalysis.computeFollowNode(breakTarget);\n-\n-    // Skip pass all the finally blocks because both the break and return will\n-    // also trigger all the finally blocks. However, the order of execution is\n-    // slightly changed. Consider:\n-    //\n-    // return a() -> finally { b() } -> return a()\n-    //\n-    // which would call a() first. However, changing the first return to a\n-    // break will result in calling b().\n-\n-    Node prefinallyFollows = follow;\n-    follow = skipFinallyNodes(follow);\n-\n-    if (prefinallyFollows != follow) {\n-      // There were finally clauses\n-      if (!isPure(result)) {\n-        // Can't defer the exit\n-        return n;\n-      }\n-    }\n-\n-    if (follow == null && (n.isThrow() || result != null)) {\n-      // Can't complete remove a throw here or a return with a result.\n-      return n;\n-    }\n-\n-    // When follow is null, this mean the follow of a break target is the\n-    // end of a function. This means a break is same as return.\n-    if (follow == null || areMatchingExits(n, follow)) {\n-      Node replacement = IR.breakNode();\n-      n.getParent().replaceChild(n, replacement);\n-      this.reportCodeChange();\n-      return replacement;\n-    }\n-\n-    return n;\n-  }\n-\n-  /**\n-   * Remove duplicate exits.  If the node following the exit node expression\n-   * has the same effect as exit node, the node can be removed.\n-   * For example:\n-   *   \"if (a) {return f()} return f();\" ==> \"if (a) {} return f();\"\n-   *   \"if (a) {throw 'ow'} throw 'ow';\" ==> \"if (a) {} throw 'ow';\"\n-   *\n-   * @param n An follow control exit expression (a THROW or RETURN node)\n-   * @return The replacement for n, or the original if no change was made.\n-   */\n-  private Node tryRemoveRedundantExit(Node n) {\n-    Node exitExpr = n.getFirstChild();\n-\n-    Node follow = ControlFlowAnalysis.computeFollowNode(n);\n-\n-    // Skip pass all the finally blocks because both the fall through and return\n-    // will also trigger all the finally blocks.\n-    Node prefinallyFollows = follow;\n-    follow = skipFinallyNodes(follow);\n-    if (prefinallyFollows != follow) {\n-      // There were finally clauses\n-      if (!isPure(exitExpr)) {\n-        // Can't replace the return\n-        return n;\n-      }\n-    }\n-\n-    if (follow == null && (n.isThrow() || exitExpr != null)) {\n-      // Can't complete remove a throw here or a return with a result.\n-      return n;\n-    }\n-\n-    // When follow is null, this mean the follow of a break target is the\n-    // end of a function. This means a break is same as return.\n-    if (follow == null || areMatchingExits(n, follow)) {\n-      n.detachFromParent();\n-      reportCodeChange();\n-      return null;\n-    }\n-\n-    return n;\n-  }\n-\n-  /**\n-   * @return Whether the expression does not produces and can not be affected\n-   * by side-effects.\n-   */\n-  boolean isPure(Node n) {\n-    return n == null\n-        || (!NodeUtil.canBeSideEffected(n)\n-            && !mayHaveSideEffects(n));\n-  }\n-\n-  /**\n-   * @return n or the node following any following finally nodes.\n-   */\n-  Node skipFinallyNodes(Node n) {\n-    while (n != null && NodeUtil.isTryFinallyNode(n.getParent(), n)) {\n-      n = ControlFlowAnalysis.computeFollowNode(n);\n-    }\n-    return n;\n-  }\n-\n-  /**\n-   * Check whether one exit can be replaced with another. Verify:\n-   * 1) They are identical expressions\n-   * 2) If an exception is possible that the statements, the original\n-   * and the potential replacement are in the same exception handler.\n-   */\n-  boolean areMatchingExits(Node nodeThis, Node nodeThat) {\n-    return nodeThis.isEquivalentTo(nodeThat)\n-        && (!isExceptionPossible(nodeThis)\n-            || getExceptionHandler(nodeThis) == getExceptionHandler(nodeThat));\n-  }\n-\n-  boolean isExceptionPossible(Node n) {\n-    // TODO(johnlenz): maybe use ControlFlowAnalysis.mayThrowException?\n-    Preconditions.checkState(n.isReturn()\n-        || n.isThrow());\n-    return n.isThrow()\n-        || (n.hasChildren()\n-            && !NodeUtil.isLiteralValue(n.getLastChild(), true));\n-  }\n-\n-  Node getExceptionHandler(Node n) {\n-    return ControlFlowAnalysis.getExceptionHandler(n);\n-  }\n-\n-  /**\n-   * Try to minimize NOT nodes such as !(x==y).\n-   *\n-   * Returns the replacement for n or the original if no change was made\n-   */\n-  private Node tryMinimizeNot(Node n) {\n-    Node parent = n.getParent();\n-\n-    Node notChild = n.getFirstChild();\n-    // negative operator of the current one : == -> != for instance.\n-    int complementOperator;\n-    switch (notChild.getType()) {\n-      case Token.EQ:\n-        complementOperator = Token.NE;\n-        break;\n-      case Token.NE:\n-        complementOperator = Token.EQ;\n-        break;\n-      case Token.SHEQ:\n-        complementOperator = Token.SHNE;\n-        break;\n-      case Token.SHNE:\n-        complementOperator = Token.SHEQ;\n-        break;\n-      // GT, GE, LT, LE are not handled in this because !(x<NaN) != x>=NaN.\n-      default:\n-        return n;\n-    }\n-    Node newOperator = n.removeFirstChild();\n-    newOperator.setType(complementOperator);\n-    parent.replaceChild(n, newOperator);\n-    reportCodeChange();\n-    return newOperator;\n-  }\n-\n-  /**\n-   * Try flipping HOOKs that have negated conditions.\n-   *\n-   * Returns the replacement for n or the original if no replacement was\n-   * necessary.\n-   */\n-  private Node tryMinimizeHook(Node n) {\n-    Node cond = n.getFirstChild();\n-    if (cond.isNot()) {\n-      Node thenBranch = cond.getNext();\n-      n.replaceChild(cond, cond.removeFirstChild());\n-      n.removeChild(thenBranch);\n-      n.addChildToBack(thenBranch);\n-      reportCodeChange();\n-    }\n-    return n;\n-  }\n-\n-  /**\n-   * Try turning IF nodes into smaller HOOKs\n-   *\n-   * Returns the replacement for n or the original if no replacement was\n-   * necessary.\n-   */\n-  private Node tryMinimizeIf(Node n) {\n-\n-    Node parent = n.getParent();\n-\n-    Node cond = n.getFirstChild();\n-\n-    /* If the condition is a literal, we'll let other\n-     * optimizations try to remove useless code.\n-     */\n-    if (NodeUtil.isLiteralValue(cond, true)) {\n-      return n;\n-    }\n-\n-    Node thenBranch = cond.getNext();\n-    Node elseBranch = thenBranch.getNext();\n-\n-    if (elseBranch == null) {\n-      if (isFoldableExpressBlock(thenBranch)) {\n-        Node expr = getBlockExpression(thenBranch);\n-        if (!late && isPropertyAssignmentInExpression(expr)) {\n-          // Keep opportunities for CollapseProperties such as\n-          // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n-          // until CollapseProperties has been run.\n-          return n;\n-        }\n-\n-        if (cond.isNot()) {\n-          // if(!x)bar(); -> x||bar();\n-          if (isLowerPrecedence(cond.getFirstChild(), OR_PRECEDENCE) &&\n-              isLowerPrecedence(expr.getFirstChild(),\n-                  OR_PRECEDENCE)) {\n-            // It's not okay to add two sets of parentheses.\n-            return n;\n-          }\n-\n-          Node or = IR.or(\n-              cond.removeFirstChild(),\n-              expr.removeFirstChild()).srcref(n);\n-          Node newExpr = NodeUtil.newExpr(or);\n-          parent.replaceChild(n, newExpr);\n-          reportCodeChange();\n-\n-          return newExpr;\n-        }\n-\n-        // if(x)foo(); -> x&&foo();\n-        if (isLowerPrecedence(cond, AND_PRECEDENCE) &&\n-            isLowerPrecedence(expr.getFirstChild(),\n-                AND_PRECEDENCE)) {\n-          // One additional set of parentheses is worth the change even if\n-          // there is no immediate code size win. However, two extra pair of\n-          // {}, we would have to think twice. (unless we know for sure the\n-          // we can further optimize its parent.\n-          return n;\n-        }\n-\n-        n.removeChild(cond);\n-        Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n-        Node newExpr = NodeUtil.newExpr(and);\n-        parent.replaceChild(n, newExpr);\n-        reportCodeChange();\n-\n-        return newExpr;\n-      } else {\n-\n-        // Try to combine two IF-ELSE\n-        if (NodeUtil.isStatementBlock(thenBranch) &&\n-            thenBranch.hasOneChild()) {\n-          Node innerIf = thenBranch.getFirstChild();\n-\n-          if (innerIf.isIf()) {\n-            Node innerCond = innerIf.getFirstChild();\n-            Node innerThenBranch = innerCond.getNext();\n-            Node innerElseBranch = innerThenBranch.getNext();\n-\n-            if (innerElseBranch == null &&\n-                 !(isLowerPrecedence(cond, AND_PRECEDENCE) &&\n-                   isLowerPrecedence(innerCond, AND_PRECEDENCE))) {\n-              n.detachChildren();\n-              n.addChildToBack(\n-                  IR.and(\n-                      cond,\n-                      innerCond.detachFromParent())\n-                      .srcref(cond));\n-              n.addChildrenToBack(innerThenBranch.detachFromParent());\n-              reportCodeChange();\n-              // Not worth trying to fold the current IF-ELSE into && because\n-              // the inner IF-ELSE wasn't able to be folded into && anyways.\n-              return n;\n-            }\n-          }\n-        }\n-      }\n-\n-      return n;\n-    }\n-\n-    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a\n-     * peephole optimization. This should probably get moved to another pass.\n-     */\n-    tryRemoveRepeatedStatements(n);\n-\n-    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n-    // An additional set of curly braces isn't worth it.\n-    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n-      n.replaceChild(cond, cond.removeFirstChild());\n-      n.removeChild(thenBranch);\n-      n.addChildToBack(thenBranch);\n-      reportCodeChange();\n-      return n;\n-    }\n-\n-    // if(x)return 1;else return 2; -> return x?1:2;\n-    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n-      Node thenExpr = getBlockReturnExpression(thenBranch);\n-      Node elseExpr = getBlockReturnExpression(elseBranch);\n-      n.removeChild(cond);\n-      thenExpr.detachFromParent();\n-      elseExpr.detachFromParent();\n-\n-      // note - we ignore any cases with \"return;\", technically this\n-      // can be converted to \"return undefined;\" or some variant, but\n-      // that does not help code size.\n-      Node returnNode = IR.returnNode(\n-                            IR.hook(cond, thenExpr, elseExpr)\n-                                .srcref(n));\n-      parent.replaceChild(n, returnNode);\n-      reportCodeChange();\n-      return returnNode;\n-    }\n-\n-    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n-    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n-\n-    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n-      Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n-      Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n-      if (thenOp.getType() == elseOp.getType()) {\n-        // if(x)a=1;else a=2; -> a=x?1:2;\n-        if (NodeUtil.isAssignmentOp(thenOp)) {\n-          Node lhs = thenOp.getFirstChild();\n-          if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n-              // if LHS has side effects, don't proceed [since the optimization\n-              // evaluates LHS before cond]\n-              // NOTE - there are some circumstances where we can\n-              // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs) &&\n-              (!mayHaveSideEffects(cond) ||\n-                  (thenOp.isAssign() && thenOp.getFirstChild().isName()))) {\n-\n-            n.removeChild(cond);\n-            Node assignName = thenOp.removeFirstChild();\n-            Node thenExpr = thenOp.removeFirstChild();\n-            Node elseExpr = elseOp.getLastChild();\n-            elseOp.removeChild(elseExpr);\n-\n-            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n-            Node assign = new Node(thenOp.getType(), assignName, hookNode)\n-                              .srcref(thenOp);\n-            Node expr = NodeUtil.newExpr(assign);\n-            parent.replaceChild(n, expr);\n-            reportCodeChange();\n-\n-            return expr;\n-          }\n-        }\n-      }\n-      // if(x)foo();else bar(); -> x?foo():bar()\n-      n.removeChild(cond);\n-      thenOp.detachFromParent();\n-      elseOp.detachFromParent();\n-      Node expr = IR.exprResult(\n-          IR.hook(cond, thenOp, elseOp).srcref(n));\n-      parent.replaceChild(n, expr);\n-      reportCodeChange();\n-      return expr;\n-    }\n-\n-    boolean thenBranchIsVar = isVarBlock(thenBranch);\n-    boolean elseBranchIsVar = isVarBlock(elseBranch);\n-\n-    // if(x)var y=1;else y=2  ->  var y=x?1:2\n-    if (thenBranchIsVar && elseBranchIsExpressionBlock &&\n-        getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n-\n-      Node var = getBlockVar(thenBranch);\n-      Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n-\n-      Node name1 = var.getFirstChild();\n-      Node maybeName2 = elseAssign.getFirstChild();\n-\n-      if (name1.hasChildren()\n-          && maybeName2.isName()\n-          && name1.getString().equals(maybeName2.getString())) {\n-        Node thenExpr = name1.removeChildren();\n-        Node elseExpr = elseAssign.getLastChild().detachFromParent();\n-        cond.detachFromParent();\n-        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n-                            .srcref(n);\n-        var.detachFromParent();\n-        name1.addChildrenToBack(hookNode);\n-        parent.replaceChild(n, var);\n-        reportCodeChange();\n-        return var;\n-      }\n-\n-    // if(x)y=1;else var y=2  ->  var y=x?1:2\n-    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&\n-        getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n-\n-      Node var = getBlockVar(elseBranch);\n-      Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n-\n-      Node maybeName1 = thenAssign.getFirstChild();\n-      Node name2 = var.getFirstChild();\n-\n-      if (name2.hasChildren()\n-          && maybeName1.isName()\n-          && maybeName1.getString().equals(name2.getString())) {\n-        Node thenExpr = thenAssign.getLastChild().detachFromParent();\n-        Node elseExpr = name2.removeChildren();\n-        cond.detachFromParent();\n-        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n-                            .srcref(n);\n-        var.detachFromParent();\n-        name2.addChildrenToBack(hookNode);\n-        parent.replaceChild(n, var);\n-        reportCodeChange();\n-\n-        return var;\n-      }\n-    }\n-\n-    return n;\n-  }\n-\n-  /**\n-   * Try to remove duplicate statements from IF blocks. For example:\n-   *\n-   * if (a) {\n-   *   x = 1;\n-   *   return true;\n-   * } else {\n-   *   x = 2;\n-   *   return true;\n-   * }\n-   *\n-   * becomes:\n-   *\n-   * if (a) {\n-   *   x = 1;\n-   * } else {\n-   *   x = 2;\n-   * }\n-   * return true;\n-   *\n-   * @param n The IF node to examine.\n-   */\n-  private void tryRemoveRepeatedStatements(Node n) {\n-    Preconditions.checkState(n.isIf());\n-\n-    Node parent = n.getParent();\n-    if (!NodeUtil.isStatementBlock(parent)) {\n-      // If the immediate parent is something like a label, we\n-      // can't move the statement, so bail.\n-      return;\n-    }\n-\n-    Node cond = n.getFirstChild();\n-    Node trueBranch = cond.getNext();\n-    Node falseBranch = trueBranch.getNext();\n-    Preconditions.checkNotNull(trueBranch);\n-    Preconditions.checkNotNull(falseBranch);\n-\n-    while (true) {\n-      Node lastTrue = trueBranch.getLastChild();\n-      Node lastFalse = falseBranch.getLastChild();\n-      if (lastTrue == null || lastFalse == null\n-          || !areNodesEqualForInlining(lastTrue, lastFalse)) {\n-        break;\n-      }\n-      lastTrue.detachFromParent();\n-      lastFalse.detachFromParent();\n-      parent.addChildAfter(lastTrue, n);\n-      reportCodeChange();\n-    }\n-  }\n-\n-  /**\n-   * @return Whether the node is a block with a single statement that is\n-   *     an expression.\n-   */\n-  private static boolean isFoldableExpressBlock(Node n) {\n-    if (n.isBlock()) {\n-      if (n.hasOneChild()) {\n-        Node maybeExpr = n.getFirstChild();\n-        if (maybeExpr.isExprResult()) {\n-          // IE has a bug where event handlers behave differently when\n-          // their return value is used vs. when their return value is in\n-          // an EXPR_RESULT. It's pretty freaking weird. See:\n-          // http://code.google.com/p/closure-compiler/issues/detail?id=291\n-          // We try to detect this case, and not fold EXPR_RESULTs\n-          // into other expressions.\n-          if (maybeExpr.getFirstChild().isCall()) {\n-            Node calledFn = maybeExpr.getFirstChild().getFirstChild();\n-\n-            // We only have to worry about methods with an implicit 'this'\n-            // param, or this doesn't happen.\n-            if (calledFn.isGetElem()) {\n-              return false;\n-            } else if (calledFn.isGetProp() &&\n-                       calledFn.getLastChild().getString().startsWith(\"on\")) {\n-              return false;\n-            }\n-          }\n-\n-          return true;\n-        }\n-        return false;\n-      }\n-    }\n-\n-    return false;\n-  }\n-\n-  /**\n-   * @return The expression node.\n-   */\n-  private static Node getBlockExpression(Node n) {\n-    Preconditions.checkState(isFoldableExpressBlock(n));\n-    return n.getFirstChild();\n-  }\n-\n-  /**\n-   * @return Whether the node is a block with a single statement that is\n-   *     an return with or without an expression.\n-   */\n-  private static boolean isReturnBlock(Node n) {\n-    if (n.isBlock()) {\n-      if (n.hasOneChild()) {\n-        Node first = n.getFirstChild();\n-        return first.isReturn();\n-      }\n-    }\n-\n-    return false;\n-  }\n-\n-  /**\n-   * @return Whether the node is a block with a single statement that is\n-   *     an return.\n-   */\n-  private static boolean isReturnExpressBlock(Node n) {\n-    if (n.isBlock()) {\n-      if (n.hasOneChild()) {\n-        Node first = n.getFirstChild();\n-        if (first.isReturn()) {\n-          return first.hasOneChild();\n-        }\n-      }\n-    }\n-\n-    return false;\n-  }\n-\n-  /**\n-   * @return Whether the node is a single return statement.\n-   */\n-  private static boolean isReturnExpression(Node n) {\n-    if (n.isReturn()) {\n-      return n.hasOneChild();\n-    }\n-    return false;\n-  }\n-\n-  /**\n-   * @return The expression that is part of the return.\n-   */\n-  private static Node getBlockReturnExpression(Node n) {\n-    Preconditions.checkState(isReturnExpressBlock(n));\n-    return n.getFirstChild().getFirstChild();\n-  }\n-\n-  /**\n-   * @return Whether the node is a block with a single statement that is\n-   *     a VAR declaration of a single variable.\n-   */\n-  private static boolean isVarBlock(Node n) {\n-    if (n.isBlock()) {\n-      if (n.hasOneChild()) {\n-        Node first = n.getFirstChild();\n-        if (first.isVar()) {\n-          return first.hasOneChild();\n-        }\n-      }\n-    }\n-\n-    return false;\n-  }\n-\n-  /**\n-   * @return The var node.\n-   */\n-  private static Node getBlockVar(Node n) {\n-    Preconditions.checkState(isVarBlock(n));\n-    return n.getFirstChild();\n-  }\n-\n-  /**\n-   * Does a statement consume a 'dangling else'? A statement consumes\n-   * a 'dangling else' if an 'else' token following the statement\n-   * would be considered by the parser to be part of the statement.\n-   */\n-  private static boolean consumesDanglingElse(Node n) {\n-    while (true) {\n-      switch (n.getType()) {\n-        case Token.IF:\n-          if (n.getChildCount() < 3) {\n-            return true;\n-          }\n-          // This IF node has no else clause.\n-          n = n.getLastChild();\n-          continue;\n-        case Token.WITH:\n-        case Token.WHILE:\n-        case Token.FOR:\n-          n = n.getLastChild();\n-          continue;\n-        default:\n-          return false;\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Whether the node type has lower precedence than \"precedence\"\n-   */\n-  private static boolean isLowerPrecedence(Node n, final int precedence) {\n-    return NodeUtil.precedence(n.getType()) < precedence;\n-  }\n-\n-  /**\n-   * Does the expression contain a property assignment?\n-   */\n-  private static boolean isPropertyAssignmentInExpression(Node n) {\n-    Predicate<Node> isPropertyAssignmentInExpressionPredicate =\n-        new Predicate<Node>() {\n-      @Override\n-      public boolean apply(Node input) {\n-        return (input.isGetProp() &&\n-            input.getParent().isAssign());\n-      }\n-    };\n-\n-    return NodeUtil.has(n, isPropertyAssignmentInExpressionPredicate,\n-        DONT_TRAVERSE_FUNCTIONS_PREDICATE);\n-  }\n-\n-  private Node tryMinimizeCondition(Node n, boolean countLeadingNot) {\n-    n = tryMinimizeConditionOld(n);\n-    return demorganMinimizeCondition(n, countLeadingNot);\n-  }\n-\n-  /**\n-   *  Minimize the given conditional node according to De Morgan's Laws.\n-   *    !(x && !y)  ==> !x || y\n-   *    (!a || !b || !c || !d)  ==>  !(a && b && c && d)\n-   *  etc.\n-   *\n-   * @param countLeadingNot When this is false, do not count a leading\n-   *  NOT in doing the minimization. i.e. Allow minimizations such as:\n-   *    (!x || !y || z)  ==>  !(x && y && !z)\n-   *  This is useful in contexts such as IFs or HOOKs where subsequent\n-   *  optimizations can efficiently deal with leading NOTs.\n-   *\n-   * @param n The conditional node.\n-   * @return The minimized version of n, or n if no minimization was possible.\n-   */\n-  private Node demorganMinimizeCondition(Node n, boolean countLeadingNot) {\n-    MinimizedCondition minCond = MinimizedCondition.fromConditionNode(n);\n-    if (countLeadingNot ||\n-         minCond.getLength() <= minCond.getNegativeLength()) {\n-      return maybeReplaceNode(n, minCond.getNode());\n-    } else {\n-      return maybeReplaceNode(n,\n-          new Node(Token.NOT, minCond.getNegatedNode()));\n-    }\n-  }\n-\n-  private Node maybeReplaceNode(Node lhs, Node rhs) {\n-    if (lhs.isEquivalentTo(rhs)) {\n-      return lhs;\n-    }\n-    Node parent = lhs.getParent();\n-    parent.replaceChild(lhs, rhs);\n-    reportCodeChange();\n-    return rhs;\n-  }\n-\n-  /** A class that represents a minimized conditional expression.\n-   *  Depending on the context, either the original conditional, or the\n-   *  negation of the original conditional may be needed, so this class\n-   *  provides ways to access minimized versions of both of those ASTs.\n-   */\n-  static class MinimizedCondition {\n-    private final Node positive;\n-    private final Node negative;\n-\n-    private MinimizedCondition(Node p, Node n) {\n-      Preconditions.checkArgument(p.getParent() == null);\n-      Preconditions.checkArgument(n.getParent() == null);\n-      positive = p;\n-      negative = n;\n-    }\n-\n-    /** Minimize the condition at the given node.\n-     *\n-     *  @param n The conditional expression tree to minimize.\n-     *   This may be still connected to a tree and will be cloned as necessary.\n-     *  @return A MinimizedCondition object representing that tree.\n-     */\n-    static MinimizedCondition fromConditionNode(Node n) {\n-      switch (n.getType()) {\n-        case Token.NOT: {\n-          MinimizedCondition subtree = fromConditionNode(n.getFirstChild());\n-          ImmutableSet<Node> positiveAsts = ImmutableSet.of(\n-              negate(subtree.positive.cloneTree()),\n-              subtree.negative.cloneTree());\n-          ImmutableSet<Node> negativeAsts = ImmutableSet.of(\n-              negate(subtree.negative),\n-              subtree.positive);\n-          return new MinimizedCondition(\n-              Collections.min(positiveAsts, AST_LENGTH_COMPARATOR),\n-              Collections.min(negativeAsts, AST_LENGTH_COMPARATOR));\n-        }\n-        case Token.AND:\n-        case Token.OR: {\n-          int opType = n.getType();\n-          int complementType = opType == Token.AND ? Token.OR : Token.AND;\n-          MinimizedCondition leftSubtree = fromConditionNode(n.getFirstChild());\n-          MinimizedCondition rightSubtree = fromConditionNode(n.getLastChild());\n-          ImmutableSet<Node> positiveAsts = ImmutableSet.of(\n-              new Node(opType,\n-                  leftSubtree.positive.cloneTree(),\n-                  rightSubtree.positive.cloneTree()).srcref(n),\n-              negate(new Node(complementType,\n-                  leftSubtree.negative.cloneTree(),\n-                  rightSubtree.negative.cloneTree()).srcref(n)));\n-          ImmutableSet<Node> negativeAsts = ImmutableSet.of(\n-              negate(new Node(opType,\n-                  leftSubtree.positive,\n-                  rightSubtree.positive).srcref(n)),\n-              new Node(complementType,\n-                  leftSubtree.negative,\n-                  rightSubtree.negative).srcref(n));\n-          return new MinimizedCondition(\n-              Collections.min(positiveAsts, AST_LENGTH_COMPARATOR),\n-              Collections.min(negativeAsts, AST_LENGTH_COMPARATOR));\n-        }\n-        default:\n-          return new MinimizedCondition(n.cloneTree(), negate(n.cloneTree()));\n-      }\n-    }\n-\n-    Node getNode() {\n-      return positive;\n-    }\n-\n-    Node getNegatedNode() {\n-      return negative;\n-    }\n-\n-    int getLength() {\n-      return length(positive);\n-    }\n-\n-    int getNegativeLength() {\n-      return length(negative);\n-    }\n-\n-    private static Node negate(Node node) {\n-      Preconditions.checkArgument(node.getParent() == null);\n-      int complementOperator;\n-      switch (node.getType()) {\n-        default:\n-          return new Node(Token.NOT, node).srcref(node);\n-        case Token.NOT:\n-          return node.removeFirstChild();\n-        // Otherwise a binary operator with a complement.\n-        case Token.EQ:\n-          complementOperator = Token.NE;\n-          break;\n-        case Token.NE:\n-          complementOperator = Token.EQ;\n-          break;\n-        case Token.SHEQ:\n-          complementOperator = Token.SHNE;\n-          break;\n-        case Token.SHNE:\n-          complementOperator = Token.SHEQ;\n-          break;\n-      }\n-      // Clone entire tree and just change operator.\n-      node.setType(complementOperator);\n-      return node;\n-    }\n-\n-    private static final Comparator<Node> AST_LENGTH_COMPARATOR =\n-        new Comparator<Node>() {\n-      @Override\n-      public int compare(Node o1, Node o2) {\n-        return length(o1) - length(o2);\n-      }\n-    };\n-\n-    /** Return the number of characters in the textual representation of\n-     *  the given tree that will be devoted to negation, or parentheses.\n-     *  Since these are the only characters that flipping a condition\n-     *  according to De Morgan's rule can affect, these are the only ones\n-     *  we count.\n-     *  @param node The tree whose length should be checked.\n-     *  @return The number of negations and parentheses in the tree.\n-     */\n-    static int length(Node node) {\n-      int result = 0;\n-      if (node.isNot()) {\n-        result++;  // One negation needed.\n-      }\n-      for (Node n = node.getFirstChild(); n != null; n = n.getNext()) {\n-        if (NodeUtil.precedenceWithDefault(n.getType())\n-            < NodeUtil.precedenceWithDefault(node.getType())) {\n-          result += 2;  // One pair of parentheses needed.\n-        }\n-        result += length(n);\n-      }\n-      return result;\n-    }\n-\n-  }\n-\n-  /**\n-   * Try to minimize conditions expressions, as there are additional\n-   * assumptions that can be made when it is known that the final result\n-   * is a boolean.\n-   *\n-   * The following transformations are done recursively:\n-   *   !(x||y) --> !x&&!y\n-   *   !(x&&y) --> !x||!y\n-   *   !!x     --> x\n-   * Thus:\n-   *   !(x&&!y) --> !x||!!y --> !x||y\n-   *\n-   *   Returns the replacement for n, or the original if no change was made\n-   */\n-  private Node tryMinimizeConditionOld(Node n) {\n-    Node parent = n.getParent();\n-\n-    switch (n.getType()) {\n-      case Token.OR:\n-      case Token.AND: {\n-        Node left = n.getFirstChild();\n-        Node right = n.getLastChild();\n-\n-        // Because the expression is in a boolean context minimize\n-        // the children, this can't be done in the general case.\n-        left = tryMinimizeConditionOld(left);\n-        right = tryMinimizeConditionOld(right);\n-\n-        // Remove useless conditionals\n-        // Handle four cases:\n-        //   x || false --> x\n-        //   x || true  --> true\n-        //   x && true --> x\n-        //   x && false  --> false\n-        TernaryValue rightVal = NodeUtil.getPureBooleanValue(right);\n-        if (NodeUtil.getPureBooleanValue(right) != TernaryValue.UNKNOWN) {\n-          int type = n.getType();\n-          Node replacement = null;\n-          boolean rval = rightVal.toBoolean(true);\n-\n-          // (x || FALSE) => x\n-          // (x && TRUE) => x\n-          if (type == Token.OR && !rval ||\n-              type == Token.AND && rval) {\n-            replacement = left;\n-          } else if (!mayHaveSideEffects(left)) {\n-            replacement = right;\n-          }\n-\n-          if (replacement != null) {\n-            n.detachChildren();\n-            parent.replaceChild(n, replacement);\n-            reportCodeChange();\n-            return replacement;\n-          }\n-        }\n-        return n;\n-      }\n-\n-      case Token.HOOK: {\n-        Node condition = n.getFirstChild();\n-        Node trueNode = n.getFirstChild().getNext();\n-        Node falseNode = n.getLastChild();\n-\n-        // Because the expression is in a boolean context minimize\n-        // the result children, this can't be done in the general case.\n-        // The condition is handled in the general case in #optimizeSubtree\n-        trueNode = tryMinimizeConditionOld(trueNode);\n-        falseNode = tryMinimizeConditionOld(falseNode);\n-\n-        // Handle four cases:\n-        //   x ? true : false --> x\n-        //   x ? false : true --> !x\n-        //   x ? true : y     --> x || y\n-        //   x ? y : false    --> x && y\n-        Node replacement = null;\n-        TernaryValue trueNodeVal = NodeUtil.getPureBooleanValue(trueNode);\n-        TernaryValue falseNodeVal = NodeUtil.getPureBooleanValue(falseNode);\n-        if (trueNodeVal == TernaryValue.TRUE\n-            && falseNodeVal == TernaryValue.FALSE) {\n-          // Remove useless conditionals, keep the condition\n-          condition.detachFromParent();\n-          replacement = condition;\n-        } else if (trueNodeVal == TernaryValue.FALSE\n-            && falseNodeVal == TernaryValue.TRUE) {\n-          // Remove useless conditionals, keep the condition\n-          condition.detachFromParent();\n-          replacement = IR.not(condition);\n-        } else if (trueNodeVal == TernaryValue.TRUE) {\n-          // Remove useless true case.\n-          n.detachChildren();\n-          replacement = IR.or(condition, falseNode);\n-        } else if (falseNodeVal == TernaryValue.FALSE) {\n-          // Remove useless false case\n-          n.detachChildren();\n-          replacement = IR.and(condition, trueNode);\n-        }\n-\n-        if (replacement != null) {\n-          parent.replaceChild(n, replacement);\n-          n = replacement;\n-          reportCodeChange();\n-        }\n-\n-        return n;\n-      }\n-\n-      default:\n-        // while(true) --> while(1)\n-        TernaryValue nVal = NodeUtil.getPureBooleanValue(n);\n-        if (nVal != TernaryValue.UNKNOWN) {\n-          boolean result = nVal.toBoolean(true);\n-          int equivalentResult = result ? 1 : 0;\n-          return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n-        }\n-        // We can't do anything else currently.\n-        return n;\n-    }\n-  }\n-\n-  /**\n-   * Replaces a node with a number node if the new number node is not equivalent\n-   * to the current node.\n-   *\n-   * Returns the replacement for n if it was replaced, otherwise returns n.\n-   */\n-  private Node maybeReplaceChildWithNumber(Node n, Node parent, int num) {\n-    Node newNode = IR.number(num);\n-    if (!newNode.isEquivalentTo(n)) {\n-      parent.replaceChild(n, newNode);\n-      reportCodeChange();\n-\n-      return newNode;\n-    }\n-\n-    return n;\n-  }\n \n   private static final ImmutableSet<String> STANDARD_OBJECT_CONSTRUCTORS =\n     // String, Number, and Boolean functions return non-object types, whereas\n--- a/src/com/google/javascript/jscomp/StatementFusion.java\n+++ b/src/com/google/javascript/jscomp/StatementFusion.java\n  * extra () around. Once we have only one statement in a block, we can then\n  * eliminate a pair of {}'s. Further more, we can also fold a single\n  * statement IF into && or create further opportunities for all the other\n- * goodies in {@link PeepholeSubstituteAlternateSyntax}.\n+ * goodies in {@link PeepholeMinimizeConditions}.\n  *\n  */\n class StatementFusion extends AbstractPeepholeOptimization {\n--- a/test/com/google/javascript/jscomp/CreateSyntheticBlocksTest.java\n+++ b/test/com/google/javascript/jscomp/CreateSyntheticBlocksTest.java\n \n         new PeepholeOptimizationsPass(compiler,\n             new PeepholeRemoveDeadCode(),\n-            new PeepholeSubstituteAlternateSyntax(true),\n+            new PeepholeMinimizeConditions(true),\n             new PeepholeFoldConstants(true))\n             .process(externs, js);\n         new MinimizeExitPoints(compiler).process(externs, js);\n--- a/test/com/google/javascript/jscomp/MultiPassTest.java\n+++ b/test/com/google/javascript/jscomp/MultiPassTest.java\n     enableNormalize();\n   }\n \n+  @Override\n   protected CompilerPass getProcessor(Compiler compiler) {\n     PhaseOptimizer po = new PhaseOptimizer(compiler, null, null);\n     po.consume(passes);\n         protected CompilerPass create(AbstractCompiler compiler) {\n           final boolean late = false;\n           return new PeepholeOptimizationsPass(compiler,\n+              new PeepholeMinimizeConditions(late),\n               new PeepholeSubstituteAlternateSyntax(late),\n               new PeepholeReplaceKnownMethods(late),\n               new PeepholeRemoveDeadCode(),\n--- a/test/com/google/javascript/jscomp/PeepholeIntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeIntegrationTest.java\n   public CompilerPass getProcessor(final Compiler compiler) {\n     PeepholeOptimizationsPass peepholePass =\n       new PeepholeOptimizationsPass(compiler,\n+        new PeepholeMinimizeConditions(late),\n         new PeepholeSubstituteAlternateSyntax(late),\n         new PeepholeRemoveDeadCode(),\n         new PeepholeFoldConstants(late)\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/PeepholeMinimizeConditionsTest.java\n+/*\n+ * Copyright 2004 The Closure Compiler Authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.javascript.jscomp.PeepholeMinimizeConditions.MinimizedCondition;\n+import com.google.javascript.rhino.Node;\n+\n+/**\n+ * Tests for {@link PeepholeMinimizeConditions} in isolation.\n+ * Tests for the interaction of multiple peephole passes are in\n+ * PeepholeIntegrationTest.\n+ */\n+public class PeepholeMinimizeConditionsTest extends CompilerTestCase {\n+\n+  private boolean late = true;\n+\n+  // TODO(user): Remove this when we no longer need to do string comparison.\n+  private PeepholeMinimizeConditionsTest(boolean compareAsTree) {\n+    super(\"\", compareAsTree);\n+  }\n+\n+  public PeepholeMinimizeConditionsTest() {\n+    super(\"\");\n+  }\n+\n+  @Override\n+  public void setUp() throws Exception {\n+    late = true;\n+    super.setUp();\n+    enableLineNumberCheck(true);\n+    disableNormalize();\n+  }\n+\n+  @Override\n+  public CompilerPass getProcessor(final Compiler compiler) {\n+    PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass(\n+        compiler, new PeepholeMinimizeConditions(late));\n+    peepholePass.setRetraverseOnChange(false);\n+    return peepholePass;\n+  }\n+\n+  @Override\n+  protected int getNumRepetitions() {\n+    return 1;\n+  }\n+\n+  private void foldSame(String js) {\n+    testSame(js);\n+  }\n+\n+  private void fold(String js, String expected) {\n+    test(js, expected);\n+  }\n+\n+  void assertResultString(String js, String expected) {\n+    assertResultString(js, expected, false);\n+  }\n+\n+  // TODO(user): This is same as fold() except it uses string comparison. Any\n+  // test that needs tell us where a folding is constructing an invalid AST.\n+  void assertResultString(String js, String expected, boolean normalize) {\n+    PeepholeMinimizeConditionsTest scTest\n+        = new PeepholeMinimizeConditionsTest(false);\n+\n+    if (normalize) {\n+      scTest.enableNormalize();\n+    } else {\n+      scTest.disableNormalize();\n+    }\n+\n+    scTest.test(js, expected);\n+  }\n+\n+  /** Check that removing blocks with 1 child works */\n+  public void testFoldOneChildBlocks() {\n+    late = false;\n+    fold(\"function f(){if(x)a();x=3}\",\n+        \"function f(){x&&a();x=3}\");\n+    fold(\"function f(){if(x){a()}x=3}\",\n+        \"function f(){x&&a();x=3}\");\n+    fold(\"function f(){if(x){return 3}}\",\n+        \"function f(){if(x)return 3}\");\n+    fold(\"function f(){if(x){a()}}\",\n+        \"function f(){x&&a()}\");\n+    fold(\"function f(){if(x){throw 1}}\", \"function f(){if(x)throw 1;}\");\n+\n+    // Try it out with functions\n+    fold(\"function f(){if(x){foo()}}\", \"function f(){x&&foo()}\");\n+    fold(\"function f(){if(x){foo()}else{bar()}}\",\n+         \"function f(){x?foo():bar()}\");\n+\n+    // Try it out with properties and methods\n+    fold(\"function f(){if(x){a.b=1}}\", \"function f(){if(x)a.b=1}\");\n+    fold(\"function f(){if(x){a.b*=1}}\", \"function f(){x&&(a.b*=1)}\");\n+    fold(\"function f(){if(x){a.b+=1}}\", \"function f(){x&&(a.b+=1)}\");\n+    fold(\"function f(){if(x){++a.b}}\", \"function f(){x&&++a.b}\");\n+    fold(\"function f(){if(x){a.foo()}}\", \"function f(){x&&a.foo()}\");\n+\n+    // Try it out with throw/catch/finally [which should not change]\n+    fold(\"function f(){try{foo()}catch(e){bar(e)}finally{baz()}}\",\n+         \"function f(){try{foo()}catch(e){bar(e)}finally{baz()}}\");\n+\n+    // Try it out with switch statements\n+    fold(\"function f(){switch(x){case 1:break}}\",\n+         \"function f(){switch(x){case 1:break}}\");\n+\n+    // Do while loops stay in a block if that's where they started\n+    fold(\"function f(){if(e1){do foo();while(e2)}else foo2()}\",\n+         \"function f(){if(e1){do foo();while(e2)}else foo2()}\");\n+    // Test an obscure case with do and while\n+    fold(\"if(x){do{foo()}while(y)}else bar()\",\n+         \"if(x){do foo();while(y)}else bar()\");\n+\n+    // Play with nested IFs\n+    fold(\"function f(){if(x){if(y)foo()}}\",\n+         \"function f(){x&&y&&foo()}\");\n+    fold(\"function f(){if(x){if(y)foo();else bar()}}\",\n+         \"function f(){x&&(y?foo():bar())}\");\n+    fold(\"function f(){if(x){if(y)foo()}else bar()}\",\n+         \"function f(){x?y&&foo():bar()}\");\n+    fold(\"function f(){if(x){if(y)foo();else bar()}else{baz()}}\",\n+         \"function f(){x?y?foo():bar():baz()}\");\n+\n+    fold(\"if(e1){while(e2){if(e3){foo()}}}else{bar()}\",\n+         \"if(e1)while(e2)e3&&foo();else bar()\");\n+\n+    fold(\"if(e1){with(e2){if(e3){foo()}}}else{bar()}\",\n+         \"if(e1)with(e2)e3&&foo();else bar()\");\n+\n+    fold(\"if(a||b){if(c||d){var x;}}\", \"if(a||b)if(c||d)var x\");\n+    fold(\"if(x){ if(y){var x;}else{var z;} }\",\n+         \"if(x)if(y)var x;else var z\");\n+\n+    // NOTE - technically we can remove the blocks since both the parent\n+    // and child have elses. But we don't since it causes ambiguities in\n+    // some cases where not all descendent ifs having elses\n+    fold(\"if(x){ if(y){var x;}else{var z;} }else{var w}\",\n+         \"if(x)if(y)var x;else var z;else var w\");\n+    fold(\"if (x) {var x;}else { if (y) { var y;} }\",\n+         \"if(x)var x;else if(y)var y\");\n+\n+    // Here's some of the ambiguous cases\n+    fold(\"if(a){if(b){f1();f2();}else if(c){f3();}}else {if(d){f4();}}\",\n+         \"if(a)if(b){f1();f2()}else c&&f3();else d&&f4()\");\n+\n+    fold(\"function f(){foo()}\", \"function f(){foo()}\");\n+    fold(\"switch(x){case y: foo()}\", \"switch(x){case y:foo()}\");\n+    fold(\"try{foo()}catch(ex){bar()}finally{baz()}\",\n+         \"try{foo()}catch(ex){bar()}finally{baz()}\");\n+  }\n+\n+  /** Try to minimize returns */\n+  public void testFoldReturns() {\n+    fold(\"function f(){if(x)return 1;else return 2}\",\n+         \"function f(){return x?1:2}\");\n+    fold(\"function f(){if(x)return 1;return 2}\",\n+         \"function f(){return x?1:2}\");\n+    fold(\"function f(){if(x)return;return 2}\",\n+         \"function f(){return x?void 0:2}\");\n+    fold(\"function f(){if(x)return 1+x;else return 2-x}\",\n+         \"function f(){return x?1+x:2-x}\");\n+    fold(\"function f(){if(x)return 1+x;return 2-x}\",\n+         \"function f(){return x?1+x:2-x}\");\n+    fold(\"function f(){if(x)return y += 1;else return y += 2}\",\n+         \"function f(){return x?(y+=1):(y+=2)}\");\n+\n+    fold(\"function f(){if(x)return;else return 2-x}\",\n+         \"function f(){if(x);else return 2-x}\");\n+    fold(\"function f(){if(x)return;return 2-x}\",\n+         \"function f(){return x?void 0:2-x}\");\n+    fold(\"function f(){if(x)return x;else return}\",\n+         \"function f(){if(x)return x;{}}\");\n+    fold(\"function f(){if(x)return x;return}\",\n+         \"function f(){if(x)return x}\");\n+\n+    foldSame(\"function f(){for(var x in y) { return x.y; } return k}\");\n+  }\n+\n+  public void testCombineIfs1() {\n+    fold(\"function f() {if (x) return 1; if (y) return 1}\",\n+         \"function f() {if (x||y) return 1;}\");\n+    fold(\"function f() {if (x) return 1; if (y) foo(); else return 1}\",\n+         \"function f() {if ((!x)&&y) foo(); else return 1;}\");\n+  }\n+\n+  public void testCombineIfs2() {\n+    // combinable but not yet done\n+    foldSame(\"function f() {if (x) throw 1; if (y) throw 1}\");\n+    // Can't combine, side-effect\n+    fold(\"function f(){ if (x) g(); if (y) g() }\",\n+         \"function f(){ x&&g(); y&&g() }\");\n+    // Can't combine, side-effect\n+    fold(\"function f(){ if (x) y = 0; if (y) y = 0; }\",\n+         \"function f(){ x&&(y = 0); y&&(y = 0); }\");\n+  }\n+\n+  public void testCombineIfs3() {\n+    foldSame(\"function f() {if (x) return 1; if (y) {g();f()}}\");\n+  }\n+\n+\n+  /** Try to minimize assignments */\n+  public void testFoldAssignments() {\n+    fold(\"function f(){if(x)y=3;else y=4;}\", \"function f(){y=x?3:4}\");\n+    fold(\"function f(){if(x)y=1+a;else y=2+a;}\", \"function f(){y=x?1+a:2+a}\");\n+\n+    // and operation assignments\n+    fold(\"function f(){if(x)y+=1;else y+=2;}\", \"function f(){y+=x?1:2}\");\n+    fold(\"function f(){if(x)y-=1;else y-=2;}\", \"function f(){y-=x?1:2}\");\n+    fold(\"function f(){if(x)y%=1;else y%=2;}\", \"function f(){y%=x?1:2}\");\n+    fold(\"function f(){if(x)y|=1;else y|=2;}\", \"function f(){y|=x?1:2}\");\n+\n+    // sanity check, don't fold if the 2 ops don't match\n+    foldSame(\"function f(){x ? y-=1 : y+=2}\");\n+\n+    // sanity check, don't fold if the 2 LHS don't match\n+    foldSame(\"function f(){x ? y-=1 : z-=1}\");\n+\n+    // sanity check, don't fold if there are potential effects\n+    foldSame(\"function f(){x ? y().a=3 : y().a=4}\");\n+  }\n+\n+  public void testRemoveDuplicateStatements() {\n+    fold(\"if (a) { x = 1; x++ } else { x = 2; x++ }\",\n+         \"x=(a) ? 1 : 2; x++\");\n+    fold(\"if (a) { x = 1; x++; y += 1; z = pi; }\" +\n+         \" else  { x = 2; x++; y += 1; z = pi; }\",\n+         \"x=(a) ? 1 : 2; x++; y += 1; z = pi;\");\n+    fold(\"function z() {\" +\n+         \"if (a) { foo(); return !0 } else { goo(); return !0 }\" +\n+         \"}\",\n+         \"function z() {(a) ? foo() : goo(); return !0}\");\n+    fold(\"function z() {if (a) { foo(); x = true; return true \" +\n+         \"} else { goo(); x = true; return true }}\",\n+         \"function z() {(a) ? foo() : goo(); x = true; return true}\");\n+\n+    fold(\"function z() {\" +\n+         \"  if (a) { bar(); foo(); return true }\" +\n+         \"    else { bar(); goo(); return true }\" +\n+         \"}\",\n+         \"function z() {\" +\n+         \"  if (a) { bar(); foo(); }\" +\n+         \"    else { bar(); goo(); }\" +\n+         \"  return true;\" +\n+         \"}\");\n+  }\n+\n+  public void testNotCond() {\n+    fold(\"function f(){if(!x)foo()}\", \"function f(){x||foo()}\");\n+    fold(\"function f(){if(!x)b=1}\", \"function f(){x||(b=1)}\");\n+    fold(\"if(!x)z=1;else if(y)z=2\", \"if(x){y&&(z=2);}else{z=1;}\");\n+    fold(\"if(x)y&&(z=2);else z=1;\", \"x ? y&&(z=2) : z=1\");\n+    foldSame(\"function f(){if(!(x=1))a.b=1}\");\n+  }\n+\n+  public void testAndParenthesesCount() {\n+    fold(\"function f(){if(x||y)a.foo()}\", \"function f(){(x||y)&&a.foo()}\");\n+    fold(\"function f(){if(x.a)x.a=0}\",\n+         \"function f(){x.a&&(x.a=0)}\");\n+    foldSame(\"function f(){if(x()||y()){x()||y()}}\");\n+  }\n+\n+  public void testFoldLogicalOpStringCompare() {\n+    // side-effects\n+    // There is two way to parse two &&'s and both are correct.\n+    assertResultString(\"if(foo() && false) z()\", \"foo()&&0&&z()\");\n+  }\n+\n+  public void testFoldNot() {\n+    fold(\"while(!(x==y)){a=b;}\" , \"while(x!=y){a=b;}\");\n+    fold(\"while(!(x!=y)){a=b;}\" , \"while(x==y){a=b;}\");\n+    fold(\"while(!(x===y)){a=b;}\", \"while(x!==y){a=b;}\");\n+    fold(\"while(!(x!==y)){a=b;}\", \"while(x===y){a=b;}\");\n+    // Because !(x<NaN) != x>=NaN don't fold < and > cases.\n+    foldSame(\"while(!(x>y)){a=b;}\");\n+    foldSame(\"while(!(x>=y)){a=b;}\");\n+    foldSame(\"while(!(x<y)){a=b;}\");\n+    foldSame(\"while(!(x<=y)){a=b;}\");\n+    foldSame(\"while(!(x<=NaN)){a=b;}\");\n+\n+    // NOT forces a boolean context\n+    fold(\"x = !(y() && true)\", \"x = !y()\");\n+    // This will be further optimized by PeepholeFoldConstants.\n+    fold(\"x = !true\", \"x = !1\");\n+  }\n+\n+  public void testMinimizeExprCondition() {\n+    fold(\"(x ? true : false) && y()\", \"x&&y()\");\n+    fold(\"(x ? false : true) && y()\", \"(!x)&&y()\");\n+    fold(\"(x ? true : y) && y()\", \"(x || y)&&y()\");\n+    fold(\"(x ? y : false) && y()\", \"(x && y)&&y()\");\n+    fold(\"(x && true) && y()\", \"x && y()\");\n+    fold(\"(x && false) && y()\", \"0&&y()\");\n+    fold(\"(x || true) && y()\", \"1&&y()\");\n+    fold(\"(x || false) && y()\", \"x&&y()\");\n+  }\n+\n+  public void testMinimizeWhileCondition() {\n+    // This test uses constant folding logic, so is only here for completeness.\n+    fold(\"while(!!true) foo()\", \"while(1) foo()\");\n+    // These test tryMinimizeCondition\n+    fold(\"while(!!x) foo()\", \"while(x) foo()\");\n+    fold(\"while(!(!x&&!y)) foo()\", \"while(x||y) foo()\");\n+    fold(\"while(x||!!y) foo()\", \"while(x||y) foo()\");\n+    fold(\"while(!(!!x&&y)) foo()\", \"while(!x||!y) foo()\");\n+    fold(\"while(!(!x&&y)) foo()\", \"while(x||!y) foo()\");\n+    fold(\"while(!(x||!y)) foo()\", \"while(!x&&y) foo()\");\n+    fold(\"while(!(x||y)) foo()\", \"while(!x&&!y) foo()\");\n+    fold(\"while(!(!x||y-z)) foo()\", \"while(x&&!(y-z)) foo()\");\n+    fold(\"while(!(!(x/y)||z+w)) foo()\", \"while(x/y&&!(z+w)) foo()\");\n+    foldSame(\"while(!(x+y||z)) foo()\");\n+    foldSame(\"while(!(x&&y*z)) foo()\");\n+    fold(\"while(!(!!x&&y)) foo()\", \"while(!x||!y) foo()\");\n+    fold(\"while(x&&!0) foo()\", \"while(x) foo()\");\n+    fold(\"while(x||!1) foo()\", \"while(x) foo()\");\n+    fold(\"while(!((x,y)&&z)) foo()\", \"while(!(x,y)||!z) foo()\");\n+  }\n+\n+  public void testMinimizeDemorganRemoveLeadingNot() {\n+    fold(\"if(!(!a||!b)&&c) foo()\", \"((a&&b)&&c)&&foo()\");\n+    fold(\"if(!(x&&y)) foo()\", \"x&&y||foo()\");\n+    fold(\"if(!(x||y)) foo()\", \"(x||y)||foo()\");\n+  }\n+\n+  public void testMinimizeDemorgan1() {\n+    fold(\"if(!a&&!b)foo()\", \"(a||b)||foo()\");\n+  }\n+\n+  public void testMinimizeDemorgan3() {\n+    fold(\"if((!a||!b)&&(c||d)) foo()\", \"(a&&b||!c&&!d)||foo()\");\n+  }\n+\n+  public void testMinimizeDemorgan5() {\n+    fold(\"if((!a||!b)&&c) foo()\", \"(a&&b||!c)||foo()\");\n+  }\n+\n+  public void testMinimizeDemorgan11() {\n+    fold(\"if (x && (y===2 || !f()) && (y===3 || !h())) foo()\",\n+         \"(!x || y!==2 && f() || y!==3 && h()) || foo()\");\n+  }\n+\n+  public void testMinimizeDemorgan20() {\n+    fold(\"if (0===c && (2===a || 1===a)) f(); else g()\",\n+         \"if (0!==c || 2!==a && 1!==a) g(); else f()\");\n+    fold(\"if (0!==c || 2!==a && 1!==a) g(); else f()\",\n+         \"(0!==c || 2!==a && 1!==a) ? g() : f()\");\n+  }\n+\n+  public void testSwapHook() {\n+    fold(\"!x ? foo() : bar()\",\n+         \"x ? bar() : foo()\");\n+  }\n+\n+  public void testMinimizeDemorgan21() {\n+    fold(\"if (0===c && (2===a || 1===a)) f()\",\n+         \"(0!==c || 2!==a && 1!==a) || f()\");\n+  }\n+\n+  public void testMinimizeAndOr1() {\n+    fold(\"if ((!a || !b) && (d || e)) f()\", \"(a&&b || !d&&!e) || f()\");\n+  }\n+\n+  public Node parseExpr(String input) {\n+    Node block = parseExpectedJs(input);\n+    Node script = block.getFirstChild();\n+    Node exprResult = script.getFirstChild();\n+    return exprResult.getFirstChild();\n+  }\n+\n+  public void minimizeCond(String input, String positive, String negative) {\n+    Node inputNode = parseExpr(input);\n+    MinimizedCondition result = PeepholeMinimizeConditions\n+        .MinimizedCondition.fromConditionNode(inputNode);\n+    Node positiveNode = parseExpr(positive);\n+    Node negativeNode = parseExpr(negative);\n+    if (!result.getNode().isEquivalentTo(positiveNode)) {\n+      fail(\"Not equal:\\n\" + result.getNode().toStringTree()\n+          + \"and:\\n\" + positiveNode.toStringTree());\n+    }\n+    if (!result.getNegatedNode().isEquivalentTo(negativeNode)) {\n+      fail(\"Not equal:\\n\" + result.getNegatedNode().toStringTree()\n+          + \"and:\\n\" + negativeNode.toStringTree());\n+    }\n+  }\n+\n+  public void testTryMinimizeCondition1() {\n+    minimizeCond(\"x\", \"x\", \"!x\");\n+  }\n+\n+  public void testTryMinimizeCondition2() {\n+    minimizeCond(\"!x\", \"!x\", \"x\");\n+  }\n+\n+  public void testTryMinimizeCondition3() {\n+    minimizeCond(\"x || y\", \"x || y\", \"!x && !y\");\n+  }\n+\n+  public void testTryMinimizeCondition4() {\n+    minimizeCond(\"x && y\", \"x && y\", \"!x || !y\");\n+  }\n+\n+  public void testTryMinimizeCondition5() {\n+    minimizeCond(\"w && x && y && z\", \"w && x && y && z\", \"!(w && x && y && z)\");\n+  }\n+\n+  public void testMinimizeCondDemorgan() {\n+    minimizeCond(\"x && (y===2 || !f()) && (y===3 || !h())\",\n+        \"x && !((y!==2 && f()) || (y!==3 && h()))\",\n+        \"!x || (y!==2 && f()) || (y!==3 && h())\");\n+  }\n+\n+  public void testMinimizeForCondition() {\n+    // This test uses constant folding logic, so is only here for completeness.\n+    // These could be simplified to \"for(;;) ...\"\n+    fold(\"for(;!!true;) foo()\", \"for(;1;) foo()\");\n+    // Don't bother with FOR inits as there are normalized out.\n+    fold(\"for(!!true;;) foo()\", \"for(!0;;) foo()\");\n+\n+    // These test tryMinimizeCondition\n+    fold(\"for(;!!x;) foo()\", \"for(;x;) foo()\");\n+\n+    // sanity check\n+    foldSame(\"for(a in b) foo()\");\n+    foldSame(\"for(a in {}) foo()\");\n+    foldSame(\"for(a in []) foo()\");\n+    fold(\"for(a in !!true) foo()\", \"for(a in !0) foo()\");\n+  }\n+\n+  public void testMinimizeCondition_example1() {\n+    // Based on a real failing code sample.\n+    fold(\"if(!!(f() > 20)) {foo();foo()}\", \"if(f() > 20){foo();foo()}\");\n+  }\n+\n+  public void testFoldLoopBreakLate() {\n+    late = true;\n+    fold(\"for(;;) if (a) break\", \"for(;!a;);\");\n+    foldSame(\"for(;;) if (a) { f(); break }\");\n+    fold(\"for(;;) if (a) break; else f()\", \"for(;!a;) { { f(); } }\");\n+    fold(\"for(;a;) if (b) break\", \"for(;a && !b;);\");\n+    fold(\"for(;a;) { if (b) break; if (c) break; }\",\n+         \"for(;(a && !b);) if (c) break;\");\n+    fold(\"for(;(a && !b);) if (c) break;\", \"for(;(a && !b) && !c;);\");\n+\n+    // 'while' is normalized to 'for'\n+    enableNormalize(true);\n+    fold(\"while(true) if (a) break\", \"for(;1&&!a;);\");\n+  }\n+\n+  public void testFoldLoopBreakEarly() {\n+    late = false;\n+    foldSame(\"for(;;) if (a) break\");\n+    foldSame(\"for(;;) if (a) { f(); break }\");\n+    foldSame(\"for(;;) if (a) break; else f()\");\n+    foldSame(\"for(;a;) if (b) break\");\n+    foldSame(\"for(;a;) { if (b) break; if (c) break; }\");\n+\n+    foldSame(\"while(1) if (a) break\");\n+    enableNormalize(true);\n+    foldSame(\"while(1) if (a) break\");\n+  }\n+\n+  public void testFoldConditionalVarDeclaration() {\n+    fold(\"if(x) var y=1;else y=2\", \"var y=x?1:2\");\n+    fold(\"if(x) y=1;else var y=2\", \"var y=x?1:2\");\n+\n+    foldSame(\"if(x) var y = 1; z = 2\");\n+    foldSame(\"if(x||y) y = 1; var z = 2\");\n+\n+    foldSame(\"if(x) { var y = 1; print(y)} else y = 2 \");\n+    foldSame(\"if(x) var y = 1; else {y = 2; print(y)}\");\n+  }\n+\n+  public void testFoldIfWithLowerOperatorsInside() {\n+    fold(\"if (x + (y=5)) z && (w,z);\",\n+         \"x + (y=5) && z && (w,z)\");\n+    fold(\"if (!(x+(y=5))) z && (w,z);\",\n+         \"x + (y=5) || z && (w,z)\");\n+    fold(\"if (x + (y=5)) if (z && (w,z)) for(;;) foo();\",\n+         \"if (x + (y=5) && z && (w,z)) for(;;) foo();\");\n+  }\n+\n+  public void testFoldReturnResult() {\n+    foldSame(\"function f(){return false;}\");\n+    foldSame(\"function f(){return null;}\");\n+    fold(\"function f(){return void 0;}\",\n+         \"function f(){return}\");\n+    fold(\"function f(){return;}\",\n+         \"function f(){}\");\n+    foldSame(\"function f(){return void foo();}\");\n+    fold(\"function f(){return undefined;}\",\n+         \"function f(){return}\");\n+    fold(\"function f(){if(a()){return undefined;}}\",\n+         \"function f(){if(a()){return}}\");\n+  }\n+\n+  public void testSubsituteReturn() {\n+\n+    fold(\"function f() { while(x) { return }}\",\n+         \"function f() { while(x) { break }}\");\n+\n+    foldSame(\"function f() { while(x) { return 5 } }\");\n+\n+    foldSame(\"function f() { a: { return 5 } }\");\n+\n+    fold(\"function f() { while(x) { return 5}  return 5}\",\n+         \"function f() { while(x) { break }    return 5}\");\n+\n+    fold(\"function f() { while(x) { return x}  return x}\",\n+         \"function f() { while(x) { break }    return x}\");\n+\n+    fold(\"function f() { while(x) { if (y) { return }}}\",\n+         \"function f() { while(x) { if (y) { break  }}}\");\n+\n+    fold(\"function f() { while(x) { if (y) { return }} return}\",\n+         \"function f() { while(x) { if (y) { break  }}}\");\n+\n+    fold(\"function f() { while(x) { if (y) { return 5 }} return 5}\",\n+         \"function f() { while(x) { if (y) { break    }} return 5}\");\n+\n+    // It doesn't matter if x is changed between them. We are still returning\n+    // x at whatever x value current holds. The whole x = 1 is skipped.\n+    fold(\"function f() { while(x) { if (y) { return x } x = 1} return x}\",\n+         \"function f() { while(x) { if (y) { break    } x = 1} return x}\");\n+\n+    // RemoveUnreachableCode would take care of the useless breaks.\n+    fold(\"function f() { while(x) { if (y) { return x } return x} return x}\",\n+         \"function f() { while(x) { if (y) {} break }return x}\");\n+\n+    // A break here only breaks out of the inner loop.\n+    foldSame(\"function f() { while(x) { while (y) { return } } }\");\n+\n+    foldSame(\"function f() { while(1) { return 7}  return 5}\");\n+\n+\n+    foldSame(\"function f() {\" +\n+             \"  try { while(x) {return f()}} catch (e) { } return f()}\");\n+\n+    foldSame(\"function f() {\" +\n+             \"  try { while(x) {return f()}} finally {alert(1)} return f()}\");\n+\n+\n+    // Both returns has the same handler\n+    fold(\"function f() {\" +\n+         \"  try { while(x) { return f() } return f() } catch (e) { } }\",\n+         \"function f() {\" +\n+         \"  try { while(x) { break } return f() } catch (e) { } }\");\n+\n+    // We can't fold this because it'll change the order of when foo is called.\n+    foldSame(\"function f() {\" +\n+             \"  try { while(x) { return foo() } } finally { alert(1) } \"  +\n+             \"  return foo()}\");\n+\n+    // This is fine, we have no side effect in the return value.\n+    fold(\"function f() {\" +\n+         \"  try { while(x) { return 1 } } finally { alert(1) } return 1}\",\n+         \"function f() {\" +\n+         \"  try { while(x) { break    } } finally { alert(1) } return 1}\"\n+         );\n+\n+    foldSame(\"function f() { try{ return a } finally { a = 2 } return a; }\");\n+\n+    fold(\n+      \"function f() { switch(a){ case 1: return a; default: g();} return a;}\",\n+      \"function f() { switch(a){ case 1: break; default: g();} return a; }\");\n+  }\n+\n+  public void testSubsituteBreakForThrow() {\n+\n+    foldSame(\"function f() { while(x) { throw Error }}\");\n+\n+    fold(\"function f() { while(x) { throw Error } throw Error }\",\n+         \"function f() { while(x) { break } throw Error}\");\n+    foldSame(\"function f() { while(x) { throw Error(1) } throw Error(2)}\");\n+    foldSame(\"function f() { while(x) { throw Error(1) } return Error(2)}\");\n+\n+    foldSame(\"function f() { while(x) { throw 5 } }\");\n+\n+    foldSame(\"function f() { a: { throw 5 } }\");\n+\n+    fold(\"function f() { while(x) { throw 5}  throw 5}\",\n+         \"function f() { while(x) { break }   throw 5}\");\n+\n+    fold(\"function f() { while(x) { throw x}  throw x}\",\n+         \"function f() { while(x) { break }   throw x}\");\n+\n+    foldSame(\"function f() { while(x) { if (y) { throw Error }}}\");\n+\n+    fold(\"function f() { while(x) { if (y) { throw Error }} throw Error}\",\n+         \"function f() { while(x) { if (y) { break }} throw Error}\");\n+\n+    fold(\"function f() { while(x) { if (y) { throw 5 }} throw 5}\",\n+         \"function f() { while(x) { if (y) { break    }} throw 5}\");\n+\n+    // It doesn't matter if x is changed between them. We are still throwing\n+    // x at whatever x value current holds. The whole x = 1 is skipped.\n+    fold(\"function f() { while(x) { if (y) { throw x } x = 1} throw x}\",\n+         \"function f() { while(x) { if (y) { break    } x = 1} throw x}\");\n+\n+    // RemoveUnreachableCode would take care of the useless breaks.\n+    fold(\"function f() { while(x) { if (y) { throw x } throw x} throw x}\",\n+         \"function f() { while(x) { if (y) {} break }throw x}\");\n+\n+    // A break here only breaks out of the inner loop.\n+    foldSame(\"function f() { while(x) { while (y) { throw Error } } }\");\n+\n+    foldSame(\"function f() { while(1) { throw 7}  throw 5}\");\n+\n+\n+    foldSame(\"function f() {\" +\n+             \"  try { while(x) {throw f()}} catch (e) { } throw f()}\");\n+\n+    foldSame(\"function f() {\" +\n+             \"  try { while(x) {throw f()}} finally {alert(1)} throw f()}\");\n+\n+\n+    // Both throws has the same handler\n+    fold(\"function f() {\" +\n+         \"  try { while(x) { throw f() } throw f() } catch (e) { } }\",\n+         \"function f() {\" +\n+         \"  try { while(x) { break } throw f() } catch (e) { } }\");\n+\n+    // We can't fold this because it'll change the order of when foo is called.\n+    foldSame(\"function f() {\" +\n+             \"  try { while(x) { throw foo() } } finally { alert(1) } \"  +\n+             \"  throw foo()}\");\n+\n+    // This is fine, we have no side effect in the throw value.\n+    fold(\"function f() {\" +\n+         \"  try { while(x) { throw 1 } } finally { alert(1) } throw 1}\",\n+         \"function f() {\" +\n+         \"  try { while(x) { break    } } finally { alert(1) } throw 1}\"\n+         );\n+\n+    foldSame(\"function f() { try{ throw a } finally { a = 2 } throw a; }\");\n+\n+    fold(\n+      \"function f() { switch(a){ case 1: throw a; default: g();} throw a;}\",\n+      \"function f() { switch(a){ case 1: break; default: g();} throw a; }\");\n+  }\n+\n+\n+  public void testRemoveDuplicateReturn() {\n+    fold(\"function f() { return; }\",\n+         \"function f(){}\");\n+    foldSame(\"function f() { return a; }\");\n+    fold(\"function f() { if (x) { return a } return a; }\",\n+         \"function f() { if (x) {} return a; }\");\n+    foldSame(\n+      \"function f() { try { if (x) { return a } } catch(e) {} return a; }\");\n+    foldSame(\n+      \"function f() { try { if (x) {} } catch(e) {} return 1; }\");\n+\n+    // finally clauses may have side effects\n+    foldSame(\n+      \"function f() { try { if (x) { return a } } finally { a++ } return a; }\");\n+    // but they don't matter if the result doesn't have side effects and can't\n+    // be affect by side-effects.\n+    fold(\"function f() { try { if (x) { return 1 } } finally {} return 1; }\",\n+         \"function f() { try { if (x) {} } finally {} return 1; }\");\n+\n+    fold(\"function f() { switch(a){ case 1: return a; } return a; }\",\n+         \"function f() { switch(a){ case 1: } return a; }\");\n+\n+    fold(\"function f() { switch(a){ \" +\n+         \"  case 1: return a; case 2: return a; } return a; }\",\n+         \"function f() { switch(a){ \" +\n+         \"  case 1: break; case 2: } return a; }\");\n+  }\n+\n+  public void testRemoveDuplicateThrow() {\n+    foldSame(\"function f() { throw a; }\");\n+    fold(\"function f() { if (x) { throw a } throw a; }\",\n+         \"function f() { if (x) {} throw a; }\");\n+    foldSame(\n+      \"function f() { try { if (x) {throw a} } catch(e) {} throw a; }\");\n+    foldSame(\n+      \"function f() { try { if (x) {throw 1} } catch(e) {f()} throw 1; }\");\n+    foldSame(\n+      \"function f() { try { if (x) {throw 1} } catch(e) {f()} throw 1; }\");\n+    foldSame(\n+      \"function f() { try { if (x) {throw 1} } catch(e) {throw 1}}\");\n+    fold(\n+      \"function f() { try { if (x) {throw 1} } catch(e) {throw 1} throw 1; }\",\n+      \"function f() { try { if (x) {throw 1} } catch(e) {} throw 1; }\");\n+\n+    // finally clauses may have side effects\n+    foldSame(\n+      \"function f() { try { if (x) { throw a } } finally { a++ } throw a; }\");\n+    // but they don't matter if the result doesn't have side effects and can't\n+    // be affect by side-effects.\n+    fold(\"function f() { try { if (x) { throw 1 } } finally {} throw 1; }\",\n+         \"function f() { try { if (x) {} } finally {} throw 1; }\");\n+\n+    fold(\"function f() { switch(a){ case 1: throw a; } throw a; }\",\n+         \"function f() { switch(a){ case 1: } throw a; }\");\n+\n+    fold(\"function f() { switch(a){ \" +\n+             \"case 1: throw a; case 2: throw a; } throw a; }\",\n+         \"function f() { switch(a){ case 1: break; case 2: } throw a; }\");\n+  }\n+\n+  public void testNestedIfCombine() {\n+    fold(\"if(x)if(y){while(1){}}\", \"if(x&&y){while(1){}}\");\n+    fold(\"if(x||z)if(y){while(1){}}\", \"if((x||z)&&y){while(1){}}\");\n+    fold(\"if(x)if(y||z){while(1){}}\", \"if((x)&&(y||z)){while(1){}}\");\n+    foldSame(\"if(x||z)if(y||z){while(1){}}\");\n+    fold(\"if(x)if(y){if(z){while(1){}}}\", \"if(x&&y&&z){while(1){}}\");\n+  }\n+\n+  public void testIssue291() {\n+    fold(\"if (true) { f.onchange(); }\", \"if (1) f.onchange();\");\n+    foldSame(\"if (f) { f.onchange(); }\");\n+    foldSame(\"if (f) { f.bar(); } else { f.onchange(); }\");\n+    fold(\"if (f) { f.bonchange(); }\", \"f && f.bonchange();\");\n+    foldSame(\"if (f) { f['x'](); }\");\n+  }\n+\n+  public void testObjectLiteral() {\n+    test(\"({})\", \"1\");\n+    test(\"({a:1})\", \"1\");\n+    testSame(\"({a:foo()})\");\n+    testSame(\"({'a':foo()})\");\n+  }\n+\n+  public void testArrayLiteral() {\n+    test(\"([])\", \"1\");\n+    test(\"([1])\", \"1\");\n+    test(\"([a])\", \"1\");\n+    testSame(\"([foo()])\");\n+  }\n+\n+  public void testRemoveElseCause() {\n+    test(\"function f() {\" +\n+         \" if(x) return 1;\" +\n+         \" else if(x) return 2;\" +\n+         \" else if(x) return 3 }\",\n+         \"function f() {\" +\n+         \" if(x) return 1;\" +\n+         \"{ if(x) return 2;\" +\n+         \"{ if(x) return 3 } } }\");\n+  }\n+\n+  public void testRemoveElseCause1() {\n+    test(\"function f() { if (x) throw 1; else f() }\",\n+         \"function f() { if (x) throw 1; { f() } }\");\n+  }\n+\n+  public void testRemoveElseCause2() {\n+    test(\"function f() { if (x) return 1; else f() }\",\n+         \"function f() { if (x) return 1; { f() } }\");\n+    test(\"function f() { if (x) return; else f() }\",\n+         \"function f() { if (x) {} else { f() } }\");\n+    // This case is handled by minimize exit points.\n+    testSame(\"function f() { if (x) return; f() }\");\n+  }\n+\n+  public void testRemoveElseCause3() {\n+    testSame(\"function f() { a:{if (x) break a; else f() } }\");\n+    testSame(\"function f() { if (x) { a:{ break a } } else f() }\");\n+    testSame(\"function f() { if (x) a:{ break a } else f() }\");\n+  }\n+\n+  public void testRemoveElseCause4() {\n+    testSame(\"function f() { if (x) { if (y) { return 1; } } else f() }\");\n+  }\n+\n+  public void testIssue925() {\n+    test(\n+        \"if (x[--y] === 1) {\\n\" +\n+        \"    x[y] = 0;\\n\" +\n+        \"} else {\\n\" +\n+        \"    x[y] = 1;\\n\" +\n+        \"}\",\n+        \"(x[--y] === 1) ? x[y] = 0 : x[y] = 1;\");\n+\n+    test(\n+        \"if (x[--y]) {\\n\" +\n+        \"    a = 0;\\n\" +\n+        \"} else {\\n\" +\n+        \"    a = 1;\\n\" +\n+        \"}\",\n+        \"a = (x[--y]) ? 0 : 1;\");\n+\n+    test(\"if (x++) { x += 2 } else { x += 3 }\",\n+         \"x++ ? x += 2 : x += 3\");\n+\n+    test(\"if (x++) { x = x + 2 } else { x = x + 3 }\",\n+        \"x = x++ ? x + 2 : x + 3\");\n+  }\n+\n+}\n--- a/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n \n package com.google.javascript.jscomp;\n \n-import com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.MinimizedCondition;\n-import com.google.javascript.rhino.Node;\n-\n /**\n  * Tests for {@link PeepholeSubstituteAlternateSyntax} in isolation.\n  * Tests for the interaction of multiple peephole passes are in\n     }\n \n     scTest.test(js, expected);\n-  }\n-\n-  /** Check that removing blocks with 1 child works */\n-  public void testFoldOneChildBlocks() {\n-    late = false;\n-    fold(\"function f(){if(x)a();x=3}\",\n-        \"function f(){x&&a();x=3}\");\n-    fold(\"function f(){if(x){a()}x=3}\",\n-        \"function f(){x&&a();x=3}\");\n-    fold(\"function f(){if(x){return 3}}\",\n-        \"function f(){if(x)return 3}\");\n-    fold(\"function f(){if(x){a()}}\",\n-        \"function f(){x&&a()}\");\n-    fold(\"function f(){if(x){throw 1}}\", \"function f(){if(x)throw 1;}\");\n-\n-    // Try it out with functions\n-    fold(\"function f(){if(x){foo()}}\", \"function f(){x&&foo()}\");\n-    fold(\"function f(){if(x){foo()}else{bar()}}\",\n-         \"function f(){x?foo():bar()}\");\n-\n-    // Try it out with properties and methods\n-    fold(\"function f(){if(x){a.b=1}}\", \"function f(){if(x)a.b=1}\");\n-    fold(\"function f(){if(x){a.b*=1}}\", \"function f(){x&&(a.b*=1)}\");\n-    fold(\"function f(){if(x){a.b+=1}}\", \"function f(){x&&(a.b+=1)}\");\n-    fold(\"function f(){if(x){++a.b}}\", \"function f(){x&&++a.b}\");\n-    fold(\"function f(){if(x){a.foo()}}\", \"function f(){x&&a.foo()}\");\n-\n-    // Try it out with throw/catch/finally [which should not change]\n-    fold(\"function f(){try{foo()}catch(e){bar(e)}finally{baz()}}\",\n-         \"function f(){try{foo()}catch(e){bar(e)}finally{baz()}}\");\n-\n-    // Try it out with switch statements\n-    fold(\"function f(){switch(x){case 1:break}}\",\n-         \"function f(){switch(x){case 1:break}}\");\n-\n-    // Do while loops stay in a block if that's where they started\n-    fold(\"function f(){if(e1){do foo();while(e2)}else foo2()}\",\n-         \"function f(){if(e1){do foo();while(e2)}else foo2()}\");\n-    // Test an obscure case with do and while\n-    fold(\"if(x){do{foo()}while(y)}else bar()\",\n-         \"if(x){do foo();while(y)}else bar()\");\n-\n-    // Play with nested IFs\n-    fold(\"function f(){if(x){if(y)foo()}}\",\n-         \"function f(){x&&y&&foo()}\");\n-    fold(\"function f(){if(x){if(y)foo();else bar()}}\",\n-         \"function f(){x&&(y?foo():bar())}\");\n-    fold(\"function f(){if(x){if(y)foo()}else bar()}\",\n-         \"function f(){x?y&&foo():bar()}\");\n-    fold(\"function f(){if(x){if(y)foo();else bar()}else{baz()}}\",\n-         \"function f(){x?y?foo():bar():baz()}\");\n-\n-    fold(\"if(e1){while(e2){if(e3){foo()}}}else{bar()}\",\n-         \"if(e1)while(e2)e3&&foo();else bar()\");\n-\n-    fold(\"if(e1){with(e2){if(e3){foo()}}}else{bar()}\",\n-         \"if(e1)with(e2)e3&&foo();else bar()\");\n-\n-    fold(\"if(a||b){if(c||d){var x;}}\", \"if(a||b)if(c||d)var x\");\n-    fold(\"if(x){ if(y){var x;}else{var z;} }\",\n-         \"if(x)if(y)var x;else var z\");\n-\n-    // NOTE - technically we can remove the blocks since both the parent\n-    // and child have elses. But we don't since it causes ambiguities in\n-    // some cases where not all descendent ifs having elses\n-    fold(\"if(x){ if(y){var x;}else{var z;} }else{var w}\",\n-         \"if(x)if(y)var x;else var z;else var w\");\n-    fold(\"if (x) {var x;}else { if (y) { var y;} }\",\n-         \"if(x)var x;else if(y)var y\");\n-\n-    // Here's some of the ambiguous cases\n-    fold(\"if(a){if(b){f1();f2();}else if(c){f3();}}else {if(d){f4();}}\",\n-         \"if(a)if(b){f1();f2()}else c&&f3();else d&&f4()\");\n-\n-    fold(\"function f(){foo()}\", \"function f(){foo()}\");\n-    fold(\"switch(x){case y: foo()}\", \"switch(x){case y:foo()}\");\n-    fold(\"try{foo()}catch(ex){bar()}finally{baz()}\",\n-         \"try{foo()}catch(ex){bar()}finally{baz()}\");\n-  }\n-\n-  /** Try to minimize returns */\n-  public void testFoldReturns() {\n-    fold(\"function f(){if(x)return 1;else return 2}\",\n-         \"function f(){return x?1:2}\");\n-    fold(\"function f(){if(x)return 1;return 2}\",\n-         \"function f(){return x?1:2}\");\n-    fold(\"function f(){if(x)return;return 2}\",\n-         \"function f(){return x?void 0:2}\");\n-    fold(\"function f(){if(x)return 1+x;else return 2-x}\",\n-         \"function f(){return x?1+x:2-x}\");\n-    fold(\"function f(){if(x)return 1+x;return 2-x}\",\n-         \"function f(){return x?1+x:2-x}\");\n-    fold(\"function f(){if(x)return y += 1;else return y += 2}\",\n-         \"function f(){return x?(y+=1):(y+=2)}\");\n-\n-    fold(\"function f(){if(x)return;else return 2-x}\",\n-         \"function f(){if(x);else return 2-x}\");\n-    fold(\"function f(){if(x)return;return 2-x}\",\n-         \"function f(){return x?void 0:2-x}\");\n-    fold(\"function f(){if(x)return x;else return}\",\n-         \"function f(){if(x)return x;{}}\");\n-    fold(\"function f(){if(x)return x;return}\",\n-         \"function f(){if(x)return x}\");\n-\n-    foldSame(\"function f(){for(var x in y) { return x.y; } return k}\");\n-  }\n-\n-  public void testCombineIfs1() {\n-    fold(\"function f() {if (x) return 1; if (y) return 1}\",\n-         \"function f() {if (x||y) return 1;}\");\n-    fold(\"function f() {if (x) return 1; if (y) foo(); else return 1}\",\n-         \"function f() {if ((!x)&&y) foo(); else return 1;}\");\n-  }\n-\n-  public void testCombineIfs2() {\n-    // combinable but not yet done\n-    foldSame(\"function f() {if (x) throw 1; if (y) throw 1}\");\n-    // Can't combine, side-effect\n-    fold(\"function f(){ if (x) g(); if (y) g() }\",\n-         \"function f(){ x&&g(); y&&g() }\");\n-    // Can't combine, side-effect\n-    fold(\"function f(){ if (x) y = 0; if (y) y = 0; }\",\n-         \"function f(){ x&&(y = 0); y&&(y = 0); }\");\n-  }\n-\n-  public void testCombineIfs3() {\n-    foldSame(\"function f() {if (x) return 1; if (y) {g();f()}}\");\n-  }\n-\n-\n-  /** Try to minimize assignments */\n-  public void testFoldAssignments() {\n-    fold(\"function f(){if(x)y=3;else y=4;}\", \"function f(){y=x?3:4}\");\n-    fold(\"function f(){if(x)y=1+a;else y=2+a;}\", \"function f(){y=x?1+a:2+a}\");\n-\n-    // and operation assignments\n-    fold(\"function f(){if(x)y+=1;else y+=2;}\", \"function f(){y+=x?1:2}\");\n-    fold(\"function f(){if(x)y-=1;else y-=2;}\", \"function f(){y-=x?1:2}\");\n-    fold(\"function f(){if(x)y%=1;else y%=2;}\", \"function f(){y%=x?1:2}\");\n-    fold(\"function f(){if(x)y|=1;else y|=2;}\", \"function f(){y|=x?1:2}\");\n-\n-    // sanity check, don't fold if the 2 ops don't match\n-    foldSame(\"function f(){x ? y-=1 : y+=2}\");\n-\n-    // sanity check, don't fold if the 2 LHS don't match\n-    foldSame(\"function f(){x ? y-=1 : z-=1}\");\n-\n-    // sanity check, don't fold if there are potential effects\n-    foldSame(\"function f(){x ? y().a=3 : y().a=4}\");\n-  }\n-\n-  public void testRemoveDuplicateStatements() {\n-    fold(\"if (a) { x = 1; x++ } else { x = 2; x++ }\",\n-         \"x=(a) ? 1 : 2; x++\");\n-    fold(\"if (a) { x = 1; x++; y += 1; z = pi; }\" +\n-         \" else  { x = 2; x++; y += 1; z = pi; }\",\n-         \"x=(a) ? 1 : 2; x++; y += 1; z = pi;\");\n-    fold(\"function z() {\" +\n-         \"if (a) { foo(); return !0 } else { goo(); return !0 }\" +\n-         \"}\",\n-         \"function z() {(a) ? foo() : goo(); return !0}\");\n-    fold(\"function z() {if (a) { foo(); x = true; return true \" +\n-         \"} else { goo(); x = true; return true }}\",\n-         \"function z() {(a) ? foo() : goo(); x = !0; return !0}\");\n-\n-    fold(\"function z() {\" +\n-         \"  if (a) { bar(); foo(); return true }\" +\n-         \"    else { bar(); goo(); return true }\" +\n-         \"}\",\n-         \"function z() {\" +\n-         \"  if (a) { bar(); foo(); }\" +\n-         \"    else { bar(); goo(); }\" +\n-         \"  return !0;\" +\n-         \"}\");\n-  }\n-\n-  public void testNotCond() {\n-    fold(\"function f(){if(!x)foo()}\", \"function f(){x||foo()}\");\n-    fold(\"function f(){if(!x)b=1}\", \"function f(){x||(b=1)}\");\n-    fold(\"if(!x)z=1;else if(y)z=2\", \"if(x){y&&(z=2);}else{z=1;}\");\n-    fold(\"if(x)y&&(z=2);else z=1;\", \"x ? y&&(z=2) : z=1\");\n-    foldSame(\"function f(){if(!(x=1))a.b=1}\");\n-  }\n-\n-  public void testAndParenthesesCount() {\n-    fold(\"function f(){if(x||y)a.foo()}\", \"function f(){(x||y)&&a.foo()}\");\n-    fold(\"function f(){if(x.a)x.a=0}\",\n-         \"function f(){x.a&&(x.a=0)}\");\n-    foldSame(\"function f(){if(x()||y()){x()||y()}}\");\n-  }\n-\n-  public void testFoldLogicalOpStringCompare() {\n-    // side-effects\n-    // There is two way to parse two &&'s and both are correct.\n-    assertResultString(\"if(foo() && false) z()\", \"foo()&&0&&z()\");\n-  }\n-\n-  public void testFoldNot() {\n-    fold(\"while(!(x==y)){a=b;}\" , \"while(x!=y){a=b;}\");\n-    fold(\"while(!(x!=y)){a=b;}\" , \"while(x==y){a=b;}\");\n-    fold(\"while(!(x===y)){a=b;}\", \"while(x!==y){a=b;}\");\n-    fold(\"while(!(x!==y)){a=b;}\", \"while(x===y){a=b;}\");\n-    // Because !(x<NaN) != x>=NaN don't fold < and > cases.\n-    foldSame(\"while(!(x>y)){a=b;}\");\n-    foldSame(\"while(!(x>=y)){a=b;}\");\n-    foldSame(\"while(!(x<y)){a=b;}\");\n-    foldSame(\"while(!(x<=y)){a=b;}\");\n-    foldSame(\"while(!(x<=NaN)){a=b;}\");\n-\n-    // NOT forces a boolean context\n-    fold(\"x = !(y() && true)\", \"x = !y()\");\n-    // This will be further optimized by PeepholeFoldConstants.\n-    fold(\"x = !true\", \"x = !1\");\n   }\n \n   public void testFoldRegExpConstructor() {\n         \"Object(), Array(\\\"abc\\\", Object(), Array(Array())))\");\n   }\n \n-  public void testMinimizeExprCondition() {\n-    fold(\"(x ? true : false) && y()\", \"x&&y()\");\n-    fold(\"(x ? false : true) && y()\", \"(!x)&&y()\");\n-    fold(\"(x ? true : y) && y()\", \"(x || y)&&y()\");\n-    fold(\"(x ? y : false) && y()\", \"(x && y)&&y()\");\n-    fold(\"(x && true) && y()\", \"x && y()\");\n-    fold(\"(x && false) && y()\", \"0&&y()\");\n-    fold(\"(x || true) && y()\", \"1&&y()\");\n-    fold(\"(x || false) && y()\", \"x&&y()\");\n-  }\n-\n-  public void testMinimizeWhileCondition() {\n-    // This test uses constant folding logic, so is only here for completeness.\n-    fold(\"while(!!true) foo()\", \"while(1) foo()\");\n-    // These test tryMinimizeCondition\n-    fold(\"while(!!x) foo()\", \"while(x) foo()\");\n-    fold(\"while(!(!x&&!y)) foo()\", \"while(x||y) foo()\");\n-    fold(\"while(x||!!y) foo()\", \"while(x||y) foo()\");\n-    fold(\"while(!(!!x&&y)) foo()\", \"while(!x||!y) foo()\");\n-    fold(\"while(!(!x&&y)) foo()\", \"while(x||!y) foo()\");\n-    fold(\"while(!(x||!y)) foo()\", \"while(!x&&y) foo()\");\n-    fold(\"while(!(x||y)) foo()\", \"while(!x&&!y) foo()\");\n-    fold(\"while(!(!x||y-z)) foo()\", \"while(x&&!(y-z)) foo()\");\n-    fold(\"while(!(!(x/y)||z+w)) foo()\", \"while(x/y&&!(z+w)) foo()\");\n-    foldSame(\"while(!(x+y||z)) foo()\");\n-    foldSame(\"while(!(x&&y*z)) foo()\");\n-    fold(\"while(!(!!x&&y)) foo()\", \"while(!x||!y) foo()\");\n-    fold(\"while(x&&!0) foo()\", \"while(x) foo()\");\n-    fold(\"while(x||!1) foo()\", \"while(x) foo()\");\n-    fold(\"while(!((x,y)&&z)) foo()\", \"while(!(x,y)||!z) foo()\");\n-  }\n-\n-  public void testMinimizeDemorganRemoveLeadingNot() {\n-    fold(\"if(!(!a||!b)&&c) foo()\", \"((a&&b)&&c)&&foo()\");\n-    fold(\"if(!(x&&y)) foo()\", \"x&&y||foo()\");\n-    fold(\"if(!(x||y)) foo()\", \"(x||y)||foo()\");\n-  }\n-\n-  public void testMinimizeDemorgan1() {\n-    fold(\"if(!a&&!b)foo()\", \"(a||b)||foo()\");\n-  }\n-\n-  public void testMinimizeDemorgan3() {\n-    fold(\"if((!a||!b)&&(c||d)) foo()\", \"(a&&b||!c&&!d)||foo()\");\n-  }\n-\n-  public void testMinimizeDemorgan5() {\n-    fold(\"if((!a||!b)&&c) foo()\", \"(a&&b||!c)||foo()\");\n-  }\n-\n-  public void testMinimizeDemorgan11() {\n-    fold(\"if (x && (y===2 || !f()) && (y===3 || !h())) foo()\",\n-         \"(!x || y!==2 && f() || y!==3 && h()) || foo()\");\n-  }\n-\n-  public void testMinimizeDemorgan20() {\n-    fold(\"if (0===c && (2===a || 1===a)) f(); else g()\",\n-         \"if (0!==c || 2!==a && 1!==a) g(); else f()\");\n-    fold(\"if (0!==c || 2!==a && 1!==a) g(); else f()\",\n-         \"(0!==c || 2!==a && 1!==a) ? g() : f()\");\n-  }\n-\n-  public void testSwapHook() {\n-    fold(\"!x ? foo() : bar()\",\n-         \"x ? bar() : foo()\");\n-  }\n-\n-  public void testMinimizeDemorgan21() {\n-    fold(\"if (0===c && (2===a || 1===a)) f()\",\n-         \"(0!==c || 2!==a && 1!==a) || f()\");\n-  }\n-\n-  public void testMinimizeAndOr1() {\n-    fold(\"if ((!a || !b) && (d || e)) f()\", \"(a&&b || !d&&!e) || f()\");\n-  }\n-\n-  public Node parseExpr(String input) {\n-    Node block = parseExpectedJs(input);\n-    Node script = block.getFirstChild();\n-    Node exprResult = script.getFirstChild();\n-    return exprResult.getFirstChild();\n-  }\n-\n-  public void minimizeCond(String input, String positive, String negative) {\n-    Node inputNode = parseExpr(input);\n-    MinimizedCondition result = PeepholeSubstituteAlternateSyntax\n-        .MinimizedCondition.fromConditionNode(inputNode);\n-    Node positiveNode = parseExpr(positive);\n-    Node negativeNode = parseExpr(negative);\n-    if (!result.getNode().isEquivalentTo(positiveNode)) {\n-      fail(\"Not equal:\\n\" + result.getNode().toStringTree()\n-          + \"and:\\n\" + positiveNode.toStringTree());\n-    }\n-    if (!result.getNegatedNode().isEquivalentTo(negativeNode)) {\n-      fail(\"Not equal:\\n\" + result.getNegatedNode().toStringTree()\n-          + \"and:\\n\" + negativeNode.toStringTree());\n-    }\n-  }\n-\n-  public void testTryMinimizeCondition1() {\n-    minimizeCond(\"x\", \"x\", \"!x\");\n-  }\n-\n-  public void testTryMinimizeCondition2() {\n-    minimizeCond(\"!x\", \"!x\", \"x\");\n-  }\n-\n-  public void testTryMinimizeCondition3() {\n-    minimizeCond(\"x || y\", \"x || y\", \"!x && !y\");\n-  }\n-\n-  public void testTryMinimizeCondition4() {\n-    minimizeCond(\"x && y\", \"x && y\", \"!x || !y\");\n-  }\n-\n-  public void testTryMinimizeCondition5() {\n-    minimizeCond(\"w && x && y && z\", \"w && x && y && z\", \"!(w && x && y && z)\");\n-  }\n-\n-  public void testMinimizeCondDemorgan() {\n-    minimizeCond(\"x && (y===2 || !f()) && (y===3 || !h())\",\n-        \"x && !((y!==2 && f()) || (y!==3 && h()))\",\n-        \"!x || (y!==2 && f()) || (y!==3 && h())\");\n-  }\n-\n-  public void testMinimizeForCondition() {\n-    // This test uses constant folding logic, so is only here for completeness.\n-    // These could be simplified to \"for(;;) ...\"\n-    fold(\"for(;!!true;) foo()\", \"for(;1;) foo()\");\n-    // Don't bother with FOR inits as there are normalized out.\n-    fold(\"for(!!true;;) foo()\", \"for(!0;;) foo()\");\n-\n-    // These test tryMinimizeCondition\n-    fold(\"for(;!!x;) foo()\", \"for(;x;) foo()\");\n-\n-    // sanity check\n-    foldSame(\"for(a in b) foo()\");\n-    foldSame(\"for(a in {}) foo()\");\n-    foldSame(\"for(a in []) foo()\");\n-    fold(\"for(a in !!true) foo()\", \"for(a in !0) foo()\");\n-  }\n-\n-  public void testMinimizeCondition_example1() {\n-    // Based on a real failing code sample.\n-    fold(\"if(!!(f() > 20)) {foo();foo()}\", \"if(f() > 20){foo();foo()}\");\n-  }\n-\n-  public void testFoldLoopBreakLate() {\n-    late = true;\n-    fold(\"for(;;) if (a) break\", \"for(;!a;);\");\n-    foldSame(\"for(;;) if (a) { f(); break }\");\n-    fold(\"for(;;) if (a) break; else f()\", \"for(;!a;) { { f(); } }\");\n-    fold(\"for(;a;) if (b) break\", \"for(;a && !b;);\");\n-    fold(\"for(;a;) { if (b) break; if (c) break; }\",\n-         \"for(;(a && !b);) if (c) break;\");\n-    fold(\"for(;(a && !b);) if (c) break;\", \"for(;(a && !b) && !c;);\");\n-\n-    // 'while' is normalized to 'for'\n-    enableNormalize(true);\n-    fold(\"while(true) if (a) break\", \"for(;1&&!a;);\");\n-  }\n-\n-  public void testFoldLoopBreakEarly() {\n-    late = false;\n-    foldSame(\"for(;;) if (a) break\");\n-    foldSame(\"for(;;) if (a) { f(); break }\");\n-    foldSame(\"for(;;) if (a) break; else f()\");\n-    foldSame(\"for(;a;) if (b) break\");\n-    foldSame(\"for(;a;) { if (b) break; if (c) break; }\");\n-\n-    foldSame(\"while(1) if (a) break\");\n-    enableNormalize(true);\n-    foldSame(\"while(1) if (a) break\");\n-  }\n-\n-  public void testFoldConditionalVarDeclaration() {\n-    fold(\"if(x) var y=1;else y=2\", \"var y=x?1:2\");\n-    fold(\"if(x) y=1;else var y=2\", \"var y=x?1:2\");\n-\n-    foldSame(\"if(x) var y = 1; z = 2\");\n-    foldSame(\"if(x||y) y = 1; var z = 2\");\n-\n-    foldSame(\"if(x) { var y = 1; print(y)} else y = 2 \");\n-    foldSame(\"if(x) var y = 1; else {y = 2; print(y)}\");\n-  }\n-\n-  public void testFoldIfWithLowerOperatorsInside() {\n-    fold(\"if (x + (y=5)) z && (w,z);\",\n-         \"x + (y=5) && z && (w,z)\");\n-    fold(\"if (!(x+(y=5))) z && (w,z);\",\n-         \"x + (y=5) || z && (w,z)\");\n-    fold(\"if (x + (y=5)) if (z && (w,z)) for(;;) foo();\",\n-         \"if (x + (y=5) && z && (w,z)) for(;;) foo();\");\n-  }\n-\n-  public void testFoldReturnResult() {\n-    fold(\"function f(){return false;}\", \"function f(){return !1}\");\n-    foldSame(\"function f(){return null;}\");\n-    fold(\"function f(){return void 0;}\",\n-         \"function f(){return}\");\n-    fold(\"function f(){return;}\",\n-         \"function f(){}\");\n-    foldSame(\"function f(){return void foo();}\");\n-    fold(\"function f(){return undefined;}\",\n-         \"function f(){return}\");\n-    fold(\"function f(){if(a()){return undefined;}}\",\n-         \"function f(){if(a()){return}}\");\n-  }\n-\n   public void testFoldStandardConstructors() {\n     foldSame(\"new Foo('a')\");\n     foldSame(\"var x = new goog.Foo(1)\");\n     fold(\"var x = new Array(20)\", \"var x = Array(20)\");\n   }\n \n-  public void testSubsituteReturn() {\n-\n-    fold(\"function f() { while(x) { return }}\",\n-         \"function f() { while(x) { break }}\");\n-\n-    foldSame(\"function f() { while(x) { return 5 } }\");\n-\n-    foldSame(\"function f() { a: { return 5 } }\");\n-\n-    fold(\"function f() { while(x) { return 5}  return 5}\",\n-         \"function f() { while(x) { break }    return 5}\");\n-\n-    fold(\"function f() { while(x) { return x}  return x}\",\n-         \"function f() { while(x) { break }    return x}\");\n-\n-    fold(\"function f() { while(x) { if (y) { return }}}\",\n-         \"function f() { while(x) { if (y) { break  }}}\");\n-\n-    fold(\"function f() { while(x) { if (y) { return }} return}\",\n-         \"function f() { while(x) { if (y) { break  }}}\");\n-\n-    fold(\"function f() { while(x) { if (y) { return 5 }} return 5}\",\n-         \"function f() { while(x) { if (y) { break    }} return 5}\");\n-\n-    // It doesn't matter if x is changed between them. We are still returning\n-    // x at whatever x value current holds. The whole x = 1 is skipped.\n-    fold(\"function f() { while(x) { if (y) { return x } x = 1} return x}\",\n-         \"function f() { while(x) { if (y) { break    } x = 1} return x}\");\n-\n-    // RemoveUnreachableCode would take care of the useless breaks.\n-    fold(\"function f() { while(x) { if (y) { return x } return x} return x}\",\n-         \"function f() { while(x) { if (y) {} break }return x}\");\n-\n-    // A break here only breaks out of the inner loop.\n-    foldSame(\"function f() { while(x) { while (y) { return } } }\");\n-\n-    foldSame(\"function f() { while(1) { return 7}  return 5}\");\n-\n-\n-    foldSame(\"function f() {\" +\n-             \"  try { while(x) {return f()}} catch (e) { } return f()}\");\n-\n-    foldSame(\"function f() {\" +\n-             \"  try { while(x) {return f()}} finally {alert(1)} return f()}\");\n-\n-\n-    // Both returns has the same handler\n-    fold(\"function f() {\" +\n-         \"  try { while(x) { return f() } return f() } catch (e) { } }\",\n-         \"function f() {\" +\n-         \"  try { while(x) { break } return f() } catch (e) { } }\");\n-\n-    // We can't fold this because it'll change the order of when foo is called.\n-    foldSame(\"function f() {\" +\n-             \"  try { while(x) { return foo() } } finally { alert(1) } \"  +\n-             \"  return foo()}\");\n-\n-    // This is fine, we have no side effect in the return value.\n-    fold(\"function f() {\" +\n-         \"  try { while(x) { return 1 } } finally { alert(1) } return 1}\",\n-         \"function f() {\" +\n-         \"  try { while(x) { break    } } finally { alert(1) } return 1}\"\n-         );\n-\n-    foldSame(\"function f() { try{ return a } finally { a = 2 } return a; }\");\n-\n-    fold(\n-      \"function f() { switch(a){ case 1: return a; default: g();} return a;}\",\n-      \"function f() { switch(a){ case 1: break; default: g();} return a; }\");\n-  }\n-\n-  public void testSubsituteBreakForThrow() {\n-\n-    foldSame(\"function f() { while(x) { throw Error }}\");\n-\n-    fold(\"function f() { while(x) { throw Error } throw Error }\",\n-         \"function f() { while(x) { break } throw Error}\");\n-    foldSame(\"function f() { while(x) { throw Error(1) } throw Error(2)}\");\n-    foldSame(\"function f() { while(x) { throw Error(1) } return Error(2)}\");\n-\n-    foldSame(\"function f() { while(x) { throw 5 } }\");\n-\n-    foldSame(\"function f() { a: { throw 5 } }\");\n-\n-    fold(\"function f() { while(x) { throw 5}  throw 5}\",\n-         \"function f() { while(x) { break }   throw 5}\");\n-\n-    fold(\"function f() { while(x) { throw x}  throw x}\",\n-         \"function f() { while(x) { break }   throw x}\");\n-\n-    foldSame(\"function f() { while(x) { if (y) { throw Error }}}\");\n-\n-    fold(\"function f() { while(x) { if (y) { throw Error }} throw Error}\",\n-         \"function f() { while(x) { if (y) { break }} throw Error}\");\n-\n-    fold(\"function f() { while(x) { if (y) { throw 5 }} throw 5}\",\n-         \"function f() { while(x) { if (y) { break    }} throw 5}\");\n-\n-    // It doesn't matter if x is changed between them. We are still throwing\n-    // x at whatever x value current holds. The whole x = 1 is skipped.\n-    fold(\"function f() { while(x) { if (y) { throw x } x = 1} throw x}\",\n-         \"function f() { while(x) { if (y) { break    } x = 1} throw x}\");\n-\n-    // RemoveUnreachableCode would take care of the useless breaks.\n-    fold(\"function f() { while(x) { if (y) { throw x } throw x} throw x}\",\n-         \"function f() { while(x) { if (y) {} break }throw x}\");\n-\n-    // A break here only breaks out of the inner loop.\n-    foldSame(\"function f() { while(x) { while (y) { throw Error } } }\");\n-\n-    foldSame(\"function f() { while(1) { throw 7}  throw 5}\");\n-\n-\n-    foldSame(\"function f() {\" +\n-             \"  try { while(x) {throw f()}} catch (e) { } throw f()}\");\n-\n-    foldSame(\"function f() {\" +\n-             \"  try { while(x) {throw f()}} finally {alert(1)} throw f()}\");\n-\n-\n-    // Both throws has the same handler\n-    fold(\"function f() {\" +\n-         \"  try { while(x) { throw f() } throw f() } catch (e) { } }\",\n-         \"function f() {\" +\n-         \"  try { while(x) { break } throw f() } catch (e) { } }\");\n-\n-    // We can't fold this because it'll change the order of when foo is called.\n-    foldSame(\"function f() {\" +\n-             \"  try { while(x) { throw foo() } } finally { alert(1) } \"  +\n-             \"  throw foo()}\");\n-\n-    // This is fine, we have no side effect in the throw value.\n-    fold(\"function f() {\" +\n-         \"  try { while(x) { throw 1 } } finally { alert(1) } throw 1}\",\n-         \"function f() {\" +\n-         \"  try { while(x) { break    } } finally { alert(1) } throw 1}\"\n-         );\n-\n-    foldSame(\"function f() { try{ throw a } finally { a = 2 } throw a; }\");\n-\n-    fold(\n-      \"function f() { switch(a){ case 1: throw a; default: g();} throw a;}\",\n-      \"function f() { switch(a){ case 1: break; default: g();} throw a; }\");\n-  }\n-\n-\n-  public void testRemoveDuplicateReturn() {\n-    fold(\"function f() { return; }\",\n-         \"function f(){}\");\n-    foldSame(\"function f() { return a; }\");\n-    fold(\"function f() { if (x) { return a } return a; }\",\n-         \"function f() { if (x) {} return a; }\");\n-    foldSame(\n-      \"function f() { try { if (x) { return a } } catch(e) {} return a; }\");\n-    foldSame(\n-      \"function f() { try { if (x) {} } catch(e) {} return 1; }\");\n-\n-    // finally clauses may have side effects\n-    foldSame(\n-      \"function f() { try { if (x) { return a } } finally { a++ } return a; }\");\n-    // but they don't matter if the result doesn't have side effects and can't\n-    // be affect by side-effects.\n-    fold(\"function f() { try { if (x) { return 1 } } finally {} return 1; }\",\n-         \"function f() { try { if (x) {} } finally {} return 1; }\");\n-\n-    fold(\"function f() { switch(a){ case 1: return a; } return a; }\",\n-         \"function f() { switch(a){ case 1: } return a; }\");\n-\n-    fold(\"function f() { switch(a){ \" +\n-         \"  case 1: return a; case 2: return a; } return a; }\",\n-         \"function f() { switch(a){ \" +\n-         \"  case 1: break; case 2: } return a; }\");\n-  }\n-\n-  public void testRemoveDuplicateThrow() {\n-    foldSame(\"function f() { throw a; }\");\n-    fold(\"function f() { if (x) { throw a } throw a; }\",\n-         \"function f() { if (x) {} throw a; }\");\n-    foldSame(\n-      \"function f() { try { if (x) {throw a} } catch(e) {} throw a; }\");\n-    foldSame(\n-      \"function f() { try { if (x) {throw 1} } catch(e) {f()} throw 1; }\");\n-    foldSame(\n-      \"function f() { try { if (x) {throw 1} } catch(e) {f()} throw 1; }\");\n-    foldSame(\n-      \"function f() { try { if (x) {throw 1} } catch(e) {throw 1}}\");\n-    fold(\n-      \"function f() { try { if (x) {throw 1} } catch(e) {throw 1} throw 1; }\",\n-      \"function f() { try { if (x) {throw 1} } catch(e) {} throw 1; }\");\n-\n-    // finally clauses may have side effects\n-    foldSame(\n-      \"function f() { try { if (x) { throw a } } finally { a++ } throw a; }\");\n-    // but they don't matter if the result doesn't have side effects and can't\n-    // be affect by side-effects.\n-    fold(\"function f() { try { if (x) { throw 1 } } finally {} throw 1; }\",\n-         \"function f() { try { if (x) {} } finally {} throw 1; }\");\n-\n-    fold(\"function f() { switch(a){ case 1: throw a; } throw a; }\",\n-         \"function f() { switch(a){ case 1: } throw a; }\");\n-\n-    fold(\"function f() { switch(a){ \" +\n-             \"case 1: throw a; case 2: throw a; } throw a; }\",\n-         \"function f() { switch(a){ case 1: break; case 2: } throw a; }\");\n-  }\n-\n-  public void testNestedIfCombine() {\n-    fold(\"if(x)if(y){while(1){}}\", \"if(x&&y){while(1){}}\");\n-    fold(\"if(x||z)if(y){while(1){}}\", \"if((x||z)&&y){while(1){}}\");\n-    fold(\"if(x)if(y||z){while(1){}}\", \"if((x)&&(y||z)){while(1){}}\");\n-    foldSame(\"if(x||z)if(y||z){while(1){}}\");\n-    fold(\"if(x)if(y){if(z){while(1){}}}\", \"if(x&&y&&z){while(1){}}\");\n-  }\n-\n   public void testFoldTrueFalse() {\n     fold(\"x = true\", \"x = !0\");\n     fold(\"x = false\", \"x = !1\");\n   }\n \n-  public void testIssue291() {\n-    fold(\"if (true) { f.onchange(); }\", \"if (1) f.onchange();\");\n-    foldSame(\"if (f) { f.onchange(); }\");\n-    foldSame(\"if (f) { f.bar(); } else { f.onchange(); }\");\n-    fold(\"if (f) { f.bonchange(); }\", \"f && f.bonchange();\");\n-    foldSame(\"if (f) { f['x'](); }\");\n-  }\n   public void testUndefined() {\n     foldSame(\"var x = undefined\");\n     foldSame(\"function f(f) {var undefined=2;var x = undefined;}\");\n     fold(\"(a(), b()), (c(), d());\", \"a(); b(); (c(), d());\");\n     fold(\"a(); b(); (c(), d());\", \"a(); b(); c(); d();\");\n     fold(\"foo(), true\", \"foo();true\");\n-    fold(\"foo();true\", \"foo();1\");\n+    foldSame(\"foo();true\");\n     fold(\"function x(){foo(), !0}\", \"function x(){foo(); !0}\");\n-    fold(\"function x(){foo(); !0}\", \"function x(){foo(); 1}\");\n+    foldSame(\"function x(){foo(); !0}\");\n   }\n \n   public void testComma1() {\n     late = false;\n     fold(\"1, 2\", \"1; 2\");\n-    fold(\"1; 2\", \"1; 1\");\n     late = true;\n     foldSame(\"1, 2\");\n   }\n     test(\"a(), b(), 1\", \"a();b();1\");\n     late = true;\n     foldSame(\"a(), b(), 1\");\n-  }\n-\n-  public void testObjectLiteral() {\n-    test(\"({})\", \"1\");\n-    test(\"({a:1})\", \"1\");\n-    testSame(\"({a:foo()})\");\n-    testSame(\"({'a':foo()})\");\n-  }\n-\n-  public void testArrayLiteral() {\n-    test(\"([])\", \"1\");\n-    test(\"([1])\", \"1\");\n-    test(\"([a])\", \"1\");\n-    testSame(\"([foo()])\");\n   }\n \n   public void testStringArraySplitting() {\n     testSame(\"var x=[',', ' ', ';', '{', '}']\");\n   }\n \n-  public void testRemoveElseCause() {\n-    test(\"function f() {\" +\n-         \" if(x) return 1;\" +\n-         \" else if(x) return 2;\" +\n-         \" else if(x) return 3 }\",\n-         \"function f() {\" +\n-         \" if(x) return 1;\" +\n-         \"{ if(x) return 2;\" +\n-         \"{ if(x) return 3 } } }\");\n-  }\n-\n-\n-  public void testRemoveElseCause1() {\n-    test(\"function f() { if (x) throw 1; else f() }\",\n-         \"function f() { if (x) throw 1; { f() } }\");\n-  }\n-\n-  public void testRemoveElseCause2() {\n-    test(\"function f() { if (x) return 1; else f() }\",\n-         \"function f() { if (x) return 1; { f() } }\");\n-    test(\"function f() { if (x) return; else f() }\",\n-         \"function f() { if (x) {} else { f() } }\");\n-    // This case is handled by minimize exit points.\n-    testSame(\"function f() { if (x) return; f() }\");\n-  }\n-\n-  public void testRemoveElseCause3() {\n-    testSame(\"function f() { a:{if (x) break a; else f() } }\");\n-    testSame(\"function f() { if (x) { a:{ break a } } else f() }\");\n-    testSame(\"function f() { if (x) a:{ break a } else f() }\");\n-  }\n-\n-  public void testRemoveElseCause4() {\n-    testSame(\"function f() { if (x) { if (y) { return 1; } } else f() }\");\n-  }\n-\n-  public void testIssue925() {\n-    test(\n-        \"if (x[--y] === 1) {\\n\" +\n-        \"    x[y] = 0;\\n\" +\n-        \"} else {\\n\" +\n-        \"    x[y] = 1;\\n\" +\n-        \"}\",\n-        \"(x[--y] === 1) ? x[y] = 0 : x[y] = 1;\");\n-\n-    test(\n-        \"if (x[--y]) {\\n\" +\n-        \"    a = 0;\\n\" +\n-        \"} else {\\n\" +\n-        \"    a = 1;\\n\" +\n-        \"}\",\n-        \"a = (x[--y]) ? 0 : 1;\");\n-\n-    test(\"if (x++) { x += 2 } else { x += 3 }\",\n-         \"x++ ? x += 2 : x += 3\");\n-\n-    test(\"if (x++) { x = x + 2 } else { x = x + 3 }\",\n-        \"x = x++ ? x + 2 : x + 3\");\n-  }\n-\n   public void testBindToCall1() {\n     test(\"(goog.bind(f))()\", \"f()\");\n     test(\"(goog.bind(f,a))()\", \"f.call(a)\");", "timestamp": 1367968330, "metainfo": ""}