{"sha": "24b7eb9a4a8850f2d0988eb81245b4b9a977d53a", "log": "Clean up constant annotations so that all constant annotations are added during the normalize() phase. This was really confusing to me, because certain kinds of constant annotations would work pre-normalize, and certain kinds would work post-normalize.  R=johnlenz DELTA=204  (114 added, 75 deleted, 15 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=1188239   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCompiler.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompiler.java\n   abstract Node parseSyntheticCode(String filename, String code);\n \n   /**\n+   * Parses code for testing.\n+   */\n+  abstract Node parseTestCode(String code);\n+\n+  /**\n    * Prints a node to source code.\n    */\n   abstract String toSource(Node root);\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n     for (Name n : globalNames) {\n       collapseDeclarationOfNameAndDescendants(n, n.name);\n     }\n-\n-    // TODO(johnlenz): The pass should maintain the constant annotations during\n-    // the main pass.\n-    new Normalize.PropogateConstantAnnotations(compiler, false);\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/ConstCheck.java\n+++ b/src/com/google/javascript/jscomp/ConstCheck.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.base.Preconditions;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n   @Override\n   public void process(Node externs, Node root) {\n+    Preconditions.checkState(compiler.isNormalized());\n     NodeTraversal.traverse(compiler, root, this);\n   }\n \n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n     return js;\n   }\n \n+  static Node parseAndNormalizeTestCode(\n+      AbstractCompiler compiler, String code, String prefix) {\n+    Node js = compiler.parseTestCode(code);\n+    NodeTraversal.traverse(compiler, js,\n+        new Normalize.NormalizeStatements(compiler, false));\n+    NodeTraversal.traverse(\n+        compiler, js,\n+        new MakeDeclaredNamesUnique());\n+    return js;\n+  }\n+\n   private void reportCodeChange(String changeDescription) {\n     if (assertOnChange) {\n       throw new IllegalStateException(\n     // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n     // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n     removeDuplicateDeclarations(externs, root);\n-    new PropogateConstantAnnotations(compiler, assertOnChange)\n+    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange)\n         .process(externs, root);\n \n     compiler.setNormalized();\n   }\n \n-  public static class PropogateConstantAnnotations\n+  /**\n+   * Propagate constant annotations over the Var graph.\n+   */\n+  static class PropagateConstantAnnotationsOverVars\n       extends AbstractPostOrderCallback\n       implements CompilerPass {\n     private final AbstractCompiler compiler;\n     private final boolean assertOnChange;\n \n-    public PropogateConstantAnnotations(\n+    PropagateConstantAnnotationsOverVars(\n         AbstractCompiler compiler, boolean forbidChanges) {\n       this.compiler = compiler;\n       this.assertOnChange = forbidChanges;\n           info = var.getJSDocInfo();\n         }\n \n-        if ((info != null && info.isConstant()) &&\n-            !n.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n+        boolean shouldBeConstant =\n+            (info != null && info.isConstant()) ||\n+            NodeUtil.isConstantByConvention(\n+                compiler.getCodingConvention(), n, parent);\n+        boolean isMarkedConstant = n.getBooleanProp(Node.IS_CONSTANT_NAME);\n+        if (shouldBeConstant && !isMarkedConstant) {\n           n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n           if (assertOnChange) {\n             String name = n.getString();\n                 \"  name: \"+ name + \"\\n\" +\n                 \"  gramps:\" + n.getParent().getParent().toStringTree());\n           }\n-          // Even though the AST has changed (an annotation was added),\n-          // the annotations are not compared so don't report the change.\n-          // reportCodeChange(\"constant annotation\");\n         }\n       }\n     }\n    *   - FOR loop are initializers are moved out of the FOR structure\n    *   - LABEL node of children other than LABEL, BLOCK, WHILE, FOR, or DO are\n    *     moved into a block.\n+   *   - Add constant annotations based on coding convention.\n    */\n   static class NormalizeStatements implements Callback {\n     private final AbstractCompiler compiler;\n         case Token.FUNCTION:\n           normalizeFunctionDeclaration(n);\n           break;\n+\n+        case Token.NAME:\n+        case Token.STRING:\n+          annotateConstantsByConvention(n, parent);\n+          break;\n+      }\n+    }\n+\n+    /**\n+     * Mark names and properties that are constants by convention.\n+     */\n+    private void annotateConstantsByConvention(Node n, Node parent) {\n+      Preconditions.checkState(\n+          n.getType() == Token.NAME || n.getType() == Token.STRING);\n+\n+      // There are only two cases where a string token\n+      // may be a variable reference: The right side of a GETPROP\n+      // or an OBJECTLIT key.\n+      boolean isObjLitKey = NodeUtil.isObjectLitKey(n, parent);\n+      boolean isProperty = isObjLitKey ||\n+          (parent.getType() == Token.GETPROP &&\n+           parent.getLastChild() == n);\n+      if (n.getType() == Token.NAME || isProperty) {\n+        if (NodeUtil.isConstantByConvention(\n+                compiler.getCodingConvention(), n, parent)) {\n+          n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+          // TODO(nicksantos): Turn this on.\n+          // if (assertOnChange) {\n+          //   String name = n.getString();\n+          //   throw new IllegalStateException(\n+          //       \"Unexpected const change.\\n\" +\n+          //       \"  name: \"+ name + \"\\n\" +\n+          //       \"  gramps:\" + n.getParent().getParent().toStringTree());\n+          // }\n+        }\n       }\n     }\n \n       // Nothing to do.\n     }\n   }\n-\n }\n--- a/src/com/google/javascript/jscomp/PrepareAst.java\n+++ b/src/com/google/javascript/jscomp/PrepareAst.java\n    * around existing JSDoc annotations as well as internal annotations.\n    */\n   static class PrepareAnnotations\n-      extends NodeTraversal.AbstractPostOrderCallback {\n+      implements NodeTraversal.Callback {\n \n     private final CodingConvention convention;\n \n       this.convention = compiler.getCodingConvention();\n     }\n \n+    @Override\n+    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n+      if (n.getType() == Token.OBJECTLIT) {\n+        normalizeObjectLiteralAnnotations(n);\n+      }\n+      return true;\n+    }\n+\n+    @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n       switch (n.getType()) {\n         case Token.CALL:\n           annotateFunctions(n, parent);\n           annotateDispatchers(n, parent);\n           break;\n-\n-        case Token.NAME:\n-        case Token.STRING:\n-          annotateConstants(n, parent);\n-          break;\n-\n-        case Token.OBJECTLIT:\n-          visitObjectLiteral(n);\n-          break;\n-      }\n-    }\n-\n-    private void visitObjectLiteral(Node objlit) {\n+      }\n+    }\n+\n+    private void normalizeObjectLiteralAnnotations(Node objlit) {\n       Preconditions.checkState(objlit.getType() == Token.OBJECTLIT);\n       for (Node key = objlit.getFirstChild();\n            key != null; key = key.getNext()) {\n         Node value = key.getFirstChild();\n-        visitObjectLiteralKey(objlit, key, value);\n-      }\n-    }\n-\n-    /**\n-     * Prepare the object literal keys.\n-     */\n-    private void visitObjectLiteralKey(Node objlit, Node key, Node value) {\n-      normalizeObjectLitJsDocs(objlit, key, value);\n-      annotateObjLitConstants(objlit, key, value);\n+        normalizeObjectLiteralKeyAnnotations(objlit, key, value);\n+      }\n     }\n \n     /**\n      * But in few narrow cases (in particular, function literals), it's\n      * a lot easier for us if the doc is attached to the value.\n      */\n-    private void normalizeObjectLitJsDocs(Node objlit, Node key, Node value) {\n+    private void normalizeObjectLiteralKeyAnnotations(\n+        Node objlit, Node key, Node value) {\n       Preconditions.checkState(objlit.getType() == Token.OBJECTLIT);\n       if (key.getJSDocInfo() != null &&\n           value.getType() == Token.FUNCTION) {\n         value.setJSDocInfo(key.getJSDocInfo());\n-      }\n-    }\n-\n-    /**\n-     * Mark names and properties that are constants by convention.\n-     */\n-    private void annotateConstants(Node n, Node parent) {\n-      Preconditions.checkState(\n-          n.getType() == Token.NAME || n.getType() == Token.STRING);\n-\n-      // There are only two cases where a string token\n-      // may be a variable reference: The right side of a GETPROP\n-      // or an OBJECTLIT key.\n-      if (n.getType() != Token.STRING\n-          || parent.getType() == Token.GETPROP) {\n-        if (NodeUtil.isConstantByConvention(convention, n, parent)) {\n-          n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-        }\n-      }\n-    }\n-\n-    /**\n-     * Mark objlit names that are constants by convention.\n-     */\n-    private void annotateObjLitConstants(Node objlit, Node key, Node value) {\n-      if (key.getType() == Token.NAME || key.getType() == Token.STRING) {\n-        String name = key.getString();\n-        if (convention.isConstantKey(name)) {\n-          key.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-        }\n       }\n     }\n \n--- a/test/com/google/javascript/jscomp/ConstCheckTest.java\n+++ b/test/com/google/javascript/jscomp/ConstCheckTest.java\n     testError(\"var a$b$XYZ = 1; a$b$XYZ <<= 2;\");\n   }\n \n+  public void testConstAnnotation() {\n+    testError(\"/** @const */ var xyz = 1; xyz = 3;\");\n+  }\n+\n   private void testError(String js) {\n     test(js, null, ConstCheck.CONST_REASSIGNED_VALUE_ERROR);\n   }\n--- a/test/com/google/javascript/jscomp/ExpressionDecomposerTest.java\n+++ b/test/com/google/javascript/jscomp/ExpressionDecomposerTest.java\n   }\n \n   private static Node parse(Compiler compiler, String js) {\n-    Node n = compiler.parseTestCode(js);\n+    Node n = Normalize.parseAndNormalizeTestCode(compiler, js, \"\");\n     assertEquals(0, compiler.getErrorCount());\n     return n;\n   }\n--- a/test/com/google/javascript/jscomp/NormalizeTest.java\n+++ b/test/com/google/javascript/jscomp/NormalizeTest.java\n package com.google.javascript.jscomp;\n \n import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n import com.google.javascript.rhino.Node;\n+\n+import java.util.Set;\n \n /**\n  * @author johnlenz@google.com (John Lenz)\n         compiler.toSource(code));\n   }\n \n+  public void testIsConstant() throws Exception {\n+    testSame(\"var CONST = 3; var b = CONST;\");\n+    Node n = getLastCompiler().getRoot();\n+\n+    Set<Node> constantNodes = findNodesWithProperty(n, Node.IS_CONSTANT_NAME);\n+    assertEquals(2, constantNodes.size());\n+    for (Node hasProp : constantNodes) {\n+      assertEquals(\"CONST\", hasProp.getString());\n+    }\n+  }\n+\n+  public void testPropertyIsConstant() throws Exception {\n+    testSame(\"var a = {};a.CONST = 3; var b = a.CONST;\");\n+    Node n = getLastCompiler().getRoot();\n+\n+    Set<Node> constantNodes = findNodesWithProperty(n, Node.IS_CONSTANT_NAME);\n+    assertEquals(2, constantNodes.size());\n+    for (Node hasProp : constantNodes) {\n+      assertEquals(\"CONST\", hasProp.getString());\n+    }\n+  }\n+\n+  private Set<Node> findNodesWithProperty(Node root, final int prop) {\n+    final Set<Node> set = Sets.newHashSet();\n+    NodeTraversal.traverse(\n+        getLastCompiler(), root, new AbstractPostOrderCallback() {\n+        public void visit(NodeTraversal t, Node node, Node parent) {\n+          if (node.getBooleanProp(prop)) {\n+            set.add(node);\n+          }\n+        }\n+      });\n+    return set;\n+  }\n+\n   public void testRenamingConstantProperties() {\n     // In order to detecte that foo.BAR is a constant, we need collapse\n     // properties to run first so that we can tell if the initial value is\n \n     private void testConstantProperties() {\n       test(\"var a={}; a.ACONST = 4;var b = a.ACONST;\",\n-            \"var a$ACONST = 4; var b = a$ACONST;\");\n+           \"var a$ACONST = 4; var b = a$ACONST;\");\n \n       test(\"var a={b:{}}; a.b.ACONST = 4;var b = a.b.ACONST;\",\n            \"var a$b$ACONST = 4;var b = a$b$ACONST;\");", "timestamp": 1289600936, "metainfo": ""}