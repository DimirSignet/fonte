{"sha": "4ade66e558226e1b8d896d24f59c704e311645a5", "log": "Handle a weird edge case where 1) we asks jscompiler to print a bundle 2) there are no input files  R=acleung DELTA=47  (43 added, 2 deleted, 2 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=4155   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n import com.google.common.base.Function;\n import com.google.common.base.Joiner;\n import com.google.common.base.Preconditions;\n+import com.google.common.base.Strings;\n import com.google.common.base.Supplier;\n-import com.google.common.base.Strings;\n import com.google.common.base.Throwables;\n-import com.google.common.io.Files;\n import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n+import com.google.common.io.Files;\n import com.google.javascript.jscomp.CompilerOptions.TweakProcessing;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.TokenStream;\n   private void printBundleTo(Iterable<CompilerInput> inputs, Appendable out)\n       throws IOException {\n     for (CompilerInput input : inputs) {\n+      // Every module has an empty file in it. This makes it easier to implement\n+      // cross-module code motion.\n+      //\n+      // But it also leads to a weird edge case because\n+      // a) If we don't have a module spec, we create a singleton module, and\n+      // b) If we print a bundle file, we copy the original input files.\n+      //\n+      // This means that in the (rare) case where we have no inputs, and no\n+      // module spec, and we're printing a bundle file, we'll have a fake\n+      // input file that shouldn't be copied. So we special-case this, to\n+      // make all the other cases simpler.\n+      if (input.getName().equals(\n+              Compiler.createFillFileName(Compiler.SINGLETON_MODULE_NAME))) {\n+        Preconditions.checkState(1 == Iterables.size(inputs));\n+        return;\n+      }\n+\n       String rootRelativePath = rootRelativePathsMap.get(input.getName());\n       String displayName = rootRelativePath != null\n           ? rootRelativePath\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n  *\n  */\n public class Compiler extends AbstractCompiler {\n+  static final String SINGLETON_MODULE_NAME = \"[singleton]\";\n \n   static final DiagnosticType MODULE_DEPENDENCY_ERROR =\n       DiagnosticType.error(\"JSC_MODULE_DEPENDENCY_ERROR\",\n    */\n   public void init(List<JSSourceFile> externs, List<JSSourceFile> inputs,\n       CompilerOptions options) {\n-    JSModule module = new JSModule(\"[singleton]\");\n+    JSModule module = new JSModule(SINGLETON_MODULE_NAME);\n     for (JSSourceFile input : inputs) {\n       module.add(input);\n     }\n   }\n \n   /**\n+   * Empty modules get an empty \"fill\" file, so that we can move code into\n+   * an empty module.\n+   */\n+  static String createFillFileName(String moduleName) {\n+    return \"[\" + moduleName + \"]\";\n+  }\n+\n+  /**\n    * Fill any empty modules with a place holder file. It makes any cross module\n    * motion easier.\n    */\n   private static void fillEmptyModules(List<JSModule> modules) {\n     for (JSModule module : modules) {\n       if (module.getInputs().isEmpty()) {\n-        module.add(JSSourceFile.fromCode(\"[\" + module.getName() + \"]\", \"\"));\n+        module.add(JSSourceFile.fromCode(\n+            createFillFileName(module.getName()), \"\"));\n       }\n     }\n   }", "timestamp": 1327961055, "metainfo": ""}