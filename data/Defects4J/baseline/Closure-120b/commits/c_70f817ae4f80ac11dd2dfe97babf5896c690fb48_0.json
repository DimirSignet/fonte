{"sha": "70f817ae4f80ac11dd2dfe97babf5896c690fb48", "log": "Add basic getters and setters support to TypeInference.  R=nicksantos DELTA=573  (533 added, 15 deleted, 25 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=366   ", "commit": "\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.TokenStream;\n+import com.google.javascript.rhino.jstype.FunctionType;\n+import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.TernaryValue;\n \n import java.util.Arrays;\n   }\n \n   /**\n+   * Get the name of an object literal key.\n+   *\n+   * @param key A node\n+   */\n+  static String getObjectLitKeyName(Node key) {\n+    switch (key.getType()) {\n+      case Token.NUMBER:\n+        return NodeUtil.getStringValue(key);\n+      case Token.STRING:\n+      case Token.GET:\n+      case Token.SET:\n+        return key.getString();\n+    }\n+    throw new IllegalStateException(\"Unexpected node type: \" + key);\n+  }\n+\n+  /**\n+   * @param key A OBJECTLIT key node.\n+   * @return The type expected when using the key.\n+   */\n+  static JSType getObjectLitKeyTypeFromValueType(Node key, JSType valueType) {\n+    if (valueType != null) {\n+      switch (key.getType()) {\n+        case Token.GET:\n+          // GET must always return a function type.\n+          if (valueType.isFunctionType()) {\n+            FunctionType fntype = ((FunctionType) valueType);\n+            valueType = fntype.getReturnType();\n+          } else {\n+            return null;\n+          }\n+          break;\n+        case Token.SET:\n+          if (valueType.isFunctionType()) {\n+            // SET must always return a function type.\n+            FunctionType fntype = ((FunctionType) valueType);\n+            Node param = fntype.getParametersNode().getFirstChild();\n+            // SET function must always have one parameter.\n+            valueType = param.getJSType();\n+          } else {\n+            return null;\n+          }\n+          break;\n+      }\n+    }\n+    return valueType;\n+  }\n+\n+  /**\n    * Determines whether a node represents an object literal get or set key\n    * (e.g. key1 in {get key1() {}, set key2(a){}).\n    *\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n         break;\n \n       case Token.NUMBER:\n-        if (n.getParent().getType() != Token.OBJECTLIT) {\n+        // Object literal keys are handled with OBJECTLIT\n+        if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n           ensureTyped(t, n, NUMBER_TYPE);\n-        } else {\n-          typeable = false;\n-        }\n+        }\n+        break;\n+\n+      case Token.STRING:\n+        // Object literal keys are handled with OBJECTLIT\n+        if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n+          ensureTyped(t, n, STRING_TYPE);\n+        }\n+        break;\n+\n+      case Token.GET:\n+      case Token.SET:\n+        // Object literal keys are handled with OBJECTLIT\n         break;\n \n       case Token.ARRAYLIT:\n         ensureTyped(t, n, ARRAY_TYPE);\n-        break;\n-\n-      case Token.STRING:\n-        if (n.getParent().getType() != Token.OBJECTLIT) {\n-          ensureTyped(t, n, STRING_TYPE);\n-        } else {\n-          typeable = false;\n-        }\n         break;\n \n       case Token.REGEXP:\n             ensureTyped(t, n);\n           }\n         }\n+        if (n.getType() == Token.OBJECTLIT) {\n+          for (Node key : n.children()) {\n+            visitObjLitKey(t, key, n);\n+          }\n+        }\n         break;\n \n       default:\n       ensureTyped(t, assign, rightType);\n     } else {\n       ensureTyped(t, assign);\n+    }\n+  }\n+\n+  /**\n+   * Visits an object literal field definition <code>key : value</code>.\n+   *\n+   * If the <code>lvalue</code> is a prototype modification, we change the\n+   * schema of the object type it is referring to.\n+   *\n+   * @param t the traversal\n+   * @param key the assign node\n+   */\n+  private void visitObjLitKey(NodeTraversal t, Node key, Node objlit) {\n+    // TODO(johnlenz): Validate get and set function declarations are valid\n+    // as is the functions can have \"extraneous\" bits.\n+\n+    // For getter and setter property definitions the\n+    // rvalue type != the property type.\n+    Node rvalue = key.getFirstChild();\n+    JSType rightType = NodeUtil.getObjectLitKeyTypeFromValueType(\n+        key, getJSType(rvalue));\n+    if (rightType == null) {\n+      rightType = getNativeType(UNKNOWN_TYPE);\n+    }\n+\n+    Node owner = objlit;\n+\n+    // Validate value is assignable to the key type.\n+\n+    JSType keyType = getJSType(key);\n+    boolean valid = validator.expectCanAssignToPropertyOf(t, key,\n+        rightType, keyType,\n+        owner, NodeUtil.getObjectLitKeyName(key));\n+    if (valid) {\n+      ensureTyped(t, key, rightType);\n+    } else {\n+      ensureTyped(t, key);\n+    }\n+\n+    // Validate that the key type is assignable to the object property type.\n+    // This is necessary as the objlit may have been cast to a non-literal\n+    // object type.\n+    // TODO(johnlenz): consider introducing a CAST node to the AST (or\n+    // perhaps a parentheses node).\n+\n+    JSType objlitType = getJSType(objlit);\n+    ObjectType type = ObjectType.cast(\n+        objlitType.restrictByNotNullOrUndefined());\n+    if (type != null) {\n+      String property = NodeUtil.getObjectLitKeyName(key);\n+      if (type.hasProperty(property) &&\n+          !type.isPropertyTypeInferred(property) &&\n+          !propertyIsImplicitCast(type, property)) {\n+        validator.expectCanAssignToPropertyOf(\n+            t, key, keyType,\n+            type.getPropertyType(property), owner, property);\n+      }\n+      return;\n     }\n   }\n \n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n          name = name.getNext()) {\n       Node value = name.getFirstChild();\n       scope = traverse(value, scope);\n-      String memberName = NodeUtil.getStringValue(name);\n+      String memberName = NodeUtil.getObjectLitKeyName(name);\n       if (memberName != null) {\n-        objectType.defineInferredProperty(memberName, getJSType(value), false,\n-            name);\n+        JSType rawValueType =  name.getFirstChild().getJSType();\n+        JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(\n+            name, rawValueType);\n+        if (valueType == null) {\n+          valueType = getNativeType(UNKNOWN_TYPE);\n+        }\n+        objectType.defineInferredProperty(memberName, valueType, false, name);\n       } else {\n         n.setJSType(getNativeType(UNKNOWN_TYPE));\n-        return scope;\n       }\n     }\n     return scope;\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n           break;\n \n         case Token.STRING:\n-          n.setJSType(getNativeType(STRING_TYPE));\n+          // Defer keys to the Token.OBJECTLIT case\n+          if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n+            n.setJSType(getNativeType(STRING_TYPE));\n+          }\n           break;\n \n         case Token.NUMBER:\n-          n.setJSType(getNativeType(NUMBER_TYPE));\n+          // Defer keys to the Token.OBJECTLIT case\n+          if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n+            n.setJSType(getNativeType(NUMBER_TYPE));\n+          }\n           break;\n \n         case Token.TRUE:\n      */\n     void processObjectLitProperties(\n         NodeTraversal t, Node objLit, ObjectType objLitType) {\n-      // TODO(nicksantos): Even if the type of the object literal is null,\n-      // we may want to declare its properties in the current scope.\n-      if (objLitType == null) {\n-        return;\n-      }\n-\n       for (Node name = objLit.getFirstChild(); name != null;\n            name = name.getNext()) {\n         Node value = name.getFirstChild();\n-        String memberName = NodeUtil.getStringValue(name);\n-        JSType type = getDeclaredTypeInAnnotation(\n+        String memberName = NodeUtil.getObjectLitKeyName(name);\n+        JSType valueType = getDeclaredTypeInAnnotation(\n             t, name, name.getJSDocInfo());\n-        if (type != null) {\n-          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n-          objLitType.defineDeclaredProperty(\n-              memberName, type, isExtern, name);\n+        JSType keyType = NodeUtil.getObjectLitKeyTypeFromValueType(\n+            name, valueType);\n+        if (keyType != null) {\n+          name.setJSType(keyType);\n+          // TODO(nicksantos): Even if the type of the object literal is null,\n+          // we may want to declare its properties in the current scope.\n+          if (objLitType != null) {\n+            boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n+            objLitType.defineDeclaredProperty(\n+                memberName, keyType, isExtern, name);\n+          }\n         }\n       }\n     }\n           Node key = value.getFirstChild();\n           while (key != null) {\n             String keyName = NodeUtil.getStringValue(key);\n-\n-            if (enumType.hasOwnProperty(keyName)) {\n+            if (keyName == null) {\n+              // GET and SET don't have a String value;\n+              compiler.report(\n+                  JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n+            } else if (enumType.hasOwnProperty(keyName)) {\n               compiler.report(JSError.make(sourceName, key, ENUM_DUP, keyName));\n             } else if (!codingConvention.isValidEnumKey(keyName)) {\n               compiler.report(\n--- a/test/com/google/javascript/jscomp/AmbiguatePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/AmbiguatePropertiesTest.java\n     test(js, output);\n   }\n \n-  public void testPrototypePropertiesAsObjLitKeys() {\n+  public void testPrototypePropertiesAsObjLitKeys1() {\n+    test(\"/** @constructor */ function Bar() {};\" +\n+             \"Bar.prototype = {2: function(){}, getA: function(){}};\",\n+             \"/** @constructor */ function Bar() {};\" +\n+             \"Bar.prototype = {2: function(){}, a: function(){}};\");\n+  }\n+\n+  public void testPrototypePropertiesAsObjLitKeys2() {\n     testSame(\"/** @constructor */ function Bar() {};\" +\n-             \"Bar.prototype = {2: function(){}, getA: function(){}};\");\n+             \"Bar.prototype = {2: function(){}, 'getA': function(){}};\");\n   }\n \n   public void testQuotedPrototypeProperty() {\n--- a/test/com/google/javascript/jscomp/CompilerTypeTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTypeTestCase.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.javascript.jscomp.CompilerOptions.LanguageMode;\n import com.google.javascript.rhino.testing.BaseJSTypeTestCase;\n \n abstract class CompilerTypeTestCase extends BaseJSTypeTestCase {\n \n   protected CompilerOptions getOptions() {\n     CompilerOptions options = new CompilerOptions();\n+    options.languageIn = LanguageMode.ECMASCRIPT5;\n     options.setWarningLevel(\n         DiagnosticGroups.MISSING_PROPERTIES, CheckLevel.WARNING);\n     options.setCodingConvention(getCodingConvention());\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n         \"/** @return {string} */ T.prototype.f = function() {\\n\" +\n         \"return goog.isString(this.a) ? this.a : 'a'; }\", null);\n   }\n+\n+  public void testQualifiedNameReduction5a() throws Exception {\n+    testTypes(\"var x = {/** @type {string} */ a:'b' };\\n\" +\n+        \"/** @return {string} */ var f = function() {\\n\" +\n+        \"return x.a; }\");\n+  }\n+\n+  public void testQualifiedNameReduction5b() throws Exception {\n+    testTypes(\n+        \"var x = {/** @type {number} */ a:12 };\\n\" +\n+        \"/** @return {string} */\\n\" +\n+        \"var f = function() {\\n\" +\n+        \"  return x.a;\\n\" +\n+        \"}\");  // would like this to be an error.\n+  }\n+\n+  public void testQualifiedNameReduction5c() throws Exception {\n+    testTypes(\n+        \"/** @return {string} */ var f = function() {\\n\" +\n+        \"var x = {/** @type {number} */ a:0 };\\n\" +\n+        \"return (x.a) ? (x.a) : 'a'; }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : (number|string)\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testQualifiedNameReduction6() throws Exception {\n+    testTypes(\n+        \"/** @return {string} */ var f = function() {\\n\" +\n+        \"var x = {/** @return {string?} */ get a() {return 'a'}};\\n\" +\n+        \"return x.a ? x.a : 'a'; }\");\n+  }\n+\n+  public void testQualifiedNameReduction7() throws Exception {\n+    testTypes(\n+        \"/** @return {string} */ var f = function() {\\n\" +\n+        \"var x = {/** @return {number} */ get a() {return 12}};\\n\" +\n+        \"return x.a; }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testQualifiedNameReduction7a() throws Exception {\n+    // It would be nice to find a way to make this an error.\n+    testTypes(\n+        \"/** @return {string} */ var f = function() {\\n\" +\n+        \"var x = {get a() {return 12}};\\n\" +\n+        \"return x.a; }\");\n+  }\n+\n+  public void testQualifiedNameReduction8() throws Exception {\n+    testTypes(\n+        \"/** @return {string} */ var f = function() {\\n\" +\n+        \"var x = {get a() {return 'a'}};\\n\" +\n+        \"return x.a ? x.a : 'a'; }\");\n+  }\n+\n+  public void testQualifiedNameReduction9() throws Exception {\n+    testTypes(\n+        \"/** @return {string} */ var f = function() {\\n\" +\n+        \"var x = { /** @param {string} b */ set a(b) {}};\\n\" +\n+        \"return x.a ? x.a : 'a'; }\");\n+  }\n+\n+  public void testQualifiedNameReduction10() throws Exception {\n+    // TODO(johnlenz): separate setter property types from getter property\n+    // types.\n+    testTypes(\n+        \"/** @return {string} */ var f = function() {\\n\" +\n+        \"var x = { /** @param {number} b */ set a(b) {}};\\n\" +\n+        \"return x.a ? x.a : 'a'; }\",\n+        \"inconsistent return type\\n\" +\n+        \"found   : (number|string)\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testObjLitDef1a() throws Exception {\n+    testTypes(\n+        \"var x = {/** @type {number} */ a:12 };\\n\" +\n+        \"x.a = 'a';\",\n+        \"assignment to property a of x\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testObjLitDef1b() throws Exception {\n+    testTypes(\n+        \"function f(){\" +\n+          \"var x = {/** @type {number} */ a:12 };\\n\" +\n+          \"x.a = 'a';\" +\n+        \"};\\n\" +\n+        \"f();\",\n+        \"assignment to property a of x\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testObjLitDef2a() throws Exception {\n+    testTypes(\n+        \"var x = {/** @param {number} b */ set a(b){} };\\n\" +\n+        \"x.a = 'a';\",\n+        \"assignment to property a of x\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testObjLitDef2b() throws Exception {\n+    testTypes(\n+        \"function f(){\" +\n+          \"var x = {/** @param {number} b */ set a(b){} };\\n\" +\n+          \"x.a = 'a';\" +\n+        \"};\\n\" +\n+        \"f();\",\n+        \"assignment to property a of x\\n\" +\n+        \"found   : string\\n\" +\n+        \"required: number\");\n+  }\n+\n+  public void testObjLitDef3a() throws Exception {\n+    testTypes(\n+        \"/** @type {string} */ var y;\\n\" +\n+        \"var x = {/** @return {number} */ get a(){} };\\n\" +\n+        \"y = x.a;\",\n+        \"assignment\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testObjLitDef3b() throws Exception {\n+    testTypes(\n+      \"/** @type {string} */ var y;\\n\" +\n+        \"function f(){\" +\n+          \"var x = {/** @return {number} */ get a(){} };\\n\" +\n+          \"y = x.a;\" +\n+        \"};\\n\" +\n+        \"f();\",\n+        \"assignment\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testObjLitDef4() throws Exception {\n+    testTypes(\n+        \"var x = {\" +\n+          \"/** @return {number} */ a:12 };\\n\",\n+          \"assignment to property a of {a: function (): number}\\n\" +\n+          \"found   : number\\n\" +\n+          \"required: function (): number\");\n+  }\n+\n+  public void testObjLitDef5() throws Exception {\n+    testTypes(\n+        \"var x = {};\\n\" +\n+        \"/** @return {number} */ x.a = 12;\\n\",\n+        \"assignment to property a of x\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: function (): number\");\n+  }\n+\n \n   public void testInstanceOfReduction1() throws Exception {\n     testTypes(\"/** @constructor */ var T = function() {};\\n\" +\n   }\n \n   public void testCast16() throws Exception {\n+    // A type cast should not invalidate the checks on the members\n+    testTypes(\n+        \"for (var i = 0; i < 10; i++) {\" +\n+          \"var x = /** @type {Object|number} */ (\" +\n+          \"  {/** @type {string} */ foo: 3});\" +\n+        \"}\",\n+        \"assignment to property foo of (Object|null|number)\\n\" +\n+        \"found   : number\\n\" +\n+        \"required: string\");\n+  }\n+\n+  public void testCast17() throws Exception {\n     // Mostly verifying that rhino actually understands these JsDocs.\n     testTypes(\"/** @constructor */ function Foo() {} \\n\" +\n         \"/** @type {Foo} */ var x = /** @type {Foo} */ ({})\");\n--- a/test/com/google/javascript/jscomp/TypeInferenceTest.java\n+++ b/test/com/google/javascript/jscomp/TypeInferenceTest.java\n import com.google.common.base.Joiner;\n import com.google.common.collect.Maps;\n import com.google.javascript.jscomp.CodingConvention.AssertionFunctionSpec;\n+import com.google.javascript.jscomp.CompilerOptions.LanguageMode;\n import com.google.javascript.jscomp.DataFlowAnalysis.BranchedFlowState;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.jstype.EnumType;\n   @Override\n   public void setUp() {\n     compiler = new Compiler();\n-    compiler.initOptions(new CompilerOptions());\n+    CompilerOptions options = new CompilerOptions();\n+    options.languageIn = LanguageMode.ECMASCRIPT5;\n+    compiler.initOptions(options);\n     registry = compiler.getTypeRegistry();\n     assumptions = Maps.newHashMap();\n     returnScope = null;\n                + \"try { throw new Error(x = 3); } catch (ex) {}\");\n     verify(\"x\", NUMBER_TYPE);\n   }\n+\n+  public void testObjectLit() {\n+    inFunction(\"var x = {}; var out = x.a;\");\n+    verify(\"out\", UNKNOWN_TYPE);  // Shouldn't this be 'undefined'?\n+\n+    inFunction(\"var x = {a:1}; var out = x.a;\");\n+    verify(\"out\", NUMBER_TYPE);\n+\n+    inFunction(\"var x = { get a() {return 1} }; var out = x.a;\");\n+    verify(\"out\", UNKNOWN_TYPE);\n+\n+    inFunction(\n+        \"var x = {\" +\n+        \"  /** @return {number} */ get a() {return 1}\" +\n+        \"};\" +\n+        \"var out = x.a;\");\n+    verify(\"out\", NUMBER_TYPE);\n+\n+    inFunction(\"var x = { set a(b) {} }; var out = x.a;\");\n+    verify(\"out\", UNKNOWN_TYPE);\n+\n+    inFunction(\"var x = { \" +\n+            \"/** @param {number} b */ set a(b) {} };\" +\n+            \"var out = x.a;\");\n+    verify(\"out\", NUMBER_TYPE);\n+  }\n }\n--- a/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n+++ b/test/com/google/javascript/jscomp/TypedScopeCreatorTest.java\n     assertEquals(Lists.newArrayList(foo), registry.getTypesWithProperty(\"Bar\"));\n   }\n \n-  public void testInferredProperty() {\n+  public void testInferredProperty1() {\n     testSame(\"var foo = {}; foo.Bar = 3;\");\n     ObjectType foo = (ObjectType) findNameType(\"foo\", globalScope);\n     assertTrue(foo.toString(), foo.hasProperty(\"Bar\"));\n     assertTrue(foo.isPropertyTypeInferred(\"Bar\"));\n   }\n \n+  public void testInferredProperty1a() {\n+    testSame(\"var foo = {}; /** @type {number} */ foo.Bar = 3;\");\n+    ObjectType foo = (ObjectType) findNameType(\"foo\", globalScope);\n+    assertTrue(foo.toString(), foo.hasProperty(\"Bar\"));\n+    assertEquals(\"number\", foo.getPropertyType(\"Bar\").toString());\n+    assertFalse(foo.isPropertyTypeInferred(\"Bar\"));\n+  }  \n+\n+  public void testInferredProperty2() {\n+    testSame(\"var foo = { Bar: 3 };\");\n+    ObjectType foo = (ObjectType) findNameType(\"foo\", globalScope);\n+    assertTrue(foo.toString(), foo.hasProperty(\"Bar\"));\n+    assertEquals(\"number\", foo.getPropertyType(\"Bar\").toString());\n+    assertTrue(foo.isPropertyTypeInferred(\"Bar\"));\n+  }  \n+\n+  public void testInferredProperty2b() {\n+    testSame(\"var foo = { /** @type {number} */ Bar: 3 };\");\n+    ObjectType foo = (ObjectType) findNameType(\"foo\", globalScope);\n+    assertTrue(foo.toString(), foo.hasProperty(\"Bar\"));\n+    assertEquals(\"number\", foo.getPropertyType(\"Bar\").toString());\n+    assertFalse(foo.isPropertyTypeInferred(\"Bar\"));\n+  }  \n+\n+  public void testInferredProperty2c() {\n+    testSame(\"var foo = { /** @return {number} */ Bar: 3 };\");\n+    ObjectType foo = (ObjectType) findNameType(\"foo\", globalScope);\n+    assertTrue(foo.toString(), foo.hasProperty(\"Bar\"));\n+    assertEquals(\"function (): number\", foo.getPropertyType(\"Bar\").toString());\n+    assertFalse(foo.isPropertyTypeInferred(\"Bar\"));\n+  }  \n+\n+  public void testInferredProperty3() {\n+    testSame(\"var foo = { /** @type {number} */ get Bar() { return 3 } };\");\n+    ObjectType foo = (ObjectType) findNameType(\"foo\", globalScope);\n+    assertTrue(foo.toString(), foo.hasProperty(\"Bar\"));\n+    assertEquals(\"?\", foo.getPropertyType(\"Bar\").toString());\n+    assertTrue(foo.isPropertyTypeInferred(\"Bar\"));\n+  }\n+\n+  public void testInferredProperty4() {\n+    testSame(\"var foo = { /** @type {number} */ set Bar(a) {} };\");\n+    ObjectType foo = (ObjectType) findNameType(\"foo\", globalScope);\n+    assertTrue(foo.toString(), foo.hasProperty(\"Bar\"));\n+    assertEquals(\"?\", foo.getPropertyType(\"Bar\").toString());\n+    assertTrue(foo.isPropertyTypeInferred(\"Bar\"));\n+  }  \n+\n+  public void testInferredProperty5() {\n+    testSame(\"var foo = { /** @return {number} */ get Bar() { return 3 } };\");\n+    ObjectType foo = (ObjectType) findNameType(\"foo\", globalScope);\n+    assertTrue(foo.toString(), foo.hasProperty(\"Bar\"));\n+    assertEquals(\"number\", foo.getPropertyType(\"Bar\").toString());\n+    assertFalse(foo.isPropertyTypeInferred(\"Bar\"));\n+  }\n+\n+  public void testInferredProperty6() {\n+    testSame(\"var foo = { /** @param {number} a */ set Bar(a) {} };\");\n+    ObjectType foo = (ObjectType) findNameType(\"foo\", globalScope);\n+    assertTrue(foo.toString(), foo.hasProperty(\"Bar\"));\n+    assertEquals(\"number\", foo.getPropertyType(\"Bar\").toString());\n+    assertFalse(foo.isPropertyTypeInferred(\"Bar\"));\n+  }   \n+\n   public void testPrototypeInit() {\n     testSame(\"/** @constructor */ var Foo = function() {};\" +\n         \"Foo.prototype = {bar: 1}; var foo = new Foo();\");\n     assertTrue(foo.isPropertyTypeInferred(\"bar\"));\n   }\n \n-  public void testInferredPrototypeProperty() {\n+  public void testInferredPrototypeProperty1() {\n     testSame(\"/** @constructor */ var Foo = function() {};\" +\n         \"Foo.prototype.bar = 1; var x = new Foo();\");\n+\n+    ObjectType x = (ObjectType) findNameType(\"x\", globalScope);\n+    assertTrue(x.hasProperty(\"bar\"));\n+    assertEquals(\"number\", x.getPropertyType(\"bar\").toString());\n+    assertTrue(x.isPropertyTypeInferred(\"bar\"));\n+  }\n+\n+  public void testInferredPrototypeProperty2() {\n+    testSame(\"/** @constructor */ var Foo = function() {};\" +\n+        \"Foo.prototype = {bar: 1}; var x = new Foo();\");\n \n     ObjectType x = (ObjectType) findNameType(\"x\", globalScope);\n     assertTrue(x.hasProperty(\"bar\"));\n     assertFalse(x.isPropertyTypeInferred(\"foo\"));\n   }\n \n-  public void testPropertyOnUnknownSuperClass() {\n+  public void testPropertyOnUnknownSuperClass1() {\n     testSame(\n         \"var goog = this.foo();\" +\n         \"/** @constructor \\n * @extends {goog.Unknown} */\" +\n     assertTrue(x.isPropertyTypeInferred(\"bar\"));\n   }\n \n-  public void testMethodBeforeFunction() throws Exception {\n+  public void testPropertyOnUnknownSuperClass2() {\n+    testSame(\n+        \"var goog = this.foo();\" +\n+        \"/** @constructor \\n * @extends {goog.Unknown} */\" +\n+        \"function Foo() {}\" +\n+        \"Foo.prototype = {bar: 1};\" +\n+        \"var x = new Foo();\",\n+        RhinoErrorReporter.PARSE_ERROR);\n+    ObjectType x = (ObjectType) findNameType(\"x\", globalScope);\n+    assertEquals(\"Foo\", x.toString());\n+    // Should be true\n+    assertFalse(x.getImplicitPrototype().hasOwnProperty(\"bar\"));\n+    assertEquals(\"number\", x.getPropertyType(\"bar\").toString());\n+    assertTrue(x.isPropertyTypeInferred(\"bar\"));\n+  }\n+\n+  public void testMethodBeforeFunction1() throws Exception {\n     testSame(\n         \"var y = Window.prototype;\" +\n         \"Window.prototype.alert = function(message) {};\" +\n         y.getPropertyType(\"alert\").toString());\n   }\n \n+  public void testMethodBeforeFunction2() throws Exception {\n+    testSame(\n+        \"var y = Window.prototype;\" +\n+        \"Window.prototype = {alert: function(message) {}};\" +\n+        \"/** @constructor */ function Window() {}\\n\" +\n+        \"var window = new Window(); \\n\" +\n+        \"var x = window;\");\n+    ObjectType x = (ObjectType) findNameType(\"x\", globalScope);\n+    assertEquals(\"Window\", x.toString());\n+    // This should be TRUE\n+    assertFalse(x.getImplicitPrototype().hasOwnProperty(\"alert\"));\n+    /*\n+    assertEquals(\"function (this:Window, ?): undefined\",\n+        x.getPropertyType(\"alert\").toString());\n+    assertTrue(x.isPropertyTypeDeclared(\"alert\"));\n+\n+    ObjectType y = (ObjectType) findNameType(\"y\", globalScope);\n+    assertEquals(\"function (this:Window, ?): undefined\",\n+        y.getPropertyType(\"alert\").toString());\n+    */\n+  }\n+\n   public void testAddMethodsPrototypeTwoWays() throws Exception {\n     testSame(\n         \"/** @constructor */function A() {}\" +\n     assertEquals(iPrototype, globalScope.getVar(\"I.prototype\").getType());\n   }\n \n+  public void testPropertiesOnInterface2() throws Exception {\n+    testSame(\"/** @interface */ var I = function() {};\" +\n+        \"I.prototype = {baz: function(){}};\" +\n+        \"/** @type {number} */ I.prototype.bar;\");\n+\n+    Var i = globalScope.getVar(\"I\");\n+    assertEquals(\"function (this:I): ?\", i.getType().toString());\n+    assertTrue(i.getType().isInterface());\n+\n+    ObjectType iPrototype = (ObjectType)\n+        ((ObjectType) i.getType()).getPropertyType(\"prototype\");\n+    assertEquals(\"I.prototype\", iPrototype.toString());\n+    assertTrue(iPrototype.isFunctionPrototypeType());\n+\n+    assertEquals(\"number\", iPrototype.getPropertyType(\"bar\").toString());\n+    \n+    // should be: \"function (this:I): undefined\"\n+    assertEquals(\"function (): undefined\",\n+        iPrototype.getPropertyType(\"baz\").toString());\n+\n+    // should not be null \n+    assertNull(globalScope.getVar(\"I.prototype\"));\n+    // assertEquals(iPrototype, globalScope.getVar(\"I.prototype\").getType());\n+  }\n+\n+  // TODO(johnlenz): A syntax for stubs using object literals?\n+\n   public void testStubsInExterns() {\n     testSame(\n         \"/** @constructor */ function Extern() {}\" +\n     assertFalse(a.hasProperty(\"name\"));\n   }\n \n-  public void testGlobalThis() {\n+  public void testGlobalThis1() {\n     testSame(\n         \"/** @constructor */ function Window() {}\" +\n         \"Window.prototype.alert = function() {};\" +\n     assertTrue(x.hasProperty(\"alert\"));\n   }\n \n+  public void testGlobalThis2() {\n+    testSame(\n+        \"/** @constructor */ function Window() {}\" +\n+        \"Window.prototype = {alert: function() {}};\" +\n+        \"var x = this;\");\n+\n+    ObjectType x = (ObjectType) (globalScope.getVar(\"x\").getType());\n+    FunctionType windowCtor =\n+        (FunctionType) (globalScope.getVar(\"Window\").getType());\n+    assertEquals(\"global this\", x.toString());\n+    assertTrue(x.isSubtype(windowCtor.getInstanceType()));\n+    assertFalse(x.equals(windowCtor.getInstanceType()));\n+    assertTrue(x.hasProperty(\"alert\"));\n+  }\n+\n   public void testObjectLiteralCast() {\n+    // Verify that \"goog.reflect.object\" does not modify the types on\n+    // \"A.B\"\n     testSame(\"/** @constructor */ A.B = function() {}\\n\" +\n              \"A.B.prototype.isEnabled = true;\\n\" +\n              \"goog.reflect.object(A.B, {isEnabled: 3})\\n\" +\n         findNameType(\"y\", globalScope).toString());\n   }\n \n+  public void testAbstractMethod4() {\n+    testSame(\n+        \"/** @type {!Function} */ var abstractMethod;\" +\n+        \"/** @constructor */ function Foo() {}\" +\n+        \"Foo.prototype = {/** @param {number} x */ bar: abstractMethod};\");\n+    assertEquals(\n+        \"Function\", findNameType(\"abstractMethod\", globalScope).toString());\n+\n+    FunctionType ctor = (FunctionType) findNameType(\"Foo\", globalScope);\n+    ObjectType instance = ctor.getInstanceType();\n+    assertEquals(\"Foo\", instance.toString());\n+\n+    ObjectType proto = instance.getImplicitPrototype();\n+    assertEquals(\"Foo.prototype\", proto.toString());\n+\n+    assertEquals(\n+        // should be: \"function (this:Foo, number): ?\"\n+        \"function (number): ?\",  \n+        proto.getPropertyType(\"bar\").toString());\n+  }\n+\n   public void testActiveXObject() {\n     testSame(\n         CompilerTypeTestCase.ACTIVE_X_OBJECT_DEF,", "timestamp": 1296153235, "metainfo": ""}