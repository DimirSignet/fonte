{"sha": "76b2fd60f886f3bf7674f11b5b479b50ee9b7e27", "log": "Improvements to inline jsdoc parsing ------------- Created by MOE: http://code.google.com/p/moe-java MOE_MIGRATED_REVID=42869456", "commit": "\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n     return sourceFile == null ? null : sourceFile.getName();\n   }\n \n+  /**\n+   * Parse a description as a {@code @type}.\n+   */\n   public JSDocInfo parseInlineTypeDoc() {\n+    skipEOLs();\n+\n     Node typeAst = parseAndRecordTypeNode(next());\n     JSTypeExpression expr = createJSTypeExpression(typeAst);\n     if (expr != null) {\n \n     JsDocToken token = next();\n \n-    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();\n-\n     // Always record that we have a comment.\n     if (jsdocBuilder.shouldParseDocumentation()) {\n       ExtractionInfo blockInfo = extractBlockComment(token);\n       }\n     }\n \n-    // Parse the actual JsDoc.\n+    return parseHelperLoop(token, Lists.<ExtendedTypeInfo>newArrayList());\n+  }\n+\n+  private boolean parseHelperLoop(JsDocToken token,\n+                                  List<ExtendedTypeInfo> extendedTypes) {\n     while (true) {\n       switch (token) {\n         case ANNOTATION:\n           return eatTokensUntilEOL();\n       }\n     }\n+\n     return next();\n-  };\n+  }\n \n   private void checkExtendedTypes(List<ExtendedTypeInfo> extendedTypes) {\n     for (ExtendedTypeInfo typeInfo : extendedTypes) {\n--- a/test/com/google/javascript/jscomp/parsing/ParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/ParserTest.java\n     assertNotNull(exprCall.getFirstChild().getJSDocInfo());\n   }\n \n-  public void testJSDocAttachment17() {\n+  public void testInlineJSDocAttachment1() {\n     Node fn = parse(\"function f(/** string */ x) {}\").getFirstChild();\n     assertTrue(fn.isFunction());\n \n     assertTypeEquals(STRING_TYPE, info.getType());\n   }\n \n-  public void testJSDocAttachment18() {\n-    Node fn = parse(\"function f(/** {string} */ x) {}\").getFirstChild();\n+  public void testInlineJSDocAttachment2() {\n+    Node fn = parse(\n+        \"function f(/**\\n\" +\n+        \" * {string}\\n\" +\n+        \" */ x) {}\").getFirstChild();\n     assertTrue(fn.isFunction());\n \n     JSDocInfo info =\n         fn.getFirstChild().getNext().getFirstChild().getJSDocInfo();\n     assertNotNull(info);\n     assertTypeEquals(STRING_TYPE, info.getType());\n+  }\n+\n+  public void testInlineJSDocAttachment3() {\n+    parse(\n+        \"function f(/** @type {string} */ x) {}\",\n+        \"Bad type annotation. type not recognized due to syntax error\");\n+  }\n+\n+  public void testInlineJSDocAttachment4() {\n+    parse(\n+        \"function f(/**\\n\" +\n+        \" * @type {string}\\n\" +\n+        \" */ x) {}\",\n+        \"Bad type annotation. type not recognized due to syntax error\");\n   }\n \n   public void testIncorrectJSDocDoesNotAlterJSParsing1() throws Exception {", "timestamp": 1361486424, "metainfo": ""}