{"sha": "efefb736fccc2039b5fb079710b3f2ac82b8c6e4", "log": "Fix issue 873 Converting from an interface type to a constructor which @implements itself causes stack overflow.  R=johnlenz,nicksantos,dimvar   Revision created by MOE tool push_codebase. MOE_MIGRATION=5982   ", "commit": "\n--- a/src/com/google/javascript/rhino/jstype/NamedType.java\n+++ b/src/com/google/javascript/rhino/jstype/NamedType.java\n     // makes more sense. Now, resolution via registry is first in order to\n     // avoid triggering the warnings built into the resolution via properties.\n     boolean resolved = resolveViaRegistry(t, enclosing);\n-    if (detectImplicitPrototypeCycle()) {\n+    if (detectInheritanceCycle()) {\n       handleTypeCycle(t);\n     }\n \n     }\n \n     resolveViaProperties(t, enclosing);\n-    if (detectImplicitPrototypeCycle()) {\n+    if (detectInheritanceCycle()) {\n       handleTypeCycle(t);\n     }\n \n--- a/src/com/google/javascript/rhino/jstype/ObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ObjectType.java\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Iterables;\n import com.google.common.collect.Sets;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n    * the {@link #getImplicitPrototype()} method and must therefore be\n    * invoked only after the object is sufficiently initialized to respond to\n    * calls to this method.<p>\n-   *\n-   * The method is not thread safe.<p>\n    *\n    * @return True iff an implicit prototype cycle was detected.\n    */\n       p = p.getImplicitPrototype();\n     } while (p != null);\n     return false;\n+  }\n+\n+  /**\n+   * Detects cycles in either the implicit prototype chain, or the implemented/extended\n+   * interfaces.<p>\n+   *\n+   * @return True iff a cycle was detected.\n+   */\n+  final boolean detectInheritanceCycle() {\n+    // TODO(user): This should get moved to preventing cycles in FunctionTypeBuilder\n+    // rather than removing them here after they have been created.\n+    // Also, this doesn't do the right thing for extended interfaces, though that is\n+    // masked by another bug.\n+    return detectImplicitPrototypeCycle()\n+        || Iterables.contains(this.getCtorImplementedInterfaces(), this)\n+        || Iterables.contains(this.getCtorExtendedInterfaces(), this);\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n             \"Could not resolve type in @extends tag of T\"));\n   }\n \n+  public void testImplementsLoop() throws Exception {\n+    testClosureTypesMultipleWarnings(\n+        suppressMissingProperty(\"foo\") +\n+        \"/** @constructor \\n * @implements {T} */var T = function() {};\" +\n+        \"alert((new T).foo);\",\n+        Lists.newArrayList(\n+            \"Parse error. Cycle detected in inheritance chain of type T\"));\n+  }\n+\n+  public void testImplementsExtendsLoop() throws Exception {\n+    testClosureTypesMultipleWarnings(\n+        suppressMissingProperty(\"foo\") +\n+            \"/** @constructor \\n * @implements {F} */var G = function() {};\" +\n+            \"/** @constructor \\n * @extends {G} */var F = function() {};\" +\n+        \"alert((new F).foo);\",\n+        Lists.newArrayList(\n+            \"Parse error. Cycle detected in inheritance chain of type F\"));\n+  }\n+\n+  public void testInterfaceExtendsLoop() throws Exception {\n+    // TODO(user): This should give a cycle in inheritance graph error,\n+    // not a cannot resolve error.\n+    testClosureTypesMultipleWarnings(\n+        suppressMissingProperty(\"foo\") +\n+            \"/** @interface \\n * @extends {F} */var G = function() {};\" +\n+            \"/** @interface \\n * @extends {G} */var F = function() {};\",\n+        Lists.newArrayList(\n+            \"Could not resolve type in @extends tag of G\"));\n+  }\n+\n+  public void testConversionFromInterfaceToRecursiveConstructor()\n+      throws Exception {\n+    testClosureTypesMultipleWarnings(\n+        suppressMissingProperty(\"foo\") +\n+            \"/** @interface */ var OtherType = function() {}\\n\" +\n+            \"/** @implements {MyType} \\n * @constructor */\\n\" +\n+            \"var MyType = function() {}\\n\" +\n+            \"/** @type {MyType} */\\n\" +\n+            \"var x = /** @type {!OtherType} */ (new Object());\",\n+        Lists.newArrayList(\n+            \"Parse error. Cycle detected in inheritance chain of type MyType\",\n+            \"initializing variable\\n\" +\n+            \"found   : OtherType\\n\" +\n+            \"required: (MyType|null)\"));\n+  }\n+\n   public void testDirectPrototypeAssign() throws Exception {\n     // For now, we just ignore @type annotations on the prototype.\n     testTypes(", "timestamp": 1355516430, "metainfo": ""}