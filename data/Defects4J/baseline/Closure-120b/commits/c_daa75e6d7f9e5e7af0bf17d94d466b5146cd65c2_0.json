{"sha": "daa75e6d7f9e5e7af0bf17d94d466b5146cd65c2", "log": "Fix up isNominalConstructor, and add proper tests for it  R=johnlenz DELTA=58  (48 added, 0 deleted, 10 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3217   ", "commit": "\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n    * Does not include structural constructors.\n    */\n   public final boolean isNominalConstructor() {\n-    return (isConstructor() || isInterface()) &&\n-        toMaybeFunctionType().getInstanceType().isNominalType();\n+    if (isConstructor() || isInterface()) {\n+      FunctionType fn = toMaybeFunctionType();\n+      if (fn == null) {\n+        return false;\n+      }\n+\n+      // Programmer-defined constructors will have a link\n+      // back to the original function in the source tree.\n+      // Structural constructors will not.\n+      if (fn.getSource() != null) {\n+        return true;\n+      }\n+\n+      // Native constructors are always nominal.\n+      return fn.isNativeObjectType();\n+    }\n+    return false;\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n     testParseType(\"function (?): (?|number)\", \"function (?): ?\");\n   }\n \n-  public void testParseFunctionalType19() throws Exception {\n-    testParseType(\"function (new:Object)\", \"function (new:Object): ?\");\n+  public void testStructuralConstructor() throws Exception {\n+    JSType type = testParseType(\n+        \"function (new:Object)\", \"function (new:Object): ?\");\n+    assertTrue(type.isConstructor());\n+    assertFalse(type.isNominalConstructor());\n+  }\n+\n+  public void testNominalConstructor() throws Exception {\n+    ObjectType type = testParseType(\"Array\", \"(Array|null)\").dereference();\n+    assertTrue(type.getConstructor().isNominalConstructor());\n   }\n \n   public void testBug1419535() throws Exception {\n         \"Bad type annotation. missing closing ]\");\n   }\n \n-  private void testParseType(String type) throws Exception {\n-    testParseType(type, type);\n-  }\n-\n-  private void testParseType(\n+  private JSType testParseType(String type) throws Exception {\n+    return testParseType(type, type);\n+  }\n+\n+  private JSType testParseType(\n       String type, String typeExpected) throws Exception {\n     JSDocInfo info = parse(\"@type {\" + type + \"}*/\");\n \n     assertNotNull(info);\n     assertTrue(info.hasType());\n-    assertEquals(typeExpected, resolve(info.getType()).toString());\n+\n+    JSType actual = resolve(info.getType());\n+    assertEquals(typeExpected, actual.toString());\n+    return actual;\n   }\n \n   public void testParseNullableModifiers1() throws Exception {\n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n     assertTrue(U2U_CONSTRUCTOR_TYPE.isNativeObjectType());\n \n     Asserts.assertResolvesToSame(U2U_CONSTRUCTOR_TYPE);\n+\n+    assertTrue(U2U_CONSTRUCTOR_TYPE.isNominalConstructor());\n   }\n \n   /**\n         NO_OBJECT_TYPE.getPropertyType(\"anyProperty\"));\n \n     Asserts.assertResolvesToSame(NO_OBJECT_TYPE);\n+\n+    assertFalse(NO_OBJECT_TYPE.isNominalConstructor());\n   }\n \n   /**\n         NO_TYPE.getPropertyType(\"anyProperty\"));\n \n     Asserts.assertResolvesToSame(NO_TYPE);\n+\n+    assertFalse(NO_TYPE.isNominalConstructor());\n   }\n \n   /**\n     assertTrue(ARRAY_TYPE.isNativeObjectType());\n \n     Asserts.assertResolvesToSame(ARRAY_TYPE);\n+\n+    assertFalse(ARRAY_TYPE.isNominalConstructor());\n+    assertTrue(ARRAY_TYPE.getConstructor().isNominalConstructor());\n   }\n \n   /**\n     assertEquals(\"Unknown\", UNKNOWN_TYPE.getDisplayName());\n \n     Asserts.assertResolvesToSame(UNKNOWN_TYPE);\n+    assertFalse(UNKNOWN_TYPE.isNominalConstructor());\n   }\n \n   /**\n     assertEquals(\"<Any Type>\", ALL_TYPE.getDisplayName());\n \n     Asserts.assertResolvesToSame(ALL_TYPE);\n+    assertFalse(ALL_TYPE.isNominalConstructor());\n   }\n \n   /**\n     assertTrue(OBJECT_TYPE.getImplicitPrototype().isNativeObjectType());\n \n     Asserts.assertResolvesToSame(OBJECT_TYPE);\n+    assertFalse(OBJECT_TYPE.isNominalConstructor());\n+    assertTrue(OBJECT_TYPE.getConstructor().isNominalConstructor());\n   }\n \n   /**\n     assertEquals(\"number\", NUMBER_TYPE.getDisplayName());\n \n     Asserts.assertResolvesToSame(NUMBER_TYPE);\n+    assertFalse(NUMBER_TYPE.isNominalConstructor());\n   }\n \n   /**\n     assertTypeEquals(NULL_TYPE,\n         NULL_TYPE.getGreatestSubtype(\n             createUnionType(forwardDeclaredNamedType, NULL_TYPE)));\n+    assertFalse(NULL_TYPE.isNominalConstructor());\n   }\n \n   /**\n     assertTrue(DATE_TYPE.isNativeObjectType());\n \n     Asserts.assertResolvesToSame(DATE_TYPE);\n+    assertFalse(DATE_TYPE.isNominalConstructor());\n+    assertTrue(DATE_TYPE.getConstructor().isNominalConstructor());\n   }\n \n   /**\n     assertTrue(REGEXP_TYPE.isNativeObjectType());\n \n     Asserts.assertResolvesToSame(REGEXP_TYPE);\n+    assertFalse(REGEXP_TYPE.isNominalConstructor());\n+    assertTrue(REGEXP_TYPE.getConstructor().isNominalConstructor());\n   }\n \n   /**\n \n     assertTrue(STRING_OBJECT_TYPE.hasDisplayName());\n     assertEquals(\"String\", STRING_OBJECT_TYPE.getDisplayName());\n+    assertFalse(STRING_OBJECT_TYPE.isNominalConstructor());\n+    assertTrue(STRING_OBJECT_TYPE.getConstructor().isNominalConstructor());\n   }\n \n   /**\n     assertEquals(null, STRING_TYPE.findPropertyType(\"unknownProperty\"));\n \n     Asserts.assertResolvesToSame(STRING_TYPE);\n+    assertFalse(STRING_TYPE.isNominalConstructor());\n   }\n \n   private void assertPropertyTypeDeclared(ObjectType ownerType, String prop) {", "timestamp": 1315505821, "metainfo": ""}