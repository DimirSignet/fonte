{"sha": "707dae6710c6f0a579ea479980e1d654e8661cd2", "log": "Remove a zombie symbol. Also, simplify the API. The old API did too much, and it was often difficult to figure out what was going on.  R=acleung DELTA=125  (71 added, 25 deleted, 29 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=3862   ", "commit": "\n--- a/src/com/google/javascript/jscomp/SymbolTable.java\n+++ b/src/com/google/javascript/jscomp/SymbolTable.java\n \n     String name = NodeUtil.getBestLValueName(\n         NodeUtil.getBestLValue(rootNode));\n-    return name == null ? null : scope.getParentScope().getSlot(name);\n+    return name == null ? null : scope.getParentScope().getQualifiedSlot(name);\n   }\n \n   /**\n \n     // scope will sometimes be null if one of the type-stripping passes\n     // was run, and the symbol isn't in the AST anymore.\n-    return scope == null ? null : scope.getSlot(name);\n+    return scope == null ? null : scope.getQualifiedSlot(name);\n   }\n \n   /**\n     } else if (type.isFunctionType()) {\n       return linkToCtor ?\n           globalScope.getSlot(\"Function\") :\n-          globalScope.getSlot(\"Function.prototype\");\n+          globalScope.getQualifiedSlot(\"Function.prototype\");\n     } else if (type.autoboxesTo() != null) {\n       return getSymbolForTypeHelper(type.autoboxesTo(), linkToCtor);\n     } else {\n         continue;\n       }\n \n-      Symbol root = symbol.scope.getSlot(qName.substring(0, rootIndex));\n+      Symbol root = symbol.scope.getQualifiedSlot(\n+          qName.substring(0, rootIndex));\n       if (root == null) {\n         // In theory, this should never happen, but we fail quietly anyway\n         // just to be safe.\n             Symbol namespace =\n                 isAnySymbolDeclared(name, currentNode, root.scope);\n             if (namespace == null) {\n-              namespace = root.scope.getSlot(name);\n+              namespace = root.scope.getQualifiedSlot(name);\n             }\n \n             if (namespace == null && root.scope.isGlobalScope()) {\n       while (-1 != (dot = currentName.lastIndexOf('.'))) {\n         currentName = currentName.substring(0, dot);\n \n-        Symbol owner = s.scope.getSlot(currentName);\n+        Symbol owner = s.scope.getQualifiedSlot(currentName);\n         if (owner != null\n             && owner.getType() != null\n             && (owner.getType().isNominalConstructor() ||\n       return parent;\n     }\n \n+    /**\n+     * Get the slot for a fully-qualified name (e.g., \"a.b.c\") by trying\n+     * to find property scopes at each part of the path.\n+     */\n+    public Symbol getQualifiedSlot(String name) {\n+      Symbol fullyNamedSym = getSlot(name);\n+      if (fullyNamedSym != null) {\n+        return fullyNamedSym;\n+      }\n+\n+      int dot = name.lastIndexOf(\".\");\n+      if (dot != -1) {\n+        Symbol owner = getQualifiedSlot(name.substring(0, dot));\n+        if (owner != null && owner.getPropertyScope() != null) {\n+          return owner.getPropertyScope().getSlot(name.substring(dot + 1));\n+        }\n+      }\n+\n+      return null;\n+    }\n+\n     @Override\n     public Symbol getSlot(String name) {\n       Symbol own = getOwnSlot(name);\n       Symbol ancestor = parent == null ? null : parent.getSlot(name);\n       if (ancestor != null) {\n         return ancestor;\n-      }\n-\n-      int dot = name.lastIndexOf('.');\n-      if (dot != -1) {\n-        Symbol owner = getSlot(name.substring(0, dot));\n-        if (owner != null && owner.getPropertyScope() != null) {\n-          return owner.getPropertyScope().getSlot(name.substring(dot + 1));\n-        }\n       }\n       return null;\n     }\n     }\n \n     // Try to find the symbol by its fully qualified name.\n-    private void tryDefineLexicalPropRef(String name, Node n) {\n+    private void tryDefineLexicalQualifiedNameRef(String name, Node n) {\n       if (name != null) {\n-        Symbol lexicalSym = getEnclosingScope(n).getSlot(name);\n+        Symbol lexicalSym = getEnclosingScope(n).getQualifiedSlot(name);\n         if (lexicalSym != null) {\n           lexicalSym.defineReferenceAt(n);\n         }\n     private void maybeDefineTypedReference(\n         Node n, String propName, JSType owner) {\n       if (owner.isGlobalThisType()) {\n-          Symbol sym = globalScope.getSlot(propName);\n-          if (sym != null) {\n-            sym.defineReferenceAt(n);\n-          }\n+        Symbol sym = globalScope.getSlot(propName);\n+        if (sym != null) {\n+          sym.defineReferenceAt(n);\n+        }\n       } else if (owner.isNominalConstructor()) {\n         maybeDefineReference(\n             n, propName, getSymbolDeclaredBy(owner.toMaybeFunctionType()));\n       if (n.isGetProp()) {\n         JSType owner = n.getFirstChild().getJSType();\n         if (owner == null || owner.isUnknownType()) {\n-          tryDefineLexicalPropRef(n.getQualifiedName(), n);\n+          tryDefineLexicalQualifiedNameRef(n.getQualifiedName(), n);\n           return;\n         }\n \n       } else if (NodeUtil.isObjectLitKey(n, parent) && n.isString()) {\n         JSType owner = parent.getJSType();\n         if (owner == null || owner.isUnknownType()) {\n-          tryDefineLexicalPropRef(NodeUtil.getBestLValueName(n), n);\n+          tryDefineLexicalQualifiedNameRef(NodeUtil.getBestLValueName(n), n);\n           return;\n         }\n \n     public int compare(Symbol a, Symbol b) {\n       SymbolScope scopeA = getScope(a);\n       SymbolScope scopeB = getScope(b);\n-      int result = scopeA.getScopeDepth() - scopeB.getScopeDepth();\n+\n+      // More deeply nested symbols should go later.\n+      int result = getLexicalScopeDepth(scopeA) - getLexicalScopeDepth(scopeB);\n       if (result != 0) {\n         return result;\n       }\n \n-      if (a.getDeclaration() == null && b.getDeclaration() == null) {\n-        return a.getName().compareTo(b.getName());\n-      } else if (a.getDeclaration() == null) {\n-        return -1;\n-      } else if (b.getDeclaration() == null) {\n-        return 1;\n-      }\n-\n-      // Make sure that Ctor comes before Ctor.prototype, even though\n-      // they're on the same node.\n-      if (b.getName().endsWith(\".prototype\") &&\n-          b.getName().equals(a.getName() + \".prototype\")) {\n-        return -1;\n-      } else if (a.getName().endsWith(\".prototype\") &&\n-          a.getName().equals(b.getName() + \".prototype\")) {\n-        return 1;\n-      }\n-\n-      return NODE_ORDERING.compare(\n-          a.getDeclaration().getNode(),  b.getDeclaration().getNode());\n+      // After than, just use lexicographic ordering.\n+      // This ensures \"a.b\" comes before \"a.b.c\".\n+      return a.getName().compareTo(b.getName());\n     }\n   };\n+\n+  /**\n+   * For a lexical scope, just returns the normal scope depth.\n+   *\n+   * For a property scope, returns the number of scopes we have to search\n+   *     to find the nearest lexical scope, plus that lexical scope's depth.\n+   *\n+   * For a doc info scope, returns 0.\n+   */\n+  private int getLexicalScopeDepth(SymbolScope scope) {\n+    if (scope.isLexicalScope() || scope.isDocScope()) {\n+      return scope.getScopeDepth();\n+    } else {\n+      Preconditions.checkState(scope.isPropertyScope());\n+      Symbol sym = scope.getSymbolForScope();\n+      Preconditions.checkNotNull(sym);\n+      return getLexicalScopeDepth(getScope(sym)) + 1;\n+    }\n+  }\n }\n--- a/test/com/google/javascript/jscomp/SymbolTableTest.java\n+++ b/test/com/google/javascript/jscomp/SymbolTableTest.java\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Ordering;\n+import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.SymbolTable.Reference;\n import com.google.javascript.jscomp.SymbolTable.Symbol;\n import com.google.javascript.jscomp.SymbolTable.SymbolScope;\n import junit.framework.TestCase;\n \n import java.util.List;\n+import java.util.Set;\n \n /**\n  * @author nicksantos@google.com (Nick Santos)\n     Ordering<Symbol> ordering = table.getNaturalSymbolOrdering();\n     assertSymmetricOrdering(ordering, a, ab);\n     assertSymmetricOrdering(ordering, a, f);\n-    assertSymmetricOrdering(ordering, ab, f);\n+    assertSymmetricOrdering(ordering, f, ab);\n     assertSymmetricOrdering(ordering, f, x);\n   }\n \n     assertEquals(1, table.getReferenceList(y).size());\n   }\n \n+  public void testNamespaceDefinitionOrder() throws Exception {\n+    // Sometimes, weird things can happen where the files appear in\n+    // a strange order. We need to make sure we're robust against this.\n+    SymbolTable table = createSymbolTable(\n+        \"/** @const */ var goog = {};\\n\"\n+        + \"/** @constructor */ goog.dom.Foo = function() {};\\n\"\n+        + \"/** @const */ goog.dom = {};\\n\");\n+\n+    Symbol goog = getGlobalVar(table, \"goog\");\n+    Symbol dom = getGlobalVar(table, \"goog.dom\");\n+    Symbol Foo = getGlobalVar(table, \"goog.dom.Foo\");\n+\n+    assertNotNull(goog);\n+    assertNotNull(dom);\n+    assertNotNull(Foo);\n+\n+    assertEquals(dom, goog.getPropertyScope().getSlot(\"dom\"));\n+    assertEquals(Foo, dom.getPropertyScope().getSlot(\"Foo\"));\n+  }\n+\n   private void assertSymmetricOrdering(\n       Ordering<Symbol> ordering, Symbol first, Symbol second) {\n     assertTrue(ordering.compare(first, first) == 0);\n   }\n \n   private Symbol getGlobalVar(SymbolTable table, String name) {\n-    return table.getGlobalScope().getSlot(name);\n+    return table.getGlobalScope().getQualifiedSlot(name);\n   }\n \n   private Symbol getDocVar(SymbolTable table, String name) {\n   private Symbol getLocalVar(SymbolTable table, String name) {\n     for (SymbolScope scope : table.getAllScopes()) {\n       if (!scope.isGlobalScope() && scope.isLexicalScope() &&\n-          scope.getSlot(name) != null) {\n-        return scope.getSlot(name);\n+          scope.getQualifiedSlot(name) != null) {\n+        return scope.getQualifiedSlot(name);\n       }\n     }\n     return null;\n    * Returns the same table for easy chaining.\n    */\n   private SymbolTable assertSymbolTableValid(SymbolTable table) {\n+    Set<Symbol> allSymbols = Sets.newHashSet(table.getAllSymbols());\n     for (Symbol sym : table.getAllSymbols()) {\n       // Make sure that grabbing the symbol's scope and looking it up\n       // again produces the same symbol.\n-      assertEquals(sym, table.getScope(sym).getSlot(sym.getName()));\n+      assertEquals(sym, table.getScope(sym).getQualifiedSlot(sym.getName()));\n \n       for (Reference ref : table.getReferences(sym)) {\n         // Make sure that the symbol and reference are mutually linked.\n         assertEquals(sym, ref.getSymbol());\n       }\n+\n+      Symbol scope = table.getSymbolForScope(table.getScope(sym));\n+      assertTrue(\n+          \"The symbol's scope is a zombie scope that shouldn't exist: \" + sym,\n+          scope == null || allSymbols.contains(scope));\n     }\n \n     // Make sure that the global \"this\" is declared at the first input root.\n-    Symbol global = getGlobalVar(table, \"*global*\");\n+    Symbol global = getGlobalVar(table, SymbolTable.GLOBAL_THIS);\n     assertNotNull(global);\n     assertNotNull(global.getDeclaration());\n     assertEquals(Token.SCRIPT, global.getDeclaration().getNode().getType());", "timestamp": 1322433636, "metainfo": ""}