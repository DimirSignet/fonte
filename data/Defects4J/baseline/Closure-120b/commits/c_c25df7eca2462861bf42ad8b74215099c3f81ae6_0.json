{"sha": "c25df7eca2462861bf42ad8b74215099c3f81ae6", "log": "Make lists the canonical representation of compiler sources. They're so much easier to sort and mutate, which is going to make a difference once we start sorting sources. (Nick) R=robert DELTA=97  (58 added, 6 deleted, 33 changed)  include everything in the @license tag. (Nick) R=robert DELTA=78  (32 added, 19 deleted, 27 changed)  tag externs files with the @externs tag. (Nick) R=alan DELTA=45  (45 added, 0 deleted, 0 changed)  fix for issue 58. work-around a bug in IE where it gets confused if the comparator passed to Array.prototype.sort writes to its own parameters. (Nick) R=alan DELTA=33  (30 added, 0 deleted, 3 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=dpiluc   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n+++ b/src/com/google/javascript/jscomp/CoalesceVariableNames.java\n \n     LiveVariablesAnalysis liveness =\n         new LiveVariablesAnalysis(cfg, scope, compiler);\n+    // If the function has exactly 2 params, mark them as escaped. This is\n+    // a work-around for an IE bug where it throws an exception if you\n+    // write to the parameters of the callback in a sort(). See:\n+    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n+    if (scope.getRootNode().getFirstChild().getNext().getChildCount() == 2) {\n+      liveness.markAllParametersEscaped();\n+    }\n     liveness.analyze();\n \n     UndiGraph<Var, Void> interferenceGraph =\n       return;\n     }\n     Var coalescedVar = colorings.peek().getPartitionSuperNode(var);\n-    \n+\n     if (!usePseudoNames) {\n       if (vNode.getValue().equals(coalescedVar)) {\n         // The coalesced name is itself, nothing to do.\n       Set<String> allMergedNames = Sets.newTreeSet();\n       for (Iterator<Var> i = t.getScope().getVars(); i.hasNext();) {\n         Var iVar = i.next();\n-        \n+\n         // Look for all the variables that can be merged (in the graph by now)\n         // and it is merged with the current coalscedVar.\n         if (colorings.peek().getGraph().getNode(iVar) != null &&\n           allMergedNames.add(iVar.name);\n         }\n       }\n-      \n+\n       // Keep its original name.\n       if (allMergedNames.size() == 1) {\n         return;\n       }\n-      \n+\n       pseudoName = Joiner.on(\"_\").join(allMergedNames);\n-      \n+\n       while (t.getScope().isDeclared(pseudoName, true)) {\n         pseudoName += \"$\";\n       }\n-      \n+\n       n.setString(pseudoName);\n       compiler.reportCodeChange();\n \n     for (Iterator<Var> i = scope.getVars(); i.hasNext();) {\n       Var v = i.next();\n       if (!escaped.contains(v)) {\n-        \n+\n         // TODO(user): In theory, we CAN coalesce function names just like\n         // any variables. Our Liveness analysis captures this just like it as\n         // described in the specification. However, we saw some zipped and\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n import com.google.common.annotations.VisibleForTesting;\n import com.google.common.base.Preconditions;\n import com.google.common.base.Supplier;\n+import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.javascript.jscomp.CompilerOptions.DevMode;\n   private PassConfig passes = null;\n \n   // The externs inputs\n-  private CompilerInput[] externs;\n+  private List<CompilerInput> externs;\n \n   // The JS source modules\n-  private JSModule[] modules;\n+  private List<JSModule> modules;\n \n   // The graph of the JS source modules\n   private JSModuleGraph moduleGraph;\n \n   // The JS source inputs\n-  private CompilerInput[] inputs;\n+  private List<CompilerInput> inputs;\n \n   // error manager to which error management is delegated\n   private ErrorManager errorManager;\n    */\n   public void init(JSSourceFile[] externs, JSSourceFile[] inputs,\n       CompilerOptions options) {\n+    init(Lists.<JSSourceFile>newArrayList(externs),\n+        Lists.<JSSourceFile>newArrayList(inputs), options);\n+  }\n+\n+  /**\n+   * Initializes the instance state needed for a compile job.\n+   */\n+  public void init(List<JSSourceFile> externs, List<JSSourceFile> inputs,\n+      CompilerOptions options) {\n     initOptions(options);\n     \n     this.externs = makeCompilerInput(externs, true);\n               + \"Modules must be listed in dependency order.\");\n \n   /**\n-   * Initializes the instance state needed for a compile job.\n+   * Initializes the instance state needed for a compile job if the sources\n+   * are in modules.\n    */\n   public void init(JSSourceFile[] externs, JSModule[] modules,\n+      CompilerOptions options) {\n+    initModules(Lists.<JSSourceFile>newArrayList(externs),\n+         Lists.<JSModule>newArrayList(modules), options);\n+  }\n+  \n+  /**\n+   * Initializes the instance state needed for a compile job if the sources\n+   * are in modules.\n+   */\n+  public void initModules(\n+      List<JSSourceFile> externs, List<JSModule> modules,\n       CompilerOptions options) {\n     initOptions(options);\n \n     }\n   }\n \n-  private CompilerInput[] makeCompilerInput(\n-      JSSourceFile[] files, boolean isExtern) {\n-    CompilerInput [] inputs = new CompilerInput[files.length];\n-    for (int i = 0; i < files.length; ++i) {\n-      inputs[i] = new CompilerInput(files[i], isExtern);\n+  private List<CompilerInput> makeCompilerInput(\n+      List<JSSourceFile> files, boolean isExtern) {\n+    List<CompilerInput> inputs = Lists.newArrayList();\n+    for (JSSourceFile file : files) {\n+      inputs.add(new CompilerInput(file, isExtern));\n     }\n     return inputs;\n   }\n    * Verifies that at least one module has been provided and that the first one\n    * has at least one source code input.\n    */\n-  private void checkFirstModule(JSModule[] modules) {\n-    if (modules.length == 0) {\n+  private void checkFirstModule(List<JSModule> modules) {\n+    if (modules.isEmpty()) {\n       report(JSError.make(EMPTY_MODULE_LIST_ERROR));\n-    } else if (modules[0].getInputs().isEmpty()) {\n+    } else if (modules.get(0).getInputs().isEmpty()) {\n       report(JSError.make(EMPTY_ROOT_MODULE_ERROR,\n-          modules[0].getName()));\n+          modules.get(0).getName()));\n     }\n   }\n   \n    * Fill any empty modules with a place holder file. It makes any cross module\n    * motion easier.\n    */\n-  private void fillEmptyModules(JSModule[] modules) {\n-    for (int i = 1; i < modules.length; i ++) {\n-      JSModule module = modules[i];\n+  private void fillEmptyModules(List<JSModule> modules) {\n+    for (JSModule module : modules) {\n       if (module.getInputs().isEmpty()) {\n         module.add(JSSourceFile.fromCode(\"[\" + module.getName() + \"]\", \"\"));\n       }\n    * Builds a single list of all module inputs. Verifies that it contains no\n    * duplicates.\n    */\n-  private CompilerInput[] getAllInputsFromModules() {\n-    List<CompilerInput> inputs = new ArrayList<CompilerInput>();\n-    Map<String, JSModule> inputMap = new HashMap<String, JSModule>();\n+  private List<CompilerInput> getAllInputsFromModules() {\n+    List<CompilerInput> inputs = Lists.newArrayList();\n+    Map<String, JSModule> inputMap = Maps.newHashMap();\n     for (JSModule module : modules) {\n       for (CompilerInput input : module.getInputs()) {\n         String inputName = input.getName();\n     if (hasErrors()) {\n \n       // There's no reason to bother parsing the code.\n-      return new CompilerInput[0];\n-    }\n-\n-    return inputs.toArray(new CompilerInput[inputs.size()]);\n+      return ImmutableList.of();\n+    }\n+\n+    return inputs;\n   }\n \n   static final DiagnosticType DUPLICATE_INPUT =\n   public Result compile(JSSourceFile[] externs,\n                         JSSourceFile[] inputs,\n                         CompilerOptions options) {\n-\n+    return compile(Lists.<JSSourceFile>newArrayList(externs),\n+        Lists.<JSSourceFile>newArrayList(inputs),\n+        options);\n+  }\n+  \n+  /**\n+   * Compiles a list of inputs.\n+   */\n+  public Result compile(List<JSSourceFile> externs,\n+      List<JSSourceFile> inputs, CompilerOptions options) {\n     // The compile method should only be called once.\n     Preconditions.checkState(jsRoot == null);\n \n   public Result compile(JSSourceFile[] externs,\n                         JSModule[] modules,\n                         CompilerOptions options) {\n+    return compileModules(Lists.<JSSourceFile>newArrayList(externs),\n+        Lists.<JSModule>newArrayList(modules),\n+        options);\n+  }\n+\n+  /**\n+   * Compiles a list of modules.\n+   */\n+  public Result compileModules(List<JSSourceFile> externs,\n+      List<JSModule> modules, CompilerOptions options) {\n     // The compile method should only be called once.\n     Preconditions.checkState(jsRoot == null);\n \n     try {\n-      init(externs, modules, options);\n+      initModules(externs, modules, options);\n       if (hasErrors()) {\n         return getResult();\n       }\n       public String[] call() throws Exception {\n         Tracer tracer = newTracer(\"toSourceArray\");\n         try {\n-          int numInputs = inputs.length;\n+          int numInputs = inputs.size();\n           String[] sources = new String[numInputs];\n           CodeBuilder cb = new CodeBuilder();\n           for (int i = 0; i < numInputs; i++) {\n-            Node scriptNode = inputs[i].getAstRoot(Compiler.this);\n+            Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);\n             cb.reset();\n             toSource(cb, i, scriptNode);\n             sources[i] = cb.toString();\n   @Override\n   Node getNodeForCodeInsertion(JSModule module) {\n     if (module == null) {\n-      if (inputs.length == 0) {\n+      if (inputs.isEmpty()) {\n         throw new IllegalStateException(\"No inputs\");\n       }\n \n-      return inputs[0].getAstRoot(this);\n-    }\n-\n-    List<CompilerInput> inputs = module.getInputs();\n-    if (inputs.size() > 0) {\n       return inputs.get(0).getAstRoot(this);\n+    }\n+\n+    List<CompilerInput> moduleInputs = module.getInputs();\n+    if (moduleInputs.size() > 0) {\n+      return moduleInputs.get(0).getAstRoot(this);\n     }\n     throw new IllegalStateException(\"Root module has no inputs\");\n   }\n \n     Node externsRoot;\n     private Node jsRoot;\n-    private CompilerInput[] externs;\n-    private CompilerInput[] inputs;\n-    private JSModule[] modules;\n+    private List<CompilerInput> externs;\n+    private List<CompilerInput> inputs;\n+    private List<JSModule> modules;\n     private PassConfig.State passConfigState;\n     private JSTypeRegistry typeRegistry;\n     private boolean normalized;\n--- a/src/com/google/javascript/jscomp/CompilerInput.java\n+++ b/src/com/google/javascript/jscomp/CompilerInput.java\n \n   // Info about where the file lives.\n   private JSModule module;\n-  private final boolean isExtern;\n+  private boolean isExtern;\n   final private String name;\n \n   // The AST.\n   public boolean isExtern() {\n     return isExtern;\n   }\n+\n+  void setIsExtern(boolean isExtern) {\n+    this.isExtern = isExtern;\n+  }\n }\n--- a/src/com/google/javascript/jscomp/JSModuleGraph.java\n+++ b/src/com/google/javascript/jscomp/JSModuleGraph.java\n \n import com.google.common.collect.Iterables;\n import com.google.common.collect.LinkedHashMultimap;\n+import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Multimap;\n \n    * Creates a module graph from a list of modules in dependency order.\n    */\n   public JSModuleGraph(JSModule[] modulesInDepOrder) {\n-    moduleDepths = new HashMap<JSModule, Integer>(modulesInDepOrder.length);\n-    modulesByDepth = new ArrayList<List<JSModule>>();\n+    this(Lists.<JSModule>newArrayList(modulesInDepOrder));\n+  }\n+\n+  /**\n+   * Creates a module graph from a list of modules in dependency order.\n+   */\n+  public JSModuleGraph(List<JSModule> modulesInDepOrder) {\n+    moduleDepths = Maps.newHashMapWithExpectedSize(modulesInDepOrder.size());\n+    modulesByDepth = Lists.newArrayList();\n \n     for (JSModule module : modulesInDepOrder) {\n       int depth = 0;\n--- a/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java\n+++ b/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java\n    * Give up computing liveness of formal parameter by putting all the parameter\n    * names in the escaped set.\n    */\n-  private void markAllParametersEscaped() {\n+  void markAllParametersEscaped() {\n     Node lp = jsScope.getRootNode().getFirstChild().getNext();\n     for(Node arg = lp.getFirstChild(); arg != null; arg = arg.getNext()) {\n       escaped.add(jsScope.getVar(arg.getString()));\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n    *\n    * @return The extraction information.\n    */\n+  @SuppressWarnings(\"fallthrough\")\n   private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                       WhitespaceOption option) {\n \n \n     do {\n       switch (token) {\n-        case ANNOTATION:\n-        case EOC:\n-        case EOF:\n-          String multilineText = builder.toString();\n-\n-          if (option != WhitespaceOption.PRESERVE) {\n-            multilineText = multilineText.trim();\n-          }\n-\n-          int endLineno = stream.getLineno();\n-          int endCharno = stream.getCharno();\n-\n-          if (multilineText.length() > 0) {\n-            jsdocBuilder.markText(multilineText, startLineno, startCharno,\n-                                  endLineno, endCharno);\n-          }\n-\n-          return new ExtractionInfo(multilineText, token);\n-\n         case STAR:\n           if (!ignoreStar) {\n             if (builder.length() > 0) {\n           ignoreStar = true;\n           token = next();\n           continue;\n+\n+        case ANNOTATION:\n+        case EOC:\n+        case EOF:\n+          // When we're capturing a license block, annotations\n+          // in the block are ok.\n+          if (!(option == WhitespaceOption.PRESERVE &&\n+                token == JsDocToken.ANNOTATION)) {\n+            String multilineText = builder.toString();\n+\n+            if (option != WhitespaceOption.PRESERVE) {\n+              multilineText = multilineText.trim();\n+            }\n+\n+            int endLineno = stream.getLineno();\n+            int endCharno = stream.getCharno();\n+\n+            if (multilineText.length() > 0) {\n+              jsdocBuilder.markText(multilineText, startLineno, startCharno,\n+                  endLineno, endCharno);\n+            }\n+\n+            return new ExtractionInfo(multilineText, token);\n+          }\n+\n+          // FALL THROUGH\n \n         default:\n           ignoreStar = false;\n--- a/test/com/google/javascript/jscomp/CoalesceVariableNamesTest.java\n+++ b/test/com/google/javascript/jscomp/CoalesceVariableNamesTest.java\n   }\n \n   public void testParameter4() {\n-    // Make sure that we are taking advantage of correct merge opportunities.\n+    // Make sure that we do not merge two-arg functions because of the\n+    // IE sort bug (see comments in computeEscaped)\n     test(\"function FUNC(x, y) {var a,b; y; a=0; a; x; b=0; b}\",\n-         \"function FUNC(x, y) {         y; y=0; y; x; x=0; x}\");\n+         \"function FUNC(x, y) {var a; y; a=0; a; x; a=0; a}\");\n+  }\n+\n+  public void testParameter4b() {\n+    // Merge parameters\n+    test(\"function FUNC(x, y, z) {var a,b; y; a=0; a; x; b=0; b}\",\n+         \"function FUNC(x, y, z) {         y; y=0; y; x; x=0; x}\");\n   }\n \n   public void testLiveRangeChangeWithinCfgNode() {\n--- a/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/JsDocInfoParserTest.java\n public class JsDocInfoParserTest extends BaseJSTypeTestCase {\n \n   private Set<String> extraAnnotations;\n+  private Node.FileLevelJsDocBuilder fileLevelJsDocBuilder = null;\n \n   @Override\n   public void setUp() throws Exception {\n     assertEquals(\": [ ] ...\", parse(comment).getDescription());\n   }\n \n-  //public void testParsePreserveWithNoBuilderGivesWarning() throws Exception {\n-  //  String comment = \"@preserve Foo\\nBar\\n*/\";\n-  //  parse(comment,\n-  //      \"@preserve or @license annotation without file to associate it with\");\n-  //}\n-\n-  //public void testParsePreserve() throws Exception {\n-  //  Node node = new Node(1);\n-  //  this.fileLevelJsDocBuilder = node.getJsDocBuilderForNode();\n-  //  String comment = \"@preserve Foo\\nBar\\n\\nBaz*/\";\n-  //  parse(comment);\n-  //  assertEquals(\" Foo\\n Bar\\n\\n Baz\", node.getJSDocInfo().getLicense());\n-  //}\n-\n-  //public void testParseLicense() throws Exception {\n-  //  Node node = new Node(1);\n-  //  this.fileLevelJsDocBuilder = node.getJsDocBuilderForNode();\n-  //  String comment = \"@license Foo\\nBar\\n\\nBaz*/\";\n-  //  parse(comment);\n-  //  assertEquals(\" Foo\\n Bar\\n\\n Baz\", node.getJSDocInfo().getLicense());\n-  //}\n+  public void testParsePreserve() throws Exception {\n+    Node node = new Node(1);\n+    this.fileLevelJsDocBuilder = node.getJsDocBuilderForNode();\n+    String comment = \"@preserve Foo\\nBar\\n\\nBaz*/\";\n+    parse(comment);\n+    assertEquals(\" Foo\\n Bar\\n\\n Baz\", node.getJSDocInfo().getLicense());\n+  }\n+\n+  public void testParseLicense() throws Exception {\n+    Node node = new Node(1);\n+    this.fileLevelJsDocBuilder = node.getJsDocBuilderForNode();\n+    String comment = \"@license Foo\\nBar\\n\\nBaz*/\";\n+    parse(comment);\n+    assertEquals(\" Foo\\n Bar\\n\\n Baz\", node.getJSDocInfo().getLicense());\n+  }\n+\n+  public void testParseLicenseWithAnnotation() throws Exception {\n+    Node node = new Node(1);\n+    this.fileLevelJsDocBuilder = node.getJsDocBuilderForNode();\n+    String comment = \"@license Foo \\n * @author Charlie Brown */\";\n+    parse(comment);\n+    assertEquals(\" Foo \\n @author Charlie Brown \",\n+        node.getJSDocInfo().getLicense());\n+  }\n \n   public void testParseDefine1() throws Exception {\n     assertTypeEquals(STRING_TYPE,\n     JsDocInfoParser jsdocParser = new JsDocInfoParser(stream(comment),\n         \"testcode\", config, errorReporter);\n \n-    //if (fileLevelJsDocBuilder != null) {\n-    //  jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);\n-    //}\n+    if (fileLevelJsDocBuilder != null) {\n+      jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);\n+    }\n \n     jsdocParser.parse();\n ", "timestamp": 1270537096, "metainfo": ""}