{"sha": "83026babd3b768f508780b0c38c3cef2bb9242a5", "log": "clean up a long-standing TODO and fix up the function type lattice  R=moedinger,awiner DELTA=168  (108 added, 21 deleted, 39 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=469041   ", "commit": "\n--- a/src/com/google/javascript/rhino/jstype/ArrowType.java\n+++ b/src/com/google/javascript/rhino/jstype/ArrowType.java\n     }\n     return this;\n   }\n+\n+  boolean hasUnknownParamsOrReturn() {\n+    if (parameters != null) {\n+      for (Node paramNode = parameters.getFirstChild();\n+           paramNode != null; paramNode = paramNode.getNext()) {\n+        JSType type = paramNode.getJSType();\n+        if (type == null || type.isUnknownType()) {\n+          return true;\n+        }\n+      }\n+    }\n+    return returnType == null || returnType.isUnknownType();\n+  }\n }\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n   private JSType supAndInfHelper(JSType that, boolean leastSuper) {\n     // NOTE(nicksantos): When we remove the unknown type, the function types\n     // form a lattice with the universal constructor at the top of the lattice,\n-    // and the NoObject type at the bottom of the lattice.\n+    // and the LEAST_FUNCTION_TYPE type at the bottom of the lattice.\n     //\n     // When we introduce the unknown type, it's much more difficult to make\n     // heads or tails of the partial ordering of types, because there's no\n     //\n     // Rather than make the situation more complicated by introducing new\n     // types (like unions of functions), we just fallback on the simpler\n-    // approach of using the universal constructor and the AnyObject as\n-    // the supremum and infinum of all function types.\n+    // approach of getting things right at the top and the bottom of the\n+    // lattice.\n     if (isFunctionType() && that.isFunctionType()) {\n       if (isEquivalentTo(that)) {\n         return this;\n       }\n \n-      // If this is a normal function, look to see if the arguments are equal.\n-      // If they are, we can just take the least supertype (or greatest\n-      // subtype) of the return types.\n-      if (isOrdinaryFunction() && that.isOrdinaryFunction() &&\n-          that instanceof FunctionType) {\n-        FunctionType other = (FunctionType) that;\n-        if (call.hasEqualParameters(other.call) &&\n-            isEquivalent(typeOfThis, other.typeOfThis)) {\n-          JSType newReturnType = leastSuper ?\n-              call.returnType.getLeastSupertype(other.call.returnType) :\n-              call.returnType.getGreatestSubtype(other.call.returnType);\n-          return cloneWithNewReturnType(\n-              newReturnType,\n-              call.returnTypeInferred || other.call.returnTypeInferred);\n+      FunctionType other = null;\n+      if (that instanceof FunctionType) {\n+        other = (FunctionType) that;\n+      }\n+\n+      // If these are ordinary functions, then merge them.\n+      // Don't do this if any of the params/return\n+      // values are unknown, because then there will be cycles in\n+      // their local lattice and they will merge in weird ways.\n+      if (other != null &&\n+          isOrdinaryFunction() && that.isOrdinaryFunction() &&\n+          !this.call.hasUnknownParamsOrReturn() &&\n+          !other.call.hasUnknownParamsOrReturn()) {\n+\n+        // Check for the degenerate case.\n+        if (this.isSubtype(that)) {\n+          return leastSuper ? that : this;\n+        } else if (that.isSubtype(this)) {\n+          return leastSuper ? this : that;\n         }\n-      }\n-\n+\n+        // Merge the two functions component-wise.\n+        FunctionType merged = tryMergeFunctionPiecewise(other, leastSuper);\n+        if (merged != null) {\n+          return merged;\n+        }\n+      }\n+\n+      // The function instance type is a special case\n+      // that lives above the rest of the lattice.\n       JSType functionInstance = registry.getNativeType(\n           JSTypeNative.FUNCTION_INSTANCE_TYPE);\n       if (functionInstance.isEquivalentTo(that)) {\n         return leastSuper ? this : that;\n       }\n \n-      return leastSuper ?\n-          registry.getNativeType(JSTypeNative.U2U_CONSTRUCTOR_TYPE) :\n-          registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n+      // In theory, we should be using the GREATEST_FUNCTION_TYPE as the\n+      // greatest function. In practice, we don't because it's way too\n+      // broad. The greatest function takes var_args None parameters, which\n+      // means that all parameters register a type warning.\n+      //\n+      // Instead, we use the U2U ctor type, which has unknown type args.\n+      FunctionType greatestFn =\n+          registry.getNativeFunctionType(JSTypeNative.U2U_CONSTRUCTOR_TYPE);\n+      FunctionType leastFn =\n+          registry.getNativeFunctionType(JSTypeNative.LEAST_FUNCTION_TYPE);\n+      return leastSuper ? greatestFn : leastFn;\n     }\n \n     return leastSuper ?\n         super.getGreatestSubtype(that);\n   }\n \n-  FunctionType cloneWithNewReturnType(JSType newReturnType, boolean inferred) {\n+  /**\n+   * Try to get the sup/inf of two functions by looking at the\n+   * piecewise components.\n+   */\n+  private FunctionType tryMergeFunctionPiecewise(\n+      FunctionType other, boolean leastSuper) {\n+    Node newParamsNode = null;\n+    if (call.hasEqualParameters(other.call)) {\n+      newParamsNode = call.parameters;\n+    } else {\n+      // If the parameters are not equal, don't try to merge them.\n+      // Someday, we should try to merge the individual params.\n+      return null;\n+    }\n+\n+    JSType newReturnType = leastSuper ?\n+        call.returnType.getLeastSupertype(other.call.returnType) :\n+        call.returnType.getGreatestSubtype(other.call.returnType);\n+\n+    ObjectType newTypeOfThis = null;\n+    if (isEquivalent(typeOfThis, other.typeOfThis)) {\n+      newTypeOfThis = typeOfThis;\n+    } else {\n+      JSType maybeNewTypeOfThis = leastSuper ?\n+          typeOfThis.getLeastSupertype(other.typeOfThis) :\n+          typeOfThis.getGreatestSubtype(other.typeOfThis);\n+      if (maybeNewTypeOfThis instanceof ObjectType) {\n+        newTypeOfThis = (ObjectType) maybeNewTypeOfThis;\n+      } else {\n+        newTypeOfThis = leastSuper ?\n+            registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) :\n+            registry.getNativeObjectType(JSTypeNative.NO_OBJECT_TYPE);\n+      }\n+    }\n+\n+    boolean newReturnTypeInferred =\n+        call.returnTypeInferred || other.call.returnTypeInferred;\n+\n     return new FunctionType(\n-        registry, null, source,\n+        registry, null, null,\n         new ArrowType(\n-            registry, call.parameters, newReturnType, inferred),\n-        typeOfThis, null, false, false);\n+            registry, newParamsNode, newReturnType, newReturnTypeInferred),\n+        newTypeOfThis, null, false, false);\n   }\n \n   /**\n--- a/src/com/google/javascript/rhino/jstype/JSTypeNative.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeNative.java\n   U2U_CONSTRUCTOR_TYPE,\n   U2U_FUNCTION_TYPE,\n \n-  // TODO(nicksantos): Fix up these types so that they fit into the\n-  // type lattice properly. Right now, they're broken.\n   LEAST_FUNCTION_TYPE,\n   GREATEST_FUNCTION_TYPE,\n \n--- a/src/com/google/javascript/rhino/testing/Asserts.java\n+++ b/src/com/google/javascript/rhino/testing/Asserts.java\n     Assert.assertTrue(\n         message +\n         (message.isEmpty() ? \"\" : \"\\n\") +\n-        \"Expected: \" + b + \"\\n\" +\n-        \"Actual  : \" + a,\n+        \"Expected: \" + a + \"\\n\" +\n+        \"Actual  : \" + b,\n         a.isEquivalentTo(b));\n   }\n }\n--- a/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/FunctionTypeTest.java\n         .isReturnTypeInferred());\n   }\n \n+  public void testSupAndInfOfReturnTypesWithDifferentParams() {\n+    FunctionType retString = new FunctionBuilder(registry)\n+        .withParamsNode(registry.createParameters(NUMBER_TYPE))\n+        .withInferredReturnType(STRING_TYPE).build();\n+    FunctionType retNumber = new FunctionBuilder(registry)\n+        .withParamsNode(registry.createParameters())\n+        .withReturnType(NUMBER_TYPE).build();\n+\n+    assertLeastSupertype(\n+        \"Function\", retString, retNumber);\n+    assertGreatestSubtype(\n+        \"function (...[*]): None\", retString, retNumber);\n+  }\n+\n   public void testSupAndInfWithDifferentParams() {\n     FunctionType retString = new FunctionBuilder(registry)\n         .withParamsNode(registry.createParameters(NUMBER_TYPE))\n     assertLeastSupertype(\n         \"Function\", retString, retNumber);\n     assertGreatestSubtype(\n-        \"NoObject\", retString, retNumber);\n+        \"function (...[*]): None\", retString, retNumber);\n   }\n \n   public void testSupAndInfWithDifferentThisTypes() {\n     FunctionType retString = new FunctionBuilder(registry)\n+        .withParamsNode(registry.createParameters())\n         .withTypeOfThis(OBJECT_TYPE)\n         .withReturnType(STRING_TYPE).build();\n     FunctionType retNumber = new FunctionBuilder(registry)\n+        .withParamsNode(registry.createParameters())\n         .withTypeOfThis(DATE_TYPE)\n         .withReturnType(NUMBER_TYPE).build();\n \n     assertLeastSupertype(\n-        \"Function\", retString, retNumber);\n+        \"function (this:Object): (number|string)\", retString, retNumber);\n     assertGreatestSubtype(\n-        \"NoObject\", retString, retNumber);\n+        \"function (this:Date): None\", retString, retNumber);\n+  }\n+\n+  public void testSupAndInfWithDifferentThisTypes2() {\n+    FunctionType retString = new FunctionBuilder(registry)\n+        .withParamsNode(registry.createParameters())\n+        .withTypeOfThis(ARRAY_TYPE)\n+        .withReturnType(STRING_TYPE).build();\n+    FunctionType retNumber = new FunctionBuilder(registry)\n+        .withParamsNode(registry.createParameters())\n+        .withTypeOfThis(DATE_TYPE)\n+        .withReturnType(NUMBER_TYPE).build();\n+\n+    assertLeastSupertype(\n+        \"function (this:Object): (number|string)\", retString, retNumber);\n+    assertGreatestSubtype(\n+        \"function (this:NoObject): None\", retString, retNumber);\n   }\n \n   private void assertLeastSupertype(String s, JSType t1, JSType t2) {\n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n           assertTypeEquals(String.format(\"sup(%s, %s)\", typeA, typeB),\n               U2U_CONSTRUCTOR_TYPE, typeA.getLeastSupertype(typeB));\n           assertTypeEquals(String.format(\"inf(%s, %s)\", typeA, typeB),\n-              NO_OBJECT_TYPE, typeA.getGreatestSubtype(typeB));\n+              LEAST_FUNCTION_TYPE, typeA.getGreatestSubtype(typeB));\n         }\n       }\n     }\n           assertTypeEquals(String.format(\"sup(%s, %s)\", typeA, typeB),\n               U2U_CONSTRUCTOR_TYPE, typeA.getLeastSupertype(typeB));\n           assertTypeEquals(String.format(\"inf(%s, %s)\", typeA, typeB),\n-              NO_OBJECT_TYPE, typeA.getGreatestSubtype(typeB));\n+              LEAST_FUNCTION_TYPE, typeA.getGreatestSubtype(typeB));\n         }\n       }\n     }\n         BOOLEAN_TYPE,\n         OBJECT_TYPE,\n         U2U_CONSTRUCTOR_TYPE,\n+        LEAST_FUNCTION_TYPE,\n+        GREATEST_FUNCTION_TYPE,\n         ALL_TYPE,\n         NO_TYPE,\n         NO_OBJECT_TYPE,\n         registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE),\n         registry.getNativeType(JSTypeNative.OBJECT_TYPE),\n         registry.getNativeType(JSTypeNative.FUNCTION_PROTOTYPE),\n+        registry.getNativeType(JSTypeNative.GREATEST_FUNCTION_TYPE),\n         dateMethod,\n+        registry.getNativeType(JSTypeNative.LEAST_FUNCTION_TYPE),\n         registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),\n         registry.getNativeType(JSTypeNative.NO_TYPE));\n     verifySubtypeChain(typeChain);", "timestamp": 1287754181, "metainfo": ""}