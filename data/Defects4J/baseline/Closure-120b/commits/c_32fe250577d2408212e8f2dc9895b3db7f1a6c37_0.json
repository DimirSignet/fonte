{"sha": "32fe250577d2408212e8f2dc9895b3db7f1a6c37", "log": "Respect coding convention constants as well as @const annotations when inferring types.  R=nicksantos   Revision created by MOE tool push_codebase. MOE_MIGRATION=6089   ", "commit": "\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n   }\n \n   /**\n-   * Returns true if a name node represents a constant variable.\n-   *\n-   * <p>Determining whether a variable is constant has three steps:\n+   * <p>Determines whether a variable is constant:\n    * <ol>\n-   * <li>In CodingConventionAnnotator, any name that matches the\n+   * <li>In Normalize, any name that matches the\n    *     {@link CodingConvention#isConstant(String)} is annotated with an\n    *     IS_CONSTANT_NAME property.\n-   * <li>The normalize pass renames any variable with the IS_CONSTANT_NAME\n-   *     annotation and that is initialized to a constant value with\n-   *     a variable name including $$constant.\n-   * <li>Return true here if the variable includes $$constant in its name.\n    * </ol>\n    *\n    * @param node A NAME or STRING node\n-   * @return True if the variable is constant\n+   * @return True if a name node represents a constant variable\n    */\n   static boolean isConstantName(Node node) {\n     return node.getBooleanProp(Node.IS_CONSTANT_NAME);\n   /** Whether the given name is constant by coding convention. */\n   static boolean isConstantByConvention(\n       CodingConvention convention, Node node, Node parent) {\n-    String name = node.getString();\n-    if (parent.isGetProp() &&\n-        node == parent.getLastChild()) {\n-      return convention.isConstantKey(name);\n+    if (parent.isGetProp() && node == parent.getLastChild()) {\n+      return convention.isConstantKey(node.getString());\n     } else if (isObjectLitKey(node, parent)) {\n-      return convention.isConstantKey(name);\n-    } else {\n-      return convention.isConstant(name);\n-    }\n+      return convention.isConstantKey(node.getString());\n+    } else if (node.isName()) {\n+      return convention.isConstant(node.getString());\n+    }\n+    return false;\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n         } else if (info.isConstructor() || info.isInterface()) {\n           return createFunctionTypeFromNodes(\n               rValue, lValue.getQualifiedName(), info, lValue);\n-        } else {\n-          // Check if this is constant, and if it has a known type.\n-          if (info.isConstant()) {\n-            JSType knownType = null;\n-            if (rValue != null) {\n-              JSDocInfo rValueInfo = rValue.getJSDocInfo();\n-              if (rValueInfo != null && rValueInfo.hasType()) {\n-                // If rValue has a type-cast, we use the type in the type-cast.\n-                return rValueInfo.getType().evaluate(scope, typeRegistry);\n-              } else if (rValue.getJSType() != null\n-                  && !rValue.getJSType().isUnknownType()) {\n-                // If rValue's type was already computed during scope creation,\n-                // then we can safely use that.\n-                return rValue.getJSType();\n-              } else if (rValue.isOr()) {\n-                // Check for a very specific JS idiom:\n-                // var x = x || TYPE;\n-                // This is used by Closure's base namespace for esoteric\n-                // reasons.\n-                Node firstClause = rValue.getFirstChild();\n-                Node secondClause = firstClause.getNext();\n-                boolean namesMatch = firstClause.isName()\n-                    && lValue.isName()\n-                    && firstClause.getString().equals(lValue.getString());\n-                if (namesMatch && secondClause.getJSType() != null\n-                    && !secondClause.getJSType().isUnknownType()) {\n-                  return secondClause.getJSType();\n-                }\n-              }\n+        }\n+      }\n+\n+      // Check if this is constant, and if it has a known type.\n+      if (isConstantSymbol(info, lValue)) {\n+        JSType knownType = null;\n+        if (rValue != null) {\n+          JSDocInfo rValueInfo = rValue.getJSDocInfo();\n+          if (rValueInfo != null && rValueInfo.hasType()) {\n+            // If rValue has a type-cast, we use the type in the type-cast.\n+            return rValueInfo.getType().evaluate(scope, typeRegistry);\n+          } else if (rValue.getJSType() != null\n+              && !rValue.getJSType().isUnknownType()) {\n+            // If rValue's type was already computed during scope creation,\n+            // then we can safely use that.\n+            return rValue.getJSType();\n+          } else if (rValue.isOr()) {\n+            // Check for a very specific JS idiom:\n+            // var x = x || TYPE;\n+            // This is used by Closure's base namespace for esoteric\n+            // reasons.\n+            Node firstClause = rValue.getFirstChild();\n+            Node secondClause = firstClause.getNext();\n+            boolean namesMatch = firstClause.isName()\n+                && lValue.isName()\n+                && firstClause.getString().equals(lValue.getString());\n+            if (namesMatch && secondClause.getJSType() != null\n+                && !secondClause.getJSType().isUnknownType()) {\n+              return secondClause.getJSType();\n             }\n           }\n         }\n       if (info != null) {\n         inferred = !(info.hasType()\n             || info.hasEnumParameterType()\n-            || (info.isConstant() && valueType != null\n+            || (isConstantSymbol(info, n) && valueType != null\n                 && !valueType.isUnknownType())\n             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n         }\n       }\n       return inferred;\n+    }\n+\n+    private boolean isConstantSymbol(JSDocInfo info, Node node) {\n+      if (info != null && info.isConstant()) {\n+        return true;\n+      }\n+\n+      switch (node.getType()) {\n+        case Token.NAME:\n+          return NodeUtil.isConstantByConvention(\n+              compiler.getCodingConvention(), node, node.getParent());\n+        case Token.GETPROP:\n+          return node.isQualifiedName() && NodeUtil.isConstantByConvention(\n+              compiler.getCodingConvention(), node.getLastChild(), node);\n+      }\n+      return false;\n     }\n \n     /**\n--- a/test/com/google/javascript/jscomp/CompilerTypeTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTypeTestCase.java\n       \"/** @constructor \\n * @param {*} var_args \\n @return {!Array} */\" +\n       \"function Array(var_args) {}\\n\" +\n       \"/** @type {number} */ Array.prototype.length;\\n\" +\n+      \"/**\\n\" +\n+      \" * @param {...T} var_args\\n\" +\n+      \" * @return {number} The new length of the array.\\n\" +\n+      \" * @this {{length: number}|Array.<T>}\\n\" +\n+      \" * @template T\\n\" +\n+      \" * @modifies {this}\\n\" +\n+      \" */\\n\" +\n+      \"Array.prototype.push = function(var_args) {};\" +\n       \"/** @constructor */\\n\" +\n       \"function Arguments() {}\\n\" +\n       \"/** @type {number} */\\n\" +\n--- a/test/com/google/javascript/jscomp/TypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/TypeCheckTest.java\n   }\n \n   public void testTemplateType5() throws Exception {\n+    compiler.getOptions().setCodingConvention(new GoogleCodingConvention());\n+    testTypes(\n+        \"var CGI_PARAM_RETRY_COUNT = 'rc';\" +\n+        \"\" +\n+        \"/**\" +\n+        \" * @param {...T} p\\n\" +\n+        \" * @return {T} \\n\" +\n+        \" * @template T\\n\" +\n+        \" */\\n\" +\n+        \"function fn(p) { return p; }\\n\" +\n+        \"/** @type {!Object} */ var x;\" +\n+        \"\" +\n+        \"/** @return {void} */\\n\" +\n+        \"function aScope() {\\n\" +\n+        \"  x = fn(CGI_PARAM_RETRY_COUNT, 1);\\n\" +\n+        \"}\",\n+        \"assignment\\n\" +\n+        \"found   : (number|string)\\n\" +\n+        \"required: Object\");\n+  }\n+\n+  public void testTemplateType6() throws Exception {\n     testTypes(\n         \"/**\" +\n         \" * @param {Array.<T>} arr \\n\" +\n         \"initializing variable\\n\" +\n         \"found   : number\\n\" +\n         \"required: Object\");\n+  }\n+\n+  public void testTemplateType7() throws Exception {\n+    // TODO(johnlenz): As the @this type for Array.prototype.push includes\n+    // \"{length:number}\" (and this includes \"Array.<number>\") we don't\n+    // get a type warning here. Consider special-casing array methods.\n+    testTypes(\n+        \"/** @type {!Array.<string>} */\\n\" +\n+        \"var query = [];\\n\" +\n+        \"query.push(1);\\n\");\n   }\n \n   public void disable_testBadTemplateType4() throws Exception {", "timestamp": 1357602703, "metainfo": ""}