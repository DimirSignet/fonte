{"sha": "63ab3ece1b17a371aa265574dd79ee7104b46921", "log": "Prepare DateUtils for 2.0 release   ", "commit": "\n--- a/src/java/org/apache/commons/lang/time/DateUtils.java\n+++ b/src/java/org/apache/commons/lang/time/DateUtils.java\n  * @author <a href=\"mailto:sergek@lokitech.com\">Serge Knystautas</a>\n  * @author Stephen Colebourne\n  * @since 2.0\n- * @version $Id: DateUtils.java,v 1.3 2003/06/08 23:14:23 scolebourne Exp $\n+ * @version $Id: DateUtils.java,v 1.4 2003/06/23 23:41:10 scolebourne Exp $\n  */\n public class DateUtils {\n     \n     public final static int RANGE_MONTH_MONDAY = 6;\n \n     /**\n-     * See the other round method.  Works with a Date object.\n-     */\n-    public static Date round(Date val, int field) {\n-        GregorianCalendar gval = new GregorianCalendar();\n-        gval.setTime(val);\n-        modify(gval, field, true);\n-        return gval.getTime();\n-    }\n-\n+     * <p><code>DateUtils<code> instances should NOT be constructed in\n+     * standard programming. Instead, the class should be used as\n+     * <code>DateUtils.parse(str);</code>.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean\n+     * instance to operate.</p>\n+     */\n+    public DateUtils() {\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Round this date, leaving the field specified as the most significant\n      * field.  For example, if you had the datetime of 28 Mar 2002\n      * 13:45:01.231, if this was passed with HOUR, it would return 28 Mar\n      * 2002 14:00:00.000.  If this was passed with MONTH, it would return\n      * 1 April 2002 0:00:00.000.\n-     */\n-    public static Calendar round(Calendar val, int field) {\n-        Calendar rounded = (Calendar) val.clone();\n+     * \n+     * @param date  the date to work with\n+     * @param field  the field from <code>Calendar</code> or SEMI_MONTH\n+     * @return the rounded date\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public static Date round(Date date, int field) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        GregorianCalendar gval = new GregorianCalendar();\n+        gval.setTime(date);\n+        modify(gval, field, true);\n+        return gval.getTime();\n+    }\n+\n+    /**\n+     * Round this date, leaving the field specified as the most significant\n+     * field.  For example, if you had the datetime of 28 Mar 2002\n+     * 13:45:01.231, if this was passed with HOUR, it would return 28 Mar\n+     * 2002 14:00:00.000.  If this was passed with MONTH, it would return\n+     * 1 April 2002 0:00:00.000.\n+     * \n+     * @param date  the date to work with\n+     * @param field  the field from <code>Calendar</code> or SEMI_MONTH\n+     * @return the rounded date (a different object)\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public static Calendar round(Calendar date, int field) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        Calendar rounded = (Calendar) date.clone();\n         modify(rounded, field, true);\n         return rounded;\n     }\n \n     /**\n-     * See the other round method.  Works with an Object, trying to\n-     * use it as either a Date or Calendar.\n-     */\n-    public static Date round(Object val, int field) {\n-        if (val instanceof Date) {\n-            return round((Date) val, field);\n-        } else if (val instanceof Calendar) {\n-            return round((Calendar) val, field).getTime();\n+     * Round this date, leaving the field specified as the most significant\n+     * field.  For example, if you had the datetime of 28 Mar 2002\n+     * 13:45:01.231, if this was passed with HOUR, it would return 28 Mar\n+     * 2002 14:00:00.000.  If this was passed with MONTH, it would return\n+     * 1 April 2002 0:00:00.000.\n+     * \n+     * @param date  the date to work with, either Date or Calendar\n+     * @param field  the field from <code>Calendar</code> or SEMI_MONTH\n+     * @return the rounded date\n+     * @throws IllegalArgumentException if the date is null\n+     * @throws ClassCastException if the object type is not a Date or Calendar\n+     */\n+    public static Date round(Object date, int field) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        if (date instanceof Date) {\n+            return round((Date) date, field);\n+        } else if (date instanceof Calendar) {\n+            return round((Calendar) date, field).getTime();\n         } else {\n-            throw new ClassCastException(\"Could not round \" + val);\n-        }\n-    }\n-\n-    /**\n-     * See the other trunc method.  Works with a Date.\n-     */\n-    public static Date trunc(Date val, int field) {\n-        GregorianCalendar gval = new GregorianCalendar();\n-        gval.setTime(val);\n-        modify(gval, field, false);\n-        return gval.getTime();\n-    }\n-\n+            throw new ClassCastException(\"Could not round \" + date);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * Truncate this date, leaving the field specified as the most significant\n      * field.  For example, if you had the datetime of 28 Mar 2002\n      * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n      * 2002 13:00:00.000.  If this was passed with MONTH, it would return\n      * 1 Mar 2002 0:00:00.000.\n-     */\n-    public static Calendar trunc(Calendar val, int field) {\n-        Calendar truncated = (Calendar) val.clone();\n+     * \n+     * @param date  the date to work with\n+     * @param field  the field from <code>Calendar</code> or SEMI_MONTH\n+     * @return the rounded date\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public static Date truncate(Date date, int field) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        GregorianCalendar gval = new GregorianCalendar();\n+        gval.setTime(date);\n+        modify(gval, field, false);\n+        return gval.getTime();\n+    }\n+\n+    /**\n+     * Truncate this date, leaving the field specified as the most significant\n+     * field.  For example, if you had the datetime of 28 Mar 2002\n+     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n+     * 2002 13:00:00.000.  If this was passed with MONTH, it would return\n+     * 1 Mar 2002 0:00:00.000.\n+     * \n+     * @param date  the date to work with\n+     * @param field  the field from <code>Calendar</code> or SEMI_MONTH\n+     * @return the rounded date (a different object)\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public static Calendar truncate(Calendar date, int field) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        Calendar truncated = (Calendar) date.clone();\n         modify(truncated, field, false);\n         return truncated;\n     }\n \n     /**\n-     * See the other trunc method.  Works with an Object, trying to\n-     * use it as either a Date or Calendar.\n-     */\n-    public static Date trunc(Object val, int field) {\n-        if (val instanceof Date) {\n-            return trunc((Date) val, field);\n-        } else if (val instanceof Calendar) {\n-            return trunc((Calendar) val, field).getTime();\n+     * Truncate this date, leaving the field specified as the most significant\n+     * field.  For example, if you had the datetime of 28 Mar 2002\n+     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n+     * 2002 13:00:00.000.  If this was passed with MONTH, it would return\n+     * 1 Mar 2002 0:00:00.000.\n+     * \n+     * @param date  the date to work with, either Date or Calendar\n+     * @param field  the field from <code>Calendar</code> or SEMI_MONTH\n+     * @return the rounded date\n+     * @throws IllegalArgumentException if the date is null\n+     * @throws ClassCastException if the object type is not a Date or Calendar\n+     */\n+    public static Date truncate(Object date, int field) {\n+        if (date == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        if (date instanceof Date) {\n+            return truncate((Date) date, field);\n+        } else if (date instanceof Calendar) {\n+            return truncate((Calendar) date, field).getTime();\n         } else {\n-            throw new ClassCastException(\"Could not trunc \" + val);\n-        }\n-    }\n-\n+            throw new ClassCastException(\"Could not truncate \" + date);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Internal calculation method\n+     * \n+     * @param val  the calendar\n+     * @param field  the field constant\n+     * @param round  true to round, false to truncate\n+     */\n     private static void modify(Calendar val, int field, boolean round) {\n         boolean roundUp = false;\n         for (int i = 0; i < fields.length; i++) {\n             //We need to remove this field\n             val.add(fields[i][0], -offset);\n         }\n-        throw new RuntimeException(\"We do not support that field.\");\n-\n-    }\n-\n-    /**\n-     * Parses strings the way that CVS supports it (very human readable).\n-     */\n-    public static Calendar parse(String original) {\n-        return parse(original, Locale.getDefault());\n-    }\n-\n-    /**\n-     * Parses strings the way that CVS supports it (very human readable).\n-     */\n-    public static Calendar parse(String original, Locale locale) {\n+        throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n+\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Parses a date string formatted in CVS format.\n+     * \n+     * @param dateStr  the date to parse\n+     * @return the parsed date\n+     * @throws IllegalArgumentException if the date cannot be parsed\n+     */\n+    public static Calendar parseCVS(String dateStr) {\n+        return parseCVS(dateStr, Locale.getDefault());\n+    }\n+\n+    /**\n+     * Parses a date string formatted in CVS format.\n+     * \n+     * @param dateStr  the date to parse\n+     * @param locale  the locale to parse in\n+     * @return the parsed date\n+     * @throws IllegalArgumentException if the date is null or cannot be parsed\n+     */\n+    public static Calendar parseCVS(String dateStr, Locale locale) {\n+        if (dateStr == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n         //Get the symbol names\n         DateFormatSymbols symbols = new DateFormatSymbols(locale);\n \n         //Prep the string to parse\n-        String value = original.toLowerCase().trim();\n+        String value = dateStr.toLowerCase().trim();\n \n         //Get the current date/time\n         Calendar now = Calendar.getInstance();\n             //Split the value and unit\n             int start = value.indexOf(\" \");\n             if (start < 0) {\n-                throw new RuntimeException(\"Could not find space in between value and unit\");\n+                throw new IllegalArgumentException(\"Could not find space in between value and unit\");\n             }\n             String unit = value.substring(start + 1);\n             value = value.substring(0, start);\n             } else if (unit.equals(\"years\") || unit.equals(\"year\")) {\n                 now.add(Calendar.YEAR, -val);\n             } else {\n-                throw new RuntimeException(\"We do not understand that many units ago\");\n+                throw new IllegalArgumentException(\"We do not understand that many units ago\");\n             }\n             return now;\n         } else if (value.startsWith(\"last \")) {\n         //Try to parse the date a number of different ways\n         for (int i = 0; i < dateFormats.length; i++) {\n             try {\n-                Date datetime = dateFormats[i].parse(original);\n+                Date datetime = dateFormats[i].parse(dateStr);\n                 Calendar cal = Calendar.getInstance();\n                 cal.setTime(datetime);\n                 return cal;\n             }\n         }\n \n-        throw new RuntimeException(\"Unable to parse '\" + original + \"'.\");\n-    }\n-\n+        throw new IllegalArgumentException(\"Unable to parse '\" + dateStr + \"'.\");\n+    }\n+\n+    //-----------------------------------------------------------------------\n     /**\n      * This constructs an Iterator that will start and stop over a date\n      * range based on the focused date and the range style.  For instance,\n      * passing Thursday, July 4, 2002 and a RANGE_MONTH_SUNDAY will return\n      * an Iterator that starts with Sunday, June 30, 2002 and ends with\n      * Saturday, August 3, 2002.\n-     */\n-    public static Iterator getCalendarIterator(Calendar focus, int rangeStyle) {\n+     * \n+     * @param focus  the date to work with\n+     * @param rangeStyle  the style constant to use\n+     * @return the date iterator\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public static Iterator iterator(Date focus, int rangeStyle) {\n+        if (focus == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n+        GregorianCalendar gval = new GregorianCalendar();\n+        gval.setTime(focus);\n+        return iterator(gval, rangeStyle);\n+    }\n+\n+    /**\n+     * This constructs an Iterator that will start and stop over a date\n+     * range based on the focused date and the range style.  For instance,\n+     * passing Thursday, July 4, 2002 and a RANGE_MONTH_SUNDAY will return\n+     * an Iterator that starts with Sunday, June 30, 2002 and ends with\n+     * Saturday, August 3, 2002.\n+     * \n+     * @param focus  the date to work with\n+     * @param rangeStyle  the style constant to use\n+     * @return the date iterator\n+     * @throws IllegalArgumentException if the date is null\n+     */\n+    public static Iterator iterator(Calendar focus, int rangeStyle) {\n+        if (focus == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n         Calendar start = null;\n         Calendar end = null;\n         int startCutoff = Calendar.SUNDAY;\n             case RANGE_MONTH_SUNDAY:\n             case RANGE_MONTH_MONDAY:\n                 //Set start to the first of the month\n-                start = trunc(focus, Calendar.MONTH);\n+                start = truncate(focus, Calendar.MONTH);\n                 //Set end to the last of the month\n                 end = (Calendar) start.clone();\n                 end.add(Calendar.MONTH, 1);\n             case RANGE_WEEK_RELATIVE:\n             case RANGE_WEEK_CENTER:\n                 //Set start and end to the current date\n-                start = trunc(focus, Calendar.DATE);\n-                end = trunc(focus, Calendar.DATE);\n+                start = truncate(focus, Calendar.DATE);\n+                end = truncate(focus, Calendar.DATE);\n                 switch (rangeStyle) {\n                     case RANGE_WEEK_SUNDAY:\n                         //already set by default\n                 }\n                 break;\n             default:\n-                throw new RuntimeException(\"The range style \" + rangeStyle + \" is not valid.\");\n+                throw new IllegalArgumentException(\"The range style \" + rangeStyle + \" is not valid.\");\n         }\n         if (startCutoff < Calendar.SUNDAY) {\n             startCutoff += 7;\n         while (end.get(Calendar.DAY_OF_WEEK) != endCutoff) {\n             end.add(Calendar.DATE, 1);\n         }\n-        final Calendar startFinal = start;\n-        final Calendar endFinal = end;\n-        Iterator it = new Iterator() {\n-            Calendar spot = null;\n-            {\n-                spot = startFinal;\n-                spot.add(Calendar.DATE, -1);\n-            }\n-\n-            public boolean hasNext() {\n-                return spot.before(endFinal);\n-            }\n-\n-            public Object next() {\n-                if (spot.equals(endFinal)) {\n-                    throw new NoSuchElementException();\n-                }\n-                spot.add(Calendar.DATE, 1);\n-                return spot.clone();\n-            }\n-\n-            public void remove() {\n-                throw new UnsupportedOperationException();\n-            }\n-        };\n-        return it;\n-    }\n-\n-    /**\n-     * See the other getCalendarIterator.  Works with a Date.\n-     */\n-    public static Iterator getCalendarIterator(Date focus, int rangeStyle) {\n-        GregorianCalendar gval = new GregorianCalendar();\n-        gval.setTime(focus);\n-        return getCalendarIterator(gval, rangeStyle);\n-    }\n-\n-    /**\n-     * See the other getCalendarIterator.  Works with an Object, trying\n-     * to use it as a Date or Calendar.\n-     */\n-    public static Iterator getCalendarIterator(Object focus, int rangeStyle) {\n+        return new DateIterator(start, end);\n+    }\n+\n+    /**\n+     * This constructs an Iterator that will start and stop over a date\n+     * range based on the focused date and the range style.  For instance,\n+     * passing Thursday, July 4, 2002 and a RANGE_MONTH_SUNDAY will return\n+     * an Iterator that starts with Sunday, June 30, 2002 and ends with\n+     * Saturday, August 3, 2002.\n+     * \n+     * @param focus  the date to work with, either Date or Calendar\n+     * @param rangeStyle  the style constant to use\n+     * @return the date iterator\n+     * @throws IllegalArgumentException if the date is null\n+     * @throws ClassCastException if the object type is not a Date or Calendar\n+     */\n+    public static Iterator iterator(Object focus, int rangeStyle) {\n+        if (focus == null) {\n+            throw new IllegalArgumentException(\"The date must not be null\");\n+        }\n         if (focus instanceof Date) {\n-            return getCalendarIterator((Date) focus, rangeStyle);\n+            return iterator((Date) focus, rangeStyle);\n         } else if (focus instanceof Calendar) {\n-            return getCalendarIterator((Calendar) focus, rangeStyle);\n+            return iterator((Calendar) focus, rangeStyle);\n         } else {\n             throw new ClassCastException(\"Could not iterate based on \" + focus);\n         }\n     }\n \n+    /**\n+     * Date iterator.\n+     */\n+    static class DateIterator implements Iterator {\n+        private final Calendar startFinal;\n+        private final Calendar endFinal;\n+        private Calendar spot = null;\n+        \n+        DateIterator(Calendar startFinal, Calendar endFinal) {\n+            super();\n+            this.startFinal = startFinal;\n+            this.endFinal = endFinal;\n+            spot = startFinal;\n+            spot.add(Calendar.DATE, -1);\n+        }\n+\n+        public boolean hasNext() {\n+            return spot.before(endFinal);\n+        }\n+\n+        public Object next() {\n+            if (spot.equals(endFinal)) {\n+                throw new NoSuchElementException();\n+            }\n+            spot.add(Calendar.DATE, 1);\n+            return spot.clone();\n+        }\n+\n+        public void remove() {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n }\n--- a/src/test/org/apache/commons/lang/time/DateUtilsTest.java\n+++ b/src/test/org/apache/commons/lang/time/DateUtilsTest.java\n         assertEquals(\"round second-2 failed\",\n                 dateTimeParser.parse(\"November 18, 2001 1:23:11.000\"),\n                 DateUtils.round(date2, Calendar.SECOND));\n+                \n+        try {\n+            DateUtils.round((Date) null, Calendar.SECOND);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateUtils.round((Calendar) null, Calendar.SECOND);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateUtils.round((Object) null, Calendar.SECOND);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateUtils.round(\"\", Calendar.SECOND);\n+            fail();\n+        } catch (ClassCastException ex) {}\n     }\n \n     /**\n      * Tests various values with the trunc method\n      */\n-    public void testTrunc() throws Exception {\n-        assertEquals(\"trunc year-1 failed\",\n+    public void testTruncate() throws Exception {\n+        assertEquals(\"truncate year-1 failed\",\n                 dateParser.parse(\"January 1, 2002\"),\n-                DateUtils.trunc(date1, Calendar.YEAR));\n-        assertEquals(\"trunc year-2 failed\",\n+                DateUtils.truncate(date1, Calendar.YEAR));\n+        assertEquals(\"truncate year-2 failed\",\n                 dateParser.parse(\"January 1, 2001\"),\n-                DateUtils.trunc(date2, Calendar.YEAR));\n-        assertEquals(\"trunc month-1 failed\",\n+                DateUtils.truncate(date2, Calendar.YEAR));\n+        assertEquals(\"truncate month-1 failed\",\n                 dateParser.parse(\"February 1, 2002\"),\n-                DateUtils.trunc(date1, Calendar.MONTH));\n-        assertEquals(\"trunc month-2 failed\",\n+                DateUtils.truncate(date1, Calendar.MONTH));\n+        assertEquals(\"truncate month-2 failed\",\n                 dateParser.parse(\"November 1, 2001\"),\n-                DateUtils.trunc(date2, Calendar.MONTH));\n-        assertEquals(\"trunc semimonth-1 failed\",\n+                DateUtils.truncate(date2, Calendar.MONTH));\n+        assertEquals(\"truncate semimonth-1 failed\",\n                 dateParser.parse(\"February 1, 2002\"),\n-                DateUtils.trunc(date1, DateUtils.SEMI_MONTH));\n-        assertEquals(\"trunc semimonth-2 failed\",\n+                DateUtils.truncate(date1, DateUtils.SEMI_MONTH));\n+        assertEquals(\"truncate semimonth-2 failed\",\n                 dateParser.parse(\"November 16, 2001\"),\n-                DateUtils.trunc(date2, DateUtils.SEMI_MONTH));\n-        assertEquals(\"trunc date-1 failed\",\n+                DateUtils.truncate(date2, DateUtils.SEMI_MONTH));\n+        assertEquals(\"truncate date-1 failed\",\n                 dateParser.parse(\"February 12, 2002\"),\n-                DateUtils.trunc(date1, Calendar.DATE));\n-        assertEquals(\"trunc date-2 failed\",\n+                DateUtils.truncate(date1, Calendar.DATE));\n+        assertEquals(\"truncate date-2 failed\",\n                 dateParser.parse(\"November 18, 2001\"),\n-                DateUtils.trunc(date2, Calendar.DATE));\n-        assertEquals(\"trunc hour-1 failed\",\n+                DateUtils.truncate(date2, Calendar.DATE));\n+        assertEquals(\"truncate hour-1 failed\",\n                 dateTimeParser.parse(\"February 12, 2002 12:00:00.000\"),\n-                DateUtils.trunc(date1, Calendar.HOUR));\n-        assertEquals(\"trunc hour-2 failed\",\n+                DateUtils.truncate(date1, Calendar.HOUR));\n+        assertEquals(\"truncate hour-2 failed\",\n                 dateTimeParser.parse(\"November 18, 2001 1:00:00.000\"),\n-                DateUtils.trunc(date2, Calendar.HOUR));\n-        assertEquals(\"trunc minute-1 failed\",\n+                DateUtils.truncate(date2, Calendar.HOUR));\n+        assertEquals(\"truncate minute-1 failed\",\n                 dateTimeParser.parse(\"February 12, 2002 12:34:00.000\"),\n-                DateUtils.trunc(date1, Calendar.MINUTE));\n-        assertEquals(\"trunc minute-2 failed\",\n+                DateUtils.truncate(date1, Calendar.MINUTE));\n+        assertEquals(\"truncate minute-2 failed\",\n                 dateTimeParser.parse(\"November 18, 2001 1:23:00.000\"),\n-                DateUtils.trunc(date2, Calendar.MINUTE));\n-        assertEquals(\"trunc second-1 failed\",\n+                DateUtils.truncate(date2, Calendar.MINUTE));\n+        assertEquals(\"truncate second-1 failed\",\n                 dateTimeParser.parse(\"February 12, 2002 12:34:56.000\"),\n-                DateUtils.trunc(date1, Calendar.SECOND));\n-        assertEquals(\"trunc second-2 failed\",\n+                DateUtils.truncate(date1, Calendar.SECOND));\n+        assertEquals(\"truncate second-2 failed\",\n                 dateTimeParser.parse(\"November 18, 2001 1:23:11.000\"),\n-                DateUtils.trunc(date2, Calendar.SECOND));\n-\n+                DateUtils.truncate(date2, Calendar.SECOND));\n+\n+        try {\n+            DateUtils.truncate((Date) null, Calendar.SECOND);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateUtils.truncate((Calendar) null, Calendar.SECOND);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateUtils.truncate((Object) null, Calendar.SECOND);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateUtils.truncate(\"\", Calendar.SECOND);\n+            fail();\n+        } catch (ClassCastException ex) {}\n     }\n \n     /**\n      * Tests the parse method, which is supposed to handle various strings\n      * as flexibly as CVS supports.\n      */\n-    public void testParse() throws Exception {\n+    public void testParseCVS() throws Exception {\n+        try {\n+            DateUtils.parseCVS(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateUtils.parseCVS(\"gobbledegook\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n         //This is difficult to test since the \"now\" used in the\n         //  parse function cannot be controlled.  We could possibly control\n         //  it by trying before and after and making sure the value we expect\n \n         now = Calendar.getInstance();\n         now.add(Calendar.MINUTE, -1);\n-        assertEquals(\"parse 1 minute ago\",\n-                now, DateUtils.parse(\"1 minute ago\"), 50);\n+        assertEquals(\"parseCVS 1 minute ago\",\n+                now, DateUtils.parseCVS(\"1 minute ago\"), 50);\n         now = Calendar.getInstance();\n         now.add(Calendar.MINUTE, -8);\n-        assertEquals(\"parse 8 minutes ago\",\n-                now, DateUtils.parse(\"8 minutes ago\"), 50);\n+        assertEquals(\"parseCVS 8 minutes ago\",\n+                now, DateUtils.parseCVS(\"8 minutes ago\"), 50);\n \n         now = Calendar.getInstance();\n         now.add(Calendar.DATE, -1);\n-        assertEquals(\"parse yesterday\",\n-                now, DateUtils.parse(\"yesterday\"), 50);\n+        assertEquals(\"parseCVS yesterday\",\n+                now, DateUtils.parseCVS(\"yesterday\"), 50);\n \n         now = Calendar.getInstance();\n         now.add(Calendar.DATE, 1);\n-        assertEquals(\"parse tomorrow\",\n-                now, DateUtils.parse(\"tomorrow\"), 50);\n+        assertEquals(\"parseCVS tomorrow\",\n+                now, DateUtils.parseCVS(\"tomorrow\"), 50);\n \n         now = Calendar.getInstance();\n         //Sunday would be 1, Saturday would be 7, so we walk back up to 6 days.\n         } else {\n             now.add(Calendar.DATE, 1 - now.get(Calendar.DAY_OF_WEEK));\n         }\n-        assertEquals(\"parse last Sunday\",\n-                now, DateUtils.parse(\"last Sunday\"), 50);\n+        assertEquals(\"parseCVS last Sunday\",\n+                now, DateUtils.parseCVS(\"last Sunday\"), 50);\n \n         now = Calendar.getInstance();\n         now.add(Calendar.DATE, -7);\n-        assertEquals(\"parse last week\",\n-                now, DateUtils.parse(\"last week\"), 50);\n+        assertEquals(\"parseCVS last week\",\n+                now, DateUtils.parseCVS(\"last week\"), 50);\n \n         now = Calendar.getInstance();\n         //January would be 0, December would be 11, so we walk back up to 11 months\n         } else {\n             now.add(Calendar.MONTH, 0 - now.get(Calendar.MONTH));\n         }\n-        assertEquals(\"parse last January\",\n-                now, DateUtils.parse(\"last January\"), 50);\n+        assertEquals(\"parseCVS last January\",\n+                now, DateUtils.parseCVS(\"last January\"), 50);\n+    }\n+\n+    /**\n+     * Tests the iterator exceptions\n+     */\n+    public void testIteratorEx() throws Exception {\n+        try {\n+            DateUtils.iterator((Date) null, DateUtils.RANGE_WEEK_CENTER);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateUtils.iterator((Calendar) null, DateUtils.RANGE_WEEK_CENTER);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateUtils.iterator((Object) null, DateUtils.RANGE_WEEK_CENTER);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            DateUtils.iterator(\"\", DateUtils.RANGE_WEEK_CENTER);\n+            fail();\n+        } catch (ClassCastException ex) {}\n     }\n \n     /**\n     public void testWeekIterator() throws Exception {\n         Calendar now = Calendar.getInstance();\n         for (int i = 0; i< 7; i++) {\n-            Calendar today = DateUtils.trunc(now, Calendar.DATE);\n-            Calendar sunday = DateUtils.trunc(now, Calendar.DATE);\n+            Calendar today = DateUtils.truncate(now, Calendar.DATE);\n+            Calendar sunday = DateUtils.truncate(now, Calendar.DATE);\n             sunday.add(Calendar.DATE, 1 - sunday.get(Calendar.DAY_OF_WEEK));\n-            Calendar monday = DateUtils.trunc(now, Calendar.DATE);\n+            Calendar monday = DateUtils.truncate(now, Calendar.DATE);\n             if (monday.get(Calendar.DAY_OF_WEEK) == 1) {\n                 //This is sunday... roll back 6 days\n                 monday.add(Calendar.DATE, -6);\n             } else {\n                 monday.add(Calendar.DATE, 2 - monday.get(Calendar.DAY_OF_WEEK));\n             }\n-            Calendar centered = DateUtils.trunc(now, Calendar.DATE);\n+            Calendar centered = DateUtils.truncate(now, Calendar.DATE);\n             centered.add(Calendar.DATE, -3);\n             \n-            Iterator it = DateUtils.getCalendarIterator(now, DateUtils.RANGE_WEEK_SUNDAY);\n+            Iterator it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_SUNDAY);\n             assertWeekIterator(it, sunday);\n-            it = DateUtils.getCalendarIterator(now, DateUtils.RANGE_WEEK_MONDAY);\n+            it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_MONDAY);\n             assertWeekIterator(it, monday);\n-            it = DateUtils.getCalendarIterator(now, DateUtils.RANGE_WEEK_RELATIVE);\n+            it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_RELATIVE);\n             assertWeekIterator(it, today);\n-            it = DateUtils.getCalendarIterator(now, DateUtils.RANGE_WEEK_CENTER);\n+            it = DateUtils.iterator(now, DateUtils.RANGE_WEEK_CENTER);\n             assertWeekIterator(it, centered);\n             now.add(Calendar.DATE,1);\n         }\n     }\n-\n+            \n     /**\n      * Tests the calendar iterator for month-based ranges\n      */\n     public void testMonthIterator() throws Exception {\n-        Iterator it = DateUtils.getCalendarIterator(date1, DateUtils.RANGE_MONTH_SUNDAY);\n+        Iterator it = DateUtils.iterator(date1, DateUtils.RANGE_MONTH_SUNDAY);\n         assertWeekIterator(it,\n                 dateParser.parse(\"January 27, 2002\"),\n                 dateParser.parse(\"March 2, 2002\"));\n \n-        it = DateUtils.getCalendarIterator(date1, DateUtils.RANGE_MONTH_MONDAY);\n+        it = DateUtils.iterator(date1, DateUtils.RANGE_MONTH_MONDAY);\n         assertWeekIterator(it,\n                 dateParser.parse(\"January 28, 2002\"),\n                 dateParser.parse(\"March 3, 2002\"));\n \n-        it = DateUtils.getCalendarIterator(date2, DateUtils.RANGE_MONTH_SUNDAY);\n+        it = DateUtils.iterator(date2, DateUtils.RANGE_MONTH_SUNDAY);\n         assertWeekIterator(it,\n                 dateParser.parse(\"October 28, 2001\"),\n                 dateParser.parse(\"December 1, 2001\"));\n \n-        it = DateUtils.getCalendarIterator(date2, DateUtils.RANGE_MONTH_MONDAY);\n+        it = DateUtils.iterator(date2, DateUtils.RANGE_MONTH_MONDAY);\n         assertWeekIterator(it,\n                 dateParser.parse(\"October 29, 2001\"),\n                 dateParser.parse(\"December 2, 2001\"));\n         int count = 1;\n         while (it.hasNext()) {\n             //Check this is just a date (no time component)\n-            assertEquals(\"\", cal, DateUtils.trunc(cal, Calendar.DATE), 0);\n+            assertEquals(\"\", cal, DateUtils.truncate(cal, Calendar.DATE), 0);\n \n             last = cal;\n             cal = (Calendar) it.next();", "timestamp": 1056411670, "metainfo": ""}