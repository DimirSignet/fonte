{"sha": "5064231cd1ba80e3a369312b653f9a0b1f48c46a", "log": "In the .text package (not for 2.1): - Javadoc nits: missing tags, wrong name in @param, \".\" in 1st line. - Refactored magic number \"32\" into static final \"CAPACITY\". - Removed extra C-style \"return (expr)\" in return expressions.   ", "commit": "\n--- a/src/java/org/apache/commons/lang/text/Interpolation.java\n+++ b/src/java/org/apache/commons/lang/text/Interpolation.java\n     }\n \n     /**\n-     * <p>Interpolates a String to replace variables of the form <code>${...}</code>.</p>\n+     * <p>Interpolates a String to replace variables of the form <code>${variable}</code>.</p>\n      * \n      * <p>This method is useful for enabling simple strings to be modified based\n      * on a map of data. A typical use case might be to add data from configuration\n     }\n \n     /**\n-     * <p>Interpolates a String to replace variables of the form <code>${...}</code>\n+     * <p>Interpolates a String to replace variables of the form <code>${variable}</code>\n      * where the replace strings may also contain variables to interpolate.</p>\n      * \n      * <p>This method is useful for enabling simple strings to be modified based\n--- a/src/java/org/apache/commons/lang/text/MappedMessageFormat.java\n+++ b/src/java/org/apache/commons/lang/text/MappedMessageFormat.java\n      * Constructs a new instance.\n      */\n     public MappedMessageFormat() {\n+        // no initialization.\n     }\n     \n     /**\n--- a/src/java/org/apache/commons/lang/text/StrBuilder.java\n+++ b/src/java/org/apache/commons/lang/text/StrBuilder.java\n  */\n public class StrBuilder implements Cloneable {\n \n+    /**\n+     * The extra capacity for new builders.\n+     */\n+    static final int CAPACITY = 32;\n+\n     /** Serialization lock. */\n     private static final long serialVersionUID = 7628716375283629643L;\n \n     public StrBuilder(int initialCapacity) {\n         super();\n         if (initialCapacity <= 0) {\n-            initialCapacity = 32;\n+            initialCapacity = CAPACITY;\n         }\n         buf = new char[initialCapacity];\n     }\n     /**\n      * Clears the string builder (convenience Collections API style method).\n      * <p>\n-     * This method is the same as {@link #setLength(0)} and is provided to match the\n+     * This method is the same as {@link #setLength(int)} and is provided to match the\n      * API of Collections.\n      */\n     public void clear() {\n      * <p>\n      * This method is the same as checking {@link #length()} and is provided to match the\n      * API of Collections.\n+     * @return <code>true</code> if the size is <code>0</code>.\n      */\n     public boolean isEmpty() {\n-        return (size == 0);\n+        return size == 0;\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Appends the text representing <code>null</code> to the string builder.\n      *\n-     * @param obj  the object to append\n      * @return this, to enable chaining\n      */\n     public StrBuilder appendNull() {\n     /**\n      * Appends a char value to the string builder.\n      *\n-     * @param value  the value to append\n+     * @param ch  the value to append\n      * @return this, to enable chaining\n      */\n     public StrBuilder append(char ch) {\n     /**\n      * Extracts a portion of this string builder as a string.\n      * \n-     * @param startIndex  the start index, inclusive, must be valid\n+     * @param start  the start index, inclusive, must be valid\n      * @return the new string\n      * @throws StringIndexOutOfBoundsException if the index is invalid\n      */\n      * @return true if the builder contains the string\n      */\n     public boolean contains(String str) {\n-        return (indexOf(str, 0) >= 0);\n+        return indexOf(str, 0) >= 0;\n     }\n \n     //-----------------------------------------------------------------------\n--- a/src/java/org/apache/commons/lang/text/StrTokenizer.java\n+++ b/src/java/org/apache/commons/lang/text/StrTokenizer.java\n      * Constructor that creates a matcher from a set of characters.\n      *\n      * @param chars  the characters to match, must not be null\n+     * @return A new matcher for the given char[].\n      * @throws IllegalArgumentException if the character set is null or empty\n      */\n     public static Matcher createCharSetMatcher(char[] chars) {\n      * Constructor that creates a matcher from a string representing a set of characters.\n      *\n      * @param chars  the characters to match, must not be null\n+     * @return A new Matcher for the given characters.\n      * @throws IllegalArgumentException if the character set is null or empty\n      */\n     public static Matcher createCharSetMatcher(String chars) {\n      * Constructor that creates a matcher from a character.\n      *\n      * @param ch  the character to match, must not be null\n+     * @return A new Matcher for the given char.\n      */\n     public static Matcher createCharMatcher(char ch) {\n         return new CharMatcher(ch);\n      * Constructor that creates a matcher from a string.\n      *\n      * @param str  the string to match, must not be null\n+     * @return A new Matcher for the given String.\n      * @throws IllegalArgumentException if the string is null or empty\n      */\n     public static Matcher createStringMatcher(String str) {\n      * the setTrimmer method).\n      * <p>\n      * You must call a \"reset\" method to set the string which you want to parse.\n+     * @return a new tokenizer instance which parses Comma Seperated Value strings\n      */\n     public static StrTokenizer getCSVInstance() {\n-        return (StrTokenizer)(CSV_TOKENIZER_PROTOTYPE.clone());\n+        return (StrTokenizer)CSV_TOKENIZER_PROTOTYPE.clone();\n     }\n \n     /**\n      * the setTrimmer method).\n      *\n      * @param input  the text to parse\n+     * @return a new tokenizer instance which parses Comma Seperated Value strings\n      */\n     public static StrTokenizer getCSVInstance(String input) {\n         StrTokenizer tok = (StrTokenizer)(CSV_TOKENIZER_PROTOTYPE.clone());\n      * the setTrimmer method).\n      *\n      * @param input  the text to parse\n+     * @return a new tokenizer instance which parses Comma Seperated Value strings\n      */\n     public static StrTokenizer getCSVInstance(char[] input) {\n         StrTokenizer tok = (StrTokenizer)(CSV_TOKENIZER_PROTOTYPE.clone());\n      * (which can be overriden with the setTrimmer method).\n      * <p>\n      * You must call a \"reset\" method to set the string which you want to parse.\n+     * @return a new tokenizer instance which parses Tab Seperated Value strings.\n      */\n     public static StrTokenizer getTSVInstance() {\n-        return (StrTokenizer)(TSV_TOKENIZER_PROTOTYPE.clone());\n+        return (StrTokenizer)TSV_TOKENIZER_PROTOTYPE.clone();\n     }\n \n     /**\n      * The default for CSV processing will be trim whitespace from both ends\n      * (which can be overriden with the setTrimmer method).\n      * @param input  the string to parse\n+     * @return a new tokenizer instance which parses Tab Seperated Value strings.\n      */\n     public static StrTokenizer getTSVInstance(String input) {\n         StrTokenizer tok = (StrTokenizer)(TSV_TOKENIZER_PROTOTYPE.clone());\n      * The default for CSV processing will be trim whitespace from both ends\n      * (which can be overriden with the setTrimmer method).\n      * @param input  the string to parse\n+     * @return a new tokenizer instance which parses Tab Seperated Value strings.\n      */\n     public static StrTokenizer getTSVInstance(char[] input) {\n         StrTokenizer tok = (StrTokenizer)(TSV_TOKENIZER_PROTOTYPE.clone());\n      */\n     public boolean hasNext() {\n         tokenize();\n-        return (tokenPos < tokens.length);\n+        return tokenPos < tokens.length;\n     }\n \n     /**\n      */\n     public boolean hasPrevious() {\n         tokenize();\n-        return (tokenPos > 0);\n+        return tokenPos > 0;\n     }\n \n     /**\n      * @return the previous token index\n      */\n     public int previousIndex() {\n-        return (tokenPos - 1);\n+        return tokenPos - 1;\n     }\n \n     /**\n \n     /**\n      * Unsupported ListIterator operation.\n-     *\n+     * @param obj this parameter ignored.\n      * @throws UnsupportedOperationException always\n      */\n     public void set(Object obj) {\n \n     /**\n      * Unsupported ListIterator operation.\n-     *\n+     * @param obj this parameter ignored.\n      * @throws UnsupportedOperationException always\n      */\n     public void add(Object obj) {\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Create a new instance of this Tokenizer.\n+     * Creates a new instance of this Tokenizer.\n      * The new instance is reset so that it will be at the start of the token list.\n+     * @return a new instance of this Tokenizer which has been reset.\n      */\n     public Object clone() {\n         try {\n          * @return the number of matching characters, zero for no match\n          */\n         public int isMatch(char[] text, int textLen, int pos) {\n-            return (Arrays.binarySearch(chars, text[pos]) >= 0 ? 1 : 0);\n+            return Arrays.binarySearch(chars, text[pos]) >= 0 ? 1 : 0;\n         }\n     }\n \n          * @return the number of matching characters, zero for no match\n          */\n         public int isMatch(char[] text, int textLen, int pos) {\n-            return (ch == text[pos] ? 1 : 0);\n+            return ch == text[pos] ? 1 : 0;\n         }\n     }\n \n          * @return the number of matching characters, zero for no match\n          */\n         public int isMatch(char[] text, int textLen, int pos) {\n-            return (text[pos] <= 32 ? 1 : 0);\n+            return text[pos] <= 32 ? 1 : 0;\n         }\n     }\n ", "timestamp": 1113250300, "metainfo": ""}