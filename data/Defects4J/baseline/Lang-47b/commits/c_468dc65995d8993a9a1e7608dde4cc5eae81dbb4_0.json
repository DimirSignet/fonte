{"sha": "468dc65995d8993a9a1e7608dde4cc5eae81dbb4", "log": "Format ready for 2.1   ", "commit": "\n--- a/src/java/org/apache/commons/lang/Interpolation.java\n+++ b/src/java/org/apache/commons/lang/Interpolation.java\n package org.apache.commons.lang;\n \n-import java.util.HashMap;\n import java.util.Iterator;\n import java.util.Map;\n \n /**\n- * Performs basic variable interpolation on a String for variables within \n- * a Map. Variables of the form, ${var}, are supported.\n+ * <p>Performs basic variable interpolation on a String for variables within a Map.\n+ * Variables of the form, ${var}, are supported.</p>\n  *\n  * @author Ken Fitzpatrick\n  * @author Henri Yandell\n+ * @since 2.1\n+ * @version $Id: Interpolation.java,v 1.2 2004/08/15 23:18:43 scolebourne Exp $\n  */\n public class Interpolation {\n \n-    // QUERY: Anyway to escape the ${..} variable so it is not interpolated?\n-\n-    // TODO: Consider making these configurable?\n+    /** The marker used to start a variable. */\n     private static final String SYMBOLIC_VALUE_MARKER_START = \"${\";\n+    /** The marker used to end a variable. */\n     private static final String SYMBOLIC_VALUE_MARKER_END = \"}\";\n \n     /**\n-     *  <p>\n-     *  Returns a String that is the result of having performed\n-     *  variable interpolation on <code>templateString</code>,\n-     *  using the value set found in <code>values</code>.\n-     *  </p>\n-     *  <p>\n-     *  The solution is compatible with all JDK versions\n-     *  where Jakarta/Commons/Lang also is supported.\n-     *  </p>\n-     *  <p>\n-     *  The expected format of <code>templateString</code> is:\n-     *<code><pre>\n+     * <p>Interpolates a String to replace variables of the form <code>${...}</code>.</p>\n+     * \n+     * <p>This method is useful for enabling simple strings to be modified based\n+     * on a map of data. A typical use case might be to add data from configuration\n+     * to an error message. This method, and this class, does not seek to replace\n+     * full interpolation mechanisms, for example Velocity.</p>\n+     * \n+     * <p>The expected format of <code>templateString</code> is:\n+     * <code><pre>\n      *   The ${animal} jumped over the ${target}.\n-     *</pre></code>\n-     *  such that the key/value pairs found in <code>values</code>\n-     *  are substituted into the string at the <code>${key-name}</code> markers.\n-     *  In the above example, <code>valuesMap</code> could have been populated as:\n-     *<code><pre>\n+     * </pre></code>\n+     * such that the key/value pairs found in <code>values</code>\n+     * are substituted into the string at the <code>${key-name}</code> markers.\n+     * In the above example, <code>valuesMap</code> could have been populated as:\n+     * <code><pre>\n      *   Map valuesMap = HashMap();\n      *   valuesMap.put( \"animal\", \"quick brown fox\" );\n      *   valuesMap.put( \"target\", \"lazy dog\" );\n      *   String resolvedString = StringUtils.interpolate( templateString, valuesMap );\n-     *</pre></code>\n-     *  yielding:\n-     *<code><pre>\n+     * </pre></code>\n+     * yielding:\n+     * <code><pre>\n      *   The quick brown fox jumped over the lazy dog.\n-     *</pre></code>\n-     *  </p>\n-     *  <p>\n-     *  The same <code>templateString</code> from the above example could be reused as:\n-     *<code><pre>\n+     * </pre></code></p>\n+     * \n+     * <p>The same <code>templateString</code> from the above example could be reused as:\n+     * <code><pre>\n      *   Map valuesMap = HashMap();\n      *   valuesMap.put( \"animal\", \"cow\" );\n      *   valuesMap.put( \"target\", \"moon\" );\n      *   String resolvedString = StringUtils.interpolate( templateString, valuesMap );\n-     *</pre></code>\n-     *  yielding:\n-     *<code><pre>\n+     * </pre></code>\n+     * yielding:\n+     * <code><pre>\n      *   The cow jumped over the moon.\n-     *</pre></code>\n-     *  </p>\n-     *  <p>\n-     *  The value of <code>templateString</code> is returned in an unaltered if <code>templateString</code>\n-     *  is null, empty, or contains no marked variables that can be resolved by the key/value pairs found in\n-     *  <code>valuesMap</code>, or if <code>valuesMap</code> is null, empty or has no key/value pairs that can be\n-     *  applied to the marked variables within <code>templateString</code>.\n-     *  </p>\n-     * @param templateString String containing any mixture of variable and non-variable\n+     * </pre></code></p>\n+     * \n+     * <p>The value of <code>templateString</code> is returned in an unaltered\n+     * if <code>templateString</code> is null, empty, or contains no marked variables\n+     * that can be resolved by the key/value pairs found in <code>valuesMap</code>,\n+     * or if <code>valuesMap</code> is null, empty or has no key/value pairs that can be\n+     * applied to the marked variables within <code>templateString</code>.</p>\n+     * \n+     * <p>If a <code>valuesMap</code> value is null, it will be treated as \"\".</p>\n+     * \n+     * @param templateString  String containing any mixture of variable and non-variable\n      *      content, to be used as a template for the value substitution process\n-     * @param valuesMap Map containing the key/value pairs to be used to resolve\n+     * @param valuesMap  Map containing the key/value pairs to be used to resolve\n      *      the values of the marked variables found within <code>templateString</code>\n-     * @return String\n+     * @return the interpolated String\n      */\n-    public static String interpolate( String templateString, Map valuesMap ) {\n+    public static String interpolate(String templateString, Map valuesMap) {\n         // pre-conditions\n-        if ( valuesMap == null )\n+        if (templateString == null || valuesMap == null ||\n+            templateString.length() == 0 || valuesMap.isEmpty()) {\n             return templateString;\n-        if ( templateString == null )\n-            return templateString;\n-        if ( templateString.length() < 1 )\n-            return templateString;\n-        if ( valuesMap.isEmpty() )\n-            return templateString;\n-\n+        }\n+        \n         // default the returned String to the templateString\n         String returnString = templateString;\n         String nextKey = null;\n         Object substitutionBean = null;\n         String substitutionValue = null;\n         String nextValueToBeSubstituted = null;\n-\n+        \n         // get a list of substitution valuesMap\n         Iterator keys = valuesMap.keySet().iterator();\n-\n-        while( keys.hasNext() ) {\n-            nextKey = ( String ) keys.next();\n-            substitutionValue = StringUtils.defaultString( ( String ) valuesMap.get( nextKey ) );\n+        while (keys.hasNext()) {\n+            nextKey = (String) keys.next();\n+            substitutionValue = StringUtils.defaultString((String) valuesMap.get(nextKey));\n             nextValueToBeSubstituted = SYMBOLIC_VALUE_MARKER_START + nextKey + SYMBOLIC_VALUE_MARKER_END;\n \n-            returnString = StringUtils.replace( returnString, nextValueToBeSubstituted, substitutionValue );\n+            returnString = StringUtils.replace(returnString, nextValueToBeSubstituted, substitutionValue);\n         }\n         return returnString;\n     }\n \n-\n     /**\n-     *  <p>\n-     *  Returns a String that is the result of having performed variable interpolation on\n-     *  <code>templateString</code>, using the value set found in <code>values</code>,\n-     *  repeatedly until there are no changes. \n-     *  </p>\n-     *  <p>\n-     *  The expected format of <code>templateString</code> is:\n-     *<code><pre>\n+     * <p>Interpolates a String to replace variables of the form <code>${...}</code>\n+     * where the replace strings may also contain variables to interpolate.</p>\n+     * \n+     * <p>This method is useful for enabling simple strings to be modified based\n+     * on a map of data. A typical use case might be to add data from configuration\n+     * to an error message. This method, and this class, does not seek to replace\n+     * full interpolation mechanisms, for example Velocity.</p>\n+     * \n+     * <p>This method calls {@link #interpolate(String, Map)} repeatedly until the\n+     * returned string does not change. This has the effect of allowing the replace\n+     * strings in <code>valuesMap</code> to contain variables that should also be\n+     * interpolated.</p>\n+     * \n+     * <p>The expected format of <code>templateString</code> is:\n+     * <code><pre>\n      *   The ${animal} jumped over the ${target}.\n-     *</pre></code>\n-     *  such that the key/value pairs found in <code>values</code> are substituted into the string at the\n-     *  <code>${key-name}</code> markers.  In the above example, <code>valuesMap</code>\n-     *  could have been populated as:\n-     *<code><pre>\n+     * </pre></code>\n+     * such that the key/value pairs found in <code>values</code> are substituted into the string at the\n+     * <code>${key-name}</code> markers.  In the above example, <code>valuesMap</code>\n+     * could have been populated as:\n+     * <code><pre>\n      *   Map valuesMap = HashMap();\n      *   valuesMap.put( \"animal\", \"${critter}\" );\n      *   valuesMap.put( \"target\", \"${pet}\" );\n      *   valuesMap.put( \"critterColor\", \"brown\" );\n      *   valuesMap.put( \"critterType\", \"fox\" );\n      *   String resolvedString = StringUtils.interpolate( templateString, valuesMap, true );\n-     *</pre></code>\n-     *  yielding:\n-     *<code><pre>\n+     * </pre></code>\n+     * yielding:\n+     * <code><pre>\n      *   The quick brown fox jumped over the lazy dog.\n-     *</pre></code>\n-     *  </p>\n-     *  yielding:\n-     *<code><pre>\n-     *   The cow jumped over the moon.\n-     *</pre></code>\n-     *  </p>\n-     *  <p>\n-     *  The value of <code>templateString</code> is returned in an unaltered form if\n-     *  <code>templateString</code> is null, empty, or\n-     *  contains no marked variables that can be resolved by the key/value pairs found in\n-     *  <code>valuesMap</code>, or if <code>valuesMap</code> is null, empty or has no key/value \n-     *  pairs that can be applied to the marked variables within <code>templateString</code>.\n-     *  </p>\n-     * @param templateString String containing any mixture of variable and non-variable\n+     * </pre></code></p>\n+     * \n+     * <p>The value of <code>templateString</code> is returned in an unaltered\n+     * if <code>templateString</code> is null, empty, or contains no marked variables\n+     * that can be resolved by the key/value pairs found in <code>valuesMap</code>,\n+     * or if <code>valuesMap</code> is null, empty or has no key/value pairs that can be\n+     * applied to the marked variables within <code>templateString</code>.</p>\n+     * \n+     * <p>If a <code>valuesMap</code> value is null, it will be treated as \"\".</p>\n+     * \n+     * @param templateString  String containing any mixture of variable and non-variable\n      *      content, to be used as a template for the value substitution process\n-     * @param valuesMap Map containing the key/value pairs to be used to resolve\n+     * @param valuesMap  Map containing the key/value pairs to be used to resolve\n      *      the values of the marked variables found within <code>templateString</code>\n-     * @return String\n+     * @return the interpolated String\n      */\n-    public static String interpolateRepeatedly(\n-            String templateString,\n-            Map valuesMap)\n-    {\n+    public static String interpolateRepeatedly(String templateString, Map valuesMap) {\n         // pre-conditions\n-        if ( valuesMap == null )\n+        if (templateString == null || valuesMap == null ||\n+            templateString.length() == 0 || valuesMap.isEmpty()) {\n             return templateString;\n-        if ( templateString == null )\n-            return templateString;\n-        if ( templateString.length() < 1 )\n-            return templateString;\n-        if ( valuesMap.isEmpty() )\n-            return templateString;\n-\n+        }\n+        \n         String currentResult = templateString;\n         String previousResult = null;\n-        while( ! StringUtils.equals( currentResult, previousResult ) )\n-        {\n+        while (!StringUtils.equals(currentResult, previousResult)) {\n             previousResult = currentResult;\n-            currentResult = Interpolation.interpolate( previousResult, valuesMap );\n+            currentResult = Interpolation.interpolate(previousResult, valuesMap);\n         }\n-\n+        \n         return currentResult;\n     }\n ", "timestamp": 1092611923, "metainfo": ""}