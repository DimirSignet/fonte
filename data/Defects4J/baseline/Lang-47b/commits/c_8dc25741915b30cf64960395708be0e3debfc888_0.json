{"sha": "8dc25741915b30cf64960395708be0e3debfc888", "log": "Reformat (Eclipse) for line-length 120 and add missing @throws documentation.   ", "commit": "\n--- a/src/java/org/apache/commons/lang/builder/ReflectionToStringBuilder.java\n+++ b/src/java/org/apache/commons/lang/builder/ReflectionToStringBuilder.java\n import java.lang.reflect.Modifier;\n import java.util.HashSet;\n import java.util.Set;\n-\n import org.apache.commons.lang.ClassUtils;\n \n /**\n- * <p>Assists in implementing {@link Object#toString()} methods using reflection.</p>\n- *\n- * <p>This class uses reflection to determine the fields to append. \n- * Because these fields are usually private, the class \n- * uses <code>AccessibleObject.setAccessible</code> to\n- * change the visibility of the fields. This will fail under a security manager,\n- * unless the appropriate permissions are set up correctly.</p>\n- *\n- * <p>A typical invocation for this method would look like:</p>\n+ * <p>\n+ * Assists in implementing {@link Object#toString()}methods using reflection.\n+ * </p>\n+ * \n+ * <p>\n+ * This class uses reflection to determine the fields to append. Because these\n+ * fields are usually private, the class uses\n+ * {@link java.lang.reflect.AccessibleObject#setAccessible(java.lang.reflect.AccessibleObject[], boolean)}\n+ * to change the visibility of the fields. This will fail under a security\n+ * manager, unless the appropriate permissions are set up correctly.\n+ * </p>\n+ * \n+ * <p>\n+ * A typical invocation for this method would look like:\n+ * </p>\n+ * \n  * <pre>\n  * public String toString() {\n  *   return ReflectionToStringBuilder.toString(this);\n  * }</pre>\n- *\n- * <p>You can also use the builder to debug 3rd party objects:</p>\n+ * \n+ * \n+ * \n+ * <p>\n+ * You can also use the builder to debug 3rd party objects:\n+ * </p>\n+ * \n  * <pre>\n  * System.out.println(\"An object: \" + ReflectionToStringBuilder.toString(anObject));</pre>\n  * \n- * <p>A subclass can control field output by overriding the methods:\n- * <ul> \n- *  <li>{@link #accept(java.lang.reflect.Field)}</li>\n- *  <li>{@link #getValue(java.lang.reflect.Field)}</li>\n+ * \n+ * \n+ * <p>\n+ * A subclass can control field output by overriding the methods:\n+ * <ul>\n+ * <li>{@link #accept(java.lang.reflect.Field)}</li>\n+ * <li>{@link #getValue(java.lang.reflect.Field)}</li>\n  * </ul>\n  * </p>\n- * <p>For example, this method does <i>not</i> include the <code>password</code> field in the returned \n- * <code>String</code>:</p>\n+ * <p>\n+ * For example, this method does <i>not</i> include the <code>password</code>\n+ * field in the returned <code>String</code>:\n+ * </p>\n+ * \n  * <pre>\n  * public String toString() {\n  *     return (new ReflectionToStringBuilder(this) {\n  *     }).toString();\n  * }</pre>\n  * \n- * <p>The exact format of the <code>toString</code> is determined by\n- * the {@link ToStringStyle} passed into the constructor.</p>\n- *\n+ * \n+ * \n+ * <p>\n+ * The exact format of the <code>toString</code> is determined by the\n+ * {@link ToStringStyle}passed into the constructor.\n+ * </p>\n+ * \n  * @author Gary Gregory\n  * @author Stephen Colebourne\n  * @author Pete Gieser\n  * @since 2.0\n- * @version $Id: ReflectionToStringBuilder.java,v 1.15 2003/12/02 19:11:58 ggregory Exp $\n+ * @version $Id: ReflectionToStringBuilder.java,v 1.15 2003/12/02 19:11:58\n+ *               ggregory Exp $\n  */\n public class ReflectionToStringBuilder extends ToStringBuilder {\n-\n-    /**\n-     * <p>A registry of objects used by <code>reflectionToString</code> methods\n-     * to detect cyclical object references and avoid infinite loops.</p>\n+    /**\n+     * <p>\n+     * A registry of objects used by <code>reflectionToString</code> methods\n+     * to detect cyclical object references and avoid infinite loops.\n+     * </p>\n      */\n     private static ThreadLocal registry = new ThreadLocal() {\n         protected synchronized Object initialValue() {\n-                // The HashSet implementation is not synchronized, \n-        // which is just what we need here. \n-    return new HashSet();\n+            // The HashSet implementation is not synchronized,\n+            // which is just what we need here.\n+            return new HashSet();\n         }\n     };\n \n     /**\n-     * <p>Returns the registry of objects being traversed by the\n-     * <code>reflectionToString</code> methods in the current thread.</p>\n-     *\n-     * @return Set the registry of objects being traversed \n+     * <p>\n+     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n+     * methods in the current thread.\n+     * </p>\n+     * \n+     * @return Set the registry of objects being traversed\n      */\n     static Set getRegistry() {\n         return (Set) registry.get();\n     }\n \n     /**\n-     * <p>Returns <code>true</code> if the registry contains the given object.\n-     * Used by the reflection methods to avoid infinite loops.</p>\n-     * \n-     * @param value The object to lookup in the registry.\n-     * @return boolean <code>true</code> if the registry contains the given object.\n+     * <p>\n+     * Returns <code>true</code> if the registry contains the given object.\n+     * Used by the reflection methods to avoid infinite loops.\n+     * </p>\n+     * \n+     * @param value\n+     *                  The object to lookup in the registry.\n+     * @return boolean <code>true</code> if the registry contains the given\n+     *             object.\n      */\n     static boolean isRegistered(Object value) {\n         return getRegistry().contains(value);\n     }\n \n     /**\n-     * <p>Registers the given object.\n-     * Used by the reflection methods to avoid infinite loops.</p>\n-     * \n-     * @param value The object to register.\n+     * <p>\n+     * Registers the given object. Used by the reflection methods to avoid\n+     * infinite loops.\n+     * </p>\n+     * \n+     * @param value\n+     *                  The object to register.\n      */\n     static void register(Object value) {\n         getRegistry().add(value);\n     }\n \n     /**\n-     * <p>This method uses reflection to build a suitable\n-     * <code>toString</code> using the default <code>ToStringStyle</code>.\n-     *\n-     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n-     * fields. This means that it will throw a security exception if run\n-     * under a security manager, if the permissions are not set up correctly.\n-     * It is also not as efficient as testing explicitly.</p>\n-     *\n-     * <p>Transient members will be not be included, as they are likely derived.\n-     * Static fields will not be included. Superclass fields will be appended.</p>\n-     *\n-     * @param object  the Object to be output\n+     * <p>\n+     * This method uses reflection to build a suitable <code>toString</code>\n+     * using the default <code>ToStringStyle</code>.\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to\n+     * private fields. This means that it will throw a security exception if\n+     * run under a security manager, if the permissions are not set up\n+     * correctly. It is also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * Transient members will be not be included, as they are likely derived.\n+     * Static fields will not be included. Superclass fields will be appended.\n+     * </p>\n+     * \n+     * @param object\n+     *                  the Object to be output\n      * @return the String result\n-     * @throws IllegalArgumentException if the Object is <code>null</code>\n+     * @throws IllegalArgumentException\n+     *                  if the Object is <code>null</code>\n      */\n     public static String toString(Object object) {\n         return toString(object, null, false, false, null);\n     }\n \n     /**\n-     * <p>This method uses reflection to build a suitable\n-     * <code>toString</code>.</p>\n-     *\n-     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n-     * fields. This means that it will throw a security exception if run\n-     * under a security manager, if the permissions are not set up correctly.\n-     * It is also not as efficient as testing explicitly.</p>\n-     *\n-     * <p>Transient members will be not be included, as they are likely derived.\n-     * Static fields will not be included. Superclass fields will be appended.</p>\n-     *\n-     * <p>If the style is <code>null</code>, the default\n-     * <code>ToStringStyle</code> is used.</p>\n-     * \n-     * @param object  the Object to be output\n-     * @param style  the style of the <code>toString</code> to create,\n-     *  may be <code>null</code>\n+     * <p>\n+     * This method uses reflection to build a suitable <code>toString</code>.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to\n+     * private fields. This means that it will throw a security exception if\n+     * run under a security manager, if the permissions are not set up\n+     * correctly. It is also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * Transient members will be not be included, as they are likely derived.\n+     * Static fields will not be included. Superclass fields will be appended.\n+     * </p>\n+     * \n+     * <p>\n+     * If the style is <code>null</code>, the default <code>ToStringStyle</code>\n+     * is used.\n+     * </p>\n+     * \n+     * @param object\n+     *                  the Object to be output\n+     * @param style\n+     *                  the style of the <code>toString</code> to create, may be\n+     *                  <code>null</code>\n      * @return the String result\n-     * @throws IllegalArgumentException if the Object or\n-     *  <code>ToStringStyle</code> is <code>null</code>\n+     * @throws IllegalArgumentException\n+     *                  if the Object or <code>ToStringStyle</code> is <code>null</code>\n      */\n     public static String toString(Object object, ToStringStyle style) {\n         return toString(object, style, false, false, null);\n     }\n \n     /**\n-     * <p>This method uses reflection to build a suitable\n-     * <code>toString</code>.</p>\n-     *\n-     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n-     * fields. This means that it will throw a security exception if run\n-     * under a security manager, if the permissions are not set up correctly.\n-     * It is also not as efficient as testing explicitly. </p>\n-     *\n-     * <p>If the <code>outputTransients</code> is <code>true</code>,\n-     * transient members will be output, otherwise they are ignored,\n-     * as they are likely derived fields, and not part of the value of the\n-     * Object.</p>\n-     *\n-     * <p>Static fields will not be included. Superclass fields will be appended.</p>\n-     *\n-     * <p>If the style is <code>null</code>, the default\n-     * <code>ToStringStyle</code> is used.</p>\n-     * \n-     * @param object  the Object to be output\n-     * @param style  the style of the <code>toString</code> to create,\n-     *  may be <code>null</code>\n-     * @param outputTransients  whether to include transient fields\n+     * <p>\n+     * This method uses reflection to build a suitable <code>toString</code>.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to\n+     * private fields. This means that it will throw a security exception if\n+     * run under a security manager, if the permissions are not set up\n+     * correctly. It is also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * If the <code>outputTransients</code> is <code>true</code>,\n+     * transient members will be output, otherwise they are ignored, as they\n+     * are likely derived fields, and not part of the value of the Object.\n+     * </p>\n+     * \n+     * <p>\n+     * Static fields will not be included. Superclass fields will be appended.\n+     * </p>\n+     * \n+     * <p>\n+     * If the style is <code>null</code>, the default <code>ToStringStyle</code>\n+     * is used.\n+     * </p>\n+     * \n+     * @param object\n+     *                  the Object to be output\n+     * @param style\n+     *                  the style of the <code>toString</code> to create, may be\n+     *                  <code>null</code>\n+     * @param outputTransients\n+     *                  whether to include transient fields\n      * @return the String result\n-     * @throws IllegalArgumentException if the Object is <code>null</code>\n+     * @throws IllegalArgumentException\n+     *                  if the Object is <code>null</code>\n      */\n     public static String toString(Object object, ToStringStyle style, boolean outputTransients) {\n         return toString(object, style, outputTransients, false, null);\n     }\n \n     /**\n-     * <p>This method uses reflection to build a suitable\n-     * <code>toString</code>.</p>\n-     *\n-     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n-     * fields. This means that it will throw a security exception if run\n-     * under a security manager, if the permissions are not set up correctly.\n-     * It is also not as efficient as testing explicitly.</p>\n-     *\n-     * <p>If the <code>outputTransients</code> is <code>true</code>,\n-     * transient fields will be output, otherwise they are ignored,\n-     * as they are likely derived fields, and not part of the value of the\n-     * Object.</p>\n-     *\n-     * <p>If the <code>outputStatics</code> is <code>true</code>,\n-     * static fields will be output, otherwise they are ignored.</p>\n-     *\n-     * <p>Static fields will not be included. Superclass fields will be appended.</p>\n-     *\n-     * <p>If the style is <code>null</code>, the default\n-     * <code>ToStringStyle</code> is used.</p>\n-     * \n-     * @param object  the Object to be output\n-     * @param style  the style of the <code>toString</code> to create,\n-     *  may be <code>null</code>\n-     * @param outputTransients  whether to include transient fields\n-     * @param outputStatics  whether to include transient fields\n+     * <p>\n+     * This method uses reflection to build a suitable <code>toString</code>.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to\n+     * private fields. This means that it will throw a security exception if\n+     * run under a security manager, if the permissions are not set up\n+     * correctly. It is also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * If the <code>outputTransients</code> is <code>true</code>,\n+     * transient fields will be output, otherwise they are ignored, as they are\n+     * likely derived fields, and not part of the value of the Object.\n+     * </p>\n+     * \n+     * <p>\n+     * If the <code>outputStatics</code> is <code>true</code>, static\n+     * fields will be output, otherwise they are ignored.\n+     * </p>\n+     * \n+     * <p>\n+     * Static fields will not be included. Superclass fields will be appended.\n+     * </p>\n+     * \n+     * <p>\n+     * If the style is <code>null</code>, the default <code>ToStringStyle</code>\n+     * is used.\n+     * </p>\n+     * \n+     * @param object\n+     *                  the Object to be output\n+     * @param style\n+     *                  the style of the <code>toString</code> to create, may be\n+     *                  <code>null</code>\n+     * @param outputTransients\n+     *                  whether to include transient fields\n+     * @param outputStatics\n+     *                  whether to include transient fields\n      * @return the String result\n-     * @throws IllegalArgumentException if the Object is <code>null</code>\n+     * @throws IllegalArgumentException\n+     *                  if the Object is <code>null</code>\n      */\n     public static String toString(Object object, ToStringStyle style, boolean outputTransients, boolean outputStatics) {\n         return toString(object, style, outputTransients, outputStatics, null);\n     }\n \n     /**\n-     * <p>This method uses reflection to build a suitable\n-     * <code>toString</code>.</p>\n-     *\n-     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n-     * fields. This means that it will throw a security exception if run\n-     * under a security manager, if the permissions are not set up correctly.\n-     * It is also not as efficient as testing explicitly. </p>\n-     *\n-     * <p>If the <code>outputTransients</code> is <code>true</code>,\n-     * transient fields will be output, otherwise they are ignored,\n-     * as they are likely derived fields, and not part of the value of the\n-     * Object.</p>\n-     *\n-     * <p>If the <code>outputStatics</code> is <code>true</code>,\n-     * static fields will be output, otherwise they are ignored.</p>\n-     *\n-     * <p>Superclass fields will be appended up to and including the \n-     * specified superclass. A null superclass is treated as \n-     * <code>java.lang.Object</code>.</p>\n-     *\n-     * <p>If the style is <code>null</code>, the default\n-     * <code>ToStringStyle</code> is used.</p>\n-     * \n-     * @param object  the Object to be output\n-     * @param style  the style of the <code>toString</code> to create,\n-     *  may be <code>null</code>\n-     * @param outputTransients  whether to include transient fields\n-     * @param outputStatics  whether to include static fields\n-     * @param reflectUpToClass  the superclass to reflect up to (inclusive),\n-     *  may be <code>null</code>\n+     * <p>\n+     * This method uses reflection to build a suitable <code>toString</code>.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to\n+     * private fields. This means that it will throw a security exception if\n+     * run under a security manager, if the permissions are not set up\n+     * correctly. It is also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * If the <code>outputTransients</code> is <code>true</code>,\n+     * transient fields will be output, otherwise they are ignored, as they are\n+     * likely derived fields, and not part of the value of the Object.\n+     * </p>\n+     * \n+     * <p>\n+     * If the <code>outputStatics</code> is <code>true</code>, static\n+     * fields will be output, otherwise they are ignored.\n+     * </p>\n+     * \n+     * <p>\n+     * Superclass fields will be appended up to and including the specified\n+     * superclass. A null superclass is treated as <code>java.lang.Object</code>.\n+     * </p>\n+     * \n+     * <p>\n+     * If the style is <code>null</code>, the default <code>ToStringStyle</code>\n+     * is used.\n+     * </p>\n+     * \n+     * @param object\n+     *                  the Object to be output\n+     * @param style\n+     *                  the style of the <code>toString</code> to create, may be\n+     *                  <code>null</code>\n+     * @param outputTransients\n+     *                  whether to include transient fields\n+     * @param outputStatics\n+     *                  whether to include static fields\n+     * @param reflectUpToClass\n+     *                  the superclass to reflect up to (inclusive), may be <code>null</code>\n      * @return the String result\n-     * @throws IllegalArgumentException if the Object is <code>null</code>\n-     */\n-    public static String toString(Object object, ToStringStyle style, boolean outputTransients, boolean outputStatics, Class reflectUpToClass) {\n-        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics).toString();\n-    }\n-\n-    /**\n-     * <p>This method uses reflection to build a suitable\n-     * <code>toString</code>.</p>\n-     *\n-     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n-     * fields. This means that it will throw a security exception if run\n-     * under a security manager, if the permissions are not set up correctly.\n-     * It is also not as efficient as testing explicitly. </p>\n-     *\n-     * <p>If the <code>outputTransients</code> is <code>true</code>,\n-     * transient members will be output, otherwise they are ignored,\n-     * as they are likely derived fields, and not part of the value of the\n-     * Object.</p>\n-     *\n-     * <p>Static fields will not be included. Superclass fields will be appended\n-     * up to and including the specified superclass. A null superclass is treated\n-     * as <code>java.lang.Object</code>.</p>\n-     *\n-     * <p>If the style is <code>null</code>, the default\n-     * <code>ToStringStyle</code> is used.</p>\n-     *\n-     * @deprecated Use {@link #toString(Object,ToStringStyle,boolean,boolean,Class)}\n-     * \n-     * @param object  the Object to be output\n-     * @param style  the style of the <code>toString</code> to create,\n-     *  may be <code>null</code>\n-     * @param outputTransients  whether to include transient fields\n-     * @param reflectUpToClass  the superclass to reflect up to (inclusive),\n-     *  may be <code>null</code>\n+     * @throws IllegalArgumentException\n+     *                  if the Object is <code>null</code>\n+     */\n+    public static String toString(Object object, ToStringStyle style, boolean outputTransients, boolean outputStatics,\n+            Class reflectUpToClass) {\n+        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n+                .toString();\n+    }\n+\n+    /**\n+     * <p>\n+     * This method uses reflection to build a suitable <code>toString</code>.\n+     * </p>\n+     * \n+     * <p>\n+     * It uses <code>AccessibleObject.setAccessible</code> to gain access to\n+     * private fields. This means that it will throw a security exception if\n+     * run under a security manager, if the permissions are not set up\n+     * correctly. It is also not as efficient as testing explicitly.\n+     * </p>\n+     * \n+     * <p>\n+     * If the <code>outputTransients</code> is <code>true</code>,\n+     * transient members will be output, otherwise they are ignored, as they\n+     * are likely derived fields, and not part of the value of the Object.\n+     * </p>\n+     * \n+     * <p>\n+     * Static fields will not be included. Superclass fields will be appended\n+     * up to and including the specified superclass. A null superclass is\n+     * treated as <code>java.lang.Object</code>.\n+     * </p>\n+     * \n+     * <p>\n+     * If the style is <code>null</code>, the default <code>ToStringStyle</code>\n+     * is used.\n+     * </p>\n+     * \n+     * @deprecated Use\n+     *                     {@link #toString(Object,ToStringStyle,boolean,boolean,Class)}\n+     * \n+     * @param object\n+     *                  the Object to be output\n+     * @param style\n+     *                  the style of the <code>toString</code> to create, may be\n+     *                  <code>null</code>\n+     * @param outputTransients\n+     *                  whether to include transient fields\n+     * @param reflectUpToClass\n+     *                  the superclass to reflect up to (inclusive), may be <code>null</code>\n      * @return the String result\n-     * @throws IllegalArgumentException if the Object is <code>null</code>\n+     * @throws IllegalArgumentException\n+     *                  if the Object is <code>null</code>\n      */\n     public static String toString(Object object, ToStringStyle style, boolean outputTransients, Class reflectUpToClass) {\n         return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients).toString();\n     }\n \n     /**\n-     * <p>Unregisters the given object.</p>\n-     *\n-     * <p>Used by the reflection methods to avoid infinite loops.</p>\n-     * \n-     * @param value The object to unregister.\n+     * <p>\n+     * Unregisters the given object.\n+     * </p>\n+     * \n+     * <p>\n+     * Used by the reflection methods to avoid infinite loops.\n+     * </p>\n+     * \n+     * @param value\n+     *                  The object to unregister.\n      */\n     static void unregister(Object value) {\n         getRegistry().remove(value);\n     private Class upToClass = null;\n \n     /**\n-     * <p>Constructor.</p>\n-     *\n-     * <p>This constructor outputs using the default style set with\n-     * <code>setDefaultStyle</code>.</p>\n-     * \n-     * @param object  the Object to build a <code>toString</code> for,\n-     *  must not be <code>null</code>\n-     * @throws IllegalArgumentException  if the Object passed in is\n-     *  <code>null</code>\n+     * <p>\n+     * Constructor.\n+     * </p>\n+     * \n+     * <p>\n+     * This constructor outputs using the default style set with <code>setDefaultStyle</code>.\n+     * </p>\n+     * \n+     * @param object\n+     *                  the Object to build a <code>toString</code> for, must not\n+     *                  be <code>null</code>\n+     * @throws IllegalArgumentException\n+     *                  if the Object passed in is <code>null</code>\n      */\n     public ReflectionToStringBuilder(Object object) {\n         super(object);\n     }\n \n     /**\n-     * <p>Constructor.</p>\n-     *\n-     * <p>If the style is <code>null</code>, the default style is used.</p>\n-     * \n-     * @param object  the Object to build a <code>toString</code> for,\n-     *  must not be <code>null</code>\n-     * @param style  the style of the <code>toString</code> to create,\n-     *  may be <code>null</code>\n-     * @throws IllegalArgumentException  if the Object passed in is\n-     *  <code>null</code>\n+     * <p>\n+     * Constructor.\n+     * </p>\n+     * \n+     * <p>\n+     * If the style is <code>null</code>, the default style is used.\n+     * </p>\n+     * \n+     * @param object\n+     *                  the Object to build a <code>toString</code> for, must not\n+     *                  be <code>null</code>\n+     * @param style\n+     *                  the style of the <code>toString</code> to create, may be\n+     *                  <code>null</code>\n+     * @throws IllegalArgumentException\n+     *                  if the Object passed in is <code>null</code>\n      */\n     public ReflectionToStringBuilder(Object object, ToStringStyle style) {\n         super(object, style);\n     }\n \n     /**\n-     * <p>Constructor.</p>\n-     *\n-     * <p>If the style is <code>null</code>, the default style is used.</p>\n-     *\n-     * <p>If the buffer is <code>null</code>, a new one is created.</p>\n-     * \n-     * @param object  the Object to build a <code>toString</code> for,\n-     *  must not be <code>null</code>\n-     * @param style  the style of the <code>toString</code> to create,\n-     *  may be <code>null</code>\n-     * @param buffer  the <code>StringBuffer</code> to populate, may be\n-     *  <code>null</code>\n-     * @throws IllegalArgumentException  if the Object passed in is\n-     *  <code>null</code>\n+     * <p>\n+     * Constructor.\n+     * </p>\n+     * \n+     * <p>\n+     * If the style is <code>null</code>, the default style is used.\n+     * </p>\n+     * \n+     * <p>\n+     * If the buffer is <code>null</code>, a new one is created.\n+     * </p>\n+     * \n+     * @param object\n+     *                  the Object to build a <code>toString</code> for, must not\n+     *                  be <code>null</code>\n+     * @param style\n+     *                  the style of the <code>toString</code> to create, may be\n+     *                  <code>null</code>\n+     * @param buffer\n+     *                  the <code>StringBuffer</code> to populate, may be <code>null</code>\n+     * @throws IllegalArgumentException\n+     *                  if the Object passed in is <code>null</code>\n      */\n     public ReflectionToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\n         super(object, style, buffer);\n     /**\n      * Constructor.\n      * \n-     * @deprecated Use {@link #ReflectionToStringBuilder(Object,ToStringStyle,StringBuffer,Class,boolean,boolean)}.\n-     * \n-     * @param object  the Object to build a <code>toString</code> for,\n-     *  must not be <code>null</code>\n-     * @param style  the style of the <code>toString</code> to create,\n-     *  may be <code>null</code>\n-     * @param buffer  the <code>StringBuffer</code> to populate, may be\n-     *  <code>null</code>\n-     * @param reflectUpToClass  the superclass to reflect up to (inclusive),\n-     *  may be <code>null</code>\n-     * @param outputTransients  whether to include transient fields\n-     */\n-    public ReflectionToStringBuilder(\n-        Object object,\n-        ToStringStyle style,\n-        StringBuffer buffer,\n-        Class reflectUpToClass,\n-        boolean outputTransients) {\n+     * @deprecated Use\n+     *                     {@link #ReflectionToStringBuilder(Object,ToStringStyle,StringBuffer,Class,boolean,boolean)}.\n+     * \n+     * @param object\n+     *                  the Object to build a <code>toString</code> for, must not\n+     *                  be <code>null</code>\n+     * @param style\n+     *                  the style of the <code>toString</code> to create, may be\n+     *                  <code>null</code>\n+     * @param buffer\n+     *                  the <code>StringBuffer</code> to populate, may be <code>null</code>\n+     * @param reflectUpToClass\n+     *                  the superclass to reflect up to (inclusive), may be <code>null</code>\n+     * @param outputTransients\n+     *                  whether to include transient fields\n+     */\n+    public ReflectionToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer, Class reflectUpToClass,\n+            boolean outputTransients) {\n         super(object, style, buffer);\n         this.setUpToClass(reflectUpToClass);\n         this.setAppendTransients(outputTransients);\n     /**\n      * Constructor.\n      * \n-     * @param object  the Object to build a <code>toString</code> for,\n-     *  must not be <code>null</code>\n-     * @param style  the style of the <code>toString</code> to create,\n-     *  may be <code>null</code>\n-     * @param buffer  the <code>StringBuffer</code> to populate, may be\n-     *  <code>null</code>\n-     * @param reflectUpToClass  the superclass to reflect up to (inclusive),\n-     *  may be <code>null</code>\n-     * @param outputTransients  whether to include transient fields\n-     * @param outputStatics  whether to include static fields\n-     */\n-    public ReflectionToStringBuilder(\n-        Object object,\n-        ToStringStyle style,\n-        StringBuffer buffer,\n-        Class reflectUpToClass,\n-        boolean outputTransients,\n-        boolean outputStatics) {\n+     * @param object\n+     *                  the Object to build a <code>toString</code> for, must not\n+     *                  be <code>null</code>\n+     * @param style\n+     *                  the style of the <code>toString</code> to create, may be\n+     *                  <code>null</code>\n+     * @param buffer\n+     *                  the <code>StringBuffer</code> to populate, may be <code>null</code>\n+     * @param reflectUpToClass\n+     *                  the superclass to reflect up to (inclusive), may be <code>null</code>\n+     * @param outputTransients\n+     *                  whether to include transient fields\n+     * @param outputStatics\n+     *                  whether to include static fields\n+     */\n+    public ReflectionToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer, Class reflectUpToClass,\n+            boolean outputTransients, boolean outputStatics) {\n         super(object, style, buffer);\n         this.setUpToClass(reflectUpToClass);\n         this.setAppendTransients(outputTransients);\n     /**\n      * Returns whether or not to append the given <code>Field</code>.\n      * <ul>\n-     *  <li>Transient fields are appended only if {@link #isAppendTransients()} returns <code>true</code>.\n-     *  <li>Static fields are appended only if {@link #isAppendStatics()} returns <code>true</code>.\n-     *  <li>Inner class fields are not appened.</li>\n+     * <li>Transient fields are appended only if {@link #isAppendTransients()}\n+     * returns <code>true</code>.\n+     * <li>Static fields are appended only if {@link #isAppendStatics()}\n+     * returns <code>true</code>.\n+     * <li>Inner class fields are not appened.</li>\n      * </ul>\n-     * @param field The Field to test.\n+     * \n+     * @param field\n+     *                  The Field to test.\n      * @return Whether or not to append the given <code>Field</code>.\n      */\n     protected boolean accept(Field field) {\n     }\n \n     /**\n-     * <p>Appends the fields and values defined by the given object of the\n-     * given Class.</p>\n-     *\n-     * <p>If a cycle is detected as an object is &quot;toString()'ed&quot;,\n-     * such an object is rendered as if <code>Object.toString()</code> \n-     * had been called and not implemented by the object.</p>\n-     * \n-     * @param clazz The class of object parameter\n+     * <p>\n+     * Appends the fields and values defined by the given object of the given\n+     * Class.\n+     * </p>\n+     * \n+     * <p>\n+     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such\n+     * an object is rendered as if <code>Object.toString()</code> had been\n+     * called and not implemented by the object.\n+     * </p>\n+     * \n+     * @param clazz\n+     *                  The class of object parameter\n      */\n     protected void appendFieldsIn(Class clazz) {\n         if (isRegistered(this.getObject())) {\n-            // The object has already been appended, therefore we have an object cycle. \n-            // Append a simple Object.toString style string. The field name is already appended at this point.\n+            // The object has already been appended, therefore we have an\n+            // object cycle.\n+            // Append a simple Object.toString style string. The field name is\n+            // already appended at this point.\n             this.appendAsObjectToString(this.getObject());\n             return;\n         }\n                 String fieldName = field.getName();\n                 if (this.accept(field)) {\n                     try {\n-                        // Warning: Field.get(Object) creates wrappers objects for primitive types.\n+                        // Warning: Field.get(Object) creates wrappers objects\n+                        // for primitive types.\n                         Object fieldValue = this.getValue(field);\n                         if (isRegistered(fieldValue) && !field.getType().isPrimitive()) {\n-                            // A known field value has already been appended, therefore we have an object cycle, \n+                            // A known field value has already been appended,\n+                            // therefore we have an object cycle,\n                             // append a simple Object.toString style string.\n                             this.getStyle().appendFieldStart(this.getStringBuffer(), fieldName);\n                             this.appendAsObjectToString(fieldValue);\n-                            // The recursion out of \n-                            //    builder.append(fieldName, fieldValue); \n-                            // below will append the field \n+                            // The recursion out of\n+                            //    builder.append(fieldName, fieldValue);\n+                            // below will append the field\n                             // end marker.\n                         } else {\n                             try {\n                             }\n                         }\n                     } catch (IllegalAccessException ex) {\n-                        //this can't happen. Would get a Security exception instead\n-                        //throw a runtime exception in case the impossible happens.\n+                        //this can't happen. Would get a Security exception\n+                        // instead\n+                        //throw a runtime exception in case the impossible\n+                        // happens.\n                         throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n                     }\n                 }\n     }\n \n     /**\n-     * <p>Gets the last super class to stop appending fields for.</p>\n+     * <p>\n+     * Gets the last super class to stop appending fields for.\n+     * </p>\n      * \n      * @return The last super class to stop appending fields for.\n      */\n     }\n \n     /**\n-     * <p>Calls <code>java.lang.reflect.Field.get(Object)</code>.</p>\n-     *\n-     * @param field The Field to query.\n+     * <p>\n+     * Calls <code>java.lang.reflect.Field.get(Object)</code>.\n+     * </p>\n+     * \n+     * @param field\n+     *                  The Field to query.\n      * @return The Object from the given Field.\n      * \n      * @throws IllegalArgumentException\n+     *                  see {@link java.lang.reflect.Field#get(Object)}\n      * @throws IllegalAccessException\n+     *                  see {@link java.lang.reflect.Field#get(Object)}\n      * \n      * @see java.lang.reflect.Field#get(Object)\n      */\n     }\n \n     /**\n-     * <p>Gets whether or not to append static fields.</p>\n+     * <p>\n+     * Gets whether or not to append static fields.\n+     * </p>\n      * \n      * @return Whether or not to append static fields.\n      */\n     }\n \n     /**\n-     * <p>Gets whether or not to append transient fields.</p>\n+     * <p>\n+     * Gets whether or not to append transient fields.\n+     * </p>\n      * \n      * @return Whether or not to append transient fields.\n      */\n     }\n \n     /**\n-     * <p>Append to the <code>toString</code> an <code>Object</code>\n-     * array.</p>\n-     *\n-     * @param array  the array to add to the <code>toString</code>\n+     * <p>\n+     * Append to the <code>toString</code> an <code>Object</code> array.\n+     * </p>\n+     * \n+     * @param array\n+     *                  the array to add to the <code>toString</code>\n      * @return this\n      */\n     public ToStringBuilder reflectionAppendArray(Object array) {\n     }\n \n     /**\n-     * <p>Registers this builder's source object to avoid infinite\n-     * loops when processing circular object references.</p>\n+     * <p>\n+     * Registers this builder's source object to avoid infinite loops when\n+     * processing circular object references.\n+     * </p>\n      */\n     void registerObject() {\n         register(this.getObject());\n     }\n \n     /**\n-     * <p>Sets whether or not to append static fields.</p>\n-     * \n-     * @param appendStatics Whether or not to append static fields.\n+     * <p>\n+     * Sets whether or not to append static fields.\n+     * </p>\n+     * \n+     * @param appendStatics\n+     *                  Whether or not to append static fields.\n      */\n     public void setAppendStatics(boolean appendStatics) {\n         this.appendStatics = appendStatics;\n     }\n \n     /**\n-     * <p>Sets whether or not to append transient fields.</p>\n-     * \n-     * @param appendTransients Whether or not to append transient fields.\n+     * <p>\n+     * Sets whether or not to append transient fields.\n+     * </p>\n+     * \n+     * @param appendTransients\n+     *                  Whether or not to append transient fields.\n      */\n     public void setAppendTransients(boolean appendTransients) {\n         this.appendTransients = appendTransients;\n     }\n \n     /**\n-     * <p>Sets the last super class to stop appending fields for.</p>\n-     * \n-     * @param clazz The last super class to stop appending fields for.\n+     * <p>\n+     * Sets the last super class to stop appending fields for.\n+     * </p>\n+     * \n+     * @param clazz\n+     *                  The last super class to stop appending fields for.\n      */\n     public void setUpToClass(Class clazz) {\n         this.upToClass = clazz;\n     }\n \n     /**\n-     * <p>Gets the String built by this builder.</p>\n-     *\n+     * <p>\n+     * Gets the String built by this builder.\n+     * </p>\n+     * \n      * @return the built string\n      */\n     public String toString() {\n     }\n \n     /**\n-     * <p>Unregisters this builder's source object to avoid infinite\n-     * loops when processing circular object references.</p>\n+     * <p>\n+     * Unregisters this builder's source object to avoid infinite loops when\n+     * processing circular object references.\n+     * </p>\n      */\n     void unregisterObject() {\n         unregister(this.getObject());\n     }\n-\n }", "timestamp": 1072662422, "metainfo": ""}