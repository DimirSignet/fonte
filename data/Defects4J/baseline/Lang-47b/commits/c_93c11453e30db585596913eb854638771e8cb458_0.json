{"sha": "93c11453e30db585596913eb854638771e8cb458", "log": "Adding in new Interpolation class for opinions. It is, apart from cleaning up, creation of a unit test and renaming to 'interpolate', the submission from Ken Fitzpatrick in Bugzilla: #18962.  Lang has had a class much like this before so opinions saught (I'm in fact suffering from some major deja vu with this, need to research how many times I've committed this type of code to Lang :) ).  Submitted by:\tKen Fitzpatrick   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/Interpolation.java\n+package org.apache.commons.lang;\n+\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+/**\n+ * Performs basic variable interpolation on a String for variables within \n+ * a Map. Variables of the form, ${var}, are supported.\n+ *\n+ * @author Ken Fitzpatrick\n+ * @author Henri Yandell\n+ */\n+public class Interpolation {\n+\n+    // QUERY: Anyway to escape the ${..} variable so it is not interpolated?\n+\n+    // TODO: Consider making these configurable?\n+    private static final String SYMBOLIC_VALUE_MARKER_START = \"${\";\n+    private static final String SYMBOLIC_VALUE_MARKER_END = \"}\";\n+\n+    /**\n+     *  <p>\n+     *  Returns a String that is the result of having performed\n+     *  variable interpolation on <code>templateString</code>,\n+     *  using the value set found in <code>values</code>.\n+     *  </p>\n+     *  <p>\n+     *  The solution is compatible with all JDK versions\n+     *  where Jakarta/Commons/Lang also is supported.\n+     *  </p>\n+     *  <p>\n+     *  The expected format of <code>templateString</code> is:\n+     *<code><pre>\n+     *   The ${animal} jumped over the ${target}.\n+     *</pre></code>\n+     *  such that the key/value pairs found in <code>values</code>\n+     *  are substituted into the string at the <code>${key-name}</code> markers.\n+     *  In the above example, <code>valuesMap</code> could have been populated as:\n+     *<code><pre>\n+     *   Map valuesMap = HashMap();\n+     *   valuesMap.put( \"animal\", \"quick brown fox\" );\n+     *   valuesMap.put( \"target\", \"lazy dog\" );\n+     *   String resolvedString = StringUtils.interpolate( templateString, valuesMap );\n+     *</pre></code>\n+     *  yielding:\n+     *<code><pre>\n+     *   The quick brown fox jumped over the lazy dog.\n+     *</pre></code>\n+     *  </p>\n+     *  <p>\n+     *  The same <code>templateString</code> from the above example could be reused as:\n+     *<code><pre>\n+     *   Map valuesMap = HashMap();\n+     *   valuesMap.put( \"animal\", \"cow\" );\n+     *   valuesMap.put( \"target\", \"moon\" );\n+     *   String resolvedString = StringUtils.interpolate( templateString, valuesMap );\n+     *</pre></code>\n+     *  yielding:\n+     *<code><pre>\n+     *   The cow jumped over the moon.\n+     *</pre></code>\n+     *  </p>\n+     *  <p>\n+     *  The value of <code>templateString</code> is returned in an unaltered if <code>templateString</code>\n+     *  is null, empty, or contains no marked variables that can be resolved by the key/value pairs found in\n+     *  <code>valuesMap</code>, or if <code>valuesMap</code> is null, empty or has no key/value pairs that can be\n+     *  applied to the marked variables within <code>templateString</code>.\n+     *  </p>\n+     * @param templateString String containing any mixture of variable and non-variable\n+     *      content, to be used as a template for the value substitution process\n+     * @param valuesMap Map containing the key/value pairs to be used to resolve\n+     *      the values of the marked variables found within <code>templateString</code>\n+     * @return String\n+     */\n+    public static String interpolate( String templateString, Map valuesMap ) {\n+        // pre-conditions\n+        if ( valuesMap == null )\n+            return templateString;\n+        if ( templateString == null )\n+            return templateString;\n+        if ( templateString.length() < 1 )\n+            return templateString;\n+        if ( valuesMap.isEmpty() )\n+            return templateString;\n+\n+        // default the returned String to the templateString\n+        String returnString = templateString;\n+        String nextKey = null;\n+        Object substitutionBean = null;\n+        String substitutionValue = null;\n+        String nextValueToBeSubstituted = null;\n+\n+        // get a list of substitution valuesMap\n+        Iterator keys = valuesMap.keySet().iterator();\n+\n+        while( keys.hasNext() ) {\n+            nextKey = ( String ) keys.next();\n+            substitutionValue = StringUtils.defaultString( ( String ) valuesMap.get( nextKey ) );\n+            nextValueToBeSubstituted = SYMBOLIC_VALUE_MARKER_START + nextKey + SYMBOLIC_VALUE_MARKER_END;\n+\n+            returnString = StringUtils.replace( returnString, nextValueToBeSubstituted, substitutionValue );\n+        }\n+        return returnString;\n+    }\n+\n+\n+    /**\n+     *  <p>\n+     *  Returns a String that is the result of having performed variable interpolation on\n+     *  <code>templateString</code>, using the value set found in <code>values</code>,\n+     *  repeatedly until there are no changes. \n+     *  </p>\n+     *  <p>\n+     *  The expected format of <code>templateString</code> is:\n+     *<code><pre>\n+     *   The ${animal} jumped over the ${target}.\n+     *</pre></code>\n+     *  such that the key/value pairs found in <code>values</code> are substituted into the string at the\n+     *  <code>${key-name}</code> markers.  In the above example, <code>valuesMap</code>\n+     *  could have been populated as:\n+     *<code><pre>\n+     *   Map valuesMap = HashMap();\n+     *   valuesMap.put( \"animal\", \"${critter}\" );\n+     *   valuesMap.put( \"target\", \"${pet}\" );\n+     *   valuesMap.put( \"pet\", \"${petCharacteristic} dog\" );\n+     *   valuesMap.put( \"petCharacteristic\", \"lazy\" );\n+     *   valuesMap.put( \"critter\", \"${critterSpeed} ${critterColor} ${critterType}\" );\n+     *   valuesMap.put( \"critterSpeed\", \"quick\" );\n+     *   valuesMap.put( \"critterColor\", \"brown\" );\n+     *   valuesMap.put( \"critterType\", \"fox\" );\n+     *   String resolvedString = StringUtils.interpolate( templateString, valuesMap, true );\n+     *</pre></code>\n+     *  yielding:\n+     *<code><pre>\n+     *   The quick brown fox jumped over the lazy dog.\n+     *</pre></code>\n+     *  </p>\n+     *  yielding:\n+     *<code><pre>\n+     *   The cow jumped over the moon.\n+     *</pre></code>\n+     *  </p>\n+     *  <p>\n+     *  The value of <code>templateString</code> is returned in an unaltered form if\n+     *  <code>templateString</code> is null, empty, or\n+     *  contains no marked variables that can be resolved by the key/value pairs found in\n+     *  <code>valuesMap</code>, or if <code>valuesMap</code> is null, empty or has no key/value \n+     *  pairs that can be applied to the marked variables within <code>templateString</code>.\n+     *  </p>\n+     * @param templateString String containing any mixture of variable and non-variable\n+     *      content, to be used as a template for the value substitution process\n+     * @param valuesMap Map containing the key/value pairs to be used to resolve\n+     *      the values of the marked variables found within <code>templateString</code>\n+     * @return String\n+     */\n+    public static String interpolateRepeatedly(\n+            String templateString,\n+            Map valuesMap)\n+    {\n+        // pre-conditions\n+        if ( valuesMap == null )\n+            return templateString;\n+        if ( templateString == null )\n+            return templateString;\n+        if ( templateString.length() < 1 )\n+            return templateString;\n+        if ( valuesMap.isEmpty() )\n+            return templateString;\n+\n+        String currentResult = templateString;\n+        String previousResult = null;\n+        while( ! StringUtils.equals( currentResult, previousResult ) )\n+        {\n+            previousResult = currentResult;\n+            currentResult = Interpolation.interpolate( previousResult, valuesMap );\n+        }\n+\n+        return currentResult;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/InterpolationTest.java\n+/*\n+ * Copyright 2002-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+import java.util.Map;\n+import java.util.HashMap;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.Interpolation}.\n+ *\n+ * @author Henri Yandell\n+ * @author Ken Fitzpatrick\n+ * @version $Id: InterpolationTest.java,v 1.1 2004/07/04 04:51:25 bayard Exp $\n+ */\n+public class InterpolationTest extends TestCase {\n+\n+    private static final String INPUT_TEMPLATE     = \"The ${animal} jumped over the ${target}.\";\n+    private static final String EXPECTED_RESULTS_1 = \"The quick brown fox jumped over the lazy dog.\";\n+    private static final String EXPECTED_RESULTS_2 = \"The cow jumped over the moon.\";\n+\n+    public InterpolationTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+    \tTestSuite suite = new TestSuite(InterpolationTest.class);\n+    \tsuite.setName(\"Interpolation Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    public void testSimpleVariableSubstitution() {\n+\n+        // test case: \"The quick brown fox jumped over the lazy dog.\"\n+        Map valuesMap = new HashMap();\n+        valuesMap.put( \"animal\", \"quick brown fox\" );\n+        valuesMap.put( \"target\", \"lazy dog\" );\n+        assertEquals( \"Test case 1: simple variable substitution\", EXPECTED_RESULTS_1,\n+            Interpolation.interpolate( INPUT_TEMPLATE, valuesMap) );\n+\n+        // test case: \"The cow jumped over the moon.\"\n+        valuesMap = new HashMap();\n+        valuesMap.put( \"animal\", \"cow\" );\n+        valuesMap.put( \"target\", \"moon\" );\n+        assertEquals( \"Test case 2: template reuse, different results\" ,EXPECTED_RESULTS_2,\n+            Interpolation.interpolate( INPUT_TEMPLATE, valuesMap) );\n+    }\n+\n+    public void testNullMap() {\n+        // negative test case: Map == null\n+        Map valuesMap = null;\n+        assertEquals( \"Test case 3: Map == null\", INPUT_TEMPLATE,\n+            Interpolation.interpolate( INPUT_TEMPLATE, valuesMap) );\n+    }\n+\n+    public void testEmptyMap() {\n+        // negative test case: Map.isEmpty()\n+        Map valuesMap = new HashMap();\n+        assertEquals( \"Test case 4: Map.isEmpty()\", INPUT_TEMPLATE,\n+            Interpolation.interpolate( INPUT_TEMPLATE, valuesMap) );\n+    }\n+\n+    public void testNullTemplate() {\n+        // negative test case: INPUT_TEMPLATE == null\n+        Map valuesMap = new HashMap();\n+        valuesMap.put( \"animal\", \"cow\" );\n+        valuesMap.put( \"target\", \"moon\" );\n+        assertNull( \"Test case 5: template == null\",\n+            Interpolation.interpolate( null, valuesMap) );\n+    }\n+\n+    public void testRecursive() {\n+        // test case: process repeatedly\n+        Map valuesMap = new HashMap();\n+        valuesMap.put( \"animal\", \"${critter}\" );\n+        valuesMap.put( \"target\", \"${pet}\" );\n+        valuesMap.put( \"pet\", \"${petCharacteristic} dog\" );\n+        valuesMap.put( \"petCharacteristic\", \"lazy\" );\n+        valuesMap.put( \"critter\", \"${critterSpeed} ${critterColor} ${critterType}\" );\n+        valuesMap.put( \"critterSpeed\", \"quick\" );\n+        valuesMap.put( \"critterColor\", \"brown\" );\n+        valuesMap.put( \"critterType\", \"fox\" );\n+        assertEquals( \"Test case 6: interpolateRepeatedly\", EXPECTED_RESULTS_1,\n+            Interpolation.interpolateRepeatedly( INPUT_TEMPLATE, valuesMap ) );\n+\n+        // test case: process repeatedly\n+        valuesMap = new HashMap();\n+        valuesMap.put( \"animal\", \"cow\" );\n+        valuesMap.put( \"target\", \"${celestialObject}\" );\n+        valuesMap.put( \"celestialObject\", \"moon\" );\n+        assertEquals( \"Test case 8: interpolateRepeatedly\", EXPECTED_RESULTS_2,\n+            Interpolation.interpolateRepeatedly( INPUT_TEMPLATE, valuesMap ) );\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/lang/LangTestSuite.java\n+++ b/src/test/org/apache/commons/lang/LangTestSuite.java\n  * @author Stephen Colebourne\n  * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n  * @author Matthew Hawthorne\n- * @version $Id: LangTestSuite.java,v 1.26 2004/02/18 23:06:19 ggregory Exp $\n+ * @version $Id: LangTestSuite.java,v 1.27 2004/07/04 04:51:25 bayard Exp $\n  */\n public class LangTestSuite extends TestCase {\n     \n         suite.addTest(EntitiesTest.suite());\n         suite.addTest(IllegalClassExceptionTest.suite());\n         suite.addTest(IncompleteArgumentExceptionTest.suite());\n+        suite.addTest(InterpolationTest.suite());\n         suite.addTest(NotImplementedExceptionTest.suite());\n         suite.addTest(NullArgumentExceptionTest.suite());\n         suite.addTest(NumberRangeTest.suite());", "timestamp": 1088916685, "metainfo": ""}