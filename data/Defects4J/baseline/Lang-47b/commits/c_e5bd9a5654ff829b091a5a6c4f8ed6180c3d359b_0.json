{"sha": "e5bd9a5654ff829b091a5a6c4f8ed6180c3d359b", "log": "Add initial version of StrBuilder, currently without any tests   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/text/StrBuilder.java\n+/*\n+ * Copyright 2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+/**\n+ * Builds a string from consituant parts providing a more flexible and powerful API\n+ * than StringBuffer.\n+ * <p>\n+ * The main differences from StringBuffer/StringBuilder are:\n+ * <ul>\n+ * <li>Not synchronized</li>\n+ * <li>Not final</li>\n+ * <li>Subclasses have direct access to character array</li>\n+ * <li>Additional methods\n+ *  <ul>\n+ *   <li>appendWithSeparators - adds an array of values, with a separator</li>\n+ *   <li>appendPadding - adds a length padding characters</li>\n+ *   <li>appendFixedLength - adds a fixed width field to the builder</li>\n+ *   <li>toCharArray/getChars - simpler ways to get a range of the character array</li>\n+ *   <li>delete - delete char or string</li>\n+ *   <li>replace - search and replace for a char or string</li>\n+ *   <li>leftString/rightString/midString - substring without exceptions</li>\n+ *   <li>contains - whether the builder contains a char or string</li>\n+ *   <li>size/clear/isEmpty - collections style API methods</li>\n+ *  </ul>\n+ * </li>\n+ * </ul>\n+ * <p>\n+ * The aim has been to provide an API that mimics very closely what StringBuffer\n+ * provides, but with additional methods. It should be noted that some edge cases,\n+ * with invalid indices or null input, have been altered - see individual methods.\n+ * The biggest of these changes is that by default, null will not output the text\n+ * 'null'. This can be controlled by a property, {@link #setNullText(String)}.\n+ *\n+ * @author Stephen Colebourne\n+ * @since 2.1\n+ * @version $Id: StrBuilder.java,v 1.1 2004/10/16 15:09:52 scolebourne Exp $\n+ */\n+public class StrBuilder implements Cloneable {\n+\n+    /** Serialization lock. */\n+    private static final long serialVersionUID = 7628716375283629643L;\n+\n+    /** Internal data storage. */\n+    protected char[] buf;\n+    /** Current size of the buffer. */\n+    protected int size;\n+    /** The null text. */\n+    private String nullText;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that creates an empty builder initial capacity 32 characters.\n+     */\n+    public StrBuilder() {\n+        this(32);\n+    }\n+\n+    /**\n+     * Constructor that creates an empty builder the specified initial capacity.\n+     *\n+     * @param initialCapacity  the initial capacity, zero or less will be converted to 32\n+     */\n+    public StrBuilder(int initialCapacity) {\n+        super();\n+        if (initialCapacity <= 0) {\n+            initialCapacity = 32;\n+        }\n+        buf = new char[initialCapacity];\n+    }\n+\n+    /**\n+     * Constructor that creates a builder from the string, allocating\n+     * 32 extra characters for growth.\n+     *\n+     * @param str  the string to copy, null treated as blank string\n+     */\n+    public StrBuilder(String str) {\n+        super();\n+        if (str == null) {\n+            buf = new char[32];\n+        } else {\n+            buf = new char[str.length() + 32];\n+            append(str);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the text to be appended when null is added.\n+     *\n+     * @return the null text, null means no append\n+     */\n+    public String getNullText() {\n+        return nullText;\n+    }\n+\n+    /**\n+     * Sets the text to be appended when null is added.\n+     *\n+     * @param str  the null text, null means no append\n+     */\n+    public void setNullText(String str) {\n+        if (str != null && str.length() == 0) {\n+            str = null;\n+        }\n+        nullText = str;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the length of the string builder.\n+     *\n+     * @return the length\n+     */\n+    public int length() {\n+        return size;\n+    }\n+\n+    /**\n+     * Updates the length of the builder by either dropping the last characters\n+     * or adding filler of unicode zero.\n+     *\n+     * @param length  the length to set to, must be zero or positive\n+     * @throws IndexOutOfBoundsException if the length is negative\n+     */\n+    public void setLength(int length) {\n+        if (length < 0) {\n+            throw new StringIndexOutOfBoundsException(length);\n+        }\n+        if (length == size) {\n+            // ok\n+        } else if (length < size) {\n+            size = length;\n+        } else {\n+            ensureCapacity(length);\n+            int oldEnd = size;\n+            int newEnd = length;\n+            size = length;\n+            for (int i = oldEnd; i < newEnd; i++) {\n+                buf[i] = '\\0';\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the current size of the internal character array buffer.\n+     *\n+     * @return the capacity\n+     */\n+    public int capacity() {\n+        return buf.length;\n+    }\n+\n+    /**\n+     * Checks the capacity and ensures that it is at least the size specified.\n+     *\n+     * @param capacity  the capacity to ensure\n+     */\n+    public void ensureCapacity(int capacity) {\n+        if (capacity > buf.length) {\n+            char[] old = buf;\n+            buf = new char[capacity];\n+            System.arraycopy(old, 0, buf, 0, size);\n+        }\n+    }\n+\n+    /**\n+     * Minimizes the capacity to the actual length of the string.\n+     */\n+    public void minimizeCapacity() {\n+        if (buf.length > length()) {\n+            char[] old = buf;\n+            buf = new char[length()];\n+            System.arraycopy(old, 0, buf, 0, size);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the length of the string builder.\n+     * <p>\n+     * This method is the same as {@link #length()} and is provided to match the\n+     * API of Collections.\n+     *\n+     * @return the length\n+     */\n+    public int size() {\n+        return size;\n+    }\n+\n+    /**\n+     * Clears the string builder (convenience Collections API style method).\n+     * <p>\n+     * This method is the same as {@link #setLength(0)} and is provided to match the\n+     * API of Collections.\n+     */\n+    public void clear() {\n+        size = 0;\n+    }\n+\n+    /**\n+     * Checks is the string builder is empty (convenience Collections API style method).\n+     * <p>\n+     * This method is the same as checking {@link #length()} and is provided to match the\n+     * API of Collections.\n+     */\n+    public boolean isEmpty() {\n+        return (size == 0);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the character at the specified index.\n+     *\n+     * @param index  the index to retrieve, must be valid\n+     * @return the character at the index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public char charAt(int index) {\n+        if (index < 0 || index >= length()) {\n+            throw new StringIndexOutOfBoundsException(index);\n+        }\n+        return buf[index];\n+    }\n+\n+    /**\n+     * Sets the character at the specified index.\n+     *\n+     * @param index  the index to set\n+     * @param ch  the new character\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public void setCharAt(int index, char ch) {\n+        if (index < 0 || index >= length()) {\n+            throw new StringIndexOutOfBoundsException(index);\n+        }\n+        buf[index] = ch;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Copies the builder's character array into a new character array.\n+     * \n+     * @return a new array that represents the contents of the builder\n+     */\n+    public char[] toCharArray() {\n+        char chars[] = new char[size];\n+        System.arraycopy(buf, 0, chars, 0, size);\n+        return chars;\n+    }\n+\n+    /**\n+     * Copies part of the builder's character array into a new character array.\n+     * \n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param endIndex  the end index, exclusive, must be valid except\n+     *  that if too large it is treated as end of string\n+     * @return a new array that holds part of the contents of the builder\n+     */\n+    public char[] toCharArray(int startIndex, int endIndex) {\n+        endIndex = validateRange(startIndex, endIndex);\n+        char chars[] = new char[size];\n+        System.arraycopy(buf, startIndex, chars, 0, endIndex - startIndex);\n+        return chars;\n+    }\n+\n+    /**\n+     * Copies the character array into the specified array.\n+     * \n+     * @param destination  the destination array, null will cause an array to be created\n+     * @return the input array, unless that was null or too small\n+     */\n+    public char[] getChars(char[] destination) {\n+        int len = length();\n+        if (destination == null || destination.length < len) {\n+            destination = new char[len];\n+        }\n+        System.arraycopy(buf, 0, destination, 0, len);\n+        return destination;\n+    }\n+\n+    /**\n+     * Copies the character array into the specified array.\n+     *\n+     * @param startIndex  first index to copy, inclusive, must be valid\n+     * @param endIndex  last index, exclusive, must be valid\n+     * @param destination  the destination array, must not be null or too small\n+     * @param destinationIndex  the index to start copying in destination\n+     * @throws NullPointerException if the array is null\n+     * @throws IndexOutOfBoundsException if any index is invalid\n+     */\n+    public void getChars(int startIndex, int endIndex, char destination[], int destinationIndex) {\n+        if (startIndex < 0) {\n+            throw new StringIndexOutOfBoundsException(startIndex);\n+        }\n+        if (endIndex < 0 || endIndex > length()) {\n+            throw new StringIndexOutOfBoundsException(endIndex);\n+        }\n+        if (startIndex > endIndex) {\n+            throw new StringIndexOutOfBoundsException(\"end < start\");\n+        }\n+        System.arraycopy(buf, startIndex, destination, destinationIndex, endIndex - startIndex);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Appends the text representing <code>null</code> to the string builder.\n+     *\n+     * @param obj  the object to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder appendNull() {\n+        if (nullText == null)  {\n+            return this;\n+        }\n+        return append(nullText);\n+    }\n+\n+    /**\n+     * Appends an object to the string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param obj  the object to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(Object obj) {\n+        if (obj == null) {\n+            return appendNull();\n+        } else {\n+            return append(obj.toString());\n+        }\n+    }\n+\n+    /**\n+     * Appends a string to the string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param str  the string to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(String str) {\n+        if (str == null) {\n+            return appendNull();\n+        }\n+        int strLen = str.length();\n+        if (strLen > 0) {\n+            int len = length();\n+            ensureCapacity(len + strLen);\n+            str.getChars(0, strLen, buf, len);\n+            size += strLen;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends a string buffer to the string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param str  the string buffer to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(StringBuffer str) {\n+        if (str == null) {\n+            return appendNull();\n+        }\n+        int strLen = str.length();\n+        if (strLen > 0) {\n+            int len = length();\n+            ensureCapacity(len + strLen);\n+            str.getChars(0, strLen, buf, len);\n+            size += strLen;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends another string builder to the string builder.\n+     * Appending null will call {@link #appendNull()}.\n+     *\n+     * @param str  the string builder to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(StrBuilder str) {\n+        if (str == null) {\n+            return appendNull();\n+        }\n+        int strLen = str.length();\n+        if (strLen > 0) {\n+            int len = length();\n+            ensureCapacity(len + strLen);\n+            System.arraycopy(str.buf, 0, buf, len, strLen);\n+            size += strLen;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends a char array to the string builder.\n+     * Appending null has no effect.\n+     * <p>\n+     * Note: This method treats a null char array as an empty char array,\n+     * unlike StringBuffer or String.\n+     *\n+     * @param chars  the char array to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(char[] chars) {\n+        if (chars == null) {\n+            return this;\n+        }\n+        int strLen = chars.length;\n+        if (strLen > 0) {\n+            int len = length();\n+            ensureCapacity(len + strLen);\n+            System.arraycopy(chars, 0, buf, len, strLen);\n+            size += strLen;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends a char array to the string builder.\n+     * Appending null has no effect.\n+     * <p>\n+     * Note: This method treats a null char array as an empty char array,\n+     * unlike StringBuffer or String.\n+     *\n+     * @param chars  the char array to append\n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param length  the length to append, must be valid\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(char[] chars, int startIndex, int length) {\n+        if (chars == null) {\n+            return this;\n+        }\n+        if (length < 0) {\n+            throw new StringIndexOutOfBoundsException(\"length must not be negative\");\n+        }\n+        if (length > 0) {\n+            int len = length();\n+            ensureCapacity(len + length);\n+            System.arraycopy(chars, startIndex, buf, len, length);\n+            size += length;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends a boolean value to the string builder.\n+     *\n+     * @param value  the value to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(boolean value) {\n+        if (value) {\n+            ensureCapacity(size + 4);\n+            buf[size++] = 't';\n+            buf[size++] = 'r';\n+            buf[size++] = 'u';\n+            buf[size++] = 'e';\n+        } else {\n+            ensureCapacity(size + 5);\n+            buf[size++] = 'f';\n+            buf[size++] = 'a';\n+            buf[size++] = 'l';\n+            buf[size++] = 's';\n+            buf[size++] = 'e';\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends a char value to the string builder.\n+     *\n+     * @param value  the value to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(char ch) {\n+        int len = length();\n+        ensureCapacity(len + 1);\n+        buf[size++] = ch;\n+        return this;\n+    }\n+\n+    /**\n+     * Appends an int value to the string builder using <code>String.valueOf</code>.\n+     *\n+     * @param value  the value to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(int value) {\n+        return append(String.valueOf(value));\n+    }\n+\n+    /**\n+     * Appends a long value to the string builder using <code>String.valueOf</code>.\n+     *\n+     * @param value  the value to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(long value) {\n+        return append(String.valueOf(value));\n+    }\n+\n+    /**\n+     * Appends a float value to the string builder using <code>String.valueOf</code>.\n+     *\n+     * @param value  the value to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(float value) {\n+        return append(String.valueOf(value));\n+    }\n+\n+    /**\n+     * Appends a double value to the string builder using <code>String.valueOf</code>.\n+     *\n+     * @param value  the value to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder append(double value) {\n+        return append(String.valueOf(value));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Appends an array placing separators between each pair of values, but\n+     * not after the last.\n+     * Appending a null array will have no effect.\n+     * Each object is appended using {@link #append(Object)}.\n+     *\n+     * @param array  the array to append\n+     * @param separator  the separator to use, null means no separator\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder appendWithSeparators(Object[] array, String separator) {\n+        if (array != null && array.length > 0) {\n+            separator = (separator == null ? \"\" : separator);\n+            append(array[0]);\n+            for (int i = 1; i < array.length; i++) {\n+                append(separator);\n+                append(array[i]);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends a collection placing separators between each pair of values, but\n+     * not after the last.\n+     * Appending a null collection will have no effect.\n+     * Each object is appended using {@link #append(Object)}.\n+     *\n+     * @param coll  the collection to append\n+     * @param separator  the separator to use, null means no separator\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder appendWithSeparators(Collection coll, String separator) {\n+        if (coll != null && coll.size() > 0) {\n+            separator = (separator == null ? \"\" : separator);\n+            Iterator it = coll.iterator();\n+            append(it.next());\n+            while (it.hasNext()) {\n+                append(separator);\n+                append(it.next());\n+            }\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Appends the pad character to the builder the specified number of times.\n+     * \n+     * @param length  the length to append, negative means no append\n+     * @param padChar  the character to append\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder appendPadding(int length, char padChar) {\n+        if (length >= 0) {\n+            ensureCapacity(size + length);\n+            for (int i = 0; i < length; i++) {\n+                buf[size++] = padChar;\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends an object to the builder padding on the left to a fixed length.\n+     * If the object is larger than the length, the left hand side is lost.\n+     * If the object is null, the null text value is used.\n+     * \n+     * @param obj  the object to append\n+     * @param length  the fixed field width\n+     * @param padChar  the pad character to use\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder appendFixedLengthPadLeft(Object obj, int length, char padChar) {\n+        if (length > 0) {\n+            ensureCapacity(size + length);\n+            String str = (obj == null ? getNullText() : obj.toString());\n+            int strLen = str.length();\n+            if (strLen >= length) {\n+                str.getChars(strLen - length, strLen, buf, size);\n+            } else {\n+                int padLen = length - strLen;\n+                for (int i = 0; i < padLen; i++) {\n+                    buf[size + i] = padChar;\n+                }\n+                str.getChars(0, strLen, buf, size + padLen);\n+            }\n+            size += length;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Appends an object to the builder padding on the right to a fixed length.\n+     * If the object is larger than the length, the right hand side is lost.\n+     * If the object is null, null text value is used.\n+     * \n+     * @param obj  the object to append\n+     * @param length  the fixed field width\n+     * @param padChar  the pad character to use\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder appendFixedLengthPadRight(Object obj, int length, char padChar) {\n+        if (length > 0) {\n+            ensureCapacity(size + length);\n+            String str = (obj == null ? getNullText() : obj.toString());\n+            int strLen = str.length();\n+            if (strLen >= length) {\n+                str.getChars(strLen - length, strLen, buf, size);\n+            } else {\n+                int padLen = length - strLen;\n+                str.getChars(0, strLen, buf, size);\n+                for (int i = 0; i < padLen; i++) {\n+                    buf[size + strLen + i] = padChar;\n+                }\n+            }\n+            size += length;\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inserts the string representation of an object into this builder.\n+     * Inserting null will use the stored null text value.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param obj  the object to insert\n+     * @return this, to enable chaining\n+     * @throws StringIndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder insert(int index, Object obj) {\n+        if (obj == null) {\n+            return insert(index, nullText);\n+        } else {\n+            return insert(index, obj.toString());\n+        }\n+    }\n+\n+    /**\n+     * Inserts the string into this builder.\n+     * Inserting null will use the stored null text value.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param str  the string to insert\n+     * @return this, to enable chaining\n+     * @throws StringIndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder insert(int index, String str) {\n+        validateIndex(index);\n+        if (str == null) {\n+            str = nullText;\n+        }\n+        int strLen = (str == null ? 0 : str.length());\n+        if (strLen > 0) {\n+            int newSize = size + strLen;\n+            ensureCapacity(newSize);\n+            System.arraycopy(buf, index, buf, index + strLen, size - index);\n+            size = newSize;\n+            str.getChars(0, strLen, buf, index);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Inserts the character array into this builder.\n+     * Inserting null has no effect.\n+     * <p>\n+     * Note: This method treats a null char array as an empty char array,\n+     * unlike StringBuffer or String.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param chars  the char array to insert\n+     * @return this, to enable chaining\n+     * @throws StringIndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder insert(int index, char chars[]) {\n+        validateIndex(index);\n+        if (chars == null) {\n+            return this;\n+        }\n+        int len = chars.length;\n+        if (len > 0) {\n+            ensureCapacity(size + len);\n+            System.arraycopy(buf, index, buf, index + len, size - index);\n+            System.arraycopy(chars, 0, buf, index, len);\n+            size += len;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Inserts part of the character array into this builder.\n+     * Inserting null has no effect.\n+     * <p>\n+     * Note: This method treats a null char array as an empty char array,\n+     * unlike StringBuffer or String.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param chars  the char array to insert\n+     * @param offset  the offset into the character array to start at, must be valid\n+     * @param length  the length of the character array part to copy, must be positive\n+     * @return this, to enable chaining\n+     * @throws StringIndexOutOfBoundsException if any index is invalid\n+     */\n+    public StrBuilder insert(int index, char chars[], int offset, int length) {\n+        validateIndex(index);\n+        if (chars == null) {\n+            return this;\n+        }\n+        if (offset < 0 || offset > chars.length) {\n+            throw new StringIndexOutOfBoundsException(\"Invalid offset: \" + offset);\n+        }\n+        if (length < 0 || offset + length > chars.length) {\n+            throw new StringIndexOutOfBoundsException(\"Invalid length: \" + length);\n+        }\n+        if (length > 0) {\n+            ensureCapacity(size + length);\n+            System.arraycopy(buf, index, buf, index + length, size - index);\n+            System.arraycopy(chars, offset, buf, index, length);\n+            size += length;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Inserts the value into this builder.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param value  the value to insert\n+     * @return this, to enable chaining\n+     * @throws StringIndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder insert(int index, boolean value) {\n+        validateIndex(index);\n+        if (value) {\n+            ensureCapacity(size + 4);\n+            System.arraycopy(buf, index, buf, index + 4, size - index);\n+            buf[index++] = 't';\n+            buf[index++] = 'r';\n+            buf[index++] = 'u';\n+            buf[index] = 'e';\n+            size += 4;\n+        } else {\n+            ensureCapacity(size + 5);\n+            System.arraycopy(buf, index, buf, index + 5, size - index);\n+            buf[index++] = 'f';\n+            buf[index++] = 'a';\n+            buf[index++] = 'l';\n+            buf[index++] = 's';\n+            buf[index] = 'e';\n+            size += 5;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Inserts the value into this builder.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param value  the value to insert\n+     * @return this, to enable chaining\n+     * @throws StringIndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder insert(int index, char value) {\n+        validateIndex(index);\n+        ensureCapacity(size + 1);\n+        System.arraycopy(buf, index, buf, index + 1, size - index);\n+        buf[index] = value;\n+        size++;\n+        return this;\n+    }\n+\n+    /**\n+     * Inserts the value into this builder.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param value  the value to insert\n+     * @return this, to enable chaining\n+     * @throws StringIndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder insert(int index, int value) {\n+        return insert(index, String.valueOf(value));\n+    }\n+\n+    /**\n+     * Inserts the value into this builder.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param value  the value to insert\n+     * @return this, to enable chaining\n+     * @throws StringIndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder insert(int index, long value) {\n+        return insert(index, String.valueOf(value));\n+    }\n+\n+    /**\n+     * Inserts the value into this builder.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param value  the value to insert\n+     * @return this, to enable chaining\n+     * @throws StringIndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder insert(int index, float value) {\n+        return insert(index, String.valueOf(value));\n+    }\n+\n+    /**\n+     * Inserts the value into this builder.\n+     *\n+     * @param index  the index to add at, must be valid\n+     * @param value  the value to insert\n+     * @return this, to enable chaining\n+     * @throws StringIndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder insert(int index, double value) {\n+        return insert(index, String.valueOf(value));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Deletes the characters between the two specified indices.\n+     *\n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param endIndex  the end index, exclusive, must be valid except\n+     *  that if too large it is treated as end of string\n+     * @return this, to enable chaining\n+     * @throws StringIndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder delete(int startIndex, int endIndex) {\n+        endIndex = validateRange(startIndex, endIndex);\n+        int len = endIndex - startIndex;\n+        if (len > 0) {\n+            System.arraycopy(buf, endIndex, buf, startIndex, size - endIndex);\n+            size -= len;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the character at the specified index.\n+     *\n+     * @param index  the index to delete\n+     * @return this, to enable chaining\n+     * @throws StringIndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder deleteCharAt(int index) {\n+        if (index < 0 || index >= size) {\n+            throw new StringIndexOutOfBoundsException(index);\n+        }\n+        System.arraycopy(buf, index + 1, buf, index, size - index - 1);\n+        size--;\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the character wherever it occurs in the builder.\n+     * \n+     * @param ch  the character to delete\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder delete(char ch) {\n+        for (int i = 0; i < size; i++) {\n+            if (buf[i] == ch) {\n+                int start = i;\n+                while (++i < size) {\n+                    if (buf[i] != ch) {\n+                        break;\n+                    }\n+                }\n+                System.arraycopy(buf, i, buf, start, size - i);\n+                size -= (i - start);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes the string wherever it occurs in the builder.\n+     * \n+     * @param str  the string to delete, null causes no action\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder delete(String str) {\n+        int len = (str == null ? 0 : str.length());\n+        if (len > 0) {\n+            int index = indexOf(str, 0);\n+            while (index >= 0) {\n+                delete(index, index + len);\n+                index = indexOf(str, index);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces a portion of the string builder with another string.\n+     * The length of the inserted string does not have to match the removed length.\n+     * \n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param endIndex  the end index, exclusive, must be valid except\n+     *  that if too large it is treated as end of string\n+     * @param str  the string to replace with\n+     * @return this, to enable chaining\n+     * @throws StringIndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder replace(int startIndex, int endIndex, String str) {\n+        endIndex = validateRange(startIndex, endIndex);\n+        int insertLen = str.length();\n+        int removeLen = endIndex = startIndex;\n+        int newSize = size - removeLen + insertLen;\n+        if (insertLen > removeLen) {\n+            ensureCapacity(newSize);\n+        }\n+        if (insertLen != removeLen) {\n+            System.arraycopy(buf, endIndex, buf, startIndex + insertLen, size - endIndex);\n+            size = newSize;\n+        }\n+        str.getChars(0, insertLen, buf, startIndex);\n+        return this;\n+    }\n+\n+    /**\n+     * Replaces a portion of the string builder with another string builder.\n+     * The length of the inserted string does not have to match the removed length.\n+     * \n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param endIndex  the end index, exclusive, must be valid except\n+     *  that if too large it is treated as end of string\n+     * @param builder  the string builder to replace with\n+     * @return this, to enable chaining\n+     * @throws StringIndexOutOfBoundsException if the index is invalid\n+     */\n+    public StrBuilder replace(int startIndex, int endIndex, StrBuilder builder) {\n+        endIndex = validateRange(startIndex, endIndex);\n+        int insertLen = builder.length();\n+        int removeLen = endIndex = startIndex;\n+        if (insertLen > removeLen) {\n+            ensureCapacity(size - removeLen + insertLen);\n+        }\n+        if (insertLen != removeLen) {\n+            System.arraycopy(buf, endIndex, buf, startIndex + insertLen, size - endIndex);\n+        }\n+        builder.getChars(0, insertLen, buf, startIndex);\n+        return this;\n+    }\n+\n+    /**\n+     * Replaces the search character with the replace character throughout the builder.\n+     * \n+     * @param search  the search string, null causes no action to occur\n+     * @param replace  the replace string, null is equivalent to an empty string\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder replace(char search, char replace) {\n+        if (search != replace) {\n+            for (int i = 0; i < size; i++) {\n+                if (buf[i] == search) {\n+                    buf[i] = replace;\n+                }\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Replaces the search string with the replace string throughout the builder.\n+     * \n+     * @param searchStr  the search string, null causes no action to occur\n+     * @param replaceStr  the replace string, null is equivalent to an empty string\n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder replace(String searchStr, String replaceStr) {\n+        int searchLen = (searchStr == null ? 0 : searchStr.length());\n+        if (searchLen > 0) {\n+            replaceStr = (replaceStr == null ? \"\" : replaceStr);\n+            int index = indexOf(searchStr, 0);\n+            while (index >= 0) {\n+                replace(index, index + searchLen, replaceStr);\n+                index = indexOf(searchStr, index);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether this builder starts with the specified string.\n+     * <p>\n+     * Note that this method handles null input quietly, unlike String.\n+     * \n+     * @param str  the string to search for, null returns false\n+     * @return true if the builder starts with the string\n+     */\n+    public boolean startsWith(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int len = str.length();\n+        if (len == 0) {\n+            return true;\n+        }\n+        if (len > size) {\n+            return false;\n+        }\n+        for (int i = 0; i < len; i++) {\n+            if (buf[i] != str.charAt(i)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Checks whether this builder ends with the specified string.\n+     * <p>\n+     * Note that this method handles null input quietly, unlike String.\n+     * \n+     * @param str  the string to search for, null returns false\n+     * @return true if the builder ends with the string\n+     */\n+    public boolean endsWith(String str) {\n+        if (str == null) {\n+            return false;\n+        }\n+        int len = str.length();\n+        if (len == 0) {\n+            return true;\n+        }\n+        if (len > size) {\n+            return false;\n+        }\n+        int pos = size - len;\n+        for (int i = 0; i < len; i++,pos++) {\n+            if (buf[pos] != str.charAt(i)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Extracts a portion of this string builder as a string.\n+     * \n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @return the new string\n+     * @throws StringIndexOutOfBoundsException if the index is invalid\n+     */\n+    public String substring(int start) {\n+        return substring(start, size);\n+    }\n+\n+    /**\n+     * Extracts a portion of this string builder as a string.\n+     * <p>\n+     * Note: This method treats an endIndex greater than the length of the\n+     * builder as equal to the length of the builder, and continues\n+     * without error, unlike StringBuffer or String.\n+     * \n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param endIndex  the end index, exclusive, must be valid except\n+     *  that if too large it is treated as end of string\n+     * @return the new string\n+     * @throws StringIndexOutOfBoundsException if the index is invalid\n+     */\n+    public String substring(int startIndex, int endIndex) {\n+        endIndex = validateRange(startIndex, endIndex);\n+        return new String(buf, startIndex, endIndex - startIndex);\n+    }\n+\n+    /**\n+     * Extracts the leftmost characters from the string builder without\n+     * throwing an exception.\n+     * <p>\n+     * This method extracts the left <code>length</code> characters from\n+     * the builder. If this many characters are not available, the whole\n+     * builder is returned. Thus the returned string may be shorter than the\n+     * length requested.\n+     * \n+     * @param length  the number of characters to extract, negative returns empty string\n+     * @return the new string\n+     */\n+    public String leftString(int length) {\n+        if (length <= 0) {\n+            return \"\";\n+        } else if (length >= size) {\n+            return new String(buf, 0, size);\n+        } else {\n+            return new String(buf, 0, length);\n+        }\n+    }\n+\n+    /**\n+     * Extracts the rightmost characters from the string builder without\n+     * throwing an exception.\n+     * <p>\n+     * This method extracts the right <code>length</code> characters from\n+     * the builder. If this many characters are not available, the whole\n+     * builder is returned. Thus the returned string may be shorter than the\n+     * length requested.\n+     * \n+     * @param length  the number of characters to extract, negative returns empty string\n+     * @return the new string\n+     */\n+    public String rightString(int length) {\n+        if (length <= 0) {\n+            return \"\";\n+        } else if (length >= size) {\n+            return new String(buf, 0, size);\n+        } else {\n+            return new String(buf, size - length, size);\n+        }\n+    }\n+\n+    /**\n+     * Extracts some characters from the middle of the string builder without\n+     * throwing an exception.\n+     * <p>\n+     * This method extracts <code>length</code> characters from the builder\n+     * at the specified index.\n+     * If the index is negative it is treated as zero.\n+     * If the index is greater than the builder size, it is treated as the builder size.\n+     * If the length is negative, the empty string is returned.\n+     * If insufficient characters are available in the builder, as much as possible is returned.\n+     * Thus the returned string may be shorter than the length requested.\n+     * \n+     * @param index  the index to start at, negative means zero\n+     * @param length  the number of characters to extract, negative returns empty string\n+     * @return the new string\n+     */\n+    public String midString(int index, int length) {\n+        if (index < 0) {\n+            index = 0;\n+        }\n+        if (length <= 0 || index >= size) {\n+            return \"\";\n+        }\n+        if (size <= index + length) {\n+            return new String(buf, index, size - index);\n+        } else {\n+            return new String(buf, index, length);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks of the string builder contains the specified char.\n+     * \n+     * @param ch  the character to find\n+     * @return true if the builder contains the character\n+     */\n+    public boolean contains(char ch) {\n+        char[] thisBuf = buf;\n+        for (int i = 0; i < thisBuf.length; i++) {\n+            if (thisBuf[i] == ch) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Checks of the string builder contains the specified string.\n+     * \n+     * @param str  the string to find\n+     * @return true if the builder contains the string\n+     */\n+    public boolean contains(String str) {\n+        return (indexOf(str, 0) >= 0);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Searches the string builder to find the first reference to the specified char.\n+     * \n+     * @param ch  the character to find\n+     * @return the first index of the character, or -1 if not found\n+     */\n+    public int indexOf(char ch) {\n+        return indexOf(ch, 0);\n+    }\n+\n+    /**\n+     * Searches the string builder to find the first reference to the specified char.\n+     * \n+     * @param ch  the character to find\n+     * @param startIndex  the index to start at, must be valid\n+     * @return the first index of the character, or -1 if not found\n+     */\n+    public int indexOf(char ch, int startIndex) {\n+        startIndex = (startIndex < 0 ? 0 : startIndex);\n+        if (startIndex >= size) {\n+            return -1;\n+        }\n+        char[] thisBuf = buf;\n+        for (int i = startIndex; i < thisBuf.length; i++) {\n+            if (thisBuf[i] == ch) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Searches the string builder to find the first reference to the specified string.\n+     * <p>\n+     * Note that a null input string will return -1, whereas the JDK throws an exception.\n+     * \n+     * @param str  the string to find, null returns -1\n+     * @return the first index of the string, or -1 if not found\n+     */\n+    public int indexOf(String str) {\n+        return indexOf(str, 0);\n+    }\n+\n+    /**\n+     * Searches the string builder to find the first reference to the specified\n+     * string starting searching from the given index.\n+     * <p>\n+     * Note that a null input string will return -1, whereas the JDK throws an exception.\n+     * \n+     * @param str  the string to find, null returns -1\n+     * @param startIndex  the index to start at, must be valid\n+     * @return the first index of the string, or -1 if not found\n+     */\n+    public int indexOf(String str, int startIndex) {\n+        startIndex = (startIndex < 0 ? 0 : startIndex);\n+        if (startIndex >= size) {\n+            return -1;\n+        }\n+        int strLen = (str == null ? 0 : str.length());\n+        if (strLen > 0 && strLen <= size) {\n+            if (strLen == 1) {\n+                return indexOf(str.charAt(0), startIndex);\n+            }\n+            char[] thisBuf = buf;\n+            outer:\n+            for (int i = startIndex; i < thisBuf.length - strLen; i++) {\n+                for (int j = 0; j < strLen; j++) {\n+                    if (str.charAt(j) != thisBuf[i + j]) {\n+                        continue outer;\n+                    }\n+                }\n+                return i;\n+            }\n+            \n+        } else if (strLen == 0) {\n+            return 0;\n+        }\n+        return -1;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Searches the string builder to find the last reference to the specified char.\n+     * \n+     * @param ch  the character to find\n+     * @return the last index of the character, or -1 if not found\n+     */\n+    public int lastIndexOf(char ch) {\n+        return lastIndexOf(ch, 0);\n+    }\n+\n+    /**\n+     * Searches the string builder to find the last reference to the specified char.\n+     * \n+     * @param ch  the character to find\n+     * @param startIndex  the index to start at, invalid index rounded to edge\n+     * @return the last index of the character, or -1 if not found\n+     */\n+    public int lastIndexOf(char ch, int startIndex) {\n+        startIndex = (startIndex >= size ? size - 1 : startIndex);\n+        if (startIndex < 0) {\n+            return -1;\n+        }\n+        char[] thisBuf = buf;\n+        for (int i = startIndex; i >= 0; i--) {\n+            if (thisBuf[i] == ch) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Searches the string builder to find the last reference to the specified string.\n+     * <p>\n+     * Note that a null input string will return -1, whereas the JDK throws an exception.\n+     * \n+     * @param str  the string to find, null returns -1\n+     * @return the last index of the string, or -1 if not found\n+     */\n+    public int lastIndexOf(String str) {\n+        return lastIndexOf(str, size);\n+    }\n+\n+    /**\n+     * Searches the string builder to find the last reference to the specified\n+     * string starting searching from the given index.\n+     * <p>\n+     * Note that a null input string will return -1, whereas the JDK throws an exception.\n+     * \n+     * @param str  the string to find, null returns -1\n+     * @param startIndex  the index to start at, invalid index rounded to edge\n+     * @return the last index of the string, or -1 if not found\n+     */\n+    public int lastIndexOf(String str, int startIndex) {\n+        startIndex = (startIndex >= size ? size - 1 : startIndex);\n+        if (startIndex < 0) {\n+            return -1;\n+        }\n+        int strLen = (str == null ? 0 : str.length());\n+        if (strLen > 0 && strLen <= size) {\n+            if (strLen == 1) {\n+                return lastIndexOf(str.charAt(0), startIndex);\n+            }\n+            char[] thisBuf = buf;\n+            outer:\n+            for (int i = startIndex - strLen; i >= 0; i--) {\n+                for (int j = 0; j < strLen; j++) {\n+                    if (str.charAt(j) != thisBuf[i + j]) {\n+                        continue outer;\n+                    }\n+                }\n+                return i;\n+            }\n+            \n+        } else if (strLen == 0) {\n+            return startIndex;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Reverses the string builder placing each character in the opposite index.\n+     * \n+     * @return this, to enable chaining\n+     */\n+    public StrBuilder reverse() {\n+        int half = size / 2;\n+        char swap;\n+        for (int i = 0; i < half; i++) {\n+            swap = buf[i];\n+            buf[i] = buf[size - i];\n+            buf[size - i] = swap;\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Gets a String version of the string builder, creating a new instance\n+     * each time the method is called.\n+     * <p>\n+     * Note that unlike StringBuffer, the string version returned is\n+     * independent of the string builder.\n+     *\n+     * @return the builder as a String\n+     */\n+    public String toString() {\n+        return new String(buf, 0, size);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Validates parameters defining a range of the builder.\n+     * \n+     * @param startIndex  the start index, inclusive, must be valid\n+     * @param endIndex  the end index, exclusive, must be valid except\n+     *  that if too large it is treated as end of string\n+     * @return the new string\n+     * @throws StringIndexOutOfBoundsException if the index is invalid\n+     */\n+    protected int validateRange(int startIndex, int endIndex) {\n+        if (startIndex < 0) {\n+            throw new StringIndexOutOfBoundsException(startIndex);\n+        }\n+        if (endIndex > size) {\n+            endIndex = size;\n+        }\n+        if (startIndex > endIndex) {\n+            throw new StringIndexOutOfBoundsException(\"end < start\");\n+        }\n+        return endIndex;\n+    }\n+\n+    /**\n+     * Validates parameters defining a single index in the builder.\n+     * \n+     * @param index  the index, must be valid\n+     * @throws StringIndexOutOfBoundsException if the index is invalid\n+     */\n+    protected void validateIndex(int index) {\n+        if (index < 0 || index > size) {\n+            throw new StringIndexOutOfBoundsException(index);\n+        }\n+    }\n+\n+}", "timestamp": 1097939392, "metainfo": ""}