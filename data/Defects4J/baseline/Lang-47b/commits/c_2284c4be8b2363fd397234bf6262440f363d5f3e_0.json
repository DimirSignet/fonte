{"sha": "2284c4be8b2363fd397234bf6262440f363d5f3e", "log": "Closure renamed to Executor   ", "commit": "\n--- a/src/java/org/apache/commons/lang/functor/TransformerUtils.java\n+++ b/src/java/org/apache/commons/lang/functor/TransformerUtils.java\n  * <li>Invoker - returns the result of a method call on the input object\n  * <li>Clone - returns a clone of the input object\n  * <li>Constant - always returns the same object\n- * <li>Closure - performs a Closure and returns the input object\n+ * <li>Executor - performs a Executor and returns the input object\n  * <li>Predicate - returns the result of the predicate as a Boolean\n  * <li>Factory - returns a new object from a factory\n  * <li>Chained - chains two or more transformers together\n  * All the supplied transformers are Serializable.\n  *\n  * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n- * @version $Id: TransformerUtils.java,v 1.1 2002/11/05 16:44:28 bayard Exp $\n+ * @version $Id: TransformerUtils.java,v 1.2 2002/11/06 19:16:33 bayard Exp $\n  */\n public class TransformerUtils {\n \n     }\n \n     /**\n-     * Creates a Transformer that calls a Closure each time the transformer is used.\n+     * Creates a Transformer that calls a Executor each time the transformer is used.\n      * The transformer returns the input object.\n      *\n      * @param command  the command to run each time in the transformer\n      * @return the transformer.\n      */\n-    public static Transformer asTransformer(Closure command) {\n+    public static Transformer asTransformer(Executor command) {\n         if (command == null) {\n-            throw new IllegalArgumentException(\"ClosureTransformer: The command must not be null\");\n-        }\n-        return new ClosureTransformer(command);\n+            throw new IllegalArgumentException(\"ExecutorTransformer: The command must not be null\");\n+        }\n+        return new ExecutorTransformer(command);\n     }\n \n     /**\n         }\n     }\n \n-    // ClosureTransformer\n-    //----------------------------------------------------------------------------------\n-\n-    /**\n-     * ClosureTransformer executes a Closure object.\n-     */\n-    private static class ClosureTransformer implements Transformer, Serializable {\n-\n-        private final Closure iClosure;\n+    // ExecutorTransformer\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * ExecutorTransformer executes a Executor object.\n+     */\n+    private static class ExecutorTransformer implements Transformer, Serializable {\n+\n+        private final Executor iExecutor;\n \n         /**\n          * Constructor to store command\n          */\n-        private ClosureTransformer(Closure command) {\n-            super();\n-            iClosure = command;\n+        private ExecutorTransformer(Executor command) {\n+            super();\n+            iExecutor = command;\n         }\n \n         /**\n          */\n         public Object transform(Object input) {\n             try {\n-                iClosure.execute(input);\n+                iExecutor.execute(input);\n                 return input;\n \n-            } catch (ClosureException ex) {\n-                throw new TransformerException(\"ClosureTransformer: \" + ex.getMessage(), ex);\n+            } catch (ExecutorException ex) {\n+                throw new TransformerException(\"ExecutorTransformer: \" + ex.getMessage(), ex);\n             }\n         }\n     }\n--- a/src/test/org/apache/commons/lang/functor/FunctorTestSuite.java\n+++ b/src/test/org/apache/commons/lang/functor/FunctorTestSuite.java\n  * Test suite for the Pattern packages.\n  *\n  * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n- * @version $Id: FunctorTestSuite.java,v 1.1 2002/11/05 16:45:13 bayard Exp $\n+ * @version $Id: FunctorTestSuite.java,v 1.2 2002/11/06 19:16:15 bayard Exp $\n  */\n public class FunctorTestSuite extends TestCase {\n     \n     }\n \n     /**\n-     * Closure-line interface.\n+     * Executor-line interface.\n      */\n     public static void main(String[] args) {\n         TestRunner.run(suite());\n      */\n     public static Test suite() {\n         TestSuite suite = new TestSuite();\n-        suite.addTest(TestClosureUtils.suite());\n+        suite.addTest(TestExecutorUtils.suite());\n         suite.addTest(TestFactoryUtils.suite());\n         suite.addTest(TestPredicateUtils.suite());\n         suite.addTest(TestTransformerUtils.suite());\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/functor/TestExecutorUtils.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.functor;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.lang.functor.Predicate;\n+import org.apache.commons.lang.functor.PredicateUtils;\n+/**\n+ * Tests the org.apache.commons.lang.functor.ExecutorUtils class.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id: TestExecutorUtils.java,v 1.1 2002/11/06 19:16:15 bayard Exp $\n+ */\n+public class TestExecutorUtils extends junit.framework.TestCase {\n+\n+    private static final Object cObject = new Object();\n+    private static final Object cString = \"Hello\";\n+    private static final Object cInteger = new Integer(6);\n+\n+    /**\n+     * Construct\n+     */\n+    public TestExecutorUtils(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * Return class aa a test suite.\n+     */\n+    public static Test suite() {\n+        return new TestSuite(TestExecutorUtils.class);\n+    }\n+\n+    /**\n+     * Set up instance variables required by this test case.\n+     */\n+    public void setUp() {\n+    }\n+\n+    /**\n+     * Tear down instance variables required by this test case.\n+     */\n+    public void tearDown() {\n+    }\n+    \n+    static class MockExecutor implements Executor {\n+        int count = 0;\n+        \n+        /**\n+         * @see org.apache.commons.lang.functor.Executor#execute(Object)\n+         */\n+        public void execute(Object object) {\n+            count++;\n+        }\n+\n+    }\n+\n+    // exceptionExecutor\n+    //------------------------------------------------------------------\n+\n+    public void testExceptionExecutor() {\n+        assertNotNull(ExecutorUtils.exceptionExecutor());\n+        assertSame(ExecutorUtils.exceptionExecutor(), ExecutorUtils.exceptionExecutor());\n+        try {\n+            ExecutorUtils.exceptionExecutor().execute(null);\n+        } catch (ExecutorException ex) {\n+            try {\n+                ExecutorUtils.exceptionExecutor().execute(cString);\n+            } catch (ExecutorException ex2) {\n+                return;\n+            }\n+        }\n+        fail();\n+    }\n+    \n+    // nopExecutor\n+    //------------------------------------------------------------------\n+\n+    public void testNopExecutor() {\n+        StringBuffer buf = new StringBuffer(\"Hello\");\n+        ExecutorUtils.nopExecutor().execute(null);\n+        assertEquals(\"Hello\", buf.toString());\n+        ExecutorUtils.nopExecutor().execute(\"Hello\");\n+        assertEquals(\"Hello\", buf.toString());\n+    }\n+\n+    // invokeExecutor\n+    //------------------------------------------------------------------\n+\n+    public void testInvokeExecutor() {\n+        StringBuffer buf = new StringBuffer(\"Hello\");\n+        ExecutorUtils.invokerExecutor(\"reverse\").execute(buf);\n+        assertEquals(\"olleH\", buf.toString());\n+        buf = new StringBuffer(\"Hello\");\n+        ExecutorUtils.invokerExecutor(\"setLength\", new Class[] {Integer.TYPE}, new Object[] {new Integer(2)}).execute(buf);\n+        assertEquals(\"He\", buf.toString());\n+    }\n+\n+    // forExecutor\n+    //------------------------------------------------------------------\n+\n+    public void testForExecutor() {\n+        MockExecutor cmd = new MockExecutor();\n+        ExecutorUtils.forExecutor(5, cmd).execute(null);\n+        assertEquals(5, cmd.count);\n+        try {\n+            ExecutorUtils.forExecutor(-1, new MockExecutor());\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    // whileExecutor\n+    //------------------------------------------------------------------\n+\n+    public void testWhileExecutor() {\n+        MockExecutor cmd = new MockExecutor();\n+        ExecutorUtils.whileExecutor(PredicateUtils.falsePredicate(), cmd).execute(null);\n+        assertEquals(0, cmd.count);\n+        try {\n+            ExecutorUtils.whileExecutor(null, null);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    // doWhileExecutor\n+    //------------------------------------------------------------------\n+\n+    public void testDoWhileExecutor() {\n+        MockExecutor cmd = new MockExecutor();\n+        ExecutorUtils.doWhileExecutor(cmd, PredicateUtils.falsePredicate()).execute(null);\n+        assertEquals(1, cmd.count);\n+        try {\n+            ExecutorUtils.doWhileExecutor(null, null);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    // chainedExecutor\n+    //------------------------------------------------------------------\n+\n+    public void testChainedExecutor() {\n+        MockExecutor a = new MockExecutor();\n+        MockExecutor b = new MockExecutor();\n+        ExecutorUtils.chainedExecutor(a, b).execute(null);\n+        assertEquals(1, a.count);\n+        assertEquals(1, b.count);\n+        \n+        a = new MockExecutor();\n+        b = new MockExecutor();\n+        ExecutorUtils.chainedExecutor(new Executor[] {a, b, a}).execute(null);\n+        assertEquals(2, a.count);\n+        assertEquals(1, b.count);\n+        \n+        a = new MockExecutor();\n+        b = new MockExecutor();\n+        Collection coll = new ArrayList();\n+        coll.add(b);\n+        coll.add(a);\n+        coll.add(b);\n+        ExecutorUtils.chainedExecutor(coll).execute(null);\n+        assertEquals(1, a.count);\n+        assertEquals(2, b.count);\n+    }\n+\n+    public void testChainedExecutorEx1a() {\n+        try {\n+            ExecutorUtils.chainedExecutor(null, null);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+    \n+    public void testChainedExecutorEx1b() {\n+        try {\n+            ExecutorUtils.chainedExecutor((Executor[]) null);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+    \n+    public void testChainedExecutorEx1c() {\n+        try {\n+            ExecutorUtils.chainedExecutor((Collection) null);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+    \n+    public void testChainedExecutorEx2() {\n+        try {\n+            ExecutorUtils.chainedExecutor(new Executor[0]);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+    \n+    public void testChainedExecutorEx3() {\n+        try {\n+            ExecutorUtils.chainedExecutor(new Executor[] {null, null});\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+    \n+    public void testChainedExecutorEx4() {\n+        try {\n+            ExecutorUtils.chainedExecutor(Collections.EMPTY_LIST);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+    \n+    public void testChainedExecutorEx5() {\n+        try {\n+            Collection coll = new ArrayList();\n+            coll.add(null);\n+            coll.add(null);\n+            ExecutorUtils.chainedExecutor(coll);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+    \n+    // switchExecutor\n+    //------------------------------------------------------------------\n+\n+    public void testSwitchExecutor() {\n+        MockExecutor a = new MockExecutor();\n+        MockExecutor b = new MockExecutor();\n+        ExecutorUtils.switchExecutor(PredicateUtils.truePredicate(), a, b).execute(null);\n+        assertEquals(1, a.count);\n+        assertEquals(0, b.count);\n+        \n+        a = new MockExecutor();\n+        b = new MockExecutor();\n+        ExecutorUtils.switchExecutor(PredicateUtils.falsePredicate(), a, b).execute(null);\n+        assertEquals(0, a.count);\n+        assertEquals(1, b.count);\n+        \n+        a = new MockExecutor();\n+        b = new MockExecutor();\n+        ExecutorUtils.switchExecutor(\n+            new Predicate[] {PredicateUtils.equalPredicate(\"HELLO\"), PredicateUtils.equalPredicate(\"THERE\")}, \n+            new Executor[] {a, b}).execute(\"WELL\");\n+        assertEquals(0, a.count);\n+        assertEquals(0, b.count);\n+        \n+        a = new MockExecutor();\n+        b = new MockExecutor();\n+        ExecutorUtils.switchExecutor(\n+            new Predicate[] {PredicateUtils.equalPredicate(\"HELLO\"), PredicateUtils.equalPredicate(\"THERE\")}, \n+            new Executor[] {a, b}).execute(\"HELLO\");\n+        assertEquals(1, a.count);\n+        assertEquals(0, b.count);\n+        \n+        a = new MockExecutor();\n+        b = new MockExecutor();\n+        MockExecutor c = new MockExecutor();\n+        ExecutorUtils.switchExecutor(\n+            new Predicate[] {PredicateUtils.equalPredicate(\"HELLO\"), PredicateUtils.equalPredicate(\"THERE\")}, \n+            new Executor[] {a, b}, c).execute(\"WELL\");\n+        assertEquals(0, a.count);\n+        assertEquals(0, b.count);\n+        assertEquals(1, c.count);\n+        \n+        a = new MockExecutor();\n+        b = new MockExecutor();\n+        Map map = new HashMap();\n+        map.put(PredicateUtils.equalPredicate(\"HELLO\"), a);\n+        map.put(PredicateUtils.equalPredicate(\"THERE\"), b);\n+        ExecutorUtils.switchExecutor(map).execute(null);\n+        assertEquals(0, a.count);\n+        assertEquals(0, b.count);\n+\n+        a = new MockExecutor();\n+        b = new MockExecutor();\n+        map = new HashMap();\n+        map.put(PredicateUtils.equalPredicate(\"HELLO\"), a);\n+        map.put(PredicateUtils.equalPredicate(\"THERE\"), b);\n+        ExecutorUtils.switchExecutor(map).execute(\"THERE\");\n+        assertEquals(0, a.count);\n+        assertEquals(1, b.count);\n+\n+        a = new MockExecutor();\n+        b = new MockExecutor();\n+        c = new MockExecutor();\n+        map = new HashMap();\n+        map.put(PredicateUtils.equalPredicate(\"HELLO\"), a);\n+        map.put(PredicateUtils.equalPredicate(\"THERE\"), b);\n+        map.put(null, c);\n+        ExecutorUtils.switchExecutor(map).execute(\"WELL\");\n+        assertEquals(0, a.count);\n+        assertEquals(0, b.count);\n+        assertEquals(1, c.count);\n+    }\n+\n+    public void testSwitchExecutorEx1a() {\n+        try {\n+            ExecutorUtils.switchExecutor(null, null);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+    \n+    public void testSwitchExecutorEx1b() {\n+        try {\n+            ExecutorUtils.switchExecutor((Predicate[]) null, (Executor[]) null);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+    \n+    public void testSwitchExecutorEx1c() {\n+        try {\n+            ExecutorUtils.switchExecutor((Map) null);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+    \n+    public void testSwitchExecutorEx2() {\n+        try {\n+            ExecutorUtils.switchExecutor(new Predicate[0], new Executor[0]);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+    \n+    public void testSwitchExecutorEx3() {\n+        try {\n+            ExecutorUtils.switchExecutor(new Predicate[2], new Executor[2]);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+    \n+    public void testSwitchExecutorEx4() {\n+        try {\n+            ExecutorUtils.switchExecutor(Collections.EMPTY_MAP);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+    \n+    public void testSwitchExecutorEx5() {\n+        try {\n+            Map map = new HashMap();\n+            map.put(null, null);\n+            map.put(null, null);\n+            ExecutorUtils.switchExecutor(map);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+    \n+    public void testSwitchExecutorEx6() {\n+        try {\n+            ExecutorUtils.switchExecutor(new Predicate[2], new Executor[1]);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+    \n+    // switchMapExecutor\n+    //------------------------------------------------------------------\n+\n+    public void testSwitchMapExecutor() {\n+        MockExecutor a = new MockExecutor();\n+        MockExecutor b = new MockExecutor();\n+        Map map = new HashMap();\n+        map.put(\"HELLO\", a);\n+        map.put(\"THERE\", b);\n+        ExecutorUtils.switchMapExecutor(map).execute(null);\n+        assertEquals(0, a.count);\n+        assertEquals(0, b.count);\n+\n+        a = new MockExecutor();\n+        b = new MockExecutor();\n+        map = new HashMap();\n+        map.put(\"HELLO\", a);\n+        map.put(\"THERE\", b);\n+        ExecutorUtils.switchMapExecutor(map).execute(\"THERE\");\n+        assertEquals(0, a.count);\n+        assertEquals(1, b.count);\n+\n+        a = new MockExecutor();\n+        b = new MockExecutor();\n+        MockExecutor c = new MockExecutor();\n+        map = new HashMap();\n+        map.put(\"HELLO\", a);\n+        map.put(\"THERE\", b);\n+        map.put(null, c);\n+        ExecutorUtils.switchMapExecutor(map).execute(\"WELL\");\n+        assertEquals(0, a.count);\n+        assertEquals(0, b.count);\n+        assertEquals(1, c.count);\n+    }\n+\n+    public void testSwitchMapExecutorEx1() {\n+        try {\n+            ExecutorUtils.switchMapExecutor(null);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+    \n+    public void testSwitchMapExecutorEx2() {\n+        try {\n+            ExecutorUtils.switchMapExecutor(Collections.EMPTY_MAP);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+    \n+    \n+}\n--- a/src/test/org/apache/commons/lang/functor/TestTransformerUtils.java\n+++ b/src/test/org/apache/commons/lang/functor/TestTransformerUtils.java\n import junit.framework.TestSuite;\n \n import org.apache.commons.lang.SerializationException;\n-import org.apache.commons.lang.functor.Closure;\n-import org.apache.commons.lang.functor.ClosureUtils;\n+import org.apache.commons.lang.functor.Executor;\n+import org.apache.commons.lang.functor.ExecutorUtils;\n import org.apache.commons.lang.functor.Factory;\n import org.apache.commons.lang.functor.FactoryUtils;\n import org.apache.commons.lang.functor.Predicate;\n  * Tests the org.apache.commons.lang.functor.TransformerUtils class.\n  *\n  * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n- * @version $Id: TestTransformerUtils.java,v 1.1 2002/11/05 16:45:13 bayard Exp $\n+ * @version $Id: TestTransformerUtils.java,v 1.2 2002/11/06 19:16:15 bayard Exp $\n  */\n public class TestTransformerUtils extends junit.framework.TestCase {\n \n     // commandTransformer\n     //------------------------------------------------------------------\n \n-    public void testClosureTransformer() {\n-        assertEquals(null, TransformerUtils.asTransformer(ClosureUtils.nopClosure()).transform(null));\n-        assertEquals(cObject, TransformerUtils.asTransformer(ClosureUtils.nopClosure()).transform(cObject));\n-        assertEquals(cString, TransformerUtils.asTransformer(ClosureUtils.nopClosure()).transform(cString));\n-        assertEquals(cInteger, TransformerUtils.asTransformer(ClosureUtils.nopClosure()).transform(cInteger));\n-        try {\n-            TransformerUtils.asTransformer((Closure) null);\n+    public void testExecutorTransformer() {\n+        assertEquals(null, TransformerUtils.asTransformer(ExecutorUtils.nopExecutor()).transform(null));\n+        assertEquals(cObject, TransformerUtils.asTransformer(ExecutorUtils.nopExecutor()).transform(cObject));\n+        assertEquals(cString, TransformerUtils.asTransformer(ExecutorUtils.nopExecutor()).transform(cString));\n+        assertEquals(cInteger, TransformerUtils.asTransformer(ExecutorUtils.nopExecutor()).transform(cInteger));\n+        try {\n+            TransformerUtils.asTransformer((Executor) null);\n         } catch (IllegalArgumentException ex) {\n             return;\n         }", "timestamp": 1036610193, "metainfo": ""}