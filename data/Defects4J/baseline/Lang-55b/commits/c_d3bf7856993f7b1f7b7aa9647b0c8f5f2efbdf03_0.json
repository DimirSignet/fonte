{"sha": "d3bf7856993f7b1f7b7aa9647b0c8f5f2efbdf03", "log": "Test the ClassUtils class   ", "commit": "\n--- a/src/java/org/apache/commons/lang/ClassUtils.java\n+++ b/src/java/org/apache/commons/lang/ClassUtils.java\n  * classes without using reflection.</p>\n  *\n  * @author <a href=\"mailto:scolebourne@apache.org\">Stephen Colebourne</a>\n- * @version $Id: ClassUtils.java,v 1.5 2002/11/16 10:41:03 scolebourne Exp $\n+ * @version $Id: ClassUtils.java,v 1.6 2002/12/15 19:36:08 scolebourne Exp $\n  */\n public class ClassUtils {\n \n     // -------------------------------------------------------------------------\n     \n     /**\n-     * <p>Gets the class name minus the package name from a\n-     * <code>Class</code>.</p>\n+     * <p>Gets the class name minus the package name for an <code>Object</code>.</p>\n+     * \n+     * @param object  the class to get the short name for\n+     * @param valueIfNull  the value to return if null\n+     * @return the class name of the object without the package name, or the null value\n+     */\n+    public static String getShortClassName(Object object, String valueIfNull) {\n+        if (object == null) {\n+            return valueIfNull;\n+        }\n+        return getShortClassName(object.getClass().getName());\n+    }\n+    \n+    /**\n+     * <p>Gets the class name minus the package name from a <code>Class</code>.</p>\n      * \n      * @param cls  the class to get the short name for, must not be\n      *  <code>null</code>\n             throw new IllegalArgumentException(\"The class must not be null\");\n         }\n         return getShortClassName(cls.getName());\n-    }\n-    \n-    /**\n-     * <p>Gets the class name minus the package name for an\n-     * <code>Object</code>.</p>\n-     * \n-     * @param object  the class to get the short name for, must not be\n-     *  <code>null</code>\n-     * @return the class name of the object without the package name\n-     * @throws IllegalArgumentException if the object is <code>null</code>\n-     */\n-    public static String getShortClassName(Object object) {\n-        if (object == null) {\n-            throw new IllegalArgumentException(\"The object must not be null\");\n-        }\n-        return getShortClassName(object.getClass().getName());\n     }\n     \n     /**\n     // -------------------------------------------------------------------------\n     \n     /**\n+     * <p>Gets the package name of an <code>Object</code>.</p>\n+     * \n+     * @param object  the class to get the package name for\n+     * @param valueIfNull  the value to return if null\n+     * @return the package name of the object, or the null value\n+     */\n+    public static String getPackageName(Object object, String valueIfNull) {\n+        if (object == null) {\n+            return valueIfNull;\n+        }\n+        return getPackageName(object.getClass().getName());\n+    }\n+    \n+    /**\n      * <p>Gets the package name of a <code>Class</code>.</p>\n      * \n      * @param cls  the class to get the package name for, must not be\n             throw new IllegalArgumentException(\"The class must not be null\");\n         }\n         return getPackageName(cls.getName());\n-    }\n-    \n-    /**\n-     * <p>Gets the package name of an <code>Object</code>.</p>\n-     * \n-     * @param object  the class to get the package name for, must not be\n-     *  <code>null</code>\n-     * @return the package name\n-     * @throws IllegalArgumentException if the object is <code>null</code>\n-     */\n-    public static String getPackageName(Object object) {\n-        if (object == null) {\n-            throw new IllegalArgumentException(\"The object must not be null\");\n-        }\n-        return getPackageName(object.getClass().getName());\n     }\n     \n     /**\n     \n     /**\n      * <p>Gets a <code>List</code> of all interfaces implemented by the given\n-     * class.</p>\n+     * class and its superclasses.</p>\n      *\n      * <p>The order is determined by looking through each interface in turn as\n-     * declared in the source file and following its hieracrchy up. Later\n-     * duplicates are ignored, so the order is maintained.</p>\n+     * declared in the source file and following its hieracrchy up. Then each \n+     * superclass is considered in the same way. Later duplicates are ignored, \n+     * so the order is maintained.</p>\n      * \n      * @param cls  the class to look up, must not be <code>null</code>\n      * @return the <code>List</code> of interfaces in order\n             throw new IllegalArgumentException(\"The class must not be null\");\n         }\n         List list = new ArrayList();\n-        Class[] interfaces = cls.getInterfaces();\n-        for (int i = 0; i < interfaces.length; i++) {\n-            if (list.contains(interfaces[i]) == false) {\n-                list.add(interfaces[i]);\n-            }\n-            List superInterfaces = getAllInterfaces(interfaces[i]);\n-            for (Iterator it = superInterfaces.iterator(); it.hasNext();) {\n-                Class intface = (Class) it.next();\n-                if (list.contains(intface) == false) {\n-                    list.add(intface);\n+        while (cls != null) {\n+            Class[] interfaces = cls.getInterfaces();\n+            for (int i = 0; i < interfaces.length; i++) {\n+                if (list.contains(interfaces[i]) == false) {\n+                    list.add(interfaces[i]);\n                 }\n-            }\n+                List superInterfaces = getAllInterfaces(interfaces[i]);\n+                for (Iterator it = superInterfaces.iterator(); it.hasNext();) {\n+                    Class intface = (Class) it.next();\n+                    if (list.contains(intface) == false) {\n+                        list.add(intface);\n+                    }\n+                }\n+            }\n+            cls = cls.getSuperclass();\n         }\n         return list;\n     }\n //        return null;\n //    }\n \n+    // -------------------------------------------------------------------------\n+    \n     /**\n      * <p>Given a <code>List</code> of class names, this method converts them into classes.     *\n      * A new <code>List</code> is returned. If the class name cannot be found, <code>null</code>\n      * is stored in the <code>List</code>. If the class name in the <code>List</code> is\n      * <code>null</code>, <code>null</code> is stored in the output <code>List</code>.</p>\n      * \n-     * @param classNames  the classNames to change, the class is stored back\n-     *  into the <code>List</code>. <code>null</code> will be stored in the <code>List</code>\n-     *  if no class is found.\n-     * @return the <code>List</code> of Class objects corresponding to the class names\n+     * @param classNames  the classNames to change\n+     * @return a <code>List</code> of Class objects corresponding to the class names\n      * @throws IllegalArgumentException if the classNames is <code>null</code>\n+     * @throws ClassCastException if classNames contains a non String entry\n      */\n     public static List convertClassNamesToClasses(List classNames) {\n         if (classNames == null) {\n     }\n     \n     /**\n-     * <p>Given a <code>List</code> of classes, this method finds all those which\n-     * are subclasses or implementations of a specified superclass.</p>\n-     * \n-     * @param classes  the classes to check\n-     * @param superclass  the superclass to check for\n-     * @return the list of subclasses or implementations\n-     * @throws IllegalArgumentException if the classes or superClass is <code>null</code>\n-     */\n-    public static List getAssignableFrom(List classes, Class superclass) {\n+     * <p>Given a <code>List</code> of <code>Class</code> objects, this method converts\n+     * them into class names.\n+     * A new <code>List</code> is returned. <code>null</code> objects will be copied into\n+     * the returned list as <code>null</code>.</p>\n+     * \n+     * @param classes  the classes to change\n+     * @return a <code>List</code> of Class objects corresponding to the class names\n+     * @throws IllegalArgumentException if the classNames is <code>null</code>\n+     * @throws ClassCastException if classNames contains a non Class or null entry\n+     */\n+    public static List convertClassesToClassNames(List classes) {\n         if (classes == null) {\n-            throw new IllegalArgumentException(\"The classes must not be null\");\n-        }\n-        if (superclass == null) {\n-            throw new IllegalArgumentException(\"The superclass must not be null\");\n-        }\n-        List subs = new ArrayList();\n-        Iterator it = classes.iterator();\n-        while (it.hasNext()) {\n+            throw new IllegalArgumentException(\"The classes list must not be null\");\n+        }\n+        List classNames = new ArrayList(classes.size());\n+        for (Iterator it = classes.iterator(); it.hasNext();) {\n             Class cls = (Class) it.next();\n             if (cls == null) {\n-                throw new IllegalArgumentException(\"The class list must not contain nulls\");\n-            }\n-            if (isAssignable(cls, superclass)) {\n-                subs.add(cls);\n-            }\n-        }\n-        return subs;\n-    }\n-\n+                classNames.add(null);\n+            } else {\n+                classNames.add(cls.getName());\n+            }\n+        }\n+        return classNames;\n+    }\n+    \n+    // -------------------------------------------------------------------------\n+    \n     /**\n      * <p>Checks if an array of Classes can be assigned to another array of Classes.</p>\n      *\n-     * <p>This can be used to check if parameter types are suitably compatable for\n-     * reflection invocation.</p>\n+     * <p>This method calls {@link #isAssignable(Class, Class) isAssignable} for each\n+     * Class pair in the input arrays. It can be used to check if a set of arguments\n+     * (the first parameter) are suitably compatable with a set of method parameter types\n+     * (the second parameter).</p>\n      *\n      * <p>Unlike the {@link Class#isAssignableFrom(java.lang.Class)} method, this\n      * method takes into account widenings of primitive classes and\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/ClassUtilsTest.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+/**\n+ * Unit tests {@link org.apache.commons.lang.ClassUtils}.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id: ClassUtilsTest.java,v 1.1 2002/12/15 19:36:08 scolebourne Exp $\n+ */\n+public class ClassUtilsTest extends TestCase {\n+\n+    public ClassUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+    \tTestSuite suite = new TestSuite(ClassUtilsTest.class);\n+    \tsuite.setName(\"ClassUtils Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    private static class Inner {\n+    }\n+    \n+    // -------------------------------------------------------------------------\n+    public void test_getShortClassName_Object() {\n+        assertEquals(\"ClassUtils\", ClassUtils.getShortClassName(new ClassUtils(), \"<null>\"));\n+        assertEquals(\"ClassUtilsTest.Inner\", ClassUtils.getShortClassName(new Inner(), \"<null>\"));\n+        assertEquals(\"String\", ClassUtils.getShortClassName(\"hello\", \"<null>\"));\n+        assertEquals(\"<null>\", ClassUtils.getShortClassName(null, \"<null>\"));\n+    }\n+    \n+    public void test_getShortClassName_Class() {\n+        assertEquals(\"ClassUtils\", ClassUtils.getShortClassName(ClassUtils.class));\n+        assertEquals(\"Map.Entry\", ClassUtils.getShortClassName(Map.Entry.class));\n+        try {\n+            ClassUtils.getShortClassName((Class) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    public void test_getShortClassName_String() {\n+        assertEquals(\"ClassUtils\", ClassUtils.getShortClassName(ClassUtils.class.getName()));\n+        assertEquals(\"Map.Entry\", ClassUtils.getShortClassName(Map.Entry.class.getName()));\n+        try {\n+            ClassUtils.getShortClassName((String) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            ClassUtils.getShortClassName(\"\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    // -------------------------------------------------------------------------\n+    public void test_getPackageName_Object() {\n+        assertEquals(\"org.apache.commons.lang\", ClassUtils.getPackageName(new ClassUtils(), \"<null>\"));\n+        assertEquals(\"org.apache.commons.lang\", ClassUtils.getPackageName(new Inner(), \"<null>\"));\n+        assertEquals(\"<null>\", ClassUtils.getPackageName(null, \"<null>\"));\n+    }\n+    \n+    public void test_getPackageName_Class() {\n+        assertEquals(\"java.lang\", ClassUtils.getPackageName(String.class));\n+        assertEquals(\"java.util\", ClassUtils.getPackageName(Map.Entry.class));\n+        try {\n+            ClassUtils.getPackageName((Class) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    public void test_getPackageName_String() {\n+        assertEquals(\"org.apache.commons.lang\", ClassUtils.getPackageName(ClassUtils.class.getName()));\n+        assertEquals(\"java.util\", ClassUtils.getPackageName(Map.Entry.class.getName()));\n+        try {\n+            ClassUtils.getPackageName((String) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            ClassUtils.getPackageName(\"\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    // -------------------------------------------------------------------------\n+    public void test_getAllSuperclasses_Class() {\n+        List list = ClassUtils.getAllSuperclasses(CY.class);\n+        assertEquals(2, list.size());\n+        assertEquals(CX.class, list.get(0));\n+        assertEquals(Object.class, list.get(1));\n+        try {\n+            ClassUtils.getAllSuperclasses(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    public void test_getAllInterfaces_Class() {\n+        List list = ClassUtils.getAllInterfaces(CY.class);\n+        assertEquals(6, list.size());\n+        assertEquals(IB.class, list.get(0));\n+        assertEquals(IC.class, list.get(1));\n+        assertEquals(ID.class, list.get(2));\n+        assertEquals(IE.class, list.get(3));\n+        assertEquals(IF.class, list.get(4));\n+        assertEquals(IA.class, list.get(5));\n+        try {\n+            ClassUtils.getAllInterfaces(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    private static interface IA {\n+    }\n+    private static interface IB {\n+    }\n+    private static interface IC extends ID, IE {\n+    }\n+    private static interface ID {\n+    }\n+    private static interface IE extends IF {\n+    }\n+    private static interface IF {\n+    }\n+    private static class CX implements IB, IA, IE {\n+    }\n+    private static class CY extends CX implements IB, IC {\n+    }\n+    \n+    // -------------------------------------------------------------------------\n+    public void test_convertClassNamesToClasses_List() {\n+        List list = new ArrayList();\n+        List result = ClassUtils.convertClassNamesToClasses(list);\n+        assertEquals(0, result.size());\n+        \n+        list.add(\"java.lang.String\");\n+        list.add(\"java.lang.xxx\");\n+        list.add(\"java.lang.Object\");\n+        result = ClassUtils.convertClassNamesToClasses(list);\n+        assertEquals(3, result.size());\n+        assertEquals(String.class, result.get(0));\n+        assertEquals(null, result.get(1));\n+        assertEquals(Object.class, result.get(2));\n+\n+        list.add(new Object());\n+        try {\n+            ClassUtils.convertClassNamesToClasses(list);\n+            fail();\n+        } catch (ClassCastException ex) {}\n+        \n+        try {\n+            ClassUtils.convertClassNamesToClasses(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    public void test_convertClassesToClassNames_List() {\n+        List list = new ArrayList();\n+        List result = ClassUtils.convertClassesToClassNames(list);\n+        assertEquals(0, result.size());\n+        \n+        list.add(String.class);\n+        list.add(Object.class);\n+        result = ClassUtils.convertClassesToClassNames(list);\n+        assertEquals(2, result.size());\n+        assertEquals(\"java.lang.String\", result.get(0));\n+        assertEquals(\"java.lang.Object\", result.get(1));\n+\n+        list.add(new Object());\n+        try {\n+            ClassUtils.convertClassesToClassNames(list);\n+            fail();\n+        } catch (ClassCastException ex) {}\n+        \n+        try {\n+            ClassUtils.convertClassesToClassNames(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    // -------------------------------------------------------------------------\n+    public void test_isInnerClass_Class() {\n+        assertEquals(true, ClassUtils.isInnerClass(Inner.class));\n+        assertEquals(true, ClassUtils.isInnerClass(Map.Entry.class));\n+        assertEquals(false, ClassUtils.isInnerClass(this.getClass()));\n+        assertEquals(false, ClassUtils.isInnerClass(String.class));\n+        try {\n+            ClassUtils.isInnerClass(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+    \n+    // -------------------------------------------------------------------------\n+    public void test_isAssignable_ClassArray_ClassArray() throws Exception {\n+        Class[] array2 = new Class[] {Object.class, Object.class};\n+        Class[] array1 = new Class[] {Object.class};\n+        Class[] array1s = new Class[] {String.class};\n+        Class[] array0 = new Class[] {};\n+\n+        assertEquals(false, ClassUtils.isAssignable(array1, array2));\n+        assertEquals(false, ClassUtils.isAssignable(null, array2));\n+        assertEquals(true, ClassUtils.isAssignable(null, array0));\n+        assertEquals(true, ClassUtils.isAssignable(array0, array0));\n+        assertEquals(true, ClassUtils.isAssignable(array0, null));\n+        assertEquals(true, ClassUtils.isAssignable((Class[]) null, (Class[]) null));\n+        \n+        assertEquals(false, ClassUtils.isAssignable(array1, array1s));\n+        assertEquals(true, ClassUtils.isAssignable(array1s, array1s));\n+        assertEquals(true, ClassUtils.isAssignable(array1s, array1));\n+    }\n+    \n+    public void test_isAssignable() throws Exception {\n+        try {\n+            ClassUtils.isAssignable(String.class, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            ClassUtils.isAssignable((Class) null, (Class) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        assertEquals(true, ClassUtils.isAssignable(null, Object.class));\n+        assertEquals(true, ClassUtils.isAssignable(null, Integer.class));\n+        assertEquals(false, ClassUtils.isAssignable(null, Integer.TYPE));\n+        assertEquals(true, ClassUtils.isAssignable(String.class, Object.class));\n+        assertEquals(true, ClassUtils.isAssignable(String.class, String.class));\n+        assertEquals(false, ClassUtils.isAssignable(Object.class, String.class));\n+        assertEquals(false, ClassUtils.isAssignable(Integer.TYPE, Integer.class));\n+        assertEquals(false, ClassUtils.isAssignable(Integer.class, Integer.TYPE));\n+        assertEquals(true, ClassUtils.isAssignable(Integer.TYPE, Integer.TYPE));\n+        assertEquals(true, ClassUtils.isAssignable(Integer.class, Integer.class));\n+    }\n+    \n+    public void test_isAssignable_Widening() throws Exception {\n+        // test byte conversions\n+        assertEquals(\"byte -> char\", false, ClassUtils.isAssignable(Byte.TYPE, Character.TYPE));\n+        assertEquals(\"byte -> byte\", true, ClassUtils.isAssignable(Byte.TYPE, Byte.TYPE));\n+        assertEquals(\"byte -> short\", true, ClassUtils.isAssignable(Byte.TYPE, Short.TYPE));\n+        assertEquals(\"byte -> int\", true, ClassUtils.isAssignable(Byte.TYPE, Integer.TYPE));\n+        assertEquals(\"byte -> long\", true, ClassUtils.isAssignable(Byte.TYPE, Long.TYPE));\n+        assertEquals(\"byte -> float\", true, ClassUtils.isAssignable(Byte.TYPE, Float.TYPE));\n+        assertEquals(\"byte -> double\", true, ClassUtils.isAssignable(Byte.TYPE, Double.TYPE));\n+        assertEquals(\"byte -> boolean\", false, ClassUtils.isAssignable(Byte.TYPE, Boolean.TYPE));\n+        \n+        // test short conversions\n+        assertEquals(\"short -> char\", false, ClassUtils.isAssignable(Short.TYPE, Character.TYPE));\n+        assertEquals(\"short -> byte\", false, ClassUtils.isAssignable(Short.TYPE, Byte.TYPE));\n+        assertEquals(\"short -> short\", true, ClassUtils.isAssignable(Short.TYPE, Short.TYPE));\n+        assertEquals(\"short -> int\", true, ClassUtils.isAssignable(Short.TYPE, Integer.TYPE));\n+        assertEquals(\"short -> long\", true, ClassUtils.isAssignable(Short.TYPE, Long.TYPE));\n+        assertEquals(\"short -> float\", true, ClassUtils.isAssignable(Short.TYPE, Float.TYPE));\n+        assertEquals(\"short -> double\", true, ClassUtils.isAssignable(Short.TYPE, Double.TYPE));\n+        assertEquals(\"short -> boolean\", false, ClassUtils.isAssignable(Short.TYPE, Boolean.TYPE));\n+        \n+        // test char conversions\n+        assertEquals(\"char -> char\", true, ClassUtils.isAssignable(Character.TYPE, Character.TYPE));\n+        assertEquals(\"char -> byte\", false, ClassUtils.isAssignable(Character.TYPE, Byte.TYPE));\n+        assertEquals(\"char -> short\", false, ClassUtils.isAssignable(Character.TYPE, Short.TYPE));\n+        assertEquals(\"char -> int\", true, ClassUtils.isAssignable(Character.TYPE, Integer.TYPE));\n+        assertEquals(\"char -> long\", true, ClassUtils.isAssignable(Character.TYPE, Long.TYPE));\n+        assertEquals(\"char -> float\", true, ClassUtils.isAssignable(Character.TYPE, Float.TYPE));\n+        assertEquals(\"char -> double\", true, ClassUtils.isAssignable(Character.TYPE, Double.TYPE));\n+        assertEquals(\"char -> boolean\", false, ClassUtils.isAssignable(Character.TYPE, Boolean.TYPE));\n+        \n+        // test int conversions\n+        assertEquals(\"int -> char\", false, ClassUtils.isAssignable(Integer.TYPE, Character.TYPE));\n+        assertEquals(\"int -> byte\", false, ClassUtils.isAssignable(Integer.TYPE, Byte.TYPE));\n+        assertEquals(\"int -> short\", false, ClassUtils.isAssignable(Integer.TYPE, Short.TYPE));\n+        assertEquals(\"int -> int\", true, ClassUtils.isAssignable(Integer.TYPE, Integer.TYPE));\n+        assertEquals(\"int -> long\", true, ClassUtils.isAssignable(Integer.TYPE, Long.TYPE));\n+        assertEquals(\"int -> float\", true, ClassUtils.isAssignable(Integer.TYPE, Float.TYPE));\n+        assertEquals(\"int -> double\", true, ClassUtils.isAssignable(Integer.TYPE, Double.TYPE));\n+        assertEquals(\"int -> boolean\", false, ClassUtils.isAssignable(Integer.TYPE, Boolean.TYPE));\n+ \n+        // test long conversions\n+        assertEquals(\"long -> char\", false, ClassUtils.isAssignable(Long.TYPE, Character.TYPE));\n+        assertEquals(\"long -> byte\", false, ClassUtils.isAssignable(Long.TYPE, Byte.TYPE));\n+        assertEquals(\"long -> short\", false, ClassUtils.isAssignable(Long.TYPE, Short.TYPE));\n+        assertEquals(\"long -> int\", false, ClassUtils.isAssignable(Long.TYPE, Integer.TYPE));\n+        assertEquals(\"long -> long\", true, ClassUtils.isAssignable(Long.TYPE, Long.TYPE));\n+        assertEquals(\"long -> float\", true, ClassUtils.isAssignable(Long.TYPE, Float.TYPE));\n+        assertEquals(\"long -> double\", true, ClassUtils.isAssignable(Long.TYPE, Double.TYPE));\n+        assertEquals(\"long -> boolean\", false, ClassUtils.isAssignable(Long.TYPE, Boolean.TYPE));\n+ \n+        // test float conversions\n+        assertEquals(\"float -> char\", false, ClassUtils.isAssignable(Float.TYPE, Character.TYPE));\n+        assertEquals(\"float -> byte\", false, ClassUtils.isAssignable(Float.TYPE, Byte.TYPE));\n+        assertEquals(\"float -> short\", false, ClassUtils.isAssignable(Float.TYPE, Short.TYPE));\n+        assertEquals(\"float -> int\", false, ClassUtils.isAssignable(Float.TYPE, Integer.TYPE));\n+        assertEquals(\"float -> long\", false, ClassUtils.isAssignable(Float.TYPE, Long.TYPE));\n+        assertEquals(\"float -> float\", true, ClassUtils.isAssignable(Float.TYPE, Float.TYPE));\n+        assertEquals(\"float -> double\", true, ClassUtils.isAssignable(Float.TYPE, Double.TYPE));\n+        assertEquals(\"float -> boolean\", false, ClassUtils.isAssignable(Float.TYPE, Boolean.TYPE));\n+        \n+        // test float conversions\n+        assertEquals(\"double -> char\", false, ClassUtils.isAssignable(Double.TYPE, Character.TYPE));\n+        assertEquals(\"double -> byte\", false, ClassUtils.isAssignable(Double.TYPE, Byte.TYPE));\n+        assertEquals(\"double -> short\", false, ClassUtils.isAssignable(Double.TYPE, Short.TYPE));\n+        assertEquals(\"double -> int\", false, ClassUtils.isAssignable(Double.TYPE, Integer.TYPE));\n+        assertEquals(\"double -> long\", false, ClassUtils.isAssignable(Double.TYPE, Long.TYPE));\n+        assertEquals(\"double -> float\", false, ClassUtils.isAssignable(Double.TYPE, Float.TYPE));\n+        assertEquals(\"double -> double\", true, ClassUtils.isAssignable(Double.TYPE, Double.TYPE));\n+        assertEquals(\"double -> boolean\", false, ClassUtils.isAssignable(Double.TYPE, Boolean.TYPE));\n+        \n+        // test float conversions\n+        assertEquals(\"boolean -> char\", false, ClassUtils.isAssignable(Boolean.TYPE, Character.TYPE));\n+        assertEquals(\"boolean -> byte\", false, ClassUtils.isAssignable(Boolean.TYPE, Byte.TYPE));\n+        assertEquals(\"boolean -> short\", false, ClassUtils.isAssignable(Boolean.TYPE, Short.TYPE));\n+        assertEquals(\"boolean -> int\", false, ClassUtils.isAssignable(Boolean.TYPE, Integer.TYPE));\n+        assertEquals(\"boolean -> long\", false, ClassUtils.isAssignable(Boolean.TYPE, Long.TYPE));\n+        assertEquals(\"boolean -> float\", false, ClassUtils.isAssignable(Boolean.TYPE, Float.TYPE));\n+        assertEquals(\"boolean -> double\", false, ClassUtils.isAssignable(Boolean.TYPE, Double.TYPE));\n+        assertEquals(\"boolean -> boolean\", true, ClassUtils.isAssignable(Boolean.TYPE, Boolean.TYPE));\n+    }\n+    \n+//    public static List getAssignableFrom(List classes, Class superclass) {\n+//    public static boolean isAssignable(Class[] classArray, Class[] toClassArray) {\n+//    public static boolean isAssignable(Class cls, Class toClass) {\n+}\n--- a/src/test/org/apache/commons/lang/LangTestSuite.java\n+++ b/src/test/org/apache/commons/lang/LangTestSuite.java\n  *\n  * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n  * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n- * @version $Id: LangTestSuite.java,v 1.7 2002/12/15 16:55:32 scolebourne Exp $\n+ * @version $Id: LangTestSuite.java,v 1.8 2002/12/15 19:36:08 scolebourne Exp $\n  */\n public class LangTestSuite extends TestCase {\n     \n         suite.addTest(ArrayUtilsTest.suite());\n         suite.addTest(BooleanUtilsTest.suite());\n         suite.addTest(CharSetUtilsTest.suite());\n+        suite.addTest(ClassUtilsTest.suite());\n         suite.addTest(NumberRangeTest.suite());\n         suite.addTest(NumberUtilsTest.suite());\n         suite.addTest(ObjectUtilsTest.suite());", "timestamp": 1039980968, "metainfo": ""}