{"sha": "b549eca779808ff17559775a294dd3fd3d9bc382", "log": "Initial version of new implementation of OptimizeParameters pass.  R=johnlenz DELTA=708  (708 added, 0 deleted, 0 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=244021   ", "commit": "\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/OptimizeParametersAlt.java\n+/*\n+ * Copyright 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+\n+/**\n+ * Optimize function calls and function signatures.\n+ *\n+ * <ul>\n+ * <li>Removes optional parameters if no caller specifies it as argument.</li>\n+ * <li>Removes arguments at call site to function that\n+ *     ignores the parameter. (Not implemented) </li>\n+ * <li>Inline a parameter if the function is always called with that constant.\n+ *     </li>\n+ * </ul>\n+ *\n+ * There are some constraints on when a function may be optmized.\n+ * Only functions which are declared in one of the following forms:<br>\n+ * <ul>\n+ * <li>function foo() {}</li>\n+ * <li>var foo = function() {}</li>\n+ * <li>var foo = function bar() {}</li>\n+ * </ul>\n+ * Also, functions are identified by their names. Therefore, if a name is not\n+ * used in a way that we know that is safe, it is blacklisted. A function whose\n+ * name is on the list cannot be optimized.\n+ *\n+ */\n+class OptimizeParametersAlt extends AbstractPostOrderCallback\n+    implements CompilerPass, SpecializationAwareCompilerPass {\n+\n+  private final AbstractCompiler compiler;\n+\n+  // maps names with declarations; sometimes more than one name might refer\n+  // to a single declaration, i.e. var foo = function f() {}\n+  private Map<String, Map<Scope, Declaration>> mappings =\n+      new HashMap<String, Map<Scope, Declaration>>();\n+\n+  // list of all declarations\n+  private Set<Declaration> decls = new HashSet<Declaration>();\n+\n+  // list of all function calls\n+  private List<Call> calls = new LinkedList<Call>();\n+\n+  // list of all names which are not supposed to be optimized\n+  private Set<String> blacklist = new HashSet<String>();\n+\n+  private SpecializeModule.SpecializationState specializationState;\n+\n+  public void enableSpecialization(\n+      SpecializeModule.SpecializationState state) {\n+    this.specializationState = state;\n+  }\n+\n+  OptimizeParametersAlt(AbstractCompiler compiler) {\n+    this.compiler = compiler;\n+  }\n+\n+  @Override\n+  public void process(Node externs, Node root) {\n+    //TODO (dhans): consider either switching to call graph and give up\n+    // support for local scopes - depending on actual test results.\n+    NodeTraversal.traverse(compiler, root, this);\n+    processCalls();\n+    removeUnsafeDeclarations();\n+    optimizeParameters();\n+  }\n+\n+  /**\n+   * Represents a declared function.\n+   */\n+  private class Declaration {\n+\n+    /*\n+     * AST node associated with the declaration.\n+     */\n+    public Node node;\n+\n+    /*\n+     * List of formal parameters that defined for the function.\n+     */\n+    public LinkedList<FormalParameter> parameters;\n+\n+    /*\n+     * List of function calls that refer to this declaration. This list may\n+     * be not exhaustive, but in this case doNotOptimize should be set to true.\n+     */\n+    public List<Call> calls;\n+\n+    /*\n+     * Number of format parameters which are always passed actual values\n+     * for example, for the given function:\n+     * function foo(a, b, c, d, e) {}; f(1, 3, 2); f(2, 3); f(1, 3, 4, 5)\n+     * minParams = 2\n+     * All parameters up to this one can be inlined, provided the same value\n+     * is passed in each call:\n+     * function foo(a, c, d, e) {var b = 3;}; f(1, 2); f(2); f(1, 4, 5)\n+     */\n+    public int minParams;\n+\n+    /*\n+     * Number of format parameters which are passed a value at least once\n+     * for example, for the given function:\n+     * function foo(a, b, c, d, e) {}; f(1, 3, 2); f(2, 3); f(1, 3, 4, 5)\n+     * maxParams = 4\n+     * All parameters after this number are never passed any values,\n+     * so there can be inlined:\n+     * function foo(a, b, c, d) {var e}; f(1, 3, 2); f(2, 3); f(1, 3, 4, 5)\n+     */\n+    public int maxParams;\n+\n+    /*\n+     * Boolean property which indicates whether there is a reason not to\n+     * optimize this declaration.\n+     */\n+    public boolean doNotOptimize;\n+\n+    Declaration(Node node, LinkedList<FormalParameter> parameters,\n+        boolean doNotOptimize) {\n+      this.node = node;\n+      this.parameters = parameters;\n+      this.doNotOptimize = doNotOptimize;\n+      this.calls = new LinkedList<Call>();\n+      this.maxParams = 0;\n+      this.minParams = parameters.size();\n+    }\n+  }\n+\n+  /**\n+   * Represents a formal parameter of a function.\n+   */\n+  private class FormalParameter {\n+    private final Node arg;\n+    private boolean manyValues;\n+    private Node initialValue;\n+\n+    FormalParameter(Node arg) {\n+      this.arg = arg;\n+      this.initialValue = null;\n+      this.manyValues = false;\n+    }\n+  }\n+\n+  /**\n+   * Represents an actual parameter passed to a function call.\n+   */\n+  private class ActualParameter {\n+    private final Node value;\n+\n+    ActualParameter(Node value) {\n+      this.value = value;\n+    }\n+  }\n+\n+  /**\n+   * Represents a call.\n+   */\n+  private static class Call {\n+    private String name;\n+    private Node callSide;\n+\n+    // Scope which the actual function is defined in\n+    private Scope scope;\n+    private List<ActualParameter> parameters;\n+\n+    Call(String name, Node callSide, Scope scope,\n+        List<ActualParameter> parameters) {\n+      this.name = name;\n+      this.callSide = callSide;\n+      this.scope = scope;\n+      this.parameters = parameters;\n+    }\n+  }\n+\n+  /**\n+   * Adds a new call to the list of all calls which should be taken into\n+   * account.\n+   *\n+   * @param name name of the function that is called\n+   * @param node AST node which represents the call or new node\n+   * @param scope scope that the function which is called belongs to\n+   */\n+  private void registerCall(String name, Node node, Scope scope) {\n+    Preconditions.checkState(NodeUtil.isCall(node) || NodeUtil.isNew(node));\n+    Preconditions.checkNotNull(node.getFirstChild());\n+\n+    List<ActualParameter> params = Lists.newLinkedList();\n+    Node child = node.getFirstChild();\n+\n+    if (NodeUtil.isFunctionObjectCall(node)) {\n+      // the first parameter is a \"this\" object\n+      // which is to be passed to the function\n+      // the rest of them represent actual parameters\n+      child = child.getNext();\n+    }\n+\n+    // collect all actual parameters passed to the call\n+    while (child != null && (child = child.getNext()) != null) {\n+      params.add(new ActualParameter(child));\n+    }\n+\n+    calls.add(new Call(name, node, scope, params));\n+  }\n+\n+  /**\n+   * This function is called when all declarations and calls are gathered.\n+   * It iterates through all the calls and two important things happen\n+   * for each one:\n+   * - a corresponding Declaration instance is found\n+   * - all actual parameters of the call are processed\n+   * After all calls are processed, there is enough information to decide if\n+   * a particular formal parameter may be optimized.\n+   */\n+  private void processCalls() {\n+    for (Call call : calls) {\n+      // unqualified name of the function which is called\n+      String name = call.name;\n+\n+      // get all function definitions with the name\n+      Map<Scope, Declaration> declarations = mappings.get(name);\n+\n+      // function is not defined the the current module or should not\n+      // be optimized anyway\n+      if (declarations == null) {\n+        continue;\n+      }\n+\n+      // find scope that the declaration belongs to\n+      Scope scope = call.scope;\n+      while (scope != null && !declarations.containsKey(scope)) {\n+        scope = scope.getParent();\n+      }\n+      Declaration declaration = declarations.get(scope);\n+\n+      if (declaration == null) {\n+        continue;\n+      }\n+\n+      // process parameters based on actual values passed as parameters\n+      processParameters(declaration, call);\n+\n+      declaration.calls.add(call);\n+    }\n+  }\n+\n+  /**\n+   * This function makes sure that functions with names that are\n+   * blacklisted are not optimized.\n+   */\n+  private void removeUnsafeDeclarations() {\n+    // do not optimize any functions whose names are blacklisted\n+    for (Entry<String, Map<Scope, Declaration>> entry : mappings.entrySet()) {\n+      String name = entry.getKey();\n+      if (blacklist.contains(name)) {\n+        for (Declaration declaration : entry.getValue().values()) {\n+          declaration.doNotOptimize = true;\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * This function iterates through a list of all actual parameters that\n+   * were passed to the corresponding declaration. It updates minParams\n+   * and maxParams values for the declaration and sets manyValues property\n+   * for a formal parameter.\n+   */\n+  private void processParameters(Declaration declaration, Call call) {\n+    List<FormalParameter> params = declaration.parameters;\n+    List<ActualParameter> actParams = call.parameters;\n+\n+    int index = 0;\n+    ListIterator<FormalParameter> it = params.listIterator();\n+    ListIterator<ActualParameter> actIt = actParams.listIterator();\n+    while (it.hasNext() && actIt.hasNext()) {\n+      ++index;\n+      FormalParameter param = it.next();\n+\n+      if (param.manyValues) {\n+        // do not bother to check anything if we already know that\n+        // the parameter cannot be optimized\n+        continue;\n+      }\n+      Node actValue = actIt.next().value;\n+\n+      if (param.initialValue == null) {\n+        // this is the first call which passes a value to the parameter\n+        param.initialValue = actValue;\n+      } else if (!nodesAreEqual(param.initialValue, actValue)) {\n+        // this call passes a different value: the parameter cannot be touched\n+        param.manyValues = true;\n+      }\n+    }\n+\n+    int maxParams = declaration.maxParams;\n+    declaration.maxParams = index > maxParams ? index : maxParams;\n+    int minParams = declaration.minParams;\n+    declaration.minParams = index < minParams ? index : minParams;\n+  }\n+\n+  private void optimizeParameters() {\n+\n+    for (Declaration decl : decls) {\n+      if (decl.doNotOptimize) {\n+        continue;\n+      }\n+\n+      if (specializationState != null &&\n+          specializationState.canFixupFunction(decl.node)) {\n+        specializationState.reportSpecializedFunctionContainingNode(decl.node);\n+      }\n+      tryEliminateOptionalArgs(decl);\n+      tryEliminateConstantArgs(decl);\n+    }\n+  }\n+\n+  void addDeclaration(String name, Scope scope, Declaration declaration) {\n+    // do not optimize anonymous function expressions or exported names\n+    // other cases when a function may be exported are covered as well\n+    // for example:\n+    // function foo() {}\n+    // tee(foo)\n+    // foo will not be aliased, as it is used in an unsafe way, as parameter\n+    if (name.isEmpty() || compiler.getCodingConvention().isExported(name)) {\n+      return;\n+    }\n+\n+    Map<Scope, Declaration> declarations;\n+    if (!mappings.containsKey(name)) {\n+      declarations = new HashMap<Scope, Declaration>();\n+      mappings.put(name, declarations);\n+    } else {\n+      declarations = mappings.get(name);\n+    }\n+\n+    if (!declarations.containsKey(scope)) {\n+      declarations.put(scope, declaration);\n+      decls.add(declaration);\n+    } else {\n+      // if one scope has more than one function with the same name,\n+      // do not optimize any of them\n+      declarations.get(scope).doNotOptimize = true;\n+    }\n+  }\n+\n+  private boolean checkIfFunctionCannotBeOptimized(Node node, Node parent) {\n+    Preconditions.checkState(node.getType() == Token.FUNCTION);\n+\n+    // check if function is defined in an array or an object\n+    if (parent.getType() == Token.ARRAYLIT ||\n+        parent.getType() == Token.OBJECTLIT) {\n+      return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  @Override\n+  public void visit(NodeTraversal t, Node n, Node parent) {\n+    // get current scope\n+    Scope scope = t.getScope();\n+    String name = null;\n+    switch (n.getType()) {\n+      case Token.FUNCTION:\n+        checkIfFunctionIsSafe(t, n, parent);\n+        break;\n+      case Token.NAME:\n+        checkIfNameIsSafe(t, n, parent);\n+        break;\n+      case Token.STRING:\n+        checkIfStringIsSafe(t, n, parent);\n+        break;\n+    }\n+  }\n+\n+  private void checkIfFunctionIsSafe(NodeTraversal t, Node node, Node parent) {\n+    String name = null;\n+    Scope scope = t.getScope();\n+\n+    // some functions are not optimized\n+    // what with something like:\n+    // array = [function foo() {}]\n+    // can this function be called by foo() ANYWHERE?\n+    if (checkIfFunctionCannotBeOptimized(node, parent)) {\n+      return;\n+    }\n+    // get function name\n+    Node child = node.getFirstChild();\n+    name = child.getString();\n+\n+    // construct list of parameters\n+    LinkedList<FormalParameter> parameters =\n+        new LinkedList<FormalParameter>();\n+    Node paramNode = child.getNext().getFirstChild();\n+    while (paramNode != null) {\n+      parameters.add(new FormalParameter(paramNode));\n+      paramNode = paramNode.getNext();\n+    }\n+\n+    // even if we already know that we will not optimize this function,\n+    // we want to save it, because if we encounter another function with\n+    // the same name, we want to know that we are dealing with a duplicate\n+    boolean doNotOptimize = parameters.isEmpty();\n+    Declaration declaration = new Declaration(node, parameters,\n+        doNotOptimize);\n+\n+    addDeclaration(name, scope, declaration);\n+\n+    // check if this function is a part of a VAR declaration\n+    // or a simple assignment\n+    if (parent != null) {\n+      Node grandparent = parent.getParent();\n+      if (grandparent != null && NodeUtil.isVar(grandparent)) {\n+        name = grandparent.getFirstChild().getString();\n+        addDeclaration(name, scope, declaration);\n+      }\n+\n+      if (NodeUtil.isAssign(parent) && parent.getLastChild() == node) {\n+        // support only simple assignments - foo = function () {}\n+        if (NodeUtil.isName(parent.getFirstChild())) {\n+          name = parent.getFirstChild().getString();\n+          addDeclaration(name, scope, declaration);\n+        }\n+      }\n+    }\n+  }\n+\n+  private void checkIfNameIsSafe(NodeTraversal t, Node node, Node parent) {\n+    Preconditions.checkState(node.getType() == Token.NAME);\n+    boolean isSafe = false;\n+    String name = node.getString();\n+    Scope scope = t.getScope();\n+\n+    // check if the name is a part of a simple function call: f()\n+    if (parent.getType() == Token.CALL && parent.getFirstChild() == node) {\n+      // register new call\n+      registerCall(name, parent, scope);\n+      return;\n+    }\n+\n+    // check if the name is a part of a new expression: new f()\n+    if (parent.getType() == Token.NEW && parent.getFirstChild() == node) {\n+      registerCall(name, parent, scope);\n+      return;\n+    }\n+\n+    // check if the name is a part of a simple call expression: f.call()\n+    int type = parent.getType();\n+    if (NodeUtil.isGet(parent) && parent.getFirstChild() == node) {\n+      Preconditions.checkNotNull(node.getNext());\n+      Node grandparent = parent.getParent();\n+      Node prop = node.getNext();\n+      if (NodeUtil.isString(prop) && prop.getString().equals(\"call\") &&\n+          NodeUtil.isCall(grandparent)) {\n+        registerCall(name, grandparent, scope);\n+        return;\n+      }\n+    }\n+\n+    // check if the name is a part of a function declaration/expression\n+    // it is checked by another function\n+    if (NodeUtil.isFunction(parent) && parent.getFirstChild() == node) {\n+      // it represents function name\n+      return;\n+    }\n+    if (parent.getType() == Token.LP &&\n+        NodeUtil.isFunction(parent.getParent()) &&\n+        parent.getFirstChild().getNext() == node) {\n+      // it represents one of its formal parameters\n+      return;\n+    }\n+\n+    // check if the name is a left side of var declaration\n+    if (NodeUtil.isVarDeclaration(node)) {\n+      return;\n+    }\n+\n+    // check if the name is a left side of assign expression\n+    if (NodeUtil.isAssign(parent) && parent.getFirstChild() == node) {\n+      return;\n+    }\n+\n+    // if we encountered \"arguments\", the enclosing\n+    // function should not be optimized\n+    if (name.equals(\"arguments\")) {\n+      // function which uses \"arguments\" variable should not be optimized\n+      Node function = t.getEnclosingFunction();\n+      if (function != null) {\n+        // check if it is a named function\n+        // function foo() {}\n+        name = function.getFirstChild().getString();\n+        if (!name.isEmpty()) {\n+          blacklist.add(name);\n+        }\n+\n+        // check if function is assigned to a variable\n+        // var foo = function() {}\n+        Node fparent = function.getParent();\n+        if (NodeUtil.isVarDeclaration(fparent)) {\n+          name = fparent.getString();\n+          blacklist.add(name);\n+        }\n+      }\n+      return;\n+    }\n+\n+    // the name is potentially unsafe\n+    blacklist.add(node.getString());\n+\n+  }\n+\n+  private void checkIfStringIsSafe(NodeTraversal t, Node node, Node parent) {\n+    Preconditions.checkState(node.getType() == Token.STRING);\n+\n+    // do not consider empty strings\n+    if (node.getString().isEmpty()) {\n+      return;\n+    }\n+\n+    // a string node is only safe when it is used to invoke a method for\n+    // the current object, like this.foo() or this['foo']()\n+    // like obj['foo']() or obj.foo()\n+    if (NodeUtil.isGet(parent)) {\n+      Node obj = parent.getFirstChild();\n+      Node grandparent = parent.getParent();\n+      if (obj.getNext() == node &&\n+          NodeUtil.isThis(obj) &&\n+          NodeUtil.isCall(grandparent) &&\n+          grandparent.getFirstChild() == parent) {\n+        registerCall(node.getString(), grandparent, t.getScope());\n+        return;\n+      }\n+    }\n+\n+    blacklist.add(node.getString());\n+  }\n+\n+  /**\n+   * Removes any optional parameters if no callers specifies it as an argument.\n+   * @param declaration function to optimize\n+   */\n+  private void tryEliminateOptionalArgs(Declaration declaration) {\n+    Node formalArgs = declaration.node.getFirstChild().getNext();\n+    Node body = formalArgs.getNext();\n+    Iterator<FormalParameter> it = declaration.parameters.descendingIterator();\n+\n+    // parameters which still does not have initial values assigned by any\n+    // calls can be safely removed\n+    int index = declaration.parameters.size() - 1;\n+    while (index >= declaration.maxParams) {\n+      FormalParameter param = it.next();\n+\n+      // this parameter has a value - it cannot be eliminated\n+      // the rest of parameters cannot be eliminated as well\n+      if (param.initialValue != null) {\n+        break;\n+      }\n+\n+      // no call specifies a value for this parameter, thus it can be removed\n+      // from the list of local parameters and replaced by a local var.\n+      formalArgs.removeChild(param.arg);\n+      Node var = new Node(Token.VAR, param.arg);\n+      body.addChildToFront(var);\n+\n+      // this parameter should not be optimized again\n+      param.manyValues = true;\n+      compiler.reportCodeChange();\n+      --index;\n+    }\n+  }\n+\n+  /**\n+   * Eliminate parameters if they are always constant.\n+   *\n+   * function foo(a, b) {...}\n+   * foo(1,2);\n+   * foo(1,3)\n+   * becomes\n+   * function foo(b) { var a = 1 ... }\n+   * foo(2);\n+   * foo(3);\n+   *\n+   * @param declaration function to optimize\n+   */\n+  private void tryEliminateConstantArgs(Declaration declaration) {\n+    Node formalArgs = declaration.node.getFirstChild().getNext();\n+    Node body = formalArgs.getNext();\n+    Iterator<FormalParameter> it = declaration.parameters.descendingIterator();\n+\n+    int index = declaration.parameters.size();//formalArgs.getChildCount();\n+    LinkedList<Integer> indexes = new LinkedList<Integer>();\n+    // parameters which are not marked with cannotRemove property\n+    // have the same initial value assigned in all calls\n+    while (it.hasNext()) {\n+      FormalParameter param = it.next();\n+      --index;\n+\n+      // optimize only parameters which are passed a value in each call\n+      if (index >= declaration.minParams) {\n+        continue;\n+      }\n+\n+      // check if this parameter can be removed\n+      if (param.manyValues) {\n+        continue;\n+      }\n+\n+      if (!checkIsSafeToRemove(param)) {\n+        continue;\n+      }\n+\n+      // there is exactly one value assigned to this parameters, thus it\n+      // can be removed from the list of formal parameters and replaced by\n+      // a local var\n+      formalArgs.removeChild(param.arg);\n+\n+      Node newVar = NodeUtil.newVarNode(param.arg.getQualifiedName(),\n+          param.initialValue.cloneTree());\n+      body.addChildToFront(newVar);\n+      compiler.reportCodeChange();\n+\n+      indexes.push(index);\n+    }\n+\n+    // Remove actual parameters from all the calls\n+    for (Call call : declaration.calls) {\n+      int currentArg = 0;\n+      Node arg = call.callSide.getFirstChild().getNext();\n+      ListIterator<Integer> itr = indexes.listIterator();\n+\n+      // in forms foo.call(this, a, b) do not consider the first parameter\n+      int rsh = NodeUtil.isFunctionObjectCall(call.callSide) ? 1 : 0;\n+\n+      while (itr.hasNext() && arg != null) {\n+        index = itr.next() + rsh;\n+        while (currentArg < index && arg != null) {\n+          arg = arg.getNext();\n+          ++currentArg;\n+        }\n+\n+        if (arg != null) {\n+          Node temp = arg.getNext();\n+          call.callSide.removeChild(arg);\n+          compiler.reportCodeChange();\n+          ++currentArg;\n+          arg = temp;\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Only certain values may be removed. For example it is not safe to change:\n+   * var foo = function (a) {};\n+   * foo(bar);\n+   * into:\n+   * var foo - function () {var a = bar};\n+   * foo();\n+   */\n+  private boolean checkIsSafeToRemove(FormalParameter parameter) {\n+    return NodeUtil.isLiteralValue(parameter.initialValue, false);\n+  }\n+\n+  /**\n+   * Node equality as intended by the this pass.\n+   * @param n1 A node\n+   * @param n2 A node\n+   * @return true if both node are considered equal for the purposes of this\n+   * class, false otherwise.\n+   */\n+  private boolean nodesAreEqual(Node n1, Node n2) {\n+    return NodeUtil.isImmutableValue(n1) && NodeUtil.isImmutableValue(n2) &&\n+        n1.checkTreeEqualsSilent(n2);\n+  }\n+\n+}", "timestamp": 1285181411, "metainfo": ""}