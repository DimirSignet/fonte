{"sha": "d7e85b0997ebb3d920c977de7a4a3f8ede5ba2d8", "log": "Add basic \"free call\" annotation and support for issue 180.  Additional testing is required to validate that new CALL nodes are not inappropriately introduced.  Also, refactored PrepareAst to make the different actions being taken easier to follow.  R=nicksantos DELTA=215  (120 added, 18 deleted, 77 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=52003   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n       }\n \n       case Token.CALL:\n-        // If the left hand side of the call is a direct reference to eval,\n+        // We have two special cases here:\n+        // 1) If the left hand side of the call is a direct reference to eval,\n         // then it must have a DIRECT_EVAL annotation. If it does not, then\n         // that means it was originally an indirect call to eval, and that\n         // indirectness must be preserved.\n-        if (first.getType() == Token.NAME &&\n-            \"eval\".equals(first.getString()) &&\n-            !first.getBooleanProp(Node.DIRECT_EVAL)) {\n-          add(\"(0,eval)\");\n+        // 2) If the left hand side of the call is a property reference,\n+        // then the call must not a FREE_CALL annotation. If it does, then\n+        // that means it was originally an call without an explicit this and\n+        // that must be preserved.\n+        if (isIndirectEval(first)\n+            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n+          add(\"(0,\");\n+          addExpr(first, NodeUtil.precedence(Token.COMMA));\n+          add(\")\");\n         } else {\n           addLeftExpr(first, NodeUtil.precedence(type), context);\n         }\n     }\n \n     cc.endSourceMapping(n);\n+  }\n+\n+  /**\n+   * @return Whether the name is an indirect eval.\n+   */\n+  private boolean isIndirectEval(Node n) {\n+    return n.getType() == Token.NAME && \"eval\".equals(n.getString()) &&\n+        !n.getBooleanProp(Node.DIRECT_EVAL);\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/PrepareAst.java\n+++ b/src/com/google/javascript/jscomp/PrepareAst.java\n       this.convention = compiler.getCodingConvention();\n     }\n \n-    /**\n-     *\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      switch (n.getType()) {\n+        case Token.CALL:\n+          annotateCalls(n);\n+          break;\n+\n+        case Token.FUNCTION:\n+          annotateFunctions(n, parent);\n+          annotateDispatchers(n, parent);\n+          break;\n+\n+        case Token.NAME:\n+        case Token.STRING:\n+          annotateConstants(n, parent);\n+          break;\n+\n+        case Token.OBJECTLIT:\n+          normalizeObjectLitJsDocs(n);\n+          break;\n+      }\n+    }\n+\n+    /**\n+     * There are two types of calls we are interested in calls without explicit\n+     * \"this\" values (what we are call \"free\" calls) and direct call to eval.\n+     */\n+    private void annotateCalls(Node n) {\n+      Preconditions.checkState(n.getType() == Token.CALL);\n+\n+      // Keep track of of the \"this\" context of a call.  A call without an\n+      // explicit \"this\" is a free call.\n+      Node first = n.getFirstChild();\n+      if (!NodeUtil.isGet(first)) {\n+        n.putBooleanProp(Node.FREE_CALL, true);\n+      }\n+\n+      // Keep track of the context in which eval is called. It is important\n+      // to distinguish between \"(0, eval)()\" and \"eval()\".\n+      if (first.getType() == Token.NAME &&\n+          \"eval\".equals(first.getString())) {\n+        first.putBooleanProp(Node.DIRECT_EVAL, true);\n+      }\n+    }\n+\n+    /**\n+     * Translate dispatcher info into the property expected node.\n+     */\n+    private void annotateDispatchers(Node n, Node parent) {\n+      Preconditions.checkState(n.getType() == Token.FUNCTION);\n+      if (parent.getJSDocInfo() != null\n+          && parent.getJSDocInfo().isJavaDispatch()) {\n+        if (parent.getType() == Token.ASSIGN) {\n+          Preconditions.checkState(parent.getLastChild() == n);\n+          n.putBooleanProp(Node.IS_DISPATCHER, true);\n+        }\n+      }\n+    }\n+\n+    /**\n      * In the AST that Rhino gives us, it needs to make a distinction\n      * between jsdoc on the object literal node and jsdoc on the object literal\n      * value. For example,\n      * But in few narrow cases (in particular, function literals), it's\n      * a lot easier for us if the doc is attached to the value.\n      */\n-    @SuppressWarnings(\"fallthrough\")\n-    public void visit(NodeTraversal t, Node n, Node parent) {\n-      int nType = n.getType();\n-      switch (nType) {\n-        case Token.STRING:\n-          // There are only two cases where a string token\n-          // may be a variable reference: The right side of a GETPROP\n-          // or an OBJECTLIT key.\n-          if (parent.getType() != Token.OBJECTLIT &&\n-              parent.getType() != Token.GETPROP) {\n-            break;\n-          }\n-          // fall-through\n-\n-        case Token.NAME:\n-          String nString = n.getString();\n-          if (nType == Token.NAME &&\n-              n.getParent().getType() == Token.CALL &&\n-              \"eval\".equals(nString)) {\n-            n.putBooleanProp(Node.DIRECT_EVAL, true);\n-          }\n-          if (NodeUtil.isConstantByConvention(convention, n, parent)) {\n-            n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n-          }\n-          break;\n-\n-        case Token.FUNCTION:\n-          JSDocInfo fnInfo = n.getJSDocInfo();\n-          if (fnInfo == null) {\n-            // Look for the info on other nodes.\n-            if (parent.getType() == Token.ASSIGN) {\n-              // on ASSIGNs\n-              fnInfo = parent.getJSDocInfo();\n-            } else if (parent.getType() == Token.NAME) {\n-              // on var NAME = function() { ... };\n-              fnInfo = parent.getParent().getJSDocInfo();\n-            }\n-          }\n-\n-          // Compute which function parameters are optional and\n-          // which are var_args.\n-          Node args = n.getFirstChild().getNext();\n-          for (Node arg = args.getFirstChild();\n-               arg != null;\n-               arg = arg.getNext()) {\n-            String argName = arg.getString();\n-            JSTypeExpression typeExpr = fnInfo == null ?\n-                null : fnInfo.getParameterType(argName);\n-\n-            if (convention.isOptionalParameter(arg) ||\n-                typeExpr != null && typeExpr.isOptionalArg()) {\n-              arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n-            }\n-            if (convention.isVarArgsParameter(arg) ||\n-                typeExpr != null && typeExpr.isVarArgs()) {\n-              arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n-            }\n-          }\n-          break;\n-\n-        case Token.OBJECTLIT:\n-          if (n.getType() == Token.OBJECTLIT) {\n-            for (Node key = n.getFirstChild();\n-                 key != null; key = key.getNext().getNext()) {\n-              Node value = key.getNext();\n-              if (key.getJSDocInfo() != null &&\n-                  key.getNext().getType() == Token.FUNCTION) {\n-                value.setJSDocInfo(key.getJSDocInfo());\n-              }\n-            }\n-          }\n-          break;\n-      }\n-\n-      // TODO(johnlenz): Determine if it is possible to simply use the javadoc\n-      // everywhere rather than use IS_DISPATCHER.\n-      /*\n-       * Translate dispatcher info into the property expected node.\n-       */\n-      if (n.getJSDocInfo() != null && n.getJSDocInfo().isJavaDispatch()) {\n-        if (n.getType() == Token.ASSIGN) {\n-          Node fnNode = n.getLastChild();\n-          Preconditions.checkState(fnNode.getType() == Token.FUNCTION);\n-          fnNode.putBooleanProp(Node.IS_DISPATCHER, true);\n-        }\n-      }\n-    }\n+    private void normalizeObjectLitJsDocs(Node n) {\n+      Preconditions.checkState(n.getType() == Token.OBJECTLIT);\n+      for (Node key = n.getFirstChild();\n+           key != null; key = key.getNext().getNext()) {\n+        Node value = key.getNext();\n+        if (key.getJSDocInfo() != null &&\n+            key.getNext().getType() == Token.FUNCTION) {\n+          value.setJSDocInfo(key.getJSDocInfo());\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Mark names that are constants by convention.\n+     */\n+    private void annotateConstants(Node n, Node parent) {\n+      Preconditions.checkState(\n+          n.getType() == Token.NAME || n.getType() == Token.STRING);\n+\n+      // There are only two cases where a string token\n+      // may be a variable reference: The right side of a GETPROP\n+      // or an OBJECTLIT key.\n+      if (n.getType() != Token.STRING\n+          || parent.getType() == Token.OBJECTLIT\n+          || parent.getType() == Token.GETPROP) {\n+        if (NodeUtil.isConstantByConvention(convention, n, parent)) {\n+          n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Annotate optional and var_arg function parameters.\n+     */\n+    private void annotateFunctions(Node n, Node parent) {\n+      Preconditions.checkState(n.getType() == Token.FUNCTION);\n+      JSDocInfo fnInfo = n.getJSDocInfo();\n+      if (fnInfo == null) {\n+        // Look for the info on other nodes.\n+        if (parent.getType() == Token.ASSIGN) {\n+          // on ASSIGNs\n+          fnInfo = parent.getJSDocInfo();\n+        } else if (parent.getType() == Token.NAME) {\n+          // on var NAME = function() { ... };\n+          fnInfo = parent.getParent().getJSDocInfo();\n+        }\n+      }\n+\n+      // Compute which function parameters are optional and\n+      // which are var_args.\n+      Node args = n.getFirstChild().getNext();\n+      for (Node arg = args.getFirstChild();\n+           arg != null;\n+           arg = arg.getNext()) {\n+        String argName = arg.getString();\n+        JSTypeExpression typeExpr = fnInfo == null ?\n+            null : fnInfo.getParameterType(argName);\n+\n+        if (convention.isOptionalParameter(arg) ||\n+            typeExpr != null && typeExpr.isOptionalArg()) {\n+          arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n+        }\n+        if (convention.isVarArgsParameter(arg) ||\n+            typeExpr != null && typeExpr.isVarArgs()) {\n+          arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n+        }\n+      }\n+    }\n+\n   }\n }\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n       SUPPRESSIONS       = 50,    // Used by the compiler to associate\n                                   // @suppress directly with functions\n                                   // and scripts.\n-      LAST_PROP          = 50;\n+      FREE_CALL          = 51,    // A CALL without an explicit \"this\" value.\n+                                  //\n+      LAST_PROP          = 51;\n \n   // values of ISNUMBER_PROP to specify\n   // which of the children are Number types\n         case IS_DISPATCHER:      return \"is_dispatcher\";\n         case DIRECTIVES:         return \"directives\";\n         case DIRECT_EVAL:        return \"direct_eval\";\n+        case FREE_CALL:          return \"free_call\";\n         default:\n           Kit.codeBug();\n       }\n--- a/test/com/google/javascript/jscomp/CodePrinterTest.java\n+++ b/test/com/google/javascript/jscomp/CodePrinterTest.java\n \n     assertPrint(\"if(x)A:do{foo()}while(y);\",\n         \"if(x){A:do foo();while(y)}\");\n-    \n+\n     assertPrint(\"var i = 0;a: do{b: do{i++;break b;} while(0);} while(0);\",\n         \"var i=0;a:do{b:do{i++;break b}while(0)}while(0)\");\n   }\n         Node.DIRECT_EVAL, false);\n     assertPrintNode(\"(0,eval)(\\\"1\\\")\", n);\n   }\n+\n+  public void testFreeCall1() {\n+    assertPrint(\"foo(a);\", \"foo(a)\");\n+    assertPrint(\"x.foo(a);\", \"x.foo(a)\");\n+  }\n+\n+  public void testFreeCall2() {\n+    Node n = parse(\"foo(a);\");\n+    assertPrintNode(\"foo(a)\", n);\n+    Node call =  n.getFirstChild().getFirstChild();\n+    assertTrue(call.getType() == Token.CALL);\n+    call.putBooleanProp(Node.FREE_CALL, true);\n+    assertPrintNode(\"foo(a)\", n);\n+  }\n+\n+  public void testFreeCall3() {\n+    Node n = parse(\"x.foo(a);\");\n+    assertPrintNode(\"x.foo(a)\", n);\n+    Node call =  n.getFirstChild().getFirstChild();\n+    assertTrue(call.getType() == Token.CALL);\n+    call.putBooleanProp(Node.FREE_CALL, true);\n+    assertPrintNode(\"(0,x.foo)(a)\", n);\n+  }\n }\n--- a/test/com/google/javascript/jscomp/PrepareAstTest.java\n+++ b/test/com/google/javascript/jscomp/PrepareAstTest.java\n \n package com.google.javascript.jscomp;\n \n+import com.google.common.base.Preconditions;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n     assertNull(secondKey.getJSDocInfo());\n     assertNotNull(secondVal.getJSDocInfo());\n   }\n+\n+  public void testFreeCall1() throws Exception {\n+    Node root = parseExpectedJs(\"foo();\");\n+    Node script = root.getFirstChild();\n+    Preconditions.checkState(script.getType() == Token.SCRIPT);\n+    Node firstExpr = script.getFirstChild();\n+    Node call = firstExpr.getFirstChild();\n+    Preconditions.checkState(call.getType() == Token.CALL);\n+\n+    assertTrue(call.getBooleanProp(Node.FREE_CALL));\n+  }\n+\n+  public void testFreeCall2() throws Exception {\n+    Node root = parseExpectedJs(\"x.foo();\");\n+    Node script = root.getFirstChild();\n+    Preconditions.checkState(script.getType() == Token.SCRIPT);\n+    Node firstExpr = script.getFirstChild();\n+    Node call = firstExpr.getFirstChild();\n+    Preconditions.checkState(call.getType() == Token.CALL);\n+\n+    assertFalse(call.getBooleanProp(Node.FREE_CALL));\n+  }\n }", "timestamp": 1279229656, "metainfo": ""}