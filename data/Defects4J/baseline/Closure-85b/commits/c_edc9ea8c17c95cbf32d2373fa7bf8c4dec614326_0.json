{"sha": "edc9ea8c17c95cbf32d2373fa7bf8c4dec614326", "log": "Folds away the string constructor if it's inside a GETELEM node. Contributed by Tim Wintle. Fixes issue 238  Revision created by MOE tool push_codebase.  R=johnlenz DELTA=89  (89 added, 0 deleted, 0 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=221400   ", "commit": "\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n     switch(subtree.getType()) {\n       case Token.CALL:\n         return tryFoldKnownMethods(subtree);\n+\n+      case Token.NEW:\n+        return tryFoldCtorCall(subtree);\n \n       case Token.TYPEOF:\n         return tryFoldTypeof(subtree);\n     return newNode;\n   }\n \n+  /**\n+   * Try to fold away unnecessary object instantiation.\n+   * e.g. this[new String('eval')] -> this.eval\n+   */\n+  private Node tryFoldCtorCall(Node n) {\n+    Preconditions.checkArgument(n.getType() == Token.NEW);\n+\n+    // we can remove this for GETELEM calls (anywhere else?)\n+    if (inForcedStringContext(n)) {\n+      return tryFoldInForcedStringContext(n);\n+    }\n+    return n;\n+  }\n+\n+  /** Returns whether this node must be coerced to a string. */\n+  private boolean inForcedStringContext(Node n) {\n+    return n.getParent().getType() == Token.GETELEM &&\n+        n.getParent().getLastChild() == n;\n+  }\n+\n+  private Node tryFoldInForcedStringContext(Node n) {\n+    // For now, we only know how to fold ctors.\n+    Preconditions.checkArgument(n.getType() == Token.NEW);\n+\n+    Node objectType = n.getFirstChild();\n+    if (objectType.getType() != Token.NAME) {\n+      return n;\n+    }\n+\n+    if (objectType.getString().equals(\"String\")) {\n+      Node value = objectType.getNext();\n+      String stringValue = null;\n+      if (value == null) {\n+        stringValue = \"\";\n+      } else {\n+        if (!NodeUtil.isImmutableValue(value)) {\n+          return n;\n+        }\n+\n+        stringValue = NodeUtil.getStringValue(value);\n+      }\n+\n+      if (stringValue == null) {\n+        return n;\n+      }\n+\n+      Node parent = n.getParent();\n+      Node newString = Node.newString(stringValue);\n+\n+      parent.replaceChild(n, newString);\n+      newString.copyInformationFrom(parent);\n+      reportCodeChange();\n+\n+      return newString;\n+    }\n+    return n;\n+  }\n+\n   private Node tryFoldKnownMethods(Node subtree) {\n     // For now we only support .join() and .indexOf()\n \n--- a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n     fold(\"x = '' + []\", \"x = \\\"\\\"+[]\");      // cannot fold (but nice if we can)\n   }\n \n+  public void testFoldConstructor() {\n+    fold(\"x = this[new String('a')]\", \"x = this['a']\");\n+    fold(\"x = ob[new String(12)]\", \"x = ob['12']\");\n+    fold(\"x = ob[new String(false)]\", \"x = ob['false']\");\n+    fold(\"x = ob[new String(null)]\", \"x = ob['null']\");\n+    foldSame(\"x = ob[new String(a)]\");\n+    foldSame(\"x = new String('a')\");\n+    foldSame(\"x = (new String('a'))[3]\");\n+  }\n+\n   public void testStringIndexOf() {\n     fold(\"x = 'abcdef'.indexOf('b')\", \"x = 1\");\n     fold(\"x = 'abcdefbe'.indexOf('b', 2)\", \"x = 6\");", "timestamp": 1284587110, "metainfo": ""}