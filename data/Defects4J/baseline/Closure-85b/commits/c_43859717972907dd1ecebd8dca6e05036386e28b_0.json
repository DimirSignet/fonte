{"sha": "43859717972907dd1ecebd8dca6e05036386e28b", "log": "Change on 2010/04/14 by john          Stop creating specialized Node types for FUNCTION and SCRIPT as the added functionality isn't used anywhere.          Also correct some formatting issue with Node (as it won't need to be merged with anything else anymore).          R=steve,robert         DELTA=3969  (1913 added, 1925 deleted, 131 changed)  Change on 2010/04/14 by john          Fix source information in MinimizeExitPoints.          R=robert         DELTA=10  (5 added, 2 deleted, 3 changed)  Change on 2010/04/14 by john          Maintain source information.          R=antonio         DELTA=17  (11 added, 0 deleted, 6 changed)  Change on 2010/04/14 by john          Maintain source information through FoldConstants.          R=robert         DELTA=42  (22 added, 0 deleted, 20 changed)  Change on 2010/04/14 by nick          lock down function type construction          R=john         DELTA=111  (83 added, 9 deleted, 19 changed)  Change on 2010/04/14 by john          Fix source info in CollapseProperties.          R=nick         DELTA=17  (8 added, 3 deleted, 6 changed)    Revision created by MOE tool push_codebase. MOE_MIGRATION=mbevwz   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AliasExternals.java\n+++ b/src/com/google/javascript/jscomp/AliasExternals.java\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n-import com.google.javascript.rhino.FunctionNode;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n     */\n \n     // Function name node\n-    Node functionName = Node.newString(Token.NAME,\n-      getMutatorFor(propName));\n+    String functionName = getMutatorFor(propName);\n \n     // Function arguments\n     String localPropName = getMutatorFor(propName) + \"$a\";\n     String localValueName = getMutatorFor(propName) + \"$b\";\n     Node hasPropNode = Node.newString(Token.NAME, localPropName);\n     Node propValueNode = Node.newString(Token.NAME, localValueName);\n-    Node args = new Node(Token.LP, hasPropNode, propValueNode);\n+    List<Node> args = Lists.newArrayList(hasPropNode, propValueNode);\n \n     // Function body\n     Node propNameNode = Node.newString(Token.NAME, localPropName);\n     Node assignFrom = Node.newString(Token.NAME, localValueName);\n     Node assign = new Node(Token.ASSIGN, getProp, assignFrom);\n     Node returnNode = new Node(Token.RETURN, assign);\n-    Node functionBlock = new Node(Token.BLOCK, returnNode);\n+    Node functionBody = new Node(Token.BLOCK, returnNode);\n \n     // Create the function and append to front of output tree\n-    FunctionNode fnNode = new FunctionNode(functionName.getString());\n-    // A hack to preserve the existing Compiler code that depends on\n-    // having the first child node being a NAME node.\n-    // TODO(user): Remove this for the final merge with Rhino and adjust the\n-    // rest of Compiler to know about the new location of function names.\n-    fnNode.addChildToBack(functionName);\n-    fnNode.addChildToBack(args);\n-    fnNode.addChildToBack(functionBlock);\n+    Node fnNode = NodeUtil.newFunctionNode(\n+        functionName, args, functionBody, -1, -1);\n     root.addChildToFront(fnNode);\n \n     compiler.reportCodeChange();\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n         break;\n \n       case Token.FUNCTION:\n+        if (n.getClass() != Node.class) {\n+          throw new Error(\"Unexpected Node subclass.\"); \n+        }        \n         Preconditions.checkState(childCount == 3);\n         boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n         if (funcNeedsParens) {\n \n       case Token.SCRIPT:\n       case Token.BLOCK: {\n+        if (n.getClass() != Node.class) {\n+          throw new Error(\"Unexpected Node subclass.\"); \n+        }\n         boolean stripBlock = n.isSyntheticBlock() ||\n             ((context != Context.PRESERVE_BLOCK) && (n.getChildCount() < 2));\n         if (!stripBlock) {\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n \n       // Create a stub variable declaration right\n       // before the current statement.\n-      Node stubVar = new Node(Token.VAR, nameNode.cloneTree());\n+      Node stubVar = new Node(Token.VAR, nameNode.cloneTree())\n+          .copyInformationFrom(nameNode);\n       currentParent.addChildBefore(stubVar, current);\n \n       parent.replaceChild(ref.node, nameNode);\n       if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n         nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n       }\n-      Node newVar = new Node(Token.VAR, nameNode);\n+      Node newVar = new Node(Token.VAR, nameNode)\n+          .copyInformationFromForTree(key);\n       if (nameToAddAfter != null) {\n         varParent.addChildAfter(newVar, nameToAddAfter);\n       } else {\n   private int addStubsForUndeclaredProperties(\n       Name n, String alias, Node parent, Node addAfter) {\n     Preconditions.checkArgument(NodeUtil.isStatementBlock(parent));\n+    Preconditions.checkNotNull(addAfter);\n     int numStubs = 0;\n     if (n.props != null) {\n       for (Name p : n.props) {\n         if (p.needsToBeStubbed()) {\n           String propAlias = appendPropForAlias(alias, p.name);\n           Node nameNode = Node.newString(Token.NAME, propAlias);\n-          Node newVar = new Node(Token.VAR, nameNode);\n-          if (addAfter == null) {\n-            parent.addChildToFront(newVar);\n-          } else {\n-            parent.addChildAfter(newVar, addAfter);\n-            addAfter = newVar;\n-          }\n+          Node newVar = new Node(Token.VAR, nameNode)\n+              .copyInformationFromForTree(addAfter);\n+          parent.addChildAfter(newVar, addAfter);\n+          addAfter = newVar;\n           numStubs++;\n           compiler.reportCodeChange();\n \n--- a/src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java\n+++ b/src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java\n       Node objectNode = node.getFirstChild();\n       node.removeChild(objectNode);\n       parent.replaceChild(node, objectNode);\n-      parent.addChildToFront(Node.newString(Token.NAME, newMethodName));\n+      parent.addChildToFront(\n+          Node.newString(Token.NAME, newMethodName)\n+              .copyInformationFrom(node));\n       compiler.reportCodeChange();\n     }\n   }\n     Node expr = parent.getParent();\n     Node block = expr.getParent();\n \n-    Node newNameNode = Node.newString(Token.NAME, newMethodName);\n+    Node newNameNode = Node.newString(Token.NAME, newMethodName)\n+        .copyInformationFrom(parent.getFirstChild());\n     parent.removeChild(functionNode);\n     newNameNode.addChildToFront(functionNode);\n     block.replaceChild(expr, new Node(Token.VAR, newNameNode));\n     // add extra argument\n     String self = newMethodName + \"$self\";\n     Node argList = functionNode.getFirstChild().getNext();\n-    argList.addChildToFront(Node.newString(Token.NAME, self));\n+    argList.addChildToFront(Node.newString(Token.NAME, self)\n+        .copyInformationFrom(functionNode));\n \n     // rewrite body\n     Node body = functionNode.getLastChild();\n--- a/src/com/google/javascript/jscomp/FoldConstants.java\n+++ b/src/com/google/javascript/jscomp/FoldConstants.java\n             cond.removeChild(expr);\n             ifNode.addChildToBack(expr);\n           } else {\n-            Node not = new Node(Token.NOT);\n+            Node not = new Node(Token.NOT).copyInformationFrom(cond);\n             n.removeChild(cond);\n             not.addChildToBack(cond);\n             ifNode.addChildToBack(not);\n \n           n.removeChild(elseBody);\n           ifNode.addChildToBack(\n-              new Node(Token.BLOCK, NodeUtil.newExpr(elseBody)));\n+              new Node(Token.BLOCK, NodeUtil.newExpr(elseBody))\n+                  .copyInformationFrom(elseBody));\n           parent.getParent().replaceChild(parent, ifNode);\n           t.getCompiler().reportCodeChange();\n           return true;\n           n.removeChild(thenBody);\n \n           ifNode.addChildToBack(\n-              new Node(Token.BLOCK, NodeUtil.newExpr(thenBody)));\n+              new Node(Token.BLOCK, NodeUtil.newExpr(thenBody))\n+                  .copyInformationFrom(thenBody));\n           parent.getParent().replaceChild(parent, ifNode);\n           t.getCompiler().reportCodeChange();\n           return true;\n           }\n \n           Node or = new Node(Token.OR, cond.removeFirstChild(),\n-              expr.removeFirstChild());\n+          expr.removeFirstChild()).copyInformationFrom(n);\n           Node newExpr = NodeUtil.newExpr(or);\n           parent.replaceChild(n, newExpr);\n           t.getCompiler().reportCodeChange();\n         }\n \n         n.removeChild(cond);\n-        Node and = new Node(Token.AND, cond, expr.removeFirstChild());\n+        Node and = new Node(Token.AND, cond, expr.removeFirstChild())\n+                       .copyInformationFrom(n);\n         Node newExpr = NodeUtil.newExpr(and);\n         parent.replaceChild(n, newExpr);\n         t.getCompiler().reportCodeChange();\n       // note - we ignore any cases with \"return;\", technically this\n       // can be converted to \"return undefined;\" or some variant, but\n       // that does not help code size.\n-      Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr);\n+      Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)\n+                          .copyInformationFrom(n);\n       Node returnNode = new Node(Token.RETURN, hookNode);\n       parent.replaceChild(n, returnNode);\n       t.getCompiler().reportCodeChange();\n             Node elseExpr = elseOp.getLastChild();\n             elseOp.removeChild(elseExpr);\n \n-            Node hookNode = new Node(Token.HOOK, cond, thenExpr,\n-                elseExpr);\n-            Node assign = new Node(thenOp.getType(), assignName,\n-                hookNode);\n+            Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)\n+                                .copyInformationFrom(n);\n+            Node assign = new Node(thenOp.getType(), assignName, hookNode)\n+                              .copyInformationFrom(thenOp);\n             Node expr = NodeUtil.newExpr(assign);\n             parent.replaceChild(n, expr);\n             t.getCompiler().reportCodeChange();\n           n.removeChild(cond);\n           thenOp.detachFromParent();\n           elseOp.detachFromParent();\n-          Node hookNode = new Node(Token.HOOK, cond, thenOp, elseOp);\n+          Node hookNode = new Node(Token.HOOK, cond, thenOp, elseOp)\n+                              .copyInformationFrom(n);\n           Node expr = NodeUtil.newExpr(hookNode);\n           parent.replaceChild(n, expr);\n           t.getCompiler().reportCodeChange();\n         Node thenExpr = name1.removeChildren();\n         Node elseExpr = elseAssign.getLastChild().detachFromParent();\n         cond.detachFromParent();\n-        Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr);\n+        Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)\n+                            .copyInformationFrom(n);\n         var.detachFromParent();\n         name1.addChildrenToBack(hookNode);\n         parent.replaceChild(n, var);\n         Node thenExpr = thenAssign.getLastChild().detachFromParent();\n         Node elseExpr = name2.removeChildren();\n         cond.detachFromParent();\n-        Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr);\n+        Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)\n+                            .copyInformationFrom(n);\n         var.detachFromParent();\n         name2.addChildrenToBack(hookNode);\n         parent.replaceChild(n, var);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n     StringBuilder sb = null;\n     int foldedSize = 0;\n+    Node prev = null;\n     Node elem = arrayNode.getFirstChild();\n     // Merges adjacent String nodes.\n     while (elem != null) {\n         sb.append(NodeUtil.getStringValue(elem));\n       } else {\n         if (sb != null) {\n+          Preconditions.checkNotNull(prev);\n           // + 2 for the quotes.\n           foldedSize += sb.length() + 2;\n-          arrayFoldedChildren.add(Node.newString(sb.toString()));\n+          arrayFoldedChildren.add(\n+              Node.newString(sb.toString()).copyInformationFrom(prev));\n           sb = null;\n         }\n         foldedSize += InlineCostEstimator.getCost(elem);\n         arrayFoldedChildren.add(elem);\n       }\n+      prev = elem;\n       elem = elem.getNext();\n     }\n \n     if (sb != null) {\n+      Preconditions.checkNotNull(prev);\n       // + 2 for the quotes.\n       foldedSize += sb.length() + 2;\n-      arrayFoldedChildren.add(Node.newString(sb.toString()));\n+      arrayFoldedChildren.add(\n+          Node.newString(sb.toString()).copyInformationFrom(prev));\n     }\n     // one for each comma.\n     foldedSize += arrayFoldedChildren.size() - 1;\n           // If the Node is not a string literal, ensure that\n           // it is coerced to a string.\n           Node replacement = new Node(Token.ADD,\n-              Node.newString(\"\"), foldedStringNode);\n+              Node.newString(\"\").copyInformationFrom(right), \n+              foldedStringNode);\n           foldedStringNode = replacement;\n         }\n         parent.replaceChild(n, foldedStringNode);\n     if (null == sb) { return n.cloneTree(); }\n \n     sb.append(s, pos, s.length());\n-    return Node.newString(sb.toString());\n+    return Node.newString(sb.toString()).copyInformationFrom(n);\n   }\n \n   /**\n--- a/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n+++ b/src/com/google/javascript/jscomp/FunctionTypeBuilder.java\n       }\n       maybeSetBaseType(fnType);\n     } else {\n-      fnType = new FunctionType(typeRegistry, fnName, sourceNode,\n+      fnType = typeRegistry.createMethodTypeWithTypeTemplate(\n+          fnName, sourceNode,\n           parametersNode, returnType, thisType, templateTypeName);\n       maybeSetBaseType(fnType);\n     }\n--- a/src/com/google/javascript/jscomp/GatherSideEffectSubexpressionsCallback.java\n+++ b/src/com/google/javascript/jscomp/GatherSideEffectSubexpressionsCallback.java\n         int type = thenHasSideEffects ? Token.AND : Token.OR;\n         Node body = thenHasSideEffects ? thenBranch : elseBranch;\n         Node simplified = new Node(\n-            type, condition.cloneTree(), simplifyShortCircuitBranch(body));\n+            type, condition.cloneTree(), simplifyShortCircuitBranch(body))\n+            .copyInformationFrom(hook);\n         replacements.add(simplified);\n       } else {\n         throw new IllegalArgumentException(\n       Node ret = null;\n       for (Node part : parts) {\n         if (ret != null) {\n-          ret = new Node(Token.COMMA, ret, part);\n+          ret = new Node(Token.COMMA, ret, part).copyInformationFrom(node);\n         } else {\n           ret = part;\n         }\n--- a/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n+++ b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n         break;\n       }\n     }\n-\n-    return;\n   }\n \n   /**\n    * Look for exits (returns, breaks, or continues, depending on the context) at\n-   * the end of a block removes them by moving the if node's siblings, if any,\n-   * into the opposite condition block.\n+   * the end of a block and removes them by moving the if node's siblings, \n+   * if any, into the opposite condition block.\n    *\n    * @param srcBlock The block to inspect.\n    * @param destBlock The block to move sibling nodes into.\n     if (ifNode.getNext() != null) {\n       // Move siblings of the if block into the opposite\n       // logic block of the exit.\n-      Node newDestBlock = new Node(Token.BLOCK);\n+      Node newDestBlock = new Node(Token.BLOCK).copyInformationFrom(ifNode);\n       if (destBlock == null) {\n         // Only possible if this is the false block.\n         ifNode.addChildToBack(newDestBlock);\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n import com.google.common.base.Predicates;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Maps;\n-import com.google.javascript.rhino.FunctionNode;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n    * @return Newly created EXPR node with the child as subexpression.\n    */\n   public static Node newExpr(Node child) {\n-    Node expr = new Node(Token.EXPR_RESULT, child);\n-    expr.copyInformationFrom(child);\n+    Node expr = new Node(Token.EXPR_RESULT, child)\n+        .copyInformationFrom(child);\n     return expr;\n   }\n \n     Node parent = getAddingRoot(branch);\n     for (Node nameNode : vars) {\n       Node var = new Node(\n-          Token.VAR, Node.newString(Token.NAME, nameNode.getString()));\n+          Token.VAR,\n+          Node.newString(Token.NAME, nameNode.getString())\n+              .copyInformationFrom(nameNode))\n+          .copyInformationFrom(nameNode);\n       copyNameAnnotations(nameNode, var.getFirstChild());\n       parent.addChildToFront(var);\n     }\n   }\n \n   /** Creates function name(params_0, ..., params_n) { body }. */\n-  public static FunctionNode newFunctionNode(String name, List<Node> params,\n+  public static Node newFunctionNode(String name, List<Node> params,\n       Node body, int lineno, int charno) {\n     Node parameterParen = new Node(Token.LP, lineno, charno);\n     for (Node param : params) {\n       parameterParen.addChildToBack(param);\n     }\n-    FunctionNode function = new FunctionNode(name, lineno, charno);\n+    Node function = new Node(Token.FUNCTION, lineno, charno);\n     function.addChildrenToBack(\n         Node.newString(Token.NAME, name, lineno, charno));\n     function.addChildToBack(parameterParen);\n--- a/src/com/google/javascript/jscomp/RemoveConstantExpressions.java\n+++ b/src/com/google/javascript/jscomp/RemoveConstantExpressions.java\n \n       List<Node> replacements = Lists.newArrayList();\n       for (Node subexpression : subexpressions) {\n-        replacements.add(new Node(Token.EXPR_RESULT, subexpression));\n+        replacements.add(NodeUtil.newExpr(subexpression));\n       }\n       return replacements;\n     }\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n                     // The new type will be picked up when we traverse the inner\n                     // function.\n                     jArgument.setJSType(\n-                        new FunctionType(\n-                            registry, jArgumentFnType.getReferenceName(),\n-                            jArgumentFnType.getSource(),\n-                            jArgumentFnType.getParametersNode(),\n-                            jArgumentFnType.getReturnType(),\n-                            (ObjectType) iArgumentType));\n+                        registry.createFunctionTypeWithNewThisType(\n+                            jArgumentFnType, (ObjectType) iArgumentType));\n                   }\n                 }\n                 // TODO(user): Add code to TypeCheck to check that the\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n               FunctionType functionType = objectType.getConstructor();\n \n               if (functionType != null) {\n-                FunctionType getterType = new FunctionType(\n-                    typeRegistry, null, null,\n-                    new FunctionParamBuilder(typeRegistry).build(),\n-                    objectType, null);\n+                FunctionType getterType =\n+                    typeRegistry.createFunctionType(objectType);\n                 codingConvention.applySingletonGetter(functionType, getterType,\n                                                       objectType);\n               }\n                     new FunctionParamBuilder(typeRegistry);\n                 functionParamBuilder.addRequiredParams(\n                     typeRegistry.getNativeType(U2U_CONSTRUCTOR_TYPE));\n-                FunctionType findDelegate = new FunctionType(\n-                    typeRegistry, null, null, functionParamBuilder.build(),\n+                FunctionType findDelegate = typeRegistry.createFunctionType(\n                     typeRegistry.createDefaultObjectUnion(\n-                        delegateBaseObject), null);\n+                        delegateBaseObject),\n+                    functionParamBuilder.build());\n \n                 FunctionType delegateProxy =\n                     typeRegistry.createConstructorType(\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n import com.google.javascript.jscomp.mozilla.rhino.ast.WithStatement;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.ScriptOrFnNode;\n import com.google.javascript.rhino.Token;\n \n import java.util.Collection;\n \n     @Override\n     Node processAstRoot(AstRoot rootNode) {\n-      Node node = new ScriptOrFnNode(Token.SCRIPT);\n+      Node node = new Node(Token.SCRIPT);\n       for (com.google.javascript.jscomp.mozilla.rhino.Node child : rootNode) {\n         node.addChildToBack(transform((AstNode)child));\n       }\n         name.setIdentifier(\"\");\n         isUnnamedFunction = true;\n       }\n-      Node node = new com.google.javascript.rhino.FunctionNode(\n-          name.getIdentifier());\n+      Node node = new Node(Token.FUNCTION);\n       node.putProp(Node.SOURCENAME_PROP, functionNode.getSourceName());\n       Node newName = transform(name);\n       if (isUnnamedFunction) {\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n *\n  */\n \n-public class Node implements Cloneable, Serializable\n-{\n+public class Node implements Cloneable, Serializable {\n+\n+  private static final long serialVersionUID = 1L;\n+\n+  public static final int\n+      // Rhino's AST captures data flow. These are the annotations\n+      // it used. We've mostly torn them out.\n+      LOCAL_BLOCK_PROP  = -3,\n+      OBJECT_IDS_PROP   = -2,\n+      CATCH_SCOPE_PROP  = -1,\n+      LABEL_ID_PROP     =  0,\n+\n+      TARGET_PROP       =  1,\n+      BREAK_PROP        =  2,\n+      CONTINUE_PROP     =  3,\n+      ENUM_PROP         =  4,\n+      FUNCTION_PROP     =  5,\n+      TEMP_PROP         =  6,\n+      LOCAL_PROP        =  7,\n+      CODEOFFSET_PROP   =  8,\n+      FIXUPS_PROP       =  9,\n+      VARS_PROP         = 10,\n+      USES_PROP         = 11,\n+      REGEXP_PROP       = 12,\n+      CASES_PROP        = 13,\n+      DEFAULT_PROP      = 14,\n+      CASEARRAY_PROP    = 15,\n+      SOURCENAME_PROP   = 16,\n+      TYPE_PROP         = 17,\n+      SPECIAL_PROP_PROP = 18,\n+      LABEL_PROP        = 19,\n+      FINALLY_PROP      = 20,\n+      LOCALCOUNT_PROP   = 21,\n+  /*\n+      the following properties are defined and manipulated by the\n+      optimizer -\n+      TARGETBLOCK_PROP - the block referenced by a branch node\n+      VARIABLE_PROP - the variable referenced by a BIND or NAME node\n+      LASTUSE_PROP - that variable node is the last reference before\n+                      a new def or the end of the block\n+      ISNUMBER_PROP - this node generates code on Number children and\n+                      delivers a Number result (as opposed to Objects)\n+      DIRECTCALL_PROP - this call node should emit code to test the function\n+                        object against the known class and call diret if it\n+                        matches.\n+  */\n+\n+      TARGETBLOCK_PROP  = 22,\n+      VARIABLE_PROP     = 23,\n+      LASTUSE_PROP      = 24,\n+      ISNUMBER_PROP     = 25,\n+      DIRECTCALL_PROP   = 26,\n+\n+      SPECIALCALL_PROP  = 27,\n+      DEBUGSOURCE_PROP  = 28,\n+      JSDOC_INFO_PROP   = 29,     // contains a TokenStream.JSDocInfo object\n+      VAR_ARGS_NAME     = 29,     // the name node is a variable length\n+                                  // argument placeholder. It can never be\n+                                  // used in conjunction with JSDOC_INFO_PROP.\n+      SKIP_INDEXES_PROP  = 30,    // array of skipped indexes of array literal\n+      INCRDECR_PROP      = 31,    // pre or post type of increment/decrement\n+      MEMBER_TYPE_PROP   = 32,    // type of element access operation\n+      NAME_PROP          = 33,    // property name\n+      PARENTHESIZED_PROP = 34,    // expression is parenthesized\n+      QUOTED_PROP        = 35,    // set to indicate a quoted object lit key\n+      OPT_ARG_NAME       = 36,    // The name node is an optional argument.\n+      SYNTHETIC_BLOCK_PROP = 37,  // A synthetic block. Used to make\n+                                  // processing simpler, and does not\n+                                  // represent a real block in the source.\n+      SOURCEFILE_PROP    = 38,    // Contains the path of the source file\n+                                  // from which the current node was parsed.\n+      EMPTY_BLOCK        = 39,    // Used to indicate BLOCK that replaced\n+                                  // EMPTY nodes.\n+      ORIGINALNAME_PROP  = 40,    // The original name of the node, before\n+                                  // renaming.\n+      BRACELESS_TYPE     = 41,    // The type syntax without curly braces.\n+      NO_SIDE_EFFECTS_CALL = 42,  // Function or constructor call has no\n+                                  // side effects.\n+      // Coding convention props\n+      IS_CONSTANT_NAME   = 43,    // The variable or property is constant.\n+      IS_OPTIONAL_PARAM  = 44,    // The parameter is optional.\n+      IS_VAR_ARGS_PARAM  = 45,    // The parameter is a var_args.\n+      IS_NAMESPACE       = 46,    // The variable creates a namespace.\n+      IS_DISPATCHER      = 47,    // The function is a dispatcher function,\n+                                  // probably generated from Java code, and\n+                                  // should be resolved to the proper\n+                                  // overload if possible.\n+      DIRECTIVES         = 48,    // The ES5 directives on this node.\n+      DIRECT_EVAL        = 49,    // ES5 distinguishes between direct and\n+                                  // indirect calls to eval.\n+      LAST_PROP          = 49;\n+\n+  // values of ISNUMBER_PROP to specify\n+  // which of the children are Number types\n+  public static final int\n+      BOTH = 0,\n+      LEFT = 1,\n+      RIGHT = 2;\n+\n+  public static final int    // values for SPECIALCALL_PROP\n+      NON_SPECIALCALL  = 0,\n+      SPECIALCALL_EVAL = 1,\n+      SPECIALCALL_WITH = 2;\n+\n+  public static final int   // flags for INCRDECR_PROP\n+      DECR_FLAG = 0x1,\n+      POST_FLAG = 0x2;\n+\n+  public static final int   // flags for MEMBER_TYPE_PROP\n+      PROPERTY_FLAG    = 0x1, // property access: element is valid name\n+      ATTRIBUTE_FLAG   = 0x2, // x.@y or x..@y\n+      DESCENDANTS_FLAG = 0x4; // x..y or x..@i\n+\n+  private static final String propToString(int propType) {\n+      switch (propType) {\n+        case LOCAL_BLOCK_PROP:   return \"local_block\";\n+        case OBJECT_IDS_PROP:    return \"object_ids_prop\";\n+        case CATCH_SCOPE_PROP:   return \"catch_scope_prop\";\n+        case LABEL_ID_PROP:      return \"label_id_prop\";\n+        case TARGET_PROP:        return \"target\";\n+        case BREAK_PROP:         return \"break\";\n+        case CONTINUE_PROP:      return \"continue\";\n+        case ENUM_PROP:          return \"enum\";\n+        case FUNCTION_PROP:      return \"function\";\n+        case TEMP_PROP:          return \"temp\";\n+        case LOCAL_PROP:         return \"local\";\n+        case CODEOFFSET_PROP:    return \"codeoffset\";\n+        case FIXUPS_PROP:        return \"fixups\";\n+        case VARS_PROP:          return \"vars\";\n+        case USES_PROP:          return \"uses\";\n+        case REGEXP_PROP:        return \"regexp\";\n+        case CASES_PROP:         return \"cases\";\n+        case DEFAULT_PROP:       return \"default\";\n+        case CASEARRAY_PROP:     return \"casearray\";\n+        case SOURCENAME_PROP:    return \"sourcename\";\n+        case TYPE_PROP:          return \"type\";\n+        case SPECIAL_PROP_PROP:  return \"special_prop\";\n+        case LABEL_PROP:         return \"label\";\n+        case FINALLY_PROP:       return \"finally\";\n+        case LOCALCOUNT_PROP:    return \"localcount\";\n+\n+        case TARGETBLOCK_PROP:   return \"targetblock\";\n+        case VARIABLE_PROP:      return \"variable\";\n+        case LASTUSE_PROP:       return \"lastuse\";\n+        case ISNUMBER_PROP:      return \"isnumber\";\n+        case DIRECTCALL_PROP:    return \"directcall\";\n+\n+        case SPECIALCALL_PROP:   return \"specialcall\";\n+        case DEBUGSOURCE_PROP:   return \"debugsource\";\n+\n+        case JSDOC_INFO_PROP:    return \"jsdoc_info\";\n+\n+        case SKIP_INDEXES_PROP:  return \"skip_indexes\";\n+        case INCRDECR_PROP:      return \"incrdecr\";\n+        case MEMBER_TYPE_PROP:   return \"member_type\";\n+        case NAME_PROP:          return \"name\";\n+        case PARENTHESIZED_PROP: return \"parenthesized\";\n+        case QUOTED_PROP:        return \"quoted\";\n+\n+        case SYNTHETIC_BLOCK_PROP: return \"synthetic\";\n+        case SOURCEFILE_PROP: return \"sourcefile\";\n+        case EMPTY_BLOCK: return \"empty_block\";\n+        case ORIGINALNAME_PROP: return \"originalname\";\n+        case NO_SIDE_EFFECTS_CALL: return \"no_side_effects_call\";\n+\n+        case IS_CONSTANT_NAME:   return \"is_constant_name\";\n+        case IS_OPTIONAL_PARAM:  return \"is_optional_param\";\n+        case IS_VAR_ARGS_PARAM:  return \"is_var_args_param\";\n+        case IS_NAMESPACE:       return \"is_namespace\";\n+        case IS_DISPATCHER:      return \"is_dispatcher\";\n+        case DIRECTIVES:         return \"directives\";\n+        case DIRECT_EVAL:        return \"direct_eval\";\n+        default:\n+          Kit.codeBug();\n+      }\n+      return null;\n+  }\n+\n+  private static class NumberNode extends Node {\n \n     private static final long serialVersionUID = 1L;\n \n-    public static final int\n-        // Rhino's AST captures data flow. These are the annotations\n-        // it used. We've mostly torn them out.\n-        LOCAL_BLOCK_PROP  = -3,\n-        OBJECT_IDS_PROP   = -2,\n-        CATCH_SCOPE_PROP  = -1,\n-        LABEL_ID_PROP     =  0,\n-\n-        TARGET_PROP       =  1,\n-        BREAK_PROP        =  2,\n-        CONTINUE_PROP     =  3,\n-        ENUM_PROP         =  4,\n-        FUNCTION_PROP     =  5,\n-        TEMP_PROP         =  6,\n-        LOCAL_PROP        =  7,\n-        CODEOFFSET_PROP   =  8,\n-        FIXUPS_PROP       =  9,\n-        VARS_PROP         = 10,\n-        USES_PROP         = 11,\n-        REGEXP_PROP       = 12,\n-        CASES_PROP        = 13,\n-        DEFAULT_PROP      = 14,\n-        CASEARRAY_PROP    = 15,\n-        SOURCENAME_PROP   = 16,\n-        TYPE_PROP         = 17,\n-        SPECIAL_PROP_PROP = 18,\n-        LABEL_PROP        = 19,\n-        FINALLY_PROP      = 20,\n-        LOCALCOUNT_PROP   = 21,\n-    /*\n-        the following properties are defined and manipulated by the\n-        optimizer -\n-        TARGETBLOCK_PROP - the block referenced by a branch node\n-        VARIABLE_PROP - the variable referenced by a BIND or NAME node\n-        LASTUSE_PROP - that variable node is the last reference before\n-                        a new def or the end of the block\n-        ISNUMBER_PROP - this node generates code on Number children and\n-                        delivers a Number result (as opposed to Objects)\n-        DIRECTCALL_PROP - this call node should emit code to test the function\n-                          object against the known class and call diret if it\n-                          matches.\n-    */\n-\n-        TARGETBLOCK_PROP  = 22,\n-        VARIABLE_PROP     = 23,\n-        LASTUSE_PROP      = 24,\n-        ISNUMBER_PROP     = 25,\n-        DIRECTCALL_PROP   = 26,\n-\n-        SPECIALCALL_PROP  = 27,\n-        DEBUGSOURCE_PROP  = 28,\n-        JSDOC_INFO_PROP   = 29,     // contains a TokenStream.JSDocInfo object\n-        VAR_ARGS_NAME     = 29,     // the name node is a variable length\n-                                    // argument placeholder. It can never be\n-                                    // used in conjunction with JSDOC_INFO_PROP.\n-        SKIP_INDEXES_PROP  = 30,    // array of skipped indexes of array literal\n-        INCRDECR_PROP      = 31,    // pre or post type of increment/decrement\n-        MEMBER_TYPE_PROP   = 32,    // type of element access operation\n-        NAME_PROP          = 33,    // property name\n-        PARENTHESIZED_PROP = 34,    // expression is parenthesized\n-        QUOTED_PROP        = 35,    // set to indicate a quoted object lit key\n-        OPT_ARG_NAME       = 36,    // The name node is an optional argument.\n-        SYNTHETIC_BLOCK_PROP = 37,  // A synthetic block. Used to make\n-                                    // processing simpler, and does not\n-                                    // represent a real block in the source.\n-        SOURCEFILE_PROP    = 38,    // Contains the path of the source file\n-                                    // from which the current node was parsed.\n-        EMPTY_BLOCK        = 39,    // Used to indicate BLOCK that replaced\n-                                    // EMPTY nodes.\n-        ORIGINALNAME_PROP  = 40,    // The original name of the node, before\n-                                    // renaming.\n-        BRACELESS_TYPE     = 41,    // The type syntax without curly braces.\n-        NO_SIDE_EFFECTS_CALL = 42,  // Function or constructor call has no\n-                                    // side effects.\n-        // Coding convention props\n-        IS_CONSTANT_NAME   = 43,    // The variable or property is constant.\n-        IS_OPTIONAL_PARAM  = 44,    // The parameter is optional.\n-        IS_VAR_ARGS_PARAM  = 45,    // The parameter is a var_args.\n-        IS_NAMESPACE       = 46,    // The variable creates a namespace.\n-        IS_DISPATCHER      = 47,    // The function is a dispatcher function,\n-                                    // probably generated from Java code, and\n-                                    // should be resolved to the proper\n-                                    // overload if possible.\n-        DIRECTIVES         = 48,    // The ES5 directives on this node.\n-        DIRECT_EVAL        = 49,    // ES5 distinguishes between direct and\n-                                    // indirect calls to eval.\n-        LAST_PROP          = 49;\n-\n-    // values of ISNUMBER_PROP to specify\n-    // which of the children are Number types\n-    public static final int\n-        BOTH = 0,\n-        LEFT = 1,\n-        RIGHT = 2;\n-\n-    public static final int    // values for SPECIALCALL_PROP\n-        NON_SPECIALCALL  = 0,\n-        SPECIALCALL_EVAL = 1,\n-        SPECIALCALL_WITH = 2;\n-\n-    public static final int   // flags for INCRDECR_PROP\n-        DECR_FLAG = 0x1,\n-        POST_FLAG = 0x2;\n-\n-    public static final int   // flags for MEMBER_TYPE_PROP\n-        PROPERTY_FLAG    = 0x1, // property access: element is valid name\n-        ATTRIBUTE_FLAG   = 0x2, // x.@y or x..@y\n-        DESCENDANTS_FLAG = 0x4; // x..y or x..@i\n-\n-    private static final String propToString(int propType) {\n-        switch (propType) {\n-            case LOCAL_BLOCK_PROP:   return \"local_block\";\n-            case OBJECT_IDS_PROP:    return \"object_ids_prop\";\n-            case CATCH_SCOPE_PROP:   return \"catch_scope_prop\";\n-            case LABEL_ID_PROP:      return \"label_id_prop\";\n-            case TARGET_PROP:        return \"target\";\n-            case BREAK_PROP:         return \"break\";\n-            case CONTINUE_PROP:      return \"continue\";\n-            case ENUM_PROP:          return \"enum\";\n-            case FUNCTION_PROP:      return \"function\";\n-            case TEMP_PROP:          return \"temp\";\n-            case LOCAL_PROP:         return \"local\";\n-            case CODEOFFSET_PROP:    return \"codeoffset\";\n-            case FIXUPS_PROP:        return \"fixups\";\n-            case VARS_PROP:          return \"vars\";\n-            case USES_PROP:          return \"uses\";\n-            case REGEXP_PROP:        return \"regexp\";\n-            case CASES_PROP:         return \"cases\";\n-            case DEFAULT_PROP:       return \"default\";\n-            case CASEARRAY_PROP:     return \"casearray\";\n-            case SOURCENAME_PROP:    return \"sourcename\";\n-            case TYPE_PROP:          return \"type\";\n-            case SPECIAL_PROP_PROP:  return \"special_prop\";\n-            case LABEL_PROP:         return \"label\";\n-            case FINALLY_PROP:       return \"finally\";\n-            case LOCALCOUNT_PROP:    return \"localcount\";\n-\n-            case TARGETBLOCK_PROP:   return \"targetblock\";\n-            case VARIABLE_PROP:      return \"variable\";\n-            case LASTUSE_PROP:       return \"lastuse\";\n-            case ISNUMBER_PROP:      return \"isnumber\";\n-            case DIRECTCALL_PROP:    return \"directcall\";\n-\n-            case SPECIALCALL_PROP:   return \"specialcall\";\n-            case DEBUGSOURCE_PROP:   return \"debugsource\";\n-\n-            case JSDOC_INFO_PROP:    return \"jsdoc_info\";\n-\n-            case SKIP_INDEXES_PROP:  return \"skip_indexes\";\n-            case INCRDECR_PROP:      return \"incrdecr\";\n-            case MEMBER_TYPE_PROP:   return \"member_type\";\n-            case NAME_PROP:          return \"name\";\n-            case PARENTHESIZED_PROP: return \"parenthesized\";\n-            case QUOTED_PROP:        return \"quoted\";\n-\n-            case SYNTHETIC_BLOCK_PROP: return \"synthetic\";\n-            case SOURCEFILE_PROP: return \"sourcefile\";\n-            case EMPTY_BLOCK: return \"empty_block\";\n-            case ORIGINALNAME_PROP: return \"originalname\";\n-            case NO_SIDE_EFFECTS_CALL: return \"no_side_effects_call\";\n-\n-            case IS_CONSTANT_NAME:   return \"is_constant_name\";\n-            case IS_OPTIONAL_PARAM:  return \"is_optional_param\";\n-            case IS_VAR_ARGS_PARAM:  return \"is_var_args_param\";\n-            case IS_NAMESPACE:       return \"is_namespace\";\n-            case IS_DISPATCHER:      return \"is_dispatcher\";\n-            case DIRECTIVES:         return \"directives\";\n-            case DIRECT_EVAL:        return \"direct_eval\";\n-            default:\n-              Kit.codeBug();\n-\n-\n-        }\n-        return null;\n-    }\n-\n-    private static class NumberNode extends Node {\n-\n-        private static final long serialVersionUID = 1L;\n-\n-        NumberNode(double number) {\n-            super(Token.NUMBER);\n-            this.number = number;\n-        }\n-\n-        public NumberNode(double number, int lineno, int charno) {\n-            super(Token.NUMBER, lineno, charno);\n-            this.number = number;\n-        }\n-\n-        @Override public double getDouble() {\n-          return this.number;\n-        }\n-\n-        @Override public void setDouble(double d) {\n-          this.number = d;\n-        }\n-\n-        @Override public boolean isEquivalentTo(Node node) {\n-            return (node instanceof NumberNode\n-                    && getDouble() == ((NumberNode) node).getDouble());\n-        }\n-\n-        private double number;\n-    }\n-\n-    private static class StringNode extends Node {\n-\n-        private static final long serialVersionUID = 1L;\n-\n-        StringNode(int type, String str) {\n-            super(type);\n-            if (null == str) {\n-                throw new IllegalArgumentException(\"StringNode: str is null\");\n-            }\n-            this.str = str;\n-        }\n-\n-        StringNode(int type, String str, int lineno, int charno) {\n-            super(type, lineno, charno);\n-            if (null == str) {\n-                throw new IllegalArgumentException(\"StringNode: str is null\");\n-            }\n-            this.str = str;\n-        }\n-\n-        /** returns the string content.\n-          * @return non null.\n-          */\n-        @Override public String getString() {\n-            return this.str;\n-        }\n-\n-        /** sets the string content.\n-          * @param str the new value.  Non null.\n-          */\n-        @Override public void setString(String str) {\n-            if (null == str) {\n-                throw new IllegalArgumentException(\"StringNode: str is null\");\n-            }\n-            this.str = str;\n-        }\n-\n-        @Override public boolean isEquivalentTo(Node node) {\n-            return (node instanceof StringNode &&\n-                    this.str.equals(((StringNode) node).str));\n-        }\n-\n-        /**\n-         * If the property is not defined, this was not a quoted key.  The\n-         * QUOTED_PROP int property is only assigned to STRING tokens used as\n-         * object lit keys.\n-         * @return true if this was a quoted string key in an object literal.\n-         */\n-        @Override public boolean isQuotedString() {\n-            return getBooleanProp(QUOTED_PROP);\n-        }\n-\n-        /**\n-         * This should only be called for STRING nodes created in object lits.\n-         */\n-        @Override public void setQuotedString() {\n-            putBooleanProp(QUOTED_PROP, true);\n-        }\n-\n-        private String str;\n-    }\n-\n-    private static class PropListItem implements Serializable\n-    {\n-        private static final long serialVersionUID = 1L;\n-\n-        PropListItem next;\n-        int type;\n-        int intValue;\n-        Object objectValue;\n-    }\n-\n-\n-    public Node(int nodeType) {\n-        type = nodeType;\n-        parent = null;\n-        sourcePosition = -1;\n-    }\n-\n-    public Node(int nodeType, Node child) {\n-        Preconditions.checkArgument(child.parent == null,\n-            \"new child has existing parent\");\n-        Preconditions.checkArgument(child.next == null,\n-            \"new child has existing sibling\");\n-\n-        type = nodeType;\n-        parent = null;\n-        first = last = child;\n-        child.next = null;\n-        child.parent = this;\n-        sourcePosition = -1;\n-    }\n-\n-    public Node(int nodeType, Node left, Node right) {\n-        Preconditions.checkArgument(left.parent == null,\n-            \"first new child has existing parent\");\n-        Preconditions.checkArgument(left.next == null,\n-            \"first new child has existing sibling\");\n-        Preconditions.checkArgument(right.parent == null,\n-            \"second new child has existing parent\");\n-        Preconditions.checkArgument(right.next == null,\n-            \"second new child has existing sibling\");\n-        type = nodeType;\n-        parent = null;\n-        first = left;\n-        last = right;\n-        left.next = right;\n-        left.parent = this;\n-        right.next = null;\n-        right.parent = this;\n-        sourcePosition = -1;\n-    }\n-\n-    public Node(int nodeType, Node left, Node mid, Node right) {\n-        Preconditions.checkArgument(left.parent == null);\n-        Preconditions.checkArgument(left.next == null);\n-        Preconditions.checkArgument(mid.parent == null);\n-        Preconditions.checkArgument(mid.next == null);\n-        Preconditions.checkArgument(right.parent == null);\n-        Preconditions.checkArgument(right.next == null);\n-        type = nodeType;\n-        parent = null;\n-        first = left;\n-        last = right;\n-        left.next = mid;\n-        left.parent = this;\n-        mid.next = right;\n-        mid.parent = this;\n-        right.next = null;\n-        right.parent = this;\n-        sourcePosition = -1;\n-    }\n-\n-    public Node(int nodeType, Node left, Node mid, Node mid2, Node right) {\n-      Preconditions.checkArgument(left.parent == null);\n-      Preconditions.checkArgument(left.next == null);\n-      Preconditions.checkArgument(mid.parent == null);\n-      Preconditions.checkArgument(mid.next == null);\n-      Preconditions.checkArgument(mid2.parent == null);\n-      Preconditions.checkArgument(mid2.next == null);\n-      Preconditions.checkArgument(right.parent == null);\n-      Preconditions.checkArgument(right.next == null);\n-      type = nodeType;\n-      parent = null;\n-      first = left;\n-      last = right;\n-      left.next = mid;\n-      left.parent = this;\n-      mid.next = mid2;\n-      mid.parent = this;\n-      mid2.next = right;\n-      mid2.parent = this;\n-      right.next = null;\n-      right.parent = this;\n-      sourcePosition = -1;\n-    }\n-\n-    public Node(int nodeType, int lineno, int charno) {\n-        type = nodeType;\n-        parent = null;\n-        sourcePosition = mergeLineCharNo(lineno, charno);\n-    }\n-\n-    public Node(int nodeType, Node child, int lineno, int charno) {\n-        this(nodeType, child);\n-        sourcePosition = mergeLineCharNo(lineno, charno);\n-    }\n-\n-    public Node(int nodeType, Node left, Node right, int lineno, int charno) {\n-        this(nodeType, left, right);\n-        sourcePosition = mergeLineCharNo(lineno, charno);\n-    }\n-\n-    public Node(int nodeType, Node left, Node mid, Node right,\n-            int lineno, int charno) {\n-        this(nodeType, left, mid, right);\n-        sourcePosition = mergeLineCharNo(lineno, charno);\n-    }\n-\n-    public Node(int nodeType, Node left, Node mid, Node mid2, Node right,\n-            int lineno, int charno) {\n-        this(nodeType, left, mid, mid2, right);\n-        sourcePosition = mergeLineCharNo(lineno, charno);\n-    }\n-\n-    public Node(int nodeType, Node[] children, int lineno, int charno) {\n-        this(nodeType, children);\n-        sourcePosition = mergeLineCharNo(lineno, charno);\n-    }\n-\n-    public Node(int nodeType, Node[] children) {\n-        this.type = nodeType;\n-        parent = null;\n-        if (children.length != 0) {\n-            this.first = children[0];\n-            this.last = children[children.length - 1];\n-\n-            for (int i = 1; i < children.length; i++) {\n-                if (null != children[i - 1].next) {\n-                    // fail early on loops.  implies same node in array twice\n-                    throw new IllegalArgumentException(\"duplicate child\");\n-                }\n-                children[i - 1].next = children[i];\n-                Preconditions.checkArgument(children[i - 1].parent == null);\n-                children[i - 1].parent = this;\n-            }\n-            Preconditions.checkArgument(\n-                children[children.length - 1].parent == null);\n-            children[children.length - 1].parent = this;\n-\n-            if (null != this.last.next) {\n-                // fail early on loops.  implies same node in array twice\n-                throw new IllegalArgumentException(\"duplicate child\");\n-            }\n-        }\n-    }\n-\n-    public static Node newNumber(double number) {\n-        return new NumberNode(number);\n-    }\n-\n-    public static Node newNumber(double number, int lineno, int charno) {\n-        return new NumberNode(number, lineno, charno);\n-    }\n-\n-    public static Node newString(String str) {\n-        return new StringNode(Token.STRING, str);\n-    }\n-\n-    public static Node newString(int type, String str) {\n-        return new StringNode(type, str);\n-    }\n-\n-    public static Node newString(String str, int lineno, int charno) {\n-        return new StringNode(Token.STRING, str, lineno, charno);\n-    }\n-\n-    public static Node newString(int type, String str, int lineno, int charno) {\n-        return new StringNode(type, str, lineno, charno);\n-    }\n-\n-    public int getType() {\n-        return type;\n-    }\n-\n-    public void setType(int type) {\n-        this.type = type;\n-    }\n-\n-    public boolean hasChildren() {\n-        return first != null;\n-    }\n-\n-    public Node getFirstChild() {\n-        return first;\n-    }\n-\n-    public Node getLastChild() {\n-        return last;\n-    }\n-\n-    public Node getNext() {\n-        return next;\n-    }\n-\n-    public Node getChildBefore(Node child) {\n-        if (child == first)\n-            return null;\n-        Node n = first;\n-        while (n.next != child) {\n-            n = n.next;\n-            if (n == null)\n-                throw new RuntimeException(\"node is not a child\");\n-        }\n-        return n;\n-    }\n-\n-    public Node getChildAtIndex(int i) {\n-      Node n = first;\n-      while (i > 0) {\n-        n = n.next;\n-        i--;\n-      }\n-      return n;\n-    }\n-\n-    public Node getLastSibling() {\n-        Node n = this;\n-        while (n.next != null) {\n-            n = n.next;\n-        }\n-        return n;\n-    }\n-\n-    public void addChildToFront(Node child) {\n-        Preconditions.checkArgument(child.parent == null);\n-        Preconditions.checkArgument(child.next == null);\n-        child.parent = this;\n-        child.next = first;\n-        first = child;\n-        if (last == null) {\n-            last = child;\n-        }\n-    }\n-\n-    public void addChildToBack(Node child) {\n-        Preconditions.checkArgument(child.parent == null);\n-        Preconditions.checkArgument(child.next == null);\n-        child.parent = this;\n-        child.next = null;\n-        if (last == null) {\n-            first = last = child;\n-            return;\n-        }\n-        last.next = child;\n-        last = child;\n-    }\n-\n-    public void addChildrenToFront(Node children) {\n-        for (Node child = children; child != null; child = child.next) {\n-          Preconditions.checkArgument(child.parent == null);\n-          child.parent = this;\n-        }\n-        Node lastSib = children.getLastSibling();\n-        lastSib.next = first;\n-        first = children;\n-        if (last == null) {\n-            last = lastSib;\n-        }\n-    }\n-\n-    public void addChildrenToBack(Node children) {\n-        for (Node child = children; child != null; child = child.next) {\n-          Preconditions.checkArgument(child.parent == null);\n-          child.parent = this;\n-        }\n-        if (last != null) {\n-            last.next = children;\n-        }\n-        last = children.getLastSibling();\n-        if (first == null) {\n-            first = children;\n-        }\n+    NumberNode(double number) {\n+      super(Token.NUMBER);\n+      this.number = number;\n+    }\n+\n+    public NumberNode(double number, int lineno, int charno) {\n+      super(Token.NUMBER, lineno, charno);\n+      this.number = number;\n+    }\n+\n+    @Override\n+    public double getDouble() {\n+      return this.number;\n+    }\n+\n+    @Override\n+    public void setDouble(double d) {\n+      this.number = d;\n+    }\n+\n+    @Override\n+    public boolean isEquivalentTo(Node node) {\n+      return (node instanceof NumberNode\n+          && getDouble() == ((NumberNode) node).getDouble());\n+    }\n+\n+    private double number;\n+  }\n+\n+  private static class StringNode extends Node {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    StringNode(int type, String str) {\n+      super(type);\n+      if (null == str) {\n+        throw new IllegalArgumentException(\"StringNode: str is null\");\n+      }\n+      this.str = str;\n+    }\n+\n+    StringNode(int type, String str, int lineno, int charno) {\n+      super(type, lineno, charno);\n+      if (null == str) {\n+        throw new IllegalArgumentException(\"StringNode: str is null\");\n+      }\n+      this.str = str;\n     }\n \n     /**\n-     * Add 'child' before 'node'.\n+     * returns the string content.\n+     * @return non null.\n      */\n-    public void addChildBefore(Node newChild, Node node) {\n-        Preconditions.checkArgument(node != null,\n-            \"The existing child node of the parent should not be null.\");\n-        Preconditions.checkArgument(newChild.next == null,\n-            \"The new child node has siblings.\");\n-        Preconditions.checkArgument(newChild.parent == null,\n-            \"The new child node already has a parent.\");\n-        if (first == node) {\n-            newChild.parent = this;\n-            newChild.next = first;\n-            first = newChild;\n-            return;\n-        }\n-        Node prev = getChildBefore(node);\n-        addChildAfter(newChild, prev);\n+    @Override\n+    public String getString() {\n+      return this.str;\n     }\n \n     /**\n-     * Add 'child' after 'node'.\n+     * sets the string content.\n+     * @param str the new value.  Non null.\n      */\n-    public void addChildAfter(Node newChild, Node node) {\n-        Preconditions.checkArgument(newChild.next == null,\n-            \"The new child node has siblings.\");\n-        Preconditions.checkArgument(newChild.parent == null,\n-            \"The new child node already has a parent.\");\n-        newChild.parent = this;\n-        newChild.next = node.next;\n-        node.next = newChild;\n-        if (last == node) {\n-            last = newChild;\n-        }\n+    @Override\n+    public void setString(String str) {\n+      if (null == str) {\n+        throw new IllegalArgumentException(\"StringNode: str is null\");\n+      }\n+      this.str = str;\n+    }\n+\n+    @Override\n+    public boolean isEquivalentTo(Node node) {\n+      return (node instanceof StringNode &&\n+         this.str.equals(((StringNode) node).str));\n     }\n \n     /**\n-     * Detach a child from its parent and siblings.\n+     * If the property is not defined, this was not a quoted key.  The\n+     * QUOTED_PROP int property is only assigned to STRING tokens used as\n+     * object lit keys.\n+     * @return true if this was a quoted string key in an object literal.\n      */\n-    public void removeChild(Node child) {\n-        Node prev = getChildBefore(child);\n-        if (prev == null)\n-            first = first.next;\n-        else\n-            prev.next = child.next;\n-        if (child == last) last = prev;\n-        child.next = null;\n-        child.parent = null;\n-    }\n-\n-    /**\n-     * Detaches child from Node and replaces it with newChild.\n-     */\n-    public void replaceChild(Node child, Node newChild) {\n-        Preconditions.checkArgument(newChild.next == null,\n-            \"The new child node has siblings.\");\n-        Preconditions.checkArgument(newChild.parent == null,\n-            \"The new child node already has a parent.\");\n-\n-        // Copy over important information.\n-        newChild.copyInformationFrom(child);\n-\n-        newChild.next = child.next;\n-        newChild.parent = this;\n-        if (child == first) {\n-            first = newChild;\n-        } else {\n-            Node prev = getChildBefore(child);\n-            prev.next = newChild;\n-        }\n-        if (child == last)\n-            last = newChild;\n-        child.next = null;\n-        child.parent = null;\n-    }\n-\n-    public void replaceChildAfter(Node prevChild, Node newChild) {\n-        Preconditions.checkArgument(prevChild.parent == this,\n-          \"prev is not a child of this node.\");\n-\n-        Preconditions.checkArgument(newChild.next == null,\n-            \"The new child node has siblings.\");\n-        Preconditions.checkArgument(newChild.parent == null,\n-            \"The new child node already has a parent.\");\n-\n-        // Copy over important information.\n-        newChild.copyInformationFrom(prevChild);\n-\n-        Node child = prevChild.next;\n-        newChild.next = child.next;\n-        newChild.parent = this;\n-        prevChild.next = newChild;\n-        if (child == last)\n-            last = newChild;\n-        child.next = null;\n-        child.parent = null;\n-    }\n-\n-    private PropListItem lookupProperty(int propType)\n-    {\n-        PropListItem x = propListHead;\n-        while (x != null && propType != x.type) {\n-            x = x.next;\n-        }\n-        return x;\n-    }\n-\n-    private PropListItem ensureProperty(int propType)\n-    {\n-        PropListItem item = lookupProperty(propType);\n-        if (item == null) {\n-            item = new PropListItem();\n-            item.type = propType;\n-            item.next = propListHead;\n-            propListHead = item;\n-        }\n-        return item;\n-    }\n-\n-    public void removeProp(int propType)\n-    {\n-        PropListItem x = propListHead;\n-        if (x != null) {\n-            PropListItem prev = null;\n-            while (x.type != propType) {\n-                prev = x;\n-                x = x.next;\n-                if (x == null) { return; }\n-            }\n-            if (prev == null) {\n-                propListHead = x.next;\n-            } else {\n-                prev.next = x.next;\n-            }\n-        }\n-    }\n-\n-    public Object getProp(int propType)\n-    {\n-        PropListItem item = lookupProperty(propType);\n-        if (item == null) { return null; }\n-        return item.objectValue;\n-    }\n-\n-    public boolean getBooleanProp(int propType) {\n-        return getIntProp(propType, 0) != 0;\n-    }\n-\n-    public int getIntProp(int propType, int defaultValue)\n-    {\n-        PropListItem item = lookupProperty(propType);\n-        if (item == null) { return defaultValue; }\n-        return item.intValue;\n-    }\n-\n-    public int getExistingIntProp(int propType)\n-    {\n-        PropListItem item = lookupProperty(propType);\n-        if (item == null) { Kit.codeBug(); }\n-        return item.intValue;\n-    }\n-\n-    public void putProp(int propType, Object prop)\n-    {\n-        if (prop == null) {\n-            removeProp(propType);\n-        } else {\n-            PropListItem item = ensureProperty(propType);\n-            item.objectValue = prop;\n-        }\n-    }\n-\n-    public void putBooleanProp(int propType, boolean prop) {\n-        putIntProp(propType, prop ? 1 : 0);\n-    }\n-\n-    public void putIntProp(int propType, int prop)\n-    {\n-        PropListItem item = ensureProperty(propType);\n-        item.intValue = prop;\n-    }\n-\n-    // Gets all the property types, in sorted order.\n-    private int[] getSortedPropTypes() {\n-        int count = 0;\n-        for (PropListItem x = propListHead; x != null; x = x.next) {\n-            count++;\n-        }\n-\n-        int[] keys = new int[count];\n-        for (PropListItem x = propListHead; x != null; x = x.next) {\n-            count--;\n-            keys[count] = x.type;\n-        }\n-\n-        Arrays.sort(keys);\n-        return keys;\n-    }\n-\n-    public int getLineno() {\n-        return extractLineno(sourcePosition);\n-    }\n-\n-    public int getCharno() {\n-        return extractCharno(sourcePosition);\n-    }\n-\n-    /** Can only be called when <tt>getType() == TokenStream.NUMBER</tt> */\n-    public double getDouble() throws UnsupportedOperationException {\n-        if (this.getType() == Token.NUMBER) {\n-            throw new IllegalStateException(\n-                    \"Number node not created with Node.newNumber\");\n-        } else {\n-            throw new UnsupportedOperationException(\n-                    this + \" is not a number node\");\n-        }\n-    }\n-\n-    /** Can only be called when <tt>getType() == TokenStream.NUMBER</tt> */\n-    public void setDouble(double s) throws UnsupportedOperationException {\n-        if (this.getType() == Token.NUMBER) {\n-            throw new IllegalStateException(\n-                    \"Number node not created with Node.newNumber\");\n-        } else {\n-            throw new UnsupportedOperationException(\n-                    this + \" is not a string node\");\n-        }\n-    }\n-\n-    /** Can only be called when node has String context. */\n-    public String getString() throws UnsupportedOperationException {\n-        if (this.getType() == Token.STRING) {\n-            throw new IllegalStateException(\n-                    \"String node not created with Node.newString\");\n-        } else {\n-            throw new UnsupportedOperationException(\n-                    this + \" is not a string node\");\n-        }\n-    }\n-\n-    /** Can only be called when node has String context. */\n-    public void setString(String s) throws UnsupportedOperationException {\n-        if (this.getType() == Token.STRING) {\n-            throw new IllegalStateException(\n-                    \"String node not created with Node.newString\");\n-        } else {\n-            throw new UnsupportedOperationException(\n-                    this + \" is not a string node\");\n-        }\n-    }\n-\n-    @Override public String toString()\n-    {\n-       return toString(true, true, true);\n-    }\n-\n-    public String toString(\n-        boolean printSource,\n-        boolean printAnnotations,\n-        boolean printType)\n-    {\n-        if (Token.printTrees) {\n-            StringBuilder sb = new StringBuilder();\n-            toString(sb, printSource, printAnnotations, printType);\n-            return sb.toString();\n-        }\n-        return String.valueOf(type);\n-    }\n-\n-    private void toString(\n-        StringBuilder sb,\n-        boolean printSource,\n-        boolean printAnnotations,\n-        boolean printType)\n-    {\n-        if (Token.printTrees) {\n-            sb.append(Token.name(type));\n-            if (this instanceof StringNode) {\n-                sb.append(' ');\n-                sb.append(getString());\n-            } else if (type == Token.FUNCTION) {\n-                sb.append(' ');\n-                sb.append(first.getString());\n-            } else if (this instanceof ScriptOrFnNode) {\n-                ScriptOrFnNode sof = (ScriptOrFnNode)this;\n-                if (this instanceof FunctionNode) {\n-                    FunctionNode fn = (FunctionNode)this;\n-                    sb.append(' ');\n-                    sb.append(fn.getFunctionName());\n-                }\n-                if (printSource) {\n-                  sb.append(\" [source name: \");\n-                  sb.append(sof.getSourceName());\n-                  sb.append(\"] [encoded source length: \");\n-                  sb.append(sof.getEncodedSourceEnd()\n-                            - sof.getEncodedSourceStart());\n-                  sb.append(\"] [base line: \");\n-                  sb.append(sof.getBaseLineno());\n-                  sb.append(\"] [end line: \");\n-                  sb.append(sof.getEndLineno());\n-                  sb.append(']');\n-                }\n-            } else if (type == Token.NUMBER) {\n-                sb.append(' ');\n-                sb.append(getDouble());\n-            }\n-            if (printSource) {\n-              int lineno = getLineno();\n-              if (lineno != -1) {\n-                  sb.append(' ');\n-                  sb.append(lineno);\n-              }\n-            }\n-\n-            if (printAnnotations) {\n-              int[] keys = getSortedPropTypes();\n-              for (int i = 0; i < keys.length; i++) {\n-                  int type = keys[i];\n-                  PropListItem x = lookupProperty(type);\n-                  sb.append(\" [\");\n-                  sb.append(propToString(type));\n-                  sb.append(\": \");\n-                  String value;\n-                  switch (type) {\n-                    case TARGETBLOCK_PROP : // can't add this as it recurses\n-                      value = \"target block property\";\n-                      break;\n-                    case LOCAL_BLOCK_PROP :     // can't add this as it is dull\n-                      value = \"last local block\";\n-                      break;\n-                    case ISNUMBER_PROP:\n-                      switch (x.intValue) {\n-                        case BOTH:\n-                          value = \"both\";\n-                          break;\n-                        case RIGHT:\n-                          value = \"right\";\n-                          break;\n-                        case LEFT:\n-                          value = \"left\";\n-                          break;\n-                        default:\n-                          throw Kit.codeBug();\n-                      }\n-                      break;\n-                    case SPECIALCALL_PROP:\n-                      switch (x.intValue) {\n-                        case SPECIALCALL_EVAL:\n-                          value = \"eval\";\n-                          break;\n-                        case SPECIALCALL_WITH:\n-                          value = \"with\";\n-                          break;\n-                        default:\n-                          // NON_SPECIALCALL should not be stored\n-                          throw Kit.codeBug();\n-                      }\n-                      break;\n-                    default :\n-                      Object obj = x.objectValue;\n-                      if (obj != null) {\n-                          value = obj.toString();\n-                      } else {\n-                          value = String.valueOf(x.intValue);\n-                      }\n-                      break;\n-                  }\n-                  sb.append(value);\n-                  sb.append(']');\n-              }\n-            }\n-\n-            if (printType) {\n-              if (jsType != null) {\n-                  String jsTypeString = jsType.toString();\n-                  if (jsTypeString != null) {\n-                      sb.append(\" : \");\n-                      sb.append(jsTypeString);\n-                  }\n-              }\n-            }\n-        }\n-    }\n-\n-\n-    public String toStringTree() {\n-        return toStringTreeImpl();\n-    }\n-\n-    private String toStringTreeImpl() {\n-        try {\n-            StringBuffer s = new StringBuffer();\n-            appendStringTree(s);\n-            return s.toString();\n-        } catch (IOException e) {\n-            throw new RuntimeException(\"Should not happen\\n\" + e);\n-        }\n-    }\n-\n-    public void appendStringTree(Appendable appendable) throws IOException {\n-        toStringTreeHelper(this, 0, appendable);\n-    }\n-\n-    private static void toStringTreeHelper(Node n, int level, Appendable sb)\n-            throws IOException\n-    {\n-        if (Token.printTrees) {\n-            for (int i = 0; i != level; ++i) {\n-                sb.append(\"    \");\n-            }\n-            sb.append(n.toString());\n-            sb.append('\\n');\n-            for (Node cursor = n.getFirstChild(); cursor != null;\n-                 cursor = cursor.getNext())\n-            {\n-                toStringTreeHelper(cursor, level + 1, sb);\n-            }\n-        }\n-    }\n-\n-    int type;              // type of the node; Token.NAME for example\n-    Node next;             // next sibling\n-    private Node first;    // first element of a linked list of children\n-    private Node last;     // last element of a linked list of children\n-\n-    /**\n-     * Linked list of properties. Since vast majority of nodes would have\n-     * no more then 2 properties, linked list saves memory and provides\n-     * fast lookup. If this does not holds, propListHead can be replaced\n-     * by UintMap.\n-     */\n-    private PropListItem propListHead;\n-\n-    /**\n-     * COLUMN_BITS represents how many of the lower-order bits of\n-     * sourcePosition are reserved for storing the column number.\n-     * Bits above these store the line number.\n-     * This gives us decent position information for everything except\n-     * files already passed through a minimizer, where lines might\n-     * be longer than 4096 characters.\n-     */\n-    public static final int COLUMN_BITS = 12;\n-\n-    /**\n-     * MAX_COLUMN_NUMBER represents the maximum column number that can\n-     * be represented.  JSCompiler's modifications to Rhino cause all\n-     * tokens located beyond the maximum column to MAX_COLUMN_NUMBER.\n-     */\n-    public static final int MAX_COLUMN_NUMBER = (1 << COLUMN_BITS) - 1;\n-\n-    /**\n-     * COLUMN_MASK stores a value where bits storing the column number\n-     * are set, and bits storing the line are not set.  It's handy for\n-     * separating column number from line number.\n-     */\n-    public static final int COLUMN_MASK = MAX_COLUMN_NUMBER;\n-\n-    /**\n-     * Source position of this node. The position is encoded with the\n-     * column number in the low 12 bits of the integer, and the line\n-     * number in the rest.  Create some handy constants so we can change this\n-     * size if we want.\n-     */\n-    private int sourcePosition;\n-\n-    private JSType jsType;\n-\n-    private Node parent;\n-\n-    //==========================================================================\n-    // Source position management\n-\n-    public void setLineno(int lineno) {\n-        int charno = getCharno();\n-        if (charno == -1) {\n-          charno = 0;\n-        }\n-        sourcePosition = mergeLineCharNo(lineno, charno);\n-    }\n-\n-    public void setCharno(int charno) {\n-        sourcePosition = mergeLineCharNo(getLineno(), charno);\n-    }\n-\n-    /**\n-     * Merges the line number and character number in one integer. The Character\n-     * number takes the first 12 bits and the line number takes the rest. If\n-     * the character number is greater than <code>2<sup>12</sup>-1</code> it is\n-     * adjusted to <code>2<sup>12</sup>-1</code>.\n-     */\n-    protected static int mergeLineCharNo(int lineno, int charno) {\n-      if (lineno < 0 || charno < 0) {\n-        return -1;\n-      } else if ((charno & ~COLUMN_MASK) != 0) {\n-        return lineno << COLUMN_BITS | COLUMN_MASK;\n-      } else {\n-        return lineno << COLUMN_BITS | (charno & COLUMN_MASK);\n-      }\n-    }\n-\n-    /**\n-     * Extracts the line number and character number from a merged line char\n-     * number (see {@link #mergeLineCharNo(int, int)}).\n-     */\n-    protected static int extractLineno(int lineCharNo) {\n-      if (lineCharNo == -1) {\n-        return -1;\n-      } else {\n-        return lineCharNo >>> COLUMN_BITS;\n-      }\n-    }\n-\n-    /**\n-     * Extracts the character number and character number from a merged line\n-     * char number (see {@link #mergeLineCharNo(int, int)}).\n-     */\n-    protected static int extractCharno(int lineCharNo) {\n-      if (lineCharNo == -1) {\n-        return -1;\n-      } else {\n-        return lineCharNo & COLUMN_MASK;\n-      }\n-    }\n-\n-    //==========================================================================\n-    // Iteration\n-\n-    /**\n-     * <p>Return an iterable object that iterates over this nodes's children.\n-     * The iterator does not support the optional operation\n-     * {@link Iterator#remove()}.</p>\n-     *\n-     * <p>To iterate over a node's siblings, one can write</p>\n-     * <pre>Node n = ...;\n-     * for (Node child : n.children()) { ...</pre>\n-     */\n-    public Iterable<Node> children() {\n-      if (first == null) {\n-        return Collections.emptySet();\n-      } else {\n-        return new SiblingNodeIterable(first);\n-      }\n-    }\n-\n-    /**\n-     * <p>Return an iterable object that iterates over this nodes's siblings.\n-     * The iterator does not support the optional operation\n-     * {@link Iterator#remove()}.</p>\n-     *\n-     * <p>To iterate over a node's siblings, one can write</p>\n-     * <pre>Node n = ...;\n-     * for (Node sibling : n.siblings()) { ...</pre>\n-     */\n-    public Iterable<Node> siblings() {\n-      return new SiblingNodeIterable(this);\n-    }\n-\n-    /**\n-     * @see Node#siblings()\n-     */\n-    private static final class SiblingNodeIterable\n-       implements Iterable<Node>, Iterator<Node>\n-    {\n-        private final Node start;\n-        private Node current;\n-        private boolean used;\n-\n-        SiblingNodeIterable(Node start) {\n-          this.start = start;\n-          this.current = start;\n-          this.used = false;\n-        }\n-\n-        public Iterator<Node> iterator() {\n-          if (!used) {\n-            used = true;\n-            return this;\n-          } else {\n-            // We have already used the current object as an iterator;\n-            // we must create a new SiblingNodeIterable based on this\n-            // iterable's start node.\n-            //\n-            // Since the primary use case for Node.children is in for\n-            // loops, this branch is extremely unlikely.\n-            return (new SiblingNodeIterable(start)).iterator();\n-          }\n-        }\n-\n-        public boolean hasNext() {\n-            return current != null;\n-        }\n-\n-        public Node next() {\n-            if (current == null) {\n-              throw new NoSuchElementException();\n-            }\n-            try {\n-                return current;\n-            } finally {\n-                current = current.getNext();\n-            }\n-        }\n-\n-        public void remove() {\n-            throw new UnsupportedOperationException();\n-        }\n-    }\n-\n-    //==========================================================================\n-    // Accessors\n-\n-    public Node getParent() {\n-        return parent;\n-    }\n-\n-    /**\n-     * Gets the ancestor node relative to this.\n-     * @param level 0 = this, 1 = the parent, etc.\n-     */\n-    public Node getAncestor(int level) {\n-      Preconditions.checkArgument(level >= 0);\n-      Node node = this;\n-      while(node != null && level-- > 0) {\n-        node = node.getParent();\n-      }\n-      return node;\n-    }\n-\n-    /**\n-     * Iterates all of the node's ancestors excluding itself.\n-     */\n-    public AncestorIterable getAncestors() {\n-      return new AncestorIterable(this.getParent());\n-    }\n-\n-    /**\n-     * Iterator to go up the ancestor tree.\n-     */\n-    public static class AncestorIterable implements Iterable<Node> {\n-      private Node cur;\n-\n-      /**\n-       * @param cur The node to start.\n-       */\n-      AncestorIterable(Node cur) {\n-        this.cur = cur;\n-      }\n-\n-      public Iterator<Node> iterator() {\n-        return new Iterator<Node>() {\n-            public boolean hasNext() {\n-              return cur != null;\n-            }\n-\n-            public Node next() {\n-              if (!hasNext()) throw new NoSuchElementException();\n-              Node n = cur;\n-              cur = cur.getParent();\n-              return n;\n-            }\n-\n-            public void remove() {\n-              throw new UnsupportedOperationException();\n-            }\n-          };\n-      }\n-    }\n-\n-    /**\n-     * Check for one child more efficiently than by iterating over all the\n-     * children as is done with Node.getChildCount().\n-     * @return Whether the node has exactly one child.\n-     */\n-    public boolean hasOneChild() {\n-      return first != null && first == last;\n-    }\n-\n-    /**\n-     * Check for more than one child more efficiently than by iterating over all\n-     * the children as is done with Node.getChildCount().\n-     * @return Whether the node more than one child.\n-     */\n-    public boolean hasMoreThanOneChild() {\n-      return first != null && first != last;\n-    }\n-\n-    public int getChildCount() {\n-        int c = 0;\n-        for (Node n = first; n != null; n = n.next)\n-            c++;\n-\n-        return c;\n-    }\n-\n-    // Intended for testing and verification only.\n-    public boolean hasChild(Node child) {\n-      for (Node n = first; n != null; n = n.getNext()) {\n-        if (child == n) {\n-          return true;\n-        }\n-      }\n-      return false;\n-    }\n-\n-    /**\n-     * Checks if the subtree under this node is the same as another subtree.\n-     * Returns null if it's equal, or a message describing the differences.\n-     */\n-    public String checkTreeEquals(Node node2) {\n-        NodeMismatch diff = checkTreeEqualsImpl(node2);\n-        if (diff != null) {\n-          return \"Node tree inequality:\" +\n-              \"\\nTree1:\\n\" + toStringTree() +\n-              \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n-              \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n-              \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree();\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * If this is a compilation pass and not a test, do not construct error\n-     * strings. Instead return true if the trees are equal.\n-     */\n-    public boolean checkTreeEqualsSilent(Node node2) {\n-        return checkTreeEqualsImpl(node2) == null;\n-    }\n-\n-    /**\n-     * Compare this node to node2 recursively and return the first pair\n-     * of nodes that differs doing a preorder depth-first traversal.\n-     * Package private for testing. Returns null if the nodes are equivalent.\n-     */\n-    NodeMismatch checkTreeEqualsImpl(Node node2) {\n-        boolean eq = false;\n-\n-        if (type == node2.getType() &&\n-            getChildCount() == node2.getChildCount() &&\n-            getClass() == node2.getClass()) {\n-\n-            eq = this.isEquivalentTo(node2);\n-        }\n-\n-        if (!eq) {\n-            return new NodeMismatch(this, node2);\n-        }\n-\n-        NodeMismatch res = null;\n-        Node n, n2;\n-        for (n = first, n2 = node2.first;\n-             res == null && n != null;\n-             n = n.next, n2 = n2.next) {\n-            res = n.checkTreeEqualsImpl(n2);\n-            if (res != null) {\n-              return res;\n-            }\n-        }\n-        return res;\n-    }\n-\n-    /**\n-     * Checks if the subtree under this node is the same as another subtree\n-     * including types. Returns null if it's equal, or a message describing the\n-     * differences.\n-     */\n-    public boolean checkTreeTypeAwareEqualsSilent(Node node2) {\n-      return checkTreeTypeAwareEqualsImpl(node2) == null;\n-    }\n-\n-    /**\n-     * Compare this node to node2 recursively and return the first pair\n-     * of nodes that differs doing a preorder depth-first traversal.\n-     * Package private for testing. Returns null if the nodes are equivalent.\n-     */\n-    NodeMismatch checkTreeTypeAwareEqualsImpl(Node node2) {\n-        boolean eq = false;\n-\n-        if (type == node2.getType() &&\n-            getChildCount() == node2.getChildCount() &&\n-            getClass() == node2.getClass() &&\n-            Objects.equal(jsType, node2.getJSType())) {\n-\n-            eq = this.isEquivalentTo(node2);\n-        }\n-\n-        if (!eq) {\n-            return new NodeMismatch(this, node2);\n-        }\n-\n-        NodeMismatch res = null;\n-        Node n, n2;\n-        for (n = first, n2 = node2.first;\n-             res == null && n != null;\n-             n = n.next, n2 = n2.next) {\n-            res = n.checkTreeTypeAwareEqualsImpl(n2);\n-            if (res != null) {\n-              return res;\n-            }\n-        }\n-        return res;\n-    }\n-\n-    public static String tokenToName(int token) {\n-        switch (token) {\n-            case Token.ERROR:           return \"error\";\n-            case Token.EOF:             return \"eof\";\n-            case Token.EOL:             return \"eol\";\n-            case Token.ENTERWITH:       return \"enterwith\";\n-            case Token.LEAVEWITH:       return \"leavewith\";\n-            case Token.RETURN:          return \"return\";\n-            case Token.GOTO:            return \"goto\";\n-            case Token.IFEQ:            return \"ifeq\";\n-            case Token.IFNE:            return \"ifne\";\n-            case Token.SETNAME:         return \"setname\";\n-            case Token.BITOR:           return \"bitor\";\n-            case Token.BITXOR:          return \"bitxor\";\n-            case Token.BITAND:          return \"bitand\";\n-            case Token.EQ:              return \"eq\";\n-            case Token.NE:              return \"ne\";\n-            case Token.LT:              return \"lt\";\n-            case Token.LE:              return \"le\";\n-            case Token.GT:              return \"gt\";\n-            case Token.GE:              return \"ge\";\n-            case Token.LSH:             return \"lsh\";\n-            case Token.RSH:             return \"rsh\";\n-            case Token.URSH:            return \"ursh\";\n-            case Token.ADD:             return \"add\";\n-            case Token.SUB:             return \"sub\";\n-            case Token.MUL:             return \"mul\";\n-            case Token.DIV:             return \"div\";\n-            case Token.MOD:             return \"mod\";\n-            case Token.BITNOT:          return \"bitnot\";\n-            case Token.NEG:             return \"neg\";\n-            case Token.NEW:             return \"new\";\n-            case Token.DELPROP:         return \"delprop\";\n-            case Token.TYPEOF:          return \"typeof\";\n-            case Token.GETPROP:         return \"getprop\";\n-            case Token.SETPROP:         return \"setprop\";\n-            case Token.GETELEM:         return \"getelem\";\n-            case Token.SETELEM:         return \"setelem\";\n-            case Token.CALL:            return \"call\";\n-            case Token.NAME:            return \"name\";\n-            case Token.NUMBER:          return \"number\";\n-            case Token.STRING:          return \"string\";\n-            case Token.NULL:            return \"null\";\n-            case Token.THIS:            return \"this\";\n-            case Token.FALSE:           return \"false\";\n-            case Token.TRUE:            return \"true\";\n-            case Token.SHEQ:            return \"sheq\";\n-            case Token.SHNE:            return \"shne\";\n-            case Token.REGEXP:          return \"regexp\";\n-            case Token.POS:             return \"pos\";\n-            case Token.BINDNAME:        return \"bindname\";\n-            case Token.THROW:           return \"throw\";\n-            case Token.IN:              return \"in\";\n-            case Token.INSTANCEOF:      return \"instanceof\";\n-            case Token.GETVAR:          return \"getvar\";\n-            case Token.SETVAR:          return \"setvar\";\n-            case Token.TRY:             return \"try\";\n-            case Token.TYPEOFNAME:      return \"typeofname\";\n-            case Token.THISFN:          return \"thisfn\";\n-            case Token.SEMI:            return \"semi\";\n-            case Token.LB:              return \"lb\";\n-            case Token.RB:              return \"rb\";\n-            case Token.LC:              return \"lc\";\n-            case Token.RC:              return \"rc\";\n-            case Token.LP:              return \"lp\";\n-            case Token.RP:              return \"rp\";\n-            case Token.COMMA:           return \"comma\";\n-            case Token.ASSIGN:          return \"assign\";\n-            case Token.ASSIGN_BITOR:    return \"assign_bitor\";\n-            case Token.ASSIGN_BITXOR:   return \"assign_bitxor\";\n-            case Token.ASSIGN_BITAND:   return \"assign_bitand\";\n-            case Token.ASSIGN_LSH:      return \"assign_lsh\";\n-            case Token.ASSIGN_RSH:      return \"assign_rsh\";\n-            case Token.ASSIGN_URSH:     return \"assign_ursh\";\n-            case Token.ASSIGN_ADD:      return \"assign_add\";\n-            case Token.ASSIGN_SUB:      return \"assign_sub\";\n-            case Token.ASSIGN_MUL:      return \"assign_mul\";\n-            case Token.ASSIGN_DIV:      return \"assign_div\";\n-            case Token.ASSIGN_MOD:      return \"assign_mod\";\n-            case Token.HOOK:            return \"hook\";\n-            case Token.COLON:           return \"colon\";\n-            case Token.OR:              return \"or\";\n-            case Token.AND:             return \"and\";\n-            case Token.INC:             return \"inc\";\n-            case Token.DEC:             return \"dec\";\n-            case Token.DOT:             return \"dot\";\n-            case Token.FUNCTION:        return \"function\";\n-            case Token.EXPORT:          return \"export\";\n-            case Token.IMPORT:          return \"import\";\n-            case Token.IF:              return \"if\";\n-            case Token.ELSE:            return \"else\";\n-            case Token.SWITCH:          return \"switch\";\n-            case Token.CASE:            return \"case\";\n-            case Token.DEFAULT:         return \"default\";\n-            case Token.WHILE:           return \"while\";\n-            case Token.DO:              return \"do\";\n-            case Token.FOR:             return \"for\";\n-            case Token.BREAK:           return \"break\";\n-            case Token.CONTINUE:        return \"continue\";\n-            case Token.VAR:             return \"var\";\n-            case Token.WITH:            return \"with\";\n-            case Token.CATCH:           return \"catch\";\n-            case Token.FINALLY:         return \"finally\";\n-            case Token.RESERVED:        return \"reserved\";\n-            case Token.NOT:             return \"not\";\n-            case Token.VOID:            return \"void\";\n-            case Token.BLOCK:           return \"block\";\n-            case Token.ARRAYLIT:        return \"arraylit\";\n-            case Token.OBJECTLIT:       return \"objectlit\";\n-            case Token.LABEL:           return \"label\";\n-            case Token.TARGET:          return \"target\";\n-            case Token.LOOP:            return \"loop\";\n-            case Token.EXPR_VOID:       return \"expr_void\";\n-            case Token.EXPR_RESULT:     return \"expr_result\";\n-            case Token.JSR:             return \"jsr\";\n-            case Token.SCRIPT:          return \"script\";\n-            case Token.EMPTY:           return \"empty\";\n-            case Token.GET_REF:         return \"get_ref\";\n-            case Token.REF_SPECIAL:     return \"ref_special\";\n-        }\n-        return \"<unknown=\"+token+\">\";\n-    }\n-\n-    /** Returns true if this node is equivalent semantically to another */\n-    public boolean isEquivalentTo(Node node) {\n-        if (type == Token.ARRAYLIT) {\n-            try {\n-                int[] indices1 = (int[])getProp(Node.SKIP_INDEXES_PROP);\n-                int[] indices2 = (int[])node.getProp(Node.SKIP_INDEXES_PROP);\n-                if (indices1 == null) {\n-                    if (indices2 != null)\n-                        return false;\n-                } else if (indices2 == null) {\n-                    return false;\n-                } else if (indices1.length != indices2.length) {\n-                    return false;\n-                } else {\n-                    for (int i = 0; i < indices1.length; i++) {\n-                        if (indices1[i] != indices2[i])\n-                            return false;\n-                    }\n-                }\n-            } catch (Exception e) {\n-                return false;\n-            }\n-        } else if (type == Token.INC ||\n-                   type == Token.DEC) {\n-            int post1 = this.getIntProp(INCRDECR_PROP, 0);\n-            int post2 = node.getIntProp(INCRDECR_PROP, 0);\n-            if (post1 != post2)\n-                return false;\n-        } else if (type == Token.STRING) {\n-            int quoted1 = this.getIntProp(QUOTED_PROP, 0);\n-            int quoted2 = node.getIntProp(QUOTED_PROP, 0);\n-            if (quoted1 != quoted2)\n-                return false;\n-        }\n-        return true;\n-    }\n-\n-    public boolean hasSideEffects()\n-    {\n-        switch (type) {\n-          case Token.EXPR_VOID:\n-          case Token.COMMA:\n-            if (last != null)\n-                return last.hasSideEffects();\n-            else\n-                return true;\n-\n-          case Token.HOOK:\n-            if (first == null ||\n-                first.next == null ||\n-                first.next.next == null)\n-                Kit.codeBug();\n-            return first.next.hasSideEffects() &&\n-                   first.next.next.hasSideEffects();\n-\n-          case Token.ERROR:         // Avoid cascaded error messages\n-          case Token.EXPR_RESULT:\n-          case Token.ASSIGN:\n-          case Token.ASSIGN_ADD:\n-          case Token.ASSIGN_SUB:\n-          case Token.ASSIGN_MUL:\n-          case Token.ASSIGN_DIV:\n-          case Token.ASSIGN_MOD:\n-          case Token.ASSIGN_BITOR:\n-          case Token.ASSIGN_BITXOR:\n-          case Token.ASSIGN_BITAND:\n-          case Token.ASSIGN_LSH:\n-          case Token.ASSIGN_RSH:\n-          case Token.ASSIGN_URSH:\n-          case Token.ENTERWITH:\n-          case Token.LEAVEWITH:\n-          case Token.RETURN:\n-          case Token.GOTO:\n-          case Token.IFEQ:\n-          case Token.IFNE:\n-          case Token.NEW:\n-          case Token.DELPROP:\n-          case Token.SETNAME:\n-          case Token.SETPROP:\n-          case Token.SETELEM:\n-          case Token.CALL:\n-          case Token.THROW:\n-          case Token.RETHROW:\n-          case Token.SETVAR:\n-          case Token.CATCH_SCOPE:\n-          case Token.RETURN_RESULT:\n-          case Token.SET_REF:\n-          case Token.DEL_REF:\n-          case Token.REF_CALL:\n-          case Token.TRY:\n-          case Token.SEMI:\n-          case Token.INC:\n-          case Token.DEC:\n-          case Token.EXPORT:\n-          case Token.IMPORT:\n-          case Token.IF:\n-          case Token.ELSE:\n-          case Token.SWITCH:\n-          case Token.WHILE:\n-          case Token.DO:\n-          case Token.FOR:\n-          case Token.BREAK:\n-          case Token.CONTINUE:\n-          case Token.VAR:\n-          case Token.CONST:\n-          case Token.WITH:\n-          case Token.CATCH:\n-          case Token.FINALLY:\n-          case Token.BLOCK:\n-          case Token.LABEL:\n-          case Token.TARGET:\n-          case Token.LOOP:\n-          case Token.JSR:\n-          case Token.SETPROP_OP:\n-          case Token.SETELEM_OP:\n-          case Token.LOCAL_BLOCK:\n-          case Token.SET_REF_OP:\n-            return true;\n-\n-          default:\n-            return false;\n-        }\n-    }\n-\n-    /**\n-     * This function takes a set of GETPROP nodes and produces a string that is\n-     * each property separated by dots.  If the node ultimately under the left\n-     * sub-tree is not a simple name, this is not a valid qualified name.\n-     *\n-     * @return a null if this is not a qualified name, or a dot-separated string\n-     * of the name and properties.\n-     */\n-    public String getQualifiedName() {\n-        if (type == Token.NAME) {\n-            return getString();\n-        } else if (type == Token.GETPROP) {\n-            String left = getFirstChild().getQualifiedName();\n-            if (left == null) {\n-              return null;\n-            }\n-            return left + \".\" + getLastChild().getString();\n-        } else if (type == Token.THIS) {\n-             return \"this\";\n-        } else {\n-            return null;\n-\n-        }\n-\n-    }\n-\n-    /**\n-     * Returns whether a node corresponds to a simple or a qualified name, such\n-     * as <code>x</code> or <code>a.b.c</code> or <code>this.a</code>.\n-     */\n-    public boolean isQualifiedName() {\n-        switch (getType()) {\n-            case Token.NAME:\n-            case Token.THIS:\n-                return true;\n-            case Token.GETPROP:\n-                return getFirstChild().isQualifiedName();\n-            default:\n-                return false;\n-        }\n-    }\n-\n-    /**\n-     * Returns whether a node corresponds to a simple or a qualified name\n-     * without a \"this\" reference, such as <code>a.b.c</code>, but not\n-     * <code>this.a</code>.\n-     */\n-    public boolean isUnscopedQualifiedName() {\n-        switch (getType()) {\n-            case Token.NAME:\n-                return true;\n-            case Token.GETPROP:\n-                return getFirstChild().isUnscopedQualifiedName();\n-            default:\n-                return false;\n-        }\n-    }\n-\n-    //==========================================================================\n-    // Mutators\n-\n-    /**\n-     * Removes this node from its parent.  Equivalent to:\n-     *     node.getParent().removeChild();\n-     */\n-    public Node detachFromParent() {\n-      Preconditions.checkState(parent != null);\n-      parent.removeChild(this);\n-      return this;\n-    }\n-\n-    /**\n-     * Removes the first child of Node.  Equivalent to:\n-     *     node.removeChild(node.getFirstChild());\n-     * @return The removed Node.\n-     */\n-    public Node removeFirstChild() {\n-      Node child = first;\n-      if (child != null) {\n-        removeChild(child);\n-      }\n-      return child;\n-    }\n-\n-    /**\n-     * @return A Node that is the head of the list of children.\n-     */\n-    public Node removeChildren() {\n-      Node children = first;\n-      for (Node child = first; child != null; child = child.getNext()) {\n-        child.parent = null;\n-      }\n-      first = null;\n-      last = null;\n-      return children;\n-    }\n-\n-    /**\n-     * Removes all children from this node and isolates the children from each\n-     * other.\n-     */\n-    public void detachChildren() {\n-      for (Node child = first; child != null; ) {\n-        Node nextChild = child.getNext();\n-        child.parent = null;\n-        child.next = null;\n-        child = nextChild;\n-      }\n-      first = null;\n-      last = null;\n-    }\n-\n-    public Node removeChildAfter(Node prev) {\n-        Preconditions.checkArgument(prev.parent == this,\n-            \"prev is not a child of this node.\");\n-        Preconditions.checkArgument(prev.next != null,\n-            \"no next sibling.\");\n-\n-        Node child = prev.next;\n-        prev.next = child.next;\n-        if (child == last) last = prev;\n-        child.next = null;\n-        child.parent = null;\n-        return child;\n-    }\n-\n-    /**\n-     * @return A detached clone of the Node, specifically excluding its\n-     * children.\n-     */\n-    public Node cloneNode() {\n-        Node result;\n-        try {\n-            result = (Node) super.clone();\n-            result.next = null;\n-            result.first = null;\n-            result.last = null;\n-            result.parent = null;\n-        }\n-        catch (CloneNotSupportedException e) {\n-            throw new RuntimeException(e.getMessage());\n-        }\n-        return result;\n-    }\n-\n-    /**\n-     * @return A detached clone of the Node and all its children.\n-     */\n-    public Node cloneTree() {\n-        Node result = cloneNode();\n-        for (Node n2 = getFirstChild(); n2 != null; n2 = n2.getNext()) {\n-            Node n2clone = n2.cloneTree();\n-            n2clone.parent = result;\n-            if (result.last != null) {\n-                result.last.next = n2clone;\n-            }\n-            if (result.first == null) {\n-                result.first = n2clone;\n-            }\n-            result.last = n2clone;\n-        }\n-        return result;\n-    }\n-\n-    /**\n-     * Copies source file, line and column number from the other\n-     * node given to the current node.\n-     * @return this\n-     */\n-    public Node copySourceLocationFrom(Node other) {\n-      if (getProp(SOURCEFILE_PROP) == null) {\n-        putProp(SOURCEFILE_PROP, other.getProp(SOURCEFILE_PROP));\n-        sourcePosition = other.sourcePosition;\n-      }\n-\n-      if (getLineno() == -1 || getCharno() == -1) {\n-        setLineno(other.getLineno());\n-        setCharno(other.getCharno());\n-      }\n-\n-      return this;\n-    }\n-\n-    /**\n-     * Copies source file and name information from the other\n-     * node given to the current node. Used for maintaining\n-     * debug information across node append and remove operations.\n-     * @return this\n-     */\n-    public Node copyInformationFrom(Node other) {\n-        if (getProp(ORIGINALNAME_PROP) == null) {\n-            putProp(ORIGINALNAME_PROP, other.getProp(ORIGINALNAME_PROP));\n-        }\n-\n-        if (getProp(SOURCEFILE_PROP) == null) {\n-            putProp(SOURCEFILE_PROP, other.getProp(SOURCEFILE_PROP));\n-            sourcePosition = other.sourcePosition;\n-        }\n-\n-        return this;\n-    }\n-\n-    /**\n-     * Copies source file and name information from the other node to the\n-     * entire tree rooted at this node.\n-     * @return this\n-     */\n-    public Node copyInformationFromForTree(Node other) {\n-      copyInformationFrom(other);\n-      for (Node child = getFirstChild();\n-           child != null; child = child.getNext()) {\n-        child.copyInformationFromForTree(other);\n-      }\n-\n-      return this;\n-    }\n-\n-    //==========================================================================\n-    // Custom annotations\n-\n-    public JSType getJSType() {\n-        return jsType;\n-    }\n-\n-    public void setJSType(JSType jsType) {\n-        this.jsType = jsType;\n-    }\n-\n-    public FileLevelJsDocBuilder getJsDocBuilderForNode() {\n-      return new FileLevelJsDocBuilder();\n-    }\n-\n-    /**\n-     * An inner class that provides back-door access to the license\n-     * property of the JSDocInfo property for this node. This is only\n-     * meant to be used for top level script nodes where the\n-     * {@link com.google.javascript.jscomp.parsing.JsDocInfoParser} needs to\n-     * be able to append directly to the top level node, not just the\n-     * current node.\n-     */\n-    public class FileLevelJsDocBuilder {\n-      public void append(String fileLevelComment) {\n-        JSDocInfo jsDocInfo = getJSDocInfo();\n-        if (jsDocInfo == null) {\n-          // TODO(user): Is there a way to determine whether to\n-          // parse the JsDoc documentation from here?\n-          jsDocInfo = new JSDocInfo(false);\n-        }\n-        String license = jsDocInfo.getLicense();\n-        if (license == null) {\n-          license = \"\";\n-        }\n-        jsDocInfo.setLicense(license + fileLevelComment);\n-        setJSDocInfo(jsDocInfo);\n-      }\n-    }\n-\n-    /**\n-     * Get the {@link JSDocInfo} attached to this node.\n-     * @return the information or {@code null} if no JSDoc is attached to this\n-     * node\n-     */\n-    public JSDocInfo getJSDocInfo()\n-    {\n-        return (JSDocInfo) getProp(JSDOC_INFO_PROP);\n-    }\n-\n-    /**\n-     * Sets the {@link JSDocInfo} attached to this node.\n-     */\n-    public void setJSDocInfo(JSDocInfo info)\n-    {\n-        putProp(JSDOC_INFO_PROP, info);\n-    }\n-\n-    /**\n-     * Sets whether this node is a variable length argument node. This\n-     * method is meaningful only on {@link Token#NAME} nodes\n-     * used to define a {@link Token#FUNCTION}'s argument list.\n-     */\n-    public void setVarArgs(boolean varArgs)\n-    {\n-        putBooleanProp(VAR_ARGS_NAME, varArgs);\n-    }\n-\n-    /**\n-     * Returns whether this node is a variable length argument node. This\n-     * method's return value is meaningful only on {@link Token#NAME} nodes\n-     * used to define a {@link Token#FUNCTION}'s argument list.\n-     */\n-    public boolean isVarArgs()\n-    {\n-        return getBooleanProp(VAR_ARGS_NAME);\n-    }\n-\n-    /**\n-     * Sets whether this node is an optional argument node. This\n-     * method is meaningful only on {@link Token#NAME} nodes\n-     * used to define a {@link Token#FUNCTION}'s argument list.\n-     */\n-    public void setOptionalArg(boolean optionalArg)\n-    {\n-        putBooleanProp(OPT_ARG_NAME, optionalArg);\n-    }\n-\n-    /**\n-     * Returns whether this node is an optional argument node. This\n-     * method's return value is meaningful only on {@link Token#NAME} nodes\n-     * used to define a {@link Token#FUNCTION}'s argument list.\n-     */\n-    public boolean isOptionalArg()\n-    {\n-        return getBooleanProp(OPT_ARG_NAME);\n-    }\n-\n-    /**\n-     * Sets whether this is a synthetic block that should not be considered\n-     * a real source block.\n-     */\n-    public void setIsSyntheticBlock(boolean val) {\n-        putBooleanProp(SYNTHETIC_BLOCK_PROP, val);\n-    }\n-\n-    /**\n-     * Returns whether this is a synthetic block that should not be considered\n-     * a real source block.\n-     */\n-    public boolean isSyntheticBlock() {\n-        return getBooleanProp(SYNTHETIC_BLOCK_PROP);\n-    }\n-\n-    /**\n-     * Sets the ES5 directives on this node.\n-     */\n-    public void setDirectives(Set<String> val) {\n-        putProp(DIRECTIVES, val);\n-    }\n-\n-    /**\n-     * Returns the set of ES5 directives for this node.\n-     */\n-    @SuppressWarnings(\"unchecked\")\n-    public Set<String> getDirectives() {\n-        return (Set<String>) getProp(DIRECTIVES);\n-    }\n-\n-    /**\n-     * Sets whether this is a synthetic block that should not be considered\n-     * a real source block.\n-     */\n-    public void setWasEmptyNode(boolean val) {\n-        putBooleanProp(EMPTY_BLOCK, val);\n-    }\n-\n-    /**\n-     * Returns whether this is a synthetic block that should not be considered\n-     * a real source block.\n-     */\n-    public boolean wasEmptyNode() {\n-        return getBooleanProp(EMPTY_BLOCK);\n-    }\n-\n-    /**\n-     * Marks this function or constructor call node as having no side effects.\n-     * This property is only meaningful for {@link Token#CALL} and\n-     * {@link Token#NEW} nodes.\n-     */\n-    public void setIsNoSideEffectsCall() {\n-        Preconditions.checkArgument(\n-           getType() == Token.CALL || getType() == Token.NEW,\n-           \"setIsNoSideEffectsCall only supports CALL and NEW nodes, got \" +\n-           Token.name(getType()));\n-\n-        putBooleanProp(NO_SIDE_EFFECTS_CALL, true);\n-    }\n-\n-    /**\n-     * Returns true if this node is a function or constructor call that\n-     * has no side effects.\n-     */\n-    public boolean isNoSideEffectsCall() {\n-        return getBooleanProp(NO_SIDE_EFFECTS_CALL);\n+    @Override\n+    public boolean isQuotedString() {\n+      return getBooleanProp(QUOTED_PROP);\n     }\n \n     /**\n      * This should only be called for STRING nodes created in object lits.\n      */\n-    public boolean isQuotedString() {\n+    @Override\n+    public void setQuotedString() {\n+      putBooleanProp(QUOTED_PROP, true);\n+    }\n+\n+    private String str;\n+  }\n+\n+  private static class PropListItem implements Serializable {\n+    private static final long serialVersionUID = 1L;\n+\n+    PropListItem next;\n+    int type;\n+    int intValue;\n+    Object objectValue;\n+  }\n+\n+\n+  public Node(int nodeType) {\n+    type = nodeType;\n+    parent = null;\n+    sourcePosition = -1;\n+  }\n+\n+  public Node(int nodeType, Node child) {\n+    Preconditions.checkArgument(child.parent == null,\n+        \"new child has existing parent\");\n+    Preconditions.checkArgument(child.next == null,\n+        \"new child has existing sibling\");\n+\n+    type = nodeType;\n+    parent = null;\n+    first = last = child;\n+    child.next = null;\n+    child.parent = this;\n+    sourcePosition = -1;\n+  }\n+\n+  public Node(int nodeType, Node left, Node right) {\n+    Preconditions.checkArgument(left.parent == null,\n+        \"first new child has existing parent\");\n+    Preconditions.checkArgument(left.next == null,\n+        \"first new child has existing sibling\");\n+    Preconditions.checkArgument(right.parent == null,\n+        \"second new child has existing parent\");\n+    Preconditions.checkArgument(right.next == null,\n+        \"second new child has existing sibling\");\n+    type = nodeType;\n+    parent = null;\n+    first = left;\n+    last = right;\n+    left.next = right;\n+    left.parent = this;\n+    right.next = null;\n+    right.parent = this;\n+    sourcePosition = -1;\n+  }\n+\n+  public Node(int nodeType, Node left, Node mid, Node right) {\n+    Preconditions.checkArgument(left.parent == null);\n+    Preconditions.checkArgument(left.next == null);\n+    Preconditions.checkArgument(mid.parent == null);\n+    Preconditions.checkArgument(mid.next == null);\n+    Preconditions.checkArgument(right.parent == null);\n+    Preconditions.checkArgument(right.next == null);\n+    type = nodeType;\n+    parent = null;\n+    first = left;\n+    last = right;\n+    left.next = mid;\n+    left.parent = this;\n+    mid.next = right;\n+    mid.parent = this;\n+    right.next = null;\n+    right.parent = this;\n+    sourcePosition = -1;\n+  }\n+\n+  public Node(int nodeType, Node left, Node mid, Node mid2, Node right) {\n+    Preconditions.checkArgument(left.parent == null);\n+    Preconditions.checkArgument(left.next == null);\n+    Preconditions.checkArgument(mid.parent == null);\n+    Preconditions.checkArgument(mid.next == null);\n+    Preconditions.checkArgument(mid2.parent == null);\n+    Preconditions.checkArgument(mid2.next == null);\n+    Preconditions.checkArgument(right.parent == null);\n+    Preconditions.checkArgument(right.next == null);\n+    type = nodeType;\n+    parent = null;\n+    first = left;\n+    last = right;\n+    left.next = mid;\n+    left.parent = this;\n+    mid.next = mid2;\n+    mid.parent = this;\n+    mid2.next = right;\n+    mid2.parent = this;\n+    right.next = null;\n+    right.parent = this;\n+    sourcePosition = -1;\n+  }\n+\n+  public Node(int nodeType, int lineno, int charno) {\n+    type = nodeType;\n+    parent = null;\n+    sourcePosition = mergeLineCharNo(lineno, charno);\n+  }\n+\n+  public Node(int nodeType, Node child, int lineno, int charno) {\n+    this(nodeType, child);\n+    sourcePosition = mergeLineCharNo(lineno, charno);\n+  }\n+\n+  public Node(int nodeType, Node left, Node right, int lineno, int charno) {\n+    this(nodeType, left, right);\n+    sourcePosition = mergeLineCharNo(lineno, charno);\n+  }\n+\n+  public Node(int nodeType, Node left, Node mid, Node right,\n+      int lineno, int charno) {\n+    this(nodeType, left, mid, right);\n+    sourcePosition = mergeLineCharNo(lineno, charno);\n+  }\n+\n+  public Node(int nodeType, Node left, Node mid, Node mid2, Node right,\n+      int lineno, int charno) {\n+    this(nodeType, left, mid, mid2, right);\n+    sourcePosition = mergeLineCharNo(lineno, charno);\n+  }\n+\n+  public Node(int nodeType, Node[] children, int lineno, int charno) {\n+    this(nodeType, children);\n+    sourcePosition = mergeLineCharNo(lineno, charno);\n+  }\n+\n+  public Node(int nodeType, Node[] children) {\n+    this.type = nodeType;\n+    parent = null;\n+    if (children.length != 0) {\n+      this.first = children[0];\n+      this.last = children[children.length - 1];\n+\n+      for (int i = 1; i < children.length; i++) {\n+        if (null != children[i - 1].next) {\n+          // fail early on loops. implies same node in array twice\n+          throw new IllegalArgumentException(\"duplicate child\");\n+        }\n+        children[i - 1].next = children[i];\n+        Preconditions.checkArgument(children[i - 1].parent == null);\n+        children[i - 1].parent = this;\n+      }\n+      Preconditions.checkArgument(children[children.length - 1].parent == null);\n+      children[children.length - 1].parent = this;\n+\n+      if (null != this.last.next) {\n+        // fail early on loops. implies same node in array twice\n+        throw new IllegalArgumentException(\"duplicate child\");\n+      }\n+    }\n+  }\n+\n+  public static Node newNumber(double number) {\n+    return new NumberNode(number);\n+  }\n+\n+  public static Node newNumber(double number, int lineno, int charno) {\n+    return new NumberNode(number, lineno, charno);\n+  }\n+\n+  public static Node newString(String str) {\n+    return new StringNode(Token.STRING, str);\n+  }\n+\n+  public static Node newString(int type, String str) {\n+    return new StringNode(type, str);\n+  }\n+\n+  public static Node newString(String str, int lineno, int charno) {\n+    return new StringNode(Token.STRING, str, lineno, charno);\n+  }\n+\n+  public static Node newString(int type, String str, int lineno, int charno) {\n+    return new StringNode(type, str, lineno, charno);\n+  }\n+\n+  public int getType() {\n+    return type;\n+  }\n+\n+  public void setType(int type) {\n+    this.type = type;\n+  }\n+\n+  public boolean hasChildren() {\n+    return first != null;\n+  }\n+\n+  public Node getFirstChild() {\n+    return first;\n+  }\n+\n+  public Node getLastChild() {\n+    return last;\n+  }\n+\n+  public Node getNext() {\n+    return next;\n+  }\n+\n+  public Node getChildBefore(Node child) {\n+    if (child == first) {\n+      return null;\n+    }\n+    Node n = first;\n+    while (n.next != child) {\n+      n = n.next;\n+      if (n == null) {\n+        throw new RuntimeException(\"node is not a child\");\n+      }\n+    }\n+    return n;\n+  }\n+\n+  public Node getChildAtIndex(int i) {\n+    Node n = first;\n+    while (i > 0) {\n+      n = n.next;\n+      i--;\n+    }\n+    return n;\n+  }\n+\n+  public Node getLastSibling() {\n+    Node n = this;\n+    while (n.next != null) {\n+      n = n.next;\n+    }\n+    return n;\n+  }\n+\n+  public void addChildToFront(Node child) {\n+    Preconditions.checkArgument(child.parent == null);\n+    Preconditions.checkArgument(child.next == null);\n+    child.parent = this;\n+    child.next = first;\n+    first = child;\n+    if (last == null) {\n+      last = child;\n+    }\n+  }\n+\n+  public void addChildToBack(Node child) {\n+    Preconditions.checkArgument(child.parent == null);\n+    Preconditions.checkArgument(child.next == null);\n+    child.parent = this;\n+    child.next = null;\n+    if (last == null) {\n+      first = last = child;\n+      return;\n+    }\n+    last.next = child;\n+    last = child;\n+  }\n+\n+  public void addChildrenToFront(Node children) {\n+    for (Node child = children; child != null; child = child.next) {\n+      Preconditions.checkArgument(child.parent == null);\n+      child.parent = this;\n+    }\n+    Node lastSib = children.getLastSibling();\n+    lastSib.next = first;\n+    first = children;\n+    if (last == null) {\n+      last = lastSib;\n+    }\n+  }\n+\n+  public void addChildrenToBack(Node children) {\n+    for (Node child = children; child != null; child = child.next) {\n+      Preconditions.checkArgument(child.parent == null);\n+      child.parent = this;\n+    }\n+    if (last != null) {\n+      last.next = children;\n+    }\n+    last = children.getLastSibling();\n+    if (first == null) {\n+      first = children;\n+    }\n+  }\n+\n+  /**\n+   * Add 'child' before 'node'.\n+   */\n+  public void addChildBefore(Node newChild, Node node) {\n+    Preconditions.checkArgument(node != null,\n+        \"The existing child node of the parent should not be null.\");\n+    Preconditions.checkArgument(newChild.next == null,\n+        \"The new child node has siblings.\");\n+    Preconditions.checkArgument(newChild.parent == null,\n+        \"The new child node already has a parent.\");\n+    if (first == node) {\n+      newChild.parent = this;\n+      newChild.next = first;\n+      first = newChild;\n+      return;\n+    }\n+    Node prev = getChildBefore(node);\n+    addChildAfter(newChild, prev);\n+  }\n+\n+  /**\n+   * Add 'child' after 'node'.\n+   */\n+  public void addChildAfter(Node newChild, Node node) {\n+    Preconditions.checkArgument(newChild.next == null,\n+        \"The new child node has siblings.\");\n+    Preconditions.checkArgument(newChild.parent == null,\n+        \"The new child node already has a parent.\");\n+    newChild.parent = this;\n+    newChild.next = node.next;\n+    node.next = newChild;\n+    if (last == node) {\n+        last = newChild;\n+    }\n+  }\n+\n+  /**\n+   * Detach a child from its parent and siblings.\n+   */\n+  public void removeChild(Node child) {\n+    Node prev = getChildBefore(child);\n+    if (prev == null)\n+        first = first.next;\n+    else\n+        prev.next = child.next;\n+    if (child == last) last = prev;\n+    child.next = null;\n+    child.parent = null;\n+  }\n+\n+  /**\n+   * Detaches child from Node and replaces it with newChild.\n+   */\n+  public void replaceChild(Node child, Node newChild) {\n+    Preconditions.checkArgument(newChild.next == null,\n+        \"The new child node has siblings.\");\n+    Preconditions.checkArgument(newChild.parent == null,\n+        \"The new child node already has a parent.\");\n+\n+    // Copy over important information.\n+    newChild.copyInformationFrom(child);\n+\n+    newChild.next = child.next;\n+    newChild.parent = this;\n+    if (child == first) {\n+        first = newChild;\n+    } else {\n+        Node prev = getChildBefore(child);\n+        prev.next = newChild;\n+    }\n+    if (child == last)\n+        last = newChild;\n+    child.next = null;\n+    child.parent = null;\n+  }\n+\n+  public void replaceChildAfter(Node prevChild, Node newChild) {\n+    Preconditions.checkArgument(prevChild.parent == this,\n+      \"prev is not a child of this node.\");\n+\n+    Preconditions.checkArgument(newChild.next == null,\n+        \"The new child node has siblings.\");\n+    Preconditions.checkArgument(newChild.parent == null,\n+        \"The new child node already has a parent.\");\n+\n+    // Copy over important information.\n+    newChild.copyInformationFrom(prevChild);\n+\n+    Node child = prevChild.next;\n+    newChild.next = child.next;\n+    newChild.parent = this;\n+    prevChild.next = newChild;\n+    if (child == last)\n+        last = newChild;\n+    child.next = null;\n+    child.parent = null;\n+  }\n+\n+  private PropListItem lookupProperty(int propType) {\n+    PropListItem x = propListHead;\n+    while (x != null && propType != x.type) {\n+      x = x.next;\n+    }\n+    return x;\n+  }\n+\n+  private PropListItem ensureProperty(int propType) {\n+    PropListItem item = lookupProperty(propType);\n+    if (item == null) {\n+      item = new PropListItem();\n+      item.type = propType;\n+      item.next = propListHead;\n+      propListHead = item;\n+    }\n+    return item;\n+  }\n+\n+  public void removeProp(int propType) {\n+    PropListItem x = propListHead;\n+    if (x != null) {\n+      PropListItem prev = null;\n+      while (x.type != propType) {\n+        prev = x;\n+        x = x.next;\n+        if (x == null) {\n+          return;\n+        }\n+      }\n+      if (prev == null) {\n+        propListHead = x.next;\n+      } else {\n+        prev.next = x.next;\n+      }\n+    }\n+  }\n+\n+  public Object getProp(int propType) {\n+    PropListItem item = lookupProperty(propType);\n+    if (item == null) {\n+      return null;\n+    }\n+    return item.objectValue;\n+  }\n+\n+  public boolean getBooleanProp(int propType) {\n+    return getIntProp(propType, 0) != 0;\n+  }\n+\n+  public int getIntProp(int propType, int defaultValue) {\n+    PropListItem item = lookupProperty(propType);\n+    if (item == null) {\n+      return defaultValue;\n+    }\n+    return item.intValue;\n+  }\n+\n+  public int getExistingIntProp(int propType) {\n+    PropListItem item = lookupProperty(propType);\n+    if (item == null) {\n+      Kit.codeBug();\n+    }\n+    return item.intValue;\n+  }\n+\n+  public void putProp(int propType, Object prop) {\n+    if (prop == null) {\n+      removeProp(propType);\n+    } else {\n+      PropListItem item = ensureProperty(propType);\n+      item.objectValue = prop;\n+    }\n+  }\n+\n+  public void putBooleanProp(int propType, boolean prop) {\n+    putIntProp(propType, prop ? 1 : 0);\n+  }\n+\n+  public void putIntProp(int propType, int prop) {\n+    PropListItem item = ensureProperty(propType);\n+    item.intValue = prop;\n+  }\n+\n+  // Gets all the property types, in sorted order.\n+  private int[] getSortedPropTypes() {\n+    int count = 0;\n+    for (PropListItem x = propListHead; x != null; x = x.next) {\n+      count++;\n+    }\n+\n+    int[] keys = new int[count];\n+    for (PropListItem x = propListHead; x != null; x = x.next) {\n+      count--;\n+      keys[count] = x.type;\n+    }\n+\n+    Arrays.sort(keys);\n+    return keys;\n+  }\n+\n+  public int getLineno() {\n+    return extractLineno(sourcePosition);\n+  }\n+\n+  public int getCharno() {\n+    return extractCharno(sourcePosition);\n+  }\n+\n+  /** Can only be called when <tt>getType() == TokenStream.NUMBER</tt> */\n+  public double getDouble() throws UnsupportedOperationException {\n+    if (this.getType() == Token.NUMBER) {\n+      throw new IllegalStateException(\n+          \"Number node not created with Node.newNumber\");\n+    } else {\n+      throw new UnsupportedOperationException(this + \" is not a number node\");\n+    }\n+  }\n+\n+  /** Can only be called when <tt>getType() == TokenStream.NUMBER</tt> */\n+  public void setDouble(double s) throws UnsupportedOperationException {\n+    if (this.getType() == Token.NUMBER) {\n+      throw new IllegalStateException(\n+          \"Number node not created with Node.newNumber\");\n+    } else {\n+      throw new UnsupportedOperationException(this + \" is not a string node\");\n+    }\n+  }\n+\n+  /** Can only be called when node has String context. */\n+  public String getString() throws UnsupportedOperationException {\n+    if (this.getType() == Token.STRING) {\n+      throw new IllegalStateException(\n+          \"String node not created with Node.newString\");\n+    } else {\n+      throw new UnsupportedOperationException(this + \" is not a string node\");\n+    }\n+  }\n+\n+  /** Can only be called when node has String context. */\n+  public void setString(String s) throws UnsupportedOperationException {\n+    if (this.getType() == Token.STRING) {\n+      throw new IllegalStateException(\n+          \"String node not created with Node.newString\");\n+    } else {\n+      throw new UnsupportedOperationException(this + \" is not a string node\");\n+    }\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return toString(true, true, true);\n+  }\n+\n+  public String toString(\n+      boolean printSource,\n+      boolean printAnnotations,\n+      boolean printType) {\n+    if (Token.printTrees) {\n+        StringBuilder sb = new StringBuilder();\n+        toString(sb, printSource, printAnnotations, printType);\n+        return sb.toString();\n+    }\n+    return String.valueOf(type);\n+  }\n+\n+  private void toString(\n+      StringBuilder sb,\n+      boolean printSource,\n+      boolean printAnnotations,\n+      boolean printType) {\n+    if (Token.printTrees) {\n+      sb.append(Token.name(type));\n+      if (this instanceof StringNode) {\n+        sb.append(' ');\n+        sb.append(getString());\n+      } else if (type == Token.FUNCTION) {\n+        sb.append(' ');\n+        sb.append(first.getString());\n+      } else if (this instanceof ScriptOrFnNode) {\n+        ScriptOrFnNode sof = (ScriptOrFnNode) this;\n+        if (this instanceof FunctionNode) {\n+          FunctionNode fn = (FunctionNode) this;\n+          sb.append(' ');\n+          sb.append(fn.getFunctionName());\n+        }\n+        if (printSource) {\n+          sb.append(\" [source name: \");\n+          sb.append(sof.getSourceName());\n+          sb.append(\"] [encoded source length: \");\n+          sb.append(sof.getEncodedSourceEnd() - sof.getEncodedSourceStart());\n+          sb.append(\"] [base line: \");\n+          sb.append(sof.getBaseLineno());\n+          sb.append(\"] [end line: \");\n+          sb.append(sof.getEndLineno());\n+          sb.append(']');\n+        }\n+      } else if (type == Token.NUMBER) {\n+        sb.append(' ');\n+        sb.append(getDouble());\n+      }\n+      if (printSource) {\n+        int lineno = getLineno();\n+        if (lineno != -1) {\n+          sb.append(' ');\n+          sb.append(lineno);\n+        }\n+      }\n+\n+      if (printAnnotations) {\n+        int[] keys = getSortedPropTypes();\n+        for (int i = 0; i < keys.length; i++) {\n+          int type = keys[i];\n+          PropListItem x = lookupProperty(type);\n+          sb.append(\" [\");\n+          sb.append(propToString(type));\n+          sb.append(\": \");\n+          String value;\n+          switch (type) {\n+            case TARGETBLOCK_PROP: // can't add this as it recurses\n+              value = \"target block property\";\n+              break;\n+            case LOCAL_BLOCK_PROP: // can't add this as it is dull\n+              value = \"last local block\";\n+              break;\n+            case ISNUMBER_PROP:\n+              switch (x.intValue) {\n+                case BOTH:\n+                  value = \"both\";\n+                  break;\n+                case RIGHT:\n+                  value = \"right\";\n+                  break;\n+                case LEFT:\n+                  value = \"left\";\n+                  break;\n+                default:\n+                  throw Kit.codeBug();\n+              }\n+              break;\n+            case SPECIALCALL_PROP:\n+              switch (x.intValue) {\n+                case SPECIALCALL_EVAL:\n+                  value = \"eval\";\n+                  break;\n+                case SPECIALCALL_WITH:\n+                  value = \"with\";\n+                  break;\n+                default:\n+                  // NON_SPECIALCALL should not be stored\n+                  throw Kit.codeBug();\n+              }\n+              break;\n+            default:\n+              Object obj = x.objectValue;\n+              if (obj != null) {\n+                value = obj.toString();\n+              } else {\n+                value = String.valueOf(x.intValue);\n+              }\n+              break;\n+          }\n+          sb.append(value);\n+          sb.append(']');\n+        }\n+      }\n+\n+      if (printType) {\n+        if (jsType != null) {\n+          String jsTypeString = jsType.toString();\n+          if (jsTypeString != null) {\n+            sb.append(\" : \");\n+            sb.append(jsTypeString);\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+\n+  public String toStringTree() {\n+    return toStringTreeImpl();\n+  }\n+\n+  private String toStringTreeImpl() {\n+    try {\n+      StringBuffer s = new StringBuffer();\n+      appendStringTree(s);\n+      return s.toString();\n+    } catch (IOException e) {\n+      throw new RuntimeException(\"Should not happen\\n\" + e);\n+    }\n+  }\n+\n+  public void appendStringTree(Appendable appendable) throws IOException {\n+    toStringTreeHelper(this, 0, appendable);\n+  }\n+\n+  private static void toStringTreeHelper(Node n, int level, Appendable sb)\n+      throws IOException {\n+    if (Token.printTrees) {\n+      for (int i = 0; i != level; ++i) {\n+        sb.append(\"    \");\n+      }\n+      sb.append(n.toString());\n+      sb.append('\\n');\n+      for (Node cursor = n.getFirstChild();\n+           cursor != null;\n+           cursor = cursor.getNext()) {\n+        toStringTreeHelper(cursor, level + 1, sb);\n+      }\n+    }\n+  }\n+\n+  int type;              // type of the node; Token.NAME for example\n+  Node next;             // next sibling\n+  private Node first;    // first element of a linked list of children\n+  private Node last;     // last element of a linked list of children\n+\n+  /**\n+   * Linked list of properties. Since vast majority of nodes would have\n+   * no more then 2 properties, linked list saves memory and provides\n+   * fast lookup. If this does not holds, propListHead can be replaced\n+   * by UintMap.\n+   */\n+  private PropListItem propListHead;\n+\n+  /**\n+   * COLUMN_BITS represents how many of the lower-order bits of\n+   * sourcePosition are reserved for storing the column number.\n+   * Bits above these store the line number.\n+   * This gives us decent position information for everything except\n+   * files already passed through a minimizer, where lines might\n+   * be longer than 4096 characters.\n+   */\n+  public static final int COLUMN_BITS = 12;\n+\n+  /**\n+   * MAX_COLUMN_NUMBER represents the maximum column number that can\n+   * be represented.  JSCompiler's modifications to Rhino cause all\n+   * tokens located beyond the maximum column to MAX_COLUMN_NUMBER.\n+   */\n+  public static final int MAX_COLUMN_NUMBER = (1 << COLUMN_BITS) - 1;\n+\n+  /**\n+   * COLUMN_MASK stores a value where bits storing the column number\n+   * are set, and bits storing the line are not set.  It's handy for\n+   * separating column number from line number.\n+   */\n+  public static final int COLUMN_MASK = MAX_COLUMN_NUMBER;\n+\n+  /**\n+   * Source position of this node. The position is encoded with the\n+   * column number in the low 12 bits of the integer, and the line\n+   * number in the rest.  Create some handy constants so we can change this\n+   * size if we want.\n+   */\n+  private int sourcePosition;\n+\n+  private JSType jsType;\n+\n+  private Node parent;\n+\n+  //==========================================================================\n+  // Source position management\n+\n+  public void setLineno(int lineno) {\n+      int charno = getCharno();\n+      if (charno == -1) {\n+        charno = 0;\n+      }\n+      sourcePosition = mergeLineCharNo(lineno, charno);\n+  }\n+\n+  public void setCharno(int charno) {\n+      sourcePosition = mergeLineCharNo(getLineno(), charno);\n+  }\n+\n+  /**\n+   * Merges the line number and character number in one integer. The Character\n+   * number takes the first 12 bits and the line number takes the rest. If\n+   * the character number is greater than <code>2<sup>12</sup>-1</code> it is\n+   * adjusted to <code>2<sup>12</sup>-1</code>.\n+   */\n+  protected static int mergeLineCharNo(int lineno, int charno) {\n+    if (lineno < 0 || charno < 0) {\n+      return -1;\n+    } else if ((charno & ~COLUMN_MASK) != 0) {\n+      return lineno << COLUMN_BITS | COLUMN_MASK;\n+    } else {\n+      return lineno << COLUMN_BITS | (charno & COLUMN_MASK);\n+    }\n+  }\n+\n+  /**\n+   * Extracts the line number and character number from a merged line char\n+   * number (see {@link #mergeLineCharNo(int, int)}).\n+   */\n+  protected static int extractLineno(int lineCharNo) {\n+    if (lineCharNo == -1) {\n+      return -1;\n+    } else {\n+      return lineCharNo >>> COLUMN_BITS;\n+    }\n+  }\n+\n+  /**\n+   * Extracts the character number and character number from a merged line\n+   * char number (see {@link #mergeLineCharNo(int, int)}).\n+   */\n+  protected static int extractCharno(int lineCharNo) {\n+    if (lineCharNo == -1) {\n+      return -1;\n+    } else {\n+      return lineCharNo & COLUMN_MASK;\n+    }\n+  }\n+\n+  //==========================================================================\n+  // Iteration\n+\n+  /**\n+   * <p>Return an iterable object that iterates over this nodes's children.\n+   * The iterator does not support the optional operation\n+   * {@link Iterator#remove()}.</p>\n+   *\n+   * <p>To iterate over a node's siblings, one can write</p>\n+   * <pre>Node n = ...;\n+   * for (Node child : n.children()) { ...</pre>\n+   */\n+  public Iterable<Node> children() {\n+    if (first == null) {\n+      return Collections.emptySet();\n+    } else {\n+      return new SiblingNodeIterable(first);\n+    }\n+  }\n+\n+  /**\n+   * <p>Return an iterable object that iterates over this nodes's siblings.\n+   * The iterator does not support the optional operation\n+   * {@link Iterator#remove()}.</p>\n+   *\n+   * <p>To iterate over a node's siblings, one can write</p>\n+   * <pre>Node n = ...;\n+   * for (Node sibling : n.siblings()) { ...</pre>\n+   */\n+  public Iterable<Node> siblings() {\n+    return new SiblingNodeIterable(this);\n+  }\n+\n+  /**\n+   * @see Node#siblings()\n+   */\n+  private static final class SiblingNodeIterable\n+      implements Iterable<Node>, Iterator<Node> {\n+    private final Node start;\n+    private Node current;\n+    private boolean used;\n+\n+    SiblingNodeIterable(Node start) {\n+      this.start = start;\n+      this.current = start;\n+      this.used = false;\n+    }\n+\n+    public Iterator<Node> iterator() {\n+      if (!used) {\n+        used = true;\n+        return this;\n+      } else {\n+        // We have already used the current object as an iterator;\n+        // we must create a new SiblingNodeIterable based on this\n+        // iterable's start node.\n+        //\n+        // Since the primary use case for Node.children is in for\n+        // loops, this branch is extremely unlikely.\n+        return (new SiblingNodeIterable(start)).iterator();\n+      }\n+    }\n+\n+    public boolean hasNext() {\n+      return current != null;\n+    }\n+\n+    public Node next() {\n+      if (current == null) {\n+        throw new NoSuchElementException();\n+      }\n+      try {\n+        return current;\n+      } finally {\n+        current = current.getNext();\n+      }\n+    }\n+\n+    public void remove() {\n+      throw new UnsupportedOperationException();\n+    }\n+  }\n+\n+  // ==========================================================================\n+  // Accessors\n+\n+  public Node getParent() {\n+    return parent;\n+  }\n+\n+  /**\n+   * Gets the ancestor node relative to this.\n+   *\n+   * @param level 0 = this, 1 = the parent, etc.\n+   */\n+  public Node getAncestor(int level) {\n+    Preconditions.checkArgument(level >= 0);\n+    Node node = this;\n+    while (node != null && level-- > 0) {\n+      node = node.getParent();\n+    }\n+    return node;\n+  }\n+\n+  /**\n+   * Iterates all of the node's ancestors excluding itself.\n+   */\n+  public AncestorIterable getAncestors() {\n+    return new AncestorIterable(this.getParent());\n+  }\n+\n+  /**\n+   * Iterator to go up the ancestor tree.\n+   */\n+  public static class AncestorIterable implements Iterable<Node> {\n+    private Node cur;\n+\n+    /**\n+     * @param cur The node to start.\n+     */\n+    AncestorIterable(Node cur) {\n+      this.cur = cur;\n+    }\n+\n+    public Iterator<Node> iterator() {\n+      return new Iterator<Node>() {\n+        public boolean hasNext() {\n+          return cur != null;\n+        }\n+\n+        public Node next() {\n+          if (!hasNext()) throw new NoSuchElementException();\n+          Node n = cur;\n+          cur = cur.getParent();\n+          return n;\n+        }\n+\n+        public void remove() {\n+          throw new UnsupportedOperationException();\n+        }\n+      };\n+    }\n+  }\n+\n+  /**\n+   * Check for one child more efficiently than by iterating over all the\n+   * children as is done with Node.getChildCount().\n+   *\n+   * @return Whether the node has exactly one child.\n+   */\n+  public boolean hasOneChild() {\n+    return first != null && first == last;\n+  }\n+\n+  /**\n+   * Check for more than one child more efficiently than by iterating over all\n+   * the children as is done with Node.getChildCount().\n+   *\n+   * @return Whether the node more than one child.\n+   */\n+  public boolean hasMoreThanOneChild() {\n+    return first != null && first != last;\n+  }\n+\n+  public int getChildCount() {\n+    int c = 0;\n+    for (Node n = first; n != null; n = n.next)\n+      c++;\n+\n+    return c;\n+  }\n+\n+  // Intended for testing and verification only.\n+  public boolean hasChild(Node child) {\n+    for (Node n = first; n != null; n = n.getNext()) {\n+      if (child == n) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Checks if the subtree under this node is the same as another subtree.\n+   * Returns null if it's equal, or a message describing the differences.\n+   */\n+  public String checkTreeEquals(Node node2) {\n+      NodeMismatch diff = checkTreeEqualsImpl(node2);\n+      if (diff != null) {\n+        return \"Node tree inequality:\" +\n+            \"\\nTree1:\\n\" + toStringTree() +\n+            \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n+            \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n+            \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree();\n+      }\n+      return null;\n+  }\n+\n+  /**\n+   * If this is a compilation pass and not a test, do not construct error\n+   * strings. Instead return true if the trees are equal.\n+   */\n+  public boolean checkTreeEqualsSilent(Node node2) {\n+    return checkTreeEqualsImpl(node2) == null;\n+  }\n+\n+  /**\n+   * Helper function to ignore differences in Node subclasses that are no longer\n+   * used.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  static private Class getNodeClass(Node n) {\n+    Class c = n.getClass();\n+    if (c == FunctionNode.class || c == ScriptOrFnNode.class) {\n+      return Node.class;\n+    }\n+    return c;\n+  }\n+\n+  /**\n+   * Compare this node to node2 recursively and return the first pair of nodes\n+   * that differs doing a preorder depth-first traversal. Package private for\n+   * testing. Returns null if the nodes are equivalent.\n+   */\n+  NodeMismatch checkTreeEqualsImpl(Node node2) {\n+    boolean eq = false;\n+\n+    if (type == node2.getType() && getChildCount() == node2.getChildCount()\n+        && getNodeClass(this) == getNodeClass(node2)) {\n+      eq = this.isEquivalentTo(node2);\n+    }\n+\n+    if (!eq) {\n+      return new NodeMismatch(this, node2);\n+    }\n+\n+    NodeMismatch res = null;\n+    Node n, n2;\n+    for (n = first, n2 = node2.first;\n+         res == null && n != null;\n+         n = n.next, n2 = n2.next) {\n+      res = n.checkTreeEqualsImpl(n2);\n+      if (res != null) {\n+        return res;\n+      }\n+    }\n+    return res;\n+  }\n+\n+  /**\n+   * Checks if the subtree under this node is the same as another subtree\n+   * including types. Returns null if it's equal, or a message describing the\n+   * differences.\n+   */\n+  public boolean checkTreeTypeAwareEqualsSilent(Node node2) {\n+    return checkTreeTypeAwareEqualsImpl(node2) == null;\n+  }\n+\n+  /**\n+   * Compare this node to node2 recursively and return the first pair of nodes\n+   * that differs doing a preorder depth-first traversal. Package private for\n+   * testing. Returns null if the nodes are equivalent.\n+   */\n+  NodeMismatch checkTreeTypeAwareEqualsImpl(Node node2) {\n+    boolean eq = false;\n+\n+    if (type == node2.getType()\n+        && getChildCount() == node2.getChildCount()\n+        && getClass() == node2.getClass()\n+        && Objects.equal(jsType, node2.getJSType())) {\n+\n+      eq = this.isEquivalentTo(node2);\n+    }\n+\n+    if (!eq) {\n+      return new NodeMismatch(this, node2);\n+    }\n+\n+    NodeMismatch res = null;\n+    Node n, n2;\n+    for (n = first, n2 = node2.first;\n+         res == null && n != null;\n+         n = n.next, n2 = n2.next) {\n+      res = n.checkTreeTypeAwareEqualsImpl(n2);\n+      if (res != null) {\n+        return res;\n+      }\n+    }\n+    return res;\n+  }\n+\n+  public static String tokenToName(int token) {\n+    switch (token) {\n+      case Token.ERROR:           return \"error\";\n+      case Token.EOF:             return \"eof\";\n+      case Token.EOL:             return \"eol\";\n+      case Token.ENTERWITH:       return \"enterwith\";\n+      case Token.LEAVEWITH:       return \"leavewith\";\n+      case Token.RETURN:          return \"return\";\n+      case Token.GOTO:            return \"goto\";\n+      case Token.IFEQ:            return \"ifeq\";\n+      case Token.IFNE:            return \"ifne\";\n+      case Token.SETNAME:         return \"setname\";\n+      case Token.BITOR:           return \"bitor\";\n+      case Token.BITXOR:          return \"bitxor\";\n+      case Token.BITAND:          return \"bitand\";\n+      case Token.EQ:              return \"eq\";\n+      case Token.NE:              return \"ne\";\n+      case Token.LT:              return \"lt\";\n+      case Token.LE:              return \"le\";\n+      case Token.GT:              return \"gt\";\n+      case Token.GE:              return \"ge\";\n+      case Token.LSH:             return \"lsh\";\n+      case Token.RSH:             return \"rsh\";\n+      case Token.URSH:            return \"ursh\";\n+      case Token.ADD:             return \"add\";\n+      case Token.SUB:             return \"sub\";\n+      case Token.MUL:             return \"mul\";\n+      case Token.DIV:             return \"div\";\n+      case Token.MOD:             return \"mod\";\n+      case Token.BITNOT:          return \"bitnot\";\n+      case Token.NEG:             return \"neg\";\n+      case Token.NEW:             return \"new\";\n+      case Token.DELPROP:         return \"delprop\";\n+      case Token.TYPEOF:          return \"typeof\";\n+      case Token.GETPROP:         return \"getprop\";\n+      case Token.SETPROP:         return \"setprop\";\n+      case Token.GETELEM:         return \"getelem\";\n+      case Token.SETELEM:         return \"setelem\";\n+      case Token.CALL:            return \"call\";\n+      case Token.NAME:            return \"name\";\n+      case Token.NUMBER:          return \"number\";\n+      case Token.STRING:          return \"string\";\n+      case Token.NULL:            return \"null\";\n+      case Token.THIS:            return \"this\";\n+      case Token.FALSE:           return \"false\";\n+      case Token.TRUE:            return \"true\";\n+      case Token.SHEQ:            return \"sheq\";\n+      case Token.SHNE:            return \"shne\";\n+      case Token.REGEXP:          return \"regexp\";\n+      case Token.POS:             return \"pos\";\n+      case Token.BINDNAME:        return \"bindname\";\n+      case Token.THROW:           return \"throw\";\n+      case Token.IN:              return \"in\";\n+      case Token.INSTANCEOF:      return \"instanceof\";\n+      case Token.GETVAR:          return \"getvar\";\n+      case Token.SETVAR:          return \"setvar\";\n+      case Token.TRY:             return \"try\";\n+      case Token.TYPEOFNAME:      return \"typeofname\";\n+      case Token.THISFN:          return \"thisfn\";\n+      case Token.SEMI:            return \"semi\";\n+      case Token.LB:              return \"lb\";\n+      case Token.RB:              return \"rb\";\n+      case Token.LC:              return \"lc\";\n+      case Token.RC:              return \"rc\";\n+      case Token.LP:              return \"lp\";\n+      case Token.RP:              return \"rp\";\n+      case Token.COMMA:           return \"comma\";\n+      case Token.ASSIGN:          return \"assign\";\n+      case Token.ASSIGN_BITOR:    return \"assign_bitor\";\n+      case Token.ASSIGN_BITXOR:   return \"assign_bitxor\";\n+      case Token.ASSIGN_BITAND:   return \"assign_bitand\";\n+      case Token.ASSIGN_LSH:      return \"assign_lsh\";\n+      case Token.ASSIGN_RSH:      return \"assign_rsh\";\n+      case Token.ASSIGN_URSH:     return \"assign_ursh\";\n+      case Token.ASSIGN_ADD:      return \"assign_add\";\n+      case Token.ASSIGN_SUB:      return \"assign_sub\";\n+      case Token.ASSIGN_MUL:      return \"assign_mul\";\n+      case Token.ASSIGN_DIV:      return \"assign_div\";\n+      case Token.ASSIGN_MOD:      return \"assign_mod\";\n+      case Token.HOOK:            return \"hook\";\n+      case Token.COLON:           return \"colon\";\n+      case Token.OR:              return \"or\";\n+      case Token.AND:             return \"and\";\n+      case Token.INC:             return \"inc\";\n+      case Token.DEC:             return \"dec\";\n+      case Token.DOT:             return \"dot\";\n+      case Token.FUNCTION:        return \"function\";\n+      case Token.EXPORT:          return \"export\";\n+      case Token.IMPORT:          return \"import\";\n+      case Token.IF:              return \"if\";\n+      case Token.ELSE:            return \"else\";\n+      case Token.SWITCH:          return \"switch\";\n+      case Token.CASE:            return \"case\";\n+      case Token.DEFAULT:         return \"default\";\n+      case Token.WHILE:           return \"while\";\n+      case Token.DO:              return \"do\";\n+      case Token.FOR:             return \"for\";\n+      case Token.BREAK:           return \"break\";\n+      case Token.CONTINUE:        return \"continue\";\n+      case Token.VAR:             return \"var\";\n+      case Token.WITH:            return \"with\";\n+      case Token.CATCH:           return \"catch\";\n+      case Token.FINALLY:         return \"finally\";\n+      case Token.RESERVED:        return \"reserved\";\n+      case Token.NOT:             return \"not\";\n+      case Token.VOID:            return \"void\";\n+      case Token.BLOCK:           return \"block\";\n+      case Token.ARRAYLIT:        return \"arraylit\";\n+      case Token.OBJECTLIT:       return \"objectlit\";\n+      case Token.LABEL:           return \"label\";\n+      case Token.TARGET:          return \"target\";\n+      case Token.LOOP:            return \"loop\";\n+      case Token.EXPR_VOID:       return \"expr_void\";\n+      case Token.EXPR_RESULT:     return \"expr_result\";\n+      case Token.JSR:             return \"jsr\";\n+      case Token.SCRIPT:          return \"script\";\n+      case Token.EMPTY:           return \"empty\";\n+      case Token.GET_REF:         return \"get_ref\";\n+      case Token.REF_SPECIAL:     return \"ref_special\";\n+    }\n+    return \"<unknown=\"+token+\">\";\n+  }\n+\n+  /** Returns true if this node is equivalent semantically to another */\n+  public boolean isEquivalentTo(Node node) {\n+    if (type == Token.ARRAYLIT) {\n+      try {\n+        int[] indices1 = (int[]) getProp(Node.SKIP_INDEXES_PROP);\n+        int[] indices2 = (int[]) node.getProp(Node.SKIP_INDEXES_PROP);\n+        if (indices1 == null) {\n+          if (indices2 != null) {\n+            return false;\n+          }\n+        } else if (indices2 == null) {\n+          return false;\n+        } else if (indices1.length != indices2.length) {\n+          return false;\n+        } else {\n+          for (int i = 0; i < indices1.length; i++) {\n+            if (indices1[i] != indices2[i]) {\n+              return false;\n+            }\n+          }\n+        }\n+      } catch (Exception e) {\n         return false;\n-    }\n-\n-    /**\n-     * This should only be called for STRING nodes created in object lits.\n-     */\n-    public void setQuotedString() {\n-        Kit.codeBug();\n-    }\n-\n-    static class NodeMismatch {\n-      final Node nodeA;\n-      final Node nodeB;\n-\n-      NodeMismatch(Node nodeA, Node nodeB) {\n-        this.nodeA = nodeA;\n-        this.nodeB = nodeB;\n-      }\n-\n-      @Override public boolean equals(Object object) {\n-        if (object instanceof NodeMismatch) {\n-          NodeMismatch that = (NodeMismatch) object;\n-          return that.nodeA.equals(this.nodeA) && that.nodeB.equals(this.nodeB);\n+      }\n+    } else if (type == Token.INC || type == Token.DEC) {\n+      int post1 = this.getIntProp(INCRDECR_PROP, 0);\n+      int post2 = node.getIntProp(INCRDECR_PROP, 0);\n+      if (post1 != post2) {\n+        return false;\n+      }\n+    } else if (type == Token.STRING) {\n+      int quoted1 = this.getIntProp(QUOTED_PROP, 0);\n+      int quoted2 = node.getIntProp(QUOTED_PROP, 0);\n+      if (quoted1 != quoted2) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  public boolean hasSideEffects() {\n+    switch (type) {\n+      case Token.EXPR_VOID:\n+      case Token.COMMA:\n+        if (last != null)\n+          return last.hasSideEffects();\n+        else\n+          return true;\n+\n+      case Token.HOOK:\n+        if (first == null || first.next == null || first.next.next == null) {\n+          Kit.codeBug();\n         }\n+        return first.next.hasSideEffects() && first.next.next.hasSideEffects();\n+\n+      case Token.ERROR: // Avoid cascaded error messages\n+      case Token.EXPR_RESULT:\n+      case Token.ASSIGN:\n+      case Token.ASSIGN_ADD:\n+      case Token.ASSIGN_SUB:\n+      case Token.ASSIGN_MUL:\n+      case Token.ASSIGN_DIV:\n+      case Token.ASSIGN_MOD:\n+      case Token.ASSIGN_BITOR:\n+      case Token.ASSIGN_BITXOR:\n+      case Token.ASSIGN_BITAND:\n+      case Token.ASSIGN_LSH:\n+      case Token.ASSIGN_RSH:\n+      case Token.ASSIGN_URSH:\n+      case Token.ENTERWITH:\n+      case Token.LEAVEWITH:\n+      case Token.RETURN:\n+      case Token.GOTO:\n+      case Token.IFEQ:\n+      case Token.IFNE:\n+      case Token.NEW:\n+      case Token.DELPROP:\n+      case Token.SETNAME:\n+      case Token.SETPROP:\n+      case Token.SETELEM:\n+      case Token.CALL:\n+      case Token.THROW:\n+      case Token.RETHROW:\n+      case Token.SETVAR:\n+      case Token.CATCH_SCOPE:\n+      case Token.RETURN_RESULT:\n+      case Token.SET_REF:\n+      case Token.DEL_REF:\n+      case Token.REF_CALL:\n+      case Token.TRY:\n+      case Token.SEMI:\n+      case Token.INC:\n+      case Token.DEC:\n+      case Token.EXPORT:\n+      case Token.IMPORT:\n+      case Token.IF:\n+      case Token.ELSE:\n+      case Token.SWITCH:\n+      case Token.WHILE:\n+      case Token.DO:\n+      case Token.FOR:\n+      case Token.BREAK:\n+      case Token.CONTINUE:\n+      case Token.VAR:\n+      case Token.CONST:\n+      case Token.WITH:\n+      case Token.CATCH:\n+      case Token.FINALLY:\n+      case Token.BLOCK:\n+      case Token.LABEL:\n+      case Token.TARGET:\n+      case Token.LOOP:\n+      case Token.JSR:\n+      case Token.SETPROP_OP:\n+      case Token.SETELEM_OP:\n+      case Token.LOCAL_BLOCK:\n+      case Token.SET_REF_OP:\n+        return true;\n+\n+      default:\n         return false;\n-      }\n-\n-      @Override public int hashCode() {\n-        return Objects.hashCode(nodeA, nodeB);\n-      }\n-    }\n+    }\n+  }\n+\n+  /**\n+   * This function takes a set of GETPROP nodes and produces a string that is\n+   * each property separated by dots. If the node ultimately under the left\n+   * sub-tree is not a simple name, this is not a valid qualified name.\n+   *\n+   * @return a null if this is not a qualified name, or a dot-separated string\n+   *         of the name and properties.\n+   */\n+  public String getQualifiedName() {\n+    if (type == Token.NAME) {\n+      return getString();\n+    } else if (type == Token.GETPROP) {\n+      String left = getFirstChild().getQualifiedName();\n+      if (left == null) {\n+        return null;\n+      }\n+      return left + \".\" + getLastChild().getString();\n+    } else if (type == Token.THIS) {\n+      return \"this\";\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Returns whether a node corresponds to a simple or a qualified name, such as\n+   * <code>x</code> or <code>a.b.c</code> or <code>this.a</code>.\n+   */\n+  public boolean isQualifiedName() {\n+    switch (getType()) {\n+      case Token.NAME:\n+      case Token.THIS:\n+        return true;\n+      case Token.GETPROP:\n+        return getFirstChild().isQualifiedName();\n+      default:\n+        return false;\n+    }\n+  }\n+\n+  /**\n+   * Returns whether a node corresponds to a simple or a qualified name without\n+   * a \"this\" reference, such as <code>a.b.c</code>, but not <code>this.a</code>\n+   * .\n+   */\n+  public boolean isUnscopedQualifiedName() {\n+    switch (getType()) {\n+      case Token.NAME:\n+        return true;\n+      case Token.GETPROP:\n+        return getFirstChild().isUnscopedQualifiedName();\n+      default:\n+        return false;\n+    }\n+  }\n+\n+  // ==========================================================================\n+  // Mutators\n+\n+  /**\n+   * Removes this node from its parent. Equivalent to:\n+   * node.getParent().removeChild();\n+   */\n+  public Node detachFromParent() {\n+    Preconditions.checkState(parent != null);\n+    parent.removeChild(this);\n+    return this;\n+  }\n+\n+  /**\n+   * Removes the first child of Node. Equivalent to:\n+   * node.removeChild(node.getFirstChild());\n+   *\n+   * @return The removed Node.\n+   */\n+  public Node removeFirstChild() {\n+    Node child = first;\n+    if (child != null) {\n+      removeChild(child);\n+    }\n+    return child;\n+  }\n+\n+  /**\n+   * @return A Node that is the head of the list of children.\n+   */\n+  public Node removeChildren() {\n+    Node children = first;\n+    for (Node child = first; child != null; child = child.getNext()) {\n+      child.parent = null;\n+    }\n+    first = null;\n+    last = null;\n+    return children;\n+  }\n+\n+  /**\n+   * Removes all children from this node and isolates the children from each\n+   * other.\n+   */\n+  public void detachChildren() {\n+    for (Node child = first; child != null;) {\n+      Node nextChild = child.getNext();\n+      child.parent = null;\n+      child.next = null;\n+      child = nextChild;\n+    }\n+    first = null;\n+    last = null;\n+  }\n+\n+  public Node removeChildAfter(Node prev) {\n+    Preconditions.checkArgument(prev.parent == this,\n+        \"prev is not a child of this node.\");\n+    Preconditions.checkArgument(prev.next != null,\n+        \"no next sibling.\");\n+\n+    Node child = prev.next;\n+    prev.next = child.next;\n+    if (child == last) last = prev;\n+    child.next = null;\n+    child.parent = null;\n+    return child;\n+  }\n+\n+  /**\n+   * @return A detached clone of the Node, specifically excluding its children.\n+   */\n+  public Node cloneNode() {\n+    Node result;\n+    try {\n+      result = (Node) super.clone();\n+      result.next = null;\n+      result.first = null;\n+      result.last = null;\n+      result.parent = null;\n+    } catch (CloneNotSupportedException e) {\n+      throw new RuntimeException(e.getMessage());\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * @return A detached clone of the Node and all its children.\n+   */\n+  public Node cloneTree() {\n+    Node result = cloneNode();\n+    for (Node n2 = getFirstChild(); n2 != null; n2 = n2.getNext()) {\n+      Node n2clone = n2.cloneTree();\n+      n2clone.parent = result;\n+      if (result.last != null) {\n+        result.last.next = n2clone;\n+      }\n+      if (result.first == null) {\n+        result.first = n2clone;\n+      }\n+      result.last = n2clone;\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * Copies source file, line and column number from the other\n+   * node given to the current node.\n+   * @return this\n+   */\n+  public Node copySourceLocationFrom(Node other) {\n+    if (getProp(SOURCEFILE_PROP) == null) {\n+      putProp(SOURCEFILE_PROP, other.getProp(SOURCEFILE_PROP));\n+      sourcePosition = other.sourcePosition;\n+    }\n+\n+    if (getLineno() == -1 || getCharno() == -1) {\n+      setLineno(other.getLineno());\n+      setCharno(other.getCharno());\n+    }\n+    return this;\n+  }\n+\n+  /**\n+   * Copies source file and name information from the other\n+   * node given to the current node. Used for maintaining\n+   * debug information across node append and remove operations.\n+   * @return this\n+   */\n+  public Node copyInformationFrom(Node other) {\n+    if (getProp(ORIGINALNAME_PROP) == null) {\n+        putProp(ORIGINALNAME_PROP, other.getProp(ORIGINALNAME_PROP));\n+    }\n+\n+    if (getProp(SOURCEFILE_PROP) == null) {\n+        putProp(SOURCEFILE_PROP, other.getProp(SOURCEFILE_PROP));\n+        sourcePosition = other.sourcePosition;\n+    }\n+\n+    return this;\n+  }\n+\n+  /**\n+   * Copies source file and name information from the other node to the\n+   * entire tree rooted at this node.\n+   * @return this\n+   */\n+  public Node copyInformationFromForTree(Node other) {\n+    copyInformationFrom(other);\n+    for (Node child = getFirstChild();\n+         child != null; child = child.getNext()) {\n+      child.copyInformationFromForTree(other);\n+    }\n+\n+    return this;\n+  }\n+\n+  //==========================================================================\n+  // Custom annotations\n+\n+  public JSType getJSType() {\n+      return jsType;\n+  }\n+\n+  public void setJSType(JSType jsType) {\n+      this.jsType = jsType;\n+  }\n+\n+  public FileLevelJsDocBuilder getJsDocBuilderForNode() {\n+    return new FileLevelJsDocBuilder();\n+  }\n+\n+  /**\n+   * An inner class that provides back-door access to the license\n+   * property of the JSDocInfo property for this node. This is only\n+   * meant to be used for top level script nodes where the\n+   * {@link com.google.javascript.jscomp.parsing.JsDocInfoParser} needs to\n+   * be able to append directly to the top level node, not just the\n+   * current node.\n+   */\n+  public class FileLevelJsDocBuilder {\n+    public void append(String fileLevelComment) {\n+      JSDocInfo jsDocInfo = getJSDocInfo();\n+      if (jsDocInfo == null) {\n+        // TODO(user): Is there a way to determine whether to\n+        // parse the JsDoc documentation from here?\n+        jsDocInfo = new JSDocInfo(false);\n+      }\n+      String license = jsDocInfo.getLicense();\n+      if (license == null) {\n+        license = \"\";\n+      }\n+      jsDocInfo.setLicense(license + fileLevelComment);\n+      setJSDocInfo(jsDocInfo);\n+    }\n+  }\n+\n+  /**\n+   * Get the {@link JSDocInfo} attached to this node.\n+   * @return the information or {@code null} if no JSDoc is attached to this\n+   * node\n+   */\n+  public JSDocInfo getJSDocInfo() {\n+    return (JSDocInfo) getProp(JSDOC_INFO_PROP);\n+  }\n+\n+  /**\n+   * Sets the {@link JSDocInfo} attached to this node.\n+   */\n+  public void setJSDocInfo(JSDocInfo info) {\n+      putProp(JSDOC_INFO_PROP, info);\n+  }\n+\n+  /**\n+   * Sets whether this node is a variable length argument node. This\n+   * method is meaningful only on {@link Token#NAME} nodes\n+   * used to define a {@link Token#FUNCTION}'s argument list.\n+   */\n+  public void setVarArgs(boolean varArgs) {\n+    putBooleanProp(VAR_ARGS_NAME, varArgs);\n+  }\n+\n+  /**\n+   * Returns whether this node is a variable length argument node. This\n+   * method's return value is meaningful only on {@link Token#NAME} nodes\n+   * used to define a {@link Token#FUNCTION}'s argument list.\n+   */\n+  public boolean isVarArgs() {\n+    return getBooleanProp(VAR_ARGS_NAME);\n+  }\n+\n+  /**\n+   * Sets whether this node is an optional argument node. This\n+   * method is meaningful only on {@link Token#NAME} nodes\n+   * used to define a {@link Token#FUNCTION}'s argument list.\n+   */\n+  public void setOptionalArg(boolean optionalArg) {\n+    putBooleanProp(OPT_ARG_NAME, optionalArg);\n+  }\n+\n+  /**\n+   * Returns whether this node is an optional argument node. This\n+   * method's return value is meaningful only on {@link Token#NAME} nodes\n+   * used to define a {@link Token#FUNCTION}'s argument list.\n+   */\n+  public boolean isOptionalArg() {\n+    return getBooleanProp(OPT_ARG_NAME);\n+  }\n+\n+  /**\n+   * Sets whether this is a synthetic block that should not be considered\n+   * a real source block.\n+   */\n+  public void setIsSyntheticBlock(boolean val) {\n+    putBooleanProp(SYNTHETIC_BLOCK_PROP, val);\n+  }\n+\n+  /**\n+   * Returns whether this is a synthetic block that should not be considered\n+   * a real source block.\n+   */\n+  public boolean isSyntheticBlock() {\n+    return getBooleanProp(SYNTHETIC_BLOCK_PROP);\n+  }\n+\n+  /**\n+   * Sets the ES5 directives on this node.\n+   */\n+  public void setDirectives(Set<String> val) {\n+    putProp(DIRECTIVES, val);\n+  }\n+\n+  /**\n+   * Returns the set of ES5 directives for this node.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  public Set<String> getDirectives() {\n+    return (Set<String>) getProp(DIRECTIVES);\n+  }\n+\n+  /**\n+   * Sets whether this is a synthetic block that should not be considered\n+   * a real source block.\n+   */\n+  public void setWasEmptyNode(boolean val) {\n+    putBooleanProp(EMPTY_BLOCK, val);\n+  }\n+\n+  /**\n+   * Returns whether this is a synthetic block that should not be considered\n+   * a real source block.\n+   */\n+  public boolean wasEmptyNode() {\n+    return getBooleanProp(EMPTY_BLOCK);\n+  }\n+\n+  /**\n+   * Marks this function or constructor call node as having no side effects.\n+   * This property is only meaningful for {@link Token#CALL} and\n+   * {@link Token#NEW} nodes.\n+   */\n+  public void setIsNoSideEffectsCall() {\n+    Preconditions.checkArgument(\n+       getType() == Token.CALL || getType() == Token.NEW,\n+       \"setIsNoSideEffectsCall only supports CALL and NEW nodes, got \" +\n+       Token.name(getType()));\n+\n+    putBooleanProp(NO_SIDE_EFFECTS_CALL, true);\n+  }\n+\n+  /**\n+   * Returns true if this node is a function or constructor call that\n+   * has no side effects.\n+   */\n+  public boolean isNoSideEffectsCall() {\n+    return getBooleanProp(NO_SIDE_EFFECTS_CALL);\n+  }\n+\n+  /**\n+   * This should only be called for STRING nodes created in object lits.\n+   */\n+  public boolean isQuotedString() {\n+    return false;\n+  }\n+\n+  /**\n+   * This should only be called for STRING nodes created in object lits.\n+   */\n+  public void setQuotedString() {\n+    Kit.codeBug();\n+  }\n+\n+  static class NodeMismatch {\n+    final Node nodeA;\n+    final Node nodeB;\n+\n+    NodeMismatch(Node nodeA, Node nodeB) {\n+      this.nodeA = nodeA;\n+      this.nodeB = nodeB;\n+    }\n+\n+    @Override\n+    public boolean equals(Object object) {\n+      if (object instanceof NodeMismatch) {\n+        NodeMismatch that = (NodeMismatch) object;\n+        return that.nodeA.equals(this.nodeA) && that.nodeB.equals(this.nodeB);\n+      }\n+      return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hashCode(nodeA, nodeB);\n+    }\n+  }\n }\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n    * @param returnType the function's return type or {@code null} to indicate\n    *        that the return type is unknown.\n    */\n-  @VisibleForTesting\n-  public FunctionType(JSTypeRegistry registry, String name, Node source,\n+  FunctionType(JSTypeRegistry registry, String name, Node source,\n       Node parameters, JSType returnType) {\n     this(registry, name, source, parameters, returnType, null, null, false,\n          false);\n    * @param typeOfThis The type of {@code this} in non-constructors.  May be\n    *        {@code null} to indicate that the type of {@code this} is unknown.\n    */\n-  public FunctionType(JSTypeRegistry registry, String name, Node source,\n+  FunctionType(JSTypeRegistry registry, String name, Node source,\n       Node parameters, JSType returnType, ObjectType typeOfThis) {\n     this(registry, name, source, parameters, returnType, typeOfThis,\n         null, false, false);\n    *        {@code null} to indicate that the type of {@code this} is unknown.\n    * @param templateTypeName The template type name or {@code null}.\n    */\n-  public FunctionType(JSTypeRegistry registry, String name, Node source,\n+  FunctionType(JSTypeRegistry registry, String name, Node source,\n       Node parameters, JSType returnType, ObjectType typeOfThis,\n       String templateTypeName) {\n     this(registry, name, source, parameters, returnType, typeOfThis,\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n     return new FunctionType(\n         this,\n         existingFunctionType.getReferenceName(),\n-        /** source node */ null,\n+        existingFunctionType.getSource(),\n         existingFunctionType.getParametersNode(),\n         returnType,\n         existingFunctionType.getTypeOfThis(),\n         existingFunctionType.getTemplateTypeName());\n+  }\n+\n+  /**\n+   * Creates a new function type based on an existing function type but\n+   * with a new {@code this} type.\n+   * @param existingFunctionType the existing function type.\n+   * @param thisType the new this type.\n+   */\n+  public FunctionType createFunctionTypeWithNewThisType(\n+      FunctionType existingFunctionType, ObjectType thisType) {\n+    return new FunctionType(\n+        this,\n+        existingFunctionType.getReferenceName(),\n+        existingFunctionType.getSource(),\n+        existingFunctionType.getParametersNode(),\n+        existingFunctionType.getReturnType(),\n+        thisType,\n+        existingFunctionType.getTemplateTypeName());\n+  }\n+\n+  /**\n+   * @param parameters the function's parameters or {@code null}\n+   *        to indicate that the parameter types are unknown.\n+   * @param returnType the function's return type or {@code null} to indicate\n+   *        that the return type is unknown.\n+   */\n+  public FunctionType createFunctionType(\n+      JSType returnType, Node parameters) {\n+    return new FunctionType(this, null, null, parameters, returnType);\n+  }\n+\n+  /**\n+   * @param name the function's name or {@code null} to indicate that the\n+   *        function is anonymous.\n+   * @param source the node defining this function. Its type\n+   *        ({@link Node#getType()}) must be {@link Token#FUNCTION}.\n+   * @param parameters the function's parameters or {@code null}\n+   *        to indicate that the parameter types are unknown.\n+   * @param returnType the function's return type or {@code null} to indicate\n+   *        that the return type is unknown.\n+   * @param typeOfThis The type of {@code this} in non-constructors.  May be\n+   *        {@code null} to indicate that the type of {@code this} is unknown.\n+   * @param templateTypeName The template type name or {@code null}.\n+   */\n+  public FunctionType createMethodTypeWithTypeTemplate(String name, Node source,\n+      Node parameters, JSType returnType, ObjectType typeOfThis,\n+      String templateTypeName) {\n+    return new FunctionType(this, name, source, parameters, returnType,\n+        typeOfThis, templateTypeName);\n+  }\n+\n+  /**\n+   * @param name the function's name or {@code null} to indicate that the\n+   *        function is anonymous.\n+   * @param source the node defining this function. Its type\n+   *        ({@link Node#getType()}) must be {@link Token#FUNCTION}.\n+   * @param parameters the function's parameters or {@code null}\n+   *        to indicate that the parameter types are unknown.\n+   * @param returnType the function's return type or {@code null} to indicate\n+   *        that the return type is unknown.\n+   * @param typeOfThis The type of {@code this} in non-constructors.  May be\n+   *        {@code null} to indicate that the type of {@code this} is unknown.\n+   */\n+  public FunctionType createMethodType(String name, Node source,\n+      Node parameters, JSType returnType, ObjectType typeOfThis) {\n+    return new FunctionType(this, name, source, parameters, returnType,\n+        typeOfThis);\n+  }\n+\n+  /**\n+   * @param parameters the function's parameters or {@code null}\n+   *        to indicate that the parameter types are unknown.\n+   * @param returnType the function's return type or {@code null} to indicate\n+   *        that the return type is unknown.\n+   * @param typeOfThis The type of {@code this} in non-constructors.  May be\n+   *        {@code null} to indicate that the type of {@code this} is unknown.\n+   */\n+  public FunctionType createMethodType(\n+      JSType returnType, Node parameters, ObjectType typeOfThis) {\n+    return new FunctionType(this, null, null, parameters,\n+        returnType, typeOfThis);\n   }\n \n   /**\n--- a/src/com/google/javascript/rhino/testing/BaseJSTypeTestCase.java\n+++ b/src/com/google/javascript/rhino/testing/BaseJSTypeTestCase.java\n       JSTypeRegistry registry, ObjectType receivingType, String methodName,\n       JSType returnType) {\n     receivingType.defineDeclaredProperty(methodName,\n-        new FunctionType(registry, null, null, null, returnType), true);\n+        registry.createMethodType(returnType, null, null), true);\n   }\n \n   protected JSType createUnionType(JSType... variants) {\n--- a/test/com/google/javascript/jscomp/CollapsePropertiesTest.java\n+++ b/test/com/google/javascript/jscomp/CollapsePropertiesTest.java\n         compiler, collapsePropertiesOnExternTypes, true);\n   }\n \n+  @Override\n+  public void setUp() {\n+    super.enableLineNumberCheck(true);\n+  }\n+\n   /** {@inheritDoc} */\n   @Override public int getNumRepetitions() {\n     return 1;\n--- a/test/com/google/javascript/jscomp/DevirtualizePrototypeMethodsTest.java\n+++ b/test/com/google/javascript/jscomp/DevirtualizePrototypeMethodsTest.java\n   @Override\n   protected void setUp() throws Exception {\n     super.setUp();\n+    super.enableLineNumberCheck(true);\n     disableTypeCheck();\n   }\n \n--- a/test/com/google/javascript/jscomp/FoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/FoldConstantsTest.java\n \n   public FoldConstantsTest() {\n     super();\n+  }\n+\n+  @Override\n+  public void setUp() {\n+    super.enableLineNumberCheck(true);\n   }\n \n   @Override\n--- a/test/com/google/javascript/jscomp/MinimizeExitPointsTest.java\n+++ b/test/com/google/javascript/jscomp/MinimizeExitPointsTest.java\n  * @author johnlenz@google.com (John Lenz)\n  */\n public class MinimizeExitPointsTest extends CompilerTestCase {\n+\n+  @Override\n+  public void setUp() {\n+    super.enableLineNumberCheck(true);\n+  }\n \n   @Override\n   protected CompilerPass getProcessor(final Compiler compiler) {\n--- a/test/com/google/javascript/jscomp/NodeUtilTest.java\n+++ b/test/com/google/javascript/jscomp/NodeUtilTest.java\n \n import com.google.common.collect.Lists;\n import com.google.common.collect.Sets;\n-import com.google.javascript.rhino.FunctionNode;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.ScriptOrFnNode;\n import com.google.javascript.rhino.Token;\n \n import junit.framework.TestCase;\n     List<Node> params = Lists.newArrayList(Node.newString(Token.NAME, \"p1\"),\n                                            Node.newString(Token.NAME, \"p2\"),\n                                            Node.newString(Token.NAME, \"p3\"));\n-    FunctionNode function = NodeUtil.newFunctionNode(\n+    Node function = NodeUtil.newFunctionNode(\n         \"foo\", params, body, -1, -1);\n-    ScriptOrFnNode actual = new ScriptOrFnNode(Token.SCRIPT);\n+    Node actual = new Node(Token.SCRIPT);\n     actual.addChildToFront(function);\n     String difference = expected.checkTreeEquals(actual);\n     if (difference != null) {\n--- a/test/com/google/javascript/jscomp/RemoveConstantExpressionsTest.java\n+++ b/test/com/google/javascript/jscomp/RemoveConstantExpressionsTest.java\n   }\n \n   @Override\n+  public void setUp() {\n+    super.enableLineNumberCheck(true);\n+  }\n+\n+  @Override\n   protected int getNumRepetitions() {\n     // Pass reaches steady state after just 1 iteration\n     return 1;\n--- a/test/com/google/javascript/jscomp/TypeInferenceTest.java\n+++ b/test/com/google/javascript/jscomp/TypeInferenceTest.java\n   public void testCall1() {\n     assuming(\"x\",\n         createNullableType(\n-            new FunctionType(registry, \"x\", null, null,\n-                registry.getNativeType(NUMBER_TYPE), null)));\n+            registry.createFunctionType(registry.getNativeType(NUMBER_TYPE))));\n     inFunction(\"var y = x();\");\n     verify(\"y\", NUMBER_TYPE);\n   }\n--- a/test/com/google/javascript/jscomp/parsing/ParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/ParserTest.java\n import com.google.javascript.jscomp.testing.TestErrorReporter;\n import com.google.javascript.rhino.JSDocInfo;\n import com.google.javascript.rhino.Node;\n-import com.google.javascript.rhino.ScriptOrFnNode;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.JSType;\n import com.google.javascript.rhino.jstype.JSTypeNative;\n   }\n \n   private Node createScript(Node n) {\n-    Node script = new ScriptOrFnNode(Token.SCRIPT);\n+    Node script = new Node(Token.SCRIPT);\n     script.addChildToBack(n);\n     return script;\n   }", "timestamp": 1271289215, "metainfo": ""}