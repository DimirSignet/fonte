{"sha": "dace90682a063279376435f07bd2379d70ae9c0e", "log": "Added a new CallGraph pass.  R=acleung DELTA=1728  (1728 added, 0 deleted, 0 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=82002   ", "commit": "\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/CallGraph.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Predicate;\n+import com.google.common.collect.Collections2;\n+import com.google.common.collect.LinkedHashMultimap;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Multimap;\n+import com.google.common.collect.Sets;\n+import com.google.javascript.jscomp.DefinitionsRemover.Definition;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;\n+import com.google.javascript.jscomp.graph.DiGraph;\n+import com.google.javascript.jscomp.graph.LinkedDirectedGraph;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * A pass the uses a {@link DefinitionProvider} to compute a call graph for an\n+ * AST.\n+ * \n+ * <p>A {@link CallGraph} connects {@link Function}s to {@link Callsite}s and \n+ * vice versa: each function in the graph links to the callsites it contains and\n+ * each callsite links to the functions it could call. Similarly, each callsite\n+ * links to the function that contains it and each function links to the\n+ * callsites that could call it.\n+ * \n+ * <p>The callgraph is not precise. That is, a callsite may indicate it can\n+ * call a function when in fact it does not do so in the running program. \n+ * \n+ * <p>The callgraph is also not complete: in some cases it may be unable to \n+ * determine some targets of a callsite. In this case, \n+ * Callsite.hasUnknownTarget() will return true.\n+ *\n+ * <p>The CallGraph doesn't (currently) have functions for externally defined\n+ * functions; however, callsites that target externs will have hasExternTarget()\n+ * return true.\n+ * \n+ * <p>TODO(dcc): Have CallGraph (optionally?) include functions for externs.\n+ *\n+ * @author dcc@google.com (Devin Coughlin)\n+ */\n+public class CallGraph implements CompilerPass { \n+  private AbstractCompiler compiler;\n+  \n+  /** Maps a function to the callsites contained in that function. */\n+  private Multimap<Function, Callsite> callsitesByContainingFunction =\n+      LinkedHashMultimap.create();\n+  \n+  /** \n+   * Maps an AST node (with type Token.CALL or Token.NEW) to a Callsite object.\n+   */\n+  private Map<Node, Callsite> callsitesByNode;\n+  \n+  /** Maps an AST node (with type Token.FUNCTION) to a Function object. */\n+  private Map<Node, Function> functionsByNode;\n+  \n+  /**\n+   * Will the call graph support looking up the callsites that could call a\n+   * given function?\n+   */\n+  private boolean computeBackwardGraph;\n+  \n+  /** \n+   * Maps a function to the callsites targeting that function. \n+   *\n+   * This data structure is only filled in if computeBackwardGraph is true.\n+   */\n+  private Multimap<Function, Callsite> callsitesByTargetingFunction;\n+  \n+  /**\n+   * Will the call graph support looking up the functions that a given callsite\n+   * can call?\n+   */\n+  private boolean computeForwardGraph;\n+ \n+  /**\n+   * Maps a callsite to the functions known to be targeted by that callsite. \n+   * \n+   * This data structure is only filled in if computeBackwardGraph if false.\n+   */\n+  private Multimap<Callsite, Function> targetFunctionsByCallsite;\n+  \n+  /**\n+   * If true, then the callgraph will use NameReferenceGraph as a \n+   * definition provider; otherwise, use the faster SimpleDefinitionProvider.\n+   */\n+  private boolean useNameReferenceGraph = false;\n+  \n+  /** Has the CallGraph already been constructed? */\n+  private boolean alreadyRun = false;\n+  \n+  /** The name we give the main function. */\n+  @VisibleForTesting\n+  public static final String MAIN_FUNCTION_NAME = \"{main}\";\n+  \n+  /**\n+   *  Represents the global function. Calling getBody() on this\n+   *  function will yield the global script/block.\n+   *  \n+   *  TODO(dcc): having a single main function is somewhat misleading. Perhaps\n+   *  it might be better to make CallGraph module aware and have one per\n+   *  module?\n+   */\n+  private Function mainFunction;\n+  \n+  /**\n+   * Creates a call graph object supporting the specified lookups.\n+   * \n+   * At leats one (and possibly both) of computeForwardGraph and\n+   * computeBackwardGraph must be true.\n+   * \n+   * @param compiler The compiler\n+   * @param computeForwardGraph Should the call graph allow lookup of the target\n+   *        functions a given callsite could call?\n+   * @param computeBackwardGraph Should the call graph allow lookup of the\n+   *        callsites that could call a given function?\n+   */\n+  public CallGraph(AbstractCompiler compiler, boolean computeForwardGraph,\n+      boolean computeBackwardGraph) {\n+    Preconditions.checkArgument(computeForwardGraph || computeBackwardGraph);\n+    \n+    this.compiler = compiler; \n+    \n+    this.computeForwardGraph = computeForwardGraph;\n+    this.computeBackwardGraph = computeBackwardGraph;\n+    \n+    callsitesByNode = Maps.newLinkedHashMap();\n+    functionsByNode = Maps.newLinkedHashMap();\n+    \n+    if (computeForwardGraph) {\n+      targetFunctionsByCallsite = LinkedHashMultimap.create();\n+    }\n+    \n+    if (computeBackwardGraph) {\n+      callsitesByTargetingFunction = LinkedHashMultimap.create();    \n+    }\n+  }\n+  \n+  /**\n+   * Creates a call graph object support both forward and backward lookups.\n+   */\n+  public CallGraph(AbstractCompiler compiler) {\n+    this(compiler, true, true);\n+  }\n+  \n+  /**\n+   * Builds a call graph for the given externsRoot and jsRoot.\n+   * This method must not be called more than once per CallGraph instance.\n+   */\n+  @Override\n+  public void process(Node externsRoot, Node jsRoot) {\n+    Preconditions.checkState(alreadyRun == false);\n+ \n+    createFunctions(jsRoot);\n+    \n+    // Depends on createFunctions already being called.\n+    createCallsites();\n+      \n+    DefinitionProvider definitionProvider =\n+        constructDefinitionProvider(externsRoot, jsRoot);\n+    \n+    // Depends on createCallsites already being called\n+    connectCallsitesToTargets(definitionProvider);\n+    \n+    alreadyRun = true;\n+  }\n+\n+  /**\n+   * Returns the call graph Function object corresponding to the provided\n+   * AST Token.FUNCTION node, or null if no such object exists.\n+   */\n+  public Function getFunctionForAstNode(Node functionNode) {\n+    Preconditions.checkArgument(NodeUtil.isFunction(functionNode));\n+    \n+    return functionsByNode.get(functionNode);\n+  }\n+  \n+  /**\n+   * Returns a Function object representing the \"main\" global function.\n+   */\n+  public Function getMainFunction() {\n+    return mainFunction;\n+  }\n+  \n+  /**\n+   * Returns a collection of all functions (including the main function)\n+   * in the call graph.\n+   */\n+  public Collection<Function> getAllFunctions() {\n+    return functionsByNode.values();\n+  }\n+  \n+  /**\n+   * Finds a function with the given name. Throws an exception if\n+   * there are no functions or multiple functions with the name. This is\n+   * for testing purposes only.\n+   */\n+  @VisibleForTesting\n+  public Function getUniqueFunctionWithName(final String desiredName) {  \n+    Collection<Function> functions =\n+        Collections2.<Function>filter(getAllFunctions(),\n+            new Predicate<Function>() {\n+        public boolean apply(Function function) {\n+\n+          String functionName = function.getName();\n+          // Anonymous functions will have null names,\n+          // so it is important to  handle that correctly here\n+          if (functionName != null && desiredName != null) {\n+            return desiredName.equals(functionName);\n+          } else {\n+            return desiredName == functionName;\n+          }\n+        }\n+      });\n+\n+    if (functions.size() == 1) {\n+      return functions.iterator().next();\n+    } else {\n+      throw new IllegalStateException(\"Found \" + functions.size() \n+          + \" functions with name \" + desiredName);\n+    }\n+  }\n+\n+  /**\n+   * Returns the call graph Callsite object corresponding to the provided\n+   * AST Token.CALL or Token.NEW node, or null if no such object exists.\n+   */\n+  public Callsite getCallsiteForAstNode(Node callsiteNode) {\n+    Preconditions.checkArgument(callsiteNode.getType() == Token.CALL || \n+        callsiteNode.getType() == Token.NEW);\n+    \n+    return callsitesByNode.get(callsiteNode);\n+  }\n+  \n+  /**\n+   * Returns a collection of all callsites in the call graph.\n+   */\n+  public Collection<Callsite> getAllCallsites() {\n+   return callsitesByContainingFunction.values();\n+  }\n+  \n+  /**\n+   * Create a Function object for given an Token.FUNCTION AST node.\n+   * \n+   * This is the bottleneck for Function creation: all Functions should\n+   * be created with this method.\n+   */\n+  private Function createFunction(Node functionNode) {\n+    Function function = new Function(functionNode);\n+    functionsByNode.put(functionNode, function); \n+    \n+    return function;\n+  }\n+  \n+  private void createFunctions(Node jsRoot) {\n+    // Create fake function representing global execution\n+    mainFunction = createFunction(jsRoot);\n+    \n+    for (Node n : collectAllFunctionNodesInSubtree(jsRoot)) {\n+      createFunction(n);\n+    }\n+  }\n+  \n+  private Callsite createCallsite(Node callsiteNode) {\n+    Callsite callsite = new Callsite(callsiteNode);   \n+    callsitesByNode.put(callsiteNode, callsite);\n+    \n+    return callsite;\n+  }\n+  \n+  private void createCallsites() {\n+    for (Function function : getAllFunctions()) {\n+      Collection<Node> callsitesInFunction =\n+          collectCallsiteNodesInShallowSubtree(function.getBodyNode());\n+          \n+      for (Node callsiteNode : callsitesInFunction) {    \n+        Callsite callsite = createCallsite(callsiteNode);\n+      \n+        callsitesByContainingFunction.put(function, callsite);       \n+        callsite.containingFunction = function;\n+      }\n+    }\n+  }\n+  \n+  /**\n+   * Maps each Callsite to the Function(s) it could call \n+   * and each Function to the Callsite(s) that could call it.\n+   * \n+   * If the definitionProvider cannot determine the target of a Callsite,\n+   * the Callsite's hasUnknownTarget field is set to true.\n+   * \n+   * If the definitionProvider determins that the target of a Callsite\n+   * could be an extern-defined function, then the Callsite's hasExternTarget\n+   * field is set to true.\n+   * \n+   * @param definitionProvider The DefinitionProvider used to determine\n+   *    targets of callsites.\n+   */\n+  private void connectCallsitesToTargets(DefinitionProvider definitionProvider)\n+      {  \n+    for (Function function : getAllFunctions()) {\n+      for (Callsite callsite : callsitesByContainingFunction.get(function)) {\n+        Collection<Definition> definitions =\n+            lookupDefinitionsForTargetsOfCall(callsite.getAstNode(),\n+                definitionProvider);\n+\n+        if (definitions == null) {\n+          callsite.hasUnknownTarget = true; \n+        } else {\n+          for (Definition definition : definitions) {\n+            if (definition.isExtern()) {\n+              callsite.hasExternTarget = true;\n+            } else {\n+              Node target = definition.getRValue();\n+\n+              if (target != null && NodeUtil.isFunction(target)) {\n+                Function targetFunction = functionsByNode.get(target);\n+                \n+                if (computeForwardGraph) {\n+                  targetFunctionsByCallsite.put(callsite, targetFunction);\n+                }\n+                \n+                if (computeBackwardGraph) {\n+                  callsitesByTargetingFunction.put(targetFunction, callsite);\n+                }             \n+              } else {\n+                  callsite.hasUnknownTarget = true;                 \n+              }\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+  \n+  /**\n+   * Constructs and returns a directed graph where the nodes are functions and\n+   * the edges are callsites connecting callers to callees.\n+   * \n+   * It is safe to call this method on both forward and backwardly constructed\n+   * CallGraphs.\n+   */\n+  public DiGraph<Function, Callsite> getForwardDirectedGraph() {\n+    return constructDirectedGraph(true);\n+  }\n+  \n+  /**\n+   * Constructs and returns a directed graph where the nodes are functions and\n+   * the edges are callsites connecting callees to callers.\n+   * \n+   * It is safe to call this method on both forward and backwardly constructed\n+   * CallGraphs.\n+   */\n+  public DiGraph<Function, Callsite> getBackwardDirectedGraph() {\n+    return constructDirectedGraph(false);\n+  }\n+  \n+  private static void digraphConnect(DiGraph<Function, Callsite> digraph,\n+      Function caller,\n+      Callsite callsite,\n+      Function callee,\n+      boolean forward) {\n+    \n+    Function source;\n+    Function destination;\n+\n+    if (forward) {\n+      source = caller;\n+      destination = callee;\n+    } else {\n+      source = callee;\n+      destination = caller;\n+    }\n+    \n+    digraph.connect(source, callsite, destination);\n+  }\n+  \n+  /**\n+   * Constructs a digraph of the call graph. If {@code forward} is true, then\n+   * the edges in the digraph will go from callers to callees, if false then\n+   * the edges will go from callees to callers.\n+   * \n+   * It is safe to run this method on both a forwardly constructed callgraph\n+   * and a backwardly constructed callgraph, regardless of the value of\n+   * {@code forward}.\n+   * \n+   * @param forward If true then the digraph will be a forward digraph.\n+   */\n+  private DiGraph<Function, Callsite> constructDirectedGraph(boolean forward) {\n+    DiGraph<Function, Callsite>digraph =\n+        new LinkedDirectedGraph<Function, Callsite>();\n+    \n+    // Create nodes in call graph\n+    for (Function function : getAllFunctions()) {\n+      digraph.createNode(function);\n+    }\n+    \n+    if (computeForwardGraph) {\n+      // The CallGraph is a forward graph, so go from callers to callees\n+      for (Function caller : getAllFunctions()) {\n+        for (Callsite callsite : caller.getCallsitesInFunction()) {\n+          for (Function callee : callsite.getPossibleTargets()) {\n+            digraphConnect(digraph, caller, callsite, callee,\n+                forward);       \n+          }\n+        }\n+      }\n+    } else {\n+      // The CallGraph is a backward graph, so go from callees to callers\n+      for (Function callee : getAllFunctions()) {\n+        for (Callsite callsite :\n+            callee.getCallsitesPossiblyTargetingFunction()) {\n+          \n+          Function caller = callsite.getContainingFunction();\n+          digraphConnect(digraph, caller, callsite, callee,\n+              forward);\n+        }\n+      }\n+    }    \n+    \n+    return digraph;\n+  }\n+  \n+  /**\n+   * Constructs a DefinitionProvider that can be used to determine the\n+   * targets of callsites.\n+   * \n+   * This construction is the main cost of building the callgraph, so we offer\n+   * the client a choice of NameReferenceGraph, which is slow and hopefully more\n+   * precise, and SimpleDefinitionFinder, which is fast and perhaps not as\n+   * precise.\n+   * \n+   * We use SimpleNameFinder as the default because in practice it does\n+   * not appear to be less precise than NameReferenceGraph and is at least an\n+   * order of magnitude faster on large compiles.\n+   */\n+  private DefinitionProvider constructDefinitionProvider(Node externsRoot,\n+        Node jsRoot) {\n+    if (useNameReferenceGraph) {\n+      // Name reference graph is very, very slow\n+      NameReferenceGraphConstruction graphConstruction \n+          = new NameReferenceGraphConstruction(compiler);\n+\n+      graphConstruction.process(externsRoot, jsRoot);\n+\n+      return graphConstruction.getNameReferenceGraph();\n+    } else {\n+      SimpleDefinitionFinder defFinder = new SimpleDefinitionFinder(compiler);\n+      defFinder.process(externsRoot, jsRoot);\n+      return defFinder;\n+    }   \n+  }\n+  \n+  /**\n+   * Queries the definition provider for the definitions that could be the\n+   * targets of the given callsite node.\n+   * \n+   * This is complicated by the fact that NameReferenceGraph and\n+   * SimpleDefinitionProvider (the two definition providers we currently\n+   * use) differ on the types of target nodes they will analyze.\n+   */\n+  private Collection<Definition> lookupDefinitionsForTargetsOfCall(\n+      Node callsite, DefinitionProvider definitionProvider) {\n+    Preconditions.checkArgument(callsite.getType() == Token.CALL\n+        || callsite.getType() == Token.NEW);\n+    \n+    Node targetExpression = callsite.getFirstChild();\n+    \n+    // NameReferenceGraph throws an exception unless the node is\n+    // a GETPROP or a NAME\n+    if (!useNameReferenceGraph \n+        || (NodeUtil.isGetProp(targetExpression)\n+        ||  NodeUtil.isName(targetExpression))) {\n+      \n+      Collection<Definition> definitions = \n+        definitionProvider.getDefinitionsReferencedAt(targetExpression);\n+      \n+      if (definitions != null && !definitions.isEmpty()) {\n+        return definitions;\n+      }\n+    }\n+    \n+    return null;\n+  }\n+  \n+  private Set<Node> collectAllFunctionNodesInSubtree(Node subtree) {\n+    final Set<Node> functionNodes = Sets.newLinkedHashSet();\n+    \n+    NodeTraversal.traverse(compiler, subtree, new AbstractPostOrderCallback() {  \n+      @Override\n+      public void visit(NodeTraversal t, Node n, Node parent) {\n+        if (NodeUtil.isFunction(n)) {\n+          functionNodes.add(n);\n+        }\n+      }\n+    });\n+    \n+    return functionNodes;\n+  }\n+  \n+  private Collection<Node> collectCallsiteNodesInShallowSubtree(Node subtree) {  \n+    final Collection<Node> callsites = Sets.newLinkedHashSet();\n+    \n+    NodeTraversal.traverse(compiler, subtree, new AbstractShallowCallback() {  \n+      @Override\n+      public void visit(NodeTraversal t, Node potentialCallsite, Node parent) {\n+        int nodeType = potentialCallsite.getType();       \n+        if (nodeType == Token.CALL || nodeType == Token.NEW) {\n+          callsites.add(potentialCallsite);\n+        }   \n+      }\n+    });\n+    \n+    return callsites;\n+  }\n+  \n+  /**\n+   * An inner class that represents functions in the call graph.\n+   * A Function knows how to get its AST node and what Callsites\n+   * it contains.\n+   */\n+  public class Function {\n+    \n+    private Node astNode;\n+    \n+    private Function(Node functionAstNode) {\n+      astNode = functionAstNode;\n+    }\n+    \n+    /**\n+     * Does this function represent the global \"main\" function?\n+     */\n+    public boolean isMain() {\n+      return (this == CallGraph.this.mainFunction);\n+    }\n+    \n+    /**\n+     * Returns the underlying AST node for the function. This usually\n+     * has type Token.FUNCTION but in the case of the \"main\" function\n+     * will have type Token.BLOCK.\n+     */\n+    public Node getAstNode() {\n+      return astNode;\n+    }\n+    \n+    /**\n+     * Returns the AST node for the body of the function. If this function\n+     * is the main function, it will return the global block.\n+     */\n+    public Node getBodyNode() {\n+      if (isMain()) {\n+        return astNode;\n+      } else {\n+        return NodeUtil.getFunctionBody(astNode);\n+      }\n+    }\n+    \n+    /**\n+     * Gets the name of this function. Returns null if the function is\n+     * anonymous.\n+     */\n+    public String getName() {\n+      if (isMain()) {\n+        return MAIN_FUNCTION_NAME;\n+      } else {\n+        return NodeUtil.getFunctionName(astNode);\n+      }\n+    }\n+    \n+    /**\n+     * Returns the callsites in this functon.\n+     */\n+    public Collection<Callsite> getCallsitesInFunction() {\n+      return CallGraph.this.callsitesByContainingFunction.get(this);\n+    }\n+    \n+    /**\n+     * Returns a collection of callsites that might call this function.\n+     * \n+     * getCallsitesPossiblyTargetingFunction() is a best effort only: the\n+     * collection may include callsites that do not actually call this function\n+     * and if this function is exported or aliased may be missing actual\n+     * targets. \n+     * \n+     * This method should not be called on a Function from a CallGraph\n+     * that was constructed with {@code computeBackwardGraph} {@code false}.\n+     */\n+    public Collection<Callsite> getCallsitesPossiblyTargetingFunction() {\n+      if (computeBackwardGraph) {\n+        return CallGraph.this.callsitesByTargetingFunction.get(this);\n+      } else {\n+        throw new UnsupportedOperationException(\"Cannot call \" +\n+            \"getCallsitesPossiblyTargetingFunction() on a Function \"\n+            + \"from a backward-forward CallGraph\");\n+      }\n+    }\n+  \n+    // TODO(dcc): Add supported for querying whether a function is aliased\n+    // or exported. (If a function is not aliased or exported, then\n+    // getCallsitesPossiblyTargetingFunction() truly contains all possible\n+    // targets that could call the function).\n+  }\n+  \n+  /**\n+   * An inner class that represents call sites in the call graph.\n+   * A Callsite knows how to get its AST node, what its containing\n+   * Function is, and what its target Functions are.\n+   */\n+  public class Callsite {\n+    private Node astNode;\n+    \n+    private boolean hasUnknownTarget = false;\n+    private boolean hasExternTarget = false;\n+     \n+    private Function containingFunction = null;\n+    \n+    private Callsite(Node callsiteAstNode) {\n+      astNode = callsiteAstNode;\n+    }\n+    \n+    public Node getAstNode() {\n+      return astNode;\n+    }\n+    \n+    public Function getContainingFunction() {\n+      return containingFunction;\n+    }\n+    \n+    /**\n+     * Returns the possible target functions that this callsite could call.\n+     * \n+     * These targets do not include functions defined in externs. If this\n+     * callsite could call an extern function, then hasExternTarget() will\n+     * return true.\n+     * \n+     * getKnownTargets() is a best effort only: the collection may include\n+     * other functions that are not actual targets and (if hasUnknownTargets()\n+     * is true) may be missing actual targets.\n+     * \n+     * This method should not be called on a Callsite from a CallGraph\n+     * that was constructed with {@code computeForwardGraph} {@code false}.\n+     */\n+    public Collection<Function> getPossibleTargets() {\n+      if (computeForwardGraph) {\n+        return CallGraph.this.targetFunctionsByCallsite.get(this);\n+      } else {\n+        throw new UnsupportedOperationException(\"Cannot call \" +\n+            \"getPossibleTargets() on a Callsite from a non-forward \" +\n+            \"CallGraph\");\n+      }\n+    }\n+    \n+    /**\n+     * If true, then DefinitionProvider used in callgraph construction\n+     * was unable find all target functions of this callsite.\n+     * \n+     * If false, then getKnownTargets() contains all the possible targets of\n+     * this callsite (and, perhaps, additional targets as well).\n+     */\n+    public boolean hasUnknownTarget() {\n+      return hasUnknownTarget;\n+    }\n+    \n+    /**\n+     * If true, then this callsite could target a function defined in the\n+     * externs. If false, then not.\n+     */\n+    public boolean hasExternTarget() {\n+      return hasExternTarget;\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/test/com/google/javascript/jscomp/CallGraphTest.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n+import com.google.javascript.jscomp.CallGraph.Callsite;\n+import com.google.javascript.jscomp.CallGraph.Function;\n+import com.google.javascript.jscomp.graph.FixedPointGraphTraversal;\n+import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * Tests for CallGraph.\n+ * \n+ * @author dcc@google.com (Devin Coughlin)\n+ */\n+public class CallGraphTest extends CompilerTestCase {\n+\n+  private CallGraph currentProcessor;\n+  \n+  private boolean createForwardCallGraph;\n+  private boolean createBackwardCallGraph;\n+  \n+  @Override\n+  protected CompilerPass getProcessor(Compiler compiler) {\n+    // We store the new callgraph so it can be tested later\n+    currentProcessor = new CallGraph(compiler, createForwardCallGraph,\n+        createBackwardCallGraph);\n+    \n+    return currentProcessor;\n+  }\n+  \n+  static final String SHARED_EXTERNS = \n+      \"var ExternalFunction = function(a) {}\\n\" +\n+      \"var externalnamespace = {}\\n\" +\n+      \"externalnamespace.prop = function(){};\\n\";\n+  \n+  public void testGetFunctionForAstNode() {\n+    String source = \"function A() {};\\n\";\n+    \n+    CallGraph callgraph = compileAndRunForward(source);\n+    \n+    CallGraph.Function functionA = callgraph.getUniqueFunctionWithName(\"A\");\n+    \n+    Node functionANode = functionA.getAstNode();\n+    \n+    assertEquals(functionA, callgraph.getFunctionForAstNode(functionANode));\n+  }\n+  \n+  public void testGetAllFunctions() {  \n+    String source = \n+        \"function A() {}\\n\" +\n+        \"var B = function() {\\n\" +\n+        \"(function C(){A()})()\\n\" + \n+        \"};\\n\";\n+      \n+    CallGraph callgraph = compileAndRunForward(source);\n+    \n+    Collection<CallGraph.Function> functions = callgraph.getAllFunctions();\n+    \n+    // 3 Functions, plus one for the main function\n+    assertEquals(4, functions.size());\n+    \n+    CallGraph.Function functionA = \n+        callgraph.getUniqueFunctionWithName(\"A\");\n+    CallGraph.Function functionB =\n+        callgraph.getUniqueFunctionWithName(\"B\");\n+    CallGraph.Function functionC =\n+        callgraph.getUniqueFunctionWithName(\"C\");\n+    \n+    assertEquals(\"A\", NodeUtil.getFunctionName(functionA.getAstNode()));\n+    assertEquals(\"B\", NodeUtil.getFunctionName(functionB.getAstNode()));\n+    assertEquals(\"C\", NodeUtil.getFunctionName(functionC.getAstNode()));\n+  }\n+  \n+  public void testGetAllFunctionsContainsNormalFunction() {\n+    String source = \"function A(){}\\n\";\n+    \n+    CallGraph callgraph = compileAndRunForward(source);\n+        \n+    Collection<CallGraph.Function> allFunctions = callgraph.getAllFunctions();\n+    \n+    // 2 functions: one for A() and one for the main function\n+    assertEquals(2, allFunctions.size());\n+    \n+   assertTrue(allFunctions.contains(callgraph.getUniqueFunctionWithName(\"A\")));\n+   assertTrue(allFunctions.contains(callgraph.getMainFunction()));\n+  }\n+  \n+  public void testGetAllFunctionsContainsVarAssignedLiteralFunction() {\n+    String source = \"var A = function(){}\\n\";\n+    \n+    CallGraph callgraph = compileAndRunForward(source);\n+        \n+    Collection<CallGraph.Function> allFunctions = callgraph.getAllFunctions();\n+    \n+    // 2 functions: one for A() and one for the global function\n+    assertEquals(2, allFunctions.size());\n+\n+    Function functionA = callgraph.getUniqueFunctionWithName(\"A\");\n+    assertTrue(allFunctions.contains(functionA));  \n+    assertTrue(allFunctions.contains(callgraph.getMainFunction()));\n+  }\n+\n+  public void testGetAllFunctionsContainsNamespaceAssignedLiteralFunction() {\n+    String source = \n+        \"var namespace = {};\\n\" +\n+        \"namespace.A = function(){};\\n\";\n+    \n+    CallGraph callgraph = compileAndRunForward(source);\n+        \n+    Collection<CallGraph.Function> allFunctions = callgraph.getAllFunctions();\n+    \n+    // 2 functions: one for namespace.A() and one for the global function\n+    assertEquals(2, allFunctions.size());\n+\n+    assertTrue(allFunctions.contains(\n+        callgraph.getUniqueFunctionWithName(\"namespace.A\")));  \n+    assertTrue(allFunctions.contains(callgraph.getMainFunction()));\n+  }\n+ \n+  public void testGetAllFunctionsContainsLocalFunction() {\n+    String source = \n+        \"var A = function(){var B = function(){}};\\n\";\n+    \n+    CallGraph callgraph = compileAndRunForward(source);\n+        \n+    Collection<CallGraph.Function> allFunctions = callgraph.getAllFunctions();\n+    \n+    // 3 functions: one for A, B, and global function\n+    assertEquals(3, allFunctions.size());\n+\n+    assertTrue(allFunctions.contains(callgraph.getUniqueFunctionWithName(\"A\")));\n+    assertTrue(allFunctions.contains(callgraph.getUniqueFunctionWithName(\"B\")));\n+    assertTrue(allFunctions.contains(callgraph.getMainFunction()));\n+  }\n+\n+  public void testGetAllFunctionsContainsAnonymousFunction() {\n+    String source = \n+        \"var A = function(){(function(){})();};\\n\";\n+    \n+    CallGraph callgraph = compileAndRunForward(source);\n+        \n+    Collection<CallGraph.Function> allFunctions = callgraph.getAllFunctions();\n+    \n+    // 3 functions: A, anonymous, and global function\n+    assertEquals(3, allFunctions.size());\n+\n+    assertTrue(allFunctions.contains(callgraph.getUniqueFunctionWithName(\"A\")));\n+    assertTrue(\n+        allFunctions.contains(callgraph.getUniqueFunctionWithName(null)));\n+    assertTrue(allFunctions.contains(callgraph.getMainFunction()));\n+  }\n+  \n+  public void testGetCallsiteForAstNode() {\n+    String source =\n+        \"function A() {B()};\\n\" +\n+        \"function B(){};\\n\";\n+    \n+    CallGraph callgraph = compileAndRunBackward(source);\n+    \n+    CallGraph.Function functionA = callgraph.getUniqueFunctionWithName(\"A\");   \n+    CallGraph.Callsite callToB =\n+        functionA.getCallsitesInFunction().iterator().next();\n+    \n+    Node callsiteNode = callToB.getAstNode();\n+    \n+    assertEquals(callToB, callgraph.getCallsiteForAstNode(callsiteNode));\n+  }\n+    \n+  public void testFunctionGetCallsites() {  \n+    String source = \n+        \"function A() {var x; x()}\\n\" +\n+        \"var B = function() {\\n\" +\n+        \"(function C(){A()})()\\n\" + \n+        \"};\\n\";\n+      \n+    CallGraph callgraph = compileAndRunForward(source);\n+    \n+    CallGraph.Function functionA = callgraph.getUniqueFunctionWithName(\"A\");  \n+    Collection<CallGraph.Callsite> callsitesInA =\n+        functionA.getCallsitesInFunction();\n+    \n+    assertEquals(1, callsitesInA.size());\n+    \n+    CallGraph.Callsite firstCallsiteInA =\n+        callsitesInA.iterator().next();\n+    \n+    Node aTargetExpression = firstCallsiteInA.getAstNode().getFirstChild();\n+    assertEquals(Token.NAME, aTargetExpression.getType());\n+    assertEquals(\"x\", aTargetExpression.getString());\n+       \n+    CallGraph.Function functionB =\n+        callgraph.getUniqueFunctionWithName(\"B\");\n+    \n+    Collection<CallGraph.Callsite> callsitesInB =\n+        functionB.getCallsitesInFunction();\n+    \n+    assertEquals(1, callsitesInB.size());\n+    \n+    CallGraph.Callsite firstCallsiteInB =\n+      callsitesInB.iterator().next();\n+    \n+    Node bTargetExpression = firstCallsiteInB.getAstNode().getFirstChild();\n+    assertEquals(Token.FUNCTION, bTargetExpression.getType());\n+    assertEquals(\"C\", NodeUtil.getFunctionName(bTargetExpression));\n+    \n+    CallGraph.Function functionC =\n+        callgraph.getUniqueFunctionWithName(\"C\");\n+    \n+    Collection<CallGraph.Callsite> callsitesInC =\n+        functionC.getCallsitesInFunction();\n+    assertEquals(1, callsitesInC.size());\n+    \n+    CallGraph.Callsite firstCallsiteInC =\n+      callsitesInC.iterator().next();\n+    \n+    Node cTargetExpression = firstCallsiteInC.getAstNode().getFirstChild();\n+    assertEquals(Token.NAME, aTargetExpression.getType());\n+    assertEquals(\"A\", cTargetExpression.getString());\n+  }\n+  \n+  public void testFindNewInFunction() {\n+    String source = \"function A() {var x; new x(1,2)}\\n;\";\n+      \n+    CallGraph callgraph = compileAndRunForward(source);\n+  \n+    CallGraph.Function functionA =\n+        callgraph.getUniqueFunctionWithName(\"A\");\n+    Collection<CallGraph.Callsite> callsitesInA =\n+        functionA.getCallsitesInFunction();\n+    assertEquals(1, callsitesInA.size());\n+    \n+    Node callsiteInA = callsitesInA.iterator().next().getAstNode();\n+    assertEquals(Token.NEW, callsiteInA.getType());\n+    \n+    Node aTargetExpression = callsiteInA.getFirstChild();\n+    assertEquals(Token.NAME, aTargetExpression.getType());\n+    assertEquals(\"x\", aTargetExpression.getString());\n+  }\n+  \n+  public void testFindCallsiteTargetGlobalName() {\n+    String source = \n+      \"function A() {}\\n\" +\n+      \"function B() {}\\n\" +\n+      \"function C() {A()}\\n\";\n+    \n+    CallGraph callgraph = compileAndRunForward(source);\n+    \n+    CallGraph.Function functionC =\n+        callgraph.getUniqueFunctionWithName(\"C\");\n+    assertNotNull(functionC);\n+    \n+    CallGraph.Callsite callsiteInC =\n+        functionC.getCallsitesInFunction().iterator().next();\n+    assertNotNull(callsiteInC);\n+    \n+    Collection<CallGraph.Function> targetsOfCallsiteInC =\n+        callsiteInC.getPossibleTargets();\n+    \n+    assertNotNull(targetsOfCallsiteInC);\n+    assertEquals(1, targetsOfCallsiteInC.size());    \n+  }\n+  \n+  public void testFindCallsiteTargetAliasedGlobalProperty() {\n+    String source = \n+        \"var namespace = {};\\n\" +\n+        \"namespace.A = function() {};\\n\" +\n+        \"function C() {namespace.A()}\\n\";\n+    \n+    CallGraph callgraph = compileAndRunForward(source);\n+    \n+    CallGraph.Function functionC =\n+        callgraph.getUniqueFunctionWithName(\"C\");\n+    assertNotNull(functionC);\n+    \n+    CallGraph.Callsite callsiteInC =\n+        functionC.getCallsitesInFunction().iterator().next();\n+    \n+    assertNotNull(callsiteInC);\n+    \n+    Collection<CallGraph.Function> targetsOfCallsiteInC =\n+        callsiteInC.getPossibleTargets();\n+    \n+    assertNotNull(targetsOfCallsiteInC);\n+    assertEquals(1, targetsOfCallsiteInC.size());    \n+  }\n+  \n+  public void testGetAllCallsitesContainsMultiple() {\n+    String source = \n+        \"function A() {}\\n\" +\n+        \"var B = function() {\\n\" +\n+        \"(function (){A()})()\\n\" + \n+        \"};\\n\" +\n+        \"A();\\n\" +\n+        \"B();\\n\";\n+    \n+    CallGraph callgraph = compileAndRunBackward(source);\n+    \n+    Collection<CallGraph.Callsite> allCallsites = callgraph.getAllCallsites();\n+    \n+    assertEquals(4, allCallsites.size());\n+  }\n+  \n+  public void testGetAllCallsitesContainsGlobalSite() {\n+    String source =\n+        \"function A(){}\\n\" +\n+        \"A();\\n\";\n+    \n+    CallGraph callgraph = compileAndRunBackward(source);\n+    \n+    Collection<CallGraph.Callsite> allCallsites = callgraph.getAllCallsites();\n+    assertEquals(1, allCallsites.size());\n+    \n+    Node callsiteNode = allCallsites.iterator().next().getAstNode();\n+    assertEquals(Token.CALL, callsiteNode.getType());\n+    assertEquals(\"A\", callsiteNode.getFirstChild().getString()); \n+  }\n+  \n+  public void testGetAllCallsitesContainsLocalSite() {\n+    String source =\n+        \"function A(){}\\n\" +\n+        \"function B(){A();}\\n\";\n+  \n+    CallGraph callgraph = compileAndRunBackward(source);\n+  \n+    Collection<CallGraph.Callsite> allCallsites = callgraph.getAllCallsites();\n+    assertEquals(1, allCallsites.size());\n+  \n+    Node callsiteNode = allCallsites.iterator().next().getAstNode();\n+    assertEquals(Token.CALL, callsiteNode.getType());\n+    assertEquals(\"A\", callsiteNode.getFirstChild().getString());\n+  }\n+  \n+  public void testGetAllCallsitesContainsLiteralSite() {\n+    String source = \"function A(){(function(a){})();}\\n\";\n+    \n+    CallGraph callgraph = compileAndRunBackward(source);\n+\n+    Collection<CallGraph.Callsite> allCallsites = callgraph.getAllCallsites();\n+    assertEquals(1, allCallsites.size());\n+\n+    Node callsiteNode = allCallsites.iterator().next().getAstNode();\n+    assertEquals(Token.CALL, callsiteNode.getType());\n+    assertEquals(Token.FUNCTION, callsiteNode.getFirstChild().getType());    \n+  }\n+  \n+  public void testGetAllCallsitesContainsConstructorSite() {\n+    String source =\n+        \"function A(){}\\n\" +\n+        \"function B(){new A();}\\n\";\n+\n+    CallGraph callgraph = compileAndRunBackward(source);\n+\n+    Collection<CallGraph.Callsite> allCallsites = callgraph.getAllCallsites();\n+    assertEquals(1, allCallsites.size());\n+\n+    Node callsiteNode = allCallsites.iterator().next().getAstNode();\n+    assertEquals(Token.NEW, callsiteNode.getType());\n+    assertEquals(\"A\", callsiteNode.getFirstChild().getString());\n+  }\n+  \n+  /**\n+   * Test getting a backward directed graph on a backward call graph\n+   * and propagating over it.\n+   */\n+  public void testGetDirectedGraph_backwardOnBackward() { \n+    // For this test we create a simple callback that when, applied until a\n+    // fixedpoint, computes whether a function is \"poisoned\" by an extern.\n+    // A function is poisoned if it calls an extern or if it calls another\n+    // poisoned function.\n+    \n+    String source =\n+        \"function A(){};\\n\" +\n+        \"function B(){ExternalFunction(6); C(); D();}\\n\" +\n+        \"function C(){B(); A();};\\n\" +\n+        \"function D(){A();};\\n\" +\n+        \"function E(){C()};\\n\" +\n+        \"A();\\n\";\n+        \n+    CallGraph callgraph = compileAndRunBackward(source);\n+    \n+    final Set<Function> poisonedFunctions = Sets.newHashSet();\n+    \n+    // Set up initial poisoned functions\n+    for (Callsite callsite : callgraph.getAllCallsites()) {\n+      if (callsite.hasExternTarget()) {\n+        poisonedFunctions.add(callsite.getContainingFunction());\n+      }\n+    }\n+    \n+    // Propagate poison from callees to callers\n+    EdgeCallback<CallGraph.Function, CallGraph.Callsite> edgeCallback =\n+        new EdgeCallback<CallGraph.Function, CallGraph.Callsite>() {\n+          @Override\n+          public boolean traverseEdge(Function callee, Callsite callsite,\n+              Function caller) {\n+            boolean changed;\n+            \n+            if (poisonedFunctions.contains(callee)) {\n+              changed = poisonedFunctions.add(caller); // Returns true if added\n+            } else {\n+              changed = false;\n+            }\n+            \n+            return changed;\n+          }\n+    };\n+    \n+    FixedPointGraphTraversal.newTraversal(edgeCallback)\n+        .computeFixedPoint(callgraph.getBackwardDirectedGraph());  \n+    \n+    // We expect B, C, and E to poisoned.\n+    assertEquals(3, poisonedFunctions.size());\n+    \n+    assertTrue(poisonedFunctions.contains(\n+        callgraph.getUniqueFunctionWithName(\"B\")));\n+    assertTrue(poisonedFunctions.contains(\n+        callgraph.getUniqueFunctionWithName(\"C\")));\n+    assertTrue(poisonedFunctions.contains(\n+        callgraph.getUniqueFunctionWithName(\"E\")));   \n+  }\n+  \n+  /**\n+   * Test getting a backward directed graph on a forward call graph\n+   * and propagating over it.\n+   */\n+  public void testGetDirectedGraph_backwardOnForward() { \n+    // For this test we create a simple callback that when, applied until a\n+    // fixedpoint, computes whether a function is \"poisoned\" by an extern.\n+    // A function is poisoned if it calls an extern or if it calls another\n+    // poisoned function.\n+    \n+    String source =\n+        \"function A(){};\\n\" +\n+        \"function B(){ExternalFunction(6); C(); D();}\\n\" +\n+        \"function C(){B(); A();};\\n\" +\n+        \"function D(){A();};\\n\" +\n+        \"function E(){C()};\\n\" +\n+        \"A();\\n\";\n+        \n+    CallGraph callgraph = compileAndRunForward(source);\n+    \n+    final Set<Function> poisonedFunctions = Sets.newHashSet();\n+    \n+    // Set up initial poisoned functions\n+    for (Callsite callsite : callgraph.getAllCallsites()) {\n+      if (callsite.hasExternTarget()) {\n+        poisonedFunctions.add(callsite.getContainingFunction());\n+      }\n+    }\n+    \n+    // Propagate poison from callees to callers\n+    EdgeCallback<CallGraph.Function, CallGraph.Callsite> edgeCallback =\n+        new EdgeCallback<CallGraph.Function, CallGraph.Callsite>() {\n+          @Override\n+          public boolean traverseEdge(Function callee, Callsite callsite,\n+              Function caller) {\n+            boolean changed;\n+            \n+            if (poisonedFunctions.contains(callee)) {\n+              changed = poisonedFunctions.add(caller); // Returns true if added\n+            } else {\n+              changed = false;\n+            }\n+            \n+            return changed;\n+          }\n+    };\n+    \n+    FixedPointGraphTraversal.newTraversal(edgeCallback)\n+        .computeFixedPoint(callgraph.getBackwardDirectedGraph());  \n+    \n+    // We expect B, C, and E to poisoned.\n+    assertEquals(3, poisonedFunctions.size());\n+    \n+    assertTrue(poisonedFunctions.contains(\n+        callgraph.getUniqueFunctionWithName(\"B\")));\n+    assertTrue(poisonedFunctions.contains(\n+        callgraph.getUniqueFunctionWithName(\"C\")));\n+    assertTrue(poisonedFunctions.contains(\n+        callgraph.getUniqueFunctionWithName(\"E\")));   \n+  }\n+  \n+  /**\n+   * Test getting a forward directed graph on a forward call graph\n+   * and propagating over it.\n+   */\n+  public void testGetDirectedGraph_forwardOnForward() { \n+    // For this test we create a simple callback that when, applied until a\n+    // fixedpoint, computes whether a function is reachable from an initial\n+    // set of \"root\" nodes.\n+    \n+    String source =\n+        \"function A(){B()};\\n\" +\n+        \"function B(){C();D()}\\n\" +\n+        \"function C(){B()};\\n\" +\n+        \"function D(){};\\n\" +\n+        \"function E(){C()};\\n\" +\n+        \"function X(){Y()};\\n\" +\n+        \"function Y(){Z()};\\n\" + \n+        \"function Z(){};\" +\n+        \"B();\\n\";\n+        \n+    CallGraph callgraph = compileAndRunForward(source);\n+    \n+    final Set<Function> reachableFunctions = Sets.newHashSet();\n+    \n+    // We assume the main function and X are our roots\n+    reachableFunctions.add(callgraph.getMainFunction());\n+    reachableFunctions.add(callgraph.getUniqueFunctionWithName(\"X\"));\n+    \n+    // Propagate reachability from callers to callees\n+    \n+    EdgeCallback<CallGraph.Function, CallGraph.Callsite> edgeCallback =\n+        new EdgeCallback<CallGraph.Function, CallGraph.Callsite>() {\n+          @Override\n+          public boolean traverseEdge(Function caller, Callsite callsite,\n+              Function callee) {\n+            boolean changed;\n+            \n+            if (reachableFunctions.contains(caller)) {\n+              changed = reachableFunctions.add(callee); // Returns true if added\n+            } else {\n+              changed = false;\n+            }\n+            \n+            return changed;\n+          }\n+    };\n+    \n+    FixedPointGraphTraversal.newTraversal(edgeCallback)\n+        .computeFixedPoint(callgraph.getForwardDirectedGraph());  \n+    \n+    // We expect B, C, D, X, Y, Z and the main function should be reachable.\n+    // A and E should not be reachable.\n+    \n+    assertEquals(7, reachableFunctions.size());\n+  \n+    assertTrue(reachableFunctions.contains(\n+        callgraph.getUniqueFunctionWithName(\"B\")));\n+    assertTrue(reachableFunctions.contains(\n+        callgraph.getUniqueFunctionWithName(\"C\")));\n+    assertTrue(reachableFunctions.contains(\n+        callgraph.getUniqueFunctionWithName(\"D\")));\n+    assertTrue(reachableFunctions.contains(\n+        callgraph.getUniqueFunctionWithName(\"X\")));\n+    assertTrue(reachableFunctions.contains(\n+        callgraph.getUniqueFunctionWithName(\"Y\")));\n+    assertTrue(reachableFunctions.contains(\n+        callgraph.getUniqueFunctionWithName(\"Z\")));\n+    assertTrue(reachableFunctions.contains(\n+        callgraph.getMainFunction()));\n+    \n+    assertFalse(reachableFunctions.contains(\n+        callgraph.getUniqueFunctionWithName(\"A\")));\n+    assertFalse(reachableFunctions.contains(\n+        callgraph.getUniqueFunctionWithName(\"E\"))); \n+  }\n+  \n+  /**\n+   * Test getting a backward directed graph on a forward call graph\n+   * and propagating over it.\n+   */\n+  public void testGetDirectedGraph_forwardOnBackward() { \n+    // For this test we create a simple callback that when, applied until a\n+    // fixedpoint, computes whether a function is reachable from an initial\n+    // set of \"root\" nodes.\n+    \n+    String source =\n+        \"function A(){B()};\\n\" +\n+        \"function B(){C();D()}\\n\" +\n+        \"function C(){B()};\\n\" +\n+        \"function D(){};\\n\" +\n+        \"function E(){C()};\\n\" +\n+        \"function X(){Y()};\\n\" +\n+        \"function Y(){Z()};\\n\" + \n+        \"function Z(){};\" +\n+        \"B();\\n\";\n+        \n+    CallGraph callgraph = compileAndRunBackward(source);\n+    \n+    final Set<Function> reachableFunctions = Sets.newHashSet();\n+    \n+    // We assume the main function and X are our roots\n+    reachableFunctions.add(callgraph.getMainFunction());\n+    reachableFunctions.add(callgraph.getUniqueFunctionWithName(\"X\"));\n+    \n+    // Propagate reachability from callers to callees\n+    \n+    EdgeCallback<CallGraph.Function, CallGraph.Callsite> edgeCallback =\n+        new EdgeCallback<CallGraph.Function, CallGraph.Callsite>() {\n+          @Override\n+          public boolean traverseEdge(Function caller, Callsite callsite,\n+              Function callee) {\n+            boolean changed;\n+            \n+            if (reachableFunctions.contains(caller)) {\n+              changed = reachableFunctions.add(callee); // Returns true if added\n+            } else {\n+              changed = false;\n+            }\n+            \n+            return changed;\n+          }\n+    };\n+    \n+    FixedPointGraphTraversal.newTraversal(edgeCallback)\n+        .computeFixedPoint(callgraph.getForwardDirectedGraph());  \n+    \n+    // We expect B, C, D, X, Y, Z and the main function should be reachable.\n+    // A and E should not be reachable.\n+    \n+    assertEquals(7, reachableFunctions.size());\n+  \n+    assertTrue(reachableFunctions.contains(\n+        callgraph.getUniqueFunctionWithName(\"B\")));\n+    assertTrue(reachableFunctions.contains(\n+        callgraph.getUniqueFunctionWithName(\"C\")));\n+    assertTrue(reachableFunctions.contains(\n+        callgraph.getUniqueFunctionWithName(\"D\")));\n+    assertTrue(reachableFunctions.contains(\n+        callgraph.getUniqueFunctionWithName(\"X\")));\n+    assertTrue(reachableFunctions.contains(\n+        callgraph.getUniqueFunctionWithName(\"Y\")));\n+    assertTrue(reachableFunctions.contains(\n+        callgraph.getUniqueFunctionWithName(\"Z\")));\n+    assertTrue(reachableFunctions.contains(\n+        callgraph.getMainFunction()));\n+    \n+    assertFalse(reachableFunctions.contains(\n+        callgraph.getUniqueFunctionWithName(\"A\")));\n+    assertFalse(reachableFunctions.contains(\n+        callgraph.getUniqueFunctionWithName(\"E\"))); \n+  }\n+  \n+  public void testFunctionIsMain() {\n+    String source =\n+        \"function A(){};\\n\" +\n+        \"A();\\n\";\n+      \n+    CallGraph callgraph = compileAndRunForward(source);\n+\n+    CallGraph.Function mainFunction = callgraph.getMainFunction();\n+    \n+    assertTrue(mainFunction.isMain());\n+    assertNotNull(mainFunction.getBodyNode());\n+    assertTrue(mainFunction.getBodyNode().getType() == Token.BLOCK);\n+    \n+    CallGraph.Function functionA = callgraph.getUniqueFunctionWithName(\"A\");\n+    \n+    assertFalse(functionA.isMain());\n+  }\n+  \n+  public void testFunctionGetAstNode() {\n+    String source =\n+        \"function A(){};\\n\" +\n+        \"A();\\n\";\n+      \n+    CallGraph callgraph = compileAndRunForward(source);\n+  \n+    CallGraph.Function mainFunction = callgraph.getMainFunction();\n+    \n+    // Main function's AST node should be the global block\n+    assertTrue(mainFunction.getAstNode().getType() == Token.BLOCK);\n+    \n+    CallGraph.Function functionA = callgraph.getUniqueFunctionWithName(\"A\");\n+    \n+    // Regular function's AST node should be the function for A\n+    assertTrue(functionA.getAstNode().getType() == Token.FUNCTION);\n+    assertEquals(\"A\", NodeUtil.getFunctionName(functionA.getAstNode()));\n+  }\n+  \n+  public void testFunctionGetBodyNode() {\n+    String source =\n+        \"function A(){};\\n\" +\n+        \"A();\\n\";\n+      \n+    CallGraph callgraph = compileAndRunForward(source);\n+  \n+    CallGraph.Function mainFunction = callgraph.getMainFunction();\n+    \n+    // Main function's body node should its AST node\n+    assertEquals(mainFunction.getAstNode(), mainFunction.getBodyNode());\n+    \n+    CallGraph.Function functionA = callgraph.getUniqueFunctionWithName(\"A\");\n+    \n+    // Regular function's body node should be the block for A\n+    assertTrue(functionA.getBodyNode().getType() == Token.BLOCK);\n+    assertEquals(NodeUtil.getFunctionBody(functionA.getAstNode()),\n+        functionA.getBodyNode());\n+  }\n+ \n+  public void testFunctionGetName() {\n+    String source =\n+        \"function A(){};\\n\" +\n+        \"A();\\n\";\n+      \n+    CallGraph callgraph = compileAndRunForward(source);\n+  \n+    CallGraph.Function mainFunction = callgraph.getMainFunction();\n+    \n+    // Main function's name should be CallGraph.MAIN_FUNCTION_NAME\n+    assertEquals(CallGraph.MAIN_FUNCTION_NAME, mainFunction.getName());\n+    \n+    CallGraph.Function functionA = callgraph.getUniqueFunctionWithName(\"A\");\n+    \n+    // Regular function's name should be its name\n+    assertEquals(NodeUtil.getFunctionName(functionA.getAstNode()),\n+        functionA.getName());\n+  }\n+  \n+  public void testFunctionGetCallsitesInFunction() {\n+    String source =\n+        \"function A(){};\\n\" +\n+        \"function B(){A()};\\n\" +\n+        \"A();\\n\" +\n+        \"B();\\n\";\n+      \n+    CallGraph callgraph = compileAndRunForward(source);\n+  \n+    // Main function calls A and B\n+    CallGraph.Function mainFunction = callgraph.getMainFunction();\n+    List<String> callsiteNamesInMain =\n+        getCallsiteTargetNames(mainFunction.getCallsitesInFunction());\n+     \n+    assertEquals(2, callsiteNamesInMain.size());\n+    assertTrue(callsiteNamesInMain.contains(\"A\"));    \n+    assertTrue(callsiteNamesInMain.contains(\"B\"));\n+    \n+    // A calls no functions\n+    CallGraph.Function functionA = callgraph.getUniqueFunctionWithName(\"A\");  \n+    assertEquals(0, functionA.getCallsitesInFunction().size());\n+    \n+    // B calls A\n+    CallGraph.Function functionB = callgraph.getUniqueFunctionWithName(\"B\");\n+    List<String> callsiteNamesInB =\n+        getCallsiteTargetNames(functionB.getCallsitesInFunction());\n+    \n+    assertEquals(1, callsiteNamesInB.size());\n+    assertTrue(callsiteNamesInMain.contains(\"A\"));\n+  }\n+  \n+  public void testFunctionGetCallsitesInFunction_ignoreInnerFunction() {\n+    String source =\n+        \"function A(){var B = function(){C();}};\\n\" +\n+        \"function C(){};\\n\";\n+      \n+    CallGraph callgraph = compileAndRunForward(source);\n+  \n+    // A calls no functions (and especially not C)\n+    CallGraph.Function functionA = callgraph.getUniqueFunctionWithName(\"A\");  \n+    assertEquals(0, functionA.getCallsitesInFunction().size());\n+  }\n+  \n+  public void testFunctionGetCallsitesPossiblyTargetingFunction() {\n+    String source =\n+        \"function A(){B()};\\n\" +\n+        \"function B(){C();C();};\\n\" +\n+        \"function C(){C()};\\n\" +\n+        \"A();\\n\";\n+    \n+    CallGraph callgraph = compileAndRunBackward(source);\n+    \n+    Function main = callgraph.getMainFunction();\n+    Function functionA = callgraph.getUniqueFunctionWithName(\"A\");\n+    Function functionB = callgraph.getUniqueFunctionWithName(\"B\");\n+    Function functionC = callgraph.getUniqueFunctionWithName(\"C\");\n+    \n+    assertEquals(0, main.getCallsitesPossiblyTargetingFunction().size());\n+    \n+    Collection<Callsite> callsitesTargetingA =\n+        functionA.getCallsitesPossiblyTargetingFunction();\n+       \n+    // A is called only from the main function\n+    assertEquals(1, callsitesTargetingA.size());\n+    assertEquals(main,\n+        callsitesTargetingA.iterator().next().getContainingFunction());\n+    \n+    Collection<Callsite> callsitesTargetingB =\n+      functionB.getCallsitesPossiblyTargetingFunction();\n+  \n+    // B is called only from A\n+    assertEquals(1, callsitesTargetingB.size());\n+    assertEquals(functionA,\n+        callsitesTargetingB.iterator().next().getContainingFunction());\n+    \n+    Collection<Callsite> callsitesTargetingC =\n+      functionC.getCallsitesPossiblyTargetingFunction();\n+    \n+    // C is called 3 times: twice from B and once from C\n+    assertEquals(3, callsitesTargetingC.size());\n+    \n+    Collection<Callsite> expectedFunctionsCallingC =\n+        Sets.newHashSet(functionB.getCallsitesInFunction());\n+    expectedFunctionsCallingC.addAll(functionC.getCallsitesInFunction());\n+    \n+    assertTrue(callsitesTargetingC.containsAll(expectedFunctionsCallingC)); \n+  }\n+  \n+  public void testFunctionGetCallsitesInFunction_newIsCallsite() {\n+    String source =\n+        \"function A(){};\\n\" +\n+        \"function C(){new A()};\\n\";\n+      \n+    CallGraph callgraph = compileAndRunForward(source);\n+  \n+    // The call to new A() in C() should count as a callsite\n+    CallGraph.Function functionC = callgraph.getUniqueFunctionWithName(\"C\");  \n+    assertEquals(1, functionC.getCallsitesInFunction().size());\n+  }\n+  \n+  public void testCallsiteGetAstNode() {\n+    String source =\n+      \"function A(){B()};\\n\" +\n+      \"function B(){};\\n\";\n+  \n+    CallGraph callgraph = compileAndRunForward(source);\n+    \n+    Function functionA = callgraph.getUniqueFunctionWithName(\"A\");   \n+    Callsite callToB = functionA.getCallsitesInFunction().iterator().next();\n+    \n+    assertTrue(callToB.getAstNode().getType() == Token.CALL);\n+  }\n+  \n+  public void testCallsiteGetContainingFunction() {\n+    String source =\n+      \"function A(){B()};\\n\" +\n+      \"function B(){};\\n\" +\n+      \"A();\\n\";\n+  \n+    CallGraph callgraph = compileAndRunForward(source);\n+    \n+    Function mainFunction = callgraph.getMainFunction();\n+    Callsite callToA = mainFunction.getCallsitesInFunction().iterator().next();\n+    assertEquals(mainFunction, callToA.getContainingFunction());\n+    \n+    Function functionA = callgraph.getUniqueFunctionWithName(\"A\");\n+    Callsite callToB = functionA.getCallsitesInFunction().iterator().next();\n+    assertEquals(functionA, callToB.getContainingFunction());\n+  }\n+  \n+  public void testCallsiteGetKnownTargets() {\n+    String source =\n+      \"function A(){B()};\\n\" +\n+      \"function B(){};\\n\" +\n+      \"A();\\n\";\n+  \n+    CallGraph callgraph = compileAndRunForward(source);\n+    \n+    Function mainFunction = callgraph.getMainFunction();\n+    Function functionA = callgraph.getUniqueFunctionWithName(\"A\");\n+    Function functionB = callgraph.getUniqueFunctionWithName(\"B\");\n+    \n+    Callsite callInMain = mainFunction.getCallsitesInFunction().iterator()\n+        .next();\n+    \n+    Collection<Function> targetsOfCallInMain = callInMain.getPossibleTargets();\n+    \n+    assertEquals(1, targetsOfCallInMain.size());\n+    assertTrue(targetsOfCallInMain.contains(functionA));\n+    \n+    Callsite callInA = functionA.getCallsitesInFunction().iterator().next();\n+    Collection<Function> targetsOfCallInA = callInA.getPossibleTargets();\n+    \n+    assertTrue(targetsOfCallInA.contains(functionB));\n+  }\n+  \n+  public void testCallsiteHasUnknownTarget() {\n+    String source =\n+      \"var A = externalnamespace.prop;\\n\" +\n+      \"function B(){A();};\\n\" +\n+      \"B();\\n\";\n+  \n+    CallGraph callgraph = compileAndRunForward(source);\n+    \n+    Function mainFunction = callgraph.getMainFunction();\n+    Function functionB = callgraph.getUniqueFunctionWithName(\"B\");\n+    \n+    Callsite callInMain =\n+        mainFunction.getCallsitesInFunction().iterator().next();\n+    \n+    // B()'s target function is known, and it is functionB\n+    assertFalse(callInMain.hasUnknownTarget());\n+    assertEquals(\"B\", callInMain.getAstNode().getFirstChild().getString());\n+        \n+    Callsite callInB = functionB.getCallsitesInFunction().iterator().next();\n+    \n+    // A() has an unknown target and no known targets\n+    assertTrue(callInB.hasUnknownTarget());\n+    assertEquals(0, callInB.getPossibleTargets().size());\n+  }\n+  \n+  public void testCallsiteHasExternTarget() {\n+    String source =\n+      \"var A = function(){}\\n\" +\n+      \"function B(){ExternalFunction(6);};\\n\" +\n+      \"A();\\n\";\n+  \n+    CallGraph callgraph = compileAndRunForward(source);\n+    \n+    Function mainFunction = callgraph.getMainFunction();\n+    Function functionB = callgraph.getUniqueFunctionWithName(\"B\");\n+    \n+    Callsite callInMain =\n+        mainFunction.getCallsitesInFunction().iterator().next();\n+    \n+    // A()'s target function is not an extern\n+    assertFalse(callInMain.hasExternTarget());\n+    \n+    Callsite callInB = functionB.getCallsitesInFunction().iterator().next();\n+    \n+    assertEquals(\"ExternalFunction\",\n+        callInB.getAstNode().getFirstChild().getString());\n+    \n+    // ExternalFunction(6) is a call to an extern function\n+    assertTrue(callInB.hasExternTarget());\n+    assertEquals(0, callInB.getPossibleTargets().size());  \n+  }\n+  \n+  public void testThrowForBackwardOpOnForwardGraph() {\n+    String source =\n+      \"function A(){B()};\\n\" +\n+      \"function B(){C();C();};\\n\" +\n+      \"function C(){C()};\\n\" +\n+      \"A();\\n\";\n+\n+    CallGraph callgraph = compileAndRunForward(source);\n+\n+    Function functionA = callgraph.getUniqueFunctionWithName(\"A\");\n+\n+    UnsupportedOperationException caughtException = null;\n+    \n+    try {\n+      functionA.getCallsitesPossiblyTargetingFunction();\n+    } catch (UnsupportedOperationException e) {\n+      caughtException = e;\n+    }\n+   \n+    assertNotNull(caughtException);    \n+  }\n+  \n+  public void testThrowForForwardOpOnBackwardGraph() {\n+    String source =\n+      \"function A(){B()};\\n\" +\n+      \"function B(){};\\n\" +\n+      \"A();\\n\";\n+  \n+    CallGraph callgraph = compileAndRunBackward(source);\n+    \n+    Function mainFunction = callgraph.getMainFunction();\n+    Function functionA = callgraph.getUniqueFunctionWithName(\"A\");\n+    \n+    Callsite callInMain = mainFunction.getCallsitesInFunction().iterator()\n+        .next();\n+      \n+    UnsupportedOperationException caughtException = null;\n+    \n+    try {\n+      callInMain.getPossibleTargets();\n+    } catch (UnsupportedOperationException e) {\n+      return;\n+    }\n+    fail();   \n+  }\n+  \n+  /**\n+   * Helper function that, given a collection of callsites, returns a\n+   * collection of the names of the target expression nodes, e.g.\n+   * if the callsites are [A(), B.b()], the collection returned is\n+   * [\"A\", \"B\"].\n+   * \n+   * This makes it easier to test methods that return collections of callsites.\n+   * \n+   * An exception is thrown if the callsite target is not a simple name\n+   * (e.g. \"a.bar()\").\n+   */\n+  private List<String> getCallsiteTargetNames(Collection<Callsite>\n+      callsites) { \n+    List<String> result = Lists.newArrayList();\n+    \n+    for (Callsite callsite : callsites) {\n+      Node targetExpressionNode = callsite.getAstNode().getFirstChild();\n+      if (targetExpressionNode.getType() == Token.NAME) {\n+        result.add(targetExpressionNode.getString());\n+      } else {\n+        throw new IllegalStateException(\"Called getCallsiteTargetNames() on \" +\n+            \"a complex callsite.\");\n+      }\n+    }\n+    \n+    return result;\n+  }\n+ \n+  private CallGraph compileAndRunBackward(String js) {\n+    return compileAndRun(SHARED_EXTERNS, js, false, true);\n+  }\n+  \n+  private CallGraph compileAndRunForward(String js) {\n+    return compileAndRun(SHARED_EXTERNS, js, true, false);\n+  }\n+  \n+  private CallGraph compileAndRun(String externs,\n+      String js,\n+      boolean forward,\n+      boolean backward) {\n+    \n+    createBackwardCallGraph = backward;\n+    createForwardCallGraph = forward;\n+    \n+    testSame(externs, js, null);\n+    \n+    return currentProcessor;\n+  }\n+}", "timestamp": 1280517717, "metainfo": ""}