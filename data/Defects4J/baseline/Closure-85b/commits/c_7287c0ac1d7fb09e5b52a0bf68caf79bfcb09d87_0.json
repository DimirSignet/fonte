{"sha": "7287c0ac1d7fb09e5b52a0bf68caf79bfcb09d87", "log": "Speed up parsing a bit by refactoring how we pull jsdoc comments into the AST.  Revision created by MOE tool push_codebase. MOE_MIGRATION=   ", "commit": "\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/parsing/Annotation.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp.parsing;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+import java.util.Map;\n+\n+/**\n+ * All natively recognized JSDoc annotations.\n+*\n+ */\n+enum Annotation {\n+  AUTHOR,\n+  CONSTANT,\n+  CONSTRUCTOR,\n+  DEFINE,\n+  DEPRECATED,\n+  DESC,\n+  ENUM,\n+  EXTENDS,\n+  EXTERNS,\n+  EXPORT,\n+  FILE_OVERVIEW,\n+  HIDDEN,\n+  IMPLEMENTS,\n+  IMPLICIT_CAST,\n+  INHERIT_DOC,\n+  INTERFACE,\n+  JAVA_DISPATCH,\n+  LICENSE, // same as preserve\n+  NO_ALIAS,\n+  NO_SHADOW,\n+  NO_SIDE_EFFECTS,\n+  NO_TYPE_CHECK,\n+  NOT_IMPLEMENTED,\n+  OVERRIDE,\n+  PARAM,\n+  PRESERVE, // same as license\n+  PRESERVE_TRY,\n+  PRIVATE,\n+  PROTECTED,\n+  PUBLIC,\n+  RETURN,\n+  SEE,\n+  SUPPRESS,\n+  TEMPLATE,\n+  THIS,\n+  THROWS,\n+  TYPE,\n+  TYPEDEF,\n+  VERSION;\n+\n+  static final Map<String, Annotation> recognizedAnnotations =\n+      new ImmutableMap.Builder<String, Annotation>().\n+      put(\"argument\", Annotation.PARAM).\n+      put(\"author\", Annotation.AUTHOR).\n+      put(\"const\", Annotation.CONSTANT).\n+      put(\"constant\", Annotation.CONSTANT).\n+      put(\"constructor\", Annotation.CONSTRUCTOR).\n+      put(\"define\", Annotation.DEFINE).\n+      put(\"deprecated\", Annotation.DEPRECATED).\n+      put(\"desc\", Annotation.DESC).\n+      put(\"enum\", Annotation.ENUM).\n+      put(\"export\", Annotation.EXPORT).\n+      put(\"extends\", Annotation.EXTENDS).\n+      put(\"externs\", Annotation.EXTERNS).\n+      put(\"fileoverview\", Annotation.FILE_OVERVIEW).\n+      put(\"final\", Annotation.CONSTANT).\n+      put(\"hidden\", Annotation.HIDDEN).\n+      put(\"implements\", Annotation.IMPLEMENTS).\n+      put(\"implicitCast\", Annotation.IMPLICIT_CAST).\n+      put(\"inheritDoc\", Annotation.INHERIT_DOC).\n+      put(\"interface\", Annotation.INTERFACE).\n+      put(\"javadispatch\", Annotation.JAVA_DISPATCH).\n+      put(\"license\", Annotation.LICENSE).\n+      put(\"noalias\", Annotation.NO_ALIAS).\n+      put(\"noshadow\", Annotation.NO_SHADOW).\n+      put(\"nosideeffects\", Annotation.NO_SIDE_EFFECTS).\n+      put(\"notypecheck\", Annotation.NO_TYPE_CHECK).\n+      put(\"override\", Annotation.OVERRIDE).\n+      put(\"owner\", Annotation.AUTHOR).\n+      put(\"param\", Annotation.PARAM).\n+      put(\"preserve\", Annotation.PRESERVE).\n+      put(\"preserveTry\", Annotation.PRESERVE_TRY).\n+      put(\"private\", Annotation.PRIVATE).\n+      put(\"protected\", Annotation.PROTECTED).\n+      put(\"public\", Annotation.PUBLIC).\n+      put(\"return\", Annotation.RETURN).\n+      put(\"returns\", Annotation.RETURN).\n+      put(\"see\", Annotation.SEE).\n+      put(\"suppress\", Annotation.SUPPRESS).\n+      put(\"template\", Annotation.TEMPLATE).\n+      put(\"this\", Annotation.THIS).\n+      put(\"throws\", Annotation.THROWS).\n+      put(\"type\", Annotation.TYPE).\n+      put(\"typedef\", Annotation.TYPEDEF).\n+      put(\"version\", Annotation.VERSION).\n+      build();\n+}\n--- a/src/com/google/javascript/jscomp/parsing/Config.java\n+++ b/src/com/google/javascript/jscomp/parsing/Config.java\n \n package com.google.javascript.jscomp.parsing;\n \n+import com.google.common.collect.ImmutableMap;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n \n+import java.util.Map;\n import java.util.Set;\n \n /**\n   final boolean parseJsDocDocumentation;\n \n   /**\n-   * JSDoc annotations that should not be warned about, even if\n-   * the parser doesn't know what to do with them otherwise.\n+   * Recognized JSDoc annotations, mapped from their name to their internal\n+   * representation.\n    */\n-  final Set<String> annotationWhitelist;\n+  final Map<String, Annotation> annotationNames;\n+\n+  /**\n+   * Annotation names.\n+   */\n \n   Config(JSTypeRegistry registry, Set<String> annotationWhitelist,\n       boolean parseJsDocDocumentation) {\n     this.registry = registry;\n-    this.annotationWhitelist = annotationWhitelist;\n+    this.annotationNames = buildAnnotationNames(annotationWhitelist);\n     this.parseJsDocDocumentation = parseJsDocDocumentation;\n   }\n+\n+  /**\n+   * Create the annotation names from the user-specified\n+   * annotation whitelist.\n+   */\n+  private static Map<String, Annotation> buildAnnotationNames(\n+      Set<String> annotationWhitelist) {\n+    ImmutableMap.Builder<String, Annotation> annotationBuilder =\n+        ImmutableMap.builder();\n+    annotationBuilder.putAll(Annotation.recognizedAnnotations);\n+    for (String unrecognizedAnnotation : annotationWhitelist) {\n+      if (!Annotation.recognizedAnnotations.containsKey(\n+              unrecognizedAnnotation)) {\n+        annotationBuilder.put(\n+            unrecognizedAnnotation, Annotation.NOT_IMPLEMENTED);\n+      }\n+    }\n+    return annotationBuilder.build();\n+  }\n }\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n import static com.google.javascript.jscomp.mozilla.rhino.Token.CommentType.JSDOC;\n \n import com.google.common.base.Preconditions;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.LinkedHashMultimap;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Multimap;\n import com.google.common.collect.Sets;\n import com.google.javascript.jscomp.mozilla.rhino.ErrorReporter;\n import com.google.javascript.jscomp.mozilla.rhino.ast.ArrayLiteral;\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.JSTypeRegistry;\n \n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n import java.util.Set;\n \n /**\n *\n  */\n public class IRFactory {\n-  /**\n-   * Property used to temporarily store the JsDoc string in a node for later\n-   * transforming into a proper JSDocInfo.\n-   */\n-  private static int TMP_JSDOC_PROP = Node.LAST_PROP + 1;\n \n   private final String sourceString;\n   private final String sourceName;\n \n   // non-static for thread safety\n   private final Set<String> ALLOWED_DIRECTIVES = Sets.newHashSet(\"use strict\");\n+\n+  // Nodes with JSDoc comments, indexed by the text of the JSDoc comment.\n+  //\n+  // It's likely that two or more nodes in the same file may have the same\n+  // jsdoc comment. In general, that's ok.\n+  //\n+  // There's one edge case where this might cause problems. If two JSDoc\n+  // comments have the same text, and the first JSDoc comment is not attached\n+  // to a node, then the second node will get the first JSDoc comment\n+  // instead of the second. When this happens, it probably won't cause any\n+  // problems. The two JSDoc comments will be exactly the same, except for\n+  // their line numbers. Their line numbers will only be exposed for\n+  // type name resolution warnings.\n+  //\n+  // TODO(nicksantos): Change rhino to put the whole Comment object\n+  // on the Node.\n+  private final Multimap<String, NodeWithJsDoc> nodesWithJsDoc =\n+      LinkedHashMultimap.create();\n \n   private IRFactory(String sourceString,\n                     String sourceName,\n     JSDocInfo fileOverviewInfo = null;\n     if (node.getComments() != null) {\n       for (Comment comment : node.getComments()) {\n-        if (comment.getCommentType() == JSDOC &&\n-            (comment.getValue().contains(\"@fileoverview\") ||\n-             comment.getValue().contains(\"@preserve\") ||\n-             comment.getValue().contains(\"@license\"))) {\n-          JSDocInfo info = irFactory.parseJSDocInfo(comment.getValue(),\n-              comment.getLineno(), comment.getAbsolutePosition(),\n-              fileLevelJsDocBuilder, fileOverviewInfo);\n-          if (info != null && fileOverviewInfo == null) {\n-            fileOverviewInfo = info;\n+        if (comment.getCommentType() == JSDOC) {\n+          JsDocInfoParser jsDocParser =\n+              irFactory.createJsDocInfoParser(comment.getValue(),\n+                  comment.getLineno(), comment.getAbsolutePosition(),\n+                  fileLevelJsDocBuilder, fileOverviewInfo);\n+          if (jsDocParser.getFileOverviewJSDocInfo() != fileOverviewInfo) {\n+            fileOverviewInfo = jsDocParser.getFileOverviewJSDocInfo();\n+          } else {\n+            JSDocInfo info = jsDocParser.retrieveAndResetParsedJSDocInfo();\n+            if (info != null) {\n+              irFactory.attachJsDoc(comment, info);\n+            }\n           }\n         }\n       }\n         }\n         irNode.setJSDocInfo(fileOverviewInfo);\n       }\n-\n-      Comment[] comments = new Comment[node.getComments().size()];\n-      comments = node.getComments().toArray(comments);\n-      irFactory.parseAllJsDocInfo(irNode, comments, 0);\n     }\n     return irNode;\n   }\n \n   private Node transform(AstNode node) {\n+    String jsDoc = node.getJsDoc();\n+    NodeWithJsDoc nodeWithJsDoc = null;\n+    if (jsDoc != null) {\n+      nodeWithJsDoc = new NodeWithJsDoc();\n+      nodesWithJsDoc.put(jsDoc, nodeWithJsDoc);\n+    }\n+\n     Node irNode = justTransform(node);\n+    if (nodeWithJsDoc != null) {\n+      nodeWithJsDoc.node = irNode;\n+    }\n+\n     // If we have a named function, set the position to that of the name.\n     if (irNode.getType() == Token.FUNCTION &&\n         irNode.getFirstChild().getLineno() != -1) {\n         irNode.setCharno(charno);\n       }\n     }\n-    if (node.getJsDoc() != null) {\n-      irNode.putProp(TMP_JSDOC_PROP, node.getJsDoc());\n-    }\n     return irNode;\n   }\n \n   /**\n-   * Parses all temporary JsDoc strings in this node and all its children\n-   * recursively as well. Assumes the remaining JsDoc strings are contained in\n-   * pre-order with skips allowed, in the given comments, after the given index.\n+   * Creates a JsDocInfoParser and parses the JsDoc string.\n    *\n-   * @param node The current node to start parsing at.\n-   * @param comments An array of all comments in the source.\n-   * @param ci Current index into the array of comments.\n-   *\n-   * @return Current index into the array of comments after parsing this node.\n-   */\n-  private int parseAllJsDocInfo(Node node, Comment[] comments, int ci) {\n-    if (ci >= comments.length) {\n-      // There are no comments left.\n-      return ci;\n-    }\n-\n-    // Parse the JsDoc string on the current node, if any.\n-    if (node.getProp(TMP_JSDOC_PROP) != null) {\n-      String jsDoc = (String) node.getProp(TMP_JSDOC_PROP);\n-\n-      // Find the match of the JsDoc string in the array of comments.\n-      while (comments[ci].getCommentType() != JSDOC ||\n-          !comments[ci].getValue().equals(jsDoc)) {\n-        ci++;\n-        Preconditions.checkState(ci < comments.length);\n-      }\n-\n-      JSDocInfo info = parseJSDocInfo(jsDoc, comments[ci].getLineno(),\n-          comments[ci].getAbsolutePosition());\n-      node.setJSDocInfo(info);\n-      if (info != null && info.hasEnumParameterType()) {\n-        if (node.getType() == Token.NAME) {\n-          registry.identifyEnumName(node.getString());\n-        } else if (node.getType() == Token.VAR &&\n-            node.getChildCount() == 1) {\n-          registry.identifyEnumName(node.getFirstChild().getString());\n-        } else if (node.getType() == Token.ASSIGN) {\n-          registry.identifyEnumName(node.getFirstChild().getQualifiedName());\n-        }\n-      }\n-\n-      ci++;\n-      node.removeProp(TMP_JSDOC_PROP);\n-    }\n-\n-    // Recurse on the children.\n-    for (Node child : node.children()) {\n-      ci = parseAllJsDocInfo(child, comments, ci);\n-    }\n-\n-    return ci;\n-  }\n-\n-  private JSDocInfo parseJSDocInfo(String comment, int lineno, int position) {\n-    return parseJSDocInfo(comment, lineno, position, null, null);\n-  }\n-\n-  /**\n-   * Parse a JsDoc string into a JSDocInfo.\n-   *\n-   * Used both for handling individual JSDoc comments (when it returns the new\n-   * JSDocInfo for the node) and for handling file-level JSDoc comments\n-   * (@fileoverview and @license).  In this second case, it returns a\n-   * JSDocInfo if it found another @fileoverview, or null if not.  Also in\n-   * the second case, all @license text found gets shoved into the\n-   * fileLevelJsDocBuilder object.\n+   * Used both for handling individual JSDoc comments and for handling\n+   * file-level JSDoc comments (@fileoverview and @license).\n    *\n    * @param comment The JsDoc comment to parse.\n    * @param lineno The line number of the node this comment is attached to.\n-   * @param fileLevelJsDocBuilder The builder for file-level JSDocInfo. If not\n-   *     null, this method parses to a fileOverview JSDocInfo as opposed to a\n-   *     node-level one.\n+   * @param fileLevelJsDocBuilder The builder for file-level JSDocInfo.\n    * @param fileOverviewInfo The current @fileoverview JSDocInfo, so that the\n    *     parser may warn if another @fileoverview is found. May be null.\n-   * @return A JSDocInfo. May be null if the method parses to the wrong level.\n+   * @return A JSDocInfoParser. Will contain either fileoverview jsdoc, or\n+   *     normal jsdoc, or no jsdoc (if the method parses to the wrong level).\n    */\n-  private JSDocInfo parseJSDocInfo(String comment, int lineno, int position,\n+  private JsDocInfoParser createJsDocInfoParser(\n+      String comment, int lineno, int position,\n       Node.FileLevelJsDocBuilder fileLevelJsDocBuilder,\n       JSDocInfo fileOverviewInfo) {\n     // The JsDocInfoParser expects the comment without the initial '/**'.\n     jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);\n     jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo);\n     jsdocParser.parse();\n-    if (fileLevelJsDocBuilder != null) {\n-      return jsdocParser.getFileOverviewJSDocInfo();\n-    } else {\n-      return jsdocParser.retrieveAndResetParsedJSDocInfo();\n+    return jsdocParser;\n+  }\n+\n+  /** Attach JSDocInfo to a node, if we can find one. */\n+  private void attachJsDoc(Comment comment, JSDocInfo info) {\n+    Collection<NodeWithJsDoc> candidates =\n+        nodesWithJsDoc.get(comment.getValue());\n+    if (candidates.isEmpty()) {\n+      return;\n+    }\n+\n+    Iterator<NodeWithJsDoc> candidateIter = candidates.iterator();\n+    Node node = candidateIter.next().node;\n+    candidateIter.remove();\n+    node.setJSDocInfo(info);\n+    if (info.hasEnumParameterType()) {\n+      if (node.getType() == Token.NAME) {\n+        registry.identifyEnumName(node.getString());\n+      } else if (node.getType() == Token.VAR &&\n+            node.getChildCount() == 1) {\n+        registry.identifyEnumName(\n+            node.getFirstChild().getString());\n+      } else if (node.getType() == Token.ASSIGN) {\n+        registry.identifyEnumName(\n+            node.getFirstChild().getQualifiedName());\n+      }\n     }\n   }\n \n     // Token without name\n     throw new IllegalStateException(String.valueOf(token));\n   }\n+\n+  /**\n+   * A simple wrapper struct, so that we can put a Node in the collection\n+   * first and populate it later.\n+   */\n+  private final class NodeWithJsDoc {\n+    private Node node = null;\n+  }\n }\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n   private JSDocInfo fileOverviewJSDocInfo = null;\n   private State state;\n \n-  private static final Map<String, Annotation> recognizedAnnotations =\n-      new ImmutableMap.Builder<String, Annotation>().\n-      put(\"argument\", Annotation.PARAM).\n-      put(\"author\", Annotation.AUTHOR).\n-      put(\"const\", Annotation.CONSTANT).\n-      put(\"constant\", Annotation.CONSTANT).\n-      put(\"constructor\", Annotation.CONSTRUCTOR).\n-      put(\"define\", Annotation.DEFINE).\n-      put(\"deprecated\", Annotation.DEPRECATED).\n-      put(\"desc\", Annotation.DESC).\n-      put(\"enum\", Annotation.ENUM).\n-      put(\"export\", Annotation.EXPORT).\n-      put(\"extends\", Annotation.EXTENDS).\n-      put(\"externs\", Annotation.EXTERNS).\n-      put(\"fileoverview\", Annotation.FILE_OVERVIEW).\n-      put(\"final\", Annotation.CONSTANT).\n-      put(\"hidden\", Annotation.HIDDEN).\n-      put(\"implements\", Annotation.IMPLEMENTS).\n-      put(\"implicitCast\", Annotation.IMPLICIT_CAST).\n-      put(\"inheritDoc\", Annotation.INHERIT_DOC).\n-      put(\"interface\", Annotation.INTERFACE).\n-      put(\"javadispatch\", Annotation.JAVA_DISPATCH).\n-      put(\"license\", Annotation.LICENSE).\n-      put(\"noalias\", Annotation.NO_ALIAS).\n-      put(\"noshadow\", Annotation.NO_SHADOW).\n-      put(\"nosideeffects\", Annotation.NO_SIDE_EFFECTS).\n-      put(\"notypecheck\", Annotation.NO_TYPE_CHECK).\n-      put(\"override\", Annotation.OVERRIDE).\n-      put(\"owner\", Annotation.AUTHOR).\n-      put(\"param\", Annotation.PARAM).\n-      put(\"preserve\", Annotation.PRESERVE).\n-      put(\"preserveTry\", Annotation.PRESERVE_TRY).\n-      put(\"private\", Annotation.PRIVATE).\n-      put(\"protected\", Annotation.PROTECTED).\n-      put(\"public\", Annotation.PUBLIC).\n-      put(\"return\", Annotation.RETURN).\n-      put(\"returns\", Annotation.RETURN).\n-      put(\"see\", Annotation.SEE).\n-      put(\"suppress\", Annotation.SUPPRESS).\n-      put(\"template\", Annotation.TEMPLATE).\n-      put(\"this\", Annotation.THIS).\n-      put(\"throws\", Annotation.THROWS).\n-      put(\"type\", Annotation.TYPE).\n-      put(\"typedef\", Annotation.TYPEDEF).\n-      put(\"version\", Annotation.VERSION).\n-      build();\n-\n   private final Map<String, Annotation> annotationNames;\n \n   private Node.FileLevelJsDocBuilder fileLevelJsDocBuilder;\n     SEARCHING_ANNOTATION,\n     SEARCHING_NEWLINE,\n     NEXT_IS_ANNOTATION\n-  }\n-\n-  private enum Annotation {\n-    AUTHOR,\n-    CONSTANT,\n-    CONSTRUCTOR,\n-    DEFINE,\n-    DEPRECATED,\n-    DESC,\n-    ENUM,\n-    EXTENDS,\n-    EXTERNS,\n-    EXPORT,\n-    FILE_OVERVIEW,\n-    HIDDEN,\n-    IMPLEMENTS,\n-    IMPLICIT_CAST,\n-    INHERIT_DOC,\n-    INTERFACE,\n-    JAVA_DISPATCH,\n-    LICENSE, // same as preserve\n-    NO_ALIAS,\n-    NO_SHADOW,\n-    NO_SIDE_EFFECTS,\n-    NO_TYPE_CHECK,\n-    NOT_IMPLEMENTED,\n-    OVERRIDE,\n-    PARAM,\n-    PRESERVE, // same as license\n-    PRESERVE_TRY,\n-    PRIVATE,\n-    PROTECTED,\n-    PUBLIC,\n-    RETURN,\n-    SEE,\n-    SUPPRESS,\n-    TEMPLATE,\n-    THIS,\n-    THROWS,\n-    TYPE,\n-    TYPEDEF,\n-    VERSION\n   }\n \n   JsDocInfoParser(JsDocTokenStream stream,\n     this.sourceName = sourceName;\n     this.typeRegistry = config.registry;\n     this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation);\n-    this.annotationNames = buildAnnotationNames(config);\n+    this.annotationNames = config.annotationNames;\n \n     this.errorReporter = errorReporter;\n-  }\n-\n-  /** Create the annotation names from the user-specified config. */\n-  private static Map<String, Annotation> buildAnnotationNames(Config config) {\n-    ImmutableMap.Builder<String, Annotation> annotationBuilder =\n-        ImmutableMap.builder();\n-    annotationBuilder.putAll(recognizedAnnotations);\n-    for (String unrecognizedAnnotation : config.annotationWhitelist) {\n-      if (!recognizedAnnotations.containsKey(unrecognizedAnnotation)) {\n-        annotationBuilder.put(\n-            unrecognizedAnnotation, Annotation.NOT_IMPLEMENTED);\n-      }\n-    }\n-    return annotationBuilder.build();\n   }\n \n   /**", "timestamp": 1265842926, "metainfo": ""}