{"sha": "8b0fb3da9bc59bbbc08a7cf44fe57310ec788eb9", "log": "MATH-817 Algorithem for fitting of a multivariate normal distributions mixture (implemented by Jared Becksfort). Added \"MixtureMultivariateNormalDistribution\" class as \"syntactic sugar\". Two unit tests are currently set to \"@Ignore\" (because they rely on \"equals\" which the patch did not seem to implement \"equals\" consistently).   ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/distribution/MixtureMultivariateNormalDistribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.distribution;\n+\n+import java.util.List;\n+import java.util.ArrayList;\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.util.Pair;\n+\n+/**\n+ * Multivariate normal mixture distribution.\n+ * This class is mainly syntactic sugar.\n+ *\n+ * @see MixtureMultivariateRealDistribution\n+ */\n+public class MixtureMultivariateNormalDistribution\n+    extends MixtureMultivariateRealDistribution<MultivariateNormalDistribution> {\n+    /**\n+     * Creates a multivariate normal mixture distribution.\n+     *\n+     * @param weights Weights of each component.\n+     * @param means Mean vector for each component.\n+     * @param covariances Covariance matrix for each component.\n+     */\n+    public MixtureMultivariateNormalDistribution(double[] weights,\n+                                                 double[][] means,\n+                                                 double[][][] covariances) {\n+        super(createComponents(weights, means, covariances));\n+    }\n+\n+    /**\n+     * Creates a mixture model from a list of distributions and their\n+     * associated weights.\n+     *\n+     * @param components List of (weight, distribution) pairs from which to sample.\n+     */\n+    public MixtureMultivariateNormalDistribution(List<Pair<Double, MultivariateNormalDistribution>> components) {\n+        super(components);\n+    }\n+\n+    /**\n+     * Creates a mixture model from a list of distributions and their\n+     * associated weights.\n+     *\n+     * @param rng Random number generator.\n+     * @param components Distributions from which to sample.\n+     * @throws NotPositiveException if any of the weights is negative.\n+     * @throws DimensionMismatchException if not all components have the same\n+     * number of variables.\n+     */\n+    public MixtureMultivariateNormalDistribution(RandomGenerator rng,\n+                                                 List<Pair<Double, MultivariateNormalDistribution>> components) {\n+        super(rng, components);\n+    }\n+\n+    /**\n+     * @param weights Weights of each component.\n+     * @param means Mean vector for each component.\n+     * @param covariances Covariance matrix for each component.\n+     * @return the list of components.\n+     */\n+    private static List<Pair<Double, MultivariateNormalDistribution>> createComponents(double[] weights,\n+                                                                                       double[][] means,\n+                                                                                       double[][][] covariances) {\n+        final List<Pair<Double, MultivariateNormalDistribution>> mvns\n+            = new ArrayList<Pair<Double, MultivariateNormalDistribution>>();\n+\n+        for (int i = 0; i < weights.length; i++) {\n+            final MultivariateNormalDistribution dist\n+                = new MultivariateNormalDistribution(means[i], covariances[i]);\n+\n+            mvns.add(new Pair<Double, MultivariateNormalDistribution>(weights[i], dist));\n+        }\n+\n+        return mvns;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/distribution/fitting/MultivariateNormalMixtureExpectationMaximization.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.commons.math3.distribution.fitting;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.apache.commons.math3.distribution.MixtureMultivariateRealDistribution;\n+import org.apache.commons.math3.distribution.MultivariateNormalDistribution;\n+import org.apache.commons.math3.distribution.MixtureMultivariateNormalDistribution;\n+import org.apache.commons.math3.exception.ConvergenceException;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n+import org.apache.commons.math3.exception.NumberIsTooLargeException;\n+import org.apache.commons.math3.exception.util.LocalizedFormats;\n+import org.apache.commons.math3.linear.Array2DRowRealMatrix;\n+import org.apache.commons.math3.linear.RealMatrix;\n+import org.apache.commons.math3.linear.SingularMatrixException;\n+import org.apache.commons.math3.stat.correlation.Covariance;\n+import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.MathArrays;\n+import org.apache.commons.math3.util.Pair;\n+\n+/**\n+ * <a href=\"https://www.ee.washington.edu/techsite/papers/documents/UWEETR-2010-0002.pdf\">\n+ * Expectation-Maximization</a> algorithm for fitting the parameters of\n+ * multivariate normal mixture model distributions.\n+ *\n+ * This implementation is based on\n+ * <a href=\"http://cran.r-project.org/web/packages/mixtools/index.html\">\n+ *  CRAN Mixtools</a>\n+ *\n+ * @version $Id$\n+ * @since 3.2\n+ */\n+public class MultivariateNormalMixtureExpectationMaximization {\n+    /**\n+     * The data to fit.\n+     */\n+    private final double[][] data;\n+    /**\n+     * The model fit against the data.\n+     */\n+    private MixtureMultivariateNormalDistribution fittedModel;\n+    /**\n+     * The log likelihood of the data given the fitted model.\n+     */\n+    private double logLikelihood = 0d;\n+    /**\n+     * Default maximum number of iterations allowed per fitting process.\n+     */\n+    private final int defaultMaxIterations = 1000;\n+    /**\n+     * Default convergence threshold for fitting.\n+     */\n+    private final double defaultThreshold = 1E-5;\n+\n+    /**\n+     * Creates an object to fit a multivariate normal mixture model to data.\n+     *\n+     * @param data Data to use in fitting procedure\n+     * @throws NotStrictlyPositiveException if data has no rows\n+     * @throws DimensionMismatchException if rows of data have different numbers\n+     *             of columns\n+     * @throws NumberIsTooSmallException if the number of columns in the data is\n+     *             less than 2\n+     */\n+    public MultivariateNormalMixtureExpectationMaximization(double[][] data)\n+        throws NotStrictlyPositiveException,\n+               DimensionMismatchException,\n+               NumberIsTooSmallException {\n+        if (data.length < 1) {\n+            throw new NotStrictlyPositiveException(data.length);\n+        }\n+\n+        this.data = new double[data.length][data[0].length];\n+\n+        for (int i = 0; i < data.length; i++) {\n+            if (data[i].length != data[0].length) {\n+                // Jagged arrays not allowed\n+                throw new DimensionMismatchException(data[i].length,\n+                                                     data[0].length);\n+            }\n+            if (data[i].length < 2) {\n+                throw new NumberIsTooSmallException(LocalizedFormats.NUMBER_TOO_SMALL,\n+                                                    data[i].length, 2, true);\n+            }\n+            this.data[i] = MathArrays.copyOf(data[i], data[i].length);\n+        }\n+    }\n+\n+    /**\n+     * Fit a mixture model to the data supplied to the constructor.\n+     *\n+     * The quality of the fit depends on the concavity of the data provided to\n+     * the constructor and the initial mixture provided to this function. If the\n+     * data has many local optima, multiple runs of the fitting function with\n+     * different initial mixtures may be required to find the optimal solution.\n+     * If a SingularMatrixException is encountered, it is possible that another\n+     * initialization would work.\n+     *\n+     * @param initialMixture Model containing initial values of weights and\n+     *            multivariate normals\n+     * @param maxIterations Maximum iterations allowed for fit\n+     * @param threshold Convergence threshold computed as difference in\n+     *             logLikelihoods between successive iterations\n+     * @throws SingularMatrixException if any component's covariance matrix is\n+     *             singular during fitting\n+     * @throws NotStrictlyPositiveException if numComponents is less than one\n+     *             or threshold is less than Double.MIN_VALUE\n+     * @throws DimensionMismatchException if initialMixture mean vector and data\n+     *             number of columns are not equal\n+     * @see #estimateMultivariateNormalMixtureModelDistribution\n+     */\n+    public void fit(final MixtureMultivariateNormalDistribution initialMixture,\n+                    final int maxIterations,\n+                    final double threshold)\n+            throws SingularMatrixException,\n+                   NotStrictlyPositiveException,\n+                   DimensionMismatchException {\n+        if (maxIterations < 1) {\n+            throw new NotStrictlyPositiveException(maxIterations);\n+        }\n+\n+        if (threshold < Double.MIN_VALUE) {\n+            throw new NotStrictlyPositiveException(threshold);\n+        }\n+\n+        final int n = data.length;\n+\n+        // Number of data columns. Jagged data already rejected in constructor,\n+        // so we can assume the lengths of each row are equal.\n+        final int numCols = data[0].length;\n+        final int k = initialMixture.getComponents().size();\n+\n+        final int numMeanColumns\n+            = initialMixture.getComponents().get(0).getSecond().getMeans().length;\n+\n+        if (numMeanColumns != numCols) {\n+            throw new DimensionMismatchException(numMeanColumns, numCols);\n+        }\n+\n+        int numIterations = 0;\n+        double previousLogLikelihood = 0d;\n+\n+        logLikelihood = Double.NEGATIVE_INFINITY;\n+\n+        // Initialize model to fit to initial mixture.\n+        fittedModel = new MixtureMultivariateNormalDistribution(initialMixture.getComponents());\n+\n+        while (numIterations++ <= maxIterations &&\n+               Math.abs(previousLogLikelihood - logLikelihood) > threshold) {\n+            previousLogLikelihood = logLikelihood;\n+            double sumLogLikelihood = 0d;\n+\n+            // Mixture components\n+            final List<Pair<Double, MultivariateNormalDistribution>> components\n+                = fittedModel.getComponents();\n+\n+            // Weight and distribution of each component\n+            final double[] weights = new double[k];\n+\n+            final MultivariateNormalDistribution[] mvns = new MultivariateNormalDistribution[k];\n+\n+            for (int j = 0; j < k; j++) {\n+                weights[j] = components.get(j).getFirst();\n+                mvns[j] = components.get(j).getSecond();\n+            }\n+\n+            // E-step: compute the data dependent parameters of the expectation\n+            // function.\n+            // The percentage of row's total density between a row and a\n+            // component\n+            final double[][] gamma = new double[n][k];\n+\n+            // Sum of gamma for each component\n+            final double[] gammaSums = new double[k];\n+\n+            // Sum of gamma times its row for each each component\n+            final double[][] gammaDataProdSums = new double[k][numCols];\n+\n+            for (int i = 0; i < n; i++) {\n+                final double rowDensity = fittedModel.density(data[i]);\n+                sumLogLikelihood += Math.log(rowDensity);\n+\n+                for (int j = 0; j < k; j++) {\n+                    gamma[i][j] = weights[j] * mvns[j].density(data[i])\n+                            / rowDensity;\n+\n+                    gammaSums[j] += gamma[i][j];\n+\n+                    for (int col = 0; col < numCols; col++) {\n+                        gammaDataProdSums[j][col] += gamma[i][j] * data[i][col];\n+                    }\n+                }\n+            }\n+\n+            logLikelihood = sumLogLikelihood / n;\n+\n+            // M-step: compute the new parameters based on the expectation\n+            // function.\n+            final double[] newWeights = new double[k];\n+            final double[][] newMeans = new double[k][numCols];\n+\n+            for (int j = 0; j < k; j++) {\n+                newWeights[j] = gammaSums[j] / n;\n+                for (int col = 0; col < numCols; col++) {\n+                    newMeans[j][col] = gammaDataProdSums[j][col] / gammaSums[j];\n+                }\n+            }\n+\n+            // Compute new covariance matrices\n+            final RealMatrix[] newCovMats = new RealMatrix[k];\n+            for (int j = 0; j < k; j++) {\n+                newCovMats[j] = new Array2DRowRealMatrix(numCols, numCols);\n+            }\n+            for (int i = 0; i < n; i++) {\n+                for (int j = 0; j < k; j++) {\n+                    final RealMatrix vec\n+                        = new Array2DRowRealMatrix(MathArrays.ebeSubtract(data[i], newMeans[j]));\n+                    final RealMatrix dataCov\n+                        = vec.multiply(vec.transpose()).scalarMultiply(gamma[i][j]);\n+                    newCovMats[j] = newCovMats[j].add(dataCov);\n+                }\n+            }\n+\n+            // Converting to arrays for use by fitted model\n+            final double[][][] newCovMatArrays = new double[k][numCols][numCols];\n+            for (int j = 0; j < k; j++) {\n+                newCovMats[j] = newCovMats[j].scalarMultiply(1d / gammaSums[j]);\n+                newCovMatArrays[j] = newCovMats[j].getData();\n+            }\n+\n+            // Update current model\n+            fittedModel = new MixtureMultivariateNormalDistribution(newWeights,\n+                                                                    newMeans,\n+                                                                    newCovMatArrays);\n+        }\n+\n+        if (Math.abs(previousLogLikelihood - logLikelihood) > threshold) {\n+            // Did not converge before the maximum number of iterations\n+            throw new ConvergenceException();\n+        }\n+    }\n+\n+    /**\n+     * Fit a mixture model to the data supplied to the constructor.\n+     *\n+     * The quality of the fit depends on the concavity of the data provided to\n+     * the constructor and the initial mixture provided to this function. If the\n+     * data has many local optima, multiple runs of the fitting function with\n+     * different initial mixtures may be required to find the optimal solution.\n+     * If a SingularMatrixException is encountered, it is possible that another\n+     * initialization would work.\n+     *\n+     * @param initialMixture Model containing initial values of weights and\n+     *            multivariate normals\n+     * @throws SingularMatrixException if any component's covariance matrix is\n+     *             singular during fitting\n+     * @throws NotStrictlyPositiveException if numComponents is less than one or\n+     *             threshold is less than Double.MIN_VALUE\n+     * @see #estimateMultivariateNormalMixtureModelDistribution\n+     */\n+    public void fit(MixtureMultivariateNormalDistribution initialMixture)\n+        throws SingularMatrixException,\n+               NotStrictlyPositiveException {\n+        fit(initialMixture, defaultMaxIterations, defaultThreshold);\n+    }\n+\n+    /**\n+     * Helper method to create a multivariate normal mixture model which can be\n+     * used to initialize {@link #fit(MixtureMultivariateRealDistribution)}.\n+     *\n+     * This method uses the data supplied to the constructor to try to determine\n+     * a good mixture model at which to start the fit, but it is not guaranteed\n+     * to supply a model which will find the optimal solution or even converge.\n+     *\n+     * @param data Data to estimate distribution\n+     * @param numComponents Number of components for estimated mixture\n+     * @return Multivariate normal mixture model estimated from the data\n+     * @throws NumberIsTooLargeException if {@code numComponents\\ is greater\n+     * than the number of data rows.\n+     * @throws NumberIsTooSmallException if {@code numComponents < 2}.\n+     * @throws NotStrictlyPositiveException if data has less than 2 rows\n+     * @throws DimensionMismatchException if rows of data have different numbers\n+     *             of columns\n+     * @see #fit\n+     */\n+    public static MixtureMultivariateNormalDistribution estimate(final double[][] data,\n+                                                                 final int numComponents)\n+        throws NotStrictlyPositiveException,\n+               DimensionMismatchException {\n+        if (data.length < 2) {\n+            throw new NotStrictlyPositiveException(data.length);\n+        }\n+        if (numComponents < 2) {\n+            throw new NumberIsTooSmallException(numComponents, 2, true);\n+        }\n+        if (numComponents > data.length) {\n+            throw new NumberIsTooLargeException(numComponents, data.length, true);\n+        }\n+\n+        final int numRows = data.length;\n+        final int numCols = data[0].length;\n+\n+        // sort the data\n+        final DataRow[] sortedData = new DataRow[numRows];\n+        for (int i = 0; i < numRows; i++) {\n+            sortedData[i] = new DataRow(data[i]);\n+        }\n+        Arrays.sort(sortedData);\n+\n+        final int totalBins = numComponents;\n+\n+        // uniform weight for each bin\n+        final double weight = 1d / totalBins;\n+\n+        // components of mixture model to be created\n+        final List<Pair<Double, MultivariateNormalDistribution>> components =\n+                new ArrayList<Pair<Double, MultivariateNormalDistribution>>();\n+\n+        // create a component based on data in each bin\n+        for (int binNumber = 1; binNumber <= totalBins; binNumber++) {\n+            // minimum index from sorted data for this bin\n+            final int minIndex\n+                = (int) FastMath.max(0,\n+                                     FastMath.floor((binNumber - 1) * numRows / totalBins));\n+\n+            // maximum index from sorted data for this bin\n+            final int maxIndex\n+                = (int) FastMath.ceil(binNumber * numRows / numComponents) - 1;\n+\n+            // number of data records that will be in this bin\n+            final int numBinRows = maxIndex - minIndex + 1;\n+\n+            // data for this bin\n+            final double[][] binData = new double[numBinRows][numCols];\n+\n+            // mean of each column for the data in the this bin\n+            final double[] columnMeans = new double[numCols];\n+\n+            // populate bin and create component\n+            for (int i = minIndex, iBin = 0; i <= maxIndex; i++, iBin++) {\n+                for (int j = 0; j < numCols; j++) {\n+                    final double val = sortedData[i].getRow()[j];\n+                    columnMeans[j] += val;\n+                    binData[iBin][j] = val;\n+                }\n+            }\n+\n+            MathArrays.scaleInPlace(1d / numBinRows, columnMeans);\n+\n+            // covariance matrix for this bin\n+            final double[][] covMat\n+                = new Covariance(binData).getCovarianceMatrix().getData();\n+            final MultivariateNormalDistribution mvn\n+                = new MultivariateNormalDistribution(columnMeans, covMat);\n+\n+            components.add(new Pair<Double, MultivariateNormalDistribution>(weight, mvn));\n+        }\n+\n+        return new MixtureMultivariateNormalDistribution(components);\n+    }\n+\n+    /**\n+     * Gets the log likelihood of the data under the fitted model.\n+     *\n+     * @return Log likelihood of data or zero of no data has been fit\n+     */\n+    public double getLogLikelihood() {\n+        return logLikelihood;\n+    }\n+\n+    /**\n+     * Gets the fitted model.\n+     *\n+     * @return fitted model or {@code null} if no fit has been performed yet.\n+     */\n+    public MixtureMultivariateNormalDistribution getFittedModel() {\n+        return new MixtureMultivariateNormalDistribution(fittedModel.getComponents());\n+    }\n+\n+    /**\n+     * Class used for sorting user-supplied data.\n+     */\n+    private static class DataRow implements Comparable<DataRow> {\n+        /** One data row. */\n+        private final double[] row;\n+        /** Mean of the data row. */\n+        private Double mean;\n+\n+        /**\n+         * Create a data row.\n+         * @param data Data to use for the row\n+         */\n+        DataRow(final double[] data) {\n+            // Store reference.\n+            row = data;\n+            // Compute mean.\n+            mean = 0d;\n+            for (int i = 0; i < data.length; i++) {\n+                mean += data[i];\n+            }\n+            mean /= data.length;\n+        }\n+\n+        /**\n+         * Compare two data rows.\n+         * @param other The other row\n+         * @return int for sorting\n+         */\n+        public int compareTo(final DataRow other) {\n+            return mean.compareTo(other.mean);\n+        }\n+\n+        /**\n+         * Get a data row.\n+         * @return data row array\n+         */\n+        public double[] getRow() {\n+            return row;\n+        }\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/distribution/fitting/MultivariateNormalMixtureExpectationMaximizationTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.commons.math3.distribution.fitting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.math3.distribution.MixtureMultivariateNormalDistribution;\n+import org.apache.commons.math3.distribution.MultivariateNormalDistribution;\n+import org.apache.commons.math3.exception.ConvergenceException;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n+import org.apache.commons.math3.util.Pair;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.junit.Ignore;\n+\n+/**\n+ * Test that demonstrates the use of\n+ * {@link MultivariateNormalMixtureExpectationMaximization}.\n+ */\n+public class MultivariateNormalMixtureExpectationMaximizationTest {\n+\n+    // TODO reject initial mixes where means/covMats not computable with data\n+    // numCols\n+\n+    @Test(expected = NotStrictlyPositiveException.class)\n+    public void testNonEmptyData() {\n+        // Should not accept empty data\n+        new MultivariateNormalMixtureExpectationMaximization(new double[][] {});\n+    }\n+\n+    @Test(expected = DimensionMismatchException.class)\n+    public void testNonJaggedData() {\n+        // Reject data with nonconstant numbers of columns\n+        double[][] data = new double[][] {\n+                { 1, 2, 3 },\n+                { 4, 5, 6, 7 },\n+        };\n+        new MultivariateNormalMixtureExpectationMaximization(data);\n+    }\n+\n+    @Test(expected = NumberIsTooSmallException.class)\n+    public void testMultipleColumnsRequired() {\n+        // Data should have at least 2 columns\n+        double[][] data = new double[][] {\n+                { 1 }, { 2 }\n+        };\n+        new MultivariateNormalMixtureExpectationMaximization(data);\n+    }\n+\n+    @Test(expected = NotStrictlyPositiveException.class)\n+    public void testMaxIterationsPositive() {\n+        // Maximum iterations for fit must be positive integer\n+        double[][] data = getTestSamples();\n+        MultivariateNormalMixtureExpectationMaximization fitter =\n+                new MultivariateNormalMixtureExpectationMaximization(data);\n+\n+        MixtureMultivariateNormalDistribution\n+            initialMix = MultivariateNormalMixtureExpectationMaximization.estimate(data, 2);\n+\n+        fitter.fit(initialMix, 0, 1E-5);\n+    }\n+\n+    @Test(expected = NotStrictlyPositiveException.class)\n+    public void testThresholdPositive() {\n+        // Maximum iterations for fit must be positive\n+        double[][] data = getTestSamples();\n+        MultivariateNormalMixtureExpectationMaximization fitter =\n+                new MultivariateNormalMixtureExpectationMaximization(\n+                    data);\n+\n+        MixtureMultivariateNormalDistribution\n+            initialMix = MultivariateNormalMixtureExpectationMaximization.estimate(data, 2);\n+\n+        fitter.fit(initialMix, 1000, 0);\n+    }\n+\n+    @Test(expected = ConvergenceException.class)\n+    public void testConvergenceException() {\n+        // ConvergenceException thrown if fit terminates before threshold met\n+        double[][] data = getTestSamples();\n+        MultivariateNormalMixtureExpectationMaximization fitter\n+            = new MultivariateNormalMixtureExpectationMaximization(data);\n+\n+        MixtureMultivariateNormalDistribution\n+            initialMix = MultivariateNormalMixtureExpectationMaximization.estimate(data, 2);\n+\n+        // 5 iterations not enough to meet convergence threshold\n+        fitter.fit(initialMix, 5, 1E-5);\n+    }\n+\n+    @Test(expected = DimensionMismatchException.class)\n+    public void testIncompatibleIntialMixture() {\n+        // Data has 3 columns\n+        double[][] data = new double[][] {\n+                { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 }\n+        };\n+        double[] weights = new double[] { 0.5, 0.5 };\n+\n+        // These distributions are compatible with 2-column data, not 3-column\n+        // data\n+        MultivariateNormalDistribution[] mvns = new MultivariateNormalDistribution[2];\n+\n+        mvns[0] = new MultivariateNormalDistribution(new double[] {\n+                        -0.0021722935000328823, 3.5432892936887908 },\n+                        new double[][] {\n+                                { 4.537422569229048, 3.5266152281729304 },\n+                                { 3.5266152281729304, 6.175448814169779 } });\n+        mvns[1] = new MultivariateNormalDistribution(new double[] {\n+                        5.090902706507635, 8.68540656355283 }, new double[][] {\n+                        { 2.886778573963039, 1.5257474543463154 },\n+                        { 1.5257474543463154, 3.3794567673616918 } });\n+\n+        // Create components and mixture\n+        List<Pair<Double, MultivariateNormalDistribution>> components =\n+                new ArrayList<Pair<Double, MultivariateNormalDistribution>>();\n+        components.add(new Pair<Double, MultivariateNormalDistribution>(\n+                weights[0], mvns[0]));\n+        components.add(new Pair<Double, MultivariateNormalDistribution>(\n+                weights[1], mvns[1]));\n+\n+        MixtureMultivariateNormalDistribution badInitialMix\n+            = new MixtureMultivariateNormalDistribution(components);\n+\n+        MultivariateNormalMixtureExpectationMaximization fitter\n+            = new MultivariateNormalMixtureExpectationMaximization(data);\n+\n+        fitter.fit(badInitialMix);\n+    }\n+\n+    @Ignore@Test\n+    public void testInitialMixture() {\n+        // Testing initial mixture estimated from data\n+        double[] correctWeights = new double[] { 0.5, 0.5 };\n+\n+        MultivariateNormalDistribution[] correctMVNs = new MultivariateNormalDistribution[2];\n+\n+        correctMVNs[0] = new MultivariateNormalDistribution(new double[] {\n+                        -0.0021722935000328823, 3.5432892936887908 },\n+                        new double[][] {\n+                                { 4.537422569229048, 3.5266152281729304 },\n+                                { 3.5266152281729304, 6.175448814169779 } });\n+        correctMVNs[1] = new MultivariateNormalDistribution(new double[] {\n+                        5.090902706507635, 8.68540656355283 }, new double[][] {\n+                        { 2.886778573963039, 1.5257474543463154 },\n+                        { 1.5257474543463154, 3.3794567673616918 } });\n+\n+        final MixtureMultivariateNormalDistribution initialMix\n+            = MultivariateNormalMixtureExpectationMaximization.estimate(getTestSamples(), 2);\n+\n+        int i = 0;\n+        for (Pair<Double, MultivariateNormalDistribution> component : initialMix\n+                .getComponents()) {\n+            Assert.assertEquals(correctWeights[i], component.getFirst(),\n+                    Math.ulp(1d));\n+            Assert.assertEquals(correctMVNs[i], component.getSecond());\n+            i++;\n+        }\n+    }\n+\n+    @Ignore@Test\n+    public void testFit() {\n+        // Test that the loglikelihood, weights, and models are determined and\n+        // fitted correctly\n+        double[][] data = getTestSamples();\n+        double correctLogLikelihood = -4.292431006791994;\n+        double[] correctWeights = new double[] { 0.2962324189652912, 0.7037675810347089 };\n+        MultivariateNormalDistribution[] correctMVNs = new MultivariateNormalDistribution[2];\n+        correctMVNs[0] = new MultivariateNormalDistribution(new double[] {\n+                        -1.4213112715121132, 1.6924690505757753 },\n+                        new double[][] {\n+                                { 1.739356907285747, -0.5867644251487614 },\n+                                { -0.5867644251487614, 1.0232932029324642 } });\n+\n+        correctMVNs[1] = new MultivariateNormalDistribution(new double[] {\n+                        4.213612224374709, 7.975621325853645 },\n+                        new double[][] {\n+                                { 4.245384898007161, 2.5797798966382155 },\n+                                { 2.5797798966382155, 3.9200272522448367 } });\n+\n+        MultivariateNormalMixtureExpectationMaximization fitter\n+            = new MultivariateNormalMixtureExpectationMaximization(data);\n+\n+        MixtureMultivariateNormalDistribution initialMix\n+            = MultivariateNormalMixtureExpectationMaximization.estimate(data, 2);\n+        fitter.fit(initialMix);\n+        MixtureMultivariateNormalDistribution fittedMix = fitter.getFittedModel();\n+        List<Pair<Double, MultivariateNormalDistribution>> components = fittedMix.getComponents();\n+\n+        Assert.assertEquals(correctLogLikelihood,\n+                            fitter.getLogLikelihood(),\n+                            Math.ulp(1d));\n+\n+        int i = 0;\n+        for (Pair<Double, MultivariateNormalDistribution> component : components) {\n+            double weight = component.getFirst();\n+            MultivariateNormalDistribution mvn = component.getSecond();\n+            Assert.assertEquals(correctWeights[i], weight, Math.ulp(1d));\n+            Assert.assertEquals(correctMVNs[i], mvn);\n+            i++;\n+        }\n+    }\n+\n+    private double[][] getTestSamples() {\n+        // generated using R Mixtools rmvnorm with mean vectors [-1.5, 2] and\n+        // [4, 8.2]\n+        return new double[][] { { 7.358553610469948, 11.31260831446758 },\n+                { 7.175770420124739, 8.988812210204454 },\n+                { 4.324151905768422, 6.837727899051482 },\n+                { 2.157832219173036, 6.317444585521968 },\n+                { -1.890157421896651, 1.74271202875498 },\n+                { 0.8922409354455803, 1.999119343923781 },\n+                { 3.396949764787055, 6.813170372579068 },\n+                { -2.057498232686068, -0.002522983830852255 },\n+                { 6.359932157365045, 8.343600029975851 },\n+                { 3.353102234276168, 7.087541882898689 },\n+                { -1.763877221595639, 0.9688890460330644 },\n+                { 6.151457185125111, 9.075011757431174 },\n+                { 4.281597398048899, 5.953270070976117 },\n+                { 3.549576703974894, 8.616038155992861 },\n+                { 6.004706732349854, 8.959423391087469 },\n+                { 2.802915014676262, 6.285676742173564 },\n+                { -0.6029879029880616, 1.083332958357485 },\n+                { 3.631827105398369, 6.743428504049444 },\n+                { 6.161125014007315, 9.60920569689001 },\n+                { -1.049582894255342, 0.2020017892080281 },\n+                { 3.910573022688315, 8.19609909534937 },\n+                { 8.180454017634863, 7.861055769719962 },\n+                { 1.488945440439716, 8.02699903761247 },\n+                { 4.813750847823778, 12.34416881332515 },\n+                { 0.0443208501259158, 5.901148093240691 },\n+                { 4.416417235068346, 4.465243084006094 },\n+                { 4.0002433603072, 6.721937850166174 },\n+                { 3.190113818788205, 10.51648348411058 },\n+                { 4.493600914967883, 7.938224231022314 },\n+                { -3.675669533266189, 4.472845076673303 },\n+                { 6.648645511703989, 12.03544085965724 },\n+                { -1.330031331404445, 1.33931042964811 },\n+                { -3.812111460708707, 2.50534195568356 },\n+                { 5.669339356648331, 6.214488981177026 },\n+                { 1.006596727153816, 1.51165463112716 },\n+                { 5.039466365033024, 7.476532610478689 },\n+                { 4.349091929968925, 7.446356406259756 },\n+                { -1.220289665119069, 3.403926955951437 },\n+                { 5.553003979122395, 6.886518211202239 },\n+                { 2.274487732222856, 7.009541508533196 },\n+                { 4.147567059965864, 7.34025244349202 },\n+                { 4.083882618965819, 6.362852861075623 },\n+                { 2.203122344647599, 7.260295257904624 },\n+                { -2.147497550770442, 1.262293431529498 },\n+                { 2.473700950426512, 6.558900135505638 },\n+                { 8.267081298847554, 12.10214104577748 },\n+                { 6.91977329776865, 9.91998488301285 },\n+                { 0.1680479852730894, 6.28286034168897 },\n+                { -1.268578659195158, 2.326711221485755 },\n+                { 1.829966451374701, 6.254187605304518 },\n+                { 5.648849025754848, 9.330002040750291 },\n+                { -2.302874793257666, 3.585545172776065 },\n+                { -2.629218791709046, 2.156215538500288 },\n+                { 4.036618140700114, 10.2962785719958 },\n+                { 0.4616386422783874, 0.6782756325806778 },\n+                { -0.3447896073408363, 0.4999834691645118 },\n+                { -0.475281453118318, 1.931470384180492 },\n+                { 2.382509690609731, 6.071782429815853 },\n+                { -3.203934441889096, 2.572079552602468 },\n+                { 8.465636032165087, 13.96462998683518 },\n+                { 2.36755660870416, 5.7844595007273 },\n+                { 0.5935496528993371, 1.374615871358943 },\n+                { -2.467481505748694, 2.097224634713005 },\n+                { 4.27867444328542, 10.24772361238549 },\n+                { -2.013791907543137, 2.013799426047639 },\n+                { 6.424588084404173, 9.185334939684516 },\n+                { -0.8448238876802175, 0.5447382022282812 },\n+                { 1.342955703473923, 8.645456317633556 },\n+                { 3.108712208751979, 8.512156853800064 },\n+                { 4.343205178315472, 8.056869549234374 },\n+                { -2.971767642212396, 3.201180146824761 },\n+                { 2.583820931523672, 5.459873414473854 },\n+                { 4.209139115268925, 8.171098193546225 },\n+                { 0.4064909057902746, 1.454390775518743 },\n+                { 3.068642411145223, 6.959485153620035 },\n+                { 6.085968972900461, 7.391429799500965 },\n+                { -1.342265795764202, 1.454550012997143 },\n+                { 6.249773274516883, 6.290269880772023 },\n+                { 4.986225847822566, 7.75266344868907 },\n+                { 7.642443254378944, 10.19914817500263 },\n+                { 6.438181159163673, 8.464396764810347 },\n+                { 2.520859761025108, 7.68222425260111 },\n+                { 2.883699944257541, 6.777960331348503 },\n+                { 2.788004550956599, 6.634735386652733 },\n+                { 3.331661231995638, 5.794191300046592 },\n+                { 3.526172276645504, 6.710802266815884 },\n+                { 3.188298528138741, 10.34495528210205 },\n+                { 0.7345539486114623, 5.807604004180681 },\n+                { 1.165044595880125, 7.830121829295257 },\n+                { 7.146962523500671, 11.62995162065415 },\n+                { 7.813872137162087, 10.62827008714735 },\n+                { 3.118099164870063, 8.286003148186371 },\n+                { -1.708739286262571, 1.561026755374264 },\n+                { 1.786163047580084, 4.172394388214604 },\n+                { 3.718506403232386, 7.807752990130349 },\n+                { 6.167414046828899, 10.01104941031293 },\n+                { -1.063477247689196, 1.61176085846339 },\n+                { -3.396739609433642, 0.7127911050002151 },\n+                { 2.438885945896797, 7.353011138689225 },\n+                { -0.2073204144780931, 0.850771146627012 }, };\n+    }\n+}", "timestamp": 1363882922, "metainfo": ""}