{"sha": "d163ec0ccf42fc7f1d63826ac6420c19b741343b", "log": "MATH-1007 Add mode function to StatUtils class   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/stat/StatUtils.java\n+++ b/src/main/java/org/apache/commons/math3/stat/StatUtils.java\n  */\n package org.apache.commons.math3.stat;\n \n+import java.util.List;\n+\n import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.NotPositiveException;\n+import org.apache.commons.math3.exception.NullArgumentException;\n import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.NoDataException;\n         }\n         return standardizedSample;\n     }\n+\n+    /**\n+     * Returns the sample mode(s).  The mode is the most frequently occurring\n+     * value in the sample. If there is a unique value with maximum frequency,\n+     * this value is returned as the only element of the output array. Otherwise,\n+     * the returned array contains the maximum frequency elements in increasing\n+     * order.  For example, if {@code sample} is {0, 12, 5, 6, 0, 13, 5, 17},\n+     * the returned array will have length two, with 0 in the first element and\n+     * 5 in the second.\n+     *\n+     * <p>NaN values are ignored when computing the mode - i.e., NaNs will never\n+     * appear in the output array.  If the sample includes only NaNs or has\n+     * length 0, an empty array is returned.</p>\n+     *\n+     * @param sample input data\n+     * @return array of array of the most frequently occuring element(s) sorted in ascending order.\n+     * @throws MathIllegalArgumentException if the indices are invalid or the array is null\n+     */    \n+    public static double[] mode(double[] sample) throws MathIllegalArgumentException {\n+        if (sample == null) {\n+            throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n+        }\n+        return getMode(sample, 0, sample.length);\n+    }\n+\n+    /**\n+     * Returns the sample mode(s).  The mode is the most frequently occurring\n+     * value in the sample. If there is a unique value with maximum frequency,\n+     * this value is returned as the only element of the output array. Otherwise,\n+     * the returned array contains the maximum frequency elements in increasing\n+     * order.  For example, if {@code sample} is {0, 12, 5, 6, 0, 13, 5, 17},\n+     * the returned array will have length two, with 0 in the first element and\n+     * 5 in the second.\n+     *\n+     * <p>NaN values are ignored when computing the mode - i.e., NaNs will never\n+     * appear in the output array.  If the sample includes only NaNs or has\n+     * length 0, an empty array is returned.</p>\n+     *\n+     * @param sample input data\n+     * @param begin index (0-based) of the first array element to include\n+     * @param length the number of elements to include\n+     *\n+     * @return array of array of the most frequently occuring element(s) sorted in ascending order.\n+     * @throws MathIllegalArgumentException if the indices are invalid or the array is null\n+     */    \n+    public static double[] mode(double[] sample, final int begin, final int length) {\n+        if (sample == null) {\n+            throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n+        }\n+\n+        if (begin < 0) {\n+            throw new NotPositiveException(LocalizedFormats.START_POSITION, Integer.valueOf(begin));\n+        }\n+\n+        if (length < 0) {\n+            throw new NotPositiveException(LocalizedFormats.LENGTH, Integer.valueOf(length));\n+        }\n+\n+        return getMode(sample, begin, length);\n+    }\n+\n+    /*\n+     * Private helper method.\n+     * Assumes parameters have been validated.\n+     */\n+    private static double[] getMode(double[] values, final int begin, final int length) {\n+        // Add the values to the frequency table\n+        Frequency freq = new Frequency();\n+        for (int i = begin; i < begin + length; i++) {\n+            final double value = values[i];\n+            if (!Double.isNaN(value)) {\n+                freq.addValue(Double.valueOf(value));\n+            }\n+        }\n+        List<Comparable<?>> list = freq.getMode();\n+        // Convert the list to an array of primitive double\n+        double[] modes = new double[list.size()];\n+        int i = 0;\n+        for(Comparable<?> c : list) {\n+            modes[i++] = ((Double) c).doubleValue();\n+        }\n+        return modes;\n+    }\n+\n }\n--- a/src/test/java/org/apache/commons/math3/stat/StatUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math3/stat/StatUtilsTest.java\n         Assert.assertEquals(1.0, stats.getStandardDeviation(), distance);\n \n     }\n+    \n+    @Test\n+    public void testMode() {\n+        final double[] singleMode = {0, 1, 0, 2, 7, 11, 12};\n+        final double[] modeSingle = StatUtils.mode(singleMode);\n+        Assert.assertEquals(0, modeSingle[0], Double.MIN_VALUE);\n+        Assert.assertEquals(1, modeSingle.length);\n+\n+        final double[] twoMode = {0, 1, 2, 0, 2, 3, 7, 11};\n+        final double[] modeDouble = StatUtils.mode(twoMode);\n+        Assert.assertEquals(0, modeDouble[0], Double.MIN_VALUE);\n+        Assert.assertEquals(2, modeDouble[1], Double.MIN_VALUE);\n+        Assert.assertEquals(2, modeDouble.length);\n+\n+        final double[] nanInfested = {0, 0, 0, Double.NaN, Double.NaN, Double.NaN, Double.NaN, 2, 2, 2, 3, 5};\n+        final double[] modeNan = StatUtils.mode(nanInfested);\n+        Assert.assertEquals(0, modeNan[0], Double.MIN_VALUE);\n+        Assert.assertEquals(2, modeNan[1], Double.MIN_VALUE);\n+        Assert.assertEquals(2, modeNan.length);\n+\n+        final double[] infInfested = {0, 0, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY,\n+            Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, 2, 2, 3, 5};\n+        final double[] modeInf = StatUtils.mode(infInfested);\n+        Assert.assertEquals(Double.NEGATIVE_INFINITY, modeInf[0], Double.MIN_VALUE);\n+        Assert.assertEquals(0, modeInf[1], Double.MIN_VALUE);\n+        Assert.assertEquals(2, modeInf[2], Double.MIN_VALUE);\n+        Assert.assertEquals(Double.POSITIVE_INFINITY, modeInf[3], Double.MIN_VALUE);\n+        Assert.assertEquals(4, modeInf.length);\n+\n+        final double[] noData = {};\n+        final double[] modeNodata = StatUtils.mode(noData);\n+        Assert.assertEquals(0, modeNodata.length);\n+\n+        final double[] nansOnly = {Double.NaN, Double.NaN};\n+        final double[] modeNansOnly = StatUtils.mode(nansOnly);\n+        Assert.assertEquals(0, modeNansOnly.length);\n+    }\n \n }", "timestamp": 1374159588, "metainfo": ""}