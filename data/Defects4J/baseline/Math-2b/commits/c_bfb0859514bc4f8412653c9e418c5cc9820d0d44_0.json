{"sha": "bfb0859514bc4f8412653c9e418c5cc9820d0d44", "log": "Added discrete distributions.  Patch contributed by Piotr Wydrych.  JIRA: MATH-941  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.distribution;\n+\n+import java.lang.reflect.Array;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.math3.exception.MathArithmeticException;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.NotPositiveException;\n+import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math3.exception.util.LocalizedFormats;\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.Well19937c;\n+import org.apache.commons.math3.util.MathArrays;\n+import org.apache.commons.math3.util.Pair;\n+\n+/**\n+ * Generic implementation of the discrete distribution.\n+ *\n+ * @param <T> type of the random variable.\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Probability_distribution#Discrete_probability_distribution\">Discrete probability distribution (Wikipedia)</a>\n+ * @see <a href=\"http://mathworld.wolfram.com/DiscreteDistribution.html\">Discrete Distribution (MathWorld)</a>\n+ * @version $Id: DiscreteDistribution.java 169 2013-03-08 09:02:38Z wydrych $\n+ */\n+public class DiscreteDistribution<T> {\n+\n+    /**\n+     * RNG instance used to generate samples from the distribution.\n+     */\n+    protected final RandomGenerator random;\n+    /**\n+     * List of random variable values.\n+     */\n+    private final List<T> singletons;\n+    /**\n+     * Normalized array of probabilities of respective random variable values.\n+     */\n+    private final double[] probabilities;\n+\n+    /**\n+     * Create a discrete distribution using the given probability mass function\n+     * definition.\n+     *\n+     * @param samples definition of probability mass function in the format of\n+     * list of pairs.\n+     * @throws NotPositiveException if probability of at least one value is\n+     * negative.\n+     * @throws MathArithmeticException if the probabilities sum to zero.\n+     * @throws MathIllegalArgumentException if probability of at least one value\n+     * is infinite.\n+     */\n+    public DiscreteDistribution(final List<Pair<T, Double>> samples)\n+        throws NotPositiveException, MathArithmeticException, MathIllegalArgumentException {\n+        this(new Well19937c(), samples);\n+    }\n+\n+    /**\n+     * Create a discrete distribution using the given random number generator\n+     * and probability mass function definition.\n+     *\n+     * @param rng random number generator.\n+     * @param samples definition of probability mass function in the format of\n+     * list of pairs.\n+     * @throws NotPositiveException if probability of at least one value is\n+     * negative.\n+     * @throws MathArithmeticException if the probabilities sum to zero.\n+     * @throws MathIllegalArgumentException if probability of at least one value\n+     * is infinite.\n+     */\n+    public DiscreteDistribution(final RandomGenerator rng, final List<Pair<T, Double>> samples)\n+        throws NotPositiveException, MathArithmeticException, MathIllegalArgumentException {\n+        random = rng;\n+\n+        singletons = new ArrayList<T>(samples.size());\n+        final double[] probs = new double[samples.size()];\n+\n+        for (int i = 0; i < samples.size(); i++) {\n+            final Pair<T, Double> sample = samples.get(i);\n+            singletons.add(sample.getKey());\n+            if (sample.getValue() < 0) {\n+                throw new NotPositiveException(sample.getValue());\n+            }\n+            probs[i] = sample.getValue();\n+        }\n+\n+        probabilities = MathArrays.normalizeArray(probs, 1.0);\n+    }\n+\n+    /**\n+     * Reseed the random generator used to generate samples.\n+     *\n+     * @param seed the new seed\n+     */\n+    public void reseedRandomGenerator(long seed) {\n+        random.setSeed(seed);\n+    }\n+\n+    /**\n+     * For a random variable {@code X} whose values are distributed according to\n+     * this distribution, this method returns {@code P(X = x)}. In other words,\n+     * this method represents the probability mass function (PMF) for the\n+     * distribution.\n+     *\n+     * @param x the point at which the PMF is evaluated\n+     * @return the value of the probability mass function at {@code x}\n+     */\n+    double probability(final T x) {\n+        double probability = 0;\n+\n+        for (int i = 0; i < probabilities.length; i++) {\n+            if ((x == null && singletons.get(i) == null) ||\n+                (x != null && x.equals(singletons.get(i)))) {\n+                probability += probabilities[i];\n+            }\n+        }\n+\n+        return probability;\n+    }\n+\n+    /**\n+     * Return the definition of probability mass function in the format of list\n+     * of pairs.\n+     *\n+     * @return definition of probability mass function.\n+     */\n+    public List<Pair<T, Double>> getSamples() {\n+        final List<Pair<T, Double>> samples = new ArrayList<Pair<T, Double>>(probabilities.length);\n+\n+        for (int i = 0; i < probabilities.length; i++) {\n+            samples.add(new Pair<T, Double>(singletons.get(i), probabilities[i]));\n+        }\n+\n+        return samples;\n+    }\n+\n+    /**\n+     * Generate a random value sampled from this distribution.\n+     *\n+     * @return a random value.\n+     */\n+    public T sample() {\n+        final double randomValue = random.nextDouble();\n+        double sum = 0;\n+\n+        for (int i = 0; i < probabilities.length; i++) {\n+            sum += probabilities[i];\n+            if (randomValue < sum) {\n+                return singletons.get(i);\n+            }\n+        }\n+\n+        /* This should never happen, but it ensures we will return a correct\n+         * object in case the loop above has some floating point inequality\n+         * problem on the final iteration. */\n+        return singletons.get(singletons.size() - 1);\n+    }\n+\n+    /**\n+     * Generate a random sample from the distribution.\n+     *\n+     * @param sampleSize the number of random values to generate.\n+     * @return an array representing the random sample.\n+     * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n+     * positive.\n+     */\n+    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n+        if (sampleSize <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n+                    sampleSize);\n+        }\n+        @SuppressWarnings(\"unchecked\")\n+        final T[]out = (T[]) Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+\n+        for (int i = 0; i < sampleSize; i++) {\n+            out[i] = sample();\n+        }\n+\n+        return out;\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/distribution/DiscreteIntegerDistribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.distribution;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MathArithmeticException;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.NotPositiveException;\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.Well19937c;\n+import org.apache.commons.math3.util.Pair;\n+\n+/**\n+ * Implementation of the integer-valued discrete distribution.\n+ *\n+ * Note: values with zero-probability are allowed but they do not extend the\n+ * support.\n+ *\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Probability_distribution#Discrete_probability_distribution\">Discrete probability distribution (Wikipedia)</a>\n+ * @see <a href=\"http://mathworld.wolfram.com/DiscreteDistribution.html\">Discrete Distribution (MathWorld)</a>\n+ * @version $Id: DiscreteIntegerDistribution.java 169 2013-03-08 09:02:38Z wydrych $\n+ */\n+public class DiscreteIntegerDistribution extends AbstractIntegerDistribution {\n+\n+    /** Serializable UID. */\n+    private static final long serialVersionUID = 20130308L;\n+\n+    /**\n+     * {@link DiscreteDistribution} instance (using the {@link Integer} wrapper)\n+     * used to generate samples.\n+     */\n+    protected final DiscreteDistribution<Integer> innerDistribution;\n+\n+    /**\n+     * Create a discrete distribution using the given probability mass function\n+     * definition.\n+     *\n+     * @param singletons array of random variable values.\n+     * @param probabilities array of probabilities.\n+     * @throws DimensionMismatchException if\n+     * {@code singletons.length != probabilities.length}\n+     * @throws NotPositiveException if probability of at least one value is\n+     * negative.\n+     * @throws MathArithmeticException if the probabilities sum to zero.\n+     * @throws MathIllegalArgumentException if probability of at least one value\n+     * is infinite.\n+     */\n+    public DiscreteIntegerDistribution(final int[] singletons, final double[] probabilities)\n+        throws DimensionMismatchException, NotPositiveException, MathArithmeticException, MathIllegalArgumentException {\n+        this(new Well19937c(), singletons, probabilities);\n+    }\n+\n+    /**\n+     * Create a discrete distribution using the given random number generator\n+     * and probability mass function definition.\n+     *\n+     * @param rng random number generator.\n+     * @param singletons array of random variable values.\n+     * @param probabilities array of probabilities.\n+     * @throws DimensionMismatchException if\n+     * {@code singletons.length != probabilities.length}\n+     * @throws NotPositiveException if probability of at least one value is\n+     * negative.\n+     * @throws MathArithmeticException if the probabilities sum to zero.\n+     * @throws MathIllegalArgumentException if probability of at least one value\n+     * is infinite.\n+     */\n+    public DiscreteIntegerDistribution(final RandomGenerator rng,\n+                                       final int[] singletons, final double[] probabilities)\n+        throws DimensionMismatchException, NotPositiveException, MathArithmeticException, MathIllegalArgumentException {\n+        super(rng);\n+        if (singletons.length != probabilities.length) {\n+            throw new DimensionMismatchException(probabilities.length, singletons.length);\n+        }\n+\n+        final List<Pair<Integer, Double>> samples = new ArrayList<Pair<Integer, Double>>(singletons.length);\n+\n+        for (int i = 0; i < singletons.length; i++) {\n+            samples.add(new Pair<Integer, Double>(singletons[i], probabilities[i]));\n+        }\n+\n+        innerDistribution = new DiscreteDistribution<Integer>(rng, samples);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public double probability(final int x) {\n+        return innerDistribution.probability(x);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public double cumulativeProbability(final int x) {\n+        double probability = 0;\n+\n+        for (final Pair<Integer, Double> sample : innerDistribution.getSamples()) {\n+            if (sample.getKey() <= x) {\n+                probability += sample.getValue();\n+            }\n+        }\n+\n+        return probability;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @return {@code sum(singletons[i] * probabilities[i])}\n+     */\n+    public double getNumericalMean() {\n+        double mean = 0;\n+\n+        for (final Pair<Integer, Double> sample : innerDistribution.getSamples()) {\n+            mean += sample.getValue() * sample.getKey();\n+        }\n+\n+        return mean;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @return {@code sum((singletons[i] - mean) ^ 2 * probabilities[i])}\n+     */\n+    public double getNumericalVariance() {\n+        double mean = 0;\n+        double meanOfSquares = 0;\n+\n+        for (final Pair<Integer, Double> sample : innerDistribution.getSamples()) {\n+            mean += sample.getValue() * sample.getKey();\n+            meanOfSquares += sample.getValue() * sample.getKey() * sample.getKey();\n+        }\n+\n+        return meanOfSquares - mean * mean;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * Returns the lowest value with non-zero probability.\n+     *\n+     * @return the lowest value with non-zero probability.\n+     */\n+    public int getSupportLowerBound() {\n+        int min = Integer.MAX_VALUE;\n+        for (final Pair<Integer, Double> sample : innerDistribution.getSamples()) {\n+            if (sample.getKey() < min && sample.getValue() > 0) {\n+                min = sample.getKey();\n+            }\n+        }\n+\n+        return min;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * Returns the highest value with non-zero probability.\n+     *\n+     * @return the highest value with non-zero probability.\n+     */\n+    public int getSupportUpperBound() {\n+        int max = Integer.MIN_VALUE;\n+        for (final Pair<Integer, Double> sample : innerDistribution.getSamples()) {\n+            if (sample.getKey() > max && sample.getValue() > 0) {\n+                max = sample.getKey();\n+            }\n+        }\n+\n+        return max;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The support of this distribution is connected.\n+     *\n+     * @return {@code true}\n+     */\n+    public boolean isSupportConnected() {\n+        return true;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public int sample() {\n+        return innerDistribution.sample();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/distribution/DiscreteRealDistribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.distribution;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MathArithmeticException;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.NotPositiveException;\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.Well19937c;\n+import org.apache.commons.math3.util.Pair;\n+\n+/**\n+ * Implementation of the discrete distribution on the reals.\n+ *\n+ * Note: values with zero-probability are allowed but they do not extend the\n+ * support.\n+ *\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Probability_distribution#Discrete_probability_distribution\">Discrete probability distribution (Wikipedia)</a>\n+ * @see <a href=\"http://mathworld.wolfram.com/DiscreteDistribution.html\">Discrete Distribution (MathWorld)</a>\n+ * @version $Id: DiscreteRealDistribution.java 169 2013-03-08 09:02:38Z wydrych $\n+ */\n+public class DiscreteRealDistribution extends AbstractRealDistribution {\n+\n+    /** Serializable UID. */\n+    private static final long serialVersionUID = 20130308L;\n+\n+    /**\n+     * {@link DiscreteDistribution} instance (using the {@link Double} wrapper)\n+     * used to generate samples.\n+     */\n+    protected final DiscreteDistribution<Double> innerDistribution;\n+\n+    /**\n+     * Create a discrete distribution using the given probability mass function\n+     * definition.\n+     *\n+     * @param singletons array of random variable values.\n+     * @param probabilities array of probabilities.\n+     * @throws DimensionMismatchException if\n+     * {@code singletons.length != probabilities.length}\n+     * @throws NotPositiveException if probability of at least one value is\n+     * negative.\n+     * @throws MathArithmeticException if the probabilities sum to zero.\n+     * @throws MathIllegalArgumentException if probability of at least one value\n+     * is infinite.\n+     */\n+    public DiscreteRealDistribution(final double[] singletons, final double[] probabilities)\n+        throws DimensionMismatchException, NotPositiveException, MathArithmeticException, MathIllegalArgumentException {\n+        this(new Well19937c(), singletons, probabilities);\n+    }\n+\n+    /**\n+     * Create a discrete distribution using the given random number generator\n+     * and probability mass function definition.\n+     *\n+     * @param rng random number generator.\n+     * @param singletons array of random variable values.\n+     * @param probabilities array of probabilities.\n+     * @throws DimensionMismatchException if\n+     * {@code singletons.length != probabilities.length}\n+     * @throws NotPositiveException if probability of at least one value is\n+     * negative.\n+     * @throws MathArithmeticException if the probabilities sum to zero.\n+     * @throws MathIllegalArgumentException if probability of at least one value\n+     * is infinite.\n+     */\n+    public DiscreteRealDistribution(final RandomGenerator rng,\n+                                    final double[] singletons, final double[] probabilities)\n+        throws DimensionMismatchException, NotPositiveException, MathArithmeticException, MathIllegalArgumentException {\n+        super(rng);\n+        if (singletons.length != probabilities.length) {\n+            throw new DimensionMismatchException(probabilities.length, singletons.length);\n+        }\n+\n+        List<Pair<Double, Double>> samples = new ArrayList<Pair<Double, Double>>(singletons.length);\n+\n+        for (int i = 0; i < singletons.length; i++) {\n+            samples.add(new Pair<Double, Double>(singletons[i], probabilities[i]));\n+        }\n+\n+        innerDistribution = new DiscreteDistribution<Double>(rng, samples);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double probability(final double x) {\n+        return innerDistribution.probability(x);\n+    }\n+\n+    /**\n+     * For a random variable {@code X} whose values are distributed according to\n+     * this distribution, this method returns {@code P(X = x)}. In other words,\n+     * this method represents the probability mass function (PMF) for the\n+     * distribution.\n+     *\n+     * @param x the point at which the PMF is evaluated\n+     * @return the value of the probability mass function at point {@code x}\n+     */\n+    public double density(final double x) {\n+        return probability(x);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public double cumulativeProbability(final double x) {\n+        double probability = 0;\n+\n+        for (final Pair<Double, Double> sample : innerDistribution.getSamples()) {\n+            if (sample.getKey() <= x) {\n+                probability += sample.getValue();\n+            }\n+        }\n+\n+        return probability;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @return {@code sum(singletons[i] * probabilities[i])}\n+     */\n+    public double getNumericalMean() {\n+        double mean = 0;\n+\n+        for (final Pair<Double, Double> sample : innerDistribution.getSamples()) {\n+            mean += sample.getValue() * sample.getKey();\n+        }\n+\n+        return mean;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @return {@code sum((singletons[i] - mean) ^ 2 * probabilities[i])}\n+     */\n+    public double getNumericalVariance() {\n+        double mean = 0;\n+        double meanOfSquares = 0;\n+\n+        for (final Pair<Double, Double> sample : innerDistribution.getSamples()) {\n+            mean += sample.getValue() * sample.getKey();\n+            meanOfSquares += sample.getValue() * sample.getKey() * sample.getKey();\n+        }\n+\n+        return meanOfSquares - mean * mean;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * Returns the lowest value with non-zero probability.\n+     *\n+     * @return the lowest value with non-zero probability.\n+     */\n+    public double getSupportLowerBound() {\n+        double min = Double.POSITIVE_INFINITY;\n+        for (final Pair<Double, Double> sample : innerDistribution.getSamples()) {\n+            if (sample.getKey() < min && sample.getValue() > 0) {\n+                min = sample.getKey();\n+            }\n+        }\n+\n+        return min;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * Returns the highest value with non-zero probability.\n+     *\n+     * @return the highest value with non-zero probability.\n+     */\n+    public double getSupportUpperBound() {\n+        double max = Double.NEGATIVE_INFINITY;\n+        for (final Pair<Double, Double> sample : innerDistribution.getSamples()) {\n+            if (sample.getKey() > max && sample.getValue() > 0) {\n+                max = sample.getKey();\n+            }\n+        }\n+\n+        return max;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The support of this distribution includes the lower bound.\n+     *\n+     * @return {@code true}\n+     */\n+    public boolean isSupportLowerBoundInclusive() {\n+        return true;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The support of this distribution includes the upper bound.\n+     *\n+     * @return {@code true}\n+     */\n+    public boolean isSupportUpperBoundInclusive() {\n+        return true;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The support of this distribution is connected.\n+     *\n+     * @return {@code true}\n+     */\n+    public boolean isSupportConnected() {\n+        return true;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double sample() {\n+        return innerDistribution.sample();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/distribution/DiscreteIntegerDistributionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.distribution;\n+\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MathArithmeticException;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.NotPositiveException;\n+import org.apache.commons.math3.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Test class for {@link DiscreteIntegerDistribution}.\n+ * \n+ * @version $Id: DiscreteIntegerDistributionTest.java 161 2013-03-07 09:47:32Z wydrych $\n+ */\n+public class DiscreteIntegerDistributionTest {\n+\n+    /**\n+     * The distribution object used for testing.\n+     */\n+    private final DiscreteIntegerDistribution testDistribution;\n+\n+    /**\n+     * Creates the default distribution object uded for testing.\n+     */\n+    public DiscreteIntegerDistributionTest() {\n+        // Non-sorted singleton array with duplicates should be allowed.\n+        // Values with zero-probability do not extend the support.\n+        testDistribution = new DiscreteIntegerDistribution(\n+                new int[]{3, -1, 3, 7, -2, 8},\n+                new double[]{0.2, 0.2, 0.3, 0.3, 0.0, 0.0});\n+    }\n+\n+    /**\n+     * Tests if the {@link DiscreteIntegerDistribution} constructor throws\n+     * exceptions for ivalid data.\n+     */\n+    @Test\n+    public void testExceptions() {\n+        DiscreteIntegerDistribution invalid = null;\n+        try {\n+            invalid = new DiscreteIntegerDistribution(new int[]{1, 2}, new double[]{0.0});\n+            Assert.fail(\"Expected DimensionMismatchException\");\n+        } catch (DimensionMismatchException e) {\n+        }\n+        try {\n+            invalid = new DiscreteIntegerDistribution(new int[]{1, 2}, new double[]{0.0, -1.0});\n+            Assert.fail(\"Expected NotPositiveException\");\n+        } catch (NotPositiveException e) {\n+        }\n+        try {\n+            invalid = new DiscreteIntegerDistribution(new int[]{1, 2}, new double[]{0.0, 0.0});\n+            Assert.fail(\"Expected MathArithmeticException\");\n+        } catch (MathArithmeticException e) {\n+        }\n+        try {\n+            invalid = new DiscreteIntegerDistribution(new int[]{1, 2}, new double[]{0.0, Double.NaN});\n+            Assert.fail(\"Expected MathArithmeticException\");\n+        } catch (MathArithmeticException e) {\n+        }\n+        try {\n+            invalid = new DiscreteIntegerDistribution(new int[]{1, 2}, new double[]{0.0, Double.POSITIVE_INFINITY});\n+            Assert.fail(\"Expected MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException e) {\n+        }\n+        Assert.assertNull(\"Expected non-initialized DiscreteRealDistribution\", invalid);\n+    }\n+\n+    /**\n+     * Tests if the distribution returns proper probability values.\n+     */\n+    @Test\n+    public void testProbability() {\n+        int[] points = new int[]{-2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8};\n+        double[] results = new double[]{0, 0.2, 0, 0, 0, 0.5, 0, 0, 0, 0.3, 0};\n+        for (int p = 0; p < points.length; p++) {\n+            double probability = testDistribution.probability(points[p]);\n+            Assert.assertEquals(results[p], probability, 0.0);\n+        }\n+    }\n+\n+    /**\n+     * Tests if the distribution returns proper cumulative probability values.\n+     */\n+    @Test\n+    public void testCumulativeProbability() {\n+        int[] points = new int[]{-2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8};\n+        double[] results = new double[]{0, 0.2, 0.2, 0.2, 0.2, 0.7, 0.7, 0.7, 0.7, 1.0, 1.0};\n+        for (int p = 0; p < points.length; p++) {\n+            double probability = testDistribution.cumulativeProbability(points[p]);\n+            Assert.assertEquals(results[p], probability, 1e-10);\n+        }\n+    }\n+\n+    /**\n+     * Tests if the distribution returns proper mean value.\n+     */\n+    @Test\n+    public void testGetNumericalMean() {\n+        Assert.assertEquals(3.4, testDistribution.getNumericalMean(), 1e-10);\n+    }\n+\n+    /**\n+     * Tests if the distribution returns proper variance.\n+     */\n+    @Test\n+    public void testGetNumericalVariance() {\n+        Assert.assertEquals(7.84, testDistribution.getNumericalVariance(), 1e-10);\n+    }\n+\n+    /**\n+     * Tests if the distribution returns proper lower bound.\n+     */\n+    @Test\n+    public void testGetSupportLowerBound() {\n+        Assert.assertEquals(-1, testDistribution.getSupportLowerBound());\n+    }\n+\n+    /**\n+     * Tests if the distribution returns proper upper bound.\n+     */\n+    @Test\n+    public void testGetSupportUpperBound() {\n+        Assert.assertEquals(7, testDistribution.getSupportUpperBound());\n+    }\n+\n+    /**\n+     * Tests if the distribution returns properly that the support is connected.\n+     */\n+    @Test\n+    public void testIsSupportConnected() {\n+        Assert.assertTrue(testDistribution.isSupportConnected());\n+    }\n+\n+    /**\n+     * Tests sampling.\n+     */\n+    @Test\n+    public void testSample() {\n+        final int n = 1000000;\n+        testDistribution.reseedRandomGenerator(-334759360); // fixed seed\n+        final int[] samples = testDistribution.sample(n);\n+        Assert.assertEquals(n, samples.length);\n+        double sum = 0;\n+        double sumOfSquares = 0;\n+        for (int i = 0; i < samples.length; i++) {\n+            sum += samples[i];\n+            sumOfSquares += samples[i] * samples[i];\n+        }\n+        Assert.assertEquals(testDistribution.getNumericalMean(),\n+                sum / n, 1e-2);\n+        Assert.assertEquals(testDistribution.getNumericalVariance(),\n+                sumOfSquares / n - FastMath.pow(sum / n, 2), 1e-2);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/distribution/DiscreteRealDistributionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.distribution;\n+\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MathArithmeticException;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.NotPositiveException;\n+import org.apache.commons.math3.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Test class for {@link DiscreteRealDistribution}.\n+ * \n+ * @version $Id: DiscreteRealDistributionTest.java 161 2013-03-07 09:47:32Z wydrych $\n+ */\n+public class DiscreteRealDistributionTest {\n+\n+    /**\n+     * The distribution object used for testing.\n+     */\n+    private final DiscreteRealDistribution testDistribution;\n+\n+    /**\n+     * Creates the default distribution object uded for testing.\n+     */\n+    public DiscreteRealDistributionTest() {\n+        // Non-sorted singleton array with duplicates should be allowed.\n+        // Values with zero-probability do not extend the support.\n+        testDistribution = new DiscreteRealDistribution(\n+                new double[]{3.0, -1.0, 3.0, 7.0, -2.0, 8.0},\n+                new double[]{0.2, 0.2, 0.3, 0.3, 0.0, 0.0});\n+    }\n+\n+    /**\n+     * Tests if the {@link DiscreteRealDistribution} constructor throws\n+     * exceptions for ivalid data.\n+     */\n+    @Test\n+    public void testExceptions() {\n+        DiscreteRealDistribution invalid = null;\n+        try {\n+            invalid = new DiscreteRealDistribution(new double[]{1.0, 2.0}, new double[]{0.0});\n+            Assert.fail(\"Expected DimensionMismatchException\");\n+        } catch (DimensionMismatchException e) {\n+        }\n+        try{\n+        invalid = new DiscreteRealDistribution(new double[]{1.0, 2.0}, new double[]{0.0, -1.0});\n+            Assert.fail(\"Expected NotPositiveException\");\n+        } catch (NotPositiveException e) {\n+        }\n+        try {\n+            invalid = new DiscreteRealDistribution(new double[]{1.0, 2.0}, new double[]{0.0, 0.0});\n+            Assert.fail(\"Expected MathArithmeticException\");\n+        } catch (MathArithmeticException e) {\n+        }\n+        try {\n+            invalid = new DiscreteRealDistribution(new double[]{1.0, 2.0}, new double[]{0.0, Double.NaN});\n+            Assert.fail(\"Expected MathArithmeticException\");\n+        } catch (MathArithmeticException e) {\n+        }\n+        try {\n+            invalid = new DiscreteRealDistribution(new double[]{1.0, 2.0}, new double[]{0.0, Double.POSITIVE_INFINITY});\n+            Assert.fail(\"Expected MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException e) {\n+        }\n+        Assert.assertNull(\"Expected non-initialized DiscreteRealDistribution\", invalid);\n+    }\n+\n+    /**\n+     * Tests if the distribution returns proper probability values.\n+     */\n+    @Test\n+    public void testProbability() {\n+        double[] points = new double[]{-2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0};\n+        double[] results = new double[]{0, 0.2, 0, 0, 0, 0.5, 0, 0, 0, 0.3, 0};\n+        for (int p = 0; p < points.length; p++) {\n+            double density = testDistribution.probability(points[p]);\n+            Assert.assertEquals(results[p], density, 0.0);\n+        }\n+    }\n+\n+    /**\n+     * Tests if the distribution returns proper density values.\n+     */\n+    @Test\n+    public void testDensity() {\n+        double[] points = new double[]{-2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0};\n+        double[] results = new double[]{0, 0.2, 0, 0, 0, 0.5, 0, 0, 0, 0.3, 0};\n+        for (int p = 0; p < points.length; p++) {\n+            double density = testDistribution.density(points[p]);\n+            Assert.assertEquals(results[p], density, 0.0);\n+        }\n+    }\n+\n+    /**\n+     * Tests if the distribution returns proper cumulative probability values.\n+     */\n+    @Test\n+    public void testCumulativeProbability() {\n+        double[] points = new double[]{-2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0};\n+        double[] results = new double[]{0, 0.2, 0.2, 0.2, 0.2, 0.7, 0.7, 0.7, 0.7, 1.0, 1.0};\n+        for (int p = 0; p < points.length; p++) {\n+            double probability = testDistribution.cumulativeProbability(points[p]);\n+            Assert.assertEquals(results[p], probability, 1e-10);\n+        }\n+    }\n+\n+    /**\n+     * Tests if the distribution returns proper mean value.\n+     */\n+    @Test\n+    public void testGetNumericalMean() {\n+        Assert.assertEquals(3.4, testDistribution.getNumericalMean(), 1e-10);\n+    }\n+\n+    /**\n+     * Tests if the distribution returns proper variance.\n+     */\n+    @Test\n+    public void testGetNumericalVariance() {\n+        Assert.assertEquals(7.84, testDistribution.getNumericalVariance(), 1e-10);\n+    }\n+\n+    /**\n+     * Tests if the distribution returns proper lower bound.\n+     */\n+    @Test\n+    public void testGetSupportLowerBound() {\n+        Assert.assertEquals(-1, testDistribution.getSupportLowerBound(), 0);\n+    }\n+\n+    /**\n+     * Tests if the distribution returns proper upper bound.\n+     */\n+    @Test\n+    public void testGetSupportUpperBound() {\n+        Assert.assertEquals(7, testDistribution.getSupportUpperBound(), 0);\n+    }\n+\n+    /**\n+     * Tests if the distribution returns properly that the support includes the\n+     * lower bound.\n+     */\n+    @Test\n+    public void testIsSupportLowerBoundInclusive() {\n+        Assert.assertTrue(testDistribution.isSupportLowerBoundInclusive());\n+    }\n+\n+    /**\n+     * Tests if the distribution returns properly that the support includes the\n+     * upper bound.\n+     */\n+    @Test\n+    public void testIsSupportUpperBoundInclusive() {\n+        Assert.assertTrue(testDistribution.isSupportUpperBoundInclusive());\n+    }\n+\n+    /**\n+     * Tests if the distribution returns properly that the support is connected.\n+     */\n+    @Test\n+    public void testIsSupportConnected() {\n+        Assert.assertTrue(testDistribution.isSupportConnected());\n+    }\n+\n+    /**\n+     * Tests sampling.\n+     */\n+    @Test\n+    public void testSample() {\n+        final int n = 1000000;\n+        testDistribution.reseedRandomGenerator(-334759360); // fixed seed\n+        final double[] samples = testDistribution.sample(n);\n+        Assert.assertEquals(n, samples.length);\n+        double sum = 0;\n+        double sumOfSquares = 0;\n+        for (int i = 0; i < samples.length; i++) {\n+            sum += samples[i];\n+            sumOfSquares += samples[i] * samples[i];\n+        }\n+        Assert.assertEquals(testDistribution.getNumericalMean(),\n+                sum / n, 1e-2);\n+        Assert.assertEquals(testDistribution.getNumericalVariance(),\n+                sumOfSquares / n - FastMath.pow(sum / n, 2), 1e-2);\n+    }\n+}", "timestamp": 1362758369, "metainfo": ""}