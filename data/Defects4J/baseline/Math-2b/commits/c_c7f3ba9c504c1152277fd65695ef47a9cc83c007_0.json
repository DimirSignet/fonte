{"sha": "c7f3ba9c504c1152277fd65695ef47a9cc83c007", "log": "[MATH-898] Add implementation of fuzzy k-means clusterer.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/ml/clustering/FuzzyKMeansClusterer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.ml.clustering;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n+import org.apache.commons.math3.linear.MatrixUtils;\n+import org.apache.commons.math3.linear.RealMatrix;\n+import org.apache.commons.math3.ml.distance.DistanceMeasure;\n+import org.apache.commons.math3.ml.distance.EuclideanDistance;\n+import org.apache.commons.math3.random.JDKRandomGenerator;\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.MathArrays;\n+import org.apache.commons.math3.util.MathUtils;\n+\n+/**\n+ * Fuzzy K-Means algorithm.\n+ * <p>\n+ * TODO\n+ * <p>\n+ * The algorithm requires two parameters:\n+ * <ul>\n+ * <li>k: the number of clusters\n+ * <li>fuzzyness: ...\n+ * </ul>\n+ *\n+ * @param <T> type of the points to cluster\n+ * @version $Id$\n+ * @since 4.0\n+ */\n+public class FuzzyKMeansClusterer<T extends Clusterable> extends Clusterer<T> {\n+\n+    /** The default value for the convergence criteria. */\n+    private static final double DEFAULT_EPSILON = 1e-3;\n+\n+    /** The number of clusters. */\n+    private final int k;\n+\n+    /** The maximum number of iterations. */\n+    private final int maxIterations;\n+\n+    /** The fuzzyness factor. */\n+    private final double fuzzyness;\n+\n+    /** The convergence criteria. */\n+    private final double epsilon;\n+\n+    /** Random generator for choosing initial centers. */\n+    private final RandomGenerator random;\n+\n+    /** The membership matrix. */\n+    private double[][] membershipMatrix;\n+\n+    /** The list of points used in the last call to {@link #cluster(Collection)}. */\n+    private List<T> points;\n+\n+    /** The list of clusters resulting from the last call to {@link #cluster(Collection)}. */\n+    private List<CentroidCluster<T>> clusters;\n+\n+    /**\n+     * Creates a new instance of a FuzzyKMeansClusterer.\n+     * <p>\n+     * The euclidean distance will be used as default distance measure.\n+     *\n+     * @param k the number of clusters to split the data into\n+     * @param fuzzyness the fuzzyness factor, must be &gt; 1.0\n+     * @throws NumberIsTooSmallException if {@code fuzzyness <= 1.0}\n+     */\n+    public FuzzyKMeansClusterer(final int k, final double fuzzyness) throws NumberIsTooSmallException {\n+        this(k, fuzzyness, -1, new EuclideanDistance());\n+    }\n+\n+    /**\n+     * Creates a new instance of a FuzzyKMeansClusterer.\n+     *\n+     * @param k the number of clusters to split the data into\n+     * @param fuzzyness the fuzzyness factor, must be &gt; 1.0\n+     * @param maxIterations the maximum number of iterations to run the algorithm for.\n+     *   If negative, no maximum will be used.\n+     * @param measure the distance measure to use\n+     * @throws NumberIsTooSmallException if {@code fuzzyness <= 1.0}\n+     */\n+    public FuzzyKMeansClusterer(final int k, final double fuzzyness,\n+                                final int maxIterations, final DistanceMeasure measure)\n+            throws NumberIsTooSmallException {\n+        this(k, fuzzyness, maxIterations, measure, DEFAULT_EPSILON, new JDKRandomGenerator());\n+    }\n+\n+    /**\n+     * Creates a new instance of a FuzzyKMeansClusterer.\n+     *\n+     * @param k the number of clusters to split the data into\n+     * @param fuzzyness the fuzzyness factor, must be &gt; 1.0\n+     * @param maxIterations the maximum number of iterations to run the algorithm for.\n+     *   If negative, no maximum will be used.\n+     * @param measure the distance measure to use\n+     * @param epsilon the convergence criteria\n+     * @param random random generator to use for choosing initial centers\n+     * @throws NumberIsTooSmallException if {@code fuzzyness <= 1.0}\n+     */\n+    public FuzzyKMeansClusterer(final int k, final double fuzzyness,\n+                                final int maxIterations, final DistanceMeasure measure,\n+                                final double epsilon, final RandomGenerator random)\n+            throws NumberIsTooSmallException {\n+\n+        super(measure);\n+\n+        if (fuzzyness <= 1.0d) {\n+            throw new NumberIsTooSmallException(fuzzyness, 1.0, false);\n+        }\n+        this.k = k;\n+        this.fuzzyness = fuzzyness;\n+        this.maxIterations = maxIterations;\n+        this.epsilon = epsilon;\n+        this.random = random;\n+\n+        this.membershipMatrix = null;\n+        this.points = null;\n+        this.clusters = null;\n+    }\n+\n+    /**\n+     * Return the number of clusters this instance will use.\n+     * @return the number of clusters\n+     */\n+    public int getK() {\n+        return k;\n+    }\n+\n+    /**\n+     * Returns the fuzzyness factor used by this instance.\n+     * @return the fuzzyness factor\n+     */\n+    public double getFuzzyness() {\n+        return fuzzyness;\n+    }\n+\n+    /**\n+     * Returns the maximum number of iterations this instance will use.\n+     * @return the maximum number of iterations, or -1 if no maximum is set\n+     */\n+    public int getMaxIterations() {\n+        return maxIterations;\n+    }\n+\n+    /**\n+     * Returns the random generator this instance will use.\n+     * @return the random generator\n+     */\n+    public RandomGenerator getRandomGenerator() {\n+        return random;\n+    }\n+\n+    /**\n+     * Returns the {@code nxk} membership matrix, where {@code n} is the number\n+     * of data points and {@code k} the number of clusters.\n+     * <p>\n+     * The element U<sub>i,j</sub> represents the membership value for data point {@code i}\n+     * to cluster {@code j}.\n+     *\n+     * @return the membership matrix\n+     */\n+    public RealMatrix getMembershipMatrix() {\n+        return MatrixUtils.createRealMatrix(membershipMatrix);\n+    }\n+\n+    /**\n+     * Returns an unmodifiable list of the data points used in the last\n+     * call to {@link #cluster(Collection)}.\n+     * @return the list of data points, or {@code null} if {@link #cluster(Collection)} has\n+     *   not been called before.\n+     */\n+    public List<T> getDataPoints() {\n+        return points;\n+    }\n+\n+    /**\n+     * Returns the list of clusters resulting from the last call to {@link #cluster(Collection)}.\n+     * @return the list of clusters, or {@code null} if {@link #cluster(Collection)} has\n+     *   not been called before.\n+     */\n+    public List<CentroidCluster<T>> getClusters() {\n+        return clusters;\n+    }\n+\n+    /**\n+     * Get the value of the objective function.\n+     * @return the objective function as double value, or {@code 0.0} if {@link #cluster(Collection)}\n+     *   has not been called before.\n+     */\n+    public double getObjectiveFunctionValue() {\n+        if (points == null || clusters == null) {\n+            return 0;\n+        }\n+\n+        int i = 0;\n+        double objFunction = 0.0;\n+        for (final T point : points) {\n+            int j = 0;\n+            for (final CentroidCluster<T> cluster : clusters) {\n+                double dist = distance(point, cluster.getCenter());\n+                objFunction += (dist * dist) * FastMath.pow(membershipMatrix[i][j], fuzzyness);\n+                j++;\n+            }\n+            i++;\n+        }\n+        return objFunction;\n+    }\n+\n+    /**\n+     * Performs Fuzzy K-Means cluster analysis.\n+     *\n+     * @param dataPoints the points to cluster\n+     * @return the list of clusters\n+     * @throws MathIllegalArgumentException if the data points are null or the number\n+     *     of clusters is larger than the number of data points\n+     */\n+    public List<CentroidCluster<T>> cluster(final Collection<T> dataPoints)\n+            throws MathIllegalArgumentException {\n+\n+        // sanity checks\n+        MathUtils.checkNotNull(dataPoints);\n+\n+        final int size = dataPoints.size();\n+\n+        // number of clusters has to be smaller or equal the number of data points\n+        if (size < k) {\n+            throw new NumberIsTooSmallException(size, k, false);\n+        }\n+\n+        // copy the input collection to an unmodifiable list with indexed access\n+        points = Collections.unmodifiableList(new ArrayList<T>(dataPoints));\n+        clusters = new ArrayList<CentroidCluster<T>>();\n+        membershipMatrix = new double[size][k];\n+        final double[][] oldMatrix = new double[size][k];\n+\n+        // if no points are provided, return an empty list of clusters\n+        if (size == 0) {\n+            return clusters;\n+        }\n+\n+        initializeMembershipMatrix();\n+\n+        // there is at least one point\n+        final int pointDimension = points.get(0).getPoint().length;\n+        for (int i = 0; i < k; i++) {\n+            clusters.add(new CentroidCluster<T>(new DoublePoint(new double[pointDimension])));\n+        }\n+\n+        int iteration = 0;\n+        final int max = (maxIterations < 0) ? Integer.MAX_VALUE : maxIterations;\n+        double difference = 0.0;\n+\n+        do {\n+            saveMembershipMatrix(oldMatrix);\n+            updateClusterCenters();\n+            updateMembershipMatrix();\n+            difference = calculateMaxMembershipChange(oldMatrix);\n+        } while (difference > epsilon && ++iteration < max);\n+\n+        return clusters;\n+    }\n+\n+    /**\n+     * Update the cluster centers.\n+     */\n+    private void updateClusterCenters() {\n+        int j = 0;\n+        final List<CentroidCluster<T>> newClusters = new ArrayList<CentroidCluster<T>>(k);\n+        for (final CentroidCluster<T> cluster : clusters) {\n+            final Clusterable center = cluster.getCenter();\n+            int i = 0;\n+            double[] arr = new double[center.getPoint().length];\n+            double sum = 0.0;\n+            for (final T point : points) {\n+                final double u = FastMath.pow(membershipMatrix[i][j], fuzzyness);\n+                final double[] pointArr = point.getPoint();\n+                for (int idx = 0; idx < arr.length; idx++) {\n+                    arr[idx] += u * pointArr[idx];\n+                }\n+                sum += u;\n+                i++;\n+            }\n+            MathArrays.scaleInPlace(1.0 / sum, arr);\n+            newClusters.add(new CentroidCluster<T>(new DoublePoint(arr)));\n+            j++;\n+        }\n+        clusters.clear();\n+        clusters = newClusters;\n+    }\n+\n+    /**\n+     * Updates the membership matrix and assigns the points to the cluster with\n+     * the highest membership.\n+     */\n+    private void updateMembershipMatrix() {\n+        for (int i = 0; i < points.size(); i++) {\n+            final T point = points.get(i);\n+            double maxMembership = 0.0;\n+            int newCluster = -1;\n+            for (int j = 0; j < clusters.size(); j++) {\n+                double sum = 0.0;\n+                final double distA = FastMath.abs(distance(point, clusters.get(j).getCenter()));\n+\n+                for (final CentroidCluster<T> c : clusters) {\n+                    final double distB = FastMath.abs(distance(point, c.getCenter()));\n+                    sum += FastMath.pow(distA / distB, 2.0 / (fuzzyness - 1.0));\n+                }\n+\n+                membershipMatrix[i][j] = 1.0 / sum;\n+\n+                if (membershipMatrix[i][j] > maxMembership) {\n+                    maxMembership = membershipMatrix[i][j];\n+                    newCluster = j;\n+                }\n+            }\n+            clusters.get(newCluster).addPoint(point);\n+        }\n+    }\n+\n+    /**\n+     * Initialize the membership matrix with random values.\n+     */\n+    private void initializeMembershipMatrix() {\n+        for (int i = 0; i < points.size(); i++) {\n+            for (int j = 0; j < k; j++) {\n+                membershipMatrix[i][j] = random.nextDouble();\n+            }\n+            membershipMatrix[i] = MathArrays.normalizeArray(membershipMatrix[i], 1.0);\n+        }\n+    }\n+\n+    /**\n+     * Calculate the maximum element-by-element change of the membership matrix\n+     * for the current iteration.\n+     *\n+     * @param matrix the membership matrix of the previous iteration\n+     * @return the maximum membership matrix change\n+     */\n+    private double calculateMaxMembershipChange(final double[][] matrix) {\n+        double maxMembership = 0.0;\n+        for (int i = 0; i < points.size(); i++) {\n+            for (int j = 0; j < clusters.size(); j++) {\n+                double v = FastMath.abs(membershipMatrix[i][j] - matrix[i][j]);\n+                maxMembership = FastMath.max(v, maxMembership);\n+            }\n+        }\n+        return maxMembership;\n+    }\n+\n+    /**\n+     * Copy the membership matrix into the provided matrix.\n+     *\n+     * @param matrix the place to store the membership matrix\n+     */\n+    private void saveMembershipMatrix(final double[][] matrix) {\n+        for (int i = 0; i < points.size(); i++) {\n+            System.arraycopy(membershipMatrix[i], 0, matrix[i], 0, clusters.size());\n+        }\n+    }\n+\n+}", "timestamp": 1365542916, "metainfo": ""}