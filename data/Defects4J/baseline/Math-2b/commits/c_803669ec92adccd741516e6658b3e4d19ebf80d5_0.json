{"sha": "803669ec92adccd741516e6658b3e4d19ebf80d5", "log": "Removed branching.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/analysis/integration/MidPointIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/integration/MidPointIntegrator.java\n      * arbitrary m sections because this configuration can best utilize the\n      * already computed values.</p>\n      *\n-     * @param n the stage of 1/2 refinement, n = 0 is no refinement\n-     * @param previousStageResult Result from the previous call to the {@code stage}\n-     * method. It is unused in the first stage (when {@code n} is equal to 0).\n+     * @param n the stage of 1/2 refinement. Must be larger than 0.\n+     * @param previousStageResult Result from the previous call to the\n+     * {@code stage} method.\n+     * @param min Lower bound of the integration interval.\n+     * @param diffMaxMin Difference between the lower bound and upper bound\n+     * of the integration interval.\n      * @return the value of n-th stage integral\n      * @throws TooManyEvaluationsException if the maximal number of evaluations\n      * is exceeded.\n      */\n     private double stage(final int n,\n-                         double previousStageResult)\n+                         double previousStageResult,\n+                         double min,\n+                         double diffMaxMin)\n         throws TooManyEvaluationsException {\n \n-        final double min = getMin();\n-        final double diff = getMax() - min;\n+        // number of new points in this stage\n+        final long np = 1L << (n - 1);\n+        double sum = 0;\n \n-        if (n == 0) {\n-            final double midPoint = min + 0.5 * diff;\n-            return diff * computeObjectiveValue(midPoint);\n-        } else {\n-            final long np = 1L << (n - 1);           // number of new points in this stage\n-            double sum = 0;\n-            // spacing between adjacent new points\n-            final double spacing = diff / np;\n-            double x = min + 0.5 * spacing;    // the first new point\n-            for (long i = 0; i < np; i++) {\n-                sum += computeObjectiveValue(x);\n-                x += spacing;\n-            }\n-            // add the new sum to previously calculated result\n-            return 0.5 * (previousStageResult + sum * spacing);\n+        // spacing between adjacent new points\n+        final double spacing = diffMaxMin / np;\n+\n+        // the first new point\n+        double x = min + 0.5 * spacing;\n+        for (long i = 0; i < np; i++) {\n+            sum += computeObjectiveValue(x);\n+            x += spacing;\n         }\n+        // add the new sum to previously calculated result\n+        return 0.5 * (previousStageResult + sum * spacing);\n     }\n+\n \n     /** {@inheritDoc} */\n     protected double doIntegrate()\n         throws MathIllegalArgumentException, TooManyEvaluationsException, MaxCountExceededException {\n \n-        double oldt = stage(0, 0d);\n-        iterations.incrementCount();\n+        final double min = getMin();\n+        final double diff = getMax() - min;\n+        final double midPoint = min + 0.5 * diff;\n+\n+        double oldt = diff * computeObjectiveValue(midPoint);\n+\n         while (true) {\n+            iterations.incrementCount();\n             final int i = iterations.getCount();\n-            final double t = stage(i, oldt);\n+            final double t = stage(i, oldt, min, diff);\n             if (i >= getMinimalIterationCount()) {\n                 final double delta = FastMath.abs(t - oldt);\n                 final double rLimit =\n                 }\n             }\n             oldt = t;\n-            iterations.incrementCount();\n         }\n \n     }", "timestamp": 1370267303, "metainfo": ""}