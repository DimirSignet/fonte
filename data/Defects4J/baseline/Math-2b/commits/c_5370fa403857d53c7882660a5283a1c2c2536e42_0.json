{"sha": "5370fa403857d53c7882660a5283a1c2c2536e42", "log": "MATH-1008 Simplification of the code introduced in revision 1508481. The changes only focus on the \"fluent API\" aspect (rather than also try to achieve thread-safety through immutability). Class \"AbstractOptimizer\" introduced to serve as the base class for all optimizers (i.e. replace the current \"BaseOptimizer\").   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/fitting/leastsquares/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/fitting/leastsquares/AbstractLeastSquaresOptimizer.java\n package org.apache.commons.math3.fitting.leastsquares;\n \n import org.apache.commons.math3.exception.DimensionMismatchException;\n-import org.apache.commons.math3.exception.MathUnsupportedOperationException;\n import org.apache.commons.math3.analysis.MultivariateVectorFunction;\n import org.apache.commons.math3.analysis.MultivariateMatrixFunction;\n import org.apache.commons.math3.linear.ArrayRealVector;\n import org.apache.commons.math3.linear.MatrixUtils;\n import org.apache.commons.math3.linear.QRDecomposition;\n import org.apache.commons.math3.linear.EigenDecomposition;\n-import org.apache.commons.math3.optim.ConvergenceChecker;\n-import org.apache.commons.math3.optim.BaseOptimizer;\n+import org.apache.commons.math3.optim.AbstractOptimizer;\n import org.apache.commons.math3.optim.PointVectorValuePair;\n-import org.apache.commons.math3.optim.OptimizationData;\n import org.apache.commons.math3.util.FastMath;\n \n /**\n  * Base class for implementing least-squares optimizers.\n  * It provides methods for error estimation.\n  *\n+ * @param <OPTIM> Concrete optimizer.\n+ *\n  * @version $Id$\n  * @since 3.3\n  */\n-public abstract class AbstractLeastSquaresOptimizer\n-    extends BaseOptimizer<PointVectorValuePair> {\n+public abstract class AbstractLeastSquaresOptimizer<OPTIM extends AbstractLeastSquaresOptimizer<OPTIM>>\n+    extends AbstractOptimizer<PointVectorValuePair, OPTIM>\n+    implements WithTarget<OPTIM>,\n+               WithWeight<OPTIM>,\n+               WithModelAndJacobian<OPTIM>,\n+               WithStartPoint<OPTIM> {\n     /** Target values for the model function at optimum. */\n-    private final double[] target;\n+    private double[] target;\n     /** Weight matrix. */\n-    private final RealMatrix weight;\n+    private RealMatrix weight;\n     /** Model function. */\n-    private final MultivariateVectorFunction model;\n+    private MultivariateVectorFunction model;\n     /** Jacobian of the model function. */\n-    private final MultivariateMatrixFunction jacobian;\n+    private MultivariateMatrixFunction jacobian;\n     /** Square-root of the weight matrix. */\n-    private final RealMatrix weightSqrt;\n+    private RealMatrix weightSqrt;\n     /** Initial guess. */\n-    private final double[] start;\n-\n-    /**\n-     * @param target Observations.\n-     * @param weight Weight of the observations.\n-     * For performance, no defensive copy is performed.\n-     * @param weightSqrt Square-root of the {@code weight} matrix.\n-     * If {@code null}, it will be computed; otherwise it is the caller's\n-     * responsibility that {@code weight} and {@code weightSqrt} are\n-     * consistent.\n-     * No defensive copy is performed.\n-     * @param model ModelFunction.\n-     * @param jacobian Jacobian of the model function.\n-     * @param checker Convergence checker.\n-     * @param start Initial guess.\n-     * @param maxEval Maximum number of evaluations of the model\n-     * function.\n-     * @param maxIter Maximum number of iterations.\n-     */\n-    protected AbstractLeastSquaresOptimizer(double[] target,\n-                                            RealMatrix weight,\n-                                            RealMatrix weightSqrt,\n-                                            MultivariateVectorFunction model,\n-                                            MultivariateMatrixFunction jacobian,\n-                                            ConvergenceChecker<PointVectorValuePair> checker,\n-                                            double[] start,\n-                                            int maxEval,\n-                                            int maxIter) {\n-        super(checker, maxEval, maxIter);\n-\n-        this.target = target;\n-        this.weight = weight;\n-        this.model = model;\n-        this.jacobian = jacobian;\n-        this.start = start;\n-\n-        this.weightSqrt = weightSqrt == null ?\n-            (weight == null ?\n-             null : squareRoot(weight)) : weightSqrt;\n+    private double[] start;\n+\n+    /**\n+     * Default constructor.\n+     */\n+    protected AbstractLeastSquaresOptimizer() {}\n+\n+    /**\n+     * Copy constructor.\n+     *\n+     * @param other Instance to copy.\n+     */\n+    protected AbstractLeastSquaresOptimizer(AbstractLeastSquaresOptimizer other) {\n+        target = other.target == null ? null : other.target.clone();\n+        start = other.start == null ? null : other.start.clone();\n+        weight = other.weight == null ? null : other.weight.copy();\n+        weightSqrt = other.weightSqrt == null ? null : other.weightSqrt.copy();\n+        model = other.model; // XXX Not thread-safe\n+        jacobian = other.jacobian; // XXX Not thread-safe\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OPTIM withTarget(double[] target) {\n+        this.target = target.clone();\n+        return self();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OPTIM withWeight(RealMatrix weight) {\n+        this.weight = weight; // XXX Not thread-safe\n+        weightSqrt = squareRoot(weight);\n+        return self();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OPTIM withModelAndJacobian(MultivariateVectorFunction model,\n+                                      MultivariateMatrixFunction jacobian) {\n+        this.model = model; // XXX Not thread-safe\n+        this.jacobian = jacobian; // XXX Not thread-safe\n+        return self();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OPTIM withStartPoint(double[] start) {\n+        this.start = start.clone();\n+        return self();\n     }\n \n     /**\n     public double computeRMS(double[] params) {\n         final double cost = computeCost(computeResiduals(getModel().value(params)));\n         return FastMath.sqrt(cost * cost / target.length);\n-    }\n-\n-    /**\n-     * Calling this method will raise an exception.\n-     *\n-     * @param optData Obsolete.\n-     * @return nothing.\n-     * @throws MathUnsupportedOperationException if called.\n-     * @deprecated Do not use this method.\n-     */\n-    @Deprecated\n-    @Override\n-    public PointVectorValuePair optimize(OptimizationData... optData)\n-        throws MathUnsupportedOperationException {\n-        throw new MathUnsupportedOperationException();\n-    }\n-\n-    /**\n-     * Gets a reference to the corresponding field.\n-     * Altering it could jeopardize the consistency of this class.\n-     *\n-     * @return the reference.\n-     */\n-    protected double[] getTargetInternal() {\n-        return target;\n-    }\n-\n-    /**\n-     * Gets a reference to the corresponding field.\n-     * Altering it could jeopardize the consistency of this class.\n-     *\n-     * @return the reference.\n-     */\n-    protected RealMatrix getWeightInternal() {\n-        return weight;\n-    }\n-\n-    /**\n-     * Gets a reference to the corresponding field.\n-     * Altering it could jeopardize the consistency of this class.\n-     *\n-     * @return the reference.\n-     */\n-    protected RealMatrix getWeightSquareRootInternal() {\n-        return weightSqrt;\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math3/fitting/leastsquares/GaussNewtonOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/fitting/leastsquares/GaussNewtonOptimizer.java\n  */\n package org.apache.commons.math3.fitting.leastsquares;\n \n-import org.apache.commons.math3.analysis.MultivariateVectorFunction;\n-import org.apache.commons.math3.analysis.MultivariateMatrixFunction;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.ConvergenceException;\n import org.apache.commons.math3.exception.NullArgumentException;\n  *\n  * @version $Id$\n  * @since 3.3\n- *\n  */\n-public class GaussNewtonOptimizer extends AbstractLeastSquaresOptimizer\n-    implements WithTarget<GaussNewtonOptimizer>,\n-               WithWeight<GaussNewtonOptimizer>,\n-               WithModelAndJacobian<GaussNewtonOptimizer>,\n-               WithConvergenceChecker<GaussNewtonOptimizer>,\n-               WithStartPoint<GaussNewtonOptimizer>,\n-               WithMaxIterations<GaussNewtonOptimizer>,\n-               WithMaxEvaluations<GaussNewtonOptimizer> {\n+public class GaussNewtonOptimizer extends AbstractLeastSquaresOptimizer<GaussNewtonOptimizer> {\n     /** Indicator for using LU decomposition. */\n-    private final boolean useLU;\n-\n-    /**\n-     * Constructor called by the various {@code withXxx} methods.\n-     *\n-     * @param target Observations.\n-     * @param weight Weight of the observations.\n-     * For performance, no defensive copy is performed.\n-     * @param weightSqrt Square-root of the {@code weight} matrix.\n-     * If {@code null}, it will be computed; otherwise it is the caller's\n-     * responsibility that {@code weight} and {@code weightSqrt} are\n-     * consistent.\n-     * No defensive copy is performed.\n-     * @param model ModelFunction.\n-     * @param jacobian Jacobian of the model function.\n-     * @param checker Convergence checker.\n-     * @param start Initial guess.\n-     * @param maxEval Maximum number of evaluations of the model\n-     * function.\n-     * @param maxIter Maximum number of iterations.\n-     * @param useLU Whether to use LU decomposition.\n-     */\n-    private GaussNewtonOptimizer(double[] target,\n-                                 RealMatrix weight,\n-                                 RealMatrix weightSqrt,\n-                                 MultivariateVectorFunction model,\n-                                 MultivariateMatrixFunction jacobian,\n-                                 ConvergenceChecker<PointVectorValuePair> checker,\n-                                 double[] start,\n-                                 int maxEval,\n-                                 int maxIter,\n-                                 boolean useLU) {\n-        super(target, weight, weightSqrt, model, jacobian, checker, start, maxEval, maxIter);\n-\n-        this.useLU = useLU;\n-    }\n+    private boolean useLU = true;\n \n     /**\n      * Creates a bare-bones instance.\n      * @return an instance of this class.\n      */\n     public static GaussNewtonOptimizer create() {\n-        return new GaussNewtonOptimizer(null, null, null, null, null, null, null,\n-                                        0, 0, true);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public GaussNewtonOptimizer withTarget(double[] target) {\n-        return new GaussNewtonOptimizer(target,\n-                                        getWeightInternal(),\n-                                        getWeightSquareRootInternal(),\n-                                        getModel(),\n-                                        getJacobian(),\n-                                        getConvergenceChecker(),\n-                                        getStart(),\n-                                        getMaxEvaluations(),\n-                                        getMaxIterations(),\n-                                        useLU);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public GaussNewtonOptimizer withWeight(RealMatrix weight) {\n-        return new GaussNewtonOptimizer(getTargetInternal(),\n-                                        weight,\n-                                        null,\n-                                        getModel(),\n-                                        getJacobian(),\n-                                        getConvergenceChecker(),\n-                                        getStart(),\n-                                        getMaxEvaluations(),\n-                                        getMaxIterations(),\n-                                        useLU);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public GaussNewtonOptimizer withModelAndJacobian(MultivariateVectorFunction model,\n-                                                     MultivariateMatrixFunction jacobian) {\n-        return new GaussNewtonOptimizer(getTargetInternal(),\n-                                        getWeightInternal(),\n-                                        getWeightSquareRootInternal(),\n-                                        model,\n-                                        jacobian,\n-                                        getConvergenceChecker(),\n-                                        getStart(),\n-                                        getMaxEvaluations(),\n-                                        getMaxIterations(),\n-                                        useLU);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public GaussNewtonOptimizer withConvergenceChecker(ConvergenceChecker<PointVectorValuePair> checker) {\n-        return new GaussNewtonOptimizer(getTarget(),\n-                                        getWeightInternal(),\n-                                        getWeightSquareRootInternal(),\n-                                        getModel(),\n-                                        getJacobian(),\n-                                        checker,\n-                                        getStart(),\n-                                        getMaxEvaluations(),\n-                                        getMaxIterations(),\n-                                        useLU);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public GaussNewtonOptimizer withStartPoint(double[] start) {\n-        return new GaussNewtonOptimizer(getTarget(),\n-                                        getWeightInternal(),\n-                                        getWeightSquareRootInternal(),\n-                                        getModel(),\n-                                        getJacobian(),\n-                                        getConvergenceChecker(),\n-                                        start,\n-                                        getMaxEvaluations(),\n-                                        getMaxIterations(),\n-                                        useLU);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public GaussNewtonOptimizer withMaxIterations(int maxIter) {\n-        return new GaussNewtonOptimizer(getTarget(),\n-                                        getWeightInternal(),\n-                                        getWeightSquareRootInternal(),\n-                                        getModel(),\n-                                        getJacobian(),\n-                                        getConvergenceChecker(),\n-                                        getStart(),\n-                                        getMaxEvaluations(),\n-                                        maxIter,\n-                                        useLU);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public GaussNewtonOptimizer withMaxEvaluations(int maxEval) {\n-        return new GaussNewtonOptimizer(getTarget(),\n-                                        getWeightInternal(),\n-                                        getWeightSquareRootInternal(),\n-                                        getModel(),\n-                                        getJacobian(),\n-                                        getConvergenceChecker(),\n-                                        getStart(),\n-                                        maxEval,\n-                                        getMaxIterations(),\n-                                        useLU);\n+        return new GaussNewtonOptimizer();\n     }\n \n     /**\n-     * Creates a new instance.\n-     *\n-     * @param withLU Whether to use LU decomposition.\n-     * @return a new instance with all fields identical to this instance except\n-     * for the givens arguments.\n+     * @param useLU Whether to use LU decomposition.\n+     * @return this instance.\n      */\n-    public GaussNewtonOptimizer withLU(boolean withLU) {\n-        return new GaussNewtonOptimizer(getTarget(),\n-                                        getWeightInternal(),\n-                                        getWeightSquareRootInternal(),\n-                                        getModel(),\n-                                        getJacobian(),\n-                                        getConvergenceChecker(),\n-                                        getStart(),\n-                                        getMaxEvaluations(),\n-                                        getMaxIterations(),\n-                                        withLU);\n+    public GaussNewtonOptimizer withLU(boolean useLU) {\n+        this.useLU = useLU;\n+        return self();\n     }\n \n     /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/math3/fitting/leastsquares/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/fitting/leastsquares/LevenbergMarquardtOptimizer.java\n package org.apache.commons.math3.fitting.leastsquares;\n \n import java.util.Arrays;\n-import org.apache.commons.math3.analysis.MultivariateVectorFunction;\n-import org.apache.commons.math3.analysis.MultivariateMatrixFunction;\n import org.apache.commons.math3.linear.RealMatrix;\n import org.apache.commons.math3.exception.ConvergenceException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n  * @version $Id$\n  * @since 2.0\n  */\n-public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer\n-    implements WithTarget<LevenbergMarquardtOptimizer>,\n-               WithWeight<LevenbergMarquardtOptimizer>,\n-               WithModelAndJacobian<LevenbergMarquardtOptimizer>,\n-               WithConvergenceChecker<LevenbergMarquardtOptimizer>,\n-               WithStartPoint<LevenbergMarquardtOptimizer>,\n-               WithMaxIterations<LevenbergMarquardtOptimizer>,\n-               WithMaxEvaluations<LevenbergMarquardtOptimizer> {\n+public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer<LevenbergMarquardtOptimizer> {\n     /** Twice the \"epsilon machine\". */\n     private static final double TWO_EPS = 2 * Precision.EPSILON;\n     /** Positive input variable used in determining the initial step bound. */\n-    private final double initialStepBoundFactor;\n+    private double initialStepBoundFactor = 100;\n     /** Desired relative error in the sum of squares. */\n-    private final double costRelativeTolerance;\n+    private double costRelativeTolerance = 1e-10;\n     /**  Desired relative error in the approximate solution parameters. */\n-    private final double parRelativeTolerance;\n+    private double parRelativeTolerance = 1e-10;\n     /** Desired max cosine on the orthogonality between the function vector\n      * and the columns of the jacobian. */\n-    private final double orthoTolerance;\n+    private double orthoTolerance = 1e-10;\n     /** Threshold for QR ranking. */\n-    private final double qrRankingThreshold;\n+    private double qrRankingThreshold = Precision.SAFE_MIN;\n     /** Levenberg-Marquardt parameter. */\n     private double lmPar;\n     /** Parameters evolution direction associated with lmPar. */\n     private double[] lmDir;\n-\n-    /**\n-     * Constructor called by the various {@code withXxx} methods.\n-     *\n-     * @param target Observations.\n-     * @param weight Weight of the observations.\n-     * For performance, no defensive copy is performed.\n-     * @param weightSqrt Square-root of the {@code weight} matrix.\n-     * If {@code null}, it will be computed; otherwise it is the caller's\n-     * responsibility that {@code weight} and {@code weightSqrt} are\n-     * consistent.\n-     * No defensive copy is performed.\n-     * @param model ModelFunction.\n-     * @param jacobian Jacobian of the model function.\n-     * @param checker Convergence checker.\n-     * @param start Initial guess.\n-     * @param maxEval Maximum number of evaluations of the model\n-     * function.\n-     * @param maxIter Maximum number of iterations.\n-     * @param initialStepBoundFactor Positive input variable used in\n-     * determining the initial step bound. This bound is set to the\n-     * product of initialStepBoundFactor and the euclidean norm of\n-     * {@code diag * x} if non-zero, or else to {@code initialStepBoundFactor}\n-     * itself. In most cases factor should lie in the interval\n-     * {@code (0.1, 100.0)}. {@code 100} is a generally recommended value.\n-     * @param costRelativeTolerance Desired relative error in the sum of\n-     * squares.\n-     * @param parRelativeTolerance Desired relative error in the approximate\n-     * solution parameters.\n-     * @param orthoTolerance Desired max cosine on the orthogonality between\n-     * the function vector and the columns of the Jacobian.\n-     * @param threshold Desired threshold for QR ranking. If the squared norm\n-     * of a column vector is smaller or equal to this threshold during QR\n-     * decomposition, it is considered to be a zero vector and hence the rank\n-     * of the matrix is reduced.\n-     */\n-    private LevenbergMarquardtOptimizer(double[] target,\n-                                        RealMatrix weight,\n-                                        RealMatrix weightSqrt,\n-                                        MultivariateVectorFunction model,\n-                                        MultivariateMatrixFunction jacobian,\n-                                        ConvergenceChecker<PointVectorValuePair> checker,\n-                                        double[] start,\n-                                        int maxEval,\n-                                        int maxIter,\n-                                        double initialStepBoundFactor,\n-                                        double costRelativeTolerance,\n-                                        double parRelativeTolerance,\n-                                        double orthoTolerance,\n-                                        double threshold) {\n-        super(target, weight, weightSqrt, model, jacobian, checker, start, maxEval, maxIter);\n-\n-        this.initialStepBoundFactor = initialStepBoundFactor;\n-        this.costRelativeTolerance = costRelativeTolerance;\n-        this.parRelativeTolerance = parRelativeTolerance;\n-        this.orthoTolerance = orthoTolerance;\n-        this.qrRankingThreshold = threshold;\n-    }\n \n     /**\n      * Creates a bare-bones instance.\n      * @return an instance of this class.\n      */\n     public static LevenbergMarquardtOptimizer create() {\n-        return new LevenbergMarquardtOptimizer(null, null, null, null, null, null, null,\n-                                               0, 0, 100, 1e-10, 1e-10, 1e-10,\n-                                               Precision.SAFE_MIN);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public LevenbergMarquardtOptimizer withTarget(double[] target) {\n-        return new LevenbergMarquardtOptimizer(target,\n-                                               getWeightInternal(),\n-                                               getWeightSquareRootInternal(),\n-                                               getModel(),\n-                                               getJacobian(),\n-                                               getConvergenceChecker(),\n-                                               getStart(),\n-                                               getMaxEvaluations(),\n-                                               getMaxIterations(),\n-                                               initialStepBoundFactor,\n-                                               costRelativeTolerance,\n-                                               parRelativeTolerance,\n-                                               orthoTolerance,\n-                                               qrRankingThreshold);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public LevenbergMarquardtOptimizer withWeight(RealMatrix weight) {\n-        return new LevenbergMarquardtOptimizer(getTargetInternal(),\n-                                               weight,\n-                                               null,\n-                                               getModel(),\n-                                               getJacobian(),\n-                                               getConvergenceChecker(),\n-                                               getStart(),\n-                                               getMaxEvaluations(),\n-                                               getMaxIterations(),\n-                                               initialStepBoundFactor,\n-                                               costRelativeTolerance,\n-                                               parRelativeTolerance,\n-                                               orthoTolerance,\n-                                               qrRankingThreshold);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public LevenbergMarquardtOptimizer withModelAndJacobian(MultivariateVectorFunction model,\n-                                                            MultivariateMatrixFunction jacobian) {\n-        return new LevenbergMarquardtOptimizer(getTargetInternal(),\n-                                               getWeightInternal(),\n-                                               getWeightSquareRootInternal(),\n-                                               model,\n-                                               jacobian,\n-                                               getConvergenceChecker(),\n-                                               getStart(),\n-                                               getMaxEvaluations(),\n-                                               getMaxIterations(),\n-                                               initialStepBoundFactor,\n-                                               costRelativeTolerance,\n-                                               parRelativeTolerance,\n-                                               orthoTolerance,\n-                                               qrRankingThreshold);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public LevenbergMarquardtOptimizer withConvergenceChecker(ConvergenceChecker<PointVectorValuePair> checker) {\n-        return new LevenbergMarquardtOptimizer(getTarget(),\n-                                               getWeightInternal(),\n-                                               getWeightSquareRootInternal(),\n-                                               getModel(),\n-                                               getJacobian(),\n-                                               checker,\n-                                               getStart(),\n-                                               getMaxEvaluations(),\n-                                               getMaxIterations(),\n-                                               initialStepBoundFactor,\n-                                               costRelativeTolerance,\n-                                               parRelativeTolerance,\n-                                               orthoTolerance,\n-                                               qrRankingThreshold);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public LevenbergMarquardtOptimizer withStartPoint(double[] start) {\n-        return new LevenbergMarquardtOptimizer(getTarget(),\n-                                               getWeightInternal(),\n-                                               getWeightSquareRootInternal(),\n-                                               getModel(),\n-                                               getJacobian(),\n-                                               getConvergenceChecker(),\n-                                               start,\n-                                               getMaxEvaluations(),\n-                                               getMaxIterations(),\n-                                               initialStepBoundFactor,\n-                                               costRelativeTolerance,\n-                                               parRelativeTolerance,\n-                                               orthoTolerance,\n-                                               qrRankingThreshold);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public LevenbergMarquardtOptimizer withMaxIterations(int maxIter) {\n-        return new LevenbergMarquardtOptimizer(getTarget(),\n-                                               getWeightInternal(),\n-                                               getWeightSquareRootInternal(),\n-                                               getModel(),\n-                                               getJacobian(),\n-                                               getConvergenceChecker(),\n-                                               getStart(),\n-                                               getMaxEvaluations(),\n-                                               maxIter,\n-                                               initialStepBoundFactor,\n-                                               costRelativeTolerance,\n-                                               parRelativeTolerance,\n-                                               orthoTolerance,\n-                                               qrRankingThreshold);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public LevenbergMarquardtOptimizer withMaxEvaluations(int maxEval) {\n-        return new LevenbergMarquardtOptimizer(getTarget(),\n-                                               getWeightInternal(),\n-                                               getWeightSquareRootInternal(),\n-                                               getModel(),\n-                                               getJacobian(),\n-                                               getConvergenceChecker(),\n-                                               getStart(),\n-                                               maxEval,\n-                                               getMaxIterations(),\n-                                               initialStepBoundFactor,\n-                                               costRelativeTolerance,\n-                                               parRelativeTolerance,\n-                                               orthoTolerance,\n-                                               qrRankingThreshold);\n-    }\n-\n-    /**\n-     * Creates a new instance.\n-     *\n-     * @param initStepBoundFactor Positive input variable used in\n+        return new LevenbergMarquardtOptimizer();\n+    }\n+\n+    /**\n+     * @param initialStepBoundFactor Positive input variable used in\n      * determining the initial step bound. This bound is set to the\n      * product of initialStepBoundFactor and the euclidean norm of\n      * {@code diag * x} if non-zero, or else to {@code initialStepBoundFactor}\n      * itself. In most cases factor should lie in the interval\n      * {@code (0.1, 100.0)}. {@code 100} is a generally recommended value.\n-     * @param costRelTol Desired relative error in the sum of squares.\n-     * @param parRelTol Desired relative error in the approximate solution\n+     * of the matrix is reduced.\n+     * @return this instance.\n+     */\n+    public LevenbergMarquardtOptimizer withInitialStepBoundFactor(double initialStepBoundFactor) {\n+        this.initialStepBoundFactor = initialStepBoundFactor;\n+        return self();\n+    }\n+\n+    /**\n+     * @param costRelativeTolerance Desired relative error in the sum of squares.\n+     * @return this instance.\n+     */\n+    public LevenbergMarquardtOptimizer withCostRelativeTolerance(double costRelativeTolerance) {\n+        this.costRelativeTolerance = costRelativeTolerance;\n+        return self();\n+    }\n+\n+    /**\n+     * @param parameterRelativeTolerance Desired relative error in the approximate solution\n      * parameters.\n-     * @param orthoTol Desired max cosine on the orthogonality between\n+     * @return this instance.\n+     */\n+    public LevenbergMarquardtOptimizer withParameterRelativeTolerance(double parameterRelativeTolerance) {\n+        this.parRelativeTolerance = parameterRelativeTolerance;\n+        return self();\n+    }\n+\n+    /**\n+     * @param orthoTolerance Desired max cosine on the orthogonality between\n      * the function vector and the columns of the Jacobian.\n-     * @param threshold Desired threshold for QR ranking. If the squared norm\n-     * of a column vector is smaller or equal to this threshold during QR\n-     * decomposition, it is considered to be a zero vector and hence the rank\n-     * of the matrix is reduced.\n-     * @return a new instance with all fields identical to this instance except\n-     * for the givens arguments.\n-     */\n-    public LevenbergMarquardtOptimizer withTuningParameters(double initStepBoundFactor,\n-                                                            double costRelTol,\n-                                                            double parRelTol,\n-                                                            double orthoTol,\n-                                                            double threshold) {\n-        return new LevenbergMarquardtOptimizer(getTarget(),\n-                                               getWeightInternal(),\n-                                               getWeightSquareRootInternal(),\n-                                               getModel(),\n-                                               getJacobian(),\n-                                               getConvergenceChecker(),\n-                                               getStart(),\n-                                               getMaxEvaluations(),\n-                                               getMaxIterations(),\n-                                               initStepBoundFactor,\n-                                               costRelTol,\n-                                               parRelTol,\n-                                               orthoTol,\n-                                               threshold);\n+     * @return this instance.\n+     */\n+    public LevenbergMarquardtOptimizer withOrthoTolerance(double orthoTolerance) {\n+        this.orthoTolerance = orthoTolerance;\n+        return self();\n+    }\n+\n+    /**\n+     * @param rankingThreshold Desired threshold for QR ranking.\n+     * If the squared norm of a column vector is smaller or equal to this\n+     * threshold during QR decomposition, it is considered to be a zero vector\n+     * and hence the rank of the matrix is reduced.\n+     * @return this instance.\n+     */\n+    public LevenbergMarquardtOptimizer withRankingThreshold(double rankingThreshold) {\n+        this.qrRankingThreshold = rankingThreshold;\n+        return self();\n     }\n \n     /**\n      * Gets the value of a tuning parameter.\n-     * @see #withTuningParameters(double,double,double,double,double)\n+     * @see #withInitialStepBoundFactor(double)\n      *\n      * @return the parameter's value.\n      */\n \n     /**\n      * Gets the value of a tuning parameter.\n-     * @see #withTuningParameters(double,double,double,double,double)\n+     * @see #withCostRelativeTolerance(double)\n      *\n      * @return the parameter's value.\n      */\n \n     /**\n      * Gets the value of a tuning parameter.\n-     * @see #withTuningParameters(double,double,double,double,double)\n+     * @see #withParameterRelativeTolerance(double)\n      *\n      * @return the parameter's value.\n      */\n-    public double getParRelativeTolerance() {\n+    public double getParameterRelativeTolerance() {\n         return parRelativeTolerance;\n     }\n \n     /**\n      * Gets the value of a tuning parameter.\n-     * @see #withTuningParameters(double,double,double,double,double)\n+     * @see #withOrthoTolerance(double)\n      *\n      * @return the parameter's value.\n      */\n \n     /**\n      * Gets the value of a tuning parameter.\n-     * @see #withTuningParameters(double,double,double,double,double)\n+     * @see #withRankingThreshold(double)\n      *\n      * @return the parameter's value.\n      */\n--- a/src/main/java/org/apache/commons/math3/fitting/leastsquares/WithConvergenceChecker.java\n+++ b/src/main/java/org/apache/commons/math3/fitting/leastsquares/WithConvergenceChecker.java\n package org.apache.commons.math3.fitting.leastsquares;\n \n import org.apache.commons.math3.optim.ConvergenceChecker;\n-import org.apache.commons.math3.optim.PointVectorValuePair;\n \n /**\n  * Interface for \"fluent-API\" that advertizes a capability of the optimizer.\n  *\n  * @param <T> Concrete optimizer implementation.\n+ * @param <PAIR> Parametric type for the {@link ConvergenceChecker}.\n  *\n  * @version $Id$\n  * @since 3.3\n  */\n-public interface WithConvergenceChecker<T> {\n+public interface WithConvergenceChecker<PAIR, T> {\n     /**\n      * Creates a new instance with the specified parameter.\n      *\n      * @return a new optimizer instance with all fields identical to this\n      * instance except for the given argument.\n      */\n-    T withConvergenceChecker(ConvergenceChecker<PointVectorValuePair> checker);\n+    T withConvergenceChecker(ConvergenceChecker<PAIR> checker);\n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/optim/AbstractOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.optim;\n+\n+import org.apache.commons.math3.util.Incrementor;\n+import org.apache.commons.math3.exception.TooManyEvaluationsException;\n+import org.apache.commons.math3.exception.TooManyIterationsException;\n+import org.apache.commons.math3.fitting.leastsquares.WithMaxEvaluations;\n+import org.apache.commons.math3.fitting.leastsquares.WithMaxIterations;\n+import org.apache.commons.math3.fitting.leastsquares.WithConvergenceChecker;\n+\n+/**\n+ * Base class for implementing optimizers.\n+ * It contains the boiler-plate code for counting the number of evaluations\n+ * of the objective function and the number of iterations of the algorithm,\n+ * and storing the convergence checker.\n+ *\n+ * @param <PAIR> Type of the point/value pair returned by the optimization\n+ * algorithm.\n+ * @param <OPTIM> Type of a subclass of this class.\n+ * This parameter allows to implement fluent API methods at upper levels\n+ * of the class hierarchy (since the fluent API requires that the actual\n+ * type of the subclass is returned).\n+ *\n+ * @version $Id$\n+ * @since 3.3\n+ */\n+public abstract class AbstractOptimizer<PAIR, OPTIM extends AbstractOptimizer<PAIR, OPTIM>>\n+    implements WithMaxEvaluations<OPTIM>,\n+               WithMaxIterations<OPTIM>,\n+               WithConvergenceChecker<PAIR, OPTIM> {\n+    /** Evaluations counter. */\n+    private Incrementor evaluations = new Incrementor(Integer.MAX_VALUE, new MaxEvalCallback());\n+    /** Iterations counter. */\n+    private Incrementor iterations = new Incrementor(Integer.MAX_VALUE, new MaxIterCallback());\n+    /** Convergence checker. */\n+    private ConvergenceChecker<PAIR> checker = null;\n+\n+    /**\n+     * Default constructor.\n+     */\n+    protected AbstractOptimizer() {}\n+\n+    /**\n+     * Copy constructor.\n+     *\n+     * @param other Instance to copy.\n+     */\n+    protected AbstractOptimizer(AbstractOptimizer other) {\n+        checker = other.checker; // XXX Not thread-safe.\n+        evaluations.setMaximalCount(other.getMaxEvaluations());\n+        iterations.setMaximalCount(other.getMaxIterations());\n+    }\n+\n+    /**\n+     * Returns this instance, cast to the type of its actual subclass.\n+     *\n+     * @return the \"self-type\" instance.\n+     */\n+    protected OPTIM self() {\n+        final OPTIM optim = (OPTIM) this;\n+        return optim;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OPTIM withConvergenceChecker(ConvergenceChecker<PAIR> checker) {\n+        this.checker = checker;\n+        return self();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OPTIM withMaxEvaluations(int max) {\n+        evaluations.setMaximalCount(max);\n+        return self();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OPTIM withMaxIterations(int max) {\n+        iterations.setMaximalCount(max);\n+        return self();\n+    }\n+\n+    /**\n+     * Gets the maximal number of function evaluations.\n+     *\n+     * @return the maximal number of function evaluations.\n+     */\n+    public int getMaxEvaluations() {\n+        return evaluations.getMaximalCount();\n+    }\n+\n+    /**\n+     * Gets the number of evaluations of the objective function.\n+     * The number of evaluations corresponds to the last call to the\n+     * {@code optimize} method. It is 0 if the method has not been\n+     * called yet.\n+     *\n+     * @return the number of evaluations of the objective function.\n+     */\n+    public int getEvaluations() {\n+        return evaluations.getCount();\n+    }\n+\n+    /**\n+     * Gets the maximal number of iterations.\n+     *\n+     * @return the maximal number of iterations.\n+     */\n+    public int getMaxIterations() {\n+        return iterations.getMaximalCount();\n+    }\n+\n+    /**\n+     * Gets the number of iterations performed by the algorithm.\n+     * The number iterations corresponds to the last call to the\n+     * {@code optimize} method. It is 0 if the method has not been\n+     * called yet.\n+     *\n+     * @return the number of evaluations of the objective function.\n+     */\n+    public int getIterations() {\n+        return iterations.getCount();\n+    }\n+\n+    /**\n+     * Gets the convergence checker.\n+     *\n+     * @return the object used to check for convergence.\n+     */\n+    public ConvergenceChecker<PAIR> getConvergenceChecker() {\n+        return checker;\n+    }\n+\n+    /**\n+     * Performs the optimization.\n+     *\n+     * @return a point/value pair that satifies the convergence criteria.\n+     * @throws TooManyEvaluationsException if the maximal number of\n+     * evaluations is exceeded.\n+     * @throws TooManyIterationsException if the maximal number of\n+     * iterations is exceeded.\n+     */\n+    public PAIR optimize()\n+        throws TooManyEvaluationsException,\n+               TooManyIterationsException {\n+        // Reset counters.\n+        evaluations.resetCount();\n+        iterations.resetCount();\n+        // Perform optimization.\n+        return doOptimize();\n+    }\n+\n+    /**\n+     * Performs the bulk of the optimization algorithm.\n+     *\n+     * @return the point/value pair giving the optimal value of the\n+     * objective function.\n+     */\n+    protected abstract PAIR doOptimize();\n+\n+    /**\n+     * Increment the evaluation count.\n+     *\n+     * @throws TooManyEvaluationsException if the allowed evaluations\n+     * have been exhausted.\n+     */\n+    protected void incrementEvaluationCount()\n+        throws TooManyEvaluationsException {\n+        evaluations.incrementCount();\n+    }\n+\n+    /**\n+     * Increment the iteration count.\n+     *\n+     * @throws TooManyIterationsException if the allowed iterations\n+     * have been exhausted.\n+     */\n+    protected void incrementIterationCount()\n+        throws TooManyIterationsException {\n+        iterations.incrementCount();\n+    }\n+\n+    /**\n+     * Defines the action to perform when reaching the maximum number\n+     * of evaluations.\n+     */\n+    private static class MaxEvalCallback\n+        implements  Incrementor.MaxCountExceededCallback {\n+        /**\n+         * {@inheritDoc}\n+         * @throws TooManyEvaluationsException\n+         */\n+        public void trigger(int max) {\n+            throw new TooManyEvaluationsException(max);\n+        }\n+    }\n+\n+    /**\n+     * Defines the action to perform when reaching the maximum number\n+     * of evaluations.\n+     */\n+    private static class MaxIterCallback\n+        implements Incrementor.MaxCountExceededCallback {\n+        /**\n+         * {@inheritDoc}\n+         * @throws TooManyIterationsException\n+         */\n+        public void trigger(int max) {\n+            throw new TooManyIterationsException(max);\n+        }\n+    }\n+}\n--- a/src/test/java/org/apache/commons/math3/fitting/leastsquares/AbstractLeastSquaresOptimizerAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math3/fitting/leastsquares/AbstractLeastSquaresOptimizerAbstractTest.java\n  *\n  * @version $Id$\n  */\n-public abstract class AbstractLeastSquaresOptimizerAbstractTest<T extends AbstractLeastSquaresOptimizer &\n-                                                                          WithTarget<T> &\n-                                                                          WithWeight<T> &\n-                                                                          WithModelAndJacobian<T> &\n-                                                                          WithConvergenceChecker<T> &\n-                                                                          WithStartPoint<T> &\n-                                                                          WithMaxIterations<T> &\n-                                                                          WithMaxEvaluations<T>> {\n+public abstract class AbstractLeastSquaresOptimizerAbstractTest<T extends AbstractLeastSquaresOptimizer<T>> {\n     /**\n      * @return a concrete optimizer.\n      */\n--- a/src/test/java/org/apache/commons/math3/fitting/leastsquares/LevenbergMarquardtOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math3/fitting/leastsquares/LevenbergMarquardtOptimizerTest.java\n                                double orthoTolerance, boolean shouldFail) {\n         try {\n             final LevenbergMarquardtOptimizer optimizer = LevenbergMarquardtOptimizer.create()\n-                .withTuningParameters(initialStepBoundFactor,\n-                                      costRelativeTolerance,\n-                                      parRelativeTolerance,\n-                                      orthoTolerance,\n-                                      Precision.SAFE_MIN)\n+                .withInitialStepBoundFactor(initialStepBoundFactor)\n+                .withCostRelativeTolerance(costRelativeTolerance)\n+                .withParameterRelativeTolerance(parRelativeTolerance)\n+                .withOrthoTolerance(orthoTolerance)\n+                .withRankingThreshold(Precision.SAFE_MIN)\n                 .withMaxEvaluations(maxCostEval)\n                 .withMaxIterations(100)\n                 .withModelAndJacobian(problem, problemJacobian)\n--- a/src/test/java/org/apache/commons/math3/fitting/leastsquares/MinpackTest.java\n+++ b/src/test/java/org/apache/commons/math3/fitting/leastsquares/MinpackTest.java\n \n     private void minpackTest(MinpackFunction function, boolean exceptionExpected) {\n         final double tol = 2.22044604926e-16;\n+        final double sqrtTol = FastMath.sqrt(tol);\n         LevenbergMarquardtOptimizer optimizer = LevenbergMarquardtOptimizer.create();\n         optimizer = optimizer\n-            .withTuningParameters(optimizer.getInitialStepBoundFactor(),\n-                                  FastMath.sqrt(tol),\n-                                  FastMath.sqrt(tol),\n-                                  tol,\n-                                  optimizer.getRankingThreshold())\n+            .withInitialStepBoundFactor(optimizer.getInitialStepBoundFactor())\n+            .withCostRelativeTolerance(sqrtTol)\n+            .withParameterRelativeTolerance(sqrtTol)\n+            .withOrthoTolerance(tol)\n+            .withRankingThreshold(optimizer.getRankingThreshold())\n             .withMaxEvaluations(400 * (function.getN() + 1))\n             .withMaxIterations(2000)\n             .withModelAndJacobian(function.getModelFunction(),", "timestamp": 1376090474, "metainfo": ""}