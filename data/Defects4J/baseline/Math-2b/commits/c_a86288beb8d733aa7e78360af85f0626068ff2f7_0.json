{"sha": "a86288beb8d733aa7e78360af85f0626068ff2f7", "log": "MATH-997 Gauss-Hermite quadrature scheme.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/analysis/integration/gauss/GaussIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/integration/gauss/GaussIntegrator.java\n     public int getNumberOfPoints() {\n         return points.length;\n     }\n+\n+    /**\n+     * Gets the integration point at the given index.\n+     * The index must be in the valid range but no check is performed.\n+     *\n+     * @return the integration point.\n+     */\n+    public double getPoint(int index) {\n+        return points[index];\n+    }\n+\n+    /**\n+     * Gets the weight of the integration point at the given index.\n+     * The index must be in the valid range but no check is performed.\n+     *\n+     * @return the weight.\n+     */\n+    public double getWeight(int index) {\n+        return weights[index];\n+    }\n }\n--- a/src/main/java/org/apache/commons/math3/analysis/integration/gauss/GaussIntegratorFactory.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/integration/gauss/GaussIntegratorFactory.java\n \n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math3.analysis.BivariateFunction;\n import org.apache.commons.math3.util.Pair;\n+import org.apache.commons.math3.util.FastMath;\n \n /**\n  * Class that provides different ways to compute the nodes and weights to be\n     private final BaseRuleFactory<Double> legendre = new LegendreRuleFactory();\n     /** Generator of Gauss-Legendre integrators. */\n     private final BaseRuleFactory<BigDecimal> legendreHighPrecision = new LegendreHighPrecisionRuleFactory();\n+    /** Generator of Gauss-Hermite integrators. */\n+    private final BaseRuleFactory<Double> hermite = new HermiteRuleFactory();\n \n     /**\n-     * Creates an integrator of the given order, and whose call to the\n+     * Creates a Gauss-Legendre integrator of the given order.\n+     * The call to the\n      * {@link GaussIntegrator#integrate(org.apache.commons.math3.analysis.UnivariateFunction)\n      * integrate} method will perform an integration on the natural interval\n      * {@code [-1 , 1]}.\n     }\n \n     /**\n-     * Creates an integrator of the given order, and whose call to the\n+     * Creates a Gauss-Legendre integrator of the given order.\n+     * The call to the\n      * {@link GaussIntegrator#integrate(org.apache.commons.math3.analysis.UnivariateFunction)\n      * integrate} method will perform an integration on the given interval.\n      *\n     }\n \n     /**\n-     * Creates an integrator of the given order, and whose call to the\n+     * Creates a Gauss-Legendre integrator of the given order.\n+     * The call to the\n      * {@link GaussIntegrator#integrate(org.apache.commons.math3.analysis.UnivariateFunction)\n      * integrate} method will perform an integration on the natural interval\n      * {@code [-1 , 1]}.\n         throws NotStrictlyPositiveException {\n         return new GaussIntegrator(transform(getRule(legendreHighPrecision, numberOfPoints),\n                                              lowerBound, upperBound));\n+    }\n+\n+    /**\n+     * Creates a Gauss-Hermite integrator of the given order.\n+     * The call to the\n+     * {@link SymmetricGaussIntegrator#integrate(org.apache.commons.math3.analysis.UnivariateFunction)\n+     * integrate} method will perform a weighted integration on the interval\n+     * {@code [-&inf;, +&inf;]}: the computed value is the improper integral of\n+     * <code>\n+     *  e<sup>-x<sup>2</sup></sup> f(x)\n+     * </code>\n+     * where {@code f(x)} is the function passed to the\n+     * {@link SymmetricGaussIntegrator#integrate(org.apache.commons.math3.analysis.UnivariateFunction)\n+     * integrate} method.\n+     *\n+     * @param numberOfPoints Order of the integration rule.\n+     * @return a Gauss-Hermite integrator.\n+     */\n+    public SymmetricGaussIntegrator hermite(int numberOfPoints) {\n+        return new SymmetricGaussIntegrator(getRule(hermite, numberOfPoints));\n     }\n \n     /**\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/analysis/integration/gauss/HermiteRuleFactory.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.analysis.integration.gauss;\n+\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.util.Pair;\n+import org.apache.commons.math3.util.FastMath;\n+\n+/**\n+ * Factory that creates a\n+ * <a href=\"http://en.wikipedia.org/wiki/Gauss-Hermite_quadrature\">\n+ *  Gauss-type quadrature rule using Hermite polynomials</a>\n+ * of the first kind.\n+ * Such a quadrature rule allows the calculation of improper integrals\n+ * of a function\n+ * <code>\n+ *  f(x) e<sup>-x<sup>2</sup></sup>\n+ * </code>\n+ * <br/>\n+ * Recurrence relation and weights computation follow\n+ * <a href=\"http://en.wikipedia.org/wiki/Abramowitz_and_Stegun\"\n+ * Abramowitz and Stegun, 1964</a>.\n+ * <br/>\n+ * The coefficients of the standard Hermite polynomials grow very rapidly;\n+ * in order to avoid overflows, each Hermite polynomial is normalized with\n+ * respect to the underlying scalar product.\n+ * The initial interval for the application of the bisection method is\n+ * based on the roots of the previous Hermite polynomial (interlacing).\n+ * Upper and lower bounds of these roots are provided by\n+ * <quote>\n+ *  I. Krasikov,\n+ *  <em>Nonnegative quadratic forms and bounds on orthogonal polynomials</em>,\n+ *  Journal of Approximation theory <b>111</b>, 31-49\n+ * </quote>\n+ *\n+ * @since 3.3\n+ * @version $Id$\n+ */\n+public class HermiteRuleFactory extends BaseRuleFactory<Double> {\n+    /** &pi;<sup>1/2</sup> */\n+    private static final double SQRT_PI = 1.77245385090551602729;\n+    /** &pi;<sup>-1/4</sup> */\n+    private static final double H0 = 7.5112554446494248286e-1;\n+    /** &pi;<sup>-1/4</sup> &radic;2 */\n+    private static final double H1 = 1.0622519320271969145;\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n+        throws DimensionMismatchException {\n+\n+        if (numberOfPoints == 1) {\n+            // Break recursion.\n+            return new Pair<Double[], Double[]>(new Double[] { 0d },\n+                                                new Double[] { SQRT_PI });\n+        }\n+\n+        // Get previous rule.\n+        // If it has not been computed yet it will trigger a recursive call\n+        // to this method.\n+        final int lastNumPoints = numberOfPoints - 1;\n+        final Double[] previousPoints = getRuleInternal(lastNumPoints).getFirst();\n+\n+        // Compute next rule.\n+        final Double[] points = new Double[numberOfPoints];\n+        final Double[] weights = new Double[numberOfPoints];\n+\n+        final double sqrtTwoTimesLastNumPoints = FastMath.sqrt(2 * lastNumPoints);\n+        final double sqrtTwoTimesNumPoints = FastMath.sqrt(2 * numberOfPoints);\n+\n+        // Find i-th root of H[n+1] by bracketing.\n+        final int iMax = numberOfPoints / 2;\n+        for (int i = 0; i < iMax; i++) {\n+            // Lower-bound of the interval.\n+            double a = (i == 0) ? -sqrtTwoTimesLastNumPoints : previousPoints[i - 1].doubleValue();\n+            // Upper-bound of the interval.\n+            double b = (iMax == 1) ? -0.5 : previousPoints[i].doubleValue();\n+\n+            // H[j-1](a)\n+            double hma = H0;\n+            // H[j](a)\n+            double ha = H1 * a;\n+            // H[j-1](b)\n+            double hmb = H0;\n+            // H[j](b)\n+            double hb = H1 * b;\n+            for (int j = 1; j < numberOfPoints; j++) {\n+                // Compute H[j+1](a) and H[j+1](b)\n+                final double jp1 = j + 1;\n+                final double s = FastMath.sqrt(2 / jp1);\n+                final double sm = FastMath.sqrt(j / jp1);\n+                final double hpa = s * a * ha - sm * hma;\n+                final double hpb = s * b * hb - sm * hmb;\n+                hma = ha;\n+                ha = hpa;\n+                hmb = hb;\n+                hb = hpb;\n+            }\n+\n+            // Now ha = H[n+1](a), and hma = H[n](a) (same holds for b).\n+            // Middle of the interval.\n+            double c = 0.5 * (a + b);\n+            // P[j-1](c)\n+            double hmc = H0;\n+            // P[j](c)\n+            double hc = H1 * c;\n+            boolean done = false;\n+            while (!done) {\n+                done = b - a <= Math.ulp(c);\n+                hmc = H0;\n+                hc = H1 * c;\n+                for (int j = 1; j < numberOfPoints; j++) {\n+                    // Compute H[j+1](c)\n+                    final double jp1 = j + 1;\n+                    final double s = FastMath.sqrt(2 / jp1);\n+                    final double sm = FastMath.sqrt(j / jp1);\n+                    final double hpc = s * c * hc - sm * hmc;\n+                    hmc = hc;\n+                    hc = hpc;\n+                }\n+                // Now h = H[n+1](c) and hm = H[n](c).\n+                if (!done) {\n+                    if (ha * hc < 0) {\n+                        b = c;\n+                        hmb = hmc;\n+                        hb = hc;\n+                    } else {\n+                        a = c;\n+                        hma = hmc;\n+                        ha = hc;\n+                    }\n+                    c = 0.5 * (a + b);\n+                }\n+            }\n+            final double d = sqrtTwoTimesNumPoints * hmc;\n+            final double w = 2 / (d * d);\n+\n+            points[i] = c;\n+            weights[i] = w;\n+\n+            final int idx = lastNumPoints - i;\n+            points[idx] = -c;\n+            weights[idx] = w;\n+        }\n+\n+        // If \"numberOfPoints\" is odd, 0 is a root.\n+        // Note: as written, the test for oddness will work for negative\n+        // integers too (although it is not necessary here), preventing\n+        // a FindBugs warning.\n+        if (numberOfPoints % 2 != 0) {\n+            double hm = H0;\n+            for (int j = 1; j < numberOfPoints; j += 2) {\n+                final double jp1 = j + 1;\n+                hm = -FastMath.sqrt(j / jp1) * hm;\n+            }\n+            final double d = sqrtTwoTimesNumPoints * hm;\n+            final double w = 2 / (d * d);\n+\n+            points[iMax] = 0d;\n+            weights[iMax] = w;\n+        }\n+\n+        return new Pair<Double[], Double[]>(points, weights);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/analysis/integration/gauss/SymmetricGaussIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.analysis.integration.gauss;\n+\n+import org.apache.commons.math3.analysis.UnivariateFunction;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.NonMonotonicSequenceException;\n+import org.apache.commons.math3.util.MathArrays;\n+import org.apache.commons.math3.util.Pair;\n+\n+/**\n+ * This class's implements {@link #integrate(UnivariateFunction) integrate}\n+ * method assuming that the integral is symmetric about 0.\n+ * This allows to reduce numerical errors.\n+ *\n+ * @since 3.3\n+ * @version $Id$\n+ */\n+public class SymmetricGaussIntegrator extends GaussIntegrator {\n+    /**\n+     * Creates an integrator from the given {@code points} and {@code weights}.\n+     * The integration interval is defined by the first and last value of\n+     * {@code points} which must be sorted in increasing order.\n+     *\n+     * @param points Integration points.\n+     * @param weights Weights of the corresponding integration nodes.\n+     * @throws NonMonotonicSequenceException if the {@code points} are not\n+     * sorted in increasing order.\n+     * @throws DimensionMismatchException if points and weights don't have the same length\n+     */\n+    public SymmetricGaussIntegrator(double[] points,\n+                                    double[] weights)\n+        throws NonMonotonicSequenceException, DimensionMismatchException {\n+        super(points, weights);\n+    }\n+\n+    /**\n+     * Creates an integrator from the given pair of points (first element of\n+     * the pair) and weights (second element of the pair.\n+     *\n+     * @param pointsAndWeights Integration points and corresponding weights.\n+     * @throws NonMonotonicSequenceException if the {@code points} are not\n+     * sorted in increasing order.\n+     *\n+     * @see #SymmetricGaussIntegrator(double[], double[])\n+     */\n+    public SymmetricGaussIntegrator(Pair<double[], double[]> pointsAndWeights)\n+        throws NonMonotonicSequenceException {\n+        this(pointsAndWeights.getFirst(), pointsAndWeights.getSecond());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double integrate(UnivariateFunction f) {\n+        final int ruleLength = getNumberOfPoints();\n+\n+        if (ruleLength == 1) {\n+            return getWeight(0) * f.value(0d);\n+        }\n+\n+        final int iMax = ruleLength / 2;\n+        double s = 0;\n+        double c = 0;\n+        for (int i = 0; i < iMax; i++) {\n+            final double p = getPoint(i);\n+            final double w = getWeight(i);\n+\n+            final double f1 = f.value(p);\n+            final double f2 = f.value(-p);\n+\n+            final double y = w * (f1 + f2) - c;\n+            final double t = s + y;\n+\n+            c = (t - s) - y;\n+            s = t;\n+        }\n+\n+        if (ruleLength % 2 == 1) {\n+            final double w = getWeight(iMax);\n+\n+            final double y = w * f.value(0d) - c;\n+            final double t = s + y;\n+\n+            c = (t - s) - y;\n+            s = t;\n+        }\n+\n+        return s;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/analysis/integration/gauss/GaussIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.analysis.integration.gauss;\n+\n+import org.apache.commons.math3.analysis.UnivariateFunction;\n+import org.apache.commons.math3.analysis.function.Constant;\n+import org.apache.commons.math3.util.Pair;\n+import org.junit.Test;\n+import org.junit.Assert;\n+\n+/**\n+ * Test for {@link GaussIntegrator} class.\n+ *\n+ * @version $Id$\n+ */\n+public class GaussIntegratorTest {\n+    @Test\n+    public void testGetWeights() {\n+        final double[] points = { 0, 1.2, 3.4 };\n+        final double[] weights = { 9.8, 7.6, 5.4 };\n+\n+        final GaussIntegrator integrator\n+            = new GaussIntegrator(new Pair<double[], double[]>(points, weights));\n+\n+        Assert.assertEquals(weights.length, integrator.getNumberOfPoints());\n+\n+        for (int i = 0; i < integrator.getNumberOfPoints(); i++) {\n+            Assert.assertEquals(weights[i], integrator.getWeight(i), 0d);\n+        }\n+    }\n+\n+    @Test\n+    public void testGetPoints() {\n+        final double[] points = { 0, 1.2, 3.4 };\n+        final double[] weights = { 9.8, 7.6, 5.4 };\n+\n+        final GaussIntegrator integrator\n+            = new GaussIntegrator(new Pair<double[], double[]>(points, weights));\n+\n+        Assert.assertEquals(points.length, integrator.getNumberOfPoints());\n+\n+        for (int i = 0; i < integrator.getNumberOfPoints(); i++) {\n+            Assert.assertEquals(points[i], integrator.getPoint(i), 0d);\n+        }\n+    }\n+\n+    @Test\n+    public void testIntegrate() {\n+        final double[] points = { 0, 1, 2, 3, 4, 5 };\n+        final double[] weights = { 1, 1, 1, 1, 1, 1 };\n+\n+        final GaussIntegrator integrator\n+            = new GaussIntegrator(new Pair<double[], double[]>(points, weights));\n+\n+        final double val = 123.456;\n+        final UnivariateFunction c = new Constant(val);\n+\n+        final double s = integrator.integrate(c);\n+        Assert.assertEquals(points.length * val, s, 0d);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/analysis/integration/gauss/HermiteParametricTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.analysis.integration.gauss;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+import org.apache.commons.math3.util.FastMath;\n+\n+/**\n+ * Test of the {@link HermiteRuleFactory}.\n+ * This parameterized test extends the standard test for Gaussian quadrature\n+ * rule, where each monomial is tested in turn.\n+ * Parametrization allows to test automatically 0, 1, ... , {@link #MAX_NUM_POINTS}\n+ * quadrature rules.\n+ *\n+ * @version $Id$\n+ */\n+@RunWith(value=Parameterized.class)\n+public class HermiteParametricTest extends GaussianQuadratureAbstractTest {\n+    private static final double SQRT_PI = FastMath.sqrt(Math.PI);\n+    private static final GaussIntegratorFactory factory = new GaussIntegratorFactory();\n+\n+    /**\n+     * The highest order quadrature rule to be tested.\n+     */\n+    public static final int MAX_NUM_POINTS = 30;\n+\n+    /**\n+     * Creates a new instance of this test, with the specified number of nodes\n+     * for the Gauss-Hermite quadrature rule.\n+     *\n+     * @param numberOfPoints Order of integration rule.\n+     * @param maxDegree Maximum degree of monomials to be tested.\n+     * @param eps Value of &epsilon;.\n+     * @param numUlps Value of the maximum relative error (in ulps).\n+     */\n+    public HermiteParametricTest(int numberOfPoints,\n+                                 int maxDegree,\n+                                 double eps,\n+                                 double numUlps) {\n+        super(factory.hermite(numberOfPoints),\n+              maxDegree, eps, numUlps);\n+    }\n+\n+    /**\n+     * Returns the collection of parameters to be passed to the constructor of\n+     * this class.\n+     * Gauss-Hermite quadrature rules of order 1, ..., {@link #MAX_NUM_POINTS}\n+     * will be constructed.\n+     *\n+     * @return the collection of parameters for this parameterized test.\n+     */\n+    @Parameters\n+    public static Collection<Object[]> getParameters() {\n+        final ArrayList<Object[]> parameters = new ArrayList<Object[]>();\n+        for (int k = 1; k <= MAX_NUM_POINTS; k++) {\n+            parameters.add(new Object[] { k, 2 * k - 1, Math.ulp(1d), 195 });\n+        }\n+        return parameters;\n+    }\n+\n+    @Override\n+    public double getExpectedValue(final int n) {\n+        if (n % 2 == 1) {\n+            return 0;\n+        }\n+\n+        final int iMax = n / 2;\n+        double p = 1;\n+        double q = 1;\n+        for (int i = 0; i < iMax; i++) {\n+            p *= 2 * i + 1;\n+            q *= 2;\n+        }\n+\n+        return p / q * SQRT_PI;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/analysis/integration/gauss/HermiteTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.analysis.integration.gauss;\n+\n+import org.apache.commons.math3.analysis.UnivariateFunction;\n+import org.apache.commons.math3.analysis.function.Gaussian;\n+import org.apache.commons.math3.distribution.RealDistribution;\n+import org.apache.commons.math3.distribution.NormalDistribution;\n+import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.Pair;\n+import org.junit.Test;\n+import org.junit.Assert;\n+\n+/**\n+ * Test of the {@link HermiteRuleFactory}.\n+ *\n+ * @version $Id$\n+ */\n+public class HermiteTest {\n+    private static final GaussIntegratorFactory factory = new GaussIntegratorFactory();\n+\n+    @Test\n+    public void testNormalDistribution() {\n+        final double oneOverSqrtPi = 1 / FastMath.sqrt(Math.PI);\n+\n+        final double mu = 12345.6789;\n+        final double sigma = 987.654321;\n+        // By defintion, Gauss-Hermite quadrature readily provides the\n+        // integral of the normal distribution density.\n+        final int numPoints = 1;\n+\n+        // Change of variable:\n+        //   y = (x - mu) / (sqrt(2) *  sigma)\n+        // such that the integrand\n+        //   N(x, mu, sigma)\n+        // is transformed to\n+        //   f(y) * exp(-y^2)\n+        final UnivariateFunction f = new UnivariateFunction() {\n+                @Override\n+                public double value(double y) {\n+                    return oneOverSqrtPi; // Constant function.\n+                }\n+            };\n+\n+        final GaussIntegrator integrator = factory.hermite(numPoints);\n+        final double result = integrator.integrate(f);\n+        final double expected = 1;\n+        Assert.assertEquals(expected, result, Math.ulp(expected));\n+    }\n+\n+    @Test\n+    public void testNormalMean() {\n+        final double sqrtTwo = FastMath.sqrt(2);\n+        final double oneOverSqrtPi = 1 / FastMath.sqrt(Math.PI);\n+\n+        final double mu = 12345.6789;\n+        final double sigma = 987.654321;\n+        final int numPoints = 5;\n+\n+        // Change of variable:\n+        //   y = (x - mu) / (sqrt(2) *  sigma)\n+        // such that the integrand\n+        //   x * N(x, mu, sigma)\n+        // is transformed to\n+        //   f(y) * exp(-y^2)\n+        final UnivariateFunction f = new UnivariateFunction() {\n+                @Override\n+                public double value(double y) {\n+                    return oneOverSqrtPi * (sqrtTwo * sigma * y + mu);\n+                }\n+            };\n+\n+        final GaussIntegrator integrator = factory.hermite(numPoints);\n+        final double result = integrator.integrate(f);\n+        final double expected = mu;\n+        Assert.assertEquals(expected, result, Math.ulp(expected));\n+    }\n+\n+    @Test\n+    public void testNormalVariance() {\n+        final double twoOverSqrtPi = 2 / FastMath.sqrt(Math.PI);\n+\n+        final double mu = 12345.6789;\n+        final double sigma = 987.654321;\n+        final double sigma2 = sigma * sigma;\n+        final int numPoints = 5;\n+\n+        // Change of variable:\n+        //   y = (x - mu) / (sqrt(2) *  sigma)\n+        // such that the integrand\n+        //   (x - mu)^2 * N(x, mu, sigma)\n+        // is transformed to\n+        //   f(y) * exp(-y^2)\n+        final UnivariateFunction f = new UnivariateFunction() {\n+                @Override\n+                public double value(double y) {\n+                    return twoOverSqrtPi * sigma2 * y * y;\n+                }\n+            };\n+\n+        final GaussIntegrator integrator = factory.hermite(numPoints);\n+        final double result = integrator.integrate(f);\n+        final double expected = sigma2;\n+        Assert.assertEquals(expected, result, 10 * Math.ulp(expected));\n+    }\n+}", "timestamp": 1373034019, "metainfo": ""}