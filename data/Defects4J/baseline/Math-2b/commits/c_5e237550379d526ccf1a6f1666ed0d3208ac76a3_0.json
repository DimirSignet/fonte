{"sha": "5e237550379d526ccf1a6f1666ed0d3208ac76a3", "log": "[MATH-898] Finish FuzzyKMeans clustering algorithm.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/ml/clustering/FuzzyKMeansClusterer.java\n+++ b/src/main/java/org/apache/commons/math3/ml/clustering/FuzzyKMeansClusterer.java\n import java.util.List;\n \n import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.MathIllegalStateException;\n import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.linear.MatrixUtils;\n import org.apache.commons.math3.linear.RealMatrix;\n import org.apache.commons.math3.util.MathUtils;\n \n /**\n- * Fuzzy K-Means algorithm.\n+ * Fuzzy K-Means clustering algorithm.\n  * <p>\n- * TODO\n+ * The Fuzzy K-Means algorithm is a variation of the classical K-Means algorithm, with the\n+ * major difference that a single data point is not uniquely assigned to a single cluster.\n+ * Instead, each point i has a set of weights u<sub>ij</sub> which indicate the degree of membership\n+ * to the cluster j.\n+ * <p>\n+ * The algorithm then tries to minimize the objective function:\n+ * <pre>\n+ * J = &#8721;<sub>i=1..C</sub>&#8721;<sub>k=1..N</sub> u<sub>ik</sub><sup>m</sup>d<sub>ik</sub><sup>2</sup>\n+ * </pre>\n+ * with d<sub>ik</sub> being the distance between data point i and the cluster center k.\n  * <p>\n  * The algorithm requires two parameters:\n  * <ul>\n- * <li>k: the number of clusters\n- * <li>fuzzyness: ...\n+ *   <li>k: the number of clusters\n+ *   <li>fuzziness: determines the level of cluster fuzziness, larger values lead to fuzzier clusters\n  * </ul>\n+ * Additional, optional parameters:\n+ * <ul>\n+ *   <li>maxIterations: the maximum number of iterations\n+ *   <li>epsilon: the convergence criteria, default is 1e-3\n+ * </ul>\n+ * <p>\n+ * The fuzzy variant of the K-Means algorithm is more robust with regard to the selection\n+ * of the initial cluster centers.\n  *\n  * @param <T> type of the points to cluster\n  * @version $Id$\n     /** The maximum number of iterations. */\n     private final int maxIterations;\n \n-    /** The fuzzyness factor. */\n-    private final double fuzzyness;\n+    /** The fuzziness factor. */\n+    private final double fuzziness;\n \n     /** The convergence criteria. */\n     private final double epsilon;\n      * The euclidean distance will be used as default distance measure.\n      *\n      * @param k the number of clusters to split the data into\n-     * @param fuzzyness the fuzzyness factor, must be &gt; 1.0\n-     * @throws NumberIsTooSmallException if {@code fuzzyness <= 1.0}\n-     */\n-    public FuzzyKMeansClusterer(final int k, final double fuzzyness) throws NumberIsTooSmallException {\n-        this(k, fuzzyness, -1, new EuclideanDistance());\n+     * @param fuzziness the fuzziness factor, must be &gt; 1.0\n+     * @throws NumberIsTooSmallException if {@code fuzziness <= 1.0}\n+     */\n+    public FuzzyKMeansClusterer(final int k, final double fuzziness) throws NumberIsTooSmallException {\n+        this(k, fuzziness, -1, new EuclideanDistance());\n     }\n \n     /**\n      * Creates a new instance of a FuzzyKMeansClusterer.\n      *\n      * @param k the number of clusters to split the data into\n-     * @param fuzzyness the fuzzyness factor, must be &gt; 1.0\n+     * @param fuzziness the fuzziness factor, must be &gt; 1.0\n      * @param maxIterations the maximum number of iterations to run the algorithm for.\n      *   If negative, no maximum will be used.\n      * @param measure the distance measure to use\n-     * @throws NumberIsTooSmallException if {@code fuzzyness <= 1.0}\n-     */\n-    public FuzzyKMeansClusterer(final int k, final double fuzzyness,\n+     * @throws NumberIsTooSmallException if {@code fuzziness <= 1.0}\n+     */\n+    public FuzzyKMeansClusterer(final int k, final double fuzziness,\n                                 final int maxIterations, final DistanceMeasure measure)\n             throws NumberIsTooSmallException {\n-        this(k, fuzzyness, maxIterations, measure, DEFAULT_EPSILON, new JDKRandomGenerator());\n+        this(k, fuzziness, maxIterations, measure, DEFAULT_EPSILON, new JDKRandomGenerator());\n     }\n \n     /**\n      * Creates a new instance of a FuzzyKMeansClusterer.\n      *\n      * @param k the number of clusters to split the data into\n-     * @param fuzzyness the fuzzyness factor, must be &gt; 1.0\n+     * @param fuzziness the fuzziness factor, must be &gt; 1.0\n      * @param maxIterations the maximum number of iterations to run the algorithm for.\n      *   If negative, no maximum will be used.\n      * @param measure the distance measure to use\n-     * @param epsilon the convergence criteria\n+     * @param epsilon the convergence criteria (default is 1e-3)\n      * @param random random generator to use for choosing initial centers\n-     * @throws NumberIsTooSmallException if {@code fuzzyness <= 1.0}\n-     */\n-    public FuzzyKMeansClusterer(final int k, final double fuzzyness,\n+     * @throws NumberIsTooSmallException if {@code fuzziness <= 1.0}\n+     */\n+    public FuzzyKMeansClusterer(final int k, final double fuzziness,\n                                 final int maxIterations, final DistanceMeasure measure,\n                                 final double epsilon, final RandomGenerator random)\n             throws NumberIsTooSmallException {\n \n         super(measure);\n \n-        if (fuzzyness <= 1.0d) {\n-            throw new NumberIsTooSmallException(fuzzyness, 1.0, false);\n+        if (fuzziness <= 1.0d) {\n+            throw new NumberIsTooSmallException(fuzziness, 1.0, false);\n         }\n         this.k = k;\n-        this.fuzzyness = fuzzyness;\n+        this.fuzziness = fuzziness;\n         this.maxIterations = maxIterations;\n         this.epsilon = epsilon;\n         this.random = random;\n     }\n \n     /**\n-     * Returns the fuzzyness factor used by this instance.\n-     * @return the fuzzyness factor\n-     */\n-    public double getFuzzyness() {\n-        return fuzzyness;\n+     * Returns the fuzziness factor used by this instance.\n+     * @return the fuzziness factor\n+     */\n+    public double getFuzziness() {\n+        return fuzziness;\n     }\n \n     /**\n      */\n     public int getMaxIterations() {\n         return maxIterations;\n+    }\n+\n+    /**\n+     * Returns the convergence criteria used by this instance.\n+     * @return the convergence criteria\n+     */\n+    public double getEpsilon() {\n+        return epsilon;\n     }\n \n     /**\n      * to cluster {@code j}.\n      *\n      * @return the membership matrix\n+     * @throws MathIllegalStateException if {@link #cluster(Collection)} has not been called before\n      */\n     public RealMatrix getMembershipMatrix() {\n+        if (membershipMatrix == null) {\n+            throw new MathIllegalStateException();\n+        }\n         return MatrixUtils.createRealMatrix(membershipMatrix);\n     }\n \n \n     /**\n      * Get the value of the objective function.\n-     * @return the objective function as double value, or {@code 0.0} if {@link #cluster(Collection)}\n-     *   has not been called before.\n+     * @return the objective function evaluation as double value\n+     * @throws MathIllegalStateException if {@link #cluster(Collection)} has not been called before\n      */\n     public double getObjectiveFunctionValue() {\n         if (points == null || clusters == null) {\n-            return 0;\n+            throw new MathIllegalStateException();\n         }\n \n         int i = 0;\n         for (final T point : points) {\n             int j = 0;\n             for (final CentroidCluster<T> cluster : clusters) {\n-                double dist = distance(point, cluster.getCenter());\n-                objFunction += (dist * dist) * FastMath.pow(membershipMatrix[i][j], fuzzyness);\n+                final double dist = distance(point, cluster.getCenter());\n+                objFunction += (dist * dist) * FastMath.pow(membershipMatrix[i][j], fuzziness);\n                 j++;\n             }\n             i++;\n             double[] arr = new double[center.getPoint().length];\n             double sum = 0.0;\n             for (final T point : points) {\n-                final double u = FastMath.pow(membershipMatrix[i][j], fuzzyness);\n+                final double u = FastMath.pow(membershipMatrix[i][j], fuzziness);\n                 final double[] pointArr = point.getPoint();\n                 for (int idx = 0; idx < arr.length; idx++) {\n                     arr[idx] += u * pointArr[idx];\n \n                 for (final CentroidCluster<T> c : clusters) {\n                     final double distB = FastMath.abs(distance(point, c.getCenter()));\n-                    sum += FastMath.pow(distA / distB, 2.0 / (fuzzyness - 1.0));\n+                    sum += FastMath.pow(distA / distB, 2.0 / (fuzziness - 1.0));\n                 }\n \n                 membershipMatrix[i][j] = 1.0 / sum;\n--- a/src/test/java/org/apache/commons/math3/ml/clustering/FuzzyKMeansClustererTest.java\n+++ b/src/test/java/org/apache/commons/math3/ml/clustering/FuzzyKMeansClustererTest.java\n  */\n package org.apache.commons.math3.ml.clustering;\n \n+import static org.hamcrest.CoreMatchers.*;\n+import static org.junit.Assert.*;\n+\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.List;\n \n import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.exception.NullArgumentException;\n-import org.junit.Assert;\n+import org.apache.commons.math3.ml.distance.CanberraDistance;\n+import org.apache.commons.math3.ml.distance.DistanceMeasure;\n+import org.apache.commons.math3.random.JDKRandomGenerator;\n+import org.apache.commons.math3.random.RandomGenerator;\n import org.junit.Test;\n \n public class FuzzyKMeansClustererTest {\n         boolean cluster1Found = false;\n         boolean cluster2Found = false;\n         boolean cluster3Found = false;\n-        Assert.assertEquals(3, clusters.size());\n+        assertEquals(3, clusters.size());\n         for (final Cluster<DoublePoint> cluster : clusters) {\n             if (cluster.getPoints().containsAll(clusterOne)) {\n                 cluster1Found = true;\n                 cluster3Found = true;\n             }\n         }\n-        Assert.assertTrue(cluster1Found);\n-        Assert.assertTrue(cluster2Found);\n-        Assert.assertTrue(cluster3Found);\n+        assertTrue(cluster1Found);\n+        assertTrue(cluster2Found);\n+        assertTrue(cluster3Found);\n     }\n \n     @Test(expected = MathIllegalArgumentException.class)\n         FuzzyKMeansClusterer<DoublePoint> clusterer = new FuzzyKMeansClusterer<DoublePoint>(3, 2.0);\n         clusterer.cluster(null);\n     }\n+    \n+    @Test\n+    public void testGetters() {\n+        DistanceMeasure measure = new CanberraDistance();\n+        RandomGenerator random = new JDKRandomGenerator();\n+        FuzzyKMeansClusterer<DoublePoint> clusterer =\n+                new FuzzyKMeansClusterer<DoublePoint>(3, 2.0, 100, measure, 1e-6, random);\n+        \n+        assertEquals(3, clusterer.getK());\n+        assertEquals(2.0, clusterer.getFuzziness(), 1e-6);\n+        assertEquals(100, clusterer.getMaxIterations());\n+        assertEquals(1e-6, clusterer.getEpsilon(), 1e-12);\n+        assertThat(clusterer.getDistanceMeasure(), is(measure));\n+        assertThat(clusterer.getRandomGenerator(), is(random));\n+    }\n \n }", "timestamp": 1365955758, "metainfo": ""}