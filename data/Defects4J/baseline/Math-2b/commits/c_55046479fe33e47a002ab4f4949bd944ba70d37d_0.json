{"sha": "55046479fe33e47a002ab4f4949bd944ba70d37d", "log": "Check bounds in multi-start vector optimizers.  JIRA: MATH-914  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/optim/BaseMultiStartMultivariateOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/BaseMultiStartMultivariateOptimizer.java\n \n import org.apache.commons.math3.exception.MathIllegalStateException;\n import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math3.exception.TooManyEvaluationsException;\n import org.apache.commons.math3.random.RandomVectorGenerator;\n \n /**\n \n     /**\n      * Create a multi-start optimizer from a single-start optimizer.\n-     *\n+     * <p>\n+     * Note that if there are bounds constraints (see {@link #getLowerBound()}\n+     * and {@link #getUpperBound()}), then a simple rejection algorithm is used\n+     * at each restart. This implies that the random vector generator should have\n+     * a good probability to generate vectors in the bounded domain, otherwise the\n+     * rejection algorithm will hit the {@link #getMaxEvaluations()} count without\n+     * generating a proper restart point. Users must be take great care of the <a\n+     * href=\"http://en.wikipedia.org/wiki/Curse_of_dimensionality\">curse of dimensionality</a>.\n+     * </p>\n      * @param optimizer Single-start optimizer to wrap.\n      * @param starts Number of starts to perform. If {@code starts == 1},\n      * the {@link #optimize(OptimizationData[]) optimize} will return the\n         clear();\n \n         final int maxEval = getMaxEvaluations();\n-        final double[] min = getLowerBound(); // XXX Should be used to enforce bounds (see below).\n-        final double[] max = getUpperBound(); // XXX Should be used to enforce bounds (see below).\n+        final double[] min = getLowerBound();\n+        final double[] max = getUpperBound();\n         final double[] startPoint = getStartPoint();\n \n         // Multi-start loop.\n                 // Decrease number of allowed evaluations.\n                 optimData[maxEvalIndex] = new MaxEval(maxEval - totalEvaluations);\n                 // New start value.\n-                final double[] s = (i == 0) ?\n-                    startPoint :\n-                    generator.nextVector(); // XXX This does not enforce bounds!\n+                double[] s = null;\n+                if (i == 0) {\n+                    s = startPoint;\n+                } else {\n+                    int attempts = 0;\n+                    while (s == null) {\n+                        if (attempts++ >= getMaxEvaluations()) {\n+                            throw new TooManyEvaluationsException(getMaxEvaluations());\n+                        }\n+                        s = generator.nextVector();\n+                        for (int k = 0; s != null && k < s.length; ++k) {\n+                            if ((min != null && s[k] < min[k]) || (max != null && s[k] > max[k])) {\n+                                // reject the vector\n+                                s = null;\n+                            }\n+                        }\n+                    }\n+                }\n                 optimData[initialGuessIndex] = new InitialGuess(s);\n                 // Optimize.\n                 final PAIR result = optimizer.optimize(optimData);\n--- a/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/MultiStartMultivariateVectorOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/MultiStartMultivariateVectorOptimizerTest.java\n  */\n package org.apache.commons.math3.optim.nonlinear.vector;\n \n+import org.apache.commons.math3.analysis.MultivariateMatrixFunction;\n import org.apache.commons.math3.analysis.MultivariateVectorFunction;\n-import org.apache.commons.math3.analysis.MultivariateMatrixFunction;\n-import org.apache.commons.math3.exception.MathIllegalStateException;\n+import org.apache.commons.math3.exception.TooManyEvaluationsException;\n import org.apache.commons.math3.linear.BlockRealMatrix;\n import org.apache.commons.math3.linear.RealMatrix;\n+import org.apache.commons.math3.optim.InitialGuess;\n import org.apache.commons.math3.optim.MaxEval;\n-import org.apache.commons.math3.optim.InitialGuess;\n+import org.apache.commons.math3.optim.OptimizationData;\n import org.apache.commons.math3.optim.PointVectorValuePair;\n+import org.apache.commons.math3.optim.SimpleBounds;\n import org.apache.commons.math3.optim.SimpleVectorValueChecker;\n import org.apache.commons.math3.optim.nonlinear.vector.jacobian.GaussNewtonOptimizer;\n import org.apache.commons.math3.random.GaussianRandomGenerator;\n  * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation)\n  */\n public class MultiStartMultivariateVectorOptimizerTest {\n+\n     @Test(expected=NullPointerException.class)\n     public void testGetOptimaBeforeOptimize() {\n-        LinearProblem problem\n-            = new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n+\n         JacobianMultivariateVectorOptimizer underlyingOptimizer\n             = new GaussNewtonOptimizer(true, new SimpleVectorValueChecker(1e-6, 1e-6));\n         JDKRandomGenerator g = new JDKRandomGenerator();\n         Assert.assertEquals(100, optimizer.getMaxEvaluations());\n     }\n \n+    @Test\n+    public void testIssue914() {\n+        LinearProblem problem = new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n+        JacobianMultivariateVectorOptimizer underlyingOptimizer =\n+                new GaussNewtonOptimizer(true, new SimpleVectorValueChecker(1e-6, 1e-6)) {\n+            public PointVectorValuePair optimize(OptimizationData... optData) {\n+                // filter out simple bounds, as they are not supported\n+                // by the underlying optimizer, and we don't really care for this test\n+                OptimizationData[] filtered = optData.clone();\n+                for (int i = 0; i < filtered.length; ++i) {\n+                    if (filtered[i] instanceof SimpleBounds) {\n+                        filtered[i] = null;\n+                    }\n+                }\n+                return super.optimize(filtered);\n+            }\n+        };\n+        JDKRandomGenerator g = new JDKRandomGenerator();\n+        g.setSeed(16069223052l);\n+        RandomVectorGenerator generator =\n+                new UncorrelatedRandomVectorGenerator(1, new GaussianRandomGenerator(g));\n+        MultiStartMultivariateVectorOptimizer optimizer =\n+                new MultiStartMultivariateVectorOptimizer(underlyingOptimizer, 10, generator);\n+\n+        optimizer.optimize(new MaxEval(100),\n+                           problem.getModelFunction(),\n+                           problem.getModelFunctionJacobian(),\n+                           problem.getTarget(),\n+                           new Weight(new double[] { 1 }),\n+                           new InitialGuess(new double[] { 0 }),\n+                           new SimpleBounds(new double[] { -1.0e-10 }, new double[] {  1.0e-10 }));\n+        PointVectorValuePair[] optima = optimizer.getOptima();\n+        // only the first start should have succeeded\n+        Assert.assertEquals(1, optima.length);\n+\n+    }\n+\n     /**\n-     * Test demonstrating that the user exception is fnally thrown if none\n+     * Test demonstrating that the user exception is finally thrown if none\n      * of the runs succeed.\n      */\n     @Test(expected=TestException.class)\n                                }));\n     }\n \n-    private static class TestException extends RuntimeException {}\n+    private static class TestException extends RuntimeException {\n+\n+    private static final long serialVersionUID = 1L;}\n \n     private static class LinearProblem {\n         private final RealMatrix factors;", "timestamp": 1362850650, "metainfo": ""}