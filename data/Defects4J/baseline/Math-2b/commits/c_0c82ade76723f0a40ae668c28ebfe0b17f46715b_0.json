{"sha": "0c82ade76723f0a40ae668c28ebfe0b17f46715b", "log": "Added midpoint integration method.  Patch contributed by Oleksandr Kornieiev.  JIRA: MATH-967  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/analysis/integration/MidPointIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.analysis.integration;\n+\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.MaxCountExceededException;\n+import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math3.exception.NumberIsTooLargeException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n+import org.apache.commons.math3.exception.TooManyEvaluationsException;\n+import org.apache.commons.math3.util.FastMath;\n+\n+/**\n+ * Implements the <a href=\"http://en.wikipedia.org/wiki/Midpoint_method\">\n+ * Midpoint Rule</a> for integration of real univariate functions. For\n+ * reference, see <b>Numerical Mathematics</b>, ISBN 0387989595,\n+ * chapter 9.2.\n+ * <p>\n+ * The function should be integrable.</p>\n+ *\n+ * @version $Id$\n+ * @since 3.3\n+ */\n+public class MidPointIntegrator extends BaseAbstractUnivariateIntegrator {\n+\n+    /** Maximum number of iterations for midpoint. */\n+    public static final int MIDPOINT_MAX_ITERATIONS_COUNT = 64;\n+\n+    /** Intermediate result. */\n+    private double s;\n+\n+    /**\n+     * Build a midpoint integrator with given accuracies and iterations counts.\n+     * @param relativeAccuracy relative accuracy of the result\n+     * @param absoluteAccuracy absolute accuracy of the result\n+     * @param minimalIterationCount minimum number of iterations\n+     * @param maximalIterationCount maximum number of iterations\n+     * (must be less than or equal to {@link #MIDPOINT_MAX_ITERATIONS_COUNT}\n+     * @exception NotStrictlyPositiveException if minimal number of iterations\n+     * is not strictly positive\n+     * @exception NumberIsTooSmallException if maximal number of iterations\n+     * is lesser than or equal to the minimal number of iterations\n+     * @exception NumberIsTooLargeException if maximal number of iterations\n+     * is greater than {@link #MIDPOINT_MAX_ITERATIONS_COUNT}\n+     */\n+    public MidPointIntegrator(final double relativeAccuracy,\n+                              final double absoluteAccuracy,\n+                              final int minimalIterationCount,\n+                              final int maximalIterationCount)\n+        throws NotStrictlyPositiveException, NumberIsTooSmallException, NumberIsTooLargeException {\n+        super(relativeAccuracy, absoluteAccuracy, minimalIterationCount, maximalIterationCount);\n+        if (maximalIterationCount > MIDPOINT_MAX_ITERATIONS_COUNT) {\n+            throw new NumberIsTooLargeException(maximalIterationCount,\n+                                                MIDPOINT_MAX_ITERATIONS_COUNT, false);\n+        }\n+    }\n+\n+    /**\n+     * Build a midpoint integrator with given iteration counts.\n+     * @param minimalIterationCount minimum number of iterations\n+     * @param maximalIterationCount maximum number of iterations\n+     * (must be less than or equal to {@link #MIDPOINT_MAX_ITERATIONS_COUNT}\n+     * @exception NotStrictlyPositiveException if minimal number of iterations\n+     * is not strictly positive\n+     * @exception NumberIsTooSmallException if maximal number of iterations\n+     * is lesser than or equal to the minimal number of iterations\n+     * @exception NumberIsTooLargeException if maximal number of iterations\n+     * is greater than {@link #MIDPOINT_MAX_ITERATIONS_COUNT}\n+     */\n+    public MidPointIntegrator(final int minimalIterationCount,\n+                              final int maximalIterationCount)\n+        throws NotStrictlyPositiveException, NumberIsTooSmallException, NumberIsTooLargeException {\n+        super(minimalIterationCount, maximalIterationCount);\n+        if (maximalIterationCount > MIDPOINT_MAX_ITERATIONS_COUNT) {\n+            throw new NumberIsTooLargeException(maximalIterationCount,\n+                                                MIDPOINT_MAX_ITERATIONS_COUNT, false);\n+        }\n+    }\n+\n+    /**\n+     * Construct a midpoint integrator with default settings.\n+     * (max iteration count set to {@link #MIDPOINT_MAX_ITERATIONS_COUNT})\n+     */\n+    public MidPointIntegrator() {\n+        super(DEFAULT_MIN_ITERATIONS_COUNT, MIDPOINT_MAX_ITERATIONS_COUNT);\n+    }\n+\n+    /**\n+     * Compute the n-th stage integral of midpoint rule.\n+     * This function should only be called by API <code>integrate()</code> in the package.\n+     * To save time it does not verify arguments - caller does.\n+     * <p>\n+     * The interval is divided equally into 2^n sections rather than an\n+     * arbitrary m sections because this configuration can best utilize the\n+     * already computed values.</p>\n+     *\n+     * @param n the stage of 1/2 refinement, n = 0 is no refinement\n+     * @return the value of n-th stage integral\n+     * @throws TooManyEvaluationsException if the maximal number of evaluations\n+     * is exceeded.\n+     */\n+    private double stage(final int n)\n+        throws TooManyEvaluationsException {\n+\n+        final double max = getMax();\n+        final double min = getMin();\n+\n+        if (n == 0) {\n+            final double midPoint = 0.5 * (max - min);\n+            s = (max - min) * computeObjectiveValue(midPoint);\n+            return s;\n+        } else {\n+            final long np = 1L << (n - 1);           // number of new points in this stage\n+            double sum = 0;\n+            // spacing between adjacent new points\n+            final double spacing = (max - min) / np;\n+            double x = min + 0.5 * spacing;    // the first new point\n+            for (long i = 0; i < np; i++) {\n+                sum += computeObjectiveValue(x);\n+                x += spacing;\n+            }\n+            // add the new sum to previously calculated result\n+            s = 0.5 * (s + sum * spacing);\n+            return s;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    protected double doIntegrate()\n+        throws MathIllegalArgumentException, TooManyEvaluationsException, MaxCountExceededException {\n+\n+        double oldt = stage(0);\n+        iterations.incrementCount();\n+        while (true) {\n+            final int i = iterations.getCount();\n+            final double t = stage(i);\n+            if (i >= getMinimalIterationCount()) {\n+                final double delta = FastMath.abs(t - oldt);\n+                final double rLimit =\n+                        getRelativeAccuracy() * (FastMath.abs(oldt) + FastMath.abs(t)) * 0.5;\n+                if ((delta <= rLimit) || (delta <= getAbsoluteAccuracy())) {\n+                    return t;\n+                }\n+            }\n+            oldt = t;\n+            iterations.incrementCount();\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/analysis/integration/MidPointIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.analysis.integration;\n+\n+import org.apache.commons.math3.analysis.QuinticFunction;\n+import org.apache.commons.math3.analysis.UnivariateFunction;\n+import org.apache.commons.math3.analysis.function.Sin;\n+import org.apache.commons.math3.exception.NumberIsTooLargeException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n+import org.apache.commons.math3.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Test case for midpoint integrator.\n+ * <p>\n+ * Test runs show that for a default relative accuracy of 1E-6, it generally\n+ * takes 10 to 15 iterations for the integral to converge.\n+ *\n+ * @version $Id: MidPointIntegratorTest.java 1374632 2012-08-18 18:11:11Z luc $\n+ */\n+public final class MidPointIntegratorTest {\n+\n+    /**\n+     * Test of integrator for the sine function.\n+     */\n+    @Test\n+    public void testSinFunction() {\n+        UnivariateFunction f = new Sin();\n+        UnivariateIntegrator integrator = new MidPointIntegrator();\n+        \n+        double min = 0;\n+        double max = FastMath.PI;\n+        double expected = 2;\n+        double tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n+        double result = integrator.integrate(Integer.MAX_VALUE, f, min, max);\n+        Assert.assertTrue(integrator.getEvaluations() < Integer.MAX_VALUE / 2);\n+        Assert.assertTrue(integrator.getIterations() < MidPointIntegrator.MIDPOINT_MAX_ITERATIONS_COUNT / 2);\n+        Assert.assertEquals(expected, result, tolerance);\n+\n+        min = -FastMath.PI/3;\n+        max = 0;\n+        expected = -0.5;\n+        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(Integer.MAX_VALUE, f, min, max);\n+        Assert.assertTrue(integrator.getEvaluations() < Integer.MAX_VALUE / 2);\n+        Assert.assertTrue(integrator.getIterations() < MidPointIntegrator.MIDPOINT_MAX_ITERATIONS_COUNT / 2);\n+        Assert.assertEquals(expected, result, tolerance);\n+\n+    }\n+\n+    /**\n+     * Test of integrator for the quintic function.\n+     */\n+    @Test\n+    public void testQuinticFunction() {\n+        UnivariateFunction f = new QuinticFunction();\n+        UnivariateIntegrator integrator = new MidPointIntegrator();\n+\n+        double min = 0;\n+        double max = 1;\n+        double expected = -1.0 / 48;\n+        double tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n+        double result = integrator.integrate(Integer.MAX_VALUE, f, min, max);\n+        Assert.assertTrue(integrator.getEvaluations() < Integer.MAX_VALUE / 2);\n+        Assert.assertTrue(integrator.getIterations() < MidPointIntegrator.MIDPOINT_MAX_ITERATIONS_COUNT / 2);\n+        Assert.assertEquals(expected, result, tolerance);\n+\n+        min = 0;\n+        max = 0.5;\n+        expected = 11.0 / 768;\n+        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(Integer.MAX_VALUE, f, min, max);\n+        Assert.assertTrue(integrator.getEvaluations() < Integer.MAX_VALUE / 2);\n+        Assert.assertTrue(integrator.getIterations() < MidPointIntegrator.MIDPOINT_MAX_ITERATIONS_COUNT / 2);\n+        Assert.assertEquals(expected, result, tolerance);\n+\n+        min = -1;\n+        max = 4;\n+        expected = 2048 / 3.0 - 78 + 1.0 / 48;\n+        tolerance = FastMath.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(Integer.MAX_VALUE, f, min, max);\n+        Assert.assertTrue(integrator.getEvaluations() < Integer.MAX_VALUE / 2);\n+        Assert.assertTrue(integrator.getIterations() < MidPointIntegrator.MIDPOINT_MAX_ITERATIONS_COUNT / 2);\n+        Assert.assertEquals(expected, result, tolerance);\n+\n+    }\n+\n+    /**\n+     * Test of parameters for the integrator.\n+     */\n+    @Test\n+    public void testParameters() {\n+        UnivariateFunction f = new Sin();\n+\n+        try {\n+            // bad interval\n+            new MidPointIntegrator().integrate(1000, f, 1, -1);\n+            Assert.fail(\"Expecting NumberIsTooLargeException - bad interval\");\n+        } catch (NumberIsTooLargeException ex) {\n+            // expected\n+        }\n+        try {\n+            // bad iteration limits\n+            new MidPointIntegrator(5, 4);\n+            Assert.fail(\"Expecting NumberIsTooSmallException - bad iteration limits\");\n+        } catch (NumberIsTooSmallException ex) {\n+            // expected\n+        }\n+        try {\n+            // bad iteration limits\n+            new MidPointIntegrator(10, 99);\n+            Assert.fail(\"Expecting NumberIsTooLargeException - bad iteration limits\");\n+        } catch (NumberIsTooLargeException ex) {\n+            // expected\n+        }\n+    }\n+}", "timestamp": 1370250280, "metainfo": ""}