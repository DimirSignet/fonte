{"sha": "d361da00de98fe7d01d1d1113487ed96a7f1f9fe", "log": "Test new RandomDataGenerator class rather than deprecated RandomImpl.  ", "commit": "\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/random/RandomDataGeneratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.random;\n+\n+import java.text.DecimalFormat;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+\n+import org.apache.commons.math3.Retry;\n+import org.apache.commons.math3.RetryRunner;\n+import org.apache.commons.math3.TestUtils;\n+import org.apache.commons.math3.distribution.BetaDistribution;\n+import org.apache.commons.math3.distribution.BinomialDistribution;\n+import org.apache.commons.math3.distribution.BinomialDistributionTest;\n+import org.apache.commons.math3.distribution.CauchyDistribution;\n+import org.apache.commons.math3.distribution.ChiSquaredDistribution;\n+import org.apache.commons.math3.distribution.ExponentialDistribution;\n+import org.apache.commons.math3.distribution.FDistribution;\n+import org.apache.commons.math3.distribution.GammaDistribution;\n+import org.apache.commons.math3.distribution.HypergeometricDistribution;\n+import org.apache.commons.math3.distribution.HypergeometricDistributionTest;\n+import org.apache.commons.math3.distribution.PascalDistribution;\n+import org.apache.commons.math3.distribution.PascalDistributionTest;\n+import org.apache.commons.math3.distribution.PoissonDistribution;\n+import org.apache.commons.math3.distribution.TDistribution;\n+import org.apache.commons.math3.distribution.WeibullDistribution;\n+import org.apache.commons.math3.distribution.ZipfDistribution;\n+import org.apache.commons.math3.distribution.ZipfDistributionTest;\n+import org.apache.commons.math3.stat.Frequency;\n+import org.apache.commons.math3.stat.descriptive.SummaryStatistics;\n+import org.apache.commons.math3.stat.inference.ChiSquareTest;\n+import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+/**\n+ * Test cases for the RandomDataGenerator class.\n+ *\n+ * @version $Id$\n+ */\n+@RunWith(RetryRunner.class)\n+public class RandomDataGeneratorTest {\n+\n+    public RandomDataGeneratorTest() {\n+        randomData = new RandomDataGenerator();\n+        randomData.reSeed(1000);\n+    }\n+\n+    protected final long smallSampleSize = 1000;\n+    protected final double[] expected = { 250, 250, 250, 250 };\n+    protected final int largeSampleSize = 10000;\n+    private final String[] hex = { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\",\n+            \"a\", \"b\", \"c\", \"d\", \"e\", \"f\" };\n+    protected RandomDataGenerator randomData = null;\n+    protected final ChiSquareTest testStatistic = new ChiSquareTest();\n+\n+    @Test\n+    public void testNextIntExtremeValues() {\n+        int x = randomData.nextInt(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        int y = randomData.nextInt(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        Assert.assertFalse(x == y);\n+    }\n+\n+    @Test\n+    public void testNextLongExtremeValues() {\n+        long x = randomData.nextLong(Long.MIN_VALUE, Long.MAX_VALUE);\n+        long y = randomData.nextLong(Long.MIN_VALUE, Long.MAX_VALUE);\n+        Assert.assertFalse(x == y);\n+    }\n+    \n+    @Test\n+    public void testNextUniformExtremeValues() {\n+        double x = randomData.nextUniform(-Double.MAX_VALUE, Double.MAX_VALUE);\n+        double y = randomData.nextUniform(-Double.MAX_VALUE, Double.MAX_VALUE);\n+        Assert.assertFalse(x == y);\n+        Assert.assertFalse(Double.isNaN(x));\n+        Assert.assertFalse(Double.isNaN(y));\n+        Assert.assertFalse(Double.isInfinite(x));\n+        Assert.assertFalse(Double.isInfinite(y));\n+    }\n+    \n+    @Test\n+    public void testNextIntIAE() {\n+        try {\n+            randomData.nextInt(4, 3);\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+    @Test\n+    public void testNextIntNegativeToPositiveRange() {\n+        for (int i = 0; i < 5; i++) {\n+            checkNextIntUniform(-3, 5);\n+            checkNextIntUniform(-3, 6);\n+        }\n+    }\n+    \n+    @Test \n+    public void testNextIntNegativeRange() {\n+        for (int i = 0; i < 5; i++) {\n+            checkNextIntUniform(-7, -4);\n+            checkNextIntUniform(-15, -2);\n+        }\n+    }\n+    \n+    @Test \n+    public void testNextIntPositiveRange() {\n+        for (int i = 0; i < 5; i++) {\n+            checkNextIntUniform(0, 3);\n+            checkNextIntUniform(2, 12);\n+            checkNextIntUniform(1,2);\n+        }\n+    }\n+    \n+    \n+    private void checkNextIntUniform(int min, int max) {\n+        final Frequency freq = new Frequency();\n+        for (int i = 0; i < smallSampleSize; i++) {\n+            final int value = randomData.nextInt(min, max);\n+            Assert.assertTrue(\"nextInt range\", (value >= min) && (value <= max));\n+            freq.addValue(value);\n+        }\n+        final int len = max - min + 1;\n+        final long[] observed = new long[len];\n+        for (int i = 0; i < len; i++) {\n+            observed[i] = freq.getCount(min + i);\n+        }\n+        final double[] expected = new double[len];\n+        for (int i = 0; i < len; i++) {\n+            expected[i] = 1d / len;\n+        }\n+        \n+        TestUtils.assertChiSquareAccept(expected, observed, 0.001);\n+    }\n+\n+    @Test\n+    public void testNextLongIAE() {\n+        try {\n+            randomData.nextLong(4, 3);\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+    @Test\n+    public void testNextLongNegativeToPositiveRange() {\n+        for (int i = 0; i < 5; i++) {\n+            checkNextLongUniform(-3, 5);\n+            checkNextLongUniform(-3, 6);\n+        }\n+    }\n+    \n+    @Test \n+    public void testNextLongNegativeRange() {\n+        for (int i = 0; i < 5; i++) {\n+            checkNextLongUniform(-7, -4);\n+            checkNextLongUniform(-15, -2);\n+        }\n+    }\n+    \n+    @Test \n+    public void testNextLongPositiveRange() {\n+        for (int i = 0; i < 5; i++) {\n+            checkNextLongUniform(0, 3);\n+            checkNextLongUniform(2, 12);\n+        }\n+    }\n+    \n+    private void checkNextLongUniform(int min, int max) {\n+        final Frequency freq = new Frequency();\n+        for (int i = 0; i < smallSampleSize; i++) {\n+            final long value = randomData.nextLong(min, max);\n+            Assert.assertTrue(\"nextLong range\", (value >= min) && (value <= max));\n+            freq.addValue(value);\n+        }\n+        final int len = max - min + 1;\n+        final long[] observed = new long[len];\n+        for (int i = 0; i < len; i++) {\n+            observed[i] = freq.getCount(min + i);\n+        }\n+        final double[] expected = new double[len];\n+        for (int i = 0; i < len; i++) {\n+            expected[i] = 1d / len;\n+        }\n+        \n+        TestUtils.assertChiSquareAccept(expected, observed, 0.01);\n+    }\n+\n+    @Test\n+    public void testNextSecureLongIAE() {\n+        try {\n+            randomData.nextSecureLong(4, 3);\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+    @Test\n+    @Retry(3)\n+    public void testNextSecureLongNegativeToPositiveRange() {\n+        for (int i = 0; i < 5; i++) {\n+            checkNextSecureLongUniform(-3, 5);\n+            checkNextSecureLongUniform(-3, 6);\n+        }\n+    }\n+    \n+    @Test\n+    @Retry(3)\n+    public void testNextSecureLongNegativeRange() {\n+        for (int i = 0; i < 5; i++) {\n+            checkNextSecureLongUniform(-7, -4);\n+            checkNextSecureLongUniform(-15, -2);\n+        }\n+    }\n+    \n+    @Test\n+    @Retry(3)\n+    public void testNextSecureLongPositiveRange() {\n+        for (int i = 0; i < 5; i++) {\n+            checkNextSecureLongUniform(0, 3);\n+            checkNextSecureLongUniform(2, 12);\n+        }\n+    }\n+    \n+    private void checkNextSecureLongUniform(int min, int max) {\n+        final Frequency freq = new Frequency();\n+        for (int i = 0; i < smallSampleSize; i++) {\n+            final long value = randomData.nextSecureLong(min, max);\n+            Assert.assertTrue(\"nextLong range\", (value >= min) && (value <= max));\n+            freq.addValue(value);\n+        }\n+        final int len = max - min + 1;\n+        final long[] observed = new long[len];\n+        for (int i = 0; i < len; i++) {\n+            observed[i] = freq.getCount(min + i);\n+        }\n+        final double[] expected = new double[len];\n+        for (int i = 0; i < len; i++) {\n+            expected[i] = 1d / len;\n+        }\n+        \n+        TestUtils.assertChiSquareAccept(expected, observed, 0.0001);\n+    }\n+\n+    @Test\n+    public void testNextSecureIntIAE() {\n+        try {\n+            randomData.nextSecureInt(4, 3);\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+    @Test\n+    @Retry(3)\n+    public void testNextSecureIntNegativeToPositiveRange() {\n+        for (int i = 0; i < 5; i++) {\n+            checkNextSecureIntUniform(-3, 5);\n+            checkNextSecureIntUniform(-3, 6);\n+        }\n+    }\n+    \n+    @Test\n+    @Retry(3)\n+    public void testNextSecureIntNegativeRange() {\n+        for (int i = 0; i < 5; i++) {\n+            checkNextSecureIntUniform(-7, -4);\n+            checkNextSecureIntUniform(-15, -2);\n+        }\n+    }\n+    \n+    @Test \n+    @Retry(3)\n+    public void testNextSecureIntPositiveRange() {\n+        for (int i = 0; i < 5; i++) {\n+            checkNextSecureIntUniform(0, 3);\n+            checkNextSecureIntUniform(2, 12);\n+        }\n+    }\n+     \n+    private void checkNextSecureIntUniform(int min, int max) {\n+        final Frequency freq = new Frequency();\n+        for (int i = 0; i < smallSampleSize; i++) {\n+            final int value = randomData.nextSecureInt(min, max);\n+            Assert.assertTrue(\"nextInt range\", (value >= min) && (value <= max));\n+            freq.addValue(value);\n+        }\n+        final int len = max - min + 1;\n+        final long[] observed = new long[len];\n+        for (int i = 0; i < len; i++) {\n+            observed[i] = freq.getCount(min + i);\n+        }\n+        final double[] expected = new double[len];\n+        for (int i = 0; i < len; i++) {\n+            expected[i] = 1d / len;\n+        }\n+        \n+        TestUtils.assertChiSquareAccept(expected, observed, 0.0001);\n+    }\n+    \n+    \n+\n+    /**\n+     * Make sure that empirical distribution of random Poisson(4)'s has P(X <=\n+     * 5) close to actual cumulative Poisson probability and that nextPoisson\n+     * fails when mean is non-positive TODO: replace with statistical test,\n+     * adding test stat to TestStatistic\n+     */\n+    @Test\n+    public void testNextPoisson() {\n+        try {\n+            randomData.nextPoisson(0);\n+            Assert.fail(\"zero mean -- expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+        Frequency f = new Frequency();\n+        for (int i = 0; i < largeSampleSize; i++) {\n+            f.addValue(randomData.nextPoisson(4.0d));\n+        }\n+        long cumFreq = f.getCount(0) + f.getCount(1) + f.getCount(2)\n+                + f.getCount(3) + f.getCount(4) + f.getCount(5);\n+        long sumFreq = f.getSumFreq();\n+        double cumPct = Double.valueOf(cumFreq).doubleValue()\n+                / Double.valueOf(sumFreq).doubleValue();\n+        Assert.assertEquals(\"cum Poisson(4)\", cumPct, 0.7851, 0.2);\n+        try {\n+            randomData.nextPoisson(-1);\n+            Assert.fail(\"negative mean supplied -- MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+        try {\n+            randomData.nextPoisson(0);\n+            Assert.fail(\"0 mean supplied -- MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testNextPoissonConsistency() {\n+\n+        // Small integral means\n+        for (int i = 1; i < 100; i++) {\n+            checkNextPoissonConsistency(i);\n+        }\n+        // non-integer means\n+        for (int i = 1; i < 10; i++) {\n+            checkNextPoissonConsistency(randomData.nextUniform(1, 1000));\n+        }\n+        // large means\n+        // TODO: When MATH-282 is resolved, s/3000/10000 below\n+        for (int i = 1; i < 10; i++) {\n+            checkNextPoissonConsistency(randomData.nextUniform(1000, 3000));\n+        }\n+    }\n+\n+    /**\n+     * Verifies that nextPoisson(mean) generates an empirical distribution of values\n+     * consistent with PoissonDistributionImpl by generating 1000 values, computing a\n+     * grouped frequency distribution of the observed values and comparing this distribution\n+     * to the corresponding expected distribution computed using PoissonDistributionImpl.\n+     * Uses ChiSquare test of goodness of fit to evaluate the null hypothesis that the\n+     * distributions are the same. If the null hypothesis can be rejected with confidence\n+     * 1 - alpha, the check fails.\n+     */\n+    public void checkNextPoissonConsistency(double mean) {\n+        // Generate sample values\n+        final int sampleSize = 1000;        // Number of deviates to generate\n+        final int minExpectedCount = 7;     // Minimum size of expected bin count\n+        long maxObservedValue = 0;\n+        final double alpha = 0.001;         // Probability of false failure\n+        Frequency frequency = new Frequency();\n+        for (int i = 0; i < sampleSize; i++) {\n+            long value = randomData.nextPoisson(mean);\n+            if (value > maxObservedValue) {\n+                maxObservedValue = value;\n+            }\n+            frequency.addValue(value);\n+        }\n+\n+        /*\n+         *  Set up bins for chi-square test.\n+         *  Ensure expected counts are all at least minExpectedCount.\n+         *  Start with upper and lower tail bins.\n+         *  Lower bin = [0, lower); Upper bin = [upper, +inf).\n+         */\n+        PoissonDistribution poissonDistribution = new PoissonDistribution(mean);\n+        int lower = 1;\n+        while (poissonDistribution.cumulativeProbability(lower - 1) * sampleSize < minExpectedCount) {\n+            lower++;\n+        }\n+        int upper = (int) (5 * mean);  // Even for mean = 1, not much mass beyond 5\n+        while ((1 - poissonDistribution.cumulativeProbability(upper - 1)) * sampleSize < minExpectedCount) {\n+            upper--;\n+        }\n+\n+        // Set bin width for interior bins.  For poisson, only need to look at end bins.\n+        int binWidth = 0;\n+        boolean widthSufficient = false;\n+        double lowerBinMass = 0;\n+        double upperBinMass = 0;\n+        while (!widthSufficient) {\n+            binWidth++;\n+            lowerBinMass = poissonDistribution.cumulativeProbability(lower - 1, lower + binWidth - 1);\n+            upperBinMass = poissonDistribution.cumulativeProbability(upper - binWidth - 1, upper - 1);\n+            widthSufficient = FastMath.min(lowerBinMass, upperBinMass) * sampleSize >= minExpectedCount;\n+        }\n+\n+        /*\n+         *  Determine interior bin bounds.  Bins are\n+         *  [1, lower = binBounds[0]), [lower, binBounds[1]), [binBounds[1], binBounds[2]), ... ,\n+         *    [binBounds[binCount - 2], upper = binBounds[binCount - 1]), [upper, +inf)\n+         *\n+         */\n+        List<Integer> binBounds = new ArrayList<Integer>();\n+        binBounds.add(lower);\n+        int bound = lower + binWidth;\n+        while (bound < upper - binWidth) {\n+            binBounds.add(bound);\n+            bound += binWidth;\n+        }\n+        binBounds.add(upper); // The size of bin [binBounds[binCount - 2], upper) satisfies binWidth <= size < 2*binWidth.\n+\n+        // Compute observed and expected bin counts\n+        final int binCount = binBounds.size() + 1;\n+        long[] observed = new long[binCount];\n+        double[] expected = new double[binCount];\n+\n+        // Bottom bin\n+        observed[0] = 0;\n+        for (int i = 0; i < lower; i++) {\n+            observed[0] += frequency.getCount(i);\n+        }\n+        expected[0] = poissonDistribution.cumulativeProbability(lower - 1) * sampleSize;\n+\n+        // Top bin\n+        observed[binCount - 1] = 0;\n+        for (int i = upper; i <= maxObservedValue; i++) {\n+            observed[binCount - 1] += frequency.getCount(i);\n+        }\n+        expected[binCount - 1] = (1 - poissonDistribution.cumulativeProbability(upper - 1)) * sampleSize;\n+\n+        // Interior bins\n+        for (int i = 1; i < binCount - 1; i++) {\n+            observed[i] = 0;\n+            for (int j = binBounds.get(i - 1); j < binBounds.get(i); j++) {\n+                observed[i] += frequency.getCount(j);\n+            } // Expected count is (mass in [binBounds[i-1], binBounds[i])) * sampleSize\n+            expected[i] = (poissonDistribution.cumulativeProbability(binBounds.get(i) - 1) -\n+                poissonDistribution.cumulativeProbability(binBounds.get(i - 1) -1)) * sampleSize;\n+        }\n+\n+        // Use chisquare test to verify that generated values are poisson(mean)-distributed\n+        ChiSquareTest chiSquareTest = new ChiSquareTest();\n+            // Fail if we can reject null hypothesis that distributions are the same\n+        if (chiSquareTest.chiSquareTest(expected, observed, alpha)) {\n+            StringBuilder msgBuffer = new StringBuilder();\n+            DecimalFormat df = new DecimalFormat(\"#.##\");\n+            msgBuffer.append(\"Chisquare test failed for mean = \");\n+            msgBuffer.append(mean);\n+            msgBuffer.append(\" p-value = \");\n+            msgBuffer.append(chiSquareTest.chiSquareTest(expected, observed));\n+            msgBuffer.append(\" chisquare statistic = \");\n+            msgBuffer.append(chiSquareTest.chiSquare(expected, observed));\n+            msgBuffer.append(\". \\n\");\n+            msgBuffer.append(\"bin\\t\\texpected\\tobserved\\n\");\n+            for (int i = 0; i < expected.length; i++) {\n+                msgBuffer.append(\"[\");\n+                msgBuffer.append(i == 0 ? 1: binBounds.get(i - 1));\n+                msgBuffer.append(\",\");\n+                msgBuffer.append(i == binBounds.size() ? \"inf\": binBounds.get(i));\n+                msgBuffer.append(\")\");\n+                msgBuffer.append(\"\\t\\t\");\n+                msgBuffer.append(df.format(expected[i]));\n+                msgBuffer.append(\"\\t\\t\");\n+                msgBuffer.append(observed[i]);\n+                msgBuffer.append(\"\\n\");\n+            }\n+            msgBuffer.append(\"This test can fail randomly due to sampling error with probability \");\n+            msgBuffer.append(alpha);\n+            msgBuffer.append(\".\");\n+            Assert.fail(msgBuffer.toString());\n+        }\n+    }\n+\n+    /** test dispersion and failure modes for nextHex() */\n+    @Test\n+    public void testNextHex() {\n+        try {\n+            randomData.nextHexString(-1);\n+            Assert.fail(\"negative length supplied -- MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+        try {\n+            randomData.nextHexString(0);\n+            Assert.fail(\"zero length supplied -- MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+        String hexString = randomData.nextHexString(3);\n+        if (hexString.length() != 3) {\n+            Assert.fail(\"incorrect length for generated string\");\n+        }\n+        hexString = randomData.nextHexString(1);\n+        if (hexString.length() != 1) {\n+            Assert.fail(\"incorrect length for generated string\");\n+        }\n+        try {\n+            hexString = randomData.nextHexString(0);\n+            Assert.fail(\"zero length requested -- expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+        Frequency f = new Frequency();\n+        for (int i = 0; i < smallSampleSize; i++) {\n+            hexString = randomData.nextHexString(100);\n+            if (hexString.length() != 100) {\n+                Assert.fail(\"incorrect length for generated string\");\n+            }\n+            for (int j = 0; j < hexString.length(); j++) {\n+                f.addValue(hexString.substring(j, j + 1));\n+            }\n+        }\n+        double[] expected = new double[16];\n+        long[] observed = new long[16];\n+        for (int i = 0; i < 16; i++) {\n+            expected[i] = (double) smallSampleSize * 100 / 16;\n+            observed[i] = f.getCount(hex[i]);\n+        }\n+        TestUtils.assertChiSquareAccept(expected, observed, 0.001);\n+    }\n+\n+    /** test dispersion and failure modes for nextHex() */\n+    @Test\n+    @Retry(3)\n+    public void testNextSecureHex() {\n+        try {\n+            randomData.nextSecureHexString(-1);\n+            Assert.fail(\"negative length -- MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+        try {\n+            randomData.nextSecureHexString(0);\n+            Assert.fail(\"zero length -- MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+        String hexString = randomData.nextSecureHexString(3);\n+        if (hexString.length() != 3) {\n+            Assert.fail(\"incorrect length for generated string\");\n+        }\n+        hexString = randomData.nextSecureHexString(1);\n+        if (hexString.length() != 1) {\n+            Assert.fail(\"incorrect length for generated string\");\n+        }\n+        try {\n+            hexString = randomData.nextSecureHexString(0);\n+            Assert.fail(\"zero length requested -- expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+        Frequency f = new Frequency();\n+        for (int i = 0; i < smallSampleSize; i++) {\n+            hexString = randomData.nextSecureHexString(100);\n+            if (hexString.length() != 100) {\n+                Assert.fail(\"incorrect length for generated string\");\n+            }\n+            for (int j = 0; j < hexString.length(); j++) {\n+                f.addValue(hexString.substring(j, j + 1));\n+            }\n+        }\n+        double[] expected = new double[16];\n+        long[] observed = new long[16];\n+        for (int i = 0; i < 16; i++) {\n+            expected[i] = (double) smallSampleSize * 100 / 16;\n+            observed[i] = f.getCount(hex[i]);\n+        }\n+        TestUtils.assertChiSquareAccept(expected, observed, 0.001);\n+    }\n+\n+    @Test\n+    public void testNextUniformIAE() {\n+        try {\n+            randomData.nextUniform(4, 3);\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+        try {\n+            randomData.nextUniform(0, Double.POSITIVE_INFINITY);\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+        try {\n+            randomData.nextUniform(Double.NEGATIVE_INFINITY, 0);\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+        try {\n+            randomData.nextUniform(0, Double.NaN);\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+        try {\n+            randomData.nextUniform(Double.NaN, 0);\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+    @Test\n+    public void testNextUniformUniformPositiveBounds() {\n+        for (int i = 0; i < 5; i++) {\n+            checkNextUniformUniform(0, 10);\n+        }\n+    }\n+    \n+    @Test\n+    public void testNextUniformUniformNegativeToPositiveBounds() {\n+        for (int i = 0; i < 5; i++) {\n+            checkNextUniformUniform(-3, 5);\n+        }\n+    }\n+    \n+    @Test\n+    public void testNextUniformUniformNegaiveBounds() {\n+        for (int i = 0; i < 5; i++) {\n+            checkNextUniformUniform(-7, -3);\n+        }\n+    }\n+    \n+    @Test\n+    public void testNextUniformUniformMaximalInterval() {\n+        for (int i = 0; i < 5; i++) {\n+            checkNextUniformUniform(-Double.MAX_VALUE, Double.MAX_VALUE);\n+        }\n+    }\n+    \n+    private void checkNextUniformUniform(double min, double max) {\n+        // Set up bin bounds - min, binBound[0], ..., binBound[binCount-2], max\n+        final int binCount = 5;\n+        final double binSize = max / binCount - min/binCount; // Prevent overflow in extreme value case\n+        final double[] binBounds = new double[binCount - 1];\n+        binBounds[0] = min + binSize;\n+        for (int i = 1; i < binCount - 1; i++) {\n+            binBounds[i] = binBounds[i - 1] + binSize;  // + instead of * to avoid overflow in extreme case\n+        }\n+        \n+        final Frequency freq = new Frequency();\n+        for (int i = 0; i < smallSampleSize; i++) {\n+            final double value = randomData.nextUniform(min, max);\n+            Assert.assertTrue(\"nextUniform range\", (value > min) && (value < max));\n+            // Find bin\n+            int j = 0;\n+            while (j < binCount - 1 && value > binBounds[j]) {\n+                j++;\n+            }\n+            freq.addValue(j);\n+        }\n+       \n+        final long[] observed = new long[binCount];\n+        for (int i = 0; i < binCount; i++) {\n+            observed[i] = freq.getCount(i);\n+        }\n+        final double[] expected = new double[binCount];\n+        for (int i = 0; i < binCount; i++) {\n+            expected[i] = 1d / binCount;\n+        }\n+        \n+        TestUtils.assertChiSquareAccept(expected, observed, 0.01);\n+    }\n+\n+    /** test exclusive endpoints of nextUniform **/\n+    @Test\n+    public void testNextUniformExclusiveEndpoints() {\n+        for (int i = 0; i < 1000; i++) {\n+            double u = randomData.nextUniform(0.99, 1);\n+            Assert.assertTrue(u > 0.99 && u < 1);\n+        }\n+    }\n+\n+    /** test failure modes and distribution of nextGaussian() */\n+    @Test\n+    public void testNextGaussian() {\n+        try {\n+            randomData.nextGaussian(0, 0);\n+            Assert.fail(\"zero sigma -- MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+        SummaryStatistics u = new SummaryStatistics();\n+        for (int i = 0; i < largeSampleSize; i++) {\n+            u.addValue(randomData.nextGaussian(0, 1));\n+        }\n+        double xbar = u.getMean();\n+        double s = u.getStandardDeviation();\n+        double n = u.getN();\n+        /*\n+         * t-test at .001-level TODO: replace with externalized t-test, with\n+         * test statistic defined in TestStatistic\n+         */\n+        Assert.assertTrue(FastMath.abs(xbar) / (s / FastMath.sqrt(n)) < 3.29);\n+    }\n+\n+    /** test failure modes and distribution of nextExponential() */\n+    @Test\n+    public void testNextExponential() {\n+        try {\n+            randomData.nextExponential(-1);\n+            Assert.fail(\"negative mean -- expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+        try {\n+            randomData.nextExponential(0);\n+            Assert.fail(\"zero mean -- expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+        long cumFreq = 0;\n+        double v = 0;\n+        for (int i = 0; i < largeSampleSize; i++) {\n+            v = randomData.nextExponential(1);\n+            Assert.assertTrue(\"exponential deviate postive\", v > 0);\n+            if (v < 2)\n+                cumFreq++;\n+        }\n+        /*\n+         * TODO: Replace with a statistical test, with statistic added to\n+         * TestStatistic. Check below compares observed cumulative distribution\n+         * evaluated at 2 with exponential CDF\n+         */\n+        Assert.assertEquals(\"exponential cumulative distribution\", (double) cumFreq\n+                / (double) largeSampleSize, 0.8646647167633873, .2);\n+\n+        /**\n+         * Proposal on improving the test of generating exponentials\n+         */\n+        double[] quartiles;\n+        long[] counts;\n+\n+        // Mean 1\n+        quartiles = TestUtils.getDistributionQuartiles(new ExponentialDistribution(1));\n+        counts = new long[4];\n+        randomData.reSeed(1000);\n+        for (int i = 0; i < 1000; i++) {\n+            double value = randomData.nextExponential(1);\n+            TestUtils.updateCounts(value, counts, quartiles);\n+        }\n+        TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n+\n+        // Mean 5\n+        quartiles = TestUtils.getDistributionQuartiles(new ExponentialDistribution(5));\n+        counts = new long[4];\n+        randomData.reSeed(1000);\n+        for (int i = 0; i < 1000; i++) {\n+            double value = randomData.nextExponential(5);\n+            TestUtils.updateCounts(value, counts, quartiles);\n+        }\n+        TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n+    }\n+\n+    /** test reseeding, algorithm/provider games */\n+    @Test\n+    public void testConfig() {\n+        randomData.reSeed(1000);\n+        double v = randomData.nextUniform(0, 1);\n+        randomData.reSeed();\n+        Assert.assertTrue(\"different seeds\", Math\n+                .abs(v - randomData.nextUniform(0, 1)) > 10E-12);\n+        randomData.reSeed(1000);\n+        Assert.assertEquals(\"same seeds\", v, randomData.nextUniform(0, 1), 10E-12);\n+        randomData.reSeedSecure(1000);\n+        String hex = randomData.nextSecureHexString(40);\n+        randomData.reSeedSecure();\n+        Assert.assertTrue(\"different seeds\", !hex.equals(randomData\n+                .nextSecureHexString(40)));\n+        randomData.reSeedSecure(1000);\n+        Assert.assertTrue(\"same seeds\", !hex\n+                .equals(randomData.nextSecureHexString(40)));\n+\n+        /*\n+         * remove this test back soon, since it takes about 4 seconds\n+         *\n+         * try { randomData.setSecureAlgorithm(\"SHA1PRNG\",\"SUN\"); } catch\n+         * (NoSuchProviderException ex) { ; } Assert.assertTrue(\"different seeds\",\n+         * !hex.equals(randomData.nextSecureHexString(40))); try {\n+         * randomData.setSecureAlgorithm(\"NOSUCHTHING\",\"SUN\");\n+         * Assert.fail(\"expecting NoSuchAlgorithmException\"); } catch\n+         * (NoSuchProviderException ex) { ; } catch (NoSuchAlgorithmException\n+         * ex) { ; }\n+         *\n+         * try { randomData.setSecureAlgorithm(\"SHA1PRNG\",\"NOSUCHPROVIDER\");\n+         * Assert.fail(\"expecting NoSuchProviderException\"); } catch\n+         * (NoSuchProviderException ex) { ; }\n+         */\n+\n+        // test reseeding without first using the generators\n+        RandomDataGenerator rd = new RandomDataGenerator();\n+        rd.reSeed(100);\n+        rd.nextLong(1, 2);\n+        RandomDataGenerator rd2 = new RandomDataGenerator();\n+        rd2.reSeedSecure(2000);\n+        rd2.nextSecureLong(1, 2);\n+        rd = new RandomDataGenerator();\n+        rd.reSeed();\n+        rd.nextLong(1, 2);\n+        rd2 = new RandomDataGenerator();\n+        rd2.reSeedSecure();\n+        rd2.nextSecureLong(1, 2);\n+    }\n+\n+    /** tests for nextSample() sampling from Collection */\n+    @Test\n+    public void testNextSample() {\n+        Object[][] c = { { \"0\", \"1\" }, { \"0\", \"2\" }, { \"0\", \"3\" },\n+                { \"0\", \"4\" }, { \"1\", \"2\" }, { \"1\", \"3\" }, { \"1\", \"4\" },\n+                { \"2\", \"3\" }, { \"2\", \"4\" }, { \"3\", \"4\" } };\n+        long[] observed = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n+        double[] expected = { 100, 100, 100, 100, 100, 100, 100, 100, 100, 100 };\n+\n+        HashSet<Object> cPop = new HashSet<Object>(); // {0,1,2,3,4}\n+        for (int i = 0; i < 5; i++) {\n+            cPop.add(Integer.toString(i));\n+        }\n+\n+        Object[] sets = new Object[10]; // 2-sets from 5\n+        for (int i = 0; i < 10; i++) {\n+            HashSet<Object> hs = new HashSet<Object>();\n+            hs.add(c[i][0]);\n+            hs.add(c[i][1]);\n+            sets[i] = hs;\n+        }\n+\n+        for (int i = 0; i < 1000; i++) {\n+            Object[] cSamp = randomData.nextSample(cPop, 2);\n+            observed[findSample(sets, cSamp)]++;\n+        }\n+\n+        /*\n+         * Use ChiSquare dist with df = 10-1 = 9, alpha = .001 Change to 21.67\n+         * for alpha = .01\n+         */\n+        Assert.assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n+                testStatistic.chiSquare(expected, observed) < 27.88);\n+\n+        // Make sure sample of size = size of collection returns same collection\n+        HashSet<Object> hs = new HashSet<Object>();\n+        hs.add(\"one\");\n+        Object[] one = randomData.nextSample(hs, 1);\n+        String oneString = (String) one[0];\n+        if ((one.length != 1) || !oneString.equals(\"one\")) {\n+            Assert.fail(\"bad sample for set size = 1, sample size = 1\");\n+        }\n+\n+        // Make sure we fail for sample size > collection size\n+        try {\n+            one = randomData.nextSample(hs, 2);\n+            Assert.fail(\"sample size > set size, expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+\n+        // Make sure we fail for empty collection\n+        try {\n+            hs = new HashSet<Object>();\n+            one = randomData.nextSample(hs, 0);\n+            Assert.fail(\"n = k = 0, expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private int findSample(Object[] u, Object[] samp) {\n+        for (int i = 0; i < u.length; i++) {\n+            HashSet<Object> set = (HashSet<Object>) u[i];\n+            HashSet<Object> sampSet = new HashSet<Object>();\n+            for (int j = 0; j < samp.length; j++) {\n+                sampSet.add(samp[j]);\n+            }\n+            if (set.equals(sampSet)) {\n+                return i;\n+            }\n+        }\n+        Assert.fail(\"sample not found:{\" + samp[0] + \",\" + samp[1] + \"}\");\n+        return -1;\n+    }\n+\n+    /** tests for nextPermutation */\n+    @Test\n+    public void testNextPermutation() {\n+        int[][] p = { { 0, 1, 2 }, { 0, 2, 1 }, { 1, 0, 2 }, { 1, 2, 0 },\n+                { 2, 0, 1 }, { 2, 1, 0 } };\n+        long[] observed = { 0, 0, 0, 0, 0, 0 };\n+        double[] expected = { 100, 100, 100, 100, 100, 100 };\n+\n+        for (int i = 0; i < 600; i++) {\n+            int[] perm = randomData.nextPermutation(3, 3);\n+            observed[findPerm(p, perm)]++;\n+        }\n+        \n+        String[] labels = {\"{0, 1, 2}\", \"{ 0, 2, 1 }\", \"{ 1, 0, 2 }\",\n+        \t\t\"{ 1, 2, 0 }\", \"{ 2, 0, 1 }\", \"{ 2, 1, 0 }\"};\n+        TestUtils.assertChiSquareAccept(labels, expected, observed, 0.001);\n+\n+        // Check size = 1 boundary case\n+        int[] perm = randomData.nextPermutation(1, 1);\n+        if ((perm.length != 1) || (perm[0] != 0)) {\n+            Assert.fail(\"bad permutation for n = 1, sample k = 1\");\n+\n+            // Make sure we fail for k size > n\n+            try {\n+                perm = randomData.nextPermutation(2, 3);\n+                Assert.fail(\"permutation k > n, expecting MathIllegalArgumentException\");\n+            } catch (MathIllegalArgumentException ex) {\n+                // ignored\n+            }\n+\n+            // Make sure we fail for n = 0\n+            try {\n+                perm = randomData.nextPermutation(0, 0);\n+                Assert.fail(\"permutation k = n = 0, expecting MathIllegalArgumentException\");\n+            } catch (MathIllegalArgumentException ex) {\n+                // ignored\n+            }\n+\n+            // Make sure we fail for k < n < 0\n+            try {\n+                perm = randomData.nextPermutation(-1, -3);\n+                Assert.fail(\"permutation k < n < 0, expecting MathIllegalArgumentException\");\n+            } catch (MathIllegalArgumentException ex) {\n+                // ignored\n+            }\n+\n+        }\n+    }\n+\n+    // Disable until we have equals\n+    //public void testSerial() {\n+    //    Assert.assertEquals(randomData, TestUtils.serializeAndRecover(randomData));\n+    //}\n+\n+    private int findPerm(int[][] p, int[] samp) {\n+        for (int i = 0; i < p.length; i++) {\n+            boolean good = true;\n+            for (int j = 0; j < samp.length; j++) {\n+                if (samp[j] != p[i][j]) {\n+                    good = false;\n+                }\n+            }\n+            if (good) {\n+                return i;\n+            }\n+        }\n+        Assert.fail(\"permutation not found\");\n+        return -1;\n+    }\n+\n+    @Test\n+    public void testNextInversionDeviate() {\n+        // Set the seed for the default random generator\n+        RandomGenerator rg = new Well19937c(100);\n+        RandomDataGenerator rdg = new RandomDataGenerator(rg);\n+        double[] quantiles = new double[10];\n+        for (int i = 0; i < 10; i++) {\n+            quantiles[i] = rdg.nextUniform(0, 1);\n+        }\n+        // Reseed again so the inversion generator gets the same sequence\n+        rg.setSeed(100);\n+        BetaDistribution betaDistribution = new BetaDistribution(rg, 2, 4,\n+                                                                 BetaDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n+        /*\n+         *  Generate a sequence of deviates using inversion - the distribution function\n+         *  evaluated at the random value from the distribution should match the uniform\n+         *  random value used to generate it, which is stored in the quantiles[] array.\n+         */\n+        for (int i = 0; i < 10; i++) {\n+            double value = betaDistribution.sample();\n+            Assert.assertEquals(betaDistribution.cumulativeProbability(value), quantiles[i], 10E-9);\n+        }\n+    }\n+\n+    @Test\n+    public void testNextBeta() {\n+        double[] quartiles = TestUtils.getDistributionQuartiles(new BetaDistribution(2,5));\n+        long[] counts = new long[4];\n+        randomData.reSeed(1000);\n+        for (int i = 0; i < 1000; i++) {\n+            double value = randomData.nextBeta(2, 5);\n+            TestUtils.updateCounts(value, counts, quartiles);\n+        }\n+        TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n+    }\n+\n+    @Test\n+    public void testNextCauchy() {\n+        double[] quartiles = TestUtils.getDistributionQuartiles(new CauchyDistribution(1.2, 2.1));\n+        long[] counts = new long[4];\n+        randomData.reSeed(1000);\n+        for (int i = 0; i < 1000; i++) {\n+            double value = randomData.nextCauchy(1.2, 2.1);\n+            TestUtils.updateCounts(value, counts, quartiles);\n+        }\n+        TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n+    }\n+\n+    @Test\n+    public void testNextChiSquare() {\n+        double[] quartiles = TestUtils.getDistributionQuartiles(new ChiSquaredDistribution(12));\n+        long[] counts = new long[4];\n+        randomData.reSeed(1000);\n+        for (int i = 0; i < 1000; i++) {\n+            double value = randomData.nextChiSquare(12);\n+            TestUtils.updateCounts(value, counts, quartiles);\n+        }\n+        TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n+    }\n+\n+    @Test\n+    public void testNextF() {\n+        double[] quartiles = TestUtils.getDistributionQuartiles(new FDistribution(12, 5));\n+        long[] counts = new long[4];\n+        randomData.reSeed(1000);\n+        for (int i = 0; i < 1000; i++) {\n+            double value = randomData.nextF(12, 5);\n+            TestUtils.updateCounts(value, counts, quartiles);\n+        }\n+        TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n+    }\n+\n+    @Test\n+    public void testNextGamma() {\n+        double[] quartiles;\n+        long[] counts;\n+\n+        // Tests shape > 1, one case in the rejection sampling\n+        quartiles = TestUtils.getDistributionQuartiles(new GammaDistribution(4, 2));\n+        counts = new long[4];\n+        randomData.reSeed(1000);\n+        for (int i = 0; i < 1000; i++) {\n+            double value = randomData.nextGamma(4, 2);\n+            TestUtils.updateCounts(value, counts, quartiles);\n+        }\n+        TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n+\n+        // Tests shape <= 1, another case in the rejection sampling\n+        quartiles = TestUtils.getDistributionQuartiles(new GammaDistribution(0.3, 3));\n+        counts = new long[4];\n+        randomData.reSeed(1000);\n+        for (int i = 0; i < 1000; i++) {\n+            double value = randomData.nextGamma(0.3, 3);\n+            TestUtils.updateCounts(value, counts, quartiles);\n+        }\n+        TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n+    }\n+\n+    @Test\n+    public void testNextT() {\n+        double[] quartiles = TestUtils.getDistributionQuartiles(new TDistribution(10));\n+        long[] counts = new long[4];\n+        randomData.reSeed(1000);\n+        for (int i = 0; i < 1000; i++) {\n+            double value = randomData.nextT(10);\n+            TestUtils.updateCounts(value, counts, quartiles);\n+        }\n+        TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n+    }\n+\n+    @Test\n+    public void testNextWeibull() {\n+        double[] quartiles = TestUtils.getDistributionQuartiles(new WeibullDistribution(1.2, 2.1));\n+        long[] counts = new long[4];\n+        randomData.reSeed(1000);\n+        for (int i = 0; i < 1000; i++) {\n+            double value = randomData.nextWeibull(1.2, 2.1);\n+            TestUtils.updateCounts(value, counts, quartiles);\n+        }\n+        TestUtils.assertChiSquareAccept(expected, counts, 0.001);\n+    }\n+\n+    @Test\n+    public void testNextBinomial() {\n+        BinomialDistributionTest testInstance = new BinomialDistributionTest();\n+        int[] densityPoints = testInstance.makeDensityTestPoints();\n+        double[] densityValues = testInstance.makeDensityTestValues();\n+        int sampleSize = 1000;\n+        int length = TestUtils.eliminateZeroMassPoints(densityPoints, densityValues);\n+        BinomialDistribution distribution = (BinomialDistribution) testInstance.makeDistribution();\n+        double[] expectedCounts = new double[length];\n+        long[] observedCounts = new long[length];\n+        for (int i = 0; i < length; i++) {\n+            expectedCounts[i] = sampleSize * densityValues[i];\n+        }\n+        randomData.reSeed(1000);\n+        for (int i = 0; i < sampleSize; i++) {\n+          int value = randomData.nextBinomial(distribution.getNumberOfTrials(),\n+                  distribution.getProbabilityOfSuccess());\n+          for (int j = 0; j < length; j++) {\n+              if (value == densityPoints[j]) {\n+                  observedCounts[j]++;\n+              }\n+          }\n+        }\n+        TestUtils.assertChiSquareAccept(densityPoints, expectedCounts, observedCounts, .001);\n+    }\n+\n+    @Test\n+    public void testNextHypergeometric() {\n+        HypergeometricDistributionTest testInstance = new HypergeometricDistributionTest();\n+        int[] densityPoints = testInstance.makeDensityTestPoints();\n+        double[] densityValues = testInstance.makeDensityTestValues();\n+        int sampleSize = 1000;\n+        int length = TestUtils.eliminateZeroMassPoints(densityPoints, densityValues);\n+        HypergeometricDistribution distribution = (HypergeometricDistribution) testInstance.makeDistribution();\n+        double[] expectedCounts = new double[length];\n+        long[] observedCounts = new long[length];\n+        for (int i = 0; i < length; i++) {\n+            expectedCounts[i] = sampleSize * densityValues[i];\n+        }\n+        randomData.reSeed(1000);\n+        for (int i = 0; i < sampleSize; i++) {\n+          int value = randomData.nextHypergeometric(distribution.getPopulationSize(),\n+                  distribution.getNumberOfSuccesses(), distribution.getSampleSize());\n+          for (int j = 0; j < length; j++) {\n+              if (value == densityPoints[j]) {\n+                  observedCounts[j]++;\n+              }\n+          }\n+        }\n+        TestUtils.assertChiSquareAccept(densityPoints, expectedCounts, observedCounts, .001);\n+    }\n+\n+    @Test\n+    public void testNextPascal() {\n+        PascalDistributionTest testInstance = new PascalDistributionTest();\n+        int[] densityPoints = testInstance.makeDensityTestPoints();\n+        double[] densityValues = testInstance.makeDensityTestValues();\n+        int sampleSize = 1000;\n+        int length = TestUtils.eliminateZeroMassPoints(densityPoints, densityValues);\n+        PascalDistribution distribution = (PascalDistribution) testInstance.makeDistribution();\n+        double[] expectedCounts = new double[length];\n+        long[] observedCounts = new long[length];\n+        for (int i = 0; i < length; i++) {\n+            expectedCounts[i] = sampleSize * densityValues[i];\n+        }\n+        randomData.reSeed(1000);\n+        for (int i = 0; i < sampleSize; i++) {\n+          int value = randomData.nextPascal(distribution.getNumberOfSuccesses(), distribution.getProbabilityOfSuccess());\n+          for (int j = 0; j < length; j++) {\n+              if (value == densityPoints[j]) {\n+                  observedCounts[j]++;\n+              }\n+          }\n+        }\n+        TestUtils.assertChiSquareAccept(densityPoints, expectedCounts, observedCounts, .001);\n+    }\n+\n+    @Test\n+    public void testNextZipf() {\n+        ZipfDistributionTest testInstance = new ZipfDistributionTest();\n+        int[] densityPoints = testInstance.makeDensityTestPoints();\n+        double[] densityValues = testInstance.makeDensityTestValues();\n+        int sampleSize = 1000;\n+        int length = TestUtils.eliminateZeroMassPoints(densityPoints, densityValues);\n+        ZipfDistribution distribution = (ZipfDistribution) testInstance.makeDistribution();\n+        double[] expectedCounts = new double[length];\n+        long[] observedCounts = new long[length];\n+        for (int i = 0; i < length; i++) {\n+            expectedCounts[i] = sampleSize * densityValues[i];\n+        }\n+        randomData.reSeed(1000);\n+        for (int i = 0; i < sampleSize; i++) {\n+          int value = randomData.nextZipf(distribution.getNumberOfElements(), distribution.getExponent());\n+          for (int j = 0; j < length; j++) {\n+              if (value == densityPoints[j]) {\n+                  observedCounts[j]++;\n+              }\n+          }\n+        }\n+        TestUtils.assertChiSquareAccept(densityPoints, expectedCounts, observedCounts, .001);\n+    }\n+\n+    @Test\n+    /**\n+     * MATH-720\n+     */\n+    public void testReseed() {\n+        PoissonDistribution x = new PoissonDistribution(3.0);\n+        x.reseedRandomGenerator(0);\n+        final double u = x.sample();\n+        PoissonDistribution y = new PoissonDistribution(3.0);\n+        y.reseedRandomGenerator(0);\n+        Assert.assertEquals(u, y.sample(), 0);\n+    }\n+\n+}\n--- a/src/test/java/org/apache/commons/math3/random/RandomGeneratorAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math3/random/RandomGeneratorAbstractTest.java\n  * @version $Id$\n  */\n \n-public abstract class RandomGeneratorAbstractTest extends RandomDataTest {\n+public abstract class RandomGeneratorAbstractTest extends RandomDataGeneratorTest {\n \n     /** RandomGenerator under test */\n     protected RandomGenerator generator;\n      */\n     public RandomGeneratorAbstractTest() {\n         generator = makeGenerator();\n-        randomData = new RandomDataImpl(generator);\n+        randomData = new RandomDataGenerator(generator);\n     }\n \n     /**\n         }\n     }\n \n-    @Override // TODO is this supposed to be an override?\n-    @Test(expected=MathIllegalArgumentException.class)\n-    public void testNextIntIAE() {\n+    @Test\n+    public void testNextIntIAE2() {\n         try {\n             generator.nextInt(-1);\n             Assert.fail(\"MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n-        generator.nextInt(0);\n+        try {\n+            generator.nextInt(0);\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n     }\n \n     @Test", "timestamp": 1362920524, "metainfo": ""}