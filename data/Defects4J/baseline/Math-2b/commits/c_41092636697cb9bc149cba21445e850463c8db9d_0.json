{"sha": "41092636697cb9bc149cba21445e850463c8db9d", "log": "[MATH-917] Refactored clustering package to include more distance measures.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/ml/clustering/CentroidCluster.java\n+package org.apache.commons.math3.ml.clustering;\n+\n+/**\n+ * A Cluster used by centroid-based clustering algorithms.\n+ * <p>\n+ * Defines additionally a cluster center which may not necessarily be a member\n+ * of the original data set.\n+ *\n+ * @param <T> the type of points that can be clustered\n+ * @version $Id $\n+ * @since 3.2\n+ */\n+public class CentroidCluster<T extends Clusterable> extends Cluster<T> {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -3075288519071812288L;\n+\n+    /** Center of the cluster. */\n+    private final Clusterable center;\n+\n+    /**\n+     * Build a cluster centered at a specified point.\n+     * @param center the point which is to be the center of this cluster\n+     */\n+    public CentroidCluster(final Clusterable center) {\n+        super();\n+        this.center = center;\n+    }\n+\n+    /**\n+     * Get the point chosen to be the center of this cluster.\n+     * @return chosen cluster center\n+     */\n+    public Clusterable getCenter() {\n+        return center;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/ml/clustering/Cluster.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.ml.clustering;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Cluster holding a set of {@link Clusterable} points.\n+ * @param <T> the type of points that can be clustered\n+ * @version $Id$\n+ * @since 3.2\n+ */\n+public class Cluster<T extends Clusterable> implements Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -3442297081515880464L;\n+\n+    /** The points contained in this cluster. */\n+    private final List<T> points;\n+\n+    /**\n+     * Build a cluster centered at a specified point.\n+     */\n+    public Cluster() {\n+        points = new ArrayList<T>();\n+    }\n+\n+    /**\n+     * Add a point to this cluster.\n+     * @param point point to add\n+     */\n+    public void addPoint(final T point) {\n+        points.add(point);\n+    }\n+\n+    /**\n+     * Get the points contained in the cluster.\n+     * @return points contained in the cluster\n+     */\n+    public List<T> getPoints() {\n+        return points;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/ml/clustering/Clusterable.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.ml.clustering;\n+\n+/**\n+ * Interface for n-dimensional points that can be clustered together.\n+ * @version $Id$\n+ * @since 3.2\n+ */\n+public interface Clusterable {\n+\n+    /**\n+     * Gets the n-dimensional point.\n+     *\n+     * @return the point array\n+     */\n+    double[] getPoint();\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/ml/clustering/Clusterer.java\n+package org.apache.commons.math3.ml.clustering;\n+\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.apache.commons.math3.exception.ConvergenceException;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.ml.distance.DistanceMeasure;\n+\n+/**\n+ * Base class for clustering algorithms.\n+ *\n+ * @param <T> the type of points that can be clustered\n+ * @version $Id $\n+ * @since 3.2\n+ */\n+public abstract class Clusterer<T extends Clusterable> {\n+\n+    /** The distance measure to use. */\n+    private DistanceMeasure measure;\n+\n+    /**\n+     * Build a new clusterer with the given {@link DistanceMeasure}.\n+     *\n+     * @param measure the distance measure to use\n+     */\n+    protected Clusterer(final DistanceMeasure measure) {\n+        this.measure = measure;\n+    }\n+\n+    /**\n+     * Perform a cluster analysis on the given set of {@link Clusterable} instances.\n+     *\n+     * @param points the set of {@link Clusterable} instances\n+     * @return a {@link List} of clusters\n+     * @throws MathIllegalArgumentException if points are null or the number of\n+     *   data points is not compatible with this clusterer\n+     * @throws ConvergenceException if the algorithm has not yet converged after\n+     *   the maximum number of iterations has been exceeded\n+     */\n+    public abstract List<? extends Cluster<T>> cluster(Collection<T> points)\n+            throws MathIllegalArgumentException, ConvergenceException;\n+\n+    /**\n+     * Returns the {@link DistanceMeasure} instance used by this clusterer.\n+     *\n+     * @return the distance measure\n+     */\n+    public DistanceMeasure getDistanceMeasure() {\n+        return measure;\n+    }\n+\n+    /**\n+     * Calculates the distance between two {@link Clusterable} instances\n+     * with the configured {@link DistanceMeasure}.\n+     *\n+     * @param p1 the first clusterable\n+     * @param p2 the second clusterable\n+     * @return the distance between the two clusterables\n+     */\n+    protected double distance(final Clusterable p1, final Clusterable p2) {\n+        return measure.compute(p1.getPoint(), p2.getPoint());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/ml/clustering/DBSCANClusterer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.ml.clustering;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.math3.exception.NotPositiveException;\n+import org.apache.commons.math3.exception.NullArgumentException;\n+import org.apache.commons.math3.ml.distance.DistanceMeasure;\n+import org.apache.commons.math3.ml.distance.EuclideanDistance;\n+import org.apache.commons.math3.util.MathUtils;\n+\n+/**\n+ * DBSCAN (density-based spatial clustering of applications with noise) algorithm.\n+ * <p>\n+ * The DBSCAN algorithm forms clusters based on the idea of density connectivity, i.e.\n+ * a point p is density connected to another point q, if there exists a chain of\n+ * points p<sub>i</sub>, with i = 1 .. n and p<sub>1</sub> = p and p<sub>n</sub> = q,\n+ * such that each pair &lt;p<sub>i</sub>, p<sub>i+1</sub>&gt; is directly density-reachable.\n+ * A point q is directly density-reachable from point p if it is in the &epsilon;-neighborhood\n+ * of this point.\n+ * <p>\n+ * Any point that is not density-reachable from a formed cluster is treated as noise, and\n+ * will thus not be present in the result.\n+ * <p>\n+ * The algorithm requires two parameters:\n+ * <ul>\n+ *   <li>eps: the distance that defines the &epsilon;-neighborhood of a point\n+ *   <li>minPoints: the minimum number of density-connected points required to form a cluster\n+ * </ul>\n+ *\n+ * @param <T> type of the points to cluster\n+ * @see <a href=\"http://en.wikipedia.org/wiki/DBSCAN\">DBSCAN (wikipedia)</a>\n+ * @see <a href=\"http://www.dbs.ifi.lmu.de/Publikationen/Papers/KDD-96.final.frame.pdf\">\n+ * A Density-Based Algorithm for Discovering Clusters in Large Spatial Databases with Noise</a>\n+ * @version $Id$\n+ * @since 3.2\n+ */\n+public class DBSCANClusterer<T extends Clusterable> extends Clusterer<T> {\n+\n+    /** Maximum radius of the neighborhood to be considered. */\n+    private final double              eps;\n+\n+    /** Minimum number of points needed for a cluster. */\n+    private final int                 minPts;\n+\n+    /** Status of a point during the clustering process. */\n+    private enum PointStatus {\n+        /** The point has is considered to be noise. */\n+        NOISE,\n+        /** The point is already part of a cluster. */\n+        PART_OF_CLUSTER\n+    }\n+\n+    /**\n+     * Creates a new instance of a DBSCANClusterer.\n+     *\n+     * @param eps maximum radius of the neighborhood to be considered\n+     * @param minPts minimum number of points needed for a cluster\n+     * @throws NotPositiveException if {@code eps < 0.0} or {@code minPts < 0}\n+     */\n+    public DBSCANClusterer(final double eps, final int minPts)\n+        throws NotPositiveException {\n+        this(eps, minPts, new EuclideanDistance());\n+    }\n+\n+    /**\n+     * Creates a new instance of a DBSCANClusterer.\n+     *\n+     * @param eps maximum radius of the neighborhood to be considered\n+     * @param minPts minimum number of points needed for a cluster\n+     * @param measure the distance measure to use\n+     * @throws NotPositiveException if {@code eps < 0.0} or {@code minPts < 0}\n+     */\n+    public DBSCANClusterer(final double eps, final int minPts, final DistanceMeasure measure)\n+        throws NotPositiveException {\n+        super(measure);\n+\n+        if (eps < 0.0d) {\n+            throw new NotPositiveException(eps);\n+        }\n+        if (minPts < 0) {\n+            throw new NotPositiveException(minPts);\n+        }\n+        this.eps = eps;\n+        this.minPts = minPts;\n+    }\n+\n+    /**\n+     * Returns the maximum radius of the neighborhood to be considered.\n+     * @return maximum radius of the neighborhood\n+     */\n+    public double getEps() {\n+        return eps;\n+    }\n+\n+    /**\n+     * Returns the minimum number of points needed for a cluster.\n+     * @return minimum number of points needed for a cluster\n+     */\n+    public int getMinPts() {\n+        return minPts;\n+    }\n+\n+    /**\n+     * Performs DBSCAN cluster analysis.\n+     *\n+     * @param points the points to cluster\n+     * @return the list of clusters\n+     * @throws NullArgumentException if the data points are null\n+     */\n+    public List<Cluster<T>> cluster(final Collection<T> points) throws NullArgumentException {\n+\n+        // sanity checks\n+        MathUtils.checkNotNull(points);\n+\n+        final List<Cluster<T>> clusters = new ArrayList<Cluster<T>>();\n+        final Map<Clusterable, PointStatus> visited = new HashMap<Clusterable, PointStatus>();\n+\n+        for (final T point : points) {\n+            if (visited.get(point) != null) {\n+                continue;\n+            }\n+            final List<T> neighbors = getNeighbors(point, points);\n+            if (neighbors.size() >= minPts) {\n+                // DBSCAN does not care about center points\n+                final Cluster<T> cluster = new Cluster<T>();\n+                clusters.add(expandCluster(cluster, point, neighbors, points, visited));\n+            } else {\n+                visited.put(point, PointStatus.NOISE);\n+            }\n+        }\n+\n+        return clusters;\n+    }\n+\n+    /**\n+     * Expands the cluster to include density-reachable items.\n+     *\n+     * @param cluster Cluster to expand\n+     * @param point Point to add to cluster\n+     * @param neighbors List of neighbors\n+     * @param points the data set\n+     * @param visited the set of already visited points\n+     * @return the expanded cluster\n+     */\n+    private Cluster<T> expandCluster(final Cluster<T> cluster,\n+                                     final T point,\n+                                     final List<T> neighbors,\n+                                     final Collection<T> points,\n+                                     final Map<Clusterable, PointStatus> visited) {\n+        cluster.addPoint(point);\n+        visited.put(point, PointStatus.PART_OF_CLUSTER);\n+\n+        List<T> seeds = new ArrayList<T>(neighbors);\n+        int index = 0;\n+        while (index < seeds.size()) {\n+            final T current = seeds.get(index);\n+            PointStatus pStatus = visited.get(current);\n+            // only check non-visited points\n+            if (pStatus == null) {\n+                final List<T> currentNeighbors = getNeighbors(current, points);\n+                if (currentNeighbors.size() >= minPts) {\n+                    seeds = merge(seeds, currentNeighbors);\n+                }\n+            }\n+\n+            if (pStatus != PointStatus.PART_OF_CLUSTER) {\n+                visited.put(current, PointStatus.PART_OF_CLUSTER);\n+                cluster.addPoint(current);\n+            }\n+\n+            index++;\n+        }\n+        return cluster;\n+    }\n+\n+    /**\n+     * Returns a list of density-reachable neighbors of a {@code point}.\n+     *\n+     * @param point the point to look for\n+     * @param points possible neighbors\n+     * @return the List of neighbors\n+     */\n+    private List<T> getNeighbors(final T point, final Collection<T> points) {\n+        final List<T> neighbors = new ArrayList<T>();\n+        for (final T neighbor : points) {\n+            if (point != neighbor && distance(neighbor, point) <= eps) {\n+                neighbors.add(neighbor);\n+            }\n+        }\n+        return neighbors;\n+    }\n+\n+    /**\n+     * Merges two lists together.\n+     *\n+     * @param one first list\n+     * @param two second list\n+     * @return merged lists\n+     */\n+    private List<T> merge(final List<T> one, final List<T> two) {\n+        final Set<T> oneSet = new HashSet<T>(one);\n+        for (T item : two) {\n+            if (!oneSet.contains(item)) {\n+                one.add(item);\n+            }\n+        }\n+        return one;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/ml/clustering/DoublePoint.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.ml.clustering;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+\n+/**\n+ * A simple implementation of {@link Clusterable} for points with double coordinates.\n+ * @version $Id$\n+ * @since 3.2\n+ */\n+public class DoublePoint implements Clusterable, Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 3946024775784901369L;\n+\n+    /** Point coordinates. */\n+    private final double[] point;\n+\n+    /**\n+     * Build an instance wrapping an double array.\n+     * <p>\n+     * The wrapped array is referenced, it is <em>not</em> copied.\n+     *\n+     * @param point the n-dimensional point in double space\n+     */\n+    public DoublePoint(final double[] point) {\n+        this.point = point;\n+    }\n+\n+    /**\n+     * Build an instance wrapping an integer array.\n+     * <p>\n+     * The wrapped array is copied to an internal double array.\n+     *\n+     * @param point the n-dimensional point in integer space\n+     */\n+    public DoublePoint(final int[] point) {\n+        this.point = new double[point.length];\n+        for ( int i = 0; i < point.length; i++) {\n+            this.point[i] = point[i];\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] getPoint() {\n+        return point;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean equals(final Object other) {\n+        if (!(other instanceof DoublePoint)) {\n+            return false;\n+        }\n+        return Arrays.equals(point, ((DoublePoint) other).point);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int hashCode() {\n+        return Arrays.hashCode(point);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public String toString() {\n+        return Arrays.toString(point);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/ml/clustering/KMeansPlusPlusClusterer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.ml.clustering;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.commons.math3.exception.ConvergenceException;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n+import org.apache.commons.math3.exception.util.LocalizedFormats;\n+import org.apache.commons.math3.ml.distance.DistanceMeasure;\n+import org.apache.commons.math3.ml.distance.EuclideanDistance;\n+import org.apache.commons.math3.random.JDKRandomGenerator;\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.stat.descriptive.moment.Variance;\n+import org.apache.commons.math3.util.MathUtils;\n+\n+/**\n+ * Clustering algorithm based on David Arthur and Sergei Vassilvitski k-means++ algorithm.\n+ * @param <T> type of the points to cluster\n+ * @see <a href=\"http://en.wikipedia.org/wiki/K-means%2B%2B\">K-means++ (wikipedia)</a>\n+ * @version $Id$\n+ * @since 3.2\n+ */\n+public class KMeansPlusPlusClusterer<T extends Clusterable> extends Clusterer<T> {\n+\n+    /** Strategies to use for replacing an empty cluster. */\n+    public static enum EmptyClusterStrategy {\n+\n+        /** Split the cluster with largest distance variance. */\n+        LARGEST_VARIANCE,\n+\n+        /** Split the cluster with largest number of points. */\n+        LARGEST_POINTS_NUMBER,\n+\n+        /** Create a cluster around the point farthest from its centroid. */\n+        FARTHEST_POINT,\n+\n+        /** Generate an error. */\n+        ERROR\n+\n+    }\n+\n+    /** The number of clusters. */\n+    private final int k;\n+\n+    /** The maximum number of iterations. */\n+    private final int maxIterations;\n+\n+    /** Random generator for choosing initial centers. */\n+    private final RandomGenerator random;\n+\n+    /** Selected strategy for empty clusters. */\n+    private final EmptyClusterStrategy emptyStrategy;\n+\n+    /** Build a clusterer.\n+     * <p>\n+     * The default strategy for handling empty clusters that may appear during\n+     * algorithm iterations is to split the cluster with largest distance variance.\n+     *\n+     * @param k the number of clusters to split the data into\n+     */\n+    public KMeansPlusPlusClusterer(final int k) {\n+        this(k, -1);\n+    }\n+\n+    /** Build a clusterer.\n+     * <p>\n+     * The default strategy for handling empty clusters that may appear during\n+     * algorithm iterations is to split the cluster with largest distance variance.\n+     *\n+     * @param k the number of clusters to split the data into\n+     * @param maxIterations the maximum number of iterations to run the algorithm for.\n+     *   If negative, no maximum will be used.\n+     */\n+    public KMeansPlusPlusClusterer(final int k, final int maxIterations) {\n+        this(k, maxIterations, new EuclideanDistance());\n+    }\n+\n+    /** Build a clusterer.\n+     * <p>\n+     * The default strategy for handling empty clusters that may appear during\n+     * algorithm iterations is to split the cluster with largest distance variance.\n+     *\n+     * @param k the number of clusters to split the data into\n+     * @param maxIterations the maximum number of iterations to run the algorithm for.\n+     *   If negative, no maximum will be used.\n+     * @param measure the distance measure to use\n+     */\n+    public KMeansPlusPlusClusterer(final int k, final int maxIterations, final DistanceMeasure measure) {\n+        this(k, maxIterations, measure, new JDKRandomGenerator());\n+    }\n+\n+    /** Build a clusterer.\n+     * <p>\n+     * The default strategy for handling empty clusters that may appear during\n+     * algorithm iterations is to split the cluster with largest distance variance.\n+     *\n+     * @param k the number of clusters to split the data into\n+     * @param maxIterations the maximum number of iterations to run the algorithm for.\n+     *   If negative, no maximum will be used.\n+     * @param measure the distance measure to use\n+     * @param random random generator to use for choosing initial centers\n+     */\n+    public KMeansPlusPlusClusterer(final int k, final int maxIterations,\n+                                   final DistanceMeasure measure,\n+                                   final RandomGenerator random) {\n+        this(k, maxIterations, measure, random, EmptyClusterStrategy.LARGEST_VARIANCE);\n+    }\n+\n+    /** Build a clusterer.\n+     *\n+     * @param k the number of clusters to split the data into\n+     * @param maxIterations the maximum number of iterations to run the algorithm for.\n+     *   If negative, no maximum will be used.\n+     * @param measure the distance measure to use\n+     * @param random random generator to use for choosing initial centers\n+     * @param emptyStrategy strategy to use for handling empty clusters that\n+     * may appear during algorithm iterations\n+     */\n+    public KMeansPlusPlusClusterer(final int k, final int maxIterations,\n+                                   final DistanceMeasure measure,\n+                                   final RandomGenerator random,\n+                                   final EmptyClusterStrategy emptyStrategy) {\n+        super(measure);\n+        this.k             = k;\n+        this.maxIterations = maxIterations;\n+        this.random        = random;\n+        this.emptyStrategy = emptyStrategy;\n+    }\n+\n+    /**\n+     * Return the number of clusters this instance will use.\n+     * @return the number of clusters\n+     */\n+    public int getK() {\n+        return k;\n+    }\n+\n+    /**\n+     * Returns the maximum number of iterations this instance will use.\n+     * @return the maximum number of iterations, or -1 if no maximum is set\n+     */\n+    public int getMaxIterations() {\n+        return maxIterations;\n+    }\n+\n+    /**\n+     * Returns the random generator this instance will use.\n+     * @return the random generator\n+     */\n+    public RandomGenerator getRandomGenerator() {\n+        return random;\n+    }\n+\n+    /**\n+     * Returns the {@link EmptyClusterStrategy} used by this instance.\n+     * @return the {@link EmptyClusterStrategy}\n+     */\n+    public EmptyClusterStrategy getEmptyClusterStrategy() {\n+        return emptyStrategy;\n+    }\n+\n+    /**\n+     * Runs the K-means++ clustering algorithm.\n+     *\n+     * @param points the points to cluster\n+     * @return a list of clusters containing the points\n+     * @throws MathIllegalArgumentException if the data points are null or the number\n+     *     of clusters is larger than the number of data points\n+     * @throws ConvergenceException if an empty cluster is encountered and the\n+     * {@link #emptyStrategy} is set to {@code ERROR}\n+     */\n+    public List<CentroidCluster<T>> cluster(final Collection<T> points)\n+        throws MathIllegalArgumentException, ConvergenceException {\n+\n+        // sanity checks\n+        MathUtils.checkNotNull(points);\n+\n+        // number of clusters has to be smaller or equal the number of data points\n+        if (points.size() < k) {\n+            throw new NumberIsTooSmallException(points.size(), k, false);\n+        }\n+\n+        // create the initial clusters\n+        List<CentroidCluster<T>> clusters = chooseInitialCenters(points);\n+\n+        // create an array containing the latest assignment of a point to a cluster\n+        // no need to initialize the array, as it will be filled with the first assignment\n+        int[] assignments = new int[points.size()];\n+        assignPointsToClusters(clusters, points, assignments);\n+\n+        // iterate through updating the centers until we're done\n+        final int max = (maxIterations < 0) ? Integer.MAX_VALUE : maxIterations;\n+        for (int count = 0; count < max; count++) {\n+            boolean emptyCluster = false;\n+            List<CentroidCluster<T>> newClusters = new ArrayList<CentroidCluster<T>>();\n+            for (final CentroidCluster<T> cluster : clusters) {\n+                final Clusterable newCenter;\n+                if (cluster.getPoints().isEmpty()) {\n+                    switch (emptyStrategy) {\n+                        case LARGEST_VARIANCE :\n+                            newCenter = getPointFromLargestVarianceCluster(clusters);\n+                            break;\n+                        case LARGEST_POINTS_NUMBER :\n+                            newCenter = getPointFromLargestNumberCluster(clusters);\n+                            break;\n+                        case FARTHEST_POINT :\n+                            newCenter = getFarthestPoint(clusters);\n+                            break;\n+                        default :\n+                            throw new ConvergenceException(LocalizedFormats.EMPTY_CLUSTER_IN_K_MEANS);\n+                    }\n+                    emptyCluster = true;\n+                } else {\n+                    newCenter = centroidOf(cluster.getPoints(), cluster.getCenter().getPoint().length);\n+                }\n+                newClusters.add(new CentroidCluster<T>(newCenter));\n+            }\n+            int changes = assignPointsToClusters(newClusters, points, assignments);\n+            clusters = newClusters;\n+\n+            // if there were no more changes in the point-to-cluster assignment\n+            // and there are no empty clusters left, return the current clusters\n+            if (changes == 0 && !emptyCluster) {\n+                return clusters;\n+            }\n+        }\n+        return clusters;\n+    }\n+\n+    /**\n+     * Adds the given points to the closest {@link Cluster}.\n+     *\n+     * @param clusters the {@link Cluster}s to add the points to\n+     * @param points the points to add to the given {@link Cluster}s\n+     * @param assignments points assignments to clusters\n+     * @return the number of points assigned to different clusters as the iteration before\n+     */\n+    private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n+                                       final Collection<T> points,\n+                                       final int[] assignments) {\n+        int assignedDifferently = 0;\n+        int pointIndex = 0;\n+        for (final T p : points) {\n+            int clusterIndex = getNearestCluster(clusters, p);\n+            if (clusterIndex != assignments[pointIndex]) {\n+                assignedDifferently++;\n+            }\n+\n+            CentroidCluster<T> cluster = clusters.get(clusterIndex);\n+            cluster.addPoint(p);\n+            assignments[pointIndex++] = clusterIndex;\n+        }\n+\n+        return assignedDifferently;\n+    }\n+\n+    /**\n+     * Use K-means++ to choose the initial centers.\n+     *\n+     * @param points the points to choose the initial centers from\n+     * @return the initial centers\n+     */\n+    private List<CentroidCluster<T>> chooseInitialCenters(final Collection<T> points) {\n+\n+        // Convert to list for indexed access. Make it unmodifiable, since removal of items\n+        // would screw up the logic of this method.\n+        final List<T> pointList = Collections.unmodifiableList(new ArrayList<T> (points));\n+\n+        // The number of points in the list.\n+        final int numPoints = pointList.size();\n+\n+        // Set the corresponding element in this array to indicate when\n+        // elements of pointList are no longer available.\n+        final boolean[] taken = new boolean[numPoints];\n+\n+        // The resulting list of initial centers.\n+        final List<CentroidCluster<T>> resultSet = new ArrayList<CentroidCluster<T>>();\n+\n+        // Choose one center uniformly at random from among the data points.\n+        final int firstPointIndex = random.nextInt(numPoints);\n+\n+        final T firstPoint = pointList.get(firstPointIndex);\n+\n+        resultSet.add(new CentroidCluster<T>(firstPoint));\n+\n+        // Must mark it as taken\n+        taken[firstPointIndex] = true;\n+\n+        // To keep track of the minimum distance squared of elements of\n+        // pointList to elements of resultSet.\n+        final double[] minDistSquared = new double[numPoints];\n+\n+        // Initialize the elements.  Since the only point in resultSet is firstPoint,\n+        // this is very easy.\n+        for (int i = 0; i < numPoints; i++) {\n+            if (i != firstPointIndex) { // That point isn't considered\n+                double d = distance(firstPoint, pointList.get(i));\n+                minDistSquared[i] = d*d;\n+            }\n+        }\n+\n+        while (resultSet.size() < k) {\n+\n+            // Sum up the squared distances for the points in pointList not\n+            // already taken.\n+            double distSqSum = 0.0;\n+\n+            for (int i = 0; i < numPoints; i++) {\n+                if (!taken[i]) {\n+                    distSqSum += minDistSquared[i];\n+                }\n+            }\n+\n+            // Add one new data point as a center. Each point x is chosen with\n+            // probability proportional to D(x)2\n+            final double r = random.nextDouble() * distSqSum;\n+\n+            // The index of the next point to be added to the resultSet.\n+            int nextPointIndex = -1;\n+\n+            // Sum through the squared min distances again, stopping when\n+            // sum >= r.\n+            double sum = 0.0;\n+            for (int i = 0; i < numPoints; i++) {\n+                if (!taken[i]) {\n+                    sum += minDistSquared[i];\n+                    if (sum >= r) {\n+                        nextPointIndex = i;\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            // If it's not set to >= 0, the point wasn't found in the previous\n+            // for loop, probably because distances are extremely small.  Just pick\n+            // the last available point.\n+            if (nextPointIndex == -1) {\n+                for (int i = numPoints - 1; i >= 0; i--) {\n+                    if (!taken[i]) {\n+                        nextPointIndex = i;\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            // We found one.\n+            if (nextPointIndex >= 0) {\n+\n+                final T p = pointList.get(nextPointIndex);\n+\n+                resultSet.add(new CentroidCluster<T> (p));\n+\n+                // Mark it as taken.\n+                taken[nextPointIndex] = true;\n+\n+                if (resultSet.size() < k) {\n+                    // Now update elements of minDistSquared.  We only have to compute\n+                    // the distance to the new center to do this.\n+                    for (int j = 0; j < numPoints; j++) {\n+                        // Only have to worry about the points still not taken.\n+                        if (!taken[j]) {\n+                            double d = distance(p, pointList.get(j));\n+                            double d2 = d * d;\n+                            if (d2 < minDistSquared[j]) {\n+                                minDistSquared[j] = d2;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+            } else {\n+                // None found --\n+                // Break from the while loop to prevent\n+                // an infinite loop.\n+                break;\n+            }\n+        }\n+\n+        return resultSet;\n+    }\n+\n+    /**\n+     * Get a random point from the {@link Cluster} with the largest distance variance.\n+     *\n+     * @param clusters the {@link Cluster}s to search\n+     * @return a random point from the selected cluster\n+     * @throws ConvergenceException if clusters are all empty\n+     */\n+    private T getPointFromLargestVarianceCluster(final Collection<CentroidCluster<T>> clusters)\n+            throws ConvergenceException {\n+\n+        double maxVariance = Double.NEGATIVE_INFINITY;\n+        Cluster<T> selected = null;\n+        for (final CentroidCluster<T> cluster : clusters) {\n+            if (!cluster.getPoints().isEmpty()) {\n+\n+                // compute the distance variance of the current cluster\n+                final Clusterable center = cluster.getCenter();\n+                final Variance stat = new Variance();\n+                for (final T point : cluster.getPoints()) {\n+                    stat.increment(distance(point, center));\n+                }\n+                final double variance = stat.getResult();\n+\n+                // select the cluster with the largest variance\n+                if (variance > maxVariance) {\n+                    maxVariance = variance;\n+                    selected = cluster;\n+                }\n+\n+            }\n+        }\n+\n+        // did we find at least one non-empty cluster ?\n+        if (selected == null) {\n+            throw new ConvergenceException(LocalizedFormats.EMPTY_CLUSTER_IN_K_MEANS);\n+        }\n+\n+        // extract a random point from the cluster\n+        final List<T> selectedPoints = selected.getPoints();\n+        return selectedPoints.remove(random.nextInt(selectedPoints.size()));\n+\n+    }\n+\n+    /**\n+     * Get a random point from the {@link Cluster} with the largest number of points\n+     *\n+     * @param clusters the {@link Cluster}s to search\n+     * @return a random point from the selected cluster\n+     * @throws ConvergenceException if clusters are all empty\n+     */\n+    private T getPointFromLargestNumberCluster(final Collection<? extends Cluster<T>> clusters)\n+            throws ConvergenceException {\n+\n+        int maxNumber = 0;\n+        Cluster<T> selected = null;\n+        for (final Cluster<T> cluster : clusters) {\n+\n+            // get the number of points of the current cluster\n+            final int number = cluster.getPoints().size();\n+\n+            // select the cluster with the largest number of points\n+            if (number > maxNumber) {\n+                maxNumber = number;\n+                selected = cluster;\n+            }\n+\n+        }\n+\n+        // did we find at least one non-empty cluster ?\n+        if (selected == null) {\n+            throw new ConvergenceException(LocalizedFormats.EMPTY_CLUSTER_IN_K_MEANS);\n+        }\n+\n+        // extract a random point from the cluster\n+        final List<T> selectedPoints = selected.getPoints();\n+        return selectedPoints.remove(random.nextInt(selectedPoints.size()));\n+\n+    }\n+\n+    /**\n+     * Get the point farthest to its cluster center\n+     *\n+     * @param clusters the {@link Cluster}s to search\n+     * @return point farthest to its cluster center\n+     * @throws ConvergenceException if clusters are all empty\n+     */\n+    private T getFarthestPoint(final Collection<CentroidCluster<T>> clusters) throws ConvergenceException {\n+\n+        double maxDistance = Double.NEGATIVE_INFINITY;\n+        Cluster<T> selectedCluster = null;\n+        int selectedPoint = -1;\n+        for (final CentroidCluster<T> cluster : clusters) {\n+\n+            // get the farthest point\n+            final Clusterable center = cluster.getCenter();\n+            final List<T> points = cluster.getPoints();\n+            for (int i = 0; i < points.size(); ++i) {\n+                final double distance = distance(points.get(i), center);\n+                if (distance > maxDistance) {\n+                    maxDistance     = distance;\n+                    selectedCluster = cluster;\n+                    selectedPoint   = i;\n+                }\n+            }\n+\n+        }\n+\n+        // did we find at least one non-empty cluster ?\n+        if (selectedCluster == null) {\n+            throw new ConvergenceException(LocalizedFormats.EMPTY_CLUSTER_IN_K_MEANS);\n+        }\n+\n+        return selectedCluster.getPoints().remove(selectedPoint);\n+\n+    }\n+\n+    /**\n+     * Returns the nearest {@link Cluster} to the given point\n+     *\n+     * @param clusters the {@link Cluster}s to search\n+     * @param point the point to find the nearest {@link Cluster} for\n+     * @return the index of the nearest {@link Cluster} to the given point\n+     */\n+    private int getNearestCluster(final Collection<CentroidCluster<T>> clusters, final T point) {\n+        double minDistance = Double.MAX_VALUE;\n+        int clusterIndex = 0;\n+        int minCluster = 0;\n+        for (final CentroidCluster<T> c : clusters) {\n+            final double distance = distance(point, c.getCenter());\n+            if (distance < minDistance) {\n+                minDistance = distance;\n+                minCluster = clusterIndex;\n+            }\n+            clusterIndex++;\n+        }\n+        return minCluster;\n+    }\n+\n+    /**\n+     * Computes the centroid for a set of points.\n+     *\n+     * @param points the set of points\n+     * @param dimension the point dimension\n+     * @return the computed centroid for the set of points\n+     */\n+    private Clusterable centroidOf(final Collection<T> points, final int dimension) {\n+        final double[] centroid = new double[dimension];\n+        for (final T p : points) {\n+            final double[] point = p.getPoint();\n+            for (int i = 0; i < centroid.length; i++) {\n+                centroid[i] += point[i];\n+            }\n+        }\n+        for (int i = 0; i < centroid.length; i++) {\n+            centroid[i] /= points.size();\n+        }\n+        return new DoublePoint(centroid);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/ml/clustering/MultiKMeansPlusPlusClusterer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.ml.clustering;\n+\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.apache.commons.math3.exception.ConvergenceException;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.stat.descriptive.moment.Variance;\n+\n+/**\n+ * A wrapper around a k-means++ clustering algorithm which performs multiple trials\n+ * and returns the best solution.\n+ * @param <T> type of the points to cluster\n+ * @version $Id$\n+ * @since 3.2\n+ */\n+public class MultiKMeansPlusPlusClusterer<T extends Clusterable> extends Clusterer<T> {\n+\n+    /** The underlying k-means clusterer. */\n+    private final KMeansPlusPlusClusterer<T> clusterer;\n+\n+    /** The number of trial runs. */\n+    private final int numTrials;\n+\n+    /** Build a clusterer.\n+     * @param clusterer the k-means clusterer to use\n+     * @param numTrials number of trial runs\n+     */\n+    public MultiKMeansPlusPlusClusterer(final KMeansPlusPlusClusterer<T> clusterer,\n+                                        final int numTrials) {\n+        super(clusterer.getDistanceMeasure());\n+        this.clusterer = clusterer;\n+        this.numTrials = numTrials;\n+    }\n+\n+    /**\n+     * Returns the embedded k-means clusterer used by this instance.\n+     * @return the embedded clusterer\n+     */\n+    public KMeansPlusPlusClusterer<T> getClusterer() {\n+        return clusterer;\n+    }\n+\n+    /**\n+     * Returns the number of trials this instance will do.\n+     * @return the number of trials\n+     */\n+    public int getNumTrials() {\n+        return numTrials;\n+    }\n+\n+    /**\n+     * Runs the K-means++ clustering algorithm.\n+     *\n+     * @param points the points to cluster\n+     * @return a list of clusters containing the points\n+     * @throws MathIllegalArgumentException if the data points are null or the number\n+     *   of clusters is larger than the number of data points\n+     * @throws ConvergenceException if an empty cluster is encountered and the\n+     *   {@link #emptyStrategy} is set to {@code ERROR}\n+     */\n+    public List<CentroidCluster<T>> cluster(final Collection<T> points)\n+        throws MathIllegalArgumentException, ConvergenceException {\n+\n+        // at first, we have not found any clusters list yet\n+        List<CentroidCluster<T>> best = null;\n+        double bestVarianceSum = Double.POSITIVE_INFINITY;\n+\n+        // do several clustering trials\n+        for (int i = 0; i < numTrials; ++i) {\n+\n+            // compute a clusters list\n+            List<CentroidCluster<T>> clusters = clusterer.cluster(points);\n+\n+            // compute the variance of the current list\n+            double varianceSum = 0.0;\n+            for (final CentroidCluster<T> cluster : clusters) {\n+                if (!cluster.getPoints().isEmpty()) {\n+\n+                    // compute the distance variance of the current cluster\n+                    final Clusterable center = cluster.getCenter();\n+                    final Variance stat = new Variance();\n+                    for (final T point : cluster.getPoints()) {\n+                        stat.increment(distance(point, center));\n+                    }\n+                    varianceSum += stat.getResult();\n+\n+                }\n+            }\n+\n+            if (varianceSum <= bestVarianceSum) {\n+                // this one is the best we have found so far, remember it\n+                best            = clusters;\n+                bestVarianceSum = varianceSum;\n+            }\n+\n+        }\n+\n+        // return the best clusters list found\n+        return best;\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/ml/clustering/package-info.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/**\n+ * Clustering algorithms.\n+ */\n+package org.apache.commons.math3.ml.clustering;\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/ml/distance/CanberraDistance.java\n+package org.apache.commons.math3.ml.distance;\n+\n+import org.apache.commons.math3.util.FastMath;\n+\n+/**\n+ * Calculates the Canberra distance between two points.\n+ *\n+ * @version $Id $\n+ * @since 3.2\n+ */\n+public class CanberraDistance implements DistanceMeasure {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -6972277381587032228L;\n+\n+    /** {@inheritDoc} */\n+    public double compute(double[] a, double[] b) {\n+        double sum = 0;\n+        for (int i = 0; i < a.length; i++) {\n+            final double num = FastMath.abs(a[i] - b[i]);\n+            final double denom = FastMath.abs(a[i]) + FastMath.abs(b[i]);\n+            sum += num == 0.0 && denom == 0.0 ? 0.0 : num / denom;\n+        }\n+        return sum;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/ml/distance/ChebyshevDistance.java\n+package org.apache.commons.math3.ml.distance;\n+\n+import org.apache.commons.math3.util.MathArrays;\n+\n+/**\n+ * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.\n+ *\n+ * @version $Id $\n+ * @since 3.2\n+ */\n+public class ChebyshevDistance implements DistanceMeasure {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -4694868171115238296L;\n+\n+    /** {@inheritDoc} */\n+    public double compute(double[] a, double[] b) {\n+        return MathArrays.distanceInf(a, b);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/ml/distance/DistanceMeasure.java\n+package org.apache.commons.math3.ml.distance;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Interface for distance measures of n-dimensional vectors.\n+ *\n+ * @version $Id $\n+ * @since 3.2\n+ */\n+public interface DistanceMeasure extends Serializable {\n+\n+    /**\n+     * Compute the distance between two n-dimensional vectors.\n+     * <p>\n+     * The two vectors are required to have the same dimension.\n+     *\n+     * @param a the first vector\n+     * @param b the second vector\n+     * @return the distance between the two vectors\n+     */\n+    double compute(double[] a, double[] b);\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/ml/distance/EuclideanDistance.java\n+package org.apache.commons.math3.ml.distance;\n+\n+import org.apache.commons.math3.util.MathArrays;\n+\n+/**\n+ * Calculates the L<sub>2</sub> (Euclidean) distance between two points.\n+ *\n+ * @version $Id $\n+ * @since 3.2\n+ */\n+public class EuclideanDistance implements DistanceMeasure {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 1717556319784040040L;\n+\n+    /** {@inheritDoc} */\n+    public double compute(double[] a, double[] b) {\n+        return MathArrays.distance(a, b);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/ml/distance/ManhattanDistance.java\n+package org.apache.commons.math3.ml.distance;\n+\n+import org.apache.commons.math3.util.MathArrays;\n+\n+/**\n+ * Calculates the L<sub>1</sub> (sum of abs) distance between two points.\n+ *\n+ * @version $Id $\n+ * @since 3.2\n+ */\n+public class ManhattanDistance implements DistanceMeasure {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -9108154600539125566L;\n+\n+    /** {@inheritDoc} */\n+    public double compute(double[] a, double[] b) {\n+        return MathArrays.distance1(a, b);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/ml/distance/package-info.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/**\n+ * Common distance measures.\n+ */\n+package org.apache.commons.math3.ml.distance;\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/ml/package-info.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/**\n+ * Base package for machine learning algorithms.\n+ */\n+package org.apache.commons.math3.ml;\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/ml/clustering/DBSCANClustererTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.ml.clustering;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.NullArgumentException;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class DBSCANClustererTest {\n+\n+    @Test\n+    public void testCluster() {\n+        // Test data generated using: http://people.cs.nctu.edu.tw/~rsliang/dbscan/testdatagen.html\n+        final DoublePoint[] points = new DoublePoint[] {\n+                new DoublePoint(new double[] { 83.08303244924173, 58.83387754182331 }),\n+                new DoublePoint(new double[] { 45.05445510940626, 23.469642649637535 }),\n+                new DoublePoint(new double[] { 14.96417921432294, 69.0264096390456 }),\n+                new DoublePoint(new double[] { 73.53189604333602, 34.896145021310076 }),\n+                new DoublePoint(new double[] { 73.28498173551634, 33.96860806993209 }),\n+                new DoublePoint(new double[] { 73.45828098873608, 33.92584423092194 }),\n+                new DoublePoint(new double[] { 73.9657889183145, 35.73191006924026 }),\n+                new DoublePoint(new double[] { 74.0074097183533, 36.81735596177168 }),\n+                new DoublePoint(new double[] { 73.41247541410848, 34.27314856695011 }),\n+                new DoublePoint(new double[] { 73.9156256353017, 36.83206791547127 }),\n+                new DoublePoint(new double[] { 74.81499205809087, 37.15682749846019 }),\n+                new DoublePoint(new double[] { 74.03144880081527, 37.57399178552441 }),\n+                new DoublePoint(new double[] { 74.51870941207744, 38.674258946906775 }),\n+                new DoublePoint(new double[] { 74.50754595105536, 35.58903978415765 }),\n+                new DoublePoint(new double[] { 74.51322752749547, 36.030572259100154 }),\n+                new DoublePoint(new double[] { 59.27900996617973, 46.41091720294207 }),\n+                new DoublePoint(new double[] { 59.73744793841615, 46.20015558367595 }),\n+                new DoublePoint(new double[] { 58.81134076672606, 45.71150126331486 }),\n+                new DoublePoint(new double[] { 58.52225539437495, 47.416083617601544 }),\n+                new DoublePoint(new double[] { 58.218626647023484, 47.36228902172297 }),\n+                new DoublePoint(new double[] { 60.27139669447206, 46.606106348801404 }),\n+                new DoublePoint(new double[] { 60.894962462363765, 46.976924697402865 }),\n+                new DoublePoint(new double[] { 62.29048673878424, 47.66970563563518 }),\n+                new DoublePoint(new double[] { 61.03857608977705, 46.212924720020965 }),\n+                new DoublePoint(new double[] { 60.16916214139201, 45.18193661351688 }),\n+                new DoublePoint(new double[] { 59.90036905976012, 47.555364347063005 }),\n+                new DoublePoint(new double[] { 62.33003634144552, 47.83941489877179 }),\n+                new DoublePoint(new double[] { 57.86035536718555, 47.31117930193432 }),\n+                new DoublePoint(new double[] { 58.13715479685925, 48.985960494028404 }),\n+                new DoublePoint(new double[] { 56.131923963548616, 46.8508904252667 }),\n+                new DoublePoint(new double[] { 55.976329887053, 47.46384037658572 }),\n+                new DoublePoint(new double[] { 56.23245975235477, 47.940035191131756 }),\n+                new DoublePoint(new double[] { 58.51687048212625, 46.622885352699086 }),\n+                new DoublePoint(new double[] { 57.85411081905477, 45.95394361577928 }),\n+                new DoublePoint(new double[] { 56.445776311447844, 45.162093662656844 }),\n+                new DoublePoint(new double[] { 57.36691949656233, 47.50097194337286 }),\n+                new DoublePoint(new double[] { 58.243626387557015, 46.114052729681134 }),\n+                new DoublePoint(new double[] { 56.27224595635198, 44.799080066150054 }),\n+                new DoublePoint(new double[] { 57.606924816500396, 46.94291057763621 }),\n+                new DoublePoint(new double[] { 30.18714230041951, 13.877149710431695 }),\n+                new DoublePoint(new double[] { 30.449448810657486, 13.490778346545994 }),\n+                new DoublePoint(new double[] { 30.295018390286714, 13.264889000216499 }),\n+                new DoublePoint(new double[] { 30.160201832884923, 11.89278262341395 }),\n+                new DoublePoint(new double[] { 31.341509791789576, 15.282655921997502 }),\n+                new DoublePoint(new double[] { 31.68601630325429, 14.756873246748 }),\n+                new DoublePoint(new double[] { 29.325963742565364, 12.097849250072613 }),\n+                new DoublePoint(new double[] { 29.54820742388256, 13.613295356975868 }),\n+                new DoublePoint(new double[] { 28.79359608888626, 10.36352064087987 }),\n+                new DoublePoint(new double[] { 31.01284597092308, 12.788479208014905 }),\n+                new DoublePoint(new double[] { 27.58509216737002, 11.47570110601373 }),\n+                new DoublePoint(new double[] { 28.593799561727792, 10.780998203903437 }),\n+                new DoublePoint(new double[] { 31.356105766724795, 15.080316198524088 }),\n+                new DoublePoint(new double[] { 31.25948503636755, 13.674329151166603 }),\n+                new DoublePoint(new double[] { 32.31590076372959, 14.95261758659035 }),\n+                new DoublePoint(new double[] { 30.460413702763617, 15.88402809202671 }),\n+                new DoublePoint(new double[] { 32.56178203062154, 14.586076852632686 }),\n+                new DoublePoint(new double[] { 32.76138648530468, 16.239837325178087 }),\n+                new DoublePoint(new double[] { 30.1829453331884, 14.709592407103628 }),\n+                new DoublePoint(new double[] { 29.55088173528202, 15.0651247180067 }),\n+                new DoublePoint(new double[] { 29.004155302187428, 14.089665298582986 }),\n+                new DoublePoint(new double[] { 29.339624439831823, 13.29096065578051 }),\n+                new DoublePoint(new double[] { 30.997460327576846, 14.551914158277214 }),\n+                new DoublePoint(new double[] { 30.66784126125276, 16.269703107886016 })\n+        };\n+\n+        final DBSCANClusterer<DoublePoint> transformer =\n+                new DBSCANClusterer<DoublePoint>(2.0, 5);\n+        final List<Cluster<DoublePoint>> clusters = transformer.cluster(Arrays.asList(points));\n+\n+        final List<DoublePoint> clusterOne =\n+                Arrays.asList(points[3], points[4], points[5], points[6], points[7], points[8], points[9], points[10],\n+                              points[11], points[12], points[13], points[14]);\n+        final List<DoublePoint> clusterTwo =\n+                Arrays.asList(points[15], points[16], points[17], points[18], points[19], points[20], points[21],\n+                              points[22], points[23], points[24], points[25], points[26], points[27], points[28],\n+                              points[29], points[30], points[31], points[32], points[33], points[34], points[35],\n+                              points[36], points[37], points[38]);\n+        final List<DoublePoint> clusterThree =\n+                Arrays.asList(points[39], points[40], points[41], points[42], points[43], points[44], points[45],\n+                              points[46], points[47], points[48], points[49], points[50], points[51], points[52],\n+                              points[53], points[54], points[55], points[56], points[57], points[58], points[59],\n+                              points[60], points[61], points[62]);\n+\n+        boolean cluster1Found = false;\n+        boolean cluster2Found = false;\n+        boolean cluster3Found = false;\n+        Assert.assertEquals(3, clusters.size());\n+        for (final Cluster<DoublePoint> cluster : clusters) {\n+            if (cluster.getPoints().containsAll(clusterOne)) {\n+                cluster1Found = true;\n+            }\n+            if (cluster.getPoints().containsAll(clusterTwo)) {\n+                cluster2Found = true;\n+            }\n+            if (cluster.getPoints().containsAll(clusterThree)) {\n+                cluster3Found = true;\n+            }\n+        }\n+        Assert.assertTrue(cluster1Found);\n+        Assert.assertTrue(cluster2Found);\n+        Assert.assertTrue(cluster3Found);\n+    }\n+\n+    @Test\n+    public void testSingleLink() {\n+        final DoublePoint[] points = {\n+                new DoublePoint(new int[] {10, 10}), // A\n+                new DoublePoint(new int[] {12, 9}),\n+                new DoublePoint(new int[] {10, 8}),\n+                new DoublePoint(new int[] {8, 8}),\n+                new DoublePoint(new int[] {8, 6}),\n+                new DoublePoint(new int[] {7, 7}),\n+                new DoublePoint(new int[] {5, 6}),  // B\n+                new DoublePoint(new int[] {14, 8}), // C\n+                new DoublePoint(new int[] {7, 15}), // N - Noise, should not be present\n+                new DoublePoint(new int[] {17, 8}), // D - single-link connected to C should not be present\n+                \n+        };\n+        \n+        final DBSCANClusterer<DoublePoint> clusterer = new DBSCANClusterer<DoublePoint>(3, 3);\n+        List<Cluster<DoublePoint>> clusters = clusterer.cluster(Arrays.asList(points));\n+        \n+        Assert.assertEquals(1, clusters.size());\n+        \n+        final List<DoublePoint> clusterOne =\n+                Arrays.asList(points[0], points[1], points[2], points[3], points[4], points[5], points[6], points[7]);\n+        Assert.assertTrue(clusters.get(0).getPoints().containsAll(clusterOne));\n+    }\n+    \n+    @Test\n+    public void testGetEps() {\n+        final DBSCANClusterer<DoublePoint> transformer = new DBSCANClusterer<DoublePoint>(2.0, 5);\n+        Assert.assertEquals(2.0, transformer.getEps(), 0.0);\n+    }\n+\n+    @Test\n+    public void testGetMinPts() {\n+        final DBSCANClusterer<DoublePoint> transformer = new DBSCANClusterer<DoublePoint>(2.0, 5);\n+        Assert.assertEquals(5, transformer.getMinPts());\n+    }\n+\n+    @Test(expected = MathIllegalArgumentException.class)\n+    public void testNegativeEps() {\n+        new DBSCANClusterer<DoublePoint>(-2.0, 5);\n+    }\n+\n+    @Test(expected = MathIllegalArgumentException.class)\n+    public void testNegativeMinPts() {\n+        new DBSCANClusterer<DoublePoint>(2.0, -5);\n+    }\n+\n+    @Test(expected = NullArgumentException.class)\n+    public void testNullDataset() {\n+        DBSCANClusterer<DoublePoint> clusterer = new DBSCANClusterer<DoublePoint>(2.0, 5);\n+        clusterer.cluster(null);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/ml/clustering/KMeansPlusPlusClustererTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.ml.clustering;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n+import org.apache.commons.math3.ml.distance.EuclideanDistance;\n+import org.apache.commons.math3.random.JDKRandomGenerator;\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class KMeansPlusPlusClustererTest {\n+\n+    private RandomGenerator random;\n+\n+    @Before\n+    public void setUp() {\n+        random = new JDKRandomGenerator();\n+        random.setSeed(1746432956321l);        \n+    }\n+\n+    /**\n+     * JIRA: MATH-305\n+     *\n+     * Two points, one cluster, one iteration\n+     */\n+    @Test\n+    public void testPerformClusterAnalysisDegenerate() {\n+        KMeansPlusPlusClusterer<DoublePoint> transformer =\n+                new KMeansPlusPlusClusterer<DoublePoint>(1, 1);\n+\n+        DoublePoint[] points = new DoublePoint[] {\n+                new DoublePoint(new int[] { 1959, 325100 }),\n+                new DoublePoint(new int[] { 1960, 373200 }), };\n+        List<? extends Cluster<DoublePoint>> clusters = transformer.cluster(Arrays.asList(points));\n+        Assert.assertEquals(1, clusters.size());\n+        Assert.assertEquals(2, (clusters.get(0).getPoints().size()));\n+        DoublePoint pt1 = new DoublePoint(new int[] { 1959, 325100 });\n+        DoublePoint pt2 = new DoublePoint(new int[] { 1960, 373200 });\n+        Assert.assertTrue(clusters.get(0).getPoints().contains(pt1));\n+        Assert.assertTrue(clusters.get(0).getPoints().contains(pt2));\n+\n+    }\n+\n+    @Test\n+    public void testCertainSpace() {\n+        KMeansPlusPlusClusterer.EmptyClusterStrategy[] strategies = {\n+            KMeansPlusPlusClusterer.EmptyClusterStrategy.LARGEST_VARIANCE,\n+            KMeansPlusPlusClusterer.EmptyClusterStrategy.LARGEST_POINTS_NUMBER,\n+            KMeansPlusPlusClusterer.EmptyClusterStrategy.FARTHEST_POINT\n+        };\n+        for (KMeansPlusPlusClusterer.EmptyClusterStrategy strategy : strategies) {\n+            int numberOfVariables = 27;\n+            // initialise testvalues\n+            int position1 = 1;\n+            int position2 = position1 + numberOfVariables;\n+            int position3 = position2 + numberOfVariables;\n+            int position4 = position3 + numberOfVariables;\n+            // testvalues will be multiplied\n+            int multiplier = 1000000;\n+\n+            DoublePoint[] breakingPoints = new DoublePoint[numberOfVariables];\n+            // define the space which will break the cluster algorithm\n+            for (int i = 0; i < numberOfVariables; i++) {\n+                int points[] = { position1, position2, position3, position4 };\n+                // multiply the values\n+                for (int j = 0; j < points.length; j++) {\n+                    points[j] = points[j] * multiplier;\n+                }\n+                DoublePoint DoublePoint = new DoublePoint(points);\n+                breakingPoints[i] = DoublePoint;\n+                position1 = position1 + numberOfVariables;\n+                position2 = position2 + numberOfVariables;\n+                position3 = position3 + numberOfVariables;\n+                position4 = position4 + numberOfVariables;\n+            }\n+\n+            for (int n = 2; n < 27; ++n) {\n+                KMeansPlusPlusClusterer<DoublePoint> transformer =\n+                    new KMeansPlusPlusClusterer<DoublePoint>(n, 100, new EuclideanDistance(), random, strategy);\n+\n+                List<? extends Cluster<DoublePoint>> clusters =\n+                        transformer.cluster(Arrays.asList(breakingPoints));\n+\n+                Assert.assertEquals(n, clusters.size());\n+                int sum = 0;\n+                for (Cluster<DoublePoint> cluster : clusters) {\n+                    sum += cluster.getPoints().size();\n+                }\n+                Assert.assertEquals(numberOfVariables, sum);\n+            }\n+        }\n+\n+    }\n+\n+    /**\n+     * A helper class for testSmallDistances(). This class is similar to DoublePoint, but\n+     * it defines a different distanceFrom() method that tends to return distances less than 1.\n+     */\n+    private class CloseDistance extends EuclideanDistance {\n+        private static final long serialVersionUID = 1L;\n+\n+        @Override\n+        public double compute(double[] a, double[] b) {\n+            return super.compute(a, b) * 0.001;\n+        }\n+    }\n+\n+    /**\n+     * Test points that are very close together. See issue MATH-546.\n+     */\n+    @Test\n+    public void testSmallDistances() {\n+        // Create a bunch of CloseDoublePoints. Most are identical, but one is different by a\n+        // small distance.\n+        int[] repeatedArray = { 0 };\n+        int[] uniqueArray = { 1 };\n+        DoublePoint repeatedPoint = new DoublePoint(repeatedArray);\n+        DoublePoint uniquePoint = new DoublePoint(uniqueArray);\n+\n+        Collection<DoublePoint> points = new ArrayList<DoublePoint>();\n+        final int NUM_REPEATED_POINTS = 10 * 1000;\n+        for (int i = 0; i < NUM_REPEATED_POINTS; ++i) {\n+            points.add(repeatedPoint);\n+        }\n+        points.add(uniquePoint);\n+\n+        // Ask a KMeansPlusPlusClusterer to run zero iterations (i.e., to simply choose initial\n+        // cluster centers).\n+        final long RANDOM_SEED = 0;\n+        final int NUM_CLUSTERS = 2;\n+        final int NUM_ITERATIONS = 0;\n+        random.setSeed(RANDOM_SEED);\n+        \n+        KMeansPlusPlusClusterer<DoublePoint> clusterer =\n+            new KMeansPlusPlusClusterer<DoublePoint>(NUM_CLUSTERS, NUM_ITERATIONS,\n+                    new CloseDistance(), random);\n+        List<CentroidCluster<DoublePoint>> clusters = clusterer.cluster(points);\n+\n+        // Check that one of the chosen centers is the unique point.\n+        boolean uniquePointIsCenter = false;\n+        for (CentroidCluster<DoublePoint> cluster : clusters) {\n+            if (cluster.getCenter().equals(uniquePoint)) {\n+                uniquePointIsCenter = true;\n+            }\n+        }\n+        Assert.assertTrue(uniquePointIsCenter);\n+    }\n+    \n+    /**\n+     * 2 variables cannot be clustered into 3 clusters. See issue MATH-436.\n+     */\n+    @Test(expected=NumberIsTooSmallException.class)\n+    public void testPerformClusterAnalysisToManyClusters() {\n+        KMeansPlusPlusClusterer<DoublePoint> transformer = \n+            new KMeansPlusPlusClusterer<DoublePoint>(3, 1, new EuclideanDistance(), random);\n+        \n+        DoublePoint[] points = new DoublePoint[] {\n+            new DoublePoint(new int[] {\n+                1959, 325100\n+            }), new DoublePoint(new int[] {\n+                1960, 373200\n+            })\n+        };\n+        \n+        transformer.cluster(Arrays.asList(points));\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/ml/clustering/MultiKMeansPlusPlusClustererTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.ml.clustering;\n+\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class MultiKMeansPlusPlusClustererTest {\n+\n+    @Test\n+    public void dimension2() {\n+        MultiKMeansPlusPlusClusterer<DoublePoint> transformer =\n+            new MultiKMeansPlusPlusClusterer<DoublePoint>(\n+                    new KMeansPlusPlusClusterer<DoublePoint>(3, 10), 5);\n+        \n+        DoublePoint[] points = new DoublePoint[] {\n+\n+                // first expected cluster\n+                new DoublePoint(new int[] { -15,  3 }),\n+                new DoublePoint(new int[] { -15,  4 }),\n+                new DoublePoint(new int[] { -15,  5 }),\n+                new DoublePoint(new int[] { -14,  3 }),\n+                new DoublePoint(new int[] { -14,  5 }),\n+                new DoublePoint(new int[] { -13,  3 }),\n+                new DoublePoint(new int[] { -13,  4 }),\n+                new DoublePoint(new int[] { -13,  5 }),\n+\n+                // second expected cluster\n+                new DoublePoint(new int[] { -1,  0 }),\n+                new DoublePoint(new int[] { -1, -1 }),\n+                new DoublePoint(new int[] {  0, -1 }),\n+                new DoublePoint(new int[] {  1, -1 }),\n+                new DoublePoint(new int[] {  1, -2 }),\n+\n+                // third expected cluster\n+                new DoublePoint(new int[] { 13,  3 }),\n+                new DoublePoint(new int[] { 13,  4 }),\n+                new DoublePoint(new int[] { 14,  4 }),\n+                new DoublePoint(new int[] { 14,  7 }),\n+                new DoublePoint(new int[] { 16,  5 }),\n+                new DoublePoint(new int[] { 16,  6 }),\n+                new DoublePoint(new int[] { 17,  4 }),\n+                new DoublePoint(new int[] { 17,  7 })\n+\n+        };\n+        List<CentroidCluster<DoublePoint>> clusters = transformer.cluster(Arrays.asList(points));\n+\n+        Assert.assertEquals(3, clusters.size());\n+        boolean cluster1Found = false;\n+        boolean cluster2Found = false;\n+        boolean cluster3Found = false;\n+        double epsilon = 1e-6;\n+        for (CentroidCluster<DoublePoint> cluster : clusters) {\n+            Clusterable center = cluster.getCenter();\n+            double[] point = center.getPoint();\n+            if (point[0] < 0) {\n+                cluster1Found = true;\n+                Assert.assertEquals(8, cluster.getPoints().size());\n+                Assert.assertEquals(-14, point[0], epsilon);\n+                Assert.assertEquals( 4, point[1], epsilon);\n+            } else if (point[1] < 0) {\n+                cluster2Found = true;\n+                Assert.assertEquals(5, cluster.getPoints().size());\n+                Assert.assertEquals( 0, point[0], epsilon);\n+                Assert.assertEquals(-1, point[1], epsilon);\n+            } else {\n+                cluster3Found = true;\n+                Assert.assertEquals(8, cluster.getPoints().size());\n+                Assert.assertEquals(15, point[0], epsilon);\n+                Assert.assertEquals(5, point[1], epsilon);\n+            }\n+        }\n+        Assert.assertTrue(cluster1Found);\n+        Assert.assertTrue(cluster2Found);\n+        Assert.assertTrue(cluster3Found);\n+\n+    }\n+\n+}", "timestamp": 1364420890, "metainfo": ""}