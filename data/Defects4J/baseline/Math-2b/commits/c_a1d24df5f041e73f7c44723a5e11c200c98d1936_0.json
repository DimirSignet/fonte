{"sha": "a1d24df5f041e73f7c44723a5e11c200c98d1936", "log": "[MATH-968] Added ParetoDistribution.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/distribution/ParetoDistribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.distribution;\n+\n+import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math3.exception.NumberIsTooLargeException;\n+import org.apache.commons.math3.exception.util.LocalizedFormats;\n+import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.random.RandomGenerator;\n+import org.apache.commons.math3.random.Well19937c;\n+\n+/**\n+ * Implementation of the Pareto distribution.\n+ *\n+ * <p>\n+ * <strong>Parameters:</strong>\n+ * The probability distribution function of {@code X} is given by (for {@code x >= k}):\n+ * <pre>\n+ *  \u03b1 * k^\u03b1 / x^(\u03b1 + 1)\n+ * </pre>\n+ * <p>\n+ * <ul>\n+ * <li>{@code k} is the <em>scale</em> parameter: this is the minimum possible value of {@code X},</li>\n+ * <li>{@code \u03b1} is the <em>shape</em> parameter: this is the Pareto index</li>\n+ * </ul>\n+ *\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Pareto_distribution\">\n+ * Pareto distribution (Wikipedia)</a>\n+ * @see <a href=\"http://mathworld.wolfram.com/ParetoDistribution.html\">\n+ * Pareto distribution (MathWorld)</a>\n+ *\n+ * @version $Id$\n+ * @since 4.0\n+ */\n+public class ParetoDistribution extends AbstractRealDistribution {\n+\n+    /** Default inverse cumulative probability accuracy. */\n+    public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 20130424;\n+\n+    /** The scale parameter of this distribution. */\n+    private final double scale;\n+\n+    /** The shape parameter of this distribution. */\n+    private final double shape;\n+\n+    /** Inverse cumulative probability accuracy. */\n+    private final double solverAbsoluteAccuracy;\n+\n+    /**\n+     * Create a Pareto distribution with a scale of {@code 1} and a shape of {@code 1}.\n+     */\n+    public ParetoDistribution() {\n+        this(1, 1);\n+    }\n+\n+    /**\n+     * Create a Pareto distribution using the specified scale and shape.\n+     *\n+     * @param scale the scale parameter of this distribution\n+     * @param shape the shape parameter of this distribution\n+     * @throws NotStrictlyPositiveException if {@code scale <= 0} or {@code shape <= 0}.\n+     */\n+    public ParetoDistribution(double scale, double shape)\n+        throws NotStrictlyPositiveException {\n+        this(scale, shape, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n+    }\n+\n+    /**\n+     * Create a Pareto distribution using the specified scale, shape and\n+     * inverse cumulative distribution accuracy.\n+     *\n+     * @param scale the scale parameter of this distribution\n+     * @param shape the shape parameter of this distribution\n+     * @param inverseCumAccuracy Inverse cumulative probability accuracy.\n+     * @throws NotStrictlyPositiveException if {@code scale <= 0} or {@code shape <= 0}.\n+     */\n+    public ParetoDistribution(double scale, double shape, double inverseCumAccuracy)\n+        throws NotStrictlyPositiveException {\n+        this(new Well19937c(), scale, shape, inverseCumAccuracy);\n+    }\n+\n+    /**\n+     * Creates a log-normal distribution.\n+     *\n+     * @param rng Random number generator.\n+     * @param scale Scale parameter of this distribution.\n+     * @param shape Shape parameter of this distribution.\n+     * @param inverseCumAccuracy Inverse cumulative probability accuracy.\n+     * @throws NotStrictlyPositiveException if {@code scale <= 0} or {@code shape <= 0}.\n+     */\n+    public ParetoDistribution(RandomGenerator rng,\n+                              double scale,\n+                              double shape,\n+                              double inverseCumAccuracy)\n+        throws NotStrictlyPositiveException {\n+        super(rng);\n+\n+        if (scale <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.SCALE, scale);\n+        }\n+\n+        if (shape <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.SHAPE, shape);\n+        }\n+\n+        this.scale = scale;\n+        this.shape = shape;\n+        this.solverAbsoluteAccuracy = inverseCumAccuracy;\n+    }\n+\n+    /**\n+     * Returns the scale parameter of this distribution.\n+     *\n+     * @return the scale parameter\n+     */\n+    public double getScale() {\n+        return scale;\n+    }\n+\n+    /**\n+     * Returns the shape parameter of this distribution.\n+     *\n+     * @return the shape parameter\n+     */\n+    public double getShape() {\n+        return shape;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * <p>\n+     * For scale {@code k}, and shape {@code \u03b1} of this distribution, the PDF\n+     * is given by\n+     * <ul>\n+     * <li>{@code 0} if {@code x < k},</li>\n+     * <li>{@code \u03b1 * k^\u03b1 / x^(\u03b1 + 1)} otherwise.</li>\n+     * </ul>\n+     */\n+    public double density(double x) {\n+        if (x < scale) {\n+            return 0;\n+        }\n+        return FastMath.pow(scale, shape) / FastMath.pow(x, shape + 1) * shape;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * <p>\n+     * For scale {@code k}, and shape {@code \u03b1} of this distribution, the CDF is given by\n+     * <ul>\n+     * <li>{@code 0} if {@code x < k},</li>\n+     * <li>{@code 1 - (k / x)^\u03b1} otherwise.</li>\n+     * </ul>\n+     */\n+    public double cumulativeProbability(double x)  {\n+        if (x <= scale) {\n+            return 0;\n+        }\n+        return 1 - FastMath.pow(scale / x, shape);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @deprecated See {@link RealDistribution#cumulativeProbability(double,double)}\n+     */\n+    @Override\n+    @Deprecated\n+    public double cumulativeProbability(double x0, double x1)\n+        throws NumberIsTooLargeException {\n+        return probability(x0, x1);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getSolverAbsoluteAccuracy() {\n+        return solverAbsoluteAccuracy;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * <p>\n+     * For scale {@code k} and shape {@code \u03b1}, the mean is given by\n+     * <ul>\n+     * <li>{@code \u221e} if {@code \u03b1 <= 1},</li>\n+     * <li>{@code \u03b1 * k / (\u03b1 - 1)} otherwise.</li>\n+     * </ul>\n+     */\n+    public double getNumericalMean() {\n+        if (shape <= 1) {\n+            return Double.POSITIVE_INFINITY;\n+        }\n+        return shape * scale / (shape - 1);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * <p>\n+     * For scale {@code k} and shape {@code \u03b1}, the variance is given by\n+     * <ul>\n+     * <li>{@code \u221e} if {@code 1 < \u03b1 <= 2},</li>\n+     * <li>{@code k^2 * \u03b1 / ((\u03b1 - 1)^2 * (\u03b1 - 2))} otherwise.</li>\n+     * </ul>\n+     */\n+    public double getNumericalVariance() {\n+        if (shape <= 2) {\n+            return Double.POSITIVE_INFINITY;\n+        }\n+        double s = shape - 1;\n+        return scale * scale * shape / (s * s) / (shape - 2);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * <p>\n+     * The lower bound of the support is equal to the scale parameter {@code k}.\n+     *\n+     * @return lower bound of the support\n+     */\n+    public double getSupportLowerBound() {\n+        return scale;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * <p>\n+     * The upper bound of the support is always positive infinity no matter the parameters.\n+     *\n+     * @return upper bound of the support (always {@code Double.POSITIVE_INFINITY})\n+     */\n+    public double getSupportUpperBound() {\n+        return Double.POSITIVE_INFINITY;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isSupportLowerBoundInclusive() {\n+        return true;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isSupportUpperBoundInclusive() {\n+        return false;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * <p>\n+     * The support of this distribution is connected.\n+     *\n+     * @return {@code true}\n+     */\n+    public boolean isSupportConnected() {\n+        return true;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double sample()  {\n+        final double n = random.nextDouble();\n+        return scale / FastMath.pow(n, 1 / shape);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/distribution/ParetoDistributionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.distribution;\n+\n+import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Test cases for {@link ParetoDistribution}.\n+ * <p>\n+ * Extends {@link RealDistributionAbstractTest}. See class javadoc of that class for details.\n+ *\n+ * @version $Id$\n+ * @since 4.0\n+ */\n+public class ParetoDistributionTest extends RealDistributionAbstractTest {\n+\n+    //-------------- Implementations for abstract methods -----------------------\n+\n+    /** Creates the default real distribution instance to use in tests. */\n+    @Override\n+    public ParetoDistribution makeDistribution() {\n+        return new ParetoDistribution(2.1, 1.4);\n+    }\n+\n+    /** Creates the default cumulative probability distribution test input values */\n+    @Override\n+    public double[] makeCumulativeTestPoints() {\n+        // quantiles computed using R\n+        return new double[] { -2.226325228634938, -1.156887023657177, -0.643949578356075, -0.2027950777320613, 0.305827808237559,\n+                              +6.42632522863494, 5.35688702365718, 4.843949578356074, 4.40279507773206, 3.89417219176244 };\n+    }\n+\n+    /** Creates the default cumulative probability density test expected values */\n+    @Override\n+    public double[] makeCumulativeTestValues() {\n+        return new double[] { 0, 0, 0, 0, 0, 0.791089998892, 0.730456085931, 0.689667290488, 0.645278794701, 0.578763688757 };\n+    }\n+\n+    /** Creates the default probability density test expected values */\n+    @Override\n+    public double[] makeDensityTestValues() {\n+        return new double[] { 0, 0, 0, 0, 0, 0.0455118580441, 0.070444173646, 0.0896924681582, 0.112794186114, 0.151439332084 };\n+    }\n+\n+    /**\n+     * Creates the default inverse cumulative probability distribution test input values.\n+     */\n+    @Override\n+    public double[] makeInverseCumulativeTestPoints() {\n+        // Exclude the test points less than zero, as they have cumulative\n+        // probability of zero, meaning the inverse returns zero, and not the\n+        // points less than zero.\n+        double[] points = makeCumulativeTestValues();\n+        double[] points2 = new double[points.length - 5];\n+        System.arraycopy(points, 5, points2, 0, points.length - 5);\n+        return points2;\n+    }\n+\n+    /**\n+     * Creates the default inverse cumulative probability test expected values.\n+     */\n+    @Override\n+    public double[] makeInverseCumulativeTestValues() {\n+        // Exclude the test points less than zero, as they have cumulative\n+        // probability of zero, meaning the inverse returns zero, and not the\n+        // points less than zero.\n+        double[] points = makeCumulativeTestPoints();\n+        double[] points2 = new double[points.length - 5];\n+        System.arraycopy(points, 5, points2, 0, points.length - 5);\n+        return points2;\n+    }\n+\n+    // --------------------- Override tolerance  --------------\n+    @Override\n+    public void setUp() {\n+        super.setUp();\n+        setTolerance(ParetoDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n+    }\n+\n+    //---------------------------- Additional test cases -------------------------\n+\n+    private void verifyQuantiles() {\n+        ParetoDistribution distribution = (ParetoDistribution)getDistribution();\n+        double mu = distribution.getScale();\n+        double sigma = distribution.getShape();\n+        setCumulativeTestPoints( new double[] { mu - 2 *sigma,  mu - sigma,\n+                                                mu,             mu + sigma,\n+                                                mu + 2 * sigma, mu + 3 * sigma,\n+                                                mu + 4 * sigma, mu + 5 * sigma });\n+        verifyCumulativeProbabilities();\n+    }\n+\n+    @Test\n+    public void testQuantiles() {\n+        setCumulativeTestValues(new double[] {0, 0, 0, 0.510884134236, 0.694625688662, 0.785201995008, 0.837811522357, 0.871634279326});\n+        setDensityTestValues(new double[] {0, 0, 0.666666666, 0.195646346305, 0.0872498032394, 0.0477328899983, 0.0294888141169, 0.0197485724114});\n+        verifyQuantiles();\n+        verifyDensities();\n+\n+        setDistribution(new ParetoDistribution(1, 1));\n+        setCumulativeTestValues(new double[] {0, 0, 0, 0.5, 0.666666666667, 0.75, 0.8, 0.833333333333});\n+        setDensityTestValues(new double[] {0, 0, 1.0, 0.25, 0.111111111111, 0.0625, 0.04, 0.0277777777778});\n+        verifyQuantiles();\n+        verifyDensities();\n+\n+        setDistribution(new ParetoDistribution(0.1, 0.1));\n+        setCumulativeTestValues(new double[] {0, 0, 0, 0.0669670084632, 0.104041540159, 0.129449436704, 0.148660077479, 0.164041197922});\n+        setDensityTestValues(new double[] {0, 0, 1.0, 0.466516495768, 0.298652819947, 0.217637640824, 0.170267984504, 0.139326467013});\n+        verifyQuantiles();\n+        verifyDensities();\n+    }\n+\n+    @Test\n+    public void testInverseCumulativeProbabilityExtremes() {\n+        setInverseCumulativeTestPoints(new double[] {0, 1});\n+        setInverseCumulativeTestValues(new double[] {2.1, Double.POSITIVE_INFINITY});\n+        verifyInverseCumulativeProbabilities();\n+    }\n+\n+    @Test\n+    public void testGetScale() {\n+        ParetoDistribution distribution = (ParetoDistribution)getDistribution();\n+        Assert.assertEquals(2.1, distribution.getScale(), 0);\n+    }\n+\n+    @Test\n+    public void testGetShape() {\n+        ParetoDistribution distribution = (ParetoDistribution)getDistribution();\n+        Assert.assertEquals(1.4, distribution.getShape(), 0);\n+    }\n+\n+    @Test(expected=NotStrictlyPositiveException.class)\n+    public void testPreconditions() {\n+        new ParetoDistribution(1, 0);\n+    }\n+\n+    @Test\n+    public void testDensity() {\n+        double [] x = new double[]{-2, -1, 0, 1, 2};\n+        // R 2.14: print(dpareto(c(-2,-1,0,1,2), scale=1, shape=1), digits=10)\n+        checkDensity(1, 1, x, new double[] { 0.00, 0.00, 0.00, 1.00, 0.25 });\n+        // R 2.14: print(dpareto(c(-2,-1,0,1,2), scale=1.1, shape=1), digits=10)\n+        checkDensity(1.1, 1, x, new double[] { 0.000, 0.000, 0.000, 0.000, 0.275 });\n+    }\n+\n+    private void checkDensity(double scale, double shape, double[] x,\n+        double[] expected) {\n+        ParetoDistribution d = new ParetoDistribution(scale, shape);\n+        for (int i = 0; i < x.length; i++) {\n+            Assert.assertEquals(expected[i], d.density(x[i]), 1e-9);\n+        }\n+    }\n+\n+    /**\n+     * Check to make sure top-coding of extreme values works correctly.\n+     */\n+    @Test\n+    public void testExtremeValues() {\n+        ParetoDistribution d = new ParetoDistribution(1, 1);\n+        for (int i = 0; i < 1e5; i++) { // make sure no convergence exception\n+            double upperTail = d.cumulativeProbability(i);\n+            if (i <= 1000) { // make sure not top-coded\n+                Assert.assertTrue(upperTail < 1.0d);\n+            }\n+            else { // make sure top coding not reversed\n+                Assert.assertTrue(upperTail > 0.999);\n+            }\n+        }\n+\n+        Assert.assertEquals(d.cumulativeProbability(Double.MAX_VALUE), 1, 0);\n+        Assert.assertEquals(d.cumulativeProbability(-Double.MAX_VALUE), 0, 0);\n+        Assert.assertEquals(d.cumulativeProbability(Double.POSITIVE_INFINITY), 1, 0);\n+        Assert.assertEquals(d.cumulativeProbability(Double.NEGATIVE_INFINITY), 0, 0);\n+    }\n+\n+    @Test\n+    public void testMeanVariance() {\n+        final double tol = 1e-9;\n+        ParetoDistribution dist;\n+\n+        dist = new ParetoDistribution(1, 1);\n+        Assert.assertEquals(dist.getNumericalMean(), Double.POSITIVE_INFINITY, tol);\n+        Assert.assertEquals(dist.getNumericalVariance(), Double.POSITIVE_INFINITY, tol);\n+\n+        dist = new ParetoDistribution(2.2, 2.4);\n+        Assert.assertEquals(dist.getNumericalMean(), 3.771428571428, tol);\n+        Assert.assertEquals(dist.getNumericalVariance(), 14.816326530, tol);\n+    }\n+}", "timestamp": 1367957392, "metainfo": ""}