{"sha": "733ec7c74bb8db825235ce5aa8695d5341ca508b", "log": "[MATH-826] Added SobolSequenceGenerator.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/random/SobolSequenceGenerator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.random;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.Arrays;\n+import java.util.NoSuchElementException;\n+import java.util.StringTokenizer;\n+\n+import org.apache.commons.math3.exception.MathInternalError;\n+import org.apache.commons.math3.exception.MathParseException;\n+import org.apache.commons.math3.exception.NotPositiveException;\n+import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math3.exception.OutOfRangeException;\n+import org.apache.commons.math3.util.FastMath;\n+\n+/**\n+ * Implementation of a Sobol sequence.\n+ * <p>\n+ * A Sobol sequence is a low-discrepancy sequence with the property that for all values of N,\n+ * its subsequence (x1, ... xN) has a low discrepancy. It can be used to generate pseudo-random\n+ * points in a space S, which are equi-distributed.\n+ * <p>\n+ * The implementation already comes with support for up to 1000 dimensions with direction numbers\n+ * calculated from <a href=\"http://web.maths.unsw.edu.au/~fkuo/sobol/\">Stephen Joe and Frances Kuo</a>.\n+ * <p>\n+ * The generator supports two modes:\n+ * <ul>\n+ *   <li>sequential generation of points: {@link #nextVector()}</li>\n+ *   <li>random access to the i-th point in the sequence: {@link #skipTo(int)}</li>\n+ * </ul>\n+ *\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Sobol_sequence\">Sobol sequence (Wikipedia)</a>\n+ * @see <a href=\"http://web.maths.unsw.edu.au/~fkuo/sobol/\">Sobol sequence direction numbers</a>\n+ *\n+ * @version $Id$\n+ * @since 4.0\n+ */\n+public class SobolSequenceGenerator implements RandomVectorGenerator {\n+\n+    /** The number of bits to use. */\n+    private static final int BITS = 52;\n+\n+    /** The scaling factor. */\n+    private static final double SCALE = FastMath.pow(2, BITS);\n+\n+    /** The maximum supported space dimension. */\n+    private static final int MAX_DIMENSION = 1000;\n+\n+    /** The resource containing the direction numbers. */\n+    private static final String RESOURCE_NAME = \"/assets/org/apache/commons/math3/random/new-joe-kuo-6.1000\";\n+\n+    /** Space dimension. */\n+    private final int dimension;\n+\n+    /** The current index in the sequence. */\n+    private int count = 0;\n+\n+    /** The direction vector for each component. */\n+    private final long[][] direction;\n+\n+    /** The current state. */\n+    private final long[] x;\n+\n+    /**\n+     * Construct a new Sobol sequence generator for the given space dimension.\n+     *\n+     * @param dimension the space dimension\n+     * @throws OutOfRangeException if the space dimension is outside the allowed range of [1, 1000]\n+     */\n+    public SobolSequenceGenerator(final int dimension) throws OutOfRangeException {\n+        if (dimension < 1 || dimension > MAX_DIMENSION) {\n+            throw new OutOfRangeException(dimension, 1, MAX_DIMENSION);\n+        }\n+\n+        // initialize the other dimensions with direction numbers from a resource\n+        final InputStream is = getClass().getResourceAsStream(RESOURCE_NAME);\n+        if (is == null) {\n+            throw new MathInternalError();\n+        }\n+\n+        this.dimension = dimension;\n+\n+        // init data structures\n+        direction = new long[dimension][BITS + 1];\n+        x = new long[dimension];\n+\n+        try {\n+            initFromStream(is);\n+        } catch (IOException e) {\n+            // the internal resource file could not be read -> should not happen\n+            throw new MathInternalError();\n+        } catch (MathParseException e) {\n+            // the internal resource file could not be parsed -> should not happen\n+            throw new MathInternalError();\n+        }\n+    }\n+\n+    /**\n+     * Construct a new Sobol sequence generator for the given space dimension with\n+     * direction vectors loaded from the given stream.\n+     * <p>\n+     * The expected format is identical to the files available from\n+     * <a href=\"http://web.maths.unsw.edu.au/~fkuo/sobol/\">Stephen Joe and Frances Kuo</a>.\n+     * The first line will be ignored as it is assumed to contain only the column headers.\n+     * The columns are:\n+     * <ul>\n+     *  <li>d: the dimension</li>\n+     *  <li>s: the degree of the primitive polynomial</li>\n+     *  <li>a: the number representing the coefficients</li>\n+     *  <li>m: the list of initial direction numbers</li>\n+     * </ul>\n+     * Example:\n+     * <pre>\n+     * d       s       a       m_i\n+     * 2       1       0       1\n+     * 3       2       1       1 3\n+     * </pre>\n+     *\n+     * @param dimension the space dimension\n+     * @param is the stream to read the direction vectors from\n+     * @throws NotStrictlyPositiveException if the space dimension is &lt; 1\n+     * @throws OutOfRangeException if the space dimension is outside the range [1, max], where\n+     *   max refers to the maximum dimension found in the input stream\n+     * @throws MathParseException if the content in the stream could not be parsed successfully\n+     * @throws IOException if an error occurs while reading from the input stream\n+     */\n+    public SobolSequenceGenerator(final int dimension, final InputStream is)\n+            throws NotStrictlyPositiveException, MathParseException, IOException {\n+\n+        if (dimension < 1) {\n+            throw new NotStrictlyPositiveException(dimension);\n+        }\n+\n+        this.dimension = dimension;\n+\n+        // init data structures\n+        direction = new long[dimension][BITS + 1];\n+        x = new long[dimension];\n+\n+        // initialize the other dimensions with direction numbers from the stream\n+        int lastDimension = initFromStream(is);\n+        if (lastDimension < dimension) {\n+            throw new OutOfRangeException(dimension, 1, lastDimension);\n+        }\n+    }\n+\n+    /**\n+     * Load the direction vector for each dimension from the given stream.\n+     *\n+     * @param is the input stream to read the direction vector from\n+     * @return the last dimension that has been read from the input stream\n+     * @throws IOException if the stream could not be read\n+     * @throws MathParseException if the content could not be parsed successfully\n+     */\n+    private int initFromStream(final InputStream is) throws MathParseException, IOException {\n+\n+        // special case: dimension 1 -> use unit initialization\n+        for (int i = 1; i <= BITS; i++) {\n+            direction[0][i] = 1l << (BITS - i);\n+        }\n+\n+        final BufferedReader reader = new BufferedReader(new InputStreamReader(is));\n+        int dim = -1;\n+\n+        try {\n+            // ignore first line\n+            reader.readLine();\n+\n+            int lineNumber = 2;\n+            int index = 1;\n+            String line = null;\n+            while ( (line = reader.readLine()) != null) {\n+                StringTokenizer st = new StringTokenizer(line, \" \");\n+                try {\n+                    dim = Integer.valueOf(st.nextToken());\n+                    if (dim >= 2 && dim <= dimension) { // we have found the right dimension\n+                        final int s = Integer.valueOf(st.nextToken());\n+                        final int a = Integer.valueOf(st.nextToken());\n+                        final int[] m = new int[s + 1];\n+                        for (int i = 1; i <= s; i++) {\n+                            m[i] = Integer.valueOf(st.nextToken());\n+                        }\n+                        initDirectionVector(index++, a, m);\n+                    }\n+\n+                    if (dim > dimension) {\n+                        return dim;\n+                    }\n+                } catch (NoSuchElementException e) {\n+                    throw new MathParseException(line, lineNumber);\n+                } catch (NumberFormatException e) {\n+                    throw new MathParseException(line, lineNumber);\n+                }\n+                lineNumber++;\n+            }\n+        } finally {\n+            reader.close();\n+        }\n+\n+        return dim;\n+    }\n+\n+    /**\n+     * Calculate the direction numbers from the given polynomial.\n+     *\n+     * @param d the dimension, zero-based\n+     * @param a the coefficients of the primitive polynomial\n+     * @param m the initial direction numbers\n+     */\n+    private void initDirectionVector(final int d, final int a, final int[] m) {\n+        final int s = m.length - 1;\n+        for (int i = 1; i <= s; i++) {\n+            direction[d][i] = ((long) m[i]) << (BITS - i);\n+        }\n+        for (int i = s + 1; i <= BITS; i++) {\n+            direction[d][i] = direction[d][i - s] ^ (direction[d][i - s] >> s);\n+            for (int k = 1; k <= s - 1; k++) {\n+                direction[d][i] ^= ((a >> (s - 1 - k)) & 1) * direction[d][i - k];\n+            }\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] nextVector() {\n+        final double[] v = new double[dimension];\n+        if (count == 0) {\n+            count++;\n+            return v;\n+        }\n+\n+        // find the index c of the rightmost 0\n+        int c = 1;\n+        int value = count - 1;\n+        while ((value & 1) == 1) {\n+            value >>= 1;\n+            c++;\n+        }\n+\n+        for (int i = 0; i < dimension; i++) {\n+            x[i] = x[i] ^ direction[i][c];\n+            v[i] = (double) x[i] / SCALE;\n+        }\n+        count++;\n+        return v;\n+    }\n+\n+    /**\n+     * Skip to the i-th point in the Sobol sequence.\n+     * <p>\n+     * This operation can be performed in O(1).\n+     *\n+     * @param index the index in the sequence to skip to\n+     * @return the i-th point in the Sobol sequence\n+     * @throws NotPositiveException if index &lt; 0\n+     */\n+    public double[] skipTo(final int index) throws NotPositiveException {\n+        if (index == 0) {\n+            // reset x vector\n+            Arrays.fill(x, 0);\n+        } else {\n+            final int i = index - 1;\n+            final long grayCode = i ^ (i / 2);\n+            for (int j = 0; j < dimension; j++) {\n+                long result = 0;\n+                for (int k = 1; k <= BITS; k++) {\n+                    final long shift = grayCode >> (k - 1);\n+                    if (shift == 0) {\n+                        // stop, as all remaining bits will be zero\n+                        break;\n+                    }\n+                    // the k-th bit of i\n+                    final long ik = shift & 1;\n+                    result ^= ik * direction[j][k];\n+                }\n+                x[j] = result;\n+            }\n+        }\n+        count = index;\n+        return nextVector();\n+    }\n+\n+    /**\n+     * Returns the index i of the next point in the Sobol sequence that will be returned\n+     * by calling {@link #nextVector()}.\n+     *\n+     * @return the index of the next point\n+     */\n+    public int getNextIndex() {\n+        return count;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/random/SobolSequenceGeneratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.random;\n+\n+import static org.junit.Assert.*;\n+\n+import java.io.InputStream;\n+\n+import org.apache.commons.math3.exception.OutOfRangeException;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class SobolSequenceGeneratorTest {\n+\n+    private double[][] referenceValues = {\n+            { 0.0, 0.0, 0.0 },\n+            { 0.5, 0.5, 0.5 },\n+            { 0.75, 0.25, 0.25 },\n+            { 0.25, 0.75, 0.75 },\n+            { 0.375, 0.375, 0.625 },\n+            { 0.875, 0.875, 0.125 },\n+            { 0.625, 0.125, 0.875 },\n+            { 0.125, 0.625, 0.375 },\n+            { 0.1875, 0.3125, 0.9375 },\n+            { 0.6875, 0.8125, 0.4375 }\n+    };\n+\n+    private SobolSequenceGenerator generator;\n+\n+    @Before\n+    public void setUp() {\n+        generator = new SobolSequenceGenerator(3);\n+    }\n+\n+    @Test\n+    public void test3DReference() {\n+        for (int i = 0; i < referenceValues.length; i++) {\n+            double[] result = generator.nextVector();\n+            assertArrayEquals(referenceValues[i], result, 1e-6);\n+            assertEquals(i + 1, generator.getNextIndex());\n+        }\n+    }\n+    \n+    @Test\n+    public void testConstructor() {\n+        try {\n+            new SobolSequenceGenerator(0);\n+            fail();\n+        } catch (OutOfRangeException e) {\n+            // expected\n+        }\n+        \n+        try {\n+            new SobolSequenceGenerator(1001);\n+            fail();\n+        } catch (OutOfRangeException e) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void testConstructor2() throws Exception{\n+        try {\n+            final String RESOURCE_NAME = \"/assets/org/apache/commons/math3/random/new-joe-kuo-6.1000\";\n+            final InputStream is = getClass().getResourceAsStream(RESOURCE_NAME);\n+            new SobolSequenceGenerator(1001, is);\n+            fail();\n+        } catch (OutOfRangeException e) {\n+            // expected\n+        }\n+        \n+        try {\n+            new SobolSequenceGenerator(1001);\n+            fail();\n+        } catch (OutOfRangeException e) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void testSkip() {\n+        double[] result = generator.skipTo(5);\n+        assertArrayEquals(referenceValues[5], result, 1e-6);\n+        assertEquals(6, generator.getNextIndex());\n+        \n+        for (int i = 6; i < referenceValues.length; i++) {\n+            result = generator.nextVector();\n+            assertArrayEquals(referenceValues[i], result, 1e-6);\n+            assertEquals(i + 1, generator.getNextIndex());\n+        }\n+    }\n+\n+}", "timestamp": 1368367206, "metainfo": ""}