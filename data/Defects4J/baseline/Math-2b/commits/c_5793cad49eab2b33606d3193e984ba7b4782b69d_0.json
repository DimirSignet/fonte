{"sha": "5793cad49eab2b33606d3193e984ba7b4782b69d", "log": "Filled throws clauses for the analysis package.  JIRA: MATH-854  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/analysis/FunctionUtils.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/FunctionUtils.java\n                 return r;\n             }\n \n-            /** {@inheritDoc} */\n-            public DerivativeStructure value(final DerivativeStructure t) {\n+            /** {@inheritDoc}\n+             * @throws DimensionMismatchException if functions are not consistent with each other\n+             */\n+            public DerivativeStructure value(final DerivativeStructure t)\n+                throws DimensionMismatchException {\n                 DerivativeStructure r = f[0].value(t);\n                 for (int i = 1; i < f.length; i++) {\n                     r = r.add(f[i].value(t));\n      * @throws NotStrictlyPositiveException if the number of sample points\n      * {@code n} is negative.\n      */\n-    public static double[] sample(UnivariateFunction f,\n-                                  double min, double max, int n) {\n+    public static double[] sample(UnivariateFunction f, double min, double max, int n)\n+       throws NumberIsTooLargeException, NotStrictlyPositiveException {\n \n         if (n <= 0) {\n             throw new NotStrictlyPositiveException(\n             }\n \n             /** {@inheritDoc}\n-             * @exception DimensionMismatchException if number of parameters or derivation\n-             * order are higher than 1\n+             * @exception NumberIsTooLargeException if derivation order is higher than 1\n+             * @exception DimensionMismatchException if numbers of free parameters are inconsistent\n              */\n             public DerivativeStructure value(final DerivativeStructure[] t)\n                 throws DimensionMismatchException, NumberIsTooLargeException {\n             }\n \n             /** {@inheritDoc}\n-             * @exception DimensionMismatchException if number of parameters or derivation\n-             * order are higher than 1\n+             * @exception NumberIsTooLargeException if derivation order is higher than 1\n+             * @exception DimensionMismatchException if numbers of free parameters are inconsistent\n              */\n             public DerivativeStructure[] value(final DerivativeStructure[] t)\n                 throws DimensionMismatchException, NumberIsTooLargeException {\n--- a/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java\n import java.util.concurrent.atomic.AtomicReference;\n \n import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MathArithmeticException;\n+import org.apache.commons.math3.exception.MathInternalError;\n+import org.apache.commons.math3.exception.NotPositiveException;\n import org.apache.commons.math3.exception.NumberIsTooLargeException;\n import org.apache.commons.math3.util.ArithmeticUtils;\n import org.apache.commons.math3.util.FastMath;\n      * @param order derivation order\n      * @param valueCompiler compiler for the value part\n      * @param derivativeCompiler compiler for the derivative part\n+     * @throws NumberIsTooLargeException if order is too large\n      */\n     private DSCompiler(final int parameters, final int order,\n-                       final DSCompiler valueCompiler, final DSCompiler derivativeCompiler) {\n+                       final DSCompiler valueCompiler, final DSCompiler derivativeCompiler)\n+        throws NumberIsTooLargeException {\n \n         this.parameters = parameters;\n         this.order      = order;\n      * @param parameters number of free parameters\n      * @param order derivation order\n      * @return cached rules set\n-     */\n-    public static DSCompiler getCompiler(int parameters, int order) {\n+     * @throws NumberIsTooLargeException if order is too large\n+     */\n+    public static DSCompiler getCompiler(int parameters, int order)\n+        throws NumberIsTooLargeException {\n \n         // get the cached compilers\n         final DSCompiler[][] cache = compilers.get();\n      * @param sizes sizes array\n      * @param derivativesIndirection derivatives indirection array\n      * @return multiplication indirection array\n+     * @throws NumberIsTooLargeException if order is too large\n      */\n     private static int[][][] compileCompositionIndirection(final int parameters, final int order,\n-                                                        final DSCompiler valueCompiler,\n-                                                        final DSCompiler derivativeCompiler,\n-                                                        final int[][] sizes,\n-                                                        final int[][] derivativesIndirection) {\n+                                                           final DSCompiler valueCompiler,\n+                                                           final DSCompiler derivativeCompiler,\n+                                                           final int[][] sizes,\n+                                                           final int[][] derivativesIndirection)\n+       throws NumberIsTooLargeException {\n \n         if ((parameters == 0) || (order == 0)) {\n             return new int[][][] { { { 1, 0 } } };\n      * @param destSizes sizes array for the destination derivative structure\n      * @return index of the partial derivative with the <em>same</em> characteristics\n      * in destination derivative structure\n+     * @throws NumberIsTooLargeException if order is too large\n      */\n     private static int convertIndex(final int index,\n                                     final int srcP, final int[][] srcDerivativesIndirection,\n-                                    final int destP, final int destO, final int[][] destSizes) {\n+                                    final int destP, final int destO, final int[][] destSizes)\n+        throws NumberIsTooLargeException {\n         int[] orders = new int[destP];\n         System.arraycopy(srcDerivativesIndirection[index], 0, orders, 0, FastMath.min(srcP, destP));\n         return getPartialDerivativeIndex(destP, destO, destSizes, orders);\n      * @param dsOffset offset of the derivative structure in its array\n      * @param delta parameters offsets (&Delta;x, &Delta;y, ...)\n      * @return value of the Taylor expansion at x + &Delta;x, y + &Delta;y, ...\n-     */\n-    public double taylor(final double[] ds, final int dsOffset, final double ... delta) {\n+     * @throws MathArithmeticException if factorials becomes too large\n+     */\n+    public double taylor(final double[] ds, final int dsOffset, final double ... delta)\n+       throws MathArithmeticException {\n         double value = 0;\n         for (int i = getSize() - 1; i >= 0; --i) {\n             final int[] orders = getPartialDerivativeOrders(i);\n             double term = ds[dsOffset + i];\n             for (int k = 0; k < orders.length; ++k) {\n                 if (orders[k] > 0) {\n-                    term *= FastMath.pow(delta[k], orders[k]) / ArithmeticUtils.factorial(orders[k]);\n+                    try {\n+                        term *= FastMath.pow(delta[k], orders[k]) /\n+                                ArithmeticUtils.factorial(orders[k]);\n+                    } catch (NotPositiveException e) {\n+                        // this cannot happen\n+                        throw new MathInternalError(e);\n+                    }\n                 }\n             }\n             value += term;\n--- a/src/main/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.java\n import org.apache.commons.math3.Field;\n import org.apache.commons.math3.FieldElement;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MathArithmeticException;\n import org.apache.commons.math3.exception.NumberIsTooLargeException;\n import org.apache.commons.math3.util.FastMath;\n import org.apache.commons.math3.util.MathArrays;\n     /** Build an instance with all values and derivatives set to 0.\n      * @param parameters number of free parameters\n      * @param order derivation order\n-     */\n-    public DerivativeStructure(final int parameters, final int order) {\n+     * @throws NumberIsTooLargeException if order is too large\n+     */\n+    public DerivativeStructure(final int parameters, final int order)\n+        throws NumberIsTooLargeException {\n         this(DSCompiler.getCompiler(parameters, order));\n     }\n \n      * @param parameters number of free parameters\n      * @param order derivation order\n      * @param value value of the constant\n+     * @throws NumberIsTooLargeException if order is too large\n      * @see #DerivativeStructure(int, int, int, double)\n      */\n-    public DerivativeStructure(final int parameters, final int order, final double value) {\n+    public DerivativeStructure(final int parameters, final int order, final double value)\n+        throws NumberIsTooLargeException {\n         this(parameters, order);\n         this.data[0] = value;\n     }\n      * {@link DSCompiler#getPartialDerivativeIndex(int...)}\n      * @exception DimensionMismatchException if derivatives array does not match the\n      * {@link DSCompiler#getSize() size} expected by the compiler\n+     * @throws NumberIsTooLargeException if order is too large\n      * @see #getAllDerivatives()\n      */\n     public DerivativeStructure(final int parameters, final int order, final double ... derivatives)\n-        throws DimensionMismatchException {\n+        throws DimensionMismatchException, NumberIsTooLargeException {\n         this(parameters, order);\n         if (derivatives.length != data.length) {\n             throw new DimensionMismatchException(derivatives.length, data.length);\n         return ds;\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @exception DimensionMismatchException if number of free parameters\n+     * or orders do not match\n+     */\n     public DerivativeStructure add(final DerivativeStructure a)\n         throws DimensionMismatchException {\n         compiler.checkCompatibility(a.compiler);\n         return add(-a);\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @exception DimensionMismatchException if number of free parameters\n+     * or orders do not match\n+     */\n     public DerivativeStructure subtract(final DerivativeStructure a)\n         throws DimensionMismatchException {\n         compiler.checkCompatibility(a.compiler);\n         return ds;\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @exception DimensionMismatchException if number of free parameters\n+     * or orders do not match\n+     */\n     public DerivativeStructure multiply(final DerivativeStructure a)\n         throws DimensionMismatchException {\n         compiler.checkCompatibility(a.compiler);\n         return ds;\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @exception DimensionMismatchException if number of free parameters\n+     * or orders do not match\n+     */\n     public DerivativeStructure divide(final DerivativeStructure a)\n         throws DimensionMismatchException {\n         compiler.checkCompatibility(a.compiler);\n         return ds;\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @exception DimensionMismatchException if number of free parameters\n+     * or orders do not match\n+     */\n     public DerivativeStructure remainder(final DerivativeStructure a)\n         throws DimensionMismatchException {\n         compiler.checkCompatibility(a.compiler);\n     }\n \n     /** {@inheritDoc} */\n-    public DerivativeStructure copySign(final double sign){\n+    public DerivativeStructure copySign(final double sign) {\n         long m = Double.doubleToLongBits(data[0]);\n         long s = Double.doubleToLongBits(sign);\n         if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { // Sign is currently OK\n         return ds;\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @exception DimensionMismatchException if number of free parameters\n+     * or orders do not match\n+     */\n     public DerivativeStructure hypot(final DerivativeStructure y)\n         throws DimensionMismatchException {\n \n      * @param x a value\n      * @param y a value\n      * @return sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)\n-     * @exception DimensionMismatchException if number of free parameters or orders are inconsistent\n+     * @exception DimensionMismatchException if number of free parameters\n+     * or orders do not match\n      */\n     public static DerivativeStructure hypot(final DerivativeStructure x, final DerivativeStructure y)\n         throws DimensionMismatchException {\n      * @exception DimensionMismatchException if the number of derivatives\n      * in the array is not equal to {@link #getOrder() order} + 1\n      */\n-    public DerivativeStructure compose(final double ... f) {\n+    public DerivativeStructure compose(final double ... f)\n+        throws DimensionMismatchException {\n         if (f.length != getOrder() + 1) {\n             throw new DimensionMismatchException(f.length, getOrder() + 1);\n         }\n         return result;\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @exception DimensionMismatchException if number of free parameters\n+     * or orders do not match\n+     */\n     public DerivativeStructure pow(final DerivativeStructure e)\n         throws DimensionMismatchException {\n         compiler.checkCompatibility(e.compiler);\n      * @param y first argument of the arc tangent\n      * @param x second argument of the arc tangent\n      * @return atan2(y, x)\n-     * @exception DimensionMismatchException if number of free parameters or orders are inconsistent\n+     * @exception DimensionMismatchException if number of free parameters\n+     * or orders do not match\n      */\n     public static DerivativeStructure atan2(final DerivativeStructure y, final DerivativeStructure x)\n         throws DimensionMismatchException {\n     /** Evaluate Taylor expansion a derivative structure.\n      * @param delta parameters offsets (&Delta;x, &Delta;y, ...)\n      * @return value of the Taylor expansion at x + &Delta;x, y + &Delta;y, ...\n-     */\n-    public double taylor(final double ... delta) {\n+     * @throws MathArithmeticException if factorials becomes too large\n+     */\n+    public double taylor(final double ... delta) throws MathArithmeticException {\n         return compiler.taylor(data, 0, delta);\n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @exception DimensionMismatchException if number of free parameters\n+     * or orders do not match\n+     */\n     public DerivativeStructure linearCombination(final DerivativeStructure[] a, final DerivativeStructure[] b)\n         throws DimensionMismatchException {\n \n \n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @exception DimensionMismatchException if number of free parameters\n+     * or orders do not match\n+     */\n     public DerivativeStructure linearCombination(final double[] a, final DerivativeStructure[] b)\n         throws DimensionMismatchException {\n \n \n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @exception DimensionMismatchException if number of free parameters\n+     * or orders do not match\n+     */\n     public DerivativeStructure linearCombination(final DerivativeStructure a1, final DerivativeStructure b1,\n-                                                 final DerivativeStructure a2, final DerivativeStructure b2) {\n+                                                 final DerivativeStructure a2, final DerivativeStructure b2)\n+        throws DimensionMismatchException {\n \n         // compute an accurate value, taking care of cancellations\n         final double accurateValue = MathArrays.linearCombination(a1.getValue(), b1.getValue(),\n \n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @exception DimensionMismatchException if number of free parameters\n+     * or orders do not match\n+     */\n     public DerivativeStructure linearCombination(final double a1, final DerivativeStructure b1,\n-                                                 final double a2, final DerivativeStructure b2) {\n+                                                 final double a2, final DerivativeStructure b2)\n+        throws DimensionMismatchException {\n \n         // compute an accurate value, taking care of cancellations\n         final double accurateValue = MathArrays.linearCombination(a1, b1.getValue(),\n \n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @exception DimensionMismatchException if number of free parameters\n+     * or orders do not match\n+     */\n     public DerivativeStructure linearCombination(final DerivativeStructure a1, final DerivativeStructure b1,\n                                                  final DerivativeStructure a2, final DerivativeStructure b2,\n-                                                 final DerivativeStructure a3, final DerivativeStructure b3) {\n+                                                 final DerivativeStructure a3, final DerivativeStructure b3)\n+        throws DimensionMismatchException {\n \n         // compute an accurate value, taking care of cancellations\n         final double accurateValue = MathArrays.linearCombination(a1.getValue(), b1.getValue(),\n \n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @exception DimensionMismatchException if number of free parameters\n+     * or orders do not match\n+     */\n     public DerivativeStructure linearCombination(final double a1, final DerivativeStructure b1,\n                                                  final double a2, final DerivativeStructure b2,\n-                                                 final double a3, final DerivativeStructure b3) {\n+                                                 final double a3, final DerivativeStructure b3)\n+        throws DimensionMismatchException {\n \n         // compute an accurate value, taking care of cancellations\n         final double accurateValue = MathArrays.linearCombination(a1, b1.getValue(),\n \n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @exception DimensionMismatchException if number of free parameters\n+     * or orders do not match\n+     */\n     public DerivativeStructure linearCombination(final DerivativeStructure a1, final DerivativeStructure b1,\n                                                  final DerivativeStructure a2, final DerivativeStructure b2,\n                                                  final DerivativeStructure a3, final DerivativeStructure b3,\n-                                                 final DerivativeStructure a4, final DerivativeStructure b4) {\n+                                                 final DerivativeStructure a4, final DerivativeStructure b4)\n+        throws DimensionMismatchException {\n \n         // compute an accurate value, taking care of cancellations\n         final double accurateValue = MathArrays.linearCombination(a1.getValue(), b1.getValue(),\n \n     }\n \n-    /** {@inheritDoc} */\n+    /** {@inheritDoc}\n+     * @exception DimensionMismatchException if number of free parameters\n+     * or orders do not match\n+     */\n     public DerivativeStructure linearCombination(final double a1, final DerivativeStructure b1,\n                                                  final double a2, final DerivativeStructure b2,\n                                                  final double a3, final DerivativeStructure b3,\n-                                                 final double a4, final DerivativeStructure b4) {\n+                                                 final double a4, final DerivativeStructure b4)\n+        throws DimensionMismatchException {\n \n         // compute an accurate value, taking care of cancellations\n         final double accurateValue = MathArrays.linearCombination(a1, b1.getValue(),\n--- a/src/main/java/org/apache/commons/math3/analysis/differentiation/GradientFunction.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/differentiation/GradientFunction.java\n     }\n \n     /** {@inheritDoc} */\n-    public double[] value(double[] point)\n-        throws IllegalArgumentException {\n+    public double[] value(double[] point) {\n \n         // set up parameters\n         final DerivativeStructure[] dsX = new DerivativeStructure[point.length];\n--- a/src/main/java/org/apache/commons/math3/analysis/differentiation/JacobianFunction.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/differentiation/JacobianFunction.java\n     }\n \n     /** {@inheritDoc} */\n-    public double[][] value(double[] point)\n-        throws IllegalArgumentException {\n+    public double[][] value(double[] point) {\n \n         // set up parameters\n         final DerivativeStructure[] dsX = new DerivativeStructure[point.length];\n--- a/src/main/java/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.java\n package org.apache.commons.math3.analysis.differentiation;\n \n import org.apache.commons.math3.analysis.UnivariateFunction;\n-import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n \n /** Interface for univariate functions derivatives.\n  * <p>This interface represents a simple function which computes\n      * value and the first derivative of the function.</p>\n      * @param t function input value\n      * @return function result\n-     * @exception MathIllegalArgumentException if {@code t} does not\n-     * fulfill functions constraints (argument out of bound, or unsupported\n-     * derivative order for example)\n+     * @exception DimensionMismatchException if t is inconsistent with\n+     * function free parameters or order\n      */\n-    DerivativeStructure value(DerivativeStructure t) throws MathIllegalArgumentException;\n+    DerivativeStructure value(DerivativeStructure t)\n+        throws DimensionMismatchException;\n \n }\n--- a/src/main/java/org/apache/commons/math3/analysis/function/Gaussian.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/function/Gaussian.java\n     /** {@inheritDoc}\n      * @since 3.1\n      */\n-    public DerivativeStructure value(final DerivativeStructure t) {\n+    public DerivativeStructure value(final DerivativeStructure t)\n+        throws DimensionMismatchException {\n \n         final double u = is * (t.getValue() - mean);\n         double[] f = new double[t.getOrder() + 1];\n--- a/src/main/java/org/apache/commons/math3/analysis/function/HarmonicOscillator.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/function/HarmonicOscillator.java\n     /** {@inheritDoc}\n      * @since 3.1\n      */\n-    public DerivativeStructure value(final DerivativeStructure t) {\n+    public DerivativeStructure value(final DerivativeStructure t)\n+        throws DimensionMismatchException {\n         final double x = t.getValue();\n         double[] f = new double[t.getOrder() + 1];\n \n--- a/src/main/java/org/apache/commons/math3/analysis/function/Sigmoid.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/function/Sigmoid.java\n     /** {@inheritDoc}\n      * @since 3.1\n      */\n-    public DerivativeStructure value(final DerivativeStructure t) {\n+    public DerivativeStructure value(final DerivativeStructure t)\n+        throws DimensionMismatchException {\n \n         double[] f = new double[t.getOrder() + 1];\n         final double exp = FastMath.exp(-t.getValue());\n--- a/src/main/java/org/apache/commons/math3/analysis/function/Sinc.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/function/Sinc.java\n import org.apache.commons.math3.analysis.UnivariateFunction;\n import org.apache.commons.math3.analysis.differentiation.DerivativeStructure;\n import org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.util.FastMath;\n \n /**\n     /** {@inheritDoc}\n      * @since 3.1\n      */\n-    public DerivativeStructure value(final DerivativeStructure t) {\n+    public DerivativeStructure value(final DerivativeStructure t)\n+        throws DimensionMismatchException {\n \n         final double scaledX  = (normalized ? FastMath.PI : 1) * t.getValue();\n         final double scaledX2 = scaledX * scaledX;\n--- a/src/main/java/org/apache/commons/math3/analysis/function/StepFunction.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/function/StepFunction.java\n import java.util.Arrays;\n import org.apache.commons.math3.analysis.UnivariateFunction;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.NonMonotonicSequenceException;\n import org.apache.commons.math3.exception.NullArgumentException;\n import org.apache.commons.math3.exception.NoDataException;\n import org.apache.commons.math3.util.MathArrays;\n      *\n      * @param x Domain values where the function changes value.\n      * @param y Values of the function.\n-     * @throws org.apache.commons.math3.exception.NonMonotonicSequenceException\n+     * @throws NonMonotonicSequenceException\n      * if the {@code x} array is not sorted in strictly increasing order.\n      * @throws NullArgumentException if {@code x} or {@code y} are {@code null}.\n      * @throws NoDataException if {@code x} or {@code y} are zero-length.\n      */\n     public StepFunction(double[] x,\n                         double[] y)\n-        throws NullArgumentException,\n-               NoDataException,\n-               DimensionMismatchException {\n+        throws NullArgumentException, NoDataException,\n+               DimensionMismatchException, NonMonotonicSequenceException {\n         if (x == null ||\n             y == null) {\n             throw new NullArgumentException();\n--- a/src/main/java/org/apache/commons/math3/analysis/integration/BaseAbstractUnivariateIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/integration/BaseAbstractUnivariateIntegrator.java\n      * is lesser than or equal to the minimal number of iterations\n      */\n     protected BaseAbstractUnivariateIntegrator(final double relativeAccuracy,\n-                                           final double absoluteAccuracy,\n-                                           final int minimalIterationCount,\n-                                           final int maximalIterationCount)\n+                                               final double absoluteAccuracy,\n+                                               final int minimalIterationCount,\n+                                               final int maximalIterationCount)\n         throws NotStrictlyPositiveException, NumberIsTooSmallException {\n \n         // accuracy settings\n--- a/src/main/java/org/apache/commons/math3/analysis/integration/IterativeLegendreGaussIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/integration/IterativeLegendreGaussIntegrator.java\n import org.apache.commons.math3.analysis.UnivariateFunction;\n import org.apache.commons.math3.analysis.integration.gauss.GaussIntegratorFactory;\n import org.apache.commons.math3.analysis.integration.gauss.GaussIntegrator;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.exception.MaxCountExceededException;\n import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.exception.TooManyEvaluationsException;\n+import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.util.FastMath;\n \n /**\n      * @param minimalIterationCount Minimum number of iterations.\n      * @param maximalIterationCount Maximum number of iterations.\n      * @throws NotStrictlyPositiveException if minimal number of iterations\n-     * is not strictly positive.\n+     * or number of points are not strictly positive.\n      * @throws NumberIsTooSmallException if maximal number of iterations\n      * is smaller than or equal to the minimal number of iterations.\n      */\n                                             final int maximalIterationCount)\n         throws NotStrictlyPositiveException, NumberIsTooSmallException {\n         super(relativeAccuracy, absoluteAccuracy, minimalIterationCount, maximalIterationCount);\n-        numberOfPoints = n;\n+        if (n <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_POINTS, n);\n+        }\n+       numberOfPoints = n;\n     }\n \n     /**\n      * @param n Number of integration points.\n      * @param relativeAccuracy Relative accuracy of the result.\n      * @param absoluteAccuracy Absolute accuracy of the result.\n+     * @throws NotStrictlyPositiveException if {@code n < 1}.\n      */\n     public IterativeLegendreGaussIntegrator(final int n,\n                                             final double relativeAccuracy,\n-                                            final double absoluteAccuracy) {\n+                                            final double absoluteAccuracy)\n+        throws NotStrictlyPositiveException {\n         this(n, relativeAccuracy, absoluteAccuracy,\n              DEFAULT_MIN_ITERATIONS_COUNT, DEFAULT_MAX_ITERATIONS_COUNT);\n     }\n      * is not strictly positive.\n      * @throws NumberIsTooSmallException if maximal number of iterations\n      * is smaller than or equal to the minimal number of iterations.\n+     * @throws NotStrictlyPositiveException if {@code n < 1}.\n      */\n     public IterativeLegendreGaussIntegrator(final int n,\n                                             final int minimalIterationCount,\n-                                            final int maximalIterationCount) {\n+                                            final int maximalIterationCount)\n+        throws NotStrictlyPositiveException, NumberIsTooSmallException {\n         this(n, DEFAULT_RELATIVE_ACCURACY, DEFAULT_ABSOLUTE_ACCURACY,\n              minimalIterationCount, maximalIterationCount);\n     }\n     /** {@inheritDoc} */\n     @Override\n     protected double doIntegrate()\n-        throws TooManyEvaluationsException, MaxCountExceededException {\n+        throws MathIllegalArgumentException, TooManyEvaluationsException, MaxCountExceededException {\n         // Compute first estimate with a single step.\n         double oldt = stage(1);\n \n         throws TooManyEvaluationsException {\n         // Function to be integrated is stored in the base class.\n         final UnivariateFunction f = new UnivariateFunction() {\n-                public double value(double x) {\n+                public double value(double x)\n+                    throws MathIllegalArgumentException, TooManyEvaluationsException {\n                     return computeObjectiveValue(x);\n                 }\n             };\n--- a/src/main/java/org/apache/commons/math3/analysis/integration/LegendreGaussIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/integration/LegendreGaussIntegrator.java\n      * @param absoluteAccuracy absolute accuracy of the result\n      * @param minimalIterationCount minimum number of iterations\n      * @param maximalIterationCount maximum number of iterations\n+     * @exception MathIllegalArgumentException if number of points is out of [2; 5]\n      * @exception NotStrictlyPositiveException if minimal number of iterations\n      * is not strictly positive\n      * @exception NumberIsTooSmallException if maximal number of iterations\n                                    final double absoluteAccuracy,\n                                    final int minimalIterationCount,\n                                    final int maximalIterationCount)\n-        throws NotStrictlyPositiveException, NumberIsTooSmallException {\n+        throws MathIllegalArgumentException, NotStrictlyPositiveException, NumberIsTooSmallException {\n         super(relativeAccuracy, absoluteAccuracy, minimalIterationCount, maximalIterationCount);\n         switch(n) {\n         case 2 :\n      * @param n number of points desired (must be between 2 and 5 inclusive)\n      * @param relativeAccuracy relative accuracy of the result\n      * @param absoluteAccuracy absolute accuracy of the result\n+     * @exception MathIllegalArgumentException if number of points is out of [2; 5]\n      */\n     public LegendreGaussIntegrator(final int n,\n                                    final double relativeAccuracy,\n-                                   final double absoluteAccuracy) {\n+                                   final double absoluteAccuracy)\n+        throws MathIllegalArgumentException {\n         this(n, relativeAccuracy, absoluteAccuracy,\n              DEFAULT_MIN_ITERATIONS_COUNT, DEFAULT_MAX_ITERATIONS_COUNT);\n     }\n      * @param n number of points desired (must be between 2 and 5 inclusive)\n      * @param minimalIterationCount minimum number of iterations\n      * @param maximalIterationCount maximum number of iterations\n+     * @exception MathIllegalArgumentException if number of points is out of [2; 5]\n      * @exception NotStrictlyPositiveException if minimal number of iterations\n      * is not strictly positive\n      * @exception NumberIsTooSmallException if maximal number of iterations\n      */\n     public LegendreGaussIntegrator(final int n,\n                                    final int minimalIterationCount,\n-                                   final int maximalIterationCount) {\n+                                   final int maximalIterationCount)\n+        throws MathIllegalArgumentException {\n         this(n, DEFAULT_RELATIVE_ACCURACY, DEFAULT_ABSOLUTE_ACCURACY,\n              minimalIterationCount, maximalIterationCount);\n     }\n     /** {@inheritDoc} */\n     @Override\n     protected double doIntegrate()\n-        throws TooManyEvaluationsException, MaxCountExceededException {\n+        throws MathIllegalArgumentException, TooManyEvaluationsException, MaxCountExceededException {\n \n         // compute first estimate with a single step\n         double oldt = stage(1);\n--- a/src/main/java/org/apache/commons/math3/analysis/integration/TrapezoidIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/integration/TrapezoidIntegrator.java\n  */\n package org.apache.commons.math3.analysis.integration;\n \n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n import org.apache.commons.math3.exception.MaxCountExceededException;\n import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n import org.apache.commons.math3.exception.NumberIsTooLargeException;\n     /** {@inheritDoc} */\n     @Override\n     protected double doIntegrate()\n-        throws TooManyEvaluationsException, MaxCountExceededException {\n+        throws MathIllegalArgumentException, TooManyEvaluationsException, MaxCountExceededException {\n \n         double oldt = stage(this, 0);\n         iterations.incrementCount();\n--- a/src/main/java/org/apache/commons/math3/analysis/integration/gauss/BaseRuleFactory.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/integration/gauss/BaseRuleFactory.java\n import org.apache.commons.math3.util.Pair;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math3.exception.util.LocalizedFormats;\n \n /**\n  * Base class for rules that determines the integration nodes and their\n      * @param numberOfPoints Number of integration points.\n      * @return a copy of the integration rule.\n      * @throws NotStrictlyPositiveException if {@code numberOfPoints < 1}.\n+     * @throws DimensionMismatchException if the elements of the rule pair do not\n+     * have the same length.\n      */\n     public Pair<double[], double[]> getRule(int numberOfPoints)\n-        throws NotStrictlyPositiveException {\n+        throws NotStrictlyPositiveException, DimensionMismatchException {\n+\n+        if (numberOfPoints <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_POINTS,\n+                                                   numberOfPoints);\n+        }\n+\n         // Try to obtain the rule from the cache.\n         Pair<double[], double[]> cached = pointsAndWeightsDouble.get(numberOfPoints);\n \n      *\n      * @param numberOfPoints Order of the rule to be retrieved.\n      * @return the points and weights corresponding to the given order.\n-     * @throws NotStrictlyPositiveException if {@code numberOfPoints < 1}.\n+     * @throws DimensionMismatchException if the elements of the rule pair do not\n+     * have the same length.\n      */\n     protected synchronized Pair<T[], T[]> getRuleInternal(int numberOfPoints)\n-        throws NotStrictlyPositiveException {\n+        throws DimensionMismatchException {\n         final Pair<T[], T[]> rule = pointsAndWeights.get(numberOfPoints);\n         if (rule == null) {\n             addRule(computeRule(numberOfPoints));\n      * @throws DimensionMismatchException if the elements of the pair do not\n      * have the same length.\n      */\n-    protected void addRule(Pair<T[], T[]> rule) {\n+    protected void addRule(Pair<T[], T[]> rule) throws DimensionMismatchException {\n         if (rule.getFirst().length != rule.getSecond().length) {\n             throw new DimensionMismatchException(rule.getFirst().length,\n                                                  rule.getSecond().length);\n      *\n      * @param numberOfPoints Order of the rule to be computed.\n      * @return the computed rule.\n+     * @throws DimensionMismatchException if the elements of the pair do not\n+     * have the same length.\n      */\n-    protected abstract Pair<T[], T[]> computeRule(int numberOfPoints);\n+    protected abstract Pair<T[], T[]> computeRule(int numberOfPoints)\n+        throws DimensionMismatchException;\n \n     /**\n      * Converts the from the actual {@code Number} type to {@code double}\n--- a/src/main/java/org/apache/commons/math3/analysis/integration/gauss/GaussIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/integration/gauss/GaussIntegrator.java\n      * @param weights Weights of the corresponding integration nodes.\n      * @throws NonMonotonicSequenceException if the {@code points} are not\n      * sorted in increasing order.\n+     * @throws DimensionMismatchException if points and weights don't have the same length\n      */\n     public GaussIntegrator(double[] points,\n                            double[] weights)\n-        throws NonMonotonicSequenceException {\n+        throws NonMonotonicSequenceException, DimensionMismatchException {\n         if (points.length != weights.length) {\n             throw new DimensionMismatchException(points.length,\n                                                  weights.length);\n--- a/src/main/java/org/apache/commons/math3/analysis/integration/gauss/GaussIntegratorFactory.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/integration/gauss/GaussIntegratorFactory.java\n \n import java.math.BigDecimal;\n \n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n import org.apache.commons.math3.util.Pair;\n \n /**\n      * @param lowerBound Lower bound of the integration interval.\n      * @param upperBound Upper bound of the integration interval.\n      * @return a Gauss-Legendre integrator.\n+     * @throws NotStrictlyPositiveException if number of points is not positive\n      */\n     public GaussIntegrator legendre(int numberOfPoints,\n                                     double lowerBound,\n-                                    double upperBound) {\n+                                    double upperBound)\n+        throws NotStrictlyPositiveException {\n         return new GaussIntegrator(transform(getRule(legendre, numberOfPoints),\n                                              lowerBound, upperBound));\n     }\n      *\n      * @param numberOfPoints Order of the integration rule.\n      * @return a Gauss-Legendre integrator.\n+     * @throws NotStrictlyPositiveException if number of points is not positive\n      */\n-    public GaussIntegrator legendreHighPrecision(int numberOfPoints) {\n+    public GaussIntegrator legendreHighPrecision(int numberOfPoints)\n+        throws NotStrictlyPositiveException {\n         return new GaussIntegrator(getRule(legendreHighPrecision, numberOfPoints));\n     }\n \n      * @param lowerBound Lower bound of the integration interval.\n      * @param upperBound Upper bound of the integration interval.\n      * @return a Gauss-Legendre integrator.\n+     * @throws NotStrictlyPositiveException if number of points is not positive\n      */\n     public GaussIntegrator legendreHighPrecision(int numberOfPoints,\n                                                  double lowerBound,\n-                                                 double upperBound) {\n+                                                 double upperBound)\n+        throws NotStrictlyPositiveException {\n         return new GaussIntegrator(transform(getRule(legendreHighPrecision, numberOfPoints),\n                                              lowerBound, upperBound));\n     }\n      * @param factory Integration rule factory.\n      * @param numberOfPoints Order of the integration rule.\n      * @return the integration nodes and weights.\n+     * @throws NotStrictlyPositiveException if number of points is not positive\n+     * @throws DimensionMismatchException if the elements of the rule pair do not\n+     * have the same length.\n      */\n     private static Pair<double[], double[]> getRule(BaseRuleFactory<? extends Number> factory,\n-                                                    int numberOfPoints) {\n+                                                    int numberOfPoints)\n+        throws NotStrictlyPositiveException, DimensionMismatchException {\n         return factory.getRule(numberOfPoints);\n     }\n \n--- a/src/main/java/org/apache/commons/math3/analysis/integration/gauss/LegendreHighPrecisionRuleFactory.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/integration/gauss/LegendreHighPrecisionRuleFactory.java\n  */\n package org.apache.commons.math3.analysis.integration.gauss;\n \n+import java.math.BigDecimal;\n import java.math.MathContext;\n-import java.math.BigDecimal;\n+\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.util.Pair;\n-import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n-import org.apache.commons.math3.exception.util.LocalizedFormats;\n \n /**\n  * Factory that creates Gauss-type quadrature rule using Legendre polynomials.\n         oneHalf = new BigDecimal(\"0.5\", mContext);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     *\n-     * @throws NotStrictlyPositiveException if {@code numberOfPoints < 1}.\n-     */\n+    /** {@inheritDoc} */\n     @Override\n-    protected Pair<BigDecimal[], BigDecimal[]> computeRule(int numberOfPoints) {\n-        if (numberOfPoints <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_POINTS,\n-                                                   numberOfPoints);\n-        }\n+    protected Pair<BigDecimal[], BigDecimal[]> computeRule(int numberOfPoints)\n+        throws DimensionMismatchException {\n \n         if (numberOfPoints == 1) {\n             // Break recursion.\n--- a/src/main/java/org/apache/commons/math3/analysis/integration/gauss/LegendreRuleFactory.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/integration/gauss/LegendreRuleFactory.java\n  */\n package org.apache.commons.math3.analysis.integration.gauss;\n \n+import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.util.Pair;\n-import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n-import org.apache.commons.math3.exception.util.LocalizedFormats;\n \n /**\n  * Factory that creates Gauss-type quadrature rule using Legendre polynomials.\n  * @version $Id$\n  */\n public class LegendreRuleFactory extends BaseRuleFactory<Double> {\n-    /**\n-     * {@inheritDoc}\n-     */\n+    /** {@inheritDoc} */\n     @Override\n     protected Pair<Double[], Double[]> computeRule(int numberOfPoints)\n-        throws NotStrictlyPositiveException {\n-        if (numberOfPoints <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_POINTS,\n-                                                   numberOfPoints);\n-        }\n+        throws DimensionMismatchException {\n \n         if (numberOfPoints == 1) {\n             // Break recursion.\n--- a/src/main/java/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolator.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolator.java\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.NoDataException;\n import org.apache.commons.math3.exception.NonMonotonicSequenceException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.util.MathArrays;\n \n /**\n     public BicubicSplineInterpolatingFunction interpolate(final double[] xval,\n                                                           final double[] yval,\n                                                           final double[][] fval)\n-        throws NoDataException,\n-               DimensionMismatchException,\n-               NonMonotonicSequenceException {\n+        throws NoDataException, DimensionMismatchException,\n+               NonMonotonicSequenceException, NumberIsTooSmallException {\n         if (xval.length == 0 || yval.length == 0 || fval.length == 0) {\n             throw new NoDataException();\n         }\n--- a/src/main/java/org/apache/commons/math3/analysis/interpolation/BivariateGridInterpolator.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/interpolation/BivariateGridInterpolator.java\n import org.apache.commons.math3.analysis.BivariateFunction;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.NoDataException;\n+import org.apache.commons.math3.exception.NonMonotonicSequenceException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n \n /**\n  * Interface representing a bivariate real interpolating function where the\n      * @return a function which interpolates the dataset.\n      * @throws NoDataException if any of the arrays has zero length.\n      * @throws DimensionMismatchException if the array lengths are inconsistent.\n+     * @throws NonMonotonicSequenceException if the array is not sorted.\n+     * @throws NumberIsTooSmallException if the number of points is too small for\n+     * the order of the interpolation\n      */\n     BivariateFunction interpolate(double[] xval, double[] yval,\n                                   double[][] fval)\n-        throws NoDataException,\n-               DimensionMismatchException;\n+        throws NoDataException, DimensionMismatchException,\n+               NonMonotonicSequenceException, NumberIsTooSmallException;\n }\n--- a/src/main/java/org/apache/commons/math3/analysis/interpolation/FieldHermiteInterpolator.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/interpolation/FieldHermiteInterpolator.java\n import java.util.List;\n \n import org.apache.commons.math3.FieldElement;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.MathArithmeticException;\n import org.apache.commons.math3.exception.NoDataException;\n+import org.apache.commons.math3.exception.NullArgumentException;\n import org.apache.commons.math3.exception.ZeroException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n import org.apache.commons.math3.util.MathArrays;\n+import org.apache.commons.math3.util.MathUtils;\n \n /** Polynomial interpolator using both sample values and sample derivatives.\n  * <p>\n      * and a previous point is zero (i.e. the two points are at same abscissa)\n      * @exception MathArithmeticException if the number of derivatives is larger\n      * than 20, which prevents computation of a factorial\n+     * @throws DimensionMismatchException if derivative structures are inconsistent\n+     * @throws NullArgumentException if x is null\n      */\n     public void addSamplePoint(final T x, final T[] ... value)\n-        throws ZeroException, MathArithmeticException {\n-\n+        throws ZeroException, MathArithmeticException,\n+               DimensionMismatchException, NullArgumentException {\n+\n+        MathUtils.checkNotNull(x);\n         T factorial = x.getField().getOne();\n         for (int i = 0; i < value.length; ++i) {\n \n      * @param x interpolation abscissa\n      * @return interpolated value\n      * @exception NoDataException if sample is empty\n-     */\n-    public T[] value(T x) throws NoDataException {\n+     * @throws NullArgumentException if x is null\n+     */\n+    public T[] value(T x) throws NoDataException, NullArgumentException {\n \n         // safety check\n+        MathUtils.checkNotNull(x);\n         if (abscissae.isEmpty()) {\n             throw new NoDataException(LocalizedFormats.EMPTY_INTERPOLATION_SAMPLE);\n         }\n      * @return interpolated value and derivatives (value in row 0,\n      * 1<sup>st</sup> derivative in row 1, ... n<sup>th</sup> derivative in row n)\n      * @exception NoDataException if sample is empty\n-     */\n-    public T[][] derivatives(T x, int order) throws NoDataException {\n+     * @throws NullArgumentException if x is null\n+     */\n+    public T[][] derivatives(T x, int order) throws NoDataException, NullArgumentException {\n \n         // safety check\n+        MathUtils.checkNotNull(x);\n         if (abscissae.isEmpty()) {\n             throw new NoDataException(LocalizedFormats.EMPTY_INTERPOLATION_SAMPLE);\n         }\n--- a/src/main/java/org/apache/commons/math3/analysis/interpolation/MicrosphereInterpolatingFunction.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/interpolation/MicrosphereInterpolatingFunction.java\n     /**\n      * @param point Interpolation point.\n      * @return the interpolated value.\n-     */\n-    public double value(double[] point) {\n+     * @throws DimensionMismatchException if point dimension does not math sample\n+     */\n+    public double value(double[] point) throws DimensionMismatchException {\n         final RealVector p = new ArrayRealVector(point);\n \n         // Reset.\n--- a/src/main/java/org/apache/commons/math3/analysis/interpolation/MultivariateInterpolator.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/interpolation/MultivariateInterpolator.java\n package org.apache.commons.math3.analysis.interpolation;\n \n import org.apache.commons.math3.analysis.MultivariateFunction;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.NoDataException;\n+import org.apache.commons.math3.exception.NullArgumentException;\n \n /**\n  * Interface representing a univariate real interpolating function.\n      * point (where {@code d} is thus the dimension of the space).\n      * @param yval the values for the interpolation points\n      * @return a function which interpolates the data set\n-     * @throws org.apache.commons.math3.exception.MathIllegalArgumentException\n-     * if the arguments violate assumptions made by the interpolation\n-     * algorithm.\n-     * @throws org.apache.commons.math3.exception.DimensionMismatchException\n-     * when the array dimensions are not consistent.\n-     * @throws org.apache.commons.math3.exception.NoDataException if an\n-     * array has zero-length.\n-     * @throws org.apache.commons.math3.exception.NullArgumentException if\n-     * the arguments are {@code null}.\n+     * @throws MathIllegalArgumentException if the arguments violate assumptions\n+     * made by the interpolation algorithm.\n+     * @throws DimensionMismatchException when the array dimensions are not consistent.\n+     * @throws NoDataException if an array has zero-length.\n+     * @throws NullArgumentException if the arguments are {@code null}.\n      */\n-    MultivariateFunction interpolate(double[][] xval, double[] yval);\n+    MultivariateFunction interpolate(double[][] xval, double[] yval)\n+        throws MathIllegalArgumentException, DimensionMismatchException,\n+               NoDataException, NullArgumentException;\n }\n--- a/src/main/java/org/apache/commons/math3/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolator.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolator.java\n \n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.NoDataException;\n+import org.apache.commons.math3.exception.NonMonotonicSequenceException;\n import org.apache.commons.math3.exception.NotPositiveException;\n+import org.apache.commons.math3.exception.NullArgumentException;\n import org.apache.commons.math3.util.MathArrays;\n import org.apache.commons.math3.util.Precision;\n import org.apache.commons.math3.optim.nonlinear.vector.jacobian.GaussNewtonOptimizer;\n \n     /**\n      * @param degree Degree of the polynomial fitting functions.\n+     * @exception NotPositiveException if degree is not positive\n      */\n-    public SmoothingPolynomialBicubicSplineInterpolator(int degree) {\n+    public SmoothingPolynomialBicubicSplineInterpolator(int degree)\n+        throws NotPositiveException {\n         this(degree, degree);\n     }\n \n      * x-dimension.\n      * @param yDegree Degree of the polynomial fitting functions along the\n      * y-dimension.\n+     * @exception NotPositiveException if degrees are not positive\n      */\n-    public SmoothingPolynomialBicubicSplineInterpolator(int xDegree,\n-                                                        int yDegree) {\n+    public SmoothingPolynomialBicubicSplineInterpolator(int xDegree, int yDegree)\n+        throws NotPositiveException {\n         if (xDegree < 0) {\n             throw new NotPositiveException(xDegree);\n         }\n     public BicubicSplineInterpolatingFunction interpolate(final double[] xval,\n                                                           final double[] yval,\n                                                           final double[][] fval)\n-        throws NoDataException,\n-               DimensionMismatchException {\n+        throws NoDataException, NullArgumentException,\n+               DimensionMismatchException, NonMonotonicSequenceException {\n         if (xval.length == 0 || yval.length == 0 || fval.length == 0) {\n             throw new NoDataException();\n         }\n--- a/src/main/java/org/apache/commons/math3/analysis/interpolation/TricubicSplineInterpolator.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/interpolation/TricubicSplineInterpolator.java\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.NoDataException;\n import org.apache.commons.math3.exception.NonMonotonicSequenceException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.util.MathArrays;\n \n /**\n                                                            final double[] yval,\n                                                            final double[] zval,\n                                                            final double[][][] fval)\n-        throws NoDataException,\n-               DimensionMismatchException,\n-               NonMonotonicSequenceException {\n+        throws NoDataException, NumberIsTooSmallException,\n+               DimensionMismatchException, NonMonotonicSequenceException {\n         if (xval.length == 0 || yval.length == 0 || zval.length == 0 || fval.length == 0) {\n             throw new NoDataException();\n         }\n--- a/src/main/java/org/apache/commons/math3/analysis/interpolation/TrivariateGridInterpolator.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/interpolation/TrivariateGridInterpolator.java\n import org.apache.commons.math3.analysis.TrivariateFunction;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.NoDataException;\n+import org.apache.commons.math3.exception.NonMonotonicSequenceException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n \n /**\n  * Interface representing a trivariate real interpolating function where the\n      * @return a function that interpolates the data set.\n      * @throws NoDataException if any of the arrays has zero length.\n      * @throws DimensionMismatchException if the array lengths are inconsistent.\n+     * @throws NonMonotonicSequenceException if arrays are not sorted\n+     * @throws NumberIsTooSmallException if the number of points is too small for\n+     * the order of the interpolation\n      */\n     TrivariateFunction interpolate(double[] xval, double[] yval, double[] zval,\n                                    double[][][] fval)\n-        throws NoDataException,\n-               DimensionMismatchException;\n+        throws NoDataException, NumberIsTooSmallException,\n+               DimensionMismatchException, NonMonotonicSequenceException;\n }\n--- a/src/main/java/org/apache/commons/math3/analysis/interpolation/UnivariateInterpolator.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/interpolation/UnivariateInterpolator.java\n package org.apache.commons.math3.analysis.interpolation;\n \n import org.apache.commons.math3.analysis.UnivariateFunction;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n \n /**\n  * Interface representing a univariate real interpolating function.\n      * @param xval Arguments for the interpolation points.\n      * @param yval Values for the interpolation points.\n      * @return a function which interpolates the dataset.\n-     * @throws org.apache.commons.math3.exception.MathIllegalArgumentException\n+     * @throws MathIllegalArgumentException\n      * if the arguments violate assumptions made by the interpolation\n      * algorithm.\n+     * @throws DimensionMismatchException if arrays lengthes do not match\n      */\n-    UnivariateFunction interpolate(double xval[], double yval[]);\n+    UnivariateFunction interpolate(double xval[], double yval[])\n+        throws MathIllegalArgumentException, DimensionMismatchException;\n }\n--- a/src/main/java/org/apache/commons/math3/analysis/interpolation/UnivariatePeriodicInterpolator.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/interpolation/UnivariatePeriodicInterpolator.java\n import org.apache.commons.math3.analysis.UnivariateFunction;\n import org.apache.commons.math3.util.MathUtils;\n import org.apache.commons.math3.util.MathArrays;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.NonMonotonicSequenceException;\n import org.apache.commons.math3.exception.NumberIsTooSmallException;\n \n /**\n      */\n     public UnivariateFunction interpolate(double[] xval,\n                                           double[] yval)\n-        throws NumberIsTooSmallException {\n+        throws NumberIsTooSmallException, NonMonotonicSequenceException {\n         if (xval.length < extend) {\n             throw new NumberIsTooSmallException(xval.length, extend, true);\n         }\n \n         final UnivariateFunction f = interpolator.interpolate(x, y);\n         return new UnivariateFunction() {\n-            public double value(final double x) {\n+            public double value(final double x) throws MathIllegalArgumentException {\n                 return f.value(MathUtils.reduce(x, period, offset));\n             }\n         };\n--- a/src/main/java/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.java\n         }\n \n         /** {@inheritDoc} */\n-        public double value(final double x, final double ... parameters) {\n+        public double value(final double x, final double ... parameters)\n+            throws NoDataException {\n             return PolynomialFunction.evaluate(parameters, x);\n         }\n     }\n--- a/src/main/java/org/apache/commons/math3/analysis/polynomials/PolynomialFunctionLagrangeForm.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/polynomials/PolynomialFunctionLagrangeForm.java\n import org.apache.commons.math3.util.FastMath;\n import org.apache.commons.math3.util.MathArrays;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.NonMonotonicSequenceException;\n import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n \n      * @param y function values at interpolating points\n      * @throws DimensionMismatchException if the array lengths are different.\n      * @throws NumberIsTooSmallException if the number of points is less than 2.\n-     * @throws org.apache.commons.math3.exception.NonMonotonicSequenceException\n+     * @throws NonMonotonicSequenceException\n      * if two abscissae have the same value.\n      */\n-    public PolynomialFunctionLagrangeForm(double x[], double y[]) {\n+    public PolynomialFunctionLagrangeForm(double x[], double y[])\n+        throws DimensionMismatchException, NumberIsTooSmallException, NonMonotonicSequenceException {\n         this.x = new double[x.length];\n         this.y = new double[y.length];\n         System.arraycopy(x, 0, this.x, 0, x.length);\n      * @return the function value.\n      * @throws DimensionMismatchException if {@code x} and {@code y} have\n      * different lengths.\n-     * @throws org.apache.commons.math3.exception.NonMonotonicSequenceException\n+     * @throws NonMonotonicSequenceException\n      * if {@code x} is not sorted in strictly increasing order.\n      * @throws NumberIsTooSmallException if the size of {@code x} is less\n      * than 2.\n      */\n-    public static double evaluate(double x[], double y[], double z) {\n+    public static double evaluate(double x[], double y[], double z)\n+        throws DimensionMismatchException, NumberIsTooSmallException, NonMonotonicSequenceException {\n         if (verifyInterpolationArray(x, y, false)) {\n             return evaluateInternal(x, y, z);\n         }\n      * @see #evaluate(double[], double[], double)\n      * @see #computeCoefficients()\n      */\n-    public static boolean verifyInterpolationArray(double x[], double y[], boolean abort) {\n+    public static boolean verifyInterpolationArray(double x[], double y[], boolean abort)\n+        throws DimensionMismatchException, NumberIsTooSmallException, NonMonotonicSequenceException {\n         if (x.length != y.length) {\n             throw new DimensionMismatchException(x.length, y.length);\n         }\n--- a/src/main/java/org/apache/commons/math3/analysis/polynomials/PolynomialFunctionNewtonForm.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/polynomials/PolynomialFunctionNewtonForm.java\n import org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.NoDataException;\n+import org.apache.commons.math3.exception.NullArgumentException;\n import org.apache.commons.math3.exception.util.LocalizedFormats;\n+import org.apache.commons.math3.util.MathUtils;\n \n /**\n  * Implements the representation of a real polynomial function in\n      *\n      * @param a Coefficients in Newton form formula.\n      * @param c Centers.\n-     * @throws org.apache.commons.math3.exception.NullArgumentException if\n-     * any argument is {@code null}.\n+     * @throws NullArgumentException if any argument is {@code null}.\n      * @throws NoDataException if any array has zero length.\n      * @throws DimensionMismatchException if the size difference between\n      * {@code a} and {@code c} is not equal to 1.\n      */\n-    public PolynomialFunctionNewtonForm(double a[], double c[]) {\n+    public PolynomialFunctionNewtonForm(double a[], double c[])\n+        throws NullArgumentException, NoDataException, DimensionMismatchException {\n \n         verifyInputArray(a, c);\n         this.a = new double[a.length];\n      * @param c Centers.\n      * @param z Point at which the function value is to be computed.\n      * @return the function value.\n-     * @throws org.apache.commons.math3.exception.NullArgumentException if\n-     * any argument is {@code null}.\n+     * @throws NullArgumentException if any argument is {@code null}.\n      * @throws NoDataException if any array has zero length.\n      * @throws DimensionMismatchException if the size difference between\n      * {@code a} and {@code c} is not equal to 1.\n      */\n-    public static double evaluate(double a[], double c[], double z) {\n+    public static double evaluate(double a[], double c[], double z)\n+        throws NullArgumentException, DimensionMismatchException, NoDataException {\n         verifyInputArray(a, c);\n \n         final int n = c.length;\n      *\n      * @param a the coefficients in Newton form formula\n      * @param c the centers\n-     * @throws org.apache.commons.math3.exception.NullArgumentException if\n-     * any argument is {@code null}.\n+     * @throws NullArgumentException if any argument is {@code null}.\n      * @throws NoDataException if any array has zero length.\n      * @throws DimensionMismatchException if the size difference between\n      * {@code a} and {@code c} is not equal to 1.\n      * @see org.apache.commons.math3.analysis.interpolation.DividedDifferenceInterpolator#computeDividedDifference(double[],\n      * double[])\n      */\n-    protected static void verifyInputArray(double a[], double c[]) {\n-        if (a.length == 0 ||\n-            c.length == 0) {\n+    protected static void verifyInputArray(double a[], double c[])\n+        throws NullArgumentException, NoDataException, DimensionMismatchException {\n+        MathUtils.checkNotNull(a);\n+        MathUtils.checkNotNull(c);\n+        if (a.length == 0 || c.length == 0) {\n             throw new NoDataException(LocalizedFormats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY);\n         }\n         if (a.length != c.length + 1) {\n--- a/src/main/java/org/apache/commons/math3/analysis/polynomials/PolynomialSplineFunction.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/polynomials/PolynomialSplineFunction.java\n import org.apache.commons.math3.analysis.UnivariateFunction;\n import org.apache.commons.math3.analysis.differentiation.DerivativeStructure;\n import org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction;\n+import org.apache.commons.math3.exception.NonMonotonicSequenceException;\n import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n      * @throws NullArgumentException if either of the input arrays is {@code null}.\n      * @throws NumberIsTooSmallException if knots has length less than 2.\n      * @throws DimensionMismatchException if {@code polynomials.length != knots.length - 1}.\n-     * @throws org.apache.commons.math3.exception.NonMonotonicSequenceException if\n-     * the {@code knots} array is not strictly increasing.\n-     *\n-     */\n-    public PolynomialSplineFunction(double knots[], PolynomialFunction polynomials[]) {\n+     * @throws NonMonotonicSequenceException if the {@code knots} array is not strictly increasing.\n+     *\n+     */\n+    public PolynomialSplineFunction(double knots[], PolynomialFunction polynomials[])\n+        throws NullArgumentException, NumberIsTooSmallException,\n+               DimensionMismatchException, NonMonotonicSequenceException{\n         if (knots == null ||\n             polynomials == null) {\n             throw new NullArgumentException();\n--- a/src/main/java/org/apache/commons/math3/analysis/solvers/AbstractDifferentiableUnivariateSolver.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/solvers/AbstractDifferentiableUnivariateSolver.java\n      *\n      * @param point Point at which the objective function must be evaluated.\n      * @return the objective function value at specified point.\n-     * @throws org.apache.commons.math3.exception.TooManyEvaluationsException\n-     * if the maximal number of evaluations is exceeded.\n+     * @throws TooManyEvaluationsException if the maximal number of evaluations is exceeded.\n      */\n     protected double computeDerivativeObjectiveValue(double point)\n         throws TooManyEvaluationsException {\n--- a/src/main/java/org/apache/commons/math3/analysis/solvers/AbstractUnivariateDifferentiableSolver.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/solvers/AbstractUnivariateDifferentiableSolver.java\n \n import org.apache.commons.math3.analysis.differentiation.DerivativeStructure;\n import org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction;\n+import org.apache.commons.math3.exception.TooManyEvaluationsException;\n \n /**\n  * Provide a default implementation for several functions useful to generic\n      *\n      * @param point Point at which the objective function must be evaluated.\n      * @return the objective function value and derivative at specified point.\n-     * @throws org.apache.commons.math3.exception.TooManyEvaluationsException\n+     * @throws TooManyEvaluationsException\n      * if the maximal number of evaluations is exceeded.\n      */\n-    protected DerivativeStructure computeObjectiveValueAndDerivative(double point) {\n+    protected DerivativeStructure computeObjectiveValueAndDerivative(double point)\n+        throws TooManyEvaluationsException {\n         incrementEvaluationCount();\n         return function.value(new DerivativeStructure(1, 1, 0, point));\n     }\n--- a/src/main/java/org/apache/commons/math3/analysis/solvers/BaseAbstractUnivariateSolver.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/solvers/BaseAbstractUnivariateSolver.java\n      * @param max Upper bound for the interval.\n      * @param startValue Start value to use.\n      * @param maxEval Maximum number of evaluations.\n+     * @exception NullArgumentException if f is null\n      */\n     protected void setup(int maxEval,\n                          FUNC f,\n                          double min, double max,\n-                         double startValue) {\n+                         double startValue)\n+        throws NullArgumentException {\n         // Checks.\n         MathUtils.checkNotNull(f);\n \n--- a/src/main/java/org/apache/commons/math3/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/solvers/BaseSecantSolver.java\n      */\n     @Override\n     protected final double doSolve()\n-        throws ConvergenceException,\n-               MathInternalError {\n+        throws ConvergenceException {\n         // Get initial solution\n         double x0 = getMin();\n         double x1 = getMax();\n--- a/src/main/java/org/apache/commons/math3/analysis/solvers/BaseUnivariateSolver.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/solvers/BaseUnivariateSolver.java\n package org.apache.commons.math3.analysis.solvers;\n \n import org.apache.commons.math3.analysis.UnivariateFunction;\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+import org.apache.commons.math3.exception.TooManyEvaluationsException;\n \n \n /**\n      * @param min Lower bound for the interval.\n      * @param max Upper bound for the interval.\n      * @return a value where the function is zero.\n-     * @throws org.apache.commons.math3.exception.MathIllegalArgumentException\n+     * @throws MathIllegalArgumentException\n      * if the arguments do not satisfy the requirements specified by the solver.\n-     * @throws org.apache.commons.math3.exception.TooManyEvaluationsException if\n+     * @throws TooManyEvaluationsException if\n      * the allowed number of evaluations is exceeded.\n      */\n-    double solve(int maxEval, FUNC f, double min, double max);\n+    double solve(int maxEval, FUNC f, double min, double max)\n+        throws MathIllegalArgumentException, TooManyEvaluationsException;\n \n     /**\n      * Solve for a zero in the given interval, start at {@code startValue}.\n      * @param max Upper bound for the interval.\n      * @param startValue Start value to use.\n      * @return a value where the function is zero.\n-     * @throws org.apache.commons.math3.exception.MathIllegalArgumentException\n+     * @throws MathIllegalArgumentException\n      * if the arguments do not satisfy the requirements specified by the solver.\n-     * @throws org.apache.commons.math3.exception.TooManyEvaluationsException if\n+     * @throws TooManyEvaluationsException if\n      * the allowed number of evaluations is exceeded.\n      */\n-    double solve(int maxEval, FUNC f, double min, double max, double startValue);\n+    double solve(int maxEval, FUNC f, double min, double max, double startValue)\n+        throws MathIllegalArgumentException, TooManyEvaluationsException;\n \n     /**\n      * Solve for a zero in the vicinity of {@code startValue}.\n--- a/src/main/java/org/apache/commons/math3/util/Incrementor.java\n+++ b/src/main/java/org/apache/commons/math3/util/Incrementor.java\n         this(max,\n              new MaxCountExceededCallback() {\n                  /** {@inheritDoc} */\n-                 public void trigger(int max) {\n+                 public void trigger(int max) throws MaxCountExceededException {\n                      throw new MaxCountExceededException(max);\n                  }\n              });\n      * @param cb Function to be called when the maximal count has been reached.\n      * @throws NullArgumentException if {@code cb} is {@code null}\n      */\n-    public Incrementor(int max,\n-                       MaxCountExceededCallback cb) {\n+    public Incrementor(int max, MaxCountExceededCallback cb)\n+        throws NullArgumentException {\n         if (cb == null){\n             throw new NullArgumentException();\n         }\n      * @param value Number of increments.\n      * @throws MaxCountExceededException at counter exhaustion.\n      */\n-    public void incrementCount(int value) {\n+    public void incrementCount(int value) throws MaxCountExceededException {\n         for (int i = 0; i < value; i++) {\n             incrementCount();\n         }\n      * custom {@link MaxCountExceededCallback callback} has been set at\n      * construction.\n      */\n-    public void incrementCount() {\n+    public void incrementCount() throws MaxCountExceededException {\n         if (++count > maximalCount) {\n             maxCountCallback.trigger(maximalCount);\n         }\n          * Function called when the maximal count has been reached.\n          *\n          * @param maximalCount Maximal count.\n+         * @throws MaxCountExceededException at counter exhaustion\n          */\n-        void trigger(int maximalCount);\n+        void trigger(int maximalCount) throws MaxCountExceededException;\n     }\n }\n--- a/src/main/java/org/apache/commons/math3/util/MathArrays.java\n+++ b/src/main/java/org/apache/commons/math3/util/MathArrays.java\n      * @throws DimensionMismatchException if the array lengths differ.\n      * @since 3.1\n      */\n-    public static double[] ebeAdd(double[] a,\n-                                  double[] b) {\n+    public static double[] ebeAdd(double[] a, double[] b)\n+        throws DimensionMismatchException {\n         if (a.length != b.length) {\n             throw new DimensionMismatchException(a.length, b.length);\n         }\n      * @throws DimensionMismatchException if the array lengths differ.\n      * @since 3.1\n      */\n-    public static double[] ebeSubtract(double[] a,\n-                                       double[] b) {\n+    public static double[] ebeSubtract(double[] a, double[] b)\n+        throws DimensionMismatchException {\n         if (a.length != b.length) {\n             throw new DimensionMismatchException(a.length, b.length);\n         }\n      * @throws DimensionMismatchException if the array lengths differ.\n      * @since 3.1\n      */\n-    public static double[] ebeMultiply(double[] a,\n-                                       double[] b) {\n+    public static double[] ebeMultiply(double[] a, double[] b)\n+        throws DimensionMismatchException {\n         if (a.length != b.length) {\n             throw new DimensionMismatchException(a.length, b.length);\n         }\n      * @throws DimensionMismatchException if the array lengths differ.\n      * @since 3.1\n      */\n-    public static double[] ebeDivide(double[] a,\n-                                     double[] b) {\n+    public static double[] ebeDivide(double[] a, double[] b)\n+        throws DimensionMismatchException {\n         if (a.length != b.length) {\n             throw new DimensionMismatchException(a.length, b.length);\n         }\n      * @param strict Whether the order should be strict.\n      * @return {@code true} if sorted, {@code false} otherwise.\n      */\n-    public static boolean isMonotonic(double[] val,\n-                                      OrderDirection dir,\n-                                      boolean strict) {\n+    public static boolean isMonotonic(double[] val, OrderDirection dir, boolean strict) {\n         return checkOrder(val, dir, strict, false);\n     }\n ", "timestamp": 1363016754, "metainfo": ""}