{"sha": "a6e271ccacba30012f94ab9378e57e4540eecea2", "log": "Added rank revealing QR decomposition.  Patch applied after conversion to current status and slight adaptations.  JIRA: MATH-630  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/linear/QRDecomposition.java\n+++ b/src/main/java/org/apache/commons/math3/linear/QRDecomposition.java\n         cachedR  = null;\n         cachedH  = null;\n \n+        decompose(qrt);\n+\n+    }\n+\n+    /** Decompose matrix.\n+     * @param qrt transposed matrix\n+     */\n+    protected void decompose(double[][] qrt) {\n+        for (int minor = 0; minor < FastMath.min(qrt.length, qrt[0].length); minor++) {\n+            performHouseholderReflection(minor, qrt);\n+        }\n+    }\n+\n+    /** Perform Householder reflection for a minor A(minor, minor) of A.\n+     * @param minor minor index\n+     * @param qrt transposed matrix\n+     */\n+    protected void performHouseholderReflection(int minor, double[][] qrt) {\n+\n+        final double[] qrtMinor = qrt[minor];\n+\n         /*\n-         * The QR decomposition of a matrix A is calculated using Householder\n-         * reflectors by repeating the following operations to each minor\n-         * A(minor,minor) of A:\n+         * Let x be the first column of the minor, and a^2 = |x|^2.\n+         * x will be in the positions qr[minor][minor] through qr[m][minor].\n+         * The first column of the transformed minor will be (a,0,0,..)'\n+         * The sign of a is chosen to be opposite to the sign of the first\n+         * component of x. Let's find a:\n          */\n-        for (int minor = 0; minor < FastMath.min(m, n); minor++) {\n-\n-            final double[] qrtMinor = qrt[minor];\n+        double xNormSqr = 0;\n+        for (int row = minor; row < qrtMinor.length; row++) {\n+            final double c = qrtMinor[row];\n+            xNormSqr += c * c;\n+        }\n+        final double a = (qrtMinor[minor] > 0) ? -FastMath.sqrt(xNormSqr) : FastMath.sqrt(xNormSqr);\n+        rDiag[minor] = a;\n+\n+        if (a != 0.0) {\n \n             /*\n-             * Let x be the first column of the minor, and a^2 = |x|^2.\n-             * x will be in the positions qr[minor][minor] through qr[m][minor].\n-             * The first column of the transformed minor will be (a,0,0,..)'\n-             * The sign of a is chosen to be opposite to the sign of the first\n-             * component of x. Let's find a:\n+             * Calculate the normalized reflection vector v and transform\n+             * the first column. We know the norm of v beforehand: v = x-ae\n+             * so |v|^2 = <x-ae,x-ae> = <x,x>-2a<x,e>+a^2<e,e> =\n+             * a^2+a^2-2a<x,e> = 2a*(a - <x,e>).\n+             * Here <x, e> is now qr[minor][minor].\n+             * v = x-ae is stored in the column at qr:\n              */\n-            double xNormSqr = 0;\n-            for (int row = minor; row < m; row++) {\n-                final double c = qrtMinor[row];\n-                xNormSqr += c * c;\n-            }\n-            final double a = (qrtMinor[minor] > 0) ? -FastMath.sqrt(xNormSqr) : FastMath.sqrt(xNormSqr);\n-            rDiag[minor] = a;\n-\n-            if (a != 0.0) {\n-\n-                /*\n-                 * Calculate the normalized reflection vector v and transform\n-                 * the first column. We know the norm of v beforehand: v = x-ae\n-                 * so |v|^2 = <x-ae,x-ae> = <x,x>-2a<x,e>+a^2<e,e> =\n-                 * a^2+a^2-2a<x,e> = 2a*(a - <x,e>).\n-                 * Here <x, e> is now qr[minor][minor].\n-                 * v = x-ae is stored in the column at qr:\n-                 */\n-                qrtMinor[minor] -= a; // now |v|^2 = -2a*(qr[minor][minor])\n-\n-                /*\n-                 * Transform the rest of the columns of the minor:\n-                 * They will be transformed by the matrix H = I-2vv'/|v|^2.\n-                 * If x is a column vector of the minor, then\n-                 * Hx = (I-2vv'/|v|^2)x = x-2vv'x/|v|^2 = x - 2<x,v>/|v|^2 v.\n-                 * Therefore the transformation is easily calculated by\n-                 * subtracting the column vector (2<x,v>/|v|^2)v from x.\n-                 *\n-                 * Let 2<x,v>/|v|^2 = alpha. From above we have\n-                 * |v|^2 = -2a*(qr[minor][minor]), so\n-                 * alpha = -<x,v>/(a*qr[minor][minor])\n-                 */\n-                for (int col = minor+1; col < n; col++) {\n-                    final double[] qrtCol = qrt[col];\n-                    double alpha = 0;\n-                    for (int row = minor; row < m; row++) {\n-                        alpha -= qrtCol[row] * qrtMinor[row];\n-                    }\n-                    alpha /= a * qrtMinor[minor];\n-\n-                    // Subtract the column vector alpha*v from x.\n-                    for (int row = minor; row < m; row++) {\n-                        qrtCol[row] -= alpha * qrtMinor[row];\n-                    }\n-                }\n-            }\n-        }\n-    }\n+            qrtMinor[minor] -= a; // now |v|^2 = -2a*(qr[minor][minor])\n+\n+            /*\n+             * Transform the rest of the columns of the minor:\n+             * They will be transformed by the matrix H = I-2vv'/|v|^2.\n+             * If x is a column vector of the minor, then\n+             * Hx = (I-2vv'/|v|^2)x = x-2vv'x/|v|^2 = x - 2<x,v>/|v|^2 v.\n+             * Therefore the transformation is easily calculated by\n+             * subtracting the column vector (2<x,v>/|v|^2)v from x.\n+             *\n+             * Let 2<x,v>/|v|^2 = alpha. From above we have\n+             * |v|^2 = -2a*(qr[minor][minor]), so\n+             * alpha = -<x,v>/(a*qr[minor][minor])\n+             */\n+            for (int col = minor+1; col < qrt.length; col++) {\n+                final double[] qrtCol = qrt[col];\n+                double alpha = 0;\n+                for (int row = minor; row < qrtCol.length; row++) {\n+                    alpha -= qrtCol[row] * qrtMinor[row];\n+                }\n+                alpha /= a * qrtMinor[minor];\n+\n+                // Subtract the column vector alpha*v from x.\n+                for (int row = minor; row < qrtCol.length; row++) {\n+                    qrtCol[row] -= alpha * qrtMinor[row];\n+                }\n+            }\n+        }\n+    }\n+\n \n     /**\n      * Returns the matrix R of the decomposition.\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/linear/RRQRDecomposition.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.linear;\n+\n+import org.apache.commons.math3.util.FastMath;\n+\n+\n+/**\n+ * Calculates the rank-revealing QR-decomposition of a matrix, with column pivoting.\n+ * <p>The rank-revealing QR-decomposition of a matrix A consists of three matrices Q,\n+ * R and P such that AP=QR.  Q is orthogonal (Q<sup>T</sup>Q = I), and R is upper triangular.\n+ * If A is m&times;n, Q is m&times;m and R is m&times;n and P is n&times;n.</p>\n+ * <p>QR decomposition with column pivoting produces a rank-revealing QR\n+ * decomposition and the {@link #getRank(double)} method may be used to return the rank of the\n+ * input matrix A.</p>\n+ * <p>This class compute the decomposition using Householder reflectors.</p>\n+ * <p>For efficiency purposes, the decomposition in packed form is transposed.\n+ * This allows inner loop to iterate inside rows, which is much more cache-efficient\n+ * in Java.</p>\n+ * <p>This class is based on the class with similar name from the\n+ * <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a> library, with the\n+ * following changes:</p>\n+ * <ul>\n+ *   <li>a {@link #getQT() getQT} method has been added,</li>\n+ *   <li>the {@code solve} and {@code isFullRank} methods have been replaced\n+ *   by a {@link #getSolver() getSolver} method and the equivalent methods\n+ *   provided by the returned {@link DecompositionSolver}.</li>\n+ * </ul>\n+ *\n+ * @see <a href=\"http://mathworld.wolfram.com/QRDecomposition.html\">MathWorld</a>\n+ * @see <a href=\"http://en.wikipedia.org/wiki/QR_decomposition\">Wikipedia</a>\n+ *\n+ * @version $Id$\n+ * @since 3.2\n+ */\n+public class RRQRDecomposition extends QRDecomposition {\n+\n+    /** An array to record the column pivoting for later creation of P. */\n+    private int[] p;\n+\n+    /** Cached value of P. */\n+    private RealMatrix cachedP;\n+\n+\n+    /**\n+     * Calculates the QR-decomposition of the given matrix.\n+     * The singularity threshold defaults to zero.\n+     *\n+     * @param matrix The matrix to decompose.\n+     *\n+     * @see #QRDecomposition(RealMatrix,double)\n+     */\n+    public RRQRDecomposition(RealMatrix matrix) {\n+        this(matrix, 0d);\n+    }\n+\n+   /**\n+     * Calculates the QR-decomposition of the given matrix.\n+     *\n+     * @param matrix The matrix to decompose.\n+     * @param threshold Singularity threshold.\n+     */\n+    public RRQRDecomposition(RealMatrix matrix,  double threshold) {\n+        super(matrix, threshold);\n+    }\n+\n+    /** Decompose matrix.\n+     * @param qrt transposed matrix\n+     */\n+    protected void decompose(double[][] qrt) {\n+        p = new int[qrt.length];\n+        for (int i = 0; i < p.length; i++) {\n+            p[i] = i;\n+        }\n+        super.decompose(qrt);\n+    }\n+\n+    /** Perform Householder reflection for a minor A(minor, minor) of A.\n+     * @param minor minor index\n+     * @param qrt transposed matrix\n+     */\n+    protected void performHouseholderReflection(int minor, double[][] qrt) {\n+\n+        double l2NormSquaredMax = 0;\n+        // Find the unreduced column with the greatest L2-Norm\n+        int l2NormSquaredMaxIndex = minor;\n+        for (int i = minor; i < qrt.length; i++) {\n+            double l2NormSquared = 0;\n+            for (int j = 0; j < qrt[i].length; j++) {\n+                l2NormSquared += qrt[i][j] * qrt[i][j];\n+            }\n+            if (l2NormSquared > l2NormSquaredMax) {\n+                l2NormSquaredMax = l2NormSquared;\n+                l2NormSquaredMaxIndex = i;\n+            }\n+        }\n+        // swap the current column with that with the greated L2-Norm and record in p\n+        if (l2NormSquaredMaxIndex != minor) {\n+            double[] tmp1 = qrt[minor];\n+            qrt[minor] = qrt[l2NormSquaredMaxIndex];\n+            qrt[l2NormSquaredMaxIndex] = tmp1;\n+            int tmp2 = p[minor];\n+            p[minor] = p[l2NormSquaredMaxIndex];\n+            p[l2NormSquaredMaxIndex] = tmp2;\n+        }\n+\n+        super.performHouseholderReflection(minor, qrt);\n+\n+    }\n+\n+\n+    /**\n+     * Returns the pivot matrix, P, used in the QR Decomposition of matrix A such that AP = QR.\n+     *\n+     * If no pivoting is used in this decomposition then P is equal to the identity matrix.\n+     *\n+     * @return a permutation matrix.\n+     */\n+    public RealMatrix getP() {\n+        if (cachedP == null) {\n+            int n = p.length;\n+            cachedP = MatrixUtils.createRealMatrix(n,n);\n+            for (int i = 0; i < n; i++) {\n+                cachedP.setEntry(p[i], i, 1);\n+            }\n+        }\n+        return cachedP ;\n+    }\n+\n+    /**\n+     * Return the effective numerical matrix rank.\n+     * <p>The effective numerical rank is the number of non-negligible\n+     * singular values.</p>\n+     * <p>This implementation looks at Frobenius norms of the sequence of\n+     * bottom right submatrices.  When a large fall in norm is seen,\n+     * the rank is returned. The drop is computed as:</p>\n+     * <pre>\n+     *   (thisNorm/lastNorm) * rNorm < dropThreshold\n+     * </pre>\n+     * <p>\n+     * where thisNorm is the Frobenius norm of the current submatrix,\n+     * lastNorm is the Frobenius norm of the previous submatrix,\n+     * rNorm is is the Frobenius norm of the complete matrix\n+     * </p>\n+     *\n+     * @param dropThreshold threshold triggering rank computation\n+     * @return effective numerical matrix rank\n+     */\n+    public int getRank(final double dropThreshold) {\n+        RealMatrix r    = getR();\n+        int rows        = r.getRowDimension();\n+        int columns     = r.getColumnDimension();\n+        int rank        = 1;\n+        double lastNorm = r.getFrobeniusNorm();\n+        double rNorm    = lastNorm;\n+        while (rank < FastMath.min(rows, columns)) {\n+            double thisNorm = r.getSubMatrix(rank, rows - 1, rank, columns - 1).getFrobeniusNorm();\n+            if (thisNorm == 0 || (thisNorm / lastNorm) * rNorm < dropThreshold) {\n+                break;\n+            }\n+            lastNorm = thisNorm;\n+            rank++;\n+        }\n+        return rank;\n+    }\n+\n+    /**\n+     * Get a solver for finding the A &times; X = B solution in least square sense.\n+     * @return a solver\n+     */\n+    public DecompositionSolver getSolver() {\n+        return new Solver(super.getSolver(), this.getP());\n+    }\n+\n+    /** Specialized solver. */\n+    private static class Solver implements DecompositionSolver {\n+\n+        /** Upper level solver. */\n+        private final DecompositionSolver upper;\n+\n+        /** A permutation matrix for the pivots used in the QR decomposition */\n+        private RealMatrix p;\n+\n+        /**\n+         * Build a solver from decomposed matrix.\n+         *\n+         * @param upper upper level solver.\n+         * @param p permutation matrix\n+         */\n+        private Solver(final DecompositionSolver upper, final RealMatrix p) {\n+            this.upper = upper;\n+            this.p     = p;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public boolean isNonSingular() {\n+            return upper.isNonSingular();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector solve(RealVector b) {\n+            return p.operate(upper.solve(b));\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealMatrix solve(RealMatrix b) {\n+            return p.multiply(upper.solve(b));\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealMatrix getInverse() {\n+            return solve(MatrixUtils.createRealIdentityMatrix(p.getRowDimension()));\n+        }\n+    }\n+}\n--- a/src/test/java/org/apache/commons/math3/linear/QRDecompositionTest.java\n+++ b/src/test/java/org/apache/commons/math3/linear/QRDecompositionTest.java\n     public void testNonInvertible() {\n         QRDecomposition qr =\n             new QRDecomposition(MatrixUtils.createRealMatrix(testData3x3Singular));\n-\n-        final RealMatrix inv = qr.getSolver().getInverse();\n+        qr.getSolver().getInverse();\n     }\n \n     private RealMatrix createTestMatrix(final Random r, final int rows, final int columns) {\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/linear/RRQRDecompositionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.linear;\n+\n+import java.util.Random;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+\n+public class RRQRDecompositionTest {\n+    private double[][] testData3x3NonSingular = {\n+            { 12, -51, 4 },\n+            { 6, 167, -68 },\n+            { -4, 24, -41 }, };\n+\n+    private double[][] testData3x3Singular = {\n+            { 1, 4, 7, },\n+            { 2, 5, 8, },\n+            { 3, 6, 9, }, };\n+\n+    private double[][] testData3x4 = {\n+            { 12, -51, 4, 1 },\n+            { 6, 167, -68, 2 },\n+            { -4, 24, -41, 3 }, };\n+\n+    private double[][] testData4x3 = {\n+            { 12, -51, 4, },\n+            { 6, 167, -68, },\n+            { -4, 24, -41, },\n+            { -5, 34, 7, }, };\n+\n+    private static final double entryTolerance = 10e-16;\n+\n+    private static final double normTolerance = 10e-14;\n+\n+    /** test dimensions */\n+    @Test\n+    public void testDimensions() {\n+        checkDimension(MatrixUtils.createRealMatrix(testData3x3NonSingular));\n+\n+        checkDimension(MatrixUtils.createRealMatrix(testData4x3));\n+\n+        checkDimension(MatrixUtils.createRealMatrix(testData3x4));\n+\n+        Random r = new Random(643895747384642l);\n+        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        checkDimension(createTestMatrix(r, p, q));\n+        checkDimension(createTestMatrix(r, q, p));\n+\n+    }\n+\n+    private void checkDimension(RealMatrix m) {\n+        int rows = m.getRowDimension();\n+        int columns = m.getColumnDimension();\n+        RRQRDecomposition qr = new RRQRDecomposition(m);\n+        Assert.assertEquals(rows,    qr.getQ().getRowDimension());\n+        Assert.assertEquals(rows,    qr.getQ().getColumnDimension());\n+        Assert.assertEquals(rows,    qr.getR().getRowDimension());\n+        Assert.assertEquals(columns, qr.getR().getColumnDimension());\n+    }\n+\n+    /** test AP = QR */\n+    @Test\n+    public void testAPEqualQR() {\n+        checkAPEqualQR(MatrixUtils.createRealMatrix(testData3x3NonSingular));\n+\n+        checkAPEqualQR(MatrixUtils.createRealMatrix(testData3x3Singular));\n+\n+        checkAPEqualQR(MatrixUtils.createRealMatrix(testData3x4));\n+\n+        checkAPEqualQR(MatrixUtils.createRealMatrix(testData4x3));\n+\n+        Random r = new Random(643895747384642l);\n+        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        checkAPEqualQR(createTestMatrix(r, p, q));\n+\n+        checkAPEqualQR(createTestMatrix(r, q, p));\n+\n+    }\n+\n+    private void checkAPEqualQR(RealMatrix m) {\n+        RRQRDecomposition rrqr = new RRQRDecomposition(m);\n+        double norm = rrqr.getQ().multiply(rrqr.getR()).subtract(m.multiply(rrqr.getP())).getNorm();\n+        Assert.assertEquals(0, norm, normTolerance);\n+    }\n+\n+    /** test the orthogonality of Q */\n+    @Test\n+    public void testQOrthogonal() {\n+        checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x3NonSingular));\n+\n+        checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x3Singular));\n+\n+        checkQOrthogonal(MatrixUtils.createRealMatrix(testData3x4));\n+\n+        checkQOrthogonal(MatrixUtils.createRealMatrix(testData4x3));\n+\n+        Random r = new Random(643895747384642l);\n+        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        checkQOrthogonal(createTestMatrix(r, p, q));\n+\n+        checkQOrthogonal(createTestMatrix(r, q, p));\n+\n+    }\n+\n+    private void checkQOrthogonal(RealMatrix m) {\n+        RRQRDecomposition qr = new RRQRDecomposition(m);\n+        RealMatrix eye = MatrixUtils.createRealIdentityMatrix(m.getRowDimension());\n+        double norm = qr.getQT().multiply(qr.getQ()).subtract(eye).getNorm();\n+        Assert.assertEquals(0, norm, normTolerance);\n+    }\n+\n+    /** test that R is upper triangular */\n+    @Test\n+    public void testRUpperTriangular() {\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testData3x3NonSingular);\n+        checkUpperTriangular(new RRQRDecomposition(matrix).getR());\n+\n+        matrix = MatrixUtils.createRealMatrix(testData3x3Singular);\n+        checkUpperTriangular(new RRQRDecomposition(matrix).getR());\n+\n+        matrix = MatrixUtils.createRealMatrix(testData3x4);\n+        checkUpperTriangular(new RRQRDecomposition(matrix).getR());\n+\n+        matrix = MatrixUtils.createRealMatrix(testData4x3);\n+        checkUpperTriangular(new RRQRDecomposition(matrix).getR());\n+\n+        Random r = new Random(643895747384642l);\n+        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        matrix = createTestMatrix(r, p, q);\n+        checkUpperTriangular(new RRQRDecomposition(matrix).getR());\n+\n+        matrix = createTestMatrix(r, p, q);\n+        checkUpperTriangular(new RRQRDecomposition(matrix).getR());\n+\n+    }\n+\n+    private void checkUpperTriangular(RealMatrix m) {\n+        m.walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n+            @Override\n+            public void visit(int row, int column, double value) {\n+                if (column < row) {\n+                    Assert.assertEquals(0.0, value, entryTolerance);\n+                }\n+            }\n+        });\n+    }\n+\n+    /** test that H is trapezoidal */\n+    @Test\n+    public void testHTrapezoidal() {\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testData3x3NonSingular);\n+        checkTrapezoidal(new RRQRDecomposition(matrix).getH());\n+\n+        matrix = MatrixUtils.createRealMatrix(testData3x3Singular);\n+        checkTrapezoidal(new RRQRDecomposition(matrix).getH());\n+\n+        matrix = MatrixUtils.createRealMatrix(testData3x4);\n+        checkTrapezoidal(new RRQRDecomposition(matrix).getH());\n+\n+        matrix = MatrixUtils.createRealMatrix(testData4x3);\n+        checkTrapezoidal(new RRQRDecomposition(matrix).getH());\n+\n+        Random r = new Random(643895747384642l);\n+        int    p = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        int    q = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        matrix = createTestMatrix(r, p, q);\n+        checkTrapezoidal(new RRQRDecomposition(matrix).getH());\n+\n+        matrix = createTestMatrix(r, p, q);\n+        checkTrapezoidal(new RRQRDecomposition(matrix).getH());\n+\n+    }\n+\n+    private void checkTrapezoidal(RealMatrix m) {\n+        m.walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n+            @Override\n+            public void visit(int row, int column, double value) {\n+                if (column > row) {\n+                    Assert.assertEquals(0.0, value, entryTolerance);\n+                }\n+            }\n+        });\n+    }\n+\n+    @Test(expected=SingularMatrixException.class)\n+    public void testNonInvertible() {\n+        RRQRDecomposition qr =\n+            new RRQRDecomposition(MatrixUtils.createRealMatrix(testData3x3Singular), 3.0e-16);\n+        qr.getSolver().getInverse();\n+    }\n+\n+    private RealMatrix createTestMatrix(final Random r, final int rows, final int columns) {\n+        RealMatrix m = MatrixUtils.createRealMatrix(rows, columns);\n+        m.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor(){\n+            @Override\n+            public double visit(int row, int column, double value) {\n+                return 2.0 * r.nextDouble() - 1.0;\n+            }\n+        });\n+        return m;\n+    }\n+\n+    /** test the rank is returned correctly */\n+    @Test\n+    public void testRank() {\n+        double[][] d = { { 1, 1, 1 }, { 0, 0, 0 }, { 1, 2, 3 } };\n+        RealMatrix m = new Array2DRowRealMatrix(d);\n+        RRQRDecomposition qr = new RRQRDecomposition(m);\n+        Assert.assertEquals(2, qr.getRank(1.0e-16));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/linear/RRQRSolverTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math3.linear;\n+\n+import java.util.Random;\n+\n+import org.apache.commons.math3.exception.MathIllegalArgumentException;\n+\n+import org.junit.Test;\n+import org.junit.Assert;\n+\n+public class RRQRSolverTest {\n+    double[][] testData3x3NonSingular = {\n+            { 12, -51,   4 },\n+            {  6, 167, -68 },\n+            { -4,  24, -41 }\n+    };\n+\n+    double[][] testData3x3Singular = {\n+            { 1, 2,  2 },\n+            { 2, 4,  6 },\n+            { 4, 8, 12 }\n+    };\n+\n+    double[][] testData3x4 = {\n+            { 12, -51,   4, 1 },\n+            {  6, 167, -68, 2 },\n+            { -4,  24, -41, 3 }\n+    };\n+\n+    double[][] testData4x3 = {\n+            { 12, -51,   4 },\n+            {  6, 167, -68 },\n+            { -4,  24, -41 },\n+            { -5,  34,   7 }\n+    };\n+\n+    /** test rank */\n+    @Test\n+    public void testRank() {\n+        DecompositionSolver solver =\n+            new RRQRDecomposition(MatrixUtils.createRealMatrix(testData3x3NonSingular), 1.0e-16).getSolver();\n+        Assert.assertTrue(solver.isNonSingular());\n+\n+        solver = new RRQRDecomposition(MatrixUtils.createRealMatrix(testData3x3Singular), 1.0e-16).getSolver();\n+        Assert.assertFalse(solver.isNonSingular());\n+\n+        solver = new RRQRDecomposition(MatrixUtils.createRealMatrix(testData3x4), 1.0e-16).getSolver();\n+        Assert.assertTrue(solver.isNonSingular());\n+\n+        solver = new RRQRDecomposition(MatrixUtils.createRealMatrix(testData4x3), 1.0e-16).getSolver();\n+        Assert.assertTrue(solver.isNonSingular());\n+\n+    }\n+\n+    /** test solve dimension errors */\n+    @Test\n+    public void testSolveDimensionErrors() {\n+        DecompositionSolver solver =\n+            new RRQRDecomposition(MatrixUtils.createRealMatrix(testData3x3NonSingular)).getSolver();\n+        RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);\n+        try {\n+            solver.solve(b);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (MathIllegalArgumentException iae) {\n+            // expected behavior\n+        }\n+        try {\n+            solver.solve(b.getColumnVector(0));\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (MathIllegalArgumentException iae) {\n+            // expected behavior\n+        }\n+\n+    }\n+\n+    /** test solve rank errors */\n+    @Test\n+    public void testSolveRankErrors() {\n+        DecompositionSolver solver =\n+            new RRQRDecomposition(MatrixUtils.createRealMatrix(testData3x3Singular), 1.0e-16).getSolver();\n+        RealMatrix b = MatrixUtils.createRealMatrix(new double[3][2]);\n+        try {\n+            solver.solve(b);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (SingularMatrixException iae) {\n+            // expected behavior\n+        }\n+        try {\n+            solver.solve(b.getColumnVector(0));\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (SingularMatrixException iae) {\n+            // expected behavior\n+        }\n+\n+    }\n+\n+    /** test solve */\n+    @Test\n+    public void testSolve() {\n+        RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {\n+                { -102, 12250 }, { 544, 24500 }, { 167, -36750 }\n+        });\n+        RealMatrix xRef = MatrixUtils.createRealMatrix(new double[][] {\n+                { 1, 2515 }, { 2, 422 }, { -3, 898 }\n+        });\n+\n+        \n+        RRQRDecomposition decomposition = new RRQRDecomposition(MatrixUtils.createRealMatrix(testData3x3NonSingular));\n+        DecompositionSolver solver = decomposition.getSolver();\n+        \n+        // using RealMatrix\n+        Assert.assertEquals(0, solver.solve(b).subtract(xRef).getNorm(), 3.0e-16 * xRef.getNorm());\n+\n+        // using ArrayRealVector\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            final RealVector x = solver.solve(b.getColumnVector(i));\n+            final double error = x.subtract(xRef.getColumnVector(i)).getNorm();\n+            Assert.assertEquals(0, error, 3.0e-16 * xRef.getColumnVector(i).getNorm());\n+        }\n+\n+        // using RealVector with an alternate implementation\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            ArrayRealVectorTest.RealVectorTestImpl v =\n+                new ArrayRealVectorTest.RealVectorTestImpl(b.getColumn(i));\n+            final RealVector x = solver.solve(v);\n+            final double error = x.subtract(xRef.getColumnVector(i)).getNorm();\n+            Assert.assertEquals(0, error, 3.0e-16 * xRef.getColumnVector(i).getNorm());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testOverdetermined() {\n+        final Random r    = new Random(5559252868205245l);\n+        int          p    = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        int          q    = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        RealMatrix   a    = createTestMatrix(r, p, q);\n+        RealMatrix   xRef = createTestMatrix(r, q, BlockRealMatrix.BLOCK_SIZE + 3);\n+\n+        // build a perturbed system: A.X + noise = B\n+        RealMatrix b = a.multiply(xRef);\n+        final double noise = 0.001;\n+        b.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() {\n+            @Override\n+            public double visit(int row, int column, double value) {\n+                return value * (1.0 + noise * (2 * r.nextDouble() - 1));\n+            }\n+        });\n+\n+        // despite perturbation, the least square solution should be pretty good\n+        RealMatrix x = new RRQRDecomposition(a).getSolver().solve(b);\n+        Assert.assertEquals(0, x.subtract(xRef).getNorm(), 0.01 * noise * p * q);\n+\n+    }\n+\n+    @Test\n+    public void testUnderdetermined() {\n+        final Random r    = new Random(42185006424567123l);\n+        int          p    = (5 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        int          q    = (7 * BlockRealMatrix.BLOCK_SIZE) / 4;\n+        RealMatrix   a    = createTestMatrix(r, p, q);\n+        RealMatrix   xRef = createTestMatrix(r, q, BlockRealMatrix.BLOCK_SIZE + 3);\n+        RealMatrix   b    = a.multiply(xRef);\n+        RRQRDecomposition rrqrd = new RRQRDecomposition(a);\n+        RealMatrix   x = rrqrd.getSolver().solve(b);\n+\n+        // too many equations, the system cannot be solved at all\n+        Assert.assertTrue(x.subtract(xRef).getNorm() / (p * q) > 0.01);\n+\n+        // the last permuted unknown should have been set to 0\n+        RealMatrix permuted = rrqrd.getP().transpose().multiply(x);\n+        Assert.assertEquals(0.0, permuted.getSubMatrix(p, q - 1, 0, permuted.getColumnDimension() - 1).getNorm(), 0);\n+\n+    }\n+\n+    private RealMatrix createTestMatrix(final Random r, final int rows, final int columns) {\n+        RealMatrix m = MatrixUtils.createRealMatrix(rows, columns);\n+        m.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() {\n+                @Override\n+                    public double visit(int row, int column, double value) {\n+                    return 2.0 * r.nextDouble() - 1.0;\n+                }\n+            });\n+        return m;\n+    }\n+}", "timestamp": 1363108132, "metainfo": ""}