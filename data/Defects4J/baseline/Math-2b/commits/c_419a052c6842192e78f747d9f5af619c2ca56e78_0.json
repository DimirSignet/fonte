{"sha": "419a052c6842192e78f747d9f5af619c2ca56e78", "log": "MATH-949 Increment iteration counter. By default, the maximum number of iterations is \"Integer.MAX_VALUE\".   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java\n         this.checker = checker;\n \n         evaluations = new Incrementor(0, new MaxEvalCallback());\n-        iterations = new Incrementor(0, new MaxIterCallback());\n+        iterations = new Incrementor(Integer.MAX_VALUE, new MaxIterCallback());\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java\n         }\n \n         PointValuePair current = null;\n-        int iter = 0;\n         int maxEval = getMaxEvaluations();\n         while (true) {\n-            ++iter;\n+            incrementIterationCount();\n \n             final double objective = computeObjectiveValue(point);\n             PointValuePair previous = current;\n             current = new PointValuePair(point, objective);\n             if (previous != null) {\n-                if (checker.converged(iter, previous, current)) {\n+                if (checker.converged(getIterations(), previous, current)) {\n                     // We have found an optimum.\n                     return current;\n                 }\n             steepestDescent = newSteepestDescent;\n \n             // Compute conjugate search direction.\n-            if (iter % n == 0 ||\n+            if (getIterations() % n == 0 ||\n                 beta < 0) {\n                 // Break conjugation: reset search direction.\n                 searchDirection = steepestDescent.clone();\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java\n \n         generationLoop:\n         for (iterations = 1; iterations <= maxIterations; iterations++) {\n+            incrementIterationCount();\n+\n             // Generate and evaluate lambda offspring\n             final RealMatrix arz = randn1(dimension, lambda);\n             final RealMatrix arx = zeros(dimension, lambda);\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java\n         double[] x = guess;\n         double fVal = computeObjectiveValue(x);\n         double[] x1 = x.clone();\n-        int iter = 0;\n         while (true) {\n-            ++iter;\n+            incrementIterationCount();\n \n             double fX = fVal;\n             double fX2 = 0;\n             final PointValuePair current = new PointValuePair(x, fVal);\n             if (!stop) { // User-defined stopping criteria.\n                 if (checker != null) {\n-                    stop = checker.converged(iter, previous, current);\n+                    stop = checker.converged(getIterations(), previous, current);\n                 }\n             }\n             if (stop) {\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java\n         int iteration = 0;\n         final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n         while (true) {\n-            if (iteration > 0) {\n+            if (getIterations() > 0) {\n                 boolean converged = true;\n                 for (int i = 0; i < simplex.getSize(); i++) {\n                     PointValuePair prev = previous[i];\n             // We still need to search.\n             previous = simplex.getPoints();\n             simplex.iterate(evalFunc, comparator);\n-            ++iteration;\n+\n+            incrementIterationCount();\n         }\n     }\n \n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java\n \n         // iterate until convergence is reached\n         PointVectorValuePair current = null;\n-        int iter = 0;\n         for (boolean converged = false; !converged;) {\n-            ++iter;\n+            incrementIterationCount();\n \n             // evaluate the objective function and its jacobian\n             PointVectorValuePair previous = current;\n \n             // Check convergence.\n             if (previous != null) {\n-                converged = checker.converged(iter, previous, current);\n+                converged = checker.converged(getIterations(), previous, current);\n                 if (converged) {\n                     setCost(computeCost(currentResiduals));\n                     return current;\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java\n         // Outer loop.\n         lmPar = 0;\n         boolean firstIteration = true;\n-        int iter = 0;\n         final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();\n         while (true) {\n-            ++iter;\n+            incrementIterationCount();\n+\n             final PointVectorValuePair previous = current;\n \n             // QR decomposition of the jacobian matrix\n                     // tests for convergence.\n                     if (checker != null) {\n                         // we use the vectorial convergence checker\n-                        if (checker.converged(iter, previous, current)) {\n+                        if (checker.converged(getIterations(), previous, current)) {\n                             setCost(currentCost);\n                             return current;\n                         }\n--- a/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizerTest.java\n                                  new InitialGuess(new double[] { 0 }));\n         Assert.assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);\n         Assert.assertEquals(0.0, optimum.getValue(), 1.0e-10);\n+\n+        // Check that the number of iterations is updated (MATH-949).\n+        Assert.assertTrue(optimizer.getIterations() > 0);\n     }\n \n     @Test\n--- a/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizerTest.java\n \n     static final int DIM = 13;\n     static final int LAMBDA = 4 + (int)(3.*Math.log(DIM));\n-   \n+\n     @Test(expected = NumberIsTooLargeException.class)\n     public void testInitOutofbounds1() {\n         double[] startPoint = point(DIM,3);\n         for (int i = 0; i < dim; i++) {\n             Assert.assertEquals(expected.getPoint()[i], result.getPoint()[i], pointTol);\n         }\n+\n+        Assert.assertTrue(optim.getIterations() > 0);\n     }\n \n     private static double[] point(int n, double value) {\n--- a/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizerTest.java\n             Assert.assertEquals(\"found[\" + i + \"]=\" + point[i] + \" value=\" + result.getValue(),\n                                 optimum[i], point[i], pointTol);\n         }\n+\n+        Assert.assertTrue(optim.getIterations() > 0);\n     }\n }\n--- a/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizerMultiDirectionalTest.java\n+++ b/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizerMultiDirectionalTest.java\n         Assert.assertEquals(fourExtrema.valueXmYp, optimum.getValue(), 8e-13);\n         Assert.assertTrue(optimizer.getEvaluations() > 120);\n         Assert.assertTrue(optimizer.getEvaluations() < 150);\n+\n+        // Check that the number of iterations is updated (MATH-949).\n+        Assert.assertTrue(optimizer.getIterations() > 0);\n     }\n \n     @Test\n         Assert.assertEquals(fourExtrema.valueXpYm, optimum.getValue(), 2e-12);\n         Assert.assertTrue(optimizer.getEvaluations() > 120);\n         Assert.assertTrue(optimizer.getEvaluations() < 150);\n+\n+        // Check that the number of iterations is updated (MATH-949).\n+        Assert.assertTrue(optimizer.getIterations() > 0);\n     }\n \n     @Test\n         Assert.assertEquals(fourExtrema.valueXmYm, optimum.getValue(), 2e-14);\n         Assert.assertTrue(optimizer.getEvaluations() > 120);\n         Assert.assertTrue(optimizer.getEvaluations() < 150);\n+\n+        // Check that the number of iterations is updated (MATH-949).\n+        Assert.assertTrue(optimizer.getIterations() > 0);\n     }\n \n     @Test\n         Assert.assertEquals(fourExtrema.valueXpYp, optimum.getValue(), 2e-12);\n         Assert.assertTrue(optimizer.getEvaluations() > 180);\n         Assert.assertTrue(optimizer.getEvaluations() < 220);\n+\n+        // Check that the number of iterations is updated (MATH-949).\n+        Assert.assertTrue(optimizer.getIterations() > 0);\n     }\n \n     @Test\n--- a/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizerNelderMeadTest.java\n+++ b/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizerNelderMeadTest.java\n         Assert.assertEquals(fourExtrema.valueXmYp, optimum.getValue(), 6e-12);\n         Assert.assertTrue(optimizer.getEvaluations() > 60);\n         Assert.assertTrue(optimizer.getEvaluations() < 90);\n+\n+        // Check that the number of iterations is updated (MATH-949).\n+        Assert.assertTrue(optimizer.getIterations() > 0);\n     }\n \n     @Test\n         Assert.assertEquals(fourExtrema.valueXpYm, optimum.getValue(), 1e-11);\n         Assert.assertTrue(optimizer.getEvaluations() > 60);\n         Assert.assertTrue(optimizer.getEvaluations() < 90);\n+\n+        // Check that the number of iterations is updated (MATH-949).\n+        Assert.assertTrue(optimizer.getIterations() > 0);\n     }\n \n     @Test\n         Assert.assertEquals(fourExtrema.valueXmYm, optimum.getValue(), 3e-12);\n         Assert.assertTrue(optimizer.getEvaluations() > 60);\n         Assert.assertTrue(optimizer.getEvaluations() < 90);\n+\n+        // Check that the number of iterations is updated (MATH-949).\n+        Assert.assertTrue(optimizer.getIterations() > 0);\n     }\n \n     @Test\n         Assert.assertEquals(fourExtrema.valueXpYp, optimum.getValue(), 7e-12);\n         Assert.assertTrue(optimizer.getEvaluations() > 60);\n         Assert.assertTrue(optimizer.getEvaluations() < 90);\n+\n+        // Check that the number of iterations is updated (MATH-949).\n+        Assert.assertTrue(optimizer.getIterations() > 0);\n     }\n \n     @Test\n--- a/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizerAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizerAbstractTest.java\n     public abstract AbstractLeastSquaresOptimizer createOptimizer();\n \n     @Test\n+    public void testGetIterations() {\n+        AbstractLeastSquaresOptimizer optim = createOptimizer();\n+        optim.optimize(new MaxEval(100), new Target(new double[] { 1 }),\n+                       new Weight(new double[] { 1 }),\n+                       new InitialGuess(new double[] { 3 }),\n+                       new ModelFunction(new MultivariateVectorFunction() {\n+                               @Override\n+                               public double[] value(double[] point) {\n+                                   return new double[] {\n+                                       FastMath.pow(point[0], 4)\n+                                   };\n+                               }\n+                           }),\n+                       new ModelFunctionJacobian(new MultivariateMatrixFunction() {\n+                               @Override\n+                               public double[][] value(double[] point) {\n+                                   return new double[][] {\n+                                       { 0.25 * FastMath.pow(point[0], 3) }\n+                                   };\n+                               }\n+                           }));\n+\n+        Assert.assertTrue(optim.getIterations() > 0);\n+    }\n+\n+    @Test\n     public void testTrivial() {\n         LinearProblem problem\n             = new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });", "timestamp": 1363704690, "metainfo": ""}