{"sha": "f727f77a9719deeced2e8a7867aec88ab29e534a", "log": "Fixed findbugs warnings.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/distribution/fitting/MultivariateNormalMixtureExpectationMaximization.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/fitting/MultivariateNormalMixtureExpectationMaximization.java\n import org.apache.commons.math3.linear.RealMatrix;\n import org.apache.commons.math3.linear.SingularMatrixException;\n import org.apache.commons.math3.stat.correlation.Covariance;\n-import org.apache.commons.math3.util.FastMath;\n import org.apache.commons.math3.util.MathArrays;\n import org.apache.commons.math3.util.Pair;\n \n         }\n         Arrays.sort(sortedData);\n \n-        final int totalBins = numComponents;\n-\n         // uniform weight for each bin\n-        final double weight = 1d / totalBins;\n+        final double weight = 1d / numComponents;\n \n         // components of mixture model to be created\n         final List<Pair<Double, MultivariateNormalDistribution>> components =\n                 new ArrayList<Pair<Double, MultivariateNormalDistribution>>();\n \n         // create a component based on data in each bin\n-        for (int binNumber = 1; binNumber <= totalBins; binNumber++) {\n-            // minimum index from sorted data for this bin\n-            final int minIndex\n-                = (int) FastMath.max(0,\n-                                     FastMath.floor((binNumber - 1) * numRows / totalBins));\n-\n-            // maximum index from sorted data for this bin\n-            final int maxIndex\n-                = (int) FastMath.ceil(binNumber * numRows / numComponents) - 1;\n+        for (int binIndex = 0; binIndex < numComponents; binIndex++) {\n+            // minimum index (inclusive) from sorted data for this bin\n+            final int minIndex = (binIndex * numRows) / numComponents;\n+\n+            // maximum index (exclusive) from sorted data for this bin\n+            final int maxIndex = ((binIndex + 1) * numRows) / numComponents;\n \n             // number of data records that will be in this bin\n-            final int numBinRows = maxIndex - minIndex + 1;\n+            final int numBinRows = maxIndex - minIndex;\n \n             // data for this bin\n             final double[][] binData = new double[numBinRows][numCols];\n             final double[] columnMeans = new double[numCols];\n \n             // populate bin and create component\n-            for (int i = minIndex, iBin = 0; i <= maxIndex; i++, iBin++) {\n+            for (int i = minIndex, iBin = 0; i < maxIndex; i++, iBin++) {\n                 for (int j = 0; j < numCols; j++) {\n                     final double val = sortedData[i].getRow()[j];\n                     columnMeans[j] += val;\n             return mean.compareTo(other.mean);\n         }\n \n+        /** {@inheritDoc} */\n+        @Override\n+        public boolean equals(Object other) {\n+\n+            if (this == other) {\n+                return true;\n+            }\n+\n+            if (other instanceof DataRow) {\n+                return MathArrays.equals(row, ((DataRow) other).row);\n+            }\n+\n+            return false;\n+\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public int hashCode() {\n+            return Arrays.hashCode(row);\n+        }\n         /**\n          * Get a data row.\n          * @return data row array", "timestamp": 1364572247, "metainfo": ""}