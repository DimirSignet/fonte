{"sha": "1e1b887f3352b119d829b702fdaffd7c74be6f3e", "log": "Finalized implementation of diagonal matrix.  JIRA: MATH-925  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/linear/DiagonalMatrix.java\n+++ b/src/main/java/org/apache/commons/math3/linear/DiagonalMatrix.java\n package org.apache.commons.math3.linear;\n \n import java.io.Serializable;\n+\n import org.apache.commons.math3.exception.DimensionMismatchException;\n import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math3.exception.NullArgumentException;\n+import org.apache.commons.math3.exception.NumberIsTooLargeException;\n import org.apache.commons.math3.exception.OutOfRangeException;\n-import org.apache.commons.math3.exception.MathUnsupportedOperationException;\n+import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.MathUtils;\n+import org.apache.commons.math3.util.Precision;\n \n /**\n  * Implementation of a diagonal matrix.\n- * <br/>\n- * Caveat: This implementation is minimal; it is currently solely aimed\n- * at solving issue MATH-924. In particular many methods just throw\n- * {@code MathUnsupportedOperationException}.\n  *\n  * @version $Id$\n+ * @since 3.1.1\n  */\n public class DiagonalMatrix extends AbstractRealMatrix\n     implements Serializable {\n      * @param d Data for new matrix.\n      * @param copyArray if {@code true}, the input array will be copied,\n      * otherwise it will be referenced.\n-     */\n-    public DiagonalMatrix(final double[] d, final boolean copyArray) {\n+     * @exception NullArgumentException if d is null\n+     */\n+    public DiagonalMatrix(final double[] d, final boolean copyArray)\n+        throws NullArgumentException {\n+        MathUtils.checkNotNull(d);\n         data = copyArray ? d.clone() : d;\n     }\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public RealMatrix copy() {\n+    public DiagonalMatrix copy() {\n         return new DiagonalMatrix(data);\n     }\n \n         return data;\n     }\n \n-    /** {@inheritDoc}\n-     * @throws MathUnsupportedOperationException\n-     */\n-    @Override\n-    public void setSubMatrix(final double[][] subMatrix,\n-                             final int row,\n-                             final int column)\n-        throws MathUnsupportedOperationException {\n-        throw new MathUnsupportedOperationException();\n-    }\n-\n     /** {@inheritDoc} */\n     @Override\n     public double getEntry(final int row, final int column)\n     }\n \n     /** {@inheritDoc}\n-     * @throws MathUnsupportedOperationException if {@code row != column}.\n+     * @throws NumberIsTooLargeException if {@code row != column} and value is non-zero.\n      */\n     @Override\n     public void setEntry(final int row, final int column, final double value)\n-        throws OutOfRangeException,\n-               MathUnsupportedOperationException {\n-        if (row != column) {\n-            throw new MathUnsupportedOperationException();\n-        }\n-        MatrixUtils.checkMatrixIndex(this, row, column);\n-        data[row] = value;\n+        throws OutOfRangeException, NumberIsTooLargeException {\n+        if (row == column) {\n+            MatrixUtils.checkRowIndex(this, row);\n+            data[row] = value;\n+        } else {\n+            ensureZero(value);\n+        }\n     }\n \n     /** {@inheritDoc}\n-     * @throws MathUnsupportedOperationException if {@code row != column}.\n+     * @throws NumberIsTooLargeException if {@code row != column} and increment is non-zero.\n      */\n     @Override\n     public void addToEntry(final int row,\n                            final int column,\n                            final double increment)\n-        throws OutOfRangeException,\n-               MathUnsupportedOperationException {\n-        if (row != column) {\n-            throw new MathUnsupportedOperationException();\n-        }\n-        MatrixUtils.checkMatrixIndex(this, row, column);\n-        data[row] += increment;\n-    }\n-\n-    /** {@inheritDoc}\n-     * @throws MathUnsupportedOperationException if {@code row != column}.\n-     */\n+        throws OutOfRangeException, NumberIsTooLargeException {\n+        if (row == column) {\n+            MatrixUtils.checkRowIndex(this, row);\n+            data[row] += increment;\n+        } else {\n+            ensureZero(increment);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n     @Override\n     public void multiplyEntry(final int row,\n                               final int column,\n                               final double factor)\n-        throws OutOfRangeException,\n-               MathUnsupportedOperationException {\n-        if (row != column) {\n-            throw new MathUnsupportedOperationException();\n-        }\n-        MatrixUtils.checkMatrixIndex(this, row, column);\n-        data[row] *= factor;\n+        throws OutOfRangeException {\n+        // we don't care about non-diagonal elements for multiplication\n+        if (row == column) {\n+            MatrixUtils.checkRowIndex(this, row);\n+            data[row] *= factor;\n+        }\n     }\n \n     /** {@inheritDoc} */\n     @Override\n     public int getRowDimension() {\n-        return data == null ? 0 : data.length;\n+        return data.length;\n     }\n \n     /** {@inheritDoc} */\n     @Override\n     public int getColumnDimension() {\n-        return getRowDimension();\n+        return data.length;\n     }\n \n     /** {@inheritDoc} */\n         return operate(v);\n     }\n \n-    /** {@inheritDoc} */\n-    @Override\n-    public double walkInRowOrder(final RealMatrixChangingVisitor visitor)\n-        throws MathUnsupportedOperationException {\n-        throw new MathUnsupportedOperationException();\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor)\n-        throws MathUnsupportedOperationException {\n-        throw new MathUnsupportedOperationException();\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public double walkInRowOrder(final RealMatrixChangingVisitor visitor,\n-                                 final int startRow, final int endRow,\n-                                 final int startColumn, final int endColumn)\n-        throws MathUnsupportedOperationException {\n-        throw new MathUnsupportedOperationException();\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n-                                 final int startRow, final int endRow,\n-                                 final int startColumn, final int endColumn)\n-        throws MathUnsupportedOperationException {\n-        throw new MathUnsupportedOperationException();\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public double walkInColumnOrder(final RealMatrixChangingVisitor visitor)\n-        throws MathUnsupportedOperationException {\n-        throw new MathUnsupportedOperationException();\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public double walkInColumnOrder(final RealMatrixPreservingVisitor visitor)\n-        throws MathUnsupportedOperationException {\n-        throw new MathUnsupportedOperationException();\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public double walkInColumnOrder(final RealMatrixChangingVisitor visitor,\n-                                    final int startRow, final int endRow,\n-                                    final int startColumn, final int endColumn)\n-        throws MathUnsupportedOperationException {\n-        throw new MathUnsupportedOperationException();\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public double walkInColumnOrder(final RealMatrixPreservingVisitor visitor,\n-                                    final int startRow, final int endRow,\n-                                    final int startColumn, final int endColumn)\n-        throws MathUnsupportedOperationException {\n-        throw new MathUnsupportedOperationException();\n-    }\n+    /** Ensure a value is zero.\n+     * @param value value to check\n+     * @exception NumberIsTooLargeException if value is not zero\n+     */\n+    private void ensureZero(final double value) throws NumberIsTooLargeException {\n+        if (!Precision.equals(0.0, value, 1)) {\n+            throw new NumberIsTooLargeException(FastMath.abs(value), 0, true);\n+        }\n+    }\n+\n }\n--- a/src/test/java/org/apache/commons/math3/linear/DiagonalMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math3/linear/DiagonalMatrixTest.java\n  */\n package org.apache.commons.math3.linear;\n \n+import org.apache.commons.math3.TestUtils;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.NullArgumentException;\n+import org.apache.commons.math3.exception.NumberIsTooLargeException;\n+import org.apache.commons.math3.exception.OutOfRangeException;\n+import org.apache.commons.math3.util.Precision;\n+import org.junit.Assert;\n import org.junit.Test;\n-import org.junit.Assert;\n-\n-import org.apache.commons.math3.exception.MathUnsupportedOperationException;\n-import org.apache.commons.math3.exception.OutOfRangeException;\n-import org.apache.commons.math3.TestUtils;\n \n /**\n  * Test cases for the {@link DiagonalMatrix} class.\n         d[0] = 0;\n         Assert.assertTrue(d[0] == m.getEntry(0, 0));\n \n+    }\n+\n+    @Test(expected=DimensionMismatchException.class)\n+    public void testCreateError() {\n+        final double[] d = { -1.2, 3.4, 5 };\n+        final DiagonalMatrix m = new DiagonalMatrix(d, false);\n+        m.createMatrix(5, 3);\n+    }\n+\n+    @Test\n+    public void testCreate() {\n+        final double[] d = { -1.2, 3.4, 5 };\n+        final DiagonalMatrix m = new DiagonalMatrix(d, false);\n+        final RealMatrix p = m.createMatrix(5, 5);\n+        Assert.assertTrue(p instanceof DiagonalMatrix);\n+        Assert.assertEquals(5, p.getRowDimension());\n+        Assert.assertEquals(5, p.getColumnDimension());\n+    }\n+\n+    @Test\n+    public void testCopy() {\n+        final double[] d = { -1.2, 3.4, 5 };\n+        final DiagonalMatrix m = new DiagonalMatrix(d, false);\n+        final DiagonalMatrix p = m.copy();\n+        for (int i = 0; i < m.getRowDimension(); ++i) {\n+            Assert.assertEquals(m.getEntry(i, i), p.getEntry(i, i), 1.0e-20);\n+        }\n     }\n \n     @Test\n     }\n \n     @Test\n+    public void testSubtract() {\n+        final double[] data1 = { -1.2, 3.4, 5 };\n+        final DiagonalMatrix m1 = new DiagonalMatrix(data1);\n+ \n+        final double[] data2 = { 10.1, 2.3, 45 };\n+        final DiagonalMatrix m2 = new DiagonalMatrix(data2);\n+\n+        final DiagonalMatrix result = m1.subtract(m2);\n+        Assert.assertEquals(m1.getRowDimension(), result.getRowDimension());\n+        for (int i = 0; i < result.getRowDimension(); i++) {\n+            for (int j = 0; j < result.getRowDimension(); j++) {\n+                if (i == j) {\n+                    Assert.assertEquals(data1[i] - data2[i], result.getEntry(i, j), 0d);\n+                } else {\n+                    Assert.assertEquals(0d, result.getEntry(i, j), 0d);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n     public void testAddToEntry() {\n         final double[] data = { -1.2, 3.4, 5 };\n         final DiagonalMatrix m = new DiagonalMatrix(data);\n         final double[] data2 = { 10.1, 2.3, 45 };\n         final DiagonalMatrix m2 = new DiagonalMatrix(data2);\n \n-        final DiagonalMatrix result = m1.multiply(m2);\n+        final DiagonalMatrix result = (DiagonalMatrix) m1.multiply((RealMatrix) m2);\n         Assert.assertEquals(m1.getRowDimension(), result.getRowDimension());\n         for (int i = 0; i < result.getRowDimension(); i++) {\n             for (int j = 0; j < result.getRowDimension(); j++) {\n         TestUtils.assertEquals(diagResult, denseResult, 0d);\n     }\n \n-    @Test(expected=MathUnsupportedOperationException.class)\n+    @Test(expected=NumberIsTooLargeException.class)\n     public void testSetNonDiagonalEntry() {\n         final DiagonalMatrix diag = new DiagonalMatrix(3);\n         diag.setEntry(1, 2, 3.4);\n+    }\n+\n+    @Test\n+    public void testSetNonDiagonalZero() {\n+        final DiagonalMatrix diag = new DiagonalMatrix(3);\n+        diag.setEntry(1, 2, 0.0);\n+        Assert.assertEquals(0.0, diag.getEntry(1, 2), Precision.SAFE_MIN);\n+    }\n+\n+    @Test(expected=NumberIsTooLargeException.class)\n+    public void testAddNonDiagonalEntry() {\n+        final DiagonalMatrix diag = new DiagonalMatrix(3);\n+        diag.addToEntry(1, 2, 3.4);\n+    }\n+\n+    @Test\n+    public void testAddNonDiagonalZero() {\n+        final DiagonalMatrix diag = new DiagonalMatrix(3);\n+        diag.addToEntry(1, 2, 0.0);\n+        Assert.assertEquals(0.0, diag.getEntry(1, 2), Precision.SAFE_MIN);\n+    }\n+\n+    @Test\n+    public void testMultiplyNonDiagonalEntry() {\n+        final DiagonalMatrix diag = new DiagonalMatrix(3);\n+        diag.multiplyEntry(1, 2, 3.4);\n+        Assert.assertEquals(0.0, diag.getEntry(1, 2), Precision.SAFE_MIN);\n+    }\n+\n+    @Test\n+    public void testMultiplyNonDiagonalZero() {\n+        final DiagonalMatrix diag = new DiagonalMatrix(3);\n+        diag.multiplyEntry(1, 2, 0.0);\n+        Assert.assertEquals(0.0, diag.getEntry(1, 2), Precision.SAFE_MIN);\n     }\n \n     @Test(expected=OutOfRangeException.class)\n         final DiagonalMatrix diag = new DiagonalMatrix(3);\n         diag.setEntry(3, 3, 3.4);\n     }\n+\n+    @Test(expected=NullArgumentException.class)\n+    public void testNull() {\n+        new DiagonalMatrix(null, false);\n+    }\n+\n+    @Test(expected=NumberIsTooLargeException.class)\n+    public void testSetSubMatrixError() {\n+        final double[] data = { -1.2, 3.4, 5 };\n+        final DiagonalMatrix diag = new DiagonalMatrix(data);\n+        diag.setSubMatrix(new double[][] { {1.0, 1.0}, {1.0, 1.0}}, 1, 1);\n+    }\n+\n+    @Test\n+    public void testSetSubMatrix() {\n+        final double[] data = { -1.2, 3.4, 5 };\n+        final DiagonalMatrix diag = new DiagonalMatrix(data);\n+        diag.setSubMatrix(new double[][] { {0.0, 5.0, 0.0}, {0.0, 0.0, 6.0}}, 1, 0);\n+        Assert.assertEquals(-1.2, diag.getEntry(0, 0), 1.0e-20);\n+        Assert.assertEquals( 5.0, diag.getEntry(1, 1), 1.0e-20);\n+        Assert.assertEquals( 6.0, diag.getEntry(2, 2), 1.0e-20);\n+    }\n+\n }", "timestamp": 1363174386, "metainfo": ""}