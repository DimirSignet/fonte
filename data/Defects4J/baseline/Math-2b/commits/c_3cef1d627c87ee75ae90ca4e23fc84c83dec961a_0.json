{"sha": "3cef1d627c87ee75ae90ca4e23fc84c83dec961a", "log": "Missing @Override  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/distribution/MixtureMultivariateRealDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/MixtureMultivariateRealDistribution.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double[] sample() {\n         // Sampled values.\n         double[] vals = null;\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public void reseedRandomGenerator(long seed) {\n         // Seed needs to be propagated to underlying components\n         // in order to maintain consistency between runs.\n--- a/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double[] sample() {\n         final int dim = getDimension();\n         final double[] normalVals = new double[dim];\n--- a/src/main/java/org/apache/commons/math3/linear/DiagonalMatrix.java\n+++ b/src/main/java/org/apache/commons/math3/linear/DiagonalMatrix.java\n      * @throws DimensionMismatchException if\n      * {@code columnDimension(this) != rowDimension(m)}\n      */\n+    @Override\n     public RealMatrix multiply(final RealMatrix m)\n         throws DimensionMismatchException {\n         if (m instanceof DiagonalMatrix) {\n--- a/src/main/java/org/apache/commons/math3/linear/RRQRDecomposition.java\n+++ b/src/main/java/org/apache/commons/math3/linear/RRQRDecomposition.java\n     /** Decompose matrix.\n      * @param qrt transposed matrix\n      */\n+    @Override\n     protected void decompose(double[][] qrt) {\n         p = new int[qrt.length];\n         for (int i = 0; i < p.length; i++) {\n      * @param minor minor index\n      * @param qrt transposed matrix\n      */\n+    @Override\n     protected void performHouseholderReflection(int minor, double[][] qrt) {\n \n         double l2NormSquaredMax = 0;\n      * Get a solver for finding the A &times; X = B solution in least square sense.\n      * @return a solver\n      */\n+    @Override\n     public DecompositionSolver getSolver() {\n         return new Solver(super.getSolver(), this.getP());\n     }\n--- a/src/main/java/org/apache/commons/math3/ml/clustering/DBSCANClusterer.java\n+++ b/src/main/java/org/apache/commons/math3/ml/clustering/DBSCANClusterer.java\n      * @return the list of clusters\n      * @throws NullArgumentException if the data points are null\n      */\n+    @Override\n     public List<Cluster<T>> cluster(final Collection<T> points) throws NullArgumentException {\n \n         // sanity checks\n--- a/src/main/java/org/apache/commons/math3/ml/clustering/FuzzyKMeansClusterer.java\n+++ b/src/main/java/org/apache/commons/math3/ml/clustering/FuzzyKMeansClusterer.java\n      * @throws MathIllegalArgumentException if the data points are null or the number\n      *     of clusters is larger than the number of data points\n      */\n+    @Override\n     public List<CentroidCluster<T>> cluster(final Collection<T> dataPoints)\n             throws MathIllegalArgumentException {\n \n--- a/src/main/java/org/apache/commons/math3/ml/clustering/KMeansPlusPlusClusterer.java\n+++ b/src/main/java/org/apache/commons/math3/ml/clustering/KMeansPlusPlusClusterer.java\n      * @throws ConvergenceException if an empty cluster is encountered and the\n      * {@link #emptyStrategy} is set to {@code ERROR}\n      */\n+    @Override\n     public List<CentroidCluster<T>> cluster(final Collection<T> points)\n         throws MathIllegalArgumentException, ConvergenceException {\n \n--- a/src/main/java/org/apache/commons/math3/ml/clustering/MultiKMeansPlusPlusClusterer.java\n+++ b/src/main/java/org/apache/commons/math3/ml/clustering/MultiKMeansPlusPlusClusterer.java\n      *   underlying {@link KMeansPlusPlusClusterer} has its\n      *   {@link KMeansPlusPlusClusterer.EmptyClusterStrategy} is set to {@code ERROR}.\n      */\n+    @Override\n     public List<CentroidCluster<T>> cluster(final Collection<T> points)\n         throws MathIllegalArgumentException, ConvergenceException {\n \n--- a/src/main/java/org/apache/commons/math3/ode/events/FilterType.java\n+++ b/src/main/java/org/apache/commons/math3/ode/events/FilterType.java\n     TRIGGER_ONLY_DECREASING_EVENTS {\n \n         /**  {@inheritDoc} */\n+        @Override\n         protected boolean getTriggeredIncreasing() {\n             return false;\n         }\n          * where s is a tiny positive value: {@link org.apache.commons.math3.util.Precision#SAFE_MIN}.\n          * </p>\n          */\n+        @Override\n         protected  Transformer selectTransformer(final Transformer previous,\n                                                  final double g, final boolean forward) {\n             if (forward) {\n     TRIGGER_ONLY_INCREASING_EVENTS {\n \n         /**  {@inheritDoc} */\n+        @Override\n         protected boolean getTriggeredIncreasing() {\n             return true;\n         }\n          * where s is a tiny positive value: {@link org.apache.commons.math3.util.Precision#SAFE_MIN}.\n          * </p>\n          */\n+        @Override\n         protected  Transformer selectTransformer(final Transformer previous,\n                                                  final double g, final boolean forward) {\n             if (forward) {\n--- a/src/main/java/org/apache/commons/math3/ode/events/Transformer.java\n+++ b/src/main/java/org/apache/commons/math3/ode/events/Transformer.java\n      */\n     UNINITIALIZED {\n         /**  {@inheritDoc} */\n+        @Override\n         protected double transformed(final double g) {\n             return 0;\n         }\n      */\n     PLUS {\n         /**  {@inheritDoc} */\n+        @Override\n         protected double transformed(final double g) {\n             return g;\n         }\n      */\n     MINUS {\n         /**  {@inheritDoc} */\n+        @Override\n         protected double transformed(final double g) {\n             return -g;\n         }\n      */\n     MIN {\n         /**  {@inheritDoc} */\n+        @Override\n         protected double transformed(final double g) {\n             return FastMath.min(-Precision.SAFE_MIN, FastMath.min(-g, +g));\n         }\n      */\n     MAX {\n         /**  {@inheritDoc} */\n+        @Override\n         protected double transformed(final double g) {\n             return FastMath.max(+Precision.SAFE_MIN, FastMath.max(-g, +g));\n         }\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/MultivariateVectorOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/MultivariateVectorOptimizer.java\n      * @throws DimensionMismatchException if the initial guess, target, and weight\n      * arguments have inconsistent dimensions.\n      */\n+    @Override\n     public PointVectorValuePair optimize(OptimizationData... optData)\n         throws TooManyEvaluationsException,\n                DimensionMismatchException {\n--- a/src/main/java/org/apache/commons/math3/optim/univariate/UnivariateOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/univariate/UnivariateOptimizer.java\n      * @throws TooManyEvaluationsException if the maximal number of\n      * evaluations is exceeded.\n      */\n+    @Override\n     public UnivariatePointValuePair optimize(OptimizationData... optData)\n         throws TooManyEvaluationsException {\n         // Perform computation.\n--- a/src/main/java/org/apache/commons/math3/random/EmpiricalDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/random/EmpiricalDistribution.java\n      * {@inheritDoc}\n      * @since 3.1\n      */\n+    @Override\n     public double probability(double x) {\n         return 0;\n     }\n      *\n      * @since 3.1\n      */\n+    @Override\n     public double inverseCumulativeProbability(final double p) throws OutOfRangeException {\n         if (p < 0.0 || p > 1.0) {\n             throw new OutOfRangeException(p, 0, 1);\n--- a/src/test/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructureTest.java\n+++ b/src/test/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructureTest.java\n  */\n public class DerivativeStructureTest extends ExtendedFieldElementAbstractTest<DerivativeStructure> {\n \n+    @Override\n     protected DerivativeStructure build(final double x) {\n         return new DerivativeStructure(2, 1, 0, x);\n     }\n         }\n     }\n \n+    @Override\n     @Test\n     public void testExp() {\n         double[] epsilon = new double[] { 1.0e-16, 1.0e-16, 1.0e-16, 1.0e-16, 1.0e-16 };\n         }\n     }\n \n+    @Override\n     @Test\n     public void testLog() {\n         double[] epsilon = new double[] { 1.0e-16, 1.0e-16, 3.0e-14, 7.0e-13, 3.0e-11 };\n         }\n     }\n \n+    @Override\n     @Test\n     public void testAtan2() {\n         double[] epsilon = new double[] { 5.0e-16, 3.0e-15, 2.2e-14, 1.0e-12, 8.0e-11 };\n         }\n     }\n \n+    @Override\n     @Test\n     public void testAbs() {\n \n \n     }\n \n+    @Override\n     @Test\n     public void testSignum() {\n \n--- a/src/test/java/org/apache/commons/math3/dfp/DfpTest.java\n+++ b/src/test/java/org/apache/commons/math3/dfp/DfpTest.java\n \n public class DfpTest extends ExtendedFieldElementAbstractTest<Dfp> {\n \n+    @Override\n     protected Dfp build(final double x) {\n         return field.newDfp(x);\n     }\n         Assert.assertEquals(\"toString #9\", \"0.00001234\", field.newDfp(\"0.00001234\").toString());\n     }\n \n+    @Override\n     @Test\n     public void testRound()\n     {\n         field.setRoundingMode(DfpField.RoundingMode.ROUND_HALF_EVEN);  // reset\n     }\n \n+    @Override\n     @Test\n     public void testCeil()\n     {\n              DfpField.FLAG_INEXACT, \"Ceil #1\");\n     }\n \n+    @Override\n     @Test\n     public void testFloor()\n     {\n              DfpField.FLAG_INEXACT, \"Floor #1\");\n     }\n \n+    @Override\n     @Test\n     public void testRint()\n     {\n              0, \"Remainder #3\");\n     }\n \n+    @Override\n     @Test\n     public void testSqrt()\n     {\n--- a/src/test/java/org/apache/commons/math3/distribution/LevyDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math3/distribution/LevyDistributionTest.java\n         Assert.assertTrue(d.isSupportConnected());\n     }\n \n+    @Override\n     public LevyDistribution makeDistribution() {\n         return new LevyDistribution(new Well19937a(0xc5a5506bbb17e57al), 1.2, 0.4);\n     }\n \n+    @Override\n     public double[] makeCumulativeTestPoints() {\n         return new double[] {\n             1.2001, 1.21, 1.225, 1.25, 1.3, 1.9, 3.4, 5.6\n         };\n     }\n \n+    @Override\n     public double[] makeCumulativeTestValues() {\n         // values computed with R and function plevy from rmutil package\n         return new double[] {\n         };\n     }\n \n+    @Override\n     public double[] makeDensityTestValues() {\n         // values computed with R and function dlevy from rmutil package\n         return new double[] {\n--- a/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/MultiStartMultivariateVectorOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/MultiStartMultivariateVectorOptimizerTest.java\n         LinearProblem problem = new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n         JacobianMultivariateVectorOptimizer underlyingOptimizer =\n                 new GaussNewtonOptimizer(true, new SimpleVectorValueChecker(1e-6, 1e-6)) {\n+            @Override\n             public PointVectorValuePair optimize(OptimizationData... optData) {\n                 // filter out simple bounds, as they are not supported\n                 // by the underlying optimizer, and we don't really care for this test\n--- a/src/test/java/org/apache/commons/math3/random/EmpiricalDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math3/random/EmpiricalDistributionTest.java\n     protected double[] dataArray = null;\n     protected final int n = 10000;\n \n+    @Override\n     @Before\n     public void setUp() {\n         super.setUp();\n             super(i);\n         }\n         // Use constant distribution equal to bin mean within bin\n+        @Override\n         protected RealDistribution getKernel(SummaryStatistics bStats) {\n             return new ConstantDistribution(bStats.getMean());\n         }\n         public UniformKernelEmpiricalDistribution(int i) {\n             super(i);\n         }\n+        @Override\n         protected RealDistribution getKernel(SummaryStatistics bStats) {\n             return new UniformRealDistribution(randomData.getRandomGenerator(), bStats.getMin(), bStats.getMax(),\n                     UniformRealDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n--- a/src/test/java/org/apache/commons/math3/userguide/ClusterAlgorithmComparison.java\n+++ b/src/test/java/org/apache/commons/math3/userguide/ClusterAlgorithmComparison.java\n             this.duration = duration;\n         }\n         \n+        @Override\n         protected void paintComponent(Graphics g) {\n             super.paintComponent(g);\n             Graphics2D g2 = (Graphics2D)g;\n--- a/src/test/java/org/apache/commons/math3/userguide/LowDiscrepancyGeneratorComparison.java\n+++ b/src/test/java/org/apache/commons/math3/userguide/LowDiscrepancyGeneratorComparison.java\n             this.points = points;\n         }\n         \n+        @Override\n         protected void paintComponent(Graphics g) {\n             super.paintComponent(g);\n             Graphics2D g2 = (Graphics2D)g;\n--- a/src/test/java/org/apache/commons/math3/util/Decimal64Test.java\n+++ b/src/test/java/org/apache/commons/math3/util/Decimal64Test.java\n \n     public static final Decimal64 MINUS_ZERO = new Decimal64(-0.0);\n \n+    @Override\n     protected Decimal64 build(final double x) {\n         return new Decimal64(x);\n     }", "timestamp": 1373901389, "metainfo": ""}