{"sha": "d727f318fd3a3426572d68c692a9d1fc6ea7c807", "log": "Fixed PMD warnings.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java\n \n         // get the cached compilers\n         final DSCompiler[][] cache = compilers.get();\n-        if (cache != null && cache.length > parameters && cache[parameters].length > order) {\n-            if (cache[parameters][order] != null) {\n-                // the compiler has already been created\n-                return cache[parameters][order];\n-            }\n+        if (cache != null && cache.length > parameters &&\n+            cache[parameters].length > order && cache[parameters][order] != null) {\n+            // the compiler has already been created\n+            return cache[parameters][order];\n         }\n \n         // we need to create more compilers\n--- a/src/main/java/org/apache/commons/math3/dfp/DfpMath.java\n+++ b/src/main/java/org/apache/commons/math3/dfp/DfpMath.java\n             r = exp(log(x).multiply(y));\n         }\n \n-        if (invert) {\n+        if (invert && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n             // if y is odd integer\n-            if (y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n-                r = r.negate();\n-            }\n+            r = r.negate();\n         }\n \n         return x.newInstance(r);\n--- a/src/main/java/org/apache/commons/math3/geometry/VectorFormat.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/VectorFormat.java\n             CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n \n             // parse separator\n-            if (i > 0) {\n-                if (!CompositeFormat.parseFixedstring(source, trimmedSeparator, pos)) {\n-                    return null;\n-                }\n+            if (i > 0 && !CompositeFormat.parseFixedstring(source, trimmedSeparator, pos)) {\n+                return null;\n             }\n \n             // skip whitespace\n--- a/src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java\n+++ b/src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java\n         while (iter.hasNext()) {\n             iter.advance();\n             int key = iter.key();\n-            if (!entries.containsKey(key)) {\n-                if (iter.value() > max) {\n-                    max = iter.value();\n-                }\n+            if (!entries.containsKey(key) && iter.value() > max) {\n+                max = iter.value();\n             }\n         }\n         return max;\n--- a/src/main/java/org/apache/commons/math3/optim/SimplePointChecker.java\n+++ b/src/main/java/org/apache/commons/math3/optim/SimplePointChecker.java\n     public boolean converged(final int iteration,\n                              final PAIR previous,\n                              final PAIR current) {\n-        if (maxIterationCount != ITERATION_CHECK_DISABLED) {\n-            if (iteration >= maxIterationCount) {\n-                return true;\n-            }\n+        if (maxIterationCount != ITERATION_CHECK_DISABLED && iteration >= maxIterationCount) {\n+            return true;\n         }\n \n         final double[] p = previous.getKey();\n--- a/src/main/java/org/apache/commons/math3/optim/SimpleValueChecker.java\n+++ b/src/main/java/org/apache/commons/math3/optim/SimpleValueChecker.java\n     public boolean converged(final int iteration,\n                              final PointValuePair previous,\n                              final PointValuePair current) {\n-        if (maxIterationCount != ITERATION_CHECK_DISABLED) {\n-            if (iteration >= maxIterationCount) {\n-                return true;\n-            }\n+        if (maxIterationCount != ITERATION_CHECK_DISABLED && iteration >= maxIterationCount) {\n+            return true;\n         }\n \n         final double p = previous.getValue();\n--- a/src/main/java/org/apache/commons/math3/optim/SimpleVectorValueChecker.java\n+++ b/src/main/java/org/apache/commons/math3/optim/SimpleVectorValueChecker.java\n     public boolean converged(final int iteration,\n                              final PointVectorValuePair previous,\n                              final PointVectorValuePair current) {\n-        if (maxIterationCount != ITERATION_CHECK_DISABLED) {\n-            if (iteration >= maxIterationCount) {\n-                return true;\n-            }\n+        if (maxIterationCount != ITERATION_CHECK_DISABLED && iteration >= maxIterationCount) {\n+            return true;\n         }\n \n         final double[] p = previous.getValueRef();\n--- a/src/main/java/org/apache/commons/math3/optim/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math3/optim/linear/SimplexSolver.java\n                 for (Integer row : minRatioPositions) {\n                     for (int i = varStart; i < varEnd && !row.equals(minRow); i++) {\n                         final Integer basicRow = tableau.getBasicRow(i);\n-                        if (basicRow != null && basicRow.equals(row)) {\n-                            if (i < minIndex) {\n-                                minIndex = i;\n-                                minRow = row;\n-                            }\n+                        if (basicRow != null && basicRow.equals(row) && i < minIndex) {\n+                            minIndex = i;\n+                            minRow = row;\n                         }\n                     }\n                 }\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java\n             final double objective = computeObjectiveValue(point);\n             PointValuePair previous = current;\n             current = new PointValuePair(point, objective);\n-            if (previous != null) {\n-                if (checker.converged(getIterations(), previous, current)) {\n-                    // We have found an optimum.\n-                    return current;\n-                }\n+            if (previous != null && checker.converged(getIterations(), previous, current)) {\n+                // We have found an optimum.\n+                return current;\n             }\n \n             // Find the optimal step in the search direction.\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/BOBYQAOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/BOBYQAOptimizer.java\n                     vlag = tmp;\n                     isbd = iubd;\n                 }\n-                if (subd > HALF) {\n-                    if (Math.abs(vlag) < ONE_OVER_FOUR) {\n-                        step = HALF;\n-                        vlag = ONE_OVER_FOUR;\n-                        isbd = 0;\n-                    }\n+                if (subd > HALF && Math.abs(vlag) < ONE_OVER_FOUR) {\n+                    step = HALF;\n+                    vlag = ONE_OVER_FOUR;\n+                    isbd = 0;\n                 }\n                 vlag *= dderiv;\n             }\n                     final double diff = stepb - stepa;\n                     modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);\n                     gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);\n-                    if (stepa * stepb < ZERO) {\n-                        if (f < fAtInterpolationPoints.getEntry(nfm - n)) {\n-                            fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));\n-                            fAtInterpolationPoints.setEntry(nfm - n, f);\n-                            if (trustRegionCenterInterpolationPointIndex == nfm) {\n-                                trustRegionCenterInterpolationPointIndex = nfm - n;\n-                            }\n-                            interpolationPoints.setEntry(nfm - n, nfxm, stepb);\n-                            interpolationPoints.setEntry(nfm, nfxm, stepa);\n+                    if (stepa * stepb < ZERO && f < fAtInterpolationPoints.getEntry(nfm - n)) {\n+                        fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));\n+                        fAtInterpolationPoints.setEntry(nfm - n, f);\n+                        if (trustRegionCenterInterpolationPointIndex == nfm) {\n+                            trustRegionCenterInterpolationPointIndex = nfm - n;\n                         }\n+                        interpolationPoints.setEntry(nfm - n, nfxm, stepb);\n+                        interpolationPoints.setEntry(nfm, nfxm, stepa);\n                     }\n                     bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));\n                     bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));\n                 if (gradientAtTrustRegionCenter.getEntry(i) >= ZERO) {\n                     xbdi.setEntry(i, MINUS_ONE);\n                 }\n-            } else if (trustRegionCenterOffset.getEntry(i) >= upperDifference.getEntry(i)) {\n-                if (gradientAtTrustRegionCenter.getEntry(i) <= ZERO) {\n-                    xbdi.setEntry(i, ONE);\n-                }\n+            } else if (trustRegionCenterOffset.getEntry(i) >= upperDifference.getEntry(i) &&\n+                    gradientAtTrustRegionCenter.getEntry(i) <= ZERO) {\n+                xbdi.setEntry(i, ONE);\n             }\n             if (xbdi.getEntry(i) != ZERO) {\n                 ++nact;\n         modelSecondDerivativesValues = new ArrayRealVector(dimension * (dimension + 1) / 2);\n     }\n \n-    /**\n-     * Creates a new array.\n-     *\n-     * @param n Dimension of the returned array.\n-     * @param value Value for each element.\n-     * @return an array containing {@code n} elements set to the given\n-     * {@code value}.\n-     */\n-    private static double[] fillNewArray(int n,\n-                                         double value) {\n-        double[] ds = new double[n];\n-        Arrays.fill(ds, value);\n-        return ds;\n-    }\n-\n     // XXX utility for figuring out call sequence.\n     private static String caller(int n) {\n         final Throwable t = new Throwable();\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java\n                 lastResult = optimum;\n                 optimum = new PointValuePair(fitfun.repair(bestArx.getColumn(0)),\n                                              isMinimize ? bestFitness : -bestFitness);\n-                if (getConvergenceChecker() != null &&\n-                    lastResult != null) {\n-                    if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\n-                        break generationLoop;\n-                    }\n+                if (getConvergenceChecker() != null && lastResult != null &&\n+                    getConvergenceChecker().converged(iterations, optimum, lastResult)) {\n+                    break generationLoop;\n                 }\n             }\n             // handle termination criteria\n             // Break, if fitness is good enough\n-            if (stopFitness != 0) { // only if stopFitness is defined\n-                if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {\n-                    break generationLoop;\n-                }\n+            if (stopFitness != 0 && bestFitness < (isMinimize ? stopFitness : -stopFitness)) {\n+                break generationLoop;\n             }\n             final double[] sqrtDiagC = sqrt(diagC).getColumn(0);\n             final double[] pcCol = pc.getColumn(0);\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java\n \n             final PointValuePair previous = new PointValuePair(x1, fX);\n             final PointValuePair current = new PointValuePair(x, fVal);\n-            if (!stop) { // User-defined stopping criteria.\n-                if (checker != null) {\n-                    stop = checker.converged(getIterations(), previous, current);\n-                }\n+            if (!stop && checker != null) { // User-defined stopping criteria.\n+                stop = checker.converged(getIterations(), previous, current);\n             }\n             if (stop) {\n                 if (goal == GoalType.MINIMIZE) {\n--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java\n                     xNorm = FastMath.sqrt(xNorm);\n \n                     // tests for convergence.\n-                    if (checker != null) {\n-                        // we use the vectorial convergence checker\n-                        if (checker.converged(getIterations(), previous, current)) {\n-                            setCost(currentCost);\n-                            return current;\n-                        }\n+                    if (checker != null && checker.converged(getIterations(), previous, current)) {\n+                        setCost(currentCost);\n+                        return current;\n                     }\n                 } else {\n                     // failed iteration, reset the previous values\n--- a/src/main/java/org/apache/commons/math3/optim/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optim/univariate/BrentOptimizer.java\n                                  isMinim),\n                             isMinim);\n \n-                if (checker != null) {\n-                    if (checker.converged(iter, previous, current)) {\n-                        return best;\n-                    }\n+                if (checker != null && checker.converged(iter, previous, current)) {\n+                    return best;\n                 }\n \n                 // Update a, b, v, w and x.\n--- a/src/main/java/org/apache/commons/math3/optim/univariate/SimpleUnivariateValueChecker.java\n+++ b/src/main/java/org/apache/commons/math3/optim/univariate/SimpleUnivariateValueChecker.java\n     public boolean converged(final int iteration,\n                              final UnivariatePointValuePair previous,\n                              final UnivariatePointValuePair current) {\n-        if (maxIterationCount != ITERATION_CHECK_DISABLED) {\n-            if (iteration >= maxIterationCount) {\n-                return true;\n-            }\n+        if (maxIterationCount != ITERATION_CHECK_DISABLED && iteration >= maxIterationCount) {\n+            return true;\n         }\n \n         final double p = previous.getValue();\n--- a/src/main/java/org/apache/commons/math3/optimization/SimplePointChecker.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/SimplePointChecker.java\n     public boolean converged(final int iteration,\n                              final PAIR previous,\n                              final PAIR current) {\n-        if (maxIterationCount != ITERATION_CHECK_DISABLED) {\n-            if (iteration >= maxIterationCount) {\n-                return true;\n-            }\n+        if (maxIterationCount != ITERATION_CHECK_DISABLED && iteration >= maxIterationCount) {\n+            return true;\n         }\n \n         final double[] p = previous.getKey();\n--- a/src/main/java/org/apache/commons/math3/optimization/SimpleValueChecker.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/SimpleValueChecker.java\n     public boolean converged(final int iteration,\n                              final PointValuePair previous,\n                              final PointValuePair current) {\n-        if (maxIterationCount != ITERATION_CHECK_DISABLED) {\n-            if (iteration >= maxIterationCount) {\n-                return true;\n-            }\n+        if (maxIterationCount != ITERATION_CHECK_DISABLED && iteration >= maxIterationCount) {\n+            return true;\n         }\n \n         final double p = previous.getValue();\n--- a/src/main/java/org/apache/commons/math3/optimization/SimpleVectorValueChecker.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/SimpleVectorValueChecker.java\n     public boolean converged(final int iteration,\n                              final PointVectorValuePair previous,\n                              final PointVectorValuePair current) {\n-        if (maxIterationCount != ITERATION_CHECK_DISABLED) {\n-            if (iteration >= maxIterationCount) {\n-                return true;\n-            }\n+        if (maxIterationCount != ITERATION_CHECK_DISABLED && iteration >= maxIterationCount) {\n+            return true;\n         }\n \n         final double[] p = previous.getValueRef();\n--- a/src/main/java/org/apache/commons/math3/optimization/direct/BOBYQAOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/BOBYQAOptimizer.java\n                     vlag = tmp;\n                     isbd = iubd;\n                 }\n-                if (subd > HALF) {\n-                    if (Math.abs(vlag) < ONE_OVER_FOUR) {\n-                        step = HALF;\n-                        vlag = ONE_OVER_FOUR;\n-                        isbd = 0;\n-                    }\n+                if (subd > HALF && Math.abs(vlag) < ONE_OVER_FOUR) {\n+                    step = HALF;\n+                    vlag = ONE_OVER_FOUR;\n+                    isbd = 0;\n                 }\n                 vlag *= dderiv;\n             }\n                     final double diff = stepb - stepa;\n                     modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);\n                     gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);\n-                    if (stepa * stepb < ZERO) {\n-                        if (f < fAtInterpolationPoints.getEntry(nfm - n)) {\n-                            fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));\n-                            fAtInterpolationPoints.setEntry(nfm - n, f);\n-                            if (trustRegionCenterInterpolationPointIndex == nfm) {\n-                                trustRegionCenterInterpolationPointIndex = nfm - n;\n-                            }\n-                            interpolationPoints.setEntry(nfm - n, nfxm, stepb);\n-                            interpolationPoints.setEntry(nfm, nfxm, stepa);\n+                    if (stepa * stepb < ZERO && f < fAtInterpolationPoints.getEntry(nfm - n)) {\n+                        fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));\n+                        fAtInterpolationPoints.setEntry(nfm - n, f);\n+                        if (trustRegionCenterInterpolationPointIndex == nfm) {\n+                            trustRegionCenterInterpolationPointIndex = nfm - n;\n                         }\n+                        interpolationPoints.setEntry(nfm - n, nfxm, stepb);\n+                        interpolationPoints.setEntry(nfm, nfxm, stepa);\n                     }\n                     bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));\n                     bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));\n                 if (gradientAtTrustRegionCenter.getEntry(i) >= ZERO) {\n                     xbdi.setEntry(i, MINUS_ONE);\n                 }\n-            } else if (trustRegionCenterOffset.getEntry(i) >= upperDifference.getEntry(i)) {\n-                if (gradientAtTrustRegionCenter.getEntry(i) <= ZERO) {\n-                    xbdi.setEntry(i, ONE);\n-                }\n+            } else if (trustRegionCenterOffset.getEntry(i) >= upperDifference.getEntry(i) &&\n+                       gradientAtTrustRegionCenter.getEntry(i) <= ZERO) {\n+                xbdi.setEntry(i, ONE);\n             }\n             if (xbdi.getEntry(i) != ZERO) {\n                 ++nact;\n         modelSecondDerivativesValues = new ArrayRealVector(dimension * (dimension + 1) / 2);\n     }\n \n-    /**\n-     * Creates a new array.\n-     *\n-     * @param n Dimension of the returned array.\n-     * @param value Value for each element.\n-     * @return an array containing {@code n} elements set to the given\n-     * {@code value}.\n-     */\n-    private static double[] fillNewArray(int n,\n-                                         double value) {\n-        double[] ds = new double[n];\n-        Arrays.fill(ds, value);\n-        return ds;\n-    }\n-\n     // XXX utility for figuring out call sequence.\n     private static String caller(int n) {\n         final Throwable t = new Throwable();\n--- a/src/main/java/org/apache/commons/math3/optimization/direct/BaseAbstractMultivariateSimpleBoundsOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/BaseAbstractMultivariateSimpleBoundsOptimizer.java\n         super(checker);\n     }\n \n-    /**\n-     * @return the lower bounds.\n-     */\n-    public double[] getLowerBound() {\n-        return super.getLowerBound();\n-    }\n-\n-    /**\n-     * @return the upper bounds.\n-     */\n-    public double[] getUpperBound() {\n-        return super.getUpperBound();\n-    }\n-\n     /** {@inheritDoc} */\n     @Override\n     public PointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\n--- a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n                 lastResult = optimum;\n                 optimum = new PointValuePair(fitfun.repair(bestArx.getColumn(0)),\n                                              isMinimize ? bestFitness : -bestFitness);\n-                if (getConvergenceChecker() != null &&\n-                    lastResult != null) {\n-                    if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\n-                        break generationLoop;\n-                    }\n+                if (getConvergenceChecker() != null && lastResult != null &&\n+                    getConvergenceChecker().converged(iterations, optimum, lastResult)) {\n+                    break generationLoop;\n                 }\n             }\n             // handle termination criteria\n             // Break, if fitness is good enough\n-            if (stopFitness != 0) { // only if stopFitness is defined\n-                if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {\n-                    break generationLoop;\n-                }\n+            if (stopFitness != 0 && bestFitness < (isMinimize ? stopFitness : -stopFitness)) {\n+                break generationLoop;\n             }\n             final double[] sqrtDiagC = sqrt(diagC).getColumn(0);\n             final double[] pcCol = pc.getColumn(0);\n--- a/src/main/java/org/apache/commons/math3/optimization/direct/PowellOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/PowellOptimizer.java\n \n             final PointValuePair previous = new PointValuePair(x1, fX);\n             final PointValuePair current = new PointValuePair(x, fVal);\n-            if (!stop) { // User-defined stopping criteria.\n-                if (checker != null) {\n-                    stop = checker.converged(iter, previous, current);\n-                }\n+            if (!stop && checker != null) {\n+                stop = checker.converged(iter, previous, current);\n             }\n             if (stop) {\n                 if (goal == GoalType.MINIMIZE) {\n--- a/src/main/java/org/apache/commons/math3/optimization/general/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/general/LevenbergMarquardtOptimizer.java\n                     xNorm = FastMath.sqrt(xNorm);\n \n                     // tests for convergence.\n-                    if (checker != null) {\n-                        // we use the vectorial convergence checker\n-                        if (checker.converged(iter, previous, current)) {\n-                            setCost(currentCost);\n-                            // Update (deprecated) \"point\" field.\n-                            point = current.getPoint();\n-                            return current;\n-                        }\n+                    if (checker != null && checker.converged(iter, previous, current)) {\n+                        setCost(currentCost);\n+                        // Update (deprecated) \"point\" field.\n+                        point = current.getPoint();\n+                        return current;\n                     }\n                 } else {\n                     // failed iteration, reset the previous values\n--- a/src/main/java/org/apache/commons/math3/optimization/general/NonLinearConjugateGradientOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/general/NonLinearConjugateGradientOptimizer.java\n             final double objective = computeObjectiveValue(point);\n             PointValuePair previous = current;\n             current = new PointValuePair(point, objective);\n-            if (previous != null) {\n-                if (checker.converged(iter, previous, current)) {\n-                    // We have found an optimum.\n-                    return current;\n-                }\n+            if (previous != null && checker.converged(iter, previous, current)) {\n+                // We have found an optimum.\n+                return current;\n             }\n \n             // Find the optimal step in the search direction.\n--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n                 for (Integer row : minRatioPositions) {\n                     for (int i = varStart; i < varEnd && !row.equals(minRow); i++) {\n                         final Integer basicRow = tableau.getBasicRow(i);\n-                        if (basicRow != null && basicRow.equals(row)) {\n-                            if (i < minIndex) {\n-                                minIndex = i;\n-                                minRow = row;\n-                            }\n+                        if (basicRow != null && basicRow.equals(row) && i < minIndex) {\n+                            minIndex = i;\n+                            minRow = row;\n                         }\n                     }\n                 }\n--- a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n                                  isMinim),\n                             isMinim);\n \n-                if (checker != null) {\n-                    if (checker.converged(iter, previous, current)) {\n-                        return best;\n-                    }\n+                if (checker != null && checker.converged(iter, previous, current)) {\n+                    return best;\n                 }\n \n                 // Update a, b, v, w and x.\n--- a/src/main/java/org/apache/commons/math3/optimization/univariate/SimpleUnivariateValueChecker.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/univariate/SimpleUnivariateValueChecker.java\n     public boolean converged(final int iteration,\n                              final UnivariatePointValuePair previous,\n                              final UnivariatePointValuePair current) {\n-        if (maxIterationCount != ITERATION_CHECK_DISABLED) {\n-            if (iteration >= maxIterationCount) {\n-                return true;\n-            }\n+        if (maxIterationCount != ITERATION_CHECK_DISABLED && iteration >= maxIterationCount) {\n+            return true;\n         }\n \n         final double p = previous.getValue();\n--- a/src/main/java/org/apache/commons/math3/util/CompositeFormat.java\n+++ b/src/main/java/org/apache/commons/math3/util/CompositeFormat.java\n         final int n = sb.length();\n         final int startIndex = pos.getIndex();\n         final int endIndex = startIndex + n;\n-        if (endIndex < source.length()) {\n-            if (source.substring(startIndex, endIndex).compareTo(sb.toString()) == 0) {\n-                ret = Double.valueOf(value);\n-                pos.setIndex(endIndex);\n-            }\n+        if (endIndex < source.length() &&\n+            source.substring(startIndex, endIndex).compareTo(sb.toString()) == 0) {\n+            ret = Double.valueOf(value);\n+            pos.setIndex(endIndex);\n         }\n \n         return ret;\n--- a/src/main/java/org/apache/commons/math3/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math3/util/FastMath.java\n         long bits = Double.doubleToRawLongBits(x);\n \n         /* Handle special cases of negative input, and NaN */\n-        if ((bits & 0x8000000000000000L) != 0 || x != x) {\n-            if (x != 0.0) {\n-                if (hiPrec != null) {\n-                    hiPrec[0] = Double.NaN;\n-                }\n-\n-                return Double.NaN;\n-            }\n+        if (((bits & 0x8000000000000000L) != 0 || x != x) && x != 0.0) {\n+            if (hiPrec != null) {\n+                hiPrec[0] = Double.NaN;\n+            }\n+\n+            return Double.NaN;\n         }\n \n         /* Handle special cases of Positive infinity. */\n         }\n \n \n-        if (exp == -1 || exp == 0) {\n-            if (x < 1.01 && x > 0.99 && hiPrec == null) {\n-                /* The normal method doesn't work well in the range [0.99, 1.01], so call do a straight\n+        if ((exp == -1 || exp == 0) && x < 1.01 && x > 0.99 && hiPrec == null) {\n+            /* The normal method doesn't work well in the range [0.99, 1.01], so call do a straight\n            polynomial expansion in higer precision. */\n \n-               /* Compute x - 1.0 and split it */\n-                double xa = x - 1.0;\n-                double xb = xa - x + 1.0;\n-                double tmp = xa * HEX_40000000;\n-                double aa = xa + tmp - tmp;\n-                double ab = xa - aa;\n-                xa = aa;\n-                xb = ab;\n-\n-                final double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1];\n-                double ya = lnCoef_last[0];\n-                double yb = lnCoef_last[1];\n-\n-                for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {\n-                    /* Multiply a = y * x */\n-                    aa = ya * xa;\n-                    ab = ya * xb + yb * xa + yb * xb;\n-                    /* split, so now y = a */\n-                    tmp = aa * HEX_40000000;\n-                    ya = aa + tmp - tmp;\n-                    yb = aa - ya + ab;\n-\n-                    /* Add  a = y + lnQuickCoef */\n-                    final double[] lnCoef_i = LN_QUICK_COEF[i];\n-                    aa = ya + lnCoef_i[0];\n-                    ab = yb + lnCoef_i[1];\n-                    /* Split y = a */\n-                    tmp = aa * HEX_40000000;\n-                    ya = aa + tmp - tmp;\n-                    yb = aa - ya + ab;\n-                }\n-\n+            /* Compute x - 1.0 and split it */\n+            double xa = x - 1.0;\n+            double xb = xa - x + 1.0;\n+            double tmp = xa * HEX_40000000;\n+            double aa = xa + tmp - tmp;\n+            double ab = xa - aa;\n+            xa = aa;\n+            xb = ab;\n+\n+            final double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1];\n+            double ya = lnCoef_last[0];\n+            double yb = lnCoef_last[1];\n+\n+            for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {\n                 /* Multiply a = y * x */\n                 aa = ya * xa;\n                 ab = ya * xb + yb * xa + yb * xb;\n                 ya = aa + tmp - tmp;\n                 yb = aa - ya + ab;\n \n-                return ya + yb;\n-            }\n+                /* Add  a = y + lnQuickCoef */\n+                final double[] lnCoef_i = LN_QUICK_COEF[i];\n+                aa = ya + lnCoef_i[0];\n+                ab = yb + lnCoef_i[1];\n+                /* Split y = a */\n+                tmp = aa * HEX_40000000;\n+                ya = aa + tmp - tmp;\n+                yb = aa - ya + ab;\n+            }\n+\n+            /* Multiply a = y * x */\n+            aa = ya * xa;\n+            ab = ya * xb + yb * xa + yb * xb;\n+            /* split, so now y = a */\n+            tmp = aa * HEX_40000000;\n+            ya = aa + tmp - tmp;\n+            yb = aa - ya + ab;\n+\n+            return ya + yb;\n         }\n \n         // lnm is a log of a number in the range of 1.0 - 2.0, so 0 <= lnm < ln(2)\n--- a/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/BOBYQAOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/BOBYQAOptimizerTest.java\n import org.apache.commons.math3.optim.InitialGuess;\n import org.apache.commons.math3.optim.SimpleBounds;\n import org.junit.Assert;\n+import org.junit.Ignore;\n import org.junit.Test;\n \n /**\n     }\n \n     // See MATH-728\n-    @Test\n+    // TODO: this test is temporarily disabled for 3.2 release as a bug in Cobertura\n+    //       makes it run for several hours before completing\n+    @Ignore @Test\n     public void testConstrainedRosenWithMoreInterpolationPoints() {\n         final double[] startPoint = point(DIM, 0.1);\n         final double[][] boundaries = boundaries(DIM, -1, 2);\n--- a/src/test/java/org/apache/commons/math3/optimization/direct/BOBYQAOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math3/optimization/direct/BOBYQAOptimizerTest.java\n import org.apache.commons.math3.optimization.InitialGuess;\n import org.apache.commons.math3.optimization.SimpleBounds;\n import org.junit.Assert;\n+import org.junit.Ignore;\n import org.junit.Test;\n \n /**\n     }\n \n     // See MATH-728\n-    @Test\n+    // TODO: this test is temporarily disabled for 3.2 release as a bug in Cobertura\n+    //       makes it run for several hours before completing\n+    @Ignore @Test\n     public void testConstrainedRosenWithMoreInterpolationPoints() {\n         final double[] startPoint = point(DIM, 0.1);\n         final double[][] boundaries = boundaries(DIM, -1, 2);", "timestamp": 1364572107, "metainfo": ""}