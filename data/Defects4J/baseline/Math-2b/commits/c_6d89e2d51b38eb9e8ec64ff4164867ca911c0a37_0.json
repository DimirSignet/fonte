{"sha": "6d89e2d51b38eb9e8ec64ff4164867ca911c0a37", "log": "MATH-1012 Removed duplicate code.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/random/RandomDataGenerator.java\n+++ b/src/main/java/org/apache/commons/math3/random/RandomDataGenerator.java\n     private RandomGenerator rand = null;\n \n     /** underlying secure random number generator */\n-    private SecureRandom secRand = null;\n+    private RandomGenerator secRand = null;\n \n     /**\n      * Construct a RandomDataGenerator, using a default random generator as the source\n         }\n \n         // Get SecureRandom and setup Digest provider\n-        SecureRandom secRan = getSecRan();\n+        final RandomGenerator secRan = getSecRan();\n         MessageDigest alg = null;\n         try {\n             alg = MessageDigest.getInstance(\"SHA-1\");\n \n     /**  {@inheritDoc} */\n     public int nextSecureInt(final int lower, final int upper) throws NumberIsTooLargeException {\n-        if (lower >= upper) {\n-            throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n-                                                lower, upper, false);\n-        }\n-        final int max = (upper - lower) + 1;\n-        if (max <= 0) {\n-            // the range is too wide to fit in a positive int (larger than 2^31); as it covers\n-            // more than half the integer range, we use directly a simple rejection method\n-            final SecureRandom rng = getSecRan();\n-            while (true) {\n-                final int r = rng.nextInt();\n-                if (r >= lower && r <= upper) {\n-                    return r;\n-                }\n-            }\n-        } else {\n-            // we can shift the range and generate directly a positive int\n-            return lower + getSecRan().nextInt(max);\n-        }\n+        return new UniformIntegerDistribution(getSecRan(), lower, upper).sample();\n     }\n \n     /** {@inheritDoc} */\n             throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n                                                 lower, upper, false);\n         }\n+        final RandomGenerator rng = getSecRan();\n         final long max = (upper - lower) + 1;\n         if (max <= 0) {\n             // the range is too wide to fit in a positive long (larger than 2^63); as it covers\n             // more than half the long range, we use directly a simple rejection method\n-            final SecureRandom rng = getSecRan();\n             while (true) {\n                 final long r = rng.nextLong();\n                 if (r >= lower && r <= upper) {\n             }\n         } else if (max < Integer.MAX_VALUE){\n             // we can shift the range and generate directly a positive int\n-            return lower + getSecRan().nextInt((int) max);\n+            return lower + rng.nextInt((int) max);\n         } else {\n             // we can shift the range and generate directly a positive long\n-            return lower + nextLong(getSecRan(), max);\n-        }\n-    }\n-\n-    /**\n-     * Returns a pseudorandom, uniformly distributed <tt>long</tt> value\n-     * between 0 (inclusive) and the specified value (exclusive), drawn from\n-     * this random number generator's sequence.\n-     *\n-     * @param rng random generator to use\n-     * @param n the bound on the random number to be returned.  Must be\n-     * positive.\n-     * @return  a pseudorandom, uniformly distributed <tt>long</tt>\n-     * value between 0 (inclusive) and n (exclusive).\n-     * @throws IllegalArgumentException  if n is not positive.\n-     */\n-    private static long nextLong(final SecureRandom rng, final long n) throws IllegalArgumentException {\n-        if (n > 0) {\n-            final byte[] byteArray = new byte[8];\n-            long bits;\n-            long val;\n-            do {\n-                rng.nextBytes(byteArray);\n-                bits = 0;\n-                for (final byte b : byteArray) {\n-                    bits = (bits << 8) | (((long) b) & 0xffL);\n-                }\n-                bits = bits & 0x7fffffffffffffffL;\n-                val  = bits % n;\n-            } while (bits - val + (n - 1) < 0);\n-            return val;\n-        }\n-        throw new NotStrictlyPositiveException(n);\n+            return lower + nextLong(rng, max);\n+        }\n     }\n \n     /**\n      */\n     public void setSecureAlgorithm(String algorithm, String provider)\n             throws NoSuchAlgorithmException, NoSuchProviderException {\n-        secRand = SecureRandom.getInstance(algorithm, provider);\n+        secRand = RandomGeneratorFactory.createRandomGenerator(SecureRandom.getInstance(algorithm, provider));\n     }\n \n     /**\n      * {@code System.currentTimeMillis() + System.identityHashCode(this)} as the default seed.\n      * </p>\n      *\n-     * @return the SecureRandom used to generate secure random data\n-     */\n-    private SecureRandom getSecRan() {\n+     * @return the SecureRandom used to generate secure random data, wrapped in a\n+     * {@link RandomGenerator}.\n+     */\n+    private RandomGenerator getSecRan() {\n         if (secRand == null) {\n-            secRand = new SecureRandom();\n+            secRand = RandomGeneratorFactory.createRandomGenerator(new SecureRandom());\n             secRand.setSeed(System.currentTimeMillis() + System.identityHashCode(this));\n         }\n         return secRand;", "timestamp": 1375365477, "metainfo": ""}