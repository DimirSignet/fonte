{"sha": "1cd68eed57febf806c385bf04a596b922f4c1964", "log": "Fixed missing update in ODE event handlers.  When a RESET_STATE was triggered, event states for events not triggered in the same step were not updated properly.  JIRA: MATH-950  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n                 interpolator.setSoftPreviousTime(previousT);\n                 interpolator.setSoftCurrentTime(eventT);\n \n-                // trigger the event\n+                // get state at event time\n                 interpolator.setInterpolatedTime(eventT);\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n+\n+                // advance all event states to current time\n+                for (final EventState state : eventsStates) {\n+                    state.stepAccepted(eventT, eventY);\n+                    isLastStep = isLastStep || state.stop();\n+                }\n \n                 // handle the first part of the step, up to the event\n                 for (final StepHandler handler : stepHandlers) {\n                 if (isLastStep) {\n                     // the event asked to stop integration\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n                     return eventT;\n                 }\n \n-                if (currentEvent.reset(eventT, eventY)) {\n+                boolean needReset = false;\n+                for (final EventState state : eventsStates) {\n+                    needReset =  needReset || state.reset(eventT, eventY);\n+                }\n+                if (needReset) {\n                     // some event handler has triggered changes that\n                     // invalidate the derivatives, we need to recompute them\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n                     computeDerivatives(eventT, y, yDot);\n                     resetOccurred = true;\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n                     return eventT;\n                 }\n \n \n             }\n \n+            // last part of the step, after the last event\n             interpolator.setInterpolatedTime(currentT);\n             final double[] currentY = interpolator.getInterpolatedState();\n             for (final EventState state : eventsStates) {\n--- a/src/test/java/org/apache/commons/math3/ode/nonstiff/DormandPrince853IntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math3/ode/nonstiff/DormandPrince853IntegratorTest.java\n     Assert.assertEquals(8.0, y[0], 1.0e-12);\n   }\n \n+  @Test\n+  public void testEventsScheduling() {\n+\n+      FirstOrderDifferentialEquations sincos = new FirstOrderDifferentialEquations() {\n+\n+          public int getDimension() {\n+              return 2;\n+          }\n+\n+          public void computeDerivatives(double t, double[] y, double[] yDot) {\n+              yDot[0] =  y[1];\n+              yDot[1] = -y[0];\n+          }\n+\n+      };\n+\n+      SchedulingChecker sinChecker = new SchedulingChecker(0); // events at 0, PI, 2PI ...\n+      SchedulingChecker cosChecker = new SchedulingChecker(1); // events at PI/2, 3PI/2, 5PI/2 ...\n+\n+      FirstOrderIntegrator integ =\n+              new DormandPrince853Integrator(0.001, 1.0, 1.0e-12, 0.0);\n+      integ.addEventHandler(sinChecker, 0.01, 1.0e-7, 100);\n+      integ.addStepHandler(sinChecker);\n+      integ.addEventHandler(cosChecker, 0.01, 1.0e-7, 100);\n+      integ.addStepHandler(cosChecker);\n+      double   t0 = 0.5;\n+      double[] y0 = new double[] { FastMath.sin(t0), FastMath.cos(t0) };\n+      double   t  = 10.0;\n+      double[] y  = new double[2];\n+      integ.integrate(sincos, t0, y0, t, y);\n+\n+  }\n+\n+  private static class SchedulingChecker implements StepHandler, EventHandler {\n+\n+      int index;\n+      double tMin;\n+\n+      public SchedulingChecker(int index) {\n+          this.index = index;\n+      }\n+\n+      public void init(double t0, double[] y0, double t) {\n+          tMin = t0;\n+      }\n+\n+      public void handleStep(StepInterpolator interpolator, boolean isLast) {\n+          tMin = interpolator.getCurrentTime();\n+      }\n+\n+      public double g(double t, double[]  y) {\n+          // once a step has been handled by handleStep,\n+          // events checking should only refer to dates after the step\n+          Assert.assertTrue(t >= tMin);\n+          return y[index];\n+      }\n+\n+      public Action eventOccurred(double t, double[] y, boolean increasing) {\n+          return Action.RESET_STATE;\n+      }\n+\n+      public void resetState(double t, double[] y) {\n+          // in fact, we don't need to reset anything for the test\n+      }\n+\n+  }\n+\n   private static class KeplerHandler implements StepHandler {\n     public KeplerHandler(TestProblem3 pb) {\n       this.pb = pb;", "timestamp": 1363702148, "metainfo": ""}