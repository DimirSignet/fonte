{"sha": "186be85467c5339ece5c4ec42e83e8d1e64f58bc", "log": "Checkstyle  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n      *\n      * @since 3.0\n      */\n-    // See also Lucene's ASCIIFoldingFilter (Lucene 2.9) that replaces accented characters by their unaccented equivalent (and uncommited bug fix: https://issues.apache.org/jira/browse/LUCENE-1343?focusedCommentId=12858907&page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#action_12858907).\n+    // See also Lucene's ASCIIFoldingFilter (Lucene 2.9) that replaces accented characters by their\n+    // unaccented equivalent (and uncommited bug fix:\n+    // https://issues.apache.org/jira/browse/LUCENE-1343?focusedCommentId=12858907&page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#action_12858907).\n     public static String stripAccents(CharSequence input) {\n         if(input == null) {\n             return null;\n             } else if (sunAvailable) {\n                 result = removeAccentsSUN(input);\n             } else {\n-                throw new UnsupportedOperationException(\"The stripAccents(CharSequence) method requires at least Java 1.6 or a Sun JVM\");\n+                throw new UnsupportedOperationException(\"The stripAccents(CharSequence) method requires at least \"\n+                        + \"Java 1.6 or a Sun JVM\");\n             }\n             // Note that none of the above methods correctly remove ligatures...\n             return result;\n     /**\n      * Use {@code java.text.Normalizer#normalize(CharSequence, Normalizer.Form)}\n      * (but be careful, this classe exists in Java 1.3, with an entirely different meaning!)\n-     * @param text\n-     */\n-    private static String removeAccentsJava6(CharSequence text) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n+     *\n+     * @param text the text to be processed\n+     * @return the processed string\n+     * @throws IllegalAccessException may be thrown by a reflection call\n+     * @throws InvocationTargetException if a reflection call throws an exception\n+     * @throws IllegalStateException if the {@code Normalizer} class is not available\n+     */\n+    private static String removeAccentsJava6(CharSequence text)\n+        throws IllegalAccessException, InvocationTargetException {\n         /*\n         String decomposed = java.text.Normalizer.normalize(CharSequence, Normalizer.Form.NFD);\n         return java6Pattern.matcher(decomposed).replaceAll(\"\");//$NON-NLS-1$\n \n     /**\n      * Use {@code sun.text.Normalizer#decompose(String, boolean, int)}\n-     */\n-    private static String removeAccentsSUN(CharSequence text) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n+     *\n+     * @param text the text to be processed\n+     * @return the processed string\n+     * @throws IllegalAccessException may be thrown by a reflection call\n+     * @throws InvocationTargetException if a reflection call throws an exception\n+     * @throws IllegalStateException if the {@code Normalizer} class is not available\n+     */\n+    private static String removeAccentsSUN(CharSequence text)\n+        throws IllegalAccessException, InvocationTargetException {\n         /*\n         String decomposed = sun.text.Normalizer.decompose(text, false, 0);\n         return sunPattern.matcher(decomposed).replaceAll(\"\");//$NON-NLS-1$\n         try {\n             // java.text.Normalizer.normalize(CharSequence, Normalizer.Form.NFD);\n             // Be careful not to get Java 1.3 java.text.Normalizer!\n-            Class<?> normalizerFormClass = Thread.currentThread().getContextClassLoader().loadClass(\"java.text.Normalizer$Form\");//$NON-NLS-1$\n+            Class<?> normalizerFormClass = Thread.currentThread().getContextClassLoader()\n+                .loadClass(\"java.text.Normalizer$Form\");//$NON-NLS-1$\n             java6NormalizerFormNFD = normalizerFormClass.getField(\"NFD\").get(null);//$NON-NLS-1$\n-            Class<?> normalizerClass = Thread.currentThread().getContextClassLoader().loadClass(\"java.text.Normalizer\");//$NON-NLS-1$\n-            java6NormalizeMethod = normalizerClass.getMethod(\"normalize\", new Class[] {CharSequence.class, normalizerFormClass});//$NON-NLS-1$\n+            Class<?> normalizerClass = Thread.currentThread().getContextClassLoader()\n+                .loadClass(\"java.text.Normalizer\");//$NON-NLS-1$\n+            java6NormalizeMethod = normalizerClass.getMethod(\"normalize\",\n+                    new Class[] {CharSequence.class, normalizerFormClass});//$NON-NLS-1$\n             java6Available = true;\n         } catch (ClassNotFoundException e) {\n             java6Available = false;\n \n         try {\n             // sun.text.Normalizer.decompose(text, false, 0);\n-            Class<?> normalizerClass = Thread.currentThread().getContextClassLoader().loadClass(\"sun.text.Normalizer\");//$NON-NLS-1$\n-            sunDecomposeMethod = normalizerClass.getMethod(\"decompose\", new Class[] {String.class, Boolean.TYPE, Integer.TYPE});//$NON-NLS-1$\n+            Class<?> normalizerClass = Thread.currentThread().getContextClassLoader()\n+                .loadClass(\"sun.text.Normalizer\");//$NON-NLS-1$\n+            sunDecomposeMethod = normalizerClass.getMethod(\"decompose\",\n+                    new Class[] {String.class, Boolean.TYPE, Integer.TYPE});//$NON-NLS-1$\n             sunAvailable = true;\n         } catch (ClassNotFoundException e) {\n             sunAvailable = false;\n      * @param cs2  the second CharSequence, may be null\n      * @return the index where cs1 and cs2 begin to differ; -1 if they are equal\n      * @since 2.0\n-     * @since 3.0 Changed signature from indexOfDifference(String, String) to indexOfDifference(CharSequence, CharSequence)\n+     * @since 3.0 Changed signature from indexOfDifference(String, String) to\n+     * indexOfDifference(CharSequence, CharSequence)\n      */\n     public static int indexOfDifference(CharSequence cs1, CharSequence cs2) {\n         if (cs1 == cs2) {\n      * @param t  the second String, must not be null\n      * @return result distance\n      * @throws IllegalArgumentException if either String input {@code null}\n-     * @since 3.0 Changed signature from getLevenshteinDistance(String, String) to getLevenshteinDistance(CharSequence, CharSequence)\n+     * @since 3.0 Changed signature from getLevenshteinDistance(String, String) to\n+     * getLevenshteinDistance(CharSequence, CharSequence)\n      */\n     public static int getLevenshteinDistance(CharSequence s, CharSequence t) {\n         if (s == null || t == null) {\n     /**\n      * <p>Returns a new {@code CharSequence} that is a subsequence of this\n      * sequence starting with the {@code char} value at the specified index.</p>\n-     * \n+     *\n      * <p>This provides the {@code CharSequence} equivalent to {@link String#substring(int)}.\n      * The length (in {@code char}) of the returned sequence is {@code length() - start},\n      * so if {@code start == end} then an empty sequence is returned.</p>\n      * @param cs  the specified subsequence, null returns null\n      * @param start  the start index, inclusive, valid\n      * @return a new subsequence, may be null\n-     * @throws IndexOutOfBoundsException if {@code start} is negative or if \n+     * @throws IndexOutOfBoundsException if {@code start} is negative or if\n      *  {@code start} is greater than {@code length()}\n      */\n     public static CharSequence subSequence(CharSequence cs, int start) {\n         return cs == null ? null : cs.subSequence(start, cs.length());\n     }\n \n-    // The following methods are used to support basic java.lang.String functionality \n-    // for CharSequences. Currently keeping these as package private; they may be \n-    // useful as public methods so others can also support CharSequence instead of \n-    // String. At that point they may make more sense on a CharSequenceUtils and \n+    // The following methods are used to support basic java.lang.String functionality\n+    // for CharSequences. Currently keeping these as package private; they may be\n+    // useful as public methods so others can also support CharSequence instead of\n+    // String. At that point they may make more sense on a CharSequenceUtils and\n     // will want a name change.\n \n-    // Used by the indexOf(CharSequence methods) as a green implementation of indexOf\n+    /**\n+     * Used by the indexOf(CharSequence methods) as a green implementation of\n+     * indexOf.\n+     *\n+     * @param cs the {@code CharSequence} to be processed\n+     * @param searchChar the char to be searched for\n+     * @param start the start index\n+     * @return the index where the search char was found\n+     */\n     static int indexOfSequence(CharSequence cs, int searchChar, int start) {\n         if (cs instanceof String) {\n             return ((String) cs).indexOf(searchChar, start);\n             return -1;\n         }\n     }\n-    // Used by the indexOf(CharSequence methods) as a green implementation of indexOf\n+\n+    /**\n+     * Used by the indexOf(CharSequence methods) as a green implementation of indexOf.\n+     *\n+     * @param cs the {@code CharSequence} to be processed\n+     * @param searchChar the {@code CharSequence} to be searched for\n+     * @param start the start index\n+     * @return the index where the search sequence was found\n+     */\n     static int indexOfSequence(CharSequence cs, CharSequence searchChar, int start) {\n         if (cs instanceof String && searchChar instanceof String) {\n-            // TODO: Do we assume searchChar is usually relatively small; \n-            //       If so then calling toString() on it is better than reverting to \n+            // TODO: Do we assume searchChar is usually relatively small;\n+            //       If so then calling toString() on it is better than reverting to\n             //       the green implementation in the else block\n             return ((String) cs).indexOf( (String) searchChar, start);\n         } else {\n         }\n     }\n \n-    // Used by the lastIndexOf(CharSequence methods) as a green implementation of lastIndexOf\n+    /**\n+     * Used by the lastIndexOf(CharSequence methods) as a green implementation of lastIndexOf\n+     *\n+     * @param cs the {@code CharSequence} to be processed\n+     * @param searchChar the char to be searched for\n+     * @param start the start index\n+     * @return the index where the search char was found\n+     */\n     static int lastIndexOfSequence(CharSequence cs, int searchChar, int start) {\n         if (cs instanceof String) {\n             return ((String) cs).lastIndexOf(searchChar, start);\n             return -1;\n         }\n     }\n-    // Used by the lastIndexOf(CharSequence methods) as a green implementation of lastIndexOf\n+\n+    /**\n+     * Used by the lastIndexOf(CharSequence methods) as a green implementation of lastIndexOf\n+     *\n+     * @param cs the {@code CharSequence} to be processed\n+     * @param searchChar the {@code CharSequence} to be searched for\n+     * @param start the start index\n+     * @return the index where the search sequence was found\n+     */\n     static int lastIndexOfSequence(CharSequence cs, CharSequence searchChar, int start) {\n         if (cs instanceof String && searchChar instanceof String) {\n-            // TODO: Do we assume searchChar is usually relatively small; \n-            //       If so then calling toString() on it is better than reverting to \n+            // TODO: Do we assume searchChar is usually relatively small;\n+            //       If so then calling toString() on it is better than reverting to\n             //       the green implementation in the else block\n             return ((String) cs).lastIndexOf( (String) searchChar, start);\n         } else {\n         }\n     }\n \n-    // Green implementation of toCharArray\n+    /**\n+     * Green implementation of toCharArray.\n+     *\n+     * @param cs the {@code CharSequence} to be processed\n+     * @return the resulting char array\n+     */\n+    //\n     static char[] toCharArraySequence(CharSequence cs) {\n         if (cs instanceof String) {\n             return ((String) cs).toCharArray();", "timestamp": 1300552354, "metainfo": ""}