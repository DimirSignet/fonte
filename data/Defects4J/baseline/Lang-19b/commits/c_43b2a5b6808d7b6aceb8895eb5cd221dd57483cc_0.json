{"sha": "43b2a5b6808d7b6aceb8895eb5cd221dd57483cc", "log": "Applying a modified version of Maarten Coene's patch for #LANG-69. All unit tests pass; opinions would be very welcome though.   ", "commit": "\n--- a/src/java/org/apache/commons/lang/builder/ReflectionToStringBuilder.java\n+++ b/src/java/org/apache/commons/lang/builder/ReflectionToStringBuilder.java\n  * @version $Id$\n  */\n public class ReflectionToStringBuilder extends ToStringBuilder {\n-    /**\n-     * <p>\n-     * A registry of objects used by <code>reflectionToString</code> methods to detect cyclical object references and\n-     * avoid infinite loops.\n-     * </p>\n-     */\n-    private static ThreadLocal registry = new ThreadLocal() {\n-        protected synchronized Object initialValue() {\n-            // The HashSet implementation is not synchronized,\n-            // which is just what we need here.\n-            return new HashSet();\n-        }\n-    };\n-\n-    /**\n-     * <p>\n-     * Returns the registry of objects being traversed by the <code>reflectionToString</code> methods in the current\n-     * thread.\n-     * </p>\n-     * \n-     * @return Set the registry of objects being traversed\n-     */\n-    static Set getRegistry() {\n-        return (Set) registry.get();\n-    }\n-\n-    /**\n-     * <p>\n-     * Returns <code>true</code> if the registry contains the given object. Used by the reflection methods to avoid\n-     * infinite loops.\n-     * </p>\n-     * \n-     * @param value\n-     *            The object to lookup in the registry.\n-     * @return boolean <code>true</code> if the registry contains the given object.\n-     */\n-    static boolean isRegistered(Object value) {\n-        return getRegistry().contains(value);\n-    }\n-\n-    /**\n-     * <p>\n-     * Registers the given object. Used by the reflection methods to avoid infinite loops.\n-     * </p>\n-     * \n-     * @param value\n-     *            The object to register.\n-     */\n-    static void register(Object value) {\n-        getRegistry().add(value);\n-    }\n \n     /**\n      * <p>\n      */\n     public static String toStringExclude(Object object, String[] excludeFieldNames) {\n         return new ReflectionToStringBuilder(object).setExcludeFieldNames(excludeFieldNames).toString();\n-    }\n-\n-    /**\n-     * <p>\n-     * Unregisters the given object.\n-     * </p>\n-     * \n-     * <p>\n-     * Used by the reflection methods to avoid infinite loops.\n-     * </p>\n-     * \n-     * @param value\n-     *            The object to unregister.\n-     */\n-    static void unregister(Object value) {\n-        getRegistry().remove(value);\n     }\n \n     /**\n      *            The class of object parameter\n      */\n     protected void appendFieldsIn(Class clazz) {\n-        if (isRegistered(this.getObject())) {\n-            // The object has already been appended, therefore we have an\n-            // object cycle.\n-            // Append a simple Object.toString style string. The field name is\n-            // already appended at this point.\n-            this.appendAsObjectToString(this.getObject());\n+        if (clazz.isArray()) {\n+            this.reflectionAppendArray(this.getObject());\n             return;\n         }\n-        try {\n-            this.registerObject();\n-            if (clazz.isArray()) {\n-                this.reflectionAppendArray(this.getObject());\n-                return;\n-            }\n-            Field[] fields = clazz.getDeclaredFields();\n-            AccessibleObject.setAccessible(fields, true);\n-            for (int i = 0; i < fields.length; i++) {\n-                Field field = fields[i];\n-                String fieldName = field.getName();\n-                if (this.accept(field)) {\n-                    try {\n-                        // Warning: Field.get(Object) creates wrappers objects\n-                        // for primitive types.\n-                        Object fieldValue = this.getValue(field);\n-                        if (isRegistered(fieldValue) && !field.getType().isPrimitive()) {\n-                            // A known field value has already been appended,\n-                            // therefore we have an object cycle,\n-                            // append a simple Object.toString style string.\n-                            this.getStyle().appendFieldStart(this.getStringBuffer(), fieldName);\n-                            this.appendAsObjectToString(fieldValue);\n-                            this.getStyle().appendFieldEnd(this.getStringBuffer(), fieldName);\n-                            // The recursion out of\n-                            // builder.append(fieldName, fieldValue);\n-                            // below will append the field\n-                            // end marker.\n-                        } else {\n-                            try {\n-                                this.registerObject();\n-                                this.append(fieldName, fieldValue);\n-                            } finally {\n-                                this.unregisterObject();\n-                            }\n-                        }\n-                    } catch (IllegalAccessException ex) {\n-                        // this can't happen. Would get a Security exception\n-                        // instead\n-                        // throw a runtime exception in case the impossible\n-                        // happens.\n-                        throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n-                    }\n+        Field[] fields = clazz.getDeclaredFields();\n+        AccessibleObject.setAccessible(fields, true);\n+        for (int i = 0; i < fields.length; i++) {\n+            Field field = fields[i];\n+            String fieldName = field.getName();\n+            if (this.accept(field)) {\n+                try {\n+                    // Warning: Field.get(Object) creates wrappers objects\n+                    // for primitive types.\n+                    Object fieldValue = this.getValue(field);\n+                    this.append(fieldName, fieldValue);\n+                } catch (IllegalAccessException ex) {\n+                    //this can't happen. Would get a Security exception\n+                    // instead\n+                    //throw a runtime exception in case the impossible\n+                    // happens.\n+                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n                 }\n             }\n-        } finally {\n-            this.unregisterObject();\n         }\n     }\n \n     public ToStringBuilder reflectionAppendArray(Object array) {\n         this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\n         return this;\n-    }\n-\n-    /**\n-     * <p>\n-     * Registers this builder's source object to avoid infinite loops when processing circular object references.\n-     * </p>\n-     */\n-    void registerObject() {\n-        register(this.getObject());\n     }\n \n     /**\n         return super.toString();\n     }\n \n-    /**\n-     * <p>\n-     * Unregisters this builder's source object to avoid infinite loops when processing circular object references.\n-     * </p>\n-     */\n-    void unregisterObject() {\n-        unregister(this.getObject());\n-    }\n }\n--- a/src/java/org/apache/commons/lang/builder/ToStringStyle.java\n+++ b/src/java/org/apache/commons/lang/builder/ToStringStyle.java\n import java.io.Serializable;\n import java.lang.reflect.Array;\n import java.util.Collection;\n+import java.util.HashSet;\n import java.util.Map;\n+import java.util.Set;\n \n import org.apache.commons.lang.ClassUtils;\n import org.apache.commons.lang.ObjectUtils;\n     public static final ToStringStyle SIMPLE_STYLE = new SimpleToStringStyle();\n     \n     /**\n+     * <p>\n+     * A registry of objects used by <code>reflectionToString</code> methods\n+     * to detect cyclical object references and avoid infinite loops.\n+     * </p>\n+     */\n+    private static ThreadLocal registry = new ThreadLocal() {\n+        protected synchronized Object initialValue() {\n+            // The HashSet implementation is not synchronized,\n+            // which is just what we need here.\n+            return new HashSet();\n+        }\n+    };\n+\n+    /**\n+     * <p>\n+     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n+     * methods in the current thread.\n+     * </p>\n+     * \n+     * @return Set the registry of objects being traversed\n+     */\n+    static Set getRegistry() {\n+        return (Set) registry.get();\n+    }\n+\n+    /**\n+     * <p>\n+     * Returns <code>true</code> if the registry contains the given object.\n+     * Used by the reflection methods to avoid infinite loops.\n+     * </p>\n+     * \n+     * @param value\n+     *                  The object to lookup in the registry.\n+     * @return boolean <code>true</code> if the registry contains the given\n+     *             object.\n+     */\n+    static boolean isRegistered(Object value) {\n+        return getRegistry().contains(value);\n+    }\n+\n+    /**\n+     * <p>\n+     * Registers the given object. Used by the reflection methods to avoid\n+     * infinite loops.\n+     * </p>\n+     * \n+     * @param value\n+     *                  The object to register.\n+     */\n+    static void register(Object value) {\n+        if (value != null) {\n+            getRegistry().add(value);\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Unregisters the given object.\n+     * </p>\n+     * \n+     * <p>\n+     * Used by the reflection methods to avoid infinite loops.\n+     * </p>\n+     * \n+     * @param value\n+     *                  The object to unregister.\n+     */\n+    static void unregister(Object value) {\n+        getRegistry().remove(value);\n+    }\n+\n+    /**\n      * Whether to use the field names, the default is <code>true</code>.\n      */\n     private boolean useFieldNames = true;\n             removeLastFieldSeparator(buffer);\n         }\n         appendContentEnd(buffer);\n+        unregister(object);\n     }\n \n     /**\n      * @param detail  output detail or not\n      */\n     protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n-        if (ReflectionToStringBuilder.isRegistered(value)\n+        if (isRegistered(value)\n             && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n-            ObjectUtils.appendIdentityToString(buffer, value);\n-\n-        } else if (value instanceof Collection) {\n+           appendCyclicObject(buffer, fieldName, value);\n+           return;\n+        }   \n+           register(value);\n+try {\n+        if (value instanceof Collection) {\n             if (detail) {\n                 appendDetail(buffer, fieldName, (Collection) value);\n             } else {\n             }\n \n         } else {\n-            if (detail) {\n-                appendDetail(buffer, fieldName, value);\n-            } else {\n-                appendSummary(buffer, fieldName, value);\n-            }\n-        }\n+                if (detail) {\n+                    appendDetail(buffer, fieldName, value);\n+                } else {\n+                    appendSummary(buffer, fieldName, value);\n+                }\n+        }\n+            } finally {\n+                unregister(value);\n+            }\n+    }\n+    \n+    /**\n+     * <p>Append to the <code>toString</code> an <code>Object</code>\n+     * value that has been detected to participate in a cycle. This\n+     * implementation will print the standard string value of the value.</p>\n+     * \n+     * @param buffer  the <code>StringBuffer</code> to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the <code>toString</code>,\n+     *  not <code>null</code>\n+     *  \n+     * @since 2.2\n+     */\n+    protected void appendCyclicObject(StringBuffer buffer, String fieldName, Object value) {\n+       ObjectUtils.appendIdentityToString(buffer, value);\n     }\n \n     /**\n      */\n     protected void appendClassName(StringBuffer buffer, Object object) {\n         if (useClassName && object != null) {\n+        \tregister(object);\n             if (useShortClassName) {\n                 buffer.append(getShortClassName(object.getClass()));\n             } else {\n      */\n     protected void appendIdentityHashCode(StringBuffer buffer, Object object) {\n         if (this.isUseIdentityHashCode() && object!=null) {\n+        \tregister(object);\n             buffer.append('@');\n             buffer.append(Integer.toHexString(System.identityHashCode(object)));\n         }\n--- a/src/test/org/apache/commons/lang/builder/ToStringBuilderTest.java\n+++ b/src/test/org/apache/commons/lang/builder/ToStringBuilderTest.java\n         assertEquals(baseStr + \"[{<null>,5,{3,6}}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n-        this.validateEmptyReflectionRegistry();\n+        this.validateEmptyToStringStyleRegistry();\n     }\n \n     public void testReflectionLongArray() {\n         assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n-        this.validateEmptyReflectionRegistry();\n+        this.validateEmptyToStringStyleRegistry();\n     }\n \n     public void testReflectionIntArray() {\n         assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n-        this.validateEmptyReflectionRegistry();\n+        this.validateEmptyToStringStyleRegistry();\n     }\n \n     public void testReflectionShortArray() {\n         assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n-        this.validateEmptyReflectionRegistry();\n+        this.validateEmptyToStringStyleRegistry();\n     }\n \n     public void testReflectionyteArray() {\n         assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n-        this.validateEmptyReflectionRegistry();\n+        this.validateEmptyToStringStyleRegistry();\n     }\n \n     public void testReflectionCharArray() {\n         assertEquals(baseStr + \"[{A,2,_,D}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n-        this.validateEmptyReflectionRegistry();\n+        this.validateEmptyToStringStyleRegistry();\n     }\n \n     public void testReflectionDoubleArray() {\n         assertEquals(baseStr + \"[{1.0,2.9876,-3.00001,4.3}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n-        this.validateEmptyReflectionRegistry();\n+        this.validateEmptyToStringStyleRegistry();\n     }\n \n     public void testReflectionFloatArray() {\n         assertEquals(baseStr + \"[{1.0,2.9876,-3.00001,4.3}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n-        this.validateEmptyReflectionRegistry();\n+        this.validateEmptyToStringStyleRegistry();\n     }\n \n     public void testReflectionBooleanArray() {\n         assertEquals(baseStr + \"[{true,false,false}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n-        this.validateEmptyReflectionRegistry();\n+        this.validateEmptyToStringStyleRegistry();\n     }\n     \n     // Reflection Array Array tests\n         assertEquals(baseStr + \"[{{1.0,2.29686},<null>,{NaN}}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n-        this.validateEmptyReflectionRegistry();\n+        this.validateEmptyToStringStyleRegistry();\n     }\n \n \n         assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n-        this.validateEmptyReflectionRegistry();\n+        this.validateEmptyToStringStyleRegistry();\n     }\n \n     public void testReflectionIntArrayArray() {\n         assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n-        this.validateEmptyReflectionRegistry();\n+        this.validateEmptyToStringStyleRegistry();\n     }\n \n     public void testReflectionhortArrayArray() {\n         assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n-        this.validateEmptyReflectionRegistry();\n+        this.validateEmptyToStringStyleRegistry();\n     }\n \n     public void testReflectionByteArrayArray() {\n         assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n-        this.validateEmptyReflectionRegistry();\n+        this.validateEmptyToStringStyleRegistry();\n     }\n \n     public void testReflectionCharArrayArray() {\n         assertEquals(baseStr + \"[{{A,B},<null>,{p}}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n-        this.validateEmptyReflectionRegistry();\n+        this.validateEmptyToStringStyleRegistry();\n     }\n \n     public void testReflectionDoubleArrayArray() {\n         assertEquals(baseStr + \"[{{1.0,2.29686},<null>,{NaN}}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n-        this.validateEmptyReflectionRegistry();\n+        this.validateEmptyToStringStyleRegistry();\n     }\n \n     public void testReflectionBooleanArrayArray() {\n         assertEquals(baseStr + \"[{{true,false},<null>,{false}}]\", ToStringBuilder.reflectionToString(array));\n         array = null;\n         assertReflectionArray(\"<null>\", array);\n-        this.validateEmptyReflectionRegistry();\n+        this.validateEmptyToStringStyleRegistry();\n     }\n     \n     // Reflection hierarchy tests\n         String baseStr = this.toBaseString(base);\n         assertEquals(baseStr + \"[elementData={<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>},size=0,modCount=0]\", ToStringBuilder.reflectionToString(base, null, true));\n         assertEquals(baseStr + \"[size=0]\", ToStringBuilder.reflectionToString(base, null, false));\n-        this.validateEmptyReflectionRegistry();\n+        this.validateEmptyToStringStyleRegistry();\n     }\n \n     public void testReflectionHierarchy() {\n         assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null, false, List.class));\n         assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null, false, ReflectionTestFixtureA.class));\n         assertEquals(baseStr + \"[b=b]\", ToStringBuilder.reflectionToString(baseB, null, false, ReflectionTestFixtureB.class));\n-        this.validateEmptyReflectionRegistry();\n+        this.validateEmptyToStringStyleRegistry();\n     }\n \n     static class ReflectionTestFixtureA {\n         assertEquals(\n             this.toBaseString(objects) + \"[{\" + this.toBaseString(objects) + \"}]\",\n             ToStringBuilder.reflectionToString(objects));\n-        this.validateEmptyReflectionRegistry();\n+        this.validateEmptyToStringStyleRegistry();\n     }\n \n     /**\n         assertEquals(\n             this.toBaseString(objectsLevel2) + \"[{{\" + this.toBaseString(objectsLevel2) + \"}}]\",\n             ToStringBuilder.reflectionToString(objectsLevel2));\n-        this.validateEmptyReflectionRegistry();\n+        this.validateEmptyToStringStyleRegistry();\n     }\n \n     public void testReflectionArrayArrayCycle() throws Exception {\n                 + basicToString\n                 + \"}}]\",\n             ToStringBuilder.reflectionToString(objects));\n-        this.validateEmptyReflectionRegistry();\n+        this.validateEmptyToStringStyleRegistry();\n     }\n \n     /**\n     public void testSimpleReflectionObjectCycle() throws Exception {\n         SimpleReflectionTestFixture simple = new SimpleReflectionTestFixture();\n         simple.o = simple;\n-        assertTrue(ReflectionToStringBuilder.getRegistry().isEmpty());\n+        assertTrue(ToStringStyle.getRegistry().isEmpty());\n         assertEquals(this.toBaseString(simple) + \"[o=\" + this.toBaseString(simple) + \"]\", simple.toString());\n-        this.validateEmptyReflectionRegistry();\n+        this.validateEmptyToStringStyleRegistry();\n     }\n \n     /**\n      */\n     public void testSelfInstanceVarReflectionObjectCycle() throws Exception {\n         SelfInstanceVarReflectionTestFixture test = new SelfInstanceVarReflectionTestFixture();\n-        assertTrue(ReflectionToStringBuilder.getRegistry().isEmpty());\n+        assertTrue(ToStringStyle.getRegistry().isEmpty());\n         assertEquals(this.toBaseString(test) + \"[typeIsSelf=\" + this.toBaseString(test) + \"]\", test.toString());\n-        this.validateEmptyReflectionRegistry();\n+        this.validateEmptyToStringStyleRegistry();\n     }\n     \n     /**\n      */\n     public void testSelfInstanceTwoVarsReflectionObjectCycle() throws Exception {\n         SelfInstanceTwoVarsReflectionTestFixture test = new SelfInstanceTwoVarsReflectionTestFixture();\n-        assertTrue(ReflectionToStringBuilder.getRegistry().isEmpty());\n+        assertTrue(ToStringStyle.getRegistry().isEmpty());\n         assertEquals(this.toBaseString(test) + \"[typeIsSelf=\" + this.toBaseString(test) + \",otherType=\" + test.getOtherType().toString() + \"]\", test.toString());\n-        this.validateEmptyReflectionRegistry();\n+        this.validateEmptyToStringStyleRegistry();\n     }\n     \n \n         assertEquals(\n             this.toBaseString(a) + \"[b=\" + this.toBaseString(b) + \"[a=\" + this.toBaseString(a) + \"]]\",\n             a.toString());\n-        this.validateEmptyReflectionRegistry();\n-    }\n-\n+        this.validateEmptyToStringStyleRegistry();\n+    }\n+    \n     /**\n      * Test a nasty combination of arrays and Objects pointing to each other.\n      * objects[0] -> SimpleReflectionTestFixture[ o -> objects ]\n                 + this.toBaseString(simple)\n                 + \"}]\",\n             ToStringBuilder.reflectionToString(simple));\n-        this.validateEmptyReflectionRegistry();\n+        this.validateEmptyToStringStyleRegistry();\n     }\n         \n-    void validateEmptyReflectionRegistry() {\n-        assertTrue(ReflectionToStringBuilder.getRegistry().isEmpty());        \n+    void validateEmptyToStringStyleRegistry() {\n+       if (!ToStringStyle.getRegistry().isEmpty()) {\n+           System.out.println(ToStringStyle.getRegistry());\n+       }\n+       \n+        assertTrue(ToStringStyle.getRegistry().isEmpty());        \n     }\n     //  End: Reflection cycle tests\n \n         assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n     }\n \n+    public void testObjectCycle() {\n+        ObjectCycle a = new ObjectCycle();\n+        ObjectCycle b = new ObjectCycle();\n+        a.obj = b;\n+        b.obj = a;\n+       \n+        String expected = toBaseString(a) + \"[\" + toBaseString(b) + \"[\" + toBaseString(a) + \"]]\";\n+        assertEquals(expected, a.toString());\n+        validateEmptyToStringStyleRegistry();\n+    }\n+    \n+    static class ObjectCycle {\n+        Object obj;\n+       \n+        public String toString() {\n+            return new ToStringBuilder(this).append(obj).toString();\n+        }\n+    }\n+    \n     public void testSimpleReflectionStatics() {\n         SimpleReflectionStaticFieldsFixture instance1 = new SimpleReflectionStaticFieldsFixture();\n         assertEquals(\n         assertEquals(\"<null>\", ReflectionToStringBuilder.toString(null));\n     }\n \n-    /* Unit test for #36061\n-    public void testObjectCycle() {\n-        ObjectCycle a = new ObjectCycle();\n-        ObjectCycle b = new ObjectCycle();\n-        a.obj = b;\n-        b.obj = a;\n-       \n-        String expected = toBaseString(a) + \"[\" + toBaseString(b) + \"[\" + toBaseString(a) + \"]]\";\n-        assertEquals(expected, a.toString());\n-        validateEmptyReflectionRegistry();\n-    }\n-    \n-    static class ObjectCycle {\n-        Object obj;\n-       \n-        public String toString() {\n-            return new ToStringBuilder(this).append(obj).toString();\n-        }\n-    }\n-    */\n-\n }", "timestamp": 1169881868, "metainfo": ""}