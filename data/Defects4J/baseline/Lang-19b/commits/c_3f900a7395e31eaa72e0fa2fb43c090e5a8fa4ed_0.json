{"sha": "3f900a7395e31eaa72e0fa2fb43c090e5a8fa4ed", "log": "[LANG-586] clear ThreadLocal recursion registry (compatibly with existing tests, first pass)  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java\n+++ b/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n import java.io.Serializable;\n import java.lang.reflect.Array;\n import java.util.Collection;\n-import java.util.HashSet;\n+import java.util.Collections;\n import java.util.Map;\n import java.util.Set;\n+import java.util.WeakHashMap;\n \n import org.apache.commons.lang3.ClassUtils;\n import org.apache.commons.lang3.ObjectUtils;\n  * <p>For example, the detail version of the array based methods will\n  * output the whole array, whereas the summary method will just output\n  * the array length.</p>\n- * \n+ *\n  * <p>If you want to format the output of certain objects, such as dates, you\n  * must create a subclass and override a method.\n  * <pre>\n     /**\n      * The default toString style. Using the Using the <code>Person</code>\n      * example from {@link ToStringBuilder}, the output would look like this:\n-     * \n+     *\n      * <pre>\n      * Person@182f0db[name=John Doe,age=33,smoker=false]\n      * </pre>\n      */\n     public static final ToStringStyle DEFAULT_STYLE = new DefaultToStringStyle();\n-    \n+\n     /**\n      * The multi line toString style. Using the Using the <code>Person</code>\n      * example from {@link ToStringBuilder}, the output would look like this:\n-     * \n+     *\n      * <pre>\n      * Person@182f0db[\n      *   name=John Doe\n      * </pre>\n      */\n     public static final ToStringStyle MULTI_LINE_STYLE = new MultiLineToStringStyle();\n-    \n+\n     /**\n      * The no field names toString style. Using the Using the\n      * <code>Person</code> example from {@link ToStringBuilder}, the output\n      * would look like this:\n-     * \n+     *\n      * <pre>\n      * Person@182f0db[John Doe,33,false]\n      * </pre>\n      */\n     public static final ToStringStyle NO_FIELD_NAMES_STYLE = new NoFieldNameToStringStyle();\n-    \n+\n     /**\n      * The short prefix toString style. Using the <code>Person</code> example\n      * from {@link ToStringBuilder}, the output would look like this:\n-     * \n+     *\n      * <pre>\n      * Person[name=John Doe,age=33,smoker=false]\n      * </pre>\n-     * \n+     *\n      * @since 2.1\n      */\n     public static final ToStringStyle SHORT_PREFIX_STYLE = new ShortPrefixToStringStyle();\n     /**\n      * The simple toString style. Using the Using the <code>Person</code>\n      * example from {@link ToStringBuilder}, the output would look like this:\n-     * \n+     *\n      * <pre>\n      * John Doe,33,false\n      * </pre>\n      */\n     public static final ToStringStyle SIMPLE_STYLE = new SimpleToStringStyle();\n-    \n+\n     /**\n      * <p>\n      * A registry of objects used by <code>reflectionToString</code> methods\n      * to detect cyclical object references and avoid infinite loops.\n      * </p>\n      */\n-    private static final ThreadLocal<Set<Object>> registry = new ThreadLocal<Set<Object>>() {\n-        @Override\n-        protected Set<Object> initialValue() {\n-            // The HashSet implementation is not synchronized,\n-            // which is just what we need here.\n-            return new HashSet<Object>();\n-        }\n-    };\n+    private static final ThreadLocal<WeakHashMap<Object, Object>> REGISTRY = new ThreadLocal<WeakHashMap<Object,Object>>();\n \n     /**\n      * <p>\n      * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n      * methods in the current thread.\n      * </p>\n-     * \n+     *\n      * @return Set the registry of objects being traversed\n      */\n     static Set<Object> getRegistry() {\n-        return registry.get();\n+        WeakHashMap<Object, Object> m = REGISTRY.get();\n+        return m == null ? Collections.<Object> emptySet() : m.keySet();\n     }\n \n     /**\n      * Returns <code>true</code> if the registry contains the given object.\n      * Used by the reflection methods to avoid infinite loops.\n      * </p>\n-     * \n+     *\n      * @param value\n      *                  The object to lookup in the registry.\n      * @return boolean <code>true</code> if the registry contains the given\n      * Registers the given object. Used by the reflection methods to avoid\n      * infinite loops.\n      * </p>\n-     * \n+     *\n      * @param value\n      *                  The object to register.\n      */\n     static void register(Object value) {\n         if (value != null) {\n-            getRegistry().add(value);\n+            WeakHashMap<Object, Object> m;\n+            synchronized (ToStringStyle.class) {\n+                m = REGISTRY.get();\n+                if (m == null) {\n+                    m = new WeakHashMap<Object, Object>();\n+                    REGISTRY.set(m);\n+                }\n+            }\n+            m.put(value, null);\n         }\n     }\n \n      * <p>\n      * Unregisters the given object.\n      * </p>\n-     * \n+     *\n      * <p>\n      * Used by the reflection methods to avoid infinite loops.\n      * </p>\n-     * \n+     *\n      * @param value\n      *                  The object to unregister.\n      */\n     static void unregister(Object value) {\n-        getRegistry().remove(value);\n+        if (value != null) {\n+            WeakHashMap<Object, Object> m;\n+            synchronized (ToStringStyle.class) {\n+                m = REGISTRY.get();\n+                if (m != null) {\n+                    m.remove(value);\n+                    if (m.isEmpty()) {\n+                        REGISTRY.remove();\n+                    }\n+                }\n+            }\n+        }\n     }\n \n     /**\n      * Whether to use the field names, the default is <code>true</code>.\n      */\n     private boolean useFieldNames = true;\n-    \n+\n     /**\n      * Whether to use the class name, the default is <code>true</code>.\n      */\n     private boolean useClassName = true;\n-    \n+\n     /**\n      * Whether to use short class names, the default is <code>false</code>.\n      */\n     private boolean useShortClassName = false;\n-    \n+\n     /**\n      * Whether to use the identity hash code, the default is <code>true</code>.\n      */\n      * The content start <code>'['</code>.\n      */\n     private String contentStart = \"[\";\n-    \n+\n     /**\n      * The content end <code>']'</code>.\n      */\n     private String contentEnd = \"]\";\n-    \n+\n     /**\n      * The field name value separator <code>'='</code>.\n      */\n     private String fieldNameValueSeparator = \"=\";\n-    \n+\n     /**\n      * Whether the field separator should be added before any other fields.\n      */\n     private boolean fieldSeparatorAtStart = false;\n-    \n+\n     /**\n      * Whether the field separator should be added after any other fields.\n      */\n     private boolean fieldSeparatorAtEnd = false;\n-    \n+\n     /**\n      * The field separator <code>','</code>.\n      */\n     private String fieldSeparator = \",\";\n-    \n+\n     /**\n      * The array start <code>'{'</code>.\n      */\n     private String arrayStart = \"{\";\n-    \n+\n     /**\n      * The array separator <code>','</code>.\n      */\n     private String arraySeparator = \",\";\n-    \n+\n     /**\n      * The detail for array content.\n      */\n     private boolean arrayContentDetail = true;\n-    \n+\n     /**\n      * The array end <code>'}'</code>.\n      */\n     private String arrayEnd = \"}\";\n-    \n+\n     /**\n      * The value to use when fullDetail is <code>null</code>,\n      * the default value is <code>true</code>.\n      */\n     private boolean defaultFullDetail = true;\n-    \n+\n     /**\n      * The <code>null</code> text <code>'&lt;null&gt;'</code>.\n      */\n     private String nullText = \"<null>\";\n-    \n+\n     /**\n      * The summary size text start <code>'<size'</code>.\n      */\n     private String sizeStartText = \"<size=\";\n-    \n+\n     /**\n      * The summary size text start <code>'&gt;'</code>.\n      */\n     private String sizeEndText = \">\";\n-    \n+\n     /**\n      * The summary object text start <code>'&lt;'</code>.\n      */\n     private String summaryObjectStartText = \"<\";\n-    \n+\n     /**\n      * The summary object text start <code>'&gt;'</code>.\n      */\n     /**\n      * <p>Append to the <code>toString</code> the superclass toString.</p>\n      * <p>NOTE: It assumes that the toString has been created from the same ToStringStyle. </p>\n-     * \n+     *\n      * <p>A <code>null</code> <code>superToString</code> is ignored.</p>\n-     * \n+     *\n      * @param buffer  the <code>StringBuffer</code> to populate\n      * @param superToString  the <code>super.toString()</code>\n      * @since 2.0\n     /**\n      * <p>Append to the <code>toString</code> another toString.</p>\n      * <p>NOTE: It assumes that the toString has been created from the same ToStringStyle. </p>\n-     * \n+     *\n      * <p>A <code>null</code> <code>toString</code> is ignored.</p>\n-     * \n+     *\n      * @param buffer  the <code>StringBuffer</code> to populate\n      * @param toString  the additional <code>toString</code>\n      * @since 2.0\n \n     /**\n      * <p>Append to the <code>toString</code> the start of data indicator.</p>\n-     * \n+     *\n      * @param buffer  the <code>StringBuffer</code> to populate\n      * @param object  the <code>Object</code> to build a <code>toString</code> for\n      */\n \n     /**\n      * <p>Append to the <code>toString</code> the end of data indicator.</p>\n-     * \n+     *\n      * @param buffer  the <code>StringBuffer</code> to populate\n      * @param object  the <code>Object</code> to build a\n      *  <code>toString</code> for.\n \n     /**\n      * <p>Remove the last field separator from the buffer.</p>\n-     * \n+     *\n      * @param buffer  the <code>StringBuffer</code> to populate\n      * @since 2.0\n      */\n             && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n            appendCyclicObject(buffer, fieldName, value);\n            return;\n-        }   \n+        }\n \n         register(value);\n \n                 } else {\n                     appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n                 }\n-    \n+\n             } else if (value instanceof Map<?, ?>) {\n                 if (detail) {\n                     appendDetail(buffer, fieldName, (Map<?, ?>) value);\n                 } else {\n                     appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n                 }\n-    \n+\n             } else if (value instanceof long[]) {\n                 if (detail) {\n                     appendDetail(buffer, fieldName, (long[]) value);\n                 } else {\n                     appendSummary(buffer, fieldName, (long[]) value);\n                 }\n-    \n+\n             } else if (value instanceof int[]) {\n                 if (detail) {\n                     appendDetail(buffer, fieldName, (int[]) value);\n                 } else {\n                     appendSummary(buffer, fieldName, (int[]) value);\n                 }\n-    \n+\n             } else if (value instanceof short[]) {\n                 if (detail) {\n                     appendDetail(buffer, fieldName, (short[]) value);\n                 } else {\n                     appendSummary(buffer, fieldName, (short[]) value);\n                 }\n-    \n+\n             } else if (value instanceof byte[]) {\n                 if (detail) {\n                     appendDetail(buffer, fieldName, (byte[]) value);\n                 } else {\n                     appendSummary(buffer, fieldName, (byte[]) value);\n                 }\n-    \n+\n             } else if (value instanceof char[]) {\n                 if (detail) {\n                     appendDetail(buffer, fieldName, (char[]) value);\n                 } else {\n                     appendSummary(buffer, fieldName, (char[]) value);\n                 }\n-    \n+\n             } else if (value instanceof double[]) {\n                 if (detail) {\n                     appendDetail(buffer, fieldName, (double[]) value);\n                 } else {\n                     appendSummary(buffer, fieldName, (double[]) value);\n                 }\n-    \n+\n             } else if (value instanceof float[]) {\n                 if (detail) {\n                     appendDetail(buffer, fieldName, (float[]) value);\n                 } else {\n                     appendSummary(buffer, fieldName, (float[]) value);\n                 }\n-    \n+\n             } else if (value instanceof boolean[]) {\n                 if (detail) {\n                     appendDetail(buffer, fieldName, (boolean[]) value);\n                 } else {\n                     appendSummary(buffer, fieldName, (boolean[]) value);\n                 }\n-    \n+\n             } else if (value.getClass().isArray()) {\n                 if (detail) {\n                     appendDetail(buffer, fieldName, (Object[]) value);\n                 } else {\n                     appendSummary(buffer, fieldName, (Object[]) value);\n                 }\n-    \n+\n             } else {\n                     if (detail) {\n                         appendDetail(buffer, fieldName, value);\n             unregister(value);\n         }\n     }\n-    \n+\n     /**\n      * <p>Append to the <code>toString</code> an <code>Object</code>\n      * value that has been detected to participate in a cycle. This\n      * implementation will print the standard string value of the value.</p>\n-     * \n+     *\n      * @param buffer  the <code>StringBuffer</code> to populate\n      * @param fieldName  the field name, typically not used as already appended\n      * @param value  the value to add to the <code>toString</code>,\n      *  not <code>null</code>\n-     *  \n+     *\n      * @since 2.2\n      */\n     protected void appendCyclicObject(StringBuffer buffer, String fieldName, Object value) {\n \n     /**\n      * <p>Append to the <code>toString</code> the class name.</p>\n-     * \n+     *\n      * @param buffer  the <code>StringBuffer</code> to populate\n      * @param object  the <code>Object</code> whose name to output\n      */\n \n     /**\n      * <p>Append the {@link System#identityHashCode(java.lang.Object)}.</p>\n-     * \n+     *\n      * @param buffer  the <code>StringBuffer</code> to populate\n      * @param object  the <code>Object</code> whose id to output\n      */\n \n     /**\n      * <p>Append to the <code>toString</code> the content start.</p>\n-     * \n+     *\n      * @param buffer  the <code>StringBuffer</code> to populate\n      */\n     protected void appendContentStart(StringBuffer buffer) {\n \n     /**\n      * <p>Append to the <code>toString</code> the content end.</p>\n-     * \n+     *\n      * @param buffer  the <code>StringBuffer</code> to populate\n      */\n     protected void appendContentEnd(StringBuffer buffer) {\n      * <p>Append to the <code>toString</code> an indicator for <code>null</code>.</p>\n      *\n      * <p>The default indicator is <code>'&lt;null&gt;'</code>.</p>\n-     * \n+     *\n      * @param buffer  the <code>StringBuffer</code> to populate\n      * @param fieldName  the field name, typically not used as already appended\n      */\n \n     /**\n      * <p>Append to the <code>toString</code> the field separator.</p>\n-     * \n+     *\n      * @param buffer  the <code>StringBuffer</code> to populate\n      */\n     protected void appendFieldSeparator(StringBuffer buffer) {\n \n     /**\n      * <p>Append to the <code>toString</code> the field start.</p>\n-     * \n+     *\n      * @param buffer  the <code>StringBuffer</code> to populate\n      * @param fieldName  the field name\n      */\n \n     /**\n      * <p>Append to the <code>toString<code> the field end.</p>\n-     * \n+     *\n      * @param buffer  the <code>StringBuffer</code> to populate\n      * @param fieldName  the field name, typically not used as already appended\n      */\n      * <code>null</code> indicating that it doesn't care about\n      * the detail level. In this case the default detail level is\n      * used.</p>\n-     * \n+     *\n      * @param fullDetailRequest  the detail level requested\n      * @return whether full detail is to be shown\n      */\n     //---------------------------------------------------------------------\n \n     /**\n-     * <p>Gets whether the field separator should be added at the start \n+     * <p>Gets whether the field separator should be added at the start\n      * of each buffer.</p>\n-     * \n+     *\n      * @return the fieldSeparatorAtStart flag\n      * @since 2.0\n      */\n     }\n \n     /**\n-     * <p>Sets whether the field separator should be added at the start \n+     * <p>Sets whether the field separator should be added at the start\n      * of each buffer.</p>\n-     * \n+     *\n      * @param fieldSeparatorAtStart  the fieldSeparatorAtStart flag\n      * @since 2.0\n      */\n     //---------------------------------------------------------------------\n \n     /**\n-     * <p>Gets whether the field separator should be added at the end \n+     * <p>Gets whether the field separator should be added at the end\n      * of each buffer.</p>\n-     * \n+     *\n      * @return fieldSeparatorAtEnd flag\n      * @since 2.0\n      */\n     }\n \n     /**\n-     * <p>Sets whether the field separator should be added at the end \n+     * <p>Sets whether the field separator should be added at the end\n      * of each buffer.</p>\n-     * \n+     *\n      * @param fieldSeparatorAtEnd  the fieldSeparatorAtEnd flag\n      * @since 2.0\n      */\n \n         /**\n          * Required for serialization support.\n-         * \n+         *\n          * @see java.io.Serializable\n          */\n         private static final long serialVersionUID = 1L;\n     }\n \n     //----------------------------------------------------------------------------\n-    \n+\n     /**\n      * <p><code>ToStringStyle</code> that prints out the short\n      * class name and no identity hashcode.</p>", "timestamp": 1265319982, "metainfo": ""}