{"sha": "33ebcc370048d0034bcc21a7175815e35d6ec6c2", "log": "Add new test case for ExtendedMessageFormat  ", "commit": "\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/text/ExtendedMessageFormatTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import java.text.DateFormat;\n+import java.text.FieldPosition;\n+import java.text.Format;\n+import java.text.MessageFormat;\n+import java.text.NumberFormat;\n+import java.text.ParsePosition;\n+import java.util.Calendar;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Test case for {@link ExtendedMessageFormat}.\n+ *\n+ * @since 2.4\n+ * @version $Id$\n+ */\n+public class ExtendedMessageFormatTest extends TestCase {\n+\n+    private Locale[] testLocales = new Locale[] {null, //default locale\n+                                                 Locale.US,\n+                                                 Locale.UK,\n+                                                 Locale.FRANCE,\n+                                                 Locale.GERMANY};\n+\n+    private Map registry = new HashMap();\n+\n+    /**\n+     * Create a new test case.\n+     *\n+     * @param name The name of the test\n+     */\n+    public ExtendedMessageFormatTest(String name) {\n+        super(name);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        registry.put(\"lower\", new LowerCaseFormatFactory());\n+        registry.put(\"upper\", new UpperCaseFormatFactory());\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    /**\n+     * Test extended formats.\n+     */\n+    public void testExtendedFormats() {\n+        String pattern = \"Lower: {0,lower} Upper: {1,upper}\";\n+        ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry);\n+        assertEquals(\"TOPATTERN\", pattern, emf.toPattern());\n+        assertEquals(\"Lower: foo Upper: BAR\", emf.format(new Object[] {\"foo\", \"bar\"}));\n+        assertEquals(\"Lower: foo Upper: BAR\", emf.format(new Object[] {\"Foo\", \"Bar\"}));\n+        assertEquals(\"Lower: foo Upper: BAR\", emf.format(new Object[] {\"FOO\", \"BAR\"}));\n+        assertEquals(\"Lower: foo Upper: BAR\", emf.format(new Object[] {\"FOO\", \"bar\"}));\n+        assertEquals(\"Lower: foo Upper: BAR\", emf.format(new Object[] {\"foo\", \"BAR\"}));\n+    }\n+\n+    /**\n+     * Test extended and built in formats.\n+     */\n+    public void testExtendedAndBuiltInFormats() {\n+        Calendar cal = Calendar.getInstance();\n+        cal.set(2007, Calendar.JANUARY, 23, 18, 33, 05);\n+        Object[] args = new Object[] {\"John Doe\", cal.getTime(), new Double(\"12345.67\")};\n+        String pattern = \"Name: {0,upper} DOB: {1,date,short} Salary: {2,number,currency}\";\n+\n+        for (int i = 0; i < testLocales.length; i++) {\n+            DateFormat df = null;\n+            NumberFormat nf = null;\n+            ExtendedMessageFormat emf = null;\n+            if (testLocales[i] == null) {\n+                df = DateFormat.getDateInstance(DateFormat.SHORT);\n+                nf = NumberFormat.getCurrencyInstance();\n+                emf = new ExtendedMessageFormat(pattern, registry);\n+            } else {\n+                df = DateFormat.getDateInstance(DateFormat.SHORT, testLocales[i]);\n+                nf = NumberFormat.getCurrencyInstance(testLocales[i]);\n+                emf = new ExtendedMessageFormat(pattern, testLocales[i], registry);\n+            }\n+            StringBuffer expected = new StringBuffer();\n+            expected.append(\"Name: \");\n+            expected.append(args[0].toString().toUpperCase());\n+            expected.append(\" DOB: \");\n+            expected.append(df.format(args[1]));\n+            expected.append(\" Salary: \");\n+            expected.append(nf.format(args[2]));\n+            assertEquals(pattern, emf.toPattern());\n+            assertEquals(\"\" + testLocales[i], expected.toString(), emf.format(args));\n+        }\n+    }\n+\n+    /**\n+     * Test extended formats with choice format.\n+     *\n+     * N.B. FAILING - currently sub-formats not supported\n+     */\n+    public void testExtendedWithChoiceFormat() {\n+        String pattern = \"Choice: {0,choice,1.0#{1,lower}|2.0#{1,upper}}\";\n+        ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry);\n+        assertEquals(pattern, emf.toPattern());\n+        try {\n+            assertEquals(\"one\", emf.format(new Object[] {new Integer(1), \"ONE\"}));\n+            assertEquals(\"TWO\", emf.format(new Object[] {new Integer(2), \"two\"}));\n+        } catch (IllegalArgumentException e) {\n+            // currently sub-formats not supported\n+        }\n+    }\n+\n+    /**\n+     * Test mixed extended and built-in formats with choice format.\n+     *\n+     * N.B. FAILING - currently sub-formats not supported\n+     */\n+    public void testExtendedAndBuiltInWithChoiceFormat() {\n+        String pattern = \"Choice: {0,choice,1.0#{0} {1,lower} {2,number}|2.0#{0} {1,upper} {2,number,currency}}\";\n+        Object[] lowArgs  = new Object[] {new Integer(1), \"Low\",  new Double(\"1234.56\")};\n+        Object[] highArgs = new Object[] {new Integer(2), \"High\", new Double(\"9876.54\")};\n+\n+        for (int i = 0; i < testLocales.length; i++) {\n+            NumberFormat nf = null;\n+            NumberFormat cf = null;\n+            ExtendedMessageFormat emf = null;\n+            if (testLocales[i] == null) {\n+                nf = NumberFormat.getNumberInstance();\n+                cf = NumberFormat.getCurrencyInstance();\n+                emf = new ExtendedMessageFormat(pattern, registry);\n+            } else {\n+                nf = NumberFormat.getNumberInstance(testLocales[i]);\n+                cf = NumberFormat.getCurrencyInstance(testLocales[i]);\n+                emf = new ExtendedMessageFormat(pattern, testLocales[i], registry);\n+            }\n+            assertEquals(pattern, emf.toPattern());\n+            try {\n+                String lowExpected = lowArgs[0] + \" low \"    + nf.format(lowArgs[2]);\n+                String highExpected = highArgs[0] + \" HIGH \"  + cf.format(highArgs[2]);\n+                assertEquals(lowExpected,  emf.format(lowArgs));\n+                assertEquals(highExpected, emf.format(highArgs));\n+            } catch (IllegalArgumentException e) {\n+                // currently sub-formats not supported\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Test the built in choice format.\n+     */\n+    public void testBuiltInChoiceFormat() {\n+        Object[] values = new Number[] {new Integer(1), new Double(\"2.2\"), new Double(\"1234.5\")};\n+        String choicePattern = null; \n+\n+        choicePattern = \"{0,choice,1#One|2#Two|3#Many {0,number}}\";\n+        for (int i = 0; i < values.length; i++) {\n+            checkBuiltInFormat(values[i] + \": \" + choicePattern, new Object[] {values[i]});\n+        }\n+\n+        choicePattern = \"{0,choice,1#''One''|2#\\\"Two\\\"|3#''{Many}'' {0,number}}\";\n+        for (int i = 0; i < values.length; i++) {\n+            checkBuiltInFormat(values[i] + \": \" + choicePattern, new Object[] {values[i]});\n+        }\n+    }\n+\n+    /**\n+     * Test the built in date/time formats\n+     */\n+    public void testBuiltInDateTimeFormat() {\n+        Calendar cal = Calendar.getInstance();\n+        cal.set(2007, Calendar.JANUARY, 23, 18, 33, 05);\n+        Object[] args = new Object[] {cal.getTime()};\n+\n+        checkBuiltInFormat(\"1: {0,date,short}\",    args);\n+        checkBuiltInFormat(\"2: {0,date,medium}\",   args);\n+        checkBuiltInFormat(\"3: {0,date,long}\",     args);\n+        checkBuiltInFormat(\"4: {0,date,full}\",     args);\n+        checkBuiltInFormat(\"5: {0,date,d MMM yy}\", args);\n+        checkBuiltInFormat(\"6: {0,time,short}\",    args);\n+        checkBuiltInFormat(\"7: {0,time,medium}\",   args);\n+        checkBuiltInFormat(\"8: {0,time,long}\",     args);\n+        checkBuiltInFormat(\"9: {0,time,full}\",     args);\n+        checkBuiltInFormat(\"10: {0,time,HH:mm}\",   args);\n+    }\n+\n+    /**\n+     * Test the built in number formats.\n+     */\n+    public void testBuiltInNumberFormat() {\n+        Object[] args = new Object[] {new Double(\"6543.21\")};\n+        checkBuiltInFormat(\"1: {0,number}\",            args);\n+        checkBuiltInFormat(\"2: {0,number,integer}\",    args);\n+        checkBuiltInFormat(\"3: {0,number,currency}\",   args);\n+        checkBuiltInFormat(\"4: {0,number,percent}\",    args);\n+        checkBuiltInFormat(\"5: {0,number,00000.000}\",  args);\n+    }\n+\n+    /**\n+     * Create ExtendedMessageFormats for the specified pattern and the set of locales\n+     * and check the formated output matches the expected result for the parameters.\n+     */\n+    private void checkBuiltInFormat(String pattern, Object[] args) {\n+        for (int i = 0; i < testLocales.length; i++) {\n+            checkBuiltInFormat(pattern, args, testLocales[i]);\n+        }\n+    }\n+\n+    /**\n+     * Create an ExtendedMessageFormat for the specified pattern and locale and check the\n+     * formated output matches the expected result for the parameters.\n+     */\n+    private void checkBuiltInFormat(String pattern, Object[] args, Locale locale) {\n+        StringBuffer buffer = new StringBuffer();\n+        buffer.append(\"Pattern=[\");\n+        buffer.append(pattern);\n+        buffer.append(\"], locale=[\");\n+        buffer.append(locale);\n+        buffer.append(\"]\");\n+        MessageFormat mf = null;\n+        if (locale == null) {\n+            mf = new MessageFormat(pattern);\n+        } else {\n+            mf = new MessageFormat(pattern, locale);\n+        }\n+        // System.out.println(buffer + \", result=[\" + mf.format(args) +\"]\");\n+        ExtendedMessageFormat emf = null;\n+        if (locale == null) {\n+            emf = new ExtendedMessageFormat(pattern);\n+        } else {\n+            emf = new ExtendedMessageFormat(pattern, locale);\n+        }\n+        assertEquals(\"format \"    + buffer.toString(), mf.format(args), emf.format(args));\n+        assertEquals(\"toPattern \" + buffer.toString(), mf.toPattern(),  emf.toPattern());\n+    }\n+\n+    // ------------------------ Test Formats ------------------------\n+\n+    /**\n+     * {@link Format} implementation which converts to upper case.\n+     */\n+    private static class LowerCaseFormat extends Format {\n+        public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n+            return toAppendTo.append(((String)obj).toLowerCase());\n+        }\n+        public Object parseObject(String source, ParsePosition pos) {throw new UnsupportedOperationException();}\n+    }\n+\n+    /**\n+     * {@link Format} implementation which converts to lower case.\n+     */\n+    private static class UpperCaseFormat extends Format {\n+        public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n+            return toAppendTo.append(((String)obj).toUpperCase());\n+        }\n+        public Object parseObject(String source, ParsePosition pos) {throw new UnsupportedOperationException();}\n+    }\n+\n+\n+    // ------------------------ Test Format Factories ---------------\n+    /**\n+     * {@link FormatFactory} implementation for lower case format.\n+     */\n+    private static class LowerCaseFormatFactory implements FormatFactory {\n+        private static final Format LOWER_INSTANCE = new LowerCaseFormat();\n+        public Format getFormat(String name, String arguments, Locale locale) {\n+            return LOWER_INSTANCE;\n+        }\n+    }\n+    /**\n+     * {@link FormatFactory} implementation for upper case format.\n+     */\n+    private static class UpperCaseFormatFactory implements FormatFactory {\n+        private static final Format UPPER_INSTANCE = new UpperCaseFormat();\n+        public Format getFormat(String name, String arguments, Locale locale) {\n+            return UPPER_INSTANCE;\n+        }\n+    }\n+}", "timestamp": 1204130657, "metainfo": ""}