{"sha": "bacb62849589003f4743210b245b2ef7076647a4", "log": "LANG-369 - must use fixed object as lock target  ", "commit": "\n--- a/src/java/org/apache/commons/lang/exception/ExceptionUtils.java\n+++ b/src/java/org/apache/commons/lang/exception/ExceptionUtils.java\n import java.util.List;\n import java.util.StringTokenizer;\n \n+import net.jcip.annotations.GuardedBy;\n+import net.jcip.annotations.ThreadSafe;\n+\n import org.apache.commons.lang.ArrayUtils;\n import org.apache.commons.lang.ClassUtils;\n import org.apache.commons.lang.NullArgumentException;\n  * @since 1.0\n  * @version $Id$\n  */\n+@ThreadSafe\n public class ExceptionUtils {\n     \n     /**\n      */\n     static final String WRAPPED_MARKER = \" [wrapped] \";\n \n+    // Lock object for CAUSE_METHOD_NAMES\n+    private static final Object CAUSE_METHOD_NAMES_LOCK = new Object();\n+    \n     /**\n      * <p>The names of methods commonly used to access a wrapped exception.</p>\n      */\n+    @GuardedBy(\"CAUSE_METHOD_NAMES_LOCK\")\n     private static String[] CAUSE_METHOD_NAMES = {\n         \"getCause\",\n         \"getNextException\",\n         if (StringUtils.isNotEmpty(methodName) && !isCauseMethodName(methodName)) {            \n             List<String> list = getCauseMethodNameList();\n             if (list.add(methodName)) {\n-                synchronized(CAUSE_METHOD_NAMES) {\n+                synchronized(CAUSE_METHOD_NAMES_LOCK) {\n                     CAUSE_METHOD_NAMES = toArray(list);\n                 }\n             }\n         if (StringUtils.isNotEmpty(methodName)) {\n             List<String> list = getCauseMethodNameList();\n             if (list.remove(methodName)) {\n-                synchronized(CAUSE_METHOD_NAMES) {\n+                synchronized(CAUSE_METHOD_NAMES_LOCK) {\n                     CAUSE_METHOD_NAMES = toArray(list);\n                 }\n             }\n      * @return {@link #CAUSE_METHOD_NAMES} as a List.\n      */\n     private static ArrayList<String> getCauseMethodNameList() {\n-        synchronized(CAUSE_METHOD_NAMES) {\n+        synchronized(CAUSE_METHOD_NAMES_LOCK) {\n             return new ArrayList<String>(Arrays.asList(CAUSE_METHOD_NAMES));\n         }\n     }\n      * @since 2.1\n      */\n     public static boolean isCauseMethodName(String methodName) {\n-        synchronized(CAUSE_METHOD_NAMES) {\n+        synchronized(CAUSE_METHOD_NAMES_LOCK) {\n             return ArrayUtils.indexOf(CAUSE_METHOD_NAMES, methodName) >= 0;\n         }\n     }\n      * @since 1.0\n      */\n     public static Throwable getCause(Throwable throwable) {\n-        synchronized(CAUSE_METHOD_NAMES) {\n+        synchronized(CAUSE_METHOD_NAMES_LOCK) {\n             return getCause(throwable, CAUSE_METHOD_NAMES);\n         }\n     }\n         Throwable cause = getCauseUsingWellKnownTypes(throwable);\n         if (cause == null) {\n             if (methodNames == null) {\n-                synchronized(CAUSE_METHOD_NAMES) {\n+                synchronized(CAUSE_METHOD_NAMES_LOCK) {\n                     methodNames = CAUSE_METHOD_NAMES;\n                 }\n             }\n         }\n \n         Class<? extends Throwable> cls = throwable.getClass();\n-        synchronized(CAUSE_METHOD_NAMES) {\n+        synchronized(CAUSE_METHOD_NAMES_LOCK) {\n             for (int i = 0, isize = CAUSE_METHOD_NAMES.length; i < isize; i++) {\n                 try {\n                     Method method = cls.getMethod(CAUSE_METHOD_NAMES[i], (Class[]) null);", "timestamp": 1237323292, "metainfo": ""}