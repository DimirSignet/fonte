{"sha": "b0287b02a64cdd473038e1b792fae033b57158b8", "log": "Replacing some of the older code. When performing a mutation operation (even if it's on an immutable by returning a new instance), String should go in and String should come out. When performing a non-mutation operation, CharSequence should be passed in. LANG-687  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n     // IndexOf\n     //-----------------------------------------------------------------------\n     /**\n-     * <p>Finds the first index within a String, handling {@code null}.\n-     * This method uses {@link String#indexOf(int)}.</p>\n-     *\n-     * <p>A {@code null} or empty (\"\") String will return {@code INDEX_NOT_FOUND (-1)}.</p>\n+     * <p>Finds the first index within a CharSequence, handling {@code null}.\n+     * This method uses {@link String#indexOf(int, int)} if possible.</p>\n+     *\n+     * <p>A {@code null} or empty (\"\") CharSequence will return {@code INDEX_NOT_FOUND (-1)}.</p>\n      *\n      * <pre>\n      * StringUtils.indexOf(null, *)         = -1\n      * StringUtils.indexOf(\"aabaabaa\", 'b') = 2\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param seq  the CharSequence to check, may be null\n      * @param searchChar  the character to find\n      * @return the first index of the search character,\n      *  -1 if no match or {@code null} string input\n      * @since 2.0\n      */\n-    public static int indexOf(String str, int searchChar) {\n-        if (isEmpty(str)) {\n+    public static int indexOf(CharSequence seq, int searchChar) {\n+        if (isEmpty(seq)) {\n             return INDEX_NOT_FOUND;\n         }\n-        return str.indexOf(searchChar);\n-    }\n-\n-    /**\n-     * <p>Finds the first index within a String from a start position,\n+        return StringUtils.indexOfSequence(seq, searchChar, 0);\n+    }\n+\n+    /**\n+     * <p>Finds the first index within a CharSequence from a start position,\n      * handling {@code null}.\n-     * This method uses {@link String#indexOf(int, int)}.</p>\n-     *\n-     * <p>A {@code null} or empty (\"\") String will return {@code (INDEX_NOT_FOUND) -1}.\n+     * This method uses {@link String#indexOf(int, int)} if possible.</p>\n+     *\n+     * <p>A {@code null} or empty (\"\") CharSequence will return {@code (INDEX_NOT_FOUND) -1}.\n      * A negative start position is treated as zero.\n      * A start position greater than the string length returns {@code -1}.</p>\n      *\n      * StringUtils.indexOf(\"aabaabaa\", 'b', -1) = 2\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param seq  the CharSequence to check, may be null\n      * @param searchChar  the character to find\n      * @param startPos  the start position, negative treated as zero\n      * @return the first index of the search character,\n      *  -1 if no match or {@code null} string input\n      * @since 2.0\n      */\n-    public static int indexOf(String str, int searchChar, int startPos) {\n-        if (isEmpty(str)) {\n+    public static int indexOf(CharSequence seq, int searchChar, int startPos) {\n+        if (isEmpty(seq)) {\n             return INDEX_NOT_FOUND;\n         }\n-        return str.indexOf(searchChar, startPos);\n-    }\n-\n-    /**\n-     * <p>Finds the first index within a String, handling {@code null}.\n-     * This method uses {@link String#indexOf(String)}.</p>\n-     *\n-     * <p>A {@code null} String will return {@code -1}.</p>\n+        return StringUtils.indexOfSequence(seq, searchChar, startPos);\n+    }\n+\n+    /**\n+     * <p>Finds the first index within a CharSequence, handling {@code null}.\n+     * This method uses {@link String#indexOf(String, int)} if possible.</p>\n+     *\n+     * <p>A {@code null} CharSequence will return {@code -1}.</p>\n      *\n      * <pre>\n      * StringUtils.indexOf(null, *)          = -1\n      * StringUtils.indexOf(\"aabaabaa\", \"\")   = 0\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n-     * @param searchStr  the String to find, may be null\n-     * @return the first index of the search String,\n+     * @param seq  the CharSequence to check, may be null\n+     * @param searchSeq  the CharSequence to find, may be null\n+     * @return the first index of the search CharSequence,\n      *  -1 if no match or {@code null} string input\n      * @since 2.0\n      */\n-    public static int indexOf(String str, String searchStr) {\n-        if (str == null || searchStr == null) {\n+    public static int indexOf(CharSequence seq, CharSequence searchSeq) {\n+        if (seq == null || searchSeq == null) {\n             return INDEX_NOT_FOUND;\n         }\n-        return str.indexOf(searchStr);\n-    }\n-\n-    /**\n-     * <p>Finds the first index within a String, handling {@code null}.\n-     * This method uses {@link String#indexOf(String, int)}.</p>\n-     *\n-     * <p>A {@code null} String will return {@code -1}.\n+        return StringUtils.indexOfSequence(seq, searchSeq, 0);\n+    }\n+\n+    /**\n+     * <p>Finds the first index within a CharSequence, handling {@code null}.\n+     * This method uses {@link String#indexOf(String, int)} if possible.</p>\n+     *\n+     * <p>A {@code null} CharSequence will return {@code -1}.\n      * A negative start position is treated as zero.\n-     * An empty (\"\") search String always matches.\n+     * An empty (\"\") search CharSequence always matches.\n      * A start position greater than the string length only matches\n-     * an empty search String.</p>\n+     * an empty search CharSequence.</p>\n      *\n      * <pre>\n      * StringUtils.indexOf(null, *, *)          = -1\n      * StringUtils.indexOf(\"abc\", \"\", 9)        = 3\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n-     * @param searchStr  the String to find, may be null\n+     * @param seq  the CharSequence to check, may be null\n+     * @param searchSeq  the CharSequence to find, may be null\n      * @param startPos  the start position, negative treated as zero\n-     * @return the first index of the search String,\n+     * @return the first index of the search CharSequence,\n      *  -1 if no match or {@code null} string input\n      * @since 2.0\n      */\n-    public static int indexOf(String str, String searchStr, int startPos) {\n-        if (str == null || searchStr == null) {\n+    public static int indexOf(CharSequence seq, CharSequence searchSeq, int startPos) {\n+        if (seq == null || searchSeq == null) {\n             return INDEX_NOT_FOUND;\n         }\n-        return str.indexOf(searchStr, startPos);\n+        return StringUtils.indexOfSequence(seq, searchSeq, startPos);\n     }\n \n     /**\n     // LastIndexOf\n     //-----------------------------------------------------------------------\n     /**\n-     * <p>Finds the last index within a String, handling {@code null}.\n-     * This method uses {@link String#lastIndexOf(int)}.</p>\n-     *\n-     * <p>A {@code null} or empty (\"\") String will return {@code -1}.</p>\n+     * <p>Finds the last index within a CharSequence, handling {@code null}.\n+     * This method uses {@link String#lastIndexOf(int)} if possible.</p>\n+     *\n+     * <p>A {@code null} or empty (\"\") CharSequence will return {@code -1}.</p>\n      *\n      * <pre>\n      * StringUtils.lastIndexOf(null, *)         = -1\n      * StringUtils.lastIndexOf(\"aabaabaa\", 'b') = 5\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param seq  the CharSequence to check, may be null\n      * @param searchChar  the character to find\n      * @return the last index of the search character,\n      *  -1 if no match or {@code null} string input\n      * @since 2.0\n      */\n-    public static int lastIndexOf(String str, int searchChar) {\n-        if (isEmpty(str)) {\n+    public static int lastIndexOf(CharSequence seq, int searchChar) {\n+        if (isEmpty(seq)) {\n             return INDEX_NOT_FOUND;\n         }\n-        return str.lastIndexOf(searchChar);\n-    }\n-\n-    /**\n-     * <p>Finds the last index within a String from a start position,\n+        return StringUtils.lastIndexOfSequence(seq, searchChar, seq.length());\n+    }\n+\n+    /**\n+     * <p>Finds the last index within a CharSequence from a start position,\n      * handling {@code null}.\n-     * This method uses {@link String#lastIndexOf(int, int)}.</p>\n-     *\n-     * <p>A {@code null} or empty (\"\") String will return {@code -1}.\n+     * This method uses {@link String#lastIndexOf(int, int)} if possible.</p>\n+     *\n+     * <p>A {@code null} or empty (\"\") CharSequence will return {@code -1}.\n      * A negative start position returns {@code -1}.\n      * A start position greater than the string length searches the whole string.</p>\n      *\n      * StringUtils.lastIndexOf(\"aabaabaa\", 'a', 0)  = 0\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param seq  the CharSequence to check, may be null\n      * @param searchChar  the character to find\n      * @param startPos  the start position\n      * @return the last index of the search character,\n      *  -1 if no match or {@code null} string input\n      * @since 2.0\n      */\n-    public static int lastIndexOf(String str, int searchChar, int startPos) {\n-        if (isEmpty(str)) {\n+    public static int lastIndexOf(CharSequence seq, int searchChar, int startPos) {\n+        if (isEmpty(seq)) {\n             return INDEX_NOT_FOUND;\n         }\n-        return str.lastIndexOf(searchChar, startPos);\n-    }\n-\n-    /**\n-     * <p>Finds the last index within a String, handling {@code null}.\n-     * This method uses {@link String#lastIndexOf(String)}.</p>\n-     *\n-     * <p>A {@code null} String will return {@code -1}.</p>\n+        return StringUtils.lastIndexOfSequence(seq, searchChar, startPos);\n+    }\n+\n+    /**\n+     * <p>Finds the last index within a CharSequence, handling {@code null}.\n+     * This method uses {@link String#lastIndexOf(String)} if possible.</p>\n+     *\n+     * <p>A {@code null} CharSequence will return {@code -1}.</p>\n      *\n      * <pre>\n      * StringUtils.lastIndexOf(null, *)          = -1\n      * StringUtils.lastIndexOf(\"aabaabaa\", \"\")   = 8\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n-     * @param searchStr  the String to find, may be null\n+     * @param seq  the CharSequence to check, may be null\n+     * @param searchSeq  the CharSequence to find, may be null\n      * @return the last index of the search String,\n      *  -1 if no match or {@code null} string input\n      * @since 2.0\n      */\n-    public static int lastIndexOf(String str, String searchStr) {\n-        if (str == null || searchStr == null) {\n+    public static int lastIndexOf(CharSequence seq, CharSequence searchSeq) {\n+        if (seq == null || searchSeq == null) {\n             return INDEX_NOT_FOUND;\n         }\n-        return str.lastIndexOf(searchStr);\n+        return StringUtils.lastIndexOfSequence(seq, searchSeq, seq.length());\n     }\n \n     /**\n     }\n \n     /**\n-     * <p>Finds the first index within a String, handling {@code null}.\n-     * This method uses {@link String#lastIndexOf(String, int)}.</p>\n-     *\n-     * <p>A {@code null} String will return {@code -1}.\n+     * <p>Finds the first index within a CharSequence, handling {@code null}.\n+     * This method uses {@link String#lastIndexOf(String, int)} if possible.</p>\n+     *\n+     * <p>A {@code null} CharSequence will return {@code -1}.\n      * A negative start position returns {@code -1}.\n-     * An empty (\"\") search String always matches unless the start position is negative.\n+     * An empty (\"\") search CharSequence always matches unless the start position is negative.\n      * A start position greater than the string length searches the whole string.</p>\n      *\n      * <pre>\n      * StringUtils.lastIndexOf(\"aabaabaa\", \"b\", 0)  = -1\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n-     * @param searchStr  the String to find, may be null\n+     * @param seq  the CharSequence to check, may be null\n+     * @param searchSeq  the CharSequence to find, may be null\n      * @param startPos  the start position, negative treated as zero\n-     * @return the first index of the search String,\n+     * @return the first index of the search CharSequence,\n      *  -1 if no match or {@code null} string input\n      * @since 2.0\n      */\n-    public static int lastIndexOf(String str, String searchStr, int startPos) {\n-        if (str == null || searchStr == null) {\n+    public static int lastIndexOf(CharSequence seq, CharSequence searchSeq, int startPos) {\n+        if (seq == null || searchSeq == null) {\n             return INDEX_NOT_FOUND;\n         }\n-        return str.lastIndexOf(searchStr, startPos);\n+        return StringUtils.lastIndexOfSequence(seq, searchSeq, startPos);\n     }\n \n     /**\n     // Contains\n     //-----------------------------------------------------------------------\n     /**\n-     * <p>Checks if String contains a search character, handling {@code null}.\n-     * This method uses {@link String#indexOf(int)}.</p>\n-     *\n-     * <p>A {@code null} or empty (\"\") String will return {@code false}.</p>\n+     * <p>Checks if CharSequence contains a search character, handling {@code null}.\n+     * This method uses {@link String#indexOf(int)} if possible.</p>\n+     *\n+     * <p>A {@code null} or empty (\"\") CharSequence will return {@code false}.</p>\n      *\n      * <pre>\n      * StringUtils.contains(null, *)    = false\n      * StringUtils.contains(\"abc\", 'z') = false\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param seq  the CharSequence to check, may be null\n      * @param searchChar  the character to find\n-     * @return true if the String contains the search character,\n+     * @return true if the CharSequence contains the search character,\n      *  false if not or {@code null} string input\n      * @since 2.0\n      */\n-    public static boolean contains(String str, int searchChar) {\n-        if (isEmpty(str)) {\n+    public static boolean contains(CharSequence seq, int searchChar) {\n+        if (isEmpty(seq)) {\n             return false;\n         }\n-        return str.indexOf(searchChar) >= 0;\n-    }\n-\n-    /**\n-     * <p>Checks if String contains a search String, handling {@code null}.\n-     * This method uses {@link String#indexOf(String)}.</p>\n-     *\n-     * <p>A {@code null} String will return {@code false}.</p>\n+        return indexOfSequence(seq, searchChar, 0) >= 0;\n+    }\n+\n+    /**\n+     * <p>Checks if CharSequence contains a search CharSequence, handling {@code null}.\n+     * This method uses {@link String#indexOf(String)} if possible.</p>\n+     *\n+     * <p>A {@code null} CharSequence will return {@code false}.</p>\n      *\n      * <pre>\n      * StringUtils.contains(null, *)     = false\n      * StringUtils.contains(\"abc\", \"z\")  = false\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n-     * @param searchStr  the String to find, may be null\n-     * @return true if the String contains the search String,\n+     * @param seq  the CharSequence to check, may be null\n+     * @param searchSeq  the CharSequence to find, may be null\n+     * @return true if the CharSequence contains the search CharSequence,\n      *  false if not or {@code null} string input\n      * @since 2.0\n      */\n-    public static boolean contains(String str, String searchStr) {\n-        if (str == null || searchStr == null) {\n+    public static boolean contains(CharSequence seq, CharSequence searchSeq) {\n+        if (seq == null || searchSeq == null) {\n             return false;\n         }\n-        return str.indexOf(searchStr) >= 0;\n+        return indexOfSequence(seq, searchSeq, 0) >= 0;\n     }\n \n     /**\n     }\n \n     /**\n-     * Check whether the given String contains any whitespace characters.\n-     * @param str the String to check (may be {@code null})\n-     * @return {@code true} if the String is not empty and\n+     * Check whether the given CharSequence contains any whitespace characters.\n+     * @param seq the CharSequence to check (may be {@code null})\n+     * @return {@code true} if the CharSequence is not empty and\n      * contains at least 1 whitespace character\n      * @see java.lang.Character#isWhitespace\n      * @since 3.0\n      */\n     // From org.springframework.util.StringUtils, under Apache License 2.0\n-    public static boolean containsWhitespace(String str) {\n-        if (isEmpty(str)) {\n+    public static boolean containsWhitespace(CharSequence seq) {\n+        if (isEmpty(seq)) {\n             return false;\n         }\n-        int strLen = str.length();\n+        int strLen = seq.length();\n         for (int i = 0; i < strLen; i++) {\n-            if (Character.isWhitespace(str.charAt(i))) {\n+            if (Character.isWhitespace(seq.charAt(i))) {\n                 return true;\n             }\n         }\n      * @return the {@code true} if any of the chars are found,\n      * {@code false} if no match or null input\n      * @since 2.4\n-     */\n-    public static boolean containsAny(String cs, char... searchChars) {\n+     * @since 3.0 Changed signature from containsAny(String, char[]) to containsAny(CharSequence, char[])\n+     */\n+    public static boolean containsAny(CharSequence cs, char[] searchChars) {\n         if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n             return false;\n         }\n      *            the chars to search for, may be null\n      * @return the {@code true} if any of the chars are found, {@code false} if no match or null input\n      * @since 2.4\n-     */\n-    public static boolean containsAny(String cs, String searchChars) {\n+     * @since 3.0 Changed signature from containsAny(String, String) to containsAny(CharSequence, CharSequence)\n+     */\n+    public static boolean containsAny(CharSequence cs, CharSequence searchChars) {\n         if (searchChars == null) {\n             return false;\n         }\n-        return containsAny(cs, searchChars.toCharArray());\n+        return containsAny(cs, toCharArraySequence(searchChars));\n     }\n \n     // IndexOfAnyBut chars\n      * @param searchChars  the chars to search for, may be null\n      * @return the index of any of the chars, -1 if no match or null input\n      * @since 2.0\n-     * @since 3.0 Changed signature from indexOfAnyBut(String, char[]) to indexOfAnyBut(CharSequence, char...)\n-     */\n-    public static int indexOfAnyBut(CharSequence cs, char... searchChars) {\n+     * @since 3.0 Changed signature from indexOfAnyBut(String, char[]) to indexOfAnyBut(CharSequence, char[])\n+     */\n+    public static int indexOfAnyBut(CharSequence cs, char[] searchChars) {\n         if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n             return INDEX_NOT_FOUND;\n         }\n     }\n \n     /**\n-     * <p>Search a String to find the first index of any\n+     * <p>Search a CharSequence to find the first index of any\n      * character not in the given set of characters.</p>\n      *\n-     * <p>A {@code null} String will return {@code -1}.\n+     * <p>A {@code null} CharSequence will return {@code -1}.\n      * A {@code null} or empty search string will return {@code -1}.</p>\n      *\n      * <pre>\n      * StringUtils.indexOfAnyBut(\"aba\",\"ab\")         = -1\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n+     * @param seq  the CharSequence to check, may be null\n      * @param searchChars  the chars to search for, may be null\n      * @return the index of any of the chars, -1 if no match or null input\n      * @since 2.0\n      */\n-    public static int indexOfAnyBut(String str, String searchChars) {\n-        if (isEmpty(str) || isEmpty(searchChars)) {\n+    public static int indexOfAnyBut(CharSequence seq, CharSequence searchChars) {\n+        if (isEmpty(seq) || isEmpty(searchChars)) {\n             return INDEX_NOT_FOUND;\n         }\n-        int strLen = str.length();\n+        int strLen = seq.length();\n         for (int i = 0; i < strLen; i++) {\n-            char ch = str.charAt(i);\n-            boolean chFound = searchChars.indexOf(ch) >= 0;\n+            char ch = seq.charAt(i);\n+            boolean chFound = indexOfSequence(searchChars, ch, 0) >= 0;\n             if (i + 1 < strLen && Character.isHighSurrogate(ch)) {\n-                char ch2 = str.charAt(i + 1);\n-                if (chFound && searchChars.indexOf(ch2) < 0) {\n+                char ch2 = seq.charAt(i + 1);\n+                if (chFound && indexOfSequence(searchChars, ch2, 0) < 0) {\n                     return i;\n                 }\n             } else {\n     /**\n      * <p>Find the first index of any of a set of potential substrings.</p>\n      *\n-     * <p>A {@code null} String will return {@code -1}.\n+     * <p>A {@code null} CharSequence will return {@code -1}.\n      * A {@code null} or zero length search array will return {@code -1}.\n      * A {@code null} search array entry will be ignored, but a search\n      * array containing \"\" will return {@code 0} if {@code str} is not\n-     * null. This method uses {@link String#indexOf(String)}.</p>\n+     * null. This method uses {@link String#indexOf(String)} if possible.</p>\n      *\n      * <pre>\n      * StringUtils.indexOfAny(null, *)                     = -1\n      * StringUtils.indexOfAny(\"\", [\"a\"])                   = -1\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n-     * @param searchStrs  the Strings to search for, may be null\n+     * @param str  the CharSequence to check, may be null\n+     * @param searchStrs  the CharSequences to search for, may be null\n      * @return the first index of any of the searchStrs in str, -1 if no match\n      */\n-    public static int indexOfAny(String str, String... searchStrs) {\n+    public static int indexOfAny(CharSequence str, CharSequence[] searchStrs) {\n         if (str == null || searchStrs == null) {\n             return INDEX_NOT_FOUND;\n         }\n \n         int tmp = 0;\n         for (int i = 0; i < sz; i++) {\n-            String search = searchStrs[i];\n+            CharSequence search = searchStrs[i];\n             if (search == null) {\n                 continue;\n             }\n-            tmp = str.indexOf(search);\n+            tmp = indexOfSequence(str, search, 0);\n             if (tmp == INDEX_NOT_FOUND) {\n                 continue;\n             }\n     /**\n      * <p>Find the latest index of any of a set of potential substrings.</p>\n      *\n-     * <p>A {@code null} String will return {@code -1}.\n+     * <p>A {@code null} CharSequence will return {@code -1}.\n      * A {@code null} search array will return {@code -1}.\n      * A {@code null} or zero length search array entry will be ignored,\n      * but a search array containing \"\" will return the length of {@code str}\n-     * if {@code str} is not null. This method uses {@link String#indexOf(String)}</p>\n+     * if {@code str} is not null. This method uses {@link String#indexOf(String)} if possible</p>\n      *\n      * <pre>\n      * StringUtils.lastIndexOfAny(null, *)                   = -1\n      * StringUtils.lastIndexOfAny(\"zzabyycdxx\", [\"mn\",\"\"])   = 10\n      * </pre>\n      *\n-     * @param str  the String to check, may be null\n-     * @param searchStrs  the Strings to search for, may be null\n-     * @return the last index of any of the Strings, -1 if no match\n-     */\n-    public static int lastIndexOfAny(String str, String... searchStrs) {\n+     * @param str  the CharSequence to check, may be null\n+     * @param searchStrs  the CharSequences to search for, may be null\n+     * @return the last index of any of the CharSequences, -1 if no match\n+     */\n+    public static int lastIndexOfAny(CharSequence str, CharSequence[] searchStrs) {\n         if (str == null || searchStrs == null) {\n             return INDEX_NOT_FOUND;\n         }\n         int ret = INDEX_NOT_FOUND;\n         int tmp = 0;\n         for (int i = 0; i < sz; i++) {\n-            String search = searchStrs[i];\n+            CharSequence search = searchStrs[i];\n             if (search == null) {\n                 continue;\n             }\n-            tmp = str.lastIndexOf(search);\n+            tmp = lastIndexOfSequence(str, search, str.length());\n             if (tmp > ret) {\n                 ret = tmp;\n             }\n         return cs == null ? null : cs.subSequence(start, cs.length());\n     }\n \n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Used by the indexOf(CharSequence methods) as a green implementation of\n+     * indexOf.\n+     *\n+     * @param cs the {@code CharSequence} to be processed\n+     * @param searchChar the char to be searched for\n+     * @param start the start index\n+     * @return the index where the search char was found\n+     */\n+    static int indexOfSequence(CharSequence cs, int searchChar, int start) {\n+        if (cs instanceof String) {\n+            return ((String) cs).indexOf(searchChar, start);\n+        } else {\n+            int sz = cs.length();\n+            if ( start < 0 ) {\n+                start = 0;\n+            }\n+            for ( int i=start; i < sz; i++ ) {\n+                if ( cs.charAt(i) == searchChar) {\n+                    return i;\n+                }\n+            }\n+            return -1;\n+        }\n+    }\n+\n+    /**\n+     * Used by the indexOf(CharSequence methods) as a green implementation of indexOf.\n+     *\n+     * @param cs the {@code CharSequence} to be processed\n+     * @param searchChar the {@code CharSequence} to be searched for\n+     * @param start the start index\n+     * @return the index where the search sequence was found\n+     */\n+    static int indexOfSequence(CharSequence cs, CharSequence searchChar, int start) {\n+        if (cs instanceof String && searchChar instanceof String) {\n+            // TODO: Do we assume searchChar is usually relatively small;\n+            //       If so then calling toString() on it is better than reverting to\n+            //       the green implementation in the else block\n+            return ((String) cs).indexOf( (String) searchChar, start);\n+        } else {\n+            // TODO: Implement rather than convert to String\n+            return cs.toString().indexOf(searchChar.toString(), start);\n+        }\n+    }\n+\n+    /**\n+     * Used by the lastIndexOf(CharSequence methods) as a green implementation of lastIndexOf\n+     *\n+     * @param cs the {@code CharSequence} to be processed\n+     * @param searchChar the char to be searched for\n+     * @param start the start index\n+     * @return the index where the search char was found\n+     */\n+    static int lastIndexOfSequence(CharSequence cs, int searchChar, int start) {\n+        if (cs instanceof String) {\n+            return ((String) cs).lastIndexOf(searchChar, start);\n+        } else {\n+            int sz = cs.length();\n+            if ( start < 0 ) {\n+                return -1;\n+            }\n+            if ( start >= sz ) {\n+                start = sz - 1;\n+            }\n+            for ( int i=start; i >= 0; --i ) {\n+                if ( cs.charAt(i) == searchChar) {\n+                    return i;\n+                }\n+            }\n+            return -1;\n+        }\n+    }\n+\n+    /**\n+     * Used by the lastIndexOf(CharSequence methods) as a green implementation of lastIndexOf\n+     *\n+     * @param cs the {@code CharSequence} to be processed\n+     * @param searchChar the {@code CharSequence} to be searched for\n+     * @param start the start index\n+     * @return the index where the search sequence was found\n+     */\n+    static int lastIndexOfSequence(CharSequence cs, CharSequence searchChar, int start) {\n+        if (cs instanceof String && searchChar instanceof String) {\n+            // TODO: Do we assume searchChar is usually relatively small;\n+            //       If so then calling toString() on it is better than reverting to\n+            //       the green implementation in the else block\n+            return ((String) cs).lastIndexOf( (String) searchChar, start);\n+        } else {\n+            // TODO: Implement rather than convert to String\n+            return cs.toString().lastIndexOf(searchChar.toString(), start);\n+        }\n+    }\n+\n+    /**\n+     * Green implementation of toCharArray.\n+     *\n+     * @param cs the {@code CharSequence} to be processed\n+     * @return the resulting char array\n+     */\n+    //\n+    static char[] toCharArraySequence(CharSequence cs) {\n+        if (cs instanceof String) {\n+            return ((String) cs).toCharArray();\n+        } else {\n+            // TODO: Implement rather than convert to String\n+            return cs.toString().toCharArray();\n+        }\n+    }\n+\n }\n--- a/src/test/java/org/apache/commons/lang3/StringUtilsEqualsIndexOfTest.java\n+++ b/src/test/java/org/apache/commons/lang3/StringUtilsEqualsIndexOfTest.java\n         assertEquals(-1, StringUtils.indexOf(\"\", ' '));\n         assertEquals(0, StringUtils.indexOf(\"aabaabaa\", 'a'));\n         assertEquals(2, StringUtils.indexOf(\"aabaabaa\", 'b'));\n+\n+        assertEquals(2, StringUtils.indexOf(new StringBuilder(\"aabaabaa\"), 'b'));\n     }\n \n     public void testIndexOf_charInt() {\n         assertEquals(5, StringUtils.indexOf(\"aabaabaa\", 'b', 3));\n         assertEquals(-1, StringUtils.indexOf(\"aabaabaa\", 'b', 9));\n         assertEquals(2, StringUtils.indexOf(\"aabaabaa\", 'b', -1));\n+\n+        assertEquals(5, StringUtils.indexOf(new StringBuilder(\"aabaabaa\"), 'b', 3));\n     }\n \n     public void testIndexOf_String() {\n         assertEquals(2, StringUtils.indexOf(\"aabaabaa\", \"b\"));\n         assertEquals(1, StringUtils.indexOf(\"aabaabaa\", \"ab\"));\n         assertEquals(0, StringUtils.indexOf(\"aabaabaa\", \"\"));\n+\n+        assertEquals(2, StringUtils.indexOf(new StringBuilder(\"aabaabaa\"), \"b\"));\n     }\n \n     public void testIndexOf_StringInt() {\n         assertEquals(-1, StringUtils.indexOf(\"aabaabaa\", \"b\", 9));\n         assertEquals(2, StringUtils.indexOf(\"aabaabaa\", \"b\", -1));\n         assertEquals(2,StringUtils.indexOf(\"aabaabaa\", \"\", 2));\n+\n+        assertEquals(5, StringUtils.indexOf(new StringBuilder(\"aabaabaa\"), \"b\", 3));\n     }\n \n     public void testIndexOfAny_StringCharArray() {\n         assertEquals(-1, StringUtils.lastIndexOf(\"\", ' '));\n         assertEquals(7, StringUtils.lastIndexOf(\"aabaabaa\", 'a'));\n         assertEquals(5, StringUtils.lastIndexOf(\"aabaabaa\", 'b'));\n+\n+        assertEquals(5, StringUtils.lastIndexOf(new StringBuilder(\"aabaabaa\"), 'b'));\n     }\n \n     public void testLastIndexOf_charInt() {\n         assertEquals(5, StringUtils.lastIndexOf(\"aabaabaa\", 'b', 9));\n         assertEquals(-1, StringUtils.lastIndexOf(\"aabaabaa\", 'b', -1));\n         assertEquals(0, StringUtils.lastIndexOf(\"aabaabaa\", 'a', 0));\n+\n+        assertEquals(2, StringUtils.lastIndexOf(new StringBuilder(\"aabaabaa\"), 'b', 2));\n     }\n \n     public void testLastIndexOf_String() {\n         assertEquals(7, StringUtils.lastIndexOf(\"aabaabaa\", \"a\"));\n         assertEquals(5, StringUtils.lastIndexOf(\"aabaabaa\", \"b\"));\n         assertEquals(4, StringUtils.lastIndexOf(\"aabaabaa\", \"ab\"));\n+\n+        assertEquals(4, StringUtils.lastIndexOf(new StringBuilder(\"aabaabaa\"), \"ab\"));\n     }\n \n     public void testLastIndexOf_StringInt() {\n         assertEquals(-1, StringUtils.lastIndexOf(\"aabaabaa\", \"b\", -1));\n         assertEquals(-1, StringUtils.lastIndexOf(\"aabaabaa\", \"b\", 0));\n         assertEquals(0, StringUtils.lastIndexOf(\"aabaabaa\", \"a\", 0));\n+\n+        assertEquals(2, StringUtils.lastIndexOf(new StringBuilder(\"aabaabaa\"), \"b\", 3));\n     }\n \n     public void testLastIndexOfAny_StringStringArray() {", "timestamp": 1302066691, "metainfo": ""}