{"sha": "0e5ca5e18a268acc49919030e2d95f8d5f1954c0", "log": "Checkstyle  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/event/EventUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/event/EventUtils.java\n         try {\n             MethodUtils.invokeMethod(eventSource, \"add\" + listenerType.getSimpleName(), listener);\n         } catch (NoSuchMethodException e) {\n-            throw new IllegalArgumentException(\"Class \" + eventSource.getClass().getName() + \" does not have a public add\" + listenerType.getSimpleName() + \" method which takes a parameter of type \" + listenerType.getName() + \".\");\n+            throw new IllegalArgumentException(\"Class \" + eventSource.getClass().getName()\n+                    + \" does not have a public add\" + listenerType.getSimpleName()\n+                    + \" method which takes a parameter of type \" + listenerType.getName() + \".\");\n         } catch (IllegalAccessException e) {\n-            throw new IllegalArgumentException(\"Class \" + eventSource.getClass().getName() + \" does not have an accessible add\" + listenerType.getSimpleName () + \" method which takes a parameter of type \" + listenerType.getName() + \".\");\n+            throw new IllegalArgumentException(\"Class \" + eventSource.getClass().getName()\n+                    + \" does not have an accessible add\" + listenerType.getSimpleName ()\n+                    + \" method which takes a parameter of type \" + listenerType.getName() + \".\");\n         } catch (InvocationTargetException e) {\n             throw new RuntimeException(\"Unable to add listener.\", e.getCause());\n         }\n      * @param eventTypes   the event types (method names) from the listener interface (if none specified, all will be\n      *                     supported)\n      */\n-    public static <L> void bindEventsToMethod(Object target, String methodName, Object eventSource, Class<L> listenerType, String... eventTypes) {\n-        final L listener = listenerType.cast(Proxy.newProxyInstance(target.getClass().getClassLoader(), new Class[] { listenerType }, new EventBindingInvocationHandler(target, methodName, eventTypes)));\n+    public static <L> void bindEventsToMethod(Object target, String methodName, Object eventSource,\n+            Class<L> listenerType, String... eventTypes) {\n+        final L listener = listenerType.cast(Proxy.newProxyInstance(target.getClass().getClassLoader(),\n+                new Class[] { listenerType }, new EventBindingInvocationHandler(target, methodName, eventTypes)));\n         addEventListener(eventSource, listenerType, listener);\n     }\n \n         private final String methodName;\n         private final Set<String> eventTypes;\n \n+        /**\n+         * Creates a new instance of {@code EventBindingInvocationHandler}.\n+         *\n+         * @param target the target object for method invocations\n+         * @param methodName the name of the method to be invoked\n+         * @param eventTypes the names of the supported event types\n+         */\n         public EventBindingInvocationHandler(final Object target, final String methodName, String[] eventTypes) {\n             this.target = target;\n             this.methodName = methodName;\n             this.eventTypes = new HashSet<String>(Arrays.asList(eventTypes));\n         }\n \n+        /**\n+         * Handles a method invocation on the proxy object.\n+         *\n+         * @param proxy the proxy instance\n+         * @param method the method to be invoked\n+         * @param parameters the parameters for the method invocation\n+         * @return the result of the method call\n+         * @throws Throwable if an error occurs\n+         */\n         public Object invoke(final Object proxy, final Method method, final Object[] parameters) throws Throwable {\n             if ( eventTypes.isEmpty() || eventTypes.contains(method.getName())) {\n                 if (hasMatchingParametersMethod(method)) {\n             return null;\n         }\n \n+        /**\n+         * Checks whether a method for the passed in parameters can be found.\n+         *\n+         * @param method the method to be invoked\n+         * @return a flag whether the parameters could be matched\n+         */\n         private boolean hasMatchingParametersMethod(final Method method) {\n             return MethodUtils.getAccessibleMethod(target.getClass(), methodName, method.getParameterTypes()) != null;\n         }", "timestamp": 1300310352, "metainfo": ""}