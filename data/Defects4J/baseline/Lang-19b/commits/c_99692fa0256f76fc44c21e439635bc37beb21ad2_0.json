{"sha": "99692fa0256f76fc44c21e439635bc37beb21ad2", "log": "LANG-436 Remove caching from MethodUtils  ", "commit": "\n--- a/src/java/org/apache/commons/lang/reflect/MethodUtils.java\n+++ b/src/java/org/apache/commons/lang/reflect/MethodUtils.java\n public class MethodUtils {\n \n     /**\n-     * Stores a cache of MethodDescriptor -> Method in a WeakHashMap.\n-     * <p>\n-     * The keys into this map only ever exist as temporary variables within\n-     * methods of this class, and are never exposed to users of this class.\n-     * This means that the WeakHashMap is used only as a mechanism for \n-     * limiting the size of the cache, ie a way to tell the garbage collector\n-     * that the contents of the cache can be completely garbage-collected \n-     * whenever it needs the memory. Whether this is a good approach to\n-     * this problem is doubtful; something like the commons-collections\n-     * LRUMap may be more appropriate (though of course selecting an\n-     * appropriate size is an issue).\n-     * <p>\n-     * This static variable is safe even when this code is deployed via a\n-     * shared classloader because it is keyed via a MethodDescriptor object\n-     * which has a Class as one of its members and that member is used in\n-     * the MethodDescriptor.equals method. So two components that load the same\n-     * class via different classloaders will generate non-equal MethodDescriptor\n-     * objects and hence end up with different entries in the map.\n-     */\n-    private static final WeakHashMap/* <MethodDescriptor, Method> */cache = new WeakHashMap();\n-\n-    /**\n-     * Indicates whether methods should be cached for improved performance.\n-     * <p>\n-     * Note that when this class is deployed via a shared classloader in\n-     * a container, this will affect all webapps. However making this\n-     * configurable per webapp would mean having a map keyed by context classloader\n-     * which may introduce memory-leak problems.\n-     */\n-    private static boolean cacheMethods = true;\n-\n-    /**\n      * <p>MethodUtils instances should NOT be constructed in standard programming.\n      * Instead, the class should be used as\n      * <code>MethodUtils.getAccessibleMethod(method)</code>.</p>\n      */\n     public MethodUtils() {\n         super();\n-    }\n-\n-    /**\n-     * Set whether methods should be cached for greater performance or not,\n-     * default is <code>true</code>.\n-     *\n-     * @param cacheMethods <code>true</code> if methods should be\n-     * cached for greater performance, otherwise <code>false</code>\n-     */\n-    public static synchronized void setCacheMethods(boolean cacheMethods) {\n-        MethodUtils.cacheMethods = cacheMethods;\n-        if (!MethodUtils.cacheMethods) {\n-            clearCache();\n-        }\n-    }\n-\n-    /**\n-     * Clear the method cache.\n-     * @return the number of cached methods cleared\n-     */\n-    public static synchronized int clearCache() {\n-        int size = cache.size();\n-        cache.clear();\n-        return size;\n     }\n \n     /**\n     public static Method getAccessibleMethod(Class cls, String methodName,\n             Class[] parameterTypes) {\n         try {\n-            MethodDescriptor md = new MethodDescriptor(cls, methodName,\n-                    parameterTypes, true);\n-            // Check the cache first\n-            Method method = getCachedMethod(md);\n-            if (method != null) {\n-                return method;\n-            }\n-            method = getAccessibleMethod(cls.getMethod(methodName,\n+            return getAccessibleMethod(cls.getMethod(methodName,\n                     parameterTypes));\n-            cacheMethod(md, method);\n-            return method;\n         } catch (NoSuchMethodException e) {\n             return (null);\n         }\n      */\n     public static Method getMatchingAccessibleMethod(Class cls,\n             String methodName, Class[] parameterTypes) {\n-        MethodDescriptor md = new MethodDescriptor(cls, methodName,\n-                parameterTypes, false);\n-        // Check the cache first\n-        Method method = getCachedMethod(md);\n-        if (method != null) {\n-            return method;\n-        }\n-        // see if we can find the method directly\n-        // most of the time this works and it's much faster\n         try {\n-            method = cls.getMethod(methodName, parameterTypes);\n+            Method method = cls.getMethod(methodName, parameterTypes);\n             MemberUtils.setAccessibleWorkaround(method);\n-            cacheMethod(md, method);\n             return method;\n         } catch (NoSuchMethodException e) { /* SWALLOW */\n         }\n         }\n         if (bestMatch != null) {\n             MemberUtils.setAccessibleWorkaround(bestMatch);\n-            cacheMethod(md, bestMatch);\n         }\n         return bestMatch;\n     }\n-\n-    /**\n-     * Return the method from the cache, if present.\n-     *\n-     * @param md The method descriptor\n-     * @return The cached method\n-     */\n-    private static Method getCachedMethod(MethodDescriptor md) {\n-        if (cacheMethods) {\n-            return (Method) cache.get(md);\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Add a method to the cache.\n-     *\n-     * @param md The method descriptor\n-     * @param method The method to cache\n-     */\n-    private static void cacheMethod(MethodDescriptor md, Method method) {\n-        if (cacheMethods) {\n-            if (method != null) {\n-                cache.put(md, method);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Represents the key to looking up a Method by reflection.\n-     */\n-    private static class MethodDescriptor {\n-        private Class cls;\n-        private String methodName;\n-        private Class[] paramTypes;\n-        private boolean exact;\n-        private int hashCode;\n-\n-        /**\n-         * The sole constructor.\n-         *\n-         * @param cls  the class to reflect, must not be null\n-         * @param methodName  the method name to obtain\n-         * @param paramTypes the array of classes representing the paramater types\n-         * @param exact whether the match has to be exact.\n-         */\n-        public MethodDescriptor(Class cls, String methodName,\n-                Class[] paramTypes, boolean exact) {\n-            if (cls == null) {\n-                throw new IllegalArgumentException(\"Class cannot be null\");\n-            }\n-            if (methodName == null) {\n-                throw new IllegalArgumentException(\"Method Name cannot be null\");\n-            }\n-            if (paramTypes == null) {\n-                paramTypes = ArrayUtils.EMPTY_CLASS_ARRAY;\n-            }\n-            this.cls = cls;\n-            this.methodName = methodName;\n-            this.paramTypes = paramTypes;\n-            this.exact = exact;\n-            // is this adequate? :/\n-            this.hashCode = methodName.length();\n-        }\n-\n-        /**\n-         * Checks for equality.\n-         * @param obj object to be tested for equality\n-         * @return true, if the object describes the same Method.\n-         */\n-        public boolean equals(Object obj) {\n-            if (!(obj instanceof MethodDescriptor)) {\n-                return false;\n-            }\n-            MethodDescriptor md = (MethodDescriptor) obj;\n-\n-            return exact == md.exact && methodName.equals(md.methodName)\n-                    && cls.equals(md.cls)\n-                    && Arrays.equals(paramTypes, md.paramTypes);\n-        }\n-\n-        /**\n-         * Returns the string length of method name. I.e. if the\n-         * hashcodes are different, the objects are different. If the\n-         * hashcodes are the same, need to use the equals method to\n-         * determine equality.\n-         * @return the string length of method name.\n-         */\n-        public int hashCode() {\n-            return hashCode;\n-        }\n-    }\n }\n--- a/src/test/org/apache/commons/lang/reflect/MethodUtilsTest.java\n+++ b/src/test/org/apache/commons/lang/reflect/MethodUtilsTest.java\n                 .getParameterTypes()));\n     }\n \n-    public void testSetCacheMethods() throws Exception {\n-        MethodUtils.clearCache();\n-        MethodUtils.setCacheMethods(true);\n-        MethodUtils.invokeMethod(testBean, \"foo\", \"\");\n-        assertEquals(1, MethodUtils.clearCache());\n-        assertEquals(0, MethodUtils.clearCache());\n-        MethodUtils.setCacheMethods(false);\n-        MethodUtils.invokeMethod(testBean, \"foo\", \"\");\n-        assertEquals(0, MethodUtils.clearCache());\n-        MethodUtils.setCacheMethods(true);\n-    }\n-\n     private String toString(Class[] c) {\n         return Arrays.asList(c).toString();\n     }", "timestamp": 1210176381, "metainfo": ""}