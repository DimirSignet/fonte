{"sha": "861034ca9f3e50e169e049fbcff79d17931102e9", "log": "Fix brace positions  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/BooleanUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/BooleanUtils.java\n             case 1: {\n                 char ch0 = str.charAt(0);\n                 if ((ch0 == 'y' || ch0 == 'Y') ||\n-                    (ch0 == 't' || ch0 == 'T'))\n-                {\n+                    (ch0 == 't' || ch0 == 'T')) {\n                     return Boolean.TRUE;\n                 }\n                 if ((ch0 == 'n' || ch0 == 'N') ||\n-                    (ch0 == 'f' || ch0 == 'F'))\n-                {\n+                    (ch0 == 'f' || ch0 == 'F')) {\n                     return Boolean.FALSE;\n                 }\n                 break;\n                 char ch0 = str.charAt(0);\n                 char ch1 = str.charAt(1);\n                 if ((ch0 == 'o' || ch0 == 'O') && \n-                    (ch1 == 'n' || ch1 == 'N') ) \n-                {\n+                    (ch1 == 'n' || ch1 == 'N') ) {\n                     return Boolean.TRUE;\n                 }\n                 if ((ch0 == 'n' || ch0 == 'N') && \n-                    (ch1 == 'o' || ch1 == 'O') ) \n-                {\n+                    (ch1 == 'o' || ch1 == 'O') ) {\n                     return Boolean.FALSE;\n                 }\n                 break;\n                 char ch2 = str.charAt(2);\n                 if ((ch0 == 'y' || ch0 == 'Y') &&\n                     (ch1 == 'e' || ch1 == 'E') &&\n-                    (ch2 == 's' || ch2 == 'S') ) \n-                {\n+                    (ch2 == 's' || ch2 == 'S') ) {\n                     return Boolean.TRUE;\n                 }\n                 if ((ch0 == 'o' || ch0 == 'O') &&\n                     (ch1 == 'f' || ch1 == 'F') &&\n-                    (ch2 == 'f' || ch2 == 'F') ) \n-                {\n+                    (ch2 == 'f' || ch2 == 'F') ) {\n                     return Boolean.FALSE;\n                 }\n                 break;\n                 if ((ch0 == 't' || ch0 == 'T') &&\n                     (ch1 == 'r' || ch1 == 'R') &&\n                     (ch2 == 'u' || ch2 == 'U') &&\n-                    (ch3 == 'e' || ch3 == 'E') ) \n-                {\n+                    (ch3 == 'e' || ch3 == 'E') ) {\n                     return Boolean.TRUE;\n                 }\n                 break;\n                     (ch1 == 'a' || ch1 == 'A') &&\n                     (ch2 == 'l' || ch2 == 'L') &&\n                     (ch3 == 's' || ch3 == 'S') &&\n-                    (ch4 == 'e' || ch4 == 'E') ) \n-                {\n+                    (ch4 == 'e' || ch4 == 'E') ) {\n                     return Boolean.FALSE;\n                 }\n                 break;\n--- a/src/main/java/org/apache/commons/lang3/RandomStringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/RandomStringUtils.java\n                 ch = chars[random.nextInt(gap) + start];\n             }\n             if ((letters && Character.isLetter(ch))\n-                || (numbers && Character.isDigit(ch))\n-                || (!letters && !numbers)) \n-            {\n+                    || (numbers && Character.isDigit(ch))\n+                    || (!letters && !numbers)) {\n                 if(ch >= 56320 && ch <= 57343) {\n                     if(count == 0) {\n                         count++;\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n      * @return an array of parsed Strings, <code>null</code> if null String input\n      * @since 2.4\n      */\n-    private static String[] splitByWholeSeparatorWorker(String str, String separator, int max,\n-                                                        boolean preserveAllTokens)\n-    {\n+    private static String[] splitByWholeSeparatorWorker(\n+            String str, String separator, int max, boolean preserveAllTokens) {\n         if (str == null) {\n             return null;\n         }\n      *             and/or size 0)\n      * @since 2.4\n      */\n-    private static String replaceEach(String text, String[] searchList, String[] replacementList,\n-                                      boolean repeat, int timeToLive)\n-    {\n+    private static String replaceEach(\n+            String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) {\n \n         // mchyzer Performance note: This creates very few new objects (one major goal)\n         // let me know if there are performance requests, we can create a harness to measure\n \n         if (text == null || text.length() == 0 || searchList == null ||\n-            searchList.length == 0 || replacementList == null || replacementList.length == 0)\n-        {\n+                searchList.length == 0 || replacementList == null || replacementList.length == 0) {\n             return text;\n         }\n \n         // NOTE: logic duplicated below START\n         for (int i = 0; i < searchLength; i++) {\n             if (noMoreMatchesForReplIndex[i] || searchList[i] == null ||\n-                searchList[i].length() == 0 || replacementList[i] == null)\n-            {\n+                    searchList[i].length() == 0 || replacementList[i] == null) {\n                 continue;\n             }\n             tempIndex = text.indexOf(searchList[i]);\n             // NOTE: logic mostly duplicated above START\n             for (int i = 0; i < searchLength; i++) {\n                 if (noMoreMatchesForReplIndex[i] || searchList[i] == null ||\n-                    searchList[i].length() == 0 || replacementList[i] == null)\n-                {\n+                        searchList[i].length() == 0 || replacementList[i] == null) {\n                     continue;\n                 }\n                 tempIndex = text.indexOf(searchList[i], start);\n--- a/src/main/java/org/apache/commons/lang3/Validate.java\n+++ b/src/main/java/org/apache/commons/lang3/Validate.java\n      * @throws IllegalArgumentException if the character sequence does not match the pattern\n      * @see #matchesPattern(CharSequence, String, String, Object...)\n      */\n-    public static void matchesPattern(CharSequence input, String pattern)\n-    {\n-        if (Pattern.matches(pattern, input) == false)\n-        {\n+    public static void matchesPattern(CharSequence input, String pattern) {\n+        if (Pattern.matches(pattern, input) == false) {\n             throw new IllegalArgumentException(String.format(DEFAULT_MATCHES_PATTERN_EX, input, pattern));\n         }\n     }\n      * @throws IllegalArgumentException if the character sequence does not match the pattern\n      * @see #matchesPattern(CharSequence, String)\n      */\n-    public static void matchesPattern(CharSequence input, String pattern, String message, Object... values)\n-    {\n-        if (Pattern.matches(pattern, input) == false)\n-        {\n+    public static void matchesPattern(CharSequence input, String pattern, String message, Object... values) {\n+        if (Pattern.matches(pattern, input) == false) {\n             throw new IllegalArgumentException(String.format(message, values));\n         }\n     }\n      * @throws IllegalArgumentException if the value falls out of the boundaries\n      * @see #inclusiveBetween(Object, Object, Comparable, String, Object...)\n      */\n-    public static <T> void inclusiveBetween(T start, T end, Comparable<T> value)\n-    {\n-        if (value.compareTo(start) < 0 || value.compareTo(end) > 0)\n-        {\n+    public static <T> void inclusiveBetween(T start, T end, Comparable<T> value) {\n+        if (value.compareTo(start) < 0 || value.compareTo(end) > 0) {\n             throw new IllegalArgumentException(String.format(DEFAULT_INCLUSIVE_BETWEEN_EX_MESSAGE, value, start, end));\n         }\n     }\n      * @throws IllegalArgumentException if the value falls out of the boundaries\n      * @see #inclusiveBetween(Object, Object, Comparable)\n      */\n-    public static <T> void inclusiveBetween(T start, T end, Comparable<T> value, String message, Object... values)\n-    {\n-        if (value.compareTo(start) < 0 || value.compareTo(end) > 0)\n-        {\n+    public static <T> void inclusiveBetween(T start, T end, Comparable<T> value, String message, Object... values) {\n+        if (value.compareTo(start) < 0 || value.compareTo(end) > 0) {\n             throw new IllegalArgumentException(String.format(message, values));\n         }\n     }\n      * @throws IllegalArgumentException if the value falls out of the boundaries\n      * @see #exclusiveBetween(Object, Object, Comparable, String, Object...)\n      */\n-    public static <T> void exclusiveBetween(T start, T end, Comparable<T> value)\n-    {\n-        if (value.compareTo(start) <= 0 || value.compareTo(end) >= 0)\n-        {\n+    public static <T> void exclusiveBetween(T start, T end, Comparable<T> value) {\n+        if (value.compareTo(start) <= 0 || value.compareTo(end) >= 0) {\n             throw new IllegalArgumentException(String.format(DEFAULT_EXCLUSIVE_BETWEEN_EX_MESSAGE, value, start, end));\n         }\n     }\n      * @throws IllegalArgumentException if the value falls out of the boundaries\n      * @see #exclusiveBetween(Object, Object, Comparable)\n      */\n-    public static <T> void exclusiveBetween(T start, T end, Comparable<T> value, String message, Object... values)\n-    {\n-        if (value.compareTo(start) <= 0 || value.compareTo(end) >= 0)\n-        {\n+    public static <T> void exclusiveBetween(T start, T end, Comparable<T> value, String message, Object... values) {\n+        if (value.compareTo(start) <= 0 || value.compareTo(end) >= 0) {\n             throw new IllegalArgumentException(String.format(message, values));\n         }\n     }\n      * @throws IllegalArgumentException if argument is not of specified class\n      * @see #isInstanceOf(Class, Object, String, Object...)\n      */\n-    public static void isInstanceOf(Class<?> type, Object o)\n-    {\n-        if (type.isInstance(o) == false)\n-        {\n+    public static void isInstanceOf(Class<?> type, Object o) {\n+        if (type.isInstance(o) == false) {\n             throw new IllegalArgumentException(String.format(DEFAULT_IS_INSTANCE_OF_EX_MESSAGE, type.getName()));\n         }\n     }\n      * @throws IllegalArgumentException if argument is not of specified class\n      * @see #isInstanceOf(Class, Object)\n      */\n-    public static void isInstanceOf(Class<?> type, Object o, String message, Object... values)\n-    {\n-        if (type.isInstance(o) == false)\n-        {\n+    public static void isInstanceOf(Class<?> type, Object o, String message, Object... values) {\n+        if (type.isInstance(o) == false) {\n             throw new IllegalArgumentException(String.format(message, values));\n         }\n     }\n      * @throws IllegalArgumentException if argument can not be converted to the specified class\n      * @see #isAssignableFrom(Class, Class, String, Object...)\n      */\n-    public static void isAssignableFrom(Class<?> superType, Class<?> type)\n-    {\n-        if (superType.isAssignableFrom(type) == false)\n-        {\n+    public static void isAssignableFrom(Class<?> superType, Class<?> type) {\n+        if (superType.isAssignableFrom(type) == false) {\n             throw new IllegalArgumentException(String.format(DEFAULT_IS_ASSIGNABLE_EX_MESSAGE, superType.getName()));\n         }\n     }\n      * @throws IllegalArgumentException if argument can not be converted to the specified class\n      * @see #isAssignableFrom(Class, Class)\n      */\n-    public static void isAssignableFrom(Class<?> superType, Class<?> type, String message, Object... values)\n-    {\n-        if (superType.isAssignableFrom(type) == false)\n-        {\n+    public static void isAssignableFrom(Class<?> superType, Class<?> type, String message, Object... values) {\n+        if (superType.isAssignableFrom(type) == false) {\n             throw new IllegalArgumentException(String.format(message, values));\n         }\n     }\n--- a/src/main/java/org/apache/commons/lang3/builder/CompareToBuilder.java\n+++ b/src/main/java/org/apache/commons/lang3/builder/CompareToBuilder.java\n      *  with <code>lhs</code>\n      * @since 2.0\n      */\n-    public static int reflectionCompare(Object lhs, Object rhs, boolean compareTransients, \n-                                        Class<?> reflectUpToClass) \n-    {\n+    public static int reflectionCompare(\n+            Object lhs, Object rhs, boolean compareTransients, Class<?> reflectUpToClass) {\n         return reflectionCompare(lhs, rhs, compareTransients, reflectUpToClass, null);\n     }\n \n--- a/src/main/java/org/apache/commons/lang3/event/EventListenerSupport.java\n+++ b/src/main/java/org/apache/commons/lang3/event/EventListenerSupport.java\n  * @since 3.0\n  * @version $Id$\n  */\n-public class EventListenerSupport<L> implements Serializable\n-{\n+public class EventListenerSupport<L> implements Serializable {\n+\n     /** Serialization version */\n     private static final long serialVersionUID = 3593265990380473632L;\n \n      * @throws IllegalArgumentException if <code>listenerInterface</code> is\n      *         not an interface.\n      */\n-    public static <T> EventListenerSupport<T> create(Class<T> listenerInterface)\n-    {\n+    public static <T> EventListenerSupport<T> create(Class<T> listenerInterface) {\n         return new EventListenerSupport<T>(listenerInterface);\n     }\n \n      * @throws IllegalArgumentException if <code>listenerInterface</code> is\n      *         not an interface.\n      */\n-    public EventListenerSupport(Class<L> listenerInterface)\n-    {\n+    public EventListenerSupport(Class<L> listenerInterface) {\n         this(listenerInterface, Thread.currentThread().getContextClassLoader());\n     }\n \n      * @throws IllegalArgumentException if <code>listenerInterface</code> is\n      *         not an interface.\n      */\n-    public EventListenerSupport(Class<L> listenerInterface, ClassLoader classLoader)\n-    {\n+    public EventListenerSupport(Class<L> listenerInterface, ClassLoader classLoader) {\n         this();\n         Validate.notNull(listenerInterface, \"Listener interface cannot be null.\");\n         Validate.notNull(classLoader, \"ClassLoader cannot be null.\");\n      * @return a proxy object which can be used to call listener methods on all \n      * of the registered event listeners\n      */\n-    public L fire()\n-    {\n+    public L fire() {\n         return proxy;\n     }\n \n      * @throws NullPointerException if <code>listener</code> is \n      *         <code>null</code>.\n      */\n-    public void addListener(L listener)\n-    {\n+    public void addListener(L listener) {\n         Validate.notNull(listener, \"Listener object cannot be null.\");\n         listeners.add(listener);\n     }\n      *\n      * @return the number of registered listeners.\n      */\n-    int getListenerCount()\n-    {\n+    int getListenerCount() {\n         return listeners.size();\n     }\n \n      * @throws NullPointerException if <code>listener</code> is \n      *         <code>null</code>.\n      */\n-    public void removeListener(L listener)\n-    {\n+    public void removeListener(L listener) {\n         Validate.notNull(listener, \"Listener object cannot be null.\");\n         listeners.remove(listener);\n     }\n     /**\n      * An invocation handler used to dispatch the event(s) to all the listeners.\n      */\n-    protected class ProxyInvocationHandler implements InvocationHandler\n-    {\n+    protected class ProxyInvocationHandler implements InvocationHandler {\n         /** Serialization version */\n         private static final long serialVersionUID = 1L;\n \n          *        listeners.\n          * @param args event arguments to propagate to the listeners.\n          */\n-        public Object invoke(Object proxy, Method method, Object[] args) \n-            throws Throwable\n-        {\n-            for (L listener : listeners)\n-            {\n+        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+            for (L listener : listeners) {\n                 method.invoke(listener, args);\n             }\n             return null;\n--- a/src/main/java/org/apache/commons/lang3/event/EventUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/event/EventUtils.java\n  * @since 3.0\n  * @version $Id$\n  */\n-public class EventUtils\n-{\n+public class EventUtils {\n+\n     /**\n      * Adds an event listener to the specified source.  This looks for an \"add\" method corresponding to the event\n      * type (addActionListener, for example).\n      *\n      * @throws IllegalArgumentException if the object doesn't support the listener type\n      */\n-    public static <L> void addEventListener(Object eventSource, Class<L> listenerType, L listener)\n-    {\n-        try\n-        {\n+    public static <L> void addEventListener(Object eventSource, Class<L> listenerType, L listener) {\n+        try {\n             MethodUtils.invokeMethod(eventSource, \"add\" + listenerType.getSimpleName(), listener);\n-        }\n-        catch (NoSuchMethodException e)\n-        {\n+        } catch (NoSuchMethodException e) {\n             throw new IllegalArgumentException(\"Class \" + eventSource.getClass().getName() + \" does not have a public add\" + listenerType.getSimpleName() + \" method which takes a parameter of type \" + listenerType.getName() + \".\");\n-        }\n-        catch (IllegalAccessException e)\n-        {\n+        } catch (IllegalAccessException e) {\n             throw new IllegalArgumentException(\"Class \" + eventSource.getClass().getName() + \" does not have an accessible add\" + listenerType.getSimpleName () + \" method which takes a parameter of type \" + listenerType.getName() + \".\");\n-        }\n-        catch (InvocationTargetException e)\n-        {\n+        } catch (InvocationTargetException e) {\n             throw new RuntimeException(\"Unable to add listener.\", e.getCause());\n         }\n     }\n      * @param eventTypes   the event types (method names) from the listener interface (if none specified, all will be\n      *                     supported)\n      */\n-    public static <L> void bindEventsToMethod(Object target, String methodName, Object eventSource, Class<L> listenerType, String... eventTypes)\n-    {\n+    public static <L> void bindEventsToMethod(Object target, String methodName, Object eventSource, Class<L> listenerType, String... eventTypes) {\n         final L listener = listenerType.cast(Proxy.newProxyInstance(target.getClass().getClassLoader(), new Class[] { listenerType }, new EventBindingInvocationHandler(target, methodName, eventTypes)));\n         addEventListener(eventSource, listenerType, listener);\n     }\n \n-    private static class EventBindingInvocationHandler implements InvocationHandler\n-    {\n+    private static class EventBindingInvocationHandler implements InvocationHandler {\n         private final Object target;\n         private final String methodName;\n         private final Set<String> eventTypes;\n \n-        public EventBindingInvocationHandler(final Object target, final String methodName, String[] eventTypes)\n-        {\n+        public EventBindingInvocationHandler(final Object target, final String methodName, String[] eventTypes) {\n             this.target = target;\n             this.methodName = methodName;\n             this.eventTypes = new HashSet<String>(Arrays.asList(eventTypes));\n         }\n \n-        public Object invoke(final Object proxy, final Method method, final Object[] parameters) throws Throwable\n-        {\n-            if ( eventTypes.isEmpty() || eventTypes.contains(method.getName()))\n-            {\n-                if (hasMatchingParametersMethod(method))\n-                {\n+        public Object invoke(final Object proxy, final Method method, final Object[] parameters) throws Throwable {\n+            if ( eventTypes.isEmpty() || eventTypes.contains(method.getName())) {\n+                if (hasMatchingParametersMethod(method)) {\n                     return MethodUtils.invokeMethod(target, methodName, parameters);\n-                }\n-                else\n-                {\n+                } else {\n                     return MethodUtils.invokeMethod(target, methodName);\n                 }\n             }\n             return null;\n         }\n \n-        private boolean hasMatchingParametersMethod(final Method method)\n-        {\n+        private boolean hasMatchingParametersMethod(final Method method) {\n             return MethodUtils.getAccessibleMethod(target.getClass(), methodName, method.getParameterTypes()) != null;\n         }\n     }\n--- a/src/main/java/org/apache/commons/lang3/exception/DefaultExceptionContext.java\n+++ b/src/main/java/org/apache/commons/lang3/exception/DefaultExceptionContext.java\n         while (contextValueMap.containsKey(key)) {\n             Object information = contextValueMap.get(key);\n             if ((value == null && information == null)\n-                    || (value != null && value.equals(information))) \n-            {\n+                    || (value != null && value.equals(information))) {\n                 return this;\n             }\n             key = label + \"[\" + ++i +\"]\";\n                 value = this.contextValueMap.get(label);\n                 if (value == null) {\n                     buffer.append(\"null\");\n-                }\n-                else {\n+                } else {\n                     try {\n                         valueStr = value.toString();\n-                    }\n-                    catch (Exception e) {\n+                    } catch (Exception e) {\n                         valueStr = \"Exception thrown on toString(): \" + ExceptionUtils.getStackTrace(e);\n                     }\n                     buffer.append(valueStr);\n--- a/src/main/java/org/apache/commons/lang3/mutable/MutableObject.java\n+++ b/src/main/java/org/apache/commons/lang3/mutable/MutableObject.java\n         if (this.getClass() == obj.getClass()) {\n             MutableObject<?> that = (MutableObject<?>) obj;\n             return this.value.equals(that.value);\n-        }\n-        else {\n+        } else {\n             return false;\n         }\n     }\n--- a/src/main/java/org/apache/commons/lang3/text/StrBuilder.java\n+++ b/src/main/java/org/apache/commons/lang3/text/StrBuilder.java\n     public StrBuilder appendSeparator(char standard, char defaultIfEmpty) {\n         if (size() > 0) {\n             append(standard);\n-        }\n-        else {\n+        } else {\n             append(defaultIfEmpty);\n         }\n         return this;\n--- a/src/main/java/org/apache/commons/lang3/text/StrSubstitutor.java\n+++ b/src/main/java/org/apache/commons/lang3/text/StrSubstitutor.java\n      * @param valueProperties the properties with values, may be null\n      * @return the result of the replace operation\n      */\n-    public static String replace(Object source, Properties valueProperties)\n-    {\n+    public static String replace(Object source, Properties valueProperties) {\n         if (valueProperties == null) {\n             return source.toString();\n         }\n         Map<String,String> valueMap = new HashMap<String,String>();\n         Enumeration<?> propNames = valueProperties.propertyNames();\n-        while (propNames.hasMoreElements())\n-        {\n+        while (propNames.hasMoreElements()) {\n             String propName = (String)propNames.nextElement();\n             String propValue = valueProperties.getProperty(propName);\n             valueMap.put(propName, propValue);\n--- a/src/main/java/org/apache/commons/lang3/text/StrTokenizer.java\n+++ b/src/main/java/org/apache/commons/lang3/text/StrTokenizer.java\n      *  then the length of string\n      */\n     private int readWithQuotes(char[] chars, int start, int len, StrBuilder workArea, \n-                               List<String> tokens, int quoteStart, int quoteLen) \n-    {\n+                               List<String> tokens, int quoteStart, int quoteLen) {\n         // Loop until we've found the end of the quoted\n         // string or the end of the input\n         workArea.clear();\n--- a/src/main/java/org/apache/commons/lang3/time/DurationFormatUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/time/DurationFormatUtils.java\n                     days += start.getActualMaximum(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n                     \n                     // Not sure I grok why this is needed, but the brutal tests show it is\n-                    if(start instanceof GregorianCalendar) {\n-                        if( (start.get(Calendar.MONTH) == Calendar.FEBRUARY) &&\n-                            (start.get(Calendar.DAY_OF_MONTH) == 29 ) )\n-                        {\n-                            days += 1;\n-                        }\n+                    if (start instanceof GregorianCalendar &&\n+                            start.get(Calendar.MONTH) == Calendar.FEBRUARY &&\n+                            start.get(Calendar.DAY_OF_MONTH) == 29) {\n+                        days += 1;\n                     }\n                     \n                     start.add(Calendar.YEAR, 1);", "timestamp": 1299243258, "metainfo": ""}