{"sha": "8c89841c28be700a0aeca1e907128716ec2251f2", "log": "[lang-482] Added support for substitution in variable names.  ", "commit": "\n--- a/src/main/java/org/apache/commons/lang3/text/StrSubstitutor.java\n+++ b/src/main/java/org/apache/commons/lang3/text/StrSubstitutor.java\n  * <pre>\n  *   The variable $${${name}} must be used.\n  * </pre>\n+ * <p>\n+ * In some complex scenarios you might even want to perform substitution in the\n+ * names of variables, for instance\n+ * <pre>\n+ * ${jre-${java.specification.version}}\n+ * </pre>\n+ * <code>StrSubstitutor</code> supports this recursive substitution in variable\n+ * names, but it has to be enabled explicitly by setting the\n+ * {@link #setEnableSubstitutionInVariables(boolean) enableSubstitutionInVariables}\n+ * property to <b>true</b>.\n  *\n  * @author Apache Software Foundation\n  * @version $Id$\n      * Variable resolution is delegated to an implementor of VariableResolver.\n      */\n     private StrLookup<?> variableResolver;\n+    /**\n+     * The flag whether substitution in variable names is enabled.\n+     */\n+    private boolean enableSubstitutionInVariables;\n \n     //-----------------------------------------------------------------------\n     /**\n         int bufEnd = offset + length;\n         int pos = offset;\n         while (pos < bufEnd) {\n-            int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd);\n+            int startMatchLen = prefixMatcher.isMatch(chars, pos, offset,\n+                    bufEnd);\n             if (startMatchLen == 0) {\n                 pos++;\n             } else {\n                 if (pos > offset && chars[pos - 1] == escape) {\n                     // escaped\n                     buf.deleteCharAt(pos - 1);\n-                    chars = buf.buffer;  // in case buffer was altered\n+                    chars = buf.buffer; // in case buffer was altered\n                     lengthChange--;\n                     altered = true;\n                     bufEnd--;\n                     int startPos = pos;\n                     pos += startMatchLen;\n                     int endMatchLen = 0;\n+                    int nestedVarCount = 0;\n                     while (pos < bufEnd) {\n-                        endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd);\n+                        if (isEnableSubstitutionInVariables()\n+                                && (endMatchLen = prefixMatcher.isMatch(chars,\n+                                        pos, offset, bufEnd)) != 0) {\n+                            // found a nested variable start\n+                            nestedVarCount++;\n+                            pos += endMatchLen;\n+                            continue;\n+                        }\n+\n+                        endMatchLen = suffixMatcher.isMatch(chars, pos, offset,\n+                                bufEnd);\n                         if (endMatchLen == 0) {\n                             pos++;\n                         } else {\n                             // found variable end marker\n-                            String varName = new String(chars, startPos + startMatchLen,\n-                                                        pos - startPos - startMatchLen);\n-                            pos += endMatchLen;\n-                            int endPos = pos;\n-\n-                            // on the first call initialize priorVariables\n-                            if (priorVariables == null) {\n-                                priorVariables = new ArrayList<String>();\n-                                priorVariables.add(new String(chars, offset, length));\n+                            if (nestedVarCount == 0) {\n+                                String varName = new String(chars, startPos\n+                                        + startMatchLen, pos - startPos\n+                                        - startMatchLen);\n+                                if (isEnableSubstitutionInVariables()) {\n+                                    StrBuilder bufName = new StrBuilder(varName);\n+                                    substitute(bufName, 0, bufName.length());\n+                                    varName = bufName.toString();\n+                                }\n+                                pos += endMatchLen;\n+                                int endPos = pos;\n+\n+                                // on the first call initialize priorVariables\n+                                if (priorVariables == null) {\n+                                    priorVariables = new ArrayList<String>();\n+                                    priorVariables.add(new String(chars,\n+                                            offset, length));\n+                                }\n+\n+                                // handle cyclic substitution\n+                                checkCyclicSubstitution(varName, priorVariables);\n+                                priorVariables.add(varName);\n+\n+                                // resolve the variable\n+                                String varValue = resolveVariable(varName, buf,\n+                                        startPos, endPos);\n+                                if (varValue != null) {\n+                                    // recursive replace\n+                                    int varLen = varValue.length();\n+                                    buf.replace(startPos, endPos, varValue);\n+                                    altered = true;\n+                                    int change = substitute(buf, startPos,\n+                                            varLen, priorVariables);\n+                                    change = change\n+                                            + (varLen - (endPos - startPos));\n+                                    pos += change;\n+                                    bufEnd += change;\n+                                    lengthChange += change;\n+                                    chars = buf.buffer; // in case buffer was\n+                                                        // altered\n+                                }\n+\n+                                // remove variable from the cyclic stack\n+                                priorVariables\n+                                        .remove(priorVariables.size() - 1);\n+                                break;\n+                            } else {\n+                                nestedVarCount--;\n+                                pos += endMatchLen;\n                             }\n-\n-                            // handle cyclic substitution\n-                            checkCyclicSubstitution(varName, priorVariables);\n-                            priorVariables.add(varName);\n-\n-                            // resolve the variable\n-                            String varValue = resolveVariable(varName, buf, startPos, endPos);\n-                            if (varValue != null) {\n-                                // recursive replace\n-                                int varLen = varValue.length();\n-                                buf.replace(startPos, endPos, varValue);\n-                                altered = true;\n-                                int change = substitute(buf, startPos, varLen, priorVariables);\n-                                change = change + (varLen - (endPos - startPos));\n-                                pos += change;\n-                                bufEnd += change;\n-                                lengthChange += change;\n-                                chars = buf.buffer;  // in case buffer was altered\n-                            }\n-\n-                            // remove variable from the cyclic stack\n-                            priorVariables.remove(priorVariables.size() - 1);\n-                            break;\n                         }\n                     }\n                 }\n     /**\n      * Sets the variable prefix to use.\n      * <p>\n-     * The variable prefix is the characer or characters that identify the\n+     * The variable prefix is the character or characters that identify the\n      * start of a variable. This method allows a single character prefix to\n      * be easily set.\n      *\n     /**\n      * Sets the variable suffix to use.\n      * <p>\n-     * The variable suffix is the characer or characters that identify the\n+     * The variable suffix is the character or characters that identify the\n      * end of a variable. This method allows a string suffix to be easily set.\n      *\n      * @param suffix  the suffix for variables, not null\n         this.variableResolver = variableResolver;\n     }\n \n+    // Substitution support in variable names\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a flag whether substitution is done in variable names.\n+     *\n+     * @return the substitution in variable names flag\n+     * @since 3.0\n+     */\n+    public boolean isEnableSubstitutionInVariables() {\n+        return enableSubstitutionInVariables;\n+    }\n+\n+    /**\n+     * Sets a flag whether substitution is done in variable names. If set to\n+     * <b>true</b>, the names of variables can contain other variables which are\n+     * processed first before the original variable is evaluated, e.g.\n+     * <code>${jre-${java.version}}</code>. The default value is <b>false</b>.\n+     *\n+     * @param enableSubstitutionInVariables the new value of the flag\n+     * @since 3.0\n+     */\n+    public void setEnableSubstitutionInVariables(\n+            boolean enableSubstitutionInVariables) {\n+        this.enableSubstitutionInVariables = enableSubstitutionInVariables;\n+    }\n }\n--- a/src/test/java/org/apache/commons/lang3/text/StrSubstitutorTest.java\n+++ b/src/test/java/org/apache/commons/lang3/text/StrSubstitutorTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n \n /**\n  * Test class for StrSubstitutor.\n- * \n+ *\n  * @author Oliver Heger\n  * @version $Id$\n  */\n         assertEquals(\"${animal} jumps\", sub.replace(\"The ${animal} jumps over the ${target}.\", 4, 15));\n     }\n \n+    /**\n+     * Tests whether a variable can be replaced in a variable name.\n+     */\n+    public void testReplaceInVariable() {\n+        values.put(\"animal.1\", \"fox\");\n+        values.put(\"animal.2\", \"mouse\");\n+        values.put(\"species\", \"2\");\n+        StrSubstitutor sub = new StrSubstitutor(values);\n+        sub.setEnableSubstitutionInVariables(true);\n+        assertEquals(\n+                \"Wrong result (1)\",\n+                \"The mouse jumps over the lazy dog.\",\n+                sub.replace(\"The ${animal.${species}} jumps over the ${target}.\"));\n+        values.put(\"species\", \"1\");\n+        assertEquals(\n+                \"Wrong result (2)\",\n+                \"The fox jumps over the lazy dog.\",\n+                sub.replace(\"The ${animal.${species}} jumps over the ${target}.\"));\n+    }\n+\n+    /**\n+     * Tests whether substitution in variable names is disabled per default.\n+     */\n+    public void testReplaceInVariableDisabled() {\n+        values.put(\"animal.1\", \"fox\");\n+        values.put(\"animal.2\", \"mouse\");\n+        values.put(\"species\", \"2\");\n+        StrSubstitutor sub = new StrSubstitutor(values);\n+        assertEquals(\n+                \"Wrong result\",\n+                \"The ${animal.${species}} jumps over the lazy dog.\",\n+                sub.replace(\"The ${animal.${species}} jumps over the ${target}.\"));\n+    }\n+\n+    /**\n+     * Tests complex and recursive substitution in variable names.\n+     */\n+    public void testReplaceInVariableRecursive() {\n+        values.put(\"animal.2\", \"brown fox\");\n+        values.put(\"animal.1\", \"white mouse\");\n+        values.put(\"color\", \"white\");\n+        values.put(\"species.white\", \"1\");\n+        values.put(\"species.brown\", \"2\");\n+        StrSubstitutor sub = new StrSubstitutor(values);\n+        sub.setEnableSubstitutionInVariables(true);\n+        assertEquals(\n+                \"Wrong result\",\n+                \"The white mouse jumps over the lazy dog.\",\n+                sub.replace(\"The ${animal.${species.${color}}} jumps over the ${target}.\"));\n+    }\n+\n     //-----------------------------------------------------------------------\n     /**\n      * Tests protected.\n         assertEquals(true, sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher);\n         sub.setVariablePrefix('<');\n         assertEquals(true, sub.getVariablePrefixMatcher() instanceof StrMatcher.CharMatcher);\n-        \n+\n         sub.setVariablePrefix(\"<<\");\n         assertEquals(true, sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher);\n         try {\n             // expected\n         }\n         assertEquals(true, sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher);\n-        \n+\n         StrMatcher matcher = StrMatcher.commaMatcher();\n         sub.setVariablePrefixMatcher(matcher);\n         assertSame(matcher, sub.getVariablePrefixMatcher());\n         assertEquals(true, sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher);\n         sub.setVariableSuffix('<');\n         assertEquals(true, sub.getVariableSuffixMatcher() instanceof StrMatcher.CharMatcher);\n-        \n+\n         sub.setVariableSuffix(\"<<\");\n         assertEquals(true, sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher);\n         try {\n             // expected\n         }\n         assertEquals(true, sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher);\n-        \n+\n         StrMatcher matcher = StrMatcher.commaMatcher();\n         sub.setVariableSuffixMatcher(matcher);\n         assertSame(matcher, sub.getVariableSuffixMatcher());\n             + \"working with ${os.name}, your home \"\n             + \"directory is ${user.home}.\"));\n     }\n-    \n+\n     /**\n      * Test the replace of a properties object\n      */\n     private void doTestReplace(String expectedResult, String replaceTemplate, boolean substring) {\n         String expectedShortResult = expectedResult.substring(1, expectedResult.length() - 1);\n         StrSubstitutor sub = new StrSubstitutor(values);\n-        \n+\n         // replace using String\n         assertEquals(expectedResult, sub.replace(replaceTemplate));\n         if (substring) {\n             assertEquals(expectedShortResult, sub.replace(replaceTemplate, 1, replaceTemplate.length() - 2));\n         }\n-        \n+\n         // replace using char[]\n         char[] chars = replaceTemplate.toCharArray();\n         assertEquals(expectedResult, sub.replace(chars));\n         if (substring) {\n             assertEquals(expectedShortResult, sub.replace(chars, 1, chars.length - 2));\n         }\n-        \n+\n         // replace using StringBuffer\n         StringBuffer buf = new StringBuffer(replaceTemplate);\n         assertEquals(expectedResult, sub.replace(buf));\n         if (substring) {\n             assertEquals(expectedShortResult, sub.replace(buf, 1, buf.length() - 2));\n         }\n-        \n+\n         // replace using StrBuilder\n         StrBuilder bld = new StrBuilder(replaceTemplate);\n         assertEquals(expectedResult, sub.replace(bld));\n         if (substring) {\n             assertEquals(expectedShortResult, sub.replace(bld, 1, bld.length() - 2));\n         }\n-        \n+\n         // replace using object\n         MutableObject<String> obj = new MutableObject<String>(replaceTemplate);  // toString returns template\n         assertEquals(expectedResult, sub.replace(obj));\n-        \n+\n         // replace in StringBuffer\n         buf = new StringBuffer(replaceTemplate);\n         assertEquals(true, sub.replaceIn(buf));\n             assertEquals(true, sub.replaceIn(buf, 1, buf.length() - 2));\n             assertEquals(expectedResult, buf.toString());  // expect full result as remainder is untouched\n         }\n-        \n+\n         // replace in StrBuilder\n         bld = new StrBuilder(replaceTemplate);\n         assertEquals(true, sub.replaceIn(bld));\n \n     private void doTestNoReplace(String replaceTemplate) {\n         StrSubstitutor sub = new StrSubstitutor(values);\n-        \n+\n         if (replaceTemplate == null) {\n             assertEquals(null, sub.replace((String) null));\n             assertEquals(null, sub.replace((String) null, 0, 100));", "timestamp": 1286565451, "metainfo": ""}