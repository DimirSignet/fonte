{"sha": "03e0815659eab169c4cbbf33a67d2a09aadb8dc1", "log": "Towards version 2.2:  - Set the component version to 2.2-dev.  - Add .text classes VariableFormat and VariableFormatTest.  - Enable build of .text package.  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/text/VariableFormat.java\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.text;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.StringUtils;\n+\n+/**\n+ * Candidate class to replace Interpolation and MappedMessageFormat?\n+ * \n+ * <p>\n+ * A class for variable interpolation (substitution).\n+ * </p>\n+ * <p>\n+ * This class can be given a text which can contain an arbitrary number of variables. It will then try to replace all\n+ * variables by their current values, which are obtained from a map. A variable per default is specified using the\n+ * typical notation &quot; <code>${&lt;varname&gt;}</code> &quot;. However by calling the\n+ * <code>setVariablePrefix()</code> and <code>setVariableSuffix()</code> methods it is possible to use a different\n+ * prefix or suffix.\n+ * </p>\n+ * <p>\n+ * Typical usage of this class follows the following pattern: First an instance is created and initialized with the map\n+ * that contains the values for the available variables. If a prefix and/or suffix for variables should be used other\n+ * than the default ones, the appropriate settings can be performed. After that the <code>replace()</code> method can\n+ * be called passing in the source text for interpolation. In the returned text all variable references (as long as\n+ * their values are known) will be resolved. The following example demonstrates this:\n+ * </p>\n+ * <p>\n+ * <code><pre>\n+ * Map valuesMap = HashMap();\n+ * valuesMap.put(&quot;animal&quot;, &quot;quick brown fox&quot;);\n+ * valuesMap.put(&quot;target&quot;, &quot;lazy dog&quot;);\n+ * String templateString = &quot;The ${animal} jumped over the ${target}.&quot;;\n+ * VariableFormat vf = new VariableVormat(valuesMap);\n+ * String resolvedString = cf.replace(templateString);\n+ * </pre></code> yielding: <code><pre>\n+ *    The quick brown fox jumped over the lazy dog.\n+ * </pre></code>\n+ * </p>\n+ * <p>\n+ * In addition to this usage pattern there are some static convenience methods that cover the most common use cases.\n+ * These methods can be used without the need of creating an instance. However if multiple replace operations are to be\n+ * performed, creating and reusing an instance of this class will be more efficient.\n+ * </p>\n+ * <p>\n+ * Variable replacement works in a recursive way, i.e. it is possible that a variable's value is a text which again\n+ * contains variable references. These new variables will be replaced, too. Cyclic replacements are detected and will\n+ * cause an exception to be thrown.\n+ * </p>\n+ * <p>\n+ * Sometimes the interpolation's result must contain a variable prefix. As an example take the following source text:\n+ * </p>\n+ * <p>\n+ * <code>The variable ${${name}} must be used.</code>\n+ * </p>\n+ * <p>\n+ * Here only the variable's name refered to in the text should be replaced resulting in the text (assuming that the\n+ * value of the <code>name</code> variable is <code>x</code>:\n+ * </p>\n+ * <p>\n+ * <code>The variable ${x} must be used.</code>\n+ * </p>\n+ * <p>\n+ * To achieve this effect there are two possibilities: Either set a different prefix and suffix for variables which do\n+ * not conflict with the result text you want to produce. The other possibility is to use the escape character that can\n+ * be set through the <code>setEscapeCharacter()</code> method. If this character is placed before a variable\n+ * reference, this reference is ignored and won't be replaced. It can also be placed before a variable suffix, then this\n+ * suffix will be ignored, too. Per default the escape character is set to the <code>$</code> character, so that in\n+ * the example above the text could have run:\n+ * </p>\n+ * <p>\n+ * <code>The variable $${${name$}} must be used.</code>\n+ * </p>\n+ * \n+ * \n+ * @author Oliver Heger\n+ * @version $Id$\n+ * @since 2.2\n+ */\n+public class VariableFormat {\n+    /** Constant for the default variable prefix. */\n+    static final String DEFAULT_PREFIX = \"${\";\n+\n+    /** Constant for the default variable suffix. */\n+    static final String DEFAULT_SUFFIX = \"}\";\n+\n+    /** Constant for the default escape character. */\n+    static final char DEFAULT_ESCAPE = '$';\n+\n+    /** Stores the map with the variables' values. */\n+    private Map valueMap;\n+\n+    /** Stores the variable prefix. */\n+    private String variablePrefix;\n+\n+    /** Stores the variable suffix. */\n+    private String variableSuffix;\n+\n+    /** Stores the escape character. */\n+    private char escapeCharacter;\n+\n+    /**\n+     * Creates a new instance of <code>VariableFormat</code> and initializes it.\n+     * \n+     * @param valueMap\n+     *            the map with the variables' values\n+     * @param prefix\n+     *            the prefix for variables\n+     * @param suffix\n+     *            the suffix for variables\n+     * @param escape\n+     *            the escape character\n+     * @throws IllegalArgumentException\n+     *             if the map is undefined\n+     */\n+    public VariableFormat(Map valueMap, String prefix, String suffix, char escape) {\n+        setValueMap(valueMap);\n+        setVariablePrefix(prefix);\n+        setVariableSuffix(suffix);\n+        setEscapeCharacter(escape);\n+    }\n+\n+    /**\n+     * Creates a new instance of <code>VariableFormat</code> and initializes it. Uses a default escaping character.\n+     * \n+     * @param valueMap\n+     *            the map with the variables' values\n+     * @param prefix\n+     *            the prefix for variables\n+     * @param suffix\n+     *            the suffix for variables\n+     * @throws IllegalArgumentException\n+     *             if the map is undefined\n+     */\n+    public VariableFormat(Map valueMap, String prefix, String suffix) {\n+        this(valueMap, prefix, suffix, DEFAULT_ESCAPE);\n+    }\n+\n+    /**\n+     * Creates a new instance of <code>VariableFormat</code> and initializes it. Uses defaults for variable prefix and\n+     * suffix and the escaping character.\n+     * \n+     * @param valueMap\n+     *            the map with the variables' values\n+     * @throws IllegalArgumentException\n+     *             if the map is undefined\n+     */\n+    public VariableFormat(Map valueMap) {\n+        this(valueMap, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n+    }\n+\n+    /**\n+     * Returns the escape character.\n+     * \n+     * @return the character used for escaping variable references\n+     */\n+    public char getEscapeCharacter() {\n+        return this.escapeCharacter;\n+    }\n+\n+    /**\n+     * Sets the escape character. If this character is placed before a variable reference in the source text, this\n+     * variable will be ignored.\n+     * \n+     * @param escapeCharacter\n+     *            the escape character (0 for disabling escaping)\n+     */\n+    public void setEscapeCharacter(char escapeCharacter) {\n+        this.escapeCharacter = escapeCharacter;\n+    }\n+\n+    /**\n+     * Returns the map with the variables' values.\n+     * \n+     * @return the values of the variables\n+     */\n+    public Map getValueMap() {\n+        return this.valueMap;\n+    }\n+\n+    /**\n+     * Sets the map with the variables' values.\n+     * \n+     * @param valueMap\n+     *            the values of the variables\n+     * @throws IllegalArgumentException\n+     *             if <code>valueMap</code> is <b>null</b>\n+     */\n+    public void setValueMap(Map valueMap) throws IllegalArgumentException {\n+        if (valueMap == null) {\n+            throw new IllegalArgumentException(\"Value map must not be null\");\n+        }\n+        this.valueMap = valueMap;\n+    }\n+\n+    /**\n+     * Returns the prefix for variables.\n+     * \n+     * @return the prefix for variables\n+     */\n+    public String getVariablePrefix() {\n+        return this.variablePrefix;\n+    }\n+\n+    /**\n+     * Sets the prefix for variables.\n+     * \n+     * @param variablePrefix\n+     *            the prefix for variables\n+     * @throws IllegalArgumentException\n+     *             if the prefix is <b>null</b>\n+     */\n+    public void setVariablePrefix(String variablePrefix) throws IllegalArgumentException {\n+        if (variablePrefix == null) {\n+            throw new IllegalArgumentException(\"Variable prefix must not be null!\");\n+        }\n+        this.variablePrefix = variablePrefix;\n+    }\n+\n+    /**\n+     * Returns the suffix for variables.\n+     * \n+     * @return the suffix for variables\n+     */\n+    public String getVariableSuffix() {\n+        return this.variableSuffix;\n+    }\n+\n+    /**\n+     * Sets the suffix for variables\n+     * \n+     * @param variableSuffix\n+     *            the suffix for variables\n+     * @throws IllegalArgumentException\n+     *             if the prefix is <b>null</b>\n+     */\n+    public void setVariableSuffix(String variableSuffix) throws IllegalArgumentException {\n+        if (variableSuffix == null) {\n+            throw new IllegalArgumentException(\"Variable suffix must not be null!\");\n+        }\n+        this.variableSuffix = variableSuffix;\n+    }\n+\n+    /**\n+     * Replaces the occurrences of all variables in the given source data by their current values. If the source\n+     * consists only of a single variable reference, this method directly returns the value of this variable (which can\n+     * be an arbitrary object). If the source contains multiple variable references or static text, the return value\n+     * will always be a String with the concatenation of all these elements.\n+     * \n+     * @param source\n+     *            the text to be interpolated; this can be an arbitrary object whose <code>toString()</code> method\n+     *            will be called\n+     * @return the result of the replace operation\n+     */\n+    public Object replaceObject(Object source) {\n+        return doReplace(source, null);\n+    }\n+\n+    /**\n+     * Replaces the occurrences of all variables in the given source data by their current values.\n+     * \n+     * @param source\n+     *            the text to be interpolated; this can be an arbitrary object whose <code>toString()</code> method\n+     *            will be called\n+     * @return the result of the replace operation\n+     */\n+    public String replace(Object source) {\n+        Object result = replaceObject(source);\n+        return (result == null) ? null : result.toString();\n+    }\n+\n+    /**\n+     * Replaces the occurrences of all variables in the given source data by their current values obtained from the\n+     * passed in map.\n+     * \n+     * @param valueMap\n+     *            the map with the values\n+     * @param source\n+     *            the source text\n+     * @return the result of the replace operation\n+     */\n+    public static String replace(Map valueMap, Object source) {\n+        return new VariableFormat(valueMap).replace(source);\n+    }\n+\n+    /**\n+     * Replaces the occurrences of all variables in the given source data by their current values obtained from the\n+     * passed in map. This method allows to specifiy a custom variable prefix and suffix\n+     * \n+     * @param valueMap\n+     *            the map with the values\n+     * @param prefix\n+     *            the prefix of variables\n+     * @param suffix\n+     *            the suffix of variables\n+     * @param source\n+     *            the source text\n+     * @return the result of the replace operation\n+     */\n+    public static String replace(Map valueMap, String prefix, String suffix, Object source) {\n+        return new VariableFormat(valueMap, prefix, suffix).replace(source);\n+    }\n+\n+    /**\n+     * Replaces all variables in the given source data with values obtained from system properties.\n+     * \n+     * @param source\n+     *            the source text\n+     * @return the result of the replace operation\n+     */\n+    public static String replaceSystemProperties(Object source) {\n+        return new VariableFormat(System.getProperties()).replace(source);\n+    }\n+\n+    /**\n+     * Checks if the variable reference found at the specified position is escaped and if this is the case, where the\n+     * escaped text starts.\n+     * \n+     * @param text\n+     *            the text to be processed\n+     * @param beginIndex\n+     *            the start index of the variable reference to check\n+     * @return the starting index of the escaped text or -1 if this reference is not escaped\n+     */\n+    protected int escaped(String text, int beginIndex) {\n+        if (beginIndex < 1 || text.charAt(beginIndex - 1) != getEscapeCharacter()) {\n+            return -1;\n+        }\n+        int idx = beginIndex - 2;\n+        while (idx >= 0 && text.charAt(idx) == getEscapeCharacter()) {\n+            idx--;\n+        }\n+        return idx + 1;\n+    }\n+\n+    /**\n+     * Unescapes an escaped variable reference. This method is called if <code>escaped()</code> has determined an\n+     * escaped variable reference. Its purpose is to remove any escaping characters and to add the resulting text into\n+     * the target buffer. This implementation will remove the first escape character. So if the default values are used,\n+     * a text portion of <code>$${myvar}</code> will become <code>${myvar}</code>,\n+     * <code>$$$${var with dollars}</code> will result in <code>$$${var with dollars}</code>. Text between the\n+     * first variable start token and the last unescaped variable end token can contain variable references and will be\n+     * recursively replaced. So constructs of the following form can be built:\n+     * <code>Variable $${${varName$}} is incorrect!</code> (note how the first &quot;}&quot; character is escaped, so\n+     * that the second &quot;}&quot; marks the end of this construct.\n+     * \n+     * @param buf\n+     *            the target buffer\n+     * @param text\n+     *            the text to be processed\n+     * @param beginIndex\n+     *            the begin index of the escaped variable reference\n+     * @param endIndex\n+     *            the end index of the escaped variable reference\n+     * @param priorVariables\n+     *            keeps track of the replaced variables\n+     */\n+    protected void unescape(StringBuffer buf, String text, int beginIndex, int endIndex, List priorVariables) {\n+        int startToken = text.indexOf(getVariablePrefix(), beginIndex);\n+        buf.append(text.substring(beginIndex + 1, startToken));\n+        buf.append(getVariablePrefix());\n+        String escapedContent = text.substring(startToken + getVariablePrefix().length(), endIndex);\n+        buf.append(doReplace(StringUtils.replace(escapedContent, String.valueOf(getEscapeCharacter())\n+            + getVariableSuffix(), getVariableSuffix()), priorVariables));\n+    }\n+\n+    /**\n+     * Searches for a variable end token in the given string from the specified start position.\n+     * \n+     * @param text\n+     *            the text to search\n+     * @param beginIndex\n+     *            the start index\n+     * @return the index of the end token or -1 if none was found\n+     */\n+    protected int findEndToken(String text, int beginIndex) {\n+        int pos = beginIndex - getVariableSuffix().length();\n+\n+        do {\n+            pos = text.indexOf(getVariableSuffix(), pos + getVariableSuffix().length());\n+        } while (pos > 0 && getEscapeCharacter() == text.charAt(pos - 1));\n+\n+        return pos;\n+    }\n+\n+    /**\n+     * Resolves the specified variable. This method is called whenever a variable reference is detected in the source\n+     * text. It is passed the variable's name and must return the corresponding value. This implementation accesses the\n+     * value map using the variable's name as key. Derived classes may overload this method to implement a different\n+     * strategy for resolving variables.\n+     * \n+     * @param name\n+     *            the name of the variable\n+     * @return the variable's value or <b>null</b> if the variable is unknown\n+     */\n+    protected Object resolveVariable(String name) {\n+        return getValueMap().get(name);\n+    }\n+\n+    /**\n+     * Recursive handler for multple levels of interpolation. This is the main interpolation method, which resolves the\n+     * values of all variable references contained in the passed in text.\n+     * \n+     * @param base\n+     *            string with the ${key} variables\n+     * @param priorVariables\n+     *            serves two purposes: to allow checking for loops, and creating a meaningful exception message should a\n+     *            loop occur. It's 0'th element will be set to the value of base from the first call. All subsequent\n+     *            interpolated variables are added afterward. When called for the first time, this argument should be\n+     *            <b>null </b>.\n+     * @param obj\n+     *            the text to be interpolated (as object)\n+     * @param priorVariables\n+     *            keeps track of the replaced variables\n+     * @return the result of the interpolation process\n+     */\n+    private Object doReplace(Object obj, List priorVariables) {\n+        if (obj == null) {\n+            return null;\n+        }\n+\n+        String base = obj.toString();\n+        if (base.indexOf(getVariablePrefix()) < 0) {\n+            return obj;\n+        }\n+\n+        // on the first call initialize priorVariables\n+        // and add base as the first element\n+        if (priorVariables == null) {\n+            priorVariables = new ArrayList();\n+            priorVariables.add(base);\n+        }\n+\n+        int begin = -1;\n+        int end = -1;\n+        int prec = 0 - getVariableSuffix().length();\n+        String variable = null;\n+        StringBuffer result = new StringBuffer();\n+        Object objResult = null;\n+        int objLen = 0;\n+\n+        while (((begin = base.indexOf(getVariablePrefix(), prec + getVariableSuffix().length())) > -1)\n+            && ((end = findEndToken(base, begin)) > -1)) {\n+            int escBegin = escaped(base, begin);\n+            if (escBegin >= 0) {\n+                result.append(base.substring(prec + getVariableSuffix().length(), escBegin));\n+                unescape(result, base, escBegin, end + getVariableSuffix().length(), priorVariables);\n+            }\n+\n+            else {\n+                result.append(base.substring(prec + getVariableSuffix().length(), begin));\n+                variable = base.substring(begin + getVariablePrefix().length(), end);\n+\n+                // if we've got a loop, create a useful exception message and\n+                // throw\n+                if (priorVariables.contains(variable)) {\n+                    String initialBase = priorVariables.remove(0).toString();\n+                    priorVariables.add(variable);\n+                    StringBuffer priorVariableSb = new StringBuffer();\n+\n+                    // create a nice trace of interpolated variables like so:\n+                    // var1->var2->var3\n+                    for (Iterator it = priorVariables.iterator(); it.hasNext();) {\n+                        priorVariableSb.append(it.next());\n+                        if (it.hasNext()) {\n+                            priorVariableSb.append(\"->\");\n+                        }\n+                    }\n+                    throw new IllegalStateException(\"Infinite loop in property interpolation of \"\n+                        + initialBase\n+                        + \": \"\n+                        + priorVariableSb.toString());\n+                }\n+                // otherwise, add this variable to the interpolation list.\n+                priorVariables.add(variable);\n+\n+                objResult = resolveVariable(variable);\n+                if (objResult != null) {\n+                    objResult = doReplace(objResult, priorVariables);\n+                    result.append(objResult);\n+                    objLen = objResult.toString().length();\n+\n+                    // pop the interpolated variable off the stack\n+                    // this maintains priorVariables correctness for\n+                    // properties with multiple interpolations, e.g.\n+                    // prop.name=${some.other.prop1}/blahblah/${some.other.prop2}\n+                    priorVariables.remove(priorVariables.size() - 1);\n+                } else {\n+                    // variable not defined - so put it back in the value\n+                    result.append(getVariablePrefix()).append(variable).append(getVariableSuffix());\n+                }\n+            }\n+\n+            prec = end;\n+        }\n+\n+        result.append(base.substring(prec + getVariableSuffix().length(), base.length()));\n+        return (objResult != null && objLen > 0 && objLen == result.length()) ? objResult : result.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/text/VariableFormatTest.java\n+/*\n+ * Copyright 2005 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.text;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Test class for VariableResolver.\n+ * \n+ * @author Oliver Heger\n+ * @version $Id$\n+ */\n+public class VariableFormatTest extends TestCase {\n+    static final String REPLACE_TEMPLATE = \"The ${animal} jumps over the ${target}.\";\n+\n+    private VariableFormat format;\n+\n+    private Map values;\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        Map map = new HashMap();\n+        map.put(\"animal\", \"quick brown fox\");\n+        map.put(\"target\", \"lazy dog\");\n+        setValues(map);\n+        setFormat(new VariableFormat(map));\n+    }\n+\n+    /**\n+     * Tests creating new <code>VariableFormat</code> objects.\n+     */\n+    public void testInitialize() {\n+        assertNotNull(format.getValueMap());\n+        assertEquals(VariableFormat.DEFAULT_PREFIX, format.getVariablePrefix());\n+        assertEquals(VariableFormat.DEFAULT_SUFFIX, format.getVariableSuffix());\n+        assertEquals(VariableFormat.DEFAULT_ESCAPE, format.getEscapeCharacter());\n+\n+        format = new VariableFormat(values, \"<<\", \">>\", '\\\\');\n+        assertEquals(\"<<\", format.getVariablePrefix());\n+        assertEquals(\">>\", format.getVariableSuffix());\n+        assertEquals('\\\\', format.getEscapeCharacter());\n+\n+        try {\n+            format = new VariableFormat(null);\n+            fail(\"Could create format object with null map!\");\n+        } catch (IllegalArgumentException iex) {\n+            // ok\n+        }\n+\n+        try {\n+            format = new VariableFormat(values, \"${\", null);\n+            fail(\"Could create format object with undefined suffix!\");\n+        } catch (IllegalArgumentException iex) {\n+            // ok\n+        }\n+\n+        try {\n+            format = new VariableFormat(values, null, \"]\");\n+            fail(\"Could create format object with undefined prefix!\");\n+        } catch (IllegalArgumentException iex) {\n+            // ok\n+        }\n+    }\n+\n+    /**\n+     * Tests typical replace operations.\n+     */\n+    public void testReplace() {\n+        assertEquals(\"The quick brown fox jumps over the lazy dog.\", format.replaceObject(REPLACE_TEMPLATE));\n+\n+        format.getValueMap().put(\"animal\", \"cow\");\n+        format.getValueMap().put(\"target\", \"moon\");\n+        assertEquals(\"The cow jumps over the moon.\", format.replace(REPLACE_TEMPLATE));\n+\n+        assertEquals(\"Variable ${var} is unknown!\", format.replace(\"Variable ${var} is unknown!\"));\n+    }\n+\n+    /**\n+     * Tests source texts with nothing to replace.\n+     */\n+    public void testReplaceNothing() {\n+        assertNull(format.replace(null));\n+        assertEquals(\"Nothing to replace.\", format.replace(\"Nothing to replace.\"));\n+        assertEquals(\"42\", format.replace(new Integer(42)));\n+    }\n+\n+    /**\n+     * Tests escaping variable references.\n+     */\n+    public void testEscape() {\n+        assertEquals(\"${animal}\", format.replace(\"$${animal}\"));\n+        format.getValueMap().put(\"var_name\", \"x\");\n+        assertEquals(\"Many $$$$${target} $s\", format.replace(\"Many $$$$$${target} $s\"));\n+        assertEquals(\"Variable ${x} must be used!\", format.replace(\"Variable $${${var_name$}} must be used!\"));\n+    }\n+\n+    /**\n+     * Tests recursive replacements.\n+     */\n+    public void testRecursiveReplacement() {\n+        Map valuesMap = new HashMap();\n+        valuesMap.put(\"animal\", \"${critter}\");\n+        valuesMap.put(\"target\", \"${pet}\");\n+        valuesMap.put(\"pet\", \"${petCharacteristic} dog\");\n+        valuesMap.put(\"petCharacteristic\", \"lazy\");\n+        valuesMap.put(\"critter\", \"${critterSpeed} ${critterColor} ${critterType}\");\n+        valuesMap.put(\"critterSpeed\", \"quick\");\n+        valuesMap.put(\"critterColor\", \"brown\");\n+        valuesMap.put(\"critterType\", \"fox\");\n+        format.setValueMap(valuesMap);\n+        assertEquals(\"The quick brown fox jumps over the lazy dog.\", format.replace(REPLACE_TEMPLATE));\n+    }\n+\n+    /**\n+     * Tests a cyclic replace operation. The cycle should be detected and cause an exception to be thrown.\n+     */\n+    public void testCyclicReplacement() {\n+        Map valuesMap = new HashMap();\n+        valuesMap.put(\"animal\", \"${critter}\");\n+        valuesMap.put(\"target\", \"${pet}\");\n+        valuesMap.put(\"pet\", \"${petCharacteristic} dog\");\n+        valuesMap.put(\"petCharacteristic\", \"lazy\");\n+        valuesMap.put(\"critter\", \"${critterSpeed} ${critterColor} ${critterType}\");\n+        valuesMap.put(\"critterSpeed\", \"quick\");\n+        valuesMap.put(\"critterColor\", \"brown\");\n+        valuesMap.put(\"critterType\", \"${animal}\");\n+        format.setValueMap(valuesMap);\n+        try {\n+            format.replace(REPLACE_TEMPLATE);\n+            fail(\"Cyclic replacement was not detected!\");\n+        } catch (IllegalStateException isx) {\n+            // ok\n+        }\n+    }\n+\n+    /**\n+     * Tests operating on objects.\n+     */\n+    public void testReplaceObject() {\n+        format.getValueMap().put(\"value\", new Integer(42));\n+        assertEquals(new Integer(42), format.replaceObject(\"${value}\"));\n+        assertEquals(\"The answer is 42.\", format.replaceObject(\"The answer is ${value}.\"));\n+    }\n+\n+    /**\n+     * Tests chaning variable prefix and suffix and the escaping character.\n+     */\n+    public void testNonDefaultTokens() {\n+        format = new VariableFormat(values, \"<<\", \">>\", '\\\\');\n+        assertEquals(\"The quick brown fox jumps over the lazy dog.\", format\n+                .replace(\"The <<animal>> jumps over the <<target>>.\"));\n+        assertEquals(\"The quick brown fox jumps over the <<target>>.\", format\n+                .replace(\"The <<animal>> jumps over the \\\\<<target>>.\"));\n+    }\n+\n+    /**\n+     * Tests invoking the static convenience methods.\n+     */\n+    public void testNonInstanceMethods() {\n+        assertEquals(\"The quick brown fox jumps over the lazy dog.\", VariableFormat.replace(values, REPLACE_TEMPLATE));\n+        values.put(\"animal\", \"cow\");\n+        values.put(\"target\", \"moon\");\n+        assertEquals(\"The cow jumps over the moon.\", VariableFormat.replace(values, \"&\", \";\",\n+                \"The &animal; jumps over the &target;.\"));\n+    }\n+\n+    /**\n+     * Tests interpolation with system properties.\n+     */\n+    public void testReplaceSystemProperties() {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append(\"Hi \").append(System.getProperty(\"user.name\"));\n+        buf.append(\", you are working with \");\n+        buf.append(System.getProperty(\"os.name\"));\n+        buf.append(\", your home directory is \");\n+        buf.append(System.getProperty(\"user.home\")).append('.');\n+        assertEquals(buf.toString(), VariableFormat.replaceSystemProperties(\"Hi ${user.name}, you are \"\n+            + \"working with ${os.name}, your home \"\n+            + \"directory is ${user.home}.\"));\n+    }\n+\n+    Map getValues() {\n+        return this.values;\n+    }\n+\n+    void setValues(Map values) {\n+        this.values = values;\n+    }\n+\n+    VariableFormat getFormat() {\n+        return this.format;\n+    }\n+\n+    void setFormat(VariableFormat format) {\n+        this.format = format;\n+    }\n+}", "timestamp": 1120580830, "metainfo": ""}