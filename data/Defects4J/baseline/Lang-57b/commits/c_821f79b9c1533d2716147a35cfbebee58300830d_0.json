{"sha": "821f79b9c1533d2716147a35cfbebee58300830d", "log": "Enable chaining of methods  ", "commit": "\n--- a/src/java/org/apache/commons/lang/text/StrTokenizer.java\n+++ b/src/java/org/apache/commons/lang/text/StrTokenizer.java\n      * Resets this tokenizer, forgetting all parsing and iteration already completed.\n      * <p>\n      * This method allows the same tokenizer to be reused for the same String.\n-     */\n-    public void reset() {\n+     *\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer reset() {\n         tokenPos = 0;\n         tokens = null;\n+        return this;\n     }\n \n     /**\n      * on multiple input lines.\n      *\n      * @param input  the new string to tokenize, null sets no text to parse\n-     */\n-    public void reset(String input) {\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer reset(String input) {\n         reset();\n         text = input;\n         if (input != null) {\n         } else {\n             chars = null;\n         }\n+        return this;\n     }\n \n     /**\n      * passing in to this method.\n      *\n      * @param input  the new character array to tokenize, not cloned, null sets no text to parse\n-     */\n-    public void reset(char[] input) {\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer reset(char[] input) {\n         reset();\n         text = null;\n         chars = input;\n+        return this;\n     }\n \n     // ListIterator\n      * The delimitier is used to separate one token from another.\n      *\n      * @param delim  the delimiter matcher to use\n-     */\n-    public void setDelimiterMatcher(StrMatcher delim) {\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setDelimiterMatcher(StrMatcher delim) {\n         if (delim == null) {\n             this.delim = StrMatcher.noneMatcher();\n         } else {\n             this.delim = delim;\n         }\n+        return this;\n     }\n \n     /**\n      * Sets the field delimiter character.\n      *\n      * @param delim  the delimiter character to use\n-     */\n-    public void setDelimiterChar(char delim) {\n-        setDelimiterMatcher(StrMatcher.charMatcher(delim));\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setDelimiterChar(char delim) {\n+        return setDelimiterMatcher(StrMatcher.charMatcher(delim));\n     }\n \n     /**\n      * Sets the field delimiter string.\n      *\n      * @param delim  the delimiter string to use\n-     */\n-    public void setDelimiterString(String delim) {\n-        setDelimiterMatcher(StrMatcher.stringMatcher(delim));\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setDelimiterString(String delim) {\n+        return setDelimiterMatcher(StrMatcher.stringMatcher(delim));\n     }\n \n     // Quote\n      * This enables delimiters to be entered as data.\n      *\n      * @param quote  the quote matcher to use, null ignored\n-     */\n-    public void setQuoteMatcher(StrMatcher quote) {\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setQuoteMatcher(StrMatcher quote) {\n         if (quote != null) {\n             this.quote = quote;\n         }\n+        return this;\n     }\n \n     /**\n      * This enables delimiters to be entered as data.\n      *\n      * @param quote  the quote character to use\n-     */\n-    public void setQuoteChar(char quote) {\n-        setQuoteMatcher(StrMatcher.charMatcher(quote));\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setQuoteChar(char quote) {\n+        return setQuoteMatcher(StrMatcher.charMatcher(quote));\n     }\n \n     // Ignored\n      * within a quoted region.\n      *\n      * @param ignored  the ignored matcher to use, null ignored\n-     */\n-    public void setIgnoredMatcher(StrMatcher ignored) {\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setIgnoredMatcher(StrMatcher ignored) {\n         if (ignored != null) {\n             this.ignored = ignored;\n         }\n+        return this;\n     }\n \n     /**\n      * within a quoted region.\n      *\n      * @param ignored  the ignored character to use\n-     */\n-    public void setIgnoredChar(char ignored) {\n-        setIgnoredMatcher(StrMatcher.charMatcher(ignored));\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setIgnoredChar(char ignored) {\n+        return setIgnoredMatcher(StrMatcher.charMatcher(ignored));\n     }\n \n     // Trimmer\n      * unquoted string.\n      *\n      * @param trimmer  the trimmer matcher to use, null ignored\n-     */\n-    public void setTrimmerMatcher(StrMatcher trimmer) {\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setTrimmerMatcher(StrMatcher trimmer) {\n         if (trimmer != null) {\n             this.trimmer = trimmer;\n         }\n+        return this;\n     }\n \n     //-----------------------------------------------------------------------\n      * The default for this property is false.\n      *\n      * @param emptyAsNull  whether empty tokens are returned as null\n-     */\n-    public void setEmptyTokenAsNull(boolean emptyAsNull) {\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setEmptyTokenAsNull(boolean emptyAsNull) {\n         this.emptyAsNull = emptyAsNull;\n+        return this;\n     }\n \n     //-----------------------------------------------------------------------\n      * The default for this property is false.\n      *\n      * @param ignoreEmptyTokens  whether empty tokens are not returned\n-     */\n-    public void setIgnoreEmptyTokens(boolean ignoreEmptyTokens) {\n+     * @return this, to enable chaining\n+     */\n+    public StrTokenizer setIgnoreEmptyTokens(boolean ignoreEmptyTokens) {\n         this.ignoreEmptyTokens = ignoreEmptyTokens;\n+        return this;\n     }\n \n     //-----------------------------------------------------------------------\n     public Object clone() {\n         try {\n             StrTokenizer cloned = (StrTokenizer) super.clone();\n-            // chars[] does not need additional clone as it is treated as immutable\n+            cloned.chars = (char[]) cloned.chars;\n             cloned.reset();\n             return cloned;\n \n--- a/src/test/org/apache/commons/lang/text/StrTokenizerTest.java\n+++ b/src/test/org/apache/commons/lang/text/StrTokenizerTest.java\n \n         tok = new StrTokenizer(input.toCharArray());\n         assertEquals(input, tok.getContent());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testChaining() {\n+        StrTokenizer tok = new StrTokenizer();\n+        assertEquals(tok, tok.reset());\n+        assertEquals(tok, tok.reset(\"\"));\n+        assertEquals(tok, tok.reset(new char[0]));\n+        assertEquals(tok, tok.setDelimiterChar(' '));\n+        assertEquals(tok, tok.setDelimiterString(\" \"));\n+        assertEquals(tok, tok.setDelimiterMatcher(null));\n+        assertEquals(tok, tok.setQuoteChar(' '));\n+        assertEquals(tok, tok.setQuoteMatcher(null));\n+        assertEquals(tok, tok.setIgnoredChar(' '));\n+        assertEquals(tok, tok.setIgnoredMatcher(null));\n+        assertEquals(tok, tok.setTrimmerMatcher(null));\n+        assertEquals(tok, tok.setEmptyTokenAsNull(false));\n+        assertEquals(tok, tok.setIgnoreEmptyTokens(false));\n     }\n \n     //-----------------------------------------------------------------------", "timestamp": 1124548499, "metainfo": ""}