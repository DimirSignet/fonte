{"sha": "87400e67bcf5ed90dc30a69a1c8ebc457a757aac", "log": "Interpolation moved into the text package   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/text/Interpolation.java\n+package org.apache.commons.lang.text;\n+\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.StringUtils;\n+\n+/**\n+ * <p>Performs basic variable interpolation on a String for variables within a Map.\n+ * Variables of the form, ${var}, are supported.</p>\n+ *\n+ * @author Ken Fitzpatrick\n+ * @author Henri Yandell\n+ * @since 2.1\n+ * @version $Id: Interpolation.java,v 1.1 2004/09/05 00:56:31 bayard Exp $\n+ */\n+public class Interpolation {\n+\n+    /** The marker used to start a variable. */\n+    private static final String SYMBOLIC_VALUE_MARKER_START = \"${\";\n+    /** The marker used to end a variable. */\n+    private static final String SYMBOLIC_VALUE_MARKER_END = \"}\";\n+\n+    /**\n+     * <p>Interpolates a String to replace variables of the form <code>${...}</code>.</p>\n+     * \n+     * <p>This method is useful for enabling simple strings to be modified based\n+     * on a map of data. A typical use case might be to add data from configuration\n+     * to an error message. This method, and this class, does not seek to replace\n+     * full interpolation mechanisms, for example Velocity.</p>\n+     * \n+     * <p>The expected format of <code>templateString</code> is:\n+     * <code><pre>\n+     *   The ${animal} jumped over the ${target}.\n+     * </pre></code>\n+     * such that the key/value pairs found in <code>values</code>\n+     * are substituted into the string at the <code>${key-name}</code> markers.\n+     * In the above example, <code>valuesMap</code> could have been populated as:\n+     * <code><pre>\n+     *   Map valuesMap = HashMap();\n+     *   valuesMap.put( \"animal\", \"quick brown fox\" );\n+     *   valuesMap.put( \"target\", \"lazy dog\" );\n+     *   String resolvedString = StringUtils.interpolate( templateString, valuesMap );\n+     * </pre></code>\n+     * yielding:\n+     * <code><pre>\n+     *   The quick brown fox jumped over the lazy dog.\n+     * </pre></code></p>\n+     * \n+     * <p>The same <code>templateString</code> from the above example could be reused as:\n+     * <code><pre>\n+     *   Map valuesMap = HashMap();\n+     *   valuesMap.put( \"animal\", \"cow\" );\n+     *   valuesMap.put( \"target\", \"moon\" );\n+     *   String resolvedString = StringUtils.interpolate( templateString, valuesMap );\n+     * </pre></code>\n+     * yielding:\n+     * <code><pre>\n+     *   The cow jumped over the moon.\n+     * </pre></code></p>\n+     * \n+     * <p>The value of <code>templateString</code> is returned in an unaltered\n+     * if <code>templateString</code> is null, empty, or contains no marked variables\n+     * that can be resolved by the key/value pairs found in <code>valuesMap</code>,\n+     * or if <code>valuesMap</code> is null, empty or has no key/value pairs that can be\n+     * applied to the marked variables within <code>templateString</code>.</p>\n+     * \n+     * <p>If a <code>valuesMap</code> value is null, it will be treated as \"\".</p>\n+     * \n+     * @param templateString  String containing any mixture of variable and non-variable\n+     *      content, to be used as a template for the value substitution process\n+     * @param valuesMap  Map containing the key/value pairs to be used to resolve\n+     *      the values of the marked variables found within <code>templateString</code>\n+     * @return the interpolated String\n+     */\n+    public static String interpolate(String templateString, Map valuesMap) {\n+        // pre-conditions\n+        if (templateString == null || valuesMap == null ||\n+            templateString.length() == 0 || valuesMap.isEmpty()) {\n+            return templateString;\n+        }\n+        \n+        // default the returned String to the templateString\n+        String returnString = templateString;\n+        String nextKey = null;\n+        String substitutionValue = null;\n+        String nextValueToBeSubstituted = null;\n+        \n+        // get a list of substitution valuesMap\n+        Iterator keys = valuesMap.keySet().iterator();\n+        while (keys.hasNext()) {\n+            nextKey = (String) keys.next();\n+            substitutionValue = StringUtils.defaultString((String) valuesMap.get(nextKey));\n+            nextValueToBeSubstituted = SYMBOLIC_VALUE_MARKER_START + nextKey + SYMBOLIC_VALUE_MARKER_END;\n+\n+            returnString = StringUtils.replace(returnString, nextValueToBeSubstituted, substitutionValue);\n+        }\n+        return returnString;\n+    }\n+\n+    /**\n+     * <p>Interpolates a String to replace variables of the form <code>${...}</code>\n+     * where the replace strings may also contain variables to interpolate.</p>\n+     * \n+     * <p>This method is useful for enabling simple strings to be modified based\n+     * on a map of data. A typical use case might be to add data from configuration\n+     * to an error message. This method, and this class, does not seek to replace\n+     * full interpolation mechanisms, for example Velocity.</p>\n+     * \n+     * <p>This method calls {@link #interpolate(String, Map)} repeatedly until the\n+     * returned string does not change. This has the effect of allowing the replace\n+     * strings in <code>valuesMap</code> to contain variables that should also be\n+     * interpolated.</p>\n+     * \n+     * <p>The expected format of <code>templateString</code> is:\n+     * <code><pre>\n+     *   The ${animal} jumped over the ${target}.\n+     * </pre></code>\n+     * such that the key/value pairs found in <code>values</code> are substituted into the string at the\n+     * <code>${key-name}</code> markers.  In the above example, <code>valuesMap</code>\n+     * could have been populated as:\n+     * <code><pre>\n+     *   Map valuesMap = HashMap();\n+     *   valuesMap.put( \"animal\", \"${critter}\" );\n+     *   valuesMap.put( \"target\", \"${pet}\" );\n+     *   valuesMap.put( \"pet\", \"${petCharacteristic} dog\" );\n+     *   valuesMap.put( \"petCharacteristic\", \"lazy\" );\n+     *   valuesMap.put( \"critter\", \"${critterSpeed} ${critterColor} ${critterType}\" );\n+     *   valuesMap.put( \"critterSpeed\", \"quick\" );\n+     *   valuesMap.put( \"critterColor\", \"brown\" );\n+     *   valuesMap.put( \"critterType\", \"fox\" );\n+     *   String resolvedString = StringUtils.interpolate( templateString, valuesMap, true );\n+     * </pre></code>\n+     * yielding:\n+     * <code><pre>\n+     *   The quick brown fox jumped over the lazy dog.\n+     * </pre></code></p>\n+     * \n+     * <p>The value of <code>templateString</code> is returned in an unaltered\n+     * if <code>templateString</code> is null, empty, or contains no marked variables\n+     * that can be resolved by the key/value pairs found in <code>valuesMap</code>,\n+     * or if <code>valuesMap</code> is null, empty or has no key/value pairs that can be\n+     * applied to the marked variables within <code>templateString</code>.</p>\n+     * \n+     * <p>If a <code>valuesMap</code> value is null, it will be treated as \"\".</p>\n+     * \n+     * @param templateString  String containing any mixture of variable and non-variable\n+     *      content, to be used as a template for the value substitution process\n+     * @param valuesMap  Map containing the key/value pairs to be used to resolve\n+     *      the values of the marked variables found within <code>templateString</code>\n+     * @return the interpolated String\n+     */\n+    public static String interpolateRepeatedly(String templateString, Map valuesMap) {\n+        // pre-conditions\n+        if (templateString == null || valuesMap == null ||\n+            templateString.length() == 0 || valuesMap.isEmpty()) {\n+            return templateString;\n+        }\n+        \n+        String currentResult = templateString;\n+        String previousResult = null;\n+        while (!StringUtils.equals(currentResult, previousResult)) {\n+            previousResult = currentResult;\n+            currentResult = Interpolation.interpolate(previousResult, valuesMap);\n+        }\n+        \n+        return currentResult;\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/lang/LangTestSuite.java\n+++ b/src/test/org/apache/commons/lang/LangTestSuite.java\n  * @author Stephen Colebourne\n  * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n  * @author Matthew Hawthorne\n- * @version $Id: LangTestSuite.java,v 1.27 2004/07/04 04:51:25 bayard Exp $\n+ * @version $Id: LangTestSuite.java,v 1.28 2004/09/05 00:56:31 bayard Exp $\n  */\n public class LangTestSuite extends TestCase {\n     \n         suite.addTest(EntitiesTest.suite());\n         suite.addTest(IllegalClassExceptionTest.suite());\n         suite.addTest(IncompleteArgumentExceptionTest.suite());\n-        suite.addTest(InterpolationTest.suite());\n         suite.addTest(NotImplementedExceptionTest.suite());\n         suite.addTest(NullArgumentExceptionTest.suite());\n         suite.addTest(NumberRangeTest.suite());\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/text/InterpolationTest.java\n+/*\n+ * Copyright 2002-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+import java.util.Map;\n+import java.util.HashMap;\n+\n+/**\n+ * Unit tests {@link org.apache.commons.lang.text.Interpolation}.\n+ *\n+ * @author Henri Yandell\n+ * @author Ken Fitzpatrick\n+ * @version $Id: InterpolationTest.java,v 1.1 2004/09/05 00:56:31 bayard Exp $\n+ */\n+public class InterpolationTest extends TestCase {\n+\n+    private static final String INPUT_TEMPLATE     = \"The ${animal} jumped over the ${target}.\";\n+    private static final String EXPECTED_RESULTS_1 = \"The quick brown fox jumped over the lazy dog.\";\n+    private static final String EXPECTED_RESULTS_2 = \"The cow jumped over the moon.\";\n+\n+    public InterpolationTest(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+    \tTestSuite suite = new TestSuite(InterpolationTest.class);\n+    \tsuite.setName(\"Interpolation Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    public void testSimpleVariableSubstitution() {\n+\n+        // test case: \"The quick brown fox jumped over the lazy dog.\"\n+        Map valuesMap = new HashMap();\n+        valuesMap.put( \"animal\", \"quick brown fox\" );\n+        valuesMap.put( \"target\", \"lazy dog\" );\n+        assertEquals( \"Test case 1: simple variable substitution\", EXPECTED_RESULTS_1,\n+            Interpolation.interpolate( INPUT_TEMPLATE, valuesMap) );\n+\n+        // test case: \"The cow jumped over the moon.\"\n+        valuesMap = new HashMap();\n+        valuesMap.put( \"animal\", \"cow\" );\n+        valuesMap.put( \"target\", \"moon\" );\n+        assertEquals( \"Test case 2: template reuse, different results\" ,EXPECTED_RESULTS_2,\n+            Interpolation.interpolate( INPUT_TEMPLATE, valuesMap) );\n+    }\n+\n+    public void testNullMap() {\n+        // negative test case: Map == null\n+        Map valuesMap = null;\n+        assertEquals( \"Test case 3: Map == null\", INPUT_TEMPLATE,\n+            Interpolation.interpolate( INPUT_TEMPLATE, valuesMap) );\n+    }\n+\n+    public void testEmptyMap() {\n+        // negative test case: Map.isEmpty()\n+        Map valuesMap = new HashMap();\n+        assertEquals( \"Test case 4: Map.isEmpty()\", INPUT_TEMPLATE,\n+            Interpolation.interpolate( INPUT_TEMPLATE, valuesMap) );\n+    }\n+\n+    public void testNullTemplate() {\n+        // negative test case: INPUT_TEMPLATE == null\n+        Map valuesMap = new HashMap();\n+        valuesMap.put( \"animal\", \"cow\" );\n+        valuesMap.put( \"target\", \"moon\" );\n+        assertNull( \"Test case 5: template == null\",\n+            Interpolation.interpolate( null, valuesMap) );\n+    }\n+\n+    public void testRecursive() {\n+        // test case: process repeatedly\n+        Map valuesMap = new HashMap();\n+        valuesMap.put( \"animal\", \"${critter}\" );\n+        valuesMap.put( \"target\", \"${pet}\" );\n+        valuesMap.put( \"pet\", \"${petCharacteristic} dog\" );\n+        valuesMap.put( \"petCharacteristic\", \"lazy\" );\n+        valuesMap.put( \"critter\", \"${critterSpeed} ${critterColor} ${critterType}\" );\n+        valuesMap.put( \"critterSpeed\", \"quick\" );\n+        valuesMap.put( \"critterColor\", \"brown\" );\n+        valuesMap.put( \"critterType\", \"fox\" );\n+        assertEquals( \"Test case 6: interpolateRepeatedly\", EXPECTED_RESULTS_1,\n+            Interpolation.interpolateRepeatedly( INPUT_TEMPLATE, valuesMap ) );\n+\n+        // test case: process repeatedly\n+        valuesMap = new HashMap();\n+        valuesMap.put( \"animal\", \"cow\" );\n+        valuesMap.put( \"target\", \"${celestialObject}\" );\n+        valuesMap.put( \"celestialObject\", \"moon\" );\n+        assertEquals( \"Test case 8: interpolateRepeatedly\", EXPECTED_RESULTS_2,\n+            Interpolation.interpolateRepeatedly( INPUT_TEMPLATE, valuesMap ) );\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/text/TextTestSuite.java\n+/*\n+ * Copyright 2002-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Test suite for the Text package.\n+ *\n+ * @author Stephen Colebourne\n+ * @version $Id: TextTestSuite.java,v 1.1 2004/09/05 00:56:31 bayard Exp $\n+ */\n+public class TextTestSuite extends TestCase {\n+    \n+    /**\n+     * Construct a new instance.\n+     */\n+    public TextTestSuite(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * Command-line interface.\n+     */\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    /**\n+     * Get the suite of tests\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite();\n+        suite.setName(\"Commons-Lang-Text Tests\");\n+        suite.addTest(InterpolationTest.suite());\n+        return suite;\n+    }\n+}", "timestamp": 1094345791, "metainfo": ""}