{"sha": "273c3c7a7a774194856b565a76c743ae65332d9c", "log": "Create StrLookup by extraction from StrSubstitutor  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/text/StrLookup.java\n+/*\n+ * Copyright 2005-2006 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.lang.text;\n+\n+import java.util.Map;\n+\n+/**\n+ * Lookup a String key to a String value.\n+ * <p>\n+ * This class represents the simplest form of a string to string map.\n+ * It has a benefit over a map in that it can create the result on\n+ * demand based on the key.\n+ * <p>\n+ * This class comes complete with various factory methods.\n+ * If these do not suffice, you can subclass and implement your own matcher.\n+ * <p>\n+ * For example, it would be possible to implement a lookup that used the\n+ * key as a primary key, and looked up the value on demand from the database\n+ *\n+ * @author Stephen Colebourne\n+ * @since 2.2\n+ * @version $Id: $\n+ */\n+public abstract class StrLookup {\n+\n+    /**\n+     * Lookup that always returns null.\n+     */\n+    private static final StrLookup NONE_LOOKUP;\n+    /**\n+     * Lookup that uses System properties.\n+     */\n+    private static final StrLookup SYSTEM_PROPERTIES_LOOKUP;\n+    static {\n+        NONE_LOOKUP = new MapStrLookup(null);\n+        StrLookup lookup = null;\n+        try {\n+            lookup = new MapStrLookup(System.getProperties());\n+        } catch (SecurityException ex) {\n+            lookup = NONE_LOOKUP;\n+        }\n+        SYSTEM_PROPERTIES_LOOKUP = lookup;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a lookup which always returns null.\n+     *\n+     * @return a lookup that always returns null, not null\n+     */\n+    public static StrLookup noneLookup() {\n+        return NONE_LOOKUP;\n+    }\n+\n+    /**\n+     * Returns a lookup which uses {@link System#getProperties() System properties}\n+     * to lookup the key to value.\n+     * <p>\n+     * If a security manager blocked access to system properties, then null will\n+     * be returned from every lookup.\n+     * <p>\n+     * If a null key is used, this lookup will throw a NullPointerException.\n+     *\n+     * @return a lookup using system properties, not null\n+     */\n+    public static StrLookup systemPropertiesLookup() {\n+        return SYSTEM_PROPERTIES_LOOKUP;\n+    }\n+\n+    /**\n+     * Returns a lookup which looks up values using a map.\n+     * <p>\n+     * If the map is null, then null will be returned from every lookup.\n+     * The map result object is converted to a string using toString().\n+     *\n+     * @param map  the map of keys to values, may be null\n+     * @return a lookup using the map, not null\n+     */\n+    public static StrLookup mapLookup(Map map) {\n+        return new MapStrLookup(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor.\n+     */\n+    protected StrLookup() {\n+        super();\n+    }\n+\n+    /**\n+     * Looks up a String key to a String value.\n+     * <p>\n+     * The internal implementation may use any mechanism to return the value.\n+     * The simplest implementation is to use a Map. However, virtually any\n+     * implementation is possible.\n+     * <p>\n+     * For example, it would be possible to implement a lookup that used the\n+     * key as a primary key, and looked up the value on demand from the database\n+     * Or, a numeric based implementation could be created that treats the key\n+     * as an integer, increments the value and return the result as a string -\n+     * converting 1 to 2, 15 to 16 etc.\n+     *\n+     * @param key  the key to be looked up, may be null\n+     * @return the matching value, null if no match\n+     */\n+    public abstract String lookup(String key);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Lookup imnplementation that uses a Map.\n+     */\n+    static class MapStrLookup extends StrLookup {\n+\n+        /** Map keys are variable names and value. */\n+        private final Map map;\n+\n+        /**\n+         * Creates a new instance backed by a Map.\n+         *\n+         * @param map  the map of keys to values, may be null\n+         */\n+        MapStrLookup(Map map) {\n+            this.map = map;\n+        }\n+\n+        /**\n+         * Looks up a String key to a String value using the map.\n+         * <p>\n+         * If the map is null, then null is returned.\n+         * The map result object is converted to a string using toString().\n+         *\n+         * @param key  the key to be looked up, may be null\n+         * @return the matching value, null if no match\n+         */\n+        public String lookup(String key) {\n+            if (map == null) {\n+                return null;\n+            }\n+            Object obj = map.get(key);\n+            if (obj == null) {\n+                return null;\n+            }\n+            return obj.toString();\n+        }\n+    }\n+}\n--- a/src/java/org/apache/commons/lang/text/StrSubstitutor.java\n+++ b/src/java/org/apache/commons/lang/text/StrSubstitutor.java\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-\n package org.apache.commons.lang.text;\n \n import java.util.ArrayList;\n     /**\n      * Variable resolution is delegated to an implementor of VariableResolver.\n      */\n-    private VariableResolver variableResolver;\n+    private StrLookup variableResolver;\n \n     //-----------------------------------------------------------------------\n     /**\n      * @return the result of the replace operation\n      */\n     public static String replaceSystemProperties(Object source) {\n-        return new StrSubstitutor(System.getProperties()).replace(source);\n+        return new StrSubstitutor(StrLookup.systemPropertiesLookup()).replace(source);\n     }\n \n     //-----------------------------------------------------------------------\n      * and the escaping character.\n      */\n     public StrSubstitutor() {\n-        this((VariableResolver) null, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n+        this((StrLookup) null, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n     }\n \n     /**\n      * @param valueMap  the map with the variables' values, may be null\n      */\n     public StrSubstitutor(Map valueMap) {\n-        this(new MapVariableResolver(valueMap), DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n+        this(StrLookup.mapLookup(valueMap), DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the prefix or suffix is null\n      */\n     public StrSubstitutor(Map valueMap, String prefix, String suffix) {\n-        this(valueMap, prefix, suffix, DEFAULT_ESCAPE);\n+        this(StrLookup.mapLookup(valueMap), prefix, suffix, DEFAULT_ESCAPE);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the prefix or suffix is null\n      */\n     public StrSubstitutor(Map valueMap, String prefix, String suffix, char escape) {\n-        this(new MapVariableResolver(valueMap), prefix, suffix, escape);\n+        this(StrLookup.mapLookup(valueMap), prefix, suffix, escape);\n+    }\n+\n+    /**\n+     * Creates a new instance and initializes it.\n+     *\n+     * @param variableResolver  the variable resolver, may be null\n+     */\n+    public StrSubstitutor(StrLookup variableResolver) {\n+        this(variableResolver, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);\n     }\n \n     /**\n      * @param escape  the escape character\n      * @throws IllegalArgumentException if the prefix or suffix is null\n      */\n-    public StrSubstitutor(VariableResolver variableResolver, String prefix, String suffix, char escape) {\n+    public StrSubstitutor(StrLookup variableResolver, String prefix, String suffix, char escape) {\n         this.setVariableResolver(variableResolver);\n         this.setVariablePrefix(prefix);\n         this.setVariableSuffix(suffix);\n      * Creates a new instance and initializes it.\n      *\n      * @param variableResolver  the variable resolver, may be null\n-     * @param prefix  the prefix for variables, not null\n-     * @param suffix  the suffix for variables, not null\n+     * @param prefixMatcher  the prefix for variables, not null\n+     * @param suffixMatcher  the suffix for variables, not null\n      * @param escape  the escape character\n      * @throws IllegalArgumentException if the prefix or suffix is null\n      */\n-    public StrSubstitutor(VariableResolver variableResolver, StrMatcher prefix, StrMatcher suffix, char escape) {\n+    public StrSubstitutor(\n+            StrLookup variableResolver, StrMatcher prefixMatcher, StrMatcher suffixMatcher, char escape) {\n         this.setVariableResolver(variableResolver);\n-        this.setVariablePrefixMatcher(prefix);\n-        this.setVariableSuffixMatcher(suffix);\n+        this.setVariablePrefixMatcher(prefixMatcher);\n+        this.setVariableSuffixMatcher(suffixMatcher);\n         this.setEscapeChar(escape);\n     }\n \n         }\n         StrBuilder buf = new StrBuilder(length).append(source, offset, length);\n         if (substitute(buf, 0, length) == false) {\n-            return source.substring(offset, length);\n+            return source.substring(offset, offset + length);\n         }\n         return buf.toString();\n     }\n      * @return the variable's value or <b>null</b> if the variable is unknown\n      */\n     protected String resolveVariable(String variableName, StrBuilder buf, int startPos, int endPos) {\n-        VariableResolver lookup = getVariableResolver();\n-        if (lookup == null) {\n+        StrLookup resolver = getVariableResolver();\n+        if (resolver == null) {\n             return null;\n         }\n-        return lookup.resolveVariable(variableName);\n+        return resolver.lookup(variableName);\n     }\n \n     // Escape\n     // Resolver\n     //-----------------------------------------------------------------------\n     /**\n-     * Gets the VariableResolver\n+     * Gets the VariableResolver that is used to lookup variables.\n      *\n      * @return the VariableResolver\n      */\n-    public VariableResolver getVariableResolver() {\n+    public StrLookup getVariableResolver() {\n         return this.variableResolver;\n     }\n \n     /**\n-     * Sets the VariableResolver\n+     * Sets the VariableResolver that is used to lookup variables.\n      *\n      * @param variableResolver  the VariableResolver\n      */\n-    public void setVariableResolver(VariableResolver variableResolver) {\n+    public void setVariableResolver(StrLookup variableResolver) {\n         this.variableResolver = variableResolver;\n     }\n \n-    //-----------------------------------------------------------------------\n-    /**\n-     * Looks up a string value by name.\n-     * This represents the simplest form of a map.\n-     */\n-    public static interface VariableResolver {\n-        /**\n-         * Resolves the variable name to a value.\n-         *\n-         * @param varName  the name to be looked up, may be null\n-         * @return the matching value, null if no match\n-         */\n-        String resolveVariable(String varName);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Looks up a string value by name using a {@link Map}.\n-     */\n-    static class MapVariableResolver implements VariableResolver {\n-        /**\n-         * Map keys are variable names and value\n-         */\n-        Map map;\n-\n-        /**\n-         * Creates a new resolver backed by a Map.\n-         *\n-         * @param map  the variable names and values\n-         */\n-        MapVariableResolver(Map map) {\n-            this.map = map;\n-        }\n-\n-        /**\n-         * Resolves the given variable name with the backing Map.\n-         *\n-         * @param varName  a variable name\n-         * @return a value or null if the variable name is not in Map\n-         */\n-        public String resolveVariable(String varName) {\n-            if (map == null) {\n-                return null;\n-            }\n-            Object obj = map.get(varName);\n-            if (obj == null) {\n-                return null;\n-            }\n-            return obj.toString();\n-        }\n-    }\n-\n }\n--- /dev/null\n+++ b/src/test/org/apache/commons/lang/text/StrLookupTest.java\n+/*\n+ * Copyright 2005-2006 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang.text;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * Test class for StrLookup.\n+ *\n+ * @version $Id: StrSubstitutorTest.java 231316 2005-08-10 20:36:26Z ggregory $\n+ */\n+public class StrLookupTest extends TestCase {\n+\n+    /**\n+     * Main method.\n+     * \n+     * @param args  command line arguments, ignored\n+     */\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    /**\n+     * Return a new test suite containing this test case.\n+     * \n+     * @return a new test suite containing this test case\n+     */\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(StrLookupTest.class);\n+        suite.setName(\"StrLookup Tests\");\n+        return suite;\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNoneLookup() {\n+        assertEquals(null, StrLookup.noneLookup().lookup(null));\n+        assertEquals(null, StrLookup.noneLookup().lookup(\"\"));\n+        assertEquals(null, StrLookup.noneLookup().lookup(\"any\"));\n+    }\n+\n+    public void testSystemProperiesLookup() {\n+        assertEquals(System.getProperty(\"os.name\"), StrLookup.systemPropertiesLookup().lookup(\"os.name\"));\n+        assertEquals(null, StrLookup.systemPropertiesLookup().lookup(\"\"));\n+        assertEquals(null, StrLookup.systemPropertiesLookup().lookup(\"other\"));\n+        try {\n+            StrLookup.systemPropertiesLookup().lookup(null);\n+            fail();\n+        } catch (NullPointerException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testMapLookup() {\n+        Map map = new HashMap();\n+        map.put(\"key\", \"value\");\n+        map.put(\"number\", new Integer(2));\n+        assertEquals(\"value\", StrLookup.mapLookup(map).lookup(\"key\"));\n+        assertEquals(\"2\", StrLookup.mapLookup(map).lookup(\"number\"));\n+        assertEquals(null, StrLookup.mapLookup(map).lookup(null));\n+        assertEquals(null, StrLookup.mapLookup(map).lookup(\"\"));\n+        assertEquals(null, StrLookup.mapLookup(map).lookup(\"other\"));\n+    }\n+\n+    public void testMapLookup_nullMap() {\n+        Map map = null;\n+        assertEquals(null, StrLookup.mapLookup(map).lookup(null));\n+        assertEquals(null, StrLookup.mapLookup(map).lookup(\"\"));\n+        assertEquals(null, StrLookup.mapLookup(map).lookup(\"any\"));\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/lang/text/StrSubstitutorTest.java\n+++ b/src/test/org/apache/commons/lang/text/StrSubstitutorTest.java\n         super.tearDown();\n         values = null;\n     }\n-\n-    //-----------------------------------------------------------------------\n-//    /**\n-//     * Tests escaping variable references.\n-//     */\n-//    public void testEscape() {\n-//        assertEquals(\"${\", this.getFormat().replace(\"$${\"));\n-//        assertEquals(\"${animal}\", this.getFormat().replace(\"$${animal}\"));\n-//        this.getValueMap().put(\"var_name\", \"x\");\n-//        assertEquals(\"Many $$$$${target} $s\", this.getFormat().replace(\"Many $$$$$${target} $s\"));\n-//        assertEquals(\"Variable ${x} must be used!\", this.getFormat().replace(\"Variable $${${var_name}} must be used!\"));\n-//    }\n-//\n-//    /**\n-//     * Tests creating new <code>VariableFormat</code> objects.\n-//     */\n-//    public void testInitialize() {\n-//        assertNotNull(this.getFormat().getVariableResolver());\n-//        assertEquals(StrSubstitutor.DEFAULT_PREFIX, this.getFormat().getVariablePrefixMatcher());\n-//        assertEquals(StrSubstitutor.DEFAULT_SUFFIX, this.getFormat().getVariableSuffixMatcher());\n-//        assertEquals(StrSubstitutor.DEFAULT_ESCAPE, this.getFormat().getEscapeChar());\n-//\n-//        format = new StrSubstitutor(values, \"<<\", \">>\", '\\\\');\n-//        assertEquals(\"<<\", this.getFormat().getVariablePrefixMatcher());\n-//        assertEquals(\">>\", this.getFormat().getVariableSuffixMatcher());\n-//        assertEquals('\\\\', this.getFormat().getEscapeChar());\n-//\n-//        // new StrSubstitutor(null) should be OK IMO\n-//        // Gary Gregory - July 14 2005\n-//        // try {\n-//        // format = new StrSubstitutor(null);\n-//        // fail(\"Could create format object with null map!\");\n-//        // } catch (IllegalArgumentException iex) {\n-//        // // ok\n-//        // }\n-//\n-//        try {\n-//            format = new StrSubstitutor(values, \"${\", null);\n-//            fail(\"Could create format object with undefined suffix!\");\n-//        } catch (IllegalArgumentException iex) {\n-//            // ok\n-//        }\n-//\n-//        try {\n-//            format = new StrSubstitutor(values, null, \"]\");\n-//            fail(\"Could create format object with undefined prefix!\");\n-//        } catch (IllegalArgumentException iex) {\n-//            // ok\n-//        }\n-//    }\n-//\n-//    /**\n-//     * Tests chaning variable prefix and suffix and the escaping character.\n-//     */\n-//    public void testNonDefaultTokens() {\n-//        format = new StrSubstitutor(values, \"<<\", \">>\", '\\\\');\n-//        assertEquals(\"The quick brown fox jumps over the lazy dog.\", format\n-//                .replace(\"The <<animal>> jumps over the <<target>>.\"));\n-//        assertEquals(\"The quick brown fox jumps over the <<target>>.\", format\n-//                .replace(\"The <<animal>> jumps over the \\\\<<target>>.\"));\n-//    }\n-//\n-//    /**\n-//     * Tests invoking the static convenience methods.\n-//     */\n-//    public void testNonInstanceMethods() {\n-//        assertEquals(\"The quick brown fox jumps over the lazy dog.\",\n-//                StrSubstitutor.replace(REPLACE_TEMPLATE, values));\n-//        values.put(KEY_ANIMAL, \"cow\");\n-//        values.put(KEY_TARGET, \"moon\");\n-//        assertEquals(\"The cow jumps over the moon.\",\n-//                StrSubstitutor.replace(\"The &animal; jumps over the &target;.\", values, \"&\", \";\"));\n-//    }\n-//\n-//    public void testNoResolver() throws Exception {\n-//        this.testNoResolver(new StrSubstitutor());\n-//        this.testNoResolver(new StrSubstitutor(null));\n-//    }\n-//\n-//    void testNoResolver(StrSubstitutor formatter) throws Exception {\n-//        formatter.setVariableResolver(null);\n-//        this.validateNoReplace(formatter);\n-//    }\n-//\n-//    public void testNullMap() throws Exception {\n-//        StrSubstitutor formatter = new StrSubstitutor(null);\n-//        validateNoReplace(formatter);\n-//    }\n-//\n \n     //-----------------------------------------------------------------------\n     /**\n         doTestNoReplace(\"${${ }}\");\n     }\n \n+    /**\n+     * Tests simple key replace.\n+     */\n+    public void testReplacePartialString_noReplace() {\n+        StrSubstitutor sub = new StrSubstitutor();\n+        assertEquals(\"${animal} jumps\", sub.replace(\"The ${animal} jumps over the ${target}.\", 4, 15));\n+    }\n+\n     //-----------------------------------------------------------------------\n     /**\n      * Tests protected.\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Tests constructor.\n+     */\n+    public void testConstructorNoArgs() {\n+        StrSubstitutor sub = new StrSubstitutor();\n+        assertEquals(\"Hi ${name}\", sub.replace(\"Hi ${name}\"));\n+    }\n+\n+    /**\n+     * Tests constructor.\n+     */\n+    public void testConstructorMapPrefixSuffix() {\n+        Map map = new HashMap();\n+        map.put(\"name\", \"commons\");\n+        StrSubstitutor sub = new StrSubstitutor(map, \"<\", \">\");\n+        assertEquals(\"Hi < commons\", sub.replace(\"Hi $< <name>\"));\n+    }\n+\n+    /**\n+     * Tests constructor.\n+     */\n+    public void testConstructorMapFull() {\n+        Map map = new HashMap();\n+        map.put(\"name\", \"commons\");\n+        StrSubstitutor sub = new StrSubstitutor(map, \"<\", \">\", '!');\n+        assertEquals(\"Hi < commons\", sub.replace(\"Hi !< <name>\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests get set.\n+     */\n+    public void testGetSetEscape() {\n+        StrSubstitutor sub = new StrSubstitutor();\n+        assertEquals('$', sub.getEscapeChar());\n+        sub.setEscapeChar('<');\n+        assertEquals('<', sub.getEscapeChar());\n+    }\n+\n+    /**\n+     * Tests get set.\n+     */\n+    public void testGetSetPrefix() {\n+        StrSubstitutor sub = new StrSubstitutor();\n+        assertEquals(true, sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher);\n+        sub.setVariablePrefix('<');\n+        assertEquals(true, sub.getVariablePrefixMatcher() instanceof StrMatcher.CharMatcher);\n+        \n+        sub.setVariablePrefix(\"<<\");\n+        assertEquals(true, sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher);\n+        try {\n+            sub.setVariablePrefix((String) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        assertEquals(true, sub.getVariablePrefixMatcher() instanceof StrMatcher.StringMatcher);\n+        \n+        StrMatcher matcher = StrMatcher.commaMatcher();\n+        sub.setVariablePrefixMatcher(matcher);\n+        assertSame(matcher, sub.getVariablePrefixMatcher());\n+        try {\n+            sub.setVariablePrefixMatcher((StrMatcher) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        assertSame(matcher, sub.getVariablePrefixMatcher());\n+    }\n+\n+    /**\n+     * Tests get set.\n+     */\n+    public void testGetSetSuffix() {\n+        StrSubstitutor sub = new StrSubstitutor();\n+        assertEquals(true, sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher);\n+        sub.setVariableSuffix('<');\n+        assertEquals(true, sub.getVariableSuffixMatcher() instanceof StrMatcher.CharMatcher);\n+        \n+        sub.setVariableSuffix(\"<<\");\n+        assertEquals(true, sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher);\n+        try {\n+            sub.setVariableSuffix((String) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        assertEquals(true, sub.getVariableSuffixMatcher() instanceof StrMatcher.StringMatcher);\n+        \n+        StrMatcher matcher = StrMatcher.commaMatcher();\n+        sub.setVariableSuffixMatcher(matcher);\n+        assertSame(matcher, sub.getVariableSuffixMatcher());\n+        try {\n+            sub.setVariableSuffixMatcher((StrMatcher) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        assertSame(matcher, sub.getVariableSuffixMatcher());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Tests static.\n      */\n     public void testStaticReplace() {\n         assertEquals(replaceTemplate, sub.replace(replaceTemplate));\n         \n         if (replaceTemplate == null) {\n+            assertEquals(null, sub.replace((String) null, 0, 100));\n             assertEquals(null, sub.replace((char[]) null));\n+            assertEquals(null, sub.replace((char[]) null, 0, 100));\n             assertEquals(null, sub.replace((Object) null));\n             assertEquals(false, sub.replace((StrBuilder) null));\n+            assertEquals(false, sub.replace((StrBuilder) null, 0, 100));\n         } else {\n             StrBuilder bld = new StrBuilder(replaceTemplate);\n             assertEquals(false, sub.replace(bld));\n--- a/src/test/org/apache/commons/lang/text/TextTestSuite.java\n+++ b/src/test/org/apache/commons/lang/text/TextTestSuite.java\n         suite.addTest(CompositeFormatTest.suite());\n         suite.addTest(StrBuilderTest.suite());\n         suite.addTest(StrBuilderAppendInsertTest.suite());\n+        suite.addTest(StrLookupTest.suite());\n         suite.addTest(StrMatcherTest.suite());\n+        suite.addTest(StrSubstitutorTest.suite());\n         suite.addTest(StrTokenizerTest.suite());\n         suite.addTestSuite(VariableFormatterTest.class);\n         return suite;", "timestamp": 1155079725, "metainfo": ""}