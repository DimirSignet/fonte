{"sha": "1a41190bbfafd95a32800874f8fbef4cce1fa5ae", "log": "Initial checkin of ToStringBuilder and assistants   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/builder/StandardToStringStyle.java\n+package org.apache.commons.lang.builder;\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+// package org.apache.commons.lang.builder\n+\n+/**\n+ * <code>StandardToStringStyle</code> works with ToStringBuilder to create a\n+ * toString.\n+ * <p>\n+ * This class is intended to be used as a singleton. There is no need \n+ * to instantiate a new style each time. Your code should instantiate the class\n+ * once, customize the values as required, and then store the result in a \n+ * public static final variable for the rest of the program to access.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id: StandardToStringStyle.java,v 1.1 2002/09/17 22:07:20 scolebourne Exp $\n+ */\n+public class StandardToStringStyle extends ToStringStyle {\n+    \n+    /**\n+     * Constructor.\n+     */\n+    public StandardToStringStyle() {\n+        super();\n+    }\n+    \n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * Gets whether to use the class name.\n+     * @return the current useClassName flag\n+     */\n+    public boolean isUseClassName() {\n+        return useClassName;\n+    }\n+\n+    /**\n+     * Sets whether to use the class name.\n+     * @param useClassName  the new useClassName flag\n+     */\n+    public void setUseClassName(boolean useClassName) {\n+        this.useClassName = useClassName;\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * Gets whether to output short or long class names.\n+     * @return the current shortClassName flag\n+     */\n+    public boolean isShortClassName() {\n+        return useShortClassName;\n+    }\n+\n+    /**\n+     * Sets whether to output short or long class names.\n+     * @param shortClassName  the new shortClassName flag\n+     */\n+    public void setShortClassName(boolean shortClassName) {\n+        this.useShortClassName = shortClassName;\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * Gets whether to use the identity hash code.\n+     * @return the current useIdentityHashCode flag\n+     */\n+    public boolean isUseIdentityHashCode() {\n+        return useIdentityHashCode;\n+    }\n+\n+    /**\n+     * Sets whether to use the identity hash code.\n+     * @param useFieldNames  the new useIdentityHashCode flag\n+     */\n+    public void setUseIdentityHashCode(boolean useIdentityHashCode) {\n+        this.useIdentityHashCode = useIdentityHashCode;\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * Gets whether to use the field names passed in.\n+     * @return the current useFieldNames flag\n+     */\n+    public boolean isUseFieldNames() {\n+        return useFieldNames;\n+    }\n+\n+    /**\n+     * Sets whether to use the field names passed in.\n+     * @param useFieldNames  the new useFieldNames flag\n+     */\n+    public void setUseFieldNames(boolean useFieldNames) {\n+        this.useFieldNames = useFieldNames;\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * Gets whether to use full detail when the caller doesn't specify.\n+     * @return the current defaultFullDetail flag\n+     */\n+    public boolean isDefaultFullDetail() {\n+        return defaultFullDetail;\n+    }\n+\n+    /**\n+     * Sets whether to use full detail when the caller doesn't specify.\n+     * @param defaultFullDetail  the new defaultFullDetail flag\n+     */\n+    public void setDefaultFullDetail(boolean defaultFullDetail) {\n+        this.defaultFullDetail = defaultFullDetail;\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * Gets whether to output array content detail.\n+     * @return the current array content detail setting\n+     */\n+    public boolean isArrayContentDetail() {\n+        return arrayContentDetail;\n+    }\n+    \n+    /**\n+     * Sets whether to output array content detail.\n+     * @param arrayContentDetail  the new arrayContentDetail flag\n+     */\n+    public void setArrayContentDetail(boolean arrayContentDetail) {\n+        this.arrayContentDetail = arrayContentDetail;\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * Gets the array start text.\n+     * @return the current array start text\n+     */\n+    public String getArrayStart() {\n+        return arrayStart;\n+    }\n+\n+    /**\n+     * Sets the array start text.\n+     * Null is accepted, but will be converted to a blank string.\n+     * @param arrayStart  the new array start text\n+     */\n+    public void setArrayStart(String arrayStart) {\n+        if (arrayStart == null) {\n+            arrayStart = \"\";\n+        }\n+        this.arrayStart = arrayStart;\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * Gets the array end text.\n+     * @return the current array end text\n+     */\n+    public String getArrayEnd() {\n+        return arrayEnd;\n+    }\n+\n+    /**\n+     * Sets the array end text.\n+     * Null is accepted, but will be converted to a blank string.\n+     * @param arrayEnd  the new array end text\n+     */\n+    public void setArrayEnd(String arrayEnd) {\n+        if (arrayStart == null) {\n+            arrayStart = \"\";\n+        }\n+        this.arrayEnd = arrayEnd;\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * Gets the array separator text.\n+     * @return the current array separator text\n+     */\n+    public String getArraySeparator() {\n+        return arraySeparator;\n+    }\n+\n+    /**\n+     * Sets the array separator text.\n+     * Null is accepted, but will be converted to a blank string.\n+     * @param arraySeparator  the new array separator text\n+     */\n+    public void setArraySeparator(String arraySeparator) {\n+        if (arraySeparator == null) {\n+            arraySeparator = \"\";\n+        }\n+        this.arraySeparator = arraySeparator;\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * Gets the content start text.\n+     * @return the current content start text\n+     */\n+    public String getContentStart() {\n+        return contentStart;\n+    }\n+\n+    /**\n+     * Sets the content start text.\n+     * Null is accepted, but will be converted to a blank string.\n+     * @param contentStart  the new content start text\n+     */\n+    public void setContentStart(String contentStart) {\n+        if (contentStart == null) {\n+            contentStart = \"\";\n+        }\n+        this.contentStart = contentStart;\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * Gets the content end text.\n+     * @return the current content end text\n+     */\n+    public String getContentEnd() {\n+        return contentEnd;\n+    }\n+\n+    /**\n+     * Sets the content end text.\n+     * Null is accepted, but will be converted to a blank string.\n+     * @param contentEnd  the new content end text\n+     */\n+    public void setContentEnd(String contentEnd) {\n+        if (contentEnd == null) {\n+            contentEnd = \"\";\n+        }\n+        this.contentEnd = contentEnd;\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * Gets the field name value separator text.\n+     * @return the current field name value separator text\n+     */\n+    public String getFieldNameValueSeparator() {\n+        return fieldNameValueSeparator;\n+    }\n+\n+    /**\n+     * Sets the field name value separator text.\n+     * Null is accepted, but will be converted to a blank string.\n+     * @param fieldNameValueSeparator  the new field name value separator text\n+     */\n+    public void setFieldNameValueSeparator(String fieldNameValueSeparator) {\n+        if (fieldNameValueSeparator == null) {\n+            fieldNameValueSeparator = \"\";\n+        }\n+        this.fieldNameValueSeparator = fieldNameValueSeparator;\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * Gets the field separator text.\n+     * @return the current field separator text\n+     */\n+    public String getFieldSeparator() {\n+        return fieldSeparator;\n+    }\n+\n+    /**\n+     * Sets the field separator text.\n+     * Null is accepted, but will be converted to a blank string.\n+     * @param fieldSeparator  the new field separator text\n+     */\n+    public void setFieldSeparator(String fieldSeparator) {\n+        if (fieldSeparator == null) {\n+            fieldSeparator = \"\";\n+        }\n+        this.fieldSeparator = fieldSeparator;\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * Gets the text to output when null found.\n+     * @return the current text to output when null found\n+     */\n+    public String getNullText() {\n+        return nullText;\n+    }\n+\n+    /**\n+     * Sets the text to output when null found.\n+     * Null is accepted, but will be converted to a blank string.\n+     * @param nullText  the new text to output when null found\n+     */\n+    public void setNullText(String nullText) {\n+        if (nullText == null) {\n+            nullText = \"\";\n+        }\n+        this.nullText = nullText;\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * Gets the text to output when a Collection, Map or Array size is output.\n+     * This is output before the size value.\n+     * @return the current start of size text\n+     */\n+    public String getSizeStartText() {\n+        return sizeStartText;\n+    }\n+\n+    /**\n+     * Sets the text to output when a Collection, Map or Array size is output.\n+     * This is output before the size value.\n+     * Null is accepted, but will be converted to a blank string.\n+     * @param sizeStartText  the new start of size text\n+     */\n+    public void setSizeStartText(String sizeStartText) {\n+        if (sizeStartText == null) {\n+            sizeStartText = \"\";\n+        }\n+        this.sizeStartText = sizeStartText;\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * Gets the text to output when a Collection, Map or Array size is output.\n+     * This is output after the size value.\n+     * @return the current end of size text\n+     */\n+    public String getSizeEndText() {\n+        return sizeEndText;\n+    }\n+\n+    /**\n+     * Sets the text to output when a Collection, Map or Array size is output.\n+     * This is output after the size value.\n+     * Null is accepted, but will be converted to a blank string.\n+     * @param sizeEndText  the new end of size text\n+     */\n+    public void setSizeEndText(String sizeEndText) {\n+        if (sizeEndText == null) {\n+            sizeEndText = \"\";\n+        }\n+        this.sizeEndText = sizeEndText;\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * Gets the text to output when an Object is output in summary mode.\n+     * This is output before the size value.\n+     * @return the current start of summary text\n+     */\n+    public String getSummaryObjectStartText() {\n+        return summaryObjectStartText;\n+    }\n+\n+    /**\n+     * Sets the text to output when an Object is output in summary mode.\n+     * This is output before the size value.\n+     * Null is accepted, but will be converted to a blank string.\n+     * @param summaryObjectStartText  the new start of summary text\n+     */\n+    public void setSummaryObjectStartText(String summaryObjectStartText) {\n+        if (summaryObjectStartText == null) {\n+            summaryObjectStartText = \"\";\n+        }\n+        this.summaryObjectStartText = summaryObjectStartText;\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+    /**\n+     * Gets the text to output when an Object is output in summary mode.\n+     * This is output after the size value.\n+     * @return the current end of summary text\n+     */\n+    public String getSummaryObjectEndText() {\n+        return summaryObjectEndText;\n+    }\n+\n+    /**\n+     * Sets the text to output when an Object is output in summary mode.\n+     * This is output after the size value.\n+     * Null is accepted, but will be converted to a blank string.\n+     * @param summaryObjectEndText  the new end of summary text\n+     */\n+    public void setSummaryObjectEndText(String summaryObjectEndText) {\n+        if (summaryObjectEndText == null) {\n+            summaryObjectEndText = \"\";\n+        }\n+        this.summaryObjectEndText = summaryObjectEndText;\n+    }\n+\n+    //---------------------------------------------------------------------\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/builder/ToStringBuilder.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.builder;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Map;\n+/**\n+ * <code>ToString</code> generation routine.\n+ * <p>\n+ * This class enables a good toString to be built for any class. This class aims \n+ * to simplify the process by:\n+ * <ul>\n+ * <li>allowing field names\n+ * <li>handling all types consistently\n+ * <li>handling nulls consistently\n+ * <li>outputting arrays and multi-dimensional arrays\n+ * <li>enabling the detail level to be controlled for objects and collections\n+ * </ul>\n+ * <p>\n+ * To use this class write code as follows:\n+ * <code>\n+ * public class Person {\n+ *   String name;\n+ *   int age;\n+ *   boolean isSmoker;\n+ * \n+ *   ...\n+ * \n+ *   public String toString() {\n+ *     return new ToStringBuilder(this).\n+ *       append(name, \"name\").\n+ *       append(age, \"age\").\n+ *       append(smoker, \"smoker\").\n+ *       toString();\n+ *   }\n+ * }\n+ * </code>\n+ * This will produce a toString of the format:\n+ * <code>Person@7f54[name=Stephen,age=29,smoker=false]</code>\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id: ToStringBuilder.java,v 1.1 2002/09/17 22:07:20 scolebourne Exp $\n+ */\n+public class ToStringBuilder {\n+    \n+    /**\n+     * The default style of output to use\n+     */\n+    private static ToStringStyle defaultStyle;\n+    /**\n+     * Current toString buffer\n+     */\n+    private final StringBuffer buffer;\n+    /**\n+     * The style of output to use\n+     */\n+    private final ToStringStyle style;\n+    /**\n+     * The object being output\n+     */\n+    private final Object object;\n+    \n+    /**\n+     * Constructor for ToStringBuilder.\n+     * This constructor outputs using the default style set with \n+     * <code>setDefaultStyle</code>.\n+     * \n+     * @param object  the object to build a toString for, must not be null\n+     * @throws IllegalArgumentException  if the object passed in is null\n+     */\n+    public ToStringBuilder(Object object) {\n+        this(object, getDefaultStyle(), null);\n+    }\n+    \n+    /**\n+     * Constructor for ToStringBuilder specifying the output style.\n+     * <p>\n+     * If the style is null, the default style is used.\n+     * \n+     * @param object  the object to build a toString for, must not be null\n+     * @param style  the style of the toString to create, may be null\n+     * @throws IllegalArgumentException  if the object passed in is null\n+     */\n+    public ToStringBuilder(Object object, ToStringStyle style) {\n+        this(object, style, null);\n+    }\n+    \n+    /**\n+     * Constructor for ToStringBuilder.\n+     * <p>\n+     * If the style is null, the default style is used.\n+     * If the buffer is null, a new one is created.\n+     * \n+     * @param object  the object to build a toString for, must not be null\n+     * @param style  the style of the toString to create, may be null\n+     * @param buffer  the string buffer to populate, may be null\n+     * @throws IllegalArgumentException  if the object passed in is null\n+     */\n+    public ToStringBuilder(Object object, ToStringStyle style, StringBuffer buffer) {\n+        super();\n+        if (object == null) {\n+            throw new IllegalArgumentException(\"The object to create a toString for must not be null\");\n+        }\n+        if (style == null) {\n+            style = ToStringStyle.DEFAULT_STYLE;\n+        }\n+        if (buffer == null) {\n+            buffer = new StringBuffer(512);\n+        }\n+        this.buffer = buffer;\n+        this.style = style;\n+        this.object = object;\n+        \n+        style.appendStart(buffer, object);\n+    }\n+    \n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Gets the default style to use.\n+     * <p>\n+     * This could allow the toString style to be controlled for an entire\n+     * application with one call. This might be used to have a verbose toString\n+     * during development and a compact toString in production.\n+     * \n+     * @return the default toString style\n+     */\n+    public static ToStringStyle getDefaultStyle() {\n+        return defaultStyle;\n+    }\n+    \n+    /**\n+     * Sets the default style to use.\n+     * \n+     * @param style  the default toString style\n+     * @throws IllegalArgumentException if the style is null\n+     */\n+    public static void setDefaultStyle(ToStringStyle style) {\n+        if (style == null) {\n+            throw new IllegalArgumentException(\"The style must not be null\");\n+        }\n+        defaultStyle = style;\n+    }\n+    \n+    //-------------------------------------------------------------------------\n+    \n+    /**\n+     * This method uses reflection to build a suitable toString using the default style.\n+     * <p>\n+     * It uses Field.setAccessible to gain access to private fields. This means\n+     * that it will throw a security exception if run under a security manger, if\n+     * the permissions are not set up.\n+     * It is also not as efficient as testing explicitly. \n+     * Transient members will be not be included, as they are likely derived.\n+     * Static fields will be not be included.\n+     * fields, and not part of the value of the object. \n+     * \n+     * @param object  the object to be output\n+     * @return the String result\n+     * @throws IllegalArgumentException if the object is null\n+     */\n+    public static String reflectionToString(Object object) {\n+        return reflectionToString(object, null, false);\n+    }\n+\n+    /**\n+     * This method uses reflection to build a suitable toString.\n+     * <p>\n+     * It uses Field.setAccessible to gain access to private fields. This means\n+     * that it will throw a security exception if run under a security manger, if\n+     * the permissions are not set up.\n+     * It is also not as efficient as testing explicitly. \n+     * Transient members will be not be included, as they are likely derived.\n+     * Static fields will be not be included.\n+     * fields, and not part of the value of the object. \n+     * <p>\n+     * If the style is null, the default style is used.\n+     * \n+     * @param object  the object to be output\n+     * @param style  the style of the toString to create, may be null\n+     * @return the String result\n+     * @throws IllegalArgumentException if the object or style is null\n+     */\n+    public static String reflectionToString(Object object, ToStringStyle style) {\n+        return reflectionToString(object, style, false);\n+    }\n+\n+    /**\n+     * This method uses reflection to build a suitable toString.\n+     * <p>\n+     * It uses Field.setAccessible to gain access to private fields. This means\n+     * that it will throw a security exception if run under a security manger, if\n+     * the permissions are not set up.\n+     * It is also not as efficient as testing explicitly. \n+     * If the outputTransients parameter is set to true, transient members will be\n+     * output, otherwise they are ignored, as they are likely derived fields, and\n+     * not part of the value of the object. \n+     * Static fields will not be tested.\n+     * <p>\n+     * If the style is null, the default style is used.\n+     * \n+     * @param object  the object to be output\n+     * @param style  the style of the toString to create, may be null\n+     * @param outputTransients  whether to include transient fields\n+     * @return the String result\n+     * @throws IllegalArgumentException if the object or style is null\n+     */\n+    public static String reflectionToString(Object object, ToStringStyle style, \n+            boolean outputTransients) {\n+        if (object == null) {\n+            throw new IllegalArgumentException(\"The object must not be null\");\n+        }\n+        if (style == null) {\n+            style = getDefaultStyle();\n+        }\n+        Field[] fields = object.getClass().getDeclaredFields();\n+        Field.setAccessible(fields, true);\n+        ToStringBuilder builder = new ToStringBuilder(object, style);\n+        for (int i = 0; i < fields.length; ++i) {\n+            Field f = fields[i];\n+            if (outputTransients || !Modifier.isTransient(f.getModifiers())) {\n+                if (!Modifier.isStatic(f.getModifiers())) {\n+                    try {\n+                        builder.append(f.getName(), f.get(object));\n+                        \n+                    } catch (IllegalAccessException ex) {\n+                        //this can't happen. Would get a Security exception instead\n+                        //throw a runtime exception in case the impossible happens.\n+                        throw new InternalError(\"Unexpected IllegalAccessException\");\n+                    }\n+                }\n+            }\n+        }\n+        return builder.toString();\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append to the toString an Object value.\n+     *\n+     * @param value  the value to add to the toString\n+     * @return this\n+     */\n+    public ToStringBuilder append(Object object) {\n+        style.append(buffer, null, object, null);\n+        return this;\n+    }\n+\n+    /**\n+     * Append to the toString an Object value.\n+     *\n+     * @param value  the value to add to the toString\n+     * @param fieldName  the field name\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, Object object) {\n+        style.append(buffer, fieldName, object, null);\n+        return this;\n+    }\n+\n+    /**\n+     * Append to the toString an Object value.\n+     *\n+     * @param value  the value to add to the toString\n+     * @param fieldName  the field name\n+     * @param fullDetail  true for detail, false for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, Object object, boolean fullDetail) {\n+        style.append(buffer, fieldName, object, new Boolean(fullDetail));\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append to the toString a long value.\n+     *\n+     * @param value  the value to add to the toString\n+     * @return this\n+     */\n+    public ToStringBuilder append(long value) {\n+        style.append(buffer, null, value);\n+        return this;\n+    }\n+\n+    /**\n+     * Append to the toString a long value.\n+     *\n+     * @param value  the value to add to the toString\n+     * @param fieldName  the field name\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, long value) {\n+        style.append(buffer, fieldName, value);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append to the toString an int value.\n+     *\n+     * @param value  the value to add to the toString\n+     * @return this\n+     */\n+    public ToStringBuilder append(int value) {\n+        style.append(buffer, null, value);\n+        return this;\n+    }\n+\n+    /**\n+     * Append to the toString an int value.\n+     *\n+     * @param value  the value to add to the toString\n+     * @param fieldName  the field name\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, int value) {\n+        style.append(buffer, fieldName, value);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append to the toString a short value.\n+     *\n+     * @param value  the value to add to the toString\n+     * @return this\n+     */\n+    public ToStringBuilder append(short value) {\n+        style.append(buffer, null, value);\n+        return this;\n+    }\n+\n+    /**\n+     * Append to the toString a short value.\n+     *\n+     * @param value  the value to add to the toString\n+     * @param fieldName  the field name\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, short value) {\n+        style.append(buffer, fieldName, value);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append to the toString a char value.\n+     *\n+     * @param value  the value to add to the toString\n+     * @return this\n+     */\n+    public ToStringBuilder append(char value) {\n+        style.append(buffer, null, value);\n+        return this;\n+    }\n+\n+    /**\n+     * Append to the toString a char value.\n+     *\n+     * @param value  the value to add to the toString\n+     * @param fieldName  the field name\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, char value) {\n+        style.append(buffer, fieldName, value);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append to the toString a byte value.\n+     *\n+     * @param value  the value to add to the toString\n+     * @return this\n+     */\n+    public ToStringBuilder append(byte value) {\n+        style.append(buffer, null, value);\n+        return this;\n+    }\n+\n+    /**\n+     * Append to the toString a byte value.\n+     *\n+     * @param value  the value to add to the toString\n+     * @param fieldName  the field name\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, byte value) {\n+        style.append(buffer, fieldName, value);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append to the toString a double value.\n+     *\n+     * @param value  the value to add to the toString\n+     * @return this\n+     */\n+    public ToStringBuilder append(double value) {\n+        style.append(buffer, null, value);\n+        return this;\n+    }\n+\n+    /**\n+     * Append to the toString a double value.\n+     *\n+     * @param value  the value to add to the toString\n+     * @param fieldName  the field name\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, double value) {\n+        style.append(buffer, fieldName, value);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append to the toString a float value.\n+     *\n+     * @param value  the value to add to the toString\n+     * @return this\n+     */\n+    public ToStringBuilder append(float value) {\n+        style.append(buffer, null, value);\n+        return this;\n+    }\n+\n+    /**\n+     * Append to the toString a float value.\n+     *\n+     * @param value  the value to add to the toString\n+     * @param fieldName  the field name\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, float value) {\n+        style.append(buffer, fieldName, value);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append to the toString a boolean value.\n+     *\n+     * @param value  the value to add to the toString\n+     * @return this\n+     */\n+    public ToStringBuilder append(boolean value) {\n+        style.append(buffer, null, value);\n+        return this;\n+    }\n+\n+    /**\n+     * Append to the toString a boolean value.\n+     *\n+     * @param value  the value to add to the toString\n+     * @param fieldName  the field name\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, boolean value) {\n+        style.append(buffer, fieldName, value);\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append to the toString an Object array.\n+     *\n+     * @param array  the array to add to the toString\n+     * @param fieldName  the field name\n+     * @return this\n+     */\n+    public ToStringBuilder append(Object[] array) {\n+        style.append(buffer, null, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * Append to the toString an Object array.\n+     *\n+     * @param array  the array to add to the toString\n+     * @param fieldName  the field name\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, Object[] array) {\n+        style.append(buffer, fieldName, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * Append to the toString an Object array.\n+     * <p>\n+     * A boolean parameter controls the level of detail to show. Setting true\n+     * will output the array in full. Setting false will output a summary,\n+     * typically the size of the array.\n+     *\n+     * @param array  the array to add to the toString\n+     * @param fieldName  the field name\n+     * @param fullDetail  true for detail, false for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, Object[] array, boolean fullDetail) {\n+        style.append(buffer, fieldName, array, new Boolean(fullDetail));\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append to the toString a long array.\n+     *\n+     * @param array  the array to add to the toString\n+     * @param fieldName  the field name\n+     * @return this\n+     */\n+    public ToStringBuilder append(long[] array) {\n+        style.append(buffer, null, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * Append a hashCode for a long array.\n+     *\n+     * @param array  the array to add to the hashCode\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, long[] array) {\n+        style.append(buffer, fieldName, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * Append to the toString a long array.\n+     * <p>\n+     * A boolean parameter controls the level of detail to show. Setting true\n+     * will output the array in full. Setting false will output a summary,\n+     * typically the size of the array.\n+     *\n+     * @param array  the array to add to the toString\n+     * @param fieldName  the field name\n+     * @param fullDetail  true for detail, false for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, long[] array, boolean fullDetail) {\n+        style.append(buffer, fieldName, array, new Boolean(fullDetail));\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append to the toString a int array.\n+     *\n+     * @param array  the array to add to the toString\n+     * @param fieldName  the field name\n+     * @return this\n+     */\n+    public ToStringBuilder append(int[] array) {\n+        style.append(buffer, null, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * Append a hashCode for an int array.\n+     *\n+     * @param array  the array to add to the hashCode\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, int[] array) {\n+        style.append(buffer, fieldName, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * Append to the toString an int array.\n+     * <p>\n+     * A boolean parameter controls the level of detail to show. Setting true\n+     * will output the array in full. Setting false will output a summary,\n+     * typically the size of the array.\n+     *\n+     * @param array  the array to add to the toString\n+     * @param fieldName  the field name\n+     * @param fullDetail  true for detail, false for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, int[] array, boolean fullDetail) {\n+        style.append(buffer, fieldName, array, new Boolean(fullDetail));\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append to the toString a short array.\n+     *\n+     * @param array  the array to add to the toString\n+     * @param fieldName  the field name\n+     * @return this\n+     */\n+    public ToStringBuilder append(short[] array) {\n+        style.append(buffer, null, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * Append a hashCode for a short array.\n+     *\n+     * @param array  the array to add to the hashCode\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, short[] array) {\n+        style.append(buffer, fieldName, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * Append to the toString a short array.\n+     * <p>\n+     * A boolean parameter controls the level of detail to show. Setting true\n+     * will output the array in full. Setting false will output a summary,\n+     * typically the size of the array.\n+     *\n+     * @param array  the array to add to the toString\n+     * @param fieldName  the field name\n+     * @param fullDetail  true for detail, false for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, short[] array, boolean fullDetail) {\n+        style.append(buffer, fieldName, array, new Boolean(fullDetail));\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append to the toString a char array.\n+     *\n+     * @param array  the array to add to the toString\n+     * @param fieldName  the field name\n+     * @return this\n+     */\n+    public ToStringBuilder append(char[] array) {\n+        style.append(buffer, null, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * Append a hashCode for a char array.\n+     *\n+     * @param array  the array to add to the hashCode\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, char[] array) {\n+        style.append(buffer, fieldName, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * Append to the toString a char array.\n+     * <p>\n+     * A boolean parameter controls the level of detail to show. Setting true\n+     * will output the array in full. Setting false will output a summary,\n+     * typically the size of the array.\n+     *\n+     * @param array  the array to add to the toString\n+     * @param fieldName  the field name\n+     * @param fullDetail  true for detail, false for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, char[] array, boolean fullDetail) {\n+        style.append(buffer, fieldName, array, new Boolean(fullDetail));\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append to the toString a byte array.\n+     *\n+     * @param array  the array to add to the toString\n+     * @param fieldName  the field name\n+     * @return this\n+     */\n+    public ToStringBuilder append(byte[] array) {\n+        style.append(buffer, null, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * Append a hashCode for a byte array.\n+     *\n+     * @param array  the array to add to the hashCode\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, byte[] array) {\n+        style.append(buffer, fieldName, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * Append to the toString a byte array.\n+     * <p>\n+     * A boolean parameter controls the level of detail to show. Setting true\n+     * will output the array in full. Setting false will output a summary,\n+     * typically the size of the array.\n+     *\n+     * @param array  the array to add to the toString\n+     * @param fieldName  the field name\n+     * @param fullDetail  true for detail, false for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, byte[] array, boolean fullDetail) {\n+        style.append(buffer, fieldName, array, new Boolean(fullDetail));\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append to the toString a double array.\n+     *\n+     * @param array  the array to add to the toString\n+     * @param fieldName  the field name\n+     * @return this\n+     */\n+    public ToStringBuilder append(double[] array) {\n+        style.append(buffer, null, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * Append a hashCode for a double array.\n+     *\n+     * @param array  the array to add to the hashCode\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, double[] array) {\n+        style.append(buffer, fieldName, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * Append to the toString a double array.\n+     * <p>\n+     * A boolean parameter controls the level of detail to show. Setting true\n+     * will output the array in full. Setting false will output a summary,\n+     * typically the size of the array.\n+     *\n+     * @param array  the array to add to the toString\n+     * @param fieldName  the field name\n+     * @param fullDetail  true for detail, false for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, double[] array, boolean fullDetail) {\n+        style.append(buffer, fieldName, array, new Boolean(fullDetail));\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append to the toString a float array.\n+     *\n+     * @param array  the array to add to the toString\n+     * @param fieldName  the field name\n+     * @return this\n+     */\n+    public ToStringBuilder append(float[] array) {\n+        style.append(buffer, null, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * Append a hashCode for a float array.\n+     *\n+     * @param array  the array to add to the hashCode\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, float[] array) {\n+        style.append(buffer, fieldName, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * Append to the toString a float array.\n+     * <p>\n+     * A boolean parameter controls the level of detail to show. Setting true\n+     * will output the array in full. Setting false will output a summary,\n+     * typically the size of the array.\n+     *\n+     * @param array  the array to add to the toString\n+     * @param fieldName  the field name\n+     * @param fullDetail  true for detail, false for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, float[] array, boolean fullDetail) {\n+        style.append(buffer, fieldName, array, new Boolean(fullDetail));\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append to the toString a boolean array.\n+     *\n+     * @param array  the array to add to the toString\n+     * @param fieldName  the field name\n+     * @return this\n+     */\n+    public ToStringBuilder append(boolean[] array) {\n+        style.append(buffer, null, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * Append a hashCode for a boolean array.\n+     *\n+     * @param array  the array to add to the hashCode\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, boolean[] array) {\n+        style.append(buffer, fieldName, array, null);\n+        return this;\n+    }\n+\n+    /**\n+     * Append to the toString a boolean array.\n+     * <p>\n+     * A boolean parameter controls the level of detail to show. Setting true\n+     * will output the array in full. Setting false will output a summary,\n+     * typically the size of the array.\n+     *\n+     * @param array  the array to add to the toString\n+     * @param fieldName  the field name\n+     * @param fullDetail  true for detail, false for summary info\n+     * @return this\n+     */\n+    public ToStringBuilder append(String fieldName, boolean[] array, boolean fullDetail) {\n+        style.append(buffer, fieldName, array, new Boolean(fullDetail));\n+        return this;\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Gets the buffer being populated\n+     * \n+     * @return the StringBuffer being populated\n+     */    \n+    public StringBuffer getStringBuffer() {\n+        return buffer;\n+    }\n+\n+    /**\n+     * Returns the built toString\n+     * \n+     * @return the String toString\n+     */    \n+    public String toString() {\n+        style.appendEnd(buffer, object);\n+        return buffer.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/builder/ToStringStyle.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+// package org.apache.commons.lang.builder\n+\n+package org.apache.commons.lang.builder;\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Map;\n+\n+import org.apache.commons.lang.SystemUtils;\n+/**\n+ * <code>ToStringStyle</code> works with ToStringBuilder to create a\n+ * toString.\n+ * <p>\n+ * These classes are intended to be used as singletons. There is no need \n+ * to instantiate a new style each time. A prohram will generally use one\n+ * of the predefined constants on this class. Alternatively, the \n+ * {@link StandardToStringStyle} class can be used to set the individual\n+ * settings.\n+ * <P>\n+ * If necessary, this class can be subclassed to provide specific toString\n+ * designs. The main public interface is always via ToStringBuilder however.\n+ *\n+ * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n+ * @version $Id: ToStringStyle.java,v 1.1 2002/09/17 22:07:20 scolebourne Exp $\n+ */\n+public abstract class ToStringStyle implements Serializable {\n+    \n+    /**\n+     * The default toString style.\n+     */\n+    public static final ToStringStyle DEFAULT_STYLE = new DefaultToStringStyle();\n+    /**\n+     * The multi line toString style.\n+     */\n+    public static final ToStringStyle MULTI_LINE_STYLE = new MultiLineToStringStyle();\n+    /**\n+     * The no field names toString style.\n+     */\n+    public static final ToStringStyle NO_FIELD_NAMES_STYLE = new NoFieldNameToStringStyle();\n+    /**\n+     * The simple toString style.\n+     */\n+    public static final ToStringStyle SIMPLE_STYLE = new SimpleToStringStyle();\n+\n+    /**\n+     * Whether to use the field names 'true'\n+     */\n+    protected boolean useFieldNames = true;\n+    /**\n+     * Whether to use the class name 'true'\n+     */\n+    protected boolean useClassName = true;\n+    /**\n+     * Whether to use short class names 'false'\n+     */\n+    protected boolean useShortClassName = false;\n+    /**\n+     * Whether to use the identity hash code 'true'\n+     */\n+    protected boolean useIdentityHashCode = true;\n+    \n+    /**\n+     * The content start '['\n+     */\n+    protected String contentStart = \"[\";\n+    /**\n+     * The content end ']'\n+     */\n+    protected String contentEnd = \"]\";\n+    /**\n+     * The field name value separator '='\n+     */\n+    protected String fieldNameValueSeparator = \"=\";\n+    /**\n+     * The field separator ','\n+     */\n+    protected String fieldSeparator = \",\";\n+    /**\n+     * The array start '{'\n+     */\n+    protected String arrayStart = \"{\";\n+    /**\n+     * The array separator ','\n+     */\n+    protected String arraySeparator = \",\";\n+    /**\n+     * The detail for array content\n+     */\n+    protected boolean arrayContentDetail = true;\n+    /**\n+     * The array end '}'\n+     */\n+    protected String arrayEnd = \"}\";\n+    /**\n+     * The value to use when fullDetail is null 'true'\n+     */\n+    protected boolean defaultFullDetail = true;\n+    /**\n+     * The null text '<null>'\n+     */\n+    protected String nullText = \"<null>\";\n+    /**\n+     * The summary size text start '<size'\n+     */\n+    protected String sizeStartText = \"<size=\";\n+    /**\n+     * The summary size text start '>'\n+     */\n+    protected String sizeEndText = \">\";\n+    /**\n+     * The summary object text start '<'\n+     */\n+    protected String summaryObjectStartText = \"<\";\n+    /**\n+     * The summary object text start '>'\n+     */\n+    protected String summaryObjectEndText = \">\";\n+    \n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Constructor.\n+     */\n+    protected ToStringStyle() {\n+        super();\n+    }\n+    \n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append the start of data indicator.\n+     * \n+     * @param buffer  the StringBuffer to populate\n+     * @param object  the object to build a toString for, must not be null\n+     */\n+    public void appendStart(StringBuffer buffer, Object object) {\n+        appendClassName(buffer, object);\n+        appendIdentityHashCode(buffer, object);\n+        appendContentStart(buffer);\n+    }\n+\n+    /**\n+     * Append the end of data indicator.\n+     * \n+     * @param buffer  the StringBuffer to populate\n+     * @param object  the object to build a toString for, must not be null\n+     */\n+    public void appendEnd(StringBuffer buffer, Object object) {\n+        appendContentEnd(buffer);\n+    }\n+    \n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append to the toString an Object value, printing the full \n+     * toString of the object passed in.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the toString\n+     * @param fullDetail  true for detail, false for summary info, null for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, Object value, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+        \n+        if (value == null) {\n+            appendNullText(buffer, fieldName);\n+            \n+        } else {\n+            appendInternal(buffer, fieldName, value, isFullDetail(fullDetail));\n+        }\n+        \n+        appendFieldEnd(buffer, fieldName);\n+    }\n+    \n+    /**\n+     * Append to the toString an Object, correctly interpretting its type.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the toString, not null\n+     * @param detail  output detail or not\n+     */\n+    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n+        if (value instanceof Collection) {\n+            if (detail) {\n+                appendDetail(buffer, fieldName, (Collection) value);\n+            } else {\n+                appendSummarySize(buffer, fieldName, ((Collection) value).size());\n+            }\n+            \n+        } else if (value instanceof Map) {\n+            if (detail) {\n+                appendDetail(buffer, fieldName, (Map) value);\n+            } else {\n+                appendSummarySize(buffer, fieldName, ((Map) value).size());\n+            }\n+            \n+        } else if (value instanceof long[]) {\n+            if (detail) {\n+                appendDetail(buffer, fieldName, (long[]) value);\n+            } else {\n+                appendSummary(buffer, fieldName, (long[]) value);\n+            }\n+            \n+        } else if (value instanceof int[]) {\n+            if (detail) {\n+                appendDetail(buffer, fieldName, (int[]) value);\n+            } else {\n+                appendSummary(buffer, fieldName, (int[]) value);\n+            }\n+            \n+        } else if (value instanceof short[]) {\n+            if (detail) {\n+                appendDetail(buffer, fieldName, (short[]) value);\n+            } else {\n+                appendSummary(buffer, fieldName, (short[]) value);\n+            }\n+            \n+        } else if (value instanceof byte[]) {\n+            if (detail) {\n+                appendDetail(buffer, fieldName, (byte[]) value);\n+            } else {\n+                appendSummary(buffer, fieldName, (byte[]) value);\n+            }\n+            \n+        } else if (value instanceof char[]) {\n+            if (detail) {\n+                appendDetail(buffer, fieldName, (char[]) value);\n+            } else {\n+                appendSummary(buffer, fieldName, (char[]) value);\n+            }\n+            \n+        } else if (value instanceof double[]) {\n+            if (detail) {\n+                appendDetail(buffer, fieldName, (double[]) value);\n+            } else {\n+                appendSummary(buffer, fieldName, (double[]) value);\n+            }\n+            \n+        } else if (value instanceof float[]) {\n+            if (detail) {\n+                appendDetail(buffer, fieldName, (float[]) value);\n+            } else {\n+                appendSummary(buffer, fieldName, (float[]) value);\n+            }\n+            \n+        } else if (value instanceof boolean[]) {\n+            if (detail) {\n+                appendDetail(buffer, fieldName, (boolean[]) value);\n+            } else {\n+                appendSummary(buffer, fieldName, (boolean[]) value);\n+            }\n+        \n+        } else if (value.getClass().isArray()) {\n+            if (detail) {\n+                appendDetail(buffer, fieldName, (Object[]) value);\n+            } else {\n+                appendSummary(buffer, fieldName, (Object[]) value);\n+            }\n+            \n+        } else {\n+            if (detail) {\n+                appendDetail(buffer, fieldName, (Object) value);\n+            } else {\n+                appendSummary(buffer, fieldName, (Object) value);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Append to the toString an Object value, printing the full detail of the object.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the toString, not null\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, Object value) {\n+        buffer.append(value);\n+    }\n+    \n+    /**\n+     * Append to the toString a Collection.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param coll  the collection to add to the toString, not null\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, Collection coll) {\n+        buffer.append(coll);\n+    }\n+    \n+    /**\n+     * Append to the toString a Map.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param map  the maps to add to the toString, not null\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, Map map) {\n+        buffer.append(map);\n+    }\n+    \n+    /**\n+     * Append to the toString an Object value, printing a summary of the object.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the toString, not null\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, Object value) {\n+        buffer.append(summaryObjectStartText);\n+        buffer.append(getShortClassName(value.getClass()));\n+        buffer.append(summaryObjectEndText);\n+    }\n+    \n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append to the toString a long value.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the toString\n+     */\n+    public void append(StringBuffer buffer, String fieldName, long value) {\n+        appendFieldStart(buffer, fieldName);\n+        appendDetail(buffer, fieldName, value);\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * Append to the toString a long value.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the toString\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, long value) {\n+        buffer.append(value);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append to the toString an int value.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the toString\n+     */\n+    public void append(StringBuffer buffer, String fieldName, int value) {\n+        appendFieldStart(buffer, fieldName);\n+        appendDetail(buffer, fieldName, value);\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * Append to the toString an int value.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the toString\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, int value) {\n+        buffer.append(value);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append to the toString a short value.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the toString\n+     */\n+    public void append(StringBuffer buffer, String fieldName, short value) {\n+        appendFieldStart(buffer, fieldName);\n+        appendDetail(buffer, fieldName, value);\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * Append to the toString a short value.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the toString\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, short value) {\n+        buffer.append(value);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append to the toString a byte value.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the toString\n+     */\n+    public void append(StringBuffer buffer, String fieldName, byte value) {\n+        appendFieldStart(buffer, fieldName);\n+        appendDetail(buffer, fieldName, value);\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * Append to the toString a byte value.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the toString\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, byte value) {\n+        buffer.append(value);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append to the toString a char value.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the toString\n+     */\n+    public void append(StringBuffer buffer, String fieldName, char value) {\n+        appendFieldStart(buffer, fieldName);\n+        appendDetail(buffer, fieldName, value);\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * Append to the toString a char value.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the toString\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, char value) {\n+        buffer.append(value);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append to the toString a double value.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the toString\n+     */\n+    public void append(StringBuffer buffer, String fieldName, double value) {\n+        appendFieldStart(buffer, fieldName);\n+        appendDetail(buffer, fieldName, value);\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * Append to the toString a double value.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the toString\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, double value) {\n+        buffer.append(value);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append to the toString a float value.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the toString\n+     */\n+    public void append(StringBuffer buffer, String fieldName, float value) {\n+        appendFieldStart(buffer, fieldName);\n+        appendDetail(buffer, fieldName, value);\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * Append to the toString a float value.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the toString\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, float value) {\n+        buffer.append(value);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append to the toString a boolean value.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name\n+     * @param value  the value to add to the toString\n+     */\n+    public void append(StringBuffer buffer, String fieldName, boolean value) {\n+        appendFieldStart(buffer, fieldName);\n+        appendDetail(buffer, fieldName, value);\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * Append to the toString a boolean value.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param value  the value to add to the toString\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, boolean value) {\n+        buffer.append(value);\n+    }\n+\n+    /**\n+     * Append to the toString an Object array.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the toString\n+     * @param fullDetail  true for detail, false for summary info, null for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, Object[] array, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+        \n+        if (array == null) {\n+            appendNullText(buffer, fieldName);\n+            \n+        } else if (isFullDetail(fullDetail)) {\n+            appendDetail(buffer, fieldName, array);\n+            \n+        } else {\n+            appendSummary(buffer, fieldName, array);\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append to the toString the detail of an Object array.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the toString, not null\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, Object[] array) {\n+        buffer.append(arrayStart);\n+        for (int i = 0; i < array.length; i++) {\n+            Object item = array[i];\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            if (item == null) {\n+                appendNullText(buffer, fieldName);\n+                \n+            } else {\n+                appendInternal(buffer, fieldName, item, arrayContentDetail);\n+            }\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * Append to the toString a summary of an Object array.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the toString, not null\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, Object[] array) {\n+        appendSummarySize(buffer, fieldName, array.length);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append to the toString a long array.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the toString\n+     * @param fullDetail  true for detail, false for summary info, null for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, long[] array, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+        \n+        if (array == null) {\n+            appendNullText(buffer, fieldName);\n+            \n+        } else if (isFullDetail(fullDetail)) {\n+            appendDetail(buffer, fieldName, array);\n+            \n+        } else {\n+            appendSummary(buffer, fieldName, array);\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * Append to the toString the detail of a long array.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the toString, not null\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, long[] array) {\n+        buffer.append(arrayStart);\n+        for (int i = 0; i < array.length; i++) {\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            appendDetail(buffer, fieldName, array[i]);\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * Append to the toString a summary of a long array.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the toString, not null\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, long[] array) {\n+        appendSummarySize(buffer, fieldName, array.length);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append to the toString an int array.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the toString\n+     * @param fullDetail  true for detail, false for summary info, null for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, int[] array, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+        \n+        if (array == null) {\n+            appendNullText(buffer, fieldName);\n+            \n+        } else if (isFullDetail(fullDetail)) {\n+            appendDetail(buffer, fieldName, array);\n+            \n+        } else {\n+            appendSummary(buffer, fieldName, array);\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * Append to the toString the detail of an int array.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the toString, not null\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, int[] array) {\n+        buffer.append(arrayStart);\n+        for (int i = 0; i < array.length; i++) {\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            appendDetail(buffer, fieldName, array[i]);\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * Append to the toString a summary of an int array.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the toString, not null\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, int[] array) {\n+        appendSummarySize(buffer, fieldName, array.length);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append to the toString a short array.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the toString\n+     * @param fullDetail  true for detail, false for summary info, null for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, short[] array, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+        \n+        if (array == null) {\n+            appendNullText(buffer, fieldName);\n+            \n+        } else if (isFullDetail(fullDetail)) {\n+            appendDetail(buffer, fieldName, array);\n+            \n+        } else {\n+            appendSummary(buffer, fieldName, array);\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * Append to the toString the detail of a short array.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the toString, not null\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, short[] array) {\n+        buffer.append(arrayStart);\n+        for (int i = 0; i < array.length; i++) {\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            appendDetail(buffer, fieldName, array[i]);\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * Append to the toString a summary of a short array.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the toString, not null\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, short[] array) {\n+        appendSummarySize(buffer, fieldName, array.length);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append to the toString a byte array.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the toString\n+     * @param fullDetail  true for detail, false for summary info, null for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, byte[] array, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+        \n+        if (array == null) {\n+            appendNullText(buffer, fieldName);\n+            \n+        } else if (isFullDetail(fullDetail)) {\n+            appendDetail(buffer, fieldName, array);\n+            \n+        } else {\n+            appendSummary(buffer, fieldName, array);\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * Append to the toString the detail of a byte array.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the toString, not null\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, byte[] array) {\n+        buffer.append(arrayStart);\n+        for (int i = 0; i < array.length; i++) {\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            appendDetail(buffer, fieldName, array[i]);\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * Append to the toString a summary of a byte array.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the toString, not null\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, byte[] array) {\n+        appendSummarySize(buffer, fieldName, array.length);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append to the toString a char array.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the toString\n+     * @param fullDetail  true for detail, false for summary info, null for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, char[] array, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+        \n+        if (array == null) {\n+            appendNullText(buffer, fieldName);\n+            \n+        } else if (isFullDetail(fullDetail)) {\n+            appendDetail(buffer, fieldName, array);\n+            \n+        } else {\n+            appendSummary(buffer, fieldName, array);\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * Append to the toString the detail of a char array.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the toString, not null\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, char[] array) {\n+        buffer.append(arrayStart);\n+        for (int i = 0; i < array.length; i++) {\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            appendDetail(buffer, fieldName, array[i]);\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * Append to the toString a summary of a char array.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the toString, not null\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, char[] array) {\n+        appendSummarySize(buffer, fieldName, array.length);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append to the toString a double array.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the toString\n+     * @param fullDetail  true for detail, false for summary info, null for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, double[] array, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+        \n+        if (array == null) {\n+            appendNullText(buffer, fieldName);\n+            \n+        } else if (isFullDetail(fullDetail)) {\n+            appendDetail(buffer, fieldName, array);\n+            \n+        } else {\n+            appendSummary(buffer, fieldName, array);\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * Append to the toString the detail of a double array.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the toString, not null\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, double[] array) {\n+        buffer.append(arrayStart);\n+        for (int i = 0; i < array.length; i++) {\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            appendDetail(buffer, fieldName, array[i]);\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * Append to the toString a summary of a double array.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the toString, not null\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, double[] array) {\n+        appendSummarySize(buffer, fieldName, array.length);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append to the toString a float array.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the toString\n+     * @param fullDetail  true for detail, false for summary info, null for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, float[] array, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+        \n+        if (array == null) {\n+            appendNullText(buffer, fieldName);\n+            \n+        } else if (isFullDetail(fullDetail)) {\n+            appendDetail(buffer, fieldName, array);\n+            \n+        } else {\n+            appendSummary(buffer, fieldName, array);\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * Append to the toString the detail of a float array.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the toString, not null\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, float[] array) {\n+        buffer.append(arrayStart);\n+        for (int i = 0; i < array.length; i++) {\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            appendDetail(buffer, fieldName, array[i]);\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * Append to the toString a summary of a float array.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the toString, not null\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, float[] array) {\n+        appendSummarySize(buffer, fieldName, array.length);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append to the toString a boolean array.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name\n+     * @param array  the array to add to the toString\n+     * @param fullDetail  true for detail, false for summary info, null for style decides\n+     */\n+    public void append(StringBuffer buffer, String fieldName, boolean[] array, Boolean fullDetail) {\n+        appendFieldStart(buffer, fieldName);\n+        \n+        if (array == null) {\n+            appendNullText(buffer, fieldName);\n+            \n+        } else if (isFullDetail(fullDetail)) {\n+            appendDetail(buffer, fieldName, array);\n+            \n+        } else {\n+            appendSummary(buffer, fieldName, array);\n+        }\n+\n+        appendFieldEnd(buffer, fieldName);\n+    }\n+\n+    /**\n+     * Append to the toString the detail of a boolean array.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the toString, not null\n+     */\n+    protected void appendDetail(StringBuffer buffer, String fieldName, boolean[] array) {\n+        buffer.append(arrayStart);\n+        for (int i = 0; i < array.length; i++) {\n+            if (i > 0) {\n+                buffer.append(arraySeparator);\n+            }\n+            appendDetail(buffer, fieldName, array[i]);\n+        }\n+        buffer.append(arrayEnd);\n+    }\n+\n+    /**\n+     * Append to the toString a summary of a boolean array.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param array  the array to add to the toString, not null\n+     */\n+    protected void appendSummary(StringBuffer buffer, String fieldName, boolean[] array) {\n+        appendSummarySize(buffer, fieldName, array.length);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Append the class name.\n+     * \n+     * @param object  the object whose name to output\n+     */\n+    protected void appendClassName(StringBuffer buffer, Object object) {\n+        if (useClassName) {\n+            if (useShortClassName) {\n+                buffer.append(getShortClassName(object.getClass()));\n+            } else {\n+                buffer.append(object.getClass().getName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Append the IdentityHashCode.\n+     * \n+     * @param object  the object whose id to output\n+     */\n+    protected void appendIdentityHashCode(StringBuffer buffer, Object object) {\n+        if (useIdentityHashCode) {\n+            buffer.append('@');\n+            buffer.append(Integer.toHexString(System.identityHashCode(object)));\n+        }\n+    }\n+\n+    /**\n+     * Append the content start to the buffer.\n+     * \n+     * @param buffer  the StringBuffer to populate\n+     */\n+    protected void appendContentStart(StringBuffer buffer) {\n+        buffer.append(contentStart);\n+    }\n+    \n+    /**\n+     * Append the content end to the buffer.\n+     * \n+     * @param buffer  the StringBuffer to populate\n+     */\n+    protected void appendContentEnd(StringBuffer buffer) {\n+        int len = buffer.length();\n+        int sepLen = fieldSeparator.length();\n+        if (len > 0 && sepLen > 0 && len >= sepLen && buffer.charAt(len - 1) == fieldSeparator.charAt(sepLen - 1)) {\n+            buffer.setLength(len - sepLen);\n+        }\n+        buffer.append(contentEnd);\n+    }\n+    \n+    /**\n+     * Append an indicator for null to the buffer.\n+     * Default output is '<null>'.\n+     * \n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     */\n+    protected void appendNullText(StringBuffer buffer, String fieldName) {\n+        buffer.append(nullText);\n+    }\n+    \n+    /**\n+     * Append the field separator to the buffer.\n+     * \n+     * @param buffer  the StringBuffer to populate\n+     */\n+    protected void appendFieldSeparator(StringBuffer buffer) {\n+        buffer.append(fieldSeparator);\n+    }\n+    \n+    /**\n+     * Append the field start to the buffer.\n+     * \n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name\n+     */\n+    protected void appendFieldStart(StringBuffer buffer, String fieldName) {\n+        if (useFieldNames && fieldName != null) {\n+            buffer.append(fieldName);\n+            buffer.append(fieldNameValueSeparator);\n+        }\n+    }\n+    \n+    /**\n+     * Append the field end to the buffer.\n+     * \n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     */\n+    protected void appendFieldEnd(StringBuffer buffer, String fieldName) {\n+        appendFieldSeparator(buffer);\n+    }\n+    \n+    /**\n+     * Append to the toString a size summary.\n+     *\n+     * @param buffer  the StringBuffer to populate\n+     * @param fieldName  the field name, typically not used as already appended\n+     * @param size  the size to append\n+     */\n+    protected void appendSummarySize(StringBuffer buffer, String fieldName, int size) {\n+        buffer.append(sizeStartText);\n+        buffer.append(size);\n+        buffer.append(sizeEndText);\n+    }\n+\n+    /**\n+     * Is this field to be output in full detail.\n+     * \n+     * @param fullDetail  the detail level requested\n+     * @return whether full detail is to be shown\n+     */\n+    protected boolean isFullDetail(Boolean fullDetailRequest) {\n+        if (fullDetailRequest == null) {\n+            return defaultFullDetail;\n+        }\n+        return fullDetailRequest.booleanValue();\n+    }\n+    \n+    /**\n+     * Gets the short class name for a class.\n+     *\n+     * @param cls  the class to get the short name of\n+     * @return the short name\n+     */\n+    protected String getShortClassName(Class cls) {\n+        String name = cls.getName();\n+        int pos = name.lastIndexOf('.');\n+        if (pos == -1) {\n+            return name;\n+        }\n+        return name.substring(pos + 1);\n+    }\n+\n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * Default ToStringStyle.\n+     * This is an inner class rather than using StandardToStringStyle to\n+     * ensure its immutability.\n+     */\n+    private static class DefaultToStringStyle extends ToStringStyle {\n+        \n+        /**\n+         * Constructor - use the static constant rather than instantiating.\n+         */\n+        private DefaultToStringStyle() {\n+            super();\n+        }\n+        \n+        /**\n+         * Ensure singleton after serialization.\n+         */\n+        private Object readResolve() {\n+            return ToStringStyle.DEFAULT_STYLE;\n+        }\n+        \n+    }\n+    \n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * ToStringStyle that does not print out the field names.\n+     * This is an inner class rather than using StandardToStringStyle to\n+     * ensure its immutability.\n+     */\n+    private static class NoFieldNameToStringStyle extends ToStringStyle {\n+        \n+        /**\n+         * Constructor - use the static constant rather than instantiating.\n+         */\n+        private NoFieldNameToStringStyle() {\n+            super();\n+            useFieldNames = false;\n+        }\n+        \n+        /**\n+         * Ensure singleton after serialization.\n+         */\n+        private Object readResolve() {\n+            return ToStringStyle.NO_FIELD_NAMES_STYLE;\n+        }\n+        \n+    }\n+    \n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * ToStringStyle that does not print out the classname, identity hashcode,\n+     * content start or field name.\n+     * This is an inner class rather than using StandardToStringStyle to\n+     * ensure its immutability.\n+     */\n+    private static class SimpleToStringStyle extends ToStringStyle {\n+        \n+        /**\n+         * Constructor - use the static constant rather than instantiating.\n+         */\n+        private SimpleToStringStyle() {\n+            super();\n+            useClassName = false;\n+            useIdentityHashCode = false;\n+            useFieldNames = false;\n+            contentStart = \"\";\n+            contentEnd = \"\";\n+        }\n+        \n+        /**\n+         * Ensure singleton after serialization.\n+         */\n+        private Object readResolve() {\n+            return ToStringStyle.SIMPLE_STYLE;\n+        }\n+        \n+    }\n+    \n+    //----------------------------------------------------------------------------\n+    \n+    /**\n+     * ToStringStyle that outputs on multiple lines.\n+     * This is an inner class rather than using StandardToStringStyle to\n+     * ensure its immutability.\n+     */\n+    private static class MultiLineToStringStyle extends ToStringStyle {\n+\n+        /**\n+         * Constructor - use the static constant rather than instantiating.\n+         */\n+        private MultiLineToStringStyle() {\n+            super();\n+            contentStart = \"[\" + SystemUtils.LINE_SEPARATOR + \"  \";\n+            fieldSeparator = SystemUtils.LINE_SEPARATOR + \"  \";\n+            contentEnd = SystemUtils.LINE_SEPARATOR + \"]\";\n+        }\n+        \n+        /**\n+         * Ensure singleton after serialization.\n+         */\n+        private Object readResolve() {\n+            return ToStringStyle.MULTI_LINE_STYLE;\n+        }\n+        \n+    }\n+    \n+    //----------------------------------------------------------------------------\n+    \n+    // Removed, as the XML style needs more work for escaping characters, arrays,\n+    // collections, maps and embedded beans.\n+//    /**\n+//     * ToStringStyle that outputs in XML style\n+//     */\n+//    private static class XMLToStringStyle extends ToStringStyle {\n+//        \n+//        /**\n+//         * Constructor - use the static constant rather than instantiating.\n+//         */\n+//        private XMLToStringStyle() {\n+//            super();\n+//            nullText = \"null\";\n+//            sizeStartText = \"size=\";\n+//            sizeEndText = \"\";\n+//        }\n+//        \n+//        /**\n+//         * @see ToStringStyle#appendStart(StringBuffer, Object)\n+//         */\n+//        public void appendStart(StringBuffer buffer, Object object) {\n+//            buffer.append('<');\n+//            buffer.append(getShortClassName(object.getClass()));\n+//            buffer.append(\" class=\\\"\");\n+//            appendClassName(buffer, object);\n+//            buffer.append(\"\\\" hashCode=\\\"\");\n+//            appendIdentityHashCode(buffer, object);\n+//            buffer.append(\"\\\">\");\n+//            buffer.append(SystemUtils.LINE_SEPARATOR);\n+//            buffer.append(\"  \");\n+//        }\n+//\n+//        /**\n+//         * @see ToStringStyle#appendFieldStart(StringBuffer, String)\n+//         */\n+//        protected void appendFieldStart(StringBuffer buffer, String fieldName) {\n+//            buffer.append('<');\n+//            buffer.append(fieldName);\n+//            buffer.append('>');\n+//        }\n+//\n+//        /**\n+//         * @see ToStringStyle#appendFieldEnd(StringBuffer, String)\n+//         */\n+//        protected void appendFieldEnd(StringBuffer buffer, String fieldName) {\n+//            buffer.append(\"</\");\n+//            buffer.append(fieldName);\n+//            buffer.append('>');\n+//            buffer.append(SystemUtils.LINE_SEPARATOR);\n+//            buffer.append(\"  \");\n+//        }\n+//\n+//        /**\n+//         * @see ToStringStyle#appendEnd(StringBuffer, Object)\n+//         */\n+//        public void appendEnd(StringBuffer buffer, Object object) {\n+//            int len = buffer.length();\n+//            if (len > 2 && buffer.charAt(len - 1) == ' ' && buffer.charAt(len - 2) == ' ') {\n+//                buffer.setLength(len - 2);\n+//            }\n+//            buffer.append(\"</\");\n+//            buffer.append(getShortClassName(object.getClass()));\n+//            buffer.append(\"\\\">\");\n+//        }\n+//\n+//    }\n+    \n+}", "timestamp": 1032300440, "metainfo": ""}