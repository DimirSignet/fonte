{"sha": "ded14eeed550904c548d0d9d1a887a288f236e64", "log": "DurationFormatUtils implemented in a java.text.Format like way with a pattern language for specifying exactly how the format wants to appear. The two existing methods are reimplemented in terms of the new format method but the new method currently lacks its own unit tests.   ", "commit": "\n--- a/src/java/org/apache/commons/lang/time/DateUtils.java\n+++ b/src/java/org/apache/commons/lang/time/DateUtils.java\n  * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n  * @author Phil Steitz\n  * @since 2.0\n- * @version $Id: DateUtils.java,v 1.23 2004/07/12 00:04:32 stevencaswell Exp $\n+ * @version $Id: DateUtils.java,v 1.24 2004/08/27 06:45:25 bayard Exp $\n  */\n public class DateUtils {\n     \n      * Number of milliseconds in a standard day.\n      */\n     public static final long MILLIS_PER_DAY = 24 * 60 * 60 * 1000;\n+\n+    // hmm. not very accurate. used by DurationFormatUtils\n+    static final long MILLIS_PER_YEAR = 365 * 24 * 60 * 60 * 1000;\n+    static final long MILLIS_PER_MONTH = 365 / 12 * 24 * 60 * 60 * 1000;\n \n     /**\n      * This is half a month, so this represents whether a date is in the top\n--- a/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n+++ b/src/java/org/apache/commons/lang/time/DurationFormatUtils.java\n  */\n package org.apache.commons.lang.time;\n \n+import org.apache.commons.lang.ArrayUtils;\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.commons.lang.mutable.MutableInt;\n+\n /**\n  * <p>Duration formatting utilities and constants.</p>\n  *\n  * @author Stephen Colebourne\n  * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n  * @since 2.0\n- * @version $Id: DurationFormatUtils.java,v 1.10 2004/08/02 02:16:21 bayard Exp $\n+ * @version $Id: DurationFormatUtils.java,v 1.11 2004/08/27 06:45:25 bayard Exp $\n  */\n-class DurationFormatUtils {\n-    // TODO: Make class public once methods can fully select which fields to output\n+public class DurationFormatUtils {\n+\n+    /**\n+     * <p>DurationFormatUtils instances should NOT be constructed in standard programming.</p>\n+     *\n+     * <p>This constructor is public to permit tools that require a JavaBean instance\n+     * to operate.</p>\n+     */\n+    public DurationFormatUtils() {\n+    }\n \n     /**\n      * <p>Pattern used with <code>FastDateFormat</code> and <code>SimpleDateFormat</code> for the ISO8601 \n      * <p>Get the time gap as a string.</p>\n      * \n      * <p>The format used is ISO8601-like:\n-     * <i>hours</i>:<i>minutes</i>:<i>seconds</i>.<i>milliseconds</i>.</p>\n+     * <i>H</i>:<i>m</i>:<i>s</i>.<i>S</i>.</p>\n      * \n      * @param millis  the duration to format\n      * @return the time as a String\n      */\n     public static String formatISO(long millis) {\n-        int hours, minutes, seconds, milliseconds;\n-        hours = (int) (millis / DateUtils.MILLIS_PER_HOUR);\n-        millis = millis - (hours * DateUtils.MILLIS_PER_HOUR);\n-        minutes = (int) (millis / DateUtils.MILLIS_PER_MINUTE);\n-        millis = millis - (minutes * DateUtils.MILLIS_PER_MINUTE);\n-        seconds = (int) (millis / DateUtils.MILLIS_PER_SECOND);\n-        millis = millis - (seconds * DateUtils.MILLIS_PER_SECOND);\n-        milliseconds = (int) millis;\n-\n-        StringBuffer buf = new StringBuffer(32);\n-        buf.append(hours);\n-        buf.append(':');\n-        buf.append((char) (minutes / 10 + '0'));\n-        buf.append((char) (minutes % 10 + '0'));\n-        buf.append(':');\n-        buf.append((char) (seconds / 10 + '0'));\n-        buf.append((char) (seconds % 10 + '0'));\n-        buf.append('.');\n-        if (milliseconds < 10) {\n-            buf.append('0').append('0');\n-        } else if (milliseconds < 100) {\n-            buf.append('0');\n-        }\n-        buf.append(milliseconds);\n-        return buf.toString();\n+        return format(millis, \"H:mm:ss.SSS\");\n+    }\n+    /**\n+     * <p>Get the time gap as a string, using the specified format.</p>\n+     * <table border=\"1\">\n+     *  <tr><th>character</th><th>duration element</th></tr>\n+     *  <tr><td>y</td><td>years (aka 365 days)</td></tr>\n+     *  <tr><td>M</td><td>months (aka year/12)</td></tr>\n+     *  <tr><td>d</td><td>days</td></tr>\n+     *  <tr><td>H</td><td>hours</td></tr>\n+     *  <tr><td>m</td><td>minutes</td></tr>\n+     *  <tr><td>s</td><td>seconds</td></tr>\n+     *  <tr><td>S</td><td>milliseconds</td></tr>\n+     * </table>\n+     * \n+     * @param millis  the duration to format\n+     * @param format  the way iin which to format the duration\n+     * @return the time as a String\n+     */\n+    public static String format(long millis, String format) {\n+        StringBuffer buffer = new StringBuffer();\n+        Token[] tokens = lexx(format);\n+        int sz = tokens.length;\n+\n+        int years        = 0;\n+        int months       = 0;\n+        int days         = 0;\n+        int hours        = 0;\n+        int minutes      = 0;\n+        int seconds      = 0;\n+        int milliseconds = 0;\n+\n+        if(Token.containsTokenWithValue(tokens, y) ) {\n+            years = (int) (millis / DateUtils.MILLIS_PER_YEAR);\n+            millis = millis - (years * DateUtils.MILLIS_PER_YEAR);\n+        }\n+        if(Token.containsTokenWithValue(tokens, M) ) {\n+            months = (int) (millis / DateUtils.MILLIS_PER_MONTH);\n+            millis = millis - (months * DateUtils.MILLIS_PER_MONTH);\n+        }\n+        if(Token.containsTokenWithValue(tokens, d) ) {\n+            days = (int) (millis / DateUtils.MILLIS_PER_DAY);\n+            millis = millis - (days * DateUtils.MILLIS_PER_DAY);\n+        }\n+        if(Token.containsTokenWithValue(tokens, H) ) {\n+            hours = (int) (millis / DateUtils.MILLIS_PER_HOUR);\n+            millis = millis - (hours * DateUtils.MILLIS_PER_HOUR);\n+        }\n+        if(Token.containsTokenWithValue(tokens, m) ) {\n+            minutes = (int) (millis / DateUtils.MILLIS_PER_MINUTE);\n+            millis = millis - (minutes * DateUtils.MILLIS_PER_MINUTE);\n+        }\n+        if(Token.containsTokenWithValue(tokens, s) ) {\n+            seconds = (int) (millis / DateUtils.MILLIS_PER_SECOND);\n+            millis = millis - (seconds * DateUtils.MILLIS_PER_SECOND);\n+        }\n+        if(Token.containsTokenWithValue(tokens, S) ) {\n+            milliseconds = (int) millis;\n+        }\n+\n+\n+        for(int i=0; i<sz; i++) {\n+            Token token = tokens[i];\n+            Object value = token.getValue();\n+            int count = token.getCount();\n+            if(value instanceof StringBuffer) {\n+                buffer.append(value.toString());\n+            } else {\n+                if(value == y) {\n+                    buffer.append( StringUtils.leftPad(\"\"+years, count, \"0\") ); \n+                } else\n+                if(value == M) {\n+                    buffer.append( StringUtils.leftPad(\"\"+months, count, \"0\") ); \n+                } else\n+                if(value == d) {\n+                    buffer.append( StringUtils.leftPad(\"\"+days, count, \"0\") ); \n+                } else\n+                if(value == H) {\n+                    buffer.append( StringUtils.leftPad(\"\"+hours, count, \"0\") ); \n+                } else\n+                if(value == m) {\n+                    buffer.append( StringUtils.leftPad(\"\"+minutes, count, \"0\") ); \n+                } else\n+                if(value == s) {\n+                    buffer.append( StringUtils.leftPad(\"\"+seconds, count, \"0\") ); \n+                } else\n+                if(value == S) {\n+                    buffer.append( StringUtils.leftPad(\"\"+milliseconds, count, \"0\") ); \n+                }\n+            }\n+        }\n+        \n+        return buffer.toString();\n     }\n \n     /**\n         long millis,\n         boolean suppressLeadingZeroElements,\n         boolean suppressTrailingZeroElements) {\n-        long[] values = new long[4];\n-        values[0] = millis / DateUtils.MILLIS_PER_DAY;\n-        values[1] = (millis / DateUtils.MILLIS_PER_HOUR) % 24;\n-        values[2] = (millis / DateUtils.MILLIS_PER_MINUTE) % 60;\n-        values[3] = (millis / DateUtils.MILLIS_PER_SECOND) % 60;\n-        String[] fieldsOne = { \" day \", \" hour \", \" minute \", \" second\" };\n-        String[] fieldsPlural = { \" days \", \" hours \", \" minutes \", \" seconds\" };\n-\n-        StringBuffer buf = new StringBuffer(64);\n-        boolean valueOutput = false;\n-\n-        for (int i = 0; i < 4; i++) {\n-            long value = values[i];\n-            if (value == 0) {\n-                // handle zero\n-                if (valueOutput) {\n-                    if (suppressTrailingZeroElements == false) {\n-                        buf.append('0').append(fieldsPlural[i]);\n-                    }\n-                } else {\n-                    if (suppressLeadingZeroElements == false) {\n-                        buf.append('0').append(fieldsPlural[i]);\n+\n+        // This method is generally replacable by the format method, but \n+        // there are a series of tweaks and special cases that require \n+        // trickery to replicate.\n+        String duration = format(millis, \"d' days 'H' hours 'm' minutes 's' seconds'\");\n+        if(suppressLeadingZeroElements) {\n+            // this is a temporary marker on the front. Like ^ in regexp.\n+            duration = \" \" + duration;\n+            String tmp = StringUtils.replaceOnce(duration, \" 0 days\", \"\");\n+            if(tmp.length() != duration.length()) {\n+                duration = tmp;\n+                tmp = StringUtils.replaceOnce(duration, \" 0 hours\", \"\");\n+                if(tmp.length() != duration.length()) {\n+                    duration = tmp;\n+                    tmp = StringUtils.replaceOnce(duration, \" 0 minutes\", \"\");\n+                    duration = tmp;\n+                    if(tmp.length() != duration.length()) {\n+                        duration = StringUtils.replaceOnce(tmp, \" 0 seconds\", \"\");\n                     }\n                 }\n-            } else if (value == 1) {\n-                // one\n-                valueOutput = true;\n-                buf.append('1').append(fieldsOne[i]);\n+            }\n+            if(duration.length() != 0) {\n+                // strip the space off again\n+                duration = duration.substring(1);\n+            }\n+        }\n+        if(suppressTrailingZeroElements) {\n+            String tmp = StringUtils.replaceOnce(duration, \" 0 seconds\", \"\");\n+            if(tmp.length() != duration.length()) {\n+                duration = tmp;\n+                tmp = StringUtils.replaceOnce(duration, \" 0 minutes\", \"\");\n+                if(tmp.length() != duration.length()) {\n+                    duration = tmp;\n+                    tmp = StringUtils.replaceOnce(duration, \" 0 hours\", \"\");\n+                    if(tmp.length() != duration.length()) {\n+                        duration = StringUtils.replaceOnce(tmp, \" 0 days\", \"\");\n+                    }\n+                }\n+            }\n+        }\n+        // handle plurals\n+        duration = StringUtils.replaceOnce(duration, \"1 seconds\", \"1 second\");\n+        duration = StringUtils.replaceOnce(duration, \"1 minutes\", \"1 minute\");\n+        duration = StringUtils.replaceOnce(duration, \"1 hours\", \"1 hour\");\n+        duration = StringUtils.replaceOnce(duration, \"1 days\", \"1 day\");\n+        return duration;\n+    }\n+\n+    static final Object y = \"y\";\n+    static final Object M = \"M\";\n+    static final Object d = \"d\";\n+    static final Object H = \"H\";\n+    static final Object m = \"m\";\n+    static final Object s = \"s\";\n+    static final Object S = \"S\";\n+    \n+    static Token[] lexx(String format) {\n+        char[] array = format.toCharArray();\n+        java.util.ArrayList list = new java.util.ArrayList(array.length);\n+\n+        boolean inLiteral = false;\n+        StringBuffer buffer = null;\n+        Token previous = null;\n+        int sz = array.length;\n+        for(int i=0; i<sz; i++) {\n+            char ch = array[i];\n+            if(inLiteral && ch != '\\'') {\n+                buffer.append(ch);\n+                continue;\n+            }\n+            Object value = null;\n+            switch(ch) {\n+                // TODO: Need to handle escaping of '\n+                case '\\'' : \n+                  if(inLiteral) {\n+                      buffer = null;\n+                      inLiteral = false;\n+                  } else {\n+                      buffer = new StringBuffer();\n+                      list.add(new Token(buffer));\n+                      inLiteral = true;\n+                  }\n+                  break;\n+                case 'y'  : value = y; break;\n+                case 'M'  : value = M; break;\n+                case 'd'  : value = d; break;\n+                case 'H'  : value = H; break;\n+                case 'm'  : value = m; break;\n+                case 's'  : value = s; break;\n+                case 'S'  : value = S; break;\n+                default   : \n+                  if(buffer == null) {\n+                      buffer = new StringBuffer();\n+                      list.add(new Token(buffer));\n+                  }\n+                  buffer.append(ch);\n+            }\n+\n+            if(value != null) {\n+                if(previous != null && previous.getValue() == value) {\n+                    previous.increment();\n+                } else {\n+                    Token token = new Token(value);\n+                    list.add(token); \n+                    previous = token;\n+                }\n+                buffer = null; \n+            }\n+        }\n+        return (Token[]) list.toArray( new Token[0] );\n+    }\n+\n+}\n+\n+// Represents an element of the format-mini-language.\n+class Token {\n+\n+    // will only work for the tokens, not for stringbuffers/numbers\n+    static boolean containsTokenWithValue(Token[] tokens, Object value) {\n+        int sz = tokens.length;\n+        for(int i=0; i<sz; i++) {\n+            if(tokens[i].getValue() == value) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private Object value;\n+    private int count;\n+\n+    public Token(Object value) {\n+        this.value = value;\n+        this.count = 1;\n+    }\n+\n+    Token(Object value, int count) {\n+        this.value = value;\n+        this.count = count;\n+    }\n+\n+    public void increment() { \n+        count++;\n+    }\n+\n+    public int getCount() {\n+        return count;\n+    }\n+\n+    public Object getValue() {\n+        return value;\n+    }\n+\n+    public boolean equals(Object obj2) {\n+        if(obj2 instanceof Token) {\n+            Token tok2 = (Token) obj2;\n+            if(this.value.getClass() != tok2.value.getClass()) {\n+                return false;\n+            }\n+            if(this.count != tok2.count) {\n+                return false;\n+            }\n+            if(this.value instanceof StringBuffer) {\n+                return this.value.toString().equals(tok2.value.toString());\n+            } else\n+            if(this.value instanceof Number) {\n+                return this.value.equals(tok2.value);\n             } else {\n-                // other\n-                valueOutput = true;\n-                buf.append(value).append(fieldsPlural[i]);\n-            }\n-        }\n-\n-        return buf.toString().trim();\n-    }\n-\n-    /**\n-     * <p>DurationFormatUtils instances should NOT be constructed in standard programming.</p>\n-     *\n-     * <p>This constructor is public to permit tools that require a JavaBean instance\n-     * to operate.</p>\n-     */\n-    public DurationFormatUtils() {\n+                return this.value == tok2.value;\n+            }\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public String toString() {\n+        return StringUtils.repeat(this.value.toString(), this.count);\n     }\n \n }\n--- a/src/test/org/apache/commons/lang/time/DurationFormatUtilsTest.java\n+++ b/src/test/org/apache/commons/lang/time/DurationFormatUtilsTest.java\n         Constructor[] cons = DurationFormatUtils.class.getDeclaredConstructors();\n         assertEquals(1, cons.length);\n         assertEquals(true, Modifier.isPublic(cons[0].getModifiers()));\n-        assertEquals(false, Modifier.isPublic(DurationFormatUtils.class.getModifiers()));\n+        assertEquals(true, Modifier.isPublic(DurationFormatUtils.class.getModifiers()));\n         assertEquals(false, Modifier.isFinal(DurationFormatUtils.class.getModifiers()));\n     }\n     \n         //assertEquals(\"P1Y2M3DT10H30M\", text);\n     }\n \n+    public void testLexx() {\n+        // tests each constant\n+        assertArrayEquals( \n+          new Token[] { \n+            new Token( DurationFormatUtils.y, 1),\n+            new Token( DurationFormatUtils.M, 1),\n+            new Token( DurationFormatUtils.d, 1),\n+            new Token( DurationFormatUtils.H, 1),\n+            new Token( DurationFormatUtils.m, 1),\n+            new Token( DurationFormatUtils.s, 1),\n+            new Token( DurationFormatUtils.S, 1)\n+          }, DurationFormatUtils.lexx(\"yMdHmsS\") \n+        );\n+\n+        // tests the ISO8601-like\n+        assertArrayEquals( \n+          new Token[] { \n+            new Token( DurationFormatUtils.H, 1),\n+            new Token( new StringBuffer(\":\"), 1),\n+            new Token( DurationFormatUtils.m, 2),\n+            new Token( new StringBuffer(\":\"), 1),\n+            new Token( DurationFormatUtils.s, 2),\n+            new Token( new StringBuffer(\".\"), 1),\n+            new Token( DurationFormatUtils.S, 3)\n+          }, DurationFormatUtils.lexx(\"H:mm:ss.SSS\")\n+        );\n+\n+        // test the iso extended format\n+        assertArrayEquals( \n+          new Token[] { \n+            new Token( new StringBuffer(\"P\"), 1),\n+            new Token( DurationFormatUtils.y, 4),\n+            new Token( new StringBuffer(\"Y\"), 1),\n+            new Token( DurationFormatUtils.M, 1),\n+            new Token( new StringBuffer(\"M\"), 1),\n+            new Token( DurationFormatUtils.d, 1),\n+            new Token( new StringBuffer(\"DT\"), 1),\n+            new Token( DurationFormatUtils.H, 1),\n+            new Token( new StringBuffer(\"H\"), 1),\n+            new Token( DurationFormatUtils.m, 1),\n+            new Token( new StringBuffer(\"M\"), 1),\n+            new Token( DurationFormatUtils.s, 1),\n+            new Token( new StringBuffer(\".\"), 1),\n+            new Token( DurationFormatUtils.S, 1),\n+            new Token( new StringBuffer(\"S\"), 1)\n+          }, \n+          DurationFormatUtils.lexx(DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN)\n+        );\n+    }\n+    private void assertArrayEquals(Token[] obj1, Token[] obj2) {\n+        assertEquals( \"Arrays are unequal length. \", obj1.length, obj2.length );\n+        for(int i=0; i<obj1.length; i++) {\n+            assertTrue( \"Index \" + i + \" not equal, \" + obj1[i] + \" vs \" + obj2, obj1[i].equals(obj2[i]));\n+        }\n+    }\n+\n     \n }", "timestamp": 1093589125, "metainfo": ""}