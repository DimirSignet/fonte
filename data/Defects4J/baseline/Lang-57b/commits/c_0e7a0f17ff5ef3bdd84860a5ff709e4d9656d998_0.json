{"sha": "0e7a0f17ff5ef3bdd84860a5ff709e4d9656d998", "log": "Removed PADDING cache which leaked memory. Issue #38792. Updated padding(int,char) JavaDoc about it's I18N incompatabilities.  ", "commit": "\n--- a/src/java/org/apache/commons/lang/StringUtils.java\n+++ b/src/java/org/apache/commons/lang/StringUtils.java\n     private static final int PAD_LIMIT = 8192;\n \n     /**\n-     * <p>An array of <code>String</code>s used for padding.</p>\n-     *\n-     * <p>Used for efficient space padding. The length of each String expands as needed.</p>\n-     */\n-    private static final String[] PADDING = new String[Character.MAX_VALUE + 1];\n-\n-    static {\n-        // space padding is most common, start with 64 chars\n-        PADDING[32] = \"                                                                \";\n-    }\n-\n-    /**\n      * <p><code>StringUtils</code> instances should NOT be constructed in\n      * standard programming. Instead, the class should be used as\n      * <code>StringUtils.trim(\" foo \");</code>.</p>\n      * StringUtils.padding(-2, 'e') = IndexOutOfBoundsException\n      * </pre>\n      *\n+     * <p>Note: this method doesn't not support padding with\n+     * <a href=\"http://www.unicode.org/glossary/#supplementary_character\">Unicode Supplementary Characters</a>\n+     * as they require a pair of <code>char</code>s to be represented.\n+     * If you are needing to support full I18N of your applications\n+     * consider using {@link #repeat(String, int)} instead. \n+     * </p>\n+     *\n      * @param repeat  number of times to repeat delim\n      * @param padChar  character to repeat\n      * @return String with repeated character\n      * @throws IndexOutOfBoundsException if <code>repeat &lt; 0</code>\n-     */\n-    private static String padding(int repeat, char padChar) {\n-        // be careful of synchronization in this method\n-        // we are assuming that get and set from an array index is atomic\n-        String pad = PADDING[padChar];\n-        if (pad == null) {\n-            pad = String.valueOf(padChar);\n-        }\n-        while (pad.length() < repeat) {\n-            pad = pad.concat(pad);\n-        }\n-        PADDING[padChar] = pad;\n-        return pad.substring(0, repeat);\n+     * @see #repeat(String, int)\n+     */\n+    private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException {\n+        if (repeat < 0) {\n+            throw new IndexOutOfBoundsException(\"Cannot pad a negative amount: \" + repeat);\n+        }\n+        final char[] buf = new char[repeat];\n+        for (int i=0; i < buf.length; i++) {\n+            buf[i] = padChar;\n+        }\n+        return new String(buf);\n     }\n \n     /**", "timestamp": 1141766266, "metainfo": ""}