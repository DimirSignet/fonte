{"sha": "f94d244c688f97da0391cfef2f427581dca826b7", "log": "Update Null handling in StringUtils to handle nulls quietly   ", "commit": "\n--- a/src/java/org/apache/commons/lang/StringUtils.java\n+++ b/src/java/org/apache/commons/lang/StringUtils.java\n  * @author Arun Mammen Thomas\n  * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n  * @since 1.0\n- * @version $Id: StringUtils.java,v 1.59 2003/07/16 21:23:50 scolebourne Exp $\n+ * @version $Id: StringUtils.java,v 1.60 2003/07/16 23:45:39 scolebourne Exp $\n  */\n public class StringUtils {\n \n      *\n      * <p>The difference from join is that concatenate has no delimiter.</p>\n      * \n-     * @param array the array of values to concatenate.\n-     * @return the concatenated string.\n+     * @param array  the array of values to concatenate, may be null\n+     * @return the concatenated string, <code>null</code> if null array input\n      */\n     public static String concatenate(Object[] array) {\n         return join(array, null);\n      * <p>No delimiter is added before or after the list.\n      * A <code>null</code> separator is the same as an empty String (\"\").</p>\n      *\n-     * @param array the array of values to join together\n-     * @param separator the separator character to use\n-     * @return the joined String\n+     * @param array  the array of values to join together, may be null\n+     * @param separator  the separator character to use, null treated as \"\"\n+     * @return the joined String, <code>null</code> if null array input\n      */\n     public static String join(Object[] array, String separator) {\n+        if (array == null) {\n+            return null;\n+        }\n+        if (separator == null) {\n+            separator = \"\";\n+        }\n         int arraySize = array.length;\n \n         // ArraySize ==  0: Len = 0\n         //           (Assuming that all strings are roughly equally long)\n         int bufSize \n             = ((arraySize == 0) ? 0 \n-                : arraySize * (array[0].toString().length() \n+                : arraySize * ((array[0] == null ? 16 : array[0].toString().length()) \n                     + ((separator != null) ? separator.length(): 0)));\n \n         StringBuffer buf = new StringBuffer(bufSize);\n         for (int i = 0; i < arraySize; i++) {\n             if ((separator != null) && (i > 0)) {\n                 buf.append(separator);\n-         }\n-            buf.append(array[i]);\n+            }\n+            if (array[i] != null) {\n+                buf.append(array[i]);\n+            }\n         }\n         return buf.toString();\n     }\n      *\n      * <p>No delimiter is added before or after the list.\n      *\n-     * @param array the array of values to join together\n-     * @param separator the separator character to use\n-     * @return the joined String\n+     * @param array  the array of values to join together, may be null\n+     * @param separator  the separator character to use\n+     * @return the joined String, <code>null</code> if null array input\n      */\n     public static String join(Object[] array, char separator) {\n+        if (array == null) {\n+            return null;\n+        }\n         int arraySize = array.length;\n-        int bufSize = (arraySize == 0 ? 0 : (array[0].toString().length() + 1) * arraySize);\n+        int bufSize = (arraySize == 0 ? 0 : ((array[0] == null ? 16 : array[0].toString().length()) + 1) * arraySize);\n         StringBuffer buf = new StringBuffer(bufSize);\n \n         for (int i = 0; i < arraySize; i++) {\n             if (i > 0) {\n                 buf.append(separator);\n             }\n-            buf.append(array[i]);\n+            if (array[i] != null) {\n+                buf.append(array[i]);\n+            }\n         }\n         return buf.toString();\n     }\n      * <p>No delimiter is added before or after the list.\n      * A <code>null</code> separator is the same as an empty String (\"\").</p>\n      *\n-     * @param iterator the <code>Iterator</code> of values to join together\n-     * @param separator  the separator character to use\n-     * @return the joined String\n+     * @param iterator  the <code>Iterator</code> of values to join together, may be null\n+     * @param separator  the separator character to use, null treated as \"\"\n+     * @return the joined String, <code>null</code> if null iterator input\n      */\n     public static String join(Iterator iterator, String separator) {\n+        if (iterator == null) {\n+            return null;\n+        }\n         StringBuffer buf = new StringBuffer(256);  // Java default is 16, probably too small\n         while (iterator.hasNext()) {\n-            buf.append(iterator.next());\n+            Object obj = iterator.next();\n+            if (obj != null) {\n+                buf.append(obj);\n+            }\n             if ((separator != null) && iterator.hasNext()) {\n                 buf.append(separator);\n             }\n      *\n      * <p>No delimiter is added before or after the list.\n      *\n-     * @param iterator the <code>Iterator</code> of values to join together\n+     * @param iterator  the <code>Iterator</code> of values to join together, may be null\n      * @param separator  the separator character to use\n-     * @return the joined String\n+     * @return the joined String, <code>null</code> if null iterator input\n      */\n     public static String join(Iterator iterator, char separator) {\n+        if (iterator == null) {\n+            return null;\n+        }\n         StringBuffer buf = new StringBuffer(256);  // Java default is 16, probably too small\n         while (iterator.hasNext()) {\n-            buf.append(iterator.next());\n+            Object obj = iterator.next();\n+            if (obj != null) {\n+                buf.append(obj);\n+            }\n             if (iterator.hasNext()) {\n                 buf.append(separator);\n             }\n      * \n      * <p>A <code>null</code> reference passed to this method is a no-op.</p>\n      * \n+     * <pre>\n+     * StringUtils.replaceOnce(null, null, null)  = null\n+     * StringUtils.replaceOnce(\"aba\", null, null) = \"aba\"\n+     * StringUtils.replaceOnce(\"aba\", null, null) = \"aba\"\n+     * StringUtils.replaceOnce(\"aba\", \"a\", null)  = \"aba\"\n+     * StringUtils.replaceOnce(\"aba\", \"a\", \"\")    = \"aba\"\n+     * StringUtils.replaceOnce(\"aba\", \"a\", \"z\")   = \"zba\"\n+     * </pre>\n+     * \n      * @see #replace(String text, String repl, String with, int max)\n-     * @param text text to search and replace in\n-     * @param repl String to search for\n-     * @param with String to replace with\n+     * @param text  text to search and replace in, may be null\n+     * @param repl  the String to search for, may be null\n+     * @param with  the String to replace with, may be null\n      * @return the text with any replacements processed\n      */\n     public static String replaceOnce(String text, String repl, String with) {\n      *\n      * <p>A <code>null</code> reference passed to this method is a no-op.</p>\n      * \n+     * <pre>\n+     * StringUtils.replace(null, null, null)  = null\n+     * StringUtils.replace(\"aba\", null, null) = \"aba\"\n+     * StringUtils.replace(\"aba\", null, null) = \"aba\"\n+     * StringUtils.replace(\"aba\", \"a\", null)  = \"aba\"\n+     * StringUtils.replace(\"aba\", \"a\", \"\")    = \"aba\"\n+     * StringUtils.replace(\"aba\", \"a\", \"z\")   = \"zbz\"\n+     * </pre>\n+     * \n      * @see #replace(String text, String repl, String with, int max)\n-     * @param text text to search and replace in\n-     * @param repl String to search for\n-     * @param with String to replace with\n+     * @param text  text to search and replace in, may be null\n+     * @param repl  the String to search for, may be null\n+     * @param with  the String to replace with, may be null\n      * @return the text with any replacements processed\n      */\n     public static String replace(String text, String repl, String with) {\n      *\n      * <p>A <code>null</code> reference passed to this method is a no-op.</p>\n      *\n-     * @param text text to search and replace in\n-     * @param repl String to search for\n-     * @param with String to replace with\n-     * @param max maximum number of values to replace, or <code>-1</code> if no maximum\n+     * <pre>\n+     * StringUtils.replace(null, null, null, 1)   = null\n+     * StringUtils.replace(\"abaa\", null, null, 1) = \"abaa\"\n+     * StringUtils.replace(\"abaa\", null, null, 1) = \"abaa\"\n+     * StringUtils.replace(\"abaa\", \"a\", null, 1)  = \"abaa\"\n+     * StringUtils.replace(\"abaa\", \"a\", \"\", 1)    = \"abaa\"\n+     * StringUtils.replace(\"abaa\", \"a\", \"z\", 0)   = \"abaa\"\n+     * StringUtils.replace(\"abaa\", \"a\", \"z\", 1)   = \"zbaa\"\n+     * StringUtils.replace(\"abaa\", \"a\", \"z\", 2)   = \"zbza\"\n+     * StringUtils.replace(\"abaa\", \"a\", \"z\", -1)  = \"zbzz\"\n+     * </pre>\n+     * \n+     * @param text  text to search and replace in, may be null\n+     * @param repl  the String to search for, may be null\n+     * @param with  the String to replace with, may be null\n+     * @param max  maximum number of values to replace, or <code>-1</code> if no maximum\n      * @return the text with any replacements processed\n      */\n     public static String replace(String text, String repl, String with, int max) {\n-        if (text == null || repl == null || with == null || repl.length() == 0) {\n+        if (text == null || repl == null || with == null || repl.length() == 0 || max == 0) {\n             return text;\n         }\n \n     /**\n      * <p>Overlay a part of a String with another String.</p>\n      *\n-     * @param text String to do overlaying in\n-     * @param overlay String to overlay\n-     * @param start int to start overlaying at\n-     * @param end int to stop overlaying before\n-     * @return String with overlayed text\n-     * @throws NullPointerException if text or overlay is <code>null</code>\n+     * <pre>\n+     * StringUtils.overlayString(null, null, 2, 4)        = null\n+     * StringUtils.overlayString(\"abcdef\", null, 2, 4)    = \"abef\"\n+     * StringUtils.overlayString(\"abcdef\", \"\", 2, 4)      = \"abef\"\n+     * StringUtils.overlayString(\"abcdef\", \"zzzz\", 2, 4)  = \"abzzzzef\"\n+     * StringUtils.overlayString(\"abcdef\", \"zzzz\", 4, 2)  = \"abcdzzzzcdef\"\n+     * StringUtils.overlayString(\"abcdef\", \"zzzz\", -1, 4) = IndexOutOfBoundsException\n+     * StringUtils.overlayString(\"abcdef\", \"zzzz\", 2, 8)  = IndexOutOfBoundsException\n+     * </pre>\n+     * \n+     * @param text  the String to do overlaying in, may be null\n+     * @param overlay  the String to overlay, may be null\n+     * @param start  the position to start overlaying at\n+     * @param end  the position to stop overlaying before\n+     * @return overlayed string, <code>null</code> if null string input\n+     * @throws IndexOutOfBoundsException if either position is invalid\n      */\n     public static String overlayString(String text, String overlay, int start, int end) {\n+        if (text == null) {\n+            return null;\n+        }\n+        if (overlay == null) {\n+            overlay = \"\";\n+        }\n         return new StringBuffer(start + overlay.length() + text.length() - end + 1)\n             .append(text.substring(0, start))\n             .append(overlay)\n     /**\n      * <p>Center a String in a larger String of size <code>size</code>\n      * using the space character (' ').<p>\n+     * \n+     * <p>If the size is less than the string length, the string is returned.\n+     * A <code>null</code> string returns <code>null</code>.\n+     * A negative size is treated as zero.</p>\n      *\n      * <p>Equivalent to <code>center(str, size, \" \")</code>.</p>\n      *\n-     * @param str  the String to center, must not be null\n-     * @param size  the int size of new String\n-     * @return String containing centered String\n-     * @throws NullPointerException if str is <code>null</code>\n+     * <pre>\n+     * StringUtils.center(null, -1)  = null\n+     * StringUtils.center(null, 4)   = null\n+     * StringUtils.center(\"\", 4)     = \"    \"\n+     * StringUtils.center(\"ab\", 4)   = \" ab \"\n+     * StringUtils.center(\"abcd\", 2) = \"abcd\"\n+     * StringUtils.center(\"a\", 4)    = \" a  \"\n+     * </pre>\n+     * \n+     * @param str  the String to center, may be null\n+     * @param size  the int size of new String, negative treated as zero\n+     * @return centered String, <code>null</code> if null string input\n      */\n     public static String center(String str, int size) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (size < 0) {\n+            size = 0;\n+        }\n         int sz = str.length();\n         int p = size - sz;\n         if (p < 1) {\n      *\n      * <p>Uses a supplied String as the value to pad the String with.</p>\n      *\n-     * @param str  the String to center, must not be null\n-     * @param size  the int size of new String\n-     * @param padStr  the String to pad the new String with, must not be null\n-     * @return String containing centered String\n-     * @throws NullPointerException if str or padStr is <code>null</code>\n-     * @throws ArithmeticException if padStr is the empty String\n+     * <p>If the size is less than the string length, the string is returned.\n+     * A <code>null</code> string returns <code>null</code>.\n+     * A negative size is treated as zero.</p>\n+     *\n+     * <pre>\n+     * StringUtils.center(null, -1, \" \")  = null\n+     * StringUtils.center(null, 4, \" \")   = null\n+     * StringUtils.center(\"\", 4, \" \")     = \"    \"\n+     * StringUtils.center(\"ab\", 4, \" \")   = \" ab\"\n+     * StringUtils.center(\"abcd\", 2, \" \") = \" abcd\"\n+     * StringUtils.center(\"a\", 4, \" \")    = \" a  \"\n+     * StringUtils.center(\"a\", 4, \"yz\")    = \"yayz\"\n+     * StringUtils.center(\"abc\", 4, null) = IllegalArgumentException\n+     * StringUtils.center(\"abc\", 4, \"\")   = IllegalArgumentException\n+     * </pre>\n+     * \n+     * @param str  the String to center, may be null\n+     * @param size  the int size of new String, negative treated as zero\n+     * @param padStr  the String to pad the new String with, must not be null or empty\n+     * @return centered String, <code>null</code> if null string input\n+     * @throws IllegalArgumentException if padStr is <code>null</code> or empty\n      */\n     public static String center(String str, int size, String padStr) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (padStr == null || padStr.length() == 0) {\n+            throw new IllegalArgumentException(\"Pad String must not be null or empty\");\n+        }\n+        if (size < 0) {\n+            size = 0;\n+        }\n         int sz = str.length();\n         int p = size - sz;\n         if (p < 1) {\n      * It now more closely matches Perl chomp.\n      * For the previous behavior, use {@link #slice(String)}.</p>\n      *\n-     * @param str String to chomp a newline from\n-     * @return String without newline\n-     * @throws NullPointerException if str is <code>null</code>\n+     * @param str  the String to chomp a newline from, may be null\n+     * @return String without newline, <code>null</code> if null string input\n      */\n     public static String chomp(String str) {\n-        if (str.length() == 0) {\n+        if (str == null || str.length() == 0) {\n             return str;\n         }\n \n      * It now more closely matches Perl chomp.\n      * For the previous behavior, use {@link #slice(String,String)}.</p>\n      *\n-     * @param str string to chomp from\n-     * @param separator separator string\n-     * @return String without trailing separator\n-     * @throws NullPointerException if str is <code>null</code>\n+     * @param str  string to chomp from, may be null\n+     * @param separator  separator string\n+     * @return String without trailing separator, <code>null</code> if null string input\n      */\n     public static String chomp(String str, String separator) {\n-        if (str.length() == 0) {\n+        if (str == null || str.length() == 0) {\n             return str;\n         }\n         if (str.endsWith(separator)) {\n      * <p>Remove any &quot;\\n&quot; if and only if it is at the end\n      * of the supplied String.</p>\n      * \n-     * @param str String to chomp from\n+     * @param str  the String to chomp from, must not be null\n      * @return String without chomped ending\n      * @throws NullPointerException if str is <code>null</code>\n      * @deprecated Use {@link #chomp(String)} instead.\n     /**\n      * <p>Remove a value if and only if the String ends with that value.</p>\n      * \n-     * @param str String to chomp from\n-     * @param sep String to chomp\n+     * @param str  the String to chomp from, must not be null\n+     * @param sep  the String to chomp, must not be null\n      * @return String without chomped ending\n      * @throws NullPointerException if str or sep is <code>null</code>\n      * @deprecated Use {@link #chomp(String,String)} instead.\n      * everything after it from a String.\n      * [That makes no sense. Just use sliceRemainder() :-)]</p>\n      *\n-     * @param str String to chomp from\n-     * @param sep String to chomp\n+     * @param str  the String to chomp from, must not be null\n+     * @param sep  the String to chomp, must not be null\n      * @return String chomped\n      * @throws NullPointerException if str or sep is <code>null</code>\n      * @deprecated Use {@link #sliceRemainder(String,String)} instead.\n      * <p>Remove the first value of a supplied String, and everything before it\n      * from a String.</p>\n      *\n-     * @param str String to chomp from\n-     * @param sep String to chomp\n+     * @param str  the String to chomp from, must not be null\n+     * @param sep  the String to chomp, must not be null\n      * @return String without chomped beginning\n      * @throws NullPointerException if str or sep is <code>null</code>\n      * @deprecated Use {@link #sliceFirstRemainder(String,String)} instead.\n      * <p>Remove and return everything before the first value of a\n      * supplied String from another String.</p>\n      *\n-     * @param str String to chomp from\n-     * @param sep String to chomp\n+     * @param str  the String to chomp from, must not be null\n+     * @param sep  the String to chomp, must not be null\n      * @return String prechomped\n      * @throws NullPointerException if str or sep is <code>null</code>\n      * @deprecated Use {@link #sliceFirst(String,String)} instead.\n      * <p>If the String ends in <code>\\r\\n</code>, then remove both\n      * of them.</p>\n      *\n-     * @param str String to chop last character from\n-     * @return String without last character\n-     * @throws NullPointerException if str is <code>null</code>\n+     * @param str  the String to chop last character from, may be null\n+     * @return String without last character, <code>null</code> if null string input\n      */\n     public static String chop(String str) {\n-        if (\"\".equals(str)) {\n+        if (str == null) {\n+            return null;\n+        }\n+        int strLen = str.length();\n+        if (strLen < 2) {\n             return \"\";\n         }\n-        if (str.length() == 1) {\n-            return \"\";\n-        }\n-        int lastIdx = str.length() - 1;\n+        int lastIdx = strLen - 1;\n         String ret = str.substring(0, lastIdx);\n         char last = str.charAt(lastIdx);\n         if (last == '\\n') {\n      * <p>Remove <code>\\n</code> from end of a String if it's there.\n      * If a <code>\\r</code> precedes it, then remove that too.</p>\n      *\n-     * @param str String to chop a newline from\n+     * @param str  the String to chop a newline from, must not be null\n      * @return String without newline\n      * @throws NullPointerException if str is <code>null</code>\n      * @deprecated Use {@link #chomp(String)} instead.\n      *\n      * <p><em>(This method was formerly named chomp or chopNewline.)</em></p>\n      *\n-     * @param str String to slice the newline from\n-     * @return String without sliced newline\n-     * @throws NullPointerException if str is <code>null</code>\n+     * @param str  the String to slice the newline from, may be null\n+     * @return String without sliced newline, <code>null</code> if null string input\n      */\n     public static String slice(String str) {\n         return slice(str, \"\\n\");\n      *\n      * <p><em>(This method was formerly named chomp.)</em></p>\n      *\n-     * @param str String to slice from\n-     * @param sep String to slice\n-     * @return String without sliced ending\n-     * @throws NullPointerException if str or sep is <code>null</code>\n+     * @param str  the String to slice from, may be null\n+     * @param sep  the String to slice, may be null\n+     * @return String without sliced ending, <code>null</code> if null string input\n      */\n     public static String slice(String str, String sep) {\n+        if (str == null || sep == null || str.length() == 0 || sep.length() == 0) {\n+            return str;\n+        }\n         int idx = str.lastIndexOf(sep);\n         if (idx != -1) {\n             return str.substring(0, idx);\n      * <p><em>(This method was formerly named getchomp. Also, now it does not\n      * include the separator in the return value.)</em></p>\n      *\n-     * @param str String to slice from\n-     * @param sep String to slice\n-     * @return String sliced\n-     * @throws NullPointerException if str or sep is <code>null</code>\n+     * @param str  the String to slice from, may be null\n+     * @param sep  the String to slice, may be null\n+     * @return String sliced, <code>null</code> if null string input\n      */\n     public static String sliceRemainder(String str, String sep) {\n+        if (str == null || str.length() == 0) {\n+            return str;\n+        }\n+        if (sep == null || sep.length() == 0) {\n+            return \"\";\n+        }\n         int idx = str.lastIndexOf(sep);\n         if (idx == str.length() - sep.length()) {\n             return \"\";\n      * <p><em>(This method was formerly named prechomp.  Also, previously\n      * it included the separator in the return value; now it does not.)</em></p>\n      *\n-     * @param str String to slice from\n-     * @param sep String to slice\n-     * @return String without sliced beginning\n-     * @throws NullPointerException if str or sep is <code>null</code>\n+     * @param str  the String to slice from, may be null\n+     * @param sep  the String to slice, may be null\n+     * @return String without sliced beginning, <code>null</code> if null string input\n      */\n     public static String sliceFirstRemainder(String str, String sep) {\n+        if (str == null || str.length() == 0) {\n+            return str;\n+        }\n+        if (sep == null || sep.length() == 0) {\n+            return \"\";\n+        }\n         int idx = str.indexOf(sep);\n         if (idx != -1) {\n             return str.substring(idx + sep.length());\n      * <p><em>(This method was formerly named getPrechomp.  Also, it used to\n      * include the separator, but now it does not.)</em></p>\n      *\n-     * @param str String to slice from\n-     * @param sep String to slice\n-     * @return String presliced\n-     * @throws NullPointerException if str or sep is <code>null</code>\n+     * @param str  the String to slice from, may be null\n+     * @param sep  the String to slice, may be null\n+     * @return String presliced, <code>null</code> if null string input\n      */\n     public static String sliceFirst(String str, String sep) {\n+        if (str == null || sep == null || str.length() == 0 || sep.length() == 0) {\n+            return str;\n+        }\n         int idx = str.indexOf(sep);\n         if (idx != -1) {\n             return str.substring(0, idx);\n      * <p>The String is padded to the size of <code>size</code>.</p>\n      * \n      * <pre>\n+     * StringUtils.rightPad(null, 1)   = null\n      * StringUtils.rightPad(\"bat\", 3)  = \"bat\"\n      * StringUtils.rightPad(\"bat\", 5)  = \"bat  \"\n      * StringUtils.rightPad(\"bat\", 1)  = \"bat\"\n      * StringUtils.rightPad(\"bat\", -1) = \"bat\"\n-     * StringUtils.rightPad(null, 1)   = NullPointerException\n-     * </pre>\n-     *\n-     * @param str  the String to pad out, must not be null\n+     * </pre>\n+     *\n+     * @param str  the String to pad out, may be null\n      * @param size  the size of the returned string, padded on the right\n-     * @return right padded String or original String if no padding is necessary\n-     * @throws NullPointerException if str is <code>null</code>\n+     * @return right padded String or original String if no padding is necessary,\n+     *  <code>null</code> if null string input\n      */\n     public static String rightPad(String str, int size) {\n+        if (str == null) {\n+            return null;\n+        }\n         int pads = size - str.length();\n         if (pads <= 0) {\n             return str; // returns original string when possible\n      * <p>The String is padded to the size of <code>size</code>.</p>\n      *\n      * <pre>\n+     * StringUtils.rightPad(null, 1, 'z')   = null\n      * StringUtils.rightPad(\"bat\", 3, 'z')  = \"bat\"\n      * StringUtils.rightPad(\"bat\", 5, 'z')  = \"batzz\"\n      * StringUtils.rightPad(\"bat\", 1, 'z')  = \"bat\"\n      * StringUtils.rightPad(\"bat\", -1, 'z') = \"bat\"\n-     * StringUtils.rightPad(null, 1, 'z')   = NullPointerException\n-     * </pre>\n-     *\n-     * @param str  the String to pad out, must not be null\n+     * </pre>\n+     *\n+     * @param str  the String to pad out, may be null\n      * @param size  the size to pad to\n      * @param padChar  the character to pad with\n-     * @return right padded String or original String if no padding is necessary\n-     * @throws NullPointerException if str is <code>null<code>\n+     * @return right padded String or original String if no padding is necessary,\n+     *  <code>null</code> if null string input\n      */\n     public static String rightPad(String str, int size, char padChar) {\n+        if (str == null) {\n+            return null;\n+        }\n         int pads = size - str.length();\n         if (pads <= 0) {\n             return str; // returns original string when possible\n      * <p>The String is padded to the size of <code>size</code>.</p>\n      *\n      * <pre>\n+     * StringUtils.rightPad(null, 1, \"yz\")   = null\n      * StringUtils.rightPad(\"bat\", 3, \"yz\")  = \"bat\"\n      * StringUtils.rightPad(\"bat\", 5, \"yz\")  = \"batyz\"\n      * StringUtils.rightPad(\"bat\", 8, \"yz\")  = \"batyzyzy\"\n      * StringUtils.rightPad(\"bat\", 1, \"yz\")  = \"bat\"\n      * StringUtils.rightPad(\"bat\", -1, \"yz\") = \"bat\"\n-     * StringUtils.rightPad(null, 1, \"yz\")   = NullPointerException\n-     * StringUtils.rightPad(\"bat\", 1, null)  = NullPointerException\n-     * StringUtils.rightPad(\"bat\", 1, \"\")    = ArithmeticException\n-     * </pre>\n-     *\n-     * @param str  the String to pad out, must not be null\n+     * StringUtils.rightPad(\"bat\", 1, null)  = IllegalArgumentException\n+     * StringUtils.rightPad(\"bat\", 1, \"\")    = IllegalArgumentException\n+     * </pre>\n+     *\n+     * @param str  the String to pad out, may be null\n      * @param size  the size to pad to\n      * @param padStr  the String to pad with, must not be null\n-     * @return right padded String or original String if no padding is necessary\n-     * @throws NullPointerException if str or padStr is <code>null<code>\n-     * @throws ArithmeticException if padStr is the empty String\n+     * @return right padded String or original String if no padding is necessary,\n+     *  <code>null</code> if null string input\n+     * @throws IllegalArgumentException if padStr is the empty String or null\n      */\n     public static String rightPad(String str, int size, String padStr) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (padStr == null || padStr.length() == 0) {\n+            throw new IllegalArgumentException(\"Pad String must not be null or empty\");\n+        }\n         if (padStr.length() == 1 && size - str.length() <= PAD_LIMIT) {\n            return rightPad(str, size, padStr.charAt(0));\n         }\n      * <p>The String is padded to the size of <code>size<code>.</p>\n      *\n      * <pre>\n+     * StringUtils.leftPad(null, 1)   = null\n      * StringUtils.leftPad(\"bat\", 3)  = \"bat\"\n      * StringUtils.leftPad(\"bat\", 5)  = \"  bat\"\n      * StringUtils.leftPad(\"bat\", 1)  = \"bat\"\n      * StringUtils.leftPad(\"bat\", -1) = \"bat\"\n-     * StringUtils.leftPad(null, 1)   = NullPointerException\n-     * </pre>\n-     *\n-     * @param str  the String to pad out, must not be null\n+     * </pre>\n+     *\n+     * @param str  the String to pad out, may be null\n      * @param size  the size to pad to\n-     * @return left padded String or original String if no padding is necessary\n-     * @throws NullPointerException if str is <code>null<code>\n+     * @return left padded String or original String if no padding is necessary,\n+     *  <code>null</code> if null string input\n      */\n     public static String leftPad(String str, int size) {\n+        if (str == null) {\n+            return null;\n+        }\n         int pads = size - str.length();\n         if (pads <= 0) { \n             return str; // returns original string when possible\n      * <p>Pad to a size of <code>size</code>.</p>\n      *\n      * <pre>\n+     * StringUtils.leftPad(null, 1, 'z')   = null\n      * StringUtils.leftPad(\"bat\", 3, 'z')  = \"bat\"\n      * StringUtils.leftPad(\"bat\", 5, 'z')  = \"zzbat\"\n      * StringUtils.leftPad(\"bat\", 1, 'z')  = \"bat\"\n      * StringUtils.leftPad(\"bat\", -1, 'z') = \"bat\"\n-     * StringUtils.leftPad(null, 1, 'z')   = NullPointerException\n-     * </pre>\n-     *\n-     * @param str  the String to pad out, must not be null\n+     * </pre>\n+     *\n+     * @param str  the String to pad out, may be null\n      * @param size  the size to pad to\n      * @param padChar  the character to pad with\n-     * @return left padded String or original String if no padding is necessary\n-     * @throws NullPointerException if str or delim is <code>null</code>\n+     * @return left padded String or original String if no padding is necessary,\n+     *  <code>null</code> if null string input\n      */\n     public static String leftPad(String str, int size, char padChar) {\n+        if (str == null) {\n+            return null;\n+        }\n         int pads = size - str.length();\n         if (pads <= 0) {\n             return str; // returns original string when possible\n      * <p>Pad to a size of <code>size</code>.</p>\n      *\n      * <pre>\n+     * StringUtils.leftPad(null, 1, \"yz\")   = null\n      * StringUtils.leftPad(\"bat\", 3, \"yz\")  = \"bat\"\n      * StringUtils.leftPad(\"bat\", 5, \"yz\")  = \"yzbat\"\n      * StringUtils.leftPad(\"bat\", 8, \"yz\")  = \"yzyzybat\"\n      * StringUtils.leftPad(\"bat\", 1, \"yz\")  = \"bat\"\n      * StringUtils.leftPad(\"bat\", -1, \"yz\") = \"bat\"\n-     * StringUtils.leftPad(null, 1, \"yz\")   = NullPointerException\n      * StringUtils.leftPad(\"bat\", 1, null)  = NullPointerException\n      * StringUtils.leftPad(\"bat\", 1, \"\")    = ArithmeticException\n      * </pre>\n      *\n-     * @param str  the String to pad out, must not be null\n+     * @param str  the String to pad out, may be null\n      * @param size  the size to pad to\n-     * @param padStr  the String to pad with\n-     * @return left padded String or original String if no padding is necessary\n-     * @throws NullPointerException if str or delim is null\n-     * @throws ArithmeticException if delim is the empty string\n+     * @param padStr  the String to pad with, must not be null\n+     * @return left padded String or original String if no padding is necessary,\n+     *  <code>null</code> if null string input\n+     * @throws IllegalArgumentException if padStr is the empty String or null\n      */\n     public static String leftPad(String str, int size, String padStr) {\n-        if (padStr.length() == 1 && size - str.length() <= PAD_LIMIT)\n-           return leftPad(str, size, padStr.charAt(0));\n+        if (str == null) {\n+            return null;\n+        }\n+        if (padStr == null || padStr.length() == 0) {\n+            throw new IllegalArgumentException(\"Pad String must not be null or empty\");\n+        }\n+        if (padStr.length() == 1 && size - str.length() <= PAD_LIMIT) {\n+            return leftPad(str, size, padStr.charAt(0));\n+        }\n         size = (size - str.length()) / padStr.length();\n         if (size > 0) {\n             str = repeat(padStr, size) + str;\n      *\n      * <p><code>null</code> returns <code>0</code>.</p>\n      * \n-     * @param str the String to check\n-     * @param sub the substring to count\n-     * @return the number of occurances, 0 if the String is <code>null</code>\n-     * @throws NullPointerException if sub is <code>null</code>\n+     * @param str  the String to check, may be null\n+     * @param sub  the substring to count, may be null\n+     * @return the number of occurances, 0 if either String is <code>null</code>\n      */\n     public static int countMatches(String str, String sub) {\n-        if (sub.equals(\"\")) {\n-            return 0;\n-        }\n-        if (str == null) {\n+        if (str == null || str.length() == 0 || sub == null || sub.length() == 0) {\n             return 0;\n         }\n         int count = 0;\n      * <p><code>null</code> will return <code>false</code>.\n      * An empty String (\"\") will return <code>true</code>.</p>\n      * \n-     * @param str the String to check\n+     * @param str  the String to check, may be null\n      * @return <code>true</code> if only contains letters, and is non-null\n      */\n     public static boolean isAlpha(String str) {\n      * <p><code>null</code> will return <code>false</code>.\n      * An empty String (\"\") will return <code>true</code>.</p>\n      * \n-     * @param str the String to check\n+     * @param str  the String to check, may be null\n      * @return <code>true</code> if only contains whitespace, and is non-null\n      */\n     public static boolean isWhitespace(String str) {\n      * <p><code>null</code> will return <code>false</code>\n      * An empty String (\"\") will return <code>true</code>.</p>\n      * \n-     * @param str the String to check\n+     * @param str  the String to check, may be null\n      * @return <code>true</code> if only contains letters and space,\n      *  and is non-null\n      */\n      * <p><code>null</code> will return <code>false</code>.\n      * An empty String (\"\") will return <code>true</code>.</p>\n      * \n-     * @param str the String to check\n+     * @param str  the String to check, may be null\n      * @return <code>true</code> if only contains letters or digits,\n      *  and is non-null\n      */\n      * <p><code>null</code> will return <code>false</code>.\n      * An empty String (\"\") will return <code>true</code>.</p>\n      * \n-     * @param str the String to check\n+     * @param str  the String to check, may be null\n      * @return <code>true</code> if only contains letters, digits or space,\n      *  and is non-null\n      */\n      * <p><code>null</code> will return <code>false</code>.\n      * An empty String (\"\") will return <code>true</code>.</p>\n      * \n-     * @param str the String to check\n+     * @param str  the String to check, may be null\n      * @return <code>true</code> if only contains digits, and is non-null\n      */\n     public static boolean isNumeric(String str) {\n      * <p><code>null</code> will return <code>false</code>.\n      * An empty String (\"\") will return <code>true</code>.</p>\n      * \n-     * @param str the String to check\n+     * @param str  the String to check, may be null\n      * @return <code>true</code> if only contains digits or space,\n      *  and is non-null\n      */\n     /**\n      * <p>Checks if the String contains only certain chars.</p>\n      *\n-     * @param str the String to check\n-     * @param validChars a string of valid chars\n+     * @param str  the String to check, may be null\n+     * @param validChars  a string of valid chars, may be null\n      * @return true if it only contains valid chars and is non-null\n      */\n     public static boolean containsOnly(String str, String validChars) {\n     /**\n      * <p>Checks that the String does not contain certain chars.</p>\n      *\n-     * @param str the String to check\n-     * @param invalidChars a string of invalid chars\n+     * @param str  the String to check, may be null\n+     * @param invalidChars  a string of invalid chars, may be null\n      * @return true if it contains none of the invalid chars, or is null\n      */\n     public static boolean containsNone(String str, String invalidChars) {\n     /**\n      * <p>Checks that the String does not contain certain chars.</p>\n      *\n-     * @param str the String to check\n-     * @param invalidChars an array of invalid chars\n+     * @param str  the String to check, may be null\n+     * @param invalidChars  an array of invalid chars, may be null\n      * @return true if it contains none of the invalid chars, or is null\n      */\n     public static boolean containsNone(String str, char[] invalidChars) {\n     /**\n      * <p>Checks if the String contains only certain chars.</p>\n      *\n-     * @param str the String to check\n-     * @param valid an array of valid chars\n+     * @param str  the String to check, may be null\n+     * @param valid  an array of valid chars, may be null\n      * @return true if it only contains valid chars and is non-null\n      */\n     public static boolean containsOnly(String str, char[] valid) {\n         // All these pre-checks are to maintain API with an older version\n-        if( (valid == null) || (str == null) ) {\n+        if ( (valid == null) || (str == null) ) {\n             return false;\n         }\n-        if(str.length() == 0) {\n+        if (str.length() == 0) {\n             return true;\n         }\n-        if(valid.length == 0) {\n+        if (valid.length == 0) {\n             return false;\n         }\n         return indexOfAnyBut(str, valid) == -1;\n      * <p>Search a String to find the first index of any\n      * character not in the given set of characters.</p>\n      * \n-     * @param str  the String to check\n-     * @param searchChars  the chars to search for\n-     * @return the index of any of the chars\n-     * @throws NullPointerException if either str or searchChars is <code>null</code>\n+     * @param str  the String to check, may be null\n+     * @param searchChars  the chars to search for, may be null\n+     * @return the index of any of the chars, -1 if no match or null input\n      */\n      public static int indexOfAnyBut(String str, char[] searchChars) {\n-         if(searchChars == null) {\n+         if (searchChars == null) {\n              return -1;\n          }\n          return indexOfAnyBut(str, new String(searchChars));\n      * <p>Search a String to find the first index of any\n      * character not in the given set of characters.</p>\n      * \n-     * @param str  the String to check\n-     * @param searchChars  a String containing the chars to search for\n-     * @return the last index of any of the chars\n-     * @throws NullPointerException if either str or searchChars is <code>null</code>\n+     * @param str  the String to check, may be null\n+     * @param searchChars  the chars to search for, may be null\n+     * @return the index of any of the chars, -1 if no match or null input\n      */\n     public static int indexOfAnyBut(String str, String searchChars) {\n         if (str == null || searchChars == null) {\n      * </ul>\n      * </p>\n      *\n-     * @param maxWidth maximum length of result string\n-     */\n-    public static String abbreviate(String s, int maxWidth) {\n-        return abbreviate(s, 0, maxWidth);\n+     * @param str  the String to check, may be null\n+     * @param maxWidth  maximum length of result string\n+     * @throws IllegalArgumentException if the width is too small\n+     */\n+    public static String abbreviate(String str, int maxWidth) {\n+        return abbreviate(str, 0, maxWidth);\n     }\n \n     /**\n      * <p>In no case will it return a string of length greater than\n      * <code>maxWidth</code>.</p>\n      *\n-     * @param offset left edge of source string\n-     * @param maxWidth maximum length of result string\n-     */\n-    public static String abbreviate(String s, int offset, int maxWidth) {\n-        if (maxWidth < 4)\n+     * @param str  the String to check, may be null\n+     * @param offset  left edge of source string\n+     * @param maxWidth  maximum length of result string\n+     * @throws IllegalArgumentException if the width is too small\n+     */\n+    public static String abbreviate(String str, int offset, int maxWidth) {\n+        if (str == null) {\n+            return null;\n+        }\n+        if (maxWidth < 4) {\n             throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n-        if (s.length() <= maxWidth)\n-            return s;\n-        if (offset > s.length())\n-            offset = s.length();\n-        if ((s.length() - offset) < (maxWidth-3))\n-            offset = s.length() - (maxWidth-3);\n-        if (offset <= 4)\n-            return s.substring(0, maxWidth-3) + \"...\";\n-        if (maxWidth < 7)\n+        }\n+        if (str.length() <= maxWidth) {\n+            return str;\n+        }\n+        if (offset > str.length()) {\n+            offset = str.length();\n+        }\n+        if ((str.length() - offset) < (maxWidth - 3)) {\n+            offset = str.length() - (maxWidth - 3);\n+        }\n+        if (offset <= 4) {\n+            return str.substring(0, maxWidth - 3) + \"...\";\n+        }\n+        if (maxWidth < 7) {\n             throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n-        if ((offset + (maxWidth-3)) < s.length())\n-            return \"...\" + abbreviate(s.substring(offset), maxWidth-3);\n-        return \"...\" + s.substring(s.length() - (maxWidth-3));\n+        }\n+        if ((offset + (maxWidth - 3)) < str.length()) {\n+            return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n+        }\n+        return \"...\" + str.substring(str.length() - (maxWidth - 3));\n     }\n \n     // Difference\n      * <p>For example,\n      * <code>difference(\"i am a machine\", \"i am a robot\") -> \"robot\"</code>.</p>\n      *\n-     * @return the portion of s2 where it differs from s1; returns the \n+     * @param str1  the first string, may be null\n+     * @param str2  the second string, may be null\n+     * @return the portion of str2 where it differs from str1; returns the \n      * empty string if they are equal\n      */\n-    public static String difference(String s1, String s2) {\n-        int at = differenceAt(s1, s2);\n+    public static String difference(String str1, String str2) {\n+        if (str1 == null) {\n+            return str2;\n+        }\n+        if (str2 == null) {\n+            return str1;\n+        }\n+        int at = differenceAt(str1, str2);\n         if (at == -1) {\n             return \"\";\n         }\n-        return s2.substring(at);\n+        return str2.substring(at);\n     }\n \n     /**\n      * <p>For example, \n      * <code>differenceAt(\"i am a machine\", \"i am a robot\") -> 7</code></p>\n      *\n-     * @return the index where s2 and s1 begin to differ; -1 if they are equal\n-     */\n-    public static int differenceAt(String s1, String s2) {\n+     * @param str1  the first string, may be null\n+     * @param str2  the second string, may be null\n+     * @return the index where str2 and str1 begin to differ; -1 if they are equal\n+     */\n+    public static int differenceAt(String str1, String str2) {\n+        if (str1 == str2) {\n+            return -1;\n+        }\n+        if (str1 == null || str2 == null) {\n+            return 0;\n+        }\n         int i;\n-        for (i=0; i<s1.length() && i<s2.length(); ++i) {\n-            if (s1.charAt(i) != s2.charAt(i)) {\n+        for (i = 0; i < str1.length() && i < str2.length(); ++i) {\n+            if (str1.charAt(i) != str2.charAt(i)) {\n                 break;\n             }\n         }\n-        if (i<s2.length() || i<s1.length()) {\n+        if (i < str2.length() || i < str1.length()) {\n             return i;\n         }\n         return -1;\n      * <p>This implemmentation of the levenshtein distance algorithm\n      * is from <a href=\"http://www.merriampark.com/ld.htm\">http://www.merriampark.com/ld.htm</a></p>\n      * \n-     * @param s the first String\n-     * @param t the second String\n+     * @param s  the first String, must not be null\n+     * @param t  the second String, must not be null\n      * @return result distance\n-     * @throws NullPointerException if s or t is <code>null</code>\n+     * @throws IllegalArgumentException if s or t is <code>null</code>\n      */\n     public static int getLevenshteinDistance(String s, String t) {\n+        if (s == null || t == null) {\n+            throw new IllegalArgumentException(\"Strings must not be null\");\n+        }\n         int d[][]; // matrix\n         int n; // length of s\n         int m; // length of t\n--- a/src/test/org/apache/commons/lang/StringUtilsSubstringTest.java\n+++ b/src/test/org/apache/commons/lang/StringUtilsSubstringTest.java\n  *\n  * @author <a href=\"mailto:scolebourne@joda.org\">Stephen Colebourne</a>\n  * @author <a href=\"mailto:ridesmet@users.sourceforge.net\">Ringo De Smet</a>\n- * @version $Id: StringUtilsSubstringTest.java,v 1.3 2003/03/23 21:51:19 scolebourne Exp $\n+ * @version $Id: StringUtilsSubstringTest.java,v 1.4 2003/07/16 23:45:39 scolebourne Exp $\n  */\n public class StringUtilsSubstringTest extends TestCase {\n     private static final String FOO = \"foo\";\n     }\n \n     public void testCountMatches() {\n-        try {\n-            assertEquals(-1, \n-                StringUtils.countMatches(null, null));\n-            throw new RuntimeException(\"Should have thrown a NullPointerException. \");\n-        } catch(NullPointerException npe) {\n-        }\n-\n-        assertEquals(0, \n-             StringUtils.countMatches(\"x\", \"\") );\n-        assertEquals(0, \n-             StringUtils.countMatches(\"\", \"\") );\n+        assertEquals(0, StringUtils.countMatches(null, null));\n+        assertEquals(0, StringUtils.countMatches(\"blah\", null));\n+        assertEquals(0, StringUtils.countMatches(null, \"DD\"));\n+\n+        assertEquals(0, StringUtils.countMatches(\"x\", \"\"));\n+        assertEquals(0, StringUtils.countMatches(\"\", \"\"));\n \n         assertEquals(3, \n              StringUtils.countMatches(\"one long someone sentence of one\", \"one\"));\n--- a/src/test/org/apache/commons/lang/StringUtilsTest.java\n+++ b/src/test/org/apache/commons/lang/StringUtilsTest.java\n package org.apache.commons.lang;\n \n import java.util.Arrays;\n+import java.util.Iterator;\n \n import junit.framework.Test;\n import junit.framework.TestCase;\n  * @author <a href=\"mailto:fredrik@westermarck.com>Fredrik Westermarck</a>\n  * @author Holger Krauth\n  * @author <a href=\"hps@intermeta.de\">Henning P. Schmiedehausen</a>\n- * @version $Id: StringUtilsTest.java,v 1.23 2003/07/16 21:23:50 scolebourne Exp $\n+ * @version $Id: StringUtilsTest.java,v 1.24 2003/07/16 23:45:39 scolebourne Exp $\n  */\n public class StringUtilsTest extends TestCase {\n \n     }\n \n     public void testJoin() {\n+        assertEquals(null, StringUtils.concatenate(null));\n+        assertEquals(null, StringUtils.join((Object[]) null, null));\n+        assertEquals(null, StringUtils.join((Object[]) null, ','));\n+        assertEquals(null, StringUtils.join((Iterator) null, null));\n+        assertEquals(null, StringUtils.join((Iterator) null, ','));\n+        \n         assertEquals(\"concatenate(Object[]) failed\",\n                      TEXT_LIST_NOSEP, StringUtils.concatenate(ARRAY_LIST));\n         assertEquals(\"join(Object[], String) failed\", TEXT_LIST,\n     public void testOverlayString() {\n         assertEquals(\"overlayString(String, String, int, int) failed\",\n                      \"foo foor baz\", StringUtils.overlayString(SENTENCE, FOO, 4, 6) );\n+        assertEquals(null, StringUtils.overlayString(null, null, 2, 4));\n+        assertEquals(\"abef\", StringUtils.overlayString(\"abcdef\", null, 2, 4));\n+        assertEquals(\"abef\", StringUtils.overlayString(\"abcdef\", \"\", 2, 4));\n+        assertEquals(\"abzzzzef\", StringUtils.overlayString(\"abcdef\", \"zzzz\", 2, 4));\n+        assertEquals(\"abcdzzzzcdef\", StringUtils.overlayString(\"abcdef\", \"zzzz\", 4, 2));\n+        try {\n+            StringUtils.overlayString(\"abcdef\", \"zzzz\", -1, 4);\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            StringUtils.overlayString(\"abcdef\", \"zzzz\", 2, 8);\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {}\n     }\n \n     public void testRepeat() {\n     }\n \n     public void testCenter() {\n-        assertEquals(\"center(String, int) failed\",\n-                     \"   \"+FOO+\"   \", StringUtils.center(FOO, 9) );\n+        assertEquals(null, StringUtils.center(null, -1));\n+        assertEquals(null, StringUtils.center(null, 4));\n+        assertEquals(\"    \", StringUtils.center(\"\", 4));\n+        assertEquals(\" ab \", StringUtils.center(\"ab\", 4));\n+        assertEquals(\"abcd\", StringUtils.center(\"abcd\", 2));\n+        assertEquals(\" a  \", StringUtils.center(\"a\", 4));\n+\n+        assertEquals(null, StringUtils.center(null, -1, \" \"));\n+        assertEquals(null, StringUtils.center(null, 4, \" \"));\n+        assertEquals(\"    \", StringUtils.center(\"\", 4, \" \"));\n+        assertEquals(\" ab \", StringUtils.center(\"ab\", 4, \" \"));\n+        assertEquals(\"abcd\", StringUtils.center(\"abcd\", 2, \" \"));\n+        assertEquals(\" a  \", StringUtils.center(\"a\", 4, \" \"));\n+        assertEquals(\"yayz\", StringUtils.center(\"a\", 4, \"yz\"));\n+        try {\n+            StringUtils.center(\"abc\", 4, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+        }\n+        try {\n+            StringUtils.center(\"abc\", 4, \"\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+        }\n     }\n \n     public void testDeprecatedChompFunctions() {\n             { \"\\n\", \"\" },\n             { \"\\r\", \"\" },\n             { \"\\r\\n\", \"\" },\n+            { null, null },\n+            { \"\", \"\" },\n+            { \"a\", \"\" },\n         };\n         for (int i = 0; i < chopCases.length; i++) {\n             String original = chopCases[i][0];\n             {\"foo\\nbar\", \"foo\"},\n             {\"foo\\nbar\\n\", \"foo\\nbar\"},\n             {\"foo\\nbar\\nbaz\", \"foo\\nbar\"},\n+            {null, null},\n+            {\"\", \"\"},\n+            {\"foo\", \"foo\"},\n         };\n         for (int i = 0; i < sliceCases.length; i++) {\n             String original = sliceCases[i][0];\n         String original = \"fooXXbarXXbaz\";\n         String sep = \"XX\";\n \n-        assertEquals(\"slice(String,String) failed\",\n-                     \"fooXXbar\", StringUtils.slice(original, sep) );\n-\n-        assertEquals(\"sliceRemainder(String, String) failed\",\n-                     \"baz\", StringUtils.sliceRemainder(original, sep) );\n-\n-        assertEquals(\"sliceFirst(String, String) failed\",\n-                     \"foo\", StringUtils.sliceFirst(original, sep) );\n-\n-        assertEquals(\"sliceFirstRemainder(String, String) failed\",\n-                     \"barXXbaz\", StringUtils.sliceFirstRemainder(original, sep) );\n+        assertEquals(\"fooXXbar\", StringUtils.slice(original, sep) );\n+        assertEquals(null, StringUtils.slice(null, sep) );\n+        assertEquals(null, StringUtils.slice(null, null) );\n+        assertEquals(\"foo\", StringUtils.slice(\"foo\", null) );\n+        assertEquals(\"foo\", StringUtils.slice(\"foo\", \"b\") );\n+        assertEquals(\"fo\", StringUtils.slice(\"foo\", \"o\") );\n+\n+        assertEquals(\"baz\", StringUtils.sliceRemainder(original, sep) );\n+        assertEquals(null, StringUtils.sliceRemainder(null, sep) );\n+        assertEquals(null, StringUtils.sliceRemainder(null, null) );\n+        assertEquals(\"\", StringUtils.sliceRemainder(\"foo\", null) );\n+        assertEquals(\"\", StringUtils.sliceRemainder(\"foo\", \"b\") );\n+        assertEquals(\"t\", StringUtils.sliceRemainder(\"foot\", \"o\") );\n+\n+        assertEquals(\"foo\", StringUtils.sliceFirst(original, sep) );\n+\n+        assertEquals(\"barXXbaz\", StringUtils.sliceFirstRemainder(original, sep) );\n \n     }\n \n     public void testPadFunctions() {\n-        assertEquals(\"rightPad(String, int) failed\",\n-                     \"1234    \", StringUtils.rightPad (\"1234\", 8) );\n-\n-        assertEquals(\"rightPad(String, int, String) failed\",\n-                     \"1234-+-+\", StringUtils.rightPad (\"1234\", 8, \"-+\") );\n-\n-        assertEquals(\"rightPad(String, int, String) failed\",\n-                     \"123456-+~\", StringUtils.rightPad (\"123456\", 9, \"-+~\") );\n-\n-        assertEquals(\"leftPad(String, int) failed\",\n-                     \"    1234\", StringUtils.leftPad(\"1234\", 8) );\n-\n-        assertEquals(\"leftPad(String, int, String) failed\",\n-                     \"-+-+1234\", StringUtils.leftPad(\"1234\", 8, \"-+\") );\n-\n-        assertEquals(\"leftPad(String, int, String) failed\",\n-                     \"-+~123456\", StringUtils.leftPad(\"123456\", 9, \"-+~\") );\n+        assertEquals(null, StringUtils.rightPad (null, 8) );\n+        assertEquals(\"1234    \", StringUtils.rightPad (\"1234\", 8) );\n+        \n+        assertEquals(null, StringUtils.rightPad (null, 8, \"-+\") );\n+        assertEquals(\"1234-+-+\", StringUtils.rightPad (\"1234\", 8, \"-+\") );\n+        assertEquals(\"123456-+~\", StringUtils.rightPad (\"123456\", 9, \"-+~\") );\n+        assertEquals(\"123456-+\", StringUtils.rightPad (\"123456\", 8, \"-+~\") );\n+        try {\n+            StringUtils.rightPad(\"123456\", 6, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            StringUtils.rightPad(\"123456\", 6, \"\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        \n+        assertEquals(null, StringUtils.leftPad (null, 8) );\n+        assertEquals(\"    1234\", StringUtils.leftPad(\"1234\", 8) );\n+        \n+        assertEquals(null, StringUtils.leftPad (null, 8, \"-+\") );\n+        assertEquals(\"-+-+1234\", StringUtils.leftPad(\"1234\", 8, \"-+\") );\n+        assertEquals(\"-+~123456\", StringUtils.leftPad(\"123456\", 9, \"-+~\") );\n+        assertEquals(\"-+123456\", StringUtils.leftPad(\"123456\", 8, \"-+~\") );\n+        try {\n+            StringUtils.leftPad(\"123456\", 6, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            StringUtils.leftPad(\"123456\", 6, \"\");\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n     }\n \n     public void testReverseFunctions() {\n-        assertEquals(\"reverse(String) failed\",\n-                     \"sdrawkcab\", StringUtils.reverse(\"backwards\") );\n-        assertEquals(\"reverse(empty-string) failed\",\n-                     \"\", StringUtils.reverse(\"\") );\n-        assertEquals(\"reverseDelimitedString(String,'.') failed\",\n-                     \"org.apache.test\",\n+        assertEquals(\"sdrawkcab\", StringUtils.reverse(\"backwards\") );\n+        assertEquals(\"\", StringUtils.reverse(\"\") );\n+        assertEquals(null, StringUtils.reverse(null) );\n+        \n+        assertEquals(\"org.apache.test\",\n                        StringUtils.reverseDelimitedString(\"test.apache.org\", \".\") );\n         assertEquals(\"reverseDelimitedString(empty-string,'.') failed\",\n                      \"\",\n         assertEquals(\"indexOfAnyBut(String3, chars3)\", -1, StringUtils.indexOfAnyBut(str3, chars3));\n     }\n \n-    public void testAbbreviate()\n-    {\n+    public void testAbbreviate() {\n+        assertEquals(null, StringUtils.abbreviate(null, 10));\n         assertEquals(\"abbreviate(String,int) failed\",\n \t\t     \"short\", StringUtils.abbreviate(\"short\", 10));\n         assertEquals(\"abbreviate(String,int) failed\",\n         assertEquals(\"abbreviate(String,int,int) failed\",\n                 \"raspberry peach\", StringUtils.abbreviate(raspberry, 11, 15));\n \n+        assertEquals(null, StringUtils.abbreviate(null, 7, 14));\n         assertAbbreviateWithOffset(\"abcdefg...\", -1, 10);\n         assertAbbreviateWithOffset(\"abcdefg...\", 0, 10);\n         assertAbbreviateWithOffset(\"abcdefg...\", 1, 10);\n         assertEquals(message, expected, actual);\n     }\n \n-    public void testDifference()\n-    {\n+    public void testDifference() {\n+        assertEquals(null, StringUtils.difference(null, null));\n+        assertEquals(\"i am a robot\", StringUtils.difference(null, \"i am a robot\"));\n+        assertEquals(\"i am a machine\", StringUtils.difference(\"i am a machine\", null));\n         assertEquals(\"robot\", StringUtils.difference(\"i am a machine\", \"i am a robot\"));\n         assertEquals(\"\", StringUtils.difference(\"foo\", \"foo\"));\n         assertEquals(\"you are a robot\", StringUtils.difference(\"i am a robot\", \"you are a robot\"));\n     }\n \n-    public void testDifferenceAt()\n-    {\n+    public void testDifferenceAt() {\n+        assertEquals(-1, StringUtils.differenceAt(null, null));\n+        assertEquals(0, StringUtils.differenceAt(null, \"i am a robot\"));\n+        assertEquals(0, StringUtils.differenceAt(\"i am a machine\", null));\n         assertEquals(7, StringUtils.differenceAt(\"i am a machine\", \"i am a robot\"));\n         assertEquals(-1, StringUtils.differenceAt(\"foo\", \"foo\"));\n         assertEquals(0, StringUtils.differenceAt(\"i am a robot\", \"you are a robot\"));", "timestamp": 1058399139, "metainfo": ""}