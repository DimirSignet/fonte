{"sha": "b2e93d61571b3084d41a8da0a8fb9f681f143cb1", "log": "Change Identifier generation code to be independent of functors   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/util/IdentifierFactory.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.util;\n+\n+/**\n+ * <p><code>IdentifierFactory</code> defines a simple interface for\n+ * identifier generation.</p>\n+ *\n+ * @author Stephen Colebourne\n+ * @since 2.0\n+ * @version $Id: IdentifierFactory.java,v 1.1 2003/05/16 22:06:43 scolebourne Exp $\n+ */\n+public interface IdentifierFactory {\n+\n+    /**\n+     * <p>Gets the next identifier in the sequence.</p>\n+     * \n+     * @return the next identifier in sequence\n+     */\n+    Object nextIdentifier();\n+\n+}\n--- a/src/java/org/apache/commons/lang/util/IdentifierUtils.java\n+++ b/src/java/org/apache/commons/lang/util/IdentifierUtils.java\n import java.io.Serializable;\n import java.util.Random;\n \n-import org.apache.commons.lang.functor.Factory;\n-import org.apache.commons.lang.functor.FactoryException;\n /**\n  * <p><code>IdentifierUtils</code> provides a number of different identifier\n  * reference implementations.</p>\n  * \n- * <p>All the identifer factories are serializable and synchronized. The\n- * factories all implement the <i>functor</i> \n- * {@link org.apache.commons.lang.functor.Factory Factory} interface</p>\n+ * <p>All the identifer factories are serializable and synchronized.\n+ * The factories all implement one of the factory interfaces defined in this\n+ * package. This allows you to obtain and use multiple factories for \n+ * different reasons.</p>\n  *\n  * @author Stephen Colebourne\n  * @since 2.0\n- * @version $Id: IdentifierUtils.java,v 1.4 2003/04/09 01:04:48 ggregory Exp $\n+ * @version $Id: IdentifierUtils.java,v 1.5 2003/05/16 22:06:43 scolebourne Exp $\n  */\n public class IdentifierUtils {\n \n      * <li>...\n      * </ul>\n \t */\n-    public static final Factory LONG_IDENTIFIER_FACTORY = new LongIdentifierFactory(true, 0L);\n+    public static final LongIdentifierFactory LONG_IDENTIFIER_FACTORY = new LongNumericIdentifierFactory(true, 0L);\n     /**\n      * <p>Singleton instance of the <code>StringNumericIdentifierFactory</code>.\n      * </p>\n      * <li>...\n      * </ul>\n      */\n-    public static final Factory STRING_NUMERIC_IDENTIFIER_FACTORY = new StringNumericIdentifierFactory(true, 0L);\n+    public static final StringIdentifierFactory STRING_NUMERIC_IDENTIFIER_FACTORY = new StringNumericIdentifierFactory(true, 0L);\n     /**\n      * <p>Singleton instance of the\n      * <code>StringAlphanumericIdentifierFactory</code>.</p>\n      * <li>...\n      * </ul>\n      */\n-    public static final Factory STRING_ALPHANUMERIC_IDENTIFIER_FACTORY = new StringAlphanumericIdentifierFactory(true, 15);\n+    public static final StringIdentifierFactory STRING_ALPHANUMERIC_IDENTIFIER_FACTORY = new StringAlphanumericIdentifierFactory(true, 15);\n     /**\n      * <p>Singleton instance of the\n      * <code>StringSessionIdentifierFactory</code>.</p>\n      * \n      * <p>The objects returned are 10 or more base-36 digits.</p>\n      */\n-    public static final Factory STRING_SESSION_IDENTIFIER_FACTORY = new StringSessionIdentifierFactory();\n+    public static final StringIdentifierFactory STRING_SESSION_IDENTIFIER_FACTORY = new StringSessionIdentifierFactory();\n \n     //---------------------------------------------------------------------------------\n     \n      * @return a new identifier\n      */\n     public static Long nextLongIdentifier() {\n-        return (Long) LONG_IDENTIFIER_FACTORY.create();\n+        return LONG_IDENTIFIER_FACTORY.nextLongIdentifier();\n     }\n \n     /**\n      * \n      * @return a new identifier factory\n      */\n-    public static Factory longIdentifierFactory() {\n-        return new LongIdentifierFactory(true, 0L);\n+    public static LongIdentifierFactory longIdentifierFactory() {\n+        return new LongNumericIdentifierFactory(true, 0L);\n     }\n \n     /**\n      * increasing in size.</p>\n      * \n      * @param wrap  should the factory wrap when it reaches the maximum \n-     *  long value (or throw an exception)\n+     *  long value (or throw an IllegalStateException)\n      * @param initialValue  the initial long value to start at\n      * @return a new identifier factory\n      */\n-    public static Factory longIdentifierFactory(boolean wrap, long initialValue) {\n-        return new LongIdentifierFactory(wrap, initialValue);\n+    public static LongIdentifierFactory longIdentifierFactory(boolean wrap, long initialValue) {\n+        return new LongNumericIdentifierFactory(wrap, initialValue);\n     }\n     \n     //---------------------------------------------------------------------------------\n      * @return a new identifier\n      */\n     public static String nextStringNumericIdentifier() {\n-        return (String) STRING_NUMERIC_IDENTIFIER_FACTORY.create();\n+        return STRING_NUMERIC_IDENTIFIER_FACTORY.nextStringIdentifier();\n     }\n \n     /**\n      * \n      * @return a new identifier factory\n      */\n-    public static Factory stringNumericIdentifierFactory() {\n+    public static StringIdentifierFactory stringNumericIdentifierFactory() {\n         return new StringNumericIdentifierFactory(true, 0L);\n     }\n \n      * representing numbers increasing in size.</p>\n      * \n      * @param wrap  should the factory wrap when it reaches the maximum \n-     *  long value (or throw an exception)\n+     *  long value (or throw an IllegalStateException)\n      * @param initialValue  the initial long value to start at\n      * @return a new identifier factory\n      */\n-    public static Factory stringNumericIdentifierFactory(boolean wrap, long initialValue) {\n+    public static StringIdentifierFactory stringNumericIdentifierFactory(boolean wrap, long initialValue) {\n         return new StringNumericIdentifierFactory(wrap, initialValue);\n     }\n     \n      * @return a new identifier\n      */\n     public static String nextStringAlphanumericIdentifier() {\n-        return (String) STRING_ALPHANUMERIC_IDENTIFIER_FACTORY.create();\n+        return STRING_ALPHANUMERIC_IDENTIFIER_FACTORY.nextStringIdentifier();\n     }\n \n     /**\n      * \n      * @return a new identifier factory\n      */\n-    public static Factory stringAlphanumericIdentifierFactory() {\n+    public static StringIdentifierFactory stringAlphanumericIdentifierFactory() {\n         return new StringAlphanumericIdentifierFactory(true, 15);\n     }\n \n      * representing numbers increasing in size in base-36.</p>\n      * \n      * @param wrap  should the factory wrap when it reaches the maximum \n-     *  size (or throw an exception)\n+     *  size (or throw an IllegalStateException)\n      * @param size  the number of characters the id should fill\n      * @return a new identifier factory\n      */\n-    public static Factory stringAlphanumericIdentifierFactory(boolean wrap, int size) {\n+    public static StringIdentifierFactory stringAlphanumericIdentifierFactory(boolean wrap, int size) {\n         return new StringAlphanumericIdentifierFactory(wrap, size);\n     }\n     \n      * String Session factory.\n      * </p>\n      * \n-     * <p>The singleton instance is not guaranteed to be unique (although its\n-     * pretty unlikely), so in a long- lived server, the id may be duplicated.\n-     * </p>\n+     * <p>The generation routine is based on a random number and a counter\n+     * within a 2 second time interval.</p>\n      * \n      * @return a new identifier\n      */\n     public static String nextStringSessionIdentifier() {\n-        return (String) STRING_SESSION_IDENTIFIER_FACTORY.create();\n+        return STRING_SESSION_IDENTIFIER_FACTORY.nextStringIdentifier();\n     }\n \n     /**\n      * \n      * @return a new identifier factory\n      */\n-    public static Factory stringSessionIdentifierFactory() {\n+    public static StringIdentifierFactory stringSessionIdentifierFactory() {\n         return new StringSessionIdentifierFactory();\n     }\n \n      *\n      * @author Stephen Colebourne\n      */\n-    private static class LongIdentifierFactory implements Factory, Serializable {\n+    private static class LongNumericIdentifierFactory implements LongIdentifierFactory, Serializable {\n     \n         /** Should the counter wrap. */\n         private final boolean wrap;\n          *  long value (or throw an exception)\n          * @param initialValue  the initial long value to start at\n          */\n-        private LongIdentifierFactory(boolean wrap, long initialValue) {\n+        private LongNumericIdentifierFactory(boolean wrap, long initialValue) {\n             super();\n             this.wrap = wrap;\n             this.count = initialValue;\n         }\n \n         /**\n-         * Create a new identifier.\n+         * Gets the next new identifier.\n          * \n          * @return a new identifier as a Long\n          */\n-        public Object create() {\n+        public Object nextIdentifier() {\n+            return nextLongIdentifier();\n+        }\n+        \n+        /**\n+         * Gets the next new identifier.\n+         * \n+         * @return a new identifier as a Long\n+         */\n+        public Long nextLongIdentifier() {\n             long value = 0;\n             if (wrap) {\n                 synchronized (this) {\n             } else {\n                 synchronized (this) {\n                     if (count == Long.MAX_VALUE) {\n-                        throw new FactoryException(\"The maximum number of identifiers has been reached\");\n+                        throw new IllegalStateException(\"The maximum number of identifiers has been reached\");\n                     }\n                     value = count++;\n                 }\n      *\n      * @author Stephen Colebourne\n      */\n-    private static class StringNumericIdentifierFactory implements Factory, Serializable {\n+    private static class StringNumericIdentifierFactory implements StringIdentifierFactory, Serializable {\n     \n         /** Should the counter wrap. */\n         private final boolean wrap;\n         }\n \n         /**\n-         * Create a new identifier.\n+         * Gets the next new identifier.\n          * \n          * @return a new identifier as a String\n          */\n-        public Object create() {\n+        public Object nextIdentifier() {\n+            return nextStringIdentifier();\n+        }\n+        \n+        /**\n+         * Gets the next new identifier.\n+         * \n+         * @return a new identifier as a String\n+         */\n+        public String nextStringIdentifier() {\n             long value = 0;\n             if (wrap) {\n                 synchronized (this) {\n             } else {\n                 synchronized (this) {\n                     if (count == Long.MAX_VALUE) {\n-                        throw new FactoryException(\"The maximum number of identifiers has been reached\");\n+                        throw new IllegalStateException(\"The maximum number of identifiers has been reached\");\n                     }\n                     value = count++;\n                 }\n      *\n      * @author Stephen Colebourne\n      */\n-    private static class StringAlphanumericIdentifierFactory implements Factory, Serializable {\n+    private static class StringAlphanumericIdentifierFactory implements StringIdentifierFactory, Serializable {\n     \n         /** Should the counter wrap. */\n         private final boolean wrap;\n         }\n \n         /**\n-         * Create a new identifier.\n+         * Gets the next new identifier.\n          * \n          * @return a new identifier as a String\n          */\n-        public synchronized Object create() {\n+        public Object nextIdentifier() {\n+            return nextStringIdentifier();\n+        }\n+        \n+        /**\n+         * Gets the next new identifier.\n+         * \n+         * @return a new identifier as a String\n+         */\n+        public synchronized String nextStringIdentifier() {\n             for (int i = count.length - 1; i >= 0; i--) {\n                 switch (count[i]) {\n                     case 122:  // z\n                     count[i] = '0';\n                     if (i == 0 && wrap == false) {\n-                        throw new FactoryException(\"The maximum number of identifiers has been reached\");\n+                        throw new IllegalStateException(\"The maximum number of identifiers has been reached\");\n                     }\n                     break;\n                     \n      * @author Neeme Praks\n      * @author Stephen Colebourne\n      */\n-    private static class StringSessionIdentifierFactory implements Factory, Serializable {\n+    private static class StringSessionIdentifierFactory implements StringIdentifierFactory, Serializable {\n \n         /**\n          * We want to have a random string with a length of 6 characters.\n         private StringSessionIdentifierFactory() {\n             super();\n         }\n-\n-        /**\n-         * Create a new identifier. Only guaranteed unique within\n+        \n+        /**\n+         * Gets the next identifier.\n+         * \n+         * @return the next 10 char String identifier\n+         */\n+        public Object nextIdentifier() {\n+            return nextStringIdentifier();\n+        }\n+\n+        /**\n+         * Gets the next new identifier. Only guaranteed unique within\n          * this JVM, but fairly safe for cross JVM usage as well.\n          * \n          * <p>Format of identifier is\n          * [6 chars random][3 chars time][1+ chars count]</p>\n          * \n-         * @return a new identifier as a Long\n-         */\n-        public Object create() {\n+         * @return the next 10 char String identifier\n+         */\n+        public String nextStringIdentifier() {\n             // Random value\n             //--------------\n             long currentRandom = randomizer.nextLong();\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/util/LongIdentifierFactory.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.util;\n+\n+/**\n+ * <p><code>LongIdentifierFactory</code> defines a simple interface for\n+ * Long based identifier generation.</p>\n+ *\n+ * @author Stephen Colebourne\n+ * @since 2.0\n+ * @version $Id: LongIdentifierFactory.java,v 1.1 2003/05/16 22:06:43 scolebourne Exp $\n+ */\n+public interface LongIdentifierFactory extends IdentifierFactory {\n+\n+    /**\n+     * <p>Gets the next identifier in the sequence.</p>\n+     * \n+     * @return the next Long identifier in sequence\n+     */\n+    Long nextLongIdentifier();\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/lang/util/StringIdentifierFactory.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.lang.util;\n+\n+/**\n+ * <p><code>StringIdentifierFactory</code> defines a simple interface for\n+ * String based identifier generation.</p>\n+ *\n+ * @author Stephen Colebourne\n+ * @since 2.0\n+ * @version $Id: StringIdentifierFactory.java,v 1.1 2003/05/16 22:06:43 scolebourne Exp $\n+ */\n+public interface StringIdentifierFactory extends IdentifierFactory {\n+\n+    /**\n+     * <p>Gets the next identifier in the sequence.</p>\n+     * \n+     * @return the next String identifier in sequence\n+     */\n+    String nextStringIdentifier();\n+\n+}\n--- a/src/test/org/apache/commons/lang/util/IdentifierUtilsTest.java\n+++ b/src/test/org/apache/commons/lang/util/IdentifierUtilsTest.java\n import junit.framework.Test;\n import junit.framework.TestSuite;\n \n-import org.apache.commons.lang.functor.Factory;\n-import org.apache.commons.lang.functor.FactoryException;\n /**\n  * Tests the org.apache.commons.lang.util.IdentifierUtils class.\n  *\n  * @author Stephen Colebourne\n- * @version $Id: IdentifierUtilsTest.java,v 1.1 2002/12/29 21:35:03 scolebourne Exp $\n+ * @version $Id: IdentifierUtilsTest.java,v 1.2 2003/05/16 22:07:38 scolebourne Exp $\n  */\n public class IdentifierUtilsTest extends junit.framework.TestCase {\n \n     //--------------------------------------------------------------------------\n \n     public void testLongIncrementing() {\n-        Factory f = IdentifierUtils.LONG_IDENTIFIER_FACTORY;\n-        assertEquals(new Long(0), f.create());\n-        assertEquals(new Long(1), f.create());\n-        assertEquals(new Long(2), f.create());\n-        assertEquals(new Long(3), f.create());\n+        LongIdentifierFactory f = IdentifierUtils.LONG_IDENTIFIER_FACTORY;\n+        assertEquals(new Long(0), f.nextLongIdentifier());\n+        assertEquals(new Long(1), f.nextLongIdentifier());\n+        assertEquals(new Long(2), f.nextIdentifier());\n+        assertEquals(new Long(3), f.nextLongIdentifier());\n         assertEquals(new Long(4), IdentifierUtils.nextLongIdentifier());\n-        assertEquals(new Long(5), f.create());\n+        assertEquals(new Long(5), f.nextLongIdentifier());\n         assertEquals(new Long(6), IdentifierUtils.nextLongIdentifier());\n         assertEquals(new Long(7), IdentifierUtils.nextLongIdentifier());\n     }\n \n     public void testLongIncrementingNoArgs() {\n-        Factory f = IdentifierUtils.longIdentifierFactory();\n-        assertEquals(new Long(0), f.create());\n-        assertEquals(new Long(1), f.create());\n+        LongIdentifierFactory f = IdentifierUtils.longIdentifierFactory();\n+        assertEquals(new Long(0), f.nextLongIdentifier());\n+        assertEquals(new Long(1), f.nextLongIdentifier());\n         assertTrue(f != IdentifierUtils.LONG_IDENTIFIER_FACTORY);\n     }\n \n     public void testLongIncrementingInit() {\n-        Factory f = IdentifierUtils.longIdentifierFactory(true, 100);\n-        assertEquals(new Long(100), f.create());\n-        assertEquals(new Long(101), f.create());\n+        LongIdentifierFactory f = IdentifierUtils.longIdentifierFactory(true, 100);\n+        assertEquals(new Long(100), f.nextLongIdentifier());\n+        assertEquals(new Long(101), f.nextLongIdentifier());\n     }\n \n     public void testLongIncrementingWrap() {\n-        Factory f = IdentifierUtils.longIdentifierFactory(true, Long.MAX_VALUE);\n-        assertEquals(new Long(Long.MAX_VALUE), f.create());\n-        assertEquals(new Long(Long.MIN_VALUE), f.create());\n+        LongIdentifierFactory f = IdentifierUtils.longIdentifierFactory(true, Long.MAX_VALUE);\n+        assertEquals(new Long(Long.MAX_VALUE), f.nextLongIdentifier());\n+        assertEquals(new Long(Long.MIN_VALUE), f.nextLongIdentifier());\n     }\n \n     public void testLongIncrementingNoWrap() {\n-        Factory f = IdentifierUtils.longIdentifierFactory(false, Long.MAX_VALUE);\n+        LongIdentifierFactory f = IdentifierUtils.longIdentifierFactory(false, Long.MAX_VALUE);\n         try {\n-            f.create();\n+            f.nextLongIdentifier();\n             fail();\n-        } catch (FactoryException ex) {}\n+        } catch (IllegalStateException ex) {}\n     }\n \n     //--------------------------------------------------------------------------\n \n     public void testStringNumericLong() {\n-        Factory f = IdentifierUtils.STRING_NUMERIC_IDENTIFIER_FACTORY;\n-        assertEquals(\"0\", f.create());\n-        assertEquals(\"1\", f.create());\n-        assertEquals(\"2\", f.create());\n-        assertEquals(\"3\", f.create());\n+        StringIdentifierFactory f = IdentifierUtils.STRING_NUMERIC_IDENTIFIER_FACTORY;\n+        assertEquals(\"0\", f.nextStringIdentifier());\n+        assertEquals(\"1\", f.nextStringIdentifier());\n+        assertEquals(\"2\", f.nextIdentifier());\n+        assertEquals(\"3\", f.nextStringIdentifier());\n         assertEquals(\"4\", IdentifierUtils.nextStringNumericIdentifier());\n-        assertEquals(\"5\", f.create());\n+        assertEquals(\"5\", f.nextStringIdentifier());\n         assertEquals(\"6\", IdentifierUtils.nextStringNumericIdentifier());\n         assertEquals(\"7\", IdentifierUtils.nextStringNumericIdentifier());\n     }\n \n     public void testStringNumericNoArgs() {\n-        Factory f = IdentifierUtils.stringNumericIdentifierFactory();\n-        assertEquals(\"0\", f.create());\n-        assertEquals(\"1\", f.create());\n+        StringIdentifierFactory f = IdentifierUtils.stringNumericIdentifierFactory();\n+        assertEquals(\"0\", f.nextStringIdentifier());\n+        assertEquals(\"1\", f.nextStringIdentifier());\n         assertTrue(f != IdentifierUtils.STRING_NUMERIC_IDENTIFIER_FACTORY);\n     }\n \n     public void testStringNumericInit() {\n-        Factory f = IdentifierUtils.stringNumericIdentifierFactory(true, 100);\n-        assertEquals(\"100\", f.create());\n-        assertEquals(\"101\", f.create());\n+        StringIdentifierFactory f = IdentifierUtils.stringNumericIdentifierFactory(true, 100);\n+        assertEquals(\"100\", f.nextStringIdentifier());\n+        assertEquals(\"101\", f.nextStringIdentifier());\n     }\n \n     public void testStringNumericWrap() {\n-        Factory f = IdentifierUtils.stringNumericIdentifierFactory(true, Long.MAX_VALUE);\n-        assertEquals(Long.toString(Long.MAX_VALUE), f.create());\n-        assertEquals(Long.toString(Long.MIN_VALUE), f.create());\n+        StringIdentifierFactory f = IdentifierUtils.stringNumericIdentifierFactory(true, Long.MAX_VALUE);\n+        assertEquals(Long.toString(Long.MAX_VALUE), f.nextStringIdentifier());\n+        assertEquals(Long.toString(Long.MIN_VALUE), f.nextStringIdentifier());\n     }\n \n     public void testStringNumericNoWrap() {\n-        Factory f = IdentifierUtils.stringNumericIdentifierFactory(false, Long.MAX_VALUE);\n+        StringIdentifierFactory f = IdentifierUtils.stringNumericIdentifierFactory(false, Long.MAX_VALUE);\n         try {\n-            f.create();\n+            f.nextStringIdentifier();\n             fail();\n-        } catch (FactoryException ex) { }\n+        } catch (IllegalStateException ex) { }\n     }\n \n     //--------------------------------------------------------------------------\n \n     public void testStringAlphanumeric() {\n-        Factory f = IdentifierUtils.STRING_ALPHANUMERIC_IDENTIFIER_FACTORY;\n-        assertEquals(\"000000000000001\", f.create());\n-        assertEquals(\"000000000000002\", f.create());\n-        assertEquals(\"000000000000003\", f.create());\n-        assertEquals(\"000000000000004\", f.create());\n-        assertEquals(\"000000000000005\", f.create());\n-        assertEquals(\"000000000000006\", f.create());\n-        assertEquals(\"000000000000007\", f.create());\n-        assertEquals(\"000000000000008\", f.create());\n-        assertEquals(\"000000000000009\", f.create());\n-        assertEquals(\"00000000000000a\", f.create());\n-        assertEquals(\"00000000000000b\", f.create());\n-        assertEquals(\"00000000000000c\", f.create());\n+        StringIdentifierFactory f = IdentifierUtils.STRING_ALPHANUMERIC_IDENTIFIER_FACTORY;\n+        assertEquals(\"000000000000001\", f.nextStringIdentifier());\n+        assertEquals(\"000000000000002\", f.nextStringIdentifier());\n+        assertEquals(\"000000000000003\", f.nextStringIdentifier());\n+        assertEquals(\"000000000000004\", f.nextStringIdentifier());\n+        assertEquals(\"000000000000005\", f.nextStringIdentifier());\n+        assertEquals(\"000000000000006\", f.nextStringIdentifier());\n+        assertEquals(\"000000000000007\", f.nextStringIdentifier());\n+        assertEquals(\"000000000000008\", f.nextStringIdentifier());\n+        assertEquals(\"000000000000009\", f.nextStringIdentifier());\n+        assertEquals(\"00000000000000a\", f.nextStringIdentifier());\n+        assertEquals(\"00000000000000b\", f.nextStringIdentifier());\n+        assertEquals(\"00000000000000c\", f.nextStringIdentifier());\n         assertEquals(\"00000000000000d\", IdentifierUtils.nextStringAlphanumericIdentifier());\n-        assertEquals(\"00000000000000e\", f.create());\n-        assertEquals(\"00000000000000f\", f.create());\n-        assertEquals(\"00000000000000g\", f.create());\n-        assertEquals(\"00000000000000h\", f.create());\n-        assertEquals(\"00000000000000i\", f.create());\n-        assertEquals(\"00000000000000j\", f.create());\n-        assertEquals(\"00000000000000k\", f.create());\n-        assertEquals(\"00000000000000l\", f.create());\n-        assertEquals(\"00000000000000m\", f.create());\n-        assertEquals(\"00000000000000n\", f.create());\n-        assertEquals(\"00000000000000o\", f.create());\n-        assertEquals(\"00000000000000p\", f.create());\n-        assertEquals(\"00000000000000q\", f.create());\n-        assertEquals(\"00000000000000r\", f.create());\n-        assertEquals(\"00000000000000s\", f.create());\n-        assertEquals(\"00000000000000t\", f.create());\n-        assertEquals(\"00000000000000u\", f.create());\n-        assertEquals(\"00000000000000v\", f.create());\n-        assertEquals(\"00000000000000w\", f.create());\n-        assertEquals(\"00000000000000x\", f.create());\n-        assertEquals(\"00000000000000y\", f.create());\n-        assertEquals(\"00000000000000z\", f.create());\n-        assertEquals(\"000000000000010\", f.create());\n-        assertEquals(\"000000000000011\", f.create());\n-        assertEquals(\"000000000000012\", f.create());\n-        assertEquals(\"000000000000013\", f.create());\n+        assertEquals(\"00000000000000e\", f.nextStringIdentifier());\n+        assertEquals(\"00000000000000f\", f.nextStringIdentifier());\n+        assertEquals(\"00000000000000g\", f.nextStringIdentifier());\n+        assertEquals(\"00000000000000h\", f.nextStringIdentifier());\n+        assertEquals(\"00000000000000i\", f.nextStringIdentifier());\n+        assertEquals(\"00000000000000j\", f.nextStringIdentifier());\n+        assertEquals(\"00000000000000k\", f.nextStringIdentifier());\n+        assertEquals(\"00000000000000l\", f.nextStringIdentifier());\n+        assertEquals(\"00000000000000m\", f.nextStringIdentifier());\n+        assertEquals(\"00000000000000n\", f.nextStringIdentifier());\n+        assertEquals(\"00000000000000o\", f.nextStringIdentifier());\n+        assertEquals(\"00000000000000p\", f.nextStringIdentifier());\n+        assertEquals(\"00000000000000q\", f.nextStringIdentifier());\n+        assertEquals(\"00000000000000r\", f.nextStringIdentifier());\n+        assertEquals(\"00000000000000s\", f.nextStringIdentifier());\n+        assertEquals(\"00000000000000t\", f.nextStringIdentifier());\n+        assertEquals(\"00000000000000u\", f.nextStringIdentifier());\n+        assertEquals(\"00000000000000v\", f.nextStringIdentifier());\n+        assertEquals(\"00000000000000w\", f.nextStringIdentifier());\n+        assertEquals(\"00000000000000x\", f.nextStringIdentifier());\n+        assertEquals(\"00000000000000y\", f.nextStringIdentifier());\n+        assertEquals(\"00000000000000z\", f.nextStringIdentifier());\n+        assertEquals(\"000000000000010\", f.nextStringIdentifier());\n+        assertEquals(\"000000000000011\", f.nextStringIdentifier());\n+        assertEquals(\"000000000000012\", f.nextStringIdentifier());\n+        assertEquals(\"000000000000013\", f.nextStringIdentifier());\n     }\n \n     public void testLongAlphanumericNoArgs() {\n-        Factory f = IdentifierUtils.stringAlphanumericIdentifierFactory();\n-        assertEquals(\"000000000000001\", f.create());\n-        assertEquals(\"000000000000002\", f.create());\n+        StringIdentifierFactory f = IdentifierUtils.stringAlphanumericIdentifierFactory();\n+        assertEquals(\"000000000000001\", f.nextStringIdentifier());\n+        assertEquals(\"000000000000002\", f.nextStringIdentifier());\n         assertTrue(f != IdentifierUtils.STRING_ALPHANUMERIC_IDENTIFIER_FACTORY);\n     }\n \n     public void testStringAlphanumericWrap() {\n-        Factory f = IdentifierUtils.stringAlphanumericIdentifierFactory(true, 1);\n-        assertEquals(\"1\", f.create());\n-        assertEquals(\"2\", f.create());\n-        assertEquals(\"3\", f.create());\n-        assertEquals(\"4\", f.create());\n-        assertEquals(\"5\", f.create());\n-        assertEquals(\"6\", f.create());\n-        assertEquals(\"7\", f.create());\n-        assertEquals(\"8\", f.create());\n-        assertEquals(\"9\", f.create());\n-        assertEquals(\"a\", f.create());\n-        assertEquals(\"b\", f.create());\n-        assertEquals(\"c\", f.create());\n-        assertEquals(\"d\", f.create());\n-        assertEquals(\"e\", f.create());\n-        assertEquals(\"f\", f.create());\n-        assertEquals(\"g\", f.create());\n-        assertEquals(\"h\", f.create());\n-        assertEquals(\"i\", f.create());\n-        assertEquals(\"j\", f.create());\n-        assertEquals(\"k\", f.create());\n-        assertEquals(\"l\", f.create());\n-        assertEquals(\"m\", f.create());\n-        assertEquals(\"n\", f.create());\n-        assertEquals(\"o\", f.create());\n-        assertEquals(\"p\", f.create());\n-        assertEquals(\"q\", f.create());\n-        assertEquals(\"r\", f.create());\n-        assertEquals(\"s\", f.create());\n-        assertEquals(\"t\", f.create());\n-        assertEquals(\"u\", f.create());\n-        assertEquals(\"v\", f.create());\n-        assertEquals(\"w\", f.create());\n-        assertEquals(\"x\", f.create());\n-        assertEquals(\"y\", f.create());\n-        assertEquals(\"z\", f.create());\n-        assertEquals(\"0\", f.create());\n+        StringIdentifierFactory f = IdentifierUtils.stringAlphanumericIdentifierFactory(true, 1);\n+        assertEquals(\"1\", f.nextStringIdentifier());\n+        assertEquals(\"2\", f.nextStringIdentifier());\n+        assertEquals(\"3\", f.nextStringIdentifier());\n+        assertEquals(\"4\", f.nextStringIdentifier());\n+        assertEquals(\"5\", f.nextStringIdentifier());\n+        assertEquals(\"6\", f.nextStringIdentifier());\n+        assertEquals(\"7\", f.nextStringIdentifier());\n+        assertEquals(\"8\", f.nextStringIdentifier());\n+        assertEquals(\"9\", f.nextStringIdentifier());\n+        assertEquals(\"a\", f.nextStringIdentifier());\n+        assertEquals(\"b\", f.nextStringIdentifier());\n+        assertEquals(\"c\", f.nextStringIdentifier());\n+        assertEquals(\"d\", f.nextStringIdentifier());\n+        assertEquals(\"e\", f.nextStringIdentifier());\n+        assertEquals(\"f\", f.nextStringIdentifier());\n+        assertEquals(\"g\", f.nextStringIdentifier());\n+        assertEquals(\"h\", f.nextStringIdentifier());\n+        assertEquals(\"i\", f.nextStringIdentifier());\n+        assertEquals(\"j\", f.nextStringIdentifier());\n+        assertEquals(\"k\", f.nextStringIdentifier());\n+        assertEquals(\"l\", f.nextStringIdentifier());\n+        assertEquals(\"m\", f.nextStringIdentifier());\n+        assertEquals(\"n\", f.nextStringIdentifier());\n+        assertEquals(\"o\", f.nextStringIdentifier());\n+        assertEquals(\"p\", f.nextStringIdentifier());\n+        assertEquals(\"q\", f.nextStringIdentifier());\n+        assertEquals(\"r\", f.nextStringIdentifier());\n+        assertEquals(\"s\", f.nextStringIdentifier());\n+        assertEquals(\"t\", f.nextStringIdentifier());\n+        assertEquals(\"u\", f.nextStringIdentifier());\n+        assertEquals(\"v\", f.nextStringIdentifier());\n+        assertEquals(\"w\", f.nextStringIdentifier());\n+        assertEquals(\"x\", f.nextStringIdentifier());\n+        assertEquals(\"y\", f.nextStringIdentifier());\n+        assertEquals(\"z\", f.nextStringIdentifier());\n+        assertEquals(\"0\", f.nextStringIdentifier());\n     }\n \n     public void testStringAlphanumericNoWrap() {\n-        Factory f = IdentifierUtils.stringAlphanumericIdentifierFactory(false, 1);\n-        assertEquals(\"1\", f.create());\n-        assertEquals(\"2\", f.create());\n-        assertEquals(\"3\", f.create());\n-        assertEquals(\"4\", f.create());\n-        assertEquals(\"5\", f.create());\n-        assertEquals(\"6\", f.create());\n-        assertEquals(\"7\", f.create());\n-        assertEquals(\"8\", f.create());\n-        assertEquals(\"9\", f.create());\n-        assertEquals(\"a\", f.create());\n-        assertEquals(\"b\", f.create());\n-        assertEquals(\"c\", f.create());\n-        assertEquals(\"d\", f.create());\n-        assertEquals(\"e\", f.create());\n-        assertEquals(\"f\", f.create());\n-        assertEquals(\"g\", f.create());\n-        assertEquals(\"h\", f.create());\n-        assertEquals(\"i\", f.create());\n-        assertEquals(\"j\", f.create());\n-        assertEquals(\"k\", f.create());\n-        assertEquals(\"l\", f.create());\n-        assertEquals(\"m\", f.create());\n-        assertEquals(\"n\", f.create());\n-        assertEquals(\"o\", f.create());\n-        assertEquals(\"p\", f.create());\n-        assertEquals(\"q\", f.create());\n-        assertEquals(\"r\", f.create());\n-        assertEquals(\"s\", f.create());\n-        assertEquals(\"t\", f.create());\n-        assertEquals(\"u\", f.create());\n-        assertEquals(\"v\", f.create());\n-        assertEquals(\"w\", f.create());\n-        assertEquals(\"x\", f.create());\n-        assertEquals(\"y\", f.create());\n-        assertEquals(\"z\", f.create());\n+        StringIdentifierFactory f = IdentifierUtils.stringAlphanumericIdentifierFactory(false, 1);\n+        assertEquals(\"1\", f.nextStringIdentifier());\n+        assertEquals(\"2\", f.nextStringIdentifier());\n+        assertEquals(\"3\", f.nextStringIdentifier());\n+        assertEquals(\"4\", f.nextStringIdentifier());\n+        assertEquals(\"5\", f.nextStringIdentifier());\n+        assertEquals(\"6\", f.nextStringIdentifier());\n+        assertEquals(\"7\", f.nextStringIdentifier());\n+        assertEquals(\"8\", f.nextStringIdentifier());\n+        assertEquals(\"9\", f.nextStringIdentifier());\n+        assertEquals(\"a\", f.nextStringIdentifier());\n+        assertEquals(\"b\", f.nextStringIdentifier());\n+        assertEquals(\"c\", f.nextStringIdentifier());\n+        assertEquals(\"d\", f.nextStringIdentifier());\n+        assertEquals(\"e\", f.nextStringIdentifier());\n+        assertEquals(\"f\", f.nextStringIdentifier());\n+        assertEquals(\"g\", f.nextStringIdentifier());\n+        assertEquals(\"h\", f.nextStringIdentifier());\n+        assertEquals(\"i\", f.nextStringIdentifier());\n+        assertEquals(\"j\", f.nextStringIdentifier());\n+        assertEquals(\"k\", f.nextStringIdentifier());\n+        assertEquals(\"l\", f.nextStringIdentifier());\n+        assertEquals(\"m\", f.nextStringIdentifier());\n+        assertEquals(\"n\", f.nextStringIdentifier());\n+        assertEquals(\"o\", f.nextStringIdentifier());\n+        assertEquals(\"p\", f.nextStringIdentifier());\n+        assertEquals(\"q\", f.nextStringIdentifier());\n+        assertEquals(\"r\", f.nextStringIdentifier());\n+        assertEquals(\"s\", f.nextStringIdentifier());\n+        assertEquals(\"t\", f.nextStringIdentifier());\n+        assertEquals(\"u\", f.nextStringIdentifier());\n+        assertEquals(\"v\", f.nextStringIdentifier());\n+        assertEquals(\"w\", f.nextStringIdentifier());\n+        assertEquals(\"x\", f.nextStringIdentifier());\n+        assertEquals(\"y\", f.nextStringIdentifier());\n+        assertEquals(\"z\", f.nextStringIdentifier());\n         try {\n-            f.create();\n+            f.nextStringIdentifier();\n             fail();\n-        } catch (FactoryException ex) {}\n+        } catch (IllegalStateException ex) {}\n     }\n \n     //--------------------------------------------------------------------------\n \n     public void testStringSession() {\n-        Factory f = IdentifierUtils.STRING_SESSION_IDENTIFIER_FACTORY;\n+        StringIdentifierFactory f = IdentifierUtils.STRING_SESSION_IDENTIFIER_FACTORY;\n         assertTrue(f != IdentifierUtils.stringSessionIdentifierFactory());\n         \n-        String a = (String) f.create();\n+        String a = (String) f.nextStringIdentifier();\n         String b = (String) IdentifierUtils.nextStringSessionIdentifier();\n         assertTrue(a.length() >= 10);\n         assertTrue(b.length() >= 10);", "timestamp": 1053122858, "metainfo": ""}