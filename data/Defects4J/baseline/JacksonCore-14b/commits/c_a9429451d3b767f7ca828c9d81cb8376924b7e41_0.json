{"sha": "a9429451d3b767f7ca828c9d81cb8376924b7e41", "log": "Merge branch 'master' of github.com:FasterXML/jackson-core", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n      * \n      * @since 2.3\n      */\n-    public boolean requiresPropertyOrdering() {\n-        return false;\n-    }\n+    public boolean requiresPropertyOrdering() { return false; }\n \n     /**\n      * Introspection method that higher-level functionality may call\n      * \n      * @since 2.3\n      */\n-    public boolean canHandleBinaryNatively() {\n-        return false;\n-    }\n-\n+    public boolean canHandleBinaryNatively() { return false; }\n+\n+    /**\n+     * Introspection method that can be used by base factory to check\n+     * whether access using <code>char[]</code> is something that actual\n+     * parser implementations can take advantage of, over having to\n+     * use {@link java.io.Reader}. Sub-types are expected to override\n+     * definition; default implementation (suitable for JSON) alleges\n+     * that optimization are possible; and thereby is likely to try\n+     * to access {@link java.lang.String} content by first copying it into\n+     * recyclable intermediate buffer.\n+     * \n+     * @since 2.4\n+     */\n+    public boolean canUseCharArrays() { return true; }\n+    \n     /*\n     /**********************************************************\n     /* Format detection functionality (since 1.8)\n     public JsonParser createParser(String content) throws IOException, JsonParseException {\n         final int strLen = content.length();\n         // Actually, let's use this for medium-sized content, up to 64kB chunk (32kb char)\n-        if (_inputDecorator != null || strLen > 0x8000) {\n+        if (_inputDecorator != null || strLen > 0x8000 || !canUseCharArrays()) {\n             // easier to just wrap in a Reader than extend InputDecorator; or, if content\n             // is too long for us to copy it over\n             return createParser(new StringReader(content));\n      * @param f File to write contents to\n      * @param enc Character encoding to use\n      * \n-     * \n      * @deprecated Since 2.2, use {@link #createGenerator(File,JsonEncoding)} instead.\n      */\n     @Deprecated\n                 _rootCharSymbols.makeChild(isEnabled(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES),\n                         isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)),\n                         data, offset, offset+len,\n-                        // false -> caller-provided, not handled by BufferRecycler\n                         recyclable);\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n     protected final static int INT_COLON = ':';\n     protected final static int INT_COMMA = ',';\n \n+    // fp numbers\n+    protected final static int INT_PERIOD = '.';\n+    protected final static int INT_e = 'e';\n+    protected final static int INT_E = 'E';\n+    \n     /*\n     /**********************************************************\n     /* Minimal generally useful state\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n         int startPtr = ptr-1; // to include sign/digit already read\n         final int inputLen = _inputEnd;\n \n-        dummy_loop:\n-        do { // dummy loop, to be able to break out\n-            if (neg) { // need to read the next digit\n-                if (ptr >= inputLen) {\n-                    break dummy_loop;\n-                }\n-                ch = _inputBuffer[ptr++];\n-                // First check: must have a digit to follow minus sign\n-                if (ch > INT_9 || ch < INT_0) {\n-                    _inputPtr = ptr;\n-                    return _handleInvalidNumberStart(ch, true);\n-                }\n-                /* (note: has been checked for non-negative already, in\n-                 * the dispatching code that determined it should be\n-                 * a numeric value)\n-                 */\n-            }\n-            // One special case, leading zero(es):\n-            if (ch == INT_0) {\n-                break dummy_loop;\n-            }\n+        if (neg) { // need to read the next digit\n+            if (ptr >= inputLen) {\n+                _inputPtr = neg ? (startPtr+1) : startPtr;\n+                return _parseNumber2(neg);\n+            }\n+            ch = _inputBuffer[ptr++];\n+            // First check: must have a digit to follow minus sign\n+            if (ch > INT_9 || ch < INT_0) {\n+                _inputPtr = ptr;\n+                return _handleInvalidNumberStart(ch, true);\n+            }\n+            /* (note: has been checked for non-negative already, in\n+             * the dispatching code that determined it should be\n+             * a numeric value)\n+             */\n+        }\n+        // One special case, leading zero(es):\n+        if (ch == INT_0) {\n+            _inputPtr = neg ? (startPtr+1) : startPtr;\n+            return _parseNumber2(neg);\n+        }\n             \n-            /* First, let's see if the whole number is contained within\n-             * the input buffer unsplit. This should be the common case;\n-             * and to simplify processing, we will just reparse contents\n-             * in the alternative case (number split on buffer boundary)\n-             */\n-            \n-            int intLen = 1; // already got one\n-            \n-            // First let's get the obligatory integer part:\n-            \n-            int_loop:\n+        /* First, let's see if the whole number is contained within\n+         * the input buffer unsplit. This should be the common case;\n+         * and to simplify processing, we will just reparse contents\n+         * in the alternative case (number split on buffer boundary)\n+         */\n+        \n+        int intLen = 1; // already got one\n+        \n+        // First let's get the obligatory integer part:\n+        int_loop:\n+        while (true) {\n+            if (ptr >= inputLen) {\n+                _inputPtr = neg ? (startPtr+1) : startPtr;\n+                return _parseNumber2(neg);\n+            }\n+            ch = (int) _inputBuffer[ptr++];\n+            if (ch < INT_0 || ch > INT_9) {\n+                break int_loop;\n+            }\n+            ++intLen;\n+        }\n+\n+        int fractLen = 0;\n+        // And then see if we get other parts\n+        if (ch == '.') { // yes, fraction\n+            fract_loop:\n             while (true) {\n                 if (ptr >= inputLen) {\n-                    break dummy_loop;\n+                    _inputPtr = neg ? (startPtr+1) : startPtr;\n+                    return _parseNumber2(neg);\n                 }\n                 ch = (int) _inputBuffer[ptr++];\n                 if (ch < INT_0 || ch > INT_9) {\n-                    break int_loop;\n-                }\n-                ++intLen;\n-            }\n-\n-            int fractLen = 0;\n-            \n-            // And then see if we get other parts\n-            if (ch == '.') { // yes, fraction\n-                fract_loop:\n-                while (true) {\n-                    if (ptr >= inputLen) {\n-                        break dummy_loop;\n-                    }\n-                    ch = (int) _inputBuffer[ptr++];\n-                    if (ch < INT_0 || ch > INT_9) {\n-                        break fract_loop;\n-                    }\n-                    ++fractLen;\n-                }\n-                // must be followed by sequence of ints, one minimum\n-                if (fractLen == 0) {\n-                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n-                }\n-            }\n-\n-            int expLen = 0;\n-            if (ch == 'e' || ch == 'E') { // and/or exponent\n+                    break fract_loop;\n+                }\n+                ++fractLen;\n+            }\n+            // must be followed by sequence of ints, one minimum\n+            if (fractLen == 0) {\n+                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n+            }\n+        }\n+        int expLen = 0;\n+        if (ch == 'e' || ch == 'E') { // and/or exponent\n+            if (ptr >= inputLen) {\n+                _inputPtr = neg ? (startPtr+1) : startPtr;\n+                return _parseNumber2(neg);\n+            }\n+            // Sign indicator?\n+            ch = (int) _inputBuffer[ptr++];\n+            if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                 if (ptr >= inputLen) {\n-                    break dummy_loop;\n-                }\n-                // Sign indicator?\n+                    _inputPtr = neg ? (startPtr+1) : startPtr;\n+                    return _parseNumber2(neg);\n+                }\n                 ch = (int) _inputBuffer[ptr++];\n-                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n-                    if (ptr >= inputLen) {\n-                        break dummy_loop;\n-                    }\n-                    ch = (int) _inputBuffer[ptr++];\n-                }\n-                while (ch <= INT_9 && ch >= INT_0) {\n-                    ++expLen;\n-                    if (ptr >= inputLen) {\n-                        break dummy_loop;\n-                    }\n-                    ch = (int) _inputBuffer[ptr++];\n-                }\n-                // must be followed by sequence of ints, one minimum\n-                if (expLen == 0) {\n-                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n-                }\n-            }\n-            // Got it all: let's add to text buffer for parsing, access\n-            --ptr; // need to push back following separator\n-            _inputPtr = ptr;\n-            // As per #105, need separating space between root values; check here\n-            if (_parsingContext.inRoot()) {\n-                _verifyRootSpace(ch);\n-            }\n-            int len = ptr-startPtr;\n-            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n-            return reset(neg, intLen, fractLen, expLen);\n-        } while (false);\n-\n-        _inputPtr = neg ? (startPtr+1) : startPtr;\n-        return _parseNumber2(neg);\n+            }\n+            while (ch <= INT_9 && ch >= INT_0) {\n+                ++expLen;\n+                if (ptr >= inputLen) {\n+                    _inputPtr = neg ? (startPtr+1) : startPtr;\n+                    return _parseNumber2(neg);\n+                }\n+                ch = (int) _inputBuffer[ptr++];\n+            }\n+            // must be followed by sequence of ints, one minimum\n+            if (expLen == 0) {\n+                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n+            }\n+        }\n+        // Got it all: let's add to text buffer for parsing, access\n+        --ptr; // need to push back following separator\n+        _inputPtr = ptr;\n+        // As per #105, need separating space between root values; check here\n+        if (_parsingContext.inRoot()) {\n+            _verifyRootSpace(ch);\n+        }\n+        int len = ptr-startPtr;\n+        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n+        return reset(neg, intLen, fractLen, expLen);\n     }\n \n     /**\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n             }\n             int c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n             if (c > INT_9 || c < INT_0) {\n-                if (c == '.' || c == 'e' || c == 'E') {\n+                if (c == INT_PERIOD || c == INT_e || c == INT_E) {\n                     return _parseFloat(outBuf, outPtr, c, negative, intPartLength);\n                 }\n                 break;\n         boolean eof = false;\n \n         // And then see if we get other parts\n-        if (c == '.') { // yes, fraction\n+        if (c == INT_PERIOD) { // yes, fraction\n             outBuf[outPtr++] = (char) c;\n \n             fract_loop:\n         }\n \n         int expLen = 0;\n-        if (c == 'e' || c == 'E') { // exponent?\n+        if (c == INT_e || c == INT_E) { // exponent?\n             if (outPtr >= outBuf.length) {\n                 outBuf = _textBuffer.finishCurrentSegment();\n                 outPtr = 0;\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestJsonGenerator.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestJsonGenerator.java\n         }\n     }\n \n-    public void testIntWrite()\n-        throws Exception\n+    public void testIntWrite() throws Exception\n     {\n         doTestIntWrite(false);\n         doTestIntWrite(true);\n     }\n \n-    public void testLongWrite()\n-        throws Exception\n+    public void testLongWrite() throws Exception\n     {\n         doTestLongWrite(false);\n         doTestLongWrite(true);\n     }\n \n-    public void testBooleanWrite()\n-        throws Exception\n+    public void testBooleanWrite() throws Exception\n     {\n         for (int i = 0; i < 4; ++i) {\n             boolean state = (i & 1) == 0;\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestNumericValues.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestNumericValues.java\n                 String STR = INPUTS[i];\n                 double EXP_D = Double.parseDouble(STR);\n                 String DOC = \"[\"+STR+\"]\";\n-                \n+\n                 JsonParser jp;\n                 \n                 if (input == 0) {\n--- a/src/test/java/com/fasterxml/jackson/core/main/TestParserLinefeeds.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestParserLinefeeds.java\n     private void _testLinefeeds(String lf, boolean useStream)\n         throws IOException\n     {\n-        String DOC = \"[1,@2,@-178@]\";\n+        String DOC = \"[1,@2,@-478@]\";\n         DOC = DOC.replaceAll(\"@\", lf);\n \n         JsonParser jp = useStream ?\n         assertEquals(2, jp.getCurrentLocation().getLineNr());\n \n         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n-        assertEquals(-178, jp.getIntValue());\n+        assertEquals(-478, jp.getIntValue());\n         assertEquals(3, jp.getCurrentLocation().getLineNr());\n         \n         assertToken(JsonToken.END_ARRAY, jp.nextToken());", "timestamp": 1398228858, "metainfo": ""}