{"sha": "075ce3ff26ce390598a4ff526e0cdb58fc49857f", "log": "minor tweaking", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java\n {\n     /**\n      * Initial size of the primary hash area. Each entry consumes 4 ints (16 bytes),\n-     * and secondary area is same as primary; so default size will use 2kB of memory\n+     * and secondary area is same as primary; so default size will use 2kB of memory_tertiaryStart\n      * (plus 64x4 or 64x8 (256/512 bytes) for references to Strings, and Strings\n      * themselves).\n      */\n     /**\n      * Offset within {@link #_hashArea} where secondary entries start\n      */\n-    protected int _secondaryOffset;\n+    protected int _secondaryStart;\n+\n+    /**\n+     * Offset within {@link #_hashArea} where tertiary entries start\n+     */\n+    protected int _tertiaryStart;\n+    \n+    /**\n+     * Size of tertiary buckets within tertiary area, in ints.\n+     */\n+    protected int _tertiaryBucketSize;\n+\n+    /**\n+     * First part of shift used to get from primary offset into tertiary bucket\n+     * offset (0-based); basically divides primary physical offset into\n+     * logical tertiary bucket index.\n+     */\n+    protected int _tertiaryOffsetShift;\n+\n+    /**\n+     * Second part of shift used to get from primary offset into tertiary bucket\n+     * offset (0-based); given logical tertiary bucket index, multiplies by\n+     * size of tertiary slots to get relative physical offset from start of tertiary area.\n+     */\n+    protected int _tertiaryBucketShift;\n     \n     /**\n      * Total number of Strings in the symbol table; only used for child tables.\n         // Then copy shared state\n         _count = state.count;\n         _hashSize = state.size;\n-        _secondaryOffset = _hashSize << 2; // 4 ints per entry\n+        _secondaryStart = _hashSize << 2; // right after primary area\n+        _tertiaryStart = _secondaryStart + (_secondaryStart >> 1); // right after secondary\n+        \n         _hashArea = state.mainHash;\n         _names = state.names;\n \n     public int primaryCount()\n     {\n         int count = 0;\n-        for (int offset = 3, end = _secondaryOffset; offset < end; offset += 4) {\n+        for (int offset = 3, end = _secondaryStart; offset < end; offset += 4) {\n             if (_hashArea[offset] != 0) {\n                 ++count;\n             }\n      */\n     public int secondaryCount() {\n         int count = 0;\n-        int offset = _secondaryOffset + 3;\n-        for (int end = offset + (_hashSize << 1); offset < end; offset += 4) {\n+        int offset = _secondaryStart + 3;\n+        for (int end = _tertiaryStart; offset < end; offset += 4) {\n             if (_hashArea[offset] != 0) {\n                 ++count;\n             }\n      */\n     public int tertiaryCount() {\n         int count = 0;\n-        int offset = _secondaryOffset + (_hashSize << 1) + 3; // to 1.5x, starting point of tertiary\n+        int offset = _tertiaryStart + 3; // to 1.5x, starting point of tertiary\n         for (int end = offset + _hashSize; offset < end; offset += 4) {\n             if (_hashArea[offset] != 0) {\n                 ++count;\n             return null;\n         }\n         // secondary? single slot shared by N/2 primaries\n-        int offset2 = _secondaryOffset + ((offset >> 3) << 2);\n+        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n \n         q1b = hashArea[offset2];\n         len = hashArea[offset2+3];\n             return null;\n         }\n         // secondary?\n-        int offset2 = _secondaryOffset + ((offset >> 3) << 2);\n+        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n \n         q1b = hashArea[offset2];\n         len = hashArea[offset2+3];\n             return null;\n         }\n         // secondary?\n-        int offset2 = _secondaryOffset + ((offset >> 3) << 2);\n+        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n \n         q1b = hashArea[offset2];\n         len = hashArea[offset2+3];\n             return null;\n         }\n         // secondary?\n-        int offset2 = _secondaryOffset + ((offset >> 3) << 2);\n+        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n \n         final int len2 = hashArea[offset2+3];\n         if ((hash == hashArea[offset2]) && (len2 == qlen)) {\n     private String _findSecondary(int origOffset, int q1)\n     {\n         // so, first tertiary, 4 cells shared by N/16 primary slots\n-        int offset = _secondaryOffset + (_secondaryOffset >> 1);\n-        offset += (origOffset >> 6) << 2;\n+        int offset = _tertiaryStart + ((origOffset >> 6) << 2);\n \n         final int[] hashArea = _hashArea;\n \n+        /*\n+        // Since tertiary uses 8 slots, let's loop\n+        for (int end = offset + 32; offset < end; offset += 4) {\n+            ;\n+        }\n+        */\n+        \n         // then check up to 4 slots; don't worry about empty slots yet\n         if ((q1 == hashArea[offset]) && (1 == hashArea[offset+3])) {\n             return _names[offset >> 2];\n \n     private String _findSecondary(int origOffset, int q1, int q2)\n     {\n-        int offset = _secondaryOffset + (_secondaryOffset >> 1);\n-        offset += (origOffset >> 6) << 2;\n+        int offset = _tertiaryStart + ((origOffset >> 6) << 2);\n \n         final int[] hashArea = _hashArea;\n         \n \n     private String _findSecondary(int origOffset, int q1, int q2, int q3)\n     {\n-        int offset = _secondaryOffset + (_secondaryOffset >> 1);\n-        offset += (origOffset >> 6) << 2;\n+        int offset = _tertiaryStart + ((origOffset >> 6) << 2);\n \n         final int[] hashArea = _hashArea;\n         \n \n     private String _findSecondary(int origOffset, int hash, int[] q, int qlen)\n     {\n-        int offset = _secondaryOffset + (_secondaryOffset >> 1);\n-        offset += (origOffset >> 6) << 2;\n+        int offset = _tertiaryStart + ((origOffset >> 6) << 2);\n         \n         final int[] hashArea = _hashArea;\n         \n     {\n         final int[] hashArea = _hashArea;\n         // spillOffset assumed to be physical index right into quad string\n-        \n         int ix = 0;\n         do {\n             if (q[ix++] != hashArea[spillOffset++]) {\n             return offset;\n         }\n         // then secondary\n-        int offset2 = _secondaryOffset + ((offset >> 3) << 2);\n+        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n         if (hashArea[offset2+3] == 0) {\n             return offset2;\n         }\n         // if not, tertiary?\n \n-        offset2 = _secondaryOffset + (_secondaryOffset >> 1);\n+        offset2 = _secondaryStart + (_secondaryStart >> 1);\n         offset2 += (offset >> 6) << 2; // and add 1/16th of orig index (but on 4 int boundary)\n \n         if (hashArea[offset2+3] == 0) {\n         // double up main hash area, but do not expand long-name area:\n         _hashArea = new int[oldHashArea.length + (oldSize<<3)];\n         _hashSize = newSize;\n-        _secondaryOffset = _hashSize << 2; // 4 ints per entry\n+        _secondaryStart = _hashSize << 2; // 4 ints per entry\n+        _tertiaryStart = _secondaryStart + (_secondaryStart >> 1); // right after secondary\n         \n         // and simply double up name array\n         _names = new String[oldNames.length << 1];", "timestamp": 1423187218, "metainfo": ""}