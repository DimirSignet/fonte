{"sha": "f408795c6ff1e2510851e611cbc3662e4c29aac7", "log": "Added ResolvedType.getParameterSource()", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/type/ResolvedType.java\n+++ b/src/main/java/com/fasterxml/jackson/core/type/ResolvedType.java\n      * parameters (for its direct super-class and/or super-interfaces).\n      */\n     public abstract boolean hasGenericTypes();\n-    \n+\n+    /**\n+     * Accessor that can be used to find out type for which parameterization\n+     * is applied: this is often NOT same as what {@link #getRawType} returns,\n+     * but rather one of it supertype.\n+     *<p>\n+     * For example: for type like {@link java.util.HashMap}, raw type is\n+     * {@link java.util.HashMap}; but this method would return\n+     * {@link java.util.Map}, because relevant type parameters that are\n+     * resolved (and accessible using {@link #containedType(int)} and\n+     * {@link #getKeyType()}) are parameter for {@link java.util.Map}\n+     * (which may or may not be same as type parameters for subtype;\n+     * in case of {@link java.util.HashMap} they are, but for further\n+     * subtypes they may be different parameters or possibly none at all).\n+     * \n+     * @since 2.5\n+     */\n+    public Class<?> getParameterSource() {\n+        return null;\n+    }\n+\n     /**\n      * Method for accessing key type for this type, assuming type\n      * has such a concept (only Map types do)", "timestamp": 1412025817, "metainfo": ""}