{"sha": "383f63242c59628d7bcef15a73eb1c9d44d7fb56", "log": "Merge branch '2.7'  Conflicts: \trelease-notes/VERSION", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n      * parser, although it may cause parser to internally process\n      * more data (if it lazy loads contents of value events, for example)\n      */\n-    public void copyCurrentEvent(JsonParser jp) throws IOException\n+    public void copyCurrentEvent(JsonParser p) throws IOException\n     {\n-        JsonToken t = jp.getCurrentToken();\n+        JsonToken t = p.getCurrentToken();\n         // sanity check; what to do?\n         if (t == null) {\n             _reportError(\"No current event to copy\");\n             writeEndArray();\n             break;\n         case ID_FIELD_NAME:\n-            writeFieldName(jp.getCurrentName());\n+            writeFieldName(p.getCurrentName());\n             break;\n         case ID_STRING:\n-            if (jp.hasTextCharacters()) {\n-                writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength());\n+            if (p.hasTextCharacters()) {\n+                writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength());\n             } else {\n-                writeString(jp.getText());\n+                writeString(p.getText());\n             }\n             break;\n         case ID_NUMBER_INT:\n         {\n-            NumberType n = jp.getNumberType();\n+            NumberType n = p.getNumberType();\n             if (n == NumberType.INT) {\n-                writeNumber(jp.getIntValue());\n+                writeNumber(p.getIntValue());\n             } else if (n == NumberType.BIG_INTEGER) {\n-                writeNumber(jp.getBigIntegerValue());\n+                writeNumber(p.getBigIntegerValue());\n             } else {\n-                writeNumber(jp.getLongValue());\n+                writeNumber(p.getLongValue());\n             }\n             break;\n         }\n         case ID_NUMBER_FLOAT:\n         {\n-            NumberType n = jp.getNumberType();\n+            NumberType n = p.getNumberType();\n             if (n == NumberType.BIG_DECIMAL) {\n-                writeNumber(jp.getDecimalValue());\n+                writeNumber(p.getDecimalValue());\n             } else if (n == NumberType.FLOAT) {\n-                writeNumber(jp.getFloatValue());\n+                writeNumber(p.getFloatValue());\n             } else {\n-                writeNumber(jp.getDoubleValue());\n+                writeNumber(p.getDoubleValue());\n             }\n             break;\n         }\n             writeNull();\n             break;\n         case ID_EMBEDDED_OBJECT:\n-            writeObject(jp.getEmbeddedObject());\n+            writeObject(p.getEmbeddedObject());\n             break;\n         default:\n             _throwInternal();\n      * the event parser already pointed to (if there were no\n      * enclosed events), or the last enclosed event copied.\n      */\n-    public void copyCurrentStructure(JsonParser jp) throws IOException\n+    public void copyCurrentStructure(JsonParser p) throws IOException\n     {\n-        JsonToken t = jp.getCurrentToken();\n+        JsonToken t = p.getCurrentToken();\n         if (t == null) {\n             _reportError(\"No current event to copy\");\n         }\n         // Let's handle field-name separately first\n         int id = t.id();\n         if (id == ID_FIELD_NAME) {\n-            writeFieldName(jp.getCurrentName());\n-            t = jp.nextToken();\n+            writeFieldName(p.getCurrentName());\n+            t = p.nextToken();\n             id = t.id();\n             // fall-through to copy the associated value\n         }\n         switch (id) {\n         case ID_START_OBJECT:\n             writeStartObject();\n-            while (jp.nextToken() != JsonToken.END_OBJECT) {\n-                copyCurrentStructure(jp);\n+            while (p.nextToken() != JsonToken.END_OBJECT) {\n+                copyCurrentStructure(p);\n             }\n             writeEndObject();\n             break;\n         case ID_START_ARRAY:\n             writeStartArray();\n-            while (jp.nextToken() != JsonToken.END_ARRAY) {\n-                copyCurrentStructure(jp);\n+            while (p.nextToken() != JsonToken.END_ARRAY) {\n+                copyCurrentStructure(p);\n             }\n             writeEndArray();\n             break;\n         default:\n-            copyCurrentEvent(jp);\n+            copyCurrentEvent(p);\n         }\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n      */\n     public void writeTypeId(Object id) throws IOException {\n         throw new JsonGenerationException(\"No native support for writing Type Ids\", this);\n+    }\n+\n+    /**\n+     * Method that can be called on backends that support passing opaque datatypes of\n+     * non-JSON formats\n+     *\n+     * @since 2.8\n+     */\n+    public void writeEmbeddedObject(Object object) throws IOException {\n+        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n+                this);\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/core/ObjectCodec.java\n+++ b/src/main/java/com/fasterxml/jackson/core/ObjectCodec.java\n {\n     protected ObjectCodec() { }\n \n-    // Since 2.3: need baseline implementation to avoid backwards compatibility\n+    // Since 2.3\n     @Override\n-    public Version version() { return Version.unknownVersion(); }\n+    public abstract Version version();\n     \n     /*\n     /**********************************************************\n      * The reason is that due to type erasure, key and value types\n      * can not be introspected when using this method.\n      */\n-    public abstract <T> T readValue(JsonParser jp, Class<T> valueType)\n-        throws IOException, JsonProcessingException;\n+    public abstract <T> T readValue(JsonParser p, Class<T> valueType)\n+        throws IOException;\n \n     /**\n      * Method to deserialize JSON content into a Java type, reference\n      * and specifically needs to be used if the root type is a \n      * parameterized (generic) container type.\n      */\n-    public abstract <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef)\n-        throws IOException, JsonProcessingException;\n+    public abstract <T> T readValue(JsonParser p, TypeReference<?> valueTypeRef)\n+        throws IOException;\n \n     /**\n      * Method to deserialize JSON content into a POJO, type specified\n      * including containers like {@link java.util.Collection} and\n      * {@link java.util.Map}).\n      */\n-    public abstract <T> T readValue(JsonParser jp, ResolvedType valueType)\n-        throws IOException, JsonProcessingException;\n+    public abstract <T> T readValue(JsonParser p, ResolvedType valueType)\n+        throws IOException;\n \n     /**\n      * Method for reading sequence of Objects from parser stream,\n      * all with same specified value type.\n      */\n-    public abstract <T> Iterator<T> readValues(JsonParser jp, Class<T> valueType)\n-        throws IOException, JsonProcessingException;\n+    public abstract <T> Iterator<T> readValues(JsonParser p, Class<T> valueType)\n+        throws IOException;\n \n     /**\n      * Method for reading sequence of Objects from parser stream,\n      * all with same specified value type.\n      */\n-    public abstract <T> Iterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef)\n-        throws IOException, JsonProcessingException;\n+    public abstract <T> Iterator<T> readValues(JsonParser p, TypeReference<?> valueTypeRef)\n+        throws IOException;\n     \n     /**\n      * Method for reading sequence of Objects from parser stream,\n      * all with same specified value type.\n      */\n-    public abstract <T> Iterator<T> readValues(JsonParser jp, ResolvedType valueType)\n-        throws IOException, JsonProcessingException;\n-    \n+    public abstract <T> Iterator<T> readValues(JsonParser p, ResolvedType valueType)\n+        throws IOException;\n+\n     /*\n     /**********************************************************\n     /* API for serialization (Object-to-JSON)\n      * Method to serialize given Java Object, using generator\n      * provided.\n      */\n-    public abstract void writeValue(JsonGenerator jgen, Object value)\n-        throws IOException, JsonProcessingException;\n+    public abstract void writeValue(JsonGenerator gen, Object value) throws IOException;\n \n     /*\n     /**********************************************************\n      * value event, not container). Empty or whitespace\n      * documents return null.\n      *\n-     * @return next tree from jp, or null if empty.\n+     * @return next tree from p, or null if empty.\n      */\n     @Override\n-    public abstract <T extends TreeNode> T readTree(JsonParser jp)\n-        throws IOException, JsonProcessingException;\n+    public abstract <T extends TreeNode> T readTree(JsonParser p) throws IOException;\n     \n     @Override\n-    public abstract void writeTree(JsonGenerator jg, TreeNode tree)\n-        throws IOException, JsonProcessingException;\n+    public abstract void writeTree(JsonGenerator gen, TreeNode tree) throws IOException;\n     \n     /**\n      * Method for construct root level Object nodes\n--- a/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n     \n     @Override\n     public void writeTypeId(Object id) throws IOException { delegate.writeTypeId(id); }\n+\n+    @Override\n+    public void writeEmbeddedObject(Object object) throws IOException { delegate.writeEmbeddedObject(object); }\n     \n     /*\n     /**********************************************************", "timestamp": 1456539155, "metainfo": ""}