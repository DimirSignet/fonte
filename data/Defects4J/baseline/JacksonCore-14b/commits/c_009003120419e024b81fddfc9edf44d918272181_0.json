{"sha": "009003120419e024b81fddfc9edf44d918272181", "log": "more work on filtering", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java\n import java.math.BigInteger;\n \n import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.json.JsonReadContext;\n import com.fasterxml.jackson.core.util.JsonParserDelegate;\n \n /**\n     protected JsonToken _lastClearedToken;\n     \n     /**\n-     * Although delegate has its own output context it is not sufficient since we actually\n-     * have to keep track of excluded (filtered out) structures as well as ones delegate\n-     * actually outputs.\n-     */\n-    protected TokenFilterContext _filterContext;\n-\n+     * During traversal this is the actual \"open\" parse tree, which sometimes\n+     * is the same as {@link #_exposedContext}, and at other times is ahead\n+     * of it. Note that this context is never null.\n+     */\n+    protected TokenFilterContext _headContext;\n+\n+    /**\n+     * In cases where {@link #_headContext} is \"ahead\" of context exposed to\n+     * caller, this context points to what is currently exposed to caller.\n+     * When the two are in sync, this context reference will be <code>null</code>.\n+     */\n+    protected TokenFilterContext _exposedContext;\n+    \n     /**\n      * State that applies to the item within container, used where applicable.\n      * Specifically used to pass inclusion state between property name and\n         rootFilter = f;\n         // and this is the currently active filter for root values\n         _itemFilter = f;\n-        _filterContext = TokenFilterContext.createRootContext(f);\n+        _headContext = TokenFilterContext.createRootContext(f);\n         _includePath = includePath;\n         _allowMultipleMatches = allowMultipleMatches;\n     }\n     @Override public boolean isExpectedStartObjectToken() { return _currToken == JsonToken.START_OBJECT; }\n \n     @Override public JsonLocation getCurrentLocation() { return delegate.getCurrentLocation(); }\n-    @Override public JsonStreamContext getParsingContext() { return _filterContext; }\n-\n-    // !!! TODO: not necessarily correct...\n-    @Override public String getCurrentName() throws IOException { return delegate.getCurrentName(); }\n-    \n+\n+    @Override\n+    public JsonStreamContext getParsingContext() {\n+        return _filterContext();\n+    }\n+    \n+    // !!! TODO: Verify it works as expected: copied from standard JSON parser impl\n+    @Override\n+    public String getCurrentName() throws IOException {\n+        JsonStreamContext ctxt = _filterContext();\n+        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n+            JsonStreamContext parent = ctxt.getParent();\n+            return (parent == null) ? null : parent.getCurrentName();\n+        }\n+        return ctxt.getCurrentName();\n+    }\n+\n     /*\n     /**********************************************************\n     /* Public API, token state overrides\n     @Override\n     public JsonToken getLastClearedToken() { return _lastClearedToken; }\n \n-    // !!! TODO: re-implement\n-    @Override\n-    public void overrideCurrentName(String name) { delegate.overrideCurrentName(name); }\n+    @Override\n+    public void overrideCurrentName(String name) {\n+        /* 14-Apr-2015, tatu: Not sure whether this can be supported, and if so,\n+         *    what to do with it... Delegation won't work for sure, so let's for\n+         *    now throw an exception\n+         */\n+        throw new UnsupportedOperationException(\"Can not currently override name during filtering read\");\n+    }\n \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n \n-    // !!! TODO: re-implement\n-    @Override public JsonToken nextToken() throws IOException { return delegate.nextToken(); }\n+    @Override\n+    public JsonToken nextToken() throws IOException\n+    {\n+        return delegate.nextToken();\n+    }\n \n     @Override\n     public JsonToken nextValue() throws IOException {\n     @Override\n     public JsonParser skipChildren() throws IOException\n     {\n-        if (_currToken != JsonToken.START_OBJECT\n-            && _currToken != JsonToken.START_ARRAY) {\n+        if ((_currToken != JsonToken.START_OBJECT)\n+            && (_currToken != JsonToken.START_ARRAY)) {\n             return this;\n         }\n         int open = 1;\n     @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { return delegate.getBinaryValue(b64variant); }\n     @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { return delegate.readBinaryValue(b64variant, out); }\n     @Override public JsonLocation getTokenLocation() { return delegate.getTokenLocation(); }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal helper methods\n+    /**********************************************************\n+     */\n+\n+    protected JsonStreamContext _filterContext() {\n+        if (_exposedContext != null) {\n+            return _exposedContext;\n+        }\n+        return _headContext;\n+    }\n+\n }", "timestamp": 1429052553, "metainfo": ""}