{"sha": "ad3a43eb9ad2f6b26c3a3c8be3c13ed090e5e0aa", "log": "Minor performance optimization that helps with untyped (Map) serialization, ObjectNode", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n             _flushBuffer();\n         }\n         _outputBuffer[_outputTail++] = BYTE_QUOTE;\n-        name.getChars(0, len, _charBuffer, 0);\n         // But as one segment, or multiple?\n         if (len <= _outputMaxContiguous) {\n             if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                 _flushBuffer();\n             }\n-            _writeStringSegment(_charBuffer, 0, len);\n+            _writeStringSegment(name, 0, len);\n         } else {\n-            _writeStringSegments(_charBuffer, 0, len);\n+            _writeStringSegments(name, 0, len);\n         }\n         // and closing quotes; need room for one more char:\n         if (_outputTail >= _outputEnd) {\n      * the output buffer. If so, we will need to choose smaller output\n      * chunks to write at a time.\n      */\n-    private final void _writeStringSegments(char[] cbuf, int offset, int totalLen)\n-        throws IOException, JsonGenerationException\n+    private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException\n     {\n         do {\n             int len = Math.min(_outputMaxContiguous, totalLen);\n                 _flushBuffer();\n             }\n             _writeStringSegment(cbuf, offset, len);\n+            offset += len;\n+            totalLen -= len;\n+        } while (totalLen > 0);\n+    }\n+\n+    private final void _writeStringSegments(String text, int offset, int totalLen) throws IOException\n+    {\n+        do {\n+            int len = Math.min(_outputMaxContiguous, totalLen);\n+            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n+                _flushBuffer();\n+            }\n+            _writeStringSegment(text, offset, len);\n             offset += len;\n             totalLen -= len;\n         } while (totalLen > 0);\n      * potentially enough space for other cases (but not necessarily flushed)\n      */\n     private final void _writeStringSegment(char[] cbuf, int offset, int len)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n         // note: caller MUST ensure (via flushing) there's room for ASCII only\n         \n         }\n     }\n \n+    private final void _writeStringSegment(String text, int offset, int len) throws IOException\n+    {\n+        // note: caller MUST ensure (via flushing) there's room for ASCII only\n+        // Fast+tight loop for ASCII-only, no-escaping-needed output\n+        len += offset; // becomes end marker, then\n+\n+        int outputPtr = _outputTail;\n+        final byte[] outputBuffer = _outputBuffer;\n+        final int[] escCodes = _outputEscapes;\n+\n+        while (offset < len) {\n+            int ch = text.charAt(offset);\n+            // note: here we know that (ch > 0x7F) will cover case of escaping non-ASCII too:\n+            if (ch > 0x7F || escCodes[ch] != 0) {\n+                break;\n+            }\n+            outputBuffer[outputPtr++] = (byte) ch;\n+            ++offset;\n+        }\n+        _outputTail = outputPtr;\n+        if (offset < len) {\n+            if (_characterEscapes != null) {\n+                _writeCustomStringSegment2(text, offset, len);\n+            } else if (_maximumNonEscapedChar == 0) {\n+                _writeStringSegment2(text, offset, len);\n+            } else {\n+                _writeStringSegmentASCII2(text, offset, len);\n+            }\n+        }\n+    }\n+\n     /**\n      * Secondary method called when content contains characters to escape,\n      * and/or multi-byte UTF-8 characters.\n      */\n-    private final void _writeStringSegment2(final char[] cbuf, int offset, final int end)\n-        throws IOException, JsonGenerationException\n+    private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException\n     {\n         // Ok: caller guarantees buffer can have room; but that may require flushing:\n         if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n         _outputTail = outputPtr;\n     }\n \n+    private final void _writeStringSegment2(final String text, int offset, final int end) throws IOException\n+    {\n+        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n+            _flushBuffer();\n+        }\n+\n+        int outputPtr = _outputTail;\n+\n+        final byte[] outputBuffer = _outputBuffer;\n+        final int[] escCodes = _outputEscapes;\n+        \n+        while (offset < end) {\n+            int ch = text.charAt(offset++);\n+            if (ch <= 0x7F) {\n+                 if (escCodes[ch] == 0) {\n+                     outputBuffer[outputPtr++] = (byte) ch;\n+                     continue;\n+                 }\n+                 int escape = escCodes[ch];\n+                 if (escape > 0) { // 2-char escape, fine\n+                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n+                     outputBuffer[outputPtr++] = (byte) escape;\n+                 } else {\n+                     // ctrl-char, 6-byte escape...\n+                     outputPtr = _writeGenericEscape(ch, outputPtr);\n+                }\n+                continue;\n+            }\n+            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n+                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n+                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n+            } else {\n+                outputPtr = _outputMultiByteChar(ch, outputPtr);\n+            }\n+        }\n+        _outputTail = outputPtr;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Internal methods, low-level writing, text segment\n      * Same as <code>_writeStringSegment2(char[], ...)</code., but with\n      * additional escaping for high-range code points\n      */\n-    private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end)\n-        throws IOException, JsonGenerationException\n+    private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException\n     {\n         // Ok: caller guarantees buffer can have room; but that may require flushing:\n         if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n         _outputTail = outputPtr;\n     }\n \n+    private final void _writeStringSegmentASCII2(final String text, int offset, final int end) throws IOException\n+    {\n+        // Ok: caller guarantees buffer can have room; but that may require flushing:\n+        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n+            _flushBuffer();\n+        }\n+    \n+        int outputPtr = _outputTail;\n+    \n+        final byte[] outputBuffer = _outputBuffer;\n+        final int[] escCodes = _outputEscapes;\n+        final int maxUnescaped = _maximumNonEscapedChar;\n+        \n+        while (offset < end) {\n+            int ch = text.charAt(offset++);\n+            if (ch <= 0x7F) {\n+                 if (escCodes[ch] == 0) {\n+                     outputBuffer[outputPtr++] = (byte) ch;\n+                     continue;\n+                 }\n+                 int escape = escCodes[ch];\n+                 if (escape > 0) { // 2-char escape, fine\n+                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n+                     outputBuffer[outputPtr++] = (byte) escape;\n+                 } else {\n+                     // ctrl-char, 6-byte escape...\n+                     outputPtr = _writeGenericEscape(ch, outputPtr);\n+                 }\n+                 continue;\n+            }\n+            if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars:\n+                outputPtr = _writeGenericEscape(ch, outputPtr);\n+                continue;\n+            }\n+            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n+                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n+                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n+            } else {\n+                outputPtr = _outputMultiByteChar(ch, outputPtr);\n+            }\n+        }\n+        _outputTail = outputPtr;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Internal methods, low-level writing, text segment\n      * Same as <code>_writeStringSegmentASCII2(char[], ...)</code., but with\n      * additional checking for completely custom escapes\n      */\n-    private final void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end)\n-        throws IOException, JsonGenerationException\n+    private final void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException\n     {\n         // Ok: caller guarantees buffer can have room; but that may require flushing:\n         if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n         _outputTail = outputPtr;\n     }\n \n+    private final void _writeCustomStringSegment2(final String text, int offset, final int end) throws IOException\n+    {\n+        // Ok: caller guarantees buffer can have room; but that may require flushing:\n+        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n+            _flushBuffer();\n+        }\n+        int outputPtr = _outputTail;\n+    \n+        final byte[] outputBuffer = _outputBuffer;\n+        final int[] escCodes = _outputEscapes;\n+        // may or may not have this limit\n+        final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar;\n+        final CharacterEscapes customEscapes = _characterEscapes; // non-null\n+        \n+        while (offset < end) {\n+            int ch = text.charAt(offset++);\n+            if (ch <= 0x7F) {\n+                 if (escCodes[ch] == 0) {\n+                     outputBuffer[outputPtr++] = (byte) ch;\n+                     continue;\n+                 }\n+                 int escape = escCodes[ch];\n+                 if (escape > 0) { // 2-char escape, fine\n+                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n+                     outputBuffer[outputPtr++] = (byte) escape;\n+                 } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) {\n+                     SerializableString esc = customEscapes.getEscapeSequence(ch);\n+                     if (esc == null) {\n+                         _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\"\n+                                 +Integer.toHexString(ch)+\", although was supposed to have one\");\n+                     }\n+                     outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n+                 } else {\n+                     // ctrl-char, 6-byte escape...\n+                     outputPtr = _writeGenericEscape(ch, outputPtr);\n+                 }\n+                 continue;\n+            }\n+            if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars:\n+                outputPtr = _writeGenericEscape(ch, outputPtr);\n+                continue;\n+            }\n+            SerializableString esc = customEscapes.getEscapeSequence(ch);\n+            if (esc != null) {\n+                outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n+                continue;\n+            }\n+            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n+                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n+                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n+            } else {\n+                outputPtr = _outputMultiByteChar(ch, outputPtr);\n+            }\n+        }\n+        _outputTail = outputPtr;\n+    }\n+\n     private final int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars)\n         throws IOException, JsonGenerationException\n     {", "timestamp": 1427768945, "metainfo": ""}