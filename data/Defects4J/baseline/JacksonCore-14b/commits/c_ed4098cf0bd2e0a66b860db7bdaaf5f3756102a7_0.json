{"sha": "ed4098cf0bd2e0a66b860db7bdaaf5f3756102a7", "log": "minor trimming", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n  * @author Tatu Saloranta\n  */\n public abstract class JsonGenerator\n-    implements Closeable, Flushable, // as of 2.1\n-        Versioned\n+    implements Closeable, Flushable, Versioned\n {\n     /**\n      * Enumeration that defines all togglable features for generators.\n      *\n      * @return Generator itself (this), to allow chaining\n      */\n-    public final JsonGenerator configure(Feature f, boolean state)\n-    {\n-        if (state) {\n-            enable(f);\n-        } else {\n-            disable(f);\n-        }\n+    public final JsonGenerator configure(Feature f, boolean state) {\n+        if (state) enable(f); else disable(f);\n         return this;\n     }\n \n      * \n      * @throws UnsupportedOperationException if generator does not support schema\n      */\n-    public void setSchema(FormatSchema schema)\n-    {\n+    public void setSchema(FormatSchema schema) {\n         throw new UnsupportedOperationException(\"Generator of type \"+getClass().getName()+\" does not support schema of type '\"\n                 +schema.getSchemaType()+\"'\");\n     }\n      *\n      * @since 2.1\n      */\n-    public FormatSchema getSchema() {\n-        return null;\n-    }\n+    public FormatSchema getSchema() { return null; }\n \n     /*\n     /**********************************************************\n      *   is to be done; or highest code point not to escape (meaning higher\n      *   ones will be), if positive value.\n      */\n-    public JsonGenerator setHighestNonEscapedChar(int charCode) {\n-        return this;\n-    }\n+    public JsonGenerator setHighestNonEscapedChar(int charCode) { return this; }\n \n     /**\n      * Accessor method for testing what is the highest unescaped character\n      * @return Currently active limitation for highest non-escaped character,\n      *   if defined; or -1 to indicate no additional escaping is performed.\n      */\n-    public int getHighestEscapedChar() {\n-        return 0;\n-    }\n+    public int getHighestEscapedChar() { return 0; }\n \n     /**\n      * Method for accessing custom escapes factory uses for {@link JsonGenerator}s\n      * it creates.\n      */\n-    public CharacterEscapes getCharacterEscapes() {\n-        return null;\n-    }\n+    public CharacterEscapes getCharacterEscapes() { return null; }\n \n     /**\n      * Method for defining custom escapes factory uses for {@link JsonGenerator}s\n      * it creates.\n-     */\n-    public JsonGenerator setCharacterEscapes(CharacterEscapes esc) {\n-        return this;\n-    }\n+     *<p>\n+     * Default implementation does nothing and simply returns this instance.\n+     */\n+    public JsonGenerator setCharacterEscapes(CharacterEscapes esc) { return this; }\n \n     /**\n      * Method that allows overriding String used for separating root-level\n      * JSON values (default is single space character)\n+     *<p>\n+     * Default implementation throws {@link UnsupportedOperationException}.\n      * \n      * @param sep Separator to use, if any; null means that no separator is\n      *   automatically added\n      * \n      * @return True if this generator can use given schema; false if not\n      */\n-    public boolean canUseSchema(FormatSchema schema) {\n-        return false;\n-    }\n+    public boolean canUseSchema(FormatSchema schema) { return false; }\n     \n     /**\n      * Introspection method that may be called to see if the underlying\n      * \n      * @since 2.3\n      */\n-    public boolean canWriteObjectId() {\n-        return false;\n-    }\n+    public boolean canWriteObjectId() { return false; }\n \n     /**\n      * Introspection method that may be called to see if the underlying\n      * \n      * @since 2.3\n      */\n-    public boolean canWriteTypeId() {\n-        return false;\n-    }\n+    public boolean canWriteTypeId() { return false; }\n \n     /**\n      * Introspection method that may be called to see if the underlying\n      * \n      * @since 2.3\n      */\n-    public boolean canWriteBinaryNatively() {\n-        return false;\n-    }\n+    public boolean canWriteBinaryNatively() { return false; }\n     \n     /**\n      * Introspection method to call to check whether it is ok to omit\n      * \n      * @since 2.3\n      */\n-    public boolean canOmitFields() {\n-        return true;\n-    }\n+    public boolean canOmitFields() { return true; }\n \n     /*\n     /**********************************************************\n      * are allowed: meaning everywhere except for when\n      * a field name is expected.\n      */\n-    public abstract void writeStartArray()\n-        throws IOException, JsonGenerationException;\n+    public abstract void writeStartArray() throws IOException;\n \n     /**\n      * Method for writing closing marker of a JSON Array value\n      * is Array.\n      */\n     public abstract void writeEndArray()\n-        throws IOException, JsonGenerationException;\n+        throws IOException;\n \n     /**\n      * Method for writing starting marker of a JSON Object value\n      * a field name is expected.\n      */\n     public abstract void writeStartObject()\n-        throws IOException, JsonGenerationException;\n+        throws IOException;\n \n     /**\n      * Method for writing closing marker of a JSON Object value\n      * for more details).\n      */\n     public abstract void writeEndObject()\n-        throws IOException, JsonGenerationException;\n+        throws IOException;\n \n     /**\n      * Method for writing a field name (JSON String surrounded by\n      * (field names alternate with values).\n      */\n     public abstract void writeFieldName(String name)\n-        throws IOException, JsonGenerationException;\n+        throws IOException;\n \n     /**\n      * Method similar to {@link #writeFieldName(String)}, main difference\n      * use of more efficient methods argument object has.\n      */\n     public abstract void writeFieldName(SerializableString name)\n-        throws IOException, JsonGenerationException;\n+        throws IOException;\n \n     /*\n     /**********************************************************\n      * escaped as required by JSON specification.\n      */\n     public abstract void writeString(String text)\n-        throws IOException, JsonGenerationException;\n+        throws IOException;\n \n     /**\n      * Method for outputting a String value. Depending on context\n      * escaped as required by JSON specification.\n      */\n     public abstract void writeString(char[] text, int offset, int len)\n-        throws IOException, JsonGenerationException;\n+        throws IOException;\n \n     /**\n      * Method similar to {@link #writeString(String)}, but that takes\n      * if possible.\n      */\n     public abstract void writeString(SerializableString text)\n-        throws IOException, JsonGenerationException;\n+        throws IOException;\n \n     /**\n      * Method similar to {@link #writeString(String)} but that takes as\n      * of having to decode input.\n      */\n     public abstract void writeRawUTF8String(byte[] text, int offset, int length)\n-        throws IOException, JsonGenerationException;\n+        throws IOException;\n \n     /**\n      * Method similar to {@link #writeString(String)} but that takes as its input\n      * of having to decode input.\n      */\n     public abstract void writeUTF8String(byte[] text, int offset, int length)\n-        throws IOException, JsonGenerationException;\n+        throws IOException;\n     \n     /*\n     /**********************************************************\n      * such by-pass methods: those that do not will throw\n      * {@link UnsupportedOperationException}.\n      */\n-    public abstract void writeRaw(String text)\n-        throws IOException, JsonGenerationException;\n+    public abstract void writeRaw(String text) throws IOException;\n \n     /**\n      * Method that will force generator to copy\n      * such by-pass methods: those that do not will throw\n      * {@link UnsupportedOperationException}.\n      */\n-    public abstract void writeRaw(String text, int offset, int len)\n-        throws IOException, JsonGenerationException;\n+    public abstract void writeRaw(String text, int offset, int len) throws IOException;\n \n     /**\n      * Method that will force generator to copy\n      * such by-pass methods: those that do not will throw\n      * {@link UnsupportedOperationException}.\n      */\n-    public abstract void writeRaw(char[] text, int offset, int len)\n-        throws IOException, JsonGenerationException;\n+    public abstract void writeRaw(char[] text, int offset, int len) throws IOException;\n \n     /**\n      * Method that will force generator to copy\n      * such by-pass methods: those that do not will throw\n      * {@link UnsupportedOperationException}.\n      */\n-    public abstract void writeRaw(char c)\n-        throws IOException, JsonGenerationException;\n+    public abstract void writeRaw(char c) throws IOException;\n \n     /**\n      * Method that will force generator to copy\n      * \n      * @since 2.1\n      */\n-    public void writeRaw(SerializableString raw)\n-        throws IOException, JsonGenerationException {\n+    public void writeRaw(SerializableString raw) throws IOException {\n         writeRaw(raw.getValue());\n     }\n     \n      * are added if and as needed (comma or colon), and generator\n      * state updated to reflect this.\n      */\n-    public abstract void writeRawValue(String text)\n-        throws IOException, JsonGenerationException;\n-\n-    public abstract void writeRawValue(String text, int offset, int len)\n-        throws IOException, JsonGenerationException;\n-\n-    public abstract void writeRawValue(char[] text, int offset, int len)\n-        throws IOException, JsonGenerationException;\n+    public abstract void writeRawValue(String text) throws IOException;\n+\n+    public abstract void writeRawValue(String text, int offset, int len) throws IOException;\n+\n+    public abstract void writeRawValue(char[] text, int offset, int len) throws IOException;\n \n     /**\n      * Method that will output given chunk of binary data as base64\n      * are required to accept such \"long line base64\"; as do\n      * typical production-level base64 decoders.\n      *\n-     * @param b64variant Base64 variant to use: defines details such as\n+     * @param bv Base64 variant to use: defines details such as\n      *   whether padding is used (and if so, using which character);\n      *   what is the maximum line length before adding linefeed,\n      *   and also the underlying alphabet to use.\n      */\n-    public abstract void writeBinary(Base64Variant b64variant,\n-            byte[] data, int offset, int len)\n-        throws IOException, JsonGenerationException;\n+    public abstract void writeBinary(Base64Variant bv,\n+            byte[] data, int offset, int len) throws IOException;\n \n     /**\n      * Similar to {@link #writeBinary(Base64Variant,byte[],int,int)},\n      * but default to using the Jackson default Base64 variant \n      * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}).\n      */\n-    public void writeBinary(byte[] data, int offset, int len)\n-        throws IOException, JsonGenerationException\n-    {\n+    public void writeBinary(byte[] data, int offset, int len) throws IOException {\n         writeBinary(Base64Variants.getDefaultVariant(), data, offset, len);\n     }\n \n      * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}). Also\n      * assumes that whole byte array is to be output.\n      */\n-    public void writeBinary(byte[] data)\n-        throws IOException, JsonGenerationException\n-    {\n+    public void writeBinary(byte[] data) throws IOException {\n         writeBinary(Base64Variants.getDefaultVariant(), data, 0, data.length);\n     }\n \n      *    other formats may\n      */\n     public int writeBinary(InputStream data, int dataLength)\n-        throws IOException, JsonGenerationException {\n+        throws IOException {\n         return writeBinary(Base64Variants.getDefaultVariant(), data, dataLength);\n     }\n     \n      * but where input is provided through a stream, allowing for incremental\n      * writes without holding the whole input in memory.\n      * \n-     * @param b64variant Base64 variant to use\n+     * @param bv Base64 variant to use\n      * @param data InputStream to use for reading binary data to write.\n      *    Will not be closed after successful write operation\n      * @param dataLength (optional) number of bytes that will be available;\n      * \n      * @since 2.1\n      */\n-    public abstract int writeBinary(Base64Variant b64variant,\n-            InputStream data, int dataLength)\n-        throws IOException, JsonGenerationException;\n+    public abstract int writeBinary(Base64Variant bv,\n+            InputStream data, int dataLength) throws IOException;\n \n     /*\n     /**********************************************************\n      *\n      * @since 2.2\n      */\n-    public void writeNumber(short v) throws IOException, JsonGenerationException {\n-        writeNumber((int) v);\n-    }\n+    public void writeNumber(short v) throws IOException { writeNumber((int) v); }\n \n     /**\n      * Method for outputting given value as Json number.\n      * Additional white space may be added around the value\n      * if pretty-printing is enabled.\n      */\n-    public abstract void writeNumber(int v)\n-        throws IOException, JsonGenerationException;\n+    public abstract void writeNumber(int v) throws IOException;\n \n     /**\n      * Method for outputting given value as Json number.\n      * Additional white space may be added around the value\n      * if pretty-printing is enabled.\n      */\n-    public abstract void writeNumber(long v)\n-        throws IOException, JsonGenerationException;\n+    public abstract void writeNumber(long v) throws IOException;\n \n     /**\n      * Method for outputting given value as Json number.\n      * Additional white space may be added around the value\n      * if pretty-printing is enabled.\n      */\n-    public abstract void writeNumber(BigInteger v)\n-        throws IOException, JsonGenerationException;\n+    public abstract void writeNumber(BigInteger v) throws IOException;\n \n     /**\n      * Method for outputting indicate Json numeric value.\n      * Additional white space may be added around the value\n      * if pretty-printing is enabled.\n      */\n-    public abstract void writeNumber(double d)\n-        throws IOException, JsonGenerationException;\n+    public abstract void writeNumber(double d) throws IOException;\n \n     /**\n      * Method for outputting indicate Json numeric value.\n      * Additional white space may be added around the value\n      * if pretty-printing is enabled.\n      */\n-    public abstract void writeNumber(float f)\n-        throws IOException, JsonGenerationException;\n+    public abstract void writeNumber(float f) throws IOException;\n \n     /**\n      * Method for outputting indicate Json numeric value.\n      * Additional white space may be added around the value\n      * if pretty-printing is enabled.\n      */\n-    public abstract void writeNumber(BigDecimal dec)\n-        throws IOException, JsonGenerationException;\n+    public abstract void writeNumber(BigDecimal dec) throws IOException;\n \n     /**\n      * Write method that can be used for custom numeric types that can\n      * for generator-wrappers around Java objects or Json nodes.\n      * If implementation does not implement this method,\n      * it needs to throw {@link UnsupportedOperationException}.\n-     */\n-    public abstract void writeNumber(String encodedValue)\n-        throws IOException, JsonGenerationException,\n-               UnsupportedOperationException;\n+     * \n+     * @throws UnsupportedOperationException If underlying data format does not\n+     *   support numbers serialized textually AND if generator is not allowed\n+     *   to just output a String instead (Schema-based formats may require actual\n+     *   number, for example)\n+     */\n+    public abstract void writeNumber(String encodedValue) throws IOException;\n \n     /**\n      * Method for outputting literal Json boolean value (one of\n      * Additional white space may be added around the value\n      * if pretty-printing is enabled.\n      */\n-    public abstract void writeBoolean(boolean state)\n-        throws IOException, JsonGenerationException;\n+    public abstract void writeBoolean(boolean state) throws IOException;\n \n     /**\n      * Method for outputting literal Json null value.\n      * Additional white space may be added around the value\n      * if pretty-printing is enabled.\n      */\n-    public abstract void writeNull()\n-        throws IOException, JsonGenerationException;\n+    public abstract void writeNull() throws IOException;\n \n     /*\n     /**********************************************************\n      * \n      * @since 2.3\n      */\n-    public void writeObjectId(Object id)\n-        throws IOException, JsonGenerationException\n-    {\n+    public void writeObjectId(Object id) throws IOException {\n         throw new JsonGenerationException(\"No native support for writing Object Ids\");\n     }\n \n      * If output is not allowed by the data format in this position,\n      * a {@link JsonGenerationException} will be thrown.\n      */\n-    public void writeObjectRef(Object id)\n-            throws IOException, JsonGenerationException {\n+    public void writeObjectRef(Object id) throws IOException {\n         throw new JsonGenerationException(\"No native support for writing Object Ids\");\n     }\n     \n      * \n      * @since 2.3\n      */\n-    public void writeTypeId(Object id)\n-        throws IOException, JsonGenerationException {\n+    public void writeTypeId(Object id) throws IOException {\n         throw new JsonGenerationException(\"No native support for writing Type Ids\");\n     }\n     \n      * set to non-null value; for generators created by a mapping\n      * factory this is the case, for others not.\n      */\n-    public abstract void writeObject(Object pojo)\n-        throws IOException, JsonProcessingException;\n+    public abstract void writeObject(Object pojo) throws IOException;\n \n     /**\n      * Method for writing given JSON tree (expressed as a tree\n      * for convenience and to make code more explicit in cases\n      * where it deals specifically with trees.\n      */\n-    public abstract void writeTree(TreeNode rootNode)\n-        throws IOException, JsonProcessingException;\n+    public abstract void writeTree(TreeNode rootNode) throws IOException;\n \n     /*\n     /**********************************************************\n      *<p>\n      * Note: many performance-sensitive implementations override this method\n      */\n-    public void writeStringField(String fieldName, String value)\n-        throws IOException, JsonGenerationException\n-    {\n+    public void writeStringField(String fieldName, String value) throws IOException {\n         writeFieldName(fieldName);\n         writeString(value);\n     }\n      *  writeBoolean(value);\n      *</pre>\n      */\n-    public final void writeBooleanField(String fieldName, boolean value)\n-        throws IOException, JsonGenerationException\n-    {\n+    public final void writeBooleanField(String fieldName, boolean value) throws IOException {\n         writeFieldName(fieldName);\n         writeBoolean(value);\n     }\n      *  writeNull();\n      *</pre>\n      */\n-    public final void writeNullField(String fieldName)\n-        throws IOException, JsonGenerationException\n-    {\n+    public final void writeNullField(String fieldName) throws IOException {\n         writeFieldName(fieldName);\n         writeNull();\n     }\n      *  writeNumber(value);\n      *</pre>\n      */\n-    public final void writeNumberField(String fieldName, int value)\n-        throws IOException, JsonGenerationException\n-    {\n+    public final void writeNumberField(String fieldName, int value) throws IOException {\n         writeFieldName(fieldName);\n         writeNumber(value);\n     }\n      *  writeNumber(value);\n      *</pre>\n      */\n-    public final void writeNumberField(String fieldName, long value)\n-        throws IOException, JsonGenerationException\n-    {\n+    public final void writeNumberField(String fieldName, long value) throws IOException {\n         writeFieldName(fieldName);\n         writeNumber(value);\n     }\n      *  writeNumber(value);\n      *</pre>\n      */\n-    public final void writeNumberField(String fieldName, double value)\n-        throws IOException, JsonGenerationException\n-    {\n+    public final void writeNumberField(String fieldName, double value) throws IOException {\n         writeFieldName(fieldName);\n         writeNumber(value);\n     }\n      *  writeNumber(value);\n      *</pre>\n      */\n-    public final void writeNumberField(String fieldName, float value)\n-        throws IOException, JsonGenerationException\n-    {\n+    public final void writeNumberField(String fieldName, float value) throws IOException {\n         writeFieldName(fieldName);\n         writeNumber(value);\n     }\n      *  writeNumber(value);\n      *</pre>\n      */\n-    public final void writeNumberField(String fieldName, BigDecimal value)\n-        throws IOException, JsonGenerationException\n-    {\n+    public final void writeNumberField(String fieldName, BigDecimal value) throws IOException {\n         writeFieldName(fieldName);\n         writeNumber(value);\n     }\n      *  writeBinary(value);\n      *</pre>\n      */\n-    public final void writeBinaryField(String fieldName, byte[] data)\n-        throws IOException, JsonGenerationException\n-    {\n+    public final void writeBinaryField(String fieldName, byte[] data) throws IOException {\n         writeFieldName(fieldName);\n         writeBinary(data);\n     }\n      * (by calling {#link #writeEndArray}) after writing all values\n      * of the value Array.\n      */\n-    public final void writeArrayFieldStart(String fieldName)\n-        throws IOException, JsonGenerationException\n-    {\n+    public final void writeArrayFieldStart(String fieldName) throws IOException {\n         writeFieldName(fieldName);\n         writeStartArray();\n     }\n      * (by calling {#link #writeEndObject}) after writing all\n      * entries of the value Object.\n      */\n-    public final void writeObjectFieldStart(String fieldName)\n-        throws IOException, JsonGenerationException\n-    {\n+    public final void writeObjectFieldStart(String fieldName) throws IOException {\n         writeFieldName(fieldName);\n         writeStartObject();\n     }\n      *  writeObject(pojo);\n      *</pre>\n      */\n-    public final void writeObjectField(String fieldName, Object pojo)\n-        throws IOException, JsonProcessingException\n-    {\n+    public final void writeObjectField(String fieldName, Object pojo) throws IOException {\n         writeFieldName(fieldName);\n         writeObject(pojo);\n     }\n      * \n      * @since 2.3\n      */\n-    public void writeOmittedField(String fieldName)\n-        throws IOException, JsonGenerationException\n-    {\n-        // default implementation does nothing\n-    }\n+    public void writeOmittedField(String fieldName) throws IOException { }\n     \n     /*\n     /**********************************************************\n      * parser, although it may cause parser to internally process\n      * more data (if it lazy loads contents of value events, for example)\n      */\n-    public void copyCurrentEvent(JsonParser jp)\n-        throws IOException, JsonProcessingException\n+    public void copyCurrentEvent(JsonParser jp) throws IOException\n     {\n         JsonToken t = jp.getCurrentToken();\n         // sanity check; what to do?\n      * the event parser already pointed to (if there were no\n      * enclosed events), or the last enclosed event copied.\n      */\n-    public void copyCurrentStructure(JsonParser jp)\n-        throws IOException, JsonProcessingException\n+    public void copyCurrentStructure(JsonParser jp) throws IOException\n     {\n         JsonToken t = jp.getCurrentToken();\n         if (t == null) {\n      * Note that sub-classes may override this method to add more detail\n      * or use a {@link JsonGenerationException} sub-class.\n      */\n-    protected void _reportError(String msg)\n-        throws JsonGenerationException\n-    {\n+    protected void _reportError(String msg) throws JsonGenerationException {\n         throw new JsonGenerationException(msg);\n     }\n \n-    protected final void _throwInternal() {\n-        VersionUtil.throwInternal();\n-    }\n+    protected final void _throwInternal() { VersionUtil.throwInternal(); }\n \n     protected void _reportUnsupportedOperation() {\n         throw new UnsupportedOperationException(\"Operation not supported by generator of type \"+getClass().getName());\n      *\n      * @param value Non-null value to write\n      */\n-    protected void _writeSimpleObject(Object value) \n-        throws IOException, JsonGenerationException\n+    protected void _writeSimpleObject(Object value)  throws IOException\n     {\n         /* 31-Dec-2009, tatu: Actually, we could just handle some basic\n          *    types even without codec. This can improve interoperability,\n--- a/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n      */\n \n     protected JsonParser() { }\n-    protected JsonParser(int features) {\n-        _features = features;\n-    }\n+    protected JsonParser(int features) { _features = features; }\n \n     /**\n      * Accessor for {@link ObjectCodec} associated with this\n      * Method for enabling or disabling specified feature\n      * (check {@link Feature} for list of features)\n      */\n-    public JsonParser configure(Feature f, boolean state)\n-    {\n-        if (state) { enable(f);\n-        } else { disable(f); }\n+    public JsonParser configure(Feature f, boolean state) {\n+        if (state) enable(f); else disable(f);\n         return this;\n     }\n     \n      * \n      * @since 2.3\n      */\n-    public int getFeatureMask() {\n-        return _features;\n-    }\n+    public int getFeatureMask() { return _features; }\n \n     /**\n      * Bulk set method for (re)settting states of all standard {@link Feature}s\n      * @return Next token from the stream, if any found, or null\n      *   to indicate end-of-input\n      */\n-    public abstract JsonToken nextToken()\n-        throws IOException;\n+    public abstract JsonToken nextToken() throws IOException;\n \n     /**\n      * Iteration method that will advance stream enough\n      * but may be faster for parser to process, and can therefore be used if caller\n      * expects to get a String value next from input.\n      */\n-    public String nextTextValue() throws IOException\n-    {\n+    public String nextTextValue() throws IOException {\n         return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n     }\n \n      * but may be faster for parser to process, and can therefore be used if caller\n      * expects to get a String value next from input.\n      */\n-    public Boolean nextBooleanValue() throws IOException\n-    {\n+    public Boolean nextBooleanValue() throws IOException {\n         JsonToken t = nextToken();\n         if (t == JsonToken.VALUE_TRUE) { return Boolean.TRUE; }\n         if (t == JsonToken.VALUE_FALSE) { return Boolean.FALSE; }\n      * is to avoid construction of a String object (which\n      * will make a copy of contents).\n      */\n-    public abstract char[] getTextCharacters()\n-        throws IOException;\n+    public abstract char[] getTextCharacters() throws IOException;\n \n     /**\n      * Accessor used with {@link #getTextCharacters}, to know length\n      * Java byte, a {@link JsonParseException}\n      * will be thrown to indicate numeric overflow/underflow.\n      */\n-    public byte getByteValue() throws IOException\n-    {\n+    public byte getByteValue() throws IOException {\n         int value = getIntValue();\n         // So far so good: but does it fit?\n         // [JACKSON-804]: Let's actually allow range of [-128, 255], as those are uniquely mapped\n      * Decoded binary content, however, will be retained until\n      * parser is advanced to the next event.\n      *\n-     * @param b64variant Expected variant of base64 encoded\n+     * @param bv Expected variant of base64 encoded\n      *   content (see {@link Base64Variants} for definitions\n      *   of \"standard\" variants).\n      *\n      * @return Decoded binary data\n      */\n-    public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException;\n+    public abstract byte[] getBinaryValue(Base64Variant bv) throws IOException;\n \n     /**\n      * Convenience alternative to {@link #getBinaryValue(Base64Variant)}\n      * Similar to {@link #readBinaryValue(OutputStream)} but allows explicitly\n      * specifying base64 variant to use.\n      * \n-     * @param b64variant base64 variant to use\n+     * @param bv base64 variant to use\n      * @param out Output stream to use for passing decoded binary data\n      * \n      * @return Number of bytes that were decoded and written via {@link OutputStream}\n      * \n      * @since 2.1\n      */\n-    public int readBinaryValue(Base64Variant b64variant, OutputStream out)\n-            throws IOException\n-    {\n+    public int readBinaryValue(Base64Variant bv, OutputStream out) throws IOException {\n         _reportUnsupportedOperation();\n         return 0; // never gets here\n     }\n      *<p>\n      * If representation can not be converted to an int (including structured type\n      * markers like start/end Object/Array)\n-     * specified <b>defaultValue</b> will be returned; no exceptions are thrown.\n-     */\n-    public int getValueAsInt(int defaultValue) throws IOException {\n-        return defaultValue;\n-    }\n+     * specified <b>def</b> will be returned; no exceptions are thrown.\n+     */\n+    public int getValueAsInt(int def) throws IOException { return def; }\n \n     /**\n      * Method that will try to convert value of current token to a\n      *<p>\n      * If representation can not be converted to an int (including structured type\n      * markers like start/end Object/Array)\n-     * specified <b>defaultValue</b> will be returned; no exceptions are thrown.\n-     */\n-    public long getValueAsLong(long defaultValue) throws IOException {\n-        return defaultValue;\n+     * specified <b>def</b> will be returned; no exceptions are thrown.\n+     */\n+    public long getValueAsLong(long def) throws IOException {\n+        return def;\n     }\n     \n     /**\n      *<p>\n      * If representation can not be converted to an int (including structured types\n      * like Objects and Arrays),\n-     * specified <b>defaultValue</b> will be returned; no exceptions are thrown.\n-     */\n-    public double getValueAsDouble(double defaultValue) throws IOException {\n-        return defaultValue;\n+     * specified <b>def</b> will be returned; no exceptions are thrown.\n+     */\n+    public double getValueAsDouble(double def) throws IOException {\n+        return def;\n     }\n \n     /**\n      *<p>\n      * If representation can not be converted to a boolean value (including structured types\n      * like Objects and Arrays),\n-     * specified <b>defaultValue</b> will be returned; no exceptions are thrown.\n-     */\n-    public boolean getValueAsBoolean(boolean defaultValue) throws IOException {\n-        return defaultValue;\n+     * specified <b>def</b> will be returned; no exceptions are thrown.\n+     */\n+    public boolean getValueAsBoolean(boolean def) throws IOException {\n+        return def;\n     }\n \n     /**\n      * \n      * @since 2.1\n      */\n-    public abstract String getValueAsString(String defaultValue) throws IOException;\n+    public abstract String getValueAsString(String def) throws IOException;\n \n     /*\n     /**********************************************************\n      * \n      * @since 2.3\n      */\n-    public boolean canReadTypeId() {\n-        return false;\n-    }\n+    public boolean canReadTypeId() { return false; }\n \n     /**\n      * Method that can be called to check whether current token\n      * The reason is that due to type erasure, key and value types\n      * can not be introspected when using this method.\n      */\n-    public <T> T readValueAs(Class<T> valueType) throws IOException\n-    {\n-        ObjectCodec codec = getCodec();\n-        if (codec == null) {\n-            throw new IllegalStateException(\"No ObjectCodec defined for the parser, can not deserialize JSON into Java objects\");\n-        }\n-        return codec.readValue(this, valueType);\n+    public <T> T readValueAs(Class<T> valueType) throws IOException {\n+        return _codec().readValue(this, valueType);\n     }\n \n     /**\n      * stream is not advanced.\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public <T> T readValueAs(TypeReference<?> valueTypeRef) throws IOException\n-    {\n-        ObjectCodec codec = getCodec();\n-        if (codec == null) {\n-            throw new IllegalStateException(\"No ObjectCodec defined for the parser, can not deserialize JSON into Java objects\");\n-        }\n-        /* Ugh. Stupid Java type erasure... can't just chain call,s\n-         * must cast here also.\n-         */\n-        return (T) codec.readValue(this, valueTypeRef);\n+    public <T> T readValueAs(TypeReference<?> valueTypeRef) throws IOException {\n+        return (T) _codec().readValue(this, valueTypeRef);\n     }\n \n     /**\n      * Method for reading sequence of Objects from parser stream,\n      * all with same specified value type.\n      */\n-    public <T> Iterator<T> readValuesAs(Class<T> valueType) throws IOException\n-    {\n-        ObjectCodec codec = getCodec();\n-        if (codec == null) {\n-            throw new IllegalStateException(\"No ObjectCodec defined for the parser, can not deserialize JSON into Java objects\");\n-        }\n-        return codec.readValues(this, valueType);\n+    public <T> Iterator<T> readValuesAs(Class<T> valueType) throws IOException {\n+        return _codec().readValues(this, valueType);\n     }\n \n     /**\n      * Method for reading sequence of Objects from parser stream,\n      * all with same specified value type.\n      */\n-    public <T> Iterator<T> readValuesAs(TypeReference<?> valueTypeRef) throws IOException\n-    {\n-        ObjectCodec codec = getCodec();\n-        if (codec == null) {\n-            throw new IllegalStateException(\"No ObjectCodec defined for the parser, can not deserialize JSON into Java objects\");\n-        }\n-        return codec.readValues(this, valueTypeRef);\n+    public <T> Iterator<T> readValuesAs(TypeReference<?> valueTypeRef) throws IOException {\n+        return _codec().readValues(this, valueTypeRef);\n     }\n     \n     /**\n      */\n     @SuppressWarnings(\"unchecked\")\n     public <T extends TreeNode> T readValueAsTree() throws IOException {\n-        ObjectCodec codec = getCodec();\n-        if (codec == null) {\n-            throw new IllegalStateException(\"No ObjectCodec defined for the parser, can not deserialize JSON into JsonNode tree\");\n+        return (T) _codec().readTree(this);\n+    }\n+\n+    protected ObjectCodec _codec() {\n+        ObjectCodec c = getCodec();\n+        if (c == null) {\n+            throw new IllegalStateException(\"No ObjectCodec defined for parser, needed for deserialization\");\n         }\n-        return (T) codec.readTree(this);\n-    }\n-\n+        return c;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Internal methods", "timestamp": 1389941170, "metainfo": ""}