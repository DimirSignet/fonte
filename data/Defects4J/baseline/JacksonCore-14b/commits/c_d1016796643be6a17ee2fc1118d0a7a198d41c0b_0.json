{"sha": "d1016796643be6a17ee2fc1118d0a7a198d41c0b", "log": "Bit more streamlining of text handling for parsing", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n         if (_currToken == JsonToken.VALUE_STRING) {\n             if (_tokenIncomplete) {\n                 _tokenIncomplete = false;\n-                _finishString(); // only strings can be incomplete\n+                return _finishAndReturnString(); // only strings can be incomplete\n             }\n             return _textBuffer.contentsAsString();\n         }\n         if (_currToken == JsonToken.VALUE_STRING) {\n             if (_tokenIncomplete) {\n                 _tokenIncomplete = false;\n-                _finishString(); // only strings can be incomplete\n+                return _finishAndReturnString(); // only strings can be incomplete\n             }\n             return _textBuffer.contentsAsString();\n         }\n         if (_currToken == JsonToken.VALUE_STRING) {\n             if (_tokenIncomplete) {\n                 _tokenIncomplete = false;\n-                _finishString(); // only strings can be incomplete\n+                return _finishAndReturnString(); // only strings can be incomplete\n             }\n             return _textBuffer.contentsAsString();\n         }\n             if (t == JsonToken.VALUE_STRING) {\n                 if (_tokenIncomplete) {\n                     _tokenIncomplete = false;\n-                    _finishString();\n+                    return _finishAndReturnString();\n                 }\n                 return _textBuffer.contentsAsString();\n             }\n         _finishString2(outBuf, outPtr);\n     }\n \n+    /**\n+     * @since 2.6\n+     */\n+    protected String _finishAndReturnString() throws IOException\n+    {\n+        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n+        int ptr = _inputPtr;\n+        if (ptr >= _inputEnd) {\n+            loadMoreGuaranteed();\n+            ptr = _inputPtr;\n+        }\n+        int outPtr = 0;\n+        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n+        final int[] codes = _icUTF8;\n+\n+        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n+        final byte[] inputBuffer = _inputBuffer;\n+        while (ptr < max) {\n+            int c = (int) inputBuffer[ptr] & 0xFF;\n+            if (codes[c] != 0) {\n+                if (c == INT_QUOTE) {\n+                    _inputPtr = ptr+1;\n+                    return _textBuffer.setCurrentAndReturn(outPtr);\n+                }\n+                break;\n+            }\n+            ++ptr;\n+            outBuf[outPtr++] = (char) c;\n+        }\n+        _inputPtr = ptr;\n+        _finishString2(outBuf, outPtr);\n+        return _textBuffer.contentsAsString();\n+    }\n+    \n     private final void _finishString2(char[] outBuf, int outPtr)\n         throws IOException\n     {", "timestamp": 1422072005, "metainfo": ""}