{"sha": "bff15cebd72a4da7bc56d9bb623bcb309e9c49c2", "log": "Merge branch '2.5'  Conflicts: \tpom.xml \trelease-notes/VERSION", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n             _flushBuffer();\n         }\n         _outputBuffer[_outputTail++] = BYTE_QUOTE;\n-        _writeStringSegments(_charBuffer, 0, len);\n+        _writeStringSegments(text, 0, len);\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n         }\n--- a/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n import com.fasterxml.jackson.core.format.MatchStrength;\n import com.fasterxml.jackson.core.io.*;\n import com.fasterxml.jackson.core.json.*;\n-import com.fasterxml.jackson.core.sym.BytesToNameCanonicalizer;\n+import com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer;\n import com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\n import com.fasterxml.jackson.core.util.BufferRecycler;\n import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\n     implements Versioned,\n         java.io.Serializable // since 2.1 (for Android, mostly)\n {\n-    /**\n-     * Computed for Jackson 2.4.0 release\n-     */\n-    private static final long serialVersionUID = 3306684576057132431L;\n+    private static final long serialVersionUID = 1; // since 2.6.0\n \n     /*\n     /**********************************************************\n      *<p>\n      * TODO: should clean up this; looks messy having 2 alternatives\n      * with not very clear differences.\n-     */\n-    protected final transient BytesToNameCanonicalizer _rootByteSymbols = BytesToNameCanonicalizer.createRoot();\n+     * \n+     * @since 2.6.0\n+     */\n+    protected final transient ByteQuadsCanonicalizer _byteSymbolCanonicalizer = ByteQuadsCanonicalizer.createRoot();\n+\n+    /**\n+     * Earlier byte-based symbol table; replaced with 2.6 with a new implementation.\n+     * Left in for version 2.6.0: will be removed in 2.7 or later.\n+     *\n+     * @deprecated Since 2.6.0, only use {@link #_byteSymbolCanonicalizer}\n+     */\n+    @Deprecated\n+    protected final transient com.fasterxml.jackson.core.sym.BytesToNameCanonicalizer _rootByteSymbols\n+        = com.fasterxml.jackson.core.sym.BytesToNameCanonicalizer.createRoot();\n \n     /*\n     /**********************************************************\n     protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException {\n         // As per [JACKSON-259], may want to fully disable canonicalization:\n         return new ByteSourceJsonBootstrapper(ctxt, in).constructParser(_parserFeatures,\n-                _objectCodec, _rootByteSymbols, _rootCharSymbols, _factoryFeatures);\n+                _objectCodec, _byteSymbolCanonicalizer, _rootCharSymbols, _factoryFeatures);\n     }\n \n     /**\n     protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException\n     {\n         return new ByteSourceJsonBootstrapper(ctxt, data, offset, len).constructParser(_parserFeatures,\n-                _objectCodec, _rootByteSymbols, _rootCharSymbols, _factoryFeatures);\n+                _objectCodec, _byteSymbolCanonicalizer, _rootCharSymbols, _factoryFeatures);\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n      * are allowed: meaning everywhere except for when\n      * a field name is expected.\n      */\n-    public abstract void writeStartObject()\n-        throws IOException;\n+    public abstract void writeStartObject() throws IOException;\n \n     /**\n      * Method for writing closing marker of a JSON Object value\n      * complete value, or START-OBJECT marker (see JSON specification\n      * for more details).\n      */\n-    public abstract void writeEndObject()\n-        throws IOException;\n+    public abstract void writeEndObject() throws IOException;\n \n     /**\n      * Method for writing a field name (JSON String surrounded by\n      * JSON specification for details), when field name is expected\n      * (field names alternate with values).\n      */\n-    public abstract void writeFieldName(String name)\n-        throws IOException;\n+    public abstract void writeFieldName(String name) throws IOException;\n \n     /**\n      * Method similar to {@link #writeFieldName(String)}, main difference\n      * serialized String; implementations are strongly encouraged to make\n      * use of more efficient methods argument object has.\n      */\n-    public abstract void writeFieldName(SerializableString name)\n-        throws IOException;\n+    public abstract void writeFieldName(SerializableString name) throws IOException;\n \n     /*\n     /**********************************************************\n      * surrounded in double quotes, and contents will be properly\n      * escaped as required by JSON specification.\n      */\n-    public abstract void writeString(String text)\n-        throws IOException;\n+    public abstract void writeString(String text) throws IOException;\n \n     /**\n      * Method for outputting a String value. Depending on context\n      * surrounded in double quotes, and contents will be properly\n      * escaped as required by JSON specification.\n      */\n-    public abstract void writeString(char[] text, int offset, int len)\n-        throws IOException;\n+    public abstract void writeString(char[] text, int offset, int len) throws IOException;\n \n     /**\n      * Method similar to {@link #writeString(String)}, but that takes\n      * sub-classes should override it with more efficient implementation\n      * if possible.\n      */\n-    public abstract void writeString(SerializableString text)\n-        throws IOException;\n+    public abstract void writeString(SerializableString text) throws IOException;\n \n     /**\n      * Method similar to {@link #writeString(String)} but that takes as\n--- a/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n           * @since 2.3\n           */\n          STRICT_DUPLICATE_DETECTION(false),\n-            ;\n+\n+         /**\n+          * Feature that determines what to do if the underlying data format requires knowledge\n+          * of all properties to decode (usually via a Schema), and if no definition is\n+          * found for a property that input content contains.\n+          * Typically most textual data formats do NOT require schema information (although\n+          * some do, such as CSV), whereas many binary data formats do require definitions\n+          * (such as Avro, protobuf), although not all (Smile, CBOR, BSON and MessagePack do not).\n+          * Further note that some formats that do require schema information will not be able\n+          * to ignore undefined properties: for example, Avro is fully positional and there is\n+          * no possibility of undefined data. This leaves formats like Protobuf that have identifiers\n+          * that may or may not map; and as such Protobuf format does make use of this feature.\n+          *<p>\n+          * Note that support for this feature is implemented by individual data format\n+          * module, if (and only if) it makes sense for the format in question. For JSON,\n+          * for example, this feature has no effect as properties need not be pre-defined.\n+          *<p>\n+          * Feature is disabled by default, meaning that if the underlying data format\n+          * requires knowledge of all properties to output, attempts to read an unknown\n+          * property will result in a {@link JsonProcessingException}\n+          *\n+          * @since 2.6\n+          */\n+         IGNORE_UNDEFINED(false)\n+         ;\n \n         /**\n          * Whether feature is enabled or disabled by default.\n      * @since 2.5\n      */\n     public String nextFieldName() throws IOException, JsonParseException {\n-        return (nextToken() == JsonToken.FIELD_NAME)\n-                ? getCurrentName() : null;\n+        return (nextToken() == JsonToken.FIELD_NAME) ? getCurrentName() : null;\n     }\n \n     /**\n      */\n     public abstract boolean hasTokenId(int id);\n \n+    /**\n+     * Method that is functionally equivalent to:\n+     *<code>\n+     *  return getCurrentTokenId() == id\n+     *</code>\n+     * but may be more efficiently implemented.\n+     *<p>\n+     * Note that no traversal or conversion is performed; so in some\n+     * cases calling method like {@link #isExpectedStartArrayToken()}\n+     * is necessary instead.\n+     *\n+     * @since 2.6\n+     */\n+    public abstract boolean hasToken(JsonToken t);\n+    \n     /**\n      * Method that can be called to get the name associated with\n      * the current token: for {@link JsonToken#FIELD_NAME}s it will\n--- a/src/main/java/com/fasterxml/jackson/core/PrettyPrinter.java\n+++ b/src/main/java/com/fasterxml/jackson/core/PrettyPrinter.java\n      * to output a curly bracket as well, but can surround that\n      * with other (white-space) decoration.\n      */\n-    void writeStartObject(JsonGenerator jg)\n+    void writeStartObject(JsonGenerator gen)\n         throws IOException, JsonGenerationException;\n \n     /**\n      * @param nrOfEntries Number of direct members of the array that\n      *   have been output\n      */\n-    void writeEndObject(JsonGenerator jg, int nrOfEntries)\n+    void writeEndObject(JsonGenerator gen, int nrOfEntries)\n         throws IOException, JsonGenerationException;\n \n     /**\n      * to output a comma as well, but can surround that with other\n      * (white-space) decoration.\n      */\n-    void writeObjectEntrySeparator(JsonGenerator jg)\n+    void writeObjectEntrySeparator(JsonGenerator gen)\n         throws IOException, JsonGenerationException;\n \n     /**\n      * to output a colon as well, but can surround that with other\n      * (white-space) decoration.\n      */\n-    void writeObjectFieldValueSeparator(JsonGenerator jg)\n+    void writeObjectFieldValueSeparator(JsonGenerator gen)\n         throws IOException, JsonGenerationException;\n \n     // // // Array handling\n      * to output a bracket as well, but can surround that\n      * with other (white-space) decoration.\n      */\n-    void writeStartArray(JsonGenerator jg)\n+    void writeStartArray(JsonGenerator gen)\n         throws IOException, JsonGenerationException;\n \n     /**\n      * @param nrOfValues Number of direct members of the array that\n      *   have been output\n      */\n-    void writeEndArray(JsonGenerator jg, int nrOfValues)\n+    void writeEndArray(JsonGenerator gen, int nrOfValues)\n         throws IOException, JsonGenerationException;\n \n     /**\n      * to output a comma as well, but can surround that with other\n      * (white-space) decoration.\n      */\n-    void writeArrayValueSeparator(JsonGenerator jg)\n+    void writeArrayValueSeparator(JsonGenerator gen)\n         throws IOException, JsonGenerationException;\n \n     /*\n      * Default handling does not output anything, but pretty-printer\n      * is free to add any white space decoration.\n      */\n-    void beforeArrayValues(JsonGenerator jg)\n+    void beforeArrayValues(JsonGenerator gen)\n         throws IOException, JsonGenerationException;\n \n     /**\n      * Default handling does not output anything, but pretty-printer\n      * is free to add any white space decoration.\n      */\n-    void beforeObjectEntries(JsonGenerator jg)\n+    void beforeObjectEntries(JsonGenerator gen)\n         throws IOException, JsonGenerationException;\n }\n \n--- a/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n             | Feature.STRICT_DUPLICATE_DETECTION.getMask()\n             ;\n \n+    // // // Constants for validation messages (since 2.6)\n+\n+    protected final String WRITE_BINARY = \"write a binary value\";\n+    protected final String WRITE_BOOLEAN = \"write a boolean value\";\n+    protected final String WRITE_NULL = \"write a null\";\n+    protected final String WRITE_NUMBER = \"write a number\";\n+    protected final String WRITE_RAW = \"write a raw (unencoded) value\";\n+    protected final String WRITE_STRING = \"write a string\";\n+\n     /*\n     /**********************************************************\n     /* Configuration\n     }\n \n     /**\n-     * Implemented with detection that tries to find \"VERSION.txt\" in same\n-     * package as the implementation class.\n+     * Implemented with standard version number detection algorithm, typically using\n+     * a simple generated class, with information extracted from Maven project file\n+     * during build.\n      */\n     @Override public Version version() { return VersionUtil.versionFor(getClass()); }\n \n         if (getPrettyPrinter() != null) {\n             return this;\n         }\n-        return setPrettyPrinter(new DefaultPrettyPrinter());\n+        return setPrettyPrinter(_constructDefaultPrettyPrinter());\n     }\n     \n     @Override public JsonGenerator setCodec(ObjectCodec oc) {\n      */\n     protected abstract void _verifyValueWrite(String typeMsg) throws IOException;\n \n+    /**\n+     * Overridable factory method called to instantiate an appropriate {@link PrettyPrinter}\n+     * for case of \"just use the default one\", when {@link #useDefaultPrettyPrinter()} is called.\n+     *\n+     * @since 2.6\n+     */\n+    protected PrettyPrinter _constructDefaultPrettyPrinter() {\n+        return new DefaultPrettyPrinter();\n+    }\n+\n     /*\n     /**********************************************************\n     /* UTF-8 related helper method(s)\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n      */\n \n     protected ParserBase(IOContext ctxt, int features) {\n-        super();\n-        _features = features;\n+        super(features);\n         _ioContext = ctxt;\n         _textBuffer = ctxt.constructTextBuffer();\n         DupDetector dups = Feature.STRICT_DUPLICATE_DETECTION.enabledIn(features)\n     {\n         if ((_numTypesValid & NR_INT) == 0) {\n             if (_numTypesValid == NR_UNKNOWN) { // not parsed at all\n-                _parseNumericValue(NR_INT); // will also check event type\n+                return _parseIntValue();\n             }\n             if ((_numTypesValid & NR_INT) == 0) { // wasn't an int natively?\n                 convertNumberToInt(); // let's make it so, if possible\n         }\n         _reportError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\");\n     }\n-    \n+\n+    /**\n+     * @since 2.6\n+     */\n+    protected int _parseIntValue() throws IOException\n+    {\n+        // Inlined variant of: _parseNumericValue(NR_INT)\n+\n+        if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n+            char[] buf = _textBuffer.getTextBuffer();\n+            int offset = _textBuffer.getTextOffset();\n+            int len = _intLength;\n+            if (_numberNegative) {\n+                ++offset;\n+            }\n+            if (len <= 9) {\n+                int i = NumberInput.parseInt(buf, offset, len);\n+                if (_numberNegative) {\n+                    i = -i;\n+                }\n+                _numberInt = i;\n+                _numTypesValid = NR_INT;\n+                return i;\n+            }\n+        }\n+        _parseNumericValue(NR_INT);\n+        if ((_numTypesValid & NR_INT) == 0) {\n+            convertNumberToInt();\n+        }\n+        return _numberInt;\n+    }\n+\n     private void _parseSlowFloat(int expType) throws IOException\n     {\n         /* Nope: floating point. Here we need to be careful to get\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n      * effect when {@link #clearCurrentToken} was called.\n      */\n     protected JsonToken _lastClearedToken;\n-    \n+\n     /*\n     /**********************************************************\n     /* Life-cycle\n \n     // NOTE: had base impl in 2.3 and before; but shouldn't\n     // public abstract Version version();\n-    \n+\n     /*\n     /**********************************************************\n     /* Configuration overrides if any\n         return t.id() == id;\n     }\n \n+    @Override public final boolean hasToken(JsonToken t) {\n+        return (_currToken == t);\n+    }\n+    \n     @Override public boolean isExpectedStartArrayToken() { return _currToken == JsonToken.START_ARRAY; }\n     @Override public boolean isExpectedStartObjectToken() { return _currToken == JsonToken.START_OBJECT; }\n     \n     }\n \n     @Override\n+    public int getValueAsInt() throws IOException\n+    {\n+        JsonToken t = _currToken;\n+        if (t == JsonToken.VALUE_NUMBER_INT) {\n+            return getIntValue();\n+        }\n+        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n+            return getIntValue();\n+        }\n+        return getValueAsInt(0);\n+    }\n+\n+    @Override\n     public int getValueAsInt(int defaultValue) throws IOException\n     {\n         JsonToken t = _currToken;\n+        if (t == JsonToken.VALUE_NUMBER_INT) {\n+            return getIntValue();\n+        }\n+        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n+            return getIntValue();\n+        }\n         if (t != null) {\n             switch (t.id()) {\n             case ID_STRING:\n                     return 0;\n                 }\n                 return NumberInput.parseAsInt(str, defaultValue);\n-            case ID_NUMBER_INT:\n-            case ID_NUMBER_FLOAT:\n-                return getIntValue();\n             case ID_TRUE:\n                 return 1;\n             case ID_FALSE:\n         }\n         return defaultValue;\n     }\n+\n+    @Override\n+    public long getValueAsLong() throws IOException\n+    {\n+        JsonToken t = _currToken;\n+        if (t == JsonToken.VALUE_NUMBER_INT) {\n+            return getLongValue();\n+        }\n+        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n+            return getLongValue();\n+        }\n+        return getValueAsLong(0L);\n+    }\n     \n     @Override\n     public long getValueAsLong(long defaultValue) throws IOException\n     {\n         JsonToken t = _currToken;\n+        if (t == JsonToken.VALUE_NUMBER_INT) {\n+            return getLongValue();\n+        }\n+        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n+            return getLongValue();\n+        }\n         if (t != null) {\n             switch (t.id()) {\n             case ID_STRING:\n                     return 0L;\n                 }\n                 return NumberInput.parseAsLong(str, defaultValue);\n-            case ID_NUMBER_INT:\n-            case ID_NUMBER_FLOAT:\n-                return getLongValue();\n             case ID_TRUE:\n                 return 1L;\n             case ID_FALSE:\n     }\n \n     @Override\n+    public String getValueAsString() throws IOException {\n+        if (_currToken == JsonToken.VALUE_STRING) {\n+            return getText();\n+        }\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+            return getCurrentName();\n+        }\n+        return getValueAsString(null);\n+    }\n+    \n+    @Override\n     public String getValueAsString(String defaultValue) throws IOException {\n-        if (_currToken != JsonToken.VALUE_STRING) {\n-            if (_currToken == null || _currToken == JsonToken.VALUE_NULL || !_currToken.isScalarValue()) {\n-                return defaultValue;\n-            }\n+        if (_currToken == JsonToken.VALUE_STRING) {\n+            return getText();\n+        }\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+            return getCurrentName();\n+        }\n+        if (_currToken == null || _currToken == JsonToken.VALUE_NULL || !_currToken.isScalarValue()) {\n+            return defaultValue;\n         }\n         return getText();\n     }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/FilteringGeneratorDelegate.java\n+package com.fasterxml.jackson.core.filter;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.util.JsonGeneratorDelegate;\n+\n+/**\n+ * @since 2.6.0\n+ */\n+public class FilteringGeneratorDelegate extends JsonGeneratorDelegate\n+{\n+    /**\n+     * Object consulted to determine whether to write parts of content generator\n+     * is asked to write or not.\n+     */\n+    protected TokenFilter filter;\n+\n+    /**\n+     * Although delegate has its own output context it is not sufficient since we actually\n+     * have to keep track of excluded (filtered out) structures as well as ones delegate\n+     * actually outputs.\n+     */\n+    protected TokenFilterContext _filterContext;\n+\n+    /**\n+     * The current state constant is kept here as well, not just at the tip of {@link #_filterContext}.\n+     */\n+    protected int _currentState;\n+\n+    /*\n+    /**********************************************************\n+    /* Construction, initialization\n+    /**********************************************************\n+     */\n+\n+    public FilteringGeneratorDelegate(JsonGenerator d, TokenFilter f) {\n+        // By default, do NOT delegate copy methods\n+        super(d, false);\n+        filter = f;\n+        // Doesn't matter if it's include or exclude current, but shouldn't be including/excluding sub-tree\n+        _currentState = TokenFilter.FILTER_INCLUDE_CURRENT;\n+        _filterContext = TokenFilterContext.createRootContext(_currentState);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended API\n+    /**********************************************************\n+     */\n+\n+    public TokenFilter getTokenFilter() { return filter; }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, structural\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeStartArray() throws IOException\n+    {\n+        /*\n+        switch (_currentState) {\n+        case TokenFilter.FILTER_SKIP_TREE: // filter all down the tree?\n+            _filterContext = _filterContext.createChildArrayContext(_currentState);\n+            return;\n+        case TokenFilter.FILTER_SKIP_CURRENT: // may or may not include, need to check\n+        case TokenFilter.FILTER_INCLUDE_CURRENT:\n+            int newState = filter.startArray();\n+            _filterContext = _filterContext.createChildArrayContext(newState);\n+            if (newState >= TokenFilter.FILTER_INCLUDE_CURRENT) {\n+                delegate.writeStartArray();\n+            }\n+            return;\n+        case TokenFilter.FILTER_INCLUDE_TREE: // include the whole sub-tree?\n+        default:\n+            _filterContext = _filterContext.createChildArrayContext(_currentState);\n+            delegate.writeStartArray();\n+            return;\n+        }\n+        */\n+    }\n+\n+    @Override\n+    public void writeStartArray(int size) throws IOException\n+    {\n+        /*\n+        switch (_currentState) {\n+        case TokenFilter.FILTER_SKIP_TREE: // filter all down the tree?\n+            _filterContext = _filterContext.createChildArrayContext(_currentState);\n+            return;\n+        case TokenFilter.FILTER_SKIP_CURRENT: // may or may not include, need to check\n+        case TokenFilter.FILTER_INCLUDE_CURRENT:\n+            int newState = filter.startArray();\n+            _filterContext = _filterContext.createChildArrayContext(newState);\n+            if (newState >= TokenFilter.FILTER_INCLUDE_CURRENT) {\n+                delegate.writeStartArray(size);\n+            }\n+            return;\n+        case TokenFilter.FILTER_INCLUDE_TREE: // include the whole sub-tree?\n+        default:\n+            _filterContext = _filterContext.createChildArrayContext(_currentState);\n+            delegate.writeStartArray(size);\n+            return;\n+        }\n+        */\n+    }\n+    \n+    @Override\n+    public void writeEndArray() throws IOException\n+    {\n+        if (_currentState >= TokenFilter.FILTER_INCLUDE_CURRENT) {\n+            delegate.writeEndArray();\n+        }\n+        _filterContext = _filterContext.getParent();\n+        if (_filterContext != null) {\n+            _currentState = _filterContext.getFilterState();\n+        }\n+    }\n+\n+    @Override\n+    public void writeStartObject() throws IOException\n+    {\n+        /*\n+        switch (_currentState) {\n+        case TokenFilter.FILTER_SKIP_TREE: // filter all down the tree?\n+            _filterContext = _filterContext.createChildObjectContext(_currentState);\n+            return;\n+        case TokenFilter.FILTER_SKIP_CURRENT: // may or may not include, need to check\n+        case TokenFilter.FILTER_INCLUDE_CURRENT:\n+            int newState = filter.startObject();\n+            _filterContext = _filterContext.createChildObjectContext(newState);\n+            if (newState >= TokenFilter.FILTER_INCLUDE_CURRENT) {\n+                delegate.writeStartObject();\n+            }\n+            return;\n+        case TokenFilter.FILTER_INCLUDE_TREE: // include the whole sub-tree?\n+        default:\n+            _filterContext = _filterContext.createChildObjectContext(_currentState);\n+            delegate.writeStartObject();\n+            return;\n+        }\n+        */\n+    }\n+    \n+    @Override\n+    public void writeEndObject() throws IOException\n+    {\n+        if (_currentState >= TokenFilter.FILTER_INCLUDE_CURRENT) {\n+            delegate.writeEndObject();\n+        }\n+        _filterContext = _filterContext.getParent();\n+        if (_filterContext != null) {\n+            _currentState = _filterContext.getFilterState();\n+        }\n+    }\n+\n+    @Override\n+    public void writeFieldName(String name) throws IOException\n+    {\n+        /*\n+        switch (_currentState) {\n+        case TokenFilter.FILTER_SKIP_TREE:\n+            return;\n+        case TokenFilter.FILTER_SKIP_CURRENT: // may or may not include, need to check\n+        case TokenFilter.FILTER_INCLUDE_CURRENT:\n+            _propertyState = filter.\n+            int state = filter.startObject();\n+            if (state >= TokenFilter.FILTER_INCLUDE_CURRENT) {\n+                delegate.writeStartObject();\n+            }\n+            return;\n+        case TokenFilter.FILTER_INCLUDE_TREE: // include the whole sub-tree?\n+        default:\n+            delegate.writeFieldName(name);\n+            return;\n+        }\n+        */\n+    }\n+\n+    @Override\n+    public void writeFieldName(SerializableString name) throws IOException {\n+        delegate.writeFieldName(name);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, text/String values\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeString(String text) throws IOException {\n+        delegate.writeString(text);\n+    }\n+\n+    @Override\n+    public void writeString(char[] text, int offset, int len) throws IOException {\n+        delegate.writeString(text, offset, len);\n+    }\n+\n+    @Override\n+    public void writeString(SerializableString text) throws IOException {\n+        delegate.writeString(text);\n+    }\n+\n+    @Override\n+    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException {\n+        delegate.writeRawUTF8String(text, offset, length);\n+    }\n+\n+    @Override\n+    public void writeUTF8String(byte[] text, int offset, int length) throws IOException {\n+        delegate.writeUTF8String(text, offset, length);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, binary/raw content\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeRaw(String text) throws IOException {\n+        delegate.writeRaw(text);\n+    }\n+\n+    @Override\n+    public void writeRaw(String text, int offset, int len) throws IOException {\n+        delegate.writeRaw(text, offset, len);\n+    }\n+\n+    @Override\n+    public void writeRaw(SerializableString raw) throws IOException {\n+        delegate.writeRaw(raw);\n+    }\n+\n+    @Override\n+    public void writeRaw(char[] text, int offset, int len) throws IOException {\n+        delegate.writeRaw(text, offset, len);\n+    }\n+\n+    @Override\n+    public void writeRaw(char c) throws IOException {\n+        delegate.writeRaw(c);\n+    }\n+\n+    @Override\n+    public void writeRawValue(String text) throws IOException {\n+        delegate.writeRawValue(text);\n+    }\n+\n+    @Override\n+    public void writeRawValue(String text, int offset, int len) throws IOException {\n+        delegate.writeRawValue(text, offset, len);\n+    }\n+\n+    @Override\n+    public void writeRawValue(char[] text, int offset, int len) throws IOException {\n+        delegate.writeRawValue(text, offset, len);\n+    }\n+\n+    @Override\n+    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException {\n+        delegate.writeBinary(b64variant, data, offset, len);\n+    }\n+\n+    @Override\n+    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException {\n+        return delegate.writeBinary(b64variant, data, dataLength);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, other value types\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeNumber(short v) throws IOException {\n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(int v) throws IOException {\n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(long v) throws IOException {\n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(BigInteger v) throws IOException {\n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(double v) throws IOException {\n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(float v) throws IOException {\n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(BigDecimal v) throws IOException {\n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(String encodedValue) throws IOException, UnsupportedOperationException {\n+        delegate.writeNumber(encodedValue);\n+    }\n+\n+    @Override\n+    public void writeBoolean(boolean state) throws IOException {\n+        delegate.writeBoolean(state);\n+    }\n+\n+    @Override\n+    public void writeNull() throws IOException {\n+        delegate.writeNull();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridden field methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeOmittedField(String fieldName) throws IOException {\n+        delegate.writeOmittedField(fieldName);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, Native Ids\n+    /**********************************************************\n+     */\n+\n+    // 25-Mar-2015, tatu: These are tricky as they sort of predate actual filtering calls.\n+    //   Let's try to use current state as a clue at least...\n+    \n+    @Override\n+    public void writeObjectId(Object id) throws IOException {\n+        delegate.writeObjectId(id);\n+    }\n+\n+    @Override\n+    public void writeObjectRef(Object id) throws IOException {\n+        delegate.writeObjectRef(id);\n+    }\n+    \n+    @Override\n+    public void writeTypeId(Object id) throws IOException {\n+        delegate.writeTypeId(id);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, serializing Java objects\n+    /**********************************************************\n+     */\n+\n+    // Base class definitions for these seems correct to me, iff not directly delegating:\n+\n+    /*\n+    @Override\n+    public void writeObject(Object pojo) throws IOException,JsonProcessingException {\n+        if (delegateCopyMethods) {\n+            delegate.writeObject(pojo);\n+            return;\n+        }\n+        // NOTE: copied from \n+        if (pojo == null) {\n+            writeNull();\n+        } else {\n+            if (getCodec() != null) {\n+                getCodec().writeValue(this, pojo);\n+                return;\n+            }\n+            _writeSimpleObject(pojo);\n+        }\n+    }\n+    \n+    @Override\n+    public void writeTree(TreeNode rootNode) throws IOException {\n+        if (delegateCopyMethods) {\n+            delegate.writeTree(rootNode);\n+            return;\n+        }\n+        // As with 'writeObject()', we are not check if write would work\n+        if (rootNode == null) {\n+            writeNull();\n+        } else {\n+            if (getCodec() == null) {\n+                throw new IllegalStateException(\"No ObjectCodec defined\");\n+            }\n+            getCodec().writeValue(this, rootNode);\n+        }\n+    }\n+    */\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, copy-through methods\n+    /**********************************************************\n+     */\n+\n+    // Base class definitions for these seems correct to me, iff not directly delegating:\n+\n+    /*\n+    @Override\n+    public void copyCurrentEvent(JsonParser jp) throws IOException {\n+        if (delegateCopyMethods) delegate.copyCurrentEvent(jp);\n+        else super.copyCurrentEvent(jp);\n+    }\n+\n+    @Override\n+    public void copyCurrentStructure(JsonParser jp) throws IOException {\n+        if (delegateCopyMethods) delegate.copyCurrentStructure(jp);\n+        else super.copyCurrentStructure(jp);\n+    }\n+    */\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/TokenFilter.java\n+package com.fasterxml.jackson.core.filter;\n+\n+import com.fasterxml.jackson.core.JsonToken;\n+\n+/**\n+ * @since 2.6\n+ */\n+public abstract class TokenFilter\n+{\n+    // Constants\n+\n+    public final static int FILTER_SKIP_TREE = 1;\n+    public final static int FILTER_SKIP_CURRENT = 2;\n+    public final static int FILTER_INCLUDE_CURRENT = 3;\n+    public final static int FILTER_INCLUDE_TREE = 4;\n+\n+    // API, scalar values\n+\n+    public int writeRootScalarValue(JsonToken type) {\n+        return FILTER_SKIP_TREE;\n+    }\n+\n+    public int writeScalarProperty(String name, JsonToken type) {\n+        return FILTER_SKIP_TREE;\n+    }\n+\n+    public int writeScalarElement(int index, JsonToken type) {\n+        return FILTER_SKIP_TREE;\n+    }\n+\n+    // API, Objects\n+    \n+    public int startRootObject() {\n+        return FILTER_SKIP_TREE;\n+    }\n+    \n+    public int startObjectProperty(String name) {\n+        return FILTER_SKIP_TREE;\n+    }\n+    \n+    public int startObjectElement(int index) {\n+        return FILTER_SKIP_TREE;\n+    }\n+    \n+    public void finishObject() { }\n+\n+    // API, Arrays\n+    \n+    public int startRootArray() {\n+        return FILTER_SKIP_TREE;\n+    }\n+    \n+    public int startArrayProperty(String name) {\n+        return FILTER_SKIP_TREE;\n+    }\n+    \n+    public int startArrayElement(int index) {\n+        return FILTER_SKIP_TREE;\n+    }\n+    \n+    public void finishArray() { }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/TokenFilterContext.java\n+package com.fasterxml.jackson.core.filter;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+/**\n+ * Alternative variant of {@link JsonStreamContext}, used when filtering\n+ * content being read or written (based on {@link TokenFilter}).\n+ */\n+public class TokenFilterContext extends JsonStreamContext\n+{\n+    /**\n+     * Parent context for this context; null for root context.\n+     */\n+    protected final TokenFilterContext _parent;\n+\n+    /*\n+    /**********************************************************\n+    /* Simple instance reuse slots; speed up things\n+    /* a bit (10-15%) for docs with lots of small\n+    /* arrays/objects\n+    /**********************************************************\n+     */\n+\n+    protected TokenFilterContext _child = null;\n+\n+    /*\n+    /**********************************************************\n+    /* Location/state information\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Name of the field of which value is to be parsed; only\n+     * used for OBJECT contexts\n+     */\n+    protected String _currentName;\n+\n+    protected int _filterState;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    protected TokenFilterContext(int type, TokenFilterContext parent, int fstate) {\n+        super();\n+        _type = type;\n+        _parent = parent;\n+        _filterState = fstate;\n+        _index = -1;\n+    }\n+\n+    protected TokenFilterContext reset(int type, int fstate) {\n+        _type = type;\n+        _filterState = fstate;\n+        _index = -1;\n+        _currentName = null;\n+        return this;\n+    }\n+\n+    @Override\n+    public Object getCurrentValue() {\n+        return null;\n+    }\n+\n+    @Override\n+    public void setCurrentValue(Object v) { }\n+    \n+    /*\n+    /**********************************************************\n+    /* Factory methods\n+    /**********************************************************\n+     */\n+\n+    public static TokenFilterContext createRootContext(int fstate) {\n+        return new TokenFilterContext(TYPE_ROOT, null, fstate);\n+    }\n+\n+    public TokenFilterContext createChildArrayContext(int fstate) {\n+        TokenFilterContext ctxt = _child;\n+        if (ctxt == null) {\n+            _child = ctxt = new TokenFilterContext(TYPE_ARRAY, this, fstate);\n+            return ctxt;\n+        }\n+        return ctxt.reset(TYPE_ARRAY, fstate);\n+    }\n+\n+    public TokenFilterContext createChildObjectContext(int fstate) {\n+        TokenFilterContext ctxt = _child;\n+        if (ctxt == null) {\n+            _child = ctxt = new TokenFilterContext(TYPE_OBJECT, this, fstate);\n+            return ctxt;\n+        }\n+        return ctxt.reset(TYPE_OBJECT, fstate);\n+    }\n+\n+    @Override public final TokenFilterContext getParent() { return _parent; }\n+    @Override public final String getCurrentName() { return _currentName; }\n+\n+    public int getFilterState() { return _filterState; }\n+\n+    public void writeFieldName(String name) throws JsonProcessingException {\n+        _currentName = name;\n+    }\n+\n+    public void writeValue() {\n+        ++_index;\n+    }\n+\n+    // // // Internally used abstract methods\n+\n+    protected void appendDesc(StringBuilder sb) {\n+        if (_type == TYPE_OBJECT) {\n+            sb.append('{');\n+            if (_currentName != null) {\n+                sb.append('\"');\n+                // !!! TODO: Name chars should be escaped?\n+                sb.append(_currentName);\n+                sb.append('\"');\n+            } else {\n+                sb.append('?');\n+            }\n+            sb.append('}');\n+        } else if (_type == TYPE_ARRAY) {\n+            sb.append('[');\n+            sb.append(getCurrentIndex());\n+            sb.append(']');\n+        } else {\n+            // nah, ROOT:\n+            sb.append(\"/\");\n+        }\n+    }\n+\n+    // // // Overridden standard methods\n+\n+    /**\n+     * Overridden to provide developer writeable \"JsonPath\" representation\n+     * of the context.\n+     */\n+    @Override public String toString() {\n+        StringBuilder sb = new StringBuilder(64);\n+        appendDesc(sb);\n+        return sb.toString();\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\n         _encoding = enc;\n     }\n \n+    /**\n+     * @since 1.6\n+     */\n+    public IOContext withEncoding(JsonEncoding enc) {\n+        _encoding = enc;\n+        return this;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Public API, accessors\n--- a/src/main/java/com/fasterxml/jackson/core/io/NumberOutput.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/NumberOutput.java\n         return Double.toString(v);\n     }\n \n+    /**\n+     * @since 2.6.0\n+     */\n+    public static String toString(float v) {\n+        return Float.toString(v);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Internal methods\n--- a/src/main/java/com/fasterxml/jackson/core/json/ByteSourceJsonBootstrapper.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ByteSourceJsonBootstrapper.java\n import com.fasterxml.jackson.core.format.InputAccessor;\n import com.fasterxml.jackson.core.format.MatchStrength;\n import com.fasterxml.jackson.core.io.*;\n-import com.fasterxml.jackson.core.sym.BytesToNameCanonicalizer;\n+import com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer;\n import com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\n \n /**\n     }\n \n     public JsonParser constructParser(int parserFeatures, ObjectCodec codec,\n-            BytesToNameCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols,\n+            ByteQuadsCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols,\n             int factoryFeatures) throws IOException\n     {\n         JsonEncoding enc = detectEncoding();\n              * (which is ok for larger input; not so hot for smaller; but this is not a common case)\n              */\n             if (JsonFactory.Feature.CANONICALIZE_FIELD_NAMES.enabledIn(factoryFeatures)) {\n-                BytesToNameCanonicalizer can = rootByteSymbols.makeChild(factoryFeatures);\n+                ByteQuadsCanonicalizer can = rootByteSymbols.makeChild(factoryFeatures);\n                 return new UTF8StreamJsonParser(_context, parserFeatures, _in, codec, can,\n                         _inputBuffer, _inputPtr, _inputEnd, _bufferRecyclable);\n             }\n--- a/src/main/java/com/fasterxml/jackson/core/json/JsonGeneratorImpl.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonGeneratorImpl.java\n     // // Overrides just to make things final, to possibly help with inlining\n     \n     @Override\n-    public final void writeStringField(String fieldName, String value)\n-        throws IOException, JsonGenerationException\n+    public final void writeStringField(String fieldName, String value) throws IOException\n     {\n         writeFieldName(fieldName);\n         writeString(value);\n--- a/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java\n         return ctxt.reset(TYPE_OBJECT);\n     }\n \n-    // // // Shared API\n-\n     @Override public final JsonWriteContext getParent() { return _parent; }\n     @Override public final String getCurrentName() { return _currentName; }\n \n     public DupDetector getDupDetector() {\n         return _dups;\n     }\n-    \n-    // // // API sub-classes are to implement\n \n     /**\n      * Method that writer is to call before it writes a field name.\n     public int writeValue() {\n         // Most likely, object:\n         if (_type == TYPE_OBJECT) {\n+            if (!_gotName) {\n+                return STATUS_EXPECT_NAME;\n+            }\n             _gotName = false;\n             ++_index;\n             return STATUS_OK_AFTER_COLON;\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n             }\n             return _textBuffer.contentsAsString();\n         }\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+            return getCurrentName();\n+        }\n         return super.getValueAsString(null);\n     }\n     \n                 _finishString(); // only strings can be incomplete\n             }\n             return _textBuffer.contentsAsString();\n+        }\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+            return getCurrentName();\n         }\n         return super.getValueAsString(defValue);\n     }\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n import java.math.BigInteger;\n \n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.core.JsonGenerator.Feature;\n import com.fasterxml.jackson.core.io.*;\n \n public class UTF8JsonGenerator\n     private final static byte BYTE_u = (byte) 'u';\n \n     private final static byte BYTE_0 = (byte) '0';\n-    \n+\n     private final static byte BYTE_LBRACKET = (byte) '[';\n     private final static byte BYTE_RBRACKET = (byte) ']';\n     private final static byte BYTE_LCURLY = (byte) '{';\n     private final static byte BYTE_RCURLY = (byte) '}';\n- \n+\n     private final static byte BYTE_BACKSLASH = (byte) '\\\\';\n     private final static byte BYTE_COMMA = (byte) ',';\n     private final static byte BYTE_COLON = (byte) ':';\n \n     // intermediate copies only made up to certain length...\n     private final static int MAX_BYTES_TO_BUFFER = 512;\n-    \n+\n     final static byte[] HEX_CHARS = CharTypes.copyHexBytes();\n \n     private final static byte[] NULL_BYTES = { 'n', 'u', 'l', 'l' };\n     /* Output buffering\n     /**********************************************************\n      */\n-    \n+\n     /**\n      * Underlying output stream used for writing JSON content.\n      */\n      * in the output buffer after escaping\n      */\n     protected final int _outputMaxContiguous;\n-    \n+\n     /**\n      * Intermediate buffer in which characters of a String are copied\n      * before being encoded.\n      */\n     protected char[] _charBuffer;\n-    \n+\n     /**\n      * Length of <code>_charBuffer</code>\n      */\n     protected final int _charBufferLength;\n-    \n+\n     /**\n      * 6 character temporary buffer allocated if needed, for constructing\n      * escape sequences\n     @Override\n     public void writeString(String text) throws IOException\n     {\n-        _verifyValueWrite(\"write text value\");\n+        _verifyValueWrite(WRITE_STRING);\n         if (text == null) {\n             _writeNull();\n             return;\n     @Override\n     public void writeString(char[] text, int offset, int len) throws IOException\n     {\n-        _verifyValueWrite(\"write text value\");\n+        _verifyValueWrite(WRITE_STRING);\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n         }\n     @Override\n     public final void writeString(SerializableString text) throws IOException\n     {\n-        _verifyValueWrite(\"write text value\");\n+        _verifyValueWrite(WRITE_STRING);\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n         }\n         }\n         _outputBuffer[_outputTail++] = BYTE_QUOTE;\n     }\n-\n+    \n     @Override\n     public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException\n     {\n-        _verifyValueWrite(\"write text value\");\n+        _verifyValueWrite(WRITE_STRING);\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n         }\n     @Override\n     public void writeUTF8String(byte[] text, int offset, int len) throws IOException\n     {\n-        _verifyValueWrite(\"write text value\");\n+        _verifyValueWrite(WRITE_STRING);\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n         }\n     // since 2.5\n     @Override\n     public void writeRawValue(SerializableString text) throws IOException {\n-        _verifyValueWrite(\"write raw value\");\n+        _verifyValueWrite(WRITE_RAW);\n         byte[] raw = text.asUnquotedUTF8();\n         if (raw.length > 0) {\n             _writeBytes(raw);\n             byte[] data, int offset, int len)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write binary value\");\n+        _verifyValueWrite(WRITE_BINARY);\n         // Starting quotes\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n             InputStream data, int dataLength)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write binary value\");\n+        _verifyValueWrite(WRITE_BINARY);\n         // Starting quotes\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n     public void writeNumber(short s)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         // up to 5 digits and possible minus sign\n         if ((_outputTail + 6) >= _outputEnd) {\n             _flushBuffer();\n     public void writeNumber(int i)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         // up to 10 digits and possible minus sign\n         if ((_outputTail + 11) >= _outputEnd) {\n             _flushBuffer();\n     public void writeNumber(long l)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (_cfgNumbersAsStrings) {\n             _writeQuotedLong(l);\n             return;\n     public void writeNumber(BigInteger value)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (value == null) {\n             _writeNull();\n         } else if (_cfgNumbersAsStrings) {\n             return;\n         }\n         // What is the max length for doubles? 40 chars?\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         writeRaw(String.valueOf(d));\n     }\n \n             return;\n         }\n         // What is the max length for floats?\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         writeRaw(String.valueOf(f));\n     }\n \n         throws IOException, JsonGenerationException\n     {\n         // Don't really know max length for big decimal, no point checking\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (value == null) {\n             _writeNull();\n         } else if (_cfgNumbersAsStrings) {\n     public void writeNumber(String encodedValue)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (_cfgNumbersAsStrings) {\n             _writeQuotedRaw(encodedValue);            \n         } else {\n     public void writeBoolean(boolean state)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write boolean value\");\n+        _verifyValueWrite(WRITE_BOOLEAN);\n         if ((_outputTail + 5) >= _outputEnd) {\n             _flushBuffer();\n         }\n     public void writeNull()\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write null value\");\n+        _verifyValueWrite(WRITE_NULL);\n         _writeNull();\n     }\n \n      */\n \n     @Override\n-    protected final void _verifyValueWrite(String typeMsg)\n-        throws IOException, JsonGenerationException\n+    protected final void _verifyValueWrite(String typeMsg) throws IOException\n     {\n         int status = _writeContext.writeValue();\n         if (status == JsonWriteContext.STATUS_EXPECT_NAME) {\n         _verifyPrettyValueWrite(typeMsg, status);\n     }\n \n-    protected final void _verifyPrettyValueWrite(String typeMsg, int status)\n-        throws IOException, JsonGenerationException\n+    protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException\n     {\n         // If we have a pretty printer, it knows what to do:\n         switch (status) {\n      */\n \n     @Override\n-    public void flush()\n-        throws IOException\n+    public void flush() throws IOException\n     {\n         _flushBuffer();\n         if (_outputStream != null) {\n     }\n \n     @Override\n-    public void close()\n-        throws IOException\n+    public void close() throws IOException\n     {\n         super.close();\n \n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n import com.fasterxml.jackson.core.base.ParserBase;\n import com.fasterxml.jackson.core.io.CharTypes;\n import com.fasterxml.jackson.core.io.IOContext;\n-import com.fasterxml.jackson.core.sym.*;\n+import com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer;\n import com.fasterxml.jackson.core.util.*;\n \n import static com.fasterxml.jackson.core.JsonTokenId.*;\n     /**\n      * Symbol table that contains field names encountered so far\n      */\n-    final protected BytesToNameCanonicalizer _symbols;\n+    final protected ByteQuadsCanonicalizer _symbols;\n     \n     /*\n     /**********************************************************\n      */\n \n     public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in,\n-            ObjectCodec codec, BytesToNameCanonicalizer sym,\n+            ObjectCodec codec, ByteQuadsCanonicalizer sym,\n             byte[] inputBuffer, int start, int end,\n             boolean bufferRecyclable)\n     {\n      */\n \n     @Override\n-    public String getText()\n-        throws IOException, JsonParseException\n+    public String getText() throws IOException\n     {\n         if (_currToken == JsonToken.VALUE_STRING) {\n             if (_tokenIncomplete) {\n                 _tokenIncomplete = false;\n-                _finishString(); // only strings can be incomplete\n+                return _finishAndReturnString(); // only strings can be incomplete\n             }\n             return _textBuffer.contentsAsString();\n         }\n     \n     // @since 2.1\n     @Override\n-    public String getValueAsString() throws IOException, JsonParseException\n+    public String getValueAsString() throws IOException\n     {\n         if (_currToken == JsonToken.VALUE_STRING) {\n             if (_tokenIncomplete) {\n                 _tokenIncomplete = false;\n-                _finishString(); // only strings can be incomplete\n+                return _finishAndReturnString(); // only strings can be incomplete\n             }\n             return _textBuffer.contentsAsString();\n+        }\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+            return getCurrentName();\n         }\n         return super.getValueAsString(null);\n     }\n     \n     // @since 2.1\n     @Override\n-    public String getValueAsString(String defValue) throws IOException, JsonParseException\n+    public String getValueAsString(String defValue) throws IOException\n     {\n         if (_currToken == JsonToken.VALUE_STRING) {\n             if (_tokenIncomplete) {\n                 _tokenIncomplete = false;\n-                _finishString(); // only strings can be incomplete\n+                return _finishAndReturnString(); // only strings can be incomplete\n             }\n             return _textBuffer.contentsAsString();\n         }\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+            return getCurrentName();\n+        }\n         return super.getValueAsString(defValue);\n+    }\n+\n+    // since 2.6\n+    @Override\n+    public int getValueAsInt() throws IOException\n+    {\n+        JsonToken t = _currToken;\n+        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n+            // inlined 'getIntValue()'\n+            if ((_numTypesValid & NR_INT) == 0) {\n+                if (_numTypesValid == NR_UNKNOWN) {\n+                    return _parseIntValue();\n+                }\n+                if ((_numTypesValid & NR_INT) == 0) {\n+                    convertNumberToInt();\n+                }\n+            }\n+            return _numberInt;\n+        }\n+        return super.getValueAsInt(0);\n+    }\n+\n+    // since 2.6\n+    @Override\n+    public int getValueAsInt(int defValue) throws IOException\n+    {\n+        JsonToken t = _currToken;\n+        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n+            // inlined 'getIntValue()'\n+            if ((_numTypesValid & NR_INT) == 0) {\n+                if (_numTypesValid == NR_UNKNOWN) {\n+                    return _parseIntValue();\n+                }\n+                if ((_numTypesValid & NR_INT) == 0) {\n+                    convertNumberToInt();\n+                }\n+            }\n+            return _numberInt;\n+        }\n+        return super.getValueAsInt(defValue);\n     }\n     \n     protected final String _getText2(JsonToken t)\n     }\n \n     @Override\n-    public char[] getTextCharacters()\n-        throws IOException, JsonParseException\n+    public char[] getTextCharacters() throws IOException\n     {\n         if (_currToken != null) { // null only before/after document\n             switch (_currToken.id()) {\n     }\n \n     @Override\n-    public int getTextLength()\n-        throws IOException, JsonParseException\n+    public int getTextLength() throws IOException\n     {\n         if (_currToken != null) { // null only before/after document\n             switch (_currToken.id()) {\n     }\n \n     @Override\n-    public int getTextOffset() throws IOException, JsonParseException\n+    public int getTextOffset() throws IOException\n     {\n         // Most have offset of 0, only some may have other values:\n         if (_currToken != null) {\n     }\n     \n     @Override\n-    public byte[] getBinaryValue(Base64Variant b64variant)\n-        throws IOException, JsonParseException\n+    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n     {\n         if (_currToken != JsonToken.VALUE_STRING &&\n                 (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n     }\n \n     @Override\n-    public int readBinaryValue(Base64Variant b64variant, OutputStream out)\n-        throws IOException, JsonParseException\n+    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n     {\n         // if we have already read the token, just use whatever we may have\n         if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n     }\n \n     protected int _readBinary(Base64Variant b64variant, OutputStream out,\n-                              byte[] buffer)\n-        throws IOException, JsonParseException\n+                              byte[] buffer) throws IOException\n     {\n         int outputPtr = 0;\n         final int outputEnd = buffer.length - 3;\n             return _nextTokenNotInObject(i);\n         }\n         // So first parse the field name itself:\n-        Name n = _parseName(i);\n-        _parsingContext.setCurrentName(n.getName());\n+        String n = _parseName(i);\n+        _parsingContext.setCurrentName(n);\n         _currToken = JsonToken.FIELD_NAME;\n \n         i = _skipColon();\n             return null;\n         }\n \n-        Name n = _parseName(i);\n-        final String nameStr = n.getName();\n+        final String nameStr = _parseName(i);\n         _parsingContext.setCurrentName(nameStr);\n         _currToken = JsonToken.FIELD_NAME;\n \n     private final boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException\n     {\n         // // // and this is back to standard nextToken()\n-            \n-        Name n = _parseName(i);\n-        final boolean match;\n-        {\n-            String nameStr = n.getName();\n-            _parsingContext.setCurrentName(nameStr);\n-            match = nameStr.equals(str.getValue());\n-        }\n+\n+        String n = _parseName(i);\n+        _parsingContext.setCurrentName(n);\n+        final boolean match = n.equals(str.getValue());\n         _currToken = JsonToken.FIELD_NAME;\n         i = _skipColon();\n \n             if (t == JsonToken.VALUE_STRING) {\n                 if (_tokenIncomplete) {\n                     _tokenIncomplete = false;\n-                    _finishString();\n+                    return _finishAndReturnString();\n                 }\n                 return _textBuffer.contentsAsString();\n             }\n     /**********************************************************\n      */\n     \n-    protected final Name _parseName(int i) throws IOException\n+    protected final String _parseName(int i) throws IOException\n     {\n         if (i != INT_QUOTE) {\n             return _handleOddName(i);\n         }\n         // First: can we optimize out bounds checks?\n-        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n+        if ((_inputPtr + 13) > _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\n             return slowParseName();\n         }\n \n             return parseName(q, i, 1);\n         }     \n         if (q == INT_QUOTE) { // special case, \"\"\n-            return BytesToNameCanonicalizer.getEmptyName();\n+            return \"\";\n         }\n         return parseName(0, q, 0); // quoting or invalid char\n     }\n \n-    protected final Name parseMediumName(int q2) throws IOException\n+    protected final String parseMediumName(int q2) throws IOException\n     {\n         final byte[] input = _inputBuffer;\n         final int[] codes = _icLatin1;\n             }\n             return parseName(_quad1, q2, i, 4);\n         }\n-        return parseLongName(i, q2);\n-    }\n-\n-    protected final Name parseLongName(int q, final int q2) throws IOException\n+        return parseMediumName2(i, q2);\n+    }\n+\n+    /**\n+     * @since 2.6\n+     */\n+    protected final String parseMediumName2(int q3, final int q2) throws IOException\n+    {\n+        final byte[] input = _inputBuffer;\n+        final int[] codes = _icLatin1;\n+\n+        // Got 9 name bytes so far\n+        int i = input[_inputPtr++] & 0xFF;\n+        if (codes[i] != 0) {\n+            if (i == INT_QUOTE) { // 9 bytes\n+                return findName(_quad1, q2, q3, 1);\n+            }\n+            return parseName(_quad1, q2, q3, i, 1);\n+        }\n+        q3 = (q3 << 8) | i;\n+        i = input[_inputPtr++] & 0xFF;\n+        if (codes[i] != 0) {\n+            if (i == INT_QUOTE) { // 10 bytes\n+                return findName(_quad1, q2, q3, 2);\n+            }\n+            return parseName(_quad1, q2, q3, i, 2);\n+        }\n+        q3 = (q3 << 8) | i;\n+        i = input[_inputPtr++] & 0xFF;\n+        if (codes[i] != 0) {\n+            if (i == INT_QUOTE) { // 11 bytes\n+                return findName(_quad1, q2, q3, 3);\n+            }\n+            return parseName(_quad1, q2, q3, i, 3);\n+        }\n+        q3 = (q3 << 8) | i;\n+        i = input[_inputPtr++] & 0xFF;\n+        if (codes[i] != 0) {\n+            if (i == INT_QUOTE) { // 12 bytes\n+                return findName(_quad1, q2, q3, 4);\n+            }\n+            return parseName(_quad1, q2, q3, i, 4);\n+        }\n+        return parseLongName(i, q2, q3);\n+    }\n+    \n+    protected final String parseLongName(int q, final int q2, int q3) throws IOException\n     {\n         _quadBuffer[0] = _quad1;\n         _quadBuffer[1] = q2;\n+        _quadBuffer[2] = q3;\n \n         // As explained above, will ignore UTF-8 encoding at this point\n         final byte[] input = _inputBuffer;\n         final int[] codes = _icLatin1;\n-        int qlen = 2;\n+        int qlen = 3;\n \n         while ((_inputPtr + 4) <= _inputEnd) {\n             int i = input[_inputPtr++] & 0xFF;\n \n     /**\n      * Method called when not even first 8 bytes are guaranteed\n-     * to come consecutively. Happens rarely, so this is off-lined;\n+     * to come consequtively. Happens rarely, so this is offlined;\n      * plus we'll also do full checks for escaping etc.\n      */\n-    protected Name slowParseName() throws IOException\n+    protected String slowParseName() throws IOException\n     {\n         if (_inputPtr >= _inputEnd) {\n             if (!loadMore()) {\n         }\n         int i = _inputBuffer[_inputPtr++] & 0xFF;\n         if (i == INT_QUOTE) { // special case, \"\"\n-            return BytesToNameCanonicalizer.getEmptyName();\n+            return \"\";\n         }\n         return parseEscapedName(_quadBuffer, 0, 0, i, 0);\n     }\n \n-    private final Name parseName(int q1, int ch, int lastQuadBytes) throws IOException {\n+    private final String parseName(int q1, int ch, int lastQuadBytes) throws IOException {\n         return parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes);\n     }\n \n-    private final Name parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException {\n+    private final String parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException {\n         _quadBuffer[0] = q1;\n         return parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes);\n     }\n \n+    private final String parseName(int q1, int q2, int q3, int ch, int lastQuadBytes) throws IOException {\n+        _quadBuffer[0] = q1;\n+        _quadBuffer[1] = q2;\n+        return parseEscapedName(_quadBuffer, 2, q3, ch, lastQuadBytes);\n+    }\n+    \n     /**\n      * Slower parsing method which is generally branched to when\n      * an escape sequence is detected (or alternatively for long\n-     * names, or ones crossing input buffer boundary). In any case,\n-     * needs to be able to handle more exceptional cases, gets\n-     * slower, and hance is offlined to a separate method.\n-     */\n-    protected final Name parseEscapedName(int[] quads, int qlen, int currQuad, int ch,\n+     * names, one crossing input buffer boundary).\n+     * Needs to be able to handle more exceptional cases, gets slower,\n+     * and hance is offlined to a separate method.\n+     */\n+    protected final String parseEscapedName(int[] quads, int qlen, int currQuad, int ch,\n             int currQuadBytes) throws IOException\n     {\n         /* 25-Nov-2008, tatu: This may seem weird, but here we do not want to worry about\n             }\n             ch = _inputBuffer[_inputPtr++] & 0xFF;\n         }\n+\n         if (currQuadBytes > 0) {\n             if (qlen >= quads.length) {\n                 _quadBuffer = quads = growArrayBy(quads, quads.length);\n             }\n             quads[qlen++] = pad(currQuad, currQuadBytes);\n         }\n-        Name name = _symbols.findName(quads, qlen);\n+        String name = _symbols.findName(quads, qlen);\n         if (name == null) {\n             name = addName(quads, qlen, currQuadBytes);\n         }\n      * In standard mode will just throw an expection; but\n      * in non-standard modes may be able to parse name.\n      */\n-    protected Name _handleOddName(int ch) throws IOException\n+    protected String _handleOddName(int ch) throws IOException\n     {\n         // [JACKSON-173]: allow single quotes\n         if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n             }\n             quads[qlen++] = currQuad;\n         }\n-        Name name = _symbols.findName(quads, qlen);\n+        String name = _symbols.findName(quads, qlen);\n         if (name == null) {\n             name = addName(quads, qlen, currQuadBytes);\n         }\n      * for valid JSON -- more alternatives, more code, generally\n      * bit slower execution.\n      */\n-    protected Name _parseAposName() throws IOException\n+    protected String _parseAposName() throws IOException\n     {\n         if (_inputPtr >= _inputEnd) {\n             if (!loadMore()) {\n         }\n         int ch = _inputBuffer[_inputPtr++] & 0xFF;\n         if (ch == '\\'') { // special case, ''\n-            return BytesToNameCanonicalizer.getEmptyName();\n+            return \"\";\n         }\n         int[] quads = _quadBuffer;\n         int qlen = 0;\n             }\n             quads[qlen++] = pad(currQuad, currQuadBytes);\n         }\n-        Name name = _symbols.findName(quads, qlen);\n+        String name = _symbols.findName(quads, qlen);\n         if (name == null) {\n             name = addName(quads, qlen, currQuadBytes);\n         }\n     /**********************************************************\n      */\n \n-    private final Name findName(int q1, int lastQuadBytes)\n-        throws JsonParseException\n+    private final String findName(int q1, int lastQuadBytes) throws JsonParseException\n     {\n         q1 = pad(q1, lastQuadBytes);\n         // Usually we'll find it from the canonical symbol table already\n-        Name name = _symbols.findName(q1);\n+        String name = _symbols.findName(q1);\n         if (name != null) {\n             return name;\n         }\n         return addName(_quadBuffer, 1, lastQuadBytes);\n     }\n \n-    private final Name findName(int q1, int q2, int lastQuadBytes)\n-        throws JsonParseException\n+    private final String findName(int q1, int q2, int lastQuadBytes) throws JsonParseException\n     {\n         q2 = pad(q2, lastQuadBytes);\n         // Usually we'll find it from the canonical symbol table already\n-        Name name = _symbols.findName(q1, q2);\n+        String name = _symbols.findName(q1, q2);\n         if (name != null) {\n             return name;\n         }\n         return addName(_quadBuffer, 2, lastQuadBytes);\n     }\n \n-    private final Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes)\n-        throws JsonParseException\n+    private final String findName(int q1, int q2, int q3, int lastQuadBytes) throws JsonParseException\n+    {\n+        q3 = pad(q3, lastQuadBytes);\n+        String name = _symbols.findName(q1, q2, q3);\n+        if (name != null) {\n+            return name;\n+        }\n+        int[] quads = _quadBuffer;\n+        quads[0] = q1;\n+        quads[1] = q2;\n+        quads[2] = pad(q3, lastQuadBytes);\n+        return addName(quads, 3, lastQuadBytes);\n+    }\n+    \n+    private final String findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException\n     {\n         if (qlen >= quads.length) {\n             _quadBuffer = quads = growArrayBy(quads, quads.length);\n         }\n         quads[qlen++] = pad(lastQuad, lastQuadBytes);\n-        Name name = _symbols.findName(quads, qlen);\n+        String name = _symbols.findName(quads, qlen);\n         if (name == null) {\n             return addName(quads, qlen, lastQuadBytes);\n         }\n      * multi-byte chars (if any), and then construct Name instance\n      * and add it to the symbol table.\n      */\n-    private final Name addName(int[] quads, int qlen, int lastQuadBytes)\n-        throws JsonParseException\n+    private final String addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException\n     {\n         /* Ok: must decode UTF-8 chars. No other validation is\n          * needed, since unescaping has been done earlier as necessary\n         _finishString2(outBuf, outPtr);\n     }\n \n+    /**\n+     * @since 2.6\n+     */\n+    protected String _finishAndReturnString() throws IOException\n+    {\n+        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n+        int ptr = _inputPtr;\n+        if (ptr >= _inputEnd) {\n+            loadMoreGuaranteed();\n+            ptr = _inputPtr;\n+        }\n+        int outPtr = 0;\n+        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n+        final int[] codes = _icUTF8;\n+\n+        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n+        final byte[] inputBuffer = _inputBuffer;\n+        while (ptr < max) {\n+            int c = (int) inputBuffer[ptr] & 0xFF;\n+            if (codes[c] != 0) {\n+                if (c == INT_QUOTE) {\n+                    _inputPtr = ptr+1;\n+                    return _textBuffer.setCurrentAndReturn(outPtr);\n+                }\n+                break;\n+            }\n+            ++ptr;\n+            outBuf[outPtr++] = (char) c;\n+        }\n+        _inputPtr = ptr;\n+        _finishString2(outBuf, outPtr);\n+        return _textBuffer.contentsAsString();\n+    }\n+    \n     private final void _finishString2(char[] outBuf, int outPtr)\n         throws IOException\n     {\n--- a/src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java\n     @Override\n     public void writeString(String text) throws IOException\n     {\n-        _verifyValueWrite(\"write text value\");\n+        _verifyValueWrite(WRITE_STRING);\n         if (text == null) {\n             _writeNull();\n             return;\n     @Override\n     public void writeString(char[] text, int offset, int len) throws IOException\n     {\n-        _verifyValueWrite(\"write text value\");\n+        _verifyValueWrite(WRITE_STRING);\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n         }\n     @Override\n     public void writeString(SerializableString sstr) throws IOException\n     {\n-        _verifyValueWrite(\"write text value\");\n+        _verifyValueWrite(WRITE_STRING);\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n         }\n     public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write binary value\");\n+        _verifyValueWrite(WRITE_BINARY);\n         // Starting quotes\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n             InputStream data, int dataLength)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write binary value\");\n+        _verifyValueWrite(WRITE_BINARY);\n         // Starting quotes\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n     @Override\n     public void writeNumber(short s) throws IOException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (_cfgNumbersAsStrings) {\n             _writeQuotedShort(s);\n             return;\n     @Override\n     public void writeNumber(int i) throws IOException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (_cfgNumbersAsStrings) {\n             _writeQuotedInt(i);\n             return;\n     @Override\n     public void writeNumber(long l) throws IOException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (_cfgNumbersAsStrings) {\n             _writeQuotedLong(l);\n             return;\n     @Override\n     public void writeNumber(BigInteger value) throws IOException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (value == null) {\n             _writeNull();\n         } else if (_cfgNumbersAsStrings) {\n             return;\n         }\n         // What is the max length for doubles? 40 chars?\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         writeRaw(String.valueOf(d));\n     }\n \n             return;\n         }\n         // What is the max length for floats?\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         writeRaw(String.valueOf(f));\n     }\n \n     public void writeNumber(BigDecimal value) throws IOException\n     {\n         // Don't really know max length for big decimal, no point checking\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (value == null) {\n             _writeNull();\n         } else if (_cfgNumbersAsStrings) {\n     @Override\n     public void writeNumber(String encodedValue) throws IOException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (_cfgNumbersAsStrings) {\n             _writeQuotedRaw(encodedValue);            \n         } else {\n     @Override\n     public void writeBoolean(boolean state) throws IOException\n     {\n-        _verifyValueWrite(\"write boolean value\");\n+        _verifyValueWrite(WRITE_BOOLEAN);\n         if ((_outputTail + 5) >= _outputEnd) {\n             _flushBuffer();\n         }\n \n     @Override\n     public void writeNull() throws IOException {\n-        _verifyValueWrite(\"write null value\");\n+        _verifyValueWrite(WRITE_NULL);\n         _writeNull();\n     }\n \n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java\n+package com.fasterxml.jackson.core.sym;\n+\n+import java.util.Arrays;\n+import java.util.BitSet;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import com.fasterxml.jackson.core.JsonFactory;\n+import com.fasterxml.jackson.core.util.InternCache;\n+\n+/**\n+ * Replacement for <code>BytesToNameCanonicalizer</code> which aims at more localized\n+ * memory access due to flattening of name quad data.\n+ * Performance improvement modest for simple JSON document data binding (maybe 3%),\n+ * but should help more for larger symbol tables, or for binary formats like Smile.\n+ *\n+ * @since 2.6\n+ */\n+public final class ByteQuadsCanonicalizer\n+{\n+    /**\n+     * Initial size of the primary hash area. Each entry consumes 4 ints (16 bytes),\n+     * and secondary area is same as primary; so default size will use 2kB of memory_tertiaryStart\n+     * (plus 64x4 or 64x8 (256/512 bytes) for references to Strings, and Strings\n+     * themselves).\n+     */\n+    private static final int DEFAULT_T_SIZE = 64;\n+//    private static final int DEFAULT_T_SIZE = 256;\n+\n+    /**\n+     * Let's not expand symbol tables past some maximum size;\n+     * this should protected against OOMEs caused by large documents\n+     * with unique (~= random) names.\n+     * Size is in \n+     */\n+    private static final int MAX_T_SIZE = 0x10000; // 64k entries == 2M mem hash area\n+\n+    /**\n+     * No point in trying to construct tiny tables, just need to resize soon.\n+     */\n+    final static int MIN_HASH_SIZE = 16;\n+    \n+    /**\n+     * Let's only share reasonably sized symbol tables. Max size set to 3/4 of 8k;\n+     * this corresponds to 256k main hash index. This should allow for enough distinct\n+     * names for almost any case, while preventing ballooning for cases where names\n+     * are unique (or close thereof).\n+     */\n+    final static int MAX_ENTRIES_FOR_REUSE = 6000;\n+\n+    /*\n+    /**********************************************************\n+    /* Linkage, needed for merging symbol tables\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Reference to the root symbol table, for child tables, so\n+     * that they can merge table information back as necessary.\n+     */\n+    final protected ByteQuadsCanonicalizer _parent;\n+\n+    /**\n+     * Member that is only used by the root table instance: root\n+     * passes immutable state into child instances, and children\n+     * may return new state if they add entries to the table.\n+     * Child tables do NOT use the reference.\n+     */\n+    final protected AtomicReference<TableInfo> _tableInfo;\n+    \n+    /**\n+     * Seed value we use as the base to make hash codes non-static between\n+     * different runs, but still stable for lifetime of a single symbol table\n+     * instance.\n+     * This is done for security reasons, to avoid potential DoS attack via\n+     * hash collisions.\n+     */\n+    final private int _seed;\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Whether canonical symbol Strings are to be intern()ed before added\n+     * to the table or not.\n+     *<p>\n+     * NOTE: non-final to allow disabling intern()ing in case of excessive\n+     * collisions.\n+     */\n+    protected boolean _intern;\n+\n+    /**\n+     * Flag that indicates whether we should throw an exception if enough \n+     * hash collisions are detected (true); or just worked around (false).\n+     * \n+     * @since 2.4\n+     */\n+    protected final boolean _failOnDoS;\n+    \n+    /*\n+    /**********************************************************\n+    /* First, main hash area info\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Primary hash information area: consists of <code>2 * _hashSize</code>\n+     * entries of 16 bytes (4 ints), arranged in a cascading lookup\n+     * structure (details of which may be tweaked depending on expected rates\n+     * of collisions).\n+     */\n+    protected int[] _hashArea;\n+\n+    /**\n+     * Number of slots for primary entries within {@link #_hashArea}; which is\n+     * at most <code>1/8</code> of actual size of the underlying array (4-int slots,\n+     * primary covers only half of the area; plus, additional area for longer\n+     * symbols after hash area).\n+     */\n+    protected int _hashSize;\n+\n+    /**\n+     * Offset within {@link #_hashArea} where secondary entries start\n+     */\n+    protected int _secondaryStart;\n+\n+    /**\n+     * Offset within {@link #_hashArea} where tertiary entries start\n+     */\n+    protected int _tertiaryStart;\n+    \n+    /**\n+     * Constant that determines size of buckets for tertiary entries:\n+     * <code>1 << _tertiaryShift</code> is the size, and shift value\n+     * is also used for translating from primary offset into\n+     * tertiary bucket (shift right by <code>4 + _tertiaryShift</code>).\n+     *<p>\n+     * Default value is 2, for buckets of 4 slots; grows bigger with\n+     * bigger table sizes.\n+     */\n+    protected int _tertiaryShift;\n+\n+    /**\n+     * Total number of Strings in the symbol table; only used for child tables.\n+     */\n+    protected int _count;\n+\n+    /**\n+     * Array that contains <code>String</code> instances matching\n+     * entries in {@link #_hashArea}.\n+     * Contains nulls for unused entries. Note that this size is twice\n+     * that o\n+     */\n+    protected String[] _names;\n+\n+    /*\n+    /**********************************************************\n+    /* Then information on collisions etc\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Pointer to the offset within spill-over area where there is room\n+     * for more spilled over entries (if any).\n+     * Spill over area is within fixed-size portion of {@link #_hashArea}.\n+     */\n+    protected int _spilloverEnd;\n+\n+    /**\n+     * Offset within {@link #_hashArea} that follows main slots and contains\n+     * quads for longer names (13 bytes or longers), and points to the\n+     * first available int that may be used for appending quads of the next\n+     * long name.\n+     * Note that long name area follows immediately after the fixed-size\n+     * main hash area ({@link #_hashArea}).\n+     */\n+    protected int _longNameOffset;\n+\n+    /**\n+     * This flag is set if, after adding a new entry, it is deemed\n+     * that a rehash is warranted if any more entries are to be added.\n+     */\n+    private transient boolean _needRehash;\n+\n+    /*\n+    /**********************************************************\n+    /* Sharing, versioning\n+    /**********************************************************\n+     */\n+\n+    // // // Which of the buffers may be shared (and are copy-on-write)?\n+\n+    /**\n+     * Flag that indicates whether underlying data structures for\n+     * the main hash area are shared or not. If they are, then they\n+     * need to be handled in copy-on-write way, i.e. if they need\n+     * to be modified, a copy needs to be made first; at this point\n+     * it will not be shared any more, and can be modified.\n+     *<p>\n+     * This flag needs to be checked both when adding new main entries,\n+     * and when adding new collision list queues (i.e. creating a new\n+     * collision list head entry)\n+     */\n+    private boolean _hashShared;\n+\n+    /*\n+    /**********************************************************\n+    /* Bit of DoS detection goodness\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Lazily constructed structure that is used to keep track of\n+     * collision buckets that have overflowed once: this is used\n+     * to detect likely attempts at denial-of-service attacks that\n+     * uses hash collisions.\n+     * \n+     * @since 2.4\n+     */\n+    protected BitSet _overflows;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle: constructors\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Constructor used for creating per-<code>JsonFactory</code> \"root\"\n+     * symbol tables: ones used for merging and sharing common symbols\n+     * \n+     * @param sz Initial primary hash area size\n+     * @param intern Whether Strings contained should be {@link String#intern}ed\n+     * @param seed Random seed valued used to make it more difficult to cause\n+     *   collisions (used for collision-based DoS attacks).\n+     */\n+    private ByteQuadsCanonicalizer(int sz, boolean intern, int seed, boolean failOnDoS) {\n+        _parent = null;\n+        _seed = seed;\n+        _intern = intern;\n+        _failOnDoS = failOnDoS;\n+        // Sanity check: let's now allow hash sizes below certain minimum value\n+        if (sz < MIN_HASH_SIZE) {\n+            sz = MIN_HASH_SIZE;\n+        } else {\n+            // Also; size must be 2^N; otherwise hash algorithm won't\n+            // work... so let's just pad it up, if so\n+            if ((sz & (sz - 1)) != 0) { // only true if it's 2^N\n+                int curr = MIN_HASH_SIZE;\n+                while (curr < sz) {\n+                    curr += curr;\n+                }\n+                sz = curr;\n+            }\n+        }\n+        _tableInfo = new AtomicReference<TableInfo>(TableInfo.createInitial(sz));\n+    }\n+\n+    /**\n+     * Constructor used when creating a child instance\n+     */\n+    private ByteQuadsCanonicalizer(ByteQuadsCanonicalizer parent, boolean intern,\n+            int seed, boolean failOnDoS, TableInfo state)\n+    {\n+        _parent = parent;\n+        _seed = seed;\n+        _intern = intern;\n+        _failOnDoS = failOnDoS;\n+        _tableInfo = null; // not used by child tables\n+\n+        // Then copy shared state\n+        _count = state.count;\n+        _hashSize = state.size;\n+        _secondaryStart = _hashSize << 2; // right after primary area\n+        _tertiaryStart = _secondaryStart + (_secondaryStart >> 1); // right after secondary\n+        _tertiaryShift = state.tertiaryShift;\n+        \n+        _hashArea = state.mainHash;\n+        _names = state.names;\n+\n+        _spilloverEnd = state.spilloverEnd;\n+        _longNameOffset = state.longNameOffset;\n+        \n+        // and then set other state to reflect sharing status\n+        _needRehash = false;\n+        _hashShared = true;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle: factory methods, merging\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Factory method to call to create a symbol table instance with a\n+     * randomized seed value.\n+     */\n+    public static ByteQuadsCanonicalizer createRoot() {\n+        /* [Issue-21]: Need to use a variable seed, to thwart hash-collision\n+         * based attacks.\n+         */\n+        long now = System.currentTimeMillis();\n+        // ensure it's not 0; and might as well require to be odd so:\n+        int seed = (((int) now) + ((int) (now >>> 32))) | 1;\n+        return createRoot(seed);\n+    }\n+\n+    /**\n+     * Factory method that should only be called from unit tests, where seed\n+     * value should remain the same.\n+     */\n+    protected static ByteQuadsCanonicalizer createRoot(int seed) {\n+        return new ByteQuadsCanonicalizer(DEFAULT_T_SIZE, true, seed, true);\n+    }\n+    \n+    /**\n+     * Factory method used to create actual symbol table instance to\n+     * use for parsing.\n+     */\n+    public ByteQuadsCanonicalizer makeChild(int flags) {\n+        return new ByteQuadsCanonicalizer(this,\n+                JsonFactory.Feature.INTERN_FIELD_NAMES.enabledIn(flags),\n+                _seed,\n+                JsonFactory.Feature.FAIL_ON_SYMBOL_HASH_OVERFLOW.enabledIn(flags),\n+                _tableInfo.get());\n+    }\n+\n+    /**\n+     * Method called by the using code to indicate it is done\n+     * with this instance. This lets instance merge accumulated\n+     * changes into parent (if need be), safely and efficiently,\n+     * and without calling code having to know about parent\n+     * information\n+     */\n+    public void release()\n+    {\n+        // we will try to merge if child table has new entries\n+        if (_parent != null && maybeDirty()) {\n+            _parent.mergeChild(new TableInfo(this));\n+            /* Let's also mark this instance as dirty, so that just in\n+             * case release was too early, there's no corruption of possibly shared data.\n+             */\n+            _hashShared = true;\n+        }\n+    }\n+\n+    private void mergeChild(TableInfo childState)\n+    {\n+        final int childCount = childState.count;\n+        TableInfo currState = _tableInfo.get();\n+\n+        // Should usually grow; but occasionally could also shrink if (but only if)\n+        // collision list overflow ends up clearing some collision lists.\n+        if (childCount == currState.count) {\n+            return;\n+        }\n+\n+        // One caveat: let's try to avoid problems with degenerate cases of documents with\n+        // generated \"random\" names: for these, symbol tables would bloat indefinitely.\n+        // One way to do this is to just purge tables if they grow\n+        // too large, and that's what we'll do here.\n+        if (childCount > MAX_ENTRIES_FOR_REUSE) {\n+            // At any rate, need to clean up the tables\n+            childState = TableInfo.createInitial(DEFAULT_T_SIZE);\n+        }\n+        _tableInfo.compareAndSet(currState, childState);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* API, accessors\n+    /**********************************************************\n+     */\n+\n+    public int size()\n+    {\n+        if (_tableInfo != null) { // root table\n+            return _tableInfo.get().count;\n+        }\n+        // nope, child table\n+        return _count;\n+    }\n+\n+    /**\n+     * Returns number of primary slots table has currently\n+     */\n+    public int bucketCount() { return _hashSize; }\n+\n+    /**\n+     * Method called to check to quickly see if a child symbol table\n+     * may have gotten additional entries. Used for checking to see\n+     * if a child table should be merged into shared table.\n+     */\n+    public boolean maybeDirty() { return !_hashShared; }\n+\n+    public int hashSeed() { return _seed; }\n+    \n+    /**\n+     * Method mostly needed by unit tests; calculates number of\n+     * entries that are in the primary slot set. These are\n+     * \"perfect\" entries, accessible with a single lookup\n+     */\n+    public int primaryCount()\n+    {\n+        int count = 0;\n+        for (int offset = 3, end = _secondaryStart; offset < end; offset += 4) {\n+            if (_hashArea[offset] != 0) {\n+                ++count;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Method mostly needed by unit tests; calculates number of entries\n+     * in secondary buckets\n+     */\n+    public int secondaryCount() {\n+        int count = 0;\n+        int offset = _secondaryStart + 3;\n+        for (int end = _tertiaryStart; offset < end; offset += 4) {\n+            if (_hashArea[offset] != 0) {\n+                ++count;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Method mostly needed by unit tests; calculates number of entries\n+     * in tertiary buckets\n+     */\n+    public int tertiaryCount() {\n+        int count = 0;\n+        int offset = _tertiaryStart + 3; // to 1.5x, starting point of tertiary\n+        for (int end = offset + _hashSize; offset < end; offset += 4) {\n+            if (_hashArea[offset] != 0) {\n+                ++count;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Method mostly needed by unit tests; calculates number of entries\n+     * in shared spillover area\n+     */\n+    public int spilloverCount() {\n+        // difference between spillover end, start, divided by 4 (four ints per slot)\n+        return (_spilloverEnd - _spilloverStart()) >> 2;\n+    }\n+\n+    public int totalCount()\n+    {\n+        int count = 0;\n+        for (int offset = 3, end = (_hashSize << 3); offset < end; offset += 4) {\n+            if (_hashArea[offset] != 0) {\n+                ++count;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        int pri = primaryCount();\n+        int sec = secondaryCount();\n+        int tert = tertiaryCount();\n+        int spill = spilloverCount();\n+        int total = totalCount();\n+        return String.format(\"[%s: size=%d, hashSize=%d, %d/%d/%d/%d pri/sec/ter/spill (=%s), total:%d]\",\n+                getClass().getName(), _count, _hashSize,\n+                pri, sec, tert, spill, total, (pri+sec+tert+spill), total);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, accessing symbols\n+    /**********************************************************\n+     */\n+\n+    public String findName(int q1)\n+    {\n+        int offset = _calcOffset(calcHash(q1));\n+        // first: primary match?\n+        final int[] hashArea = _hashArea;\n+\n+        int len = hashArea[offset+3];\n+\n+        if (len == 1) {\n+            if (hashArea[offset] == q1) {\n+                return _names[offset >> 2];\n+            }\n+        } else if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n+            return null;\n+        }\n+        // secondary? single slot shared by N/2 primaries\n+        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n+\n+        len = hashArea[offset2+3];\n+\n+        if (len == 1) {\n+            if (hashArea[offset2] == q1) {\n+                return _names[offset2 >> 2];\n+            }\n+        } else if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n+            return null;\n+        }\n+\n+        // tertiary lookup & spillovers best to offline\n+        return _findSecondary(offset, q1);\n+    }\n+\n+    public String findName(int q1, int q2)\n+    {\n+        int offset = _calcOffset(calcHash(q1, q2));\n+\n+        final int[] hashArea = _hashArea;\n+\n+        int len = hashArea[offset+3];\n+\n+        if (len == 2) {\n+            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1])) {\n+                return _names[offset >> 2];\n+            }\n+        } else if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n+            return null;\n+        }\n+        // secondary?\n+        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n+\n+        len = hashArea[offset2+3];\n+\n+        if (len == 2) {\n+            if ((q1 == hashArea[offset2]) && (q2 == hashArea[offset2+1])) {\n+                return _names[offset2 >> 2];\n+            }\n+        } else if (len == 0) { // empty slot? Short-circuit if no more spillovers\n+            return null;\n+        }\n+        return _findSecondary(offset, q1, q2);\n+    }\n+\n+    public String findName(int q1, int q2, int q3)\n+    {\n+        int offset = _calcOffset(calcHash(q1, q2, q3));\n+        final int[] hashArea = _hashArea;\n+        int len = hashArea[offset+3];\n+\n+        if (len == 3) {\n+            if ((q1 == hashArea[offset]) && (hashArea[offset+1] == q2) && (hashArea[offset+2] == q3)) {\n+                return _names[offset >> 2];\n+            }\n+        } else if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n+            return null;\n+        }\n+        // secondary?\n+        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n+\n+        len = hashArea[offset2+3];\n+\n+        if (len == 3) {\n+            if ((q1 == hashArea[offset2]) && (hashArea[offset2+1] == q2) && (hashArea[offset2+2] == q3)) {\n+                return _names[offset2 >> 2];\n+            }\n+        } else if (len == 0) { // empty slot? Short-circuit if no more spillovers\n+            return null;\n+        }\n+        return _findSecondary(offset, q1, q2, q3);\n+    }\n+\n+    public String findName(int[] q, int qlen)\n+    {\n+        /* This version differs significantly, because longer names do not fit within cell.\n+         * Rather, they contain hash in main slot, and offset+length to extension area\n+         * that contains actual quads.\n+         */\n+        if (qlen < 4) { // another sanity check\n+            if (qlen == 3) {\n+                return findName(q[0], q[1], q[2]);\n+            }\n+            if (qlen == 2) {\n+                return findName(q[0], q[1]);\n+            }\n+            return findName(q[0]);\n+        }\n+        final int hash = calcHash(q, qlen);\n+        int offset = _calcOffset(hash);\n+\n+        final int[] hashArea = _hashArea;\n+\n+        final int len = hashArea[offset+3];\n+        \n+        if ((hash == hashArea[offset]) && (len == qlen)) {\n+            // probable but not guaranteed: verify\n+            if (_verifyLongName(q, qlen, hashArea[offset+1])) {\n+                return _names[offset >> 2];\n+            }\n+        }\n+        if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n+            return null;\n+        }\n+        // secondary?\n+        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n+\n+        final int len2 = hashArea[offset2+3];\n+        if ((hash == hashArea[offset2]) && (len2 == qlen)) {\n+            if (_verifyLongName(q, qlen, hashArea[offset2+1])) {\n+                return _names[offset2 >> 2];\n+            }\n+        }\n+        if (len == 0) { // empty slot? Short-circuit if no more spillovers\n+            return null;\n+        }\n+        return _findSecondary(offset, hash, q, qlen);\n+    }\n+    \n+    private final int _calcOffset(int hash)\n+    {\n+        // NOTE: simple for initial impl, but we may want to interleave it a bit\n+        // in near future\n+        // So: first, hash into primary hash index\n+        int ix = hash & (_hashSize-1);\n+        // keeping in mind we have 4 ints per entry\n+        return (ix << 2);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Access from spill-over areas\n+    /**********************************************************\n+     */\n+\n+    private String _findSecondary(int origOffset, int q1)\n+    {\n+        // tertiary area division is dynamic. First; its size is N/4 compared to\n+        // primary hash size; and offsets are for 4 int slots. So to get to logical\n+        // index would shift by 4. But! Tertiary area is further split into buckets,\n+        // determined by shift value. And finally, from bucket back into physical offsets\n+        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift);\n+        final int[] hashArea = _hashArea;\n+        final int bucketSize = (1 << _tertiaryShift);\n+        for (int end = offset + bucketSize; offset < end; offset += 4) {\n+            int len = hashArea[offset+3];\n+            if ((q1 == hashArea[offset]) && (1 == len)) {\n+                return _names[offset >> 2];\n+            }\n+            if (len == 0) {\n+                return null;\n+            }\n+        }\n+        // but if tertiary full, check out spill-over area as last resort\n+        // shared spillover starts at 7/8 of the main hash area\n+        // (which is sized at 2 * _hashSize), so:\n+        for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n+            if ((q1 == hashArea[offset]) && (1 == hashArea[offset+3])) {\n+                return _names[offset >> 2];\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private String _findSecondary(int origOffset, int q1, int q2)\n+    {\n+        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift);\n+        final int[] hashArea = _hashArea;\n+\n+        final int bucketSize = (1 << _tertiaryShift);\n+        for (int end = offset + bucketSize; offset < end; offset += 4) {\n+            int len = hashArea[offset+3];\n+            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (2 == len)) {\n+                return _names[offset >> 2];\n+            }\n+            if (len == 0) {\n+                return null;\n+            }\n+        }\n+        for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n+            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (2 == hashArea[offset+3])) {\n+                return _names[offset >> 2];\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private String _findSecondary(int origOffset, int q1, int q2, int q3)\n+    {\n+        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift);\n+        final int[] hashArea = _hashArea;\n+\n+        final int bucketSize = (1 << _tertiaryShift);\n+        for (int end = offset + bucketSize; offset < end; offset += 4) {\n+            int len = hashArea[offset+3];\n+            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (q3 == hashArea[offset+2]) && (3 == len)) {\n+                return _names[offset >> 2];\n+            }\n+            if (len == 0) {\n+                return null;\n+            }\n+        }\n+        for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n+            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (q3 == hashArea[offset+2])\n+                    && (3 == hashArea[offset+3])) {\n+                return _names[offset >> 2];\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private String _findSecondary(int origOffset, int hash, int[] q, int qlen)\n+    {\n+        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift);\n+        final int[] hashArea = _hashArea;\n+\n+        final int bucketSize = (1 << _tertiaryShift);\n+        for (int end = offset + bucketSize; offset < end; offset += 4) {\n+            int len = hashArea[offset+3];\n+            if ((hash == hashArea[offset]) && (qlen == len)) {\n+                return _names[offset >> 2];\n+            }\n+            if (len == 0) {\n+                return null;\n+            }\n+        }\n+        for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n+            if ((hash == hashArea[offset]) && (qlen == hashArea[offset+3])) {\n+                if (_verifyLongName(q, qlen, hashArea[offset+1])) {\n+                    return _names[offset >> 2];\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    private boolean _verifyLongName(int[] q, int qlen, int spillOffset)\n+    {\n+        final int[] hashArea = _hashArea;\n+        // spillOffset assumed to be physical index right into quad string\n+        int ix = 0;\n+\n+        switch (qlen) {\n+        default:\n+            return _verifyLongName2(q, qlen, spillOffset);\n+        case 8:\n+            if (q[ix++] != hashArea[spillOffset++]) return false;\n+        case 7:\n+            if (q[ix++] != hashArea[spillOffset++]) return false;\n+        case 6:\n+            if (q[ix++] != hashArea[spillOffset++]) return false;\n+        case 5:\n+            if (q[ix++] != hashArea[spillOffset++]) return false;\n+        case 4: // always at least 4\n+            if (q[ix++] != hashArea[spillOffset++]) return false;\n+            if (q[ix++] != hashArea[spillOffset++]) return false;\n+            if (q[ix++] != hashArea[spillOffset++]) return false;\n+            if (q[ix++] != hashArea[spillOffset++]) return false;\n+        }\n+        return true;\n+    }\n+\n+    private boolean _verifyLongName2(int[] q, int qlen, int spillOffset)\n+    {\n+        int ix = 0;\n+        do {\n+            if (q[ix++] != _hashArea[spillOffset++]) {\n+                return false;\n+            }\n+        } while (ix < qlen);\n+        return true;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* API, mutators\n+    /**********************************************************\n+     */\n+\n+    public String addName(String name, int q1) {\n+        _verifySharing();\n+        if (_intern) {\n+            name = InternCache.instance.intern(name);\n+        }\n+        int offset = _findOffsetForAdd(calcHash(q1));\n+        _hashArea[offset] = q1;\n+        _hashArea[offset+3] = 1;\n+        _names[offset >> 2] = name;\n+        ++_count;\n+        _verifyNeedForRehash();\n+        return name;\n+    }\n+\n+    public String addName(String name, int q1, int q2) {\n+        _verifySharing();\n+        if (_intern) {\n+            name = InternCache.instance.intern(name);\n+        }\n+        int hash = (q2 == 0) ? calcHash(q1) : calcHash(q1, q2);\n+        int offset = _findOffsetForAdd(hash);\n+        _hashArea[offset] = q1;\n+        _hashArea[offset+1] = q2;\n+        _hashArea[offset+3] = 2;\n+        _names[offset >> 2] = name;\n+        ++_count;\n+        _verifyNeedForRehash();\n+        return name;\n+    }\n+\n+    public String addName(String name, int q1, int q2, int q3) {\n+        _verifySharing();\n+        if (_intern) {\n+            name = InternCache.instance.intern(name);\n+        }\n+        int offset = _findOffsetForAdd(calcHash(q1, q2, q3));\n+        _hashArea[offset] = q1;\n+        _hashArea[offset+1] = q2;\n+        _hashArea[offset+2] = q3;\n+        _hashArea[offset+3] = 3;\n+        _names[offset >> 2] = name;\n+        ++_count;\n+        _verifyNeedForRehash();\n+        return name;\n+    }\n+\n+    public String addName(String name, int[] q, int qlen)\n+    {\n+        _verifySharing();\n+        if (_intern) {\n+            name = InternCache.instance.intern(name);\n+        }\n+        int offset;\n+        \n+        switch (qlen) {\n+        case 1:\n+        {\n+                offset = _findOffsetForAdd(calcHash(q[0]));\n+                _hashArea[offset] = q[0];\n+                _hashArea[offset+3] = 1;\n+            }\n+            break;\n+        case 2:\n+            {\n+                offset = _findOffsetForAdd(calcHash(q[0], q[1]));\n+                _hashArea[offset] = q[0];\n+                _hashArea[offset+1] = q[1];\n+                _hashArea[offset+3] = 2;\n+            }\n+            break;\n+        case 3:\n+            {\n+                offset = _findOffsetForAdd(calcHash(q[0], q[1], q[2]));\n+                _hashArea[offset] = q[0];\n+                _hashArea[offset+1] = q[1];\n+                _hashArea[offset+2] = q[2];\n+                _hashArea[offset+3] = 3;\n+            }\n+            break;\n+        default:\n+            final int hash = calcHash(q, qlen);\n+            offset = _findOffsetForAdd(hash);\n+\n+            _hashArea[offset] = hash;\n+            int longStart = _appendLongName(q, qlen);\n+            _hashArea[offset+1] = longStart;\n+            _hashArea[offset+3] = qlen;\n+        }\n+        // plus add the actual String\n+        _names[offset >> 2] = name;\n+\n+        // and finally; see if we really should rehash.\n+        ++_count;\n+        _verifyNeedForRehash();\n+        return name;\n+    }\n+    \n+    private void _verifyNeedForRehash() {\n+        // Yes if above 80%, or above 50% AND have ~1% spill-overs\n+        if (_count > (_hashSize >> 1)) { // over 50%\n+            int spillCount = (_spilloverEnd - _spilloverStart()) >> 2;\n+            \n+            if ((spillCount > (1 + _count >> 7))\n+                    || (_count > (_hashSize * 0.80))) {\n+                _needRehash = true;\n+            }\n+        }\n+    }\n+\n+    private void _verifySharing()\n+    {\n+        if (_hashShared) {\n+            _hashArea = Arrays.copyOf(_hashArea, _hashArea.length);\n+            _names = Arrays.copyOf(_names, _names.length);\n+            _hashShared = false;\n+        }\n+        if (_needRehash) {\n+            rehash();\n+        }\n+    }\n+    \n+    /**\n+     * Method called to find the location within hash table to add a new symbol in.\n+     */\n+    private int _findOffsetForAdd(int hash)\n+    {\n+        // first, check the primary:\n+        int offset = _calcOffset(hash);\n+        final int[] hashArea = _hashArea;\n+        if (hashArea[offset+3] == 0) {\n+            return offset;\n+        }\n+        // then secondary\n+        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n+        if (hashArea[offset2+3] == 0) {\n+            return offset2;\n+        }\n+        // if not, tertiary?\n+\n+        offset2 = _tertiaryStart + ((offset >> (_tertiaryShift + 2)) << _tertiaryShift);\n+        final int bucketSize = (1 << _tertiaryShift);\n+        for (int end = offset2 + bucketSize; offset2 < end; offset2 += 4) {\n+            if (hashArea[offset2+3] == 0) {\n+                return offset2;\n+            }\n+        }\n+\n+        // and if even tertiary full, append at the end of spill area\n+        offset = _spilloverEnd;\n+        _spilloverEnd += 4;\n+\n+        // one caveat: in the unlikely event if spill-over filling up,\n+        // check if that could be considered a DoS attack; handle appropriately\n+        // (NOTE: approximate for now; we could verify details if that becomes necessary)\n+        if (_spilloverEnd >= hashArea.length) {\n+            if (_failOnDoS) {\n+                _reportTooManyCollisions();\n+            }\n+            // and if we didn't fail, we'll simply force rehash for next add\n+            // (which, in turn, may double up or nuke contents, depending on size etc)\n+            _needRehash = true;\n+        }\n+        return offset;\n+    }\n+\n+    private int _appendLongName(int[] quads, int qlen)\n+    {\n+        int start = _longNameOffset;\n+        \n+        // note: at this point we must already be shared. But may not have enough space\n+        if ((start + qlen) > _hashArea.length) {\n+            // try to increment in reasonable chunks; at least space that we need\n+            int toAdd = (start + qlen) - _hashArea.length;\n+            // but at least 1/8 of regular hash area size or 16kB (whichever smaller)\n+            int minAdd = Math.min(4096, _hashSize);\n+\n+            int newSize = _hashArea.length + Math.max(toAdd, minAdd);\n+            _hashArea = Arrays.copyOf(_hashArea, newSize);\n+        }\n+        System.arraycopy(quads, 0, _hashArea, start, qlen);\n+        _longNameOffset += qlen;\n+        return start;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Hash calculation\n+    /**********************************************************\n+     */\n+\n+    /* Note on hash calculation: we try to make it more difficult to\n+     * generate collisions automatically; part of this is to avoid\n+     * simple \"multiply-add\" algorithm (like JDK String.hashCode()),\n+     * and add bit of shifting. And other part is to make this\n+     * non-linear, at least for shorter symbols.\n+     */\n+    \n+    // JDK uses 31; other fine choices are 33 and 65599, let's use 33\n+    // as it seems to give fewest collisions for us\n+    // (see [http://www.cse.yorku.ca/~oz/hash.html] for details)\n+    private final static int MULT = 33;\n+    private final static int MULT2 = 65599;\n+    private final static int MULT3 = 31;\n+    \n+    public int calcHash(int q1)\n+    {\n+        int hash = q1 ^ _seed;\n+        /* 29-Mar-2015, tatu: Earlier used 15 + 9 right shifts, which worked ok\n+         *    except for one specific problem case: numbers. So needed to make sure\n+         *    that all 4 least-significant bits participate in hash. Couple of ways\n+         *    to work it out, but this is the simplest, fast and seems to do ok.\n+         */\n+        hash += (hash >>> 16); // to xor hi- and low- 16-bits\n+        hash ^= (hash >>> 12); // as well as lowest 2 bytes\n+        return hash;\n+    }\n+\n+    public int calcHash(int q1, int q2)\n+    {\n+        // For two quads, let's change algorithm a bit, to spice\n+        // things up (can do bit more processing anyway)\n+        int hash = q1;\n+\n+        hash += (hash >>> 15); // try mixing first and second byte pairs first\n+        hash ^= (hash >>> 9); // as well as lowest 2 bytes\n+        hash += (q2 * MULT); // then add second quad\n+        hash ^= _seed;\n+        hash += (hash >>> 16); // and shuffle some more\n+        hash ^= (hash >>> 4);\n+        hash += (hash << 3);\n+        \n+        return hash;\n+    }\n+\n+    public int calcHash(int q1, int q2, int q3)\n+    { // use same algorithm as multi-byte, tested to work well\n+        int hash = q1 ^ _seed;\n+        hash += (hash >>> 9);\n+        hash *= MULT3;\n+        hash += q2;\n+        hash *= MULT;\n+        hash += (hash >>> 15);\n+        hash ^= q3;\n+        // 26-Mar-2015, tatu: As per two-quad case, a short shift seems to help more here\n+        hash += (hash >>> 4);\n+\n+        hash += (hash >>> 15);\n+        hash ^= (hash << 9);\n+\n+        return hash;\n+    }\n+\n+    public int calcHash(int[] q, int qlen)\n+    {\n+        if (qlen < 4) {\n+            throw new IllegalArgumentException();\n+        }\n+        /* And then change handling again for \"multi-quad\" case; mostly\n+         * to make calculation of collisions less fun. For example,\n+         * add seed bit later in the game, and switch plus/xor around,\n+         * use different shift lengths.\n+         */\n+        int hash = q[0] ^ _seed;\n+        hash += (hash >>> 9);\n+        hash += q[1];\n+        hash += (hash >>> 15);\n+        hash *= MULT;\n+        hash ^= q[2];\n+        hash += (hash >>> 4);\n+\n+        for (int i = 3; i < qlen; ++i) {\n+            int next = q[i];\n+            next = next ^ (next >> 21);\n+            hash += next;\n+        }\n+        hash *= MULT2;\n+        \n+        // and finally shuffle some more once done\n+        hash += (hash >>> 19);\n+        hash ^= (hash << 5);\n+        return hash;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Rehashing\n+    /**********************************************************\n+     */\n+\n+    private void rehash()\n+    {\n+        _needRehash = false;\n+        // Note: since we'll make copies, no need to unshare, can just mark as such:\n+        _hashShared = false;\n+\n+        // And then we can first deal with the main hash area. Since we are expanding\n+        // linearly (double up), we know there'll be no collisions during this phase.\n+        final int[] oldHashArea = _hashArea;\n+        final String[] oldNames = _names;\n+        final int oldSize = _hashSize;\n+        final int oldCount = _count;\n+        final int newSize = oldSize + oldSize;\n+        final int oldEnd = _spilloverEnd;\n+\n+        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n+         *    large documents with unique (or mostly so) names\n+         */\n+        if (newSize > MAX_T_SIZE) {\n+            nukeSymbols(true);\n+            return;\n+        }\n+        // double up main hash area, but do not expand long-name area:\n+        _hashArea = new int[oldHashArea.length + (oldSize<<3)];\n+        _hashSize = newSize;\n+        _secondaryStart = (newSize << 2); // 4 ints per entry\n+        _tertiaryStart = _secondaryStart + (_secondaryStart >> 1); // right after secondary\n+        _tertiaryShift = _calcTertiaryShift(newSize);\n+        \n+        // and simply double up name array\n+        _names = new String[oldNames.length << 1];\n+        nukeSymbols(false);\n+\n+        // Plus we can scan only through the primary hash area, looking for non-empty\n+        // slots, without worrying about ordering. This should never reduce priority\n+        // of existing entries: primaries remain primaries; however, due to increased\n+        // space, secondaries may become primaries etc\n+\n+        int copyCount = 0;\n+        int[] q = new int[16];\n+        for (int offset = 0, end = oldEnd; offset < end; offset += 4) {\n+            int len = oldHashArea[offset+3];\n+            if (len == 0) { // empty slot, skip\n+                continue;\n+            }\n+            ++copyCount;\n+            String name = oldNames[offset>>2];\n+            switch (len) {\n+            case 1:\n+                q[0] = oldHashArea[offset];\n+                addName(name, q, 1);\n+                break;\n+            case 2:\n+                q[0] = oldHashArea[offset];\n+                q[1] = oldHashArea[offset+1];\n+                addName(name, q, 2);\n+                break;\n+            case 3:\n+                q[0] = oldHashArea[offset];\n+                q[1] = oldHashArea[offset+1];\n+                q[2] = oldHashArea[offset+2];\n+                addName(name, q, 3);\n+                break;\n+            default:\n+                if (len > q.length) {\n+                    q = new int[len];\n+                }\n+                // #0 is hash, #1 offset\n+                int qoff = oldHashArea[offset+1];\n+                System.arraycopy(oldHashArea, qoff, q, 0, len);\n+                addName(name, q, len);\n+                break;\n+            }\n+        }\n+\n+        // Sanity checks: since corruption difficult to detect, assert explicitly\n+        // with production code\n+        if (copyCount != oldCount) {\n+            throw new IllegalStateException(\"Failed rehash(): old count=\"+oldCount+\", copyCount=\"+copyCount);\n+        }\n+    }\n+\n+    /**\n+     * Helper method called to empty all shared symbols, but to leave\n+     * arrays allocated\n+     */\n+    private void nukeSymbols(boolean fill) {\n+        _count = 0;\n+        // reset spill-over to empty (starting at 7/8 of hash area)\n+        _spilloverEnd = _spilloverStart();\n+        // and long name area to empty, starting immediately after hash area\n+        _longNameOffset = _hashSize << 3;\n+        if (fill) {\n+            Arrays.fill(_hashArea, 0);\n+            Arrays.fill(_names, null);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Helper method that calculates start of the spillover area\n+     */\n+    private final int _spilloverStart() {\n+        // we'll need slot at 1.75x of hashSize, but with 4-ints per slot.\n+        // So basically multiply by 7\n+        int offset = _hashSize;\n+        return (offset << 3) - offset;\n+    }\n+\n+    protected void _reportTooManyCollisions()\n+    {\n+        // First: do not fuzz about small symbol tables; may get balanced by doubling up\n+        if (_hashSize <= 1024) { // would have spill-over area of 128 entries\n+            return;\n+        }\n+        throw new IllegalStateException(\"Spill-over slots in symbol table with \"+_count\n+                +\" entries, hash area of \"+_hashSize+\" slots is now full (all \"\n+                +(_hashSize >> 3)+\" slots -- suspect a DoS attack based on hash collisions.\"\n+                +\" You can disable the check via `JsonFactory.Feature.FAIL_ON_SYMBOL_HASH_OVERFLOW`\");\n+    }\n+\n+    static int _calcTertiaryShift(int primarySlots)\n+    {\n+        // first: we only get 1/4 of slots of primary, to divide\n+        int tertSlots = (primarySlots) >> 2;\n+        \n+        // default is for buckets of 4 slots (each 4 ints, i.e. 1 << 4)\n+        if (tertSlots < 64) {\n+            return 4;\n+        }\n+        if (tertSlots <= 256) { // buckets of 8 slots (up to 256 == 32 x 8)\n+            return 5;\n+        }\n+        if (tertSlots <= 1024) { // buckets of 16 slots (up to 1024 == 64 x 16)\n+            return 6;\n+        }\n+        // and biggest buckets have 32 slots\n+        return 7;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Immutable value class used for sharing information as efficiently\n+     * as possible, by only require synchronization of reference manipulation\n+     * but not access to contents.\n+     * \n+     * @since 2.1\n+     */\n+    private final static class TableInfo\n+    {\n+        public final int size;\n+        public final int count;\n+        public final int tertiaryShift;\n+        public final int[] mainHash;\n+        public final String[] names;\n+        public final int spilloverEnd;\n+        public final int longNameOffset;\n+\n+        public TableInfo(int size, int count, int tertiaryShift, \n+                int[] mainHash, String[] names, int spilloverEnd, int longNameOffset)\n+        {\n+            this.size = size;\n+            this.count = count;\n+            this.tertiaryShift = tertiaryShift;\n+            this.mainHash = mainHash;\n+            this.names = names;\n+            this.spilloverEnd = spilloverEnd;\n+            this.longNameOffset = longNameOffset;\n+        }\n+\n+        public TableInfo(ByteQuadsCanonicalizer src)\n+        {\n+            size = src._hashSize;\n+            count = src._count;\n+            tertiaryShift = src._tertiaryShift;\n+            mainHash = src._hashArea;\n+            names = src._names;\n+            spilloverEnd = src._spilloverEnd;\n+            longNameOffset = src._longNameOffset;\n+        }\n+\n+        public static TableInfo createInitial(int sz) {\n+            int hashAreaSize = sz << 3;\n+            int tertShift = _calcTertiaryShift(sz);\n+\n+            return new TableInfo(sz, // hashSize\n+                    0, // count\n+                    tertShift,\n+                    new int[hashAreaSize], // mainHash, 2x slots, 4 ints per slot\n+                    new String[sz << 1], // 2x slots\n+                    hashAreaSize - sz, // at 7/8 of the total area\n+                    hashAreaSize // longNameOffset, immediately after main hashes\n+            );\n+        }\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n  * symbol tables, to be able to make use of usually shared vocabulary\n  * of subsequent parsing runs.\n  *\n- * @author Tatu Saloranta\n+ * @deprecated Since 2.6, replaced by {@link ByteQuadsCanonicalizer}\n  */\n+@Deprecated\n public final class BytesToNameCanonicalizer\n {\n     private static final int DEFAULT_T_SIZE = 64;\n      * this corresponds to 64k main hash index. This should allow for enough distinct\n      * names for almost any case.\n      */\n-    private final static int MAX_ENTRIES_FOR_REUSE = 6000;\n+    final static int MAX_ENTRIES_FOR_REUSE = 6000;\n \n     /**\n      * Also: to thwart attacks based on hash collisions (which may or may not\n                 0 // longestCollisionList\n         );\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Life-cycle: factory methods, merging\n     /**********************************************************\n      */\n-    \n+\n     /**\n      * Factory method to call to create a symbol table instance with a\n      * randomized seed value.\n     protected static BytesToNameCanonicalizer createRoot(int seed) {\n         return new BytesToNameCanonicalizer(DEFAULT_T_SIZE, true, seed, true);\n     }\n-    \n+\n     /**\n      * Factory method used to create actual symbol table instance to\n      * use for parsing.\n         return null;\n     }\n \n+    public Name findName(int q1, int q2, int q3)\n+    {\n+        int hash = calcHash(q1, q2, q3);\n+        int ix = (hash & _hashMask);\n+        int val = _hash[ix];\n+        \n+        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n+            // Ok, but do we have an actual match?\n+            Name name = _mainNames[ix];\n+            if (name == null) { // main slot empty; can't find\n+                return null;\n+            }\n+            if (name.equals(q1, q2, q3)) {\n+                return name;\n+            }\n+        } else if (val == 0) { // empty slot? no match\n+            return null;\n+        }\n+        // Maybe a spill-over?\n+        val &= 0xFF;\n+        if (val > 0) { // 0 means 'empty'\n+            val -= 1; // to convert from 1-based to 0...\n+            Bucket bucket = _collList[val];\n+            if (bucket != null) {\n+                return bucket.find(hash, q1, q2, q3);\n+            }\n+        }\n+        // Nope, no match whatsoever\n+        return null;\n+    }\n+    \n     /**\n      * Finds and returns name matching the specified symbol, if such\n      * name already exists in the table; or if not, creates name object,\n      */\n     public Name findName(int[] q, int qlen)\n     {\n-        if (qlen < 3) { // another sanity check\n+        if (qlen < 4) { // another sanity check\n+            if (qlen == 3) {\n+                return findName(q[0], q[1], q[2]);\n+            }\n             return findName(q[0], (qlen < 2) ? 0 : q[1]);\n         }\n         int hash = calcHash(q, qlen);\n             name = InternCache.instance.intern(name);\n         }\n         int hash;\n-        if (qlen < 3) {\n-            hash = (qlen == 1) ? calcHash(q[0]) : calcHash(q[0], q[1]);\n+        if (qlen < 4) {\n+            if (qlen == 1) {\n+                hash = calcHash(q[0]);\n+            } else if (qlen == 2) {\n+                hash = calcHash(q[0], q[1]);\n+            } else {\n+                hash = calcHash(q[0], q[1], q[2]);\n+            }\n         } else {\n             hash = calcHash(q, qlen);\n         }\n         return hash;\n     }\n \n+    public int calcHash(int q1, int q2, int q3)\n+    {\n+        // use same algorithm as multi-byte, tested to work well\n+        int hash = q1 ^ _seed;\n+        hash += (hash >>> 9);\n+        hash *= MULT;\n+        hash += q2;\n+        hash *= MULT2;\n+        hash += (hash >>> 15);\n+        hash ^= q3;\n+        hash += (hash >>> 17);\n+\n+        // and finally shuffle some more once done\n+        hash += (hash >>> 15); // to get high-order bits to mix more\n+        hash ^= (hash << 9); // as well as lowest 2 bytes\n+\n+        return hash;\n+    }\n+    \n     public int calcHash(int[] q, int qlen)\n     {\n-        // Note: may be called for qlen < 3; but has at least one int\n-        if (qlen < 3) {\n+        if (qlen < 4) {\n             throw new IllegalArgumentException();\n         }\n \n             case 2:\n                 return new Name2(name, hash, quads[0], quads[1]);\n             case 3:\n+            default:\n                 return new Name3(name, hash, quads[0], quads[1], quads[2]);\n-            default:\n             }\n         }\n         return NameN.construct(name, hash, quads, qlen);\n     /* Other helper methods\n     /**********************************************************\n      */\n-    \n+\n     /**\n      * @since 2.1\n      */\n         throw new IllegalStateException(\"Longest collision chain in symbol table (of size \"+_count\n                 +\") now exceeds maximum, \"+maxLen+\" -- suspect a DoS attack based on hash collisions\");\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Helper classes\n             return null;\n         }\n \n+        public Name find(int h, int q1, int q2, int q3) {\n+            if (hash == h) {\n+                if (name.equals(q1, q2, q3)) {\n+                    return name;\n+                }\n+            }\n+            for (Bucket curr = next; curr != null; curr = curr.next) {\n+                if (curr.hash == h) {\n+                    Name currName = curr.name;\n+                    if (currName.equals(q1, q2, q3)) {\n+                        return currName;\n+                    }\n+                }\n+            }\n+            return null;\n+        }\n+        \n         public Name find(int h, int[] quads, int qlen) {\n             if (hash == h) {\n                 if (name.equals(quads, qlen)) {\n--- a/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java\n      * and truncates to be used as the index.\n      */\n     public int _hashToIndex(int rawHash) {\n-        rawHash += (rawHash >>> 15); // this seems to help quite a bit, at least for our tests\n+        // doing these seems to help a bit\n+        rawHash += (rawHash >>> 15);\n+        rawHash ^= (rawHash << 7);\n+        rawHash += (rawHash >>> 3);\n         return (rawHash & _indexMask);\n     }\n     \n--- a/src/main/java/com/fasterxml/jackson/core/sym/Name.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/Name.java\n     /**********************************************************\n      */\n \n-    public abstract boolean equals(int quad1);\n+    public abstract boolean equals(int q1);\n \n-    public abstract boolean equals(int quad1, int quad2);\n+    public abstract boolean equals(int q1, int q2);\n+\n+    /**\n+     * @since 2.6\n+     */\n+    public abstract boolean equals(int q1, int q2, int q3);\n \n     public abstract boolean equals(int[] quads, int qlen);\n \n--- a/src/main/java/com/fasterxml/jackson/core/sym/Name1.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/Name1.java\n \n     @Override public boolean equals(int quad) { return (quad == q); }\n     @Override public boolean equals(int quad1, int quad2) { return (quad1 == q) && (quad2 == 0); }\n+    @Override public boolean equals(int q1, int q2, int q3) { return false; }\n+\n     @Override public boolean equals(int[] quads, int qlen) { return (qlen == 1 && quads[0] == q); }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/sym/Name2.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/Name2.java\n     @Override\n     public boolean equals(int quad1, int quad2) { return (quad1 == q1) && (quad2 == q2); }\n \n+    @Override public boolean equals(int quad1, int quad2, int q3) { return false; }\n+    \n     @Override\n     public boolean equals(int[] quads, int qlen) { return (qlen == 2 && quads[0] == q1 && quads[1] == q2); }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/sym/Name3.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/Name3.java\n     public boolean equals(int quad1, int quad2) { return false; }\n \n     @Override\n+    public boolean equals(int quad1, int quad2, int quad3) {\n+        return (q1 == quad1) && (q2 == quad2) && (q3 == quad3);\n+    }\n+\n+    @Override\n     public boolean equals(int[] quads, int qlen) {\n         return (qlen == 3) && (quads[0] == q1) && (quads[1] == q2) && (quads[2] == q3);\n     }\n--- a/src/main/java/com/fasterxml/jackson/core/sym/NameN.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/NameN.java\n     @Override\n     public boolean equals(int quad1, int quad2) { return false; }\n \n+    // Implies quad length == 3, never matches\n+    @Override\n+    public boolean equals(int quad1, int quad2, int quad3) { return false; }\n+\n     @Override\n     public boolean equals(int[] quads, int len) {\n         if (len != qlen) { return false; }\n--- a/src/main/java/com/fasterxml/jackson/core/util/BufferRecycler.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/BufferRecycler.java\n     public final char[] allocCharBuffer(int ix) {\n         return allocCharBuffer(ix, 0);\n     }\n-    \n+\n     public char[] allocCharBuffer(int ix, int minSize) {\n         final int DEF_SIZE = charBufferLength(ix);\n         if (minSize < DEF_SIZE) {\n--- a/src/main/java/com/fasterxml/jackson/core/util/DefaultIndenter.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/DefaultIndenter.java\n     private final int charsPerLevel;\n     private final String eol;\n \n-    /** Indent with two spaces and the system's default line feed */\n+    /**\n+     * Indent with two spaces and the system's default line feed\n+     */\n     public DefaultIndenter() {\n         this(\"  \", SYS_LF);\n     }\n     \n-    /** Create an indenter which uses the <code>indent</code> string to indent one level\n+    /**\n+     * Create an indenter which uses the <code>indent</code> string to indent one level\n      *  and the <code>eol</code> string to separate lines.\n      */\n     public DefaultIndenter(String indent, String eol)\n--- a/src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java\n      * @since 2.6.0\n      */\n     public DefaultPrettyPrinter withRootSeparator(String rootSeparator) {\n-        return withRootSeparator(new SerializedString(rootSeparator));\n+        return withRootSeparator((rootSeparator == null) ? null : new SerializedString(rootSeparator));\n     }\n     \n     public void indentArraysWith(Indenter i) {\n      * (white-space) decoration.\n      */\n     @Override\n-    public void writeArrayValueSeparator(JsonGenerator jg)\n-        throws IOException, JsonGenerationException\n-    {\n-        jg.writeRaw(',');\n-        _arrayIndenter.writeIndentation(jg, _nesting);\n-    }\n-\n-    @Override\n-    public void writeEndArray(JsonGenerator jg, int nrOfValues)\n-        throws IOException, JsonGenerationException\n+    public void writeArrayValueSeparator(JsonGenerator gen) throws IOException\n+    {\n+        gen.writeRaw(',');\n+        _arrayIndenter.writeIndentation(gen, _nesting);\n+    }\n+\n+    @Override\n+    public void writeEndArray(JsonGenerator gen, int nrOfValues) throws IOException\n     {\n         if (!_arrayIndenter.isInline()) {\n             --_nesting;\n         }\n         if (nrOfValues > 0) {\n-            _arrayIndenter.writeIndentation(jg, _nesting);\n+            _arrayIndenter.writeIndentation(gen, _nesting);\n         } else {\n-            jg.writeRaw(' ');\n-        }\n-        jg.writeRaw(']');\n+            gen.writeRaw(' ');\n+        }\n+        gen.writeRaw(']');\n     }\n \n     /*\n     }\n \n     /**\n-     * This is a very simple indenter that only every adds a\n+     * This is a very simple indenter that only adds a\n      * single space for indentation. It is used as the default\n      * indenter for array values.\n      */\n         public static final FixedSpaceIndenter instance = new FixedSpaceIndenter();\n \n         @Override\n-        public void writeIndentation(JsonGenerator jg, int level)\n-            throws IOException, JsonGenerationException\n+        public void writeIndentation(JsonGenerator jg, int level) throws IOException\n         {\n             jg.writeRaw(' ');\n         }\n--- a/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n     /* Construction, initialization\n     /**********************************************************\n      */\n-    \n+\n     public JsonGeneratorDelegate(JsonGenerator d) {\n         this(d, true);\n     }\n--- a/src/main/java/com/fasterxml/jackson/core/util/JsonParserDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonParserDelegate.java\n     @Override public int getCurrentTokenId() { return delegate.getCurrentTokenId(); }\n     @Override public boolean hasCurrentToken() { return delegate.hasCurrentToken(); }\n     @Override public boolean hasTokenId(int id) { return delegate.hasTokenId(id); }\n-    \n+    @Override public boolean hasToken(JsonToken t) { return delegate.hasToken(t); }\n+\n     @Override public String getCurrentName() throws IOException, JsonParseException { return delegate.getCurrentName(); }\n     @Override public JsonLocation getCurrentLocation() { return delegate.getCurrentLocation(); }\n     @Override public JsonStreamContext getParsingContext() { return delegate.getParsingContext(); }\n--- a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n         if (_resultString != null) return false;\n         return true;\n     }\n-    \n+\n+    /**\n+     * Accessor that may be used to get the contents of this buffer in a single\n+     * <code>char</code> array regardless of whether they were collected in a segmented\n+     * fashion or not.\n+     */\n     public char[] getTextBuffer()\n     {\n         // Are we just using shared input buffer?\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments)  return _currentSegment;\n+        if (!_hasSegments) {\n+            return (_currentSegment == null) ? NO_CHARS : _currentSegment;\n+        }\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }\n--- a/src/test/java/com/fasterxml/jackson/core/BaseTest.java\n+++ b/src/test/java/com/fasterxml/jackson/core/BaseTest.java\n      * available methods, and ensures results are consistent, before\n      * returning them\n      */\n-    protected String getAndVerifyText(JsonParser jp)\n-        throws IOException, JsonParseException\n+    protected String getAndVerifyText(JsonParser jp) throws IOException\n     {\n         // Ok, let's verify other accessors\n         int actLen = jp.getTextLength();\n         return result;\n     }\n \n-    public String quote(String str) {\n+    protected String quote(String str) {\n         return '\"'+str+'\"';\n+    }\n+\n+    protected String aposToQuotes(String json) {\n+        return json.replace(\"'\", \"\\\"\");\n     }\n \n     protected void fieldNameFor(StringBuilder sb, int index)\n         return sb.toString();\n     }\n \n+    protected int[] calcQuads(byte[] wordBytes) {\n+        int blen = wordBytes.length;\n+        int[] result = new int[(blen + 3) / 4];\n+        for (int i = 0; i < blen; ++i) {\n+            int x = wordBytes[i] & 0xFF;\n+\n+            if (++i < blen) {\n+                x = (x << 8) | (wordBytes[i] & 0xFF);\n+                if (++i < blen) {\n+                    x = (x << 8) | (wordBytes[i] & 0xFF);\n+                    if (++i < blen) {\n+                        x = (x << 8) | (wordBytes[i] & 0xFF);\n+                    }\n+                }\n+            }\n+            result[i >> 2] = x;\n+        }\n+        return result;\n+    }\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/GeneratorFailTest.java\n+package com.fasterxml.jackson.core.json;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.OutputStreamWriter;\n+\n+import com.fasterxml.jackson.core.JsonEncoding;\n+import com.fasterxml.jackson.core.JsonFactory;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+\n+public class GeneratorFailTest\n+    extends com.fasterxml.jackson.core.BaseTest\n+{\n+    private final JsonFactory F = new JsonFactory();\n+\n+    // [core#167]: no error for writing field name twice\n+    public void testDupFieldNameWrites() throws Exception\n+    {\n+        _testDupFieldNameWrites(F, false);\n+        _testDupFieldNameWrites(F, true);        \n+    }\n+\n+    // [core#177]\n+    // Also: should not try writing JSON String if field name expected\n+    // (in future maybe take one as alias... but not yet)\n+    public void testFailOnWritingStringNotFieldNameBytes() throws Exception {\n+        _testFailOnWritingStringNotFieldName(F, false);\n+    }\n+\n+    // [core#177]\n+    public void testFailOnWritingStringNotFieldNameChars() throws Exception {\n+        _testFailOnWritingStringNotFieldName(F, true);        \n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+\n+    private void _testDupFieldNameWrites(JsonFactory f, boolean useReader) throws Exception\n+    {\n+        JsonGenerator gen;\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        if (useReader) {\n+            gen = f.createGenerator(new OutputStreamWriter(bout, \"UTF-8\"));\n+        } else {\n+            gen = f.createGenerator(bout, JsonEncoding.UTF8);\n+        }\n+        gen.writeStartObject();\n+        gen.writeFieldName(\"a\");\n+        \n+        try {\n+            gen.writeFieldName(\"b\");\n+            gen.flush();\n+            String json = bout.toString(\"UTF-8\");\n+            fail(\"Should not have let two consecutive field name writes succeed: output = \"+json);\n+        } catch (JsonProcessingException e) {\n+            verifyException(e, \"can not write a field name, expecting a value\");\n+        }\n+        gen.close();\n+    }\n+\n+    private void _testFailOnWritingStringNotFieldName(JsonFactory f, boolean useReader) throws Exception\n+    {\n+        JsonGenerator gen;\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        if (useReader) {\n+            gen = f.createGenerator(new OutputStreamWriter(bout, \"UTF-8\"));\n+        } else {\n+            gen = f.createGenerator(bout, JsonEncoding.UTF8);\n+        }\n+        gen.writeStartObject();\n+        \n+        try {\n+            gen.writeString(\"a\");\n+            gen.flush();\n+            String json = bout.toString(\"UTF-8\");\n+            fail(\"Should not have let \"+gen.getClass().getName()+\".writeString() be used in place of 'writeFieldName()': output = \"+json);\n+        } catch (JsonProcessingException e) {\n+            verifyException(e, \"can not write a String\");\n+        }\n+        gen.close();\n+    }\n+\n+\n+}\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestJsonGenerator.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestJsonGenerator.java\n         gen.close();\n     }\n \n-    // [core#167]: no error for writing field name twice\n-    public void testDupFieldNameWrites() throws Exception\n-    {\n-        JsonFactory f = new JsonFactory();\n-        _testDupFieldNameWrites(f, false);\n-        _testDupFieldNameWrites(f, true);        \n-    }\n-\n-    private void _testDupFieldNameWrites(JsonFactory f, boolean useReader) throws Exception\n-    {\n-        JsonGenerator gen;\n-        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n-        if (useReader) {\n-            gen = f.createGenerator(new OutputStreamWriter(bout, \"UTF-8\"));\n-        } else {\n-            gen = f.createGenerator(bout, JsonEncoding.UTF8);\n-        }\n-        gen.writeStartObject();\n-        gen.writeFieldName(\"a\");\n-        \n-        try {\n-            gen.writeFieldName(\"b\");\n-            gen.flush();\n-            String json = bout.toString(\"UTF-8\");\n-            fail(\"Should not have let two consequtive field name writes succeed: output = \"+json);\n-        } catch (JsonProcessingException e) {\n-            verifyException(e, \"can not write a field name, expecting a value\");\n-        }\n-        gen.close();\n-    }\n-\n     /*\n     /**********************************************************\n     /* Internal methods\n     /**********************************************************\n      */\n-    \n-    private void doTestIntWrite(boolean pad)\n-        throws Exception\n+\n+    private void doTestIntWrite(boolean pad) throws Exception\n     {\n         int[] VALUES = new int[] {\n             0, 1, -9, 32, -32, 57, 189, 2017, -9999, 13240, 123456,\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestJsonParser.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestJsonParser.java\n package com.fasterxml.jackson.core.json;\n \n import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.util.JsonParserDelegate;\n \n import java.io.*;\n import java.net.URL;\n         }\n         jp.close();\n     }\n+\n+    public void testGetValueAsTextBytes() throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+        _testGetValueAsText(f, true, false);\n+        _testGetValueAsText(f, true, true);\n+    }\n+\n+    public void testGetValueAsTextChars() throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+        _testGetValueAsText(f, false, false);\n+        _testGetValueAsText(f, false, true);\n+    }\n     \n+    @SuppressWarnings(\"resource\")\n+    private void _testGetValueAsText(JsonFactory f,\n+            boolean useBytes, boolean delegate) throws Exception\n+    {\n+        String JSON = \"{\\\"a\\\":1,\\\"b\\\":true,\\\"c\\\":null,\\\"d\\\":\\\"foo\\\"}\";\n+        JsonParser p = useBytes ? f.createParser(JSON.getBytes(\"UTF-8\"))\n+                : f.createParser(JSON);\n+\n+        if (delegate) {\n+            p = new JsonParserDelegate(p);\n+        }\n+        \n+        assertToken(JsonToken.START_OBJECT, p.nextToken());\n+        assertNull(p.getValueAsString());\n+\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n+        assertEquals(\"a\", p.getText());\n+        assertEquals(\"a\", p.getValueAsString());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n+        assertEquals(\"1\", p.getValueAsString());\n+\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n+        assertEquals(\"b\", p.getValueAsString());\n+        assertToken(JsonToken.VALUE_TRUE, p.nextToken());\n+        assertEquals(\"true\", p.getValueAsString());\n+\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n+        assertEquals(\"c\", p.getValueAsString());\n+        assertToken(JsonToken.VALUE_NULL, p.nextToken());\n+        // null token returned as Java null, as per javadoc\n+        assertNull(p.getValueAsString());\n+\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n+        assertEquals(\"d\", p.getValueAsString());\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertEquals(\"foo\", p.getValueAsString());\n+\n+        assertToken(JsonToken.END_OBJECT, p.nextToken());\n+        assertNull(p.getValueAsString());\n+\n+        assertNull(p.nextToken());\n+        p.close();\n+    }\n+\n     /*\n     /**********************************************************\n     /* Helper methods\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestParserSymbols.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestParserSymbols.java\n {\n     // For [Issue#148]\n     public void testSymbolsWithNullBytes() throws Exception {\n-        _testSymbolsWithNull(true);\n+        JsonFactory f = new JsonFactory();\n+        _testSymbolsWithNull(f, true);\n+        // and repeat with same factory, just for fun, and to ensure symbol table is fine\n+        _testSymbolsWithNull(f, true);\n     }\n \n     // For [Issue#148]\n     public void testSymbolsWithNullChars() throws Exception {\n-        _testSymbolsWithNull(false);\n+        JsonFactory f = new JsonFactory();\n+        _testSymbolsWithNull(f, false);\n+        _testSymbolsWithNull(f, false);\n     }\n-    \n-    private void _testSymbolsWithNull(boolean useBytes) throws Exception\n+\n+    private void _testSymbolsWithNull(JsonFactory f, boolean useBytes) throws Exception\n     {\n-        final JsonFactory f = new JsonFactory();\n         final String INPUT = \"{\\\"\\\\u0000abc\\\" : 1, \\\"abc\\\":2}\";\n         JsonParser parser = useBytes ? f.createParser(INPUT.getBytes(\"UTF-8\"))\n                 : f.createParser(INPUT);\n         assertToken(JsonToken.START_OBJECT, parser.nextToken());\n \n         assertToken(JsonToken.FIELD_NAME, parser.nextToken());\n-        assertEquals(\"\\u0000abc\", parser.getCurrentName());\n+        String currName = parser.getCurrentName();\n+        if (!\"\\u0000abc\".equals(currName)) {\n+            fail(\"Expected \\\\0abc (4 bytes), '\"+currName+\"' (\"+currName.length()+\")\");\n+        }\n         assertToken(JsonToken.VALUE_NUMBER_INT, parser.nextToken());\n         assertEquals(1, parser.getIntValue());\n \n         assertToken(JsonToken.FIELD_NAME, parser.nextToken());\n-        assertEquals(\"abc\", parser.getCurrentName());\n+        currName = parser.getCurrentName();\n+        if (!\"abc\".equals(currName)) {\n+            /*\n+            for (int i = 0; i < currName.length(); ++i) {\n+                System.out.println(\"#\"+i+\" -> 0x\"+Integer.toHexString(currName.charAt(i)));\n+            }\n+            */\n+            fail(\"Expected 'abc' (3 bytes), '\"+currName+\"' (\"+currName.length()+\")\");\n+        }\n         assertToken(JsonToken.VALUE_NUMBER_INT, parser.nextToken());\n         assertEquals(2, parser.getIntValue());\n         \n--- a/src/test/java/com/fasterxml/jackson/core/json/TestUtf8Parser.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestUtf8Parser.java\n         jp.close();\n     }\n \n-    public void testUtf8Name2Bytes()\n-        throws Exception\n+    public void testUtf8Name2Bytes() throws Exception\n     {\n         final String[] NAMES = UTF8_2BYTE_STRINGS;\n \n             String DOC = \"{ \\\"\"+NAME+\"\\\" : 0 }\";\n             JsonParser jp = createParserUsingStream(DOC, \"UTF-8\");\n             assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+\n+            assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+\n+            assertTrue(jp.hasToken(JsonToken.FIELD_NAME));\n+            assertTrue(jp.hasTokenId(JsonTokenId.ID_FIELD_NAME));\n             \n-            assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n             assertEquals(NAME, jp.getCurrentName());\n             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertTrue(jp.hasToken(JsonToken.VALUE_NUMBER_INT));\n+            assertTrue(jp.hasTokenId(JsonTokenId.ID_NUMBER_INT));\n+\n             // should retain name during value entry, too\n             assertEquals(NAME, jp.getCurrentName());\n             \n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestByteBasedSymbols.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestByteBasedSymbols.java\n import java.io.*;\n \n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.core.sym.BytesToNameCanonicalizer;\n-import com.fasterxml.jackson.core.sym.Name;\n \n /**\n  * Unit test(s) to verify that handling of (byte-based) symbol tables\n         jp0.close();\n     }\n \n-    public void testAuxMethods()\n-        throws Exception\n+    public void testAuxMethodsWithNewSymboTable() throws Exception\n     {\n         final int A_BYTES = 0x41414141; // \"AAAA\"\n         final int B_BYTES = 0x42424242; // \"BBBB\"\n \n-        BytesToNameCanonicalizer nc = BytesToNameCanonicalizer.createRoot()\n+        ByteQuadsCanonicalizer nc = ByteQuadsCanonicalizer.createRoot()\n                 .makeChild(JsonFactory.Feature.collectDefaults());\n         assertNull(nc.findName(A_BYTES));\n         assertNull(nc.findName(A_BYTES, B_BYTES));\n \n         nc.addName(\"AAAA\", new int[] { A_BYTES }, 1);\n-        Name n1 = nc.findName(A_BYTES);\n-        assertNotNull(n1);\n-        assertEquals(\"AAAA\", n1.getName());\n+        String n1 = nc.findName(A_BYTES);\n+        assertEquals(\"AAAA\", n1);\n         nc.addName(\"AAAABBBB\", new int[] { A_BYTES, B_BYTES }, 2);\n-        Name n2 = nc.findName(A_BYTES, B_BYTES);\n-        assertEquals(\"AAAABBBB\", n2.getName());\n+        String n2 = nc.findName(A_BYTES, B_BYTES);\n+        assertEquals(\"AAAABBBB\", n2);\n         assertNotNull(n2);\n \n         /* and let's then just exercise this method so it gets covered;\n          */\n         assertNotNull(nc.toString());\n     }\n-\n+    \n     /*\n     /**********************************************************\n     /* Helper methods\n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestJsonParserSymbols.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestJsonParserSymbols.java\n      */\n     final static class MyJsonFactory extends JsonFactory\n     {\n-        public int byteSymbolCount() { return _rootByteSymbols.size(); }\n+        public int byteSymbolCount() { return _byteSymbolCanonicalizer.size(); }\n         public int charSymbolCount() { return _rootCharSymbols.size(); }\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n package com.fasterxml.jackson.core.sym;\n \n import java.io.IOException;\n+import java.lang.reflect.Field;\n import java.nio.charset.Charset;\n \n-import com.fasterxml.jackson.core.JsonFactory;\n+import com.fasterxml.jackson.core.*;\n \n public class TestSymbolTables extends com.fasterxml.jackson.core.BaseTest\n {\n     {\n         // pass seed, to keep results consistent:\n         CharsToNameCanonicalizer symbols = CharsToNameCanonicalizer.createRoot(1);\n-        final int COUNT = 6000;\n+        final int COUNT = 12000;\n         for (int i = 0; i < COUNT; ++i) {\n             String id = fieldNameFor(i);\n             char[] ch = id.toCharArray();\n             symbols.findSymbol(ch, 0, ch.length, symbols.calcHash(id));\n         }\n \n-        assertEquals(8192, symbols.bucketCount());\n+        assertEquals(16384, symbols.bucketCount());\n         assertEquals(COUNT, symbols.size());\n         \n //System.out.printf(\"Char stuff: collisions %d, max-coll %d\\n\", symbols.collisionCount(), symbols.maxCollisionLength());\n         \n         // holy guacamoley... there are way too many. 31 gives 3567 (!), 33 gives 2747\n         // ... at least before shuffling. Shuffling helps quite a lot, so:\n-\n-        assertEquals(1401, symbols.collisionCount()); // with 33\n-//        assertEquals(1858, symbols.collisionCount()); // with 31\n-\n-        // esp. with collisions; first got about 30;\n-        // with fixes 4 (for 33), 5 (for 31)\n-\n-        assertEquals(4, symbols.maxCollisionLength()); // 33\n-//        assertEquals(5, symbols.maxCollisionLength()); // 31\n+        \n+        assertEquals(3431, symbols.collisionCount());\n+\n+        assertEquals(6, symbols.maxCollisionLength());\n     }\n \n     // Test for verifying stability of hashCode, wrt collisions, using\n     // synthetic field name generation and byte-based input (UTF-8)\n-    public void testSyntheticWithBytes() throws IOException\n+    @SuppressWarnings(\"deprecation\")\n+    public void testSyntheticWithBytesOld() throws IOException\n     {\n         // pass seed, to keep results consistent:\n         final int SEED = 33333;\n         BytesToNameCanonicalizer symbols =\n                 BytesToNameCanonicalizer.createRoot(SEED).makeChild(JsonFactory.Feature.collectDefaults());\n-        final int COUNT = 6000;\n+\n+        final int COUNT = 12000;\n         for (int i = 0; i < COUNT; ++i) {\n             String id = fieldNameFor(i);\n-            int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\"));\n-            symbols.addName(id, quads, quads.length);\n-        }\n-        assertEquals(COUNT, symbols.size());\n-        assertEquals(8192, symbols.bucketCount());\n+            int[] quads = calcQuads(id.getBytes(\"UTF-8\"));\n+            symbols.addName(id, quads, quads.length);\n+        }\n+        assertEquals(COUNT, symbols.size());\n+        assertEquals(16384, symbols.bucketCount());\n \n //System.out.printf(\"Byte stuff: collisions %d, max-coll %d\\n\", symbols.collisionCount(), symbols.maxCollisionLength());\n-    \n-        assertEquals(1733, symbols.collisionCount());\n-        // but not super long collision chains:\n-        assertEquals(9, symbols.maxCollisionLength());\n+        assertEquals(3476, symbols.collisionCount());\n+        // longest collision chain not optimal but ok:\n+        assertEquals(15, symbols.maxCollisionLength());\n+\n+        // But also verify entries are actually found?\n+    }\n+\n+    public void testSyntheticWithBytesNew() throws IOException\n+    {\n+        // pass seed, to keep results consistent:\n+        final int SEED = 33333;\n+        ByteQuadsCanonicalizer symbols =\n+                ByteQuadsCanonicalizer.createRoot(SEED).makeChild(JsonFactory.Feature.collectDefaults());\n+\n+        final int COUNT = 12000;\n+        for (int i = 0; i < COUNT; ++i) {\n+            String id = fieldNameFor(i);\n+            int[] quads = calcQuads(id.getBytes(\"UTF-8\"));\n+            symbols.addName(id, quads, quads.length);\n+        }\n+        assertEquals(COUNT, symbols.size());\n+        assertEquals(16384, symbols.bucketCount());\n+        \n+        // fragile, but essential to verify low collision counts;\n+        // anywhere between 70-80% primary matches\n+        assertEquals(8524, symbols.primaryCount());\n+        // secondary between 10-20%\n+        assertEquals(2534, symbols.secondaryCount());\n+        // and most of remaining in tertiary\n+        assertEquals(942, symbols.tertiaryCount());\n+        // so that spill-over is empty or close to\n+        assertEquals(0, symbols.spilloverCount());\n     }\n \n     // [Issue#145]\n-    public void testThousandsOfSymbols() throws IOException\n-    {\n-        final int SEED = 33333;\n-\n-        BytesToNameCanonicalizer symbolsBRoot = BytesToNameCanonicalizer.createRoot(SEED);\n+    public void testThousandsOfSymbolsWithChars() throws IOException\n+    {\n+        final int SEED = 33333;\n+\n         CharsToNameCanonicalizer symbolsCRoot = CharsToNameCanonicalizer.createRoot(SEED);\n-        final Charset utf8 = Charset.forName(\"UTF-8\");\n+        int exp = 0;\n         \n         for (int doc = 0; doc < 100; ++doc) {\n             CharsToNameCanonicalizer symbolsC =\n                     symbolsCRoot.makeChild(JsonFactory.Feature.collectDefaults());\n+            for (int i = 0; i < 250; ++i) {\n+                String name = \"f_\"+doc+\"_\"+i;\n+                char[] ch = name.toCharArray();\n+                String str = symbolsC.findSymbol(ch, 0, ch.length,\n+                        symbolsC.calcHash(name));\n+                assertNotNull(str);\n+            }\n+            symbolsC.release();\n+            exp += 250;\n+            if (exp > CharsToNameCanonicalizer.MAX_ENTRIES_FOR_REUSE) {\n+                exp = 0;\n+            }\n+            assertEquals(exp, symbolsCRoot.size());\n+        }\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    public void testThousandsOfSymbolsWithOldBytes() throws IOException\n+    {\n+        final int SEED = 33333;\n+\n+        BytesToNameCanonicalizer symbolsBRoot = BytesToNameCanonicalizer.createRoot(SEED);\n+        final Charset utf8 = Charset.forName(\"UTF-8\");\n+        int exp = 0;\n+        \n+        for (int doc = 0; doc < 100; ++doc) {\n             BytesToNameCanonicalizer symbolsB =\n                     symbolsBRoot.makeChild(JsonFactory.Feature.collectDefaults());\n             for (int i = 0; i < 250; ++i) {\n \n                 int[] quads = BytesToNameCanonicalizer.calcQuads(name.getBytes(utf8));\n                 symbolsB.addName(name, quads, quads.length);\n-\n-                char[] ch = name.toCharArray();\n-                String str = symbolsC.findSymbol(ch, 0, ch.length,\n-                        symbolsC.calcHash(name));\n-                assertNotNull(str);\n+                Name n = symbolsB.findName(quads, quads.length);\n+                assertEquals(name, n.getName());\n             }\n             symbolsB.release();\n-            symbolsC.release();\n-        }\n+            exp += 250;\n+            if (exp > BytesToNameCanonicalizer.MAX_ENTRIES_FOR_REUSE) {\n+                exp = 0;\n+            }\n+            assertEquals(exp, symbolsBRoot.size());\n+        }\n+    }\n+\n+    // Since 2.6\n+    public void testThousandsOfSymbolsWithNew() throws IOException\n+    {\n+        final int SEED = 33333;\n+\n+        ByteQuadsCanonicalizer symbolsBRoot = ByteQuadsCanonicalizer.createRoot(SEED);\n+        final Charset utf8 = Charset.forName(\"UTF-8\");\n+        int exp = 0;\n+        ByteQuadsCanonicalizer symbolsB = null;\n+\n+        // loop to get \n+        for (int doc = 0; doc < 100; ++doc) {\n+            symbolsB = symbolsBRoot.makeChild(JsonFactory.Feature.collectDefaults());\n+            for (int i = 0; i < 250; ++i) {\n+                String name = \"f_\"+doc+\"_\"+i;\n+\n+                int[] quads = calcQuads(name.getBytes(utf8));\n+                \n+                symbolsB.addName(name, quads, quads.length);\n+                String n = symbolsB.findName(quads, quads.length);\n+                assertEquals(name, n);\n+            }\n+            symbolsB.release();\n+            \n+            exp += 250;\n+            if (exp > ByteQuadsCanonicalizer.MAX_ENTRIES_FOR_REUSE) {\n+                exp = 0;\n+            }\n+            assertEquals(exp, symbolsBRoot.size());\n+        }\n+        /* 05-Feb-2015, tatu: Fragile, but it is important to ensure that collision\n+         *   rates are not accidentally increased...\n+         */\n+        assertEquals(6250, symbolsB.size());\n+        assertEquals(4761, symbolsB.primaryCount()); // 80% primary hit rate\n+        assertEquals(1190, symbolsB.secondaryCount()); // 13% secondary\n+        assertEquals(299, symbolsB.tertiaryCount()); // 7% tertiary\n+        assertEquals(0, symbolsB.spilloverCount()); // and couple of leftovers\n+    }\n+    \n+    // And then one more test just for Bytes-based symbol table\n+    public void testByteBasedSymbolTable() throws Exception\n+    {\n+        // combination of short, medium1/2, long names...\n+        final String JSON = aposToQuotes(\"{'abc':1, 'abc\\\\u0000':2, '\\\\u0000abc':3, \"\n+                // then some medium\n+                +\"'abc123':4,'abcd1234':5,\"\n+                +\"'abcd1234a':6,'abcd1234abcd':7,\"\n+                +\"'abcd1234abcd1':8\"\n+                +\"}\");\n+\n+        JsonFactory f = new JsonFactory();\n+        JsonParser p = f.createParser(JSON.getBytes(\"UTF-8\"));\n+        ByteQuadsCanonicalizer symbols = _findSymbols(p);\n+        assertEquals(0, symbols.size());\n+        _streamThrough(p);\n+        assertEquals(8, symbols.size());\n+        p.close();\n+\n+        // and, for fun, try again\n+        p = f.createParser(JSON.getBytes(\"UTF-8\"));\n+        _streamThrough(p);\n+        symbols = _findSymbols(p);\n+        assertEquals(8, symbols.size());\n+        p.close();\n+\n+        p = f.createParser(JSON.getBytes(\"UTF-8\"));\n+        _streamThrough(p);\n+        symbols = _findSymbols(p);\n+        assertEquals(8, symbols.size());\n+        p.close();\n+    }\n+\n+    private void _streamThrough(JsonParser p) throws IOException\n+    {\n+        while (p.nextToken() != null) { }\n+    }\n+    \n+    private ByteQuadsCanonicalizer _findSymbols(JsonParser p) throws Exception\n+    {\n+        Field syms = p.getClass().getDeclaredField(\"_symbols\");\n+        syms.setAccessible(true);\n+        return ((ByteQuadsCanonicalizer) syms.get(p));\n     }\n \n     // [core#187]: unexpectedly high number of collisions for straight numbers\n+    @SuppressWarnings(\"deprecation\")\n     public void testCollisionsWithBytes187() throws IOException\n     {\n         BytesToNameCanonicalizer symbols =\n         assertEquals(65536, symbols.bucketCount());\n \n         // collision count rather high, but has to do\n-        assertEquals(14408, symbols.collisionCount());\n+        assertEquals(7127, symbols.collisionCount());\n         // as well as collision counts\n-        assertEquals(10, symbols.maxCollisionLength());\n+        assertEquals(4, symbols.maxCollisionLength());\n+    }\n+\n+    // [core#187]: unexpectedly high number of collisions for straight numbers\n+    public void testCollisionsWithBytesNew187a() throws IOException\n+    {\n+        ByteQuadsCanonicalizer symbols =\n+                ByteQuadsCanonicalizer.createRoot(1).makeChild(JsonFactory.Feature.collectDefaults());\n+\n+        final int COUNT = 43000;\n+        for (int i = 0; i < COUNT; ++i) {\n+            String id = String.valueOf(10000 + i);\n+            int[] quads = calcQuads(id.getBytes(\"UTF-8\"));\n+            symbols.addName(id, quads, quads.length);\n+        }\n+\n+        assertEquals(COUNT, symbols.size());\n+        assertEquals(65536, symbols.bucketCount());\n+\n+        /* 29-Mar-2015, tatu: To get collision counts down for this\n+         *    test took quite a bit of tweaking...\n+         */\n+        assertEquals(32342, symbols.primaryCount());\n+        assertEquals(8863, symbols.secondaryCount());\n+        assertEquals(1795, symbols.tertiaryCount());\n+\n+        // finally managed to get this to 0; other variants produced thousands\n+        assertEquals(0, symbols.spilloverCount());\n+    }\n+\n+    // Another variant, but with 1-quad names\n+    public void testCollisionsWithBytesNew187b() throws IOException\n+    {\n+        ByteQuadsCanonicalizer symbols =\n+                ByteQuadsCanonicalizer.createRoot(1).makeChild(JsonFactory.Feature.collectDefaults());\n+\n+        final int COUNT = 10000;\n+        for (int i = 0; i < COUNT; ++i) {\n+            String id = String.valueOf(i);\n+            int[] quads = calcQuads(id.getBytes(\"UTF-8\"));\n+            symbols.addName(id, quads, quads.length);\n+        }\n+        assertEquals(COUNT, symbols.size());\n+        \n+        assertEquals(32768, symbols.bucketCount());\n+\n+        // fragile, but essential to verify low collision counts;\n+        // anywhere between 70-80% primary matches\n+        assertEquals(9386, symbols.primaryCount());\n+        // secondary between 10-20%\n+        assertEquals(345, symbols.secondaryCount());\n+        // and most of remaining in tertiary\n+        assertEquals(257, symbols.tertiaryCount());\n+        // but number of spill-overs starts to grow beyond 30k quite a lot:\n+        assertEquals(12, symbols.spilloverCount());\n     }\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolsWithMediaItem.java\n+package com.fasterxml.jackson.core.sym;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+public class TestSymbolsWithMediaItem extends com.fasterxml.jackson.core.BaseTest\n+{\n+    private final String JSON = aposToQuotes(\n+            \"{'media' : {\\n\"\n+            +\"      'uri' : 'http://foo.com',\"\n+            +\"      'title' : 'Test title 1',\"\n+            +\"      'width' : 640, 'height' : 480,\"\n+            +\"      'format' : 'video/mpeg4',\"\n+            +\"      'duration' : 18000000,\"\n+            +\"      'size' : 58982400,\"\n+            +\"      'bitrate' : 262144,\"\n+            +\"      'persons' : [ ],\"\n+            +\"      'player' : 'native',\"\n+            +\"      'copyright' : 'None'\"\n+            +\"   },\\n\"\n+            +\"   'images' : [ {\\n\"\n+            +\"      'uri' : 'http://bar.com',\\n\"\n+            +\"      'title' : 'Test title 1',\\n\"\n+            +\"      'width' : 1024,'height' : 768,\\n\"\n+            +\"      'size' : 'LARGE'\\n\"\n+            +\"    }, {\\n\"\n+            +\"      'uri' : 'http://foobar.org',\\n\"\n+            +\"      'title' : 'Javaone Keynote',\\n\"\n+            +\"      'width' : 320, 'height' : 240,\\n\"\n+            +\"      'size' : 'SMALL'\\n\"\n+            +\"    } ]\\n\"\n+            +\"}\\n\");\n+\n+    public void testSmallSymbolSetWithBytes() throws IOException\n+    {\n+        final int SEED = 33333;\n+\n+        ByteQuadsCanonicalizer symbolsRoot = ByteQuadsCanonicalizer.createRoot(SEED);\n+        ByteQuadsCanonicalizer symbols = symbolsRoot.makeChild(JsonFactory.Feature.collectDefaults());\n+        JsonFactory f = new JsonFactory();\n+        JsonParser p = f.createParser(JSON.getBytes(\"UTF-8\"));\n+\n+        JsonToken t;\n+        while ((t = p.nextToken()) != null) {\n+            if (t != JsonToken.FIELD_NAME) {\n+                continue;\n+            }\n+            String name = p.getCurrentName();\n+            int[] quads = calcQuads(name.getBytes(\"UTF-8\"));\n+\n+            if (symbols.findName(quads, quads.length) != null) {\n+                continue;\n+            }\n+            symbols.addName(name, quads, quads.length);\n+        }\n+        p.close();\n+        \n+        assertEquals(13, symbols.size());\n+        assertEquals(12, symbols.primaryCount()); // 80% primary hit rate\n+        assertEquals(1, symbols.secondaryCount()); // 13% secondary\n+        assertEquals(0, symbols.tertiaryCount()); // 7% tertiary\n+        assertEquals(0, symbols.spilloverCount()); // and couple of leftovers\n+    }\n+\n+    public void testSmallSymbolSetWithChars() throws IOException\n+    {\n+        final int SEED = 33333;\n+\n+        CharsToNameCanonicalizer symbols = CharsToNameCanonicalizer.createRoot(SEED);\n+        JsonFactory f = new JsonFactory();\n+        JsonParser p = f.createParser(JSON);\n+\n+        JsonToken t;\n+        while ((t = p.nextToken()) != null) {\n+            if (t != JsonToken.FIELD_NAME) {\n+                continue;\n+            }\n+            String name = p.getCurrentName();\n+            char[] ch = name.toCharArray();\n+            symbols.findSymbol(ch, 0, ch.length, symbols.calcHash(name));\n+        }\n+        p.close();\n+        \n+        assertEquals(13, symbols.size());\n+        assertEquals(13, symbols.size());\n+        assertEquals(64, symbols.bucketCount());\n+\n+        // usually get 1 collision, but sometimes get lucky with 0; other times less so with 2\n+        // (with differing shifting for hash etc)\n+        assertEquals(0, symbols.collisionCount());\n+        assertEquals(0, symbols.maxCollisionLength());\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/core/util/TestTextBuffer.java\n+++ b/src/test/java/com/fasterxml/jackson/core/util/TestTextBuffer.java\n package com.fasterxml.jackson.core.util;\n-\n-import com.fasterxml.jackson.core.util.BufferRecycler;\n-import com.fasterxml.jackson.core.util.TextBuffer;\n \n public class TestTextBuffer\n     extends com.fasterxml.jackson.core.BaseTest\n               }\n           }\n       }\n+\n+    // [Core#182]\n+    public void testEmpty() {\n+        TextBuffer tb = new TextBuffer(new BufferRecycler());\n+        tb.resetWithEmpty();\n+\n+        assertTrue(tb.getTextBuffer().length == 0);\n+        tb.contentsAsString();\n+        assertTrue(tb.getTextBuffer().length == 0);\n+    }\n }\n--- /dev/null\n+++ b/src/test/java/perf/EnumByBytesLookup.java\n+package perf;\n+\n+import java.nio.charset.Charset;\n+import java.util.Arrays;\n+\n+/**\n+ * Trie container/wrapper, in this case implements Enum-value lookup.\n+ * Sample code to possibly use for streamlined-lookup by dictionary, using\n+ * UTF-8 bytes of {@link Enum#name()} as the key.\n+ */\n+public class EnumByBytesLookup<E extends Enum<E>>\n+{\n+    private final static Charset UTF8 = Charset.forName(\"UTF-8\");\n+\n+    private final Trie<E> _root;\n+    private final int _size;\n+\n+    private EnumByBytesLookup(Trie<E> root, int size) {\n+        _root = root;\n+        _size = size;\n+    }\n+\n+    public static <EIN extends Enum<EIN>> EnumByBytesLookup<EIN> buildFor(Class<EIN> enumClass)\n+    {\n+        Trie<EIN> root = new Trie<EIN>(null);\n+        int size = 0;\n+        for (EIN en : enumClass.getEnumConstants()) {\n+            byte[] key = en.name().getBytes(UTF8);\n+            root = root.with(en, key);\n+            ++size;\n+        }\n+        return new EnumByBytesLookup<EIN>(root, size);\n+    }\n+\n+    public E find(byte[] rawId) {\n+      return _root.find(rawId);\n+    }\n+\n+    public int size() { return _size; }\n+}\n+\n+/**\n+ * Trie nodes\n+ */\n+class Trie<T> {\n+    private final static byte[] NO_BYTES = new byte[0];\n+\n+    private final static Trie<?>[] NO_NODES = new Trie<?>[0];\n+\n+    /**\n+     * For leaves, value matched by sequence\n+     */\n+    private final T _match;\n+\n+    private final byte[] _nextBytes;\n+    private final Trie<T>[] nextNodes;\n+\n+    private final int nextCount;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    Trie(T match) {\n+      this(match, NO_BYTES, (Trie<T>[]) NO_NODES);\n+    }\n+\n+    private Trie(T match, byte[] nextBytes, Trie<T>[] nextNodes) {\n+      this._match = match;\n+      this._nextBytes = nextBytes;\n+      this.nextNodes = nextNodes;\n+      nextCount = nextBytes.length;\n+    }\n+\n+    private Trie(Trie<T> base, T match) {\n+      // should we allow duplicate calls with same match? For now, let's not\n+      if (base._match != null) {\n+        throw new IllegalArgumentException(\"Trying to add same match multiple times\");\n+      }\n+      this._match = match;\n+      _nextBytes = base._nextBytes;\n+      nextNodes = base.nextNodes;\n+      nextCount = base.nextCount;\n+    }\n+\n+    private Trie(Trie<T> base, byte nextByte, Trie<T> nextNode) {\n+      // should we allow duplicate calls with same match? For now, let's not\n+      if (base._match != null) {\n+        throw new IllegalArgumentException(\"Trying to add same match multiple times\");\n+      }\n+      _match = base._match;\n+      int size = base._nextBytes.length + 1;\n+      _nextBytes = Arrays.copyOf(base._nextBytes, size);\n+      _nextBytes[size-1] = nextByte;\n+      nextNodes = Arrays.copyOf(base.nextNodes, size);\n+      nextNodes[size-1] = nextNode;\n+      nextCount = size;\n+    }\n+\n+    /**\n+     * Constructor used when an existing branch needs to be replaced due to addition\n+     */\n+    private Trie(Trie<T> base, int offset, Trie<T> newNode) {\n+      _match = base._match;\n+      // can keep nextBytes, as they don't change\n+      _nextBytes = base._nextBytes;\n+      // but must create a copy of next nodes, to modify one entry\n+      nextNodes = Arrays.copyOf(base.nextNodes, base.nextNodes.length);\n+      nextNodes[offset] = newNode;\n+      nextCount = base.nextCount;\n+    }\n+\n+    /**\n+     * \"Mutant factory\" method: constructs a modified Trie, with specified raw id\n+     * added.\n+     */\n+    public Trie<T> with(T match, byte[] rawId) {\n+      return with(match, rawId, 0, rawId.length);\n+    }\n+\n+    private Trie<T> with(T match, byte[] rawId, int start, int end) {\n+      if (start == end) {\n+        return new Trie<T>(this, match);\n+      }\n+      // Ok: two choices; either we follow existing branch; or need to create new one\n+      final byte b = rawId[start++];\n+      for (int i = 0; i < nextCount; ++i) {\n+        if (_nextBytes[i] == b) {\n+          // existing branch: good day for delegation...\n+          Trie<T> old = nextNodes[i];\n+          // to keep things truly immutable, copy underlying arrays, then\n+          return new Trie<T>(this, i, old.with(match, rawId, start, end));\n+        }\n+      }\n+      // simplest recursively, but for fun let's convert to iteration. Start with tail\n+      Trie<T> curr = new Trie<T>(match);\n+\n+      for (int i = end-1; i >= start; --i) {\n+        curr = new Trie<T>(this, rawId[i], curr);\n+      }\n+      return new Trie<T>(this, b, curr);\n+    }\n+\n+    public T find(byte[] id) {\n+      return find(id, 0, id.length);\n+    }\n+\n+    public T find(byte[] id, int offset, int length) {\n+      Trie<T> t = this;\n+      final int end = offset+length;\n+\n+      for (; offset < end; ++offset) {\n+        byte b = id[offset];\n+        t = t.next(b);\n+        if (t == null) {\n+            // NOTE: if using null-padding, would trim here\n+            /*\n+          if (b == (byte) 0) {\n+            break;\n+          }\n+          */\n+          return null;\n+        }\n+      }\n+      return t._match;\n+    }\n+\n+    private Trie<T> next(int b) {\n+      for (int i = 0; i < nextCount; ++i) {\n+        if (_nextBytes[i] == b) {\n+          return nextNodes[i];\n+        }\n+      }\n+      return null;\n+    }\n+}", "timestamp": 1427766220, "metainfo": ""}