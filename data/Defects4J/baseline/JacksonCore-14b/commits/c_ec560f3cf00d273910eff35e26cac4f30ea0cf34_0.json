{"sha": "ec560f3cf00d273910eff35e26cac4f30ea0cf34", "log": "Add a failing test for #223", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n          */\n         ESCAPE_NON_ASCII(false),\n \n+// 23-Nov-2015, tatu: for [core#223], if and when it gets implemented\n+        /**\n+         * Feature that specifies handling of UTF-8 content that contains\n+         * characters beyond BMP (Basic Multilingual Plane), which are\n+         * represented in UCS-2 (Java internal character encoding) as two\n+         * \"surrogate\" characters. If feature is enabled, these surrogate\n+         * pairs are separately escaped using backslash escapes; if disabled,\n+         * native output (4-byte UTF-8 sequence, or, with char-backed output\n+         * targets, writing of surrogates as is which is typically converted\n+         * by {@link java.io.Writer} into 4-byte UTF-8 sequence eventually)\n+         * is used.\n+         *<p>\n+         * Note that the original JSON specification suggests use of escaping;\n+         * but that this is not correct from standard UTF-8 handling perspective.\n+         * Because of two competing goals, this feature was added to allow either\n+         * behavior to be used, but defaulting to UTF-8 specification compliant\n+         * mode.\n+         *<p>\n+         * Feature is disabled by default.\n+         *\n+         * @since 2.7\n+         */\n+//        ESCAPE_UTF8_SURROGATES(false),\n+        \n         // // Schema/Validity support features\n \n         /**\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n      */\n \n     @Override\n-    public void writeNumber(short s)\n-        throws IOException, JsonGenerationException\n+    public void writeNumber(short s) throws IOException\n     {\n         _verifyValueWrite(WRITE_NUMBER);\n         // up to 5 digits and possible minus sign\n     } \n     \n     @Override\n-    public void writeNumber(int i)\n-        throws IOException, JsonGenerationException\n+    public void writeNumber(int i) throws IOException\n     {\n         _verifyValueWrite(WRITE_NUMBER);\n         // up to 10 digits and possible minus sign\n     }    \n \n     @Override\n-    public void writeNumber(long l)\n-        throws IOException, JsonGenerationException\n+    public void writeNumber(long l) throws IOException\n     {\n         _verifyValueWrite(WRITE_NUMBER);\n         if (_cfgNumbersAsStrings) {\n     }\n \n     @Override\n-    public void writeNumber(BigInteger value)\n-        throws IOException, JsonGenerationException\n+    public void writeNumber(BigInteger value) throws IOException\n     {\n         _verifyValueWrite(WRITE_NUMBER);\n         if (value == null) {\n \n     \n     @Override\n-    public void writeNumber(double d)\n-        throws IOException, JsonGenerationException\n+    public void writeNumber(double d) throws IOException\n     {\n         if (_cfgNumbersAsStrings ||\n-            // [JACKSON-139]\n             (((Double.isNaN(d) || Double.isInfinite(d))\n-                && isEnabled(Feature.QUOTE_NON_NUMERIC_NUMBERS)))) {\n+                && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) {\n             writeString(String.valueOf(d));\n             return;\n         }\n     }\n \n     @Override\n-    public void writeNumber(float f)\n-        throws IOException, JsonGenerationException\n+    public void writeNumber(float f) throws IOException\n     {\n         if (_cfgNumbersAsStrings ||\n             // [JACKSON-139]\n             (((Float.isNaN(f) || Float.isInfinite(f))\n-                && isEnabled(Feature.QUOTE_NON_NUMERIC_NUMBERS)))) {\n+                && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) {\n             writeString(String.valueOf(f));\n             return;\n         }\n     }\n \n     @Override\n-    public void writeNumber(BigDecimal value)\n-        throws IOException, JsonGenerationException\n+    public void writeNumber(BigDecimal value) throws IOException\n     {\n         // Don't really know max length for big decimal, no point checking\n         _verifyValueWrite(WRITE_NUMBER);\n         if (value == null) {\n             _writeNull();\n         } else if (_cfgNumbersAsStrings) {\n-            String raw = isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN) ? value.toPlainString() : value.toString();\n+            String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)\n+                    ? value.toPlainString() : value.toString();\n             _writeQuotedRaw(raw);\n-        } else if (isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN)) {\n+        } else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) {\n             writeRaw(value.toPlainString());\n         } else {\n             writeRaw(value.toString());\n     }\n \n     @Override\n-    public void writeNumber(String encodedValue)\n-        throws IOException, JsonGenerationException\n+    public void writeNumber(String encodedValue) throws IOException\n     {\n         _verifyValueWrite(WRITE_NUMBER);\n         if (_cfgNumbersAsStrings) {\n     }\n     \n     @Override\n-    public void writeBoolean(boolean state)\n-        throws IOException, JsonGenerationException\n+    public void writeBoolean(boolean state) throws IOException\n     {\n         _verifyValueWrite(WRITE_BOOLEAN);\n         if ((_outputTail + 5) >= _outputEnd) {\n     }\n \n     @Override\n-    public void writeNull()\n-        throws IOException, JsonGenerationException\n+    public void writeNull() throws IOException\n     {\n         _verifyValueWrite(WRITE_NULL);\n         _writeNull();\n         return inputOffset;\n     }\n \n-    protected final void _outputSurrogates(int surr1, int surr2)\n-        throws IOException\n+    protected final void _outputSurrogates(int surr1, int surr2) throws IOException\n     {\n         int c = _decodeSurrogate(surr1, surr2);\n         if ((_outputTail + 4) > _outputEnd) {\n     {\n         byte[] bbuf = _outputBuffer;\n         if (ch >= SURR1_FIRST && ch <= SURR2_LAST) { // yes, outside of BMP; add an escape\n-            bbuf[outputPtr++] = BYTE_BACKSLASH;\n-            bbuf[outputPtr++] = BYTE_u;\n-            \n-            bbuf[outputPtr++] = HEX_CHARS[(ch >> 12) & 0xF];\n-            bbuf[outputPtr++] = HEX_CHARS[(ch >> 8) & 0xF];\n-            bbuf[outputPtr++] = HEX_CHARS[(ch >> 4) & 0xF];\n-            bbuf[outputPtr++] = HEX_CHARS[ch & 0xF];\n+            // 23-Nov-2015, tatu: As per [core#223], may or may not want escapes;\n+            //   it would be added here... but as things are, we do not have proper\n+            //   access yet...\n+//            if (Feature.ESCAPE_UTF8_SURROGATES.enabledIn(_features)) {\n+                bbuf[outputPtr++] = BYTE_BACKSLASH;\n+                bbuf[outputPtr++] = BYTE_u;\n+                \n+                bbuf[outputPtr++] = HEX_CHARS[(ch >> 12) & 0xF];\n+                bbuf[outputPtr++] = HEX_CHARS[(ch >> 8) & 0xF];\n+                bbuf[outputPtr++] = HEX_CHARS[(ch >> 4) & 0xF];\n+                bbuf[outputPtr++] = HEX_CHARS[ch & 0xF];\n+//            } else { ... }\n         } else {\n             bbuf[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n             bbuf[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n         }\n         return outputPtr;\n     }\n-    \n+\n     private final void _writeNull() throws IOException\n     {\n         if ((_outputTail + 4) >= _outputEnd) {\n      * \n      * @param charToEscape Character to escape using escape sequence (\\\\uXXXX)\n      */\n-    private int _writeGenericEscape(int charToEscape, int outputPtr)\n-        throws IOException\n+    private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException\n     {\n         final byte[] bbuf = _outputBuffer;\n         bbuf[outputPtr++] = BYTE_BACKSLASH;\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/LocationInArrayTest.java\n+package com.fasterxml.jackson.core.json;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+// Tests mostly for [core#229]\n+public class LocationInArrayTest extends com.fasterxml.jackson.core.BaseTest\n+{\n+    final JsonFactory JSON_F = new JsonFactory();\n+\n+    // for [core#229]\n+    public void testOffsetInArraysBytes() throws Exception {\n+        _testOffsetInArrays(true);\n+    }\n+    \n+    // for [core#229]\n+    public void testOffsetInArraysChars() throws Exception {\n+        _testOffsetInArrays(false);\n+    }        \n+\n+    private void _testOffsetInArrays(boolean useBytes) throws Exception\n+    {\n+        JsonParser p;\n+        final String DOC = \"  [10, 251,\\n   3  ]\";\n+\n+        // first, char based:\n+        p = useBytes ? JSON_F.createParser(DOC.getBytes(\"UTF-8\"))\n+                : JSON_F.createParser(DOC.toCharArray());\n+        assertToken(JsonToken.START_ARRAY, p.nextToken());\n+        _assertLocation(useBytes, p.getTokenLocation(), 2L, 1, 3);\n+        _assertLocation(useBytes, p.getCurrentLocation(), 3L, 1, 4);\n+\n+        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n+        _assertLocation(useBytes, p.getTokenLocation(), 3L, 1, 4);\n+        assertEquals(10, p.getIntValue()); // just to ensure read proceeds to end\n+        // 2-digits so\n+        _assertLocation(useBytes, p.getCurrentLocation(), 5L, 1, 6);\n+\n+        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n+        _assertLocation(useBytes, p.getTokenLocation(), 7L, 1, 8);\n+        assertEquals(251, p.getIntValue()); // just to ensure read proceeds to end\n+        _assertLocation(useBytes, p.getCurrentLocation(), 10L, 1, 11);\n+\n+        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n+        _assertLocation(useBytes, p.getTokenLocation(), 15L, 2, 4);\n+        assertEquals(3, p.getIntValue());\n+        _assertLocation(useBytes, p.getCurrentLocation(), 16L, 2, 5);\n+\n+        assertToken(JsonToken.END_ARRAY, p.nextToken());\n+        _assertLocation(useBytes, p.getTokenLocation(), 18L, 2, 7);\n+        _assertLocation(useBytes, p.getCurrentLocation(), 19L, 2, 8);\n+        \n+        p.close();\n+    }\n+\n+    private void _assertLocation(boolean useBytes, JsonLocation loc, long offset, int row, int col)\n+    {\n+        assertEquals(row, loc.getLineNr());\n+        assertEquals(col, loc.getColumnNr());\n+\n+        if (useBytes) {\n+            assertEquals(offset, loc.getByteOffset());\n+        } else {\n+            assertEquals(offset, loc.getCharOffset());\n+        }\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestUtf8Generator.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestUtf8Generator.java\n         p.close();\n     }\n \n-    // for [Issue#115]\n+    // for [core#115]\n     public void testSurrogatesWithRaw() throws Exception\n     {\n         final String VALUE = quote(\"\\ud83d\\ude0c\");\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/Surrogate223Test.java\n+package com.fasterxml.jackson.failing;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.StringWriter;\n+import java.io.Writer;\n+\n+import com.fasterxml.jackson.core.BaseTest;\n+import com.fasterxml.jackson.core.JsonFactory;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonToken;\n+\n+public class Surrogate223Test extends BaseTest\n+{\n+    private final JsonFactory JSON_F = new JsonFactory();\n+    \n+    // for [core#223]\n+    public void testSurrogatesByteBacked() throws Exception\n+    {\n+        ByteArrayOutputStream out;\n+        JsonGenerator g;\n+        final String toQuote = new String(Character.toChars(0x1F602));\n+        assertEquals(2, toQuote.length()); // just sanity check\n+\n+        // default should be disabled:\n+//        assertFalse(JSON_F.isEnabled(JsonGenerator.Feature.ESCAPE_UTF8_SURROGATES));\n+\n+        out = new ByteArrayOutputStream();\n+        g = JSON_F.createGenerator(out);\n+        g.writeStartArray();\n+        g.writeString(toQuote);\n+        g.writeEndArray();\n+        g.close();\n+        assertEquals(2 + 2 + 4, out.size()); // brackets, quotes, 4-byte encoding\n+\n+        // Also parse back to ensure correctness\n+        JsonParser p = JSON_F.createParser(out.toByteArray());\n+        assertToken(JsonToken.START_ARRAY, p.nextToken());\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertToken(JsonToken.END_ARRAY, p.nextToken());\n+        p.close();\n+        \n+        // but may revert back to original behavior\n+        out = new ByteArrayOutputStream();\n+        g = JSON_F.createGenerator(out);\n+//        g.enable(JsonGenerator.Feature.ESCAPE_UTF8_SURROGATES);\n+        g.writeStartArray();\n+        g.writeString(toQuote);\n+        g.writeEndArray();\n+        g.close();\n+        assertEquals(2 + 2 + 12, out.size()); // brackets, quotes, 2 x 6 byte JSON escape\n+    }\n+\n+    // for [core#223]\n+    public void testSurrogatesCharBacked() throws Exception\n+    {\n+        Writer out;\n+        JsonGenerator g;\n+        final String toQuote = new String(Character.toChars(0x1F602));\n+        assertEquals(2, toQuote.length()); // just sanity check\n+\n+        // default should be disabled:\n+//        assertFalse(JSON_F.isEnabled(JsonGenerator.Feature.ESCAPE_UTF8_SURROGATES));\n+\n+        out = new StringWriter();\n+        g = JSON_F.createGenerator(out);\n+        g.writeStartArray();\n+        g.writeString(toQuote);\n+        g.writeEndArray();\n+        g.close();\n+        assertEquals(2 + 2 + 2, out.toString().length()); // brackets, quotes, 2 chars as is\n+\n+        // Also parse back to ensure correctness\n+        JsonParser p = JSON_F.createParser(out.toString());\n+        assertToken(JsonToken.START_ARRAY, p.nextToken());\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertToken(JsonToken.END_ARRAY, p.nextToken());\n+        p.close();\n+        \n+        // but may revert back to original behavior\n+        out = new StringWriter();\n+        g = JSON_F.createGenerator(out);\n+//        g.enable(JsonGenerator.Feature.ESCAPE_UTF8_SURROGATES);\n+        g.writeStartArray();\n+        g.writeString(toQuote);\n+        g.writeEndArray();\n+        g.close();\n+        assertEquals(2 + 2 + 12, out.toString().length()); // brackets, quotes, 2 x 6 byte JSON escape\n+    }\n+}", "timestamp": 1448347822, "metainfo": ""}