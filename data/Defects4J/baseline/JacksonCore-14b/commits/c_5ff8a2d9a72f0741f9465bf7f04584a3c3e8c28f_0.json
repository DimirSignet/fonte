{"sha": "5ff8a2d9a72f0741f9465bf7f04584a3c3e8c28f", "log": "Add unit tests from 1.x, all but 2 passing", "commit": "\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/TestVersions.java\n+package com.fasterxml.jackson.core;\n+\n+import com.fasterxml.jackson.core.json.*;\n+import com.fasterxml.jackson.core.io.IOContext;\n+import com.fasterxml.jackson.core.util.BufferRecycler;\n+\n+/**\n+ * Tests to verify [JACKSON-278]\n+ */\n+public class TestVersions extends com.fasterxml.jackson.test.BaseTest\n+{\n+    /**\n+     * 18-Nov-2010, tatu: Not a good to do this, but has to do, for now...\n+     */\n+    private final static int MAJOR_VERSION = 2;\n+    private final static int MINOR_VERSION = 0;\n+    \n+    public void testCoreVersions()\n+    {\n+        /* 01-Sep-2010, tatu: Somewhat of a dirty hack; let's only run when specific system\n+         *    property is set; and set that flag from Ant unit test. Why? To prevent running\n+         *    from Eclipse, where this would just fail\n+         */\n+        if (runsFromAnt()) {\n+            System.out.println(\"Note: running version tests (FROM_ANT=true)\");\n+            assertVersion(new JsonFactory().version(), MAJOR_VERSION, MINOR_VERSION);\n+            assertVersion(new ReaderBasedJsonParser(getIOContext(), 0, null, null, null).version(),\n+                    MAJOR_VERSION, MINOR_VERSION);\n+            assertVersion(new WriterBasedJsonGenerator(getIOContext(), 0, null, null).version(),\n+                    MAJOR_VERSION, MINOR_VERSION);\n+        } else {\n+            System.out.println(\"Skipping version test (FROM_ANT=false)\");\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+    \n+    private void assertVersion(Version v, int major, int minor)\n+    {\n+        assertFalse(\"Should find version information (got \"+v+\")\", v.isUknownVersion());\n+        assertEquals(major, v.getMajorVersion());\n+        assertEquals(minor, v.getMinorVersion());\n+        // 07-Jan-2011, tatus: Check patch level initially, comment out for maint versions\n+\n+        //assertEquals(0, v.getPatchLevel());\n+    }\n+\n+    private IOContext getIOContext() {\n+        return new IOContext(new BufferRecycler(), null, false);\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/format/TestJsonFormatDetection.java\n+package com.fasterxml.jackson.core.format;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.format.DataFormatDetector;\n+import com.fasterxml.jackson.core.format.DataFormatMatcher;\n+import com.fasterxml.jackson.core.format.MatchStrength;\n+\n+public class TestJsonFormatDetection extends com.fasterxml.jackson.test.BaseTest\n+{\n+    public void testSimpleValidArray() throws Exception\n+    {\n+        JsonFactory jsonF = new JsonFactory();\n+        DataFormatDetector detector = new DataFormatDetector(jsonF);\n+        final String ARRAY_JSON = \"[ 1, 2 ]\";\n+        DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(ARRAY_JSON.getBytes(\"UTF-8\")));\n+        // should have match\n+        assertTrue(matcher.hasMatch());\n+        assertEquals(\"JSON\", matcher.getMatchedFormatName());\n+        assertSame(jsonF, matcher.getMatch());\n+        // no \"certain\" match with JSON, but solid:\n+        assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength());\n+        // and thus:\n+        JsonParser jp = matcher.createParserWithMatch();\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        assertNull(jp.nextToken());\n+        jp.close();\n+    }\n+\n+    public void testSimpleValidObject() throws Exception\n+    {\n+        JsonFactory jsonF = new JsonFactory();\n+        DataFormatDetector detector = new DataFormatDetector(jsonF);\n+        final String JSON = \"{  \\\"field\\\" : true }\";\n+        DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\")));\n+        // should have match\n+        assertTrue(matcher.hasMatch());\n+        assertEquals(\"JSON\", matcher.getMatchedFormatName());\n+        assertSame(jsonF, matcher.getMatch());\n+        // no \"certain\" match with JSON, but solid:\n+        assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength());\n+        // and thus:\n+        JsonParser jp = matcher.createParserWithMatch();\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"field\", jp.getCurrentName());\n+        assertToken(JsonToken.VALUE_TRUE, jp.nextToken());\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+        assertNull(jp.nextToken());\n+        jp.close();\n+    }\n+\n+    /**\n+     * While JSON String is not a strong match alone, it should\n+     * be detected unless some better match is available\n+     */\n+    public void testSimpleValidString() throws Exception\n+    {\n+        JsonFactory jsonF = new JsonFactory();\n+        DataFormatDetector detector = new DataFormatDetector(jsonF);\n+        final String JSON = \"\\\"JSON!\\\"\";\n+        DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\")));\n+        // should have match\n+        assertTrue(matcher.hasMatch());\n+        assertEquals(\"JSON\", matcher.getMatchedFormatName());\n+        assertSame(jsonF, matcher.getMatch());\n+        assertEquals(MatchStrength.WEAK_MATCH, matcher.getMatchStrength());\n+        JsonParser jp = matcher.createParserWithMatch();\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(\"JSON!\", jp.getText());\n+        assertNull(jp.nextToken());\n+        jp.close();\n+    }\n+    \n+    public void testSimpleInvalid() throws Exception\n+    {\n+        DataFormatDetector detector = new DataFormatDetector(new JsonFactory());\n+        final String NON_JSON = \"<root />\";\n+        DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(NON_JSON.getBytes(\"UTF-8\")));\n+        // should not have match\n+        assertFalse(matcher.hasMatch());\n+        // and thus:\n+        assertEquals(MatchStrength.INCONCLUSIVE, matcher.getMatchStrength());\n+        // also:\n+        assertNull(matcher.createParserWithMatch());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/io/TestIOContext.java\n+package com.fasterxml.jackson.core.io;\n+\n+import com.fasterxml.jackson.core.io.IOContext;\n+import com.fasterxml.jackson.core.util.BufferRecycler;\n+\n+public class TestIOContext\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    public void testAllocations() throws Exception\n+    {\n+        IOContext ctxt = new IOContext(new BufferRecycler(), \"N/A\", true);\n+\n+        /* I/O Read buffer */\n+\n+        // First succeeds:\n+        assertNotNull(ctxt.allocReadIOBuffer());\n+        // second fails\n+        try {\n+            ctxt.allocReadIOBuffer();\n+        } catch (IllegalStateException e) {\n+            verifyException(e, \"second time\");\n+        }\n+        // Also: can't succeed with different buffer\n+        try {\n+            ctxt.releaseReadIOBuffer(new byte[1]);\n+        } catch (IllegalArgumentException e) {\n+            verifyException(e, \"not owned\");\n+        }\n+        // but call with null is a NOP for convenience\n+        ctxt.releaseReadIOBuffer(null);\n+\n+        /* I/O Write buffer */\n+\n+        assertNotNull(ctxt.allocWriteEncodingBuffer());\n+        try {\n+            ctxt.allocWriteEncodingBuffer();\n+        } catch (IllegalStateException e) {\n+            verifyException(e, \"second time\");\n+        }\n+        try {\n+            ctxt.releaseWriteEncodingBuffer(new byte[1]);\n+        } catch (IllegalArgumentException e) {\n+            verifyException(e, \"not owned\");\n+        }\n+        ctxt.releaseWriteEncodingBuffer(null);\n+\n+        /* Token (read) buffer */\n+\n+        assertNotNull(ctxt.allocTokenBuffer());\n+        try {\n+            ctxt.allocTokenBuffer();\n+        } catch (IllegalStateException e) {\n+            verifyException(e, \"second time\");\n+        }\n+        try {\n+            ctxt.releaseTokenBuffer(new char[1]);\n+        } catch (IllegalArgumentException e) {\n+            verifyException(e, \"not owned\");\n+        }\n+        ctxt.releaseTokenBuffer(null);\n+\n+        /* Concat (write?) buffer */\n+\n+        assertNotNull(ctxt.allocConcatBuffer());\n+        try {\n+            ctxt.allocConcatBuffer();\n+        } catch (IllegalStateException e) {\n+            verifyException(e, \"second time\");\n+        }\n+        try {\n+            ctxt.releaseConcatBuffer(new char[1]);\n+        } catch (IllegalArgumentException e) {\n+            verifyException(e, \"not owned\");\n+        }\n+        ctxt.releaseConcatBuffer(null);\n+\n+        /* NameCopy (write?) buffer */\n+\n+        assertNotNull(ctxt.allocNameCopyBuffer(100));\n+        try {\n+            ctxt.allocNameCopyBuffer(100);\n+        } catch (IllegalStateException e) {\n+            verifyException(e, \"second time\");\n+        }\n+        try {\n+            ctxt.releaseNameCopyBuffer(new char[1]);\n+        } catch (IllegalArgumentException e) {\n+            verifyException(e, \"not owned\");\n+        }\n+        ctxt.releaseNameCopyBuffer(null);\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/io/TestJsonStringEncoder.java\n+package com.fasterxml.jackson.core.io;\n+\n+import java.io.StringWriter;\n+import java.util.Random;\n+\n+import static org.junit.Assert.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.io.JsonStringEncoder;\n+\n+public class TestJsonStringEncoder\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    public void testQuoteAsString() throws Exception\n+    {\n+        JsonStringEncoder encoder = new JsonStringEncoder();\n+        char[] result = encoder.quoteAsString(\"foobar\");\n+        assertArrayEquals(\"foobar\".toCharArray(), result);\n+        result = encoder.quoteAsString(\"\\\"x\\\"\");\n+        assertArrayEquals(\"\\\\\\\"x\\\\\\\"\".toCharArray(), result);\n+    }\n+\n+    public void testQuoteAsUTF8() throws Exception\n+    {\n+        // In this case, let's actually use existing JsonGenerator to produce expected values\n+        JsonFactory f = new JsonFactory();\n+        JsonStringEncoder encoder = new JsonStringEncoder();\n+        int[] lengths = new int[] {\n+            5, 19, 200, 7000, 21000, 37000\n+        };\n+        for (int length : lengths) {\n+            String str = generateRandom(length);\n+            StringWriter sw = new StringWriter(length*2);\n+            JsonGenerator jgen = f.createJsonGenerator(sw);\n+            jgen.writeString(str);\n+            jgen.close();\n+            String encoded = sw.toString();\n+            // ok, except need to remove surrounding quotes\n+            encoded = encoded.substring(1, encoded.length() - 1);\n+            byte[] expected = encoded.getBytes(\"UTF-8\");\n+            byte[] actual = encoder.quoteAsUTF8(str);\n+            assertArrayEquals(expected, actual);\n+        }\n+    }\n+\n+    public void testEncodeAsUTF8() throws Exception\n+    {\n+        JsonStringEncoder encoder = new JsonStringEncoder();\n+        String[] strings = new String[] {\n+                \"a\", \"foobar\", \"p\\u00f6ll\\u00f6\", \"\\\"foo\\\"\",\n+                generateRandom(200),\n+                generateRandom(5000),\n+                generateRandom(39000)\n+        };\n+        for (String str : strings) {\n+            assertArrayEquals(str.getBytes(\"UTF-8\"), encoder.encodeAsUTF8(str));\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    \n+    private String generateRandom(int length)\n+    {\n+        StringBuilder sb = new StringBuilder(length);\n+        Random rnd = new Random(length);\n+        for (int i = 0; i < length; ++i) {\n+            // let's limit it not to include surrogate pairs:\n+            char ch = (char) rnd.nextInt(0xCFFF);\n+            sb.append(ch);\n+        }\n+        return sb.toString();\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/io/TestMergedStream.java\n+package com.fasterxml.jackson.core.io;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.JsonEncoding;\n+import com.fasterxml.jackson.core.io.IOContext;\n+import com.fasterxml.jackson.core.io.MergedStream;\n+import com.fasterxml.jackson.core.util.BufferRecycler;\n+\n+public class TestMergedStream\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    public void testSimple() throws Exception\n+    {\n+        BufferRecycler rec = new BufferRecycler();\n+        IOContext ctxt = new IOContext(rec, null, false);\n+        // bit complicated; must use recyclable buffer...\n+        byte[] first = ctxt.allocReadIOBuffer();\n+        System.arraycopy(\"ABCDE\".getBytes(\"UTF-8\"), 0, first, 99, 5);\n+        byte[] second = \"FGHIJ\".getBytes(\"UTF-8\");\n+\n+        assertNull(ctxt.getSourceReference());\n+        assertFalse(ctxt.isResourceManaged());\n+        ctxt.setEncoding(JsonEncoding.UTF8);\n+        MergedStream ms = new MergedStream(ctxt, new ByteArrayInputStream(second),\n+                                           first, 99, 99+5);\n+        // Ok, first, should have 5 bytes from first buffer:\n+        assertEquals(5, ms.available());\n+        // not supported when there's buffered stuff...\n+        assertFalse(ms.markSupported());\n+        // so this won't work, but shouldn't throw exception\n+        ms.mark(1);\n+        assertEquals((byte) 'A', ms.read());\n+        assertEquals(3, ms.skip(3));\n+        byte[] buffer = new byte[5];\n+        /* Ok, now, code is allowed to return anywhere between 1 and 3,\n+         * but we now it will return 1...\n+         */\n+        assertEquals(1, ms.read(buffer, 1, 3));\n+        assertEquals((byte) 'E', buffer[1]);\n+        // So let's read bit more\n+        assertEquals(3, ms.read(buffer, 0, 3));\n+        assertEquals((byte) 'F', buffer[0]);\n+        assertEquals((byte) 'G', buffer[1]);\n+        assertEquals((byte) 'H', buffer[2]);\n+        assertEquals(2, ms.available());\n+        // And then skip the reset\n+        assertEquals(2, ms.skip(200));\n+\n+        ms.close();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/io/TestUTF8Writer.java\n+package com.fasterxml.jackson.core.io;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.io.IOContext;\n+import com.fasterxml.jackson.core.io.UTF8Writer;\n+import com.fasterxml.jackson.core.util.BufferRecycler;\n+\n+public class TestUTF8Writer\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    public void testSimple() throws Exception\n+    {\n+        BufferRecycler rec = new BufferRecycler();\n+        IOContext ctxt = new IOContext(rec, null, false);\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        UTF8Writer w = new UTF8Writer(ctxt, out);\n+\n+        String str = \"AB\\u00A0\\u1AE9\\uFFFC\";\n+        char[] ch = str.toCharArray();\n+\n+        // Let's write 3 times, using different methods\n+        w.write(str);\n+\n+        w.append(ch[0]);\n+        w.write(ch[1]);\n+        w.write(ch, 2, 3);\n+\n+        w.write(str, 0, str.length());\n+        w.close();\n+\n+        // and thus should have 3 times contents\n+        byte[] data = out.toByteArray();\n+        assertEquals(3*10, data.length);\n+        String act = out.toString(\"UTF-8\");\n+        assertEquals(15, act.length());\n+\n+        assertEquals(3 * str.length(), act.length());\n+        assertEquals(str+str+str, act);\n+    }\n+\n+    public void testFlushAfterClose() throws Exception\n+    {\n+        BufferRecycler rec = new BufferRecycler();\n+        IOContext ctxt = new IOContext(rec, null, false);\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        UTF8Writer w = new UTF8Writer(ctxt, out);\n+        \n+        w.write('X');\n+        \n+        w.close();\n+        assertEquals(1, out.size());\n+\n+        // and this ought to be fine...\n+        w.flush();\n+        // as well as some more...\n+        w.close();\n+        w.flush();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestBase64Codec.java\n+package com.fasterxml.jackson.core.json;\n+\n+import org.junit.Assert;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+public class TestBase64Codec\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    public void testProps()\n+    {\n+        Base64Variant std = Base64Variants.MIME;\n+        // let's verify basic props of std cocec\n+        assertEquals(\"MIME\", std.getName());\n+        assertEquals(\"MIME\", std.toString());\n+        assertTrue(std.usesPadding());\n+        assertFalse(std.usesPaddingChar('X'));\n+        assertEquals('=', std.getPaddingChar());\n+        assertTrue(std.usesPaddingChar('='));\n+        assertEquals((byte) '=', std.getPaddingByte());\n+        assertEquals(76, std.getMaxLineLength());\n+    }\n+\n+    public void testCharEncoding() throws Exception\n+    {\n+        Base64Variant std = Base64Variants.MIME;\n+        assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char('?'));\n+        assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char((int) '?'));\n+        assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char((byte) '?'));\n+\n+        assertEquals(0, std.decodeBase64Char('A'));\n+        assertEquals(1, std.decodeBase64Char((int) 'B'));\n+        assertEquals(2, std.decodeBase64Char((byte)'C'));\n+\n+        assertEquals('/', std.encodeBase64BitsAsChar(63));\n+        assertEquals((byte) 'b', std.encodeBase64BitsAsByte(27));\n+\n+        String EXP_STR = \"HwdJ\";\n+        int TRIPLET = 0x1F0749;\n+        StringBuilder sb = new StringBuilder();\n+        std.encodeBase64Chunk(sb, TRIPLET);\n+        assertEquals(EXP_STR, sb.toString());\n+\n+        byte[] exp = EXP_STR.getBytes(\"UTF-8\");\n+        byte[] act = new byte[exp.length];\n+        std.encodeBase64Chunk(TRIPLET, act, 0);\n+        Assert.assertArrayEquals(exp, act);\n+    }\n+\n+    public void testErrors() throws Exception\n+    {\n+        try {\n+            new Base64Variant(\"foobar\", \"xyz\", false, '!', 24);\n+        } catch (IllegalArgumentException iae) {\n+            verifyException(iae, \"length must be exactly\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestBase64Parsing.java\n+package com.fasterxml.jackson.core.json;\n+\n+import static org.junit.Assert.assertArrayEquals;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+public class TestBase64Parsing\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    public void testBase64UsingInputStream() throws Exception\n+    {\n+        _testBase64Text(true);\n+    }\n+\n+    public void testBase64UsingReader() throws Exception\n+    {\n+        _testBase64Text(false);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test helper methods\n+    /**********************************************************\n+     */\n+    \n+    // Test for [JACKSON-631]\n+    public void _testBase64Text(boolean useBytes) throws Exception\n+    {\n+        // let's actually iterate over sets of encoding modes, lengths\n+        \n+        final int[] LENS = { 1, 2, 3, 4, 7, 9, 32, 33, 34, 35 };\n+        final Base64Variant[] VARIANTS = {\n+                Base64Variants.MIME,\n+                Base64Variants.MIME_NO_LINEFEEDS,\n+                Base64Variants.MODIFIED_FOR_URL,\n+                Base64Variants.PEM\n+        };\n+\n+        JsonFactory jsonFactory = new JsonFactory();\n+        final ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n+        StringWriter chars = null;\n+        for (int len : LENS) {\n+            byte[] input = new byte[len];\n+            for (int i = 0; i < input.length; ++i) {\n+                input[i] = (byte) i;\n+            }\n+            for (Base64Variant variant : VARIANTS) {\n+                JsonGenerator jgen;\n+                if (useBytes) {\n+                    bytes.reset();\n+                    jgen = jsonFactory.createJsonGenerator(bytes, JsonEncoding.UTF8);\n+                } else {\n+                    chars = new StringWriter();\n+                    jgen = jsonFactory.createJsonGenerator(chars);\n+                }\n+                jgen.writeBinary(variant, input, 0, input.length);\n+                jgen.close();\n+                JsonParser jp;\n+                if (useBytes) {\n+                    jp = jsonFactory.createJsonParser(bytes.toByteArray());\n+                } else {\n+                    jp = jsonFactory.createJsonParser(chars.toString());\n+                }\n+                assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+                byte[] data = null;\n+                try {\n+                    data = jp.getBinaryValue(variant);\n+                } catch (Exception e) {\n+                    throw new IOException(\"Failed (variant \"+variant+\", data length \"+len+\"): \"+e.getMessage(), e);\n+                }\n+                assertNotNull(data);\n+                assertArrayEquals(data, input);\n+                assertNull(jp.nextToken());\n+                jp.close();\n+            }\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestByteBasedSymbols.java\n+package com.fasterxml.jackson.core.json;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.sym.BytesToNameCanonicalizer;\n+import com.fasterxml.jackson.core.sym.Name;\n+\n+/**\n+ * Unit test(s) to verify that handling of (byte-based) symbol tables\n+ * is working. Created to verify fix to [JACKSON-5] (although not very\n+ * good at catching it...).\n+ */\n+public class TestByteBasedSymbols\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    final static String[] FIELD_NAMES = new String[] {\n+        \"a\", \"b\", \"c\", \"x\", \"y\", \"b13\", \"abcdefg\", \"a123\",\n+        \"a0\", \"b0\", \"c0\", \"d0\", \"e0\", \"f0\", \"g0\", \"h0\",\n+        \"x2\", \"aa\", \"ba\", \"ab\", \"b31\", \"___x\", \"aX\", \"xxx\",\n+        \"a2\", \"b2\", \"c2\", \"d2\", \"e2\", \"f2\", \"g2\", \"h2\",\n+        \"a3\", \"b3\", \"c3\", \"d3\", \"e3\", \"f3\", \"g3\", \"h3\",\n+        \"a1\", \"b1\", \"c1\", \"d1\", \"e1\", \"f1\", \"g1\", \"h1\",\n+    };\n+\n+    /**\n+     * This unit test checks that [JACKSON-5] is fixed; if not, a\n+     * symbol table corruption should result in odd problems.\n+     */\n+    public void testSharedSymbols()\n+        throws Exception\n+    {\n+        // MUST share a single json factory\n+        JsonFactory jf = new JsonFactory();\n+\n+        /* First things first: parse a dummy doc to populate\n+         * shared symbol table with some stuff\n+         */\n+        String DOC0 = \"{ \\\"a\\\" : 1, \\\"x\\\" : [ ] }\";\n+        JsonParser jp0 = createParser(jf, DOC0);\n+\n+        /* Important: don't close, don't traverse past end.\n+         * This is needed to create partial still-in-use symbol\n+         * table...\n+         */\n+        while (jp0.nextToken() != JsonToken.START_ARRAY) { }\n+\n+        String doc1 = createDoc(FIELD_NAMES, true);\n+        String doc2 = createDoc(FIELD_NAMES, false);\n+\n+        // Let's run it twice... shouldn't matter\n+        for (int x = 0; x < 2; ++x) {\n+            JsonParser jp1 = createParser(jf, doc1);\n+            JsonParser jp2 = createParser(jf, doc2);\n+\n+            assertToken(JsonToken.START_OBJECT, jp1.nextToken());\n+            assertToken(JsonToken.START_OBJECT, jp2.nextToken());\n+            \n+            int len = FIELD_NAMES.length;\n+            for (int i = 0; i < len; ++i) {\n+                assertToken(JsonToken.FIELD_NAME, jp1.nextToken());\n+                assertToken(JsonToken.FIELD_NAME, jp2.nextToken());\n+                assertEquals(FIELD_NAMES[i], jp1.getCurrentName());\n+                assertEquals(FIELD_NAMES[len-(i+1)], jp2.getCurrentName());\n+                assertToken(JsonToken.VALUE_NUMBER_INT, jp1.nextToken());\n+                assertToken(JsonToken.VALUE_NUMBER_INT, jp2.nextToken());\n+                assertEquals(i, jp1.getIntValue());\n+                assertEquals(i, jp2.getIntValue());\n+            }\n+            \n+            assertToken(JsonToken.END_OBJECT, jp1.nextToken());\n+            assertToken(JsonToken.END_OBJECT, jp2.nextToken());\n+            \n+            jp1.close();\n+            jp2.close();\n+        }\n+    }\n+\n+    public void testAuxMethods()\n+        throws Exception\n+    {\n+        final int A_BYTES = 0x41414141; // \"AAAA\"\n+        final int B_BYTES = 0x42424242; // \"BBBB\"\n+\n+        BytesToNameCanonicalizer nc = BytesToNameCanonicalizer.createRoot();\n+        assertNull(nc.findName(A_BYTES));\n+        assertNull(nc.findName(A_BYTES, B_BYTES));\n+\n+        nc.addName(\"AAAA\", new int[] { A_BYTES }, 1);\n+        Name n1 = nc.findName(A_BYTES);\n+        assertNotNull(n1);\n+        assertEquals(\"AAAA\", n1.getName());\n+        nc.addName(\"AAAABBBB\", new int[] { A_BYTES, B_BYTES }, 2);\n+        Name n2 = nc.findName(A_BYTES, B_BYTES);\n+        assertEquals(\"AAAABBBB\", n2.getName());\n+        assertNotNull(n2);\n+\n+        /* and let's then just exercise this method so it gets covered;\n+         * it's only used for debugging.\n+         */\n+        assertNotNull(nc.toString());\n+    }\n+\n+    /*\n+    ////////////////////////////////////////////\n+    // Helper methods\n+    ////////////////////////////////////////////\n+     */\n+\n+    protected JsonParser createParser(JsonFactory jf, String input)\n+        throws IOException, JsonParseException\n+    {\n+        byte[] data = input.getBytes(\"UTF-8\");\n+        InputStream is = new ByteArrayInputStream(data);\n+        return jf.createJsonParser(is);\n+    }\n+\n+    private String createDoc(String[] fieldNames, boolean add)\n+    {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"{ \");\n+\n+        int len = fieldNames.length;\n+        for (int i = 0; i < len; ++i) {\n+            if (i > 0) {\n+                sb.append(\", \");\n+            }\n+            sb.append('\"');\n+            sb.append(add ? fieldNames[i] : fieldNames[len - (i+1)]);\n+            sb.append(\"\\\" : \");\n+            sb.append(i);\n+        }\n+        sb.append(\" }\");\n+        return sb.toString();\n+    }\n+}\n+\n+\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestCustomEscaping.java\n+package com.fasterxml.jackson.core.json;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.io.CharacterEscapes;\n+import com.fasterxml.jackson.core.io.SerializedString;\n+\n+public class TestCustomEscaping  extends com.fasterxml.jackson.test.BaseTest\n+{\n+    final static int TWO_BYTE_ESCAPED = 0x111;\n+    final static int THREE_BYTE_ESCAPED = 0x1111;\n+\n+    final static SerializedString TWO_BYTE_ESCAPED_STRING = new SerializedString(\"&111;\");\n+    final static SerializedString THREE_BYTE_ESCAPED_STRING = new SerializedString(\"&1111;\");\n+    \n+    /*\n+    /********************************************************\n+    /* Helper types\n+    /********************************************************\n+     */\n+\n+    /**\n+     * Trivial simple custom escape definition set.\n+     */\n+    static class MyEscapes extends CharacterEscapes\n+    {\n+        \n+        private final int[] _asciiEscapes;\n+\n+        public MyEscapes() {\n+            _asciiEscapes = standardAsciiEscapesForJSON();\n+            _asciiEscapes['a'] = 'A'; // to basically give us \"\\A\"\n+            _asciiEscapes['b'] = CharacterEscapes.ESCAPE_STANDARD; // too force \"\\u0062\"\n+            _asciiEscapes['d'] = CharacterEscapes.ESCAPE_CUSTOM;\n+        }\n+        \n+        @Override\n+        public int[] getEscapeCodesForAscii() {\n+            return _asciiEscapes;\n+        }\n+\n+        @Override\n+        public SerializableString getEscapeSequence(int ch)\n+        {\n+            if (ch == 'd') {\n+                return new SerializedString(\"[D]\");\n+            }\n+            if (ch == TWO_BYTE_ESCAPED) {\n+                return TWO_BYTE_ESCAPED_STRING;\n+            }\n+            if (ch == THREE_BYTE_ESCAPED) {\n+                return THREE_BYTE_ESCAPED_STRING;\n+            }\n+            return null;\n+        }\n+    }\n+    \n+    /*\n+    /********************************************************\n+    /* Unit tests\n+    /********************************************************\n+     */\n+\n+    /**\n+     * Test to ensure that it is possible to force escaping\n+     * of non-ASCII characters.\n+     * Related to [JACKSON-102]\n+     */\n+    public void testAboveAsciiEscapeWithReader() throws Exception\n+    {\n+        _testEscapeAboveAscii(false); // reader\n+    }\n+\n+    public void testAboveAsciiEscapeWithUTF8Stream() throws Exception\n+    {\n+        _testEscapeAboveAscii(true); // stream (utf-8)\n+    }\n+\n+    // // // Tests for [JACKSON-106]\n+    \n+    public void testEscapeCustomWithReader() throws Exception\n+    {\n+        _testEscapeCustom(false); // reader\n+    }\n+\n+    public void testEscapeCustomWithUTF8Stream() throws Exception\n+    {\n+        _testEscapeCustom(true); // stream (utf-8)\n+    }\n+    \n+    /*\n+    /********************************************************\n+    /* Secondary test methods\n+    /********************************************************\n+     */\n+\n+    private void _testEscapeAboveAscii(boolean useStream) throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+        final String VALUE = \"chars: [\\u00A0]/[\\u1234]\";\n+        final String KEY = \"fun:\\u0088:\\u3456\";\n+        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n+        JsonGenerator jgen;\n+\n+        // First: output normally; should not add escaping\n+        if (useStream) {\n+            jgen = f.createJsonGenerator(bytes, JsonEncoding.UTF8);\n+        } else {\n+            jgen = f.createJsonGenerator(new OutputStreamWriter(bytes, \"UTF-8\"));\n+        }\n+        jgen.writeStartArray();\n+        jgen.writeString(VALUE);\n+        jgen.writeEndArray();\n+        jgen.close();\n+        String json = bytes.toString(\"UTF-8\");\n+        \n+        assertEquals(\"[\"+quote(VALUE)+\"]\", json);\n+\n+        // And then with forced ASCII; first, values\n+\n+        bytes = new ByteArrayOutputStream();\n+        if (useStream) {\n+            jgen = f.createJsonGenerator(bytes, JsonEncoding.UTF8);\n+        } else {\n+            jgen = f.createJsonGenerator(new OutputStreamWriter(bytes, \"UTF-8\"));\n+        }\n+        jgen.enable(JsonGenerator.Feature.ESCAPE_NON_ASCII);\n+        jgen.writeStartArray();\n+        jgen.writeString(VALUE);\n+        jgen.writeEndArray();\n+        jgen.close();\n+        json = bytes.toString(\"UTF-8\");\n+        assertEquals(\"[\"+quote(\"chars: [\\\\u00A0]/[\\\\u1234]\")+\"]\", json);\n+\n+        // and then keys\n+        bytes = new ByteArrayOutputStream();\n+        if (useStream) {\n+            jgen = f.createJsonGenerator(bytes, JsonEncoding.UTF8);\n+        } else {\n+            jgen = f.createJsonGenerator(new OutputStreamWriter(bytes, \"UTF-8\"));\n+        }\n+        jgen.enable(JsonGenerator.Feature.ESCAPE_NON_ASCII);\n+        jgen.writeStartObject();\n+        jgen.writeFieldName(KEY);\n+        jgen.writeBoolean(true);\n+        jgen.writeEndObject();\n+        jgen.close();\n+        json = bytes.toString(\"UTF-8\");\n+        assertEquals(\"{\"+quote(\"fun:\\\\u0088:\\\\u3456\")+\":true}\", json);\n+    }\n+\n+    private void _testEscapeCustom(boolean useStream) throws Exception\n+    {\n+        JsonFactory f = new JsonFactory().setCharacterEscapes(new MyEscapes());\n+        final String STR_IN = \"[abcd/\"+((char) TWO_BYTE_ESCAPED)+\"/\"+((char) THREE_BYTE_ESCAPED)+\"]\";\n+        final String STR_OUT = \"[\\\\A\\\\u0062c[D]/\"+TWO_BYTE_ESCAPED_STRING+\"/\"+THREE_BYTE_ESCAPED_STRING+\"]\";\n+        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n+        JsonGenerator jgen;\n+        \n+        // First: output normally; should not add escaping\n+        if (useStream) {\n+            jgen = f.createJsonGenerator(bytes, JsonEncoding.UTF8);\n+        } else {\n+            jgen = f.createJsonGenerator(new OutputStreamWriter(bytes, \"UTF-8\"));\n+        }\n+        jgen.writeStartObject();\n+        jgen.writeStringField(STR_IN, STR_IN);\n+        jgen.writeEndObject();\n+        jgen.close();\n+        String json = bytes.toString(\"UTF-8\");\n+        assertEquals(\"{\"+quote(STR_OUT)+\":\"+quote(STR_OUT)+\"}\", json);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestDecorators.java\n+package com.fasterxml.jackson.core.json;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.io.IOContext;\n+import com.fasterxml.jackson.core.io.InputDecorator;\n+import com.fasterxml.jackson.core.io.OutputDecorator;\n+\n+/**\n+ * Unit tests to verify that input and output decorators work as\n+ * expected\n+ * \n+ * @since 1.8\n+ */\n+public class TestDecorators extends com.fasterxml.jackson.test.BaseTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    static class SimpleInputDecorator extends InputDecorator\n+    {\n+        @Override\n+        public InputStream decorate(IOContext ctxt, InputStream in)\n+            throws IOException\n+        {\n+            return new ByteArrayInputStream(\"123\".getBytes(\"UTF-8\"));\n+        }\n+\n+        @Override\n+        public InputStream decorate(IOContext ctxt, byte[] src, int offset, int length)\n+            throws IOException\n+        {\n+            return new ByteArrayInputStream(\"456\".getBytes(\"UTF-8\"));\n+        }\n+\n+        @Override\n+        public Reader decorate(IOContext ctxt, Reader src) {\n+            return new StringReader(\"789\");\n+        }\n+    }\n+\n+    static class SimpleOutputDecorator extends OutputDecorator\n+    {\n+        @Override\n+        public OutputStream decorate(IOContext ctxt, OutputStream out) throws IOException\n+        {\n+            out.write(\"123\".getBytes(\"UTF-8\"));\n+            out.flush();\n+            return new ByteArrayOutputStream();\n+        }\n+\n+        @Override\n+        public Writer decorate(IOContext ctxt, Writer w) throws IOException\n+        {\n+            w.write(\"567\");\n+            w.flush();\n+            return new StringWriter();\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testInputDecoration() throws IOException\n+    {\n+        JsonFactory f = new JsonFactory();\n+        f.setInputDecorator(new SimpleInputDecorator());\n+        JsonParser jp;\n+        // first test with Reader\n+        jp = f.createJsonParser(new StringReader(\"{ }\"));\n+        // should be overridden;\n+        assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(789, jp.getIntValue());\n+        jp.close();\n+\n+        // similarly with InputStream\n+        jp = f.createJsonParser(new ByteArrayInputStream(\"[ ]\".getBytes(\"UTF-8\")));\n+        // should be overridden;\n+        assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(123, jp.getIntValue());\n+        jp.close();\n+\n+        // and with raw bytes\n+        jp = f.createJsonParser(\"[ ]\".getBytes(\"UTF-8\"));\n+        // should be overridden;\n+        assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(456, jp.getIntValue());\n+        jp.close();\n+    }\n+\n+    public void testOutputDecoration() throws IOException\n+    {\n+        JsonFactory f = new JsonFactory();\n+        f.setOutputDecorator(new SimpleOutputDecorator());\n+        JsonGenerator jg;\n+\n+        StringWriter sw = new StringWriter();\n+        jg = f.createJsonGenerator(sw);\n+        jg.close();\n+        assertEquals(\"567\", sw.toString());\n+\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        jg = f.createJsonGenerator(out, JsonEncoding.UTF8);\n+        jg.close();\n+        assertEquals(\"123\", out.toString(\"UTF-8\"));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestJsonParser.java\n+package com.fasterxml.jackson.core.json;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+/**\n+ * Set of basic unit tests for verifying that the basic parser\n+ * functionality works as expected.\n+ */\n+public class TestJsonParser\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    public void testConfig() throws Exception\n+    {\n+        JsonParser jp = createParserUsingReader(\"[ ]\");\n+        jp.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE);\n+        assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE));\n+        jp.disable(JsonParser.Feature.AUTO_CLOSE_SOURCE);\n+        assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE));\n+\n+        jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, true);\n+        assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE));\n+        jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, false);\n+        assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE));\n+\n+        assertTrue(jp.isEnabled(JsonParser.Feature.INTERN_FIELD_NAMES));\n+        jp.configure(JsonParser.Feature.INTERN_FIELD_NAMES, false);\n+        assertFalse(jp.isEnabled(JsonParser.Feature.INTERN_FIELD_NAMES));\n+        jp.configure(JsonParser.Feature.INTERN_FIELD_NAMES, true);\n+        assertTrue(jp.isEnabled(JsonParser.Feature.INTERN_FIELD_NAMES));\n+    }\n+\n+    public void testConfigDeprecated() throws Exception\n+    {\n+        JsonParser jp = createParserUsingReader(\"[ ]\");\n+        // and then deprecated methods\n+        jp.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE);\n+        assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE));\n+        jp.disable(JsonParser.Feature.AUTO_CLOSE_SOURCE);\n+        assertFalse(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE));\n+        jp.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, true);\n+        assertTrue(jp.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE));\n+    }\n+\n+    public void testInterningWithStreams() throws Exception\n+    {\n+        _testIntern(true, true, \"a\");\n+        _testIntern(true, false, \"b\");\n+    }\n+\n+    public void testInterningWithReaders() throws Exception\n+    {\n+        _testIntern(false, true, \"c\");\n+        _testIntern(false, false, \"d\");\n+    }\n+    \n+    private void _testIntern(boolean useStream, boolean enableIntern, String expName) throws IOException\n+    {\n+        JsonFactory f = new JsonFactory();\n+        f.configure(JsonParser.Feature.INTERN_FIELD_NAMES, enableIntern);\n+        assertEquals(enableIntern, f.isEnabled(JsonParser.Feature.INTERN_FIELD_NAMES));\n+        final String JSON = \"{ \\\"\"+expName+\"\\\" : 1}\";\n+        JsonParser jp = useStream ?\n+            createParserUsingStream(f, JSON, \"UTF-8\") : createParserUsingReader(f, JSON);\n+\n+        assertEquals(enableIntern, jp.isEnabled(JsonParser.Feature.INTERN_FIELD_NAMES));\n+            \n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        // needs to be same of cours\n+        String actName = jp.getCurrentName();\n+        assertEquals(expName, actName);\n+        if (enableIntern) {\n+            assertSame(expName, actName);\n+        } else {\n+            assertNotSame(expName, actName);\n+        }\n+        jp.close();\n+    }\n+\n+    public void testTokenAccess() throws Exception\n+    {\n+        JsonParser jp = createParserUsingReader(\"[ ]\");\n+        assertNull(jp.getCurrentToken());\n+        jp.clearCurrentToken();\n+        assertNull(jp.getCurrentToken());\n+        assertNull(jp.getEmbeddedObject());\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.START_ARRAY, jp.getCurrentToken());\n+        jp.clearCurrentToken();\n+        assertNull(jp.getCurrentToken());\n+\n+\n+        // Also: no codec defined by default\n+        try {\n+            jp.readValueAsTree();\n+            fail(\"Should get exception without codec\");\n+        } catch (IllegalStateException e) {\n+            verifyException(e, \"No ObjectCodec defined\");\n+        }\n+\n+        jp.close();\n+    }\n+\n+    /**\n+     * This basic unit test verifies that example given in the Json\n+     * specification (RFC-4627 or later) is properly parsed at\n+     * high-level, without verifying values.\n+     */\n+    public void testSpecExampleSkipping()\n+        throws Exception\n+    {\n+        doTestSpec(false);\n+    }\n+\n+    /**\n+     * Unit test that verifies that the spec example JSON is completely\n+     * parsed, and proper values are given for contents of all\n+     * events/tokens.\n+     */\n+    public void testSpecExampleFully()\n+        throws Exception\n+    {\n+        doTestSpec(true);\n+    }\n+\n+    /**\n+     * Unit test that verifies that 3 basic keywords (null, true, false)\n+     * are properly parsed in various contexts.\n+     */\n+    public void testKeywords()\n+        throws Exception\n+    {\n+        final String DOC = \"{\\n\"\n+            +\"\\\"key1\\\" : null,\\n\"\n+            +\"\\\"key2\\\" : true,\\n\"\n+            +\"\\\"key3\\\" : false,\\n\"\n+            +\"\\\"key4\\\" : [ false, null, true ]\\n\"\n+            +\"}\"\n+            ;\n+\n+        JsonParser jp = createParserUsingStream(DOC, \"UTF-8\");\n+\n+        JsonStreamContext ctxt = jp.getParsingContext();\n+        assertTrue(ctxt.inRoot());\n+        assertFalse(ctxt.inArray());\n+        assertFalse(ctxt.inObject());\n+        assertEquals(0, ctxt.getEntryCount());\n+        assertEquals(0, ctxt.getCurrentIndex());\n+\n+        /* Before advancing to content, we should have following\n+         * default state...\n+         */\n+        assertFalse(jp.hasCurrentToken());\n+        assertNull(jp.getText());\n+        assertNull(jp.getTextCharacters());\n+        assertEquals(0, jp.getTextLength());\n+        // not sure if this is defined but:\n+        assertEquals(0, jp.getTextOffset());\n+\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+\n+        assertTrue(jp.hasCurrentToken());\n+        JsonLocation loc = jp.getTokenLocation();\n+        assertNotNull(loc);\n+        assertEquals(1, loc.getLineNr());\n+        assertEquals(1, loc.getColumnNr());\n+\n+        ctxt = jp.getParsingContext();\n+        assertFalse(ctxt.inRoot());\n+        assertFalse(ctxt.inArray());\n+        assertTrue(ctxt.inObject());\n+        assertEquals(0, ctxt.getEntryCount());\n+        assertEquals(0, ctxt.getCurrentIndex());\n+\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        verifyFieldName(jp, \"key1\");\n+        assertEquals(2, jp.getTokenLocation().getLineNr());\n+\n+        ctxt = jp.getParsingContext();\n+        assertFalse(ctxt.inRoot());\n+        assertFalse(ctxt.inArray());\n+        assertTrue(ctxt.inObject());\n+        assertEquals(1, ctxt.getEntryCount());\n+        assertEquals(0, ctxt.getCurrentIndex());\n+\n+        assertToken(JsonToken.VALUE_NULL, jp.nextToken());\n+\n+        ctxt = jp.getParsingContext();\n+        assertEquals(1, ctxt.getEntryCount());\n+        assertEquals(0, ctxt.getCurrentIndex());\n+\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        verifyFieldName(jp, \"key2\");\n+        ctxt = jp.getParsingContext();\n+        assertEquals(2, ctxt.getEntryCount());\n+        assertEquals(1, ctxt.getCurrentIndex());\n+\n+        assertToken(JsonToken.VALUE_TRUE, jp.nextToken());\n+\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        verifyFieldName(jp, \"key3\");\n+        assertToken(JsonToken.VALUE_FALSE, jp.nextToken());\n+\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        verifyFieldName(jp, \"key4\");\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_FALSE, jp.nextToken());\n+        assertToken(JsonToken.VALUE_NULL, jp.nextToken());\n+        assertToken(JsonToken.VALUE_TRUE, jp.nextToken());\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+    }\n+\n+    public void testInvalidKeywords() throws Exception\n+    {\n+        _testInvalidKeywords(true);\n+        _testInvalidKeywords(false);\n+    }\n+\n+    private void _testInvalidKeywords(boolean useStream) throws Exception\n+    {\n+        doTestInvalidKeyword1(useStream, \"nul\");\n+        doTestInvalidKeyword1(useStream, \"nulla\");\n+        doTestInvalidKeyword1(useStream, \"fal\");\n+        doTestInvalidKeyword3(useStream, \"False\");\n+        doTestInvalidKeyword1(useStream, \"falsett0\");\n+        doTestInvalidKeyword1(useStream, \"tr\");\n+        doTestInvalidKeyword1(useStream, \"truE\");\n+        doTestInvalidKeyword1(useStream, \"trueenough\");\n+    }\n+\n+    public void testSkipping()\n+        throws Exception\n+    {\n+        String DOC =\n+            \"[ 1, 3, [ true, null ], 3, { \\\"a\\\":\\\"b\\\" }, [ [ ] ], { } ]\";\n+            ;\n+        JsonParser jp = createParserUsingStream(DOC, \"UTF-8\");\n+\n+        // First, skipping of the whole thing\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        jp.skipChildren();\n+        assertEquals(JsonToken.END_ARRAY, jp.getCurrentToken());\n+        JsonToken t = jp.nextToken();\n+        if (t != null) {\n+            fail(\"Expected null at end of doc, got \"+t);\n+        }\n+        jp.close();\n+\n+        // Then individual ones\n+        jp = createParserUsingStream(DOC, \"UTF-8\");\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        jp.skipChildren();\n+        // shouldn't move\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken());\n+        assertEquals(1, jp.getIntValue());\n+\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        // then skip array\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        jp.skipChildren();\n+        assertToken(JsonToken.END_ARRAY, jp.getCurrentToken());\n+\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        jp.skipChildren();\n+        assertToken(JsonToken.END_OBJECT, jp.getCurrentToken());\n+\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        jp.skipChildren();\n+        assertToken(JsonToken.END_ARRAY, jp.getCurrentToken());\n+\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        jp.skipChildren();\n+        assertToken(JsonToken.END_OBJECT, jp.getCurrentToken());\n+\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+\n+        jp.close();\n+    }\n+\n+    public void testNameEscaping() throws IOException\n+    {\n+        _testNameEscaping(false);\n+        _testNameEscaping(true);\n+    }\n+\n+    private void _testNameEscaping(boolean useStream) throws IOException\n+    {\n+        final Map<String,String> NAME_MAP = new LinkedHashMap<String,String>();\n+        NAME_MAP.put(\"\", \"\");\n+        NAME_MAP.put(\"\\\\\\\"funny\\\\\\\"\", \"\\\"funny\\\"\");\n+        NAME_MAP.put(\"\\\\\\\\\", \"\\\\\");\n+        NAME_MAP.put(\"\\\\r\", \"\\r\");\n+        NAME_MAP.put(\"\\\\n\", \"\\n\");\n+        NAME_MAP.put(\"\\\\t\", \"\\t\");\n+        NAME_MAP.put(\"\\\\r\\\\n\", \"\\r\\n\");\n+        NAME_MAP.put(\"\\\\\\\"\\\\\\\"\", \"\\\"\\\"\");\n+        NAME_MAP.put(\"Line\\\\nfeed\", \"Line\\nfeed\");\n+        NAME_MAP.put(\"Yet even longer \\\\\\\"name\\\\\\\"!\", \"Yet even longer \\\"name\\\"!\");\n+\n+        JsonFactory jf = new JsonFactory();\n+        int entry = 0;\n+        for (Map.Entry<String,String> en : NAME_MAP.entrySet()) {\n+            ++entry;\n+            String input = en.getKey();\n+            String expResult = en.getValue();\n+            final String DOC = \"{ \\\"\"+input+\"\\\":null}\";\n+            JsonParser jp = useStream ?\n+                jf.createJsonParser(new ByteArrayInputStream(DOC.getBytes(\"UTF-8\")))\n+                : jf.createJsonParser(new StringReader(DOC));\n+\n+            assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+            assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+            // first, sanity check (field name == getText()\n+            String act = jp.getCurrentName();\n+            assertEquals(act, getAndVerifyText(jp));\n+            if (!expResult.equals(act)) {\n+                String msg = \"Failed for name #\"+entry+\"/\"+NAME_MAP.size();\n+                if (expResult.length() != act.length()) {\n+                    fail(msg+\": exp length \"+expResult.length()+\", actual \"+act.length());\n+                }\n+                assertEquals(msg, expResult, act);\n+            }\n+            assertToken(JsonToken.VALUE_NULL, jp.nextToken());\n+            assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+            jp.close();\n+        }\n+    }\n+    \n+    /**\n+     * Unit test that verifies that long text segments are handled\n+     * correctly; mostly to stress-test underlying segment-based\n+     * text buffer(s).\n+     */\n+    public void testLongText() throws Exception\n+    {\n+        final int LEN = 96000;\n+        StringBuilder sb = new StringBuilder(LEN + 100);\n+        Random r = new Random(99);\n+        while (sb.length() < LEN) {\n+            sb.append(r.nextInt());\n+            sb.append(\" xyz foo\");\n+            if (r.nextBoolean()) {\n+                sb.append(\" and \\\"bar\\\"\");\n+            } else if (r.nextBoolean()) {\n+                sb.append(\" [whatever].... \");\n+            } else {\n+                // Let's try some more 'exotic' chars\n+                sb.append(\" UTF-8-fu: try this {\\u00E2/\\u0BF8/\\uA123!} (look funny?)\");\n+            }\n+            if (r.nextBoolean()) {\n+                if (r.nextBoolean()) {\n+                    sb.append('\\n');\n+                } else if (r.nextBoolean()) {\n+                    sb.append('\\r');\n+                } else {\n+                    sb.append(\"\\r\\n\");\n+                }\n+            }\n+        }\n+        final String VALUE = sb.toString();\n+\n+        JsonFactory jf = new JsonFactory();\n+        \n+        // Let's use real generator to get json done right\n+        StringWriter sw = new StringWriter(LEN + (LEN >> 2));\n+        JsonGenerator jg = jf.createJsonGenerator(sw);\n+        jg.writeStartObject();\n+        jg.writeFieldName(\"doc\");\n+        jg.writeString(VALUE);\n+        jg.writeEndObject();\n+        jg.close();\n+        \n+        final String DOC = sw.toString();\n+\n+        for (int type = 0; type < 3; ++type) {\n+            JsonParser jp;\n+\n+            switch (type) {\n+            default:\n+                jp = jf.createJsonParser(DOC.getBytes(\"UTF-8\"));\n+                break;\n+            case 1:\n+                jp = jf.createJsonParser(DOC);\n+                break;\n+            case 2: // NEW: let's also exercise UTF-32...\n+                jp = jf.createJsonParser(encodeInUTF32BE(DOC));\n+                break;\n+            }\n+            assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+            assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+            assertEquals(\"doc\", jp.getCurrentName());\n+            assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+            \n+            String act = getAndVerifyText(jp);\n+            if (act.length() != VALUE.length()) {\n+                fail(\"Expected length \"+VALUE.length()+\", got \"+act.length());\n+            }\n+            if (!act.equals(VALUE)) {\n+                fail(\"Long text differs\");\n+            }\n+\n+            // should still know the field name\n+            assertEquals(\"doc\", jp.getCurrentName());\n+            assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+            jp.close();\n+        }\n+    }\n+\n+    /**\n+     * Simple unit test that verifies that passing in a byte array\n+     * as source works as expected.\n+     */\n+    public void testBytesAsSource() throws Exception\n+    {\n+        String JSON = \"[ 1, 2, 3, 4 ]\";\n+        byte[] b = JSON.getBytes(\"UTF-8\");\n+        int offset = 50;\n+        int len = b.length;\n+        byte[] src = new byte[offset + len + offset];\n+\n+        System.arraycopy(b, 0, src, offset, len);\n+\n+        JsonFactory jf = new JsonFactory();\n+        JsonParser jp = jf.createJsonParser(src, offset, len);\n+\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(1, jp.getIntValue());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(2, jp.getIntValue());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(3, jp.getIntValue());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(4, jp.getIntValue());\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        assertNull(jp.nextToken());\n+\n+        jp.close();\n+    }\n+\n+    // [JACKSON-632]\n+    public void testUtf8BOMHandling() throws Exception\n+    {\n+        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n+        // first, write BOM:\n+        bytes.write(0xEF);\n+        bytes.write(0xBB);\n+        bytes.write(0xBF);\n+        bytes.write(\"[ 1 ]\".getBytes(\"UTF-8\"));\n+        JsonFactory jf = new JsonFactory();\n+        JsonParser jp = jf.createJsonParser(bytes.toByteArray());\n+        assertEquals(JsonToken.START_ARRAY, jp.nextToken());\n+        // should also have skipped first 3 bytes of BOM; but do we have offset available?\n+        /*\n+        JsonLocation loc = jp.getTokenLocation();\n+        assertEquals(3, loc.getByteOffset());\n+        assertEquals(-1, loc.getCharOffset());\n+        */\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    private void doTestSpec(boolean verify)\n+        throws IOException\n+    {\n+        // First, using a StringReader:\n+        doTestSpecIndividual(null, verify);\n+\n+        // Then with streams using supported encodings:\n+        doTestSpecIndividual(\"UTF-8\", verify);\n+        doTestSpecIndividual(\"UTF-16BE\", verify);\n+        doTestSpecIndividual(\"UTF-16LE\", verify);\n+\n+        /* Hmmh. UTF-32 is harder only because JDK doesn't come with\n+         * a codec for it. Can't test it yet using this method\n+         */\n+        doTestSpecIndividual(\"UTF-32\", verify);\n+    }\n+\n+    private void doTestSpecIndividual(String enc, boolean verify)\n+        throws IOException\n+    {\n+        String doc = SAMPLE_DOC_JSON_SPEC;\n+        JsonParser jp;\n+\n+        if (enc == null) {\n+            jp = createParserUsingReader(doc);\n+        } else {\n+            jp = createParserUsingStream(doc, enc);\n+        }\n+        verifyJsonSpecSampleDoc(jp, verify);\n+        jp.close();\n+    }\n+\n+    private void doTestInvalidKeyword1(boolean useStream, String value)\n+        throws IOException\n+    {\n+        final String doc = \"{ \\\"key1\\\" : \"+value+\" }\";\n+        JsonParser jp = useStream ? createParserUsingStream(doc, \"UTF-8\")\n+                : this.createParserUsingReader(doc);\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        /* 24-Nov-2008, tatu: Note that depending on parser impl, we may\n+         *   get the exception early or late...\n+         */\n+        try {\n+            assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+            jp.nextToken();\n+            fail(\"Expected an exception for malformed value keyword\");\n+        } catch (JsonParseException jex) {\n+            verifyException(jex, \"Unrecognized token\");\n+        }\n+    }\n+\n+    private void doTestInvalidKeyword3(boolean useStream, String value)\n+        throws IOException\n+    {\n+        final String doc = \"{ \\\"key1\\\" : \"+value+\" }\";\n+        JsonParser jp = useStream ? createParserUsingStream(doc, \"UTF-8\")\n+                : this.createParserUsingReader(doc);\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        /* 24-Nov-2008, tatu: Note that depending on parser impl, we may\n+         *   get the exception early or late...\n+         */\n+        try {\n+            assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+            jp.nextToken();\n+            fail(\"Expected an exception for malformed value keyword\");\n+        } catch (JsonParseException jex) {\n+            verifyException(jex, \"expected a valid value\");\n+        }\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestJsonParserBinary.java\n+package com.fasterxml.jackson.core.json;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+import static org.junit.Assert.*;\n+\n+/**\n+ * Tests for verifying that accessing base64 encoded content works ok.\n+ */\n+public class TestJsonParserBinary\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    /*\n+    /**********************************************************************\n+    /* Unit tests\n+    /**********************************************************************\n+     */\n+\n+    public void testSimple()\n+        throws IOException\n+    {\n+        // let's test reader (char) based first, then stream (byte)\n+        _testSimple(false);\n+        _testSimple(true);\n+    }\n+\n+    public void testInArray()\n+        throws IOException\n+    {\n+        // let's test reader (char) based first, then stream (byte)\n+        _testInArray(false);\n+        _testInArray(true);\n+    }\n+\n+    public void testWithEscaped() throws IOException\n+    {\n+        // let's test reader (char) based first, then stream (byte)\n+        _testEscaped(false);\n+        _testEscaped(true);\n+    }\n+    \n+    /*\n+    /**********************************************************************\n+    /* Actual test methods\n+    /**********************************************************************\n+     */\n+\n+    private void _testSimple(boolean useStream)\n+        throws IOException\n+    {\n+        /* The usual sample input string, from Thomas Hobbes's \"Leviathan\"\n+         * (via Wikipedia)\n+         */\n+        final String RESULT = \"Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.\";\n+        final byte[] RESULT_BYTES = RESULT.getBytes(\"US-ASCII\");\n+\n+        // And here's what should produce it...\n+        final String INPUT_STR = \n+ \"TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlz\"\n++\"IHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2Yg\"\n++\"dGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGlu\"\n++\"dWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRo\"\n++\"ZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=\"\n+            ;\n+\n+        final String DOC = \"\\\"\"+INPUT_STR+\"\\\"\";\n+        JsonParser jp = _getParser(DOC, useStream);\n+\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        byte[] data = jp.getBinaryValue();\n+        assertNotNull(data);\n+        assertArrayEquals(RESULT_BYTES, data);\n+    }\n+\n+    private void _testInArray(boolean useStream)\n+        throws IOException\n+    {\n+        JsonFactory jf = new JsonFactory();\n+\n+        final int entryCount = 7;\n+\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator jg = jf.createJsonGenerator(sw);\n+        jg.writeStartArray();\n+\n+        byte[][] entries = new byte[entryCount][];\n+        for (int i = 0; i < entryCount; ++i) {\n+            byte[] b = new byte[200 + i * 100];\n+            for (int x = 0; x < b.length; ++x) {\n+                b[x] = (byte) (i + x);\n+            }\n+            entries[i] = b;\n+            jg.writeBinary(b);\n+        }\n+\n+        jg.writeEndArray();\n+        jg.close();\n+\n+        JsonParser jp = _getParser(sw.toString(), useStream);\n+\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+\n+        for (int i = 0; i < entryCount; ++i) {\n+            assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+            byte[] b = jp.getBinaryValue();\n+            assertArrayEquals(entries[i], b);\n+        }\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+    }\n+\n+    private void _testEscaped(boolean useStream) throws IOException\n+    {\n+        // Input: \"Test!\" -> \"VGVzdCE=\"\n+\n+        // First, try with embedded linefeed half-way through:\n+\n+        String DOC = quote(\"VGVz\\\\ndCE=\"); // note: must double-quote to get linefeed\n+        JsonParser jp = _getParser(DOC, useStream);\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        byte[] b = jp.getBinaryValue();\n+        assertEquals(\"Test!\", new String(b, \"US-ASCII\"));\n+        assertNull(jp.nextToken());\n+        jp.close();\n+\n+        // and then with escaped chars\n+//        DOC = quote(\"V\\\\u0047V\\\\u007AdCE=\"); // note: must escape backslash...\n+        DOC = quote(\"V\\\\u0047V\\\\u007AdCE=\"); // note: must escape backslash...\n+        jp = _getParser(DOC, useStream);\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        b = jp.getBinaryValue();\n+        assertEquals(\"Test!\", new String(b, \"US-ASCII\"));\n+        assertNull(jp.nextToken());\n+        jp.close();\n+    }\n+    \n+    /*\n+    /**********************************************************************\n+    /* Other helper methods\n+    /**********************************************************************\n+     */\n+    \n+    private JsonParser _getParser(String doc, boolean useStream)\n+        throws IOException\n+    {\n+        JsonFactory jf = new JsonFactory();\n+        if (useStream) {\n+            return jf.createJsonParser(doc.getBytes(\"UTF-8\"));\n+        }\n+        return jf.createJsonParser(new StringReader(doc));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestNextXxx.java\n+package com.fasterxml.jackson.core.json;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.StringReader;\n+\n+import com.fasterxml.jackson.core.JsonFactory;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.core.SerializableString;\n+import com.fasterxml.jackson.core.io.SerializedString;\n+\n+public class TestNextXxx\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    // [JACKSON-653]\n+    public void testIsNextTokenName() throws Exception\n+    {\n+        _testIsNextTokenName1(false);\n+        _testIsNextTokenName1(true);\n+        _testIsNextTokenName2(false);\n+        _testIsNextTokenName2(true);\n+    }\n+\n+    private void _testIsNextTokenName1(boolean useStream) throws Exception\n+    {\n+        final String DOC = \"{\\\"name\\\":123,\\\"name2\\\":14,\\\"x\\\":\\\"name\\\"}\";\n+        JsonFactory jf = new JsonFactory();\n+        JsonParser jp = useStream ?\n+            jf.createJsonParser(new ByteArrayInputStream(DOC.getBytes(\"UTF-8\")))\n+            : jf.createJsonParser(new StringReader(DOC));\n+        SerializedString NAME = new SerializedString(\"name\");\n+        assertFalse(jp.nextFieldName(NAME));\n+        assertToken(JsonToken.START_OBJECT, jp.getCurrentToken());\n+        assertTrue(jp.nextFieldName(NAME));\n+        assertToken(JsonToken.FIELD_NAME, jp.getCurrentToken());\n+        assertEquals(NAME.getValue(), jp.getCurrentName());\n+        assertEquals(NAME.getValue(), jp.getText());\n+        assertFalse(jp.nextFieldName(NAME));\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken());\n+        assertEquals(123, jp.getIntValue());\n+\n+        assertFalse(jp.nextFieldName(NAME));\n+        assertToken(JsonToken.FIELD_NAME, jp.getCurrentToken());\n+        assertEquals(\"name2\", jp.getCurrentName());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+\n+        assertFalse(jp.nextFieldName(NAME));\n+        assertToken(JsonToken.FIELD_NAME, jp.getCurrentToken());\n+        assertEquals(\"x\", jp.getCurrentName());\n+\n+        assertFalse(jp.nextFieldName(NAME));\n+        assertToken(JsonToken.VALUE_STRING, jp.getCurrentToken());\n+\n+        assertFalse(jp.nextFieldName(NAME));\n+        assertToken(JsonToken.END_OBJECT, jp.getCurrentToken());\n+\n+        assertFalse(jp.nextFieldName(NAME));\n+        assertNull(jp.getCurrentToken());\n+\n+        jp.close();\n+    }\n+\n+    private void _testIsNextTokenName2(boolean useStream) throws Exception\n+    {\n+        final String DOC = \"{\\\"name\\\":123,\\\"name2\\\":14,\\\"x\\\":\\\"name\\\"}\";\n+        JsonFactory jf = new JsonFactory();\n+        JsonParser jp = useStream ?\n+            jf.createJsonParser(new ByteArrayInputStream(DOC.getBytes(\"UTF-8\")))\n+            : jf.createJsonParser(new StringReader(DOC));\n+        SerializableString NAME = new SerializedString(\"name\");\n+        assertFalse(jp.nextFieldName(NAME));\n+        assertToken(JsonToken.START_OBJECT, jp.getCurrentToken());\n+        assertTrue(jp.nextFieldName(NAME));\n+        assertToken(JsonToken.FIELD_NAME, jp.getCurrentToken());\n+        assertEquals(NAME.getValue(), jp.getCurrentName());\n+        assertEquals(NAME.getValue(), jp.getText());\n+        assertFalse(jp.nextFieldName(NAME));\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken());\n+        assertEquals(123, jp.getIntValue());\n+\n+        assertFalse(jp.nextFieldName(NAME));\n+        assertToken(JsonToken.FIELD_NAME, jp.getCurrentToken());\n+        assertEquals(\"name2\", jp.getCurrentName());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+\n+        assertFalse(jp.nextFieldName(NAME));\n+        assertToken(JsonToken.FIELD_NAME, jp.getCurrentToken());\n+        assertEquals(\"x\", jp.getCurrentName());\n+\n+        assertFalse(jp.nextFieldName(NAME));\n+        assertToken(JsonToken.VALUE_STRING, jp.getCurrentToken());\n+\n+        assertFalse(jp.nextFieldName(NAME));\n+        assertToken(JsonToken.END_OBJECT, jp.getCurrentToken());\n+\n+        assertFalse(jp.nextFieldName(NAME));\n+        assertNull(jp.getCurrentToken());\n+\n+        jp.close();\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestParserNonStandard.java\n+package com.fasterxml.jackson.core.json;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+public class TestParserNonStandard\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    // // // And then tests to verify [JACKSON-69]:\n+\n+    public void testSimpleUnquoted() throws Exception\n+    {\n+        _testSimpleUnquoted(false);\n+        _testSimpleUnquoted(true);\n+    }\n+\n+    public void testLargeUnquoted() throws Exception\n+    {\n+        _testLargeUnquoted(false);\n+        _testLargeUnquoted(true);\n+    }\n+\n+    public void testSingleQuotesDefault() throws Exception\n+    {\n+        _testSingleQuotesDefault(false);\n+        _testSingleQuotesDefault(true);\n+    }\n+\n+    public void testSingleQuotesEnabled() throws Exception\n+    {\n+        _testSingleQuotesEnabled(false);\n+        _testSingleQuotesEnabled(true);\n+        _testSingleQuotesEscaped(false);\n+        _testSingleQuotesEscaped(true);\n+    }\n+\n+    // Test for [JACKSON-267], allowing '@' as name char, for unquoted names\n+    public void testNonStandardNameChars() throws Exception\n+    {\n+        _testNonStandardNameChars(false);\n+        _testNonStandardNameChars(true);\n+    }\n+    \n+    // Test for [JACKSON-300]\n+    public void testNonStandardAnyCharQuoting() throws Exception\n+    {\n+        _testNonStandarBackslashQuoting(false);\n+        _testNonStandarBackslashQuoting(true);\n+    }\n+\n+    // Test for [JACKSON-358]\n+    public void testLeadingZeroesUTF8() throws Exception {\n+        _testLeadingZeroes(true, false);\n+        _testLeadingZeroes(true, true);\n+    }\n+\n+    public void testLeadingZeroesReader() throws Exception {\n+        _testLeadingZeroes(false, false);\n+        _testLeadingZeroes(false, true);\n+    }\n+\n+    // [JACKSON-142]: allow NaN\n+    public void testAllowNaN() throws Exception {\n+        _testAllowNaN(false);\n+        _testAllowNaN(true);\n+    }\n+\n+    // [JACKSON-142]: allow +Inf/-Inf\n+    public void testAllowInfinity() throws Exception {\n+        _testAllowInf(false);\n+        _testAllowInf(true);\n+    }\n+    \n+    /*\n+    /****************************************************************\n+    /* Secondary test methods\n+    /****************************************************************\n+     */\n+\n+    private void _testLargeUnquoted(boolean useStream) throws Exception\n+    {\n+        StringBuilder sb = new StringBuilder(5000);\n+        sb.append(\"[\\n\");\n+        //final int REPS = 2000;\n+        final int REPS = 1050;\n+        for (int i = 0; i < REPS; ++i) {\n+            if (i > 0) {\n+                sb.append(',');\n+                if ((i & 7) == 0) {\n+                    sb.append('\\n');\n+                }\n+            }\n+            sb.append(\"{\");\n+            sb.append(\"abc\").append(i&127).append(':');\n+            sb.append((i & 1) != 0);\n+            sb.append(\"}\\n\");\n+        }\n+        sb.append(\"]\");\n+        String JSON = sb.toString();\n+        JsonFactory f = new JsonFactory();\n+        f.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);\n+        JsonParser jp = useStream ?\n+            createParserUsingStream(f, JSON, \"UTF-8\")\n+            : createParserUsingReader(f, JSON)\n+            ;\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        for (int i = 0; i < REPS; ++i) {\n+            assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+            assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+            assertEquals(\"abc\"+(i&127), jp.getCurrentName());\n+            assertToken(((i&1) != 0) ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE, jp.nextToken());\n+            assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+        }\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+    }\n+\n+    \n+    private void _testSimpleUnquoted(boolean useStream) throws Exception\n+    {\n+        final String JSON = \"{ a : 1, _foo:true, $:\\\"money!\\\", \\\" \\\":null }\";\n+        JsonFactory f = new JsonFactory();\n+        f.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);\n+        JsonParser jp = useStream ?\n+            createParserUsingStream(f, JSON, \"UTF-8\")\n+            : createParserUsingReader(f, JSON)\n+            ;\n+\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"a\", jp.getCurrentName());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"_foo\", jp.getCurrentName());\n+        assertToken(JsonToken.VALUE_TRUE, jp.nextToken());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"$\", jp.getCurrentName());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(\"money!\", jp.getText());\n+\n+        // and then regular quoted one should still work too:\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\" \", jp.getCurrentName());\n+\n+        assertToken(JsonToken.VALUE_NULL, jp.nextToken());\n+\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+    }\n+\n+    /**\n+     * Test to verify that the default parser settings do not\n+     * accept single-quotes for String values (field names,\n+     * textual values)\n+     */\n+    private void _testSingleQuotesDefault(boolean useStream) throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+        // First, let's see that by default they are not allowed\n+        String JSON = \"[ 'text' ]\";\n+        JsonParser jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\")\n+            : createParserUsingReader(f, JSON);\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        try {\n+            jp.nextToken();\n+            fail(\"Expected exception\");\n+        } catch (JsonParseException e) {\n+            verifyException(e, \"Unexpected character ('''\");\n+        }\n+\n+        JSON = \"{ 'a':1 }\";\n+        jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\")\n+            : createParserUsingReader(f, JSON);\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        try {\n+            jp.nextToken();\n+            fail(\"Expected exception\");\n+        } catch (JsonParseException e) {\n+            verifyException(e, \"Unexpected character ('''\");\n+        }\n+    }\n+\n+    /**\n+     * Test to verify [JACKSON-173], optional handling of\n+     * single quotes, to allow handling invalid (but, alas, common)\n+     * JSON.\n+     */\n+    private void _testSingleQuotesEnabled(boolean useStream) throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+        f.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, true);\n+\n+        String JSON = \"{ 'a' : 1, \\\"foobar\\\": 'b', '_abcde1234':'d', '\\\"' : '\\\"\\\"', '':'' }\";\n+        JsonParser jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\")\n+            : createParserUsingReader(f, JSON);\n+\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"a\", jp.getText());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(\"1\", jp.getText());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"foobar\", jp.getText());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(\"b\", jp.getText());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"_abcde1234\", jp.getText());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(\"d\", jp.getText());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"\\\"\", jp.getText());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        //assertEquals(\"\\\"\\\"\", jp.getText());\n+\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"\", jp.getText());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(\"\", jp.getText());\n+\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+    }\n+\n+    // test to verify that we implicitly allow escaping of apostrophe [JACKSON-548]\n+    private void _testSingleQuotesEscaped(boolean useStream) throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+        f.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, true);\n+\n+        String JSON = \"[ '16\\\\'' ]\";\n+        JsonParser jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\")\n+            : createParserUsingReader(f, JSON);\n+\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(\"16'\", jp.getText());\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+    }\n+    \n+    private void _testNonStandardNameChars(boolean useStream) throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+        f.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);\n+        String JSON = \"{ @type : \\\"mytype\\\", #color : 123, *error* : true, \"\n+            +\" hyphen-ated : \\\"yes\\\", me+my : null\"\n+            +\"}\";\n+        JsonParser jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\")\n+                : createParserUsingReader(f, JSON);\n+\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"@type\", jp.getText());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(\"mytype\", jp.getText());\n+\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"#color\", jp.getText());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(123, jp.getIntValue());\n+\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"*error*\", jp.getText());\n+        assertToken(JsonToken.VALUE_TRUE, jp.nextToken());\n+\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"hyphen-ated\", jp.getText());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(\"yes\", jp.getText());\n+\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"me+my\", jp.getText());\n+        assertToken(JsonToken.VALUE_NULL, jp.nextToken());\n+    \n+        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+        jp.close();\n+    }\n+\n+    private void _testNonStandarBackslashQuoting(boolean useStream) throws Exception\n+    {\n+        // first: verify that we get an exception\n+        JsonFactory f = new JsonFactory();\n+        assertFalse(f.isEnabled(JsonParser.Feature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER));\n+        final String JSON = quote(\"\\\\'\");\n+        JsonParser jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\")                \n+                : createParserUsingReader(f, JSON);\n+        try {      \n+            jp.nextToken();\n+            jp.getText();\n+            fail(\"Should have thrown an exception for doc <\"+JSON+\">\");\n+        } catch (JsonParseException e) {\n+            verifyException(e, \"unrecognized character escape\");\n+        }\n+        // and then verify it's ok...\n+        f.configure(JsonParser.Feature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER, true);\n+        assertTrue(f.isEnabled(JsonParser.Feature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER));\n+        jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\")                \n+                : createParserUsingReader(f, JSON);\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(\"'\", jp.getText());\n+    }\n+\n+    private void _testLeadingZeroes(boolean useStream, boolean appendSpace) throws Exception\n+    {\n+        // first: verify that we get an exception\n+        JsonFactory f = new JsonFactory();\n+        assertFalse(f.isEnabled(JsonParser.Feature.ALLOW_NUMERIC_LEADING_ZEROS));\n+        String JSON = \"00003\";\n+        if (appendSpace) {\n+            JSON += \" \";\n+        }\n+        JsonParser jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\")                \n+                : createParserUsingReader(f, JSON);\n+        try {      \n+            jp.nextToken();\n+            jp.getText();\n+            fail(\"Should have thrown an exception for doc <\"+JSON+\">\");\n+        } catch (JsonParseException e) {\n+            verifyException(e, \"invalid numeric value\");\n+        }\n+        \n+        // and then verify it's ok when enabled\n+        f.configure(JsonParser.Feature.ALLOW_NUMERIC_LEADING_ZEROS, true);\n+        assertTrue(f.isEnabled(JsonParser.Feature.ALLOW_NUMERIC_LEADING_ZEROS));\n+        jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\")                \n+                : createParserUsingReader(f, JSON);\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(3, jp.getIntValue());\n+        assertEquals(\"3\", jp.getText());\n+        jp.close();\n+    \n+        // Plus, also: verify that leading zero magnitude is ok:\n+        JSON = \"0\"+Integer.MAX_VALUE;\n+        if (appendSpace) {\n+            JSON += \" \";\n+        }\n+        jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\") : createParserUsingReader(f, JSON);\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(String.valueOf(Integer.MAX_VALUE), jp.getText());\n+        assertEquals(Integer.MAX_VALUE, jp.getIntValue());\n+        Number nr = jp.getNumberValue();\n+        assertSame(Integer.class, nr.getClass());\n+        jp.close();\n+    }\n+\n+    private void _testAllowNaN(boolean useStream) throws Exception\n+    {\n+        final String JSON = \"[ NaN]\";\n+        JsonFactory f = new JsonFactory();\n+        assertFalse(f.isEnabled(JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS));\n+\n+        // without enabling, should get an exception\n+        JsonParser jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\")\n+            : createParserUsingReader(f, JSON);\n+\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        try {\n+            jp.nextToken();\n+            fail(\"Expected exception\");\n+        } catch (Exception e) {\n+            verifyException(e, \"non-standard\");\n+        }\n+\n+        // we can enable it dynamically (impl detail)\n+        f.configure(JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS, true);\n+        jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\")\n+                : createParserUsingReader(f, JSON);\n+        \n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+        double d = jp.getDoubleValue();\n+        assertTrue(Double.isNaN(d));\n+        assertEquals(\"NaN\", jp.getText());\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        jp.close();\n+\n+        // finally, should also work with skipping\n+        f.configure(JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS, true);\n+        jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\")\n+                : createParserUsingReader(f, JSON);\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        jp.close();\n+    }\n+\n+    private void _testAllowInf(boolean useStream) throws Exception\n+    {\n+        final String JSON = \"[ -INF, +INF, +Infinity,-Infinity ]\";\n+        JsonFactory f = new JsonFactory();\n+        assertFalse(f.isEnabled(JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS));\n+\n+        // without enabling, should get an exception\n+        JsonParser jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\")\n+            : createParserUsingReader(f, JSON);\n+\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        try {\n+            jp.nextToken();\n+            fail(\"Expected exception\");\n+        } catch (Exception e) {\n+            verifyException(e, \"Non-standard token '-INF'\");\n+        }\n+\n+        f.configure(JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS, true);\n+        jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\")\n+                : createParserUsingReader(f, JSON);\n+        \n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+\n+        assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+        double d = jp.getDoubleValue();\n+        assertEquals(\"-INF\", jp.getText());\n+        assertTrue(Double.isInfinite(d));\n+        assertTrue(d == Double.NEGATIVE_INFINITY);\n+\n+        assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+        d = jp.getDoubleValue();\n+        assertEquals(\"+INF\", jp.getText());\n+        assertTrue(Double.isInfinite(d));\n+        assertTrue(d == Double.POSITIVE_INFINITY);\n+\n+        assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+        d = jp.getDoubleValue();\n+        assertEquals(\"+Infinity\", jp.getText());\n+        assertTrue(Double.isInfinite(d));\n+        assertTrue(d == Double.POSITIVE_INFINITY);\n+        \n+        assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+        d = jp.getDoubleValue();\n+        assertEquals(\"-Infinity\", jp.getText());\n+        assertTrue(Double.isInfinite(d));\n+        assertTrue(d == Double.NEGATIVE_INFINITY);\n+\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        jp.close();\n+\n+        // finally, should also work with skipping\n+        f.configure(JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS, true);\n+        jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\")\n+                : createParserUsingReader(f, JSON);\n+\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+        assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+        assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+        assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        \n+        jp.close();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestUtf8Generator.java\n+package com.fasterxml.jackson.core.json;\n+\n+import java.io.ByteArrayOutputStream;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.json.UTF8JsonGenerator;\n+import com.fasterxml.jackson.core.io.IOContext;\n+import com.fasterxml.jackson.core.util.BufferRecycler;\n+import com.fasterxml.jackson.test.BaseTest;\n+\n+public class TestUtf8Generator\n+    extends BaseTest\n+{\n+    public void testUtf8Issue462() throws Exception\n+    {\n+        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n+        IOContext ioc = new IOContext(new BufferRecycler(), bytes, true);\n+        JsonGenerator gen = new UTF8JsonGenerator(ioc, 0, null, bytes);\n+        String str = \"Natuurlijk is alles gelukt en weer een tevreden klant\\uD83D\\uDE04\";\n+        int length = 4000 - 38;\n+\n+        for (int i = 1; i <= length; ++i) {\n+            gen.writeNumber(1);\n+        }\n+        gen.writeString(str);\n+        gen.flush();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestUtf8Parser.java\n+package com.fasterxml.jackson.core.json;\n+\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.test.BaseTest;\n+\n+import java.io.*;\n+import java.util.Random;\n+\n+/**\n+ * Set of basic unit tests for verifying that the basic parser\n+ * functionality works as expected.\n+ */\n+public class TestUtf8Parser\n+    extends BaseTest\n+{\n+    final static String[] UTF8_2BYTE_STRINGS = new String[] {\n+        /* This may look funny, but UTF8 scanner has fairly\n+         * elaborate decoding machinery, and it is indeed\n+         * necessary to try out various combinations...\n+         */\n+        \"b\", \"A\\u00D8\", \"abc\", \"c3p0\",\n+        \"12345\", \"......\", \"Long\\u00FAer\",\n+        \"Latin1-fully-\\u00BE-develop\\u00A8d\",\n+        \"Some very long name, ridiculously long actually to see that buffer expansion works: \\u00BF?\"\n+    };\n+\n+    final static String[] UTF8_3BYTE_STRINGS = new String[] {\n+        \"\\uC823?\", \"A\\u400F\", \"1\\u1234?\",\n+        \"Ab123\\u4034\",\n+        \"Even-longer:\\uC023\"\n+    };\n+\n+    public void testEmptyName()\n+        throws Exception\n+    {\n+        final String DOC = \"{ \\\"\\\" : \\\"\\\" }\";\n+\n+        JsonParser jp = createParserUsingStream(DOC, \"UTF-8\");\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"\", jp.getCurrentName());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(\"\", jp.getText());\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+        jp.close();\n+    }\n+\n+    public void testUtf8Name2Bytes()\n+        throws Exception\n+    {\n+        final String[] NAMES = UTF8_2BYTE_STRINGS;\n+\n+        for (int i = 0; i < NAMES.length; ++i) {\n+            String NAME = NAMES[i];\n+            String DOC = \"{ \\\"\"+NAME+\"\\\" : 0 }\";\n+            JsonParser jp = createParserUsingStream(DOC, \"UTF-8\");\n+            assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+            \n+            assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+            assertEquals(NAME, jp.getCurrentName());\n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            // should retain name during value entry, too\n+            assertEquals(NAME, jp.getCurrentName());\n+            \n+            assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+            jp.close();\n+        }\n+    }\n+\n+    public void testUtf8Name3Bytes() throws Exception\n+    {\n+        final String[] NAMES = UTF8_3BYTE_STRINGS;\n+\n+        for (int i = 0; i < NAMES.length; ++i) {\n+            String NAME = NAMES[i];\n+            String DOC = \"{ \\\"\"+NAME+\"\\\" : true }\";\n+\n+            JsonParser jp = createParserUsingStream(DOC, \"UTF-8\");\n+            assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+            \n+            assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+            assertEquals(NAME, jp.getCurrentName());\n+            assertToken(JsonToken.VALUE_TRUE, jp.nextToken());\n+            assertEquals(NAME, jp.getCurrentName());\n+            \n+            assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+            \n+            jp.close();\n+        }\n+    }\n+\n+    // How about tests for Surrogate-Pairs?\n+\n+    public void testUtf8StringTrivial() throws Exception\n+    {\n+        String[] VALUES = UTF8_2BYTE_STRINGS;\n+        for (int i = 0; i < VALUES.length; ++i) {\n+            String VALUE = VALUES[i];\n+            String DOC = \"[ \\\"\"+VALUE+\"\\\" ]\";\n+            JsonParser jp = createParserUsingStream(DOC, \"UTF-8\");\n+            assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+            assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+            String act = getAndVerifyText(jp);\n+            if (act.length() != VALUE.length()) {\n+                fail(\"Failed for value #\"+(i+1)+\"/\"+VALUES.length+\": length was \"+act.length()+\", should be \"+VALUE.length());\n+            }\n+            assertEquals(VALUE, act);\n+            assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+            jp.close();\n+        }\n+\n+        VALUES = UTF8_3BYTE_STRINGS;\n+        for (int i = 0; i < VALUES.length; ++i) {\n+            String VALUE = VALUES[i];\n+            String DOC = \"[ \\\"\"+VALUE+\"\\\" ]\";\n+            JsonParser jp = createParserUsingStream(DOC, \"UTF-8\");\n+            assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+            assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+            assertEquals(VALUE, getAndVerifyText(jp));\n+            assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+            jp.close();\n+        }\n+    }\n+\n+    public void testUtf8StringValue() throws Exception\n+    {\n+        Random r = new Random(13);\n+        //int LEN = 72000;\n+        int LEN = 720;\n+        StringBuilder sb = new StringBuilder(LEN + 20);\n+        while (sb.length() < LEN) {\n+            int c;\n+            if (r.nextBoolean()) { // ascii\n+                c = 32 + (r.nextInt() & 0x3F);\n+                if (c == '\"' || c == '\\\\') {\n+                    c = ' ';\n+                }\n+            } else if (r.nextBoolean()) { // 2-byte\n+                c = 160 + (r.nextInt() & 0x3FF);\n+            } else if (r.nextBoolean()) { // 3-byte (non-surrogate)\n+                c = 8000 + (r.nextInt() & 0x7FFF);\n+            } else { // surrogates (2 chars)\n+                int value = r.nextInt() & 0x3FFFF; // 20-bit, ~ 1 million\n+                sb.append((char) (0xD800 + (value >> 10)));\n+                c = (0xDC00 + (value & 0x3FF));\n+\n+            }\n+            sb.append((char) c);\n+        }\n+\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream(LEN);\n+        OutputStreamWriter out = new OutputStreamWriter(bout, \"UTF-8\");\n+        out.write(\"[\\\"\");\n+        String VALUE = sb.toString();\n+        out.write(VALUE);\n+        out.write(\"\\\"]\");\n+        out.close();\n+\n+        byte[] data = bout.toByteArray();\n+\n+        JsonParser jp = new JsonFactory().createJsonParser(new ByteArrayInputStream(data));\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        String act = jp.getText();\n+\n+        assertEquals(VALUE.length(), act.length());\n+        assertEquals(VALUE, act);\n+        jp.close();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestArrayParsing.java\n+package com.fasterxml.jackson.core.main;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+/**\n+ * Set of additional unit for verifying array parsing, specifically\n+ * edge cases.\n+ */\n+public class TestArrayParsing\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    public void testValidEmpty()\n+        throws Exception\n+    {\n+        final String DOC = \"[   \\n  ]\";\n+\n+        JsonParser jp = createParserUsingStream(DOC, \"UTF-8\");\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        assertNull(jp.nextToken());\n+        jp.close();\n+    }\n+\n+    public void testInvalidEmptyMissingClose()\n+        throws Exception\n+    {\n+        final String DOC = \"[ \";\n+\n+        JsonParser jp = createParserUsingStream(DOC, \"UTF-8\");\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+\n+        try {\n+            jp.nextToken();\n+            fail(\"Expected a parsing error for missing array close marker\");\n+        } catch (JsonParseException jex) {\n+            verifyException(jex, \"expected close marker for ARRAY\");\n+        }\n+    }\n+\n+    public void testInvalidMissingFieldName()\n+        throws Exception\n+    {\n+        final String DOC = \"[  : 3 ] \";\n+\n+        JsonParser jp = createParserUsingStream(DOC, \"UTF-8\");\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+\n+        try {\n+            jp.nextToken();\n+            fail(\"Expected a parsing error for odd character\");\n+        } catch (JsonParseException jex) {\n+            verifyException(jex, \"Unexpected character\");\n+        }\n+    }\n+\n+    public void testInvalidExtraComma()\n+        throws Exception\n+    {\n+        final String DOC = \"[ 24, ] \";\n+\n+        JsonParser jp = createParserUsingStream(DOC, \"UTF-8\");\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(24, jp.getIntValue());\n+\n+        try {\n+            jp.nextToken();\n+            fail(\"Expected a parsing error for missing array close marker\");\n+        } catch (JsonParseException jex) {\n+            verifyException(jex, \"expected a value\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestCharEscaping.java\n+package com.fasterxml.jackson.core.main;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.io.CharacterEscapes;\n+\n+/**\n+ * Set of basic unit tests for verifying that the basic parser\n+ * functionality works as expected.\n+ */\n+public class TestCharEscaping\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    // for [JACKSON-627]\n+    private final static CharacterEscapes ESC_627 = new CharacterEscapes() {\n+        final int[] ascii = CharacterEscapes.standardAsciiEscapesForJSON();\n+        {\n+          ascii['<'] = CharacterEscapes.ESCAPE_STANDARD;\n+          ascii['>'] = CharacterEscapes.ESCAPE_STANDARD;\n+        }\n+\n+        @Override\n+        public int[] getEscapeCodesForAscii() {\n+          return ascii;\n+        }\n+\n+        @Override\n+        public SerializableString getEscapeSequence(int ch) {\n+          throw new UnsupportedOperationException(\"Not implemented for test\");\n+        }\n+      };\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+      */\n+\n+    public void testMissingEscaping()\n+        throws Exception\n+    {\n+        // Invalid: control chars, including lf, must be escaped\n+        final String DOC = \"[\"\n+            +\"\\\"Linefeed: \\n.\\\"\"\n+            +\"]\";\n+        JsonParser jp = createParserUsingReader(DOC);\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        try {\n+            // This may or may not trigger exception\n+            JsonToken t = jp.nextToken();\n+            assertToken(JsonToken.VALUE_STRING, t);\n+            // and if not, should get it here:\n+            jp.getText();\n+            fail(\"Expected an exception for un-escaped linefeed in string value\");\n+        } catch (JsonParseException jex) {\n+            verifyException(jex, \"has to be escaped\");\n+        }\n+    }\n+\n+    public void testSimpleEscaping()\n+        throws Exception\n+    {\n+        String DOC = \"[\"\n+            +\"\\\"LF=\\\\n\\\"\"\n+            +\"]\";\n+\n+        JsonParser jp = createParserUsingReader(DOC);\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(\"LF=\\n\", jp.getText());\n+        jp.close();\n+\n+\n+        /* Note: must split Strings, so that javac won't try to handle\n+         * escape and inline null char\n+         */\n+        DOC = \"[\\\"NULL:\\\\u0000!\\\"]\";\n+\n+        jp = createParserUsingReader(DOC);\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(\"NULL:\\0!\", jp.getText());\n+\n+        // Then just a single char escaping\n+        jp = createParserUsingReader(\"[\\\"\\\\u0123\\\"]\");\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(\"\\u0123\", jp.getText());\n+\n+        // And then double sequence\n+        jp = createParserUsingReader(\"[\\\"\\\\u0041\\\\u0043\\\"]\");\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(\"AC\", jp.getText());\n+    }\n+\n+    public void testInvalid()\n+        throws Exception\n+    {\n+        // 2-char sequences not allowed:\n+        String DOC = \"[\\\"\\\\u41=A\\\"]\";\n+        JsonParser jp = createParserUsingReader(DOC);\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        try {\n+            jp.nextToken();\n+            jp.getText();\n+            fail(\"Expected an exception for unclosed ARRAY\");\n+        } catch (JsonParseException jpe) {\n+            verifyException(jpe, \"for character escape\");\n+        }\n+    }\n+\n+    /**\n+     * Test to verify that decoder does not allow 8-digit escapes\n+     * (non-BMP characters must be escaped using two 4-digit sequences)\n+     */\n+    public void test8DigitSequence()\n+        throws Exception\n+    {\n+        String DOC = \"[\\\"\\\\u00411234\\\"]\";\n+        JsonParser jp = createParserUsingReader(DOC);\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(\"A1234\", jp.getText());\n+    }\n+\n+    // for [JACKSON-627]\n+    public void testWriteLongCustomEscapes() throws Exception\n+    {\n+        JsonFactory jf = new JsonFactory();\n+        jf.setCharacterEscapes(ESC_627); // must set to trigger bug\n+        StringBuilder longString = new StringBuilder();\n+        while (longString.length() < 2000) {\n+          longString.append(\"\\u65e5\\u672c\\u8a9e\");\n+        }\n+\n+        StringWriter writer = new StringWriter();\n+        // must call #createJsonGenerator(Writer), #createJsonGenerator(OutputStream) doesn't trigger bug\n+        JsonGenerator jgen = jf.createJsonGenerator(writer);\n+        jgen.setHighestNonEscapedChar(127); // must set to trigger bug\n+        jgen.writeString(longString.toString());\n+      }      \n+\n+}\n+\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestComments.java\n+package com.fasterxml.jackson.core.main;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+/**\n+ * Unit tests for verifying that support for (non-standard) comments\n+ * works as expected.\n+ */\n+public class TestComments\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    final static String DOC_WITH_SLASHSTAR_COMMENT =\n+        \"[ /* comment:\\n ends here */ 1 /* one more ok to have \\\"unquoted\\\"  */ ]\"\n+        ;\n+\n+    final static String DOC_WITH_SLASHSLASH_COMMENT =\n+        \"[ // comment...\\n 1 \\r  // one more, not array: []   \\n ]\"\n+        ;\n+\n+    /**\n+     * Unit test for verifying that by default comments are not\n+     * recognized.\n+     */\n+    public void testDefaultSettings()\n+        throws Exception\n+    {\n+        JsonFactory jf = new JsonFactory();\n+        assertFalse(jf.isEnabled(JsonParser.Feature.ALLOW_COMMENTS));\n+        JsonParser jp = jf.createJsonParser(new StringReader(\"[ 1 ]\"));\n+        assertFalse(jp.isEnabled(JsonParser.Feature.ALLOW_COMMENTS));\n+    }\n+\n+    public void testCommentsDisabled()\n+        throws Exception\n+    {\n+        _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, false);\n+        _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, false);\n+        _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, true);\n+        _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, true);\n+    }\n+\n+    public void testCommentsEnabled()\n+        throws Exception\n+    {\n+        _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false);\n+        _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false);\n+        _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true);\n+        _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true);\n+    }\n+\n+    /*\n+    /////////////////////////////////////////////////\n+    // Helper methods\n+    /////////////////////////////////////////////////\n+     */\n+\n+    private void _testDisabled(String doc, boolean useStream)\n+        throws IOException\n+    {\n+        JsonParser jp = _createParser(doc, useStream, false);\n+        try {\n+            jp.nextToken();\n+            fail(\"Expected exception for unrecognized comment\");\n+        } catch (JsonParseException je) {\n+            // Should have something denoting that user may want to enable 'ALLOW_COMMENTS'\n+            verifyException(je, \"ALLOW_COMMENTS\");\n+        }\n+    }\n+\n+    private void _testEnabled(String doc, boolean useStream)\n+        throws IOException\n+    {\n+        JsonParser jp = _createParser(doc, useStream, true);\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(1, jp.getIntValue());\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+    }\n+\n+    private JsonParser _createParser(String doc, boolean useStream, boolean enabled)\n+        throws IOException\n+    {\n+        JsonFactory jf = new JsonFactory();\n+        jf.configure(JsonParser.Feature.ALLOW_COMMENTS, enabled);\n+        JsonParser jp = useStream ?\n+            jf.createJsonParser(doc.getBytes(\"UTF-8\"))\n+            : jf.createJsonParser(doc);\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        return jp;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestGeneratorArray.java\n+package com.fasterxml.jackson.core.main;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+import java.io.*;\n+\n+/**\n+ * Set of basic unit tests for verifying that the Array write methods\n+ * of {@link JsonGenerator} work as expected.\n+ */\n+public class TestGeneratorArray\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    public void testEmptyArrayWrite()\n+        throws Exception\n+    {\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator gen = new JsonFactory().createJsonGenerator(sw);\n+\n+        JsonStreamContext ctxt = gen.getOutputContext();\n+        assertTrue(ctxt.inRoot());\n+        assertFalse(ctxt.inArray());\n+        assertFalse(ctxt.inObject());\n+        assertEquals(0, ctxt.getEntryCount());\n+        assertEquals(0, ctxt.getCurrentIndex());\n+\n+        gen.writeStartArray();\n+\n+        ctxt = gen.getOutputContext();\n+        assertFalse(ctxt.inRoot());\n+        assertTrue(ctxt.inArray());\n+        assertFalse(ctxt.inObject());\n+        assertEquals(0, ctxt.getEntryCount());\n+        assertEquals(0, ctxt.getCurrentIndex());\n+\n+        gen.writeEndArray();\n+\n+        ctxt = gen.getOutputContext();\n+        assertTrue(\"Should be in root, was \"+ctxt.getTypeDesc(), ctxt.inRoot());\n+        assertFalse(ctxt.inArray());\n+        assertFalse(ctxt.inObject());\n+        assertEquals(1, ctxt.getEntryCount());\n+        // Index won't yet move\n+        assertEquals(0, ctxt.getCurrentIndex());\n+\n+        gen.close();\n+        String docStr = sw.toString();\n+        JsonParser jp = createParserUsingReader(docStr);\n+        assertEquals(JsonToken.START_ARRAY, jp.nextToken());\n+        assertEquals(JsonToken.END_ARRAY, jp.nextToken());\n+        jp.close();\n+\n+        // Ok, then array with nested empty array\n+        sw = new StringWriter();\n+        gen = new JsonFactory().createJsonGenerator(sw);\n+        gen.writeStartArray();\n+        gen.writeStartArray();\n+        gen.writeEndArray();\n+        gen.writeEndArray();\n+        gen.close();\n+        docStr = sw.toString();\n+        jp = createParserUsingReader(docStr);\n+        assertEquals(JsonToken.START_ARRAY, jp.nextToken());\n+        assertEquals(JsonToken.START_ARRAY, jp.nextToken());\n+        assertEquals(JsonToken.END_ARRAY, jp.nextToken());\n+        assertEquals(JsonToken.END_ARRAY, jp.nextToken());\n+        assertEquals(null, jp.nextToken());\n+        jp.close();\n+    }\n+\n+    public void testInvalidArrayWrite()\n+        throws Exception\n+    {\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator gen = new JsonFactory().createJsonGenerator(sw);\n+        gen.writeStartArray();\n+        // Mismatch:\n+        try {\n+            gen.writeEndObject();\n+            fail(\"Expected an exception for mismatched array/object write\");\n+        } catch (JsonGenerationException e) {\n+            verifyException(e, \"Current context not an object\");\n+        }\n+    }\n+\n+    public void testSimpleArrayWrite()\n+        throws Exception\n+    {\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator gen = new JsonFactory().createJsonGenerator(sw);\n+        gen.writeStartArray();\n+        gen.writeNumber(13);\n+        gen.writeBoolean(true);\n+        gen.writeString(\"foobar\");\n+        gen.writeEndArray();\n+        gen.close();\n+        String docStr = sw.toString();\n+        JsonParser jp = createParserUsingReader(docStr);\n+        assertEquals(JsonToken.START_ARRAY, jp.nextToken());\n+        assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(13, jp.getIntValue());\n+        assertEquals(JsonToken.VALUE_TRUE, jp.nextToken());\n+        assertEquals(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(\"foobar\", jp.getText());\n+        assertEquals(JsonToken.END_ARRAY, jp.nextToken());\n+        assertEquals(null, jp.nextToken());\n+        jp.close();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestGeneratorClosing.java\n+package com.fasterxml.jackson.core.main;\n+\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.test.BaseTest;\n+\n+import java.io.*;\n+\n+/**\n+ * Set of basic unit tests that verify aspect of closing a\n+ * {@link JsonGenerator} instance. This includes both closing\n+ * of physical resources (target), and logical content\n+ * (json content tree)\n+ *<p>\n+ * Specifically, features\n+ * <code>JsonGenerator.Feature#AUTO_CLOSE_TARGET</code>\n+ * and\n+ * <code>JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT</code>\n+ * are tested.\n+ */\n+public class TestGeneratorClosing\n+    extends BaseTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    final static class MyWriter extends StringWriter\n+    {\n+        boolean mIsClosed = false;\n+\n+        public MyWriter() { }\n+\n+        @Override\n+        public void close() throws IOException {\n+            mIsClosed = true;\n+            super.close();\n+        }\n+        public boolean isClosed() { return mIsClosed; }\n+    }\n+\n+    final static class MyStream extends ByteArrayOutputStream\n+    {\n+        boolean mIsClosed = false;\n+\n+        public MyStream() { }\n+\n+        @Override\n+        public void close() throws IOException {\n+            mIsClosed = true;\n+            super.close();\n+        }\n+        public boolean isClosed() { return mIsClosed; }\n+    }\n+\n+    static class MyBytes extends ByteArrayOutputStream\n+    {\n+        public int flushed = 0;\n+\n+        @Override\n+        public void flush() throws IOException\n+        {\n+            ++flushed;\n+            super.flush();\n+        }\n+    }\n+\n+    static class MyChars extends StringWriter\n+    {\n+        public int flushed = 0;\n+\n+        @Override\n+        public void flush()\n+        {\n+            ++flushed;\n+            super.flush();\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * This unit test checks the default behaviour; with no auto-close, no\n+     * automatic closing should occur, nor explicit one unless specific\n+     * forcing method is used.\n+     */\n+    public void testNoAutoCloseGenerator()\n+        throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+\n+        // Check the default settings\n+        assertTrue(f.isEnabled(JsonGenerator.Feature.AUTO_CLOSE_TARGET));\n+        // then change\n+        f.disable(JsonGenerator.Feature.AUTO_CLOSE_TARGET);\n+        assertFalse(f.isEnabled(JsonGenerator.Feature.AUTO_CLOSE_TARGET));\n+        MyWriter output = new MyWriter();\n+        JsonGenerator jg = f.createJsonGenerator(output);\n+\n+        // shouldn't be closed to begin with...\n+        assertFalse(output.isClosed());\n+        jg.writeNumber(39);\n+        // regular close won't close it either:\n+        jg.close();\n+        assertFalse(output.isClosed());\n+    }\n+\n+    public void testCloseGenerator()\n+        throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+        f.enable(JsonGenerator.Feature.AUTO_CLOSE_TARGET);\n+        MyWriter output = new MyWriter();\n+        JsonGenerator jg = f.createJsonGenerator(output);\n+\n+        // shouldn't be closed to begin with...\n+        assertFalse(output.isClosed());\n+        jg.writeNumber(39);\n+        // but close() should now close the writer\n+        jg.close();\n+        assertTrue(output.isClosed());\n+    }\n+\n+    public void testNoAutoCloseOutputStream()\n+        throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+        f.disable(JsonGenerator.Feature.AUTO_CLOSE_TARGET);\n+        MyStream output = new MyStream();\n+        JsonGenerator jg = f.createJsonGenerator(output, JsonEncoding.UTF8);\n+\n+        assertFalse(output.isClosed());\n+        jg.writeNumber(39);\n+        jg.close();\n+        assertFalse(output.isClosed());\n+    }\n+\n+    public void testAutoCloseArraysAndObjects()\n+        throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+        // let's verify default setting, first:\n+        assertTrue(f.isEnabled(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT));\n+        StringWriter sw = new StringWriter();\n+\n+        // First, test arrays:\n+        JsonGenerator jg = f.createJsonGenerator(sw);\n+        jg.writeStartArray();\n+        jg.close();\n+        assertEquals(\"[]\", sw.toString());\n+\n+        // Then objects\n+        sw = new StringWriter();\n+        jg = f.createJsonGenerator(sw);\n+        jg.writeStartObject();\n+        jg.close();\n+        assertEquals(\"{}\", sw.toString());\n+    }\n+\n+    public void testNoAutoCloseArraysAndObjects()\n+        throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+        f.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator jg = f.createJsonGenerator(sw);\n+        jg.writeStartArray();\n+        jg.close();\n+        // shouldn't close\n+        assertEquals(\"[\", sw.toString());\n+\n+        // Then objects\n+        sw = new StringWriter();\n+        jg = f.createJsonGenerator(sw);\n+        jg.writeStartObject();\n+        jg.close();\n+        assertEquals(\"{\", sw.toString());\n+    }\n+\n+    // [JACKSON-401]\n+    public void testAutoFlushOrNot() throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+        assertTrue(f.isEnabled(JsonGenerator.Feature.FLUSH_PASSED_TO_STREAM));\n+        MyChars sw = new MyChars();\n+        JsonGenerator jg = f.createJsonGenerator(sw);\n+        jg.writeStartArray();\n+        jg.writeEndArray();\n+        assertEquals(0, sw.flushed);\n+        jg.flush();\n+        assertEquals(1, sw.flushed);\n+        jg.close();\n+        \n+        // ditto with stream\n+        MyBytes bytes = new MyBytes();\n+        jg = f.createJsonGenerator(bytes, JsonEncoding.UTF8);\n+        jg.writeStartArray();\n+        jg.writeEndArray();\n+        assertEquals(0, bytes.flushed);\n+        jg.flush();\n+        assertEquals(1, bytes.flushed);\n+        assertEquals(2, bytes.toByteArray().length);\n+        jg.close();\n+\n+        // then disable and we should not see flushing again...\n+        f.disable(JsonGenerator.Feature.FLUSH_PASSED_TO_STREAM);\n+        // first with a Writer\n+        sw = new MyChars();\n+        jg = f.createJsonGenerator(sw);\n+        jg.writeStartArray();\n+        jg.writeEndArray();\n+        assertEquals(0, sw.flushed);\n+        jg.flush();\n+        assertEquals(0, sw.flushed);\n+        jg.close();\n+        assertEquals(\"[]\", sw.toString());\n+\n+        // and then with OutputStream\n+        bytes = new MyBytes();\n+        jg = f.createJsonGenerator(bytes, JsonEncoding.UTF8);\n+        jg.writeStartArray();\n+        jg.writeEndArray();\n+        assertEquals(0, bytes.flushed);\n+        jg.flush();\n+        assertEquals(0, bytes.flushed);\n+        jg.close();\n+        assertEquals(2, bytes.toByteArray().length);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestGeneratorCopy.java\n+package com.fasterxml.jackson.core.main;\n+\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.test.BaseTest;\n+\n+import java.io.*;\n+\n+/**\n+ * Set of basic unit tests for verifying that copy-through methods\n+ * of {@link JsonGenerator} work as expected.\n+ */\n+public class TestGeneratorCopy\n+    extends BaseTest\n+{\n+    public void testCopyRootTokens()\n+        throws IOException\n+    {\n+        JsonFactory jf = new JsonFactory();\n+        final String DOC = \"\\\"text\\\\non two lines\\\" true false 2.0\";\n+        JsonParser jp = jf.createJsonParser(new StringReader(DOC));\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator gen = jf.createJsonGenerator(sw);\n+\n+        JsonToken t;\n+\n+        while ((t = jp.nextToken()) != null) {\n+            gen.copyCurrentEvent(jp);\n+            // should not change parser state:\n+            assertToken(t, jp.getCurrentToken());\n+        }\n+        jp.close();\n+        gen.close();\n+\n+        assertEquals(\"\\\"text\\\\non two lines\\\" true false 2.0\", sw.toString());\n+    }\n+\n+    public void testCopyArrayTokens()\n+        throws IOException\n+    {\n+        JsonFactory jf = new JsonFactory();\n+        final String DOC = \"123 [ 1, null, [ false ] ]\";\n+        JsonParser jp = jf.createJsonParser(new StringReader(DOC));\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator gen = jf.createJsonGenerator(sw);\n+\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        gen.copyCurrentEvent(jp);\n+        // should not change parser state:\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.getCurrentToken());\n+        assertEquals(123, jp.getIntValue());\n+\n+        // And then let's copy the array\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        gen.copyCurrentStructure(jp);\n+        // which will advance parser to matching close Array\n+        assertToken(JsonToken.END_ARRAY, jp.getCurrentToken());\n+        jp.close();\n+        gen.close();\n+\n+        assertEquals(\"123 [1,null,[false]]\", sw.toString());\n+    }\n+\n+    public void testCopyObjectTokens()\n+        throws IOException\n+    {\n+        JsonFactory jf = new JsonFactory();\n+        final String DOC = \"{ \\\"a\\\":1, \\\"b\\\":[{ \\\"c\\\" : null }] }\";\n+        JsonParser jp = jf.createJsonParser(new StringReader(DOC));\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator gen = jf.createJsonGenerator(sw);\n+\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        gen.copyCurrentStructure(jp);\n+        // which will advance parser to matching end Object\n+        assertToken(JsonToken.END_OBJECT, jp.getCurrentToken());\n+        jp.close();\n+        gen.close();\n+\n+        assertEquals(\"{\\\"a\\\":1,\\\"b\\\":[{\\\"c\\\":null}]}\", sw.toString());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestGeneratorMisc.java\n+package com.fasterxml.jackson.core.main;\n+\n+import java.io.*;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.concurrent.atomic.*;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+/**\n+ * Set of basic unit tests for verifying basic generator\n+ * features.\n+ */\n+public class TestGeneratorMisc\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Tests for closing, status\n+    /**********************************************************\n+     */\n+\n+    public void testIsClosed()\n+        throws IOException\n+    {\n+        JsonFactory jf = new JsonFactory();\n+        for (int i = 0; i < 2; ++i) {\n+            boolean stream = ((i & 1) == 0);\n+            JsonGenerator jg = stream ?\n+                jf.createJsonGenerator(new StringWriter())\n+                : jf.createJsonGenerator(new ByteArrayOutputStream(), JsonEncoding.UTF8)\n+                ;\n+            assertFalse(jg.isClosed());\n+            jg.writeStartArray();\n+            jg.writeNumber(-1);\n+            jg.writeEndArray();\n+            assertFalse(jg.isClosed());\n+            jg.close();\n+            assertTrue(jg.isClosed());\n+            jg.close();\n+            assertTrue(jg.isClosed());\n+        }\n+    }\n+\n+    // Also, \"very simple\" objects are supported even without Codec:\n+    public void testSimpleWriteObject() throws IOException\n+    {\n+        // note: NOT mapping factory, for this test\n+        JsonFactory jf = new JsonFactory();\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator gen = jf.createJsonGenerator(sw);\n+        gen.writeStartArray();\n+\n+        // simple wrappers first\n+        gen.writeObject(Integer.valueOf(1));\n+        gen.writeObject(Short.valueOf((short)-2));\n+        gen.writeObject(Long.valueOf(3));\n+        gen.writeObject(Byte.valueOf((byte)-4));\n+        gen.writeObject(Double.valueOf(0.25));\n+        gen.writeObject(Float.valueOf(-0.125f));\n+        gen.writeObject(Boolean.TRUE);\n+        gen.close();\n+        String act = sw.toString().trim();\n+        assertEquals(\"[1,-2,3,-4,0.25,-0.125,true]\", act);\n+        \n+        // then other basic types\n+        sw = new StringWriter();\n+        gen = jf.createJsonGenerator(sw);\n+        gen.writeStartArray();\n+        gen.writeObject(BigInteger.valueOf(1234));\n+        gen.writeObject(new BigDecimal(0.5));\n+        gen.writeEndArray();\n+        gen.close();\n+        act = sw.toString().trim();\n+        assertEquals(\"[1234,0.5]\", act);\n+\n+        // then Atomic types\n+        sw = new StringWriter();\n+        gen = jf.createJsonGenerator(sw);\n+        gen.writeStartArray();\n+        gen.writeObject(new AtomicBoolean(false));\n+        gen.writeObject(new AtomicInteger(13));\n+        gen.writeObject(new AtomicLong(-127L));\n+        gen.writeEndArray();\n+        gen.close();\n+        act = sw.toString().trim();\n+        assertEquals(\"[false,13,-127]\", act);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Tests for raw output\n+    /**********************************************************\n+     */\n+\n+    public void testRaw() throws IOException\n+    {\n+        JsonFactory jf = new JsonFactory();\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator gen = jf.createJsonGenerator(sw);\n+        gen.writeStartArray();\n+        gen.writeRaw(\"-123, true\");\n+        gen.writeRaw(\", \\\"x\\\"  \");\n+        gen.writeEndArray();\n+        gen.close();\n+\n+                \n+        JsonParser jp = createParserUsingReader(sw.toString());\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(-123, jp.getIntValue());\n+        assertToken(JsonToken.VALUE_TRUE, jp.nextToken());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(\"x\", jp.getText());\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        jp.close();\n+    }\n+\n+    public void testRawValue() throws IOException\n+    {\n+        JsonFactory jf = new JsonFactory();\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator gen = jf.createJsonGenerator(sw);\n+        gen.writeStartArray();\n+        gen.writeRawValue(\"7\");\n+        gen.writeRawValue(\"[ null ]\");\n+        gen.writeRawValue(\"false\");\n+        gen.writeEndArray();\n+        gen.close();\n+\n+        JsonParser jp = createParserUsingReader(sw.toString());\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(7, jp.getIntValue());\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_NULL, jp.nextToken());\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_FALSE, jp.nextToken());\n+\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        jp.close();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Tests for binary data\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * This is really inadequate test, all in all, but should serve\n+     * as some kind of sanity check. Reader-side should more thoroughly\n+     * test things, as it does need writers to construct the data first.\n+     */\n+    public void testBinaryWrite() throws Exception\n+    {\n+        _testBinaryWrite(false);\n+        _testBinaryWrite(true);\n+    }\n+\n+    private void _testBinaryWrite(boolean useCharBased) throws Exception\n+    {\n+        /* The usual sample input string, from Thomas Hobbes's \"Leviathan\"\n+         * (via Wikipedia)\n+         */\n+        final String INPUT = \"Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.\";\n+        final byte[] INPUT_BYTES = INPUT.getBytes(\"US-ASCII\");\n+        // as per MIME variant, result minus lfs =\n+        final String OUTPUT =\n+ \"TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlz\"\n++\"IHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2Yg\"\n++\"dGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGlu\"\n++\"dWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRo\"\n++\"ZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=\"\n+            ;\n+\n+        /* Let's only test the standard base64 variant; but write\n+         * values in root, array and object contexts.\n+         */\n+        Base64Variant b64v = Base64Variants.getDefaultVariant();\n+        JsonFactory jf = new JsonFactory();\n+\n+        for (int i = 0; i < 3; ++i) {\n+            JsonGenerator gen;\n+            ByteArrayOutputStream bout = new ByteArrayOutputStream(200);\n+            if (useCharBased) {\n+                gen = jf.createJsonGenerator(new OutputStreamWriter(bout, \"UTF-8\"));\n+            } else {\n+                gen = jf.createJsonGenerator(bout, JsonEncoding.UTF8);\n+            }\n+\n+            switch (i) {\n+            case 0: // root\n+                gen.writeBinary(b64v, INPUT_BYTES, 0, INPUT_BYTES.length);\n+                break;\n+            case 1: // array\n+                gen.writeStartArray();\n+                gen.writeBinary(b64v, INPUT_BYTES, 0, INPUT_BYTES.length);\n+                gen.writeEndArray();\n+                break;\n+            default: // object\n+                gen.writeStartObject();\n+                gen.writeFieldName(\"field\");\n+                gen.writeBinary(b64v, INPUT_BYTES, 0, INPUT_BYTES.length);\n+                gen.writeEndObject();\n+                break;\n+            }\n+            gen.close();\n+\n+            JsonParser jp = jf.createJsonParser(new ByteArrayInputStream(bout.toByteArray()));\n+            \n+            // Need to skip other events before binary data:\n+            switch (i) {\n+            case 0:\n+                break;\n+            case 1:\n+                assertEquals(JsonToken.START_ARRAY, jp.nextToken());\n+                break;\n+            default:\n+                assertEquals(JsonToken.START_OBJECT, jp.nextToken());\n+                assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+                break;\n+            }\n+            assertEquals(JsonToken.VALUE_STRING, jp.nextToken());\n+            String actualValue = jp.getText();\n+            jp.close();\n+            assertEquals(OUTPUT, actualValue);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Tests for object writing\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Unit test that tries to trigger buffer-boundary conditions\n+     */\n+    public void testLongerObjects() throws Exception\n+    {\n+        JsonFactory jf = new JsonFactory();\n+        for (int i = 0; i < 2; ++i) {\n+            boolean useChars = (i == 0);\n+            JsonGenerator jgen;\n+            ByteArrayOutputStream bout = new ByteArrayOutputStream(200);\n+            if (useChars) {\n+                jgen = jf.createJsonGenerator(new OutputStreamWriter(bout, \"UTF-8\"));\n+            } else {\n+                jgen = jf.createJsonGenerator(bout, JsonEncoding.UTF8);\n+            }\n+\n+            jgen.writeStartObject();\n+\n+            for (int rounds = 0; rounds < 1500; ++rounds) {\n+                for (int letter = 'a'; letter <= 'z'; ++letter) {\n+                    for (int index = 0; index < 20; ++index) {\n+                        String name;\n+                        if (letter > 'f') {\n+                            name = \"X\"+letter+index;\n+                        } else if (letter > 'p') {\n+                            name = \"\"+letter+index;\n+                        } else {\n+                            name = \"__\"+index+letter;\n+                        }\n+                        jgen.writeFieldName(name);\n+                        jgen.writeNumber(index-1);\n+                    }\n+                    jgen.writeRaw('\\n');\n+                }\n+            }\n+            jgen.writeEndObject();\n+            jgen.close();\n+\n+            byte[] json = bout.toByteArray();\n+            JsonParser jp = jf.createJsonParser(json);\n+            assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+            for (int rounds = 0; rounds < 1500; ++rounds) {\n+            for (int letter = 'a'; letter <= 'z'; ++letter) {\n+                for (int index = 0; index < 20; ++index) {\n+                    assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+                    String name;\n+                    if (letter > 'f') {\n+                        name = \"X\"+letter+index;\n+                    } else if (letter > 'p') {\n+                        name = \"\"+letter+index;\n+                    } else {\n+                        name = \"__\"+index+letter;\n+                    }\n+                    assertEquals(name, jp.getCurrentName());\n+                    assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+                    assertEquals(index-1, jp.getIntValue());\n+                }\n+            }\n+            }\n+            assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestGeneratorObject.java\n+package com.fasterxml.jackson.core.main;\n+\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.test.BaseTest;\n+\n+import java.io.*;\n+import java.math.BigDecimal;\n+\n+/**\n+ * Set of basic unit tests for verifying that the Object write methods\n+ * of {@link JsonGenerator} work as expected.\n+ */\n+public class TestGeneratorObject\n+    extends BaseTest\n+{\n+    public void testEmptyObjectWrite()\n+        throws Exception\n+    {\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator gen = new JsonFactory().createJsonGenerator(sw);\n+\n+        JsonStreamContext ctxt = gen.getOutputContext();\n+        assertTrue(ctxt.inRoot());\n+        assertFalse(ctxt.inArray());\n+        assertFalse(ctxt.inObject());\n+        assertEquals(0, ctxt.getEntryCount());\n+        assertEquals(0, ctxt.getCurrentIndex());\n+\n+        gen.writeStartObject();\n+\n+        ctxt = gen.getOutputContext();\n+        assertFalse(ctxt.inRoot());\n+        assertFalse(ctxt.inArray());\n+        assertTrue(ctxt.inObject());\n+        assertEquals(0, ctxt.getEntryCount());\n+        assertEquals(0, ctxt.getCurrentIndex());\n+\n+        gen.writeEndObject();\n+\n+        ctxt = gen.getOutputContext();\n+        assertTrue(ctxt.inRoot());\n+        assertFalse(ctxt.inArray());\n+        assertFalse(ctxt.inObject());\n+        assertEquals(1, ctxt.getEntryCount());\n+        // Index won't yet move\n+        assertEquals(0, ctxt.getCurrentIndex());\n+\n+        gen.close();\n+\n+        String docStr = sw.toString();\n+        JsonParser jp = createParserUsingReader(docStr);\n+        assertEquals(JsonToken.START_OBJECT, jp.nextToken());\n+        assertEquals(JsonToken.END_OBJECT, jp.nextToken());\n+        assertEquals(null, jp.nextToken());\n+    }\n+\n+    public void testInvalidObjectWrite()\n+        throws Exception\n+    {\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator gen = new JsonFactory().createJsonGenerator(sw);\n+        gen.writeStartObject();\n+        // Mismatch:\n+        try {\n+            gen.writeEndArray();\n+            fail(\"Expected an exception for mismatched array/object write\");\n+        } catch (JsonGenerationException e) {\n+            verifyException(e, \"Current context not an array\");\n+        }\n+    }\n+\n+    public void testSimpleObjectWrite()\n+        throws Exception\n+    {\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator gen = new JsonFactory().createJsonGenerator(sw);\n+        gen.writeStartObject();\n+        gen.writeFieldName(\"first\");\n+        gen.writeNumber(-901);\n+        gen.writeFieldName(\"sec\");\n+        gen.writeBoolean(false);\n+        gen.writeFieldName(\"3rd!\"); // json field names are just strings, not ids with restrictions\n+        gen.writeString(\"yee-haw\");\n+        gen.writeEndObject();\n+        gen.close();\n+        String docStr = sw.toString();\n+        JsonParser jp = createParserUsingReader(docStr);\n+        assertEquals(JsonToken.START_OBJECT, jp.nextToken());\n+        assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"first\", jp.getText());\n+        assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(-901, jp.getIntValue());\n+        assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"sec\", jp.getText());\n+        assertEquals(JsonToken.VALUE_FALSE, jp.nextToken());\n+        assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"3rd!\", jp.getText());\n+        assertEquals(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(\"yee-haw\", jp.getText());\n+        assertEquals(JsonToken.END_OBJECT, jp.nextToken());\n+        assertEquals(null, jp.nextToken());\n+        jp.close();\n+    }\n+\n+    /**\n+     * Methods to test functionality added for [JACKSON-26]\n+     */\n+    public void testConvenienceMethods()\n+        throws Exception\n+    {\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator gen = new JsonFactory().createJsonGenerator(sw);\n+        gen.writeStartObject();\n+\n+        final BigDecimal dec = new BigDecimal(\"0.1\");\n+        final String TEXT = \"\\\"some\\nString!\\\"\";\n+\n+        gen.writeNullField(\"null\");\n+        gen.writeBooleanField(\"bt\", true);\n+        gen.writeBooleanField(\"bf\", false);\n+        gen.writeNumberField(\"int\", -1289);\n+        gen.writeNumberField(\"dec\", dec);\n+\n+        gen.writeObjectFieldStart(\"ob\");\n+        gen.writeStringField(\"str\", TEXT);\n+        gen.writeEndObject();\n+\n+        gen.writeArrayFieldStart(\"arr\");\n+        gen.writeEndArray();\n+\n+        gen.writeEndObject();\n+        gen.close();\n+\n+        String docStr = sw.toString();\n+        JsonParser jp = createParserUsingReader(docStr);\n+        assertEquals(JsonToken.START_OBJECT, jp.nextToken());\n+\n+        assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"null\", jp.getText());\n+        assertEquals(JsonToken.VALUE_NULL, jp.nextToken());\n+        assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"bt\", jp.getText());\n+        assertEquals(JsonToken.VALUE_TRUE, jp.nextToken());\n+        assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"bf\", jp.getText());\n+        assertEquals(JsonToken.VALUE_FALSE, jp.nextToken());\n+        assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"int\", jp.getText());\n+        assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"dec\", jp.getText());\n+        assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+\n+        assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"ob\", jp.getText());\n+        assertEquals(JsonToken.START_OBJECT, jp.nextToken());\n+        assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"str\", jp.getText());\n+        assertEquals(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(TEXT, getAndVerifyText(jp));\n+        assertEquals(JsonToken.END_OBJECT, jp.nextToken());\n+\n+        assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"arr\", jp.getText());\n+        assertEquals(JsonToken.START_ARRAY, jp.nextToken());\n+        assertEquals(JsonToken.END_ARRAY, jp.nextToken());\n+\n+        assertEquals(JsonToken.END_OBJECT, jp.nextToken());\n+        assertEquals(null, jp.nextToken());\n+        jp.close();\n+    }\n+\n+    /**\n+     * Tests to cover [JACKSON-164]\n+     */\n+    public void testConvenienceMethodsWithNulls()\n+        throws Exception\n+    {\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator gen = new JsonFactory().createJsonGenerator(sw);\n+        gen.writeStartObject();\n+\n+        gen.writeStringField(\"str\", null);\n+        gen.writeNumberField(\"num\", null);\n+        gen.writeObjectField(\"obj\", null);\n+\n+        gen.writeEndObject();\n+        gen.close();\n+\n+        String docStr = sw.toString();\n+        JsonParser jp = createParserUsingReader(docStr);\n+        assertEquals(JsonToken.START_OBJECT, jp.nextToken());\n+\n+        assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"str\", jp.getCurrentName());\n+        assertEquals(JsonToken.VALUE_NULL, jp.nextToken());\n+\n+        assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"num\", jp.getCurrentName());\n+        assertEquals(JsonToken.VALUE_NULL, jp.nextToken());\n+\n+        assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"obj\", jp.getCurrentName());\n+        assertEquals(JsonToken.VALUE_NULL, jp.nextToken());\n+\n+        assertEquals(JsonToken.END_OBJECT, jp.nextToken());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestGeneratorWithSerializedString.java\n+package com.fasterxml.jackson.core.main;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.io.SerializedString;\n+\n+public class TestGeneratorWithSerializedString\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    final static String NAME_WITH_QUOTES = \"\\\"name\\\"\";\n+    final static String NAME_WITH_LATIN1 = \"P\\u00f6ll\\u00f6\";\n+\n+    private final SerializedString quotedName = new SerializedString(NAME_WITH_QUOTES);\n+    private final SerializedString latin1Name = new SerializedString(NAME_WITH_LATIN1);\n+    \n+    public void testSimple() throws Exception\n+    {\n+        JsonFactory jf = new JsonFactory();\n+\n+        // First using char-backed generator\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator jgen = jf.createJsonGenerator(sw);\n+        _writeSimple(jgen);\n+        jgen.close();\n+        String json = sw.toString();\n+        _verifySimple(jf.createJsonParser(json));\n+\n+        // then using UTF-8\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        jgen = jf.createJsonGenerator(out, JsonEncoding.UTF8);\n+        _writeSimple(jgen);\n+        jgen.close();\n+        byte[] jsonB = out.toByteArray();\n+        _verifySimple(jf.createJsonParser(jsonB));\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+    \n+    private void _writeSimple(JsonGenerator jgen) throws Exception\n+    {\n+        // Let's just write array of 2 objects\n+        jgen.writeStartArray();\n+\n+        jgen.writeStartObject();\n+        jgen.writeFieldName(quotedName);\n+        jgen.writeString(\"a\");\n+        jgen.writeFieldName(latin1Name);\n+        jgen.writeString(\"b\");\n+        jgen.writeEndObject();\n+\n+        jgen.writeStartObject();\n+        jgen.writeFieldName(latin1Name);\n+        jgen.writeString(\"c\");\n+        jgen.writeFieldName(quotedName);\n+        jgen.writeString(\"d\");\n+        jgen.writeEndObject();\n+        \n+        jgen.writeEndArray();\n+    }\n+\n+    private void _verifySimple(JsonParser jp) throws Exception\n+    {\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(NAME_WITH_QUOTES, jp.getText());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(\"a\", jp.getText());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(NAME_WITH_LATIN1, jp.getText());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(\"b\", jp.getText());\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(NAME_WITH_LATIN1, jp.getText());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(\"c\", jp.getText());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(NAME_WITH_QUOTES, jp.getText());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(\"d\", jp.getText());\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+        \n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        assertNull(jp.nextToken());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestJsonFactory.java\n+package com.fasterxml.jackson.core.main;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+public class TestJsonFactory\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    public void testGeneratorFeatures() throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+        assertNull(f.getCodec());\n+\n+        f.configure(JsonGenerator.Feature.QUOTE_FIELD_NAMES, true);\n+        assertTrue(f.isEnabled(JsonGenerator.Feature.QUOTE_FIELD_NAMES));\n+        f.configure(JsonGenerator.Feature.QUOTE_FIELD_NAMES, false);\n+        assertFalse(f.isEnabled(JsonGenerator.Feature.QUOTE_FIELD_NAMES));\n+    }\n+\n+    public void testParserFeatures() throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+        assertNull(f.getCodec());\n+\n+        f.configure(JsonParser.Feature.INTERN_FIELD_NAMES, true);\n+        assertTrue(f.isEnabled(JsonParser.Feature.INTERN_FIELD_NAMES));\n+        f.configure(JsonParser.Feature.INTERN_FIELD_NAMES, false);\n+        assertFalse(f.isEnabled(JsonParser.Feature.INTERN_FIELD_NAMES));\n+    }\n+    \n+    public void testJsonWithFiles() throws Exception\n+    {\n+        File file = File.createTempFile(\"jackson-test\", null);\n+        file.deleteOnExit();\n+        \n+        JsonFactory f = new JsonFactory();\n+\n+        // First: create file via generator.. and use an odd encoding\n+        JsonGenerator jg = f.createJsonGenerator(file, JsonEncoding.UTF16_LE);\n+        jg.writeStartObject();\n+        jg.writeRaw(\"   \");\n+        jg.writeEndObject();\n+        jg.close();\n+\n+        // Ok: first read file directly\n+        JsonParser jp = f.createJsonParser(file);\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+        assertNull(jp.nextToken());\n+        jp.close();\n+\n+        // Then via URL:\n+        jp = f.createJsonParser(file.toURI().toURL());\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+        assertNull(jp.nextToken());\n+        jp.close();\n+\n+        // ok, delete once we are done\n+        file.delete();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestJsonGenerator.java\n+package com.fasterxml.jackson.core.main;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+import java.io.*;\n+\n+/**\n+ * Set of basic unit tests for verifying that the basic generator\n+ * functionality works as expected.\n+ */\n+public class TestJsonGenerator\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    // // // First, tests for primitive (non-structured) values\n+\n+    public void testStringWrite()\n+        throws Exception\n+    {\n+        JsonFactory jf = new JsonFactory();\n+        String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" };\n+        for (int useReader = 0; useReader < 2; ++useReader) {\n+            for (int writeString = 0; writeString < 2; ++writeString) {\n+                for (int strIx = 0; strIx < inputStrings.length; ++strIx) {\n+                    String input = inputStrings[strIx];\n+                    JsonGenerator gen;\n+                    ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+                    if (useReader != 0) {\n+                        gen = jf.createJsonGenerator(new OutputStreamWriter(bout, \"UTF-8\"));\n+                    } else {\n+                        gen = jf.createJsonGenerator(bout, JsonEncoding.UTF8);\n+                    }\n+                    if (writeString > 0) {\n+                        gen.writeString(input);\n+                    } else {\n+                        int len = input.length();\n+                        char[] buffer = new char[len + 20];\n+                        // Let's use non-zero base offset too...\n+                        input.getChars(0, len, buffer, strIx);\n+                        gen.writeString(buffer, strIx, len);\n+                    }\n+                    gen.flush();\n+                    gen.close();\n+                    JsonParser jp = jf.createJsonParser(new ByteArrayInputStream(bout.toByteArray()));\n+                \n+                    JsonToken t = jp.nextToken();\n+                    assertNotNull(\"Document \\\"\"+bout.toString(\"UTF-8\")+\"\\\" yielded no tokens\", t);\n+                    assertEquals(JsonToken.VALUE_STRING, t);\n+                    assertEquals(input, jp.getText());\n+                    assertEquals(null, jp.nextToken());\n+                    jp.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    public void testIntWrite()\n+        throws Exception\n+    {\n+        doTestIntWrite(false);\n+        doTestIntWrite(true);\n+    }\n+\n+    public void testLongWrite()\n+        throws Exception\n+    {\n+        doTestLongWrite(false);\n+        doTestLongWrite(true);\n+    }\n+\n+    public void testBooleanWrite()\n+        throws Exception\n+    {\n+        for (int i = 0; i < 4; ++i) {\n+            boolean state = (i & 1) == 0;\n+            boolean pad = (i & 2) == 0;\n+            StringWriter sw = new StringWriter();\n+            JsonGenerator gen = new JsonFactory().createJsonGenerator(sw);\n+            gen.writeBoolean(state);\n+            if (pad) {\n+                gen.writeRaw(\" \");\n+            }\n+            gen.close();\n+            String docStr = sw.toString();\n+            JsonParser jp = createParserUsingReader(docStr);\n+            JsonToken t = jp.nextToken();\n+            String exp = Boolean.valueOf(state).toString();\n+            if (!exp.equals(jp.getText())) {\n+                fail(\"Expected '\"+exp+\"', got '\"+jp.getText());\n+            }\n+            assertEquals(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE, t);\n+            assertEquals(null, jp.nextToken());\n+            jp.close();\n+        }\n+    }\n+\n+    public void testNullWrite()\n+        throws Exception\n+    {\n+        for (int i = 0; i < 2; ++i) {\n+            boolean pad = (i & 1) == 0;\n+            StringWriter sw = new StringWriter();\n+            JsonGenerator gen = new JsonFactory().createJsonGenerator(sw);\n+            gen.writeNull();\n+            if (pad) {\n+                gen.writeRaw(\" \");\n+            }\n+            gen.close();\n+            String docStr = sw.toString();\n+            JsonParser jp = createParserUsingReader(docStr);\n+            JsonToken t = jp.nextToken();\n+            String exp = \"null\";\n+            if (!exp.equals(jp.getText())) {\n+                fail(\"Expected '\"+exp+\"', got '\"+jp.getText());\n+            }\n+            assertEquals(JsonToken.VALUE_NULL, t);\n+            assertEquals(null, jp.nextToken());\n+            jp.close();\n+        }\n+    }\n+    \n+    // // Then root-level output testing\n+\n+     public void testRootIntsWrite()\n+         throws Exception\n+     {\n+         StringWriter sw = new StringWriter();\n+         JsonGenerator gen = new JsonFactory().createJsonGenerator(sw);\n+         gen.writeNumber(1);\n+         gen.writeNumber(2);\n+         gen.writeNumber(-13);\n+         gen.close();\n+\n+         String docStr = sw.toString();\n+\n+         JsonParser jp = createParserUsingReader(docStr);\n+         assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+         assertEquals(1, jp.getIntValue());\n+         assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+         assertEquals(2, jp.getIntValue());\n+         assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+         assertEquals(-13, jp.getIntValue());\n+         jp.close();\n+     }\n+    \n+    // Convenience methods\n+    \n+    public void testFieldValueWrites()\n+         throws Exception\n+     {\n+         StringWriter sw = new StringWriter();\n+         JsonGenerator gen = new JsonFactory().createJsonGenerator(sw);\n+         gen.writeStartObject();\n+         gen.writeNumberField(\"long\", 3L);\n+         gen.writeNumberField(\"double\", 0.25);\n+         gen.writeNumberField(\"float\", -0.25f);\n+         gen.writeEndObject();\n+         gen.close();\n+\n+         assertEquals(\"{\\\"long\\\":3,\\\"double\\\":0.25,\\\"float\\\":-0.25}\", sw.toString().trim());\n+     }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+    \n+    private void doTestIntWrite(boolean pad)\n+        throws Exception\n+    {\n+        int[] VALUES = new int[] {\n+            0, 1, -9, 32, -32, 57, 13240, -9999, Integer.MAX_VALUE, Integer.MAX_VALUE\n+        };\n+        for (int i = 0; i < VALUES.length; ++i) {\n+            int VALUE = VALUES[i];\n+            StringWriter sw = new StringWriter();\n+            JsonGenerator gen = new JsonFactory().createJsonGenerator(sw);\n+            gen.writeNumber(VALUE);\n+            if (pad) {\n+                gen.writeRaw(\" \");\n+            }\n+            gen.close();\n+            String docStr = sw.toString();\n+            JsonParser jp = createParserUsingReader(docStr);\n+            JsonToken t = jp.nextToken();\n+            assertNotNull(\"Document \\\"\"+docStr+\"\\\" yielded no tokens\", t);\n+            // Number are always available as lexical representation too\n+            String exp = \"\"+VALUE;\n+            if (!exp.equals(jp.getText())) {\n+                fail(\"Expected '\"+exp+\"', got '\"+jp.getText());\n+            }\n+            assertEquals(JsonToken.VALUE_NUMBER_INT, t);\n+            assertEquals(VALUE, jp.getIntValue());\n+            assertEquals(null, jp.nextToken());\n+            jp.close();\n+        }\n+    }\n+\n+    private void doTestLongWrite(boolean pad)\n+        throws Exception\n+    {\n+        long[] VALUES = new long[] {\n+            0L, 1L, -1L, -12005002294L, Long.MIN_VALUE, Long.MAX_VALUE\n+        };\n+        for (int i = 0; i < VALUES.length; ++i) {\n+            long VALUE = VALUES[i];\n+            StringWriter sw = new StringWriter();\n+            JsonGenerator gen = new JsonFactory().createJsonGenerator(sw);\n+            gen.writeNumber(VALUE);\n+            if (pad) {\n+                gen.writeRaw(\" \");\n+            }\n+            gen.close();\n+            String docStr = sw.toString();\n+            JsonParser jp = createParserUsingReader(docStr);\n+            JsonToken t = jp.nextToken();\n+            assertNotNull(\"Document \\\"\"+docStr+\"\\\" yielded no tokens\", t);\n+            String exp = \"\"+VALUE;\n+            if (!exp.equals(jp.getText())) {\n+                fail(\"Expected '\"+exp+\"', got '\"+jp.getText());\n+            }\n+            assertEquals(JsonToken.VALUE_NUMBER_INT, t);\n+            assertEquals(VALUE, jp.getLongValue());\n+            assertEquals(null, jp.nextToken());\n+            jp.close();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestJsonGeneratorFeatures.java\n+package com.fasterxml.jackson.core.main;\n+\n+import java.io.*;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+/**\n+ * Set of basic unit tests for verifying that the basic generator\n+ * functionality works as expected.\n+ */\n+public class TestJsonGeneratorFeatures\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    public void testConfigDefaults() throws IOException\n+    {\n+        JsonFactory jf = new JsonFactory();\n+        JsonGenerator jg = jf.createJsonGenerator(new StringWriter());\n+        assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS));\n+    }\n+\n+    public void testFieldNameQuoting() throws IOException\n+    {\n+        JsonFactory jf = new JsonFactory();\n+        // by default, quoting should be enabled\n+        _testFieldNameQuoting(jf, true);\n+        // can disable it\n+        jf.disable(JsonGenerator.Feature.QUOTE_FIELD_NAMES);\n+        _testFieldNameQuoting(jf, false);\n+        // and (re)enable:\n+        jf.enable(JsonGenerator.Feature.QUOTE_FIELD_NAMES);\n+        _testFieldNameQuoting(jf, true);\n+    }\n+\n+    public void testNonNumericQuoting()\n+        throws IOException\n+    {\n+        JsonFactory jf = new JsonFactory();\n+        // by default, quoting should be enabled\n+        _testNonNumericQuoting(jf, true);\n+        // can disable it\n+        jf.disable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS);\n+        _testNonNumericQuoting(jf, false);\n+        // and (re)enable:\n+        jf.enable(JsonGenerator.Feature.QUOTE_NON_NUMERIC_NUMBERS);\n+        _testNonNumericQuoting(jf, true);\n+    }\n+\n+    /**\n+     * Testing for [JACKSON-176], ability to force serializing numbers\n+     * as JSON Strings.\n+     */\n+    public void testNumbersAsJSONStrings() throws IOException\n+    {\n+        JsonFactory jf = new JsonFactory();\n+        // by default should output numbers as-is:\n+        assertEquals(\"[1,2,1.25,2.25,3001,0.5,-1]\", _writeNumbers(jf));        \n+\n+        // but if overridden, quotes as Strings\n+        jf.configure(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS, true);\n+        assertEquals(\"[\\\"1\\\",\\\"2\\\",\\\"1.25\\\",\\\"2.25\\\",\\\"3001\\\",\\\"0.5\\\",\\\"-1\\\"]\",\n+                     _writeNumbers(jf));\n+    }\n+\n+    private String _writeNumbers(JsonFactory jf) throws IOException\n+    {\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator jg = jf.createJsonGenerator(sw);\n+    \n+        jg.writeStartArray();\n+        jg.writeNumber(1);\n+        jg.writeNumber(2L);\n+        jg.writeNumber(1.25);\n+        jg.writeNumber(2.25f);\n+        jg.writeNumber(BigInteger.valueOf(3001));\n+        jg.writeNumber(BigDecimal.valueOf(0.5));\n+        jg.writeNumber(\"-1\");\n+        jg.writeEndArray();\n+        jg.close();\n+\n+        return sw.toString();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    private void _testFieldNameQuoting(JsonFactory jf, boolean quoted)\n+        throws IOException\n+    {\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator jg = jf.createJsonGenerator(sw);\n+        jg.writeStartObject();\n+        jg.writeFieldName(\"foo\");\n+        jg.writeNumber(1);\n+        jg.writeEndObject();\n+        jg.close();\n+\n+        String result = sw.toString();\n+        if (quoted) {\n+            assertEquals(\"{\\\"foo\\\":1}\", result);\n+        } else {\n+            assertEquals(\"{foo:1}\", result);\n+        }\n+    }\n+    private void _testNonNumericQuoting(JsonFactory jf, boolean quoted)\n+        throws IOException\n+    {\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator jg = jf.createJsonGenerator(sw);\n+        jg.writeStartObject();\n+        jg.writeFieldName(\"double\");\n+        jg.writeNumber(Double.NaN);\n+        jg.writeEndObject();\n+        jg.writeStartObject();\n+        jg.writeFieldName(\"float\");\n+        jg.writeNumber(Float.NaN);\n+        jg.writeEndObject();\n+        jg.close();\n+\t\n+        String result = sw.toString();\n+        if (quoted) {\n+            assertEquals(\"{\\\"double\\\":\\\"NaN\\\"} {\\\"float\\\":\\\"NaN\\\"}\", result);\n+        } else {\n+            assertEquals(\"{\\\"double\\\":NaN} {\\\"float\\\":NaN}\", result);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestJsonParserSymbols.java\n+package com.fasterxml.jackson.core.main;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.json.UTF8StreamJsonParser;\n+\n+/**\n+ * Unit tests for verifying that {@link JsonParser} instances properly\n+ * merge back symbols to the root symbol table\n+ */\n+public class TestJsonParserSymbols\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    /**\n+     * To peek into state of \"root\" symbol tables (parent of all symbol\n+     * tables for parsers constructed by this factory) we need to\n+     * add some methods.\n+     */\n+    final static class MyJsonFactory extends JsonFactory\n+    {\n+        public int byteSymbolCount() { return _rootByteSymbols.size(); }\n+        public int charSymbolCount() { return _rootCharSymbols.size(); }\n+    }\n+\n+    final static String JSON = \"{ \\\"a\\\" : 3, \\\"aaa\\\" : 4, \\\"_a\\\" : 0 }\";\n+\n+    public void testByteSymbolsWithClose() throws Exception\n+    {\n+        _testWithClose(true);\n+    }\n+\n+    public void testByteSymbolsWithEOF() throws Exception\n+    {\n+        MyJsonFactory f = new MyJsonFactory();\n+        JsonParser jp = _getParser(f, JSON, true);\n+        while (jp.nextToken() != null) {\n+            // shouldn't update before hitting end\n+            assertEquals(0, f.byteSymbolCount());\n+        }\n+        // but now should have it after hitting EOF\n+        assertEquals(3, f.byteSymbolCount());\n+        jp.close();\n+        assertEquals(3, f.byteSymbolCount());\n+    }\n+\n+    public void testCharSymbolsWithClose() throws Exception\n+    {\n+        _testWithClose(false);\n+    }\n+\n+    public void testCharSymbolsWithEOF() throws Exception\n+    {\n+        MyJsonFactory f = new MyJsonFactory();\n+        JsonParser jp = _getParser(f, JSON, false);\n+        while (jp.nextToken() != null) {\n+            // shouldn't update before hitting end\n+            assertEquals(0, f.charSymbolCount());\n+        }\n+        // but now should have it\n+        assertEquals(3, f.charSymbolCount());\n+        jp.close();\n+        assertEquals(3, f.charSymbolCount());\n+    }\n+\n+    /*\n+    ////////////////////////////////////\n+    // Helper methods\n+    ////////////////////////////////////\n+     */\n+\n+    private void _testWithClose(boolean useBytes) throws IOException\n+    {\n+        MyJsonFactory f = new MyJsonFactory();\n+        JsonParser jp = _getParser(f, JSON, useBytes);\n+        // Let's check 2 names\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+\n+        // shouldn't update before close or EOF:\n+        assertEquals(0, useBytes ? f.byteSymbolCount() : f.charSymbolCount());\n+        jp.close();\n+        // but should after close\n+        assertEquals(2, useBytes ? f.byteSymbolCount() : f.charSymbolCount());\n+    }\n+\n+    private JsonParser _getParser(MyJsonFactory f, String doc, boolean useBytes) throws IOException\n+    {\n+        JsonParser jp;\n+        if (useBytes) {\n+            jp = f.createJsonParser(doc.getBytes(\"UTF-8\"));\n+            assertEquals(UTF8StreamJsonParser.class, jp.getClass());\n+            assertEquals(0, f.byteSymbolCount());\n+        } else {\n+            jp = f.createJsonParser(doc);\n+            assertEquals(UTF8StreamJsonParser.class, jp.getClass());\n+            assertEquals(0, f.charSymbolCount());\n+        }\n+        return jp;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestNumberParsing.java\n+package com.fasterxml.jackson.core.main;\n+\n+import com.fasterxml.jackson.core.io.NumberInput;\n+\n+/**\n+ * Set of basic unit tests for verifying that the low-level number\n+ * handling methods work as expected.\n+ */\n+public class TestNumberParsing\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    public void testIntParsing() throws Exception\n+    {\n+        char[] testChars = \"123456789\".toCharArray();\n+\n+        assertEquals(3, NumberInput.parseInt(testChars, 2, 1));\n+        assertEquals(123, NumberInput.parseInt(testChars, 0, 3));\n+        assertEquals(2345, NumberInput.parseInt(testChars, 1, 4));\n+        assertEquals(9, NumberInput.parseInt(testChars, 8, 1));\n+        assertEquals(456789, NumberInput.parseInt(testChars, 3, 6));\n+        assertEquals(23456, NumberInput.parseInt(testChars, 1, 5));\n+        assertEquals(123456789, NumberInput.parseInt(testChars, 0, 9));\n+\n+        testChars = \"32\".toCharArray();\n+        assertEquals(32, NumberInput.parseInt(testChars, 0, 2));\n+        testChars = \"189\".toCharArray();\n+        assertEquals(189, NumberInput.parseInt(testChars, 0, 3));\n+\n+        testChars = \"10\".toCharArray();\n+        assertEquals(10, NumberInput.parseInt(testChars, 0, 2));\n+        assertEquals(0, NumberInput.parseInt(testChars, 1, 1));\n+    }\n+\n+    public void testIntParsingWithStrings() throws Exception\n+    {\n+        assertEquals(3, NumberInput.parseInt(\"3\"));\n+        assertEquals(0, NumberInput.parseInt(\"0\"));\n+        assertEquals(-3, NumberInput.parseInt(\"-3\"));\n+        assertEquals(27, NumberInput.parseInt(\"27\"));\n+        assertEquals(-31, NumberInput.parseInt(\"-31\"));\n+        assertEquals(271, NumberInput.parseInt(\"271\"));\n+        assertEquals(-131, NumberInput.parseInt(\"-131\"));\n+        assertEquals(2709, NumberInput.parseInt(\"2709\"));\n+        assertEquals(-9999, NumberInput.parseInt(\"-9999\"));\n+        assertEquals(Integer.MIN_VALUE, NumberInput.parseInt(\"\"+Integer.MIN_VALUE));\n+        assertEquals(Integer.MAX_VALUE, NumberInput.parseInt(\"\"+Integer.MAX_VALUE));\n+    }\n+    \n+    public void testLongParsing() throws Exception\n+    {\n+        char[] testChars = \"123456789012345678\".toCharArray();\n+\n+        assertEquals(123456789012345678L, NumberInput.parseLong(testChars, 0, testChars.length));\n+    }\n+\n+    // Unit test for [JACKSON-491]\n+    public void testLongBoundsChecks() throws Exception\n+    {\n+        String minLong = String.valueOf(Long.MIN_VALUE).substring(1);\n+        String maxLong = String.valueOf(Long.MAX_VALUE);\n+        final String VALUE_491 = \"1323372036854775807\"; // is within range (JACKSON-491)\n+        final String OVERFLOW =  \"9999999999999999999\"; // and this one is clearly out\n+\n+        assertTrue(NumberInput.inLongRange(minLong, true));\n+        assertTrue(NumberInput.inLongRange(maxLong, false));\n+        assertTrue(NumberInput.inLongRange(VALUE_491, true));\n+        assertTrue(NumberInput.inLongRange(VALUE_491, false));\n+        assertFalse(NumberInput.inLongRange(OVERFLOW, false));\n+        assertFalse(NumberInput.inLongRange(OVERFLOW, true));\n+\n+        char[] cbuf = minLong.toCharArray();\n+        assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true));\n+        cbuf = maxLong.toCharArray();\n+        assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false));\n+        cbuf = VALUE_491.toCharArray();\n+        assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, true));\n+        assertTrue(NumberInput.inLongRange(cbuf, 0, cbuf.length, false));\n+        cbuf = OVERFLOW.toCharArray();\n+        assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, true));\n+        assertFalse(NumberInput.inLongRange(cbuf, 0, cbuf.length, false));\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestNumericValues.java\n+package com.fasterxml.jackson.core.main;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+/**\n+ * Set of basic unit tests for verifying that the basic parser\n+ * functionality works as expected.\n+ */\n+public class TestNumericValues\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    public void testSimpleInt()\n+        throws Exception\n+    {\n+        int EXP_I = 1234;\n+\n+        JsonParser jp = createParserUsingReader(\"[ \"+EXP_I+\" ]\");\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(JsonParser.NumberType.INT, jp.getNumberType());\n+        assertEquals(\"\"+EXP_I, jp.getText());\n+\n+        assertEquals(EXP_I, jp.getIntValue());\n+        assertEquals((long) EXP_I, jp.getLongValue());\n+        assertEquals((double) EXP_I, jp.getDoubleValue());\n+        assertEquals(BigDecimal.valueOf((long) EXP_I), jp.getDecimalValue());\n+    }\n+\n+    public void testIntRange()\n+        throws Exception\n+    {\n+        // let's test with readers and streams, separate code paths:\n+        for (int i = 0; i < 2; ++i) {\n+            String input = \"[ \"+Integer.MAX_VALUE+\",\"+Integer.MIN_VALUE+\" ]\";\n+            JsonParser jp;\n+            if (i == 0) {\n+                jp = createParserUsingReader(input);                \n+            } else {\n+                jp = this.createParserUsingStream(input, \"UTF-8\");\n+            }\n+            assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(JsonParser.NumberType.INT, jp.getNumberType());\n+            assertEquals(Integer.MAX_VALUE, jp.getIntValue());\n+    \n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(JsonParser.NumberType.INT, jp.getNumberType());\n+            assertEquals(Integer.MIN_VALUE, jp.getIntValue());\n+        }\n+    }\n+    \n+    public void testInvalidIntAccess()\n+        throws Exception\n+    {\n+        JsonParser jp = createParserUsingReader(\"[ \\\"abc\\\" ]\");\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        try {\n+            jp.getIntValue();\n+            fail(\"Expected error trying to call getIntValue on non-numeric value\");\n+        } catch (JsonParseException e) {\n+            verifyException(e, \"can not use numeric value accessors\");\n+        }\n+    }\n+\n+    public void testSimpleLong()\n+        throws Exception\n+    {\n+        long EXP_L = 12345678907L;\n+\n+        JsonParser jp = createParserUsingReader(\"[ \"+EXP_L+\" ]\");\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        // beyond int, should be long\n+        assertEquals(JsonParser.NumberType.LONG, jp.getNumberType());\n+        assertEquals(\"\"+EXP_L, jp.getText());\n+\n+        assertEquals(EXP_L, jp.getLongValue());\n+        // Should get an exception if trying to convert to int \n+        try {\n+            jp.getIntValue();\n+        } catch (JsonParseException jpe) {\n+            verifyException(jpe, \"out of range\");\n+        }\n+        assertEquals((double) EXP_L, jp.getDoubleValue());\n+        assertEquals(BigDecimal.valueOf((long) EXP_L), jp.getDecimalValue());\n+    }\n+\n+    public void testLongRange()\n+        throws Exception\n+    {\n+        for (int i = 0; i < 2; ++i) {\n+            long belowMinInt = -1L + Integer.MIN_VALUE;\n+            long aboveMaxInt = 1L + Integer.MAX_VALUE;\n+            String input = \"[ \"+Long.MAX_VALUE+\",\"+Long.MIN_VALUE+\",\"+aboveMaxInt+\", \"+belowMinInt+\" ]\";\n+            JsonParser jp;\n+            if (i == 0) {\n+                jp = createParserUsingReader(input);                \n+            } else {\n+                jp = this.createParserUsingStream(input, \"UTF-8\");\n+            }\n+            assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(JsonParser.NumberType.LONG, jp.getNumberType());\n+            assertEquals(Long.MAX_VALUE, jp.getLongValue());\n+        \n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(JsonParser.NumberType.LONG, jp.getNumberType());\n+            assertEquals(Long.MIN_VALUE, jp.getLongValue());\n+\n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(JsonParser.NumberType.LONG, jp.getNumberType());\n+            assertEquals(aboveMaxInt, jp.getLongValue());\n+\n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(JsonParser.NumberType.LONG, jp.getNumberType());\n+            assertEquals(belowMinInt, jp.getLongValue());\n+\n+            \n+            assertToken(JsonToken.END_ARRAY, jp.nextToken());        \n+            jp.close();\n+        }\n+    }\n+\n+    public void testBigDecimalRange()\n+        throws Exception\n+    {\n+        for (int i = 0; i < 2; ++i) {\n+            // let's test first values outside of Long range\n+            BigInteger small = new BigDecimal(Long.MIN_VALUE).toBigInteger();\n+            small = small.subtract(BigInteger.ONE);\n+            BigInteger big = new BigDecimal(Long.MAX_VALUE).toBigInteger();\n+            big = big.add(BigInteger.ONE);\n+            String input = \"[ \"+small+\"  ,  \"+big+\"]\";\n+            JsonParser jp;\n+            if (i == 0) {\n+                jp = createParserUsingReader(input);                \n+            } else {\n+                jp = this.createParserUsingStream(input, \"UTF-8\");\n+            }\n+            assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType());\n+            assertEquals(small, jp.getBigIntegerValue());\n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(JsonParser.NumberType.BIG_INTEGER, jp.getNumberType());\n+            assertEquals(big, jp.getBigIntegerValue());\n+            assertToken(JsonToken.END_ARRAY, jp.nextToken());        \n+            jp.close();\n+        }\n+}\n+    \n+    public void testSimpleDouble()\n+        throws Exception\n+    {\n+        final String[] INPUTS = new String[] {\n+            \"1234.00\", \"2.1101567E-16\", \"1.0e5\", \"2.5e+5\", \"9e4\", \"-12e-3\", \"0.25\"\n+        };\n+        for (int input = 0; input < 2; ++input) {\n+            for (int i = 0; i < INPUTS.length; ++i) {\n+\n+                /* Testing double is more difficult, given the rounding\n+                 * errors and such. But let's try anyways.\n+                 */\n+                String STR = INPUTS[i];\n+                double EXP_D = Double.parseDouble(STR);\n+                String DOC = \"[\"+STR+\"]\";\n+                \n+                JsonParser jp;\n+                \n+                if (input == 0) {\n+                    jp = createParserUsingStream(DOC, \"UTF-8\");\n+                } else {\n+                    jp = createParserUsingReader(DOC);\n+                }\n+                assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+                assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+                assertEquals(STR, jp.getText());\n+                assertEquals(EXP_D, jp.getDoubleValue());\n+                assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+                jp.close();\n+            }\n+        }\n+    }\n+\n+    public void testNumbers()\n+        throws Exception\n+    {\n+        final String DOC = \"[ -13, 8100200300, 13.5, 0.00010, -2.033 ]\";\n+\n+        for (int input = 0; input < 2; ++input) {\n+            JsonParser jp;\n+\n+            if (input == 0) {\n+                jp = createParserUsingStream(DOC, \"UTF-8\");\n+            } else {\n+                jp = createParserUsingReader(DOC);\n+            }\n+\n+            assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+            \n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(-13, jp.getIntValue());\n+            assertEquals(-13L, jp.getLongValue());\n+            assertEquals(-13., jp.getDoubleValue());\n+            assertEquals(\"-13\", jp.getText());\n+            \n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(8100200300L, jp.getLongValue());\n+            // Should get exception for overflow:\n+            try {\n+                /*int x =*/ jp.getIntValue();\n+                fail(\"Expected an exception for overflow\");\n+            } catch (Exception e) {\n+                verifyException(e, \"out of range\");\n+            }\n+            assertEquals(8100200300., jp.getDoubleValue());\n+            assertEquals(\"8100200300\", jp.getText());\n+            \n+            assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+            assertEquals(13, jp.getIntValue());\n+            assertEquals(13L, jp.getLongValue());\n+            assertEquals(13.5, jp.getDoubleValue());\n+            assertEquals(\"13.5\", jp.getText());\n+            \n+            assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+            assertEquals(0, jp.getIntValue());\n+            assertEquals(0L, jp.getLongValue());\n+            assertEquals(0.00010, jp.getDoubleValue());\n+            assertEquals(\"0.00010\", jp.getText());\n+            \n+            assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+            assertEquals(-2, jp.getIntValue());\n+            assertEquals(-2L, jp.getLongValue());\n+            assertEquals(-2.033, jp.getDoubleValue());\n+            assertEquals(\"-2.033\", jp.getText());\n+            \n+            assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        }\n+    }\n+\n+    /**\n+     * Method that tries to test that number parsing works in cases where\n+     * input is split between buffer boundaries.\n+     */\n+    public void testParsingOfLongerSequences()\n+        throws Exception\n+    {\n+        double[] values = new double[] { 0.01, -10.5, 2.1e9, 4.0e-8 };\n+        StringBuilder sb = new StringBuilder();\n+\n+        for (int i = 0; i < values.length; ++i) {\n+            if (i > 0) {\n+                sb.append(',');\n+            }\n+            sb.append(values[i]);\n+        }\n+        String segment = sb.toString();\n+\n+        int COUNT = 1000;\n+        sb = new StringBuilder(COUNT * segment.length() + 20);\n+        sb.append(\"[\");\n+        for (int i = 0; i < COUNT; ++i) {\n+            if (i > 0) {\n+                sb.append(',');\n+            }\n+            sb.append(segment);\n+            sb.append('\\n');\n+            // let's add somewhat arbitray number of spaces\n+            int x = (i & 3);\n+            if (i > 300) {\n+                x += i % 5;\n+            }\n+            while (--x > 0) {\n+                sb.append(' ');\n+            }\n+        }\n+        sb.append(\"]\");\n+        String DOC = sb.toString();\n+\n+        for (int input = 0; input < 2; ++input) {\n+            JsonParser jp;\n+\n+            if (input == 0) {\n+                jp = createParserUsingStream(DOC, \"UTF-8\");\n+            } else {\n+                jp = createParserUsingReader(DOC);\n+            }\n+\n+            assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+            for (int i = 0; i < COUNT; ++i) {\n+                for (double d : values) {\n+                    assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+                    assertEquals(d, jp.getDoubleValue());\n+                }\n+            }\n+            assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* New tests for 1.3 features\n+    /**********************************************************\n+     */\n+\n+    public void testSimpleBoolean()\n+        throws Exception\n+    {\n+        JsonParser jp = createParserUsingReader(\"[ true ]\");\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_TRUE, jp.nextToken());\n+        assertEquals(true, jp.getBooleanValue());\n+    }\n+\n+    public void testInvalidBooleanAccess()\n+        throws Exception\n+    {\n+        JsonParser jp = createParserUsingReader(\"[ \\\"abc\\\" ]\");\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        try {\n+            jp.getBooleanValue();\n+            fail(\"Expected error trying to call getBooleanValue on non-boolean value\");\n+        } catch (JsonParseException e) {\n+            verifyException(e, \"not of boolean type\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestParserClosing.java\n+package com.fasterxml.jackson.core.main;\n+\n+import static org.junit.Assert.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.test.BaseTest;\n+\n+import java.io.*;\n+\n+/**\n+ * Set of basic unit tests that verify that the closing (or not) of\n+ * the underlying source occurs as expected and specified\n+ * by documentation.\n+ */\n+public class TestParserClosing\n+    extends BaseTest\n+{\n+    /**\n+     * This unit test checks the default behaviour; with no auto-close, no\n+     * automatic closing should occur, nor explicit one unless specific\n+     * forcing method is used.\n+     */\n+    public void testNoAutoCloseReader()\n+        throws Exception\n+    {\n+        final String DOC = \"[ 1 ]\";\n+\n+        JsonFactory f = new JsonFactory();\n+\n+        // Check the default settings\n+        assertTrue(f.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE));\n+        // then change\n+        f.disable(JsonParser.Feature.AUTO_CLOSE_SOURCE);\n+        assertFalse(f.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE));\n+        MyReader input = new MyReader(DOC);\n+        JsonParser jp = f.createJsonParser(input);\n+\n+        // shouldn't be closed to begin with...\n+        assertFalse(input.isClosed());\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        assertNull(jp.nextToken());\n+        // normally would be closed now\n+        assertFalse(input.isClosed());\n+        // regular close won't close it either:\n+        jp.close();\n+        assertFalse(input.isClosed());\n+\n+    }\n+\n+    public void testAutoCloseReader() throws Exception\n+    {\n+        final String DOC = \"[ 1 ]\";\n+\n+        JsonFactory f = new JsonFactory();\n+        f.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE);\n+        assertTrue(f.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE));\n+        MyReader input = new MyReader(DOC);\n+        JsonParser jp = f.createJsonParser(input);\n+        assertFalse(input.isClosed());\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        // but can close half-way through\n+        jp.close();\n+        assertTrue(input.isClosed());\n+\n+        // And then let's test implicit close at the end too:\n+        input = new MyReader(DOC);\n+        jp = f.createJsonParser(input);\n+        assertFalse(input.isClosed());\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        assertNull(jp.nextToken());\n+        assertTrue(input.isClosed());\n+    }\n+\n+    public void testNoAutoCloseInputStream()\n+        throws Exception\n+    {\n+        final String DOC = \"[ 1 ]\";\n+        JsonFactory f = new JsonFactory();\n+\n+        f.disable(JsonParser.Feature.AUTO_CLOSE_SOURCE);\n+        MyStream input = new MyStream(DOC.getBytes(\"UTF-8\"));\n+        JsonParser jp = f.createJsonParser(input);\n+\n+        // shouldn't be closed to begin with...\n+        assertFalse(input.isClosed());\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        assertNull(jp.nextToken());\n+        // normally would be closed now\n+        assertFalse(input.isClosed());\n+        // regular close won't close it either:\n+        jp.close();\n+        assertFalse(input.isClosed());\n+    }\n+\n+    // [JACKSON-287]\n+    public void testReleaseContentBytes() throws Exception\n+    {\n+        byte[] input = \"[1]foobar\".getBytes(\"UTF-8\");\n+        JsonParser jp = new JsonFactory().createJsonParser(input);\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        // theoretically could have only read subset; but current impl is more greedy\n+        assertEquals(6, jp.releaseBuffered(out));\n+        assertArrayEquals(\"foobar\".getBytes(\"UTF-8\"), out.toByteArray());\n+    }\n+\n+    public void testReleaseContentChars() throws Exception\n+    {\n+        JsonParser jp = new JsonFactory().createJsonParser(\"[true]xyz\");\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_TRUE, jp.nextToken());\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        StringWriter sw = new StringWriter();\n+        // theoretically could have only read subset; but current impl is more greedy\n+        assertEquals(3, jp.releaseBuffered(sw));\n+        assertEquals(\"xyz\", sw.toString());\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    final static class MyReader extends StringReader\n+    {\n+        boolean mIsClosed = false;\n+\n+        public MyReader(String contents) {\n+            super(contents);\n+        }\n+\n+        @Override\n+        public void close() {\n+            mIsClosed = true;\n+            super.close();\n+        }\n+\n+        public boolean isClosed() { return mIsClosed; }\n+    }\n+\n+    final static class MyStream extends ByteArrayInputStream\n+    {\n+        boolean mIsClosed = false;\n+\n+        public MyStream(byte[] data) {\n+            super(data);\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            mIsClosed = true;\n+            super.close();\n+        }\n+\n+        public boolean isClosed() { return mIsClosed; }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestParserFeatures.java\n+package com.fasterxml.jackson.core.main;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+/**\n+ * Unit tests for verifying that additional <code>JsonParser.Feature</code>\n+ * settings work as expected.\n+ */\n+public class TestParserFeatures\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    public void testDefaultSettings()\n+    {\n+        JsonFactory f = new JsonFactory();\n+        assertTrue(f.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE));\n+        assertFalse(f.isEnabled(JsonParser.Feature.ALLOW_COMMENTS));\n+        assertFalse(f.isEnabled(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES));\n+        assertFalse(f.isEnabled(JsonParser.Feature.ALLOW_SINGLE_QUOTES));\n+        assertFalse(f.isEnabled(JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS));\n+    }\n+\n+    public void testQuotesRequired() throws Exception\n+    {\n+        _testQuotesRequired(false);\n+        _testQuotesRequired(true);\n+    }\n+\n+\n+    // // Tests for [JACKSON-208], unquoted tabs:\n+\n+    public void testTabsDefault() throws Exception\n+    {\n+        _testTabsDefault(false);\n+        _testTabsDefault(true);\n+    }\n+\n+    public void testTabsEnabled() throws Exception\n+    {\n+        _testTabsEnabled(false);\n+        _testTabsEnabled(true);\n+    }\n+\n+    /*\n+    /****************************************************************\n+    /* Secondary test methods\n+    /****************************************************************\n+     */\n+\n+    private void _testQuotesRequired(boolean useStream) throws Exception\n+    {\n+        final String JSON = \"{ test : 3 }\";\n+        final String EXP_ERROR_FRAGMENT = \"was expecting double-quote to start\";\n+        JsonFactory f = new JsonFactory();\n+        JsonParser jp = useStream ?\n+            createParserUsingStream(f, JSON, \"UTF-8\")\n+            : createParserUsingReader(f, JSON)\n+            ;\n+\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        try {\n+            jp.nextToken();\n+        } catch (JsonParseException je) {\n+            verifyException(je, EXP_ERROR_FRAGMENT);\n+        }\n+    }\n+\n+    // // // Tests for [JACKSON-208]\n+\n+    private void _testTabsDefault(boolean useStream) throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+        // First, let's see that by default unquoted tabs are illegal\n+        String JSON = \"[\\\"tab:\\t\\\"]\";\n+        JsonParser jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\") : createParserUsingReader(f, JSON);\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        try {\n+            jp.nextToken();\n+            jp.getText();\n+            fail(\"Expected exception\");\n+        } catch (JsonParseException e) {\n+            verifyException(e, \"Illegal unquoted character\");\n+        }\n+    }\n+\n+    private void _testTabsEnabled(boolean useStream) throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+        f.configure(JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS, true);\n+\n+        String FIELD = \"a\\tb\";\n+        String VALUE = \"\\t\";\n+        String JSON = \"{ \"+quote(FIELD)+\" : \"+quote(VALUE)+\"}\";\n+        JsonParser jp = useStream ? createParserUsingStream(f, JSON, \"UTF-8\") : createParserUsingReader(f, JSON);\n+\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(FIELD, jp.getText());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(VALUE, jp.getText());\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestParserLinefeeds.java\n+package com.fasterxml.jackson.core.main;\n+\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.test.BaseTest;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Set of basic unit tests for verifying that the basic parser\n+ * functionality works as expected.\n+ */\n+public class TestParserLinefeeds\n+    extends BaseTest\n+{\n+    public void testCR() throws Exception\n+    {\n+        _testLinefeeds(\"\\r\", true);\n+        _testLinefeeds(\"\\r\", false);\n+    }\n+\n+    public void testLF() throws Exception\n+    {\n+        _testLinefeeds(\"\\n\", true);\n+        _testLinefeeds(\"\\n\", false);\n+    }\n+\n+    public void testCRLF() throws Exception\n+    {\n+        _testLinefeeds(\"\\r\\n\", true);\n+        _testLinefeeds(\"\\r\\n\", false);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    private void _testLinefeeds(String lf, boolean useStream)\n+        throws IOException\n+    {\n+        String DOC = \"[1,@2,@-178@]\";\n+        DOC = DOC.replaceAll(\"@\", lf);\n+\n+        JsonParser jp = useStream ?\n+            createParserUsingStream(DOC, \"UTF-8\")\n+            : createParserUsingReader(DOC);\n+            \n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertEquals(1, jp.getCurrentLocation().getLineNr());\n+        \n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(1, jp.getIntValue());\n+        assertEquals(1, jp.getCurrentLocation().getLineNr());\n+\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(2, jp.getIntValue());\n+        assertEquals(2, jp.getCurrentLocation().getLineNr());\n+\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(-178, jp.getIntValue());\n+        assertEquals(3, jp.getCurrentLocation().getLineNr());\n+        \n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        assertEquals(4, jp.getCurrentLocation().getLineNr());\n+\n+        jp.close();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestParserWithObjects.java\n+package com.fasterxml.jackson.core.main;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+/**\n+ * Unit tests for verifying that object mapping functionality can\n+ * be accessed using JsonParser.\n+ */\n+public class TestParserWithObjects\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+\n+    /*\n+    /**********************************************************\n+    /* Test for simple traversal with data mapping\n+    /**********************************************************\n+     */\n+\n+    public void testNextValue() throws IOException\n+    {\n+        // Let's test both byte-backed and Reader-based one\n+        _testNextValueBasic(false);\n+        _testNextValueBasic(true);\n+    }\n+\n+    // [JACKSON-395]\n+    public void testNextValueNested() throws IOException\n+    {\n+        // Let's test both byte-backed and Reader-based one\n+        _testNextValueNested(false);\n+        _testNextValueNested(true);\n+    }\n+\n+    public void testIsClosed()\n+        throws IOException\n+    {\n+        for (int i = 0; i < 4; ++i) {\n+            String JSON = \"[ 1, 2, 3 ]\";\n+            boolean stream = ((i & 1) == 0);\n+            JsonParser jp = stream ?\n+                createParserUsingStream(JSON, \"UTF-8\")\n+                : createParserUsingReader(JSON);\n+            boolean partial = ((i & 2) == 0);\n+\n+            assertFalse(jp.isClosed());\n+            assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+\n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertFalse(jp.isClosed());\n+\n+            if (partial) {\n+                jp.close();\n+                assertTrue(jp.isClosed());\n+            } else {\n+                assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+                assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+                assertNull(jp.nextToken());\n+                assertTrue(jp.isClosed());\n+            }\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Supporting methods\n+    /**********************************************************\n+     */\n+\n+    private void  _testNextValueBasic(boolean useStream) throws IOException\n+    {\n+        // first array, no change to default\n+        JsonParser jp = _getParser(\"[ 1, 2, 3, 4 ]\", useStream);\n+        assertToken(JsonToken.START_ARRAY, jp.nextValue());\n+        for (int i = 1; i <= 4; ++i) {\n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextValue());\n+            assertEquals(i, jp.getIntValue());\n+        }\n+        assertToken(JsonToken.END_ARRAY, jp.nextValue());\n+        assertNull(jp.nextValue());\n+        jp.close();\n+\n+        // then Object, is different\n+        jp = _getParser(\"{ \\\"3\\\" :3, \\\"4\\\": 4, \\\"5\\\" : 5 }\", useStream);\n+        assertToken(JsonToken.START_OBJECT, jp.nextValue());\n+        for (int i = 3; i <= 5; ++i) {\n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextValue());\n+            assertEquals(String.valueOf(i), jp.getCurrentName());\n+            assertEquals(i, jp.getIntValue());\n+        }\n+        assertToken(JsonToken.END_OBJECT, jp.nextValue());\n+        assertNull(jp.nextValue());\n+        jp.close();\n+\n+        // and then mixed...\n+        jp = _getParser(\"[ true, [ ], { \\\"a\\\" : 3 } ]\", useStream);\n+\n+        assertToken(JsonToken.START_ARRAY, jp.nextValue());\n+        assertToken(JsonToken.VALUE_TRUE, jp.nextValue());\n+        assertToken(JsonToken.START_ARRAY, jp.nextValue());\n+        assertToken(JsonToken.END_ARRAY, jp.nextValue());\n+\n+        assertToken(JsonToken.START_OBJECT, jp.nextValue());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextValue());\n+        assertEquals(\"a\", jp.getCurrentName());\n+        assertToken(JsonToken.END_OBJECT, jp.nextValue());\n+        assertToken(JsonToken.END_ARRAY, jp.nextValue());\n+\n+        assertNull(jp.nextValue());\n+        jp.close();\n+    }\n+\n+    // [JACKSON-395]\n+    private void  _testNextValueNested(boolean useStream) throws IOException\n+    {\n+        // first array, no change to default\n+        JsonParser jp;\n+    \n+        // then object with sub-objects...\n+        jp = _getParser(\"{\\\"a\\\": { \\\"b\\\" : true, \\\"c\\\": false }, \\\"d\\\": 3 }\", useStream);\n+\n+        assertToken(JsonToken.START_OBJECT, jp.nextValue());\n+        assertNull(jp.getCurrentName());\n+        assertToken(JsonToken.START_OBJECT, jp.nextValue());\n+        assertEquals(\"a\", jp.getCurrentName());\n+        assertToken(JsonToken.VALUE_TRUE, jp.nextValue());\n+        assertEquals(\"b\", jp.getCurrentName());\n+        assertToken(JsonToken.VALUE_FALSE, jp.nextValue());\n+        assertEquals(\"c\", jp.getCurrentName());\n+        assertToken(JsonToken.END_OBJECT, jp.nextValue());\n+        // ideally we should match closing marker with field, too:\n+        assertEquals(\"a\", jp.getCurrentName());\n+\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextValue());\n+        assertEquals(\"d\", jp.getCurrentName());\n+        assertToken(JsonToken.END_OBJECT, jp.nextValue());\n+        assertNull(jp.getCurrentName());\n+        assertNull(jp.nextValue());\n+        jp.close();\n+\n+        // and arrays\n+        jp = _getParser(\"{\\\"a\\\": [ false ] }\", useStream);\n+\n+        assertToken(JsonToken.START_OBJECT, jp.nextValue());\n+        assertNull(jp.getCurrentName());\n+        assertToken(JsonToken.START_ARRAY, jp.nextValue());\n+        assertEquals(\"a\", jp.getCurrentName());\n+        assertToken(JsonToken.VALUE_FALSE, jp.nextValue());\n+        assertNull(jp.getCurrentName());\n+        assertToken(JsonToken.END_ARRAY, jp.nextValue());\n+        // ideally we should match closing marker with field, too:\n+        assertEquals(\"a\", jp.getCurrentName());\n+        assertToken(JsonToken.END_OBJECT, jp.nextValue());\n+        assertNull(jp.getCurrentName());\n+        assertNull(jp.nextValue());\n+        jp.close();\n+    }\n+\n+    private JsonParser _getParser(String doc, boolean useStream)\n+        throws IOException\n+    {\n+        JsonFactory jf = new JsonFactory();\n+        if (useStream) {\n+            return jf.createJsonParser(doc.getBytes(\"UTF-8\"));\n+        }\n+        return jf.createJsonParser(new StringReader(doc));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestPrettyPrinter.java\n+package com.fasterxml.jackson.core.main;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.util.MinimalPrettyPrinter;\n+\n+import java.io.*;\n+\n+/**\n+ * Set of basic unit tests for verifying that indenting\n+ * option of generator works correctly\n+ */\n+public class TestPrettyPrinter\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    public void testSimpleDocWithDefault() throws Exception\n+    {\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator gen = new JsonFactory().createJsonGenerator(sw);\n+        gen.useDefaultPrettyPrinter();\n+        _verifyPrettyPrinter(gen, sw);\n+    }\n+\n+    public void testSimpleDocWithMinimal() throws Exception\n+    {\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator gen = new JsonFactory().createJsonGenerator(sw);\n+        // first with standard minimal\n+        gen.setPrettyPrinter(new MinimalPrettyPrinter());\n+        String docStr = _verifyPrettyPrinter(gen, sw);\n+        // which should have no linefeeds, tabs\n+        assertEquals(-1, docStr.indexOf('\\n'));\n+        assertEquals(-1, docStr.indexOf('\\t'));\n+\n+        // And then with slightly customized variant\n+        gen = new JsonFactory().createJsonGenerator(sw);\n+        gen.setPrettyPrinter(new MinimalPrettyPrinter() {\n+            @Override\n+            // use TAB between array values\n+            public void beforeArrayValues(JsonGenerator jg) throws IOException, JsonGenerationException\n+            {\n+                jg.writeRaw(\"\\t\");\n+            }\n+        });\n+        docStr = _verifyPrettyPrinter(gen, sw);\n+        assertEquals(-1, docStr.indexOf('\\n'));\n+        assertTrue(docStr.indexOf('\\t') >= 0);\n+    }\n+    \n+    private String _verifyPrettyPrinter(JsonGenerator gen, StringWriter sw) throws Exception\n+    {    \n+        gen.writeStartArray();\n+        gen.writeNumber(3);\n+        gen.writeString(\"abc\");\n+\n+        gen.writeStartArray();\n+        gen.writeBoolean(true);\n+        gen.writeEndArray();\n+\n+        gen.writeStartObject();\n+        gen.writeFieldName(\"f\");\n+        gen.writeNull();\n+        gen.writeFieldName(\"f2\");\n+        gen.writeNull();\n+        gen.writeEndObject();\n+\n+        gen.writeEndArray();\n+        gen.close();\n+\n+        String docStr = sw.toString();\n+        JsonParser jp = createParserUsingReader(docStr);\n+\n+        assertEquals(JsonToken.START_ARRAY, jp.nextToken());\n+\n+        assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(3, jp.getIntValue());\n+        assertEquals(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(\"abc\", jp.getText());\n+\n+        assertEquals(JsonToken.START_ARRAY, jp.nextToken());\n+        assertEquals(JsonToken.VALUE_TRUE, jp.nextToken());\n+        assertEquals(JsonToken.END_ARRAY, jp.nextToken());\n+\n+        assertEquals(JsonToken.START_OBJECT, jp.nextToken());\n+        assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"f\", jp.getText());\n+        assertEquals(JsonToken.VALUE_NULL, jp.nextToken());\n+        assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"f2\", jp.getText());\n+        assertEquals(JsonToken.VALUE_NULL, jp.nextToken());\n+        assertEquals(JsonToken.END_OBJECT, jp.nextToken());\n+\n+        assertEquals(JsonToken.END_ARRAY, jp.nextToken());\n+\n+        jp.close();\n+\n+        return docStr;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestRawStringWriting.java\n+package com.fasterxml.jackson.core.main;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import static org.junit.Assert.*;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+/**\n+ * @since 1.7\n+ */\n+public class TestRawStringWriting extends com.fasterxml.jackson.test.BaseTest\n+{\n+    /**\n+     * Unit test for \"JsonGenerator.writeRawUTF8String()\"\n+     */\n+    public void testUtf8RawStrings() throws Exception\n+    {\n+        // Let's create set of Strings to output; no ctrl chars as we do raw\n+        List<byte[]> strings = generateStrings(new Random(28), 750000, false);\n+        ByteArrayOutputStream out = new ByteArrayOutputStream(16000);\n+        JsonFactory jf = new JsonFactory();\n+        JsonGenerator jgen = jf.createJsonGenerator(out, JsonEncoding.UTF8);\n+        jgen.writeStartArray();\n+        for (byte[] str : strings) {\n+            jgen.writeRawUTF8String(str, 0, str.length);\n+        }\n+        jgen.writeEndArray();\n+        jgen.close();\n+        byte[] json = out.toByteArray();\n+        \n+        // Ok: let's verify that stuff was written out ok\n+        JsonParser jp = jf.createJsonParser(json);\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        for (byte[] inputBytes : strings) {\n+            assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+            String string = jp.getText();\n+            byte[] outputBytes = string.getBytes(\"UTF-8\");\n+            assertEquals(inputBytes.length, outputBytes.length);\n+            assertArrayEquals(inputBytes, outputBytes);\n+        }\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+    }\n+\n+    /**\n+     * Unit test for \"JsonGenerator.writeUTF8String()\", which needs\n+     * to handle escaping properly\n+     */\n+    public void testUtf8StringsWithEscaping() throws Exception\n+    {\n+        // Let's create set of Strings to output; do include control chars too:\n+        List<byte[]> strings = generateStrings(new Random(28), 720000, true);\n+        ByteArrayOutputStream out = new ByteArrayOutputStream(16000);\n+        JsonFactory jf = new JsonFactory();\n+        JsonGenerator jgen = jf.createJsonGenerator(out, JsonEncoding.UTF8);\n+        jgen.writeStartArray();\n+\n+        for (byte[] str : strings) {\n+            jgen.writeUTF8String(str, 0, str.length);\n+            jgen.writeRaw('\\n');\n+        }\n+        jgen.writeEndArray();\n+        jgen.close();\n+        byte[] json = out.toByteArray();\n+        \n+        // Ok: let's verify that stuff was written out ok\n+        JsonParser jp = jf.createJsonParser(json);\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        for (byte[] inputBytes : strings) {\n+            assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+            String string = jp.getText();\n+\n+            byte[] outputBytes = string.getBytes(\"UTF-8\");\n+            assertEquals(inputBytes.length, outputBytes.length);\n+            assertArrayEquals(inputBytes, outputBytes);\n+        }\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+    \n+    private List<byte[]> generateStrings(Random rnd, int totalLength, boolean includeCtrlChars)\n+        throws IOException\n+    {\n+        ArrayList<byte[]> strings = new ArrayList<byte[]>();\n+        do {\n+            int len = 2;\n+            int bits = rnd.nextInt(13);\n+            while (--bits >= 0) {\n+                len += len;\n+            }\n+            len = 1 + ((len + len) / 3);\n+            String str = generateString(rnd, len, includeCtrlChars);\n+            byte[] bytes = str.getBytes(\"UTF-8\");\n+            strings.add(bytes);\n+            totalLength -= bytes.length;\n+        } while (totalLength > 0);\n+        return strings;\n+    }\n+        \n+    private String generateString(Random rnd, int length, boolean includeCtrlChars)\n+    {\n+        StringBuilder sb = new StringBuilder(length);\n+        do {\n+            int i;\n+            switch (rnd.nextInt(3)) {\n+            case 0: // 3 byte one\n+                i = 2048 + rnd.nextInt(16383);\n+                break;\n+            case 1: // 2 byte\n+                i = 128 + rnd.nextInt(1024);\n+                break;\n+            default: // ASCII\n+                i = rnd.nextInt(192);\n+                if (!includeCtrlChars) {\n+                    i += 32;\n+                    // but also need to avoid backslash, double-quote\n+                    if (i == '\\\\' || i == '\"') {\n+                        i = '@'; // just arbitrary choice\n+                    }\n+                }\n+            }\n+            sb.append((char) i);\n+        } while (sb.length() < length);\n+        return sb.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestScopeMatching.java\n+package com.fasterxml.jackson.core.main;\n+\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.test.BaseTest;\n+\n+/**\n+ * Set of basic unit tests for verifying that Array/Object scopes\n+ * are properly matched.\n+ */\n+public class TestScopeMatching\n+    extends BaseTest\n+{\n+    public void testUnclosedArray()\n+        throws Exception\n+    {\n+        JsonParser jp = createParserUsingReader(\"[ 1, 2\");\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+\n+        try {\n+            jp.nextToken();\n+            fail(\"Expected an exception for unclosed ARRAY\");\n+        } catch (JsonParseException jpe) {\n+            verifyException(jpe, \"expected close marker for ARRAY\");\n+        }\n+    }\n+\n+    public void testUnclosedObject()\n+        throws Exception\n+    {\n+        JsonParser jp = createParserUsingReader(\"{ \\\"key\\\" : 3  \");\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+\n+        try {\n+            jp.nextToken();\n+            fail(\"Expected an exception for unclosed OBJECT\");\n+        } catch (JsonParseException jpe) {\n+            verifyException(jpe, \"expected close marker for OBJECT\");\n+        }\n+    }\n+\n+    public void testEOFInName()\n+        throws Exception\n+    {\n+        final String JSON = \"{ \\\"abcd\";\n+        for (int i = 0; i < 2; ++i) {\n+            JsonParser jp = (i == 0) ? createParserUsingReader(JSON)\n+                : createParserUsingStream(JSON, \"UTF-8\");\n+            assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+            try {\n+                jp.nextToken();\n+                fail(\"Expected an exception for EOF\");\n+            } catch (JsonParseException jpe) {\n+                verifyException(jpe, \"Unexpected end-of-input\");\n+            }\n+        }\n+    }\n+\n+    public void testWeirdToken()\n+        throws Exception\n+    {\n+        final String JSON = \"[ nil ]\";\n+        for (int i = 0; i < 2; ++i) {\n+            JsonParser jp = (i == 0) ? createParserUsingReader(JSON)\n+                : createParserUsingStream(JSON, \"UTF-8\");\n+            assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+            try {\n+                jp.nextToken();\n+                fail(\"Expected an exception for weird token\");\n+            } catch (JsonParseException jpe) {\n+                verifyException(jpe, \"Unrecognized token\");\n+            }\n+        }\n+    }\n+\n+    public void testMismatchArrayToObject()\n+        throws Exception\n+    {\n+        final String JSON = \"[ 1, 2 }\";\n+        for (int i = 0; i < 2; ++i) {\n+            JsonParser jp = (i == 0) ? createParserUsingReader(JSON)\n+                : createParserUsingStream(JSON, \"UTF-8\");\n+            assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            try {\n+                jp.nextToken();\n+                fail(\"Expected an exception for incorrectly closed ARRAY\");\n+            } catch (JsonParseException jpe) {\n+                verifyException(jpe, \"Unexpected close marker '}': expected ']'\");\n+            }\n+        }\n+    }\n+\n+    public void testMismatchObjectToArray()\n+        throws Exception\n+    {\n+        final String JSON = \"{ ]\";\n+        for (int i = 0; i < 2; ++i) {\n+            JsonParser jp = (i == 0) ? createParserUsingReader(JSON)\n+                : createParserUsingStream(JSON, \"UTF-8\");\n+            assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+            \n+            try {\n+                jp.nextToken();\n+                fail(\"Expected an exception for incorrectly closed OBJECT\");\n+            } catch (JsonParseException jpe) {\n+                verifyException(jpe, \"Unexpected close marker ']': expected '}'\");\n+            }\n+        }\n+    }\n+\n+    public void testMisssingColon()\n+        throws Exception\n+    {\n+        final String JSON = \"{ \\\"a\\\" \\\"b\\\" }\";\n+        for (int i = 0; i < 2; ++i) {\n+            JsonParser jp = (i == 0) ? createParserUsingReader(JSON)\n+                : createParserUsingStream(JSON, \"UTF-8\");\n+            assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+            try {\n+                // can be either here, or with next one...\n+                assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+                jp.nextToken();\n+                fail(\"Expected an exception for missing semicolon\");\n+            } catch (JsonParseException jpe) {\n+                verifyException(jpe, \"was expecting a colon\");\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestStringGeneration.java\n+package com.fasterxml.jackson.core.main;\n+\n+import java.io.*;\n+\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.test.BaseTest;\n+\n+import java.util.Random;\n+\n+/**\n+ * Set of basic unit tests for verifying that the string\n+ * generation, including character escaping, works as expected.\n+ */\n+public class TestStringGeneration\n+    extends BaseTest\n+{\n+    final static String[] SAMPLES = new String[] {\n+        \"\\\"test\\\"\",\n+        \"\\n\", \"\\\\n\", \"\\r\\n\", \"a\\\\b\", \"tab:\\nok?\",\n+        \"a\\tb\\tc\\n\\fdef\\t \\tg\\\"\\\"\\\"h\\\"\\\\ijklmn\\b\",\n+        \"\\\"\\\"\\\"\", \"\\\\r)'\\\"\",\n+        \"Longer text & other stuff:\\twith some\\r\\n\\r\\n random linefeeds etc added in to cause some \\\"special\\\" handling \\\\\\\\ to occur...\\n\"\n+    };\n+    \n+    public void testBasicEscaping()\n+        throws Exception\n+    {\n+        doTestBasicEscaping(false);\n+        doTestBasicEscaping(true);\n+    }\n+\n+    public void testLongerRandomSingleChunk()\n+        throws Exception\n+    {\n+        /* Let's first generate 100k of pseudo-random characters, favoring\n+         * 7-bit ascii range\n+         */\n+        for (int round = 0; round < 80; ++round) {\n+            String content = generateRandom(75000+round);\n+            doTestLongerRandom(content, false);\n+            doTestLongerRandom(content, true);\n+        }\n+    }\n+\n+    public void testLongerRandomMultiChunk()\n+        throws Exception\n+    {\n+        /* Let's first generate 100k of pseudo-random characters, favoring\n+         * 7-bit ascii range\n+         */\n+        for (int round = 0; round < 70; ++round) {\n+            String content = generateRandom(73000+round);\n+            doTestLongerRandomMulti(content, false, round);\n+            doTestLongerRandomMulti(content, true, round);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+\n+    private String generateRandom(int len)\n+    {\n+        StringBuilder sb = new StringBuilder(len+1000); // pad for surrogates\n+        Random r = new Random(len);\n+        for (int i = 0; i < len; ++i) {\n+            if (r.nextBoolean()) { // non-ascii\n+                int value = r.nextInt() & 0xFFFF;\n+                // Otherwise easy, except that need to ensure that\n+                // surrogates are properly paired: and, also\n+                // their values do not exceed 0x10FFFF\n+                if (value >= 0xD800 && value <= 0xDFFF) {\n+                    // Let's discard first value, then, and produce valid pair\n+                    int fullValue = (r.nextInt() & 0xFFFFF);\n+                    sb.append((char) (0xD800 + (fullValue >> 10)));\n+                    value = 0xDC00 + (fullValue & 0x3FF);\n+                }\n+                sb.append((char) value);\n+            } else { // ascii\n+                sb.append((char) (r.nextInt() & 0x7F));\n+            }\n+        }\n+        return sb.toString();\n+    }   \n+\n+    private void doTestBasicEscaping(boolean charArray)\n+        throws Exception\n+    {\n+        for (int i = 0; i < SAMPLES.length; ++i) {\n+            String VALUE = SAMPLES[i];\n+            StringWriter sw = new StringWriter();\n+            JsonGenerator gen = new JsonFactory().createJsonGenerator(sw);\n+            gen.writeStartArray();\n+            if (charArray) {\n+                char[] buf = new char[VALUE.length() + i];\n+                VALUE.getChars(0, VALUE.length(), buf, i);\n+                gen.writeString(buf, i, VALUE.length());\n+            } else {\n+                gen.writeString(VALUE);\n+            }\n+            gen.writeEndArray();\n+            gen.close();\n+            String docStr = sw.toString();\n+            JsonParser jp = createParserUsingReader(docStr);\n+            assertEquals(JsonToken.START_ARRAY, jp.nextToken());\n+            JsonToken t = jp.nextToken();\n+            assertEquals(JsonToken.VALUE_STRING, t);\n+            assertEquals(VALUE, jp.getText());\n+            assertEquals(JsonToken.END_ARRAY, jp.nextToken());\n+            assertEquals(null, jp.nextToken());\n+            jp.close();\n+        }\n+    }\n+\n+    private void doTestLongerRandom(String text, boolean charArray)\n+        throws Exception\n+    {\n+        ByteArrayOutputStream bow = new ByteArrayOutputStream(text.length());\n+        JsonGenerator gen = new JsonFactory().createJsonGenerator(bow, JsonEncoding.UTF8);\n+\n+        gen.writeStartArray();\n+        if (charArray) {\n+            char[] buf = new char[text.length()];\n+            text.getChars(0, text.length(), buf, 0);\n+            gen.writeString(buf, 0, text.length());\n+        } else {\n+            gen.writeString(text);\n+        }\n+        gen.writeEndArray();\n+        gen.close();\n+        byte[] docData = bow.toByteArray();\n+        JsonParser jp = new JsonFactory().createJsonParser(new ByteArrayInputStream(docData));\n+        assertEquals(JsonToken.START_ARRAY, jp.nextToken());\n+        JsonToken t = jp.nextToken();\n+        assertEquals(JsonToken.VALUE_STRING, t);\n+        String act = jp.getText();\n+        if (!text.equals(act)) {\n+            if (text.length() != act.length()) {\n+                fail(\"Expected string length \"+text.length()+\", actual \"+act.length());\n+            }\n+            int i = 0;\n+            for (int len = text.length(); i < len; ++i) {\n+                if (text.charAt(i) != act.charAt(i)) {\n+                    break;\n+                }\n+            }\n+            fail(\"Strings differ at position #\"+i+\" (len \"+text.length()+\"): expected char 0x\"+Integer.toHexString(text.charAt(i))+\", actual 0x\"+Integer.toHexString(act.charAt(i)));\n+        }\n+        assertEquals(JsonToken.END_ARRAY, jp.nextToken());\n+        assertEquals(null, jp.nextToken());\n+        jp.close();\n+    }\n+\n+    private void doTestLongerRandomMulti(String text, boolean charArray, int round)\n+        throws Exception\n+    {\n+        ByteArrayOutputStream bow = new ByteArrayOutputStream(text.length());\n+        JsonGenerator gen = new JsonFactory().createJsonGenerator(bow, JsonEncoding.UTF8);\n+        gen.writeStartArray();\n+\n+        gen.writeString(text);\n+        gen.writeEndArray();\n+        gen.close();\n+        \n+        gen = new JsonFactory().createJsonGenerator(bow, JsonEncoding.UTF8);\n+        gen.writeStartArray();\n+        gen.writeStartArray();\n+\n+        Random rnd = new Random(text.length());\n+        int offset = 0;\n+\n+        while (offset < text.length()) {\n+            int shift = 1 + ((rnd.nextInt() & 0xFFFFF) % 12); // 1 - 12\n+            int len = (1 << shift) + shift; // up to 4k\n+            if ((offset + len) >= text.length()) {\n+                len = text.length() - offset;\n+            } else {\n+            \t// Need to avoid splitting surrogates though\n+            \tchar c = text.charAt(offset+len-1);\n+            \tif (c >= 0xD800 && c < 0xDC00) {\n+            \t\t++len;\n+            \t}\n+            }\n+            if (charArray) {\n+                char[] buf = new char[len];\n+                text.getChars(offset, offset+len, buf, 0);\n+                gen.writeString(buf, 0, len);\n+            } else {\n+                gen.writeString(text.substring(offset, offset+len));\n+            }\n+            offset += len;\n+        }\n+\n+        gen.writeEndArray();\n+        gen.close();\n+        byte[] docData = bow.toByteArray();\n+        JsonParser jp = new JsonFactory().createJsonParser(new ByteArrayInputStream(docData));\n+        assertEquals(JsonToken.START_ARRAY, jp.nextToken());\n+\n+        offset = 0;\n+        while (jp.nextToken() == JsonToken.VALUE_STRING) {\n+            // Let's verify, piece by piece\n+            String act = jp.getText();\n+            String exp = text.substring(offset, offset+act.length());\n+            if (act.length() != exp.length()) {\n+                fail(\"String segment [\"+offset+\" - \"+(offset+act.length())+\"[ differs; exp length \"+exp+\", actual \"+act);                \n+            }\n+            if (!act.equals(exp)) {\n+                int i = 0;\n+                while (act.charAt(i) == exp.charAt(i)) {\n+                    ++i;\n+                }\n+                fail(\"String segment [\"+offset+\" - \"+(offset+act.length())+\"[ different at offset #\"+i\n+                        +\"; exp char 0x\"+Integer.toHexString(exp.charAt(i))\n+                        +\", actual 0x\"+Integer.toHexString(act.charAt(i)));\n+            }\n+            offset += act.length();\n+        }\n+        assertEquals(JsonToken.END_ARRAY, jp.getCurrentToken());\n+        jp.close();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestUnicode.java\n+package com.fasterxml.jackson.core.main;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+public class TestUnicode extends com.fasterxml.jackson.test.BaseTest\n+{\n+    public void testSurrogates() throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+        _testSurrogates(f, true);\n+        _testSurrogates(f, false);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    private void _testSurrogates(JsonFactory f, boolean checkText) throws IOException\n+    {\n+        byte[] json = \"{\\\"text\\\":\\\"\\uD83D\\uDE03\\\"}\".getBytes(\"UTF-8\");\n+        // first\n+        JsonParser jp = f.createJsonParser(json);\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        if (checkText) {\n+            assertEquals(\"text\", jp.getText());\n+        }\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        if (checkText) {\n+            assertEquals(\"\\uD83D\\uDE03\", jp.getText());\n+        }\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestValueConversions.java\n+package com.fasterxml.jackson.core.main;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonToken;\n+\n+/**\n+ * @since 1.6\n+ */\n+public class TestValueConversions\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    public void testAsInt() throws Exception\n+    {\n+        final String input = \"[ 1, -3, 4.98, true, false, null, \\\"-17\\\", \\\"foo\\\" ]\";\n+        for (int i = 0; i < 2; ++i) {\n+            JsonParser jp;\n+            if (i == 0) {\n+                jp = createParserUsingReader(input);                \n+            } else {\n+                jp = this.createParserUsingStream(input, \"UTF-8\");\n+            }\n+            assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+            assertEquals(0, jp.getValueAsLong());\n+            assertEquals(9, jp.getValueAsLong(9));\n+\n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(1, jp.getValueAsLong());\n+            assertEquals(1, jp.getValueAsLong(-99));\n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(-3, jp.getValueAsLong());\n+            assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+            assertEquals(4, jp.getValueAsLong());\n+            assertEquals(4, jp.getValueAsLong(99));\n+            assertToken(JsonToken.VALUE_TRUE, jp.nextToken());\n+            assertEquals(1, jp.getValueAsLong());\n+            assertToken(JsonToken.VALUE_FALSE, jp.nextToken());\n+            assertEquals(0, jp.getValueAsLong());\n+            assertToken(JsonToken.VALUE_NULL, jp.nextToken());\n+            assertEquals(0, jp.getValueAsLong());\n+            assertEquals(0, jp.getValueAsLong(27));\n+            assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+            assertEquals(-17, jp.getValueAsLong());\n+            assertEquals(-17, jp.getValueAsLong(3));\n+            assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+            assertEquals(0, jp.getValueAsLong());\n+            assertEquals(9, jp.getValueAsLong(9));\n+            \n+            assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+            assertEquals(0, jp.getValueAsLong());\n+            assertEquals(9, jp.getValueAsLong(9));\n+\n+            jp.close();\n+        }     \n+    }\n+\n+    /**\n+     * @since 1.7\n+     */\n+    public void testAsBoolean() throws Exception\n+    {\n+        final String input = \"[ true, false, null, 1, 0, \\\"true\\\", \\\"false\\\", \\\"foo\\\" ]\";\n+        for (int i = 0; i < 2; ++i) {\n+            JsonParser jp;\n+            if (i == 0) {\n+                jp = createParserUsingReader(input);                \n+            } else {\n+                jp = this.createParserUsingStream(input, \"UTF-8\");\n+            }\n+            assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+            assertEquals(false, jp.getValueAsBoolean());\n+            assertEquals(true, jp.getValueAsBoolean(true));\n+\n+            assertToken(JsonToken.VALUE_TRUE, jp.nextToken());\n+            assertEquals(true, jp.getValueAsBoolean());\n+            assertToken(JsonToken.VALUE_FALSE, jp.nextToken());\n+            assertEquals(false, jp.getValueAsBoolean());\n+            assertToken(JsonToken.VALUE_NULL, jp.nextToken());\n+            assertEquals(false, jp.getValueAsBoolean());\n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(1, jp.getIntValue());\n+            assertEquals(true, jp.getValueAsBoolean());\n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(0, jp.getIntValue());\n+            assertEquals(false, jp.getValueAsBoolean());\n+\n+            assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+            assertEquals(true, jp.getValueAsBoolean());\n+            assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+            assertEquals(false, jp.getValueAsBoolean());\n+            assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+            assertEquals(false, jp.getValueAsBoolean());\n+            \n+            assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+            assertEquals(false, jp.getValueAsBoolean());\n+            assertEquals(true, jp.getValueAsBoolean(true));\n+\n+            jp.close();\n+        }     \n+    }\n+    \n+    public void testAsLong() throws Exception\n+    {\n+        final String input = \"[ 1, -3, 4.98, true, false, null, \\\"-17\\\", \\\"foo\\\" ]\";\n+        for (int i = 0; i < 2; ++i) {\n+            JsonParser jp;\n+            if (i == 0) {\n+                jp = createParserUsingReader(input);                \n+            } else {\n+                jp = this.createParserUsingStream(input, \"UTF-8\");\n+            }\n+            assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+            assertEquals(0L, jp.getValueAsLong());\n+            assertEquals(9L, jp.getValueAsLong(9L));\n+\n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(1L, jp.getValueAsLong());\n+            assertEquals(1L, jp.getValueAsLong(-99L));\n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(-3L, jp.getValueAsLong());\n+            assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+            assertEquals(4L, jp.getValueAsLong());\n+            assertEquals(4L, jp.getValueAsLong(99L));\n+            assertToken(JsonToken.VALUE_TRUE, jp.nextToken());\n+            assertEquals(1L, jp.getValueAsLong());\n+            assertToken(JsonToken.VALUE_FALSE, jp.nextToken());\n+            assertEquals(0L, jp.getValueAsLong());\n+            assertToken(JsonToken.VALUE_NULL, jp.nextToken());\n+            assertEquals(0L, jp.getValueAsLong());\n+            assertEquals(0L, jp.getValueAsLong(27L));\n+            assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+            assertEquals(-17L, jp.getValueAsLong());\n+            assertEquals(-17L, jp.getValueAsLong(3L));\n+            assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+            assertEquals(0L, jp.getValueAsLong());\n+            assertEquals(9L, jp.getValueAsLong(9L));\n+            \n+            assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+            assertEquals(0L, jp.getValueAsLong());\n+            assertEquals(9L, jp.getValueAsLong(9L));\n+\n+            jp.close();\n+        }     \n+    }\n+\n+    public void testAsDouble() throws Exception\n+    {\n+        final String input = \"[ 1, -3, 4.98, true, false, null, \\\"-17.25\\\", \\\"foo\\\" ]\";\n+        for (int i = 0; i < 2; ++i) {\n+            JsonParser jp;\n+            if (i == 0) {\n+                jp = createParserUsingReader(input);                \n+            } else {\n+                jp = this.createParserUsingStream(input, \"UTF-8\");\n+            }\n+            assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+            assertEquals(0.0, jp.getValueAsDouble());\n+            assertEquals(9.0, jp.getValueAsDouble(9.0));\n+\n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(1., jp.getValueAsDouble());\n+            assertEquals(1., jp.getValueAsDouble(-99.0));\n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(-3., jp.getValueAsDouble());\n+            assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+            assertEquals(4.98, jp.getValueAsDouble());\n+            assertEquals(4.98, jp.getValueAsDouble(12.5));\n+            assertToken(JsonToken.VALUE_TRUE, jp.nextToken());\n+            assertEquals(1.0, jp.getValueAsDouble());\n+            assertToken(JsonToken.VALUE_FALSE, jp.nextToken());\n+            assertEquals(0.0, jp.getValueAsDouble());\n+            assertToken(JsonToken.VALUE_NULL, jp.nextToken());\n+            assertEquals(0.0, jp.getValueAsDouble());\n+            assertEquals(0.0, jp.getValueAsDouble(27.8));\n+            assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+            assertEquals(-17.25, jp.getValueAsDouble());\n+            assertEquals(-17.25, jp.getValueAsDouble(1.9));\n+            assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+            assertEquals(0.0, jp.getValueAsDouble());\n+            assertEquals(1.25, jp.getValueAsDouble(1.25));\n+            \n+            assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+            assertEquals(0.0, jp.getValueAsDouble());\n+            assertEquals(7.5, jp.getValueAsDouble(7.5));\n+\n+            jp.close();\n+        }     \n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestWithTonsaSymbols.java\n+package com.fasterxml.jackson.core.main;\n+\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.test.BaseTest;\n+\n+import java.io.*;\n+\n+/**\n+ * Some unit tests to try to exercise part of parser code that\n+ * deals with symbol (table) management.\n+ */\n+public class TestWithTonsaSymbols\n+    extends BaseTest\n+{\n+    final static String FIELD_BASENAME = \"f\";\n+\n+    /**\n+     * How many fields to generate? Since maximum symbol table\n+     * size is defined as 6000 (above which table gets cleared,\n+     * assuming the name vocabulary is unbounded), let's do something\n+     * just slightly below it.\n+     */\n+    final static int FIELD_COUNT = 5000;\n+\n+    public void testStreamReaderParser() throws Exception\n+    {\n+        _testWith(true);\n+    }\n+\n+    public void testReaderParser() throws Exception\n+    {\n+        _testWith(false);\n+    }\n+\n+    /*\n+    //////////////////////////////////////////////////////\n+    // Helper methods\n+    //////////////////////////////////////////////////////\n+     */\n+\n+    private void _testWith(boolean useStream)\n+        throws Exception\n+    {\n+        JsonFactory jf = new JsonFactory();\n+        String doc = buildDoc(FIELD_COUNT);\n+\n+        /* And let's do this multiple times: just so that symbol table\n+         * state is different between runs.\n+         */\n+        for (int x = 0; x < 3; ++x) {\n+            JsonParser jp = useStream ?\n+                jf.createJsonParser(new ByteArrayInputStream(doc.getBytes(\"UTF-8\")))\n+                : jf.createJsonParser(new StringReader(doc));\n+            assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+            for (int i = 0; i < FIELD_COUNT; ++i) {\n+                assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+                assertEquals(fieldNameFor(i), jp.getCurrentName());\n+                assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+                assertEquals(i, jp.getIntValue());\n+            }\n+            assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+            jp.close();\n+        }\n+    }\n+\n+    private void fieldNameFor(StringBuilder sb, int index)\n+    {\n+        /* let's do something like \"f1.1\" to exercise different\n+         * field names (important for byte-based codec)\n+         * Other name shuffling done mostly just for fun... :)\n+         */\n+        sb.append(FIELD_BASENAME);\n+        sb.append(index);\n+        if (index > 50) {\n+            sb.append('.');\n+            if (index > 200) {\n+                sb.append(index);\n+                if (index > 4000) { // and some even longer symbols...\n+                    sb.append(\".\").append(index);\n+                }\n+            } else {\n+                sb.append(index >> 3); // divide by 8\n+            }\n+        }\n+    }\n+\n+    private String fieldNameFor(int index)\n+    {\n+        StringBuilder sb = new StringBuilder(16);\n+        fieldNameFor(sb, index);\n+        return sb.toString();\n+    }\n+        \n+    private String buildDoc(int len)\n+    {\n+        StringBuilder sb = new StringBuilder(len * 12);\n+        sb.append('{');\n+        for (int i = 0; i < len; ++i) {\n+            if (i > 0) {\n+                sb.append(',');\n+            }\n+            sb.append('\"');\n+            fieldNameFor(sb, i);\n+            sb.append('\"');\n+            sb.append(':');\n+            sb.append(i);\n+        }\n+        sb.append('}');\n+        return sb.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/util/TestCharTypes.java\n+package com.fasterxml.jackson.core.util;\n+\n+import com.fasterxml.jackson.core.io.CharTypes;\n+\n+public class TestCharTypes\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    public void testQuoting()\n+    {\n+        StringBuilder sb = new StringBuilder();\n+        CharTypes.appendQuoted(sb, \"\\n\");\n+        assertEquals(\"\\\\n\", sb.toString());\n+        sb = new StringBuilder();\n+        CharTypes.appendQuoted(sb, \"\\u0000\");\n+        assertEquals(\"\\\\u0000\", sb.toString());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/util/TestDelegates.java\n+package com.fasterxml.jackson.core.util;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+public class TestDelegates extends com.fasterxml.jackson.test.BaseTest\n+{\n+    /**\n+     * Test default, non-overridden parser delegate.\n+     */\n+    public void testParserDelegate() throws IOException\n+    {\n+        JsonParser jp = new JsonFactory().createJsonParser(\"[ 1, true ]\");\n+        assertNull(jp.getCurrentToken());\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertEquals(\"[\", jp.getText());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(1, jp.getIntValue());\n+        assertToken(JsonToken.VALUE_TRUE, jp.nextToken());\n+        assertTrue(jp.getBooleanValue());\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        jp.close();\n+        assertTrue(jp.isClosed());\n+    }\n+\n+    /**\n+     * Test default, non-overridden generator delegate.\n+     */\n+    public void testGeneratorDelegate() throws IOException\n+    {\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator jg = new JsonFactory().createJsonGenerator(sw);\n+        jg.writeStartArray();\n+        jg.writeNumber(13);\n+        jg.writeNull();\n+        jg.writeBoolean(false);\n+        jg.writeEndArray();\n+        jg.close();\n+        assertTrue(jg.isClosed());        \n+        assertEquals(\"[13,null,false]\", sw.toString());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/util/TestNumberPrinting.java\n+package com.fasterxml.jackson.core.util;\n+\n+import java.util.Random;\n+\n+import com.fasterxml.jackson.core.io.NumberOutput;\n+\n+/**\n+ * Set of basic unit tests for verifying that the low-level number\n+ * printingg methods work as expected.\n+ */\n+public class TestNumberPrinting\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    public void testIntPrinting()\n+        throws Exception\n+    {\n+        assertIntPrint(0);\n+        assertIntPrint(-3);\n+        assertIntPrint(1234);\n+        assertIntPrint(-1234);\n+        assertIntPrint(56789);\n+        assertIntPrint(-56789);\n+        assertIntPrint(999999);\n+        assertIntPrint(-999999);\n+        assertIntPrint(1000000);\n+        assertIntPrint(-1000000);\n+        assertIntPrint(10000001);\n+        assertIntPrint(-10000001);\n+        assertIntPrint(-100000012);\n+        assertIntPrint(100000012);\n+        assertIntPrint(1999888777);\n+        assertIntPrint(-1999888777);\n+        assertIntPrint(Integer.MAX_VALUE);\n+        assertIntPrint(Integer.MIN_VALUE);\n+\n+        Random rnd = new Random(12345L);\n+        for (int i = 0; i < 251000; ++i) {\n+            assertIntPrint(rnd.nextInt());\n+        }\n+    }\n+\n+    public void testLongPrinting()\n+        throws Exception\n+    {\n+        // First, let's just cover couple of edge cases\n+        assertLongPrint(0L, 0);\n+        assertLongPrint(1L, 0);\n+        assertLongPrint(-1L, 0);\n+        assertLongPrint(Long.MAX_VALUE, 0);\n+        assertLongPrint(Long.MIN_VALUE, 0);\n+        assertLongPrint(Long.MAX_VALUE-1L, 0);\n+        assertLongPrint(Long.MIN_VALUE+1L, 0);\n+\n+        Random rnd = new Random(12345L);\n+        // Bigger value space, need more iterations for long\n+        for (int i = 0; i < 678000; ++i) {\n+            long l = ((long) rnd.nextInt() << 32) | (long) rnd.nextInt();\n+            assertLongPrint(l, i);\n+        }\n+    }\n+\n+    /*\n+    ////////////////////////////////////////////////////////\n+    // Internal methods\n+    ////////////////////////////////////////////////////////\n+     */\n+\n+    private void assertIntPrint(int value)\n+    {\n+        String exp = \"\"+value;\n+        String act = printToString(value);\n+\n+        if (!exp.equals(act)) {\n+            assertEquals(\"Expected conversion (exp '\"+exp+\"', len \"+exp.length()+\"; act len \"+act.length()+\")\", exp, act);\n+        }\n+    }\n+\n+    private void assertLongPrint(long value, int index)\n+    {\n+        String exp = \"\"+value;\n+        String act = printToString(value);\n+\n+        if (!exp.equals(act)) {\n+            assertEquals(\"Expected conversion (exp '\"+exp+\"', len \"+exp.length()+\"; act len \"+act.length()+\"; number index \"+index+\")\", exp, act);\n+        }\n+    }\n+\n+    private String printToString(int value)\n+    {\n+        char[] buffer = new char[12];\n+        int offset = NumberOutput.outputInt(value, buffer, 0);\n+        return new String(buffer, 0, offset);\n+    }\n+\n+    private String printToString(long value)\n+    {\n+        char[] buffer = new char[22];\n+        int offset = NumberOutput.outputLong(value, buffer, 0);\n+        return new String(buffer, 0, offset);\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/util/TestTextBuffer.java\n+package com.fasterxml.jackson.core.util;\n+\n+import com.fasterxml.jackson.core.util.BufferRecycler;\n+import com.fasterxml.jackson.core.util.TextBuffer;\n+\n+public class TestTextBuffer\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    /**\n+     * Trivially simple basic test to ensure all basic append\n+     * methods work\n+     */\n+    public void testSimple()\n+    {\n+        TextBuffer tb = new TextBuffer(new BufferRecycler());\n+        tb.append('a');\n+        tb.append(new char[] { 'X', 'b' }, 1, 1);\n+        tb.append(\"c\", 0, 1);\n+        assertEquals(3, tb.contentsAsArray().length);\n+        assertEquals(\"abc\", tb.toString());\n+\n+        assertNotNull(tb.expandCurrentSegment());\n+    }\n+\n+    public void testLonger()\n+    {\n+        TextBuffer tb = new TextBuffer(new BufferRecycler());\n+        for (int i = 0; i < 2000; ++i) {\n+            tb.append(\"abc\", 0, 3);\n+        }\n+        String str = tb.contentsAsString();\n+        assertEquals(6000, str.length());\n+        assertEquals(6000, tb.contentsAsArray().length);\n+\n+        tb.resetWithShared(new char[] { 'a' }, 0, 1);\n+        assertEquals(1, tb.toString().length());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/util/TestVersionUtil.java\n+package com.fasterxml.jackson.core.util;\n+\n+import com.fasterxml.jackson.core.Version;\n+import com.fasterxml.jackson.core.util.VersionUtil;\n+\n+public class TestVersionUtil extends com.fasterxml.jackson.test.BaseTest\n+{\n+    public void testVersionPartParsing()\n+    {\n+        assertEquals(13, VersionUtil.parseVersionPart(\"13\"));\n+        assertEquals(27, VersionUtil.parseVersionPart(\"27.8\"));\n+        assertEquals(0, VersionUtil.parseVersionPart(\"-3\"));\n+    }\n+\n+    public void testVersionParsing()\n+    {\n+        assertEquals(new Version(1, 2, 15, \"foo\"), VersionUtil.parseVersion(\"1.2.15-foo\"));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/test/BaseTest.java\n+package com.fasterxml.jackson.test;\n+\n+import java.io.*;\n+import java.util.Arrays;\n+\n+import junit.framework.TestCase;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+//import static org.junit.Assert.*;\n+\n+public abstract class BaseTest\n+    extends TestCase\n+{\n+    /*\n+    /**********************************************************\n+    /* Some sample documents:\n+    /**********************************************************\n+     */\n+\n+    protected final static int SAMPLE_SPEC_VALUE_WIDTH = 800;\n+    protected final static int SAMPLE_SPEC_VALUE_HEIGHT = 600;\n+    protected final static String SAMPLE_SPEC_VALUE_TITLE = \"View from 15th Floor\";\n+    protected final static String SAMPLE_SPEC_VALUE_TN_URL = \"http://www.example.com/image/481989943\";\n+    protected final static int SAMPLE_SPEC_VALUE_TN_HEIGHT = 125;\n+    protected final static String SAMPLE_SPEC_VALUE_TN_WIDTH = \"100\";\n+    protected final static int SAMPLE_SPEC_VALUE_TN_ID1 = 116;\n+    protected final static int SAMPLE_SPEC_VALUE_TN_ID2 = 943;\n+    protected final static int SAMPLE_SPEC_VALUE_TN_ID3 = 234;\n+    protected final static int SAMPLE_SPEC_VALUE_TN_ID4 = 38793;\n+\n+    protected final static String SAMPLE_DOC_JSON_SPEC = \n+        \"{\\n\"\n+        +\"  \\\"Image\\\" : {\\n\"\n+        +\"    \\\"Width\\\" : \"+SAMPLE_SPEC_VALUE_WIDTH+\",\\n\"\n+        +\"    \\\"Height\\\" : \"+SAMPLE_SPEC_VALUE_HEIGHT+\",\"\n+        +\"\\\"Title\\\" : \\\"\"+SAMPLE_SPEC_VALUE_TITLE+\"\\\",\\n\"\n+        +\"    \\\"Thumbnail\\\" : {\\n\"\n+        +\"      \\\"Url\\\" : \\\"\"+SAMPLE_SPEC_VALUE_TN_URL+\"\\\",\\n\"\n+        +\"\\\"Height\\\" : \"+SAMPLE_SPEC_VALUE_TN_HEIGHT+\",\\n\"\n+        +\"      \\\"Width\\\" : \\\"\"+SAMPLE_SPEC_VALUE_TN_WIDTH+\"\\\"\\n\"\n+        +\"    },\\n\"\n+        +\"    \\\"IDs\\\" : [\"+SAMPLE_SPEC_VALUE_TN_ID1+\",\"+SAMPLE_SPEC_VALUE_TN_ID2+\",\"+SAMPLE_SPEC_VALUE_TN_ID3+\",\"+SAMPLE_SPEC_VALUE_TN_ID4+\"]\\n\"\n+        +\"  }\"\n+        +\"}\"\n+        ;\n+\n+    /*\n+    /**********************************************************\n+    /* Helper classes (beans)\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Sample class from Jackson tutorial (\"JacksonInFiveMinutes\")\n+     */\n+    protected static class FiveMinuteUser {\n+        public enum Gender { MALE, FEMALE };\n+\n+        public static class Name\n+        {\n+          private String _first, _last;\n+\n+          public Name() { }\n+          public Name(String f, String l) {\n+              _first = f;\n+              _last = l;\n+          }\n+          \n+          public String getFirst() { return _first; }\n+          public String getLast() { return _last; }\n+\n+          public void setFirst(String s) { _first = s; }\n+          public void setLast(String s) { _last = s; }\n+\n+          @Override\n+          public boolean equals(Object o)\n+          {\n+              if (o == this) return true;\n+              if (o == null || o.getClass() != getClass()) return false;\n+              Name other = (Name) o;\n+              return _first.equals(other._first) && _last.equals(other._last); \n+          }\n+        }\n+\n+        private Gender _gender;\n+        private Name _name;\n+        private boolean _isVerified;\n+        private byte[] _userImage;\n+\n+        public FiveMinuteUser() { }\n+\n+        public FiveMinuteUser(String first, String last, boolean verified, Gender g, byte[] data)\n+        {\n+            _name = new Name(first, last);\n+            _isVerified = verified;\n+            _gender = g;\n+            _userImage = data;\n+        }\n+        \n+        public Name getName() { return _name; }\n+        public boolean isVerified() { return _isVerified; }\n+        public Gender getGender() { return _gender; }\n+        public byte[] getUserImage() { return _userImage; }\n+\n+        public void setName(Name n) { _name = n; }\n+        public void setVerified(boolean b) { _isVerified = b; }\n+        public void setGender(Gender g) { _gender = g; }\n+        public void setUserImage(byte[] b) { _userImage = b; }\n+\n+        @Override\n+        public boolean equals(Object o)\n+        {\n+            if (o == this) return true;\n+            if (o == null || o.getClass() != getClass()) return false;\n+            FiveMinuteUser other = (FiveMinuteUser) o;\n+            if (_isVerified != other._isVerified) return false;\n+            if (_gender != other._gender) return false; \n+            if (!_name.equals(other._name)) return false;\n+            byte[] otherImage = other._userImage;\n+            if (otherImage.length != _userImage.length) return false;\n+            for (int i = 0, len = _userImage.length; i < len; ++i) {\n+                if (_userImage[i] != otherImage[i]) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* High-level helpers\n+    /**********************************************************\n+     */\n+\n+    protected void verifyJsonSpecSampleDoc(JsonParser jp, boolean verifyContents)\n+        throws IOException\n+    {\n+        verifyJsonSpecSampleDoc(jp, verifyContents, true);\n+    }\n+\n+    protected void verifyJsonSpecSampleDoc(JsonParser jp, boolean verifyContents,\n+            boolean requireNumbers)\n+        throws IOException\n+    {\n+        if (!jp.hasCurrentToken()) {\n+            jp.nextToken();\n+        }\n+        assertToken(JsonToken.START_OBJECT, jp.getCurrentToken()); // main object\n+\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Image'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Image\");\n+        }\n+\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken()); // 'image' object\n+\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Width'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Width\");\n+        }\n+\n+        verifyIntToken(jp.nextToken(), requireNumbers);\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_WIDTH);\n+        }\n+\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Height'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Height\");\n+        }\n+\n+        verifyIntToken(jp.nextToken(), requireNumbers);\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_HEIGHT);\n+        }\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Title'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Title\");\n+        }\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(SAMPLE_SPEC_VALUE_TITLE, getAndVerifyText(jp));\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Thumbnail'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Thumbnail\");\n+        }\n+\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken()); // 'thumbnail' object\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Url'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Url\");\n+        }\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        if (verifyContents) {\n+            assertEquals(SAMPLE_SPEC_VALUE_TN_URL, getAndVerifyText(jp));\n+        }\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Height'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Height\");\n+        }\n+        verifyIntToken(jp.nextToken(), requireNumbers);\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_TN_HEIGHT);\n+        }\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Width'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Width\");\n+        }\n+        // Width value is actually a String in the example\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        if (verifyContents) {\n+            assertEquals(SAMPLE_SPEC_VALUE_TN_WIDTH, getAndVerifyText(jp));\n+        }\n+\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken()); // 'thumbnail' object\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'IDs'\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken()); // 'ids' array\n+        verifyIntToken(jp.nextToken(), requireNumbers); // ids[0]\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_TN_ID1);\n+        }\n+        verifyIntToken(jp.nextToken(), requireNumbers); // ids[1]\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_TN_ID2);\n+        }\n+        verifyIntToken(jp.nextToken(), requireNumbers); // ids[2]\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_TN_ID3);\n+        }\n+        verifyIntToken(jp.nextToken(), requireNumbers); // ids[3]\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_TN_ID4);\n+        }\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken()); // 'ids' array\n+\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken()); // 'image' object\n+\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken()); // main object\n+    }\n+\n+    private void verifyIntToken(JsonToken t, boolean requireNumbers)\n+    {\n+        if (t == JsonToken.VALUE_NUMBER_INT) {\n+            return;\n+        }\n+        if (requireNumbers) { // to get error\n+            assertToken(JsonToken.VALUE_NUMBER_INT, t);\n+        }\n+        // if not number, must be String\n+        if (t != JsonToken.VALUE_STRING) {\n+            fail(\"Expected INT or STRING value, got \"+t);\n+        }\n+    }\n+    \n+    protected void verifyFieldName(JsonParser jp, String expName)\n+        throws IOException\n+    {\n+        assertEquals(expName, jp.getText());\n+        assertEquals(expName, jp.getCurrentName());\n+    }\n+\n+    protected void verifyIntValue(JsonParser jp, long expValue)\n+        throws IOException\n+    {\n+        // First, via textual\n+        assertEquals(String.valueOf(expValue), jp.getText());\n+    }\n+\n+    /**\n+     * Method that checks whether Unit tests appear to run from Ant build\n+     * scripts.\n+     * \n+     * @since 1.6\n+     */\n+    protected static boolean runsFromAnt() {\n+        return \"true\".equals(System.getProperty(\"FROM_ANT\"));\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Parser/generator construction\n+    /**********************************************************\n+     */\n+\n+    protected JsonParser createParserUsingReader(String input)\n+        throws IOException, JsonParseException\n+    {\n+        return createParserUsingReader(new JsonFactory(), input);\n+    }\n+\n+    protected JsonParser createParserUsingReader(JsonFactory f, String input)\n+        throws IOException, JsonParseException\n+    {\n+        return f.createJsonParser(new StringReader(input));\n+    }\n+\n+    protected JsonParser createParserUsingStream(String input, String encoding)\n+        throws IOException, JsonParseException\n+    {\n+        return createParserUsingStream(new JsonFactory(), input, encoding);\n+    }\n+\n+    protected JsonParser createParserUsingStream(JsonFactory f,\n+                                                 String input, String encoding)\n+        throws IOException, JsonParseException\n+    {\n+\n+        /* 23-Apr-2008, tatus: UTF-32 is not supported by JDK, have to\n+         *   use our own codec too (which is not optimal since there's\n+         *   a chance both encoder and decoder might have bugs, but ones\n+         *   that cancel each other out or such)\n+         */\n+        byte[] data;\n+        if (encoding.equalsIgnoreCase(\"UTF-32\")) {\n+            data = encodeInUTF32BE(input);\n+        } else {\n+            data = input.getBytes(encoding);\n+        }\n+        InputStream is = new ByteArrayInputStream(data);\n+        return f.createJsonParser(is);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Additional assertion methods\n+    /**********************************************************\n+     */\n+\n+    protected void assertToken(JsonToken expToken, JsonToken actToken)\n+    {\n+        if (actToken != expToken) {\n+            fail(\"Expected token \"+expToken+\", current token \"+actToken);\n+        }\n+    }\n+\n+    protected void assertToken(JsonToken expToken, JsonParser jp)\n+    {\n+        assertToken(expToken, jp.getCurrentToken());\n+    }\n+\n+    protected void assertType(Object ob, Class<?> expType)\n+    {\n+        if (ob == null) {\n+            fail(\"Expected an object of type \"+expType.getName()+\", got null\");\n+        }\n+        Class<?> cls = ob.getClass();\n+        if (!expType.isAssignableFrom(cls)) {\n+            fail(\"Expected type \"+expType.getName()+\", got \"+cls.getName());\n+        }\n+    }\n+\n+    protected void verifyException(Throwable e, String... matches)\n+    {\n+        String msg = e.getMessage();\n+        String lmsg = (msg == null) ? \"\" : msg.toLowerCase();\n+        for (String match : matches) {\n+            String lmatch = match.toLowerCase();\n+            if (lmsg.indexOf(lmatch) >= 0) {\n+                return;\n+            }\n+        }\n+        fail(\"Expected an exception with one of substrings (\"+Arrays.asList(matches)+\"): got one with message \\\"\"+msg+\"\\\"\");\n+    }\n+\n+    /**\n+     * Method that gets textual contents of the current token using\n+     * available methods, and ensures results are consistent, before\n+     * returning them\n+     */\n+    protected String getAndVerifyText(JsonParser jp)\n+        throws IOException, JsonParseException\n+    {\n+        // Ok, let's verify other accessors\n+        int actLen = jp.getTextLength();\n+        char[] ch = jp.getTextCharacters();\n+        String str2 = new String(ch, jp.getTextOffset(), actLen);\n+        String str = jp.getText();\n+\n+        if (str.length() !=  actLen) {\n+            fail(\"Internal problem (jp.token == \"+jp.getCurrentToken()+\"): jp.getText().length() ['\"+str+\"'] == \"+str.length()+\"; jp.getTextLength() == \"+actLen);\n+        }\n+        assertEquals(\"String access via getText(), getTextXxx() must be the same\", str, str2);\n+\n+        return str;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* And other helpers\n+    /**********************************************************\n+     */\n+\n+    protected byte[] encodeInUTF32BE(String input)\n+    {\n+        int len = input.length();\n+        byte[] result = new byte[len * 4];\n+        int ptr = 0;\n+        for (int i = 0; i < len; ++i, ptr += 4) {\n+            char c = input.charAt(i);\n+            result[ptr] = result[ptr+1] = (byte) 0;\n+            result[ptr+2] = (byte) (c >> 8);\n+            result[ptr+3] = (byte) c;\n+        }\n+        return result;\n+    }\n+\n+    public String quote(String str) {\n+        return '\"'+str+'\"';\n+    }\n+}", "timestamp": 1324705944, "metainfo": ""}