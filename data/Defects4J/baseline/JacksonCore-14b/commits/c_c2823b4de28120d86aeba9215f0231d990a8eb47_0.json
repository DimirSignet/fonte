{"sha": "c2823b4de28120d86aeba9215f0231d990a8eb47", "log": "Fix #207", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java\n package com.fasterxml.jackson.core.sym;\n \n import java.util.Arrays;\n-import java.util.BitSet;\n import java.util.concurrent.atomic.AtomicReference;\n \n import com.fasterxml.jackson.core.JsonFactory;\n      */\n     private boolean _hashShared;\n \n-    /*\n-    /**********************************************************\n-    /* Bit of DoS detection goodness\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * Lazily constructed structure that is used to keep track of\n-     * collision buckets that have overflowed once: this is used\n-     * to detect likely attempts at denial-of-service attacks that\n-     * uses hash collisions.\n-     * \n-     * @since 2.4\n-     */\n-    protected BitSet _overflows;\n-    \n     /*\n     /**********************************************************\n     /* Life-cycle: constructors\n \n         _spilloverEnd = state.spilloverEnd;\n         _longNameOffset = state.longNameOffset;\n-        \n+\n         // and then set other state to reflect sharing status\n         _needRehash = false;\n         _hashShared = true;\n         _verifyNeedForRehash();\n         return name;\n     }\n-    \n+\n     private void _verifyNeedForRehash() {\n         // Yes if above 80%, or above 50% AND have ~1% spill-overs\n         if (_count > (_hashSize >> 1)) { // over 50%\n             int spillCount = (_spilloverEnd - _spilloverStart()) >> 2;\n-            \n             if ((spillCount > (1 + _count >> 7))\n                     || (_count > (_hashSize * 0.80))) {\n                 _needRehash = true;\n         int offset = _calcOffset(hash);\n         final int[] hashArea = _hashArea;\n         if (hashArea[offset+3] == 0) {\n+//System.err.printf(\" PRImary slot #%d, hash %X\\n\", (offset>>2), hash & 0x7F);\n             return offset;\n         }\n         // then secondary\n         int offset2 = _secondaryStart + ((offset >> 3) << 2);\n         if (hashArea[offset2+3] == 0) {\n+//System.err.printf(\" SECondary slot #%d (start x%X), hash %X\\n\",(offset >> 3), _secondaryStart, (hash & 0x7F));\n             return offset2;\n         }\n         // if not, tertiary?\n         final int bucketSize = (1 << _tertiaryShift);\n         for (int end = offset2 + bucketSize; offset2 < end; offset2 += 4) {\n             if (hashArea[offset2+3] == 0) {\n+//System.err.printf(\" TERtiary slot x%X (from x%X, start x%X), hash %X.\\n\", offset2, ((offset >> (_tertiaryShift + 2)) << _tertiaryShift), _tertiaryStart, (hash & 0x7F));\n                 return offset2;\n             }\n         }\n         offset = _spilloverEnd;\n         _spilloverEnd += 4;\n \n+//System.err.printf(\" SPIll-over at x%X; start x%X; end x%X, hash %X\\n\", offset, _spilloverStart(), _hashArea.length, (hash & 0x7F));\n+        \n         // one caveat: in the unlikely event if spill-over filling up,\n         // check if that could be considered a DoS attack; handle appropriately\n         // (NOTE: approximate for now; we could verify details if that becomes necessary)\n-        if (_spilloverEnd >= hashArea.length) {\n+        /* 31-Jul-2015, tatu: Note that spillover area does NOT end at end of array,\n+         *   since \"long names\" area follows. Instead, need to calculate from hash size.\n+         */\n+        final int end = (_hashSize << 3);\n+        if (_spilloverEnd >= end) {\n             if (_failOnDoS) {\n                 _reportTooManyCollisions();\n             }\n          *    to work it out, but this is the simplest, fast and seems to do ok.\n          */\n         hash += (hash >>> 16); // to xor hi- and low- 16-bits\n-        hash ^= (hash >>> 12); // as well as lowest 2 bytes\n+        hash ^= (hash << 3); // shuffle back a bit\n+        hash += (hash >>> 12); // and bit more\n         return hash;\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n         \n         // fragile, but essential to verify low collision counts;\n         // anywhere between 70-80% primary matches\n-        assertEquals(8524, symbols.primaryCount());\n+        assertEquals(8534, symbols.primaryCount());\n         // secondary between 10-20%\n         assertEquals(2534, symbols.secondaryCount());\n         // and most of remaining in tertiary\n-        assertEquals(942, symbols.tertiaryCount());\n+        assertEquals(932, symbols.tertiaryCount());\n         // so that spill-over is empty or close to\n         assertEquals(0, symbols.spilloverCount());\n     }\n         }\n         assertEquals(COUNT, symbols.size());\n         \n-        assertEquals(32768, symbols.bucketCount());\n+        assertEquals(16384, symbols.bucketCount());\n \n         // fragile, but essential to verify low collision counts;\n-        // anywhere between 70-80% primary matches\n-        assertEquals(9386, symbols.primaryCount());\n-        // secondary between 10-20%\n-        assertEquals(345, symbols.secondaryCount());\n+        // here bit low primary, 55% \n+        assertEquals(5402, symbols.primaryCount());\n+        // secondary higher than usual, above 25%\n+        assertEquals(2744, symbols.secondaryCount());\n         // and most of remaining in tertiary\n-        assertEquals(257, symbols.tertiaryCount());\n-        // but number of spill-overs starts to grow beyond 30k quite a lot:\n-        assertEquals(12, symbols.spilloverCount());\n+        assertEquals(1834, symbols.tertiaryCount());\n+        // with a bit of spillover\n+        assertEquals(20, symbols.spilloverCount());\n     }\n \n     // [core#191]: similarly, but for \"short\" symbols:\n             }\n             assertEquals(COUNT, symbols.size());\n \n-            assertEquals(2048, symbols.bucketCount());\n+            assertEquals(1024, symbols.bucketCount());\n \n             // Primary is good, but secondary spills cluster in nasty way...\n-            assertEquals(640, symbols.primaryCount());\n-            assertEquals(30, symbols.secondaryCount());\n-            assertEquals(16, symbols.tertiaryCount());\n-            assertEquals(14, symbols.spilloverCount());\n+            assertEquals(564, symbols.primaryCount());\n+            assertEquals(122, symbols.secondaryCount());\n+            assertEquals(14, symbols.tertiaryCount());\n+            assertEquals(0, symbols.spilloverCount());\n \n             assertEquals(COUNT,\n                     symbols.primaryCount() + symbols.secondaryCount() + symbols.tertiaryCount() + symbols.spilloverCount());", "timestamp": 1438397028, "metainfo": ""}