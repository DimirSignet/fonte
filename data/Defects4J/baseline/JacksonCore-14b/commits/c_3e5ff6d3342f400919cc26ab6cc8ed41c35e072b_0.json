{"sha": "3e5ff6d3342f400919cc26ab6cc8ed41c35e072b", "log": "Implemented JsonParser.readBinaryValue(...)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n         if (_inputDecorator != null) {\n             r = _inputDecorator.decorate(ctxt, r);\n         }\n-\treturn _createParser(r, ctxt);\n+        return _createParser(r, ctxt);\n     }\n \n     /**\n     public JsonParser createJsonParser(String content)\n         throws IOException, JsonParseException\n     {\n-\tReader r = new StringReader(content);\n+        Reader r = new StringReader(content);\n         // true -> we own the Reader (and must close); not a big deal\n         IOContext ctxt = _createContext(r, true);\n         // [JACKSON-512]: allow wrapping with InputDecorator\n         if (_inputDecorator != null) {\n             r = _inputDecorator.decorate(ctxt, r);\n         }\n-\treturn _createParser(r, ctxt);\n+        return _createParser(r, ctxt);\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n     }\n \n     /**\n-     * Similar to {@link #writeBinary(Base64Variant,InputStream)},\n+     * Similar to {@link #writeBinary(Base64Variant,InputStream,int)},\n      * but assumes default to using the Jackson default Base64 variant \n      * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}).\n      * \n      *    Will not be closed after successful write operation\n      * @param dataLength (optional) number of bytes that will be available;\n      *    or -1 to be indicate it is not known.\n-     *    If a positive length is given, {@link data} MUST provide at least\n+     *    If a positive length is given, <code>data</code> MUST provide at least\n      *    that many bytes: if not, an exception will be thrown.\n      *    Note that implementations\n      *    need not support cases where length is not known in advance; this\n      *    depends on underlying data format: JSON output does NOT require length,\n      *    other formats may.\n      * \n-     * @return Number of bytes read from {@link data} and written as binary payload\n+     * @return Number of bytes read from <code>data</code> and written as binary payload\n      * \n      * @since 2.1\n      */\n     public abstract int writeBinary(Base64Variant b64variant,\n             InputStream data, int dataLength)\n         throws IOException, JsonGenerationException;\n-    \n+\n     /*\n     /**********************************************************\n     /* Public API, write methods, other value types\n--- a/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n      * @since 2.1\n      */\n     public FormatSchema getSchema() {\n-\treturn null;\n+        return null;\n     }\n     \n     /**\n      * \n      * @since 2.1\n      */\n-    public abstract int readBinaryValue(Base64Variant b64variant, OutputStream out)\n-            throws IOException, JsonParseException;\n+    public int readBinaryValue(Base64Variant b64variant, OutputStream out)\n+            throws IOException, JsonParseException\n+    {\n+        _reportUnsupportedOperation();\n+        return 0; // never gets here\n+    }\n     \n     /*\n     /**********************************************************\n     {\n         return new JsonParseException(msg, getCurrentLocation());\n     }\n+\n+    /**\n+     * Helper method to call for operations that are not supported by\n+     * parser implementation.\n+     *\n+     * @since 2.1\n+     */\n+    protected void _reportUnsupportedOperation() {\n+        throw new UnsupportedOperationException(\"Operation not supported by parser of type \"+getClass().getName());\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n         _verifyValueWrite(\"write raw value\");\n         writeRaw(text, offset, len);\n     }\n-    \n-    //public abstract void writeBinary(byte[] data, int offset, int len, boolean includeLFs) throws IOException, JsonGenerationException;\n-\n-    \n-    /*\n-    /**********************************************************\n-    /* Public API, write methods, primitive\n-    /**********************************************************\n-     */\n+\n+    @Override\n+    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength)\n+        throws IOException, JsonGenerationException {\n+        // Let's implement this as \"unsupported\" to make it easier to add new parser impls\n+        _reportUnsupportedOperation();\n+        return 0;\n+    }\n+\n+    /*\n+   /**********************************************************\n+   /* Public API, write methods, primitive\n+   /**********************************************************\n+    */\n \n     // Not implemented at this level, added as placeholders\n \n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n      * Not used for  pure integer values.\n      */\n     protected int _expLength;\n-    \n+\n     /*\n     /**********************************************************\n     /* Life-cycle\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n     public int readBinaryValue(Base64Variant b64variant, OutputStream out)\n         throws IOException, JsonParseException\n     {\n-        // !!! TODO\n-        throw new UnsupportedOperationException();\n+        // if we have already read the token, just use whatever we may have\n+        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n+            byte[] b = getBinaryValue(b64variant);\n+            out.write(b);\n+            return b.length;\n+        }\n+        // otherwise do \"real\" incremental parsing...\n+        byte[] buf = _ioContext.allocBase64Buffer();\n+        try {\n+            return _readBinary(b64variant, out, buf);\n+        } finally {\n+            _ioContext.releaseBase64Buffer(buf);\n+        }\n+    }\n+\n+    protected int _readBinary(Base64Variant b64variant, OutputStream out,\n+                              byte[] buffer)\n+            throws IOException, JsonParseException\n+    {\n+        int outputPtr = 0;\n+        final int outputEnd = buffer.length - 3;\n+        int outputCount = 0;\n+\n+        while (true) {\n+            // first, we'll skip preceding white space, if any\n+            char ch;\n+            do {\n+                if (_inputPtr >= _inputEnd) {\n+                    loadMoreGuaranteed();\n+                }\n+                ch = _inputBuffer[_inputPtr++];\n+            } while (ch <= INT_SPACE);\n+            int bits = b64variant.decodeBase64Char(ch);\n+            if (bits < 0) { // reached the end, fair and square?\n+                if (ch == '\"') {\n+                    break;\n+                }\n+                bits = _decodeBase64Escape(b64variant, ch, 0);\n+                if (bits < 0) { // white space to skip\n+                    continue;\n+                }\n+            }\n+\n+            // enough room? If not, flush\n+            if (outputPtr > outputEnd) {\n+                outputCount += outputPtr;\n+                out.write(buffer, 0, outputPtr);\n+                outputPtr = 0;\n+            }\n+\n+            int decodedData = bits;\n+\n+            // then second base64 char; can't get padding yet, nor ws\n+\n+            if (_inputPtr >= _inputEnd) {\n+                loadMoreGuaranteed();\n+            }\n+            ch = _inputBuffer[_inputPtr++];\n+            bits = b64variant.decodeBase64Char(ch);\n+            if (bits < 0) {\n+                bits = _decodeBase64Escape(b64variant, ch, 1);\n+            }\n+            decodedData = (decodedData << 6) | bits;\n+\n+            // third base64 char; can be padding, but not ws\n+            if (_inputPtr >= _inputEnd) {\n+                loadMoreGuaranteed();\n+            }\n+            ch = _inputBuffer[_inputPtr++];\n+            bits = b64variant.decodeBase64Char(ch);\n+\n+            // First branch: can get padding (-> 1 byte)\n+            if (bits < 0) {\n+                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n+                    // as per [JACKSON-631], could also just be 'missing'  padding\n+                    if (ch == '\"' && !b64variant.usesPadding()) {\n+                        decodedData >>= 4;\n+                        buffer[outputPtr++] = (byte) decodedData;\n+                        break;\n+                    }\n+                    bits = _decodeBase64Escape(b64variant, ch, 2);\n+                }\n+                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n+                    // Ok, must get padding\n+                    if (_inputPtr >= _inputEnd) {\n+                        loadMoreGuaranteed();\n+                    }\n+                    ch = _inputBuffer[_inputPtr++];\n+                    if (!b64variant.usesPaddingChar(ch)) {\n+                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n+                    }\n+                    // Got 12 bits, only need 8, need to shift\n+                    decodedData >>= 4;\n+                    buffer[outputPtr++] = (byte) decodedData;\n+                    continue;\n+                }\n+            }\n+            // Nope, 2 or 3 bytes\n+            decodedData = (decodedData << 6) | bits;\n+            // fourth and last base64 char; can be padding, but not ws\n+            if (_inputPtr >= _inputEnd) {\n+                loadMoreGuaranteed();\n+            }\n+            ch = _inputBuffer[_inputPtr++];\n+            bits = b64variant.decodeBase64Char(ch);\n+            if (bits < 0) {\n+                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n+                    // as per [JACKSON-631], could also just be 'missing'  padding\n+                    if (ch == '\"' && !b64variant.usesPadding()) {\n+                        decodedData >>= 2;\n+                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n+                        buffer[outputPtr++] = (byte) decodedData;\n+                        break;\n+                    }\n+                    bits = _decodeBase64Escape(b64variant, ch, 3);\n+                }\n+                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n+                    /* With padding we only get 2 bytes; but we have\n+                     * to shift it a bit so it is identical to triplet\n+                     * case with partial output.\n+                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n+                     * dummies, need to discard:\n+                     */\n+                    decodedData >>= 2;\n+                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n+                    buffer[outputPtr++] = (byte) decodedData;\n+                    continue;\n+                }\n+            }\n+            // otherwise, our triplet is now complete\n+            decodedData = (decodedData << 6) | bits;\n+            buffer[outputPtr++] = (byte) (decodedData >> 16);\n+            buffer[outputPtr++] = (byte) (decodedData >> 8);\n+            buffer[outputPtr++] = (byte) decodedData;\n+        }\n+        _tokenIncomplete = false;\n+        if (outputPtr > 0) {\n+            outputCount += outputPtr;\n+            out.write(buffer, 0, outputPtr);\n+        }\n+        return outputCount;\n     }\n \n     /*\n-    /**********************************************************\n-    /* Public API, traversal\n-    /**********************************************************\n-     */\n+   /**********************************************************\n+   /* Public API, traversal\n+   /**********************************************************\n+    */\n \n     /**\n      * @return Next token from the stream, if any found, or null\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n     public int readBinaryValue(Base64Variant b64variant, OutputStream out)\n         throws IOException, JsonParseException\n     {\n-        // !!! TODO\n-        throw new UnsupportedOperationException();\n-    }\n-    \n+        // if we have already read the token, just use whatever we may have\n+        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n+            byte[] b = getBinaryValue(b64variant);\n+            out.write(b);\n+            return b.length;\n+        }\n+        // otherwise do \"real\" incremental parsing...\n+        byte[] buf = _ioContext.allocBase64Buffer();\n+        try {\n+            return _readBinary(b64variant, out, buf);\n+        } finally {\n+            _ioContext.releaseBase64Buffer(buf);\n+        }\n+    }\n+\n+    protected int _readBinary(Base64Variant b64variant, OutputStream out,\n+                              byte[] buffer)\n+        throws IOException, JsonParseException\n+    {\n+        int outputPtr = 0;\n+        final int outputEnd = buffer.length - 3;\n+        int outputCount = 0;\n+\n+        while (true) {\n+            // first, we'll skip preceding white space, if any\n+            int ch;\n+            do {\n+                if (_inputPtr >= _inputEnd) {\n+                    loadMoreGuaranteed();\n+                }\n+                ch = (int) _inputBuffer[_inputPtr++] & 0xFF;\n+            } while (ch <= INT_SPACE);\n+            int bits = b64variant.decodeBase64Char(ch);\n+            if (bits < 0) { // reached the end, fair and square?\n+                if (ch == INT_QUOTE) {\n+                    break;\n+                }\n+                bits = _decodeBase64Escape(b64variant, ch, 0);\n+                if (bits < 0) { // white space to skip\n+                    continue;\n+                }\n+            }\n+\n+            // enough room? If not, flush\n+            if (outputPtr > outputEnd) {\n+                outputCount += outputPtr;\n+                out.write(buffer, 0, outputPtr);\n+                outputPtr = 0;\n+            }\n+\n+            int decodedData = bits;\n+\n+            // then second base64 char; can't get padding yet, nor ws\n+\n+            if (_inputPtr >= _inputEnd) {\n+                loadMoreGuaranteed();\n+            }\n+            ch = _inputBuffer[_inputPtr++] & 0xFF;\n+            bits = b64variant.decodeBase64Char(ch);\n+            if (bits < 0) {\n+                bits = _decodeBase64Escape(b64variant, ch, 1);\n+            }\n+            decodedData = (decodedData << 6) | bits;\n+\n+            // third base64 char; can be padding, but not ws\n+            if (_inputPtr >= _inputEnd) {\n+                loadMoreGuaranteed();\n+            }\n+            ch = _inputBuffer[_inputPtr++] & 0xFF;\n+            bits = b64variant.decodeBase64Char(ch);\n+\n+            // First branch: can get padding (-> 1 byte)\n+            if (bits < 0) {\n+                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n+                    // as per [JACKSON-631], could also just be 'missing'  padding\n+                    if (ch == '\"' && !b64variant.usesPadding()) {\n+                        decodedData >>= 4;\n+                        buffer[outputPtr++] = (byte) decodedData;\n+                        break;\n+                    }\n+                    bits = _decodeBase64Escape(b64variant, ch, 2);\n+                }\n+                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n+                    // Ok, must get padding\n+                    if (_inputPtr >= _inputEnd) {\n+                        loadMoreGuaranteed();\n+                    }\n+                    ch = _inputBuffer[_inputPtr++] & 0xFF;\n+                    if (!b64variant.usesPaddingChar(ch)) {\n+                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n+                    }\n+                    // Got 12 bits, only need 8, need to shift\n+                    decodedData >>= 4;\n+                    buffer[outputPtr++] = (byte) decodedData;\n+                    continue;\n+                }\n+            }\n+            // Nope, 2 or 3 bytes\n+            decodedData = (decodedData << 6) | bits;\n+            // fourth and last base64 char; can be padding, but not ws\n+            if (_inputPtr >= _inputEnd) {\n+                loadMoreGuaranteed();\n+            }\n+            ch = _inputBuffer[_inputPtr++] & 0xFF;\n+            bits = b64variant.decodeBase64Char(ch);\n+            if (bits < 0) {\n+                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n+                    // as per [JACKSON-631], could also just be 'missing'  padding\n+                    if (ch == '\"' && !b64variant.usesPadding()) {\n+                        decodedData >>= 2;\n+                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n+                        buffer[outputPtr++] = (byte) decodedData;\n+                        break;\n+                    }\n+                    bits = _decodeBase64Escape(b64variant, ch, 3);\n+                }\n+                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n+                    /* With padding we only get 2 bytes; but we have\n+                     * to shift it a bit so it is identical to triplet\n+                     * case with partial output.\n+                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n+                     * dummies, need to discard:\n+                     */\n+                    decodedData >>= 2;\n+                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n+                    buffer[outputPtr++] = (byte) decodedData;\n+                    continue;\n+                }\n+            }\n+            // otherwise, our triplet is now complete\n+            decodedData = (decodedData << 6) | bits;\n+            buffer[outputPtr++] = (byte) (decodedData >> 16);\n+            buffer[outputPtr++] = (byte) (decodedData >> 8);\n+            buffer[outputPtr++] = (byte) decodedData;\n+        }\n+        _tokenIncomplete = false;\n+        if (outputPtr > 0) {\n+            outputCount += outputPtr;\n+            out.write(buffer, 0, outputPtr);\n+        }\n+        return outputCount;\n+    }\n+\n     /*\n     /**********************************************************\n     /* Public API, traversal, basic", "timestamp": 1340848003, "metainfo": ""}