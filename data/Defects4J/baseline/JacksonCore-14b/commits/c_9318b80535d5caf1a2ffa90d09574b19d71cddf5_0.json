{"sha": "9318b80535d5caf1a2ffa90d09574b19d71cddf5", "log": "...", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java\n      * reuse factories it doesn't matter either way; but when\n      * recreating factories often, initial overhead may dominate.\n      */\n-    protected static final int DEFAULT_TABLE_SIZE = 64;\n+    protected static final int DEFAULT_T_SIZE = 64;\n \n     /**\n      * Let's not expand symbol tables past some maximum size;\n      * this should protected against OOMEs caused by large documents\n      * with uniquer (~= random) names.\n      */\n-    protected static final int MAX_TABLE_SIZE = 0x10000; // 64k entries == 256k mem\n+    protected static final int MAX_T_SIZE = 0x10000; // 64k entries == 256k mem\n \n     /**\n      * Let's only share reasonably sized symbol tables. Max size set to 3/4 of 16k;\n      */\n     final static int MAX_COLL_CHAIN_FOR_REUSE  = 63;\n     \n-    final static CharsToNameCanonicalizer sBootstrapSymbolTable;\n-    static {\n-        sBootstrapSymbolTable = new CharsToNameCanonicalizer();\n-    }\n+    final static CharsToNameCanonicalizer sBootstrapSymbolTable = new CharsToNameCanonicalizer();\n \n     /*\n     /**********************************************************\n      * instance. Root instance is never used directly; its main use is for\n      * storing and sharing underlying symbol arrays as needed.\n      */\n-    public static CharsToNameCanonicalizer createRoot()\n-    {\n+    public static CharsToNameCanonicalizer createRoot() {\n         /* [Issue-21]: Need to use a variable seed, to thwart hash-collision\n          * based attacks.\n          */\n      * @param initialSize Minimum initial size for bucket array; internally\n      *   will always use a power of two equal to or bigger than this value.\n      */\n-    private CharsToNameCanonicalizer()\n-    {\n+    private CharsToNameCanonicalizer() {\n         // these settings don't really matter for the bootstrap instance\n         _canonicalize = true;\n         _intern = true;\n         _dirty = true;\n         _hashSeed = 0;\n         _longestCollisionList = 0;\n-        initTables(DEFAULT_TABLE_SIZE);\n+        initTables(DEFAULT_T_SIZE);\n     }\n \n     private void initTables(int initialSize)\n         _sizeThreshold = _thresholdSize(initialSize);\n     }\n \n-    private static int _thresholdSize(int hashAreaSize) {\n-        return hashAreaSize - (hashAreaSize >> 2);\n-    }\n+    private static int _thresholdSize(int hashAreaSize) { return hashAreaSize - (hashAreaSize >> 2); }\n     \n     /**\n      * Internal constructor used when creating child instances.\n      */\n-    private CharsToNameCanonicalizer(CharsToNameCanonicalizer parent,\n-            boolean canonicalize, boolean intern,\n-            String[] symbols, Bucket[] buckets, int size,\n-            int hashSeed, int longestColl)\n-    {\n+    private CharsToNameCanonicalizer(CharsToNameCanonicalizer parent, boolean canonicalize, boolean intern,\n+            String[] symbols, Bucket[] buckets, int size, int hashSeed, int longestColl) {\n         _parent = parent;\n         _canonicalize = canonicalize;\n         _intern = intern;\n      * on which only makeChild/mergeChild are called, but instance itself\n      * is not used as a symbol table.\n      */\n-    public CharsToNameCanonicalizer makeChild(final boolean canonicalize,\n-            final boolean intern)\n-    {\n+    public CharsToNameCanonicalizer makeChild(final boolean canonicalize, final boolean intern) {\n         /* 24-Jul-2012, tatu: Trying to reduce scope of synchronization, assuming\n          *   that synchronizing construction is the (potentially) expensive part,\n          *   and not so much short copy-the-variables thing.\n                 symbols, buckets, size, hashSeed, longestCollisionList);\n     }\n \n-    private CharsToNameCanonicalizer makeOrphan(int seed)\n-    {\n-        return new CharsToNameCanonicalizer(null, true, true,\n-                _symbols, _buckets, _size, seed, _longestCollisionList);\n+    private CharsToNameCanonicalizer makeOrphan(int seed) {\n+        return new CharsToNameCanonicalizer(null, true, true, _symbols, _buckets, _size, seed, _longestCollisionList);\n     }\n \n     /**\n      * Note that caller has to make sure symbol table passed in is\n      * really a child or sibling of this symbol table.\n      */\n-    private void mergeChild(CharsToNameCanonicalizer child)\n-    {\n+    private void mergeChild(CharsToNameCanonicalizer child) {\n         /* One caveat: let's try to avoid problems with\n          * degenerate cases of documents with generated \"random\"\n          * names: for these, symbol tables would bloat indefinitely.\n             // (as it's somewhat abnormal thing to happen)\n             // At any rate, need to clean up the tables, then:\n             synchronized (this) {\n-                initTables(DEFAULT_TABLE_SIZE);\n+                initTables(DEFAULT_T_SIZE);\n                 // Dirty flag... well, let's just clear it. Shouldn't really matter for master tables\n                 // (which this is, given something is merged to it)\n                 _dirty = false;\n         }\n     }\n \n-    public void release()\n-    {\n+    public void release(){\n         // If nothing has been added, nothing to do\n-        if (!maybeDirty()) {\n-            return;\n-        }\n+        if (!maybeDirty()) { return; }\n         if (_parent != null) {\n             _parent.mergeChild(this);\n             /* Let's also mark this instance as dirty, so that just in\n      * \n      * @since 2.1\n      */\n-    public int bucketCount() { \n-       return _symbols.length; }\n-    \n+    public int bucketCount() {  return _symbols.length; }\n     public boolean maybeDirty() { return _dirty; }\n-\n     public int hashSeed() { return _hashSeed; }\n     \n     /**\n      * \n      * @since 2.1\n      */\n-    public int collisionCount()\n-    {\n+    public int collisionCount() {\n         int count = 0;\n         \n         for (Bucket bucket : _buckets) {\n      * \n      * @since 2.1\n      */\n-    public int maxCollisionLength()\n-    {\n-        return _longestCollisionList;\n-    }\n+    public int maxCollisionLength() { return _longestCollisionList; }\n \n     /*\n     /**********************************************************\n      * Helper method that takes in a \"raw\" hash value, shuffles it as necessary,\n      * and truncates to be used as the index.\n      */\n-    public int _hashToIndex(int rawHash)\n-    {\n+    public int _hashToIndex(int rawHash) {\n         rawHash += (rawHash >>> 15); // this seems to help quite a bit, at least for our tests\n         return (rawHash & _indexMask);\n     }\n      * @param len Length of String; has to be at least 1 (caller guarantees\n      *   this pre-condition)\n      */\n-    public int calcHash(char[] buffer, int start, int len)\n-    {\n+    public int calcHash(char[] buffer, int start, int len) {\n         int hash = _hashSeed;\n         for (int i = 0; i < len; ++i) {\n             hash = (hash * HASH_MULT) + (int) buffer[i];\n      * Method called when copy-on-write is needed; generally when first\n      * change is made to a derived symbol table.\n      */\n-    private void copyArrays()\n-    {\n+    private void copyArrays() {\n         final String[] oldSyms = _symbols;\n         _symbols = Arrays.copyOf(oldSyms, oldSyms.length);\n         final Bucket[] oldBuckets = _buckets;\n      * is really redistributing old entries into new String/Bucket\n      * entries.\n      */\n-    private void rehash()\n-    {\n+    private void rehash() {\n         int size = _symbols.length;\n         int newSize = size + size;\n \n          *    prepared to use, to guard against OOME in case of unbounded\n          *    name sets (unique [non-repeating] names)\n          */\n-        if (newSize > MAX_TABLE_SIZE) {\n+        if (newSize > MAX_T_SIZE) {\n             /* If this happens, there's no point in either growing or\n              * shrinking hash areas. Rather, it's better to just clean\n              * them up for reuse.\n     /**\n      * @since 2.1\n      */\n-    protected void reportTooManyCollisions(int maxLen)\n-    {\n+    protected void reportTooManyCollisions(int maxLen) {\n         throw new IllegalStateException(\"Longest collision chain in symbol table (of size \"+_size\n                 +\") now exceeds maximum, \"+maxLen+\" -- suspect a DoS attack based on hash collisions\");\n     }", "timestamp": 1387001787, "metainfo": ""}