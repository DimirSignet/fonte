{"sha": "df37ed361269fb0d9defba5e46b3e714fa908f26", "log": "Merge branch '2.5'  Conflicts: \tsrc/test/java/com/fasterxml/jackson/core/json/TestParserSymbols.java", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n \n     /**\n      * Method called when not even first 8 bytes are guaranteed\n-     * to come consequtively. Happens rarely, so this is offlined;\n+     * to come consecutively. Happens rarely, so this is off-lined;\n      * plus we'll also do full checks for escaping etc.\n      */\n     protected Name slowParseName() throws IOException\n             }\n             ch = _inputBuffer[_inputPtr++] & 0xFF;\n         }\n-\n         if (currQuadBytes > 0) {\n             if (qlen >= quads.length) {\n                 _quadBuffer = quads = growArrayBy(quads, quads.length);\n             }\n-            quads[qlen++] = currQuad;\n+            quads[qlen++] = pad(currQuad, currQuadBytes);\n         }\n         Name name = _symbols.findName(quads, qlen);\n         if (name == null) {\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestParserSymbols.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestParserSymbols.java\n     \n     private void _testSymbolsWithNull(JsonFactory f, boolean useBytes) throws Exception\n     {\n-        final String INPUT = \"{\\\"\\\\u0000abc\\\" : 1, \\\"abc\\\" : 2}\";\n+        final JsonFactory f = new JsonFactory();\n+        final String INPUT = \"{\\\"\\\\u0000abc\\\" : 1, \\\"abc\\\":2}\";\n         JsonParser parser = useBytes ? f.createParser(INPUT.getBytes(\"UTF-8\"))\n                 : f.createParser(INPUT);\n \n--- a/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n      * are allowed: meaning everywhere except for when\n      * a field name is expected.\n      */\n-    public abstract void writeStartObject()\n-        throws IOException;\n+    public abstract void writeStartObject() throws IOException;\n \n     /**\n      * Method for writing closing marker of a JSON Object value\n      * complete value, or START-OBJECT marker (see JSON specification\n      * for more details).\n      */\n-    public abstract void writeEndObject()\n-        throws IOException;\n+    public abstract void writeEndObject() throws IOException;\n \n     /**\n      * Method for writing a field name (JSON String surrounded by\n      * JSON specification for details), when field name is expected\n      * (field names alternate with values).\n      */\n-    public abstract void writeFieldName(String name)\n-        throws IOException;\n+    public abstract void writeFieldName(String name) throws IOException;\n \n     /**\n      * Method similar to {@link #writeFieldName(String)}, main difference\n      * serialized String; implementations are strongly encouraged to make\n      * use of more efficient methods argument object has.\n      */\n-    public abstract void writeFieldName(SerializableString name)\n-        throws IOException;\n+    public abstract void writeFieldName(SerializableString name) throws IOException;\n \n     /*\n     /**********************************************************\n      * surrounded in double quotes, and contents will be properly\n      * escaped as required by JSON specification.\n      */\n-    public abstract void writeString(String text)\n-        throws IOException;\n+    public abstract void writeString(String text) throws IOException;\n \n     /**\n      * Method for outputting a String value. Depending on context\n      * surrounded in double quotes, and contents will be properly\n      * escaped as required by JSON specification.\n      */\n-    public abstract void writeString(char[] text, int offset, int len)\n-        throws IOException;\n+    public abstract void writeString(char[] text, int offset, int len) throws IOException;\n \n     /**\n      * Method similar to {@link #writeString(String)}, but that takes\n      * sub-classes should override it with more efficient implementation\n      * if possible.\n      */\n-    public abstract void writeString(SerializableString text)\n-        throws IOException;\n+    public abstract void writeString(SerializableString text) throws IOException;\n \n     /**\n      * Method similar to {@link #writeString(String)} but that takes as\n--- a/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n      * @since 2.5\n      */\n     public String nextFieldName() throws IOException, JsonParseException {\n-        return (nextToken() == JsonToken.FIELD_NAME)\n-                ? getCurrentName() : null;\n+        return (nextToken() == JsonToken.FIELD_NAME) ? getCurrentName() : null;\n     }\n \n     /**\n      */\n     public abstract boolean hasTokenId(int id);\n \n+    /**\n+     * Method that is functionally equivalent to:\n+     *<code>\n+     *  return getCurrentTokenId() == id\n+     *</code>\n+     * but may be more efficiently implemented.\n+     *<p>\n+     * Note that no traversal or conversion is performed; so in some\n+     * cases calling method like {@link #isExpectedStartArrayToken()}\n+     * is necessary instead.\n+     *\n+     * @since 2.6\n+     */\n+    public abstract boolean hasToken(JsonToken t);\n+    \n     /**\n      * Method that can be called to get the name associated with\n      * the current token: for {@link JsonToken#FIELD_NAME}s it will\n--- a/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n             | Feature.ESCAPE_NON_ASCII.getMask()\n             | Feature.STRICT_DUPLICATE_DETECTION.getMask()\n             ;\n+\n+    // // // Constants for validation messages (since 2.6)\n+\n+    protected final String WRITE_BINARY = \"write a binary value\";\n+    protected final String WRITE_BOOLEAN = \"write a boolean value\";\n+    protected final String WRITE_NULL = \"write a null\";\n+    protected final String WRITE_NUMBER = \"write a number\";\n+    protected final String WRITE_RAW = \"write a raw (unencoded) value\";\n+    protected final String WRITE_STRING = \"write a string\";\n \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n      */\n \n     protected ParserBase(IOContext ctxt, int features) {\n-        super();\n-        _features = features;\n+        super(features);\n         _ioContext = ctxt;\n         _textBuffer = ctxt.constructTextBuffer();\n         DupDetector dups = Feature.STRICT_DUPLICATE_DETECTION.enabledIn(features)\n     {\n         if ((_numTypesValid & NR_INT) == 0) {\n             if (_numTypesValid == NR_UNKNOWN) { // not parsed at all\n-                _parseNumericValue(NR_INT); // will also check event type\n+                return _parseIntValue();\n             }\n             if ((_numTypesValid & NR_INT) == 0) { // wasn't an int natively?\n                 convertNumberToInt(); // let's make it so, if possible\n         }\n         _reportError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\");\n     }\n-    \n+\n+    /**\n+     * @since 2.6\n+     */\n+    protected int _parseIntValue() throws IOException\n+    {\n+        // Inlined variant of: _parseNumericValue(NR_INT)\n+\n+        if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n+            char[] buf = _textBuffer.getTextBuffer();\n+            int offset = _textBuffer.getTextOffset();\n+            int len = _intLength;\n+            if (_numberNegative) {\n+                ++offset;\n+            }\n+            if (len <= 9) {\n+                int i = NumberInput.parseInt(buf, offset, len);\n+                if (_numberNegative) {\n+                    i = -i;\n+                }\n+                _numberInt = i;\n+                _numTypesValid = NR_INT;\n+                return i;\n+            }\n+        }\n+        _parseNumericValue(NR_INT);\n+        if ((_numTypesValid & NR_INT) == 0) {\n+            convertNumberToInt();\n+        }\n+        return _numberInt;\n+    }\n+\n     private void _parseSlowFloat(int expType) throws IOException\n     {\n         /* Nope: floating point. Here we need to be careful to get\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n      * effect when {@link #clearCurrentToken} was called.\n      */\n     protected JsonToken _lastClearedToken;\n-    \n+\n     /*\n     /**********************************************************\n     /* Life-cycle\n \n     // NOTE: had base impl in 2.3 and before; but shouldn't\n     // public abstract Version version();\n-    \n+\n     /*\n     /**********************************************************\n     /* Configuration overrides if any\n         return t.id() == id;\n     }\n \n+    @Override public final boolean hasToken(JsonToken t) {\n+        return (_currToken == t);\n+    }\n+    \n     @Override public boolean isExpectedStartArrayToken() { return _currToken == JsonToken.START_ARRAY; }\n     @Override public boolean isExpectedStartObjectToken() { return _currToken == JsonToken.START_OBJECT; }\n     \n--- a/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\n         _encoding = enc;\n     }\n \n+    /**\n+     * @since 1.6\n+     */\n+    public IOContext withEncoding(JsonEncoding enc) {\n+        _encoding = enc;\n+        return this;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Public API, accessors\n--- a/src/main/java/com/fasterxml/jackson/core/json/JsonGeneratorImpl.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonGeneratorImpl.java\n     // // Overrides just to make things final, to possibly help with inlining\n     \n     @Override\n-    public final void writeStringField(String fieldName, String value)\n-        throws IOException, JsonGenerationException\n+    public final void writeStringField(String fieldName, String value) throws IOException\n     {\n         writeFieldName(fieldName);\n         writeString(value);\n--- a/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java\n     public int writeValue() {\n         // Most likely, object:\n         if (_type == TYPE_OBJECT) {\n+            if (!_gotName) {\n+                return STATUS_EXPECT_NAME;\n+            }\n             _gotName = false;\n             ++_index;\n             return STATUS_OK_AFTER_COLON;\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n     private final static byte BYTE_u = (byte) 'u';\n \n     private final static byte BYTE_0 = (byte) '0';\n-    \n+\n     private final static byte BYTE_LBRACKET = (byte) '[';\n     private final static byte BYTE_RBRACKET = (byte) ']';\n     private final static byte BYTE_LCURLY = (byte) '{';\n     private final static byte BYTE_RCURLY = (byte) '}';\n- \n+\n     private final static byte BYTE_BACKSLASH = (byte) '\\\\';\n     private final static byte BYTE_COMMA = (byte) ',';\n     private final static byte BYTE_COLON = (byte) ':';\n \n     // intermediate copies only made up to certain length...\n     private final static int MAX_BYTES_TO_BUFFER = 512;\n-    \n+\n     final static byte[] HEX_CHARS = CharTypes.copyHexBytes();\n \n     private final static byte[] NULL_BYTES = { 'n', 'u', 'l', 'l' };\n     /* Output buffering\n     /**********************************************************\n      */\n-    \n+\n     /**\n      * Underlying output stream used for writing JSON content.\n      */\n      * in the output buffer after escaping\n      */\n     protected final int _outputMaxContiguous;\n-    \n+\n     /**\n      * Intermediate buffer in which characters of a String are copied\n      * before being encoded.\n      */\n     protected char[] _charBuffer;\n-    \n+\n     /**\n      * Length of <code>_charBuffer</code>\n      */\n     protected final int _charBufferLength;\n-    \n+\n     /**\n      * 6 character temporary buffer allocated if needed, for constructing\n      * escape sequences\n     @Override\n     public void writeString(String text) throws IOException\n     {\n-        _verifyValueWrite(\"write text value\");\n+        _verifyValueWrite(WRITE_STRING);\n         if (text == null) {\n             _writeNull();\n             return;\n     @Override\n     public void writeString(char[] text, int offset, int len) throws IOException\n     {\n-        _verifyValueWrite(\"write text value\");\n+        _verifyValueWrite(WRITE_STRING);\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n         }\n     @Override\n     public final void writeString(SerializableString text) throws IOException\n     {\n-        _verifyValueWrite(\"write text value\");\n+        _verifyValueWrite(WRITE_STRING);\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n         }\n         }\n         _outputBuffer[_outputTail++] = BYTE_QUOTE;\n     }\n-\n+    \n     @Override\n     public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException\n     {\n-        _verifyValueWrite(\"write text value\");\n+        _verifyValueWrite(WRITE_STRING);\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n         }\n     @Override\n     public void writeUTF8String(byte[] text, int offset, int len) throws IOException\n     {\n-        _verifyValueWrite(\"write text value\");\n+        _verifyValueWrite(WRITE_STRING);\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n         }\n     // since 2.5\n     @Override\n     public void writeRawValue(SerializableString text) throws IOException {\n-        _verifyValueWrite(\"write raw value\");\n+        _verifyValueWrite(WRITE_RAW);\n         byte[] raw = text.asUnquotedUTF8();\n         if (raw.length > 0) {\n             _writeBytes(raw);\n             byte[] data, int offset, int len)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write binary value\");\n+        _verifyValueWrite(WRITE_BINARY);\n         // Starting quotes\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n             InputStream data, int dataLength)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write binary value\");\n+        _verifyValueWrite(WRITE_BINARY);\n         // Starting quotes\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n     public void writeNumber(short s)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         // up to 5 digits and possible minus sign\n         if ((_outputTail + 6) >= _outputEnd) {\n             _flushBuffer();\n     public void writeNumber(int i)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         // up to 10 digits and possible minus sign\n         if ((_outputTail + 11) >= _outputEnd) {\n             _flushBuffer();\n     public void writeNumber(long l)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (_cfgNumbersAsStrings) {\n             _writeQuotedLong(l);\n             return;\n     public void writeNumber(BigInteger value)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (value == null) {\n             _writeNull();\n         } else if (_cfgNumbersAsStrings) {\n             return;\n         }\n         // What is the max length for doubles? 40 chars?\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         writeRaw(String.valueOf(d));\n     }\n \n             return;\n         }\n         // What is the max length for floats?\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         writeRaw(String.valueOf(f));\n     }\n \n         throws IOException, JsonGenerationException\n     {\n         // Don't really know max length for big decimal, no point checking\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (value == null) {\n             _writeNull();\n         } else if (_cfgNumbersAsStrings) {\n     public void writeNumber(String encodedValue)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (_cfgNumbersAsStrings) {\n             _writeQuotedRaw(encodedValue);            \n         } else {\n     public void writeBoolean(boolean state)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write boolean value\");\n+        _verifyValueWrite(WRITE_BOOLEAN);\n         if ((_outputTail + 5) >= _outputEnd) {\n             _flushBuffer();\n         }\n     public void writeNull()\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write null value\");\n+        _verifyValueWrite(WRITE_NULL);\n         _writeNull();\n     }\n \n      */\n \n     @Override\n-    protected final void _verifyValueWrite(String typeMsg)\n-        throws IOException, JsonGenerationException\n+    protected final void _verifyValueWrite(String typeMsg) throws IOException\n     {\n         int status = _writeContext.writeValue();\n         if (status == JsonWriteContext.STATUS_EXPECT_NAME) {\n         _verifyPrettyValueWrite(typeMsg, status);\n     }\n \n-    protected final void _verifyPrettyValueWrite(String typeMsg, int status)\n-        throws IOException, JsonGenerationException\n+    protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException\n     {\n         // If we have a pretty printer, it knows what to do:\n         switch (status) {\n      */\n \n     @Override\n-    public void flush()\n-        throws IOException\n+    public void flush() throws IOException\n     {\n         _flushBuffer();\n         if (_outputStream != null) {\n     }\n \n     @Override\n-    public void close()\n-        throws IOException\n+    public void close() throws IOException\n     {\n         super.close();\n \n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n      */\n \n     @Override\n-    public String getText()\n-        throws IOException, JsonParseException\n+    public String getText() throws IOException\n     {\n         if (_currToken == JsonToken.VALUE_STRING) {\n             if (_tokenIncomplete) {\n                 _tokenIncomplete = false;\n-                _finishString(); // only strings can be incomplete\n+                return _finishAndReturnString(); // only strings can be incomplete\n             }\n             return _textBuffer.contentsAsString();\n         }\n     \n     // @since 2.1\n     @Override\n-    public String getValueAsString() throws IOException, JsonParseException\n+    public String getValueAsString() throws IOException\n     {\n         if (_currToken == JsonToken.VALUE_STRING) {\n             if (_tokenIncomplete) {\n                 _tokenIncomplete = false;\n-                _finishString(); // only strings can be incomplete\n+                return _finishAndReturnString(); // only strings can be incomplete\n             }\n             return _textBuffer.contentsAsString();\n         }\n     \n     // @since 2.1\n     @Override\n-    public String getValueAsString(String defValue) throws IOException, JsonParseException\n+    public String getValueAsString(String defValue) throws IOException\n     {\n         if (_currToken == JsonToken.VALUE_STRING) {\n             if (_tokenIncomplete) {\n                 _tokenIncomplete = false;\n-                _finishString(); // only strings can be incomplete\n+                return _finishAndReturnString(); // only strings can be incomplete\n             }\n             return _textBuffer.contentsAsString();\n         }\n     }\n \n     @Override\n-    public char[] getTextCharacters()\n-        throws IOException, JsonParseException\n+    public char[] getTextCharacters() throws IOException\n     {\n         if (_currToken != null) { // null only before/after document\n             switch (_currToken.id()) {\n     }\n \n     @Override\n-    public int getTextLength()\n-        throws IOException, JsonParseException\n+    public int getTextLength() throws IOException\n     {\n         if (_currToken != null) { // null only before/after document\n             switch (_currToken.id()) {\n     }\n \n     @Override\n-    public int getTextOffset() throws IOException, JsonParseException\n+    public int getTextOffset() throws IOException\n     {\n         // Most have offset of 0, only some may have other values:\n         if (_currToken != null) {\n     }\n     \n     @Override\n-    public byte[] getBinaryValue(Base64Variant b64variant)\n-        throws IOException, JsonParseException\n+    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n     {\n         if (_currToken != JsonToken.VALUE_STRING &&\n                 (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n     }\n \n     @Override\n-    public int readBinaryValue(Base64Variant b64variant, OutputStream out)\n-        throws IOException, JsonParseException\n+    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n     {\n         // if we have already read the token, just use whatever we may have\n         if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n     }\n \n     protected int _readBinary(Base64Variant b64variant, OutputStream out,\n-                              byte[] buffer)\n-        throws IOException, JsonParseException\n+                              byte[] buffer) throws IOException\n     {\n         int outputPtr = 0;\n         final int outputEnd = buffer.length - 3;\n             if (t == JsonToken.VALUE_STRING) {\n                 if (_tokenIncomplete) {\n                     _tokenIncomplete = false;\n-                    _finishString();\n+                    return _finishAndReturnString();\n                 }\n                 return _textBuffer.contentsAsString();\n             }\n         _finishString2(outBuf, outPtr);\n     }\n \n+    /**\n+     * @since 2.6\n+     */\n+    protected String _finishAndReturnString() throws IOException\n+    {\n+        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n+        int ptr = _inputPtr;\n+        if (ptr >= _inputEnd) {\n+            loadMoreGuaranteed();\n+            ptr = _inputPtr;\n+        }\n+        int outPtr = 0;\n+        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n+        final int[] codes = _icUTF8;\n+\n+        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n+        final byte[] inputBuffer = _inputBuffer;\n+        while (ptr < max) {\n+            int c = (int) inputBuffer[ptr] & 0xFF;\n+            if (codes[c] != 0) {\n+                if (c == INT_QUOTE) {\n+                    _inputPtr = ptr+1;\n+                    return _textBuffer.setCurrentAndReturn(outPtr);\n+                }\n+                break;\n+            }\n+            ++ptr;\n+            outBuf[outPtr++] = (char) c;\n+        }\n+        _inputPtr = ptr;\n+        _finishString2(outBuf, outPtr);\n+        return _textBuffer.contentsAsString();\n+    }\n+    \n     private final void _finishString2(char[] outBuf, int outPtr)\n         throws IOException\n     {\n--- a/src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java\n     @Override\n     public void writeString(String text) throws IOException\n     {\n-        _verifyValueWrite(\"write text value\");\n+        _verifyValueWrite(WRITE_STRING);\n         if (text == null) {\n             _writeNull();\n             return;\n     @Override\n     public void writeString(char[] text, int offset, int len) throws IOException\n     {\n-        _verifyValueWrite(\"write text value\");\n+        _verifyValueWrite(WRITE_STRING);\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n         }\n     @Override\n     public void writeString(SerializableString sstr) throws IOException\n     {\n-        _verifyValueWrite(\"write text value\");\n+        _verifyValueWrite(WRITE_STRING);\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n         }\n     public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write binary value\");\n+        _verifyValueWrite(WRITE_BINARY);\n         // Starting quotes\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n             InputStream data, int dataLength)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write binary value\");\n+        _verifyValueWrite(WRITE_BINARY);\n         // Starting quotes\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n     @Override\n     public void writeNumber(short s) throws IOException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (_cfgNumbersAsStrings) {\n             _writeQuotedShort(s);\n             return;\n     @Override\n     public void writeNumber(int i) throws IOException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (_cfgNumbersAsStrings) {\n             _writeQuotedInt(i);\n             return;\n     @Override\n     public void writeNumber(long l) throws IOException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (_cfgNumbersAsStrings) {\n             _writeQuotedLong(l);\n             return;\n     @Override\n     public void writeNumber(BigInteger value) throws IOException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (value == null) {\n             _writeNull();\n         } else if (_cfgNumbersAsStrings) {\n             return;\n         }\n         // What is the max length for doubles? 40 chars?\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         writeRaw(String.valueOf(d));\n     }\n \n             return;\n         }\n         // What is the max length for floats?\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         writeRaw(String.valueOf(f));\n     }\n \n     public void writeNumber(BigDecimal value) throws IOException\n     {\n         // Don't really know max length for big decimal, no point checking\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (value == null) {\n             _writeNull();\n         } else if (_cfgNumbersAsStrings) {\n     @Override\n     public void writeNumber(String encodedValue) throws IOException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (_cfgNumbersAsStrings) {\n             _writeQuotedRaw(encodedValue);            \n         } else {\n     @Override\n     public void writeBoolean(boolean state) throws IOException\n     {\n-        _verifyValueWrite(\"write boolean value\");\n+        _verifyValueWrite(WRITE_BOOLEAN);\n         if ((_outputTail + 5) >= _outputEnd) {\n             _flushBuffer();\n         }\n \n     @Override\n     public void writeNull() throws IOException {\n-        _verifyValueWrite(\"write null value\");\n+        _verifyValueWrite(WRITE_NULL);\n         _writeNull();\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/core/util/BufferRecycler.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/BufferRecycler.java\n     public final char[] allocCharBuffer(int ix) {\n         return allocCharBuffer(ix, 0);\n     }\n-    \n+\n     public char[] allocCharBuffer(int ix, int minSize) {\n         final int DEF_SIZE = charBufferLength(ix);\n         if (minSize < DEF_SIZE) {\n--- a/src/main/java/com/fasterxml/jackson/core/util/JsonParserDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonParserDelegate.java\n     @Override public int getCurrentTokenId() { return delegate.getCurrentTokenId(); }\n     @Override public boolean hasCurrentToken() { return delegate.hasCurrentToken(); }\n     @Override public boolean hasTokenId(int id) { return delegate.hasTokenId(id); }\n-    \n+    @Override public boolean hasToken(JsonToken t) { return delegate.hasToken(t); }\n+\n     @Override public String getCurrentName() throws IOException, JsonParseException { return delegate.getCurrentName(); }\n     @Override public JsonLocation getCurrentLocation() { return delegate.getCurrentLocation(); }\n     @Override public JsonStreamContext getParsingContext() { return delegate.getParsingContext(); }\n--- a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n     public int getCurrentSegmentSize() { return _currentSize; }\n     public void setCurrentLength(int len) { _currentSize = len; }\n \n+    /**\n+     * @since 2.6\n+     */\n+    public String setCurrentAndReturn(int len) {\n+        _currentSize = len;\n+        // We can simplify handling here compared to full `contentsAsString()`:\n+        if (_segmentSize > 0) { // longer text; call main method\n+            return contentsAsString();\n+        }\n+        // more common case: single segment\n+        int currLen = _currentSize;\n+        String str = (currLen == 0) ? \"\" : new String(_currentSegment, 0, currLen);\n+        _resultString = str;\n+        return str;\n+    }\n+    \n     public char[] finishCurrentSegment() {\n         if (_segments == null) {\n             _segments = new ArrayList<char[]>();\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/GeneratorFailTest.java\n+package com.fasterxml.jackson.core.json;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.OutputStreamWriter;\n+\n+import com.fasterxml.jackson.core.JsonEncoding;\n+import com.fasterxml.jackson.core.JsonFactory;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+\n+public class GeneratorFailTest\n+    extends com.fasterxml.jackson.core.BaseTest\n+{\n+    private final JsonFactory F = new JsonFactory();\n+\n+    // [core#167]: no error for writing field name twice\n+    public void testDupFieldNameWrites() throws Exception\n+    {\n+        _testDupFieldNameWrites(F, false);\n+        _testDupFieldNameWrites(F, true);        \n+    }\n+\n+    // [core#177]\n+    // Also: should not try writing JSON String if field name expected\n+    // (in future maybe take one as alias... but not yet)\n+    public void testFailOnWritingStringNotFieldNameBytes() throws Exception {\n+        _testFailOnWritingStringNotFieldName(F, false);\n+    }\n+\n+    // [core#177]\n+    public void testFailOnWritingStringNotFieldNameChars() throws Exception {\n+        _testFailOnWritingStringNotFieldName(F, true);        \n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+\n+    private void _testDupFieldNameWrites(JsonFactory f, boolean useReader) throws Exception\n+    {\n+        JsonGenerator gen;\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        if (useReader) {\n+            gen = f.createGenerator(new OutputStreamWriter(bout, \"UTF-8\"));\n+        } else {\n+            gen = f.createGenerator(bout, JsonEncoding.UTF8);\n+        }\n+        gen.writeStartObject();\n+        gen.writeFieldName(\"a\");\n+        \n+        try {\n+            gen.writeFieldName(\"b\");\n+            gen.flush();\n+            String json = bout.toString(\"UTF-8\");\n+            fail(\"Should not have let two consecutive field name writes succeed: output = \"+json);\n+        } catch (JsonProcessingException e) {\n+            verifyException(e, \"can not write a field name, expecting a value\");\n+        }\n+        gen.close();\n+    }\n+\n+    private void _testFailOnWritingStringNotFieldName(JsonFactory f, boolean useReader) throws Exception\n+    {\n+        JsonGenerator gen;\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        if (useReader) {\n+            gen = f.createGenerator(new OutputStreamWriter(bout, \"UTF-8\"));\n+        } else {\n+            gen = f.createGenerator(bout, JsonEncoding.UTF8);\n+        }\n+        gen.writeStartObject();\n+        \n+        try {\n+            gen.writeString(\"a\");\n+            gen.flush();\n+            String json = bout.toString(\"UTF-8\");\n+            fail(\"Should not have let \"+gen.getClass().getName()+\".writeString() be used in place of 'writeFieldName()': output = \"+json);\n+        } catch (JsonProcessingException e) {\n+            verifyException(e, \"can not write a String\");\n+        }\n+        gen.close();\n+    }\n+\n+\n+}\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestJsonGenerator.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestJsonGenerator.java\n         gen.close();\n     }\n \n-    // [core#167]: no error for writing field name twice\n-    public void testDupFieldNameWrites() throws Exception\n-    {\n-        JsonFactory f = new JsonFactory();\n-        _testDupFieldNameWrites(f, false);\n-        _testDupFieldNameWrites(f, true);        \n-    }\n-\n-    private void _testDupFieldNameWrites(JsonFactory f, boolean useReader) throws Exception\n-    {\n-        JsonGenerator gen;\n-        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n-        if (useReader) {\n-            gen = f.createGenerator(new OutputStreamWriter(bout, \"UTF-8\"));\n-        } else {\n-            gen = f.createGenerator(bout, JsonEncoding.UTF8);\n-        }\n-        gen.writeStartObject();\n-        gen.writeFieldName(\"a\");\n-        \n-        try {\n-            gen.writeFieldName(\"b\");\n-            gen.flush();\n-            String json = bout.toString(\"UTF-8\");\n-            fail(\"Should not have let two consequtive field name writes succeed: output = \"+json);\n-        } catch (JsonProcessingException e) {\n-            verifyException(e, \"can not write a field name, expecting a value\");\n-        }\n-        gen.close();\n-    }\n-\n     /*\n     /**********************************************************\n     /* Internal methods\n     /**********************************************************\n      */\n-    \n-    private void doTestIntWrite(boolean pad)\n-        throws Exception\n+\n+    private void doTestIntWrite(boolean pad) throws Exception\n     {\n         int[] VALUES = new int[] {\n             0, 1, -9, 32, -32, 57, 189, 2017, -9999, 13240, 123456,\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestParserSymbols.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestParserSymbols.java\n {\n     // For [Issue#148]\n     public void testSymbolsWithNullBytes() throws Exception {\n-        _testSymbolsWithNull(true);\n+        JsonFactory f = new JsonFactory();\n+        _testSymbolsWithNull(f, true);\n+        // and repeat with same factory, just for fun, and to ensure symbol table is fine\n+        _testSymbolsWithNull(f, true);\n     }\n \n     // For [Issue#148]\n     public void testSymbolsWithNullChars() throws Exception {\n-        _testSymbolsWithNull(false);\n+        JsonFactory f = new JsonFactory();\n+        _testSymbolsWithNull(f, false);\n+        _testSymbolsWithNull(f, false);\n     }\n     \n-    private void _testSymbolsWithNull(boolean useBytes) throws Exception\n+    private void _testSymbolsWithNull(JsonFactory f, boolean useBytes) throws Exception\n     {\n         final JsonFactory f = new JsonFactory();\n         final String INPUT = \"{\\\"\\\\u0000abc\\\" : 1, \\\"abc\\\":2}\";\n         assertToken(JsonToken.START_OBJECT, parser.nextToken());\n \n         assertToken(JsonToken.FIELD_NAME, parser.nextToken());\n-        assertEquals(\"\\u0000abc\", parser.getCurrentName());\n+        String currName = parser.getCurrentName();\n+        if (!\"\\u0000abc\".equals(currName)) {\n+            fail(\"Expected \\\\0abc (4 bytes), '\"+currName+\"' (\"+currName.length()+\")\");\n+        }\n         assertToken(JsonToken.VALUE_NUMBER_INT, parser.nextToken());\n         assertEquals(1, parser.getIntValue());\n \n         assertToken(JsonToken.FIELD_NAME, parser.nextToken());\n-        assertEquals(\"abc\", parser.getCurrentName());\n+        currName = parser.getCurrentName();\n+        if (!\"abc\".equals(currName)) {\n+            /*\n+            for (int i = 0; i < currName.length(); ++i) {\n+                System.out.println(\"#\"+i+\" -> 0x\"+Integer.toHexString(currName.charAt(i)));\n+            }\n+            */\n+            fail(\"Expected 'abc' (3 bytes), '\"+currName+\"' (\"+currName.length()+\")\");\n+        }\n         assertToken(JsonToken.VALUE_NUMBER_INT, parser.nextToken());\n         assertEquals(2, parser.getIntValue());\n         \n--- a/src/test/java/com/fasterxml/jackson/core/json/TestUtf8Parser.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestUtf8Parser.java\n         jp.close();\n     }\n \n-    public void testUtf8Name2Bytes()\n-        throws Exception\n+    public void testUtf8Name2Bytes() throws Exception\n     {\n         final String[] NAMES = UTF8_2BYTE_STRINGS;\n \n             String DOC = \"{ \\\"\"+NAME+\"\\\" : 0 }\";\n             JsonParser jp = createParserUsingStream(DOC, \"UTF-8\");\n             assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+\n+            assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+\n+            assertTrue(jp.hasToken(JsonToken.FIELD_NAME));\n+            assertTrue(jp.hasTokenId(JsonTokenId.ID_FIELD_NAME));\n             \n-            assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n             assertEquals(NAME, jp.getCurrentName());\n             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertTrue(jp.hasToken(JsonToken.VALUE_NUMBER_INT));\n+            assertTrue(jp.hasTokenId(JsonTokenId.ID_NUMBER_INT));\n+\n             // should retain name during value entry, too\n             assertEquals(NAME, jp.getCurrentName());\n             \n--- /dev/null\n+++ b/src/test/java/perf/EnumByBytesLookup.java\n+package perf;\n+\n+import java.nio.charset.Charset;\n+import java.util.Arrays;\n+\n+/**\n+ * Trie container/wrapper, in this case implements Enum-value lookup.\n+ * Sample code to possibly use for streamlined-lookup by dictionary, using\n+ * UTF-8 bytes of {@link Enum#name()} as the key.\n+ */\n+public class EnumByBytesLookup<E extends Enum<E>>\n+{\n+    private final static Charset UTF8 = Charset.forName(\"UTF-8\");\n+\n+    private final Trie<E> _root;\n+    private final int _size;\n+\n+    private EnumByBytesLookup(Trie<E> root, int size) {\n+        _root = root;\n+        _size = size;\n+    }\n+\n+    public static <EIN extends Enum<EIN>> EnumByBytesLookup<EIN> buildFor(Class<EIN> enumClass)\n+    {\n+        Trie<EIN> root = new Trie<EIN>(null);\n+        int size = 0;\n+        for (EIN en : enumClass.getEnumConstants()) {\n+            byte[] key = en.name().getBytes(UTF8);\n+            root = root.with(en, key);\n+            ++size;\n+        }\n+        return new EnumByBytesLookup<EIN>(root, size);\n+    }\n+\n+    public E find(byte[] rawId) {\n+      return _root.find(rawId);\n+    }\n+\n+    public int size() { return _size; }\n+}\n+\n+/**\n+ * Trie nodes\n+ */\n+class Trie<T> {\n+    private final static byte[] NO_BYTES = new byte[0];\n+\n+    private final static Trie<?>[] NO_NODES = new Trie<?>[0];\n+\n+    /**\n+     * For leaves, value matched by sequence\n+     */\n+    private final T _match;\n+\n+    private final byte[] _nextBytes;\n+    private final Trie<T>[] nextNodes;\n+\n+    private final int nextCount;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    Trie(T match) {\n+      this(match, NO_BYTES, (Trie<T>[]) NO_NODES);\n+    }\n+\n+    private Trie(T match, byte[] nextBytes, Trie<T>[] nextNodes) {\n+      this._match = match;\n+      this._nextBytes = nextBytes;\n+      this.nextNodes = nextNodes;\n+      nextCount = nextBytes.length;\n+    }\n+\n+    private Trie(Trie<T> base, T match) {\n+      // should we allow duplicate calls with same match? For now, let's not\n+      if (base._match != null) {\n+        throw new IllegalArgumentException(\"Trying to add same match multiple times\");\n+      }\n+      this._match = match;\n+      _nextBytes = base._nextBytes;\n+      nextNodes = base.nextNodes;\n+      nextCount = base.nextCount;\n+    }\n+\n+    private Trie(Trie<T> base, byte nextByte, Trie<T> nextNode) {\n+      // should we allow duplicate calls with same match? For now, let's not\n+      if (base._match != null) {\n+        throw new IllegalArgumentException(\"Trying to add same match multiple times\");\n+      }\n+      _match = base._match;\n+      int size = base._nextBytes.length + 1;\n+      _nextBytes = Arrays.copyOf(base._nextBytes, size);\n+      _nextBytes[size-1] = nextByte;\n+      nextNodes = Arrays.copyOf(base.nextNodes, size);\n+      nextNodes[size-1] = nextNode;\n+      nextCount = size;\n+    }\n+\n+    /**\n+     * Constructor used when an existing branch needs to be replaced due to addition\n+     */\n+    private Trie(Trie<T> base, int offset, Trie<T> newNode) {\n+      _match = base._match;\n+      // can keep nextBytes, as they don't change\n+      _nextBytes = base._nextBytes;\n+      // but must create a copy of next nodes, to modify one entry\n+      nextNodes = Arrays.copyOf(base.nextNodes, base.nextNodes.length);\n+      nextNodes[offset] = newNode;\n+      nextCount = base.nextCount;\n+    }\n+\n+    /**\n+     * \"Mutant factory\" method: constructs a modified Trie, with specified raw id\n+     * added.\n+     */\n+    public Trie<T> with(T match, byte[] rawId) {\n+      return with(match, rawId, 0, rawId.length);\n+    }\n+\n+    private Trie<T> with(T match, byte[] rawId, int start, int end) {\n+      if (start == end) {\n+        return new Trie<T>(this, match);\n+      }\n+      // Ok: two choices; either we follow existing branch; or need to create new one\n+      final byte b = rawId[start++];\n+      for (int i = 0; i < nextCount; ++i) {\n+        if (_nextBytes[i] == b) {\n+          // existing branch: good day for delegation...\n+          Trie<T> old = nextNodes[i];\n+          // to keep things truly immutable, copy underlying arrays, then\n+          return new Trie<T>(this, i, old.with(match, rawId, start, end));\n+        }\n+      }\n+      // simplest recursively, but for fun let's convert to iteration. Start with tail\n+      Trie<T> curr = new Trie<T>(match);\n+\n+      for (int i = end-1; i >= start; --i) {\n+        curr = new Trie<T>(this, rawId[i], curr);\n+      }\n+      return new Trie<T>(this, b, curr);\n+    }\n+\n+    public T find(byte[] id) {\n+      return find(id, 0, id.length);\n+    }\n+\n+    public T find(byte[] id, int offset, int length) {\n+      Trie<T> t = this;\n+      final int end = offset+length;\n+\n+      for (; offset < end; ++offset) {\n+        byte b = id[offset];\n+        t = t.next(b);\n+        if (t == null) {\n+            // NOTE: if using null-padding, would trim here\n+            /*\n+          if (b == (byte) 0) {\n+            break;\n+          }\n+          */\n+          return null;\n+        }\n+      }\n+      return t._match;\n+    }\n+\n+    private Trie<T> next(int b) {\n+      for (int i = 0; i < nextCount; ++i) {\n+        if (_nextBytes[i] == b) {\n+          return nextNodes[i];\n+        }\n+      }\n+      return null;\n+    }\n+}", "timestamp": 1422941855, "metainfo": ""}