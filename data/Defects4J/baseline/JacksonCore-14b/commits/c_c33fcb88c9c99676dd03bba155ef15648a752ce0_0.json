{"sha": "c33fcb88c9c99676dd03bba155ef15648a752ce0", "log": "Merge branch '2.7'", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n      * \n      * @since 2.5\n      */\n-    protected final static int DERIVED_FEATURES_MASK = Feature.WRITE_NUMBERS_AS_STRINGS.getMask()\n+    protected final static int DERIVED_FEATURES_MASK =\n+            Feature.WRITE_NUMBERS_AS_STRINGS.getMask()\n             | Feature.ESCAPE_NON_ASCII.getMask()\n             | Feature.STRICT_DUPLICATE_DETECTION.getMask()\n             ;\n      * {@link com.fasterxml.jackson.core.JsonGenerator.Feature#WRITE_NUMBERS_AS_STRINGS}).\n      */\n     protected boolean _cfgNumbersAsStrings;\n-    \n+\n     /*\n     /**********************************************************\n     /* State\n     @Override public int getFeatureMask() { return _features; }\n \n     //public JsonGenerator configure(Feature f, boolean state) { }\n-    \n+\n     @Override\n     public JsonGenerator enable(Feature f) {\n         final int mask = f.getMask();\n         _features |= mask;\n         if ((mask & DERIVED_FEATURES_MASK) != 0) {\n+            // why not switch? Requires addition of a generated class, alas\n             if (f == Feature.WRITE_NUMBERS_AS_STRINGS) {\n                 _cfgNumbersAsStrings = true;\n             } else if (f == Feature.ESCAPE_NON_ASCII) {\n             }\n         }\n     }\n-    \n+\n     @Override public JsonGenerator useDefaultPrettyPrinter() {\n         // Should not override a pretty printer if one already assigned.\n         if (getPrettyPrinter() != null) {\n--- a/src/main/java/com/fasterxml/jackson/core/json/JsonGeneratorImpl.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonGeneratorImpl.java\n     protected SerializableString _rootValueSeparator\n         = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;\n \n+    /**\n+     * Flag that is set if quoting is not to be added around\n+     * JSON Object property names.\n+     *\n+     * @since 2.7\n+     */\n+    protected boolean _cfgUnqNames;\n+\n     /*\n     /**********************************************************\n     /* Life-cycle\n     {\n         super(features, codec);\n         _ioContext = ctxt;\n-        if (isEnabled(Feature.ESCAPE_NON_ASCII)) {\n+        if (Feature.ESCAPE_NON_ASCII.enabledIn(features)) {\n             // inlined `setHighestNonEscapedChar()`\n             _maximumNonEscapedChar = 127;\n         }\n+        _cfgUnqNames = !Feature.QUOTE_FIELD_NAMES.enabledIn(features);\n     }\n \n     /*\n     /* Overridden configuration methods\n     /**********************************************************\n      */\n+\n+    @Override\n+    public JsonGenerator enable(Feature f) {\n+        super.enable(f);\n+        if (f == Feature.QUOTE_FIELD_NAMES) {\n+            _cfgUnqNames = false;\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public JsonGenerator disable(Feature f) {\n+        super.disable(f);\n+        if (f == Feature.QUOTE_FIELD_NAMES) {\n+            _cfgUnqNames = true;\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    protected void _checkStdFeatureChanges(int newFeatureFlags, int changedFeatures) {\n+        super._checkStdFeatureChanges(newFeatureFlags, changedFeatures);\n+        _cfgUnqNames = !Feature.QUOTE_FIELD_NAMES.enabledIn(newFeatureFlags);\n+    }\n \n     @Override\n     public JsonGenerator setHighestNonEscapedChar(int charCode) {\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n      * needs to be returned to recycler once we are done) or not.\n      */\n     protected boolean _bufferRecyclable;\n-\n-    /*\n-    /**********************************************************\n-    /* Quick flags\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * Flag that is set if quoting is not to be added around\n-     * JSON Object property names.\n-     */\n-    protected boolean _cfgUnqNames;\n \n     /*\n     /**********************************************************\n         if (isEnabled(Feature.ESCAPE_NON_ASCII)) {\n             setHighestNonEscapedChar(127);\n         }\n-        _cfgUnqNames = !Feature.QUOTE_FIELD_NAMES.enabledIn(features);\n     }\n     \n     public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec,\n         _outputMaxContiguous = (_outputEnd >> 3);\n         _charBuffer = ctxt.allocConcatBuffer();\n         _charBufferLength = _charBuffer.length;\n-        _cfgUnqNames = !Feature.QUOTE_FIELD_NAMES.enabledIn(features);\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java\n             _outputBuffer[_outputTail++] = ',';\n         }\n         // Alternate mode, in which quoting of field names disabled?\n-        if (!isEnabled(Feature.QUOTE_FIELD_NAMES)) {\n+        if (_cfgUnqNames) {\n             _writeString(name);\n             return;\n         }\n         }\n         // Alternate mode, in which quoting of field names disabled?\n         final char[] quoted = name.asQuotedChars();\n-        if (!isEnabled(Feature.QUOTE_FIELD_NAMES)) {\n+        if (_cfgUnqNames) {\n             writeRaw(quoted, 0, quoted.length);\n             return;\n         }\n             _cfgPrettyPrinter.beforeObjectEntries(this);\n         }\n \n-        if (isEnabled(Feature.QUOTE_FIELD_NAMES)) { // standard\n+        if (_cfgUnqNames) {// non-standard, omit quotes\n+            _writeString(name);\n+        } else { \n             if (_outputTail >= _outputEnd) {\n                 _flushBuffer();\n             }\n                 _flushBuffer();\n             }\n             _outputBuffer[_outputTail++] = '\"';\n-        } else { // non-standard, omit quotes\n-            _writeString(name);\n         }\n     }\n \n         }\n     \n         final char[] quoted = name.asQuotedChars();\n-        if (isEnabled(Feature.QUOTE_FIELD_NAMES)) { // standard\n+        if (_cfgUnqNames) {// non-standard, omit quotes\n+            writeRaw(quoted, 0, quoted.length);\n+        } else {\n             if (_outputTail >= _outputEnd) {\n                 _flushBuffer();\n             }\n                 _flushBuffer();\n             }\n             _outputBuffer[_outputTail++] = '\"';\n-        } else { // non-standard, omit quotes\n-            writeRaw(quoted, 0, quoted.length);\n         }\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/core/json/TestJsonGeneratorFeatures.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestJsonGeneratorFeatures.java\n public class TestJsonGeneratorFeatures\n     extends com.fasterxml.jackson.core.BaseTest\n {\n+    private final JsonFactory JSON_F = new JsonFactory();\n+\n     public void testConfigDefaults() throws IOException\n     {\n-        JsonFactory jf = new JsonFactory();\n-        JsonGenerator jg = jf.createGenerator(new StringWriter());\n+        JsonGenerator jg = JSON_F.createGenerator(new StringWriter());\n         assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS));\n         assertFalse(jg.isEnabled(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN));\n         jg.close();\n         _testFieldNameQuoting(jf, true);\n     }\n \n-    public void testNonNumericQuoting()\n-        throws IOException\n+    public void testNonNumericQuoting() throws IOException\n     {\n         JsonFactory jf = new JsonFactory();\n         // by default, quoting should be enabled\n         return sw.toString();\n     }\n \n+    // for [core#246]\n+    public void testFieldNameQuotingEnabled() throws IOException\n+    {\n+        // // First, test with default factory, with quoting enabled by default\n+        \n+        // First, default, with quotes\n+        _testFieldNameQuotingEnabled(JSON_F, true, true, \"{\\\"foo\\\":1}\");\n+        _testFieldNameQuotingEnabled(JSON_F, false, true, \"{\\\"foo\\\":1}\");\n+\n+        // then without quotes\n+        _testFieldNameQuotingEnabled(JSON_F, true, false, \"{foo:1}\");\n+        _testFieldNameQuotingEnabled(JSON_F, false, false, \"{foo:1}\");\n+\n+        // // Then with alternatively configured factory\n+\n+        JsonFactory JF2 = new JsonFactory();\n+        JF2.disable(JsonGenerator.Feature.QUOTE_FIELD_NAMES);\n+\n+        _testFieldNameQuotingEnabled(JF2, true, true, \"{\\\"foo\\\":1}\");\n+        _testFieldNameQuotingEnabled(JF2, false, true, \"{\\\"foo\\\":1}\");\n+\n+        // then without quotes\n+        _testFieldNameQuotingEnabled(JF2, true, false, \"{foo:1}\");\n+        _testFieldNameQuotingEnabled(JF2, false, false, \"{foo:1}\");\n+    }\n+\n+    private void _testFieldNameQuotingEnabled(JsonFactory jf, boolean useBytes,\n+            boolean useQuotes, String exp) throws IOException\n+    {\n+        ByteArrayOutputStream bytes = useBytes ? new ByteArrayOutputStream() : null;\n+        StringWriter sw = useBytes ? null : new StringWriter();\n+        JsonGenerator gen = useBytes ? jf.createGenerator(bytes) : jf.createGenerator(sw);\n+        if (useQuotes) {\n+            gen.enable(JsonGenerator.Feature.QUOTE_FIELD_NAMES);\n+        } else {\n+            gen.disable(JsonGenerator.Feature.QUOTE_FIELD_NAMES);\n+        }\n+\n+        gen.writeStartObject();\n+        gen.writeFieldName(\"foo\");\n+        gen.writeNumber(1);\n+        gen.writeEndObject();\n+        gen.close();\n+\n+        String json = useBytes ? bytes.toString(\"UTF-8\") : sw.toString();\n+        assertEquals(exp, json);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Helper methods\n--- a/src/main/java/com/fasterxml/jackson/core/ObjectCodec.java\n+++ b/src/main/java/com/fasterxml/jackson/core/ObjectCodec.java\n {\n     protected ObjectCodec() { }\n \n-    // Since 2.3: need baseline implementation to avoid backwards compatibility\n+    // Since 2.3\n     @Override\n-    public Version version() { return Version.unknownVersion(); }\n+    public abstract Version version();\n     \n     /*\n     /**********************************************************\n      * The reason is that due to type erasure, key and value types\n      * can not be introspected when using this method.\n      */\n-    public abstract <T> T readValue(JsonParser jp, Class<T> valueType)\n-        throws IOException, JsonProcessingException;\n+    public abstract <T> T readValue(JsonParser p, Class<T> valueType)\n+        throws IOException;\n \n     /**\n      * Method to deserialize JSON content into a Java type, reference\n      * and specifically needs to be used if the root type is a \n      * parameterized (generic) container type.\n      */\n-    public abstract <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef)\n-        throws IOException, JsonProcessingException;\n+    public abstract <T> T readValue(JsonParser p, TypeReference<?> valueTypeRef)\n+        throws IOException;\n \n     /**\n      * Method to deserialize JSON content into a POJO, type specified\n      * including containers like {@link java.util.Collection} and\n      * {@link java.util.Map}).\n      */\n-    public abstract <T> T readValue(JsonParser jp, ResolvedType valueType)\n-        throws IOException, JsonProcessingException;\n+    public abstract <T> T readValue(JsonParser p, ResolvedType valueType)\n+        throws IOException;\n \n     /**\n      * Method for reading sequence of Objects from parser stream,\n      * all with same specified value type.\n      */\n-    public abstract <T> Iterator<T> readValues(JsonParser jp, Class<T> valueType)\n-        throws IOException, JsonProcessingException;\n+    public abstract <T> Iterator<T> readValues(JsonParser p, Class<T> valueType)\n+        throws IOException;\n \n     /**\n      * Method for reading sequence of Objects from parser stream,\n      * all with same specified value type.\n      */\n-    public abstract <T> Iterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef)\n-        throws IOException, JsonProcessingException;\n+    public abstract <T> Iterator<T> readValues(JsonParser p, TypeReference<?> valueTypeRef)\n+        throws IOException;\n     \n     /**\n      * Method for reading sequence of Objects from parser stream,\n      * all with same specified value type.\n      */\n-    public abstract <T> Iterator<T> readValues(JsonParser jp, ResolvedType valueType)\n-        throws IOException, JsonProcessingException;\n-    \n+    public abstract <T> Iterator<T> readValues(JsonParser p, ResolvedType valueType)\n+        throws IOException;\n+\n     /*\n     /**********************************************************\n     /* API for serialization (Object-to-JSON)\n      * Method to serialize given Java Object, using generator\n      * provided.\n      */\n-    public abstract void writeValue(JsonGenerator jgen, Object value)\n-        throws IOException, JsonProcessingException;\n+    public abstract void writeValue(JsonGenerator gen, Object value) throws IOException;\n \n     /*\n     /**********************************************************\n      * value event, not container). Empty or whitespace\n      * documents return null.\n      *\n-     * @return next tree from jp, or null if empty.\n+     * @return next tree from p, or null if empty.\n      */\n     @Override\n-    public abstract <T extends TreeNode> T readTree(JsonParser jp)\n-        throws IOException, JsonProcessingException;\n+    public abstract <T extends TreeNode> T readTree(JsonParser p) throws IOException;\n     \n     @Override\n-    public abstract void writeTree(JsonGenerator jg, TreeNode tree)\n-        throws IOException, JsonProcessingException;\n+    public abstract void writeTree(JsonGenerator gen, TreeNode tree) throws IOException;\n     \n     /**\n      * Method for construct root level Object nodes", "timestamp": 1456200915, "metainfo": ""}