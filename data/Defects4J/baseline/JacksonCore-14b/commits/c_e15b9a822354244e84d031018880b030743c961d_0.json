{"sha": "e15b9a822354244e84d031018880b030743c961d", "log": "minor cleanup", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n          * Method that calculates bit set (flags) of all features that\n          * are enabled by default.\n          */\n-        public static int collectDefaults()\n-        {\n+        public static int collectDefaults() {\n             int flags = 0;\n             for (Feature f : values()) {\n-                if (f.enabledByDefault()) {\n-                    flags |= f.getMask();\n-                }\n+                if (f.enabledByDefault()) { flags |= f.getMask(); }\n             }\n             return flags;\n         }\n         \n-        private Feature(boolean defaultState)\n-        {\n-            _defaultState = defaultState;\n-        }\n+        private Feature(boolean defaultState) { _defaultState = defaultState; }\n         \n         public boolean enabledByDefault() { return _defaultState; }\n-\n         public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\n-        \n         public int getMask() { return (1 << ordinal()); }\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/core/io/SerializedString.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/SerializedString.java\n      *   enough to omit volatiles here, given how simple lazy initialization is.\n      *   This can be compared to how {@link String#intern} works; lazily and\n      *   without synchronization or use of volatile keyword.\n-     *   \n+     *\n      *   Change to remove volatile was a request by implementors of a high-throughput\n      *   search framework; and they believed this is an important optimization for\n      *   heaviest, multi-core deployed use cases.\n     /*\n      * 22-Sep-2013, tatu: FWIW, there have been no reports of problems in this\n      *   area, or anything pointing to it. So I think we are safe up to JDK7\n+     *   and hopefully beyond.\n      */\n     \n     protected /*volatile*/ byte[] _quotedUTF8Ref;\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n     /**********************************************************\n      */\n \n-    @Override\n-    public ObjectCodec getCodec() {\n-        return _objectCodec;\n-    }\n-\n-    @Override\n-    public void setCodec(ObjectCodec c) {\n-        _objectCodec = c;\n-    }\n+    @Override public ObjectCodec getCodec() { return _objectCodec; }\n+    @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n     \n     @Override\n-    public int releaseBuffered(Writer w) throws IOException\n-    {\n+    public int releaseBuffered(Writer w) throws IOException {\n         int count = _inputEnd - _inputPtr;\n-        if (count < 1) {\n-            return 0;\n-        }\n+        if (count < 1) { return 0; }\n         // let's just advance ptr to end\n         int origPtr = _inputPtr;\n         w.write(_inputBuffer, origPtr, count);\n         return count;\n     }\n \n-    @Override\n-    public Object getInputSource() {\n-        return _reader;\n-    }\n+    @Override public Object getInputSource() { return _reader; }\n \n     @Override\n     protected boolean loadMore() throws IOException\n         return false;\n     }\n \n-    protected char getNextChar(String eofMsg)\n-        throws IOException, JsonParseException\n+    protected char getNextChar(String eofMsg) throws IOException\n     {\n         if (_inputPtr >= _inputEnd) {\n             if (!loadMore()) {\n      * separately (if need be).\n      */\n     @Override\n-    protected void _releaseBuffers()\n-        throws IOException\n+    protected void _releaseBuffers() throws IOException\n     {\n         super._releaseBuffers();\n         // merge new symbols, if any\n      * Method can be called for any event.\n      */\n     @Override\n-    public String getText()\n-        throws IOException, JsonParseException\n+    public String getText() throws IOException\n     {\n         JsonToken t = _currToken;\n         if (t == JsonToken.VALUE_STRING) {\n     \n     // @since 2.1\n     @Override\n-    public String getValueAsString() throws IOException, JsonParseException\n+    public String getValueAsString() throws IOException\n     {\n         if (_currToken == JsonToken.VALUE_STRING) {\n             if (_tokenIncomplete) {\n     \n     // @since 2.1\n     @Override\n-    public String getValueAsString(String defValue) throws IOException, JsonParseException\n-    {\n+    public String getValueAsString(String defValue) throws IOException {\n         if (_currToken == JsonToken.VALUE_STRING) {\n             if (_tokenIncomplete) {\n                 _tokenIncomplete = false;\n         return super.getValueAsString(defValue);\n     }\n \n-    protected String _getText2(JsonToken t)\n-    {\n+    protected String _getText2(JsonToken t) {\n         if (t == null) {\n             return null;\n         }\n     }\n \n     @Override\n-    public char[] getTextCharacters()\n-        throws IOException, JsonParseException\n+    public char[] getTextCharacters() throws IOException\n     {\n         if (_currToken != null) { // null only before/after document\n             switch (_currToken.id()) {\n     }\n \n     @Override\n-    public int getTextLength()\n-        throws IOException, JsonParseException\n+    public int getTextLength() throws IOException\n     {\n         if (_currToken != null) { // null only before/after document\n             switch (_currToken.id()) {\n     }\n \n     @Override\n-    public int getTextOffset() throws IOException, JsonParseException\n+    public int getTextOffset() throws IOException\n     {\n         // Most have offset of 0, only some may have other values:\n         if (_currToken != null) {\n     }\n \n     @Override\n-    public byte[] getBinaryValue(Base64Variant b64variant)\n-        throws IOException, JsonParseException\n+    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n     {\n         if (_currToken != JsonToken.VALUE_STRING &&\n                 (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n     }\n     \n     @Override\n-    public int readBinaryValue(Base64Variant b64variant, OutputStream out)\n-        throws IOException, JsonParseException\n+    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n     {\n         // if we have already read the token, just use whatever we may have\n         if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n         }\n     }\n \n-    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer)\n-            throws IOException, JsonParseException\n+    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException\n     {\n         int outputPtr = 0;\n         final int outputEnd = buffer.length - 3;\n      *   to indicate end-of-input\n      */\n     @Override\n-    public JsonToken nextToken()\n-        throws IOException, JsonParseException\n+    public JsonToken nextToken() throws IOException\n     {\n         _numTypesValid = NR_UNKNOWN;\n \n     /*\n     @Override\n     public boolean nextFieldName(SerializableString str)\n-         throws IOException, JsonParseException\n+         throws IOException\n      */\n \n     // note: identical to one in UTF8StreamJsonParser\n     @Override\n-    public String nextTextValue()\n-        throws IOException, JsonParseException\n+    public String nextTextValue() throws IOException\n     {\n         if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n             _nameCopied = false;\n \n     // note: identical to one in Utf8StreamParser\n     @Override\n-    public int nextIntValue(int defaultValue)\n-        throws IOException, JsonParseException\n+    public int nextIntValue(int defaultValue) throws IOException\n     {\n         if (_currToken == JsonToken.FIELD_NAME) {\n             _nameCopied = false;\n \n     // note: identical to one in Utf8StreamParser\n     @Override\n-    public long nextLongValue(long defaultValue)\n-        throws IOException, JsonParseException\n+    public long nextLongValue(long defaultValue) throws IOException\n     {\n         if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n             _nameCopied = false;\n \n     // note: identical to one in UTF8StreamJsonParser\n     @Override\n-    public Boolean nextBooleanValue()\n-        throws IOException, JsonParseException\n+    public Boolean nextBooleanValue() throws IOException\n     {\n         if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n             _nameCopied = false;\n         _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n     }\n     \n-    protected void _reportInvalidToken(String matchedPart, String msg)\n-        throws IOException\n+    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n     {\n         StringBuilder sb = new StringBuilder(matchedPart);\n         /* Let's just try to find what appears to be the token, using", "timestamp": 1390626064, "metainfo": ""}