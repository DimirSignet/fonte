{"sha": "0f1018fcc5d97d4107024b25829a73361719584c", "log": "trying to complete generator-filtering, complicated stuff.", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/filter/FilteringGeneratorDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/FilteringGeneratorDelegate.java\n  */\n public class FilteringGeneratorDelegate extends JsonGeneratorDelegate\n {\n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+    \n     /**\n      * Object consulted to determine whether to write parts of content generator\n      * is asked to write or not.\n      */\n     protected TokenFilter filter;\n+\n+    /**\n+     * Flag that determines whether filtering will continue after the first\n+     * match is indicated or not: if `false`, output is based on just the first\n+     * full match (returning {@link TokenFilter#FILTER_INCLUDE}) and no more\n+     * checks are made; if `true` then filtering will be applied as necessary\n+     * until end of content.\n+     */\n+    protected boolean _filterAll;\n+\n+    /**\n+     * Flag that determines whether path leading up to included content should\n+     * also be automatically included or not. If `false`, no path inclusion is\n+     * done and only explicitly included entries are output; if `true` then\n+     * path from main level down to match is also included as necessary.\n+     */\n+    protected boolean _includePath;\n+    \n+    /*\n+    /**********************************************************\n+    /* Construction, initialization\n+    /**********************************************************\n+     */\n \n     /**\n      * Although delegate has its own output context it is not sufficient since we actually\n      * actually outputs.\n      */\n     protected TokenFilterContext _filterContext;\n-\n-    /**\n-     * The current state constant is kept here as well, not just at the tip of {@link #_filterContext}.\n+    \n+    /**\n+     * The current state constant is kept here as well,\n+     * not just at the tip of {@link #_filterContext}.\n      */\n     protected int _currentState;\n \n+    /**\n+     * Number of tokens for which {@link TokenFilter#FILTER_INCLUDE}\n+     * has been returned\n+     */\n+    protected int _fullMatchCount;\n+\n+    /**\n+     * Number of tokens for which {@link TokenFilter#FILTER_INCLUDE_BUT_CHECK}\n+     * has been returned\n+     */\n+    protected int _partialMatchCount;\n+\n     /*\n     /**********************************************************\n     /* Construction, initialization\n     /**********************************************************\n      */\n \n-    public FilteringGeneratorDelegate(JsonGenerator d, TokenFilter f) {\n+    public FilteringGeneratorDelegate(JsonGenerator d, TokenFilter f)\n+    {\n         // By default, do NOT delegate copy methods\n         super(d, false);\n         filter = f;\n         // Doesn't matter if it's include or exclude current, but shouldn't be including/excluding sub-tree\n-        _currentState = TokenFilter.FILTER_INCLUDE_CURRENT;\n+        _currentState = TokenFilter.FILTER_CHECK;\n         _filterContext = TokenFilterContext.createRootContext(_currentState);\n     }\n \n \n     public TokenFilter getTokenFilter() { return filter; }\n \n+    /**\n+     * Accessor for finding number of \"full\" matches, where specific token and sub-tree\n+     * starting (if structured type) are passed.\n+     */\n+    public int getFullMatchCount() {\n+        return _partialMatchCount + _fullMatchCount;\n+    }\n+    \n+    /**\n+     * Accessor for finding number of total matches; both full matches (see\n+     * {@link #getFullMatchCount()}) and partial matches, latter meaning inclusion\n+     * of intermediate containers but not necessarily whole sub-tree.\n+     * This method can be called to check if any content was passed: if <code>0</code>\n+     * is returned, all content was filtered out and nothing was copied.\n+     */\n+    public int getMatchCount() {\n+        return _partialMatchCount + _fullMatchCount;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Public API, write methods, structural\n     /**********************************************************\n      */\n-\n+    \n     @Override\n     public void writeStartArray() throws IOException\n     {\n-        /*\n+        // First things first: whole-sale skipping easy\n+        if (_currentState == TokenFilter.FILTER_SKIP) {\n+            _filterContext = _filterContext.createChildArrayContext(_currentState, false);\n+            return;\n+        }\n+        \n         switch (_currentState) {\n-        case TokenFilter.FILTER_SKIP_TREE: // filter all down the tree?\n-            _filterContext = _filterContext.createChildArrayContext(_currentState);\n-            return;\n-        case TokenFilter.FILTER_SKIP_CURRENT: // may or may not include, need to check\n-        case TokenFilter.FILTER_INCLUDE_CURRENT:\n-            int newState = filter.startArray();\n-            _filterContext = _filterContext.createChildArrayContext(newState);\n-            if (newState >= TokenFilter.FILTER_INCLUDE_CURRENT) {\n+        case TokenFilter.FILTER_CHECK: // may or may not include, need to check\n+            int oldState = _currentState;\n+            _currentState = filter.filterStartArray();\n+            if (_currentState == TokenFilter.FILTER_INCLUDE) {\n+                // First: may need to re-create path\n+                _checkContainerParentPath(oldState, _currentState);\n+                _filterContext = _filterContext.createChildArrayContext(_currentState, true);\n                 delegate.writeStartArray();\n-            }\n-            return;\n-        case TokenFilter.FILTER_INCLUDE_TREE: // include the whole sub-tree?\n+            } else { // filter out\n+                _filterContext = _filterContext.createChildArrayContext(_currentState, false);\n+            }\n+            return;\n+        case TokenFilter.FILTER_INCLUDE: // include the whole sub-tree?\n         default:\n-            _filterContext = _filterContext.createChildArrayContext(_currentState);\n+            _filterContext = _filterContext.createChildArrayContext(_currentState, true);\n             delegate.writeStartArray();\n             return;\n         }\n-        */\n-    }\n-\n+    }\n+        \n     @Override\n     public void writeStartArray(int size) throws IOException\n     {\n-        /*\n+        // First things first: whole-sale skipping easy\n+        if (_currentState == TokenFilter.FILTER_SKIP) {\n+            _filterContext = _filterContext.createChildArrayContext(_currentState, false);\n+            return;\n+        }\n+\n         switch (_currentState) {\n-        case TokenFilter.FILTER_SKIP_TREE: // filter all down the tree?\n-            _filterContext = _filterContext.createChildArrayContext(_currentState);\n-            return;\n-        case TokenFilter.FILTER_SKIP_CURRENT: // may or may not include, need to check\n-        case TokenFilter.FILTER_INCLUDE_CURRENT:\n-            int newState = filter.startArray();\n-            _filterContext = _filterContext.createChildArrayContext(newState);\n-            if (newState >= TokenFilter.FILTER_INCLUDE_CURRENT) {\n+        case TokenFilter.FILTER_CHECK: // may or may not include, need to check\n+            int oldState = _currentState;\n+            _currentState = filter.filterStartArray();\n+            if (_currentState == TokenFilter.FILTER_INCLUDE) {\n+                // First: may need to re-create path\n+                _checkContainerParentPath(oldState, _currentState);\n+                _filterContext = _filterContext.createChildArrayContext(_currentState, true);\n                 delegate.writeStartArray(size);\n-            }\n-            return;\n-        case TokenFilter.FILTER_INCLUDE_TREE: // include the whole sub-tree?\n+            } else { // filter out\n+                _filterContext = _filterContext.createChildArrayContext(_currentState, false);\n+            }\n+            return;\n+        case TokenFilter.FILTER_INCLUDE: // include the whole sub-tree?\n         default:\n-            _filterContext = _filterContext.createChildArrayContext(_currentState);\n+            _filterContext = _filterContext.createChildArrayContext(_currentState, true);\n             delegate.writeStartArray(size);\n             return;\n         }\n-        */\n     }\n     \n     @Override\n     public void writeEndArray() throws IOException\n     {\n-        if (_currentState >= TokenFilter.FILTER_INCLUDE_CURRENT) {\n+        if (_filterContext.needsCloseToken()) {\n             delegate.writeEndArray();\n         }\n         _filterContext = _filterContext.getParent();\n     @Override\n     public void writeStartObject() throws IOException\n     {\n-        /*\n+        // First things first: whole-sale skipping easy\n+        if (_currentState == TokenFilter.FILTER_SKIP) {\n+            _filterContext = _filterContext.createChildObjectContext(_currentState, false);\n+            return;\n+        }\n+\n         switch (_currentState) {\n-        case TokenFilter.FILTER_SKIP_TREE: // filter all down the tree?\n-            _filterContext = _filterContext.createChildObjectContext(_currentState);\n-            return;\n-        case TokenFilter.FILTER_SKIP_CURRENT: // may or may not include, need to check\n-        case TokenFilter.FILTER_INCLUDE_CURRENT:\n-            int newState = filter.startObject();\n-            _filterContext = _filterContext.createChildObjectContext(newState);\n-            if (newState >= TokenFilter.FILTER_INCLUDE_CURRENT) {\n+        case TokenFilter.FILTER_CHECK: // may or may not include, need to check\n+            int oldState = _currentState;\n+            _currentState = filter.filterStartArray();\n+            if (_currentState == TokenFilter.FILTER_INCLUDE) {\n+                // First: may need to re-create path\n+                _checkContainerParentPath(oldState, _currentState);\n+                _filterContext = _filterContext.createChildObjectContext(_currentState, true);\n                 delegate.writeStartObject();\n-            }\n-            return;\n-        case TokenFilter.FILTER_INCLUDE_TREE: // include the whole sub-tree?\n+            } else { // filter out\n+                _filterContext = _filterContext.createChildObjectContext(_currentState, false);\n+            }\n+            return;\n+        case TokenFilter.FILTER_INCLUDE: // include the whole sub-tree?\n         default:\n-            _filterContext = _filterContext.createChildObjectContext(_currentState);\n+            _filterContext = _filterContext.createChildObjectContext(_currentState, true);\n             delegate.writeStartObject();\n             return;\n         }\n-        */\n     }\n     \n     @Override\n     public void writeEndObject() throws IOException\n     {\n-        if (_currentState >= TokenFilter.FILTER_INCLUDE_CURRENT) {\n-            delegate.writeEndObject();\n+        if (_filterContext.needsCloseToken()) {\n+            delegate.writeEndArray();\n         }\n         _filterContext = _filterContext.getParent();\n         if (_filterContext != null) {\n     @Override\n     public void writeFieldName(String name) throws IOException\n     {\n-        /*\n+        if (_currentState == TokenFilter.FILTER_SKIP) {\n+            return;\n+        }\n+        \n+        // !!! TODO\n+        \n         switch (_currentState) {\n-        case TokenFilter.FILTER_SKIP_TREE:\n-            return;\n-        case TokenFilter.FILTER_SKIP_CURRENT: // may or may not include, need to check\n-        case TokenFilter.FILTER_INCLUDE_CURRENT:\n-            _propertyState = filter.\n-            int state = filter.startObject();\n-            if (state >= TokenFilter.FILTER_INCLUDE_CURRENT) {\n-                delegate.writeStartObject();\n-            }\n-            return;\n-        case TokenFilter.FILTER_INCLUDE_TREE: // include the whole sub-tree?\n+        case TokenFilter.FILTER_CHECK:\n+            return;\n+        case TokenFilter.FILTER_INCLUDE:\n         default:\n-            delegate.writeFieldName(name);\n-            return;\n-        }\n-        */\n-    }\n-\n-    @Override\n-    public void writeFieldName(SerializableString name) throws IOException {\n-        delegate.writeFieldName(name);\n+            return;\n+        }\n+    }\n+\n+    @Override\n+    public void writeFieldName(SerializableString name) throws IOException\n+    {\n+        if (_currentState == TokenFilter.FILTER_SKIP) {\n+            return;\n+        }\n+\n+        // !!! TODO\n+        \n+        switch (_currentState) {\n+        case TokenFilter.FILTER_CHECK:\n+            return;\n+        case TokenFilter.FILTER_INCLUDE:\n+        default:\n+            return;\n+        }\n+//        delegate.writeFieldName(name);\n     }\n \n     /*\n      */\n \n     @Override\n-    public void writeString(String text) throws IOException {\n+    public void writeString(String text) throws IOException\n+    {\n+        if (_currentState == TokenFilter.FILTER_SKIP) {\n+            return;\n+        }\n+\n+        \n+        if (_currentState == TokenFilter.FILTER_INCLUDE) {\n+            delegate.writeString(text);\n+        } else if (_currentState == TokenFilter.FILTER_CHECK) {\n+//            if (filter.includeString(value))\n+        } \n+    }\n+\n+    @Override\n+    public void writeString(char[] text, int offset, int len) throws IOException {\n+        if (_currentState == TokenFilter.FILTER_SKIP) {\n+            return;\n+        }\n+        delegate.writeString(text, offset, len);\n+    }\n+\n+    @Override\n+    public void writeString(SerializableString text) throws IOException {\n+        if (_currentState == TokenFilter.FILTER_SKIP) {\n+            return;\n+        }\n         delegate.writeString(text);\n     }\n \n     @Override\n-    public void writeString(char[] text, int offset, int len) throws IOException {\n-        delegate.writeString(text, offset, len);\n-    }\n-\n-    @Override\n-    public void writeString(SerializableString text) throws IOException {\n-        delegate.writeString(text);\n-    }\n-\n-    @Override\n     public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException {\n+        if (_currentState == TokenFilter.FILTER_SKIP) {\n+            return;\n+        }\n         delegate.writeRawUTF8String(text, offset, length);\n     }\n \n     @Override\n     public void writeUTF8String(byte[] text, int offset, int length) throws IOException {\n+        if (_currentState == TokenFilter.FILTER_SKIP) {\n+            return;\n+        }\n         delegate.writeUTF8String(text, offset, length);\n     }\n \n \n     @Override\n     public void writeRaw(String text) throws IOException {\n+        if (_currentState == TokenFilter.FILTER_SKIP) {\n+            return;\n+        }\n         delegate.writeRaw(text);\n     }\n \n     @Override\n     public void writeRaw(String text, int offset, int len) throws IOException {\n+        if (_currentState == TokenFilter.FILTER_SKIP) {\n+            return;\n+        }\n         delegate.writeRaw(text, offset, len);\n     }\n \n     @Override\n     public void writeRaw(SerializableString raw) throws IOException {\n+        if (_currentState == TokenFilter.FILTER_SKIP) {\n+            return;\n+        }\n         delegate.writeRaw(raw);\n     }\n \n     @Override\n     public void writeRaw(char[] text, int offset, int len) throws IOException {\n+        if (_currentState == TokenFilter.FILTER_SKIP) {\n+            return;\n+        }\n         delegate.writeRaw(text, offset, len);\n     }\n \n     @Override\n     public void writeRaw(char c) throws IOException {\n+        if (_currentState == TokenFilter.FILTER_SKIP) {\n+            return;\n+        }\n         delegate.writeRaw(c);\n     }\n \n     @Override\n     public void writeRawValue(String text) throws IOException {\n+        if (_currentState == TokenFilter.FILTER_SKIP) {\n+            return;\n+        }\n         delegate.writeRawValue(text);\n     }\n \n     @Override\n     public void writeRawValue(String text, int offset, int len) throws IOException {\n+        if (_currentState == TokenFilter.FILTER_SKIP) {\n+            return;\n+        }\n         delegate.writeRawValue(text, offset, len);\n     }\n \n     @Override\n     public void writeRawValue(char[] text, int offset, int len) throws IOException {\n+        if (_currentState == TokenFilter.FILTER_SKIP) {\n+            return;\n+        }\n         delegate.writeRawValue(text, offset, len);\n     }\n \n     @Override\n     public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException {\n+        if (_currentState == TokenFilter.FILTER_SKIP) {\n+            return;\n+        }\n         delegate.writeBinary(b64variant, data, offset, len);\n     }\n \n     @Override\n     public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException {\n+        if (_currentState == TokenFilter.FILTER_SKIP) {\n+            return 0;\n+        }\n         return delegate.writeBinary(b64variant, data, dataLength);\n     }\n \n \n     @Override\n     public void writeNumber(short v) throws IOException {\n+        if (_currentState == TokenFilter.FILTER_SKIP) {\n+            return;\n+        }\n         delegate.writeNumber(v);\n     }\n \n     @Override\n     public void writeNumber(int v) throws IOException {\n+        if (_currentState == TokenFilter.FILTER_SKIP) {\n+            return;\n+        }\n         delegate.writeNumber(v);\n     }\n \n     @Override\n     public void writeNumber(long v) throws IOException {\n+        if (_currentState == TokenFilter.FILTER_SKIP) {\n+            return;\n+        }\n         delegate.writeNumber(v);\n     }\n \n     @Override\n     public void writeNumber(BigInteger v) throws IOException {\n+        if (_currentState == TokenFilter.FILTER_SKIP) {\n+            return;\n+        }\n         delegate.writeNumber(v);\n     }\n \n     @Override\n     public void writeNumber(double v) throws IOException {\n+        if (_currentState == TokenFilter.FILTER_SKIP) {\n+            return;\n+        }\n         delegate.writeNumber(v);\n     }\n \n     @Override\n     public void writeNumber(float v) throws IOException {\n+        if (_currentState == TokenFilter.FILTER_SKIP) {\n+            return;\n+        }\n         delegate.writeNumber(v);\n     }\n \n     @Override\n     public void writeNumber(BigDecimal v) throws IOException {\n+        if (_currentState == TokenFilter.FILTER_SKIP) {\n+            return;\n+        }\n         delegate.writeNumber(v);\n     }\n \n     @Override\n     public void writeNumber(String encodedValue) throws IOException, UnsupportedOperationException {\n+        if (_currentState == TokenFilter.FILTER_SKIP) {\n+            return;\n+        }\n         delegate.writeNumber(encodedValue);\n     }\n \n     @Override\n     public void writeBoolean(boolean state) throws IOException {\n+        if (_currentState == TokenFilter.FILTER_SKIP) {\n+            return;\n+        }\n         delegate.writeBoolean(state);\n     }\n \n     @Override\n     public void writeNull() throws IOException {\n+        if (_currentState == TokenFilter.FILTER_SKIP) {\n+            return;\n+        }\n         delegate.writeNull();\n     }\n \n         else super.copyCurrentStructure(jp);\n     }\n     */\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+    \n+    protected void _checkContainerParentPath(int oldState, int newState)\n+        throws IOException\n+    {\n+        if (newState == TokenFilter.FILTER_INCLUDE) {\n+            ++_fullMatchCount;\n+        } else {\n+            ++_partialMatchCount;\n+        }\n+        // only need to construct path if parent wasn't written\n+        if (oldState == TokenFilter.FILTER_CHECK) {\n+            // and even then only if parent path is actually desired...\n+            if (_includePath) {\n+                _filterContext.writePath(delegate);\n+            }\n+            // also: if no multiple matches desired, short-cut checks\n+            if (newState == TokenFilter.FILTER_INCLUDE && !_filterAll) {\n+                // Mark parents as \"skip\" so that further check calls are not made\n+                _filterContext.skipParentChecks();\n+            }\n+        }\n+    }\n+\n+    protected void _checkScalarParentPath(int oldState, int newState)\n+            throws IOException\n+    {\n+        if (newState == TokenFilter.FILTER_INCLUDE) {\n+            ++_fullMatchCount;\n+        } else {\n+            ++_partialMatchCount;\n+        }\n+        if (oldState == TokenFilter.FILTER_CHECK) {\n+            // and even then only if parent path is actually desired...\n+            if (_includePath) {\n+                _filterContext.writePath(delegate);\n+            }\n+            // also: if no multiple matches desired, short-cut checks\n+            if (newState == TokenFilter.FILTER_INCLUDE && !_filterAll) {\n+                // Mark parents as \"skip\" so that further check calls are not made\n+                _filterContext.skipParentChecks();\n+            }\n+        }\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/filter/TokenFilter.java\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/TokenFilter.java\n package com.fasterxml.jackson.core.filter;\n \n-import com.fasterxml.jackson.core.JsonToken;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n \n /**\n  * @since 2.6\n {\n     // Constants\n \n-    public final static int FILTER_SKIP_TREE = 1;\n-    public final static int FILTER_SKIP_CURRENT = 2;\n-    public final static int FILTER_INCLUDE_CURRENT = 3;\n-    public final static int FILTER_INCLUDE_TREE = 4;\n+    /**\n+     * Value that indicates that the current token (and its children, if any)\n+     * should be (or is being) skipped and NOT to be passed on delegate.\n+     */\n+    public final static int FILTER_SKIP = 1;\n \n-    // API, scalar values\n+    /**\n+     * Value that indicates that it is not yet certain whether the current token\n+     * should or should not be included. If returned for leaf node it will\n+     * usually be taken to mean same as {@link #FILTER_SKIP}; for container nodes\n+     * and property names it means that traversal needs to check contents,\n+     * and inclusion will be based on those.\n+     */\n+    public final static int FILTER_CHECK = 2;\n \n-    public int writeRootScalarValue(JsonToken type) {\n-        return FILTER_SKIP_TREE;\n+    /**\n+     * Value that indicates that the current token (and its children, if any)\n+     * should be (or is being) included and to be passed on delegate.\n+     * As state for container states this means that the start token has been\n+     * passed, and matching end token must also be passed.\n+     */\n+    public final static int FILTER_INCLUDE = 3;\n+\n+\n+    // API, container values\n+\n+    public int filterStartObject() {\n+        return FILTER_CHECK;\n     }\n \n-    public int writeScalarProperty(String name, JsonToken type) {\n-        return FILTER_SKIP_TREE;\n+    public int filterStartArray() {\n+        return FILTER_CHECK;\n+    }\n+    \n+    public void filterFinishObject() { }\n+    public void filterFinishArray() { }\n+\n+    // API, properties/elements\n+\n+    public int filterProperty(String name) {\n+        return FILTER_CHECK;\n     }\n \n-    public int writeScalarElement(int index, JsonToken type) {\n-        return FILTER_SKIP_TREE;\n+    public int filterElement(int index) {\n+        return FILTER_CHECK;\n     }\n \n-    // API, Objects\n-    \n-    public int startRootObject() {\n-        return FILTER_SKIP_TREE;\n+    // API, scalar\n+\n+    public boolean includeBoolean(boolean value) {\n+        return false;\n+    }\n+\n+    public boolean includeNull() {\n+        return false;\n+    }\n+\n+    public boolean includeString(String value) {\n+        return false;\n+    }\n+\n+    /**\n+     * NOTE: also called for `short`, `byte`\n+     */\n+    public boolean includeNumber(int i) {\n+        return false;\n+    }\n+\n+    public boolean includeNumber(long l) {\n+        return false;\n+    }\n+\n+    public boolean includeNumber(BigDecimal v) {\n+        return false;\n+    }\n+\n+    public boolean includeNumber(BigInteger v) {\n+        return false;\n+    }\n+\n+    /**\n+     * NOTE: no binary payload passed; assumption is this won't be of much\n+     * use.\n+     */\n+    public boolean includeBinary() {\n+        return false;\n+    }\n+\n+    /**\n+     * NOTE: value itself not passed since it may come on multiple forms\n+     * and is unlikely to be of much use in determining inclusion\n+     * criteria.\n+     */\n+    public boolean includeRawValue() {\n+        return false;\n     }\n     \n-    public int startObjectProperty(String name) {\n-        return FILTER_SKIP_TREE;\n+    public boolean includeEmbeddedValue(Object ob) {\n+        return false;\n     }\n-    \n-    public int startObjectElement(int index) {\n-        return FILTER_SKIP_TREE;\n-    }\n-    \n-    public void finishObject() { }\n-\n-    // API, Arrays\n-    \n-    public int startRootArray() {\n-        return FILTER_SKIP_TREE;\n-    }\n-    \n-    public int startArrayProperty(String name) {\n-        return FILTER_SKIP_TREE;\n-    }\n-    \n-    public int startArrayElement(int index) {\n-        return FILTER_SKIP_TREE;\n-    }\n-    \n-    public void finishArray() { }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/filter/TokenFilterContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/TokenFilterContext.java\n package com.fasterxml.jackson.core.filter;\n+\n+import java.io.IOException;\n \n import com.fasterxml.jackson.core.*;\n \n      */\n     protected String _currentName;\n \n+    /**\n+     * State of this context.\n+     */\n     protected int _filterState;\n+\n+    /**\n+     * Flag that indicates that start token has been written, so\n+     * that matching close token needs to be written as well,\n+     * regardless of inclusion status.\n+     */\n+    protected boolean _startWritten;\n     \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n \n-    protected TokenFilterContext(int type, TokenFilterContext parent, int fstate) {\n+    protected TokenFilterContext(int type, TokenFilterContext parent,\n+            int fstate, boolean startWritten)\n+    {\n         super();\n         _type = type;\n         _parent = parent;\n         _filterState = fstate;\n         _index = -1;\n-    }\n-\n-    protected TokenFilterContext reset(int type, int fstate) {\n+        _startWritten = false;\n+    }\n+\n+    protected TokenFilterContext reset(int type,\n+            int fstate, boolean startWritten)\n+    {\n         _type = type;\n         _filterState = fstate;\n         _index = -1;\n         _currentName = null;\n+        _startWritten = startWritten;\n         return this;\n     }\n \n+    /*\n+    /**********************************************************\n+    /* Factory methods\n+    /**********************************************************\n+     */\n+\n+    public static TokenFilterContext createRootContext(int fstate) {\n+        return new TokenFilterContext(TYPE_ROOT, null, fstate, false);\n+    }\n+\n+    public TokenFilterContext createChildArrayContext(int fstate, boolean writeStart) {\n+        TokenFilterContext ctxt = _child;\n+        if (ctxt == null) {\n+            _child = ctxt = new TokenFilterContext(TYPE_ARRAY, this, fstate, writeStart);\n+            return ctxt;\n+        }\n+        return ctxt.reset(TYPE_ARRAY, fstate, writeStart);\n+    }\n+\n+    public TokenFilterContext createChildObjectContext(int fstate, boolean writeStart) {\n+        TokenFilterContext ctxt = _child;\n+        if (ctxt == null) {\n+            _child = ctxt = new TokenFilterContext(TYPE_OBJECT, this, fstate, writeStart);\n+            return ctxt;\n+        }\n+        return ctxt.reset(TYPE_OBJECT, fstate, writeStart);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* State changes\n+    /**********************************************************\n+     */\n+    \n+    public void writeFieldName(String name) throws JsonProcessingException {\n+        _currentName = name;\n+    }\n+    public int writeValue() {\n+        return ++_index;\n+    }\n+    /**\n+     * Method called to ensure that parent path from root is written up to\n+     * and including this node.\n+     */\n+    public void writePath(JsonGenerator gen) throws IOException\n+    {\n+        if (_filterState == TokenFilter.FILTER_CHECK) {\n+            if (_parent != null) {\n+                _parent.writePath(gen);\n+            }\n+            if (!_startWritten) {\n+                _startWritten = true;\n+                if (_type == TYPE_OBJECT) {\n+                    gen.writeStartObject();\n+                    gen.writeFieldName(_currentName);\n+                } else if (_type == TYPE_ARRAY) {\n+                    gen.writeStartArray();\n+                }\n+            }\n+        }\n+    }\n+\n+    public void skipParentChecks() {\n+        _filterState = TokenFilter.FILTER_SKIP;\n+        for (TokenFilterContext ctxt = _parent; ctxt != null; ctxt = ctxt._parent) {\n+            _parent._filterState = TokenFilter.FILTER_SKIP;\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Accessors, mutators\n+    /**********************************************************\n+     */\n+\n     @Override\n-    public Object getCurrentValue() {\n-        return null;\n-    }\n+    public Object getCurrentValue() { return null; }\n \n     @Override\n     public void setCurrentValue(Object v) { }\n-    \n-    /*\n-    /**********************************************************\n-    /* Factory methods\n-    /**********************************************************\n-     */\n-\n-    public static TokenFilterContext createRootContext(int fstate) {\n-        return new TokenFilterContext(TYPE_ROOT, null, fstate);\n-    }\n-\n-    public TokenFilterContext createChildArrayContext(int fstate) {\n-        TokenFilterContext ctxt = _child;\n-        if (ctxt == null) {\n-            _child = ctxt = new TokenFilterContext(TYPE_ARRAY, this, fstate);\n-            return ctxt;\n-        }\n-        return ctxt.reset(TYPE_ARRAY, fstate);\n-    }\n-\n-    public TokenFilterContext createChildObjectContext(int fstate) {\n-        TokenFilterContext ctxt = _child;\n-        if (ctxt == null) {\n-            _child = ctxt = new TokenFilterContext(TYPE_OBJECT, this, fstate);\n-            return ctxt;\n-        }\n-        return ctxt.reset(TYPE_OBJECT, fstate);\n-    }\n \n     @Override public final TokenFilterContext getParent() { return _parent; }\n     @Override public final String getCurrentName() { return _currentName; }\n \n     public int getFilterState() { return _filterState; }\n-\n-    public void writeFieldName(String name) throws JsonProcessingException {\n-        _currentName = name;\n-    }\n-\n-    public void writeValue() {\n-        ++_index;\n-    }\n-\n+    public boolean needsCloseToken() { return _startWritten; }\n+\n+    public void markStartToken() { _startWritten = true; }\n+    \n     // // // Internally used abstract methods\n \n     protected void appendDesc(StringBuilder sb) {", "timestamp": 1428107691, "metainfo": ""}