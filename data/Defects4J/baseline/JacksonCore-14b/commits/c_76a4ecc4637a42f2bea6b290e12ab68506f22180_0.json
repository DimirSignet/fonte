{"sha": "76a4ecc4637a42f2bea6b290e12ab68506f22180", "log": "git branch Merge branch 'master' of github.com:FasterXML/jackson-core", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n     public int getValueAsInt() throws IOException\n     {\n         JsonToken t = _currToken;\n-        if (t == JsonToken.VALUE_NUMBER_INT) {\n+        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n             return getIntValue();\n         }\n-        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n-            return getIntValue();\n-        }\n         return getValueAsInt(0);\n     }\n \n     public int getValueAsInt(int defaultValue) throws IOException\n     {\n         JsonToken t = _currToken;\n-        if (t == JsonToken.VALUE_NUMBER_INT) {\n-            return getIntValue();\n-        }\n-        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n+        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n             return getIntValue();\n         }\n         if (t != null) {\n     public long getValueAsLong() throws IOException\n     {\n         JsonToken t = _currToken;\n-        if (t == JsonToken.VALUE_NUMBER_INT) {\n+        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n             return getLongValue();\n         }\n-        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n-            return getLongValue();\n-        }\n         return getValueAsLong(0L);\n     }\n     \n     public long getValueAsLong(long defaultValue) throws IOException\n     {\n         JsonToken t = _currToken;\n-        if (t == JsonToken.VALUE_NUMBER_INT) {\n-            return getLongValue();\n-        }\n-        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n+        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n             return getLongValue();\n         }\n         if (t != null) {\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n             return _nextTokenNotInObject(i);\n         }\n         // So first parse the field name itself:\n-        String n = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-\n+        String n = _parseName(i);\n         _parsingContext.setCurrentName(n);\n         _currToken = JsonToken.FIELD_NAME;\n \n                 }\n             }\n         }\n-        return _isNextTokenNameMaybe(i, str.getValue());\n+        return _isNextTokenNameMaybe(i, str);\n     }\n \n     @Override\n             return null;\n         }\n \n-        final String nameStr = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        final String nameStr = _parseName(i);\n         _parsingContext.setCurrentName(nameStr);\n         _currToken = JsonToken.FIELD_NAME;\n \n         _inputPtr = ptr-1;\n         return _skipColon2(false);\n     }\n-\n+    \n     private final void _isNextTokenNameYes(int i) throws IOException\n     {\n         _currToken = JsonToken.FIELD_NAME;\n         }\n         _nextToken = _handleUnexpectedValue(i);\n     }\n-\n-    private final boolean _isNextTokenNameMaybe(int i, String str) throws IOException\n+    \n+    \n+    private final boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException\n     {\n         // // // and this is back to standard nextToken()\n \n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n+        String n = _parseName(i);\n+        _parsingContext.setCurrentName(n);\n+        final boolean match = n.equals(str.getValue());\n         _currToken = JsonToken.FIELD_NAME;\n         i = _skipColon();\n \n         if (i == INT_QUOTE) {\n             _tokenIncomplete = true;\n             _nextToken = JsonToken.VALUE_STRING;\n-            return name.equals(str);\n+            return match;\n         }\n         JsonToken t;\n \n             t = _handleUnexpectedValue(i);\n         }\n         _nextToken = t;\n-        return name.equals(str);\n+        return match;\n     }\n \n     @Override\n     /**********************************************************\n      */\n     \n-    protected final String _parseName() throws IOException\n-    {\n+    protected final String _parseName(int i) throws IOException\n+    {\n+        if (i != INT_QUOTE) {\n+            return _handleOddName(i);\n+        }\n         // First: can we optimize out bounds checks?\n         if ((_inputPtr + 13) > _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\n             return slowParseName();\n         int q = input[_inputPtr++] & 0xFF;\n \n         if (codes[q] == 0) {\n-            int i = input[_inputPtr++] & 0xFF;\n+            i = input[_inputPtr++] & 0xFF;\n             if (codes[i] == 0) {\n                 q = (q << 8) | i;\n                 i = input[_inputPtr++] & 0xFF;\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n     @Override\n     public final JsonToken nextToken() throws IOException\n     {\n-        _numTypesValid = NR_UNKNOWN;\n-\n         /* First: field names are special -- we will always tokenize\n          * (part of) value along with field name to simplify\n          * state handling. If so, can and need to use secondary token:\n         if (_currToken == JsonToken.FIELD_NAME) {\n             return _nextAfterName();\n         }\n+        // But if we didn't already have a name, and (partially?) decode number,\n+        // need to ensure no numeric information is leaked\n+        _numTypesValid = NR_UNKNOWN;\n         if (_tokenIncomplete) {\n             _skipString(); // only strings can be partial\n         }\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n     @Override\n     public JsonToken nextToken() throws IOException\n     {\n-        _numTypesValid = NR_UNKNOWN;\n         /* First: field names are special -- we will always tokenize\n          * (part of) value along with field name to simplify\n          * state handling. If so, can and need to use secondary token:\n         if (_currToken == JsonToken.FIELD_NAME) {\n             return _nextAfterName();\n         }\n+        // But if we didn't already have a name, and (partially?) decode number,\n+        // need to ensure no numeric information is leaked\n+        _numTypesValid = NR_UNKNOWN;\n         if (_tokenIncomplete) {\n             _skipString(); // only strings can be partial\n         }\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestNextXxx.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestNextXxx.java\n \n     private final JsonFactory JSON_F = new JsonFactory();\n \n-    // [JACKSON-653]\n     public void testIsNextTokenName() throws Exception\n     {\n         _testIsNextTokenName1(false);\n         _testIsNextTokenName1(true);\n+    }\n+\n+    public void testIsNextTokenName2() throws Exception {\n         _testIsNextTokenName2(false);\n         _testIsNextTokenName2(true);\n+    }        \n+    \n+    public void testIsNextTokenName3() throws Exception {\n         _testIsNextTokenName3(false);\n         _testIsNextTokenName3(true);\n     }\n-\n+    \n+    public void testIsNextTokenName4() throws Exception {\n+        _testIsNextTokenName4(false);\n+        _testIsNextTokenName4(true);\n+    }\n+    \n     // [Issue#34]\n     public void testIssue34() throws Exception\n     {\n         assertToken(JsonToken.FIELD_NAME, jp.getCurrentToken());\n         assertEquals(\"name2\", jp.getCurrentName());\n         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        // do NOT check number value, to enforce skipping\n \n         assertFalse(jp.nextFieldName(NAME));\n         assertToken(JsonToken.FIELD_NAME, jp.getCurrentToken());\n \n         assertNull(jp.nextFieldName());\n         assertNull(jp.getCurrentToken());\n+\n+        jp.close();\n+    }\n+\n+    private void _testIsNextTokenName4(boolean useStream) throws Exception\n+    {\n+        final String DOC = \"{\\\"name\\\":-123,\\\"name2\\\":99}\";\n+        JsonParser jp = useStream ?\n+                JSON_F.createParser(new ByteArrayInputStream(DOC.getBytes(\"UTF-8\")))\n+            : JSON_F.createParser(new StringReader(DOC));\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+\n+        assertTrue(jp.nextFieldName(new SerializedString(\"name\")));\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(-123, jp.getIntValue());\n+\n+        assertTrue(jp.nextFieldName(new SerializedString(\"name2\")));\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(99, jp.getIntValue());\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+        assertNull(jp.nextToken());\n \n         jp.close();\n     }", "timestamp": 1439587204, "metainfo": ""}