{"sha": "d0b4bfe4d0f96912573d4aa0e2e7bd09d50013d5", "log": "Start building filtering to support exposing subsets of content read/written", "commit": "\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/util/FilteringGeneratorDelegate.java\n+package com.fasterxml.jackson.core.util;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+/**\n+ * @since 2.6.0\n+ */\n+public class FilteringGeneratorDelegate extends JsonGeneratorDelegate\n+{\n+    protected TokenFilter filter;\n+\n+    /*\n+    /**********************************************************\n+    /* Construction, initialization\n+    /**********************************************************\n+     */\n+\n+    public FilteringGeneratorDelegate(JsonGenerator d, TokenFilter f) {\n+        // By default, do NOT delegate copy methods\n+        super(d, false);\n+        filter = f;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, structural\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeStartArray() throws IOException {\n+        delegate.writeStartArray();\n+    }\n+\n+    @Override\n+    public void writeStartArray(int size) throws IOException {\n+        delegate.writeStartArray(size);\n+    }\n+    \n+    @Override\n+    public void writeEndArray() throws IOException {\n+        delegate.writeEndArray();\n+    }\n+\n+    @Override\n+    public void writeStartObject() throws IOException {\n+        delegate.writeStartObject();\n+    }\n+    \n+    @Override\n+    public void writeEndObject() throws IOException {\n+        delegate.writeEndObject();\n+    }\n+\n+    @Override\n+    public void writeFieldName(String name) throws IOException {\n+        delegate.writeFieldName(name);\n+    }\n+\n+    @Override\n+    public void writeFieldName(SerializableString name) throws IOException {\n+        delegate.writeFieldName(name);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, text/String values\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeString(String text) throws IOException {\n+        delegate.writeString(text);\n+    }\n+\n+    @Override\n+    public void writeString(char[] text, int offset, int len) throws IOException {\n+        delegate.writeString(text, offset, len);\n+    }\n+\n+    @Override\n+    public void writeString(SerializableString text) throws IOException {\n+        delegate.writeString(text);\n+    }\n+\n+    @Override\n+    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException {\n+        delegate.writeRawUTF8String(text, offset, length);\n+    }\n+\n+    @Override\n+    public void writeUTF8String(byte[] text, int offset, int length) throws IOException {\n+        delegate.writeUTF8String(text, offset, length);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, binary/raw content\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeRaw(String text) throws IOException {\n+        delegate.writeRaw(text);\n+    }\n+\n+    @Override\n+    public void writeRaw(String text, int offset, int len) throws IOException {\n+        delegate.writeRaw(text, offset, len);\n+    }\n+\n+    @Override\n+    public void writeRaw(SerializableString raw) throws IOException {\n+        delegate.writeRaw(raw);\n+    }\n+\n+    @Override\n+    public void writeRaw(char[] text, int offset, int len) throws IOException {\n+        delegate.writeRaw(text, offset, len);\n+    }\n+\n+    @Override\n+    public void writeRaw(char c) throws IOException {\n+        delegate.writeRaw(c);\n+    }\n+\n+    @Override\n+    public void writeRawValue(String text) throws IOException {\n+        delegate.writeRawValue(text);\n+    }\n+\n+    @Override\n+    public void writeRawValue(String text, int offset, int len) throws IOException {\n+        delegate.writeRawValue(text, offset, len);\n+    }\n+\n+    @Override\n+    public void writeRawValue(char[] text, int offset, int len) throws IOException {\n+        delegate.writeRawValue(text, offset, len);\n+    }\n+\n+    @Override\n+    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException {\n+        delegate.writeBinary(b64variant, data, offset, len);\n+    }\n+\n+    @Override\n+    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException {\n+        return delegate.writeBinary(b64variant, data, dataLength);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, other value types\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeNumber(short v) throws IOException {\n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(int v) throws IOException {\n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(long v) throws IOException {\n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(BigInteger v) throws IOException {\n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(double v) throws IOException {\n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(float v) throws IOException {\n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(BigDecimal v) throws IOException {\n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(String encodedValue) throws IOException, UnsupportedOperationException {\n+        delegate.writeNumber(encodedValue);\n+    }\n+\n+    @Override\n+    public void writeBoolean(boolean state) throws IOException {\n+        delegate.writeBoolean(state);\n+    }\n+\n+    @Override\n+    public void writeNull() throws IOException {\n+        delegate.writeNull();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridden field methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeOmittedField(String fieldName) throws IOException {\n+        delegate.writeOmittedField(fieldName);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, Native Ids\n+    /**********************************************************\n+     */\n+\n+    // 25-Mar-2015, tatu: These are tricky as they sort of predate actual filtering calls.\n+    //   Let's try to use current state as a clue at least...\n+    \n+    @Override\n+    public void writeObjectId(Object id) throws IOException {\n+        delegate.writeObjectId(id);\n+    }\n+\n+    @Override\n+    public void writeObjectRef(Object id) throws IOException {\n+        delegate.writeObjectRef(id);\n+    }\n+    \n+    @Override\n+    public void writeTypeId(Object id) throws IOException {\n+        delegate.writeTypeId(id);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, serializing Java objects\n+    /**********************************************************\n+     */\n+\n+    // Base class definitions for these seems correct to me, iff not directly delegating:\n+\n+    /*\n+    @Override\n+    public void writeObject(Object pojo) throws IOException,JsonProcessingException {\n+        if (delegateCopyMethods) {\n+            delegate.writeObject(pojo);\n+            return;\n+        }\n+        // NOTE: copied from \n+        if (pojo == null) {\n+            writeNull();\n+        } else {\n+            if (getCodec() != null) {\n+                getCodec().writeValue(this, pojo);\n+                return;\n+            }\n+            _writeSimpleObject(pojo);\n+        }\n+    }\n+    \n+    @Override\n+    public void writeTree(TreeNode rootNode) throws IOException {\n+        if (delegateCopyMethods) {\n+            delegate.writeTree(rootNode);\n+            return;\n+        }\n+        // As with 'writeObject()', we are not check if write would work\n+        if (rootNode == null) {\n+            writeNull();\n+        } else {\n+            if (getCodec() == null) {\n+                throw new IllegalStateException(\"No ObjectCodec defined\");\n+            }\n+            getCodec().writeValue(this, rootNode);\n+        }\n+    }\n+    */\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, copy-through methods\n+    /**********************************************************\n+     */\n+\n+    // Base class definitions for these seems correct to me, iff not directly delegating:\n+\n+    /*\n+    @Override\n+    public void copyCurrentEvent(JsonParser jp) throws IOException {\n+        if (delegateCopyMethods) delegate.copyCurrentEvent(jp);\n+        else super.copyCurrentEvent(jp);\n+    }\n+\n+    @Override\n+    public void copyCurrentStructure(JsonParser jp) throws IOException {\n+        if (delegateCopyMethods) delegate.copyCurrentStructure(jp);\n+        else super.copyCurrentStructure(jp);\n+    }\n+    */\n+}\n--- a/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n     /* Construction, initialization\n     /**********************************************************\n      */\n-    \n+\n     public JsonGeneratorDelegate(JsonGenerator d) {\n         this(d, true);\n     }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/util/TokenFilter.java\n+package com.fasterxml.jackson.core.util;\n+\n+import com.fasterxml.jackson.core.JsonToken;\n+\n+/**\n+ * @since 2.6\n+ */\n+public abstract class TokenFilter\n+{\n+    // Constants\n+    \n+    public int FILTER_SKIP_TREE = 1;\n+    public int FILTER_SKIP_CURRENT = 2;\n+    public int FILTER_INCLUDE_TREE = 3;\n+    public int FILTER_INCLUDE_CURRENT = 4;\n+\n+    // API\n+\n+    public int writeScalar(JsonToken type) {\n+        return FILTER_SKIP_TREE;\n+    }\n+\n+    public int startObject() {\n+        return FILTER_SKIP_TREE;\n+    }\n+\n+    public void finishObject() { }\n+\n+    public int startArray() {\n+        return FILTER_SKIP_TREE;\n+    }\n+\n+    public void finishArray() { }\n+\n+    public int startObjectProperty(String name) {\n+        return FILTER_SKIP_TREE;\n+    }\n+\n+    public void finishObjectProperty() { }\n+\n+    public int startArrayElement(int index) {\n+        return FILTER_SKIP_TREE;\n+    }\n+\n+    public void finishArrayElement() { }\n+}", "timestamp": 1427324801, "metainfo": ""}