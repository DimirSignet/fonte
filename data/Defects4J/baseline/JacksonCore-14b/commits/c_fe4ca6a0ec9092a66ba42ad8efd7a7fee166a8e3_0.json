{"sha": "fe4ca6a0ec9092a66ba42ad8efd7a7fee166a8e3", "log": "Further improvements to reduce hash collisions, now for 1-4 byte ids", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java\n     public int calcHash(int q1)\n     {\n         int hash = q1 ^ _seed;\n-        hash += (hash >>> 15); // to xor hi- and low- 16-bits\n-        hash ^= (hash >>> 9); // as well as lowest 2 bytes\n+        /* 29-Mar-2015, tatu: Earlier used 15 + 9 right shifts, which worked ok\n+         *    except for one specific problem case: numbers. So needed to make sure\n+         *    that all 4 least-significant bits participate in hash. Couple of ways\n+         *    to work it out, but this is the simplest, fast and seems to do ok.\n+         */\n+        hash += (hash >>> 16); // to xor hi- and low- 16-bits\n+        hash ^= (hash >>> 12); // as well as lowest 2 bytes\n         return hash;\n     }\n \n         hash ^= (hash >>> 9); // as well as lowest 2 bytes\n         hash += (q2 * MULT); // then add second quad\n         hash ^= _seed;\n-        hash += (hash >>> 7); // and shuffle some more\n+        hash += (hash >>> 16); // and shuffle some more\n         hash ^= (hash >>> 4);\n         \n         return hash;\n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n \n         // fragile, but essential to verify low collision counts;\n         // anywhere between 70-80% primary matches\n-        assertEquals(8566, symbols.primaryCount());\n+        assertEquals(8533, symbols.primaryCount());\n         // secondary between 10-20%\n-        assertEquals(2440, symbols.secondaryCount());\n+        assertEquals(2468, symbols.secondaryCount());\n         // and most of remaining in tertiary\n-        assertEquals(994, symbols.tertiaryCount());\n+        assertEquals(999, symbols.tertiaryCount());\n         // so that spill-over is empty or close to\n         assertEquals(0, symbols.spilloverCount());\n     }\n                 String n = symbolsB.findName(quads, quads.length);\n                 assertEquals(name, n);\n             }\n-//System.out.println(\"New symbols: \"+symbolsB);\n             symbolsB.release();\n             \n             exp += 250;\n             }\n             assertEquals(exp, symbolsBRoot.size());\n         }\n-\n         /* 05-Feb-2015, tatu: Fragile, but it is important to ensure that collision\n          *   rates are not accidentally increased...\n          */\n         assertEquals(6250, symbolsB.size());\n-        assertEquals(4992, symbolsB.primaryCount()); // 80% primary hit rate\n-        assertEquals(803, symbolsB.secondaryCount()); // 13% secondary\n-        assertEquals(445, symbolsB.tertiaryCount()); // 7% tertiary\n-        assertEquals(10, symbolsB.spilloverCount()); // and couple of leftovers\n+        assertEquals(4761, symbolsB.primaryCount()); // 80% primary hit rate\n+        assertEquals(1019, symbolsB.secondaryCount()); // 13% secondary\n+        assertEquals(456, symbolsB.tertiaryCount()); // 7% tertiary\n+        assertEquals(14, symbolsB.spilloverCount()); // and couple of leftovers\n     }\n     \n     // And then one more test just for Bytes-based symbol table\n     }\n \n     // [core#187]: unexpectedly high number of collisions for straight numbers\n-    public void testCollisionsWithBytesNew187() throws IOException\n+    public void testCollisionsWithBytesNew187a() throws IOException\n     {\n         ByteQuadsCanonicalizer symbols =\n                 ByteQuadsCanonicalizer.createRoot(1).makeChild(JsonFactory.Feature.collectDefaults());\n             int[] quads = calcQuads(id.getBytes(\"UTF-8\"));\n             symbols.addName(id, quads, quads.length);\n         }\n+\n         assertEquals(COUNT, symbols.size());\n         assertEquals(65536, symbols.bucketCount());\n \n         // fragile, but essential to verify low collision counts;\n         // anywhere between 70-80% primary matches\n-        assertEquals(32446, symbols.primaryCount());\n+        assertEquals(32342, symbols.primaryCount());\n         // secondary between 10-20%\n-        assertEquals(6472, symbols.secondaryCount());\n+        assertEquals(6759, symbols.secondaryCount());\n         // and most of remaining in tertiary\n-        assertEquals(3773, symbols.tertiaryCount());\n+        assertEquals(3715, symbols.tertiaryCount());\n         // but number of spill-overs starts to grow beyond 30k quite a lot:\n-        assertEquals(309, symbols.spilloverCount());\n+        assertEquals(184, symbols.spilloverCount());\n+    }\n+\n+    // Another variant, but with 1-quad names\n+    public void testCollisionsWithBytesNew187b() throws IOException\n+    {\n+        ByteQuadsCanonicalizer symbols =\n+                ByteQuadsCanonicalizer.createRoot(1).makeChild(JsonFactory.Feature.collectDefaults());\n+\n+        final int COUNT = 10000;\n+        for (int i = 0; i < COUNT; ++i) {\n+            String id = String.valueOf(i);\n+            int[] quads = calcQuads(id.getBytes(\"UTF-8\"));\n+            symbols.addName(id, quads, quads.length);\n+        }\n+        assertEquals(COUNT, symbols.size());\n+        \n+        assertEquals(32768, symbols.bucketCount());\n+\n+        // fragile, but essential to verify low collision counts;\n+        // anywhere between 70-80% primary matches\n+        assertEquals(9386, symbols.primaryCount());\n+        // secondary between 10-20%\n+        assertEquals(345, symbols.secondaryCount());\n+        // and most of remaining in tertiary\n+        assertEquals(257, symbols.tertiaryCount());\n+        // but number of spill-overs starts to grow beyond 30k quite a lot:\n+        assertEquals(12, symbols.spilloverCount());\n     }\n }", "timestamp": 1427695862, "metainfo": ""}