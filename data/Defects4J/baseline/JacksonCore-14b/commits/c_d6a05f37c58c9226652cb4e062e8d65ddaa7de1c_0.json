{"sha": "d6a05f37c58c9226652cb4e062e8d65ddaa7de1c", "log": "Merge pull request #166 from digulla/master  Allow to configure line endings and indentation", "commit": "\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/util/DefaultIndenter.java\n+package com.fasterxml.jackson.core.util;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+\n+/**\n+ * Default linefeed-based indenter uses system-specific linefeeds and\n+ * 2 spaces for indentation per level.\n+ */\n+public class DefaultIndenter\n+    extends DefaultPrettyPrinter.NopIndenter\n+{\n+    public final static String SYS_LF;\n+    static {\n+        String lf;\n+        try {\n+            lf = System.getProperty(\"line.separator\");\n+        } catch (Throwable t) {\n+            lf = \"\\n\"; // fallback when security manager denies access\n+        }\n+        SYS_LF = lf;\n+    }\n+\n+    public static final DefaultIndenter SYSTEM_LINEFEED_INSTANCE = new DefaultIndenter(\"  \", SYS_LF);\n+\n+    private final static int INDENT_LEVELS = 64;\n+    private final char[] indents;\n+    private final int charsPerLevel;\n+    private final String eol;\n+\n+    /** Indent with two spaces and the system's default line feed */\n+    public DefaultIndenter() {\n+        this(\"  \", SYS_LF);\n+    }\n+    \n+    /** Create an indenter which uses the <code>indent</code> string to indent one level\n+     *  and the <code>eol</code> string to separate lines. */\n+    public DefaultIndenter(String indent, String eol)\n+    {\n+        charsPerLevel = indent.length();\n+\n+        this.indents = new char[indent.length() * INDENT_LEVELS];\n+        int offset = 0;\n+        for (int i=0; i<INDENT_LEVELS; i++) {\n+            indent.getChars(0, indent.length(), this.indents, offset);\n+            offset += indent.length();\n+        }\n+\n+        this.eol = eol;\n+    }\n+    \n+    public DefaultIndenter withLinefeed(String lf)\n+    {\n+        if (lf.equals(eol)) {\n+            return this;\n+        }\n+        return new DefaultIndenter(getIndent(), lf);\n+    }\n+    \n+    public DefaultIndenter withIndent(String indent)\n+    {\n+        if (indent.equals(getIndent())) {\n+            return this;\n+        }\n+        return new DefaultIndenter(indent, eol);\n+    }\n+\n+    @Override\n+    public boolean isInline() { return false; }\n+\n+    @Override\n+    public void writeIndentation(JsonGenerator jg, int level)\n+        throws IOException, JsonGenerationException\n+    {\n+        jg.writeRaw(eol);\n+        if (level > 0) { // should we err on negative values (as there's some flaw?)\n+            level *= charsPerLevel;\n+            while (level > indents.length) { // should never happen but...\n+                jg.writeRaw(indents, 0, indents.length); \n+                level -= indents.length;\n+            }\n+            jg.writeRaw(indents, 0, level);\n+        }\n+    }\n+    \n+    public String getEol()\n+    {\n+        return eol;\n+    }\n+    \n+    public String getIndent()\n+    {\n+        return new String(indents, 0, charsPerLevel);\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java\n      * system-specific linefeeds, and 2 spaces per level (as opposed to,\n      * say, single tabs)\n      */\n-    protected Indenter _objectIndenter = Lf2SpacesIndenter.instance;\n+    protected Indenter _objectIndenter = DefaultIndenter.SYSTEM_LINEFEED_INSTANCE;\n \n     /**\n      * String printed between root-level values, if any.\n         @Override\n         public boolean isInline() { return true; }\n     }\n-\n-    /**\n-     * Default linefeed-based indenter uses system-specific linefeeds and\n-     * 2 spaces for indentation per level.\n-     */\n-    public static class Lf2SpacesIndenter extends NopIndenter\n-    {\n-        private final static String SYS_LF;\n-        static {\n-            String lf = null;\n-            try {\n-                lf = System.getProperty(\"line.separator\");\n-            } catch (Throwable t) { } // access exception?\n-            SYS_LF = (lf == null) ? \"\\n\" : lf;\n-        }\n-\n-        final static int SPACE_COUNT = 64;\n-        final static char[] SPACES = new char[SPACE_COUNT];\n-        static {\n-            Arrays.fill(SPACES, ' ');\n-        }\n-\n-        @SuppressWarnings(\"hiding\")\n+    \n+    /** @deprecated Use {@link DefaultIndenter} instead */\n+    @Deprecated\n+    public static class Lf2SpacesIndenter extends DefaultIndenter\n+    {\n+        /** @deprecated Use {@link DefaultIndenter.SYSTEM_LINEFEED_INSTANCE} instead */\n         public static final Lf2SpacesIndenter instance = new Lf2SpacesIndenter();\n \n-        /**\n-         * Linefeed used; default value is the platform-specific linefeed.\n-         */\n-        protected final String _lf;\n-\n-        public Lf2SpacesIndenter() { this(SYS_LF); }\n+        /** @deprecated Use {@code new DefaultIndenter(\"  \", DefaultIndenter.SYS_LF)} instead */\n+        public Lf2SpacesIndenter()\n+        {\n+            super(\"  \", DefaultIndenter.SYS_LF);\n+        }\n         \n-        /**\n-         * @since 2.3\n-         */\n+        /** @deprecated Use {@code new DefaultIndenter(\"  \", lf)} instead */\n         public Lf2SpacesIndenter(String lf) {\n-            _lf = lf;\n-        }\n-\n-        /**\n-         * \"Mutant factory\" method that will return an instance that uses\n-         * specified String as linefeed.\n-         * \n-         * @since 2.3\n-         */\n-        public Lf2SpacesIndenter withLinefeed(String lf)\n-        {\n-            if (lf.equals(_lf)) {\n-                return this;\n-            }\n-            return new Lf2SpacesIndenter(lf);\n-        }\n-        \n-        @Override\n-        public boolean isInline() { return false; }\n-\n-        @Override\n-        public void writeIndentation(JsonGenerator jg, int level)\n-            throws IOException, JsonGenerationException\n-        {\n-            jg.writeRaw(_lf);\n-            if (level > 0) { // should we err on negative values (as there's some flaw?)\n-                level += level; // 2 spaces per level\n-                while (level > SPACE_COUNT) { // should never happen but...\n-                    jg.writeRaw(SPACES, 0, SPACE_COUNT); \n-                    level -= SPACES.length;\n-                }\n-                jg.writeRaw(SPACES, 0, level);\n-            }\n+            super(\"  \", lf);\n         }\n     }\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/util/TestDefaultPrettyPrinter.java\n+package com.fasterxml.jackson.core.util;\n+\n+import static org.junit.Assert.*;\n+\n+import java.io.IOException;\n+import java.io.StringWriter;\n+\n+import org.junit.Test;\n+\n+import com.fasterxml.jackson.core.JsonFactory;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.PrettyPrinter;\n+\n+public class TestDefaultPrettyPrinter\n+{\n+    @Test\n+    public void testSystemLinefeed() throws IOException\n+    {\n+        PrettyPrinter pp = new DefaultPrettyPrinter();\n+        String LF = System.getProperty(\"line.separator\");\n+        assertEquals(\n+            \"{\" + LF +\n+            \"  \\\"name\\\" : \\\"John Doe\\\",\" + LF +\n+            \"  \\\"age\\\" : 3.14\" + LF +\n+            \"}\", _printTestData(pp));\n+    }\n+\n+    @Test\n+    public void testWithLineFeed() throws IOException\n+    {\n+        PrettyPrinter pp = new DefaultPrettyPrinter()\n+        .withObjectIndenter(new DefaultIndenter().withLinefeed(\"\\n\"));\n+        assertEquals(\n+            \"{\\n\" +\n+            \"  \\\"name\\\" : \\\"John Doe\\\",\\n\" +\n+            \"  \\\"age\\\" : 3.14\\n\" +\n+            \"}\", _printTestData(pp));\n+    }\n+    \n+    @Test\n+    public void testWithIndent() throws IOException\n+    {\n+        PrettyPrinter pp = new DefaultPrettyPrinter()\n+        .withObjectIndenter(new DefaultIndenter().withIndent(\" \"));\n+        assertEquals(\n+            \"{\\n\" +\n+            \" \\\"name\\\" : \\\"John Doe\\\",\\n\" +\n+            \" \\\"age\\\" : 3.14\\n\" +\n+            \"}\", _printTestData(pp));\n+    }\n+    \n+    @Test\n+    public void testUnixLinefeed() throws IOException\n+    {\n+        PrettyPrinter pp = new DefaultPrettyPrinter()\n+                .withObjectIndenter(new DefaultIndenter(\"  \", \"\\n\"));\n+        assertEquals(\n+            \"{\\n\" +\n+            \"  \\\"name\\\" : \\\"John Doe\\\",\\n\" +\n+            \"  \\\"age\\\" : 3.14\\n\" +\n+            \"}\", _printTestData(pp));\n+    }\n+    \n+    @Test\n+    public void testWindowsLinefeed() throws IOException\n+    {\n+        PrettyPrinter pp = new DefaultPrettyPrinter()\n+        .withObjectIndenter(new DefaultIndenter(\"  \", \"\\r\\n\"));\n+        assertEquals(\n+            \"{\\r\\n\" +\n+            \"  \\\"name\\\" : \\\"John Doe\\\",\\r\\n\" +\n+            \"  \\\"age\\\" : 3.14\\r\\n\" +\n+            \"}\", _printTestData(pp));\n+    }\n+    \n+    @Test\n+    public void testTabIndent() throws IOException\n+    {\n+        PrettyPrinter pp = new DefaultPrettyPrinter()\n+        .withObjectIndenter(new DefaultIndenter(\"\\t\", \"\\n\"));\n+        assertEquals(\n+            \"{\\n\" +\n+            \"\\t\\\"name\\\" : \\\"John Doe\\\",\\n\" +\n+            \"\\t\\\"age\\\" : 3.14\\n\" +\n+            \"}\", _printTestData(pp));\n+    }\n+\n+    private String _printTestData(PrettyPrinter pp) throws IOException\n+    {\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator gen = new JsonFactory().createGenerator(sw);\n+        gen.setPrettyPrinter(pp);\n+        gen.writeStartObject();\n+        gen.writeFieldName(\"name\");\n+        gen.writeString(\"John Doe\");\n+        gen.writeFieldName(\"age\");\n+        gen.writeNumber(3.14);\n+        gen.writeEndObject();\n+        gen.close();\n+        return sw.toString();\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n      */\n     public Object getOutputTarget() {\n         return null;\n+    }\n+\n+    /**\n+     * Helper method, usually equivalent to:\n+     *<code>\n+     *   getOutputContext().getCurrentValue();\n+     *<code>\n+     * \n+     * @since 2.5\n+     */\n+    public Object getCurrentValue() {\n+        JsonStreamContext ctxt = getOutputContext();\n+        return (ctxt == null) ? null : ctxt.getCurrentValue();\n+    }\n+\n+    /**\n+     * Helper method, usually equivalent to:\n+     *<code>\n+     *   getOutputContext().setCurrentValue(v);\n+     *<code>\n+     * \n+     * @since 2.5\n+     */\n+    public void setCurrentValue(Object v) {\n+        JsonStreamContext ctxt = getOutputContext();\n+        if (ctxt != null) {\n+            ctxt.setCurrentValue(v);\n+        }\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n      */\n     public Object getInputSource() { return null; }\n \n+    /**\n+     * Helper method, usually equivalent to:\n+     *<code>\n+     *   getParsingContext().getCurrentValue();\n+     *<code>\n+     * \n+     * @since 2.5\n+     */\n+    public Object getCurrentValue() {\n+        JsonStreamContext ctxt = getParsingContext();\n+        return (ctxt == null) ? null : ctxt.getCurrentValue();\n+    }\n+\n+    /**\n+     * Helper method, usually equivalent to:\n+     *<code>\n+     *   getParsingContext().setCurrentValue(v);\n+     *<code>\n+     * \n+     * @since 2.5\n+     */\n+    public void setCurrentValue(Object v) {\n+        JsonStreamContext ctxt = getParsingContext();\n+        if (ctxt != null) {\n+            ctxt.setCurrentValue(v);\n+        }\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Format support\n--- a/src/main/java/com/fasterxml/jackson/core/JsonStreamContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonStreamContext.java\n      * follow field names; null for root level and array values.\n      */\n     public abstract String getCurrentName();\n+\n+    /**\n+     * Method for accessing currently active value being used by data-binding\n+     * (as the source of streaming data to write, or destination of data being\n+     * read), at this level in hierarchy.\n+     * The value may not exist or be available due to various limitations (at\n+     * least during reading of data, as target value object may not have yet\n+     * been constructed).\n+     * \n+     * @return Currently active value, if one has been assigned.\n+     * \n+     * @since 2.5\n+     */\n+    public Object getCurrentValue() {\n+        return null;\n+    }\n+\n+    /**\n+     * Method to call to pass value to be returned via {@link #getCurrentValue}; typically\n+     * called indirectly through {@link JsonParser#setCurrentValue}\n+     * or {@link JsonGenerator#setCurrentValue}).\n+     * \n+     * @since 2.5\n+     */\n+    public void setCurrentValue(Object v) { }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/TreeNode.java\n+++ b/src/main/java/com/fasterxml/jackson/core/TreeNode.java\n      * Functionally equivalent to first serializing tree using\n      * {@link ObjectCodec} and then re-parsing but\n      * more efficient.\n+     *<p>\n+     * NOTE: constructed parser instance will NOT initially point to a token,\n+     * so before passing it to deserializers, it is typically necessary to\n+     * advance it to the first available token by calling {@link JsonParser#nextToken()}.\n+     *<p>\n+     * Also note that calling this method will <b>NOT</b> pass {@link ObjectCodec}\n+     * reference, so data-binding callback methods like {@link JsonParser#readValueAs(Class)}\n+     * will not work with calling {@link JsonParser#setCodec}).\n+     * It is often better to call {@link #traverse(ObjectCodec)} to pass the codec explicitly.\n      */\n     JsonParser traverse();\n \n      * Same as {@link #traverse()}, but additionally passes {@link com.fasterxml.jackson.core.ObjectCodec}\n      * to use if {@link JsonParser#readValueAs(Class)} is used (otherwise caller must call\n      * {@link JsonParser#setCodec} on response explicitly).\n+     *<p>\n+     * NOTE: constructed parser instance will NOT initially point to a token,\n+     * so before passing it to deserializers, it is typically necessary to\n+     * advance it to the first available token by calling {@link JsonParser#nextToken()}.\n      * \n      * @since 2.1\n      */\n--- a/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n      * package as the implementation class.\n      */\n     @Override public Version version() { return VersionUtil.versionFor(getClass()); }\n-    \n+\n+    @Override\n+    public Object getCurrentValue() {\n+        return _writeContext.getCurrentValue();\n+    }\n+\n+    @Override\n+    public void setCurrentValue(Object v) {\n+        _writeContext.setCurrentValue(v);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Configuration\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n \n     @Override public Version version() { return PackageVersion.VERSION; }\n \n+    @Override\n+    public Object getCurrentValue() {\n+        return _parsingContext.getCurrentValue();\n+    }\n+\n+    @Override\n+    public void setCurrentValue(Object v) {\n+        _parsingContext.setCurrentValue(v);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Overrides for Feature handling\n--- a/src/main/java/com/fasterxml/jackson/core/json/JsonReadContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonReadContext.java\n     // // // Optional duplicate detection\n \n     protected DupDetector _dups;\n-    \n-    // // // Location information (minus source reference)\n-\n-    protected int _lineNr;\n-    protected int _columnNr;\n-\n-    protected String _currentName;\n-    \n+\n     /*\n     /**********************************************************\n     /* Simple instance reuse slots; speeds up things\n \n     /*\n     /**********************************************************\n-    /* Instance construction, reuse\n+    /* Location/state information (minus source reference)\n+    /**********************************************************\n+     */\n+\n+    protected String _currentName;\n+\n+    /**\n+     * @since 2.5\n+     */\n+    protected Object _currentValue;\n+    \n+    protected int _lineNr;\n+    protected int _columnNr;\n+\n+    /*\n+    /**********************************************************\n+    /* Instance construction, config, reuse\n     /**********************************************************\n      */\n \n         _lineNr = lineNr;\n         _columnNr = colNr;\n         _currentName = null;\n+        _currentValue = null;\n         if (_dups != null) {\n             _dups.reset();\n         }\n         return this;\n     }\n \n+    @Override\n+    public Object getCurrentValue() {\n+        return _currentValue;\n+    }\n+\n+    @Override\n+    public void setCurrentValue(Object v) {\n+        _currentValue = v;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Factory methods\n--- a/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java\n     // // // Optional duplicate detection\n \n     protected DupDetector _dups;\n-    \n+\n     /*\n     /**********************************************************\n     /* Simple instance reuse slots; speed up things\n \n     protected JsonWriteContext _child = null;\n \n+    /*\n+    /**********************************************************\n+    /* Location/state information (minus source reference)\n+    /**********************************************************\n+     */\n+    \n     /**\n      * Name of the field of which value is to be parsed; only\n      * used for OBJECT contexts\n      */\n     protected String _currentName;\n \n+    /**\n+     * @since 2.5\n+     */\n+    protected Object _currentValue;\n+    \n     /**\n      * Marker used to indicate that we just received a name, and\n      * now expect a value\n         _index = -1;\n         _currentName = null;\n         _gotName = false;\n+        _currentValue = null;\n         if (_dups != null) { _dups.reset(); }\n         return this;\n     }\n     public JsonWriteContext withDupDetector(DupDetector dups) {\n         _dups = dups;\n         return this;\n+    }\n+\n+    @Override\n+    public Object getCurrentValue() {\n+        return _currentValue;\n+    }\n+\n+    @Override\n+    public void setCurrentValue(Object v) {\n+        _currentValue = v;\n     }\n     \n     /*\n      * @return Index of the field entry (0-based)\n      */\n     public int writeFieldName(String name) throws JsonProcessingException {\n+        if (_gotName) {\n+            return JsonWriteContext.STATUS_EXPECT_VALUE;\n+        }\n         _gotName = true;\n         _currentName = name;\n         if (_dups != null) { _checkDup(_dups, name); }\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n      */\n \n     @Override\n-    protected final boolean loadMore()\n-        throws IOException\n+    protected final boolean loadMore() throws IOException\n     {\n         _currInputProcessed += _inputEnd;\n         _currInputRowStart -= _inputEnd;\n         \n         if (_inputStream != null) {\n-            int count = _inputStream.read(_inputBuffer, 0, _inputBuffer.length);\n+            int space = _inputBuffer.length;\n+            if (space == 0) { // only occurs when we've been closed\n+                return false;\n+            }\n+            \n+            int count = _inputStream.read(_inputBuffer, 0, space);\n             if (count > 0) {\n                 _inputPtr = 0;\n                 _inputEnd = count;\n      * Helper method that will try to load at least specified number bytes in\n      * input buffer, possible moving existing data around if necessary\n      */\n-    protected final boolean _loadToHaveAtLeast(int minAvailable)\n-        throws IOException\n+    protected final boolean _loadToHaveAtLeast(int minAvailable) throws IOException\n     {\n         // No input stream, no leading (either we are closed, or have non-stream input source)\n         if (_inputStream == null) {\n         if (_bufferRecyclable) {\n             byte[] buf = _inputBuffer;\n             if (buf != null) {\n-                _inputBuffer = null;\n+                /* 21-Nov-2014, tatu: Let's not set it to null; this way should\n+                 *   get slightly more meaningful error messages in case someone\n+                 *   closes parser indirectly, without realizing.\n+                 */\n+                _inputBuffer = ByteArrayBuilder.NO_BYTES;\n                 _ioContext.releaseReadIOBuffer(buf);\n             }\n         }\n--- a/src/main/java/com/fasterxml/jackson/core/util/ByteArrayBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/ByteArrayBuilder.java\n  */\n public final class ByteArrayBuilder extends OutputStream\n {\n-    private final static byte[] NO_BYTES = new byte[0];\n+    public final static byte[] NO_BYTES = new byte[0];\n     \n     // Size of the first block we will allocate.\n     private final static int INITIAL_BLOCK_SIZE = 500;\n--- a/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n         this.delegateCopyMethods = delegateCopyMethods;\n     }\n \n+    @Override\n+    public Object getCurrentValue() {\n+        return delegate.getCurrentValue();\n+    }\n+\n+    @Override\n+    public void setCurrentValue(Object v) {\n+        delegate.setCurrentValue(v);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Extended API\n--- a/src/main/java/com/fasterxml/jackson/core/util/JsonParserDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonParserDelegate.java\n         delegate = d;\n     }\n \n+    @Override\n+    public Object getCurrentValue() {\n+        return delegate.getCurrentValue();\n+    }\n+\n+    @Override\n+    public void setCurrentValue(Object v) {\n+        delegate.setCurrentValue(v);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Public API, configuration\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestGeneratorDupHandling.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestGeneratorDupHandling.java\n         final JsonFactory f = new JsonFactory();\n         _testSimpleDups(false, true, f);\n     }\n-    \n+\n     @SuppressWarnings(\"resource\")\n     protected void _testSimpleDups(boolean useStream, boolean lazySetting, JsonFactory f)\n             throws Exception\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestJsonGenerator.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestJsonGenerator.java\n {\n     // // // First, tests for primitive (non-structured) values\n \n-    @SuppressWarnings(\"resource\")\n     public void testStringWrite() throws Exception\n     {\n         JsonFactory jf = new JsonFactory();\n         \n         gen.close();\n     }\n-    \n+\n+    // [core#167]: no error for writing field name twice\n+    public void testDupFieldNameWrites() throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+        _testDupFieldNameWrites(f, false);\n+        _testDupFieldNameWrites(f, true);        \n+    }\n+\n+    private void _testDupFieldNameWrites(JsonFactory f, boolean useReader) throws Exception\n+    {\n+        JsonGenerator gen;\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        if (useReader) {\n+            gen = f.createGenerator(new OutputStreamWriter(bout, \"UTF-8\"));\n+        } else {\n+            gen = f.createGenerator(bout, JsonEncoding.UTF8);\n+        }\n+        gen.writeStartObject();\n+        gen.writeFieldName(\"a\");\n+        \n+        try {\n+            gen.writeFieldName(\"b\");\n+            gen.flush();\n+            String json = bout.toString(\"UTF-8\");\n+            fail(\"Should not have let two consequtive field name writes succeed: output = \"+json);\n+        } catch (JsonProcessingException e) {\n+            verifyException(e, \"can not write a field name, expecting a value\");\n+        }\n+        gen.close();\n+    }\n+            \n     /*\n     /**********************************************************\n     /* Internal methods", "timestamp": 1417235852, "metainfo": ""}