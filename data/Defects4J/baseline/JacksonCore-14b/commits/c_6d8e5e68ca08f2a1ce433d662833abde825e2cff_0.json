{"sha": "6d8e5e68ca08f2a1ce433d662833abde825e2cff", "log": "minor clean up for JsonPointer changes (fixing what I think was a minor bug)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\n \n     /**\n      * Marker instance used to represent segment that matches current\n-     * node or position.\n+     * node or position (that is, returns true for\n+     * {@link #matches()}).\n      */\n     protected final static JsonPointer EMPTY = new JsonPointer();\n     \n     /**\n      * Reference to rest of the pointer beyond currently matching\n-     * segment (if any); null if this pointer refers to a matching\n+     * segment (if any); null if this pointer refers to the matching\n      * segment.\n      */\n     protected final JsonPointer _nextSegment;\n \n     /**\n-     * Reference form currently matching segment (if any) to node\n+     * Reference from currently matching segment (if any) to node\n      * before leaf.\n      */\n     protected final JsonPointer _headSegment;\n     protected static JsonPointer _parseTailAndHead(String input) {\n         final int end = input.length();\n \n-        int lastSlash = input.lastIndexOf('/');\n-\n         // first char is the contextual slash, skip\n         for (int i = 1; i < end; ) {\n             char c = input.charAt(i);\n             if (c == '/') { // common case, got a segment\n-                if(i == NO_SLASH) {\n+                int lastSlash = input.lastIndexOf('/');\n+                if (lastSlash == NO_SLASH) {\n                     return new JsonPointer(input, input.substring(1, i),\n                             _parseTailAndHead(input.substring(i)), EMPTY);\n-                } else {\n-                    return new JsonPointer(input, input.substring(1, i),\n-                            _parseTailAndHead(input.substring(i)), compile(input.substring(0, lastSlash)));\n                 }\n+                return new JsonPointer(input, input.substring(1, i),\n+                        _parseTailAndHead(input.substring(i)), compile(input.substring(0, lastSlash)));\n             }\n             ++i;\n             // quoting is different; offline this case\n         }\n         _appendEscape(sb, input.charAt(i++));\n \n-        int lastSlash = input.lastIndexOf('/');\n-\n         while (i < end) {\n             char c = input.charAt(i);\n             if (c == '/') { // end is nigh!\n-                if(i == NO_SLASH) {\n+                int lastSlash = input.lastIndexOf('/');\n+                if (lastSlash == NO_SLASH) {\n                     return new JsonPointer(input, sb.toString(),\n                             _parseTailAndHead(input.substring(i)), EMPTY);\n-                } else {\n-                    return new JsonPointer(input, sb.toString(),\n-                            _parseTailAndHead(input.substring(i)), compile(input.substring(0, lastSlash)));\n                 }\n+                return new JsonPointer(input, sb.toString(),\n+                        _parseTailAndHead(input.substring(i)), compile(input.substring(0, lastSlash)));\n             }\n             ++i;\n             if (c == '~' && i < end) {\n--- a/src/test/java/com/fasterxml/jackson/core/TestJsonPointer.java\n+++ b/src/test/java/com/fasterxml/jackson/core/TestJsonPointer.java\n         assertEquals(\"15\", ptr.getMatchingProperty());\n         assertEquals(\"/15\", ptr.head().toString());\n         assertEquals(\"/15/name\", ptr.toString());\n+\n+        assertEquals(\"\", ptr.head().head().toString());\n+        assertNull(ptr.head().head().head());\n \n         ptr = ptr.tail();\n         assertNotNull(ptr);", "timestamp": 1418161638, "metainfo": ""}