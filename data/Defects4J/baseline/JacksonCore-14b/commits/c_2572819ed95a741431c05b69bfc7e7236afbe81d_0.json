{"sha": "2572819ed95a741431c05b69bfc7e7236afbe81d", "log": "Merge branch 'master' into exp/new-symbol-table", "commit": "\n--- a/src/test/java/com/fasterxml/jackson/core/BaseTest.java\n+++ b/src/test/java/com/fasterxml/jackson/core/BaseTest.java\n      * available methods, and ensures results are consistent, before\n      * returning them\n      */\n-    protected String getAndVerifyText(JsonParser jp)\n-        throws IOException, JsonParseException\n+    protected String getAndVerifyText(JsonParser jp) throws IOException\n     {\n         // Ok, let's verify other accessors\n         int actLen = jp.getTextLength();\n         return result;\n     }\n \n-    public String quote(String str) {\n+    protected String quote(String str) {\n         return '\"'+str+'\"';\n+    }\n+\n+    protected String aposToQuotes(String json) {\n+        return json.replace(\"'\", \"\\\"\");\n     }\n \n     protected void fieldNameFor(StringBuilder sb, int index)\n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n package com.fasterxml.jackson.core.sym;\n \n import java.io.IOException;\n+import java.lang.reflect.Field;\n import java.nio.charset.Charset;\n \n-import com.fasterxml.jackson.core.JsonFactory;\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.json.UTF8StreamJsonParser;\n \n public class TestSymbolTables extends com.fasterxml.jackson.core.BaseTest\n {\n             symbolsC.release();\n         }\n     }\n+\n+    // And then one more test just for Bytes-based symbol table\n+    public void testByteBasedSymbolTable() throws Exception\n+    {\n+        // combination of short, medium1/2, long names...\n+        final String JSON = aposToQuotes(\"{'abc':1, 'abc\\\\u0000':2, '\\\\u0000abc':3, \"\n+                // then some medium\n+                +\"'abc123':4,'abcd1234':5,\"\n+                +\"'abcd1234a':6,'abcd1234abcd':7,\"\n+                +\"'abcd1234abcd1':8\"\n+                +\"}\");\n+\n+        JsonFactory f = new JsonFactory();\n+        JsonParser p = f.createParser(JSON.getBytes(\"UTF-8\"));\n+        assertEquals(0, _findSymbolCount(p));\n+        _streamThrough(p);\n+        assertEquals(8, _findSymbolCount(p));\n+        p.close();\n+\n+        // and, for fun, try again\n+        p = f.createParser(JSON.getBytes(\"UTF-8\"));\n+        _streamThrough(p);\n+        assertEquals(8, _findSymbolCount(p));\n+        p.close();\n+    }\n+\n+    private void _streamThrough(JsonParser p) throws IOException\n+    {\n+        while (p.nextToken() != null) { }\n+    }\n+    \n+    private int _findSymbolCount(JsonParser p) throws Exception\n+    {\n+        Field syms = p.getClass().getDeclaredField(\"_symbols\");\n+        syms.setAccessible(true);\n+        return ((BytesToNameCanonicalizer) syms.get(p)).size();\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n             return _handleOddName(i);\n         }\n         // First: can we optimize out bounds checks?\n-        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n+        if ((_inputPtr + 13) > _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\n             return slowParseName();\n         }\n \n             }\n             return parseName(_quad1, q2, i, 4);\n         }\n-        return parseLongName(i, q2);\n-    }\n-\n-    protected final Name parseLongName(int q, final int q2) throws IOException\n+        return parseMediumName2(i, q2);\n+    }\n+\n+    /**\n+     * @since 2.6\n+     */\n+    protected final Name parseMediumName2(int q3, final int q2) throws IOException\n+    {\n+        final byte[] input = _inputBuffer;\n+        final int[] codes = _icLatin1;\n+\n+        // Got 9 name bytes so far\n+        int i = input[_inputPtr++] & 0xFF;\n+        if (codes[i] != 0) {\n+            if (i == INT_QUOTE) { // 9 bytes\n+                return findName(_quad1, q2, q3, 1);\n+            }\n+            return parseName(_quad1, q2, q3, i, 1);\n+        }\n+        q3 = (q3 << 8) | i;\n+        i = input[_inputPtr++] & 0xFF;\n+        if (codes[i] != 0) {\n+            if (i == INT_QUOTE) { // 10 bytes\n+                return findName(_quad1, q2, q3, 2);\n+            }\n+            return parseName(_quad1, q2, q3, i, 2);\n+        }\n+        q3 = (q3 << 8) | i;\n+        i = input[_inputPtr++] & 0xFF;\n+        if (codes[i] != 0) {\n+            if (i == INT_QUOTE) { // 11 bytes\n+                return findName(_quad1, q2, q3, 3);\n+            }\n+            return parseName(_quad1, q2, q3, i, 3);\n+        }\n+        q3 = (q3 << 8) | i;\n+        i = input[_inputPtr++] & 0xFF;\n+        if (codes[i] != 0) {\n+            if (i == INT_QUOTE) { // 12 bytes\n+                return findName(_quad1, q2, q3, 4);\n+            }\n+            return parseName(_quad1, q2, q3, i, 4);\n+        }\n+        return parseLongName(i, q2, q3);\n+    }\n+    \n+    protected final Name parseLongName(int q, final int q2, int q3) throws IOException\n     {\n         _quadBuffer[0] = _quad1;\n         _quadBuffer[1] = q2;\n+        _quadBuffer[2] = q3;\n \n         // As explained above, will ignore UTF-8 encoding at this point\n         final byte[] input = _inputBuffer;\n         final int[] codes = _icLatin1;\n-        int qlen = 2;\n+        int qlen = 3;\n \n         while ((_inputPtr + 4) <= _inputEnd) {\n             int i = input[_inputPtr++] & 0xFF;\n \n     /**\n      * Method called when not even first 8 bytes are guaranteed\n-     * to come consecutively. Happens rarely, so this is off-lined;\n+     * to come consequtively. Happens rarely, so this is offlined;\n      * plus we'll also do full checks for escaping etc.\n      */\n     protected Name slowParseName() throws IOException\n         return parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes);\n     }\n \n+    private final Name parseName(int q1, int q2, int q3, int ch, int lastQuadBytes) throws IOException {\n+        _quadBuffer[0] = q1;\n+        _quadBuffer[1] = q2;\n+        return parseEscapedName(_quadBuffer, 2, q3, ch, lastQuadBytes);\n+    }\n+    \n     /**\n      * Slower parsing method which is generally branched to when\n      * an escape sequence is detected (or alternatively for long\n-     * names, or ones crossing input buffer boundary). In any case,\n-     * needs to be able to handle more exceptional cases, gets\n-     * slower, and hance is offlined to a separate method.\n+     * names, one crossing input buffer boundary).\n+     * Needs to be able to handle more exceptional cases, gets slower,\n+     * and hance is offlined to a separate method.\n      */\n     protected final Name parseEscapedName(int[] quads, int qlen, int currQuad, int ch,\n             int currQuadBytes) throws IOException\n             }\n             ch = _inputBuffer[_inputPtr++] & 0xFF;\n         }\n+\n         if (currQuadBytes > 0) {\n             if (qlen >= quads.length) {\n                 _quadBuffer = quads = growArrayBy(quads, quads.length);\n     /**********************************************************\n      */\n \n-    private final Name findName(int q1, int lastQuadBytes)\n-        throws JsonParseException\n+    private final Name findName(int q1, int lastQuadBytes) throws JsonParseException\n     {\n         q1 = pad(q1, lastQuadBytes);\n         // Usually we'll find it from the canonical symbol table already\n         return addName(_quadBuffer, 1, lastQuadBytes);\n     }\n \n-    private final Name findName(int q1, int q2, int lastQuadBytes)\n-        throws JsonParseException\n+    private final Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException\n     {\n         q2 = pad(q2, lastQuadBytes);\n         // Usually we'll find it from the canonical symbol table already\n         return addName(_quadBuffer, 2, lastQuadBytes);\n     }\n \n-    private final Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes)\n-        throws JsonParseException\n+    private final Name findName(int q1, int q2, int q3, int lastQuadBytes) throws JsonParseException\n+    {\n+        Name name = _symbols.findName(q1, q2, q3);\n+        if (name != null) {\n+            return name;\n+        }\n+        int[] quads = _quadBuffer;\n+        quads[0] = q1;\n+        quads[1] = q2;\n+        quads[2] = pad(q3, lastQuadBytes);\n+        return addName(quads, 3, lastQuadBytes);\n+    }\n+    \n+    private final Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException\n     {\n         if (qlen >= quads.length) {\n             _quadBuffer = quads = growArrayBy(quads, quads.length);\n--- a/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n         return null;\n     }\n \n+    public Name findName(int q1, int q2, int q3)\n+    {\n+        int hash = calcHash(q1, q2, q3);\n+        int ix = (hash & _hashMask);\n+        int val = _hash[ix];\n+        \n+        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n+            // Ok, but do we have an actual match?\n+            Name name = _mainNames[ix];\n+            if (name == null) { // main slot empty; can't find\n+                return null;\n+            }\n+            if (name.equals(q1, q2, q3)) {\n+                return name;\n+            }\n+        } else if (val == 0) { // empty slot? no match\n+            return null;\n+        }\n+        // Maybe a spill-over?\n+        val &= 0xFF;\n+        if (val > 0) { // 0 means 'empty'\n+            val -= 1; // to convert from 1-based to 0...\n+            Bucket bucket = _collList[val];\n+            if (bucket != null) {\n+                return bucket.find(hash, q1, q2, q3);\n+            }\n+        }\n+        // Nope, no match whatsoever\n+        return null;\n+    }\n+    \n     /**\n      * Finds and returns name matching the specified symbol, if such\n      * name already exists in the table; or if not, creates name object,\n      */\n     public Name findName(int[] q, int qlen)\n     {\n-        if (qlen < 3) { // another sanity check\n+        if (qlen < 4) { // another sanity check\n+            if (qlen == 3) {\n+                return findName(q[0], q[1], q[2]);\n+            }\n             return findName(q[0], (qlen < 2) ? 0 : q[1]);\n         }\n         int hash = calcHash(q, qlen);\n             name = InternCache.instance.intern(name);\n         }\n         int hash;\n-        if (qlen < 3) {\n-            hash = (qlen == 1) ? calcHash(q[0]) : calcHash(q[0], q[1]);\n+        if (qlen < 4) {\n+            if (qlen == 1) {\n+                hash = calcHash(q[0]);\n+            } else if (qlen == 2) {\n+                hash = calcHash(q[0], q[1]);\n+            } else {\n+                hash = calcHash(q[0], q[1], q[2]);\n+            }\n         } else {\n             hash = calcHash(q, qlen);\n         }\n         return hash;\n     }\n \n+    public int calcHash(int q1, int q2, int q3)\n+    {\n+        // use same algorithm as multi-byte, tested to work well\n+        int hash = q1 ^ _seed;\n+        hash += (hash >>> 9);\n+        hash *= MULT;\n+        hash += q2;\n+        hash *= MULT2;\n+        hash += (hash >>> 15);\n+        hash ^= q3;\n+        hash += (hash >>> 17);\n+\n+        // and finally shuffle some more once done\n+        hash += (hash >>> 15); // to get high-order bits to mix more\n+        hash ^= (hash << 9); // as well as lowest 2 bytes\n+\n+        return hash;\n+    }\n+    \n     public int calcHash(int[] q, int qlen)\n     {\n-        // Note: may be called for qlen < 3; but has at least one int\n-        if (qlen < 3) {\n+        if (qlen < 4) {\n             throw new IllegalArgumentException();\n         }\n \n             case 2:\n                 return new Name2(name, hash, quads[0], quads[1]);\n             case 3:\n+            default:\n                 return new Name3(name, hash, quads[0], quads[1], quads[2]);\n-            default:\n             }\n         }\n         return NameN.construct(name, hash, quads, qlen);\n             return null;\n         }\n \n+        public Name find(int h, int q1, int q2, int q3) {\n+            if (hash == h) {\n+                if (name.equals(q1, q2, q3)) {\n+                    return name;\n+                }\n+            }\n+            for (Bucket curr = next; curr != null; curr = curr.next) {\n+                if (curr.hash == h) {\n+                    Name currName = curr.name;\n+                    if (currName.equals(q1, q2, q3)) {\n+                        return currName;\n+                    }\n+                }\n+            }\n+            return null;\n+        }\n+        \n         public Name find(int h, int[] quads, int qlen) {\n             if (hash == h) {\n                 if (name.equals(quads, qlen)) {\n--- a/src/main/java/com/fasterxml/jackson/core/sym/Name.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/Name.java\n     /**********************************************************\n      */\n \n-    public abstract boolean equals(int quad1);\n+    public abstract boolean equals(int q1);\n \n-    public abstract boolean equals(int quad1, int quad2);\n+    public abstract boolean equals(int q1, int q2);\n+\n+    /**\n+     * @since 2.6\n+     */\n+    public abstract boolean equals(int q1, int q2, int q3);\n \n     public abstract boolean equals(int[] quads, int qlen);\n \n--- a/src/main/java/com/fasterxml/jackson/core/sym/Name1.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/Name1.java\n \n     @Override public boolean equals(int quad) { return (quad == q); }\n     @Override public boolean equals(int quad1, int quad2) { return (quad1 == q) && (quad2 == 0); }\n+    @Override public boolean equals(int q1, int q2, int q3) { return false; }\n+\n     @Override public boolean equals(int[] quads, int qlen) { return (qlen == 1 && quads[0] == q); }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/sym/Name2.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/Name2.java\n     @Override\n     public boolean equals(int quad1, int quad2) { return (quad1 == q1) && (quad2 == q2); }\n \n+    @Override public boolean equals(int quad1, int quad2, int q3) { return false; }\n+    \n     @Override\n     public boolean equals(int[] quads, int qlen) { return (qlen == 2 && quads[0] == q1 && quads[1] == q2); }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/sym/Name3.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/Name3.java\n     public boolean equals(int quad1, int quad2) { return false; }\n \n     @Override\n+    public boolean equals(int quad1, int quad2, int quad3) {\n+        return (q1 == quad1) && (q2 == quad2) && (q3 == quad3);\n+    }\n+\n+    @Override\n     public boolean equals(int[] quads, int qlen) {\n         return (qlen == 3) && (quads[0] == q1) && (quads[1] == q2) && (quads[2] == q3);\n     }\n--- a/src/main/java/com/fasterxml/jackson/core/sym/NameN.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/NameN.java\n     @Override\n     public boolean equals(int quad1, int quad2) { return false; }\n \n+    // Implies quad length == 3, never matches\n+    @Override\n+    public boolean equals(int quad1, int quad2, int quad3) { return false; }\n+\n     @Override\n     public boolean equals(int[] quads, int len) {\n         if (len != qlen) { return false; }\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestParserSymbols.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestParserSymbols.java\n         _testSymbolsWithNull(f, false);\n         _testSymbolsWithNull(f, false);\n     }\n-    \n+\n     private void _testSymbolsWithNull(JsonFactory f, boolean useBytes) throws Exception\n     {\n         final String INPUT = \"{\\\"\\\\u0000abc\\\" : 1, \\\"abc\\\":2}\";\n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n         final int SEED = 33333;\n         BytesToNameCanonicalizer symbols =\n                 BytesToNameCanonicalizer.createRoot(SEED).makeChild(JsonFactory.Feature.collectDefaults());\n+\n         final int COUNT = 6000;\n         for (int i = 0; i < COUNT; ++i) {\n             String id = fieldNameFor(i);\n         assertEquals(1686, symbols.collisionCount());\n         // but not super long collision chains:\n         assertEquals(9, symbols.maxCollisionLength());\n+\n+        // But also verify entries are actually found?\n     }\n \n     // [Issue#145]", "timestamp": 1423029849, "metainfo": ""}