{"sha": "46e806be2ef3e4f2c6a08d678ab89929d72b27d7", "log": "test refactoring", "commit": "\n--- a/src/test/java/com/fasterxml/jackson/core/TestVersions.java\n+++ b/src/test/java/com/fasterxml/jackson/core/TestVersions.java\n     \n     private void assertVersion(Version v)\n     {\n-    \tassertEquals(PackageVersion.VERSION, v);\n+        assertEquals(PackageVersion.VERSION, v);\n     }\n \n     private IOContext getIOContext() {\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/base64/TestBase64Codec.java\n+package com.fasterxml.jackson.core.base64;\n+\n+import org.junit.Assert;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+public class TestBase64Codec\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    public void testProps()\n+    {\n+        Base64Variant std = Base64Variants.MIME;\n+        // let's verify basic props of std cocec\n+        assertEquals(\"MIME\", std.getName());\n+        assertEquals(\"MIME\", std.toString());\n+        assertTrue(std.usesPadding());\n+        assertFalse(std.usesPaddingChar('X'));\n+        assertEquals('=', std.getPaddingChar());\n+        assertTrue(std.usesPaddingChar('='));\n+        assertEquals((byte) '=', std.getPaddingByte());\n+        assertEquals(76, std.getMaxLineLength());\n+    }\n+\n+    public void testCharEncoding() throws Exception\n+    {\n+        Base64Variant std = Base64Variants.MIME;\n+        assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char('?'));\n+        assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char((int) '?'));\n+        assertEquals(Base64Variant.BASE64_VALUE_INVALID, std.decodeBase64Char((byte) '?'));\n+\n+        assertEquals(0, std.decodeBase64Char('A'));\n+        assertEquals(1, std.decodeBase64Char((int) 'B'));\n+        assertEquals(2, std.decodeBase64Char((byte)'C'));\n+\n+        assertEquals('/', std.encodeBase64BitsAsChar(63));\n+        assertEquals((byte) 'b', std.encodeBase64BitsAsByte(27));\n+\n+        String EXP_STR = \"HwdJ\";\n+        int TRIPLET = 0x1F0749;\n+        StringBuilder sb = new StringBuilder();\n+        std.encodeBase64Chunk(sb, TRIPLET);\n+        assertEquals(EXP_STR, sb.toString());\n+\n+        byte[] exp = EXP_STR.getBytes(\"UTF-8\");\n+        byte[] act = new byte[exp.length];\n+        std.encodeBase64Chunk(TRIPLET, act, 0);\n+        Assert.assertArrayEquals(exp, act);\n+    }\n+\n+    @SuppressWarnings(\"unused\")\n+    public void testErrors() throws Exception\n+    {\n+        try {\n+            Base64Variant b = new Base64Variant(\"foobar\", \"xyz\", false, '!', 24);\n+        } catch (IllegalArgumentException iae) {\n+            verifyException(iae, \"length must be exactly\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/base64/TestBase64Generation.java\n+package com.fasterxml.jackson.core.base64;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+public class TestBase64Generation\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    static class ThrottledInputStream extends FilterInputStream\n+    {\n+        protected final int _maxBytes;\n+\n+        public ThrottledInputStream(byte[] data, int maxBytes)\n+        {\n+            this(new ByteArrayInputStream(data), maxBytes);\n+        }\n+        \n+        public ThrottledInputStream(InputStream in, int maxBytes)\n+        {\n+            super(in);\n+            _maxBytes = maxBytes;\n+        }\n+\n+        @Override\n+        public int read(byte[] buf) throws IOException {\n+            return read(buf, 0, buf.length);\n+        }\n+        \n+        @Override\n+        public int read(byte[] buf, int offset, int len) throws IOException {\n+            return in.read(buf, offset, Math.min(_maxBytes, len));\n+        }\n+        \n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    public void testStreamingWrites() throws Exception\n+    {\n+        final JsonFactory f = new JsonFactory();\n+        _testStreamingWrites(f, true);\n+        _testStreamingWrites(f, false);\n+    }\n+\n+    // For [#55]\n+    public void testIssue55() throws Exception\n+    {\n+        final JsonFactory f = new JsonFactory();\n+\n+        // First,  byte-backed:\n+        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n+\n+        JsonGenerator gen = f.createGenerator(bytes);\n+        ByteArrayInputStream data = new ByteArrayInputStream(new byte[2000]);\n+        gen.writeBinary(data, 1999);       \n+        gen.close();\n+\n+        final int EXP_LEN = 2670;\n+        \n+        assertEquals(EXP_LEN, bytes.size());\n+\n+        // Then char-backed\n+        StringWriter sw = new StringWriter();\n+        \n+        gen = f.createGenerator(sw);\n+        data = new ByteArrayInputStream(new byte[2000]);\n+        gen.writeBinary(data, 1999);       \n+        gen.close();\n+        \n+        assertEquals(EXP_LEN, sw.toString().length());\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    private final static Base64Variant[] VARIANTS = {\n+            Base64Variants.MIME,\n+            Base64Variants.MIME_NO_LINEFEEDS,\n+            Base64Variants.MODIFIED_FOR_URL,\n+            Base64Variants.PEM\n+    };\n+\n+    private final static String TEXT = \"Some content so that we can test encoding of base64 data; must\"\n+            +\" be long enough include a line wrap or two...\";\n+    private final static String TEXT4 = TEXT + TEXT + TEXT + TEXT;\n+\n+    private void _testStreamingWrites(JsonFactory jf, boolean useBytes) throws Exception\n+    {\n+        final byte[] INPUT = TEXT4.getBytes(\"UTF-8\");\n+        for (Base64Variant variant : VARIANTS) {\n+            final String EXP_OUTPUT = \"[\" + quote(variant.encode(INPUT))+\"]\";\n+            for (boolean passLength : new boolean[] { true, false }) {\n+                for (int chunkSize : new int[] { 1, 2, 3, 4, 7, 11, 29, 5000 }) {\n+//System.err.println(\"\"+variant+\", length \"+passLength+\", chunk \"+chunkSize);\n+                    \n+                    JsonGenerator jgen;\n+                    \n+                    final ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n+                    if (useBytes) {\n+                        jgen = jf.createGenerator(bytes);\n+                    } else {\n+                        jgen = jf.createGenerator(new OutputStreamWriter(bytes, \"UTF-8\"));\n+                    }\n+                    jgen.writeStartArray();\n+                    int length = passLength ? INPUT.length : -1;\n+                    InputStream data = new ThrottledInputStream(INPUT, chunkSize);\n+                    jgen.writeBinary(variant, data, length);\n+                    jgen.writeEndArray();\n+                    jgen.close();\n+                    String JSON = bytes.toString(\"UTF-8\");\n+                    assertEquals(EXP_OUTPUT, JSON);\n+                }\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/base64/TestBase64Parsing.java\n+package com.fasterxml.jackson.core.base64;\n+\n+import static org.junit.Assert.assertArrayEquals;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+public class TestBase64Parsing\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    public void testBase64UsingInputStream() throws Exception\n+    {\n+        _testBase64Text(true);\n+    }\n+\n+    public void testBase64UsingReader() throws Exception\n+    {\n+        _testBase64Text(false);\n+    }\n+\n+    // [Issue-15] (streaming binary reads)\n+    public void testStreaming() throws IOException\n+    {\n+        _testStreaming(false);\n+        _testStreaming(true);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test helper methods\n+    /**********************************************************\n+     */\n+    \n+    // Test for [JACKSON-631]\n+    public void _testBase64Text(boolean useBytes) throws Exception\n+    {\n+        // let's actually iterate over sets of encoding modes, lengths\n+        \n+        final int[] LENS = { 1, 2, 3, 4, 7, 9, 32, 33, 34, 35 };\n+        final Base64Variant[] VARIANTS = {\n+                Base64Variants.MIME,\n+                Base64Variants.MIME_NO_LINEFEEDS,\n+                Base64Variants.MODIFIED_FOR_URL,\n+                Base64Variants.PEM\n+        };\n+\n+        JsonFactory jsonFactory = new JsonFactory();\n+        final ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n+        StringWriter chars = null;\n+        for (int len : LENS) {\n+            byte[] input = new byte[len];\n+            for (int i = 0; i < input.length; ++i) {\n+                input[i] = (byte) i;\n+            }\n+            for (Base64Variant variant : VARIANTS) {\n+                JsonGenerator jgen;\n+                if (useBytes) {\n+                    bytes.reset();\n+                    jgen = jsonFactory.createGenerator(bytes, JsonEncoding.UTF8);\n+                } else {\n+                    chars = new StringWriter();\n+                    jgen = jsonFactory.createGenerator(chars);\n+                }\n+                jgen.writeBinary(variant, input, 0, input.length);\n+                jgen.close();\n+                JsonParser jp;\n+                if (useBytes) {\n+                    jp = jsonFactory.createParser(bytes.toByteArray());\n+                } else {\n+                    jp = jsonFactory.createParser(chars.toString());\n+                }\n+                assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+                byte[] data = null;\n+                try {\n+                    data = jp.getBinaryValue(variant);\n+                } catch (Exception e) {\n+                    IOException ioException = new IOException(\"Failed (variant \"+variant+\", data length \"+len+\"): \"+e.getMessage());\n+                    ioException.initCause(e);\n+                    throw ioException;\n+                }\n+                assertNotNull(data);\n+                assertArrayEquals(data, input);\n+                assertNull(jp.nextToken());\n+                jp.close();\n+            }\n+        }\n+    }\n+\n+    private byte[] _generateData(int size)\n+    {\n+        byte[] result = new byte[size];\n+        for (int i = 0; i < size; ++i) {\n+            result[i] = (byte) (i % 255);\n+        }\n+        return result;\n+    }\n+\n+    private void _testStreaming(boolean useBytes) throws IOException\n+    {\n+        final int[] SIZES = new int[] {\n+            1, 2, 3, 4, 5, 6,\n+            7, 8, 12,\n+            100, 350, 1900, 6000, 19000, 65000,\n+            139000\n+        };\n+\n+        JsonFactory jsonFactory = new JsonFactory();\n+        final ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n+        StringWriter chars = null;\n+\n+        for (int size : SIZES) {\n+            byte[] data = _generateData(size);\n+            JsonGenerator g;\n+            if (useBytes) {\n+                bytes.reset();\n+                g = jsonFactory.createGenerator(bytes, JsonEncoding.UTF8);\n+            } else {\n+                chars = new StringWriter();\n+                g = jsonFactory.createGenerator(chars);\n+            }\n+\n+            g.writeStartObject();\n+            g.writeFieldName(\"b\");\n+            g.writeBinary(data);\n+            g.writeEndObject();\n+            g.close();\n+\n+            // and verify\n+            JsonParser p;\n+            if (useBytes) {\n+                p = jsonFactory.createParser(bytes.toByteArray());\n+            } else {\n+                p = jsonFactory.createParser(chars.toString());\n+            }\n+            assertToken(JsonToken.START_OBJECT, p.nextToken());\n+    \n+            assertToken(JsonToken.FIELD_NAME, p.nextToken());\n+            assertEquals(\"b\", p.getCurrentName());\n+            assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+            ByteArrayOutputStream result = new ByteArrayOutputStream(size);\n+            int gotten = p.readBinaryValue(result);\n+            assertEquals(size, gotten);\n+            assertArrayEquals(data, result.toByteArray());\n+            assertToken(JsonToken.END_OBJECT, p.nextToken());\n+            assertNull(p.nextToken());\n+            p.close();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestCharEscaping.java\n+package com.fasterxml.jackson.core.json;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.io.CharacterEscapes;\n+\n+/**\n+ * Set of basic unit tests for verifying that the basic parser\n+ * functionality works as expected.\n+ */\n+public class TestCharEscaping\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    // for [JACKSON-627]\n+    @SuppressWarnings(\"serial\")\n+    private final static CharacterEscapes ESC_627 = new CharacterEscapes() {\n+        final int[] ascii = CharacterEscapes.standardAsciiEscapesForJSON();\n+        {\n+          ascii['<'] = CharacterEscapes.ESCAPE_STANDARD;\n+          ascii['>'] = CharacterEscapes.ESCAPE_STANDARD;\n+        }\n+\n+        @Override\n+        public int[] getEscapeCodesForAscii() {\n+          return ascii;\n+        }\n+\n+        @Override\n+        public SerializableString getEscapeSequence(int ch) {\n+          throw new UnsupportedOperationException(\"Not implemented for test\");\n+        }\n+      };\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+      */\n+\n+    public void testMissingEscaping()\n+        throws Exception\n+    {\n+        // Invalid: control chars, including lf, must be escaped\n+        final String DOC = \"[\"\n+            +\"\\\"Linefeed: \\n.\\\"\"\n+            +\"]\";\n+        JsonParser jp = createParserUsingReader(DOC);\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        try {\n+            // This may or may not trigger exception\n+            JsonToken t = jp.nextToken();\n+            assertToken(JsonToken.VALUE_STRING, t);\n+            // and if not, should get it here:\n+            jp.getText();\n+            fail(\"Expected an exception for un-escaped linefeed in string value\");\n+        } catch (JsonParseException jex) {\n+            verifyException(jex, \"has to be escaped\");\n+        }\n+    }\n+\n+    public void testSimpleEscaping()\n+        throws Exception\n+    {\n+        String DOC = \"[\"\n+            +\"\\\"LF=\\\\n\\\"\"\n+            +\"]\";\n+\n+        JsonParser jp = createParserUsingReader(DOC);\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(\"LF=\\n\", jp.getText());\n+        jp.close();\n+\n+\n+        /* Note: must split Strings, so that javac won't try to handle\n+         * escape and inline null char\n+         */\n+        DOC = \"[\\\"NULL:\\\\u0000!\\\"]\";\n+\n+        jp = createParserUsingReader(DOC);\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(\"NULL:\\0!\", jp.getText());\n+\n+        // Then just a single char escaping\n+        jp = createParserUsingReader(\"[\\\"\\\\u0123\\\"]\");\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(\"\\u0123\", jp.getText());\n+\n+        // And then double sequence\n+        jp = createParserUsingReader(\"[\\\"\\\\u0041\\\\u0043\\\"]\");\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(\"AC\", jp.getText());\n+    }\n+\n+    public void testInvalid()\n+        throws Exception\n+    {\n+        // 2-char sequences not allowed:\n+        String DOC = \"[\\\"\\\\u41=A\\\"]\";\n+        JsonParser jp = createParserUsingReader(DOC);\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        try {\n+            jp.nextToken();\n+            jp.getText();\n+            fail(\"Expected an exception for unclosed ARRAY\");\n+        } catch (JsonParseException jpe) {\n+            verifyException(jpe, \"for character escape\");\n+        }\n+    }\n+\n+    /**\n+     * Test to verify that decoder does not allow 8-digit escapes\n+     * (non-BMP characters must be escaped using two 4-digit sequences)\n+     */\n+    public void test8DigitSequence()\n+        throws Exception\n+    {\n+        String DOC = \"[\\\"\\\\u00411234\\\"]\";\n+        JsonParser jp = createParserUsingReader(DOC);\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(\"A1234\", jp.getText());\n+    }\n+\n+    // for [JACKSON-627]\n+    public void testWriteLongCustomEscapes() throws Exception\n+    {\n+        JsonFactory jf = new JsonFactory();\n+        jf.setCharacterEscapes(ESC_627); // must set to trigger bug\n+        StringBuilder longString = new StringBuilder();\n+        while (longString.length() < 2000) {\n+          longString.append(\"\\u65e5\\u672c\\u8a9e\");\n+        }\n+\n+        StringWriter writer = new StringWriter();\n+        // must call #createGenerator(Writer), #createGenerator(OutputStream) doesn't trigger bug\n+        JsonGenerator jgen = jf.createGenerator(writer);\n+        jgen.setHighestNonEscapedChar(127); // must set to trigger bug\n+        jgen.writeString(longString.toString());\n+      }      \n+\n+}\n+\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestComments.java\n+package com.fasterxml.jackson.core.json;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+/**\n+ * Unit tests for verifying that support for (non-standard) comments\n+ * works as expected.\n+ */\n+public class TestComments\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    final static String DOC_WITH_SLASHSTAR_COMMENT =\n+        \"[ /* comment:\\n ends here */ 1 /* one more ok to have \\\"unquoted\\\"  */ ]\"\n+        ;\n+\n+    final static String DOC_WITH_SLASHSLASH_COMMENT =\n+        \"[ // comment...\\n 1 \\r  // one more, not array: []   \\n ]\"\n+        ;\n+\n+    /*\n+    /**********************************************************\n+    /* Test method wrappers\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Unit test for verifying that by default comments are not\n+     * recognized.\n+     */\n+    public void testDefaultSettings()\n+        throws Exception\n+    {\n+        JsonFactory jf = new JsonFactory();\n+        assertFalse(jf.isEnabled(JsonParser.Feature.ALLOW_COMMENTS));\n+        JsonParser jp = jf.createParser(new StringReader(\"[ 1 ]\"));\n+        assertFalse(jp.isEnabled(JsonParser.Feature.ALLOW_COMMENTS));\n+    }\n+\n+    public void testCommentsDisabled()\n+        throws Exception\n+    {\n+        _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, false);\n+        _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, false);\n+        _testDisabled(DOC_WITH_SLASHSTAR_COMMENT, true);\n+        _testDisabled(DOC_WITH_SLASHSLASH_COMMENT, true);\n+    }\n+\n+    public void testCommentsEnabled()\n+        throws Exception\n+    {\n+        _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, false);\n+        _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, false);\n+        _testEnabled(DOC_WITH_SLASHSTAR_COMMENT, true);\n+        _testEnabled(DOC_WITH_SLASHSLASH_COMMENT, true);\n+    }\n+\n+    // for [JACKSON-779]\n+    public void testCommentsWithUTF8() throws Exception\n+    {\n+        final String JSON = \"/* \\u00a9 2099 Yoyodyne Inc. */\\n [ \\\"bar? \\u00a9\\\" ]\\n\";\n+        _testWithUTF8Chars(JSON, false);\n+        _testWithUTF8Chars(JSON, true);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    private void _testWithUTF8Chars(String doc, boolean useStream) throws IOException\n+    {\n+        // should basically just stream through\n+        JsonParser jp = _createParser(doc, useStream, true);\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        assertNull(jp.nextToken());\n+        jp.close();\n+    }\n+    \n+    private void _testDisabled(String doc, boolean useStream) throws IOException\n+    {\n+        JsonParser jp = _createParser(doc, useStream, false);\n+        try {\n+            jp.nextToken();\n+            fail(\"Expected exception for unrecognized comment\");\n+        } catch (JsonParseException je) {\n+            // Should have something denoting that user may want to enable 'ALLOW_COMMENTS'\n+            verifyException(je, \"ALLOW_COMMENTS\");\n+        }\n+    }\n+\n+    private void _testEnabled(String doc, boolean useStream)\n+        throws IOException\n+    {\n+        JsonParser jp = _createParser(doc, useStream, true);\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(1, jp.getIntValue());\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+    }\n+\n+    private JsonParser _createParser(String doc, boolean useStream, boolean enabled)\n+        throws IOException\n+    {\n+        JsonFactory jf = new JsonFactory();\n+        jf.configure(JsonParser.Feature.ALLOW_COMMENTS, enabled);\n+        JsonParser jp = useStream ?\n+            jf.createParser(doc.getBytes(\"UTF-8\"))\n+            : jf.createParser(doc);\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        return jp;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestGeneratorWithSerializedString.java\n+package com.fasterxml.jackson.core.json;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.io.SerializedString;\n+\n+public class TestGeneratorWithSerializedString\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    final static String NAME_WITH_QUOTES = \"\\\"name\\\"\";\n+    final static String NAME_WITH_LATIN1 = \"P\\u00f6ll\\u00f6\";\n+\n+    private final SerializedString quotedName = new SerializedString(NAME_WITH_QUOTES);\n+    private final SerializedString latin1Name = new SerializedString(NAME_WITH_LATIN1);\n+    \n+    public void testSimple() throws Exception\n+    {\n+        JsonFactory jf = new JsonFactory();\n+\n+        // First using char-backed generator\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator jgen = jf.createGenerator(sw);\n+        _writeSimple(jgen);\n+        jgen.close();\n+        String json = sw.toString();\n+        _verifySimple(jf.createParser(json));\n+\n+        // then using UTF-8\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        jgen = jf.createGenerator(out, JsonEncoding.UTF8);\n+        _writeSimple(jgen);\n+        jgen.close();\n+        byte[] jsonB = out.toByteArray();\n+        _verifySimple(jf.createParser(jsonB));\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+    \n+    private void _writeSimple(JsonGenerator jgen) throws Exception\n+    {\n+        // Let's just write array of 2 objects\n+        jgen.writeStartArray();\n+\n+        jgen.writeStartObject();\n+        jgen.writeFieldName(quotedName);\n+        jgen.writeString(\"a\");\n+        jgen.writeFieldName(latin1Name);\n+        jgen.writeString(\"b\");\n+        jgen.writeEndObject();\n+\n+        jgen.writeStartObject();\n+        jgen.writeFieldName(latin1Name);\n+        jgen.writeString(\"c\");\n+        jgen.writeFieldName(quotedName);\n+        jgen.writeString(\"d\");\n+        jgen.writeEndObject();\n+        \n+        jgen.writeEndArray();\n+    }\n+\n+    private void _verifySimple(JsonParser jp) throws Exception\n+    {\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(NAME_WITH_QUOTES, jp.getText());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(\"a\", jp.getText());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(NAME_WITH_LATIN1, jp.getText());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(\"b\", jp.getText());\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(NAME_WITH_LATIN1, jp.getText());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(\"c\", jp.getText());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(NAME_WITH_QUOTES, jp.getText());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(\"d\", jp.getText());\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+        \n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        assertNull(jp.nextToken());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestUnicode.java\n+package com.fasterxml.jackson.core.json;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+public class TestUnicode extends com.fasterxml.jackson.test.BaseTest\n+{\n+    public void testSurrogates() throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+        _testSurrogates(f, true);\n+        _testSurrogates(f, false);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    private void _testSurrogates(JsonFactory f, boolean checkText) throws IOException\n+    {\n+        byte[] json = \"{\\\"text\\\":\\\"\\uD83D\\uDE03\\\"}\".getBytes(\"UTF-8\");\n+        // first\n+        JsonParser jp = f.createParser(json);\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        if (checkText) {\n+            assertEquals(\"text\", jp.getText());\n+        }\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        if (checkText) {\n+            assertEquals(\"\\uD83D\\uDE03\", jp.getText());\n+        }\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestValueConversions.java\n+package com.fasterxml.jackson.core.json;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonToken;\n+\n+/**\n+ * @since 1.6\n+ */\n+public class TestValueConversions\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    public void testAsInt() throws Exception\n+    {\n+        final String input = \"[ 1, -3, 4.98, true, false, null, \\\"-17\\\", \\\"foo\\\" ]\";\n+        for (int i = 0; i < 2; ++i) {\n+            JsonParser jp;\n+            if (i == 0) {\n+                jp = createParserUsingReader(input);                \n+            } else {\n+                jp = this.createParserUsingStream(input, \"UTF-8\");\n+            }\n+            assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+            assertEquals(0, jp.getValueAsLong());\n+            assertEquals(9, jp.getValueAsLong(9));\n+\n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(1, jp.getValueAsLong());\n+            assertEquals(1, jp.getValueAsLong(-99));\n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(-3, jp.getValueAsLong());\n+            assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+            assertEquals(4, jp.getValueAsLong());\n+            assertEquals(4, jp.getValueAsLong(99));\n+            assertToken(JsonToken.VALUE_TRUE, jp.nextToken());\n+            assertEquals(1, jp.getValueAsLong());\n+            assertToken(JsonToken.VALUE_FALSE, jp.nextToken());\n+            assertEquals(0, jp.getValueAsLong());\n+            assertToken(JsonToken.VALUE_NULL, jp.nextToken());\n+            assertEquals(0, jp.getValueAsLong());\n+            assertEquals(0, jp.getValueAsLong(27));\n+            assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+            assertEquals(-17, jp.getValueAsLong());\n+            assertEquals(-17, jp.getValueAsLong(3));\n+            assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+            assertEquals(0, jp.getValueAsLong());\n+            assertEquals(9, jp.getValueAsLong(9));\n+            \n+            assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+            assertEquals(0, jp.getValueAsLong());\n+            assertEquals(9, jp.getValueAsLong(9));\n+\n+            jp.close();\n+        }     \n+    }\n+\n+    /**\n+     * @since 1.7\n+     */\n+    public void testAsBoolean() throws Exception\n+    {\n+        final String input = \"[ true, false, null, 1, 0, \\\"true\\\", \\\"false\\\", \\\"foo\\\" ]\";\n+        for (int i = 0; i < 2; ++i) {\n+            JsonParser jp;\n+            if (i == 0) {\n+                jp = createParserUsingReader(input);                \n+            } else {\n+                jp = this.createParserUsingStream(input, \"UTF-8\");\n+            }\n+            assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+            assertEquals(false, jp.getValueAsBoolean());\n+            assertEquals(true, jp.getValueAsBoolean(true));\n+\n+            assertToken(JsonToken.VALUE_TRUE, jp.nextToken());\n+            assertEquals(true, jp.getValueAsBoolean());\n+            assertToken(JsonToken.VALUE_FALSE, jp.nextToken());\n+            assertEquals(false, jp.getValueAsBoolean());\n+            assertToken(JsonToken.VALUE_NULL, jp.nextToken());\n+            assertEquals(false, jp.getValueAsBoolean());\n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(1, jp.getIntValue());\n+            assertEquals(true, jp.getValueAsBoolean());\n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(0, jp.getIntValue());\n+            assertEquals(false, jp.getValueAsBoolean());\n+\n+            assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+            assertEquals(true, jp.getValueAsBoolean());\n+            assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+            assertEquals(false, jp.getValueAsBoolean());\n+            assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+            assertEquals(false, jp.getValueAsBoolean());\n+            \n+            assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+            assertEquals(false, jp.getValueAsBoolean());\n+            assertEquals(true, jp.getValueAsBoolean(true));\n+\n+            jp.close();\n+        }     \n+    }\n+    \n+    public void testAsLong() throws Exception\n+    {\n+        final String input = \"[ 1, -3, 4.98, true, false, null, \\\"-17\\\", \\\"foo\\\" ]\";\n+        for (int i = 0; i < 2; ++i) {\n+            JsonParser jp;\n+            if (i == 0) {\n+                jp = createParserUsingReader(input);                \n+            } else {\n+                jp = this.createParserUsingStream(input, \"UTF-8\");\n+            }\n+            assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+            assertEquals(0L, jp.getValueAsLong());\n+            assertEquals(9L, jp.getValueAsLong(9L));\n+\n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(1L, jp.getValueAsLong());\n+            assertEquals(1L, jp.getValueAsLong(-99L));\n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(-3L, jp.getValueAsLong());\n+            assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+            assertEquals(4L, jp.getValueAsLong());\n+            assertEquals(4L, jp.getValueAsLong(99L));\n+            assertToken(JsonToken.VALUE_TRUE, jp.nextToken());\n+            assertEquals(1L, jp.getValueAsLong());\n+            assertToken(JsonToken.VALUE_FALSE, jp.nextToken());\n+            assertEquals(0L, jp.getValueAsLong());\n+            assertToken(JsonToken.VALUE_NULL, jp.nextToken());\n+            assertEquals(0L, jp.getValueAsLong());\n+            assertEquals(0L, jp.getValueAsLong(27L));\n+            assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+            assertEquals(-17L, jp.getValueAsLong());\n+            assertEquals(-17L, jp.getValueAsLong(3L));\n+            assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+            assertEquals(0L, jp.getValueAsLong());\n+            assertEquals(9L, jp.getValueAsLong(9L));\n+            \n+            assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+            assertEquals(0L, jp.getValueAsLong());\n+            assertEquals(9L, jp.getValueAsLong(9L));\n+\n+            jp.close();\n+        }     \n+    }\n+\n+    public void testAsDouble() throws Exception\n+    {\n+        final String input = \"[ 1, -3, 4.98, true, false, null, \\\"-17.25\\\", \\\"foo\\\" ]\";\n+        for (int i = 0; i < 2; ++i) {\n+            JsonParser jp;\n+            if (i == 0) {\n+                jp = createParserUsingReader(input);                \n+            } else {\n+                jp = this.createParserUsingStream(input, \"UTF-8\");\n+            }\n+            assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+            assertEquals(0.0, jp.getValueAsDouble());\n+            assertEquals(9.0, jp.getValueAsDouble(9.0));\n+\n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(1., jp.getValueAsDouble());\n+            assertEquals(1., jp.getValueAsDouble(-99.0));\n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(-3., jp.getValueAsDouble());\n+            assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+            assertEquals(4.98, jp.getValueAsDouble());\n+            assertEquals(4.98, jp.getValueAsDouble(12.5));\n+            assertToken(JsonToken.VALUE_TRUE, jp.nextToken());\n+            assertEquals(1.0, jp.getValueAsDouble());\n+            assertToken(JsonToken.VALUE_FALSE, jp.nextToken());\n+            assertEquals(0.0, jp.getValueAsDouble());\n+            assertToken(JsonToken.VALUE_NULL, jp.nextToken());\n+            assertEquals(0.0, jp.getValueAsDouble());\n+            assertEquals(0.0, jp.getValueAsDouble(27.8));\n+            assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+            assertEquals(-17.25, jp.getValueAsDouble());\n+            assertEquals(-17.25, jp.getValueAsDouble(1.9));\n+            assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+            assertEquals(0.0, jp.getValueAsDouble());\n+            assertEquals(1.25, jp.getValueAsDouble(1.25));\n+            \n+            assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+            assertEquals(0.0, jp.getValueAsDouble());\n+            assertEquals(7.5, jp.getValueAsDouble(7.5));\n+\n+            jp.close();\n+        }     \n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestWithTonsaSymbols.java\n+package com.fasterxml.jackson.core.json;\n+\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.test.BaseTest;\n+\n+import java.io.*;\n+\n+/**\n+ * Some unit tests to try to exercise part of parser code that\n+ * deals with symbol (table) management.\n+ */\n+public class TestWithTonsaSymbols\n+    extends BaseTest\n+{\n+    /**\n+     * How many fields to generate? Since maximum symbol table\n+     * size is defined as 6000 (above which table gets cleared,\n+     * assuming the name vocabulary is unbounded), let's do something\n+     * just slightly below it.\n+     */\n+    final static int FIELD_COUNT = 5000;\n+\n+    public void testStreamReaderParser() throws Exception\n+    {\n+        _testWith(true);\n+    }\n+\n+    public void testReaderParser() throws Exception\n+    {\n+        _testWith(false);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    private void _testWith(boolean useStream)\n+        throws Exception\n+    {\n+        JsonFactory jf = new JsonFactory();\n+        String doc = buildDoc(FIELD_COUNT);\n+\n+        /* And let's do this multiple times: just so that symbol table\n+         * state is different between runs.\n+         */\n+        for (int x = 0; x < 3; ++x) {\n+            JsonParser jp = useStream ?\n+                jf.createParser(new ByteArrayInputStream(doc.getBytes(\"UTF-8\")))\n+                : jf.createParser(new StringReader(doc));\n+            assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+            for (int i = 0; i < FIELD_COUNT; ++i) {\n+                assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+                assertEquals(fieldNameFor(i), jp.getCurrentName());\n+                assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+                assertEquals(i, jp.getIntValue());\n+            }\n+            assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+            jp.close();\n+        }\n+    }\n+        \n+    private String buildDoc(int len)\n+    {\n+        StringBuilder sb = new StringBuilder(len * 12);\n+        sb.append('{');\n+        for (int i = 0; i < len; ++i) {\n+            if (i > 0) {\n+                sb.append(',');\n+            }\n+            sb.append('\"');\n+            fieldNameFor(sb, i);\n+            sb.append('\"');\n+            sb.append(':');\n+            sb.append(i);\n+        }\n+        sb.append('}');\n+        return sb.toString();\n+    }\n+}", "timestamp": 1370549588, "metainfo": ""}