{"sha": "dfd690999fcdde88cd9045d4e87871b564176fff", "log": "Add skeletal FilteringParserDelegate, to (eventually) add filtering on parser too", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n     /* Minimal generally useful state\n     /**********************************************************\n      */\n-    \n+\n     /**\n      * Last token retrieved via {@link #nextToken}, if any.\n      * Null before the first call to <code>nextToken()</code>,\n         }\n     }\n \n-    /**\n-     * @param bindex Relative index within base64 character unit; between 0\n-     *   and 3 (as unit has exactly 4 characters)\n-     *   \n-     * @deprecated in 2.2.3; should migrate away\n-     */\n-    @Deprecated\n-    protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg)\n-        throws JsonParseException\n-    {\n-        String base;\n-        if (ch <= INT_SPACE) {\n-            base = \"Illegal white space character (code 0x\"+Integer.toHexString(ch)+\") as character #\"+(bindex+1)+\" of 4-char base64 unit: can only used between units\";\n-        } else if (b64variant.usesPaddingChar(ch)) {\n-            base = \"Unexpected padding character ('\"+b64variant.getPaddingChar()+\"') as character #\"+(bindex+1)+\" of 4-char base64 unit: padding only legal as 3rd or 4th character\";\n-        } else if (!Character.isDefined(ch) || Character.isISOControl(ch)) {\n-            // Not sure if we can really get here... ? (most illegal xml chars are caught at lower level)\n-            base = \"Illegal character (code 0x\"+Integer.toHexString(ch)+\") in base64 content\";\n-        } else {\n-            base = \"Illegal character '\"+ch+\"' (code 0x\"+Integer.toHexString(ch)+\") in base64 content\";\n-        }\n-        if (msg != null) {\n-            base = base + \": \" + msg;\n-        }\n-        throw _constructError(base);\n-    }\n-\n-    /**\n-     *   \n-     * @deprecated in 2.2.3; should migrate away\n-     */\n-    @Deprecated\n-    protected void _reportBase64EOF() throws JsonParseException {\n-        throw _constructError(\"Unexpected end-of-String in base64 content\");\n-    }\n-\n     /*\n     /**********************************************************\n     /* Coercion helper methods (overridable)\n--- a/src/main/java/com/fasterxml/jackson/core/filter/FilteringGeneratorDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/FilteringGeneratorDelegate.java\n     \n     /*\n     /**********************************************************\n-    /* Construction, initialization\n+    /* Additional state\n     /**********************************************************\n      */\n \n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java\n+package com.fasterxml.jackson.core.filter;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.util.JsonParserDelegate;\n+\n+/**\n+ * Specialized {@link JsonParserDelegate} that allows use of\n+ * {@link TokenFilter} for outputting a subset of content that\n+ * is visible to caller\n+ * \n+ * @since 2.6\n+ */\n+public class FilteringParserDelegate extends JsonParserDelegate\n+{\n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Object consulted to determine whether to write parts of content generator\n+     * is asked to write or not.\n+     */\n+    protected TokenFilter rootFilter;\n+\n+    /**\n+     * Flag that determines whether filtering will continue after the first\n+     * match is indicated or not: if `false`, output is based on just the first\n+     * full match (returning {@link TokenFilter#INCLUDE_ALL}) and no more\n+     * checks are made; if `true` then filtering will be applied as necessary\n+     * until end of content.\n+     */\n+    protected boolean _allowMultipleMatches;\n+\n+    /**\n+     * Flag that determines whether path leading up to included content should\n+     * also be automatically included or not. If `false`, no path inclusion is\n+     * done and only explicitly included entries are output; if `true` then\n+     * path from main level down to match is also included as necessary.\n+     */\n+    protected boolean _includePath;\n+    \n+    /*\n+    /**********************************************************\n+    /* State\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Last token retrieved via {@link #nextToken}, if any.\n+     * Null before the first call to <code>nextToken()</code>,\n+     * as well as if token has been explicitly cleared\n+     */\n+    protected JsonToken _currToken;\n+\n+    /**\n+     * Last cleared token, if any: that is, value that was in\n+     * effect when {@link #clearCurrentToken} was called.\n+     */\n+    protected JsonToken _lastClearedToken;\n+    \n+    /**\n+     * Although delegate has its own output context it is not sufficient since we actually\n+     * have to keep track of excluded (filtered out) structures as well as ones delegate\n+     * actually outputs.\n+     */\n+    protected TokenFilterContext _filterContext;\n+\n+    /**\n+     * State that applies to the item within container, used where applicable.\n+     * Specifically used to pass inclusion state between property name and\n+     * property, and also used for array elements.\n+     */\n+    protected TokenFilter _itemFilter;\n+    \n+    /**\n+     * Number of tokens for which {@link TokenFilter#INCLUDE_ALL}\n+     * has been returned\n+     */\n+    protected int _matchCount;\n+\n+    /*\n+    /**********************************************************\n+    /* Construction, initialization\n+    /**********************************************************\n+     */\n+\n+    public FilteringParserDelegate(JsonParser p, TokenFilter f,\n+            boolean includePath, boolean allowMultipleMatches)\n+    {\n+        super(p);\n+        rootFilter = f;\n+        // and this is the currently active filter for root values\n+        _itemFilter = f;\n+        _filterContext = TokenFilterContext.createRootContext(f);\n+        _includePath = includePath;\n+        _allowMultipleMatches = allowMultipleMatches;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended API\n+    /**********************************************************\n+     */\n+\n+    public TokenFilter getFilter() { return rootFilter; }\n+\n+    /**\n+     * Accessor for finding number of matches, where specific token and sub-tree\n+     * starting (if structured type) are passed.\n+     */\n+    public int getMatchCount() {\n+        return _matchCount;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, token accessors\n+    /**********************************************************\n+     */\n+\n+    @Override public JsonToken getCurrentToken() { return _currToken; }\n+\n+    @Override public final int getCurrentTokenId() {\n+        final JsonToken t = _currToken;\n+        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n+    }\n+\n+    @Override public boolean hasCurrentToken() { return _currToken != null; }\n+    @Override public boolean hasTokenId(int id) {\n+        final JsonToken t = _currToken;\n+        if (t == null) {\n+            return (JsonTokenId.ID_NO_TOKEN == id);\n+        }\n+        return t.id() == id;\n+    }\n+\n+    @Override public final boolean hasToken(JsonToken t) {\n+        return (_currToken == t);\n+    }\n+    \n+    @Override public boolean isExpectedStartArrayToken() { return _currToken == JsonToken.START_ARRAY; }\n+    @Override public boolean isExpectedStartObjectToken() { return _currToken == JsonToken.START_OBJECT; }\n+\n+    @Override public JsonLocation getCurrentLocation() { return delegate.getCurrentLocation(); }\n+    @Override public JsonStreamContext getParsingContext() { return _filterContext; }\n+\n+    // !!! TODO: not necessarily correct...\n+    @Override public String getCurrentName() throws IOException { return delegate.getCurrentName(); }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, token state overrides\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void clearCurrentToken() {\n+        if (_currToken != null) {\n+            _lastClearedToken = _currToken;\n+            _currToken = null;\n+        }\n+    }\n+\n+    @Override\n+    public JsonToken getLastClearedToken() { return _lastClearedToken; }\n+\n+    // !!! TODO: re-implement\n+    @Override\n+    public void overrideCurrentName(String name) { delegate.overrideCurrentName(name); }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, traversal\n+    /**********************************************************\n+     */\n+\n+    // !!! TODO: re-implement\n+    @Override public JsonToken nextToken() throws IOException { return delegate.nextToken(); }\n+\n+    @Override\n+    public JsonToken nextValue() throws IOException {\n+        // Re-implemented same as ParserMinimalBase:\n+        JsonToken t = nextToken();\n+        if (t == JsonToken.FIELD_NAME) {\n+            t = nextToken();\n+        }\n+        return t;\n+    }\n+\n+    /**\n+     * Need to override, re-implement similar to how method defined in\n+     * {@link com.fasterxml.jackson.core.base.ParserMinimalBase}, to keep\n+     * state correct here.\n+     */\n+    @Override\n+    public JsonParser skipChildren() throws IOException\n+    {\n+        if (_currToken != JsonToken.START_OBJECT\n+            && _currToken != JsonToken.START_ARRAY) {\n+            return this;\n+        }\n+        int open = 1;\n+\n+        // Since proper matching of start/end markers is handled\n+        // by nextToken(), we'll just count nesting levels here\n+        while (true) {\n+            JsonToken t = nextToken();\n+            if (t == null) { // not ideal but for now, just return\n+                return this;\n+            }\n+            if (t.isStructStart()) {\n+                ++open;\n+            } else if (t.isStructEnd()) {\n+                if (--open == 0) {\n+                    return this;\n+                }\n+            }\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, access to token information, text\n+    /**********************************************************\n+     */\n+\n+    @Override public String getText() throws IOException { return delegate.getText();  }\n+    @Override public boolean hasTextCharacters() { return delegate.hasTextCharacters(); }\n+    @Override public char[] getTextCharacters() throws IOException { return delegate.getTextCharacters(); }\n+    @Override public int getTextLength() throws IOException { return delegate.getTextLength(); }\n+    @Override public int getTextOffset() throws IOException { return delegate.getTextOffset(); }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, access to token information, numeric\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public BigInteger getBigIntegerValue() throws IOException { return delegate.getBigIntegerValue(); }\n+\n+    @Override\n+    public boolean getBooleanValue() throws IOException { return delegate.getBooleanValue(); }\n+    \n+    @Override\n+    public byte getByteValue() throws IOException { return delegate.getByteValue(); }\n+\n+    @Override\n+    public short getShortValue() throws IOException { return delegate.getShortValue(); }\n+\n+    @Override\n+    public BigDecimal getDecimalValue() throws IOException { return delegate.getDecimalValue(); }\n+\n+    @Override\n+    public double getDoubleValue() throws IOException { return delegate.getDoubleValue(); }\n+\n+    @Override\n+    public float getFloatValue() throws IOException { return delegate.getFloatValue(); }\n+\n+    @Override\n+    public int getIntValue() throws IOException { return delegate.getIntValue(); }\n+\n+    @Override\n+    public long getLongValue() throws IOException { return delegate.getLongValue(); }\n+\n+    @Override\n+    public NumberType getNumberType() throws IOException { return delegate.getNumberType(); }\n+\n+    @Override\n+    public Number getNumberValue() throws IOException { return delegate.getNumberValue(); }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, access to token information, coercion/conversion\n+    /**********************************************************\n+     */\n+    \n+    @Override public int getValueAsInt() throws IOException { return delegate.getValueAsInt(); }\n+    @Override public int getValueAsInt(int defaultValue) throws IOException { return delegate.getValueAsInt(defaultValue); }\n+    @Override public long getValueAsLong() throws IOException { return delegate.getValueAsLong(); }\n+    @Override public long getValueAsLong(long defaultValue) throws IOException { return delegate.getValueAsLong(defaultValue); }\n+    @Override public double getValueAsDouble() throws IOException { return delegate.getValueAsDouble(); }\n+    @Override public double getValueAsDouble(double defaultValue) throws IOException { return delegate.getValueAsDouble(defaultValue); }\n+    @Override public boolean getValueAsBoolean() throws IOException { return delegate.getValueAsBoolean(); }\n+    @Override public boolean getValueAsBoolean(boolean defaultValue) throws IOException { return delegate.getValueAsBoolean(defaultValue); }\n+    @Override public String getValueAsString() throws IOException { return delegate.getValueAsString(); }\n+    @Override public String getValueAsString(String defaultValue) throws IOException { return delegate.getValueAsString(defaultValue); }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, access to token values, other\n+    /**********************************************************\n+     */\n+\n+    @Override public Object getEmbeddedObject() throws IOException { return delegate.getEmbeddedObject(); }\n+    @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { return delegate.getBinaryValue(b64variant); }\n+    @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { return delegate.readBinaryValue(b64variant, out); }\n+    @Override public JsonLocation getTokenLocation() { return delegate.getTokenLocation(); }\n+}\n--- a/src/main/java/com/fasterxml/jackson/core/util/JsonParserDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonParserDelegate.java\n     @Override public boolean hasTokenId(int id) { return delegate.hasTokenId(id); }\n     @Override public boolean hasToken(JsonToken t) { return delegate.hasToken(t); }\n \n-    @Override public String getCurrentName() throws IOException, JsonParseException { return delegate.getCurrentName(); }\n+    @Override public String getCurrentName() throws IOException { return delegate.getCurrentName(); }\n     @Override public JsonLocation getCurrentLocation() { return delegate.getCurrentLocation(); }\n     @Override public JsonStreamContext getParsingContext() { return delegate.getParsingContext(); }\n     @Override public boolean isExpectedStartArrayToken() { return delegate.isExpectedStartArrayToken(); }\n     /**********************************************************\n      */\n \n-    @Override public String getText() throws IOException, JsonParseException { return delegate.getText();  }\n+    @Override public String getText() throws IOException { return delegate.getText();  }\n     @Override public boolean hasTextCharacters() { return delegate.hasTextCharacters(); }\n-    @Override public char[] getTextCharacters() throws IOException, JsonParseException { return delegate.getTextCharacters(); }\n-    @Override public int getTextLength() throws IOException, JsonParseException { return delegate.getTextLength(); }\n-    @Override public int getTextOffset() throws IOException, JsonParseException { return delegate.getTextOffset(); }\n+    @Override public char[] getTextCharacters() throws IOException { return delegate.getTextCharacters(); }\n+    @Override public int getTextLength() throws IOException { return delegate.getTextLength(); }\n+    @Override public int getTextOffset() throws IOException { return delegate.getTextOffset(); }\n \n     /*\n     /**********************************************************\n      */\n     \n     @Override\n-    public BigInteger getBigIntegerValue() throws IOException,JsonParseException { return delegate.getBigIntegerValue(); }\n-\n-    @Override\n-    public boolean getBooleanValue() throws IOException, JsonParseException { return delegate.getBooleanValue(); }\n-    \n-    @Override\n-    public byte getByteValue() throws IOException, JsonParseException { return delegate.getByteValue(); }\n-\n-    @Override\n-    public short getShortValue() throws IOException, JsonParseException { return delegate.getShortValue(); }\n-\n-    @Override\n-    public BigDecimal getDecimalValue() throws IOException, JsonParseException { return delegate.getDecimalValue(); }\n-\n-    @Override\n-    public double getDoubleValue() throws IOException, JsonParseException { return delegate.getDoubleValue(); }\n-\n-    @Override\n-    public float getFloatValue() throws IOException, JsonParseException { return delegate.getFloatValue(); }\n-\n-    @Override\n-    public int getIntValue() throws IOException, JsonParseException { return delegate.getIntValue(); }\n-\n-    @Override\n-    public long getLongValue() throws IOException, JsonParseException { return delegate.getLongValue(); }\n-\n-    @Override\n-    public NumberType getNumberType() throws IOException, JsonParseException { return delegate.getNumberType(); }\n-\n-    @Override\n-    public Number getNumberValue() throws IOException, JsonParseException { return delegate.getNumberValue(); }\n+    public BigInteger getBigIntegerValue() throws IOException { return delegate.getBigIntegerValue(); }\n+\n+    @Override\n+    public boolean getBooleanValue() throws IOException { return delegate.getBooleanValue(); }\n+    \n+    @Override\n+    public byte getByteValue() throws IOException { return delegate.getByteValue(); }\n+\n+    @Override\n+    public short getShortValue() throws IOException { return delegate.getShortValue(); }\n+\n+    @Override\n+    public BigDecimal getDecimalValue() throws IOException { return delegate.getDecimalValue(); }\n+\n+    @Override\n+    public double getDoubleValue() throws IOException { return delegate.getDoubleValue(); }\n+\n+    @Override\n+    public float getFloatValue() throws IOException { return delegate.getFloatValue(); }\n+\n+    @Override\n+    public int getIntValue() throws IOException { return delegate.getIntValue(); }\n+\n+    @Override\n+    public long getLongValue() throws IOException { return delegate.getLongValue(); }\n+\n+    @Override\n+    public NumberType getNumberType() throws IOException { return delegate.getNumberType(); }\n+\n+    @Override\n+    public Number getNumberValue() throws IOException { return delegate.getNumberValue(); }\n \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n     \n-    @Override public int getValueAsInt() throws IOException, JsonParseException { return delegate.getValueAsInt(); }\n-    @Override public int getValueAsInt(int defaultValue) throws IOException, JsonParseException { return delegate.getValueAsInt(defaultValue); }\n-    @Override public long getValueAsLong() throws IOException, JsonParseException { return delegate.getValueAsLong(); }\n-    @Override public long getValueAsLong(long defaultValue) throws IOException, JsonParseException { return delegate.getValueAsLong(defaultValue); }\n-    @Override public double getValueAsDouble() throws IOException, JsonParseException { return delegate.getValueAsDouble(); }\n-    @Override public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException { return delegate.getValueAsDouble(defaultValue); }\n-    @Override public boolean getValueAsBoolean() throws IOException, JsonParseException { return delegate.getValueAsBoolean(); }\n-    @Override public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException { return delegate.getValueAsBoolean(defaultValue); }\n-    @Override public String getValueAsString() throws IOException, JsonParseException { return delegate.getValueAsString(); }\n-    @Override public String getValueAsString(String defaultValue) throws IOException, JsonParseException { return delegate.getValueAsString(defaultValue); }\n+    @Override public int getValueAsInt() throws IOException { return delegate.getValueAsInt(); }\n+    @Override public int getValueAsInt(int defaultValue) throws IOException { return delegate.getValueAsInt(defaultValue); }\n+    @Override public long getValueAsLong() throws IOException { return delegate.getValueAsLong(); }\n+    @Override public long getValueAsLong(long defaultValue) throws IOException { return delegate.getValueAsLong(defaultValue); }\n+    @Override public double getValueAsDouble() throws IOException { return delegate.getValueAsDouble(); }\n+    @Override public double getValueAsDouble(double defaultValue) throws IOException { return delegate.getValueAsDouble(defaultValue); }\n+    @Override public boolean getValueAsBoolean() throws IOException { return delegate.getValueAsBoolean(); }\n+    @Override public boolean getValueAsBoolean(boolean defaultValue) throws IOException { return delegate.getValueAsBoolean(defaultValue); }\n+    @Override public String getValueAsString() throws IOException { return delegate.getValueAsString(); }\n+    @Override public String getValueAsString(String defaultValue) throws IOException { return delegate.getValueAsString(defaultValue); }\n     \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n \n-    @Override public Object getEmbeddedObject() throws IOException, JsonParseException { return delegate.getEmbeddedObject(); }\n-    @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { return delegate.getBinaryValue(b64variant); }\n-    @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException { return delegate.readBinaryValue(b64variant, out); }\n+    @Override public Object getEmbeddedObject() throws IOException { return delegate.getEmbeddedObject(); }\n+    @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { return delegate.getBinaryValue(b64variant); }\n+    @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { return delegate.readBinaryValue(b64variant, out); }\n     @Override public JsonLocation getTokenLocation() { return delegate.getTokenLocation(); }\n-    @Override public JsonToken nextToken() throws IOException, JsonParseException { return delegate.nextToken(); }\n-    @Override public JsonToken nextValue() throws IOException, JsonParseException { return delegate.nextValue(); }\n-    \n-    @Override\n-    public JsonParser skipChildren() throws IOException, JsonParseException {\n+    @Override public JsonToken nextToken() throws IOException { return delegate.nextToken(); }\n+    @Override public JsonToken nextValue() throws IOException { return delegate.nextValue(); }\n+    \n+    @Override\n+    public JsonParser skipChildren() throws IOException {\n         delegate.skipChildren();\n         // NOTE: must NOT delegate this method to delegate, needs to be self-reference for chaining\n         return this;\n \n     @Override public boolean canReadObjectId() { return delegate.canReadObjectId(); }\n     @Override public boolean canReadTypeId() { return delegate.canReadTypeId(); }\n-    @Override public Object getObjectId() throws IOException, JsonGenerationException { return delegate.getObjectId(); }\n-    @Override public Object getTypeId() throws IOException, JsonGenerationException { return delegate.getTypeId(); }\n+    @Override public Object getObjectId() throws IOException { return delegate.getObjectId(); }\n+    @Override public Object getTypeId() throws IOException { return delegate.getTypeId(); }\n }", "timestamp": 1428643774, "metainfo": ""}