{"sha": "ba50df6cdf93201aa49d152ddec42d13c25ba1f6", "log": "Merge branch '2.6'  Conflicts: \tpom.xml \trelease-notes/VERSION", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/util/VersionUtil.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/VersionUtil.java\n     /**\n      * Loads version information by introspecting a class named\n      * \"PackageVersion\" in the same package as the given class.\n-     *\n+     *<p>\n      * If the class could not be found or does not have a public\n      * static Version field named \"VERSION\", returns null.\n      */\n     public static Version packageVersionFor(Class<?> cls)\n     {\n+        Version v = null;\n         try {\n             String versionInfoClassName = cls.getPackage().getName() + \".PackageVersion\";\n             Class<?> vClass = Class.forName(versionInfoClassName, true, cls.getClassLoader());\n             // However, if class exists, it better work correctly, no swallowing exceptions\n             try {\n-                return ((Versioned) vClass.newInstance()).version();\n+                v = ((Versioned) vClass.newInstance()).version();\n             } catch (Exception e) {\n                 throw new IllegalArgumentException(\"Failed to get Versioned out of \"+vClass);\n             }\n         } catch (Exception e) { // ok to be missing (not good but acceptable)\n-            return null;\n+            ;\n         }\n+        return (v == null) ? Version.unknownVersion() : v;\n     }\n \n     /**\n                     (parts.length > 3) ? parts[3] : null,\n                     groupId, artifactId);\n         }\n-        return null;\n+        return Version.unknownVersion();\n     }\n \n     protected static int parseVersionPart(String s) {\n--- a/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n      */\n     protected final transient ByteQuadsCanonicalizer _byteSymbolCanonicalizer = ByteQuadsCanonicalizer.createRoot();\n \n-    /**\n-     * Earlier byte-based symbol table; replaced with 2.6 with a new implementation.\n-     * Left in for version 2.6.0: will be removed in 2.7 or later.\n-     *\n-     * @deprecated Since 2.6.0, only use {@link #_byteSymbolCanonicalizer}\n-     */\n-    @Deprecated\n-    protected final transient com.fasterxml.jackson.core.sym.BytesToNameCanonicalizer _rootByteSymbols\n-        = com.fasterxml.jackson.core.sym.BytesToNameCanonicalizer.createRoot();\n-\n     /*\n     /**********************************************************\n     /* Configuration\n \n     /**\n      * Method for constructing JSON parser instance to parse\n-     * contents of specified file. Encoding is auto-detected\n-     * from contents according to JSON specification recommended\n-     * mechanism.\n+     * contents of specified file.\n+     *\n+     *<p>\n+     * Encoding is auto-detected from contents according to JSON\n+     * specification recommended mechanism. Json specification\n+     * supports only UTF-8, UTF-16 and UTF-32 as valid encodings,\n+     * so auto-detection implemented only for this charsets.\n+     * For other charsets use {@link #createParser(java.io.Reader)}.\n+     *\n      *<p>\n      * Underlying input stream (needed for reading contents)\n      * will be <b>owned</b> (and managed, i.e. closed as need be) by\n     /**\n      * Method for constructing JSON parser instance to parse\n      * contents of resource reference by given URL.\n-     * Encoding is auto-detected\n-     * from contents according to JSON specification recommended\n-     * mechanism.\n+     *\n+     *<p>\n+     * Encoding is auto-detected from contents according to JSON\n+     * specification recommended mechanism. Json specification\n+     * supports only UTF-8, UTF-16 and UTF-32 as valid encodings,\n+     * so auto-detection implemented only for this charsets.\n+     * For other charsets use {@link #createParser(java.io.Reader)}.\n+     *\n      *<p>\n      * Underlying input stream (needed for reading contents)\n      * will be <b>owned</b> (and managed, i.e. closed as need be) by\n      * if (and only if) {@link com.fasterxml.jackson.core.JsonParser.Feature#AUTO_CLOSE_SOURCE}\n      * is enabled.\n      *<p>\n+     *\n      * Note: no encoding argument is taken since it can always be\n-     * auto-detected as suggested by JSON RFC.\n+     * auto-detected as suggested by JSON RFC. Json specification\n+     * supports only UTF-8, UTF-16 and UTF-32 as valid encodings,\n+     * so auto-detection implemented only for this charsets.\n+     * For other charsets use {@link #createParser(java.io.Reader)}.\n      *\n      * @param in InputStream to use for reading JSON content to parse\n      * \n \n     /*\n     /**********************************************************\n-    /* Parser factories (old ones, as per [Issue-25])\n+    /* Parser factories (old ones, pre-2.2)\n     /**********************************************************\n      */\n \n     /**\n      * Method for constructing JSON parser instance to parse\n-     * contents of specified file. Encoding is auto-detected\n-     * from contents according to JSON specification recommended\n-     * mechanism.\n+     * contents of specified file.\n+     *<p>\n+     * Encoding is auto-detected from contents according to JSON\n+     * specification recommended mechanism. Json specification\n+     * supports only UTF-8, UTF-16 and UTF-32 as valid encodings,\n+     * so auto-detection implemented only for this charsets.\n+     * For other charsets use {@link #createParser(java.io.Reader)}.\n+     *\n      *<p>\n      * Underlying input stream (needed for reading contents)\n      * will be <b>owned</b> (and managed, i.e. closed as need be) by\n     /**\n      * Method for constructing JSON parser instance to parse\n      * contents of resource reference by given URL.\n-     * Encoding is auto-detected\n-     * from contents according to JSON specification recommended\n-     * mechanism.\n+     *\n+     *<p>\n+     * Encoding is auto-detected from contents according to JSON\n+     * specification recommended mechanism. Json specification\n+     * supports only UTF-8, UTF-16 and UTF-32 as valid encodings,\n+     * so auto-detection implemented only for this charsets.\n+     * For other charsets use {@link #createParser(java.io.Reader)}.\n+     *\n      *<p>\n      * Underlying input stream (needed for reading contents)\n      * will be <b>owned</b> (and managed, i.e. closed as need be) by\n      * if (and only if) {@link com.fasterxml.jackson.core.JsonParser.Feature#AUTO_CLOSE_SOURCE}\n      * is enabled.\n      *<p>\n+     *\n      * Note: no encoding argument is taken since it can always be\n-     * auto-detected as suggested by JSON RFC.\n+     * auto-detected as suggested by JSON RFC. Json specification\n+     * supports only UTF-8, UTF-16 and UTF-32 as valid encodings,\n+     * so auto-detection implemented only for this charsets.\n+     * For other charsets use {@link #createParser(java.io.Reader)}.\n      *\n      * @param in InputStream to use for reading JSON content to parse\n      * \n \n     /*\n     /**********************************************************\n-    /* Generator factories, old (as per [Issue-25]\n+    /* Generator factories, old (pre-2.2)\n     /**********************************************************\n      */\n \n     public JsonGenerator createJsonGenerator(OutputStream out) throws IOException {\n         return createGenerator(out, JsonEncoding.UTF8);\n     }\n-    \n-    /**\n-     * Method for constructing JSON generator for writing JSON content\n-     * to specified file, overwriting contents it might have (or creating\n-     * it if such file does not yet exist).\n-     * Encoding to use must be specified, and needs to be one of available\n-     * types (as per JSON specification).\n-     *<p>\n-     * Underlying stream <b>is owned</b> by the generator constructed,\n-     * i.e. generator will handle closing of file when\n-     * {@link JsonGenerator#close} is called.\n-     *\n-     * @param f File to write contents to\n-     * @param enc Character encoding to use\n-     * \n-     * @deprecated Since 2.2, use {@link #createGenerator(File,JsonEncoding)} instead.\n-     */\n-    @Deprecated\n-    public JsonGenerator createJsonGenerator(File f, JsonEncoding enc) throws IOException {\n-        return createGenerator(f, enc);\n-    }\n \n     /*\n     /**********************************************************\n         }\n         return br;\n     }\n-    \n+\n     /**\n      * Overridable factory method that actually instantiates desired\n      * context object.\n     protected IOContext _createContext(Object srcRef, boolean resourceManaged) {\n         return new IOContext(_getBufferRecycler(), srcRef, resourceManaged);\n     }\n-    \n+\n     /**\n      * Helper methods used for constructing an optimal stream for\n      * parsers to use, when input is to be read from an URL.\n--- a/src/main/java/com/fasterxml/jackson/core/JsonGenerationException.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonGenerationException.java\n     extends JsonProcessingException\n {\n     private final static long serialVersionUID = 123; // Stupid eclipse...\n-    \n-    public JsonGenerationException(Throwable rootCause)\n-    {\n+\n+    protected JsonGenerator _processor;\n+\n+    @Deprecated // since 2.7\n+    public JsonGenerationException(Throwable rootCause) {\n         super(rootCause);\n     }\n \n-    public JsonGenerationException(String msg)\n-    {\n+    @Deprecated // since 2.7\n+    public JsonGenerationException(String msg) {\n         super(msg, (JsonLocation)null);\n     }\n \n-    public JsonGenerationException(String msg, Throwable rootCause)\n-    {\n+    @Deprecated // since 2.7\n+    public JsonGenerationException(String msg, Throwable rootCause) {\n         super(msg, null, rootCause);\n     }\n+\n+    /**\n+     * @since 2.7\n+     */\n+    public JsonGenerationException(Throwable rootCause, JsonGenerator g) {\n+        super(rootCause);\n+        _processor = g;\n+    }\n+\n+    /**\n+     * @since 2.7\n+     */\n+    public JsonGenerationException(String msg, JsonGenerator g) {\n+        super(msg, (JsonLocation) null);\n+        _processor = g;\n+    }\n+    \n+    /**\n+     * @since 2.7\n+     */\n+    public JsonGenerationException(String msg, Throwable rootCause, JsonGenerator g) {\n+        super(msg, null, rootCause);\n+        _processor = g;\n+    }\n+\n+    /**\n+     * Fluent method that may be used to assign originating {@link JsonGenerator},\n+     * to be accessed using {@link #getProcessor()}.\n+     *\n+     * @since 2.7\n+     */\n+    public JsonGenerationException withGenerator(JsonGenerator g) {\n+        _processor = g;\n+        return this;\n+    }\n+\n+    @Override\n+    public JsonGenerator getProcessor() { return _processor; }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n          */\n         ESCAPE_NON_ASCII(false),\n \n+// 23-Nov-2015, tatu: for [core#223], if and when it gets implemented\n+        /**\n+         * Feature that specifies handling of UTF-8 content that contains\n+         * characters beyond BMP (Basic Multilingual Plane), which are\n+         * represented in UCS-2 (Java internal character encoding) as two\n+         * \"surrogate\" characters. If feature is enabled, these surrogate\n+         * pairs are separately escaped using backslash escapes; if disabled,\n+         * native output (4-byte UTF-8 sequence, or, with char-backed output\n+         * targets, writing of surrogates as is which is typically converted\n+         * by {@link java.io.Writer} into 4-byte UTF-8 sequence eventually)\n+         * is used.\n+         *<p>\n+         * Note that the original JSON specification suggests use of escaping;\n+         * but that this is not correct from standard UTF-8 handling perspective.\n+         * Because of two competing goals, this feature was added to allow either\n+         * behavior to be used, but defaulting to UTF-8 specification compliant\n+         * mode.\n+         *<p>\n+         * Feature is disabled by default.\n+         *\n+         * @since Xxx\n+         */\n+//        ESCAPE_UTF8_SURROGATES(false),\n+        \n         // // Schema/Validity support features\n \n         /**\n \n     /**\n      * Method for accessing the object used for writing Java\n-     * object as Json content\n+     * object as JSON content\n      * (using method {@link #writeObject}).\n      */\n     public abstract ObjectCodec getCodec();\n      */\n     public abstract boolean isEnabled(Feature f);\n \n-\n     /**\n      * Bulk access method for getting state of all standard (non-dataformat-specific)\n      * {@link JsonGenerator.Feature}s.\n      *    and which disabled\n      *\n      * @return This parser object, to allow chaining of calls\n-     */\n+     *\n+     * @deprecated Since 2.7, use {@link #overrideStdFeatures(int, int)} instead\n+     */\n+    @Deprecated\n     public abstract JsonGenerator setFeatureMask(int values);\n \n     /**\n      *    int newState = (oldState &amp; ~mask) | (values &amp; mask);\n      *    setFeatureMask(newState);\n      *</code>\n+     * but preferred as this lets caller more efficiently specify actual changes made.\n      * \n      * @param values Bit mask of set/clear state for features to change\n      * @param mask Bit mask of features to change\n      * encoded, as a complete String value (surrounded by double quotes).\n      * This method defaults\n      *<p>\n-     * Note: because Json Strings can not contain unescaped linefeeds,\n+     * Note: because JSON Strings can not contain unescaped linefeeds,\n      * if linefeeds are included (as per last argument), they must be\n      * escaped. This adds overhead for decoding without improving\n      * readability.\n     public abstract void writeNumber(String encodedValue) throws IOException;\n \n     /**\n-     * Method for outputting literal Json boolean value (one of\n+     * Method for outputting literal JSON boolean value (one of\n      * Strings 'true' and 'false').\n      * Can be called in any context where a value is expected\n      * (Array value, Object field value, root-level value).\n     public abstract void writeBoolean(boolean state) throws IOException;\n \n     /**\n-     * Method for outputting literal Json null value.\n+     * Method for outputting literal JSON null value.\n      * Can be called in any context where a value is expected\n      * (Array value, Object field value, root-level value).\n      * Additional white space may be added around the value\n      * @since 2.3\n      */\n     public void writeObjectId(Object id) throws IOException {\n-        throw new JsonGenerationException(\"No native support for writing Object Ids\");\n+        throw new JsonGenerationException(\"No native support for writing Object Ids\", this);\n     }\n \n     /**\n      * a {@link JsonGenerationException} will be thrown.\n      */\n     public void writeObjectRef(Object id) throws IOException {\n-        throw new JsonGenerationException(\"No native support for writing Object Ids\");\n+        throw new JsonGenerationException(\"No native support for writing Object Ids\", this);\n     }\n     \n     /**\n      * @since 2.3\n      */\n     public void writeTypeId(Object id) throws IOException {\n-        throw new JsonGenerationException(\"No native support for writing Type Ids\");\n-    }\n-    \n+        throw new JsonGenerationException(\"No native support for writing Type Ids\", this);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Public API, write methods, serializing Java objects\n      * Method for writing given Java object (POJO) as Json.\n      * Exactly how the object gets written depends on object\n      * in question (ad on codec, its configuration); for most\n-     * beans it will result in Json object, but for others Json\n-     * array, or String or numeric value (and for nulls, Json\n+     * beans it will result in JSON Object, but for others JSON\n+     * Array, or String or numeric value (and for nulls, JSON\n      * null literal.\n      * <b>NOTE</b>: generator must have its <b>object codec</b>\n      * set to non-null value; for generators created by a mapping\n      * Method for copying contents of the current event that\n      * the given parser instance points to.\n      * Note that the method <b>will not</b> copy any other events,\n-     * such as events contained within Json Array or Object structures.\n+     * such as events contained within JSON Array or Object structures.\n      *<p>\n      * Calling this method will not advance the given\n      * parser, although it may cause parser to internally process\n      *  </li>\n      * <li>{@link JsonToken#FIELD_NAME} the logical value (which\n      *   can consist of a single scalar value; or a sequence of related\n-     *   events for structured types (Json Arrays, Objects)) will\n+     *   events for structured types (JSON Arrays, Objects)) will\n      *   be copied along with the name itself. So essentially the\n      *   whole <b>field entry</b> (name and value) will be copied.\n      *  </li>\n      * or use a {@link JsonGenerationException} sub-class.\n      */\n     protected void _reportError(String msg) throws JsonGenerationException {\n-        throw new JsonGenerationException(msg);\n+        throw new JsonGenerationException(msg, this);\n     }\n \n     protected final void _throwInternal() { VersionUtil.throwInternal(); }\n     protected void _reportUnsupportedOperation() {\n         throw new UnsupportedOperationException(\"Operation not supported by generator of type \"+getClass().getName());\n     }\n-    \n+\n     /**\n      * Helper method to try to call appropriate write method for given\n      * untyped Object. At this point, no structural conversions should be done,\n             } else if (n instanceof BigDecimal) {\n                 writeNumber((BigDecimal) n);\n                 return;\n-                \n+\n             // then Atomic types\n-                \n             } else if (n instanceof AtomicInteger) {\n                 writeNumber(((AtomicInteger) n).get());\n                 return;\n--- a/src/main/java/com/fasterxml/jackson/core/JsonParseException.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonParseException.java\n  * is encountered.\n  */\n public class JsonParseException extends JsonProcessingException {\n-    private static final long serialVersionUID = 1L;\n-    \n+    private static final long serialVersionUID = 2L; // 2.7\n+\n+    protected JsonParser _processor;\n+\n+    @Deprecated // since 2.7\n     public JsonParseException(String msg, JsonLocation loc) {\n         super(msg, loc);\n     }\n \n+    @Deprecated // since 2.7\n     public JsonParseException(String msg, JsonLocation loc, Throwable root) {\n         super(msg, loc, root);\n     }\n+\n+    /**\n+     * Constructor that uses current parsing location as location, and\n+     * sets processor (accessible via {@link #getProcessor()}) to\n+     * specified parser.\n+     *\n+     * @since 2.7\n+     */\n+    public JsonParseException(JsonParser p, String msg) {\n+        super(msg, (p == null) ? null : p.getCurrentLocation());\n+        _processor = p;\n+    }\n+\n+    /**\n+     * @since 2.7\n+     */\n+    public JsonParseException(JsonParser p, String msg, Throwable root) {\n+        super(msg, (p == null) ? null : p.getCurrentLocation(), root);\n+        _processor = p;\n+    }\n+    \n+    /**\n+     * @since 2.7\n+     */\n+    public JsonParseException(JsonParser p, String msg, JsonLocation loc) {\n+        super(msg, loc);\n+        _processor = p;\n+    }\n+\n+    /**\n+     * @since 2.7\n+     */\n+    public JsonParseException(JsonParser p, String msg, JsonLocation loc, Throwable root) {\n+        super(msg, loc, root);\n+        _processor = p;\n+    }\n+\n+    /**\n+     * Fluent method that may be used to assign originating {@link JsonParser},\n+     * to be accessed using {@link #getProcessor()}.\n+     *\n+     * @since 2.7\n+     */\n+    public JsonParseException withParser(JsonParser p) {\n+        _processor = p;\n+        return this;\n+    }\n+\n+    @Override\n+    public JsonParser getProcessor() {\n+        return _processor;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n          * Feature that determines whether parser will allow use\n          * of single quotes (apostrophe, character '\\'') for\n          * quoting Strings (names and String values). If so,\n-         * this is in addition to other acceptabl markers.\n+         * this is in addition to other acceptable markers.\n          * but not by JSON specification).\n          *<p>\n          * Since JSON specification requires use of double quotes for\n      * @return This parser object, to allow chaining of calls\n      * \n      * @since 2.3\n-     */\n+     * \n+     * @deprecated Since 2.7, use {@link #overrideStdFeatures(int, int)} instead\n+     */\n+    @Deprecated\n     public JsonParser setFeatureMask(int mask) {\n         _features = mask;\n         return this;\n      *    int newState = (oldState &amp; ~mask) | (values &amp; mask);\n      *    setFeatureMask(newState);\n      *</code>\n+     * but preferred as this lets caller more efficiently specify actual changes made.\n      * \n      * @param values Bit mask of set/clear state for features to change\n      * @param mask Bit mask of features to change\n      * @since 2.6\n      */\n     public JsonParser overrideStdFeatures(int values, int mask) {\n-        _features = (_features & ~mask) | (values & mask);\n-        return this;\n+        int newState = (_features & ~mask) | (values & mask);\n+        return setFeatureMask(newState);\n     }\n \n     /**\n         JsonToken t = getCurrentToken();\n         if (t == JsonToken.VALUE_TRUE) return true;\n         if (t == JsonToken.VALUE_FALSE) return false;\n-        throw new JsonParseException(\"Current token (\"+t+\") not of boolean type\", getCurrentLocation());\n+        throw new JsonParseException(this,\n+                String.format(\"Current token (%s) not of boolean type\", t));\n     }\n \n     /**\n      * based on current state of the parser\n      */\n     protected JsonParseException _constructError(String msg) {\n-        return new JsonParseException(msg, getCurrentLocation());\n+        return new JsonParseException(this, msg);\n     }\n \n     /**\n--- a/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\n \n     /*\n     /**********************************************************\n-    /* Cosntruction\n+    /* Construction\n     /**********************************************************\n      */\n     \n--- a/src/main/java/com/fasterxml/jackson/core/JsonProcessingException.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonProcessingException.java\n         this(null, null, rootCause);\n     }\n \n-    public JsonLocation getLocation() { return _location; }\n-\n     /*\n     /**********************************************************\n     /* Extended API\n     /**********************************************************\n      */\n \n+    public JsonLocation getLocation() { return _location; }\n+    \n     /**\n      * Method that allows accessing the original \"message\" argument,\n      * without additional decorations (like location information)\n      * @since 2.1\n      */\n     public String getOriginalMessage() { return super.getMessage(); }\n+\n+    /**\n+     * Method that allows accessing underlying processor that triggered\n+     * this exception; typically either {@link JsonParser} or {@link JsonGenerator}\n+     * for exceptions that originate from streaming API.\n+     * Note that it is possible that `null` may be returned if code throwing\n+     * exception either has no access to processor; or has not been retrofitted\n+     * to set it; this means that caller needs to take care to check for nulls.\n+     * Subtypes override this method with co-variant return type, for more\n+     * type-safe access.\n+     * \n+     * @return Originating processor, if available; null if not.\n+     *\n+     * @since 2.7\n+     */\n+    public Object getProcessor() { return null; }\n \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/core/TreeCodec.java\n+++ b/src/main/java/com/fasterxml/jackson/core/TreeCodec.java\n  */\n public abstract class TreeCodec\n {\n-    public abstract <T extends TreeNode> T readTree(JsonParser jp) throws IOException, JsonProcessingException;\n-    public abstract void writeTree(JsonGenerator jg, TreeNode tree) throws IOException, JsonProcessingException;\n+    public abstract <T extends TreeNode> T readTree(JsonParser p) throws IOException, JsonProcessingException;\n+    public abstract void writeTree(JsonGenerator g, TreeNode tree) throws IOException, JsonProcessingException;\n     public abstract TreeNode createArrayNode();\n     public abstract TreeNode createObjectNode();\n     public abstract JsonParser treeAsTokens(TreeNode node);\n--- a/src/main/java/com/fasterxml/jackson/core/Version.java\n+++ b/src/main/java/com/fasterxml/jackson/core/Version.java\n     private static final long serialVersionUID = 1L;\n \n     private final static Version UNKNOWN_VERSION = new Version(0, 0, 0, null, null, null);\n-    \n+\n     protected final int _majorVersion;\n \n     protected final int _minorVersion;\n     protected final int _patchLevel;\n \n     protected final String _groupId;\n-    \n+\n     protected final String _artifactId;\n-    \n+\n     /**\n      * Additional information for snapshot versions; null for non-snapshot\n      * (release) versions.\n     {\n         this(major, minor, patchLevel, snapshotInfo, null, null);\n     }\n-    \n+\n     public Version(int major, int minor, int patchLevel, String snapshotInfo,\n             String groupId, String artifactId)\n     {\n      */\n     public static Version unknownVersion() { return UNKNOWN_VERSION; }\n \n-    public boolean isUknownVersion() { return (this == UNKNOWN_VERSION); }\n+    /**\n+     * @since 2.7 to replace misspelled {@link #isUknownVersion()}\n+     */\n+    public boolean isUnknownVersion() { return (this == UNKNOWN_VERSION); }\n     public boolean isSnapshot() { return (_snapshotInfo != null && _snapshotInfo.length() > 0); }\n-    \n+\n+    /**\n+     * @deprecated Since 2.7 use correctly spelled method {@link #isUnknownVersion()}\n+     */\n+    @Deprecated\n+    public boolean isUknownVersion() { return isUnknownVersion(); }\n+\n     public int getMajorVersion() { return _majorVersion; }\n     public int getMinorVersion() { return _minorVersion; }\n     public int getPatchLevel() { return _patchLevel; }\n \n     public String getGroupId() { return _groupId; }\n     public String getArtifactId() { return _artifactId; }\n-    \n+\n     public String toFullString() {\n         return _groupId + '/' + _artifactId + '/' + toString();\n     }\n-    \n+\n     @Override public String toString() {\n         StringBuilder sb = new StringBuilder();\n         sb.append(_majorVersion).append('.');\n--- a/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n         return this;\n     }\n \n-    @Override public JsonGenerator setFeatureMask(int newMask) {\n+    @Override\n+    @Deprecated\n+    public JsonGenerator setFeatureMask(int newMask) {\n         int changed = newMask ^ _features;\n         _features = newMask;\n-        if ((changed & DERIVED_FEATURES_MASK) != 0) {\n-            _cfgNumbersAsStrings = Feature.WRITE_NUMBERS_AS_STRINGS.enabledIn(newMask);\n-            if (Feature.ESCAPE_NON_ASCII.enabledIn(changed)) {\n-                if (Feature.ESCAPE_NON_ASCII.enabledIn(newMask)) {\n-                    setHighestNonEscapedChar(127);\n-                } else {\n-                    setHighestNonEscapedChar(0);\n+        if (changed != 0) {\n+            _checkStdFeatureChanges(newMask, changed);\n+        }\n+        return this;\n+    }\n+\n+    @Override // since 2.7\n+    public JsonGenerator overrideStdFeatures(int values, int mask) {\n+        int oldState = _features;\n+        int newState = (oldState & ~mask) | (values & mask);\n+        int changed = oldState ^ newState;\n+        if (changed != 0) {\n+            _features = newState;\n+            _checkStdFeatureChanges(newState, changed);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Helper method called to verify changes to standard features.\n+     *\n+     * @param newFeatureFlags Bitflag of standard features after they were changed\n+     * @param changedFeatures Bitflag of standard features for which setting\n+     *    did change\n+     *\n+     * @since 2.7\n+     */\n+    protected void _checkStdFeatureChanges(int newFeatureFlags, int changedFeatures)\n+    {\n+        if ((changedFeatures & DERIVED_FEATURES_MASK) == 0) {\n+            return;\n+        }\n+        _cfgNumbersAsStrings = Feature.WRITE_NUMBERS_AS_STRINGS.enabledIn(newFeatureFlags);\n+        if (Feature.ESCAPE_NON_ASCII.enabledIn(changedFeatures)) {\n+            if (Feature.ESCAPE_NON_ASCII.enabledIn(newFeatureFlags)) {\n+                setHighestNonEscapedChar(127);\n+            } else {\n+                setHighestNonEscapedChar(0);\n+            }\n+        }\n+        if (Feature.STRICT_DUPLICATE_DETECTION.enabledIn(changedFeatures)) {\n+            if (Feature.STRICT_DUPLICATE_DETECTION.enabledIn(newFeatureFlags)) { // enabling\n+                if (_writeContext.getDupDetector() == null) { // but only if disabled currently\n+                    _writeContext = _writeContext.withDupDetector(DupDetector.rootDetector(this));\n                 }\n-            }\n-            if (Feature.STRICT_DUPLICATE_DETECTION.enabledIn(changed)) {\n-                if (Feature.STRICT_DUPLICATE_DETECTION.enabledIn(newMask)) { // enabling\n-                    if (_writeContext.getDupDetector() == null) { // but only if disabled currently\n-                        _writeContext = _writeContext.withDupDetector(DupDetector.rootDetector(this));\n-                    }\n-                } else { // disabling\n-                    _writeContext = _writeContext.withDupDetector(null);\n-                }\n-            }\n-        }\n-        return this;\n+            } else { // disabling\n+                _writeContext = _writeContext.withDupDetector(null);\n+            }\n+        }\n     }\n     \n     @Override public JsonGenerator useDefaultPrettyPrinter() {\n-        /* 28-Sep-2012, tatu: As per [Issue#84], should not override a\n-         *  pretty printer if one already assigned.\n-         */\n+        // Should not override a pretty printer if one already assigned.\n         if (getPrettyPrinter() != null) {\n             return this;\n         }\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n     /**\n      * Pointer to next available character in buffer\n      */\n-    protected int _inputPtr = 0;\n+    protected int _inputPtr;\n \n     /**\n      * Index of character after last available one in the buffer.\n      */\n-    protected int _inputEnd = 0;\n+    protected int _inputEnd;\n \n     /*\n     /**********************************************************\n      * Number of characters/bytes that were contained in previous blocks\n      * (blocks that were already processed prior to the current buffer).\n      */\n-    protected long _currInputProcessed = 0L;\n+    protected long _currInputProcessed;\n \n     /**\n      * Current row location of current point in input buffer, starting\n      * of not having column itself is that this only has to be updated\n      * once per line.\n      */\n-    protected int _currInputRowStart = 0;\n+    protected int _currInputRowStart;\n \n     /*\n     /**********************************************************\n      * For big (gigabyte-sized) sizes are possible, needs to be long,\n      * unlike pointers and sizes related to in-memory buffers.\n      */\n-    protected long _tokenInputTotal = 0; \n+    protected long _tokenInputTotal;\n \n     /**\n      * Input row on which current token starts, 1-based\n      * Column on input row that current token starts; 0-based (although\n      * in the end it'll be converted to 1-based)\n      */\n-    protected int _tokenInputCol = 0;\n+    protected int _tokenInputCol;\n \n     /*\n     /**********************************************************\n      * using {@link #getTextCharacters} method (instead of String\n      * returning alternatives)\n      */\n-    protected char[] _nameCopyBuffer = null;\n+    protected char[] _nameCopyBuffer;\n \n     /**\n      * Flag set to indicate whether the field name is available\n      * from the name copy buffer or not (in addition to its String\n      * representation  being available via read context)\n      */\n-    protected boolean _nameCopied = false;\n+    protected boolean _nameCopied;\n \n     /**\n      * ByteArrayBuilder is needed if 'getBinaryValue' is called. If so,\n      * we better reuse it for remainder of content.\n      */\n-    protected ByteArrayBuilder _byteArrayBuilder = null;\n+    protected ByteArrayBuilder _byteArrayBuilder;\n \n     /**\n      * We will hold on to decoded binary data, for duration of\n         }\n         return this;\n     }\n-    \n-    @Override\n+\n+    @Override\n+    @Deprecated\n     public JsonParser setFeatureMask(int newMask) {\n         int changes = (_features ^ newMask);\n         if (changes != 0) {\n             _features = newMask;\n-            if (Feature.STRICT_DUPLICATE_DETECTION.enabledIn(newMask)) { // enabling\n-                if (_parsingContext.getDupDetector() == null) { // but only if disabled currently\n+            _checkStdFeatureChanges(newMask, changes);\n+        }\n+        return this;\n+    }\n+\n+    @Override // since 2.7\n+    public JsonParser overrideStdFeatures(int values, int mask) {\n+        int oldState = _features;\n+        int newState = (oldState & ~mask) | (values & mask);\n+        int changed = oldState ^ newState;\n+        if (changed != 0) {\n+            _features = newState;\n+            _checkStdFeatureChanges(newState, changed);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Helper method called to verify changes to standard features.\n+     *\n+     * @param newFeatureFlags Bitflag of standard features after they were changed\n+     * @param changedFeatures Bitflag of standard features for which setting\n+     *    did change\n+     *\n+     * @since 2.7\n+     */\n+    protected void _checkStdFeatureChanges(int newFeatureFlags, int changedFeatures)\n+    {\n+        int f = Feature.STRICT_DUPLICATE_DETECTION.getMask();\n+        \n+        if ((changedFeatures & f) != 0) {\n+            if ((newFeatureFlags & f) != 0) {\n+                if (_parsingContext.getDupDetector() == null) {\n                     _parsingContext = _parsingContext.withDupDetector(DupDetector.rootDetector(this));\n+                } else { // disabling\n+                    _parsingContext = _parsingContext.withDupDetector(null);\n                 }\n-            } else { // disabling\n-                _parsingContext = _parsingContext.withDupDetector(null);\n-            }\n-        }\n-        return this;\n-    }\n-    \n+            }\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* JsonParser impl\n     @Override public String getCurrentName() throws IOException {\n         // [JACKSON-395]: start markers require information from parent\n         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n-            JsonReadContext parent = _parsingContext.getParent();\n+            JsonReadContext parent = _parsingContext.clearAndGetParent();\n             return parent.getCurrentName();\n         }\n         return _parsingContext.getCurrentName();\n \n     // No embedded objects with base impl...\n     @Override public Object getEmbeddedObject() throws IOException { return null; }\n-    \n+\n+    @SuppressWarnings(\"resource\")\n+    @Override // since 2.7\n+    public byte[] getBinaryValue(Base64Variant variant) throws IOException\n+    {\n+        if (_binaryValue == null) {\n+            if (_currToken != JsonToken.VALUE_STRING) {\n+                _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING, can not access as binary\");\n+            }\n+            ByteArrayBuilder builder = _getByteArrayBuilder();\n+            _decodeBase64(getText(), builder, variant);\n+            _binaryValue = builder.toByteArray();\n+        }\n+        return _binaryValue;\n+    }\n+\n     /*\n     /**********************************************************\n     /* Public low-level accessors\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n     public int getValueAsInt() throws IOException\n     {\n         JsonToken t = _currToken;\n-        if (t == JsonToken.VALUE_NUMBER_INT) {\n+        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n             return getIntValue();\n         }\n-        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n-            return getIntValue();\n-        }\n         return getValueAsInt(0);\n     }\n \n     public int getValueAsInt(int defaultValue) throws IOException\n     {\n         JsonToken t = _currToken;\n-        if (t == JsonToken.VALUE_NUMBER_INT) {\n-            return getIntValue();\n-        }\n-        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n+        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n             return getIntValue();\n         }\n         if (t != null) {\n     public long getValueAsLong() throws IOException\n     {\n         JsonToken t = _currToken;\n-        if (t == JsonToken.VALUE_NUMBER_INT) {\n+        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n             return getLongValue();\n         }\n-        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n-            return getLongValue();\n-        }\n         return getValueAsLong(0L);\n     }\n     \n     public long getValueAsLong(long defaultValue) throws IOException\n     {\n         JsonToken t = _currToken;\n-        if (t == JsonToken.VALUE_NUMBER_INT) {\n-            return getLongValue();\n-        }\n-        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n+        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n             return getLongValue();\n         }\n         if (t != null) {\n     }\n \n     protected final JsonParseException _constructError(String msg, Throwable t) {\n-        return new JsonParseException(msg, getCurrentLocation(), t);\n+        return new JsonParseException(this, msg, t);\n     }\n \n     protected static byte[] _asciiBytes(String str) {\n         }\n         return b;\n     }\n-    \n+\n     protected static String _ascii(byte[] b) {\n         try {\n             return new String(b, \"US-ASCII\");\n--- a/src/main/java/com/fasterxml/jackson/core/filter/FilteringGeneratorDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/FilteringGeneratorDelegate.java\n      * Marked as deprecated since its status is uncertain.\n      */\n     @Deprecated\n-    protected boolean _includeImmediateParent = false;\n+    protected boolean _includeImmediateParent;\n \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java\n      * Marked as deprecated since its status is uncertain.\n      */\n     @Deprecated\n-    protected boolean _includeImmediateParent = false;\n+    protected boolean _includeImmediateParent;\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/core/filter/TokenFilterContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/TokenFilterContext.java\n     /**********************************************************\n      */\n \n-    protected TokenFilterContext _child = null;\n+    protected TokenFilterContext _child;\n \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/core/io/CharTypes.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/CharTypes.java\n      * Lookup table used for determining which input characters\n      * need special handling when contained in text segment.\n      */\n-    final static int[] sInputCodes;\n+    private final static int[] sInputCodes;\n     static {\n         /* 96 would do for most cases (backslash is ASCII 94)\n          * but if we want to do lookups by raw bytes it's better\n      * Additionally we can combine UTF-8 decoding info into similar\n      * data table.\n      */\n-    final static int[] sInputCodesUTF8;\n+    private final static int[] sInputCodesUTF8;\n     static {\n         final int[] table = new int[sInputCodes.length];\n         System.arraycopy(sInputCodes, 0, table, 0, table.length);\n      * Basically this is list of 8-bit ASCII characters that are legal\n      * as part of Javascript identifier\n      */\n-    final static int[] sInputCodesJsNames;\n+    private final static int[] sInputCodesJsNames;\n     static {\n         final int[] table = new int[256];\n         // Default is \"not a name char\", mark ones that are\n      * code as ok. They will be validated at a later point, when decoding\n      * name\n      */\n-    final static int[] sInputCodesUtf8JsNames;\n+    private final static int[] sInputCodesUtf8JsNames;\n     static {\n         final int[] table = new int[256];\n         // start with 8-bit JS names\n      * Decoding table used to quickly determine characters that are\n      * relevant within comment content.\n      */\n-    final static int[] sInputCodesComment;\n+    private final static int[] sInputCodesComment;\n     static {\n         final int[] buf = new int[256];\n         // but first: let's start with UTF-8 multi-byte markers:\n      * \n      * @since 2.3\n      */\n-    final static int[] sInputCodesWS;\n+    private final static int[] sInputCodesWS;\n     static {\n         // but first: let's start with UTF-8 multi-byte markers:\n         final int[] buf = new int[256];\n      * Lookup table used for determining which output characters in\n      * 7-bit ASCII range need to be quoted.\n      */\n-    final static int[] sOutputEscapes128;\n+    private final static int[] sOutputEscapes128;\n     static {\n         int[] table = new int[128];\n         // Control chars need generic escape sequence\n      * range. For actual hex digits, contains corresponding value;\n      * for others -1.\n      */\n-    final static int[] sHexValues = new int[128];\n+    private final static int[] sHexValues = new int[128];\n     static {\n         Arrays.fill(sHexValues, -1);\n         for (int i = 0; i < 10; ++i) {\n--- a/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\n      * Reference to the allocated I/O buffer for low-level input reading,\n      * if any allocated.\n      */\n-    protected byte[] _readIOBuffer = null;\n+    protected byte[] _readIOBuffer;\n \n     /**\n      * Reference to the allocated I/O buffer used for low-level\n      * encoding-related buffering.\n      */\n-    protected byte[] _writeEncodingBuffer = null;\n+    protected byte[] _writeEncodingBuffer;\n     \n     /**\n      * Reference to the buffer allocated for temporary use with\n      * base64 encoding or decoding.\n      */\n-    protected byte[] _base64Buffer = null;\n+    protected byte[] _base64Buffer;\n \n     /**\n      * Reference to the buffer allocated for tokenization purposes,\n      * in which character input is read, and from which it can be\n      * further returned.\n      */\n-    protected char[] _tokenCBuffer = null;\n+    protected char[] _tokenCBuffer;\n \n     /**\n      * Reference to the buffer allocated for buffering it for\n      * output, before being encoded: generally this means concatenating\n      * output, then encoding when buffer fills up.\n      */\n-    protected char[] _concatCBuffer = null;\n+    protected char[] _concatCBuffer;\n \n     /**\n      * Reference temporary buffer Parser instances need if calling\n      * Regular text buffer can not be used as it may contain textual\n      * representation of the value token.\n      */\n-    protected char[] _nameCopyBuffer = null;\n+    protected char[] _nameCopyBuffer;\n \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/core/io/NumberOutput.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/NumberOutput.java\n \n     final static String SMALLEST_LONG = String.valueOf(Long.MIN_VALUE);\n \n-    final static char[] LEAD_3 = new char[4000];\n-    final static char[] FULL_3 = new char[4000];\n+    private final static char[] LEAD_3 = new char[4000];\n+    private final static char[] FULL_3 = new char[4000];\n     static {\n         /* Let's fill it with NULLs for ignorable leading digits,\n          * and digit chars for others\n         }\n     }\n \n-    final static byte[] FULL_TRIPLETS_B = new byte[4000];\n+    private final static byte[] FULL_TRIPLETS_B = new byte[4000];\n     static {\n         for (int i = 0; i < 4000; ++i) {\n             FULL_TRIPLETS_B[i] = (byte) FULL_3[i];\n         }\n     }\n     \n-    final static String[] sSmallIntStrs = new String[] {\n+    private final static String[] sSmallIntStrs = new String[] {\n         \"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\"\n     };\n-    final static String[] sSmallIntStrs2 = new String[] {\n+    private final static String[] sSmallIntStrs2 = new String[] {\n         \"-1\",\"-2\",\"-3\",\"-4\",\"-5\",\"-6\",\"-7\",\"-8\",\"-9\",\"-10\"\n     };\n \n--- a/src/main/java/com/fasterxml/jackson/core/io/UTF32Reader.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/UTF32Reader.java\n     /**\n      * Total read character count; used for error reporting purposes\n      */\n-    protected int _charCount = 0;\n+    protected int _charCount;\n \n     /**\n      * Total read byte count; used for error reporting purposes\n      */\n-    protected int _byteCount = 0;\n+    protected int _byteCount;\n \n     protected final boolean _managedBuffers;\n     \n         }\n     }\n \n-    protected char[] _tmpBuf = null;\n+    protected char[] _tmpBuf;\n \n     /**\n      * Although this method is implemented by the base class, AND it should\n--- a/src/main/java/com/fasterxml/jackson/core/io/UTF8Writer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/UTF8Writer.java\n      * To do this, both pairs must be known first; and since it is possible\n      * pairs may be split, we need temporary storage for the first half\n      */\n-    private int _surrogate = 0;\n+    private int _surrogate;\n \n     public UTF8Writer(IOContext ctxt, OutputStream out)\n     {\n--- a/src/main/java/com/fasterxml/jackson/core/json/ByteSourceJsonBootstrapper.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ByteSourceJsonBootstrapper.java\n \n     protected boolean _bigEndian = true;\n \n-    protected int _bytesPerChar = 0; // 0 means \"dunno yet\"\n+    protected int _bytesPerChar; // 0 means \"dunno yet\"\n \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/core/json/DupDetector.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/DupDetector.java\n public class DupDetector\n {\n     /**\n-     * We need to store a back-reference here to parser/generator, unfortunately.\n+     * We need to store a back-reference here to parser/generator.\n      */\n     protected final Object _source;\n \n         // do generators have a way to provide Location? Apparently not...\n         return null;\n     }\n-    \n+\n+    /**\n+     * @since 2.7\n+     */\n+    public Object getSource() {\n+        return _source;\n+    }\n+\n     public boolean isDup(String name) throws JsonParseException\n     {\n         if (_firstName == null) {\n--- a/src/main/java/com/fasterxml/jackson/core/json/JsonGeneratorImpl.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonGeneratorImpl.java\n         super(features, codec);\n         _ioContext = ctxt;\n         if (isEnabled(Feature.ESCAPE_NON_ASCII)) {\n-            setHighestNonEscapedChar(127);\n+            // inlined `setHighestNonEscapedChar()`\n+            _maximumNonEscapedChar = 127;\n         }\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/core/json/JsonReadContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonReadContext.java\n     /**********************************************************\n      */\n \n-    protected JsonReadContext _child = null;\n+    protected JsonReadContext _child;\n \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n \n-    @Deprecated // since 2.3, use variant that takes dup detector\n-    public static JsonReadContext createRootContext(int lineNr, int colNr) {\n-        return createRootContext(lineNr, colNr, null);\n-    }\n-\n     public static JsonReadContext createRootContext(int lineNr, int colNr, DupDetector dups) {\n         return new JsonReadContext(null, dups, TYPE_ROOT, lineNr, colNr);\n-    }\n-\n-    @Deprecated // since 2.3, use variant that takes dup detector\n-    public static JsonReadContext createRootContext() {\n-        return createRootContext(null);\n     }\n \n     public static JsonReadContext createRootContext(DupDetector dups) {\n     @Override public String getCurrentName() { return _currentName; }\n     @Override public JsonReadContext getParent() { return _parent; }\n \n+    /**\n+     * Method that can be used to both clear the accumulated references\n+     * (specifically value set with {@link #setCurrentValue(Object)})\n+     * that should not be retained, and returns parent (as would\n+     * {@link #getParent()} do). Typically called when closing the active\n+     * context when encountering {@link JsonToken#END_ARRAY} or\n+     * {@link JsonToken#END_OBJECT}.\n+     *\n+     * @since 2.7\n+     */\n+    public JsonReadContext clearAndGetParent() {\n+        _currentValue = null;\n+        // could also clear the current name, but seems cheap enough to leave?\n+        return _parent;\n+    }\n+\n     /*\n     /**********************************************************\n     /* Extended API\n \n     private void _checkDup(DupDetector dd, String name) throws JsonProcessingException {\n         if (dd.isDup(name)) {\n-            throw new JsonParseException(\"Duplicate field '\"+name+\"'\", dd.findLocation());\n-        }\n-    }\n-    \n+            Object src = dd.getSource();\n+            throw new JsonParseException(((src instanceof JsonGenerator) ? ((JsonParser) src) : null),\n+                    \"Duplicate field '\"+name+\"'\");\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Overridden standard methods\n--- a/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java\n     /**********************************************************\n      */\n \n-    protected JsonWriteContext _child = null;\n+    protected JsonWriteContext _child;\n \n     /*\n     /**********************************************************\n     @Override public final JsonWriteContext getParent() { return _parent; }\n     @Override public final String getCurrentName() { return _currentName; }\n \n+    /**\n+     * Method that can be used to both clear the accumulated references\n+     * (specifically value set with {@link #setCurrentValue(Object)})\n+     * that should not be retained, and returns parent (as would\n+     * {@link #getParent()} do). Typically called when closing the active\n+     * context when encountering {@link JsonToken#END_ARRAY} or\n+     * {@link JsonToken#END_OBJECT}.\n+     *\n+     * @since 2.7\n+     */\n+    public JsonWriteContext clearAndGetParent() {\n+        _currentValue = null;\n+        // could also clear the current name, but seems cheap enough to leave?\n+        return _parent;\n+    }\n+    \n     public DupDetector getDupDetector() {\n         return _dups;\n     }\n     }\n \n     private final void _checkDup(DupDetector dd, String name) throws JsonProcessingException {\n-        if (dd.isDup(name)) { throw new JsonGenerationException(\"Duplicate field '\"+name+\"'\"); }\n+        if (dd.isDup(name)) {\n+            Object src = dd.getSource();\n+            throw new JsonGenerationException(\"Duplicate field '\"+name+\"'\",\n+                    ((src instanceof JsonGenerator) ? ((JsonGenerator) src) : null));\n+        }\n     }\n     \n     public int writeValue() {\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n      * buffer.\n      */\n     protected boolean _bufferRecyclable;\n-    \n+\n     /*\n     /**********************************************************\n     /* Configuration\n     protected ObjectCodec _objectCodec;\n \n     final protected CharsToNameCanonicalizer _symbols;\n-    \n+\n     final protected int _hashSeed;\n \n     /*\n     /* Parsing state\n     /**********************************************************\n      */\n-    \n+\n     /**\n      * Flag that indicates that the current token has not yet\n      * been fully processed, and needs to be finished for\n      * some access (or skipped to obtain the next token)\n      */\n-    protected boolean _tokenIncomplete = false;\n+    protected boolean _tokenIncomplete;\n+\n+    /**\n+     * Value of {@link #_inputPtr} at the time when the first character of\n+     * name token was read. Used for calculating token location when requested;\n+     * combined with {@link #_currInputProcessed}, may be updated appropriately\n+     * as needed.\n+     *\n+     * @since 2.7\n+     */\n+    protected long _nameStartOffset;\n+\n+    /**\n+     * @since 2.7\n+     */\n+    protected int _nameStartRow;\n+\n+    /**\n+     * @since 2.7\n+     */\n+    protected int _nameStartCol;\n \n     /*\n     /**********************************************************\n     /**\n      * Method called when caller wants to provide input buffer directly,\n      * and it may or may not be recyclable use standard recycle context.\n-     * \n+     *\n      * @since 2.4\n      */\n     public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n \n     @Override public ObjectCodec getCodec() { return _objectCodec; }\n     @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n-    \n+\n     @Override\n     public int releaseBuffered(Writer w) throws IOException {\n         int count = _inputEnd - _inputPtr;\n     @Override\n     protected boolean loadMore() throws IOException\n     {\n-        _currInputProcessed += _inputEnd;\n-        _currInputRowStart -= _inputEnd;\n+        final int bufSize = _inputEnd;\n+\n+        _currInputProcessed += bufSize;\n+        _currInputRowStart -= bufSize;\n+\n+        // 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n+        //   this increase to avoid \"moving\" name-offset, resulting most likely\n+        //   in negative value, which is fine as combine value remains unchanged.\n+        _nameStartOffset -= bufSize;\n \n         if (_reader != null) {\n             int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n             }\n         }\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Public API, data access\n     /**********************************************************\n      */\n-    \n+\n     /**\n      * Method for accessing textual representation of the current event;\n      * if no current event (before first call to {@link #nextToken}, or\n     }\n \n     // // // Let's override default impls for improved performance\n-    \n+\n     // @since 2.1\n     @Override\n     public final String getValueAsString() throws IOException\n         }\n         return super.getValueAsString(null);\n     }\n-    \n+\n     // @since 2.1\n     @Override\n     public final String getValueAsString(String defValue) throws IOException {\n                     _nameCopied = true;\n                 }\n                 return _nameCopyBuffer;\n-    \n             case ID_STRING:\n                 if (_tokenIncomplete) {\n                     _tokenIncomplete = false;\n             case ID_NUMBER_INT:\n             case ID_NUMBER_FLOAT:\n                 return _textBuffer.getTextBuffer();\n-                \n             default:\n                 return _currToken.asCharArray();\n             }\n     {\n         if (_currToken != null) { // null only before/after document\n             switch (_currToken.id()) {\n-                \n             case ID_FIELD_NAME:\n                 return _parsingContext.getCurrentName().length();\n             case ID_STRING:\n             case ID_NUMBER_INT:\n             case ID_NUMBER_FLOAT:\n                 return _textBuffer.size();\n-                \n             default:\n                 return _currToken.asCharArray().length;\n             }\n         }\n         return _binaryValue;\n     }\n-    \n+\n     @Override\n     public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n     {\n     @Override\n     public final JsonToken nextToken() throws IOException\n     {\n-        _numTypesValid = NR_UNKNOWN;\n-\n         /* First: field names are special -- we will always tokenize\n          * (part of) value along with field name to simplify\n          * state handling. If so, can and need to use secondary token:\n         if (_currToken == JsonToken.FIELD_NAME) {\n             return _nextAfterName();\n         }\n+        // But if we didn't already have a name, and (partially?) decode number,\n+        // need to ensure no numeric information is leaked\n+        _numTypesValid = NR_UNKNOWN;\n         if (_tokenIncomplete) {\n             _skipString(); // only strings can be partial\n         }\n             close();\n             return (_currToken = null);\n         }\n-\n-        /* First, need to ensure we know the starting location of token\n-         * after skipping leading white space\n-         */\n-        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n-        _tokenInputRow = _currInputRow;\n-        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n-\n-        // finally: clear any data retained so far\n+        // clear any data retained so far\n         _binaryValue = null;\n \n         // Closing scope?\n         if (i == INT_RBRACKET) {\n+            _updateLocation();\n             if (!_parsingContext.inArray()) {\n                 _reportMismatchedEndMarker(i, '}');\n             }\n-            _parsingContext = _parsingContext.getParent();\n+            _parsingContext = _parsingContext.clearAndGetParent();\n             return (_currToken = JsonToken.END_ARRAY);\n         }\n         if (i == INT_RCURLY) {\n+            _updateLocation();\n             if (!_parsingContext.inObject()) {\n                 _reportMismatchedEndMarker(i, ']');\n             }\n-            _parsingContext = _parsingContext.getParent();\n+            _parsingContext = _parsingContext.clearAndGetParent();\n             return (_currToken = JsonToken.END_OBJECT);\n         }\n \n             i = _skipComma(i);\n         }\n \n-        /* And should we now have a name? Always true for\n-         * Object contexts, since the intermediate 'expect-value'\n-         * state is never retained.\n+        /* And should we now have a name? Always true for Object contexts, since\n+         * the intermediate 'expect-value' state is never retained.\n          */\n         boolean inObject = _parsingContext.inObject();\n         if (inObject) {\n-           // First, field name itself:\n+            // First, field name itself:\n+            _updateNameLocation();\n             String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n             _parsingContext.setCurrentName(name);\n             _currToken = JsonToken.FIELD_NAME;\n             i = _skipColon();\n         }\n+        _updateLocation();\n \n         // Ok: we must have a value... what is it?\n \n         _nameCopied = false; // need to invalidate if it was copied\n         JsonToken t = _nextToken;\n         _nextToken = null;\n+\n+// !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n+        \n         // Also: may need to start new context?\n         if (t == JsonToken.START_ARRAY) {\n             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n     /**********************************************************\n      */\n \n-    /*\n+    // Implemented since 2.7\n     @Override\n-    public boolean nextFieldName(SerializableString str)\n-        throws IOException\n-    {\n-    \n-    }\n-    */\n+    public boolean nextFieldName(SerializableString sstr) throws IOException\n+    {\n+        // // // Note: most of code below is copied from nextToken()\n+\n+        _numTypesValid = NR_UNKNOWN;\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+            _nextAfterName();\n+            return false;\n+        }\n+        if (_tokenIncomplete) {\n+            _skipString();\n+        }\n+        int i = _skipWSOrEnd();\n+        if (i < 0) {\n+            close();\n+            _currToken = null;\n+            return false;\n+        }\n+        _binaryValue = null;\n+\n+        if (i == INT_RBRACKET) {\n+            _updateLocation();\n+            if (!_parsingContext.inArray()) {\n+                _reportMismatchedEndMarker(i, '}');\n+            }\n+            _parsingContext = _parsingContext.clearAndGetParent();\n+            _currToken = JsonToken.END_ARRAY;\n+            return false;\n+        }\n+        if (i == INT_RCURLY) {\n+            _updateLocation();\n+            if (!_parsingContext.inObject()) {\n+                _reportMismatchedEndMarker(i, ']');\n+            }\n+            _parsingContext = _parsingContext.clearAndGetParent();\n+            _currToken = JsonToken.END_OBJECT;\n+            return false;\n+        }\n+        if (_parsingContext.expectComma()) {\n+            i = _skipComma(i);\n+        }\n+\n+        if (!_parsingContext.inObject()) {\n+            _updateLocation();\n+            _nextTokenNotInObject(i);\n+            return false;\n+        }\n+\n+        _updateNameLocation();\n+        if (i == INT_QUOTE) {\n+            // when doing literal match, must consider escaping:\n+            char[] nameChars = sstr.asQuotedChars();\n+            final int len = nameChars.length;\n+\n+            // Require 4 more bytes for faster skipping of colon that follows name\n+            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n+                // first check length match by\n+                final int end = _inputPtr+len;\n+                if (_inputBuffer[end] == '\"') {\n+                    int offset = 0;\n+                    int ptr = _inputPtr;\n+                    while (true) {\n+                        if (ptr == end) { // yes, match!\n+                            _parsingContext.setCurrentName(sstr.getValue());\n+                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n+                            return true;\n+                        }\n+                        if (nameChars[offset] != _inputBuffer[ptr]) {\n+                            break;\n+                        }\n+                        ++offset;\n+                        ++ptr;\n+                    }\n+                }\n+            }\n+        }\n+        return _isNextTokenNameMaybe(i, sstr.getValue());\n+    }\n \n     @Override\n     public String nextFieldName() throws IOException\n             _currToken = null;\n             return null;\n         }\n-        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n-        _tokenInputRow = _currInputRow;\n-        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n         _binaryValue = null;\n         if (i == INT_RBRACKET) {\n+            _updateLocation();\n             if (!_parsingContext.inArray()) {\n                 _reportMismatchedEndMarker(i, '}');\n             }\n-            _parsingContext = _parsingContext.getParent();\n+            _parsingContext = _parsingContext.clearAndGetParent();\n             _currToken = JsonToken.END_ARRAY;\n             return null;\n         }\n         if (i == INT_RCURLY) {\n+            _updateLocation();\n             if (!_parsingContext.inObject()) {\n                 _reportMismatchedEndMarker(i, ']');\n             }\n-            _parsingContext = _parsingContext.getParent();\n+            _parsingContext = _parsingContext.clearAndGetParent();\n             _currToken = JsonToken.END_OBJECT;\n             return null;\n         }\n         if (_parsingContext.expectComma()) {\n             i = _skipComma(i);\n         }\n-\n         if (!_parsingContext.inObject()) {\n+            _updateLocation();\n             _nextTokenNotInObject(i);\n             return null;\n         }\n \n+        _updateNameLocation();\n         String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n         _parsingContext.setCurrentName(name);\n         _currToken = JsonToken.FIELD_NAME;\n         i = _skipColon();\n \n+        _updateLocation();\n         if (i == INT_QUOTE) {\n             _tokenIncomplete = true;\n             _nextToken = JsonToken.VALUE_STRING;\n         }\n         _nextToken = t;\n         return name;\n+    }\n+\n+    private final void _isNextTokenNameYes(int i) throws IOException\n+    {\n+        _currToken = JsonToken.FIELD_NAME;\n+        _updateLocation();\n+\n+        switch (i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            _nextToken = JsonToken.VALUE_STRING;\n+            return;\n+        case '[':\n+            _nextToken = JsonToken.START_ARRAY;\n+            return;\n+        case '{':\n+            _nextToken = JsonToken.START_OBJECT;\n+            return;\n+        case 't':\n+            _matchToken(\"true\", 1);\n+            _nextToken = JsonToken.VALUE_TRUE;\n+            return;\n+        case 'f':\n+            _matchToken(\"false\", 1);\n+            _nextToken = JsonToken.VALUE_FALSE;\n+            return;\n+        case 'n':\n+            _matchToken(\"null\", 1);\n+            _nextToken = JsonToken.VALUE_NULL;\n+            return;\n+        case '-':\n+            _nextToken = _parseNegNumber();\n+            return;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            _nextToken = _parsePosNumber(i);\n+            return;\n+        }\n+        _nextToken = _handleOddValue(i);\n+    }\n+\n+    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n+    {\n+        // // // and this is back to standard nextToken()\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n+        _updateLocation();\n+        if (i == INT_QUOTE) {\n+            _tokenIncomplete = true;\n+            _nextToken = JsonToken.VALUE_STRING;\n+            return nameToMatch.equals(name);\n+        }\n+        // Ok: we must have a value... what is it?\n+        JsonToken t;\n+        switch (i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+        }\n+        _nextToken = t;\n+        return nameToMatch.equals(name);\n     }\n \n     private final JsonToken _nextTokenNotInObject(int i) throws IOException\n         }\n         return (_currToken = _handleOddValue(i));\n     }\n-    \n+\n     // note: identical to one in UTF8StreamJsonParser\n     @Override\n     public final String nextTextValue() throws IOException\n         if (ch == INT_0) {\n             return _parseNumber2(false, startPtr);\n         }\n-            \n+\n         /* First, let's see if the whole number is contained within\n          * the input buffer unsplit. This should be the common case;\n          * and to simplify processing, we will just reparse contents\n          * in the alternative case (number split on buffer boundary)\n          */\n-        \n+\n         int intLen = 1; // already got one\n-        \n+\n         // First let's get the obligatory integer part:\n         int_loop:\n         while (true) {\n             return _parseNumber2(true, startPtr);\n         }\n         int intLen = 1; // already got one\n-        \n+\n         // First let's get the obligatory integer part:\n         int_loop:\n         while (true) {\n         // and offline the less common case\n         return _verifyNLZ2();\n     }\n-        \n+\n     private char _verifyNLZ2() throws IOException\n     {\n         if (_inputPtr >= _inputEnd && !loadMore()) {\n                     return '0';\n                 }\n                 ++_inputPtr; // skip previous zero\n-                if (ch != '0') { // followed by other number; return \n+                if (ch != '0') { // followed by other number; return\n                     break;\n                 }\n             }\n         }\n         _reportMissingRootWS(ch);\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Internal methods, secondary parsing\n         _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n         return null;\n     }\n-    \n+\n     protected JsonToken _handleApos() throws IOException\n     {\n         char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n         _textBuffer.setCurrentLength(outPtr);\n         return JsonToken.VALUE_STRING;\n     }\n-    \n+\n     private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n     {\n         _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n             return _symbols.findSymbol(buf, start, len, hash);\n         }\n     }\n-  \n+\n     @Override\n     protected final void _finishString() throws IOException\n     {\n     /* Internal methods, other parsing\n     /**********************************************************\n      */\n-    \n+\n     /**\n      * We actually need to check the character value here\n      * (to see if we have \\n following \\r).\n         ++_currInputRow;\n         _currInputRowStart = _inputPtr;\n     }\n-    \n+\n     private final int _skipColon() throws IOException\n     {\n         if ((_inputPtr + 4) >= _inputEnd) {\n                     if (i == INT_SLASH || i == INT_HASH) {\n                         return _skipColon2(true);\n                     }\n-                    ++_inputPtr;                    \n+                    ++_inputPtr;\n                     return i;\n                 }\n             }\n             }\n         }\n     }\n- \n+\n+    // Variant called when we know there's at least 4 more bytes available\n+    private final int _skipColonFast(int ptr) throws IOException\n+    {\n+        int i = (int) _inputBuffer[ptr++];\n+        if (i == INT_COLON) { // common case, no leading space\n+            i = _inputBuffer[ptr++];\n+            if (i > INT_SPACE) { // nor trailing\n+                if (i != INT_SLASH && i != INT_HASH) {\n+                    _inputPtr = ptr;\n+                    return i;\n+                }\n+            } else if (i == INT_SPACE || i == INT_TAB) {\n+                i = (int) _inputBuffer[ptr++];\n+                if (i > INT_SPACE) {\n+                    if (i != INT_SLASH && i != INT_HASH) {\n+                        _inputPtr = ptr;\n+                        return i;\n+                    }\n+                }\n+            }\n+            _inputPtr = ptr-1;\n+            return _skipColon2(true); // true -> skipped colon\n+        }\n+        if (i == INT_SPACE || i == INT_TAB) {\n+            i = _inputBuffer[ptr++];\n+        }\n+        boolean gotColon = (i == INT_COLON);\n+        if (gotColon) {\n+            i = _inputBuffer[ptr++];\n+            if (i > INT_SPACE) {\n+                if (i != INT_SLASH && i != INT_HASH) {\n+                    _inputPtr = ptr;\n+                    return i;\n+                }\n+            } else if (i == INT_SPACE || i == INT_TAB) {\n+                i = (int) _inputBuffer[ptr++];\n+                if (i > INT_SPACE) {\n+                    if (i != INT_SLASH && i != INT_HASH) {\n+                        _inputPtr = ptr;\n+                        return i;\n+                    }\n+                }\n+            }\n+        }\n+        _inputPtr = ptr-1;\n+        return _skipColon2(gotColon);\n+    }\n+\n     // Primary loop: no reloading, comment handling\n     private final int _skipComma(int i) throws IOException\n     {\n         }\n         throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n     }\n-    \n+\n     private final int _skipWSOrEnd() throws IOException\n     {\n         // Let's handle first character separately since it is likely that\n                 _throwInvalidSpace(i);\n             }\n         }\n-        \n+\n         while (_inputPtr < _inputEnd) {\n             i = (int) _inputBuffer[_inputPtr++];\n             if (i > INT_SPACE) {\n             }\n         }\n     }\n-    \n+\n     private void _skipComment() throws IOException\n     {\n         if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n         _skipLine();\n         return true;\n     }\n-    \n+\n     private void _skipLine() throws IOException\n     {\n         // Ok: need to find EOF or linefeed\n         }\n         return (char) value;\n     }\n-    \n+\n     private final void _matchTrue() throws IOException {\n         int ptr = _inputPtr;\n         if ((ptr + 3) < _inputEnd) {\n                 }\n             }\n             int decodedData = bits;\n-            \n+\n             // then second base64 char; can't get padding yet, nor ws\n-            \n+\n             if (_inputPtr >= _inputEnd) {\n                 loadMoreGuaranteed();\n             }\n                 bits = _decodeBase64Escape(b64variant, ch, 1);\n             }\n             decodedData = (decodedData << 6) | bits;\n-            \n+\n             // third base64 char; can be padding, but not ws\n             if (_inputPtr >= _inputEnd) {\n                 loadMoreGuaranteed();\n \n     /*\n     /**********************************************************\n+    /* Internal methods, location updating (refactored in 2.7)\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JsonLocation getTokenLocation()\n+    {\n+        final Object src = _ioContext.getSourceReference();\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+            long total = _currInputProcessed + (_nameStartOffset-1);\n+            return new JsonLocation(src,\n+                    -1L, total, _nameStartRow, _nameStartCol);\n+        }\n+        return new JsonLocation(src,\n+                -1L, _tokenInputTotal-1, _tokenInputRow, _tokenInputCol);\n+    }\n+\n+    @Override\n+    public JsonLocation getCurrentLocation() {\n+        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n+        return new JsonLocation(_ioContext.getSourceReference(),\n+                -1L, _currInputProcessed + _inputPtr,\n+                _currInputRow, col);\n+    }\n+\n+    // @since 2.7\n+    private final void _updateLocation()\n+    {\n+        int ptr = _inputPtr;\n+        _tokenInputTotal = _currInputProcessed + ptr;\n+        _tokenInputRow = _currInputRow;\n+        _tokenInputCol = ptr - _currInputRowStart;\n+    }\n+\n+    // @since 2.7\n+    private final void _updateNameLocation()\n+    {\n+        int ptr = _inputPtr;\n+        _nameStartOffset = ptr;\n+        _nameStartRow = _currInputRow;\n+        _nameStartCol = ptr - _currInputRowStart;\n+    }\n+\n+    /*\n+    /**********************************************************\n     /* Error reporting\n     /**********************************************************\n      */\n     protected void _reportInvalidToken(String matchedPart) throws IOException {\n         _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n     }\n-    \n+\n     protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n     {\n         StringBuilder sb = new StringBuilder(matchedPart);\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n     // intermediate copies only made up to certain length...\n     private final static int MAX_BYTES_TO_BUFFER = 512;\n \n-    final static byte[] HEX_CHARS = CharTypes.copyHexBytes();\n+    private final static byte[] HEX_CHARS = CharTypes.copyHexBytes();\n \n     private final static byte[] NULL_BYTES = { 'n', 'u', 'l', 'l' };\n     private final static byte[] TRUE_BYTES = { 't', 'r', 'u', 'e' };\n      * Pointer to the position right beyond the last character to output\n      * (end marker; may be past the buffer)\n      */\n-    protected int _outputTail = 0;\n+    protected int _outputTail;\n \n     /**\n      * End marker of the output buffer; one past the last valid position\n             }\n             _outputBuffer[_outputTail++] = BYTE_RBRACKET;\n         }\n-        _writeContext = _writeContext.getParent();\n+        _writeContext = _writeContext.clearAndGetParent();\n     }\n \n     @Override\n             }\n             _outputBuffer[_outputTail++] = BYTE_RCURLY;\n         }\n-        _writeContext = _writeContext.getParent();\n+        _writeContext = _writeContext.clearAndGetParent();\n     }\n \n     /**\n      */\n \n     @Override\n-    public void writeNumber(short s)\n-        throws IOException, JsonGenerationException\n+    public void writeNumber(short s) throws IOException\n     {\n         _verifyValueWrite(WRITE_NUMBER);\n         // up to 5 digits and possible minus sign\n     } \n     \n     @Override\n-    public void writeNumber(int i)\n-        throws IOException, JsonGenerationException\n+    public void writeNumber(int i) throws IOException\n     {\n         _verifyValueWrite(WRITE_NUMBER);\n         // up to 10 digits and possible minus sign\n     }    \n \n     @Override\n-    public void writeNumber(long l)\n-        throws IOException, JsonGenerationException\n+    public void writeNumber(long l) throws IOException\n     {\n         _verifyValueWrite(WRITE_NUMBER);\n         if (_cfgNumbersAsStrings) {\n     }\n \n     @Override\n-    public void writeNumber(BigInteger value)\n-        throws IOException, JsonGenerationException\n+    public void writeNumber(BigInteger value) throws IOException\n     {\n         _verifyValueWrite(WRITE_NUMBER);\n         if (value == null) {\n \n     \n     @Override\n-    public void writeNumber(double d)\n-        throws IOException, JsonGenerationException\n+    public void writeNumber(double d) throws IOException\n     {\n         if (_cfgNumbersAsStrings ||\n-            // [JACKSON-139]\n             (((Double.isNaN(d) || Double.isInfinite(d))\n-                && isEnabled(Feature.QUOTE_NON_NUMERIC_NUMBERS)))) {\n+                && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) {\n             writeString(String.valueOf(d));\n             return;\n         }\n     }\n \n     @Override\n-    public void writeNumber(float f)\n-        throws IOException, JsonGenerationException\n+    public void writeNumber(float f) throws IOException\n     {\n         if (_cfgNumbersAsStrings ||\n             // [JACKSON-139]\n             (((Float.isNaN(f) || Float.isInfinite(f))\n-                && isEnabled(Feature.QUOTE_NON_NUMERIC_NUMBERS)))) {\n+                && Feature.QUOTE_NON_NUMERIC_NUMBERS.enabledIn(_features)))) {\n             writeString(String.valueOf(f));\n             return;\n         }\n     }\n \n     @Override\n-    public void writeNumber(BigDecimal value)\n-        throws IOException, JsonGenerationException\n+    public void writeNumber(BigDecimal value) throws IOException\n     {\n         // Don't really know max length for big decimal, no point checking\n         _verifyValueWrite(WRITE_NUMBER);\n         if (value == null) {\n             _writeNull();\n         } else if (_cfgNumbersAsStrings) {\n-            String raw = isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN) ? value.toPlainString() : value.toString();\n+            String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)\n+                    ? value.toPlainString() : value.toString();\n             _writeQuotedRaw(raw);\n-        } else if (isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN)) {\n+        } else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) {\n             writeRaw(value.toPlainString());\n         } else {\n             writeRaw(value.toString());\n     }\n \n     @Override\n-    public void writeNumber(String encodedValue)\n-        throws IOException, JsonGenerationException\n+    public void writeNumber(String encodedValue) throws IOException\n     {\n         _verifyValueWrite(WRITE_NUMBER);\n         if (_cfgNumbersAsStrings) {\n     }\n     \n     @Override\n-    public void writeBoolean(boolean state)\n-        throws IOException, JsonGenerationException\n+    public void writeBoolean(boolean state) throws IOException\n     {\n         _verifyValueWrite(WRITE_BOOLEAN);\n         if ((_outputTail + 5) >= _outputEnd) {\n     }\n \n     @Override\n-    public void writeNull()\n-        throws IOException, JsonGenerationException\n+    public void writeNull() throws IOException\n     {\n         _verifyValueWrite(WRITE_NULL);\n         _writeNull();\n         return inputOffset;\n     }\n \n-    protected final void _outputSurrogates(int surr1, int surr2)\n-        throws IOException\n+    protected final void _outputSurrogates(int surr1, int surr2) throws IOException\n     {\n         int c = _decodeSurrogate(surr1, surr2);\n         if ((_outputTail + 4) > _outputEnd) {\n     {\n         byte[] bbuf = _outputBuffer;\n         if (ch >= SURR1_FIRST && ch <= SURR2_LAST) { // yes, outside of BMP; add an escape\n-            bbuf[outputPtr++] = BYTE_BACKSLASH;\n-            bbuf[outputPtr++] = BYTE_u;\n-            \n-            bbuf[outputPtr++] = HEX_CHARS[(ch >> 12) & 0xF];\n-            bbuf[outputPtr++] = HEX_CHARS[(ch >> 8) & 0xF];\n-            bbuf[outputPtr++] = HEX_CHARS[(ch >> 4) & 0xF];\n-            bbuf[outputPtr++] = HEX_CHARS[ch & 0xF];\n+            // 23-Nov-2015, tatu: As per [core#223], may or may not want escapes;\n+            //   it would be added here... but as things are, we do not have proper\n+            //   access yet...\n+//            if (Feature.ESCAPE_UTF8_SURROGATES.enabledIn(_features)) {\n+                bbuf[outputPtr++] = BYTE_BACKSLASH;\n+                bbuf[outputPtr++] = BYTE_u;\n+                \n+                bbuf[outputPtr++] = HEX_CHARS[(ch >> 12) & 0xF];\n+                bbuf[outputPtr++] = HEX_CHARS[(ch >> 8) & 0xF];\n+                bbuf[outputPtr++] = HEX_CHARS[(ch >> 4) & 0xF];\n+                bbuf[outputPtr++] = HEX_CHARS[ch & 0xF];\n+//            } else { ... }\n         } else {\n             bbuf[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n             bbuf[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n         }\n         return outputPtr;\n     }\n-    \n+\n     private final void _writeNull() throws IOException\n     {\n         if ((_outputTail + 4) >= _outputEnd) {\n      * \n      * @param charToEscape Character to escape using escape sequence (\\\\uXXXX)\n      */\n-    private int _writeGenericEscape(int charToEscape, int outputPtr)\n-        throws IOException\n+    private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException\n     {\n         final byte[] bbuf = _outputBuffer;\n         bbuf[outputPtr++] = BYTE_BACKSLASH;\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n      * been fully processed, and needs to be finished for\n      * some access (or skipped to obtain the next token)\n      */\n-    protected boolean _tokenIncomplete = false;\n+    protected boolean _tokenIncomplete;\n \n     /**\n      * Temporary storage for partially parsed name bytes.\n      */\n     private int _quad1;\n+\n+    /**\n+     * Value of {@link #_inputPtr} at the time when the first character of\n+     * name token was read. Used for calculating token location when requested;\n+     * combined with {@link #_currInputProcessed}, may be updated appropriately\n+     * as needed.\n+     *\n+     * @since 2.7\n+     */\n+    protected int _nameStartOffset; \n+\n+    /**\n+     * @since 2.7\n+     */\n+    protected int _nameStartRow;\n+\n+    /**\n+     * @since 2.7\n+     */\n+    protected int _nameStartCol;\n \n     /*\n     /**********************************************************\n     @Override\n     protected final boolean loadMore() throws IOException\n     {\n+        final int bufSize = _inputEnd;\n+\n         _currInputProcessed += _inputEnd;\n         _currInputRowStart -= _inputEnd;\n-        \n+\n+        // 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n+        //   this increase to avoid \"moving\" name-offset, resulting most likely\n+        //   in negative value, which is fine as combine value remains unchanged.\n+        _nameStartOffset -= bufSize;\n+\n         if (_inputStream != null) {\n             int space = _inputBuffer.length;\n             if (space == 0) { // only occurs when we've been closed\n         // Need to move remaining data in front?\n         int amount = _inputEnd - _inputPtr;\n         if (amount > 0 && _inputPtr > 0) {\n-            _currInputProcessed += _inputPtr;\n-            _currInputRowStart -= _inputPtr;\n-            System.arraycopy(_inputBuffer, _inputPtr, _inputBuffer, 0, amount);\n+            final int ptr = _inputPtr;\n+\n+            _currInputProcessed += ptr;\n+            _currInputRowStart -= ptr;\n+            // 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n+            //  (note: probably has little effect here but just in case)\n+            _nameStartOffset -= ptr;\n+\n+            System.arraycopy(_inputBuffer, ptr, _inputBuffer, 0, amount);\n             _inputEnd = amount;\n         } else {\n             _inputEnd = 0;\n         return outputCount;\n     }\n \n-    // As per [Issue#108], must ensure we call the right method\n-    @Override\n-    public JsonLocation getTokenLocation()\n-    {\n-        return new JsonLocation(_ioContext.getSourceReference(),\n-                getTokenCharacterOffset(), -1L, // bytes, chars\n-                getTokenLineNr(),\n-                getTokenColumnNr());\n-    }\n-\n-    // As per [Issue#108], must ensure we call the right method\n-    @Override\n-    public JsonLocation getCurrentLocation()\n-    {\n-        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n-        return new JsonLocation(_ioContext.getSourceReference(),\n-                _currInputProcessed + _inputPtr, -1L, // bytes, chars\n-                _currInputRow, col);\n-    }\n-    \n     /*\n     /**********************************************************\n     /* Public API, traversal, basic\n     @Override\n     public JsonToken nextToken() throws IOException\n     {\n-        _numTypesValid = NR_UNKNOWN;\n         /* First: field names are special -- we will always tokenize\n          * (part of) value along with field name to simplify\n          * state handling. If so, can and need to use secondary token:\n         if (_currToken == JsonToken.FIELD_NAME) {\n             return _nextAfterName();\n         }\n+        // But if we didn't already have a name, and (partially?) decode number,\n+        // need to ensure no numeric information is leaked\n+        _numTypesValid = NR_UNKNOWN;\n         if (_tokenIncomplete) {\n             _skipString(); // only strings can be partial\n         }\n             close();\n             return (_currToken = null);\n         }\n-\n-        // First, need to ensure we know the starting location of token\n-        // after skipping leading white space\n-        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n-        _tokenInputRow = _currInputRow;\n-        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n-\n-        // finally: clear any data retained so far\n+        // clear any data retained so far\n         _binaryValue = null;\n \n         // Closing scope?\n         if (i == INT_RBRACKET) {\n+            _updateLocation();\n             if (!_parsingContext.inArray()) {\n                 _reportMismatchedEndMarker(i, '}');\n             }\n-            _parsingContext = _parsingContext.getParent();\n+            _parsingContext = _parsingContext.clearAndGetParent();\n             return (_currToken = JsonToken.END_ARRAY);\n         }\n         if (i == INT_RCURLY) {\n+            _updateLocation();\n             if (!_parsingContext.inObject()) {\n                 _reportMismatchedEndMarker(i, ']');\n             }\n-            _parsingContext = _parsingContext.getParent();\n+            _parsingContext = _parsingContext.clearAndGetParent();\n             return (_currToken = JsonToken.END_OBJECT);\n         }\n \n          * state is never retained.\n          */\n         if (!_parsingContext.inObject()) {\n+            _updateLocation();\n             return _nextTokenNotInObject(i);\n         }\n         // So first parse the field name itself:\n+        _updateNameLocation();\n         String n = _parseName(i);\n         _parsingContext.setCurrentName(n);\n         _currToken = JsonToken.FIELD_NAME;\n \n         i = _skipColon();\n+        _updateLocation();\n \n         // Ok: we must have a value... what is it? Strings are very common, check first:\n         if (i == INT_QUOTE) {\n         _nameCopied = false; // need to invalidate if it was copied\n         JsonToken t = _nextToken;\n         _nextToken = null;\n+\n+ // !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n+        \n         // Also: may need to start new context?\n         if (t == JsonToken.START_ARRAY) {\n             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n     public boolean nextFieldName(SerializableString str) throws IOException\n     {\n         // // // Note: most of code below is copied from nextToken()\n-        \n         _numTypesValid = NR_UNKNOWN;\n         if (_currToken == JsonToken.FIELD_NAME) { // can't have name right after name\n             _nextAfterName();\n             _currToken = null;\n             return false;\n         }\n-        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n-        _tokenInputRow = _currInputRow;\n-        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n-\n-        // finally: clear any data retained so far\n         _binaryValue = null;\n \n         // Closing scope?\n         if (i == INT_RBRACKET) {\n+            _updateLocation();\n             if (!_parsingContext.inArray()) {\n                 _reportMismatchedEndMarker(i, '}');\n             }\n-            _parsingContext = _parsingContext.getParent();\n+            _parsingContext = _parsingContext.clearAndGetParent();\n             _currToken = JsonToken.END_ARRAY;\n             return false;\n         }\n         if (i == INT_RCURLY) {\n+            _updateLocation();\n             if (!_parsingContext.inObject()) {\n                 _reportMismatchedEndMarker(i, ']');\n             }\n-            _parsingContext = _parsingContext.getParent();\n+            _parsingContext = _parsingContext.clearAndGetParent();\n             _currToken = JsonToken.END_OBJECT;\n             return false;\n         }\n         }\n \n         if (!_parsingContext.inObject()) {\n+            _updateLocation();\n             _nextTokenNotInObject(i);\n             return false;\n         }\n         \n         // // // This part differs, name parsing\n+        _updateNameLocation();\n         if (i == INT_QUOTE) {\n             // when doing literal match, must consider escaping:\n             byte[] nameBytes = str.asQuotedUTF8();\n             _currToken = null;\n             return null;\n         }\n-        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n-        _tokenInputRow = _currInputRow;\n-        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n-\n         _binaryValue = null;\n \n         if (i == INT_RBRACKET) {\n+            _updateLocation();\n             if (!_parsingContext.inArray()) {\n                 _reportMismatchedEndMarker(i, '}');\n             }\n-            _parsingContext = _parsingContext.getParent();\n+            _parsingContext = _parsingContext.clearAndGetParent();\n             _currToken = JsonToken.END_ARRAY;\n             return null;\n         }\n         if (i == INT_RCURLY) {\n+            _updateLocation();\n             if (!_parsingContext.inObject()) {\n                 _reportMismatchedEndMarker(i, ']');\n             }\n-            _parsingContext = _parsingContext.getParent();\n+            _parsingContext = _parsingContext.clearAndGetParent();\n             _currToken = JsonToken.END_OBJECT;\n             return null;\n         }\n             }\n             i = _skipWS();\n         }\n-\n         if (!_parsingContext.inObject()) {\n+            _updateLocation();\n             _nextTokenNotInObject(i);\n             return null;\n         }\n \n+        _updateNameLocation();\n         final String nameStr = _parseName(i);\n         _parsingContext.setCurrentName(nameStr);\n         _currToken = JsonToken.FIELD_NAME;\n \n         i = _skipColon();\n+        _updateLocation();\n         if (i == INT_QUOTE) {\n             _tokenIncomplete = true;\n             _nextToken = JsonToken.VALUE_STRING;\n     private final void _isNextTokenNameYes(int i) throws IOException\n     {\n         _currToken = JsonToken.FIELD_NAME;\n+        _updateLocation();\n \n         switch (i) {\n         case '\"':\n         }\n         _nextToken = _handleUnexpectedValue(i);\n     }\n-    \n-    \n+\n     private final boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException\n     {\n         // // // and this is back to standard nextToken()\n         final boolean match = n.equals(str.getValue());\n         _currToken = JsonToken.FIELD_NAME;\n         i = _skipColon();\n+        _updateLocation();\n \n         // Ok: we must have a value... what is it? Strings are very common, check first:\n         if (i == INT_QUOTE) {\n \n     /**\n      * Method called when not even first 8 bytes are guaranteed\n-     * to come consequtively. Happens rarely, so this is offlined;\n+     * to come consecutively. Happens rarely, so this is offlined;\n      * plus we'll also do full checks for escaping etc.\n      */\n     protected String slowParseName() throws IOException\n     /**\n      * Method called when we see non-white space character other\n      * than double quote, when expecting a field name.\n-     * In standard mode will just throw an expection; but\n+     * In standard mode will just throw an exception; but\n      * in non-standard modes may be able to parse name.\n      */\n     protected String _handleOddName(int ch) throws IOException\n \n     /*\n     /**********************************************************\n+    /* Improved location updating (refactored in 2.7)\n+    /**********************************************************\n+     */\n+\n+    // As per [core#108], must ensure we call the right method\n+    @Override\n+    public JsonLocation getTokenLocation()\n+    {\n+        final Object src = _ioContext.getSourceReference();\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+            long total = _currInputProcessed + (_nameStartOffset-1);\n+            return new JsonLocation(src,\n+                    total, -1L, _nameStartRow, _nameStartCol);\n+        }\n+        return new JsonLocation(src,\n+                _tokenInputTotal-1, -1L, _tokenInputRow, _tokenInputCol);\n+    }\n+\n+    // As per [core#108], must ensure we call the right method\n+    @Override\n+    public JsonLocation getCurrentLocation()\n+    {\n+        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n+        return new JsonLocation(_ioContext.getSourceReference(),\n+                _currInputProcessed + _inputPtr, -1L, // bytes, chars\n+                _currInputRow, col);\n+    }\n+\n+    // @since 2.7\n+    private final void _updateLocation()\n+    {\n+        _tokenInputRow = _currInputRow;\n+        final int ptr = _inputPtr;\n+        _tokenInputTotal = _currInputProcessed + ptr;\n+        _tokenInputCol = ptr - _currInputRowStart;\n+    }\n+\n+    // @since 2.7\n+    private final void _updateNameLocation()\n+    {\n+        _nameStartRow = _currInputRow;\n+        final int ptr = _inputPtr;\n+        _nameStartOffset = ptr;\n+        _nameStartCol = ptr - _currInputRowStart;\n+    }\n+\n+    /*\n+    /**********************************************************\n     /* Internal methods, other\n     /**********************************************************\n      */\n--- a/src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java\n     final protected static int SHORT_WRITE = 32;\n \n     final protected static char[] HEX_CHARS = CharTypes.copyHexChars();\n-    \n+\n     /*\n     /**********************************************************\n     /* Output buffering\n      */\n \n     final protected Writer _writer;\n-    \n+\n     /**\n      * Intermediate buffer in which contents are buffered before\n      * being written using {@link #_writer}.\n     /**\n      * Pointer to the first buffered character to output\n      */\n-    protected int _outputHead = 0;\n+    protected int _outputHead;\n \n     /**\n      * Pointer to the position right beyond the last character to output\n      * (end marker; may point to position right beyond the end of the buffer)\n      */\n-    protected int _outputTail = 0;\n+    protected int _outputTail;\n \n     /**\n      * End marker of the output buffer; one past the last valid position\n             _reportError(\"Can not write a field name, expecting a value\");\n         }\n         _writeFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA));\n+    }\n+\n+    protected void _writeFieldName(String name, boolean commaBefore) throws IOException\n+    {\n+        if (_cfgPrettyPrinter != null) {\n+            _writePPFieldName(name, commaBefore);\n+            return;\n+        }\n+        // for fast+std case, need to output up to 2 chars, comma, dquote\n+        if ((_outputTail + 1) >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        if (commaBefore) {\n+            _outputBuffer[_outputTail++] = ',';\n+        }\n+        // Alternate mode, in which quoting of field names disabled?\n+        if (!isEnabled(Feature.QUOTE_FIELD_NAMES)) {\n+            _writeString(name);\n+            return;\n+        }\n+        // we know there's room for at least one more char\n+        _outputBuffer[_outputTail++] = '\"';\n+        // The beef:\n+        _writeString(name);\n+        // and closing quotes; need room for one more char:\n+        if (_outputTail >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = '\"';\n+    }\n+    \n+    protected void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException\n+    {\n+        if (_cfgPrettyPrinter != null) {\n+            _writePPFieldName(name, commaBefore);\n+            return;\n+        }\n+        // for fast+std case, need to output up to 2 chars, comma, dquote\n+        if ((_outputTail + 1) >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        if (commaBefore) {\n+            _outputBuffer[_outputTail++] = ',';\n+        }\n+        // Alternate mode, in which quoting of field names disabled?\n+        final char[] quoted = name.asQuotedChars();\n+        if (!isEnabled(Feature.QUOTE_FIELD_NAMES)) {\n+            writeRaw(quoted, 0, quoted.length);\n+            return;\n+        }\n+        // we know there's room for at least one more char\n+        _outputBuffer[_outputTail++] = '\"';\n+        // The beef:\n+        final int qlen = quoted.length;\n+        if ((_outputTail + qlen + 1) >= _outputEnd) {\n+            writeRaw(quoted, 0, qlen);\n+            // and closing quotes; need room for one more char:\n+            if (_outputTail >= _outputEnd) {\n+                _flushBuffer();\n+            }\n+            _outputBuffer[_outputTail++] = '\"';\n+        } else {\n+            System.arraycopy(quoted, 0, _outputBuffer, _outputTail, qlen);\n+            _outputTail += qlen;\n+            _outputBuffer[_outputTail++] = '\"';\n+        }\n     }\n     \n     /*\n             }\n             _outputBuffer[_outputTail++] = ']';\n         }\n-        _writeContext = _writeContext.getParent();\n+        _writeContext = _writeContext.clearAndGetParent();\n     }\n \n     @Override\n             }\n             _outputBuffer[_outputTail++] = '}';\n         }\n-        _writeContext = _writeContext.getParent();\n-    }\n-\n-    protected void _writeFieldName(String name, boolean commaBefore) throws IOException\n-    {\n-        if (_cfgPrettyPrinter != null) {\n-            _writePPFieldName(name, commaBefore);\n-            return;\n-        }\n-        // for fast+std case, need to output up to 2 chars, comma, dquote\n-        if ((_outputTail + 1) >= _outputEnd) {\n-            _flushBuffer();\n-        }\n-        if (commaBefore) {\n-            _outputBuffer[_outputTail++] = ',';\n-        }\n-\n-        /* To support [JACKSON-46], we'll do this:\n-         * (Question: should quoting of spaces (etc) still be enabled?)\n-         */\n-        if (!isEnabled(Feature.QUOTE_FIELD_NAMES)) {\n-            _writeString(name);\n-            return;\n-        }\n-\n-        // we know there's room for at least one more char\n-        _outputBuffer[_outputTail++] = '\"';\n-        // The beef:\n-        _writeString(name);\n-        // and closing quotes; need room for one more char:\n-        if (_outputTail >= _outputEnd) {\n-            _flushBuffer();\n-        }\n-        _outputBuffer[_outputTail++] = '\"';\n-    }\n-\n-    protected void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException\n-    {\n-        if (_cfgPrettyPrinter != null) {\n-            _writePPFieldName(name, commaBefore);\n-            return;\n-        }\n-        // for fast+std case, need to output up to 2 chars, comma, dquote\n-        if ((_outputTail + 1) >= _outputEnd) {\n-            _flushBuffer();\n-        }\n-        if (commaBefore) {\n-            _outputBuffer[_outputTail++] = ',';\n-        }\n-        /* To support [JACKSON-46], we'll do this:\n-         * (Question: should quoting of spaces (etc) still be enabled?)\n-         */\n-        final char[] quoted = name.asQuotedChars();\n-        if (!isEnabled(Feature.QUOTE_FIELD_NAMES)) {\n-            writeRaw(quoted, 0, quoted.length);\n-            return;\n-        }\n-        // we know there's room for at least one more char\n-        _outputBuffer[_outputTail++] = '\"';\n-        // The beef:\n-        final int qlen = quoted.length;\n-        if ((_outputTail + qlen + 1) >= _outputEnd) {\n-            writeRaw(quoted, 0, qlen);\n-            // and closing quotes; need room for one more char:\n-            if (_outputTail >= _outputEnd) {\n-                _flushBuffer();\n-            }\n-            _outputBuffer[_outputTail++] = '\"';\n-        } else {\n-            System.arraycopy(quoted, 0, _outputBuffer, _outputTail, qlen);\n-            _outputTail += qlen;\n-            _outputBuffer[_outputTail++] = '\"';\n-        }\n-    }\n-    \n+        _writeContext = _writeContext.clearAndGetParent();\n+    }\n+\n     /**\n      * Specialized version of <code>_writeFieldName</code>, off-lined\n      * to keep the \"fast path\" as simple (and hopefully fast) as possible.\n      */\n-    protected void _writePPFieldName(String name, boolean commaBefore)\n-        throws IOException, JsonGenerationException\n+    protected void _writePPFieldName(String name, boolean commaBefore) throws IOException\n     {\n         if (commaBefore) {\n             _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n         }\n     }\n \n-    protected void _writePPFieldName(SerializableString name, boolean commaBefore)\n-        throws IOException, JsonGenerationException\n+    protected void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException\n     {\n         if (commaBefore) {\n             _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n--- a/src/main/java/com/fasterxml/jackson/core/type/ResolvedType.java\n+++ b/src/main/java/com/fasterxml/jackson/core/type/ResolvedType.java\n      * subtypes they may be different parameters or possibly none at all).\n      * \n      * @since 2.5\n+     *\n+     * @deprecated Since 2.7: does not have meaning as parameters depend on type\n+     *    resolved.\n      */\n+    @Deprecated // since 2.7\n     public Class<?> getParameterSource() {\n         return null;\n     }\n--- a/src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java\n      * Number of open levels of nesting. Used to determine amount of\n      * indentation to use.\n      */\n-    protected transient int _nesting = 0;\n+    protected transient int _nesting;\n \n     /*\n     /**********************************************************\n      */\n \n     @Override\n-    public void writeRootValueSeparator(JsonGenerator jg)\n-        throws IOException, JsonGenerationException\n+    public void writeRootValueSeparator(JsonGenerator jg) throws IOException\n     {\n         if (_rootSeparator != null) {\n             jg.writeRaw(_rootSeparator);\n     }\n \n     @Override\n-    public void writeStartObject(JsonGenerator jg)\n-        throws IOException, JsonGenerationException\n+    public void writeStartObject(JsonGenerator jg) throws IOException\n     {\n         jg.writeRaw('{');\n         if (!_objectIndenter.isInline()) {\n     }\n \n     @Override\n-    public void beforeObjectEntries(JsonGenerator jg)\n-        throws IOException, JsonGenerationException\n+    public void beforeObjectEntries(JsonGenerator jg) throws IOException\n     {\n         _objectIndenter.writeIndentation(jg, _nesting);\n     }\n      * (white-space) decoration.\n      */\n     @Override\n-    public void writeObjectFieldValueSeparator(JsonGenerator jg)\n-        throws IOException, JsonGenerationException\n+    public void writeObjectFieldValueSeparator(JsonGenerator jg) throws IOException\n     {\n         if (_spacesInObjectEntries) {\n             jg.writeRaw(\" : \");\n      * (white-space) decoration.\n      */\n     @Override\n-    public void writeObjectEntrySeparator(JsonGenerator jg)\n-        throws IOException, JsonGenerationException\n+    public void writeObjectEntrySeparator(JsonGenerator jg) throws IOException\n     {\n         jg.writeRaw(',');\n         _objectIndenter.writeIndentation(jg, _nesting);\n     }\n \n     @Override\n-    public void writeEndObject(JsonGenerator jg, int nrOfEntries)\n-        throws IOException, JsonGenerationException\n+    public void writeEndObject(JsonGenerator jg, int nrOfEntries) throws IOException\n     {\n         if (!_objectIndenter.isInline()) {\n             --_nesting;\n     }\n \n     @Override\n-    public void writeStartArray(JsonGenerator jg)\n-        throws IOException, JsonGenerationException\n+    public void writeStartArray(JsonGenerator jg) throws IOException\n     {\n         if (!_arrayIndenter.isInline()) {\n             ++_nesting;\n     }\n \n     @Override\n-    public void beforeArrayValues(JsonGenerator jg)\n-        throws IOException, JsonGenerationException\n-    {\n+    public void beforeArrayValues(JsonGenerator jg) throws IOException {\n         _arrayIndenter.writeIndentation(jg, _nesting);\n     }\n \n         @Override\n         public boolean isInline() { return true; }\n     }\n-    \n-    /**\n-     * @deprecated Since 2.5 use {@link DefaultIndenter} instead\n-     */\n-    @Deprecated\n-    public static class Lf2SpacesIndenter extends DefaultIndenter\n-    {\n-        /** @deprecated Use {@link DefaultIndenter#SYSTEM_LINEFEED_INSTANCE} instead.\n-         */\n-        @SuppressWarnings(\"hiding\")\n-        @Deprecated\n-        public static final Lf2SpacesIndenter instance = new Lf2SpacesIndenter();\n-\n-        /** @deprecated Use {@code new DefaultIndenter(\"  \", DefaultIndenter.SYS_LF)} instead\n-         */\n-        @Deprecated\n-        public Lf2SpacesIndenter() {\n-            super(\"  \", DefaultIndenter.SYS_LF);\n-        }\n-        \n-        /** @deprecated Use {@code new DefaultIndenter(\"  \", lf)} instead\n-         */\n-        @Deprecated\n-        public Lf2SpacesIndenter(String lf) {\n-            super(\"  \", lf);\n-        }\n-\n-        /**\n-         * Note: method was accidentally missing from 2.5.0; put back for 2.5.1 and\n-         * later 2.5.x versions.\n-         */\n-        @Override\n-        public Lf2SpacesIndenter withLinefeed(String lf) {\n-            if (lf.equals(getEol())) {\n-                return this;\n-            }\n-            return new Lf2SpacesIndenter(lf);\n-        }\n-    }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n     public int getFeatureMask() { return delegate.getFeatureMask(); }\n \n     @Override\n+    @Deprecated\n     public JsonGenerator setFeatureMask(int mask) {\n         delegate.setFeatureMask(mask);\n+        return this;\n+    }\n+\n+    @Override\n+    public JsonGenerator overrideStdFeatures(int values, int mask) {\n+        delegate.overrideStdFeatures(values, mask);\n+        return this;\n+    }\n+\n+    @Override\n+    public JsonGenerator overrideFormatFeatures(int values, int mask) {\n+        delegate.overrideFormatFeatures(values, mask);\n         return this;\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/core/util/JsonParserDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonParserDelegate.java\n     @Override public int getFeatureMask() { return delegate.getFeatureMask(); }\n \n     @Override\n+    @Deprecated // since 2.7\n     public JsonParser setFeatureMask(int mask) {\n         delegate.setFeatureMask(mask);\n+        return this;\n+    }\n+\n+    @Override\n+    public JsonParser overrideStdFeatures(int values, int mask) {\n+        delegate.overrideStdFeatures(values, mask);\n+        return this;\n+    }\n+\n+    @Override\n+    public JsonParser overrideFormatFeatures(int values, int mask) {\n+        delegate.overrideFormatFeatures(values, mask);\n         return this;\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n     /**\n      * Flag that indicates whether _seqments is non-empty\n      */\n-    private boolean _hasSegments = false;\n+    private boolean _hasSegments;\n \n     // // // Currently used segment; not (yet) contained in _seqments\n \n--- a/src/test/java/com/fasterxml/jackson/core/TestExceptions.java\n+++ b/src/test/java/com/fasterxml/jackson/core/TestExceptions.java\n package com.fasterxml.jackson.core;\n \n+import java.io.StringWriter;\n \n public class TestExceptions extends BaseTest\n {\n-    // For [Issue#10]\n+    private final JsonFactory JSON_F = new JsonFactory();\n+    \n+    // For [core#10]\n     public void testOriginalMesssage()\n     {\n-        JsonProcessingException exc = new JsonParseException(\"Foobar\", JsonLocation.NA);\n+        JsonProcessingException exc = new JsonParseException(null, \"Foobar\", JsonLocation.NA);\n         String msg = exc.getMessage();\n         String orig = exc.getOriginalMessage();\n         assertEquals(\"Foobar\", orig);\n         assertTrue(msg.length() > orig.length());\n     }\n+\n+    // [core#198]\n+    public void testAccessToParser() throws Exception\n+    {\n+        JsonParser p = JSON_F.createParser(\"{}\");\n+        assertToken(JsonToken.START_OBJECT, p.nextToken());\n+        JsonParseException e = new JsonParseException(p, \"Test!\");\n+        assertSame(p, e.getProcessor());\n+        assertEquals(\"Test!\", e.getOriginalMessage());\n+        JsonLocation loc = e.getLocation();\n+        assertNotNull(loc);\n+        assertEquals(2, loc.getColumnNr());\n+        assertEquals(1, loc.getLineNr());\n+        p.close();\n+    }\n+\n+    // [core#198]\n+    public void testAccessToGenerator() throws Exception\n+    {\n+        StringWriter w = new StringWriter();\n+        JsonGenerator g = JSON_F.createGenerator(w);\n+        g.writeStartObject();\n+        JsonGenerationException e = new JsonGenerationException(\"Test!\", g);\n+        assertSame(g, e.getProcessor());\n+        assertEquals(\"Test!\", e.getOriginalMessage());\n+        g.close();\n+    }\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/LocationInArrayTest.java\n+package com.fasterxml.jackson.core.json;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+// Tests mostly for [core#229]\n+public class LocationInArrayTest extends com.fasterxml.jackson.core.BaseTest\n+{\n+    final JsonFactory JSON_F = new JsonFactory();\n+\n+    // for [core#229]\n+    public void testOffsetInArraysBytes() throws Exception {\n+        _testOffsetInArrays(true);\n+    }\n+    \n+    // for [core#229]\n+    public void testOffsetInArraysChars() throws Exception {\n+        _testOffsetInArrays(false);\n+    }        \n+\n+    private void _testOffsetInArrays(boolean useBytes) throws Exception\n+    {\n+        JsonParser p;\n+        final String DOC = \"  [10, 251,\\n   3  ]\";\n+\n+        // first, char based:\n+        p = useBytes ? JSON_F.createParser(DOC.getBytes(\"UTF-8\"))\n+                : JSON_F.createParser(DOC.toCharArray());\n+        assertToken(JsonToken.START_ARRAY, p.nextToken());\n+        _assertLocation(useBytes, p.getTokenLocation(), 2L, 1, 3);\n+        _assertLocation(useBytes, p.getCurrentLocation(), 3L, 1, 4);\n+\n+        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n+        _assertLocation(useBytes, p.getTokenLocation(), 3L, 1, 4);\n+        assertEquals(10, p.getIntValue()); // just to ensure read proceeds to end\n+        // 2-digits so\n+        _assertLocation(useBytes, p.getCurrentLocation(), 5L, 1, 6);\n+\n+        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n+        _assertLocation(useBytes, p.getTokenLocation(), 7L, 1, 8);\n+        assertEquals(251, p.getIntValue()); // just to ensure read proceeds to end\n+        _assertLocation(useBytes, p.getCurrentLocation(), 10L, 1, 11);\n+\n+        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n+        _assertLocation(useBytes, p.getTokenLocation(), 15L, 2, 4);\n+        assertEquals(3, p.getIntValue());\n+        _assertLocation(useBytes, p.getCurrentLocation(), 16L, 2, 5);\n+\n+        assertToken(JsonToken.END_ARRAY, p.nextToken());\n+        _assertLocation(useBytes, p.getTokenLocation(), 18L, 2, 7);\n+        _assertLocation(useBytes, p.getCurrentLocation(), 19L, 2, 8);\n+        \n+        p.close();\n+    }\n+\n+    private void _assertLocation(boolean useBytes, JsonLocation loc, long offset, int row, int col)\n+    {\n+        assertEquals(row, loc.getLineNr());\n+        assertEquals(col, loc.getColumnNr());\n+\n+        if (useBytes) {\n+            assertEquals(offset, loc.getByteOffset());\n+        } else {\n+            assertEquals(offset, loc.getCharOffset());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/LocationInObjectTest.java\n+package com.fasterxml.jackson.core.json;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+// tests for [core#37]\n+public class LocationInObjectTest extends BaseTest\n+{\n+    public void testOffsetWithObjectFieldsUsingUTF8() throws Exception\n+    {\n+        final JsonFactory f = new JsonFactory();\n+        byte[] b = \"{\\\"f1\\\":\\\"v1\\\",\\\"f2\\\":{\\\"f3\\\":\\\"v3\\\"},\\\"f4\\\":[true,false],\\\"f5\\\":5}\".getBytes(\"UTF-8\");\n+        //            1      6      11    16 17    22      28    33 34 39      46    51\n+        JsonParser p = f.createParser(b);\n+\n+        assertEquals(JsonToken.START_OBJECT, p.nextToken());\n+\n+        assertEquals(JsonToken.FIELD_NAME, p.nextToken());\n+        assertEquals(1L, p.getTokenLocation().getByteOffset());\n+        assertEquals(JsonToken.VALUE_STRING, p.nextToken());\n+        assertEquals(6L, p.getTokenLocation().getByteOffset());\n+\n+        assertEquals(\"f2\", p.nextFieldName());\n+        assertEquals(11L, p.getTokenLocation().getByteOffset());\n+        assertEquals(JsonToken.START_OBJECT, p.nextValue());\n+        assertEquals(16L, p.getTokenLocation().getByteOffset());\n+\n+        assertEquals(\"f3\", p.nextFieldName());\n+        assertEquals(17L, p.getTokenLocation().getByteOffset());\n+        assertEquals(JsonToken.VALUE_STRING, p.nextValue());\n+        assertEquals(22L, p.getTokenLocation().getByteOffset());\n+        assertEquals(JsonToken.END_OBJECT, p.nextToken());\n+\n+        assertEquals(\"f4\", p.nextFieldName());\n+        assertEquals(28L, p.getTokenLocation().getByteOffset());\n+        assertEquals(JsonToken.START_ARRAY, p.nextValue());\n+        assertEquals(33L, p.getTokenLocation().getByteOffset());\n+\n+        assertEquals(JsonToken.VALUE_TRUE, p.nextValue());\n+        assertEquals(34L, p.getTokenLocation().getByteOffset());\n+\n+        assertEquals(JsonToken.VALUE_FALSE, p.nextValue());\n+        assertEquals(39L, p.getTokenLocation().getByteOffset());\n+        assertEquals(JsonToken.END_ARRAY, p.nextToken());\n+\n+        assertEquals(\"f5\", p.nextFieldName());\n+        assertEquals(46L, p.getTokenLocation().getByteOffset());\n+        assertEquals(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n+        assertEquals(51L, p.getTokenLocation().getByteOffset());\n+        assertEquals(JsonToken.END_OBJECT, p.nextToken());\n+\n+        p.close();\n+    }\n+\n+    public void testOffsetWithObjectFieldsUsingReader() throws Exception\n+    {\n+        final JsonFactory f = new JsonFactory();\n+        char[] c = \"{\\\"f1\\\":\\\"v1\\\",\\\"f2\\\":{\\\"f3\\\":\\\"v3\\\"},\\\"f4\\\":[true,false],\\\"f5\\\":5}\".toCharArray();\n+        //            1      6      11    16 17    22      28    33 34 39      46    51\n+        JsonParser p = f.createParser(c);\n+\n+        assertEquals(JsonToken.START_OBJECT, p.nextToken());\n+\n+        assertEquals(JsonToken.FIELD_NAME, p.nextToken());\n+        assertEquals(1L, p.getTokenLocation().getCharOffset());\n+        assertEquals(JsonToken.VALUE_STRING, p.nextToken());\n+        assertEquals(6L, p.getTokenLocation().getCharOffset());\n+\n+        assertEquals(\"f2\", p.nextFieldName());\n+        assertEquals(11L, p.getTokenLocation().getCharOffset());\n+        assertEquals(JsonToken.START_OBJECT, p.nextValue());\n+        assertEquals(16L, p.getTokenLocation().getCharOffset());\n+\n+        assertEquals(\"f3\", p.nextFieldName());\n+        assertEquals(17L, p.getTokenLocation().getCharOffset());\n+        assertEquals(JsonToken.VALUE_STRING, p.nextValue());\n+        assertEquals(22L, p.getTokenLocation().getCharOffset());\n+        assertEquals(JsonToken.END_OBJECT, p.nextToken());\n+\n+        assertEquals(\"f4\", p.nextFieldName());\n+        assertEquals(28L, p.getTokenLocation().getCharOffset());\n+        assertEquals(JsonToken.START_ARRAY, p.nextValue());\n+        assertEquals(33L, p.getTokenLocation().getCharOffset());\n+\n+        assertEquals(JsonToken.VALUE_TRUE, p.nextValue());\n+        assertEquals(34L, p.getTokenLocation().getCharOffset());\n+\n+        assertEquals(JsonToken.VALUE_FALSE, p.nextValue());\n+        assertEquals(39L, p.getTokenLocation().getCharOffset());\n+        assertEquals(JsonToken.END_ARRAY, p.nextToken());\n+\n+        assertEquals(\"f5\", p.nextFieldName());\n+        assertEquals(46L, p.getTokenLocation().getCharOffset());\n+        assertEquals(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n+        assertEquals(51L, p.getTokenLocation().getCharOffset());\n+        assertEquals(JsonToken.END_OBJECT, p.nextToken());\n+\n+        p.close();\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestLocation.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestLocation.java\n // NOTE: just a stub so for, fill me!\n public class TestLocation extends com.fasterxml.jackson.core.BaseTest\n {\n+    final JsonFactory JSON_F = new JsonFactory();\n+\n     // Trivially simple unit test for basics wrt offsets\n     public void testSimpleInitialOffsets() throws Exception\n     {\n-        final JsonFactory f = new JsonFactory();\n         JsonLocation loc;\n         JsonParser p;\n         final String DOC = \"{ }\";\n \n         // first, char based:\n-        p = f.createParser(DOC);\n+        p = JSON_F.createParser(DOC);\n         assertToken(JsonToken.START_OBJECT, p.nextToken());\n \n         loc = p.getTokenLocation();\n \n         // then byte-based\n         \n-        p = f.createParser(DOC.getBytes(\"UTF-8\"));\n+        p = JSON_F.createParser(DOC.getBytes(\"UTF-8\"));\n         assertToken(JsonToken.START_OBJECT, p.nextToken());\n \n         loc = p.getTokenLocation();\n         p.close();\n     }\n \n-    // for [Issue#111]\n+    // for [core#111]\n     public void testOffsetWithInputOffset() throws Exception\n     {\n-        final JsonFactory f = new JsonFactory();\n         JsonLocation loc;\n         JsonParser p;\n         // 3 spaces before, 2 after, just for padding\n         byte[] b = \"   { }  \".getBytes(\"UTF-8\");\n \n         // and then peel them off\n-        p = f.createParser(b, 3, b.length-5);\n+        p = JSON_F.createParser(b, 3, b.length-5);\n         assertToken(JsonToken.START_OBJECT, p.nextToken());\n \n         loc = p.getTokenLocation();\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestNextXxx.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestNextXxx.java\n     {\n         _testIsNextTokenName1(false);\n         _testIsNextTokenName1(true);\n+    }\n+\n+    public void testIsNextTokenName2() throws Exception {\n         _testIsNextTokenName2(false);\n         _testIsNextTokenName2(true);\n+    }        \n+    \n+    public void testIsNextTokenName3() throws Exception {\n         _testIsNextTokenName3(false);\n         _testIsNextTokenName3(true);\n     }\n \n+    public void testIsNextTokenName4() throws Exception {\n+        _testIsNextTokenName4(false);\n+        _testIsNextTokenName4(true);\n+    }\n+    \n     // [jackson-core#34]\n     public void testIssue34() throws Exception\n     {\n         assertToken(JsonToken.FIELD_NAME, jp.getCurrentToken());\n         assertEquals(\"name2\", jp.getCurrentName());\n         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        // do NOT check number value, to enforce skipping\n \n         assertFalse(jp.nextFieldName(NAME));\n         assertToken(JsonToken.FIELD_NAME, jp.getCurrentToken());\n         p.close();\n     }\n \n+    private void _testIsNextTokenName4(boolean useStream) throws Exception\n+    {\n+        final String DOC = \"{\\\"name\\\":-123,\\\"name2\\\":99}\";\n+        JsonParser jp = useStream ?\n+                JSON_F.createParser(new ByteArrayInputStream(DOC.getBytes(\"UTF-8\")))\n+            : JSON_F.createParser(new StringReader(DOC));\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+\n+        assertTrue(jp.nextFieldName(new SerializedString(\"name\")));\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(-123, jp.getIntValue());\n+\n+        assertTrue(jp.nextFieldName(new SerializedString(\"name2\")));\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(99, jp.getIntValue());\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+        assertNull(jp.nextToken());\n+\n+        jp.close();\n+    }\n+\n     private void _testNextFieldNameIndent(boolean useStream) throws Exception\n     {\n         final String DOC = \"{\\n  \\\"name\\\" : \\n  [\\n  ]\\n   }\";\n \n         p.close();\n     }\n-    \n+\n     private void _textNextText(boolean useStream) throws Exception\n     {\n         final String DOC = aposToQuotes(\"{'a':'123','b':5,'c':[false,'foo']}\");\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestNumericValues.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestNumericValues.java\n             }\n             sb.append(segment);\n             sb.append('\\n');\n-            // let's add somewhat arbitray number of spaces\n+            // let's add somewhat arbitrary number of spaces\n             int x = (i & 3);\n             if (i > 300) {\n                 x += i % 5;\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestUtf8Generator.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestUtf8Generator.java\n         p.close();\n     }\n \n-    // for [Issue#115]\n+    // for [core#115]\n     public void testSurrogatesWithRaw() throws Exception\n     {\n         final String VALUE = quote(\"\\ud83d\\ude0c\");\n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n         assertEquals(6, symbols.maxCollisionLength());\n     }\n \n-    // Test for verifying stability of hashCode, wrt collisions, using\n-    // synthetic field name generation and byte-based input (UTF-8)\n-    @SuppressWarnings(\"deprecation\")\n-    public void testSyntheticWithBytesOld() throws IOException\n-    {\n-        // pass seed, to keep results consistent:\n-        final int SEED = 33333;\n-        BytesToNameCanonicalizer symbols =\n-                BytesToNameCanonicalizer.createRoot(SEED).makeChild(JsonFactory.Feature.collectDefaults());\n-\n-        final int COUNT = 12000;\n-        for (int i = 0; i < COUNT; ++i) {\n-            String id = fieldNameFor(i);\n-            int[] quads = calcQuads(id.getBytes(\"UTF-8\"));\n-            symbols.addName(id, quads, quads.length);\n-        }\n-        assertEquals(COUNT, symbols.size());\n-        assertEquals(16384, symbols.bucketCount());\n-\n-//System.out.printf(\"Byte stuff: collisions %d, max-coll %d\\n\", symbols.collisionCount(), symbols.maxCollisionLength());\n-        assertEquals(3476, symbols.collisionCount());\n-        // longest collision chain not optimal but ok:\n-        assertEquals(15, symbols.maxCollisionLength());\n-\n-        // But also verify entries are actually found?\n-    }\n-\n     public void testSyntheticWithBytesNew() throws IOException\n     {\n         // pass seed, to keep results consistent:\n         }\n     }\n \n-    @SuppressWarnings(\"deprecation\")\n-    public void testThousandsOfSymbolsWithOldBytes() throws IOException\n-    {\n-        final int SEED = 33333;\n-\n-        BytesToNameCanonicalizer symbolsBRoot = BytesToNameCanonicalizer.createRoot(SEED);\n-        final Charset utf8 = Charset.forName(\"UTF-8\");\n-        int exp = 0;\n-        \n-        for (int doc = 0; doc < 100; ++doc) {\n-            BytesToNameCanonicalizer symbolsB =\n-                    symbolsBRoot.makeChild(JsonFactory.Feature.collectDefaults());\n-            for (int i = 0; i < 250; ++i) {\n-                String name = \"f_\"+doc+\"_\"+i;\n-\n-                int[] quads = BytesToNameCanonicalizer.calcQuads(name.getBytes(utf8));\n-                symbolsB.addName(name, quads, quads.length);\n-                Name n = symbolsB.findName(quads, quads.length);\n-                assertEquals(name, n.getName());\n-            }\n-            symbolsB.release();\n-            exp += 250;\n-            if (exp > BytesToNameCanonicalizer.MAX_ENTRIES_FOR_REUSE) {\n-                exp = 0;\n-            }\n-            assertEquals(exp, symbolsBRoot.size());\n-        }\n-    }\n-\n     // Since 2.6\n     public void testThousandsOfSymbolsWithNew() throws IOException\n     {\n         Field syms = p.getClass().getDeclaredField(\"_symbols\");\n         syms.setAccessible(true);\n         return ((ByteQuadsCanonicalizer) syms.get(p));\n-    }\n-\n-    // [core#187]: unexpectedly high number of collisions for straight numbers\n-    @SuppressWarnings(\"deprecation\")\n-    public void testCollisionsWithBytes187() throws IOException\n-    {\n-        BytesToNameCanonicalizer symbols =\n-                BytesToNameCanonicalizer.createRoot(1).makeChild(JsonFactory.Feature.collectDefaults());\n-        final int COUNT = 30000;\n-        for (int i = 0; i < COUNT; ++i) {\n-            String id = String.valueOf(10000 + i);\n-            int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\"));\n-            symbols.addName(id, quads, quads.length);\n-        }\n-\n-//System.out.printf(\"Byte stuff: collisions %d, max-coll %d\\n\", symbols.collisionCount(), symbols.maxCollisionLength());\n-        \n-        assertEquals(COUNT, symbols.size());\n-        assertEquals(65536, symbols.bucketCount());\n-\n-        // collision count acceptable\n-        assertEquals(5782, symbols.collisionCount());\n-        // as well as collision counts\n-        assertEquals(24, symbols.maxCollisionLength());\n     }\n \n     // [core#187]: unexpectedly high number of collisions for straight numbers\n         assertEquals(2, symbols.maxCollisionLength());\n     }\n \n-    @SuppressWarnings(\"deprecation\")\n-    public void testShortQuotedDirectBytesOld() throws IOException\n-    {\n-        final int COUNT = 400;\n-        BytesToNameCanonicalizer symbols =\n-                BytesToNameCanonicalizer.createRoot(1).makeChild(JsonFactory.Feature.collectDefaults());\n-        for (int i = 0; i < COUNT; ++i) {\n-            String id = String.format(\"\\\\u%04x\", i);\n-            int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\"));\n-            symbols.addName(id, quads, quads.length);\n-        }\n-        assertEquals(COUNT, symbols.size());\n-        assertEquals(1024, symbols.bucketCount());\n-\n-        assertEquals(44, symbols.collisionCount());\n-        assertEquals(2, symbols.maxCollisionLength());\n-    }\n-\n     public void testShortQuotedDirectBytes() throws IOException\n     {\n         final int COUNT = 400;\n     }\n     \n     // [core#191]\n-    @SuppressWarnings(\"deprecation\")\n     public void testShortNameCollisionsDirect() throws IOException\n     {\n         final int COUNT = 600;\n             assertEquals(1024, symbols.bucketCount());\n     \n             assertEquals(16, symbols.collisionCount());\n-            assertEquals(1, symbols.maxCollisionLength());\n-        }\n-        \n-        // then byte-based\n-        {\n-            BytesToNameCanonicalizer symbols =\n-                    BytesToNameCanonicalizer.createRoot(1).makeChild(JsonFactory.Feature.collectDefaults());\n-            for (int i = 0; i < COUNT; ++i) {\n-                String id = String.valueOf((char) i);\n-                int[] quads = calcQuads(id.getBytes(\"UTF-8\"));\n-                symbols.addName(id, quads, quads.length);\n-            }\n-            assertEquals(COUNT, symbols.size());\n-            assertEquals(1024, symbols.bucketCount());\n-    \n-            assertEquals(209, symbols.collisionCount());\n             assertEquals(1, symbols.maxCollisionLength());\n         }\n     }\n--- a/src/test/java/com/fasterxml/jackson/core/util/TestNumberPrinting.java\n+++ b/src/test/java/com/fasterxml/jackson/core/util/TestNumberPrinting.java\n \n /**\n  * Set of basic unit tests for verifying that the low-level number\n- * printingg methods work as expected.\n+ * printing methods work as expected.\n  */\n public class TestNumberPrinting\n     extends com.fasterxml.jackson.core.BaseTest\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/Surrogate223Test.java\n+package com.fasterxml.jackson.failing;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.StringWriter;\n+import java.io.Writer;\n+\n+import com.fasterxml.jackson.core.BaseTest;\n+import com.fasterxml.jackson.core.JsonFactory;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonToken;\n+\n+public class Surrogate223Test extends BaseTest\n+{\n+    private final JsonFactory JSON_F = new JsonFactory();\n+    \n+    // for [core#223]\n+    public void testSurrogatesByteBacked() throws Exception\n+    {\n+        ByteArrayOutputStream out;\n+        JsonGenerator g;\n+        final String toQuote = new String(Character.toChars(0x1F602));\n+        assertEquals(2, toQuote.length()); // just sanity check\n+\n+        // default should be disabled:\n+//        assertFalse(JSON_F.isEnabled(JsonGenerator.Feature.ESCAPE_UTF8_SURROGATES));\n+\n+        out = new ByteArrayOutputStream();\n+        g = JSON_F.createGenerator(out);\n+        g.writeStartArray();\n+        g.writeString(toQuote);\n+        g.writeEndArray();\n+        g.close();\n+        assertEquals(2 + 2 + 4, out.size()); // brackets, quotes, 4-byte encoding\n+\n+        // Also parse back to ensure correctness\n+        JsonParser p = JSON_F.createParser(out.toByteArray());\n+        assertToken(JsonToken.START_ARRAY, p.nextToken());\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertToken(JsonToken.END_ARRAY, p.nextToken());\n+        p.close();\n+        \n+        // but may revert back to original behavior\n+        out = new ByteArrayOutputStream();\n+        g = JSON_F.createGenerator(out);\n+//        g.enable(JsonGenerator.Feature.ESCAPE_UTF8_SURROGATES);\n+        g.writeStartArray();\n+        g.writeString(toQuote);\n+        g.writeEndArray();\n+        g.close();\n+        assertEquals(2 + 2 + 12, out.size()); // brackets, quotes, 2 x 6 byte JSON escape\n+    }\n+\n+    // for [core#223]\n+    public void testSurrogatesCharBacked() throws Exception\n+    {\n+        Writer out;\n+        JsonGenerator g;\n+        final String toQuote = new String(Character.toChars(0x1F602));\n+        assertEquals(2, toQuote.length()); // just sanity check\n+\n+        // default should be disabled:\n+//        assertFalse(JSON_F.isEnabled(JsonGenerator.Feature.ESCAPE_UTF8_SURROGATES));\n+\n+        out = new StringWriter();\n+        g = JSON_F.createGenerator(out);\n+        g.writeStartArray();\n+        g.writeString(toQuote);\n+        g.writeEndArray();\n+        g.close();\n+        assertEquals(2 + 2 + 2, out.toString().length()); // brackets, quotes, 2 chars as is\n+\n+        // Also parse back to ensure correctness\n+        JsonParser p = JSON_F.createParser(out.toString());\n+        assertToken(JsonToken.START_ARRAY, p.nextToken());\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertToken(JsonToken.END_ARRAY, p.nextToken());\n+        p.close();\n+        \n+        // but may revert back to original behavior\n+        out = new StringWriter();\n+        g = JSON_F.createGenerator(out);\n+//        g.enable(JsonGenerator.Feature.ESCAPE_UTF8_SURROGATES);\n+        g.writeStartArray();\n+        g.writeString(toQuote);\n+        g.writeEndArray();\n+        g.close();\n+        assertEquals(2 + 2 + 12, out.toString().length()); // brackets, quotes, 2 x 6 byte JSON escape\n+    }\n+}", "timestamp": 1453780915, "metainfo": ""}