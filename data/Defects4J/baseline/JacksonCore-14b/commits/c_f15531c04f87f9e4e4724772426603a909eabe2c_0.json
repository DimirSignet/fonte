{"sha": "f15531c04f87f9e4e4724772426603a909eabe2c", "log": "Check in actual sources, moved to the new package, cleaned up a bit", "commit": "\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/Base64Variant.java\n+/* Jackson JSON-processor.\n+ *\n+ * Copyright (c) 2007- Tatu Saloranta, tatu.saloranta@iki.fi\n+ *\n+ * Licensed under the License specified in file LICENSE, included with\n+ * the source code and binary code bundles.\n+ * You may not use this file except in compliance with the License.\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.fasterxml.jackson.core;\n+\n+import java.util.Arrays;\n+\n+/**\n+ * Abstract base class used to define specific details of which\n+ * variant of Base64 encoding/decoding is to be used. Although there is\n+ * somewhat standard basic version (so-called \"MIME Base64\"), other variants\n+ * exists, see <a href=\"http://en.wikipedia.org/wiki/Base64\">Base64 Wikipedia entry</a> for details.\n+ * \n+ * @author Tatu Saloranta\n+ */\n+public final class Base64Variant\n+{\n+    /**\n+     * Placeholder used by \"no padding\" variant, to be used when a character\n+     * value is needed.\n+     */\n+    final static char PADDING_CHAR_NONE = '\\0';\n+\n+    /**\n+     * Marker used to denote ascii characters that do not correspond\n+     * to a 6-bit value (in this variant), and is not used as a padding\n+     * character.\n+     */\n+    public final static int BASE64_VALUE_INVALID = -1;\n+\n+    /**\n+     * Marker used to denote ascii character (in decoding table) that\n+     * is the padding character using this variant (if any).\n+     */\n+    public final static int BASE64_VALUE_PADDING = -2;\n+\n+    /*\n+    /**********************************************************\n+    /* Encoding/decoding tables\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Decoding table used for base 64 decoding.\n+     */\n+    private final int[] _asciiToBase64 = new int[128];\n+\n+    /**\n+     * Encoding table used for base 64 decoding when output is done\n+     * as characters.\n+     */\n+    private final char[] _base64ToAsciiC = new char[64];\n+\n+    /**\n+     * Alternative encoding table used for base 64 decoding when output is done\n+     * as ascii bytes.\n+     */\n+    private final byte[] _base64ToAsciiB = new byte[64];\n+\n+    /*\n+    /**********************************************************\n+    /* Other configuration\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Symbolic name of variant; used for diagnostics/debugging.\n+     */\n+    final String _name;\n+\n+    /**\n+     * Whether this variant uses padding or not.\n+     */\n+    final boolean _usesPadding;\n+\n+    /**\n+     * Characted used for padding, if any ({@link #PADDING_CHAR_NONE} if not).\n+     */\n+    final char _paddingChar;\n+    \n+    /**\n+     * Maximum number of encoded base64 characters to output during encoding\n+     * before adding a linefeed, if line length is to be limited\n+     * ({@link java.lang.Integer#MAX_VALUE} if not limited).\n+     *<p>\n+     * Note: for some output modes (when writing attributes) linefeeds may\n+     * need to be avoided, and this value ignored.\n+     */\n+    final int _maxLineLength;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    public Base64Variant(String name, String base64Alphabet, boolean usesPadding, char paddingChar, int maxLineLength)\n+    {\n+        _name = name;\n+        _usesPadding = usesPadding;\n+        _paddingChar = paddingChar;\n+        _maxLineLength = maxLineLength;\n+\n+        // Ok and then we need to create codec tables.\n+\n+        // First the main encoding table:\n+        int alphaLen = base64Alphabet.length();\n+        if (alphaLen != 64) {\n+            throw new IllegalArgumentException(\"Base64Alphabet length must be exactly 64 (was \"+alphaLen+\")\");\n+        }\n+\n+        // And then secondary encoding table and decoding table:\n+        base64Alphabet.getChars(0, alphaLen, _base64ToAsciiC, 0);\n+        Arrays.fill(_asciiToBase64, BASE64_VALUE_INVALID);\n+        for (int i = 0; i < alphaLen; ++i) {\n+            char alpha = _base64ToAsciiC[i];\n+            _base64ToAsciiB[i] = (byte) alpha;\n+            _asciiToBase64[alpha] = i;\n+        }\n+\n+        // Plus if we use padding, add that in too\n+        if (usesPadding) {\n+            _asciiToBase64[(int) paddingChar] = BASE64_VALUE_PADDING;\n+        }\n+    }\n+\n+    /**\n+     * \"Copy constructor\" that can be used when the base alphabet is identical\n+     * to one used by another variant except for the maximum line length\n+     * (and obviously, name).\n+     */\n+    public Base64Variant(Base64Variant base, String name, int maxLineLength)\n+    {\n+        this(base, name, base._usesPadding, base._paddingChar, maxLineLength);\n+    }\n+\n+    /**\n+     * \"Copy constructor\" that can be used when the base alphabet is identical\n+     * to one used by another variant, but other details (padding, maximum\n+     * line length) differ\n+     */\n+    public Base64Variant(Base64Variant base, String name, boolean usesPadding, char paddingChar, int maxLineLength)\n+    {\n+        _name = name;\n+        byte[] srcB = base._base64ToAsciiB;\n+        System.arraycopy(srcB, 0, this._base64ToAsciiB, 0, srcB.length);\n+        char[] srcC = base._base64ToAsciiC;\n+        System.arraycopy(srcC, 0, this._base64ToAsciiC, 0, srcC.length);\n+        int[] srcV = base._asciiToBase64;\n+        System.arraycopy(srcV, 0, this._asciiToBase64, 0, srcV.length);\n+\n+        _usesPadding = usesPadding;\n+        _paddingChar = paddingChar;\n+        _maxLineLength = maxLineLength;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public accessors\n+    /**********************************************************\n+     */\n+\n+    public String getName() { return _name; }\n+\n+    public boolean usesPadding() { return _usesPadding; }\n+    public boolean usesPaddingChar(char c) { return c == _paddingChar; }\n+    public boolean usesPaddingChar(int ch) { return ch == (int) _paddingChar; }\n+    public char getPaddingChar() { return _paddingChar; }\n+    public byte getPaddingByte() { return (byte)_paddingChar; }\n+\n+    public int getMaxLineLength() { return _maxLineLength; }\n+\n+    /*\n+    /**********************************************************\n+    /* Decoding support\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @return 6-bit decoded value, if valid character; \n+     */\n+    public int decodeBase64Char(char c)\n+    {\n+        int ch = (int) c;\n+        return (ch <= 127) ? _asciiToBase64[ch] : BASE64_VALUE_INVALID;\n+    }\n+\n+    public int decodeBase64Char(int ch)\n+    {\n+        return (ch <= 127) ? _asciiToBase64[ch] : BASE64_VALUE_INVALID;\n+    }\n+\n+    public int decodeBase64Byte(byte b)\n+    {\n+        int ch = (int) b;\n+        return (ch <= 127) ? _asciiToBase64[ch] : BASE64_VALUE_INVALID;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Encoding support\n+    /**********************************************************\n+     */\n+\n+    public char encodeBase64BitsAsChar(int value)\n+    {\n+        /* Let's assume caller has done necessary checks; this\n+         * method must be fast and inlinable\n+         */\n+        return _base64ToAsciiC[value];\n+    }\n+\n+    /**\n+     * Method that encodes given right-aligned (LSB) 24-bit value\n+     * into 4 base64 characters, stored in given result buffer.\n+     */\n+    public int encodeBase64Chunk(int b24, char[] buffer, int ptr)\n+    {\n+        buffer[ptr++] = _base64ToAsciiC[(b24 >> 18) & 0x3F];\n+        buffer[ptr++] = _base64ToAsciiC[(b24 >> 12) & 0x3F];\n+        buffer[ptr++] = _base64ToAsciiC[(b24 >> 6) & 0x3F];\n+        buffer[ptr++] = _base64ToAsciiC[b24 & 0x3F];\n+        return ptr;\n+    }\n+\n+    public void encodeBase64Chunk(StringBuilder sb, int b24)\n+    {\n+        sb.append(_base64ToAsciiC[(b24 >> 18) & 0x3F]);\n+        sb.append(_base64ToAsciiC[(b24 >> 12) & 0x3F]);\n+        sb.append(_base64ToAsciiC[(b24 >> 6) & 0x3F]);\n+        sb.append(_base64ToAsciiC[b24 & 0x3F]);\n+    }\n+\n+    /**\n+     * Method that outputs partial chunk (which only encodes one\n+     * or two bytes of data). Data given is still aligned same as if\n+     * it as full data; that is, missing data is at the \"right end\"\n+     * (LSB) of int.\n+     *\n+     * @param outputBytes Number of encoded bytes included (either 1 or 2)\n+     */\n+    public int encodeBase64Partial(int bits, int outputBytes, char[] buffer, int outPtr)\n+    {\n+        buffer[outPtr++] = _base64ToAsciiC[(bits >> 18) & 0x3F];\n+        buffer[outPtr++] = _base64ToAsciiC[(bits >> 12) & 0x3F];\n+        if (_usesPadding) {\n+            buffer[outPtr++] = (outputBytes == 2) ?\n+                _base64ToAsciiC[(bits >> 6) & 0x3F] : _paddingChar;\n+            buffer[outPtr++] = _paddingChar;\n+        } else {\n+            if (outputBytes == 2) {\n+                buffer[outPtr++] = _base64ToAsciiC[(bits >> 6) & 0x3F];\n+            }\n+        }\n+        return outPtr;\n+    }\n+\n+    public void encodeBase64Partial(StringBuilder sb, int bits, int outputBytes)\n+    {\n+        sb.append(_base64ToAsciiC[(bits >> 18) & 0x3F]);\n+        sb.append(_base64ToAsciiC[(bits >> 12) & 0x3F]);\n+        if (_usesPadding) {\n+            sb.append((outputBytes == 2) ?\n+                      _base64ToAsciiC[(bits >> 6) & 0x3F] : _paddingChar);\n+            sb.append(_paddingChar);\n+        } else {\n+            if (outputBytes == 2) {\n+                sb.append(_base64ToAsciiC[(bits >> 6) & 0x3F]);\n+            }\n+        }\n+    }\n+\n+    public byte encodeBase64BitsAsByte(int value)\n+    {\n+        // As with above, assuming it is 6-bit value\n+        return _base64ToAsciiB[value];\n+    }\n+\n+    /**\n+     * Method that encodes given right-aligned (LSB) 24-bit value\n+     * into 4 base64 bytes (ascii), stored in given result buffer.\n+     */\n+    public int encodeBase64Chunk(int b24, byte[] buffer, int ptr)\n+    {\n+        buffer[ptr++] = _base64ToAsciiB[(b24 >> 18) & 0x3F];\n+        buffer[ptr++] = _base64ToAsciiB[(b24 >> 12) & 0x3F];\n+        buffer[ptr++] = _base64ToAsciiB[(b24 >> 6) & 0x3F];\n+        buffer[ptr++] = _base64ToAsciiB[b24 & 0x3F];\n+        return ptr;\n+    }\n+\n+    /**\n+     * Method that outputs partial chunk (which only encodes one\n+     * or two bytes of data). Data given is still aligned same as if\n+     * it as full data; that is, missing data is at the \"right end\"\n+     * (LSB) of int.\n+     *\n+     * @param outputBytes Number of encoded bytes included (either 1 or 2)\n+     */\n+    public int encodeBase64Partial(int bits, int outputBytes, byte[] buffer, int outPtr)\n+    {\n+        buffer[outPtr++] = _base64ToAsciiB[(bits >> 18) & 0x3F];\n+        buffer[outPtr++] = _base64ToAsciiB[(bits >> 12) & 0x3F];\n+        if (_usesPadding) {\n+            byte pb = (byte) _paddingChar;\n+            buffer[outPtr++] = (outputBytes == 2) ?\n+                _base64ToAsciiB[(bits >> 6) & 0x3F] : pb;\n+            buffer[outPtr++] = pb;\n+        } else {\n+            if (outputBytes == 2) {\n+                buffer[outPtr++] = _base64ToAsciiB[(bits >> 6) & 0x3F];\n+            }\n+        }\n+        return outPtr;\n+    }\n+\n+    /**\n+     * Convenience method for converting given byte array as base64 encoded\n+     * String using this variant's settings.\n+     * Resulting value is \"raw\", that is, not enclosed in double-quotes.\n+     * \n+     * @param input Byte array to encode\n+     */\n+    public String encode(byte[] input)\n+    {\n+        return encode(input, false);\n+    }\n+\n+    /**\n+     * Convenience method for converting given byte array as base64 encoded\n+     * String using this variant's settings, optionally enclosed in\n+     * double-quotes.\n+     * \n+     * @param input Byte array to encode\n+     * @param addQuotes Whether to surround resulting value in double quotes or not\n+     */\n+    public String encode(byte[] input, boolean addQuotes)\n+    {\n+        int inputEnd = input.length;\n+        StringBuilder sb;\n+        {\n+            // let's approximate... 33% overhead, ~= 3/8 (0.375)\n+            int outputLen = inputEnd + (inputEnd >> 2) + (inputEnd >> 3);\n+            sb = new StringBuilder(outputLen);\n+        }\n+        if (addQuotes) {\n+            sb.append('\"');\n+        }\n+\n+        int chunksBeforeLF = getMaxLineLength() >> 2;\n+\n+        // Ok, first we loop through all full triplets of data:\n+        int inputPtr = 0;\n+        int safeInputEnd = inputEnd-3; // to get only full triplets\n+\n+        while (inputPtr <= safeInputEnd) {\n+            // First, mash 3 bytes into lsb of 32-bit int\n+            int b24 = ((int) input[inputPtr++]) << 8;\n+            b24 |= ((int) input[inputPtr++]) & 0xFF;\n+            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n+            encodeBase64Chunk(sb, b24);\n+            if (--chunksBeforeLF <= 0) {\n+                // note: must quote in JSON value, so not really useful...\n+                sb.append('\\\\');\n+                sb.append('n');\n+                chunksBeforeLF = getMaxLineLength() >> 2;\n+            }\n+        }\n+\n+        // And then we may have 1 or 2 leftover bytes to encode\n+        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n+        if (inputLeft > 0) { // yes, but do we have room for output?\n+            int b24 = ((int) input[inputPtr++]) << 16;\n+            if (inputLeft == 2) {\n+                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n+            }\n+            encodeBase64Partial(sb, b24, inputLeft);\n+        }\n+\n+        if (addQuotes) {\n+            sb.append('\"');\n+        }\n+        return sb.toString();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* other methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String toString() { return _name; }\n+}\n+\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/Base64Variants.java\n+/* Jackson JSON-processor.\n+ *\n+ * Copyright (c) 2007- Tatu Saloranta, tatu.saloranta@iki.fi\n+ *\n+ * Licensed under the License specified in file LICENSE, included with\n+ * the source code and binary code bundles.\n+ * You may not use this file except in compliance with the License.\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.fasterxml.jackson.core;\n+\n+/**\n+ * Container for commonly used Base64 variants.\n+ * \n+ * @author Tatu Saloranta\n+ */\n+public final class Base64Variants\n+{\n+    final static String STD_BASE64_ALPHABET = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n+\n+    /**\n+     * This variant is what most people would think of \"the standard\"\n+     * Base64 encoding.\n+     *<p>\n+     * See <a href=\"\">wikipedia Base64 entry</a> for details.\n+     *<p>\n+     * Note that although this can be thought of as the standard variant,\n+     * it is <b>not</b> the default for Jackson: no-linefeeds alternative\n+     * is because of JSON requirement of escaping all linefeeds.\n+     */\n+    public final static Base64Variant MIME;\n+    static {\n+        MIME = new Base64Variant(\"MIME\", STD_BASE64_ALPHABET, true, '=', 76);\n+    }\n+\n+    /**\n+     * Slightly non-standard modification of {@link #MIME} which does not\n+     * use linefeeds (max line length set to infinite). Useful when linefeeds\n+     * wouldn't work well (possibly in attributes), or for minor space savings\n+     * (save 1 linefeed per 76 data chars, ie. ~1.4% savings).\n+     */\n+    public final static Base64Variant MIME_NO_LINEFEEDS;\n+    static {\n+        MIME_NO_LINEFEEDS = new Base64Variant(MIME, \"MIME-NO-LINEFEEDS\", Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * This variant is the one that predates {@link #MIME}: it is otherwise\n+     * identical, except that it mandates shorter line length.\n+     */\n+    public final static Base64Variant PEM = new Base64Variant(MIME, \"PEM\", true, '=', 64);\n+\n+    /**\n+     * This non-standard variant is usually used when encoded data needs to be\n+     * passed via URLs (such as part of GET request). It differs from the\n+     * base {@link #MIME} variant in multiple ways.\n+     * First, no padding is used: this also means that it generally can not\n+     * be written in multiple separate but adjacent chunks (which would not\n+     * be the usual use case in any case). Also, no linefeeds are used (max\n+     * line length set to infinite). And finally, two characters (plus and\n+     * slash) that would need quoting in URLs are replaced with more\n+     * optimal alternatives (hyphen and underscore, respectively).\n+     */\n+    public final static Base64Variant MODIFIED_FOR_URL;\n+    static {\n+        StringBuffer sb = new StringBuffer(STD_BASE64_ALPHABET);\n+        // Replace plus with hyphen, slash with underscore (and no padding)\n+        sb.setCharAt(sb.indexOf(\"+\"), '-');\n+        sb.setCharAt(sb.indexOf(\"/\"), '_');\n+        /* And finally, let's not split lines either, wouldn't work too\n+         * well with URLs\n+         */\n+        MODIFIED_FOR_URL = new Base64Variant(\"MODIFIED-FOR-URL\", sb.toString(), false, Base64Variant.PADDING_CHAR_NONE, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * Method used to get the default variant (\"MIME_NO_LINEFEEDS\") for cases\n+     * where caller does not explicitly specify the variant.\n+     * We will prefer no-linefeed version because linefeeds in JSON values\n+     * must be escaped, making linefeed-containing variants sub-optimal.\n+     */\n+    public static Base64Variant getDefaultVariant() {\n+        return MIME_NO_LINEFEEDS;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/FormatSchema.java\n+package com.fasterxml.jackson.core;\n+\n+/**\n+ * Simple tag interface used to mark schema objects that are used by some\n+ * {@link JsonParser} and {@link JsonGenerator} implementations to further\n+ * specify structure of expected format.\n+ * Basic JSON-based parsers and generators do not use schemas, but some data\n+ * formats (like many binary data formats like Thrift, protobuf) mandate\n+ * use of schemas.\n+ *<p>\n+ * Since there is little commonality between schemas for different data formats,\n+ * this interface does not define much meaningful functionality for accessing\n+ * schema details; rather, specific parser and generator implementations need\n+ * to cast to schema implementations they use. This marker interface is mostly\n+ * used for tagging \"some kind of schema\" -- instead of passing opaque\n+ * {@link java.lang.Object} -- for documentation purposes.\n+ * \n+ * @since 1.8\n+ */\n+public interface FormatSchema\n+{\n+    /**\n+     * Method that can be used to get an identifier that can be used for diagnostics\n+     * purposes, to indicate what kind of data format this schema is used for: typically\n+     * it is a short name of format itself, but it can also contain additional information\n+     * in cases where data format supports multiple types of schemas.\n+     */\n+    public String getSchemaType();\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonEncoding.java\n+package com.fasterxml.jackson.core;\n+\n+/**\n+ * Enumeration that defines legal encodings that can be used\n+ * for JSON content, based on list of allowed encodings from\n+ * <a href=\"http://www.ietf.org/rfc/rfc4627.txt\">JSON specification</a>.\n+ *<p>\n+ * Note: if application want to explicitly disregard Encoding\n+ * limitations (to read in JSON encoded using an encoding not\n+ * listed as allowed), they can use {@link java.io.Reader} /\n+ * {@link java.io.Writer} instances as input\n+ */\n+public enum JsonEncoding {\n+    UTF8(\"UTF-8\", false), // N/A for big-endian, really\n+        UTF16_BE(\"UTF-16BE\", true),\n+        UTF16_LE(\"UTF-16LE\", false),\n+        UTF32_BE(\"UTF-32BE\", true),\n+        UTF32_LE(\"UTF-32LE\", false)\n+        ;\n+    \n+    protected final String _javaName;\n+\n+    protected final boolean _bigEndian;\n+    \n+    JsonEncoding(String javaName, boolean bigEndian)\n+    {\n+        _javaName = javaName;\n+        _bigEndian = bigEndian;\n+    }\n+\n+    /**\n+     * Method for accessing encoding name that JDK will support.\n+     *\n+     * @return Matching encoding name that JDK will support.\n+     */\n+    public String getJavaName() { return _javaName; }\n+\n+    /**\n+     * Whether encoding is big-endian (if encoding supports such\n+     * notion). If no such distinction is made (as is the case for\n+     * {@link #UTF8}), return value is undefined.\n+     *\n+     * @return True for big-endian encodings; false for little-endian\n+     *   (or if not applicable)\n+     */\n+    public boolean isBigEndian() { return _bigEndian; }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n+/* Jackson JSON-processor.\n+ *\n+ * Copyright (c) 2007- Tatu Saloranta, tatu.saloranta@iki.fi\n+ *\n+ * Licensed under the License specified in file LICENSE, included with\n+ * the source code and binary code bundles.\n+ * You may not use this file except in compliance with the License.\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.fasterxml.jackson.core;\n+\n+import java.io.*;\n+import java.lang.ref.SoftReference;\n+import java.net.URL;\n+\n+import com.fasterxml.jackson.core.format.InputAccessor;\n+import com.fasterxml.jackson.core.format.MatchStrength;\n+import com.fasterxml.jackson.core.io.*;\n+import com.fasterxml.jackson.core.json.ByteSourceJsonBootstrapper;\n+import com.fasterxml.jackson.core.json.ReaderBasedJsonParser;\n+import com.fasterxml.jackson.core.json.UTF8JsonGenerator;\n+import com.fasterxml.jackson.core.json.WriterBasedJsonGenerator;\n+import com.fasterxml.jackson.core.sym.BytesToNameCanonicalizer;\n+import com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\n+import com.fasterxml.jackson.core.util.BufferRecycler;\n+import com.fasterxml.jackson.core.util.VersionUtil;\n+\n+/**\n+ * The main factory class of Jackson package, used to configure and\n+ * construct reader (aka parser, {@link JsonParser})\n+ * and writer (aka generator, {@link JsonGenerator})\n+ * instances.\n+ *<p>\n+ * Factory instances are thread-safe and reusable after configuration\n+ * (if any). Typically applications and services use only a single\n+ * globally shared factory instance, unless they need differently\n+ * configured factories. Factory reuse is important if efficiency matters;\n+ * most recycling of expensive construct is done on per-factory basis.\n+ *<p>\n+ * Creation of a factory instance is a light-weight operation,\n+ * and since there is no need for pluggable alternative implementations\n+ * (as there is no \"standard\" JSON processor API to implement),\n+ * the default constructor is used for constructing factory\n+ * instances.\n+ *\n+ * @author Tatu Saloranta\n+ */\n+public class JsonFactory implements Versioned\n+{\n+    /**\n+     * Name used to identify JSON format\n+     * (and returned by {@link #getFormatName()}\n+     */\n+    public final static String FORMAT_NAME_JSON = \"JSON\";\n+    \n+    /**\n+     * Bitfield (set of flags) of all parser features that are enabled\n+     * by default.\n+     */\n+    final static int DEFAULT_PARSER_FEATURE_FLAGS = JsonParser.Feature.collectDefaults();\n+\n+    /**\n+     * Bitfield (set of flags) of all generator features that are enabled\n+     * by default.\n+     */\n+    final static int DEFAULT_GENERATOR_FEATURE_FLAGS = JsonGenerator.Feature.collectDefaults();\n+\n+    /*\n+    /**********************************************************\n+    /* Buffer, symbol table management\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * This <code>ThreadLocal</code> contains a {@link java.lang.ref.SoftRerefence}\n+     * to a {@link BufferRecycler} used to provide a low-cost\n+     * buffer recycling between reader and writer instances.\n+     */\n+    final protected static ThreadLocal<SoftReference<BufferRecycler>> _recyclerRef\n+        = new ThreadLocal<SoftReference<BufferRecycler>>();\n+\n+    /**\n+     * Each factory comes equipped with a shared root symbol table.\n+     * It should not be linked back to the original blueprint, to\n+     * avoid contents from leaking between factories.\n+     */\n+    protected CharsToNameCanonicalizer _rootCharSymbols = CharsToNameCanonicalizer.createRoot();\n+\n+    /**\n+     * Alternative to the basic symbol table, some stream-based\n+     * parsers use different name canonicalization method.\n+     *<p>\n+     * TODO: should clean up this; looks messy having 2 alternatives\n+     * with not very clear differences.\n+     */\n+    protected BytesToNameCanonicalizer _rootByteSymbols = BytesToNameCanonicalizer.createRoot();\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Object that implements conversion functionality between\n+     * Java objects and JSON content. For base JsonFactory implementation\n+     * usually not set by default, but can be explicitly set.\n+     * Sub-classes (like @link org.codehaus.jackson.map.MappingJsonFactory}\n+     * usually provide an implementation.\n+     */\n+    protected ObjectCodec _objectCodec;\n+\n+    /**\n+     * Currently enabled parser features.\n+     */\n+    protected int _parserFeatures = DEFAULT_PARSER_FEATURE_FLAGS;\n+\n+    /**\n+     * Currently enabled generator features.\n+     */\n+    protected int _generatorFeatures = DEFAULT_GENERATOR_FEATURE_FLAGS;\n+\n+    /**\n+     * Definition of custom character escapes to use for generators created\n+     * by this factory, if any. If null, standard data format specific\n+     * escapes are used.\n+     */\n+    protected CharacterEscapes _characterEscapes;\n+\n+    /**\n+     * Optional helper object that may decorate input sources, to do\n+     * additional processing on input during parsing.\n+     */\n+    protected InputDecorator _inputDecorator;\n+\n+    /**\n+     * Optional helper object that may decorate output object, to do\n+     * additional processing on output during content generation.\n+     */\n+    protected OutputDecorator _outputDecorator;\n+    \n+    /*\n+    /**********************************************************\n+    /* Construction\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Default constructor used to create factory instances.\n+     * Creation of a factory instance is a light-weight operation,\n+     * but it is still a good idea to reuse limited number of\n+     * factory instances (and quite often just a single instance):\n+     * factories are used as context for storing some reused\n+     * processing objects (such as symbol tables parsers use)\n+     * and this reuse only works within context of a single\n+     * factory instance.\n+     */\n+    public JsonFactory() { this(null); }\n+\n+    public JsonFactory(ObjectCodec oc) { _objectCodec = oc; }\n+\n+    /*\n+    /**********************************************************\n+    /* Format detection functionality (since 1.8)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that returns short textual id identifying format\n+     * this factory supports.\n+     *<p>\n+     * Note: sub-classes should override this method; default\n+     * implementation will return null for all sub-classes\n+     */\n+    public String getFormatName()\n+    {\n+        /* Somewhat nasty check: since we can't make this abstract\n+         * (due to backwards compatibility concerns), need to prevent\n+         * format name \"leakage\"\n+         */\n+        if (getClass() == JsonFactory.class) {\n+            return FORMAT_NAME_JSON;\n+        }\n+        return null;\n+    }\n+\n+    public MatchStrength hasFormat(InputAccessor acc) throws IOException\n+    {\n+        // since we can't keep this abstract, only implement for \"vanilla\" instance\n+        if (getClass() == JsonFactory.class) {\n+            return hasJSONFormat(acc);\n+        }\n+        return null;\n+    }\n+\n+    protected MatchStrength hasJSONFormat(InputAccessor acc) throws IOException\n+    {\n+        return ByteSourceJsonBootstrapper.hasJSONFormat(acc);\n+    }    \n+    \n+    /*\n+    /**********************************************************\n+    /* Versioned\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public Version version() {\n+        // VERSION is included under impl, so can't pass this class:\n+        return VersionUtil.versionFor(UTF8JsonGenerator.class);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration, parser settings\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for enabling or disabling specified parser feature\n+     * (check {@link JsonParser.Feature} for list of features)\n+     */\n+    public final JsonFactory configure(JsonParser.Feature f, boolean state)\n+    {\n+        if (state) {\n+            enable(f);\n+        } else {\n+            disable(f);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Method for enabling specified parser feature\n+     * (check {@link JsonParser.Feature} for list of features)\n+     */\n+    public JsonFactory enable(JsonParser.Feature f) {\n+        _parserFeatures |= f.getMask();\n+        return this;\n+    }\n+\n+    /**\n+     * Method for disabling specified parser features\n+     * (check {@link JsonParser.Feature} for list of features)\n+     */\n+    public JsonFactory disable(JsonParser.Feature f) {\n+        _parserFeatures &= ~f.getMask();\n+        return this;\n+    }\n+\n+    /**\n+     * Checked whether specified parser feature is enabled.\n+     */\n+    public final boolean isEnabled(JsonParser.Feature f) {\n+        return (_parserFeatures & f.getMask()) != 0;\n+    }\n+\n+    /**\n+     * Method for getting currently configured input decorator (if any;\n+     * there is no default decorator).\n+     */\n+    public InputDecorator getInputDecorator() {\n+        return _inputDecorator;\n+    }\n+\n+    /**\n+     * Method for overriding currently configured input decorator\n+     */\n+    public JsonFactory setInputDecorator(InputDecorator d) {\n+        _inputDecorator = d;\n+        return this;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration, generator settings\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for enabling or disabling specified generator feature\n+     * (check {@link JsonGenerator.Feature} for list of features)\n+     */\n+    public final JsonFactory configure(JsonGenerator.Feature f, boolean state) {\n+        if (state) {\n+            enable(f);\n+        } else {\n+            disable(f);\n+        }\n+        return this;\n+    }\n+\n+\n+    /**\n+     * Method for enabling specified generator features\n+     * (check {@link JsonGenerator.Feature} for list of features)\n+     */\n+    public JsonFactory enable(JsonGenerator.Feature f) {\n+        _generatorFeatures |= f.getMask();\n+        return this;\n+    }\n+\n+    /**\n+     * Method for disabling specified generator feature\n+     * (check {@link JsonGenerator.Feature} for list of features)\n+     */\n+    public JsonFactory disable(JsonGenerator.Feature f) {\n+        _generatorFeatures &= ~f.getMask();\n+        return this;\n+    }\n+\n+    /**\n+     * Check whether specified generator feature is enabled.\n+     */\n+    public final boolean isEnabled(JsonGenerator.Feature f) {\n+        return (_generatorFeatures & f.getMask()) != 0;\n+    }\n+\n+    /**\n+     * Method for accessing custom escapes factory uses for {@link JsonGenerator}s\n+     * it creates.\n+     */\n+    public CharacterEscapes getCharacterEscapes() {\n+        return _characterEscapes;\n+    }\n+\n+    /**\n+     * Method for defining custom escapes factory uses for {@link JsonGenerator}s\n+     * it creates.\n+     */\n+    public JsonFactory setCharacterEscapes(CharacterEscapes esc) {\n+        _characterEscapes = esc;\n+        return this;\n+    }\n+\n+    /**\n+     * Method for getting currently configured output decorator (if any;\n+     * there is no default decorator).\n+     */\n+    public OutputDecorator getOutputDecorator() {\n+        return _outputDecorator;\n+    }\n+\n+    /**\n+     * Method for overriding currently configured output decorator\n+     */\n+    public JsonFactory setOutputDecorator(OutputDecorator d) {\n+        _outputDecorator = d;\n+        return this;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration, other\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for associating a {@link ObjectCodec} (typically\n+     * a {@link org.codehaus.jackson.map.ObjectMapper}) with\n+     * this factory (and more importantly, parsers and generators\n+     * it constructs). This is needed to use data-binding methods\n+     * of {@link JsonParser} and {@link JsonGenerator} instances.\n+     */\n+    public JsonFactory setCodec(ObjectCodec oc) {\n+        _objectCodec = oc;\n+        return this;\n+    }\n+\n+    public ObjectCodec getCodec() { return _objectCodec; }\n+\n+    /*\n+    /**********************************************************\n+    /* Reader factories\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for constructing JSON parser instance to parse\n+     * contents of specified file. Encoding is auto-detected\n+     * from contents according to JSON specification recommended\n+     * mechanism.\n+     *<p>\n+     * Underlying input stream (needed for reading contents)\n+     * will be <b>owned</b> (and managed, i.e. closed as need be) by\n+     * the parser, since caller has no access to it.\n+     *\n+     * @param f File that contains JSON content to parse\n+     */\n+    public JsonParser createJsonParser(File f)\n+        throws IOException, JsonParseException\n+    {\n+        // true, since we create InputStream from File\n+        IOContext ctxt = _createContext(f, true);\n+        InputStream in = new FileInputStream(f);\n+        // [JACKSON-512]: allow wrapping with InputDecorator\n+        if (_inputDecorator != null) {\n+            in = _inputDecorator.decorate(ctxt, in);\n+        }\n+        return _createJsonParser(in, ctxt);\n+    }\n+\n+    /**\n+     * Method for constructing JSON parser instance to parse\n+     * contents of resource reference by given URL.\n+     * Encoding is auto-detected\n+     * from contents according to JSON specification recommended\n+     * mechanism.\n+     *<p>\n+     * Underlying input stream (needed for reading contents)\n+     * will be <b>owned</b> (and managed, i.e. closed as need be) by\n+     * the parser, since caller has no access to it.\n+     *\n+     * @param url URL pointing to resource that contains JSON content to parse\n+     */\n+    public JsonParser createJsonParser(URL url)\n+        throws IOException, JsonParseException\n+    {\n+        // true, since we create InputStream from URL\n+        IOContext ctxt = _createContext(url, true);\n+        InputStream in = _optimizedStreamFromURL(url);\n+        // [JACKSON-512]: allow wrapping with InputDecorator\n+        if (_inputDecorator != null) {\n+            in = _inputDecorator.decorate(ctxt, in);\n+        }\n+        return _createJsonParser(in, ctxt);\n+    }\n+\n+    /**\n+     * Method for constructing JSON parser instance to parse\n+     * the contents accessed via specified input stream.\n+     *<p>\n+     * The input stream will <b>not be owned</b> by\n+     * the parser, it will still be managed (i.e. closed if\n+     * end-of-stream is reacher, or parser close method called)\n+     * if (and only if) {@link com.fasterxml.jackson.core.JsonParser.Feature#AUTO_CLOSE_SOURCE}\n+     * is enabled.\n+     *<p>\n+     * Note: no encoding argument is taken since it can always be\n+     * auto-detected as suggested by Json RFC.\n+     *\n+     * @param in InputStream to use for reading JSON content to parse\n+     */\n+    public JsonParser createJsonParser(InputStream in)\n+        throws IOException, JsonParseException\n+    {\n+        IOContext ctxt = _createContext(in, false);\n+        // [JACKSON-512]: allow wrapping with InputDecorator\n+        if (_inputDecorator != null) {\n+            in = _inputDecorator.decorate(ctxt, in);\n+        }\n+        return _createJsonParser(in, ctxt);\n+    }\n+\n+    /**\n+     * Method for constructing parser for parsing\n+     * the contents accessed via specified Reader.\n+     <p>\n+     * The read stream will <b>not be owned</b> by\n+     * the parser, it will still be managed (i.e. closed if\n+     * end-of-stream is reacher, or parser close method called)\n+     * if (and only if) {@link com.fasterxml.jackson.core.JsonParser.Feature#AUTO_CLOSE_SOURCE}\n+     * is enabled.\n+     *<p>\n+     *\n+     * @param r Reader to use for reading JSON content to parse\n+     */\n+    public JsonParser createJsonParser(Reader r)\n+        throws IOException, JsonParseException\n+    {\n+        // false -> we do NOT own Reader (did not create it)\n+        IOContext ctxt = _createContext(r, false);\n+        // [JACKSON-512]: allow wrapping with InputDecorator\n+        if (_inputDecorator != null) {\n+            r = _inputDecorator.decorate(ctxt, r);\n+        }\n+\treturn _createJsonParser(r, ctxt);\n+    }\n+\n+    /**\n+     * Method for constructing parser for parsing\n+     * the contents of given byte array.\n+     */\n+    public JsonParser createJsonParser(byte[] data)\n+        throws IOException, JsonParseException\n+    {\n+        IOContext ctxt = _createContext(data, true);\n+        // [JACKSON-512]: allow wrapping with InputDecorator\n+        if (_inputDecorator != null) {\n+            InputStream in = _inputDecorator.decorate(ctxt, data, 0, data.length);\n+            if (in != null) {\n+                return _createJsonParser(in, ctxt);\n+            }\n+        }\n+        return _createJsonParser(data, 0, data.length, ctxt);\n+    }\n+\n+    /**\n+     * Method for constructing parser for parsing\n+     * the contents of given byte array.\n+     * \n+     * @param data Buffer that contains data to parse\n+     * @param offset Offset of the first data byte within buffer\n+     * @param len Length of contents to parse within buffer\n+     */\n+    public JsonParser createJsonParser(byte[] data, int offset, int len)\n+        throws IOException, JsonParseException\n+    {\n+        IOContext ctxt = _createContext(data, true);\n+        // [JACKSON-512]: allow wrapping with InputDecorator\n+        if (_inputDecorator != null) {\n+            InputStream in = _inputDecorator.decorate(ctxt, data, offset, len);\n+            if (in != null) {\n+                return _createJsonParser(in, ctxt);\n+            }\n+        }\n+\treturn _createJsonParser(data, offset, len, ctxt);\n+    }\n+\n+    /**\n+     * Method for constructing parser for parsing\n+     * contents of given String.\n+     */\n+    public JsonParser createJsonParser(String content)\n+        throws IOException, JsonParseException\n+    {\n+\tReader r = new StringReader(content);\n+        // true -> we own the Reader (and must close); not a big deal\n+        IOContext ctxt = _createContext(r, true);\n+        // [JACKSON-512]: allow wrapping with InputDecorator\n+        if (_inputDecorator != null) {\n+            r = _inputDecorator.decorate(ctxt, r);\n+        }\n+\treturn _createJsonParser(r, ctxt);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Generator factories\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for constructing JSON generator for writing JSON content\n+     * using specified output stream.\n+     * Encoding to use must be specified, and needs to be one of available\n+     * types (as per JSON specification).\n+     *<p>\n+     * Underlying stream <b>is NOT owned</b> by the generator constructed,\n+     * so that generator will NOT close the output stream when\n+     * {@link JsonGenerator#close} is called (unless auto-closing\n+     * feature,\n+     * {@link com.fasterxml.jackson.core.JsonGenerator.Feature#AUTO_CLOSE_TARGET}\n+     * is enabled).\n+     * Using application needs to close it explicitly if this is the case.\n+     *<p>\n+     * Note: there are formats that use fixed encoding (like most binary data formats)\n+     * and that ignore passed in encoding.\n+     *\n+     * @param out OutputStream to use for writing JSON content \n+     * @param enc Character encoding to use\n+     */\n+    public JsonGenerator createJsonGenerator(OutputStream out, JsonEncoding enc)\n+        throws IOException\n+    {\n+\t// false -> we won't manage the stream unless explicitly directed to\n+        IOContext ctxt = _createContext(out, false);\n+        ctxt.setEncoding(enc);\n+        if (enc == JsonEncoding.UTF8) {\n+            // [JACKSON-512]: allow wrapping with _outputDecorator\n+            if (_outputDecorator != null) {\n+                out = _outputDecorator.decorate(ctxt, out);\n+            }\n+            return _createUTF8JsonGenerator(out, ctxt);\n+        }\n+        Writer w = _createWriter(out, enc, ctxt);\n+        // [JACKSON-512]: allow wrapping with _outputDecorator\n+        if (_outputDecorator != null) {\n+            w = _outputDecorator.decorate(ctxt, w);\n+        }\n+\treturn _createJsonGenerator(w, ctxt);\n+    }\n+\n+    /**\n+     * Method for constructing JSON generator for writing JSON content\n+     * using specified Writer.\n+     *<p>\n+     * Underlying stream <b>is NOT owned</b> by the generator constructed,\n+     * so that generator will NOT close the Reader when\n+     * {@link JsonGenerator#close} is called (unless auto-closing\n+     * feature,\n+     * {@link com.fasterxml.jackson.core.JsonGenerator.Feature#AUTO_CLOSE_TARGET} is enabled).\n+     * Using application needs to close it explicitly.\n+     *\n+     * @param out Writer to use for writing JSON content \n+     */\n+    public JsonGenerator createJsonGenerator(Writer out)\n+        throws IOException\n+    {\n+        IOContext ctxt = _createContext(out, false);\n+        // [JACKSON-512]: allow wrapping with _outputDecorator\n+        if (_outputDecorator != null) {\n+            out = _outputDecorator.decorate(ctxt, out);\n+        }\n+\treturn _createJsonGenerator(out, ctxt);\n+    }\n+\n+    /**\n+     * Convenience method for constructing generator that uses default\n+     * encoding of the format (UTF-8 for JSON and most other data formats).\n+     *<p>\n+     * Note: there are formats that use fixed encoding (like most binary data formats).\n+     */\n+    public JsonGenerator createJsonGenerator(OutputStream out) throws IOException {\n+        return createJsonGenerator(out, JsonEncoding.UTF8);\n+    }\n+    \n+    /**\n+     * Method for constructing JSON generator for writing JSON content\n+     * to specified file, overwriting contents it might have (or creating\n+     * it if such file does not yet exist).\n+     * Encoding to use must be specified, and needs to be one of available\n+     * types (as per JSON specification).\n+     *<p>\n+     * Underlying stream <b>is owned</b> by the generator constructed,\n+     * i.e. generator will handle closing of file when\n+     * {@link JsonGenerator#close} is called.\n+     *\n+     * @param f File to write contents to\n+     * @param enc Character encoding to use\n+     */\n+    public JsonGenerator createJsonGenerator(File f, JsonEncoding enc)\n+        throws IOException\n+    {\n+\tOutputStream out = new FileOutputStream(f);\n+\t// true -> yes, we have to manage the stream since we created it\n+        IOContext ctxt = _createContext(out, true);\n+        ctxt.setEncoding(enc);\n+        if (enc == JsonEncoding.UTF8) {\n+            // [JACKSON-512]: allow wrapping with _outputDecorator\n+            if (_outputDecorator != null) {\n+                out = _outputDecorator.decorate(ctxt, out);\n+            }\n+            return _createUTF8JsonGenerator(out, ctxt);\n+        }\n+        Writer w = _createWriter(out, enc, ctxt);\n+        // [JACKSON-512]: allow wrapping with _outputDecorator\n+        if (_outputDecorator != null) {\n+            w = _outputDecorator.decorate(ctxt, w);\n+        }\n+\treturn _createJsonGenerator(w, ctxt);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Factory methods used by factory for creating parser instances,\n+    /* overridable by sub-classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Overridable factory method that actually instantiates desired parser\n+     * given {@link InputStream} and context object.\n+     *<p>\n+     * This method is specifically designed to remain\n+     * compatible between minor versions so that sub-classes can count\n+     * on it being called as expected. That is, it is part of official\n+     * interface from sub-class perspective, although not a public\n+     * method available to users of factory implementations.\n+     */\n+    protected JsonParser _createJsonParser(InputStream in, IOContext ctxt)\n+        throws IOException, JsonParseException\n+    {\n+        return new ByteSourceJsonBootstrapper(ctxt, in).constructParser(_parserFeatures,\n+                _objectCodec, _rootByteSymbols, _rootCharSymbols);\n+    }\n+\n+    /**\n+     * Overridable factory method that actually instantiates parser\n+     * using given {@link Reader} object for reading content.\n+     *<p>\n+     * This method is specifically designed to remain\n+     * compatible between minor versions so that sub-classes can count\n+     * on it being called as expected. That is, it is part of official\n+     * interface from sub-class perspective, although not a public\n+     * method available to users of factory implementations.\n+     */\n+    protected JsonParser _createJsonParser(Reader r, IOContext ctxt)\n+\tthrows IOException, JsonParseException\n+    {\n+        return new ReaderBasedJsonParser(ctxt, _parserFeatures, r, _objectCodec,\n+                _rootCharSymbols.makeChild(isEnabled(JsonParser.Feature.CANONICALIZE_FIELD_NAMES),\n+                    isEnabled(JsonParser.Feature.INTERN_FIELD_NAMES)));\n+    }\n+\n+    /**\n+     * Overridable factory method that actually instantiates parser\n+     * using given {@link Reader} object for reading content\n+     * passed as raw byte array.\n+     *<p>\n+     * This method is specifically designed to remain\n+     * compatible between minor versions so that sub-classes can count\n+     * on it being called as expected. That is, it is part of official\n+     * interface from sub-class perspective, although not a public\n+     * method available to users of factory implementations.\n+     */\n+    protected JsonParser _createJsonParser(byte[] data, int offset, int len, IOContext ctxt)\n+        throws IOException, JsonParseException\n+    {\n+        return new ByteSourceJsonBootstrapper(ctxt, data, offset, len).constructParser(_parserFeatures,\n+                _objectCodec, _rootByteSymbols, _rootCharSymbols);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Factory methods used by factory for creating generator instances,\n+    /* overridable by sub-classes\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Overridable factory method that actually instantiates generator for\n+     * given {@link Writer} and context object.\n+     *<p>\n+     * This method is specifically designed to remain\n+     * compatible between minor versions so that sub-classes can count\n+     * on it being called as expected. That is, it is part of official\n+     * interface from sub-class perspective, although not a public\n+     * method available to users of factory implementations.\n+     */\n+    protected JsonGenerator _createJsonGenerator(Writer out, IOContext ctxt)\n+        throws IOException\n+    {\n+        WriterBasedJsonGenerator gen = new WriterBasedJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n+        if (_characterEscapes != null) {\n+            gen.setCharacterEscapes(_characterEscapes);\n+        }\n+        return gen;\n+    }\n+\n+    /**\n+     * Overridable factory method that actually instantiates generator for\n+     * given {@link OutputStream} and context object, using UTF-8 encoding.\n+     *<p>\n+     * This method is specifically designed to remain\n+     * compatible between minor versions so that sub-classes can count\n+     * on it being called as expected. That is, it is part of official\n+     * interface from sub-class perspective, although not a public\n+     * method available to users of factory implementations.\n+     */\n+    protected JsonGenerator _createUTF8JsonGenerator(OutputStream out, IOContext ctxt)\n+        throws IOException\n+    {\n+        UTF8JsonGenerator gen = new UTF8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n+        if (_characterEscapes != null) {\n+            gen.setCharacterEscapes(_characterEscapes);\n+        }\n+        return gen;\n+    }\n+\n+    protected Writer _createWriter(OutputStream out, JsonEncoding enc, IOContext ctxt) throws IOException\n+    {\n+        // note: this should not get called any more (caller checks, dispatches)\n+        if (enc == JsonEncoding.UTF8) { // We have optimized writer for UTF-8\n+            return new UTF8Writer(ctxt, out);\n+        }\n+        // not optimal, but should do unless we really care about UTF-16/32 encoding speed\n+        return new OutputStreamWriter(out, enc.getJavaName());\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Internal factory methods, other\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Overridable factory method that actually instantiates desired\n+     * context object.\n+     */\n+    protected IOContext _createContext(Object srcRef, boolean resourceManaged)\n+    {\n+        return new IOContext(_getBufferRecycler(), srcRef, resourceManaged);\n+    }\n+\n+    /**\n+     * Method used by factory to create buffer recycler instances\n+     * for parsers and generators.\n+     *<p>\n+     * Note: only public to give access for <code>ObjectMapper</code>\n+     */\n+    public BufferRecycler _getBufferRecycler()\n+    {\n+        SoftReference<BufferRecycler> ref = _recyclerRef.get();\n+        BufferRecycler br = (ref == null) ? null : ref.get();\n+\n+        if (br == null) {\n+            br = new BufferRecycler();\n+            _recyclerRef.set(new SoftReference<BufferRecycler>(br));\n+        }\n+        return br;\n+    }\n+    \n+    /**\n+     * Helper methods used for constructing an optimal stream for\n+     * parsers to use, when input is to be read from an URL.\n+     * This helps when reading file content via URL.\n+     */\n+    protected InputStream _optimizedStreamFromURL(URL url)\n+        throws IOException\n+    {\n+        if (\"file\".equals(url.getProtocol())) {\n+            /* Can not do this if the path refers\n+             * to a network drive on windows. This fixes the problem;\n+             * might not be needed on all platforms (NFS?), but should not\n+             * matter a lot: performance penalty of extra wrapping is more\n+             * relevant when accessing local file system.\n+             */\n+            String host = url.getHost();\n+            if (host == null || host.length() == 0) {\n+                return new FileInputStream(url.getPath());\n+            }\n+        }\n+        return url.openStream();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonGenerationException.java\n+package com.fasterxml.jackson.core;\n+\n+/**\n+ * Exception type for exceptions during JSON writing, such as trying\n+ * to output  content in wrong context (non-matching end-array or end-object,\n+ * for example).\n+ */\n+public class JsonGenerationException\n+    extends JsonProcessingException\n+{\n+    private final static long serialVersionUID = 123; // Stupid eclipse...\n+    \n+    public JsonGenerationException(Throwable rootCause)\n+    {\n+        super(rootCause);\n+    }\n+\n+    public JsonGenerationException(String msg)\n+    {\n+        super(msg, (JsonLocation)null);\n+    }\n+\n+    public JsonGenerationException(String msg, Throwable rootCause)\n+    {\n+        super(msg, (JsonLocation)null, rootCause);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n+/* Jackson JSON-processor.\n+ *\n+ * Copyright (c) 2007- Tatu Saloranta, tatu.saloranta@iki.fi\n+ *\n+ * Licensed under the License specified in file LICENSE, included with\n+ * the source code and binary code bundles.\n+ * You may not use this file except in compliance with the License.\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.fasterxml.jackson.core;\n+\n+import java.io.*;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.io.CharacterEscapes;\n+import com.fasterxml.jackson.core.io.SerializedString;\n+\n+/**\n+ * Base class that defines public API for writing JSON content.\n+ * Instances are created using factory methods of\n+ * a {@link JsonFactory} instance.\n+ *\n+ * @author Tatu Saloranta\n+ */\n+public abstract class JsonGenerator\n+    implements Closeable, Versioned\n+{\n+    /**\n+     * Enumeration that defines all togglable features for generators.\n+     */\n+    public enum Feature {\n+        /**\n+         * Feature that determines whether generator will automatically\n+         * close underlying output target that is NOT owned by the\n+         * generator.\n+         * If disabled, calling application has to separately\n+         * close the underlying {@link OutputStream} and {@link Writer}\n+         * instances used to create the generator. If enabled, generator\n+         * will handle closing, as long as generator itself gets closed:\n+         * this happens when end-of-input is encountered, or generator\n+         * is closed by a call to {@link JsonGenerator#close}.\n+         *<p>\n+         * Feature is enabled by default.\n+         */\n+        AUTO_CLOSE_TARGET(true),\n+\n+        /**\n+         * Feature that determines what happens when the generator is\n+         * closed while there are still unmatched\n+         * {@link JsonToken#START_ARRAY} or {@link JsonToken#START_OBJECT}\n+         * entries in output content. If enabled, such Array(s) and/or\n+         * Object(s) are automatically closed; if disabled, nothing\n+         * specific is done.\n+         *<p>\n+         * Feature is enabled by default.\n+         */\n+        AUTO_CLOSE_JSON_CONTENT(true),\n+\n+        /**\n+         * Feature that determines whether JSON Object field names are\n+         * quoted using double-quotes, as specified by JSON specification\n+         * or not. Ability to disable quoting was added to support use\n+         * cases where they are not usually expected, which most commonly\n+         * occurs when used straight from Javascript.\n+         */\n+        QUOTE_FIELD_NAMES(true),\n+\n+        /**\n+         * Feature that determines whether \"exceptional\" (not real number)\n+         * float/double values are output as quoted strings.\n+         * The values checked are Double.Nan,\n+         * Double.POSITIVE_INFINITY and Double.NEGATIVE_INIFINTY (and \n+         * associated Float values).\n+         * If feature is disabled, these numbers are still output using\n+         * associated literal values, resulting in non-conformant\n+         * output.\n+         *<p>\n+         * Feature is enabled by default.\n+         */\n+        QUOTE_NON_NUMERIC_NUMBERS(true),\n+\n+        /**\n+         * Feature that forces all Java numbers to be written as JSON strings.\n+         * Default state is 'false', meaning that Java numbers are to\n+         * be serialized using basic numeric serialization (as JSON\n+         * numbers, integral or floating point). If enabled, all such\n+         * numeric values are instead written out as JSON Strings.\n+         *<p>\n+         * One use case is to avoid problems with Javascript limitations:\n+         * since Javascript standard specifies that all number handling\n+         * should be done using 64-bit IEEE 754 floating point values,\n+         * result being that some 64-bit integer values can not be\n+         * accurately represent (as mantissa is only 51 bit wide).\n+         *<p>\n+         * Feature is disabled by default.\n+         *\n+         * @since 1.3\n+         */\n+        WRITE_NUMBERS_AS_STRINGS(false),\n+\n+        /**\n+         * Feature that specifies that calls to {@link #flush} will cause\n+         * matching <code>flush()</code> to underlying {@link OutputStream}\n+         * or {@link Writer}; if disabled this will not be done.\n+         * Main reason to disable this feature is to prevent flushing at\n+         * generator level, if it is not possible to prevent method being\n+         * called by other code (like <code>ObjectMapper</code> or third\n+         * party libraries).\n+         *<p>\n+         * Feature is enabled by default.\n+         * \n+         * @since 1.7\n+         */\n+        FLUSH_PASSED_TO_STREAM(true),\n+        \n+        /**\n+         * Feature that specifies that all characters beyond 7-bit ASCII\n+         * range (i.e. code points of 128 and above) need to be output\n+         * using format-specific escapes (for JSON, backslash escapes),\n+         * if format uses escaping mechanisms (which is generally true\n+         * for textual formats but not for binary formats).\n+         * \n+         * @since 1.8\n+         */\n+        ESCAPE_NON_ASCII(false)\n+        \n+            ;\n+\n+        final boolean _defaultState;\n+\n+        final int _mask;\n+        \n+        /**\n+         * Method that calculates bit set (flags) of all features that\n+         * are enabled by default.\n+         */\n+        public static int collectDefaults()\n+        {\n+            int flags = 0;\n+            for (Feature f : values()) {\n+                if (f.enabledByDefault()) {\n+                    flags |= f.getMask();\n+                }\n+            }\n+            return flags;\n+        }\n+        \n+        private Feature(boolean defaultState) {\n+            _defaultState = defaultState;\n+            _mask = (1 << ordinal());\n+        }\n+        \n+        public boolean enabledByDefault() { return _defaultState; }\n+    \n+        public int getMask() { return _mask; }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Object that handles pretty-printing (usually additional\n+     * white space to make results more human-readable) during\n+     * output. If null, no pretty-printing is done.\n+     */\n+    protected PrettyPrinter _cfgPrettyPrinter;\n+\n+    /*\n+    /**********************************************************\n+    /* Construction, configuration, initialization\n+    /**********************************************************\n+     */\n+    \n+    protected JsonGenerator() { }\n+\n+    /**\n+     * Method to call to make this generator use specified schema.\n+     * Method must be called before generating any content, right after instance\n+     * has been created.\n+     * Note that not all generators support schemas; and those that do usually only\n+     * accept specific types of schemas: ones defined for data format this generator\n+     * produces.\n+     *<p>\n+     * If generator does not support specified schema, {@link UnsupportedOperationException}\n+     * is thrown.\n+     * \n+     * @param schema Schema to use\n+     * \n+     * @throws UnsupportedOperationException if generator does not support schema\n+     * \n+     * @since 1.8\n+     */\n+    public void setSchema(FormatSchema schema)\n+    {\n+        throw new UnsupportedOperationException(\"Generator of type \"+getClass().getName()+\" does not support schema of type '\"\n+                +schema.getSchemaType()+\"'\");\n+    }\n+    \n+    /**\n+     * Method that can be used to verify that given schema can be used with\n+     * this generator (using {@link #setSchema}).\n+     * \n+     * @param schema Schema to check\n+     * \n+     * @return True if this generator can use given schema; false if not\n+     * \n+     * @since 1.8\n+     */\n+    public boolean canUseSchema(FormatSchema schema) {\n+        return false;\n+    }\n+    \n+    /**\n+     * @since 1.6\n+     */\n+    @Override\n+    public Version version() {\n+        return Version.unknownVersion();\n+    }\n+\n+    /**\n+     * Method that can be used to get access to object that is used\n+     * as target for generated output; this is usually either\n+     * {@link OutputStream} or {@link Writer}, depending on what\n+     * generator was constructed with.\n+     * Note that returned value may be null in some cases; including\n+     * case where implementation does not want to exposed raw\n+     * source to caller.\n+     * In cases where output has been decorated, object returned here\n+     * is the decorated version; this allows some level of interaction\n+     * between users of generator and decorator object.\n+     *<p>\n+     * In general use of this accessor should be considered as\n+     * \"last effort\", i.e. only used if no other mechanism is applicable.\n+     * \n+     * @since 1.8\n+     */\n+    public Object getOutputTarget() {\n+        return null;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, configuration\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for enabling specified parser features:\n+     * check {@link Feature} for list of available features.\n+     *\n+     * @return Generator itself (this), to allow chaining\n+     *\n+     * @since 1.2\n+     */\n+    public abstract JsonGenerator enable(Feature f);\n+\n+    /**\n+     * Method for disabling specified  features\n+     * (check {@link Feature} for list of features)\n+     *\n+     * @return Generator itself (this), to allow chaining\n+     *\n+     * @since 1.2\n+     */\n+    public abstract JsonGenerator disable(Feature f);\n+\n+    /**\n+     * Method for enabling or disabling specified feature:\n+     * check {@link Feature} for list of available features.\n+     *\n+     * @return Generator itself (this), to allow chaining\n+     *\n+     * @since 1.2\n+     */\n+    public JsonGenerator configure(Feature f, boolean state)\n+    {\n+        if (state) {\n+            enable(f);\n+        } else {\n+            disable(f);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Method for checking whether given feature is enabled.\n+     * Check {@link Feature} for list of available features.\n+     *\n+     * @since 1.2\n+     */\n+    public abstract boolean isEnabled(Feature f);\n+\n+    /**\n+     * Method that can be called to set or reset the object to\n+     * use for writing Java objects as JsonContent\n+     * (using method {@link #writeObject}).\n+     *\n+     * @return Generator itself (this), to allow chaining\n+     */\n+    public abstract JsonGenerator setCodec(ObjectCodec oc);\n+\n+    /**\n+     * Method for accessing the object used for writing Java\n+     * object as Json content\n+     * (using method {@link #writeObject}).\n+     */\n+    public abstract ObjectCodec getCodec();\n+\n+    /*\n+    /**********************************************************\n+    /* Configuring generator\n+    /**********************************************************\n+      */\n+\n+    /**\n+     * Method for setting a custom pretty printer, which is usually\n+     * used to add indentation for improved human readability.\n+     * By default, generator does not do pretty printing.\n+     *<p>\n+     * To use the default pretty printer that comes with core\n+     * Jackson distribution, call {@link #useDefaultPrettyPrinter}\n+     * instead.\n+     *\n+     * @return Generator itself (this), to allow chaining\n+     */\n+    public JsonGenerator setPrettyPrinter(PrettyPrinter pp) {\n+        _cfgPrettyPrinter = pp;\n+        return this;\n+    }\n+\n+    /**\n+     * Convenience method for enabling pretty-printing using\n+     * the default pretty printer\n+     * ({@link com.fasterxml.jackson.core.util.DefaultPrettyPrinter}).\n+     *\n+     * @return Generator itself (this), to allow chaining\n+     */\n+    public abstract JsonGenerator useDefaultPrettyPrinter();\n+\n+    /**\n+     * Method that can be called to request that generator escapes\n+     * all character codes above specified code point (if positive value);\n+     * or, to not escape any characters except for ones that must be\n+     * escaped for the data format (if -1).\n+     * To force escaping of all non-ASCII characters, for example,\n+     * this method would be called with value of 127.\n+     *<p>\n+     * Note that generators are NOT required to support setting of value\n+     * higher than 127, because there are other ways to affect quoting\n+     * (or lack thereof) of character codes between 0 and 127.\n+     * Not all generators support concept of escaping, either; if so,\n+     * calling this method will have no effect.\n+     *<p>\n+     * Default implementation does nothing; sub-classes need to redefine\n+     * it according to rules of supported data format.\n+     * \n+     * @param charCode Either -1 to indicate that no additional escaping\n+     *   is to be done; or highest code point not to escape (meaning higher\n+     *   ones will be), if positive value.\n+     * \n+     * @since 1.8\n+     */\n+    public JsonGenerator setHighestNonEscapedChar(int charCode) {\n+        return this;\n+    }\n+\n+    /**\n+     * Accessor method for testing what is the highest unescaped character\n+     * configured for this generator. This may be either positive value\n+     * (when escaping configuration has been set and is in effect), or\n+     * 0 to indicate that no additional escaping is in effect.\n+     * Some generators may not support additional escaping: for example,\n+     * generators for binary formats that do not use escaping should\n+     * simply return 0.\n+     * \n+     * @return Currently active limitation for highest non-escaped character,\n+     *   if defined; or -1 to indicate no additional escaping is performed.\n+     */\n+    public int getHighestEscapedChar() {\n+        return 0;\n+    }\n+    /**\n+     * Method for accessing custom escapes factory uses for {@link JsonGenerator}s\n+     * it creates.\n+     * \n+     * @since 1.8\n+     */\n+    public CharacterEscapes getCharacterEscapes() {\n+        return null;\n+    }\n+\n+    /**\n+     * Method for defining custom escapes factory uses for {@link JsonGenerator}s\n+     * it creates.\n+     * \n+     * @since 1.8\n+     */\n+    public JsonGenerator setCharacterEscapes(CharacterEscapes esc) {\n+        return this;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, structural\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for writing starting marker of a JSON Array value\n+     * (character '['; plus possible white space decoration\n+     * if pretty-printing is enabled).\n+     *<p>\n+     * Array values can be written in any context where values\n+     * are allowed: meaning everywhere except for when\n+     * a field name is expected.\n+     */\n+    public abstract void writeStartArray()\n+        throws IOException, JsonGenerationException;\n+\n+    /**\n+     * Method for writing closing marker of a JSON Array value\n+     * (character ']'; plus possible white space decoration\n+     * if pretty-printing is enabled).\n+     *<p>\n+     * Marker can be written if the innermost structured type\n+     * is Array.\n+     */\n+    public abstract void writeEndArray()\n+        throws IOException, JsonGenerationException;\n+\n+    /**\n+     * Method for writing starting marker of a JSON Object value\n+     * (character '{'; plus possible white space decoration\n+     * if pretty-printing is enabled).\n+     *<p>\n+     * Object values can be written in any context where values\n+     * are allowed: meaning everywhere except for when\n+     * a field name is expected.\n+     */\n+    public abstract void writeStartObject()\n+        throws IOException, JsonGenerationException;\n+\n+    /**\n+     * Method for writing closing marker of a JSON Object value\n+     * (character '}'; plus possible white space decoration\n+     * if pretty-printing is enabled).\n+     *<p>\n+     * Marker can be written if the innermost structured type\n+     * is Object, and the last written event was either a\n+     * complete value, or START-OBJECT marker (see JSON specification\n+     * for more details).\n+     */\n+    public abstract void writeEndObject()\n+        throws IOException, JsonGenerationException;\n+\n+    /**\n+     * Method for writing a field name (JSON String surrounded by\n+     * double quotes: syntactically identical to a JSON String value),\n+     * possibly decorated by white space if pretty-printing is enabled.\n+     *<p>\n+     * Field names can only be written in Object context (check out\n+     * JSON specification for details), when field name is expected\n+     * (field names alternate with values).\n+     */\n+    public abstract void writeFieldName(String name)\n+        throws IOException, JsonGenerationException;\n+\n+    /**\n+     * Method similar to {@link #writeFieldName(String)}, main difference\n+     * being that it may perform better as some of processing (such as\n+     * quoting of certain characters, or encoding into external encoding\n+     * if supported by generator) can be done just once and reused for\n+     * later calls.\n+     *<p>\n+     * Default implementation simple uses unprocessed name container in\n+     * serialized String; implementations are strongly encouraged to make\n+     * use of more efficient methods argument object has.\n+     * \n+     * @since 1.6\n+     */\n+    public void writeFieldName(SerializedString name)\n+        throws IOException, JsonGenerationException\n+    {\n+        writeFieldName(name.getValue());\n+    }\n+\n+    /**\n+     * Method similar to {@link #writeFieldName(String)}, main difference\n+     * being that it may perform better as some of processing (such as\n+     * quoting of certain characters, or encoding into external encoding\n+     * if supported by generator) can be done just once and reused for\n+     * later calls.\n+     *<p>\n+     * Default implementation simple uses unprocessed name container in\n+     * serialized String; implementations are strongly encouraged to make\n+     * use of more efficient methods argument object has.\n+     * \n+     * @since 1.7\n+     */\n+    public void writeFieldName(SerializableString name)\n+        throws IOException, JsonGenerationException\n+    {\n+        writeFieldName(name.getValue());\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, text/String values\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for outputting a String value. Depending on context\n+     * this means either array element, (object) field value or\n+     * a stand alone String; but in all cases, String will be\n+     * surrounded in double quotes, and contents will be properly\n+     * escaped as required by JSON specification.\n+     */\n+    public abstract void writeString(String text)\n+        throws IOException, JsonGenerationException;\n+\n+    /**\n+     * Method for outputting a String value. Depending on context\n+     * this means either array element, (object) field value or\n+     * a stand alone String; but in all cases, String will be\n+     * surrounded in double quotes, and contents will be properly\n+     * escaped as required by JSON specification.\n+     */\n+    public abstract void writeString(char[] text, int offset, int len)\n+        throws IOException, JsonGenerationException;\n+\n+    /**\n+     * Method similar to {@link #writeString(String)}, but that takes\n+     * {@link SerializableString} which can make this potentially\n+     * more efficient to call as generator may be able to reuse\n+     * quoted and/or encoded representation.\n+     *<p>\n+     * Default implementation just calls {@link #writeString(String)};\n+     * sub-classes should override it with more efficient implementation\n+     * if possible.\n+     * \n+     * @since 1.7\n+     */\n+    public void writeString(SerializableString text)\n+        throws IOException, JsonGenerationException\n+    {\n+        writeString(text.getValue());\n+    }\n+\n+    /**\n+     * Method similar to {@link #writeString(String)} but that takes as\n+     * its input a UTF-8 encoded String that is to be output as-is, without additional\n+     * escaping (type of which depends on data format; backslashes for JSON).\n+     * However, quoting that data format requires (like double-quotes for JSON) will be added\n+     * around the value if and as necessary.\n+     *<p>\n+     * Note that some backends may choose not to support this method: for\n+     * example, if underlying destination is a {@link java.io.Writer}\n+     * using this method would require UTF-8 decoding.\n+     * If so, implementation may instead choose to throw a\n+     * {@link UnsupportedOperationException} due to ineffectiveness\n+     * of having to decode input.\n+     * \n+     * @since 1.7\n+     */\n+    public abstract void writeRawUTF8String(byte[] text, int offset, int length)\n+        throws IOException, JsonGenerationException;\n+\n+    /**\n+     * Method similar to {@link #writeString(String)} but that takes as its input\n+     * a UTF-8 encoded String which has <b>not</b> been escaped using whatever\n+     * escaping scheme data format requires (for JSON that is backslash-escaping\n+     * for control characters and double-quotes; for other formats something else).\n+     * This means that textual JSON backends need to check if value needs\n+     * JSON escaping, but otherwise can just be copied as is to output.\n+     * Also, quoting that data format requires (like double-quotes for JSON) will be added\n+     * around the value if and as necessary.\n+     *<p>\n+     * Note that some backends may choose not to support this method: for\n+     * example, if underlying destination is a {@link java.io.Writer}\n+     * using this method would require UTF-8 decoding.\n+     * In this case\n+     * generator implementation may instead choose to throw a\n+     * {@link UnsupportedOperationException} due to ineffectiveness\n+     * of having to decode input.\n+     * \n+     * @since 1.7\n+     */\n+    public abstract void writeUTF8String(byte[] text, int offset, int length)\n+        throws IOException, JsonGenerationException;\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, binary/raw content\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method that will force generator to copy\n+     * input text verbatim with <b>no</b> modifications (including\n+     * that no escaping is done and no separators are added even\n+     * if context [array, object] would otherwise require such).\n+     * If such separators are desired, use\n+     * {@link #writeRawValue(String)} instead.\n+     *<p>\n+     * Note that not all generator implementations necessarily support\n+     * such by-pass methods: those that do not will throw\n+     * {@link UnsupportedOperationException}.\n+     */\n+    public abstract void writeRaw(String text)\n+        throws IOException, JsonGenerationException;\n+\n+    /**\n+     * Method that will force generator to copy\n+     * input text verbatim with <b>no</b> modifications (including\n+     * that no escaping is done and no separators are added even\n+     * if context [array, object] would otherwise require such).\n+     * If such separators are desired, use\n+     * {@link #writeRawValue(String)} instead.\n+     *<p>\n+     * Note that not all generator implementations necessarily support\n+     * such by-pass methods: those that do not will throw\n+     * {@link UnsupportedOperationException}.\n+     */\n+    public abstract void writeRaw(String text, int offset, int len)\n+        throws IOException, JsonGenerationException;\n+\n+    /**\n+     * Method that will force generator to copy\n+     * input text verbatim with <b>no</b> modifications (including\n+     * that no escaping is done and no separators are added even\n+     * if context [array, object] would otherwise require such).\n+     * If such separators are desired, use\n+     * {@link #writeRawValue(String)} instead.\n+     *<p>\n+     * Note that not all generator implementations necessarily support\n+     * such by-pass methods: those that do not will throw\n+     * {@link UnsupportedOperationException}.\n+     */\n+    public abstract void writeRaw(char[] text, int offset, int len)\n+        throws IOException, JsonGenerationException;\n+\n+    /**\n+     * Method that will force generator to copy\n+     * input text verbatim with <b>no</b> modifications (including\n+     * that no escaping is done and no separators are added even\n+     * if context [array, object] would otherwise require such).\n+     * If such separators are desired, use\n+     * {@link #writeRawValue(String)} instead.\n+     *<p>\n+     * Note that not all generator implementations necessarily support\n+     * such by-pass methods: those that do not will throw\n+     * {@link UnsupportedOperationException}.\n+     */\n+    public abstract void writeRaw(char c)\n+        throws IOException, JsonGenerationException;\n+\n+    /**\n+     * Method that will force generator to copy\n+     * input text verbatim without any modifications, but assuming\n+     * it must constitute a single legal JSON value (number, string,\n+     * boolean, null, Array or List). Assuming this, proper separators\n+     * are added if and as needed (comma or colon), and generator\n+     * state updated to reflect this.\n+     */\n+    public abstract void writeRawValue(String text)\n+        throws IOException, JsonGenerationException;\n+\n+    public abstract void writeRawValue(String text, int offset, int len)\n+        throws IOException, JsonGenerationException;\n+\n+    public abstract void writeRawValue(char[] text, int offset, int len)\n+        throws IOException, JsonGenerationException;\n+\n+    /**\n+     * Method that will output given chunk of binary data as base64\n+     * encoded, as a complete String value (surrounded by double quotes).\n+     * This method defaults\n+     *<p>\n+     * Note: because Json Strings can not contain unescaped linefeeds,\n+     * if linefeeds are included (as per last argument), they must be\n+     * escaped. This adds overhead for decoding without improving\n+     * readability.\n+     * Alternatively if linefeeds are not included,\n+     * resulting String value may violate the requirement of base64\n+     * RFC which mandates line-length of 76 characters and use of\n+     * linefeeds. However, all {@link JsonParser} implementations\n+     * are required to accept such \"long line base64\"; as do\n+     * typical production-level base64 decoders.\n+     *\n+     * @param b64variant Base64 variant to use: defines details such as\n+     *   whether padding is used (and if so, using which character);\n+     *   what is the maximum line length before adding linefeed,\n+     *   and also the underlying alphabet to use.\n+     */\n+    public abstract void writeBinary(Base64Variant b64variant,\n+                                     byte[] data, int offset, int len)\n+        throws IOException, JsonGenerationException;\n+\n+    /**\n+     * Similar to {@link #writeBinary(Base64Variant,byte[],int,int)},\n+     * but default to using the Jackson default Base64 variant \n+     * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}).\n+     */\n+    public void writeBinary(byte[] data, int offset, int len)\n+        throws IOException, JsonGenerationException\n+    {\n+        writeBinary(Base64Variants.getDefaultVariant(), data, offset, len);\n+    }\n+\n+    /**\n+     * Similar to {@link #writeBinary(Base64Variant,byte[],int,int)},\n+     * but assumes default to using the Jackson default Base64 variant \n+     * (which is {@link Base64Variants#MIME_NO_LINEFEEDS}). Also\n+     * assumes that whole byte array is to be output.\n+     */\n+    public void writeBinary(byte[] data)\n+        throws IOException, JsonGenerationException\n+    {\n+        writeBinary(Base64Variants.getDefaultVariant(), data, 0, data.length);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, other value types\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for outputting given value as Json number.\n+     * Can be called in any context where a value is expected\n+     * (Array value, Object field value, root-level value).\n+     * Additional white space may be added around the value\n+     * if pretty-printing is enabled.\n+     */\n+    public abstract void writeNumber(int v)\n+        throws IOException, JsonGenerationException;\n+\n+    /**\n+     * Method for outputting given value as Json number.\n+     * Can be called in any context where a value is expected\n+     * (Array value, Object field value, root-level value).\n+     * Additional white space may be added around the value\n+     * if pretty-printing is enabled.\n+     */\n+    public abstract void writeNumber(long v)\n+        throws IOException, JsonGenerationException;\n+\n+    /**\n+     * Method for outputting given value as Json number.\n+     * Can be called in any context where a value is expected\n+     * (Array value, Object field value, root-level value).\n+     * Additional white space may be added around the value\n+     * if pretty-printing is enabled.\n+     */\n+    public abstract void writeNumber(BigInteger v)\n+        throws IOException, JsonGenerationException;\n+\n+    /**\n+     * Method for outputting indicate Json numeric value.\n+     * Can be called in any context where a value is expected\n+     * (Array value, Object field value, root-level value).\n+     * Additional white space may be added around the value\n+     * if pretty-printing is enabled.\n+     */\n+    public abstract void writeNumber(double d)\n+        throws IOException, JsonGenerationException;\n+\n+    /**\n+     * Method for outputting indicate Json numeric value.\n+     * Can be called in any context where a value is expected\n+     * (Array value, Object field value, root-level value).\n+     * Additional white space may be added around the value\n+     * if pretty-printing is enabled.\n+     */\n+    public abstract void writeNumber(float f)\n+        throws IOException, JsonGenerationException;\n+\n+    /**\n+     * Method for outputting indicate Json numeric value.\n+     * Can be called in any context where a value is expected\n+     * (Array value, Object field value, root-level value).\n+     * Additional white space may be added around the value\n+     * if pretty-printing is enabled.\n+     */\n+    public abstract void writeNumber(BigDecimal dec)\n+        throws IOException, JsonGenerationException;\n+\n+    /**\n+     * Write method that can be used for custom numeric types that can\n+     * not be (easily?) converted to \"standard\" Java number types.\n+     * Because numbers are not surrounded by double quotes, regular\n+     * {@link #writeString} method can not be used; nor\n+     * {@link #writeRaw} because that does not properly handle\n+     * value separators needed in Array or Object contexts.\n+     *<p>\n+     * Note: because of lack of type safety, some generator\n+     * implementations may not be able to implement this\n+     * method. For example, if a binary json format is used,\n+     * it may require type information for encoding; similarly\n+     * for generator-wrappers around Java objects or Json nodes.\n+     * If implementation does not implement this method,\n+     * it needs to throw {@link UnsupportedOperationException}.\n+     */\n+    public abstract void writeNumber(String encodedValue)\n+        throws IOException, JsonGenerationException,\n+               UnsupportedOperationException;\n+\n+    /**\n+     * Method for outputting literal Json boolean value (one of\n+     * Strings 'true' and 'false').\n+     * Can be called in any context where a value is expected\n+     * (Array value, Object field value, root-level value).\n+     * Additional white space may be added around the value\n+     * if pretty-printing is enabled.\n+     */\n+    public abstract void writeBoolean(boolean state)\n+        throws IOException, JsonGenerationException;\n+\n+    /**\n+     * Method for outputting literal Json null value.\n+     * Can be called in any context where a value is expected\n+     * (Array value, Object field value, root-level value).\n+     * Additional white space may be added around the value\n+     * if pretty-printing is enabled.\n+     */\n+    public abstract void writeNull()\n+        throws IOException, JsonGenerationException;\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, serializing Java objects\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for writing given Java object (POJO) as Json.\n+     * Exactly how the object gets written depends on object\n+     * in question (ad on codec, its configuration); for most\n+     * beans it will result in Json object, but for others Json\n+     * array, or String or numeric value (and for nulls, Json\n+     * null literal.\n+     * <b>NOTE</b>: generator must have its <b>object codec</b>\n+     * set to non-null value; for generators created by a mapping\n+     * factory this is the case, for others not.\n+     */\n+    public abstract void writeObject(Object pojo)\n+        throws IOException, JsonProcessingException;\n+\n+    /**\n+     * Method for writing given JSON tree (expressed as a tree\n+     * where given JsonNode is the root) using this generator.\n+     * This will generally just call\n+     * {@link #writeObject} with given node, but is added\n+     * for convenience and to make code more explicit in cases\n+     * where it deals specifically with trees.\n+     */\n+    public abstract void writeTree(JsonNode rootNode)\n+        throws IOException, JsonProcessingException;\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, convenience field write methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Convenience method for outputting a field entry (\"member\")\n+     * that has a String value. Equivalent to:\n+     *<pre>\n+     *  writeFieldName(fieldName);\n+     *  writeString(value);\n+     *</pre>\n+     *<p>\n+     * Note: many performance-sensitive implementations override this method\n+     */\n+    public void writeStringField(String fieldName, String value)\n+        throws IOException, JsonGenerationException\n+    {\n+        writeFieldName(fieldName);\n+        writeString(value);\n+    }\n+\n+    /**\n+     * Convenience method for outputting a field entry (\"member\")\n+     * that has a boolean value. Equivalent to:\n+     *<pre>\n+     *  writeFieldName(fieldName);\n+     *  writeBoolean(value);\n+     *</pre>\n+     */\n+    public final void writeBooleanField(String fieldName, boolean value)\n+        throws IOException, JsonGenerationException\n+    {\n+        writeFieldName(fieldName);\n+        writeBoolean(value);\n+    }\n+\n+    /**\n+     * Convenience method for outputting a field entry (\"member\")\n+     * that has JSON literal value null. Equivalent to:\n+     *<pre>\n+     *  writeFieldName(fieldName);\n+     *  writeNull();\n+     *</pre>\n+     */\n+    public final void writeNullField(String fieldName)\n+        throws IOException, JsonGenerationException\n+    {\n+        writeFieldName(fieldName);\n+        writeNull();\n+    }\n+    /**\n+     * Convenience method for outputting a field entry (\"member\")\n+     * that has the specified numeric value. Equivalent to:\n+     *<pre>\n+     *  writeFieldName(fieldName);\n+     *  writeNumber(value);\n+     *</pre>\n+     */\n+    public final void writeNumberField(String fieldName, int value)\n+        throws IOException, JsonGenerationException\n+    {\n+        writeFieldName(fieldName);\n+        writeNumber(value);\n+    }\n+\n+    /**\n+     * Convenience method for outputting a field entry (\"member\")\n+     * that has the specified numeric value. Equivalent to:\n+     *<pre>\n+     *  writeFieldName(fieldName);\n+     *  writeNumber(value);\n+     *</pre>\n+     */\n+    public final void writeNumberField(String fieldName, long value)\n+        throws IOException, JsonGenerationException\n+    {\n+        writeFieldName(fieldName);\n+        writeNumber(value);\n+    }\n+\n+    /**\n+     * Convenience method for outputting a field entry (\"member\")\n+     * that has the specified numeric value. Equivalent to:\n+     *<pre>\n+     *  writeFieldName(fieldName);\n+     *  writeNumber(value);\n+     *</pre>\n+     */\n+    public final void writeNumberField(String fieldName, double value)\n+        throws IOException, JsonGenerationException\n+    {\n+        writeFieldName(fieldName);\n+        writeNumber(value);\n+    }\n+\n+    /**\n+     * Convenience method for outputting a field entry (\"member\")\n+     * that has the specified numeric value. Equivalent to:\n+     *<pre>\n+     *  writeFieldName(fieldName);\n+     *  writeNumber(value);\n+     *</pre>\n+     */\n+    public final void writeNumberField(String fieldName, float value)\n+        throws IOException, JsonGenerationException\n+    {\n+        writeFieldName(fieldName);\n+        writeNumber(value);\n+    }\n+\n+    /**\n+     * Convenience method for outputting a field entry (\"member\")\n+     * that has the specified numeric value.\n+     * Equivalent to:\n+     *<pre>\n+     *  writeFieldName(fieldName);\n+     *  writeNumber(value);\n+     *</pre>\n+     */\n+    public final void writeNumberField(String fieldName, BigDecimal value)\n+        throws IOException, JsonGenerationException\n+    {\n+        writeFieldName(fieldName);\n+        writeNumber(value);\n+    }\n+\n+    /**\n+     * Convenience method for outputting a field entry (\"member\")\n+     * that contains specified data in base64-encoded form.\n+     * Equivalent to:\n+     *<pre>\n+     *  writeFieldName(fieldName);\n+     *  writeBinary(value);\n+     *</pre>\n+     */\n+    public final void writeBinaryField(String fieldName, byte[] data)\n+        throws IOException, JsonGenerationException\n+    {\n+        writeFieldName(fieldName);\n+        writeBinary(data);\n+    }\n+\n+    /**\n+     * Convenience method for outputting a field entry (\"member\")\n+     * (that will contain a JSON Array value), and the START_ARRAY marker.\n+     * Equivalent to:\n+     *<pre>\n+     *  writeFieldName(fieldName);\n+     *  writeStartArray();\n+     *</pre>\n+     *<p>\n+     * Note: caller still has to take care to close the array\n+     * (by calling {#link #writeEndArray}) after writing all values\n+     * of the value Array.\n+     */\n+    public final void writeArrayFieldStart(String fieldName)\n+        throws IOException, JsonGenerationException\n+    {\n+        writeFieldName(fieldName);\n+        writeStartArray();\n+    }\n+\n+    /**\n+     * Convenience method for outputting a field entry (\"member\")\n+     * (that will contain a JSON Object value), and the START_OBJECT marker.\n+     * Equivalent to:\n+     *<pre>\n+     *  writeFieldName(fieldName);\n+     *  writeStartObject();\n+     *</pre>\n+     *<p>\n+     * Note: caller still has to take care to close the Object\n+     * (by calling {#link #writeEndObject}) after writing all\n+     * entries of the value Object.\n+     */\n+    public final void writeObjectFieldStart(String fieldName)\n+        throws IOException, JsonGenerationException\n+    {\n+        writeFieldName(fieldName);\n+        writeStartObject();\n+    }\n+\n+    /**\n+     * Convenience method for outputting a field entry (\"member\")\n+     * that has contents of specific Java object as its value.\n+     * Equivalent to:\n+     *<pre>\n+     *  writeFieldName(fieldName);\n+     *  writeObject(pojo);\n+     *</pre>\n+     */\n+    public final void writeObjectField(String fieldName, Object pojo)\n+        throws IOException, JsonProcessingException\n+    {\n+        writeFieldName(fieldName);\n+        writeObject(pojo);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, copy-through methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for copying contents of the current event that\n+     * the given parser instance points to.\n+     * Note that the method <b>will not</b> copy any other events,\n+     * such as events contained within Json Array or Object structures.\n+     *<p>\n+     * Calling this method will not advance the given\n+     * parser, although it may cause parser to internally process\n+     * more data (if it lazy loads contents of value events, for example)\n+     */\n+    public abstract void copyCurrentEvent(JsonParser jp)\n+        throws IOException, JsonProcessingException;\n+\n+    /**\n+     * Method for copying contents of the current event\n+     * <b>and following events that it encloses</b>\n+     * the given parser instance points to.\n+     *<p>\n+     * So what constitutes enclosing? Here is the list of\n+     * events that have associated enclosed events that will\n+     * get copied:\n+     *<ul>\n+     * <li>{@link JsonToken#START_OBJECT}:\n+     *   all events up to and including matching (closing)\n+     *   {@link JsonToken#END_OBJECT} will be copied\n+     *  </li>\n+     * <li>{@link JsonToken#START_ARRAY}\n+     *   all events up to and including matching (closing)\n+     *   {@link JsonToken#END_ARRAY} will be copied\n+     *  </li>\n+     * <li>{@link JsonToken#FIELD_NAME} the logical value (which\n+     *   can consist of a single scalar value; or a sequence of related\n+     *   events for structured types (Json Arrays, Objects)) will\n+     *   be copied along with the name itself. So essentially the\n+     *   whole <b>field entry</b> (name and value) will be copied.\n+     *  </li>\n+     *</ul>\n+     *<p>\n+     * After calling this method, parser will point to the\n+     * <b>last event</b> that was copied. This will either be\n+     * the event parser already pointed to (if there were no\n+     * enclosed events), or the last enclosed event copied.\n+     */\n+    public abstract void copyCurrentStructure(JsonParser jp)\n+        throws IOException, JsonProcessingException;\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, context access\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @return Context object that can give information about logical\n+     *   position within generated json content.\n+     */\n+    public abstract JsonStreamContext getOutputContext();\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, buffer handling\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to flush any buffered content to the underlying\n+     * target (output stream, writer), and to flush the target itself\n+     * as well.\n+     */\n+    public abstract void flush() throws IOException;\n+\n+    /**\n+     * Method that can be called to determine whether this generator\n+     * is closed or not. If it is closed, no more output can be done.\n+     */\n+    public abstract boolean isClosed();\n+\n+    /*\n+    /**********************************************************\n+    /* Closeable implementation\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to close this generator, so that no more content\n+     * can be written.\n+     *<p>\n+     * Whether the underlying target (stream, writer) gets closed depends\n+     * on whether this generator either manages the target (i.e. is the\n+     * only one with access to the target -- case if caller passes a\n+     * reference to the resource such as File, but not stream); or\n+     * has feature {@link Feature#AUTO_CLOSE_TARGET} enabled.\n+     * If either of above is true, the target is also closed. Otherwise\n+     * (not managing, feature not enabled), target is not closed.\n+     */\n+    @Override\n+    public abstract void close()\n+        throws IOException;\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonLocation.java\n+package com.fasterxml.jackson.core;\n+\n+/**\n+ * Object that encapsulates Location information used for reporting\n+ * parsing (or potentially generation) errors, as well as current location\n+ * within input streams.\n+ */\n+public class JsonLocation\n+    implements java.io.Serializable // as per [JACKSON-168]\n+{\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * Shared immutable \"N/A location\" that can be returned to indicate\n+     * that no location information is available\n+     *\n+     * @since 1.3\n+     */\n+    public final static JsonLocation NA = new JsonLocation(\"N/A\", -1L, -1L, -1, -1);\n+\n+    final long _totalBytes;\n+    final long _totalChars;\n+\n+    final int _lineNr;\n+    final int _columnNr;\n+\n+    /**\n+     * Displayable description for input source: file path, url\n+     */\n+    final Object _sourceRef;\n+\n+    public JsonLocation(Object srcRef, long totalChars, int lineNr, int colNr)\n+    {\n+        /* Unfortunately, none of legal encodings are straight single-byte\n+         * encodings. Could determine offset for UTF-16/UTF-32, but the\n+         * most important one is UTF-8...\n+         * so for now, we'll just not report any real byte count\n+         */\n+        this(srcRef, -1L, totalChars, lineNr, colNr);\n+    }\n+\n+    // 22-Dec-2011, tatu: TODO: add deserializer for this type instead:\n+    //@JsonCreator\n+    public JsonLocation(/*@JsonProperty(\"sourceRef\")*/ Object sourceRef,\n+                        /*@JsonProperty(\"byteOffset\")*/ long totalBytes,\n+                        /*@JsonProperty(\"charOffset\")*/ long totalChars,\n+                        /*@JsonProperty(\"lineNr\")*/ int lineNr,\n+                        /*@JsonProperty(\"columnNr\")*/ int columnNr)\n+    {\n+        _sourceRef = sourceRef;\n+        _totalBytes = totalBytes;\n+        _totalChars = totalChars;\n+        _lineNr = lineNr;\n+        _columnNr = columnNr;\n+    }\n+\n+    /**\n+     * Reference to the original resource being read, if one available.\n+     * For example, when a parser has been constructed by passing\n+     * a {@link java.io.File} instance, this method would return\n+     * that File. Will return null if no such reference is available,\n+     * for example when {@link java.io.InputStream} was used to\n+     * construct the parser instance.\n+     */\n+    public Object getSourceRef() { return _sourceRef; }\n+\n+    /**\n+     * @return Line number of the location (1-based)\n+     */\n+    public int getLineNr() { return _lineNr; }\n+\n+    /**\n+     * @return Column number of the location (1-based)\n+     */\n+    public int getColumnNr() { return _columnNr; }\n+\n+    /**\n+     * @return Character offset within underlying stream, reader or writer,\n+     *   if available; -1 if not.\n+     */\n+    public long getCharOffset() { return _totalChars; }\n+\n+    /**\n+     * @return Byte offset within underlying stream, reader or writer,\n+     *   if available; -1 if not.\n+     */\n+    public long getByteOffset()\n+    {\n+        return _totalBytes;\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        StringBuilder sb = new StringBuilder(80);\n+        sb.append(\"[Source: \");\n+        if (_sourceRef == null) {\n+            sb.append(\"UNKNOWN\");\n+        } else {\n+            sb.append(_sourceRef.toString());\n+        }\n+        sb.append(\"; line: \");\n+        sb.append(_lineNr);\n+        sb.append(\", column: \");\n+        sb.append(_columnNr);\n+        sb.append(']');\n+        return sb.toString();\n+    }\n+\n+    @Override\n+    public int hashCode()\n+    {\n+        int hash = (_sourceRef == null) ? 1 : _sourceRef.hashCode();\n+        hash ^= _lineNr;\n+        hash += _columnNr;\n+        hash ^= (int) _totalChars;\n+        hash += (int) _totalBytes;\n+        return hash;\n+    }\n+\n+    @Override\n+    public boolean equals(Object other)\n+    {\n+        if (other == this) return true;\n+        if (other == null) return false;\n+        if (!(other instanceof JsonLocation)) return false;\n+        JsonLocation otherLoc = (JsonLocation) other;\n+\n+        if (_sourceRef == null) {\n+            if (otherLoc._sourceRef != null) return false;\n+        } else if (!_sourceRef.equals(otherLoc._sourceRef)) return false;\n+\n+        return (_lineNr == otherLoc._lineNr)\n+            && (_columnNr == otherLoc._columnNr)\n+            && (_totalChars == otherLoc._totalChars)\n+            && (getByteOffset() == otherLoc.getByteOffset())\n+            ;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonNode.java\n+package com.fasterxml.jackson.core;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.*;\n+\n+/**\n+ * Base class for all JSON nodes, which form the basis of JSON\n+ * Tree Model that Jackson implements.\n+ * One way to think of these nodes is to consider them\n+ * similar to DOM nodes in XML DOM trees.\n+ *<p>\n+ * As a general design rule, most accessors (\"getters\") are included\n+ * in this base class, to allow for traversing structure without\n+ * type casts. Most mutators, however, need to be accessed through\n+ * specific sub-classes (such as <code>org.codehaus.jackson.node.ObjectNode</code>\n+ * and <code>org.codehaus.jackson.node.ArrayNode</code>).\n+ * This seems sensible because proper type\n+ * information is generally available when building or modifying\n+ * trees, but less often when reading a tree (newly built from\n+ * parsed JSON content).\n+ *<p>\n+ * Actual concrete sub-classes can be found from package\n+ * {@link org.codehaus.jackson.node}, which is in 'mapper' jar\n+ * (whereas this class is in 'core' jar, since it is declared as\n+ * nominal type for operations in {@link ObjectCodec})\n+ */\n+public abstract class JsonNode\n+    implements Iterable<JsonNode>\n+{\n+    protected final static List<JsonNode> NO_NODES = Collections.emptyList();\n+    protected final static List<String> NO_STRINGS = Collections.emptyList();\n+\n+    protected JsonNode() { }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, type introspection\n+    /**********************************************************\n+     */\n+\n+    // // First high-level division between values, containers and \"missing\"\n+\n+    /**\n+     * Method that returns true for all value nodes: ones that \n+     * are not containers, and that do not represent \"missing\" nodes\n+     * in the path. Such value nodes represent String, Number, Boolean\n+     * and null values from JSON.\n+     *<p>\n+     * Note: one and only one of methods {@link #isValueNode},\n+     * {@link #isContainerNode} and {@link #isMissingNode} ever\n+     * returns true for any given node.\n+     */\n+    public boolean isValueNode() { return false; }\n+\n+    /**\n+     * Method that returns true for container nodes: Arrays and Objects.\n+     *<p>\n+     * Note: one and only one of methods {@link #isValueNode},\n+     * {@link #isContainerNode} and {@link #isMissingNode} ever\n+     * returns true for any given node.\n+     */\n+    public boolean isContainerNode() { return false; }\n+\n+    /**\n+     * Method that returns true for \"virtual\" nodes which represent\n+     * missing entries constructed by path accessor methods when\n+     * there is no actual node matching given criteria.\n+     *<p>\n+     * Note: one and only one of methods {@link #isValueNode},\n+     * {@link #isContainerNode} and {@link #isMissingNode} ever\n+     * returns true for any given node.\n+     */\n+    public boolean isMissingNode() { return false; }\n+\n+    // // Then more specific type introspection\n+    // // (along with defaults to be overridden)\n+\n+    /**\n+     * @return True if this node represents Json Array\n+     */\n+    public boolean isArray() { return false; }\n+\n+    /**\n+     * @return True if this node represents Json Object\n+     */\n+    public boolean isObject() { return false; }\n+\n+    /**\n+     * Method that can be used to check if the node is a wrapper\n+     * for a POJO (\"Plain Old Java Object\" aka \"bean\".\n+     * Returns true only for\n+     * instances of {@link org.codehaus.jackson.node.POJONode}.\n+     *\n+     * @return True if this node wraps a POJO\n+     */\n+    public boolean isPojo() { return false; }\n+\n+    /**\n+     * @return True if this node represents a numeric Json\n+     *   value\n+     */\n+    public boolean isNumber() { return false; }\n+\n+    /**\n+     * @return True if this node represents an integral (integer)\n+     *   numeric Json value\n+     */\n+    public boolean isIntegralNumber() { return false; }\n+\n+    /**\n+     * @return True if this node represents a non-integral\n+     *   numeric Json value\n+     */\n+    public boolean isFloatingPointNumber() { return false; }\n+\n+    /**\n+     * @return True if this node represents an integral\n+     *   numeric Json value that withs in Java int value space\n+     */\n+    public boolean isInt() { return false; }\n+\n+    /**\n+     * @return True if this node represents an integral\n+     *   numeric Json value that fits in Java long value space\n+     *   (but not int value space, i.e. {@link #isInt} returns false)\n+     */\n+    public boolean isLong() { return false; }\n+\n+    public boolean isDouble() { return false; }\n+    public boolean isBigDecimal() { return false; }\n+    public boolean isBigInteger() { return false; }\n+\n+    public boolean isTextual() { return false; }\n+\n+    /**\n+     * Method that can be used to check if this node was created from\n+     * Json boolean value (literals \"true\" and \"false\").\n+     */\n+    public boolean isBoolean() { return false; }\n+\n+    /**\n+     * Method that can be used to check if this node was created from\n+     * Json liternal null value.\n+     */\n+    public boolean isNull() { return false; }\n+\n+    /**\n+     * Method that can be used to check if this node represents\n+     * binary data (Base64 encoded). Although this will be externally\n+     * written as Json String value, {@link #isTextual} will\n+     * return false if this method returns true.\n+     *\n+     * @return True if this node represents base64 encoded binary data\n+     */\n+    public boolean isBinary() { return false; }\n+\n+    /**\n+     * Method that can be used for efficient type detection\n+     * when using stream abstraction for traversing nodes.\n+     * Will return the first {@link JsonToken} that equivalent\n+     * stream event would produce (for most nodes there is just\n+     * one token but for structured/container types multiple)\n+     */\n+    public abstract JsonToken asToken();\n+\n+    /**\n+     * If this node is a numeric type (as per {@link #isNumber}),\n+     * returns native type that node uses to store the numeric\n+     * value.\n+     */\n+    public abstract JsonParser.NumberType getNumberType();\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, straight value access\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method to use for accessing String values.\n+     * Does <b>NOT</b> do any conversions for non-String value nodes;\n+     * for non-String values (ones for which {@link #isTextual} returns\n+     * false) null will be returned.\n+     * For String values, null is never returned (but empty Strings may be)\n+     *\n+     * @return Textual value this node contains, iff it is a textual\n+     *   json node (comes from Json String value entry)\n+     */\n+    public String getTextValue() { return null; }\n+\n+    /**\n+     * Method to use for accessing binary content of binary nodes (nodes\n+     * for which {@link #isBinary} returns true); or for Text Nodes\n+     * (ones for which {@link #getTextValue} returns non-null value),\n+     * to read decoded base64 data.\n+     * For other types of nodes, returns null.\n+     *\n+     * @return Binary data this node contains, iff it is a binary\n+     *   node; null otherwise\n+     */\n+    public byte[] getBinaryValue() throws IOException\n+    {\n+        return null;\n+    }\n+\n+    /**\n+     * Method to use for accessing JSON boolean values (value\n+     * literals 'true' and 'false').\n+     * For other types, always returns false.\n+     *\n+     * @return Textual value this node contains, iff it is a textual\n+     *   json node (comes from Json String value entry)\n+     */\n+    public boolean getBooleanValue() { return false; }\n+\n+    /**\n+     * Returns numeric value for this node, <b>if and only if</b>\n+     * this node is numeric ({@link #isNumber} returns true); otherwise\n+     * returns null\n+     *\n+     * @return Number value this node contains, if any (null for non-number\n+     *   nodes).\n+     */\n+    public Number getNumberValue() { return null; }\n+\n+    /**\n+     * Returns integer value for this node, <b>if and only if</b>\n+     * this node is numeric ({@link #isNumber} returns true). For other\n+     * types returns 0.\n+     * For floating-point numbers, value is truncated using default\n+     * Java coercion, similar to how cast from double to int operates.\n+     *\n+     * @return Integer value this node contains, if any; 0 for non-number\n+     *   nodes.\n+     */\n+    public int getIntValue() { return 0; }\n+\n+    public long getLongValue() { return 0L; }\n+    public double getDoubleValue() { return 0.0; }\n+    public BigDecimal getDecimalValue() { return BigDecimal.ZERO; }\n+    public BigInteger getBigIntegerValue() { return BigInteger.ZERO; }\n+\n+    /**\n+     * Method for accessing value of the specified element of\n+     * an array node. For other nodes, null is always returned.\n+     *<p>\n+     * For array nodes, index specifies\n+     * exact location within array and allows for efficient iteration\n+     * over child elements (underlying storage is guaranteed to\n+     * be efficiently indexable, i.e. has random-access to elements).\n+     * If index is less than 0, or equal-or-greater than\n+     * <code>node.size()</code>, null is returned; no exception is\n+     * thrown for any index.\n+     *\n+     * @return Node that represent value of the specified element,\n+     *   if this node is an array and has specified element.\n+     *   Null otherwise.\n+     */\n+    public JsonNode get(int index) { return null; }\n+\n+    /**\n+     * Method for accessing value of the specified field of\n+     * an object node. If this node is not an object (or it\n+     * does not have a value for specified field name), or\n+     * if there is no field with such name, null is returned.\n+     *\n+     * @return Node that represent value of the specified field,\n+     *   if this node is an object and has value for the specified\n+     *   field. Null otherwise.\n+     */\n+    public JsonNode get(String fieldName) { return null; }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, value access with conversion(s)/coercion(s)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that will return valid String representation of\n+     * the container value, if the node is a value node\n+     * (method {@link #isValueNode} returns true), otherwise\n+     * empty String.\n+     */\n+    public abstract String asText();\n+\n+    /**\n+     * Method that will try to convert value of this node to a Java <b>int</b>.\n+     * Numbers are coerced using default Java rules; booleans convert to 0 (false)\n+     * and 1 (true), and Strings are parsed using default Java language integer\n+     * parsing rules.\n+     *<p>\n+     * If representation can not be converted to an int (including structured types\n+     * like Objects and Arrays),\n+     * default value of <b>0</b> will be returned; no exceptions are thrown.\n+     */\n+    public int asInt() {\n+        return asInt(0);\n+    }\n+    \n+    /**\n+     * Method that will try to convert value of this node to a Java <b>int</b>.\n+     * Numbers are coerced using default Java rules; booleans convert to 0 (false)\n+     * and 1 (true), and Strings are parsed using default Java language integer\n+     * parsing rules.\n+     *<p>\n+     * If representation can not be converted to an int (including structured types\n+     * like Objects and Arrays),\n+     * specified <b>defaultValue</b> will be returned; no exceptions are thrown.\n+     */\n+    public int asInt(int defaultValue) {\n+        return defaultValue;\n+    }\n+\n+    /**\n+     * Method that will try to convert value of this node to a Java <b>long</b>.\n+     * Numbers are coerced using default Java rules; booleans convert to 0 (false)\n+     * and 1 (true), and Strings are parsed using default Java language integer\n+     * parsing rules.\n+     *<p>\n+     * If representation can not be converted to an long (including structured types\n+     * like Objects and Arrays),\n+     * default value of <b>0</b> will be returned; no exceptions are thrown.\n+     */\n+    public long asLong() {\n+        return asLong(0L);\n+    }\n+    \n+    /**\n+     * Method that will try to convert value of this node to a Java <b>long</b>.\n+     * Numbers are coerced using default Java rules; booleans convert to 0 (false)\n+     * and 1 (true), and Strings are parsed using default Java language integer\n+     * parsing rules.\n+     *<p>\n+     * If representation can not be converted to an long (including structured types\n+     * like Objects and Arrays),\n+     * specified <b>defaultValue</b> will be returned; no exceptions are thrown.\n+     */\n+    public long asLong(long defaultValue) {\n+        return defaultValue;\n+    }\n+    \n+    /**\n+     * Method that will try to convert value of this node to a Java <b>double</b>.\n+     * Numbers are coerced using default Java rules; booleans convert to 0.0 (false)\n+     * and 1.0 (true), and Strings are parsed using default Java language integer\n+     * parsing rules.\n+     *<p>\n+     * If representation can not be converted to an int (including structured types\n+     * like Objects and Arrays),\n+     * default value of <b>0.0</b> will be returned; no exceptions are thrown.\n+     */\n+    public double asDouble() {\n+        return asDouble(0.0);\n+    }\n+    \n+    /**\n+     * Method that will try to convert value of this node to a Java <b>double</b>.\n+     * Numbers are coerced using default Java rules; booleans convert to 0.0 (false)\n+     * and 1.0 (true), and Strings are parsed using default Java language integer\n+     * parsing rules.\n+     *<p>\n+     * If representation can not be converted to an int (including structured types\n+     * like Objects and Arrays),\n+     * specified <b>defaultValue</b> will be returned; no exceptions are thrown.\n+     */\n+    public double asDouble(double defaultValue) {\n+        return defaultValue;\n+    }\n+\n+    /**\n+     * Method that will try to convert value of this node to a Java <b>boolean</b>.\n+     * JSON booleans map naturally; integer numbers other than 0 map to true, and\n+     * 0 maps to false\n+     * and Strings 'true' and 'false' map to corresponding values.\n+     *<p>\n+     * If representation can not be converted to a boolean value (including structured types\n+     * like Objects and Arrays),\n+     * default value of <b>false</b> will be returned; no exceptions are thrown.\n+     */\n+    public boolean asBoolean() {\n+        return asBoolean(false);\n+    }\n+    \n+    /**\n+     * Method that will try to convert value of this node to a Java <b>boolean</b>.\n+     * JSON booleans map naturally; integer numbers other than 0 map to true, and\n+     * 0 maps to false\n+     * and Strings 'true' and 'false' map to corresponding values.\n+     *<p>\n+     * If representation can not be converted to a boolean value (including structured types\n+     * like Objects and Arrays),\n+     * specified <b>defaultValue</b> will be returned; no exceptions are thrown.\n+     */\n+    public boolean asBoolean(boolean defaultValue) {\n+        return defaultValue;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, value find / existence check methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method that allows checking whether this node is JSON Object node\n+     * and contains value for specified property. If this is the case\n+     * (including properties with explicit null values), returns true;\n+     * otherwise returns false.\n+     *<p>\n+     * This method is equivalent to:\n+     *<pre>\n+     *   node.get(fieldName) != null\n+     *</pre>\n+     * (since return value of get() is node, not value node contains)\n+     *\n+     * @param fieldName Name of element to check\n+     * \n+     * @return True if this node is a JSON Object node, and has a property\n+     *   entry with specified name (with any value, including null value)\n+     */\n+    public boolean has(String fieldName) {\n+        return get(fieldName) != null;\n+    }\n+\n+    /**\n+     * Method that allows checking whether this node is JSON Array node\n+     * and contains a value for specified index\n+     * If this is the case\n+     * (including case of specified indexing having null as value), returns true;\n+     * otherwise returns false.\n+     *<p>\n+     * Note: array element indexes are 0-based.\n+     *<p>\n+     * This method is equivalent to:\n+     *<pre>\n+     *   node.get(index) != null\n+     *</pre>\n+     *\n+     * @param index Index to check\n+     * \n+     * @return True if this node is a JSON Object node, and has a property\n+     *   entry with specified name (with any value, including null value)\n+     */\n+    public boolean has(int index) {\n+        return get(index) != null;\n+    }\n+\n+    /**\n+     * Method for finding a JSON Object field with specified name in this\n+     * node or its child nodes, and returning value it has.\n+     * If no matching field is found in this node or its descendants, returns null.\n+     * \n+     * @param fieldName Name of field to look for\n+     * \n+     * @return Value of first matching node found, if any; null if none\n+     */\n+    public abstract JsonNode findValue(String fieldName);\n+\n+    /**\n+     * Method for finding JSON Object fields with specified name, and returning\n+     * found ones as a List. Note that sub-tree search ends if a field is found,\n+     * so possible children of result nodes are <b>not</b> included.\n+     * If no matching fields are found in this node or its descendants, returns\n+     * an empty List.\n+     * \n+     * @param fieldName Name of field to look for\n+     */\n+    public final List<JsonNode> findValues(String fieldName)\n+    {\n+        List<JsonNode> result = findValues(fieldName, null);\n+        if (result == null) {\n+            return Collections.emptyList();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Similar to {@link #findValues}, but will additionally convert\n+     * values into Strings, calling {@link #getValueAsText}.\n+     */\n+    public final List<String> findValuesAsText(String fieldName)\n+    {\n+        List<String> result = findValuesAsText(fieldName, null);\n+        if (result == null) {\n+            return Collections.emptyList();\n+        }\n+        return result;\n+    }\n+    \n+    /**\n+     * Method similar to {@link #findValue}, but that will return a\n+     * \"missing node\" instead of null if no field is found. Missing node\n+     * is a specific kind of node for which {@link #isMissingNode}\n+     * returns true; and all value access methods return empty or\n+     * missing value.\n+     * \n+     * @param fieldName Name of field to look for\n+     * \n+     * @return Value of first matching node found; or if not found, a\n+     *    \"missing node\" (non-null instance that has no value)\n+     */\n+    public abstract JsonNode findPath(String fieldName);\n+    \n+    /**\n+     * Method for finding a JSON Object that contains specified field,\n+     * within this node or its descendants.\n+     * If no matching field is found in this node or its descendants, returns null.\n+     * \n+     * @param fieldName Name of field to look for\n+     * \n+     * @return Value of first matching node found, if any; null if none\n+     */\n+    public abstract JsonNode findParent(String fieldName);\n+\n+    /**\n+     * Method for finding a JSON Object that contains specified field,\n+     * within this node or its descendants.\n+     * If no matching field is found in this node or its descendants, returns null.\n+     * \n+     * @param fieldName Name of field to look for\n+     * \n+     * @return Value of first matching node found, if any; null if none\n+     */\n+    public final List<JsonNode> findParents(String fieldName)\n+    {\n+        List<JsonNode> result = findParents(fieldName, null);\n+        if (result == null) {\n+            return Collections.emptyList();\n+        }\n+        return result;\n+    }\n+\n+    public abstract List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar);\n+    public abstract List<String> findValuesAsText(String fieldName, List<String> foundSoFar);\n+    public abstract List<JsonNode> findParents(String fieldName, List<JsonNode> foundSoFar);\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, container access\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that returns number of child nodes this node contains:\n+     * for Array nodes, number of child elements, for Object nodes,\n+     * number of fields, and for all other nodes 0.\n+     *\n+     * @return For non-container nodes returns 0; for arrays number of\n+     *   contained elements, and for objects number of fields.\n+     */\n+    public int size() { return 0; }\n+\n+    /**\n+     * Same as calling {@link #getElements}; implemented so that\n+     * convenience \"for-each\" loop can be used for looping over elements\n+     * of JSON Array constructs.\n+     */\n+    @Override\n+    public final Iterator<JsonNode> iterator() { return getElements(); }\n+\n+    /**\n+     * Method for accessing all value nodes of this Node, iff\n+     * this node is a JSON Array or Object node. In case of Object node,\n+     * field names (keys) are not included, only values.\n+     * For other types of nodes, returns empty iterator.\n+     */\n+    public Iterator<JsonNode> getElements() { return NO_NODES.iterator(); }\n+\n+    /**\n+     * Method for accessing names of all fields for this Node, iff\n+     * this node is a JSON Object node.\n+     */\n+    public Iterator<String> getFieldNames() { return NO_STRINGS.iterator(); }\n+\n+    /**\n+     * @return Iterator that can be used to traverse all key/value pairs for\n+     *   object nodes; empty iterator (no contents) for other types\n+     */\n+    public Iterator<Map.Entry<String, JsonNode>> getFields() {\n+        Collection<Map.Entry<String, JsonNode>> coll = Collections.emptyList();\n+        return coll.iterator();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, path handling\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * This method is similar to {@link #get(String)}, except\n+     * that instead of returning null if no such value exists (due\n+     * to this node not being an object, or object not having value\n+     * for the specified field),\n+     * a \"missing node\" (node that returns true for\n+     * {@link #isMissingNode}) will be returned. This allows for\n+     * convenient and safe chained access via path calls.\n+     */\n+    public abstract JsonNode path(String fieldName);\n+\n+    /**\n+     * This method is similar to {@link #get(int)}, except\n+     * that instead of returning null if no such element exists (due\n+     * to index being out of range, or this node not being an array),\n+     * a \"missing node\" (node that returns true for\n+     * {@link #isMissingNode}) will be returned. This allows for\n+     * convenient and safe chained access via path calls.\n+     */\n+    public abstract JsonNode path(int index);\n+\n+    /**\n+     * Method that can be called on object nodes, to access a property\n+     * that has object value; or if no such property exists, to create and\n+     * return such object node.\n+     * If node method is called on is not Object node,\n+     * or if property exists and has value that is not object node,\n+     * {@link UnsupportedOperationException} is thrown\n+     */\n+    public JsonNode with(String propertyName) {\n+        throw new UnsupportedOperationException(\"JsonNode not of type ObjectNode (but \"\n+                +getClass().getName()+\"), can not call with() on it\");\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API: converting to/from Streaming API\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for constructing a {@link JsonParser} instance for\n+     * iterating over contents of the tree that this\n+     * node is root of.\n+     * Functionally equivalent to first serializing tree using\n+     * {@link ObjectCodec} and then re-parsing but\n+     * more efficient.\n+     */\n+    public abstract JsonParser traverse();\n+\n+    /*\n+    /**********************************************************\n+    /* Overridden standard methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     *<p>\n+     * Note: marked as abstract to ensure all implementation\n+     * classes define it properly.\n+     */\n+    @Override\n+    public abstract String toString();\n+\n+    /**\n+     * Equality for node objects is defined as full (deep) value\n+     * equality. This means that it is possible to compare complete\n+     * JSON trees for equality by comparing equality of root nodes.\n+     *<p>\n+     * Note: marked as abstract to ensure all implementation\n+     * classes define it properly and not rely on definition\n+     * from {@link java.lang.Object}.\n+     */\n+    @Override\n+    public abstract boolean equals(Object o);\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonParseException.java\n+package com.fasterxml.jackson.core;\n+\n+/**\n+ * Exception type for parsing problems, used when non-well-formed content\n+ * (content that does not conform to JSON syntax as per specification)\n+ * is encountered.\n+ */\n+public class JsonParseException\n+    extends JsonProcessingException\n+{\n+    final static long serialVersionUID = 123; // Stupid eclipse...\n+\n+    public JsonParseException(String msg, JsonLocation loc)\n+    {\n+        super(msg, loc);\n+    }\n+\n+    public JsonParseException(String msg, JsonLocation loc, Throwable root)\n+    {\n+        super(msg, loc, root);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n+/* Jackson JSON-processor.\n+ *\n+ * Copyright (c) 2007- Tatu Saloranta, tatu.saloranta@iki.fi\n+ *\n+ * Licensed under the License specified in file LICENSE, included with\n+ * the source code and binary code bundles.\n+ * You may not use this file except in compliance with the License.\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.fasterxml.jackson.core;\n+\n+import java.io.*;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.Iterator;\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+\n+/**\n+ * Base class that defines public API for reading JSON content.\n+ * Instances are created using factory methods of\n+ * a {@link JsonFactory} instance.\n+ *\n+ * @author Tatu Saloranta\n+ */\n+public abstract class JsonParser\n+    implements Closeable, Versioned\n+{\n+    private final static int MIN_BYTE_I = (int) Byte.MIN_VALUE;\n+    private final static int MAX_BYTE_I = (int) Byte.MAX_VALUE;\n+\n+    private final static int MIN_SHORT_I = (int) Short.MIN_VALUE;\n+    private final static int MAX_SHORT_I = (int) Short.MAX_VALUE;\n+\n+    /**\n+     * Enumeration of possible \"native\" (optimal) types that can be\n+     * used for numbers.\n+     */\n+    public enum NumberType {\n+        INT, LONG, BIG_INTEGER, FLOAT, DOUBLE, BIG_DECIMAL\n+    };\n+\n+    /**\n+     * Enumeration that defines all togglable features for parsers.\n+     */\n+    public enum Feature {\n+        \n+        // // // Low-level I/O handling features:\n+        \n+        /**\n+         * Feature that determines whether parser will automatically\n+         * close underlying input source that is NOT owned by the\n+         * parser. If disabled, calling application has to separately\n+         * close the underlying {@link InputStream} and {@link Reader}\n+         * instances used to create the parser. If enabled, parser\n+         * will handle closing, as long as parser itself gets closed:\n+         * this happens when end-of-input is encountered, or parser\n+         * is closed by a call to {@link JsonParser#close}.\n+         *<p>\n+         * Feature is enabled by default.\n+         */\n+        AUTO_CLOSE_SOURCE(true),\n+            \n+        // // // Support for non-standard data format constructs\n+\n+        /**\n+         * Feature that determines whether parser will allow use\n+         * of Java/C++ style comments (both '/'+'*' and\n+         * '//' varieties) within parsed content or not.\n+         *<p>\n+         * Since JSON specification does not mention comments as legal\n+         * construct,\n+         * this is a non-standard feature; however, in the wild\n+         * this is extensively used. As such, feature is\n+         * <b>disabled by default</b> for parsers and must be\n+         * explicitly enabled (via factory or parser instance).\n+         *<p>\n+         * This feature can be changed for parser instances.\n+         */\n+        ALLOW_COMMENTS(false),\n+\n+        /**\n+         * Feature that determines whether parser will allow use\n+         * of unquoted field names (which is allowed by Javascript,\n+         * but not by JSON specification).\n+         *<p>\n+         * Since JSON specification requires use of double quotes for\n+         * field names,\n+         * this is a non-standard feature, and as such disabled by\n+         * default.\n+         *<p>\n+         * This feature can be changed for parser instances.\n+         */\n+        ALLOW_UNQUOTED_FIELD_NAMES(false),\n+\n+        /**\n+         * Feature that determines whether parser will allow use\n+         * of single quotes (apostrophe, character '\\'') for\n+         * quoting Strings (names and String values). If so,\n+         * this is in addition to other acceptabl markers.\n+         * but not by JSON specification).\n+         *<p>\n+         * Since JSON specification requires use of double quotes for\n+         * field names,\n+         * this is a non-standard feature, and as such disabled by\n+         * default.\n+         *<p>\n+         * This feature can be changed for parser instances.\n+         */\n+        ALLOW_SINGLE_QUOTES(false),\n+\n+        /**\n+         * Feature that determines whether parser will allow\n+         * JSON Strings to contain unquoted control characters\n+         * (ASCII characters with value less than 32, including\n+         * tab and line feed characters) or not.\n+         * If feature is set false, an exception is thrown if such a\n+         * character is encountered.\n+         *<p>\n+         * Since JSON specification requires quoting for all control characters,\n+         * this is a non-standard feature, and as such disabled by default.\n+         *<p>\n+         * This feature can be changed for parser instances.\n+         */\n+        ALLOW_UNQUOTED_CONTROL_CHARS(false),\n+\n+        /**\n+         * Feature that can be enabled to accept quoting of all character\n+         * using backslash qooting mechanism: if not enabled, only characters\n+         * that are explicitly listed by JSON specification can be thus\n+         * escaped (see JSON spec for small list of these characters)\n+         *<p>\n+         * Since JSON specification requires quoting for all control characters,\n+         * this is a non-standard feature, and as such disabled by default.\n+         *<p>\n+         * This feature can be changed for parser instances.\n+         */\n+        ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER(false),\n+\n+        /**\n+         * Feature that determines whether parser will allow\n+         * JSON integral numbers to start with additional (ignorable) \n+         * zeroes (like: 000001). If enabled, no exception is thrown, and extra\n+         * nulls are silently ignored (and not included in textual representation\n+         * exposed via {@link JsonParser#getText}).\n+         *<p>\n+         * Since JSON specification does not allow leading zeroes,\n+         * this is a non-standard feature, and as such disabled by default.\n+         *<p>\n+         * This feature can be changed for parser instances.\n+         */\n+        ALLOW_NUMERIC_LEADING_ZEROS(false),\n+        \n+        /**\n+         * Feature that allows parser to recognize set of\n+         * \"Not-a-Number\" (NaN) tokens as legal floating number\n+         * values (similar to how many other data formats and\n+         * programming language source code allows it).\n+         * Specific subset contains values that\n+         * <a href=\"http://www.w3.org/TR/xmlschema-2/\">XML Schema</a>\n+         * (see section 3.2.4.1, Lexical Representation)\n+         * allows (tokens are quoted contents, not including quotes):\n+         *<ul>\n+         *  <li>\"INF\" (for positive infinity), as well as alias of \"Infinity\"\n+         *  <li>\"-INF\" (for negative infinity), alias \"-Infinity\"\n+         *  <li>\"NaN\" (for other not-a-numbers, like result of division by zero)\n+         *</ul>\n+         */\n+\n+         ALLOW_NON_NUMERIC_NUMBERS(false),\n+        \n+        // // // Controlling canonicalization (interning etc)\n+        \n+        /**\n+         * Feature that determines whether JSON object field names are\n+         * to be canonicalized using {@link String#intern} or not:\n+         * if enabled, all field names will be intern()ed (and caller\n+         * can count on this being true for all such names); if disabled,\n+         * no intern()ing is done. There may still be basic\n+         * canonicalization (that is, same String will be used to represent\n+         * all identical object property names for a single document).\n+         *<p>\n+         * Note: this setting only has effect if\n+         * {@link #CANONICALIZE_FIELD_NAMES} is true -- otherwise no\n+         * canonicalization of any sort is done.\n+         */\n+        INTERN_FIELD_NAMES(true),\n+\n+        /**\n+         * Feature that determines whether JSON object field names are\n+         * to be canonicalized (details of how canonicalization is done\n+         * then further specified by\n+         * {@link #INTERN_FIELD_NAMES}).\n+         */\n+        CANONICALIZE_FIELD_NAMES(true),\n+\n+\n+            ;\n+\n+        final boolean _defaultState;\n+\n+        /**\n+         * Method that calculates bit set (flags) of all features that\n+         * are enabled by default.\n+         */\n+        public static int collectDefaults()\n+        {\n+            int flags = 0;\n+            for (Feature f : values()) {\n+                if (f.enabledByDefault()) {\n+                    flags |= f.getMask();\n+                }\n+            }\n+            return flags;\n+        }\n+        \n+        private Feature(boolean defaultState) {\n+            _defaultState = defaultState;\n+        }\n+        \n+        public boolean enabledByDefault() { return _defaultState; }\n+\n+        public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\n+        \n+        public int getMask() { return (1 << ordinal()); }\n+    };\n+\n+    /*\n+    /**********************************************************\n+    /* Minimal configuration state\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Bit flag composed of bits that indicate which\n+     * {@link com.fasterxml.jackson.core.JsonParser.Feature}s\n+     * are enabled.\n+     */\n+    protected int _features;\n+\n+    /*\n+    /**********************************************************\n+    /* Minimal generic state\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Last token retrieved via {@link #nextToken}, if any.\n+     * Null before the first call to <code>nextToken()</code>,\n+     * as well as if token has been explicitly cleared\n+     * (by call to {@link #clearCurrentToken})\n+     */\n+    protected JsonToken _currToken;\n+\n+    /**\n+     * Last cleared token, if any: that is, value that was in\n+     * effect when {@link #clearCurrentToken} was called.\n+     */\n+    protected JsonToken _lastClearedToken;\n+\n+    /*\n+    /**********************************************************\n+    /* Construction, configuration, initialization\n+    /**********************************************************\n+     */\n+\n+    protected JsonParser() { }\n+    protected JsonParser(int features) {\n+        _features = features;\n+    }\n+\n+    /**\n+     * Accessor for {@link ObjectCodec} associated with this\n+     * parser, if any. Codec is used by {@link #readValueAs(Class)}\n+     * method (and its variants).\n+     */\n+    public abstract ObjectCodec getCodec();\n+\n+    /**\n+     * Setter that allows defining {@link ObjectCodec} associated with this\n+     * parser, if any. Codec is used by {@link #readValueAs(Class)}\n+     * method (and its variants).\n+     */\n+    public abstract void setCodec(ObjectCodec c);\n+\n+    /**\n+     * Method to call to make this parser use specified schema. Method must\n+     * be called before trying to parse any content, right after parser instance\n+     * has been created.\n+     * Note that not all parsers support schemas; and those that do usually only\n+     * accept specific types of schemas: ones defined for data format parser can read.\n+     *<p>\n+     * If parser does not support specified schema, {@link UnsupportedOperationException}\n+     * is thrown.\n+     * \n+     * @param schema Schema to use\n+     * \n+     * @throws UnsupportedOperationException if parser does not support schema\n+     */\n+    public void setSchema(FormatSchema schema)\n+    {\n+        throw new UnsupportedOperationException(\"Parser of type \"+getClass().getName()+\" does not support schema of type '\"\n+                +schema.getSchemaType()+\"'\");\n+    }\n+    \n+    /**\n+     * Method that can be used to verify that given schema can be used with\n+     * this parser (using {@link #setSchema}).\n+     * \n+     * @param schema Schema to check\n+     * \n+     * @return True if this parser can use given schema; false if not\n+     */\n+    public boolean canUseSchema(FormatSchema schema) {\n+        return false;\n+    }\n+    \n+    /**\n+     * Accessor for getting version of the core package, given a parser instance.\n+     */\n+    @Override\n+    public Version version() {\n+        return Version.unknownVersion();\n+    }\n+\n+    /**\n+     * Method that can be used to get access to object that is used\n+     * to access input being parsed; this is usually either\n+     * {@link InputStream} or {@link Reader}, depending on what\n+     * parser was constructed with.\n+     * Note that returned value may be null in some cases; including\n+     * case where parser implementation does not want to exposed raw\n+     * source to caller.\n+     * In cases where input has been decorated, object returned here\n+     * is the decorated version; this allows some level of interaction\n+     * between users of parser and decorator object.\n+     *<p>\n+     * In general use of this accessor should be considered as\n+     * \"last effort\", i.e. only used if no other mechanism is applicable.\n+     */\n+    public Object getInputSource() {\n+        return null;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Closeable implementation\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Closes the parser so that no further iteration or data access\n+     * can be made; will also close the underlying input source\n+     * if parser either <b>owns</b> the input source, or feature\n+     * {@link Feature#AUTO_CLOSE_SOURCE} is enabled.\n+     * Whether parser owns the input source depends on factory\n+     * method that was used to construct instance (so check\n+     * {@link com.fasterxml.jackson.core.JsonFactory} for details,\n+     * but the general\n+     * idea is that if caller passes in closable resource (such\n+     * as {@link InputStream} or {@link Reader}) parser does NOT\n+     * own the source; but if it passes a reference (such as\n+     * {@link java.io.File} or {@link java.net.URL} and creates\n+     * stream or reader it does own them.\n+     */\n+    @Override\n+    public abstract void close() throws IOException;\n+\n+    /*\n+    /**********************************************************\n+    /* Buffer handling\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that can be called to push back any content that\n+     * has been read but not consumed by the parser. This is usually\n+     * done after reading all content of interest using parser.\n+     * Content is released by writing it to given stream if possible;\n+     * if underlying input is byte-based it can released, if not (char-based)\n+     * it can not.\n+     * \n+     * @return -1 if the underlying content source is not byte based\n+     *    (that is, input can not be sent to {@link OutputStream};\n+     *    otherwise number of bytes released (0 if there was nothing to release)\n+     *    \n+     * @throws IOException if write to stream threw exception\n+     */    \n+    public int releaseBuffered(OutputStream out) throws IOException\n+    {\n+        return -1;\n+    }\n+\n+    /**\n+     * Method that can be called to push back any content that\n+     * has been read but not consumed by the parser.\n+     * This is usually\n+     * done after reading all content of interest using parser.\n+     * Content is released by writing it to given writer if possible;\n+     * if underlying input is char-based it can released, if not (byte-based)\n+     * it can not.\n+     * \n+     * @return -1 if the underlying content source is not char-based\n+     *    (that is, input can not be sent to {@link Writer};\n+     *    otherwise number of chars released (0 if there was nothing to release)\n+     *    \n+     * @throws IOException if write using Writer threw exception\n+     */    \n+    public int releaseBuffered(Writer w) throws IOException\n+    {\n+        return -1;\n+    }\n+    \n+    /*\n+    /***************************************************\n+    /* Public API, configuration\n+    /***************************************************\n+     */\n+\n+    /**\n+     * Method for enabling specified parser feature\n+     * (check {@link Feature} for list of features)\n+     */\n+    public JsonParser enable(Feature f)\n+    {\n+        _features |= f.getMask();\n+        return this;\n+    }\n+\n+    /**\n+     * Method for disabling specified  feature\n+     * (check {@link Feature} for list of features)\n+     */\n+    public JsonParser disable(Feature f)\n+    {\n+        _features &= ~f.getMask();\n+        return this;\n+    }\n+\n+    /**\n+     * Method for enabling or disabling specified feature\n+     * (check {@link Feature} for list of features)\n+     */\n+    public JsonParser configure(Feature f, boolean state)\n+    {\n+        if (state) {\n+            enable(f);\n+        } else {\n+            disable(f);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Method for checking whether specified {@link Feature} is enabled.\n+     */\n+    public boolean isEnabled(Feature f) {\n+        return (_features & f.getMask()) != 0;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, traversal\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Main iteration method, which will advance stream enough\n+     * to determine type of the next token, if any. If none\n+     * remaining (stream has no content other than possible\n+     * white space before ending), null will be returned.\n+     *\n+     * @return Next token from the stream, if any found, or null\n+     *   to indicate end-of-input\n+     */\n+    public abstract JsonToken nextToken()\n+        throws IOException, JsonParseException;\n+\n+    /**\n+     * Iteration method that will advance stream enough\n+     * to determine type of the next token that is a value type\n+     * (including JSON Array and Object start/end markers).\n+     * Or put another way, nextToken() will be called once,\n+     * and if {@link JsonToken#FIELD_NAME} is returned, another\n+     * time to get the value for the field.\n+     * Method is most useful for iterating over value entries\n+     * of JSON objects; field name will still be available\n+     * by calling {@link #getCurrentName} when parser points to\n+     * the value.\n+     *\n+     * @return Next non-field-name token from the stream, if any found,\n+     *   or null to indicate end-of-input (or, for non-blocking\n+     *   parsers, {@link JsonToken#NOT_AVAILABLE} if no tokens were\n+     *   available yet)\n+     */\n+    public JsonToken nextValue()\n+        throws IOException, JsonParseException\n+    {\n+        /* Implementation should be as trivial as follows; only\n+         * needs to change if we are to skip other tokens (for\n+         * example, if comments were exposed as tokens)\n+         */\n+        JsonToken t = nextToken();\n+        if (t == JsonToken.FIELD_NAME) {\n+            t = nextToken();\n+        }\n+        return t;\n+    }\n+\n+    /**\n+     * Method that fetches next token (as if calling {@link #nextToken}) and\n+     * verifies whether it is {@link JsonToken#FIELD_NAME} with specified name\n+     * and returns result of that comparison.\n+     * It is functionally equivalent to:\n+     *<pre>\n+     *  return (nextToken() == JsonToken.FIELD_NAME) && str.getValue().equals(getCurrentName());\n+     *</pre>\n+     * but may be faster for parser to verify, and can therefore be used if caller\n+     * expects to get such a property name from input next.\n+     * \n+     * @param str Property name to compare next token to (if next token is <code>JsonToken.FIELD_NAME<code>)\n+     */\n+    public boolean nextFieldName(SerializableString str)\n+        throws IOException, JsonParseException\n+    {\n+        return (nextToken() == JsonToken.FIELD_NAME) && str.getValue().equals(getCurrentName());\n+    }\n+\n+    /**\n+     * Method that fetches next token (as if calling {@link #nextToken}) and\n+     * if it is {@link JsonToken#VALUE_STRING} returns contained String value;\n+     * otherwise returns null.\n+     * It is functionally equivalent to:\n+     *<pre>\n+     *  return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n+     *</pre>\n+     * but may be faster for parser to process, and can therefore be used if caller\n+     * expects to get a String value next from input.\n+     */\n+    public String nextTextValue()\n+        throws IOException, JsonParseException\n+    {\n+        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n+    }\n+\n+    /**\n+     * Method that fetches next token (as if calling {@link #nextToken}) and\n+     * if it is {@link JsonToken#VALUE_NUMBER_INT} returns 32-bit int value;\n+     * otherwise returns specified default value\n+     * It is functionally equivalent to:\n+     *<pre>\n+     *  return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n+     *</pre>\n+     * but may be faster for parser to process, and can therefore be used if caller\n+     * expects to get a String value next from input.\n+     */\n+    public int nextIntValue(int defaultValue)\n+        throws IOException, JsonParseException\n+    {\n+        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n+    }\n+\n+    /**\n+     * Method that fetches next token (as if calling {@link #nextToken}) and\n+     * if it is {@link JsonToken#VALUE_NUMBER_INT} returns 64-bit long value;\n+     * otherwise returns specified default value\n+     * It is functionally equivalent to:\n+     *<pre>\n+     *  return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n+     *</pre>\n+     * but may be faster for parser to process, and can therefore be used if caller\n+     * expects to get a String value next from input.\n+     */\n+    public long nextLongValue(long defaultValue)\n+        throws IOException, JsonParseException\n+    {\n+        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n+    }\n+\n+    /**\n+     * Method that fetches next token (as if calling {@link #nextToken}) and\n+     * if it is {@link JsonToken#VALUE_TRUE} or {@link JsonToken#VALUE_FALSE}\n+     * returns matching Boolean value; otherwise return null.\n+     * It is functionally equivalent to:\n+     *<pre>\n+     *  JsonToken t = nextToken();\n+     *  if (t == JsonToken.VALUE_TRUE) return Boolean.TRUE;\n+     *  if (t == JsonToken.VALUE_FALSE) return Boolean.FALSE;\n+     *  return null;\n+     *</pre>\n+     * but may be faster for parser to process, and can therefore be used if caller\n+     * expects to get a String value next from input.\n+     */\n+    public Boolean nextBooleanValue()\n+        throws IOException, JsonParseException\n+    {\n+        switch (nextToken()) {\n+        case VALUE_TRUE:\n+            return Boolean.TRUE;\n+        case VALUE_FALSE:\n+            return Boolean.FALSE;\n+        }\n+        return null;\n+    }\n+    \n+    /**\n+     * Method that will skip all child tokens of an array or\n+     * object token that the parser currently points to,\n+     * iff stream points to \n+     * {@link JsonToken#START_OBJECT} or {@link JsonToken#START_ARRAY}.\n+     * If not, it will do nothing.\n+     * After skipping, stream will point to <b>matching</b>\n+     * {@link JsonToken#END_OBJECT} or {@link JsonToken#END_ARRAY}\n+     * (possibly skipping nested pairs of START/END OBJECT/ARRAY tokens\n+     * as well as value tokens).\n+     * The idea is that after calling this method, application\n+     * will call {@link #nextToken} to point to the next\n+     * available token, if any.\n+     */\n+    public abstract JsonParser skipChildren()\n+        throws IOException, JsonParseException;\n+    \n+    /**\n+     * Method that can be called to determine whether this parser\n+     * is closed or not. If it is closed, no new tokens can be\n+     * retrieved by calling {@link #nextToken} (and the underlying\n+     * stream may be closed). Closing may be due to an explicit\n+     * call to {@link #close} or because parser has encountered\n+     * end of input.\n+     */\n+    public abstract boolean isClosed();\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, token accessors\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Accessor to find which token parser currently points to, if any;\n+     * null will be returned if none.\n+     * If return value is non-null, data associated with the token\n+     * is available via other accessor methods.\n+     *\n+     * @return Type of the token this parser currently points to,\n+     *   if any: null before any tokens have been read, and\n+     *   after end-of-input has been encountered, as well as\n+     *   if the current token has been explicitly cleared.\n+     */\n+    public JsonToken getCurrentToken() {\n+        return _currToken;\n+    }\n+\n+    /**\n+     * Method for checking whether parser currently points to\n+     * a token (and data for that token is available).\n+     * Equivalent to check for <code>parser.getCurrentToken() != null</code>.\n+     *\n+     * @return True if the parser just returned a valid\n+     *   token via {@link #nextToken}; false otherwise (parser\n+     *   was just constructed, encountered end-of-input\n+     *   and returned null from {@link #nextToken}, or the token\n+     *   has been consumed)\n+     */\n+    public boolean hasCurrentToken() {\n+        return _currToken != null;\n+    }\n+\n+\n+    /**\n+     * Method called to \"consume\" the current token by effectively\n+     * removing it so that {@link #hasCurrentToken} returns false, and\n+     * {@link #getCurrentToken} null).\n+     * Cleared token value can still be accessed by calling\n+     * {@link #getLastClearedToken} (if absolutely needed), but\n+     * usually isn't.\n+     *<p>\n+     * Method was added to be used by the optional data binder, since\n+     * it has to be able to consume last token used for binding (so that\n+     * it will not be used again).\n+     */\n+    public void clearCurrentToken() {\n+        if (_currToken != null) {\n+            _lastClearedToken = _currToken;\n+            _currToken = null;\n+        }\n+    }\n+\n+    /**\n+     * Method that can be called to get the name associated with\n+     * the current token: for {@link JsonToken#FIELD_NAME}s it will\n+     * be the same as what {@link #getText} returns;\n+     * for field values it will be preceding field name;\n+     * and for others (array values, root-level values) null.\n+     */\n+    public abstract String getCurrentName()\n+        throws IOException, JsonParseException;\n+\n+    /**\n+     * Method that can be used to access current parsing context reader\n+     * is in. There are 3 different types: root, array and object contexts,\n+     * with slightly different available information. Contexts are\n+     * hierarchically nested, and can be used for example for figuring\n+     * out part of the input document that correspond to specific\n+     * array or object (for highlighting purposes, or error reporting).\n+     * Contexts can also be used for simple xpath-like matching of\n+     * input, if so desired.\n+     */\n+    public abstract JsonStreamContext getParsingContext();\n+\n+    /**\n+     * Method that return the <b>starting</b> location of the current\n+     * token; that is, position of the first character from input\n+     * that starts the current token.\n+     */\n+    public abstract JsonLocation getTokenLocation();\n+\n+    /**\n+     * Method that returns location of the last processed character;\n+     * usually for error reporting purposes.\n+     */\n+    public abstract JsonLocation getCurrentLocation();\n+\n+    /**\n+     * Method that can be called to get the last token that was\n+     * cleared using {@link #clearCurrentToken}. This is not necessarily\n+     * the latest token read.\n+     * Will return null if no tokens have been cleared,\n+     * or if parser has been closed.\n+     */\n+    public JsonToken getLastClearedToken() {\n+        return _lastClearedToken;\n+    }\n+\n+    /**\n+     * Specialized accessor that can be used to verify that the current\n+     * token indicates start array (usually meaning that current token\n+     * is {@link JsonToken#START_ARRAY}) when start array is expected.\n+     * For some specialized parsers this can return true for other cases\n+     * as well; this is usually done to emulate arrays.\n+     *<p>\n+     * Default implementation is equivalent to:\n+     *<pre>\n+     *   getCurrentToken() == JsonToken.START_ARRAY\n+     *</pre>\n+     * but may be overridden by custom parser implementations.\n+     *\n+     * @return True if the current token can be considered as a\n+     *   start-array marker (such {@link JsonToken#START_ARRAY});\n+     *   false if not.\n+     */\n+    public boolean isExpectedStartArrayToken() {\n+        return getCurrentToken() == JsonToken.START_ARRAY;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, access to token information, text\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for accessing textual representation of the current token;\n+     * if no current token (before first call to {@link #nextToken}, or\n+     * after encountering end-of-input), returns null.\n+     * Method can be called for any token type.\n+     */\n+    public abstract String getText()\n+        throws IOException, JsonParseException;\n+\n+    /**\n+     * Method similar to {@link #getText}, but that will return\n+     * underlying (unmodifiable) character array that contains\n+     * textual value, instead of constructing a String object\n+     * to contain this information.\n+     * Note, however, that:\n+     *<ul>\n+     * <li>Textual contents are not guaranteed to start at\n+     *   index 0 (rather, call {@link #getTextOffset}) to\n+     *   know the actual offset\n+     *  </li>\n+     * <li>Length of textual contents may be less than the\n+     *  length of returned buffer: call {@link #getTextLength}\n+     *  for actual length of returned content.\n+     *  </li>\n+     * </ul>\n+     *<p>\n+     * Note that caller <b>MUST NOT</b> modify the returned\n+     * character array in any way -- doing so may corrupt\n+     * current parser state and render parser instance useless.\n+     *<p>\n+     * The only reason to call this method (over {@link #getText})\n+     * is to avoid construction of a String object (which\n+     * will make a copy of contents).\n+     */\n+    public abstract char[] getTextCharacters()\n+        throws IOException, JsonParseException;\n+\n+    /**\n+     * Accessor used with {@link #getTextCharacters}, to know length\n+     * of String stored in returned buffer.\n+     *\n+     * @return Number of characters within buffer returned\n+     *   by {@link #getTextCharacters} that are part of\n+     *   textual content of the current token.\n+     */\n+    public abstract int getTextLength()\n+        throws IOException, JsonParseException;\n+\n+    /**\n+     * Accessor used with {@link #getTextCharacters}, to know offset\n+     * of the first text content character within buffer.\n+     *\n+     * @return Offset of the first character within buffer returned\n+     *   by {@link #getTextCharacters} that is part of\n+     *   textual content of the current token.\n+     */\n+    public abstract int getTextOffset()\n+        throws IOException, JsonParseException;\n+\n+    /**\n+     * Method that can be used to determine whether calling of\n+     * {@link #getTextCharacters} would be the most efficient\n+     * way to access textual content for the event parser currently\n+     * points to.\n+     *<p> \n+     * Default implementation simply returns false since only actual\n+     * implementation class has knowledge of its internal buffering\n+     * state.\n+     * Implementations are strongly encouraged to properly override\n+     * this method, to allow efficient copying of content by other\n+     * code.\n+     * \n+     * @return True if parser currently has character array that can\n+     *   be efficiently returned via {@link #getTextCharacters}; false\n+     *   means that it may or may not exist\n+     */\n+    public boolean hasTextCharacters() {\n+        return false;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, access to token information, numeric\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Generic number value accessor method that will work for\n+     * all kinds of numeric values. It will return the optimal\n+     * (simplest/smallest possible) wrapper object that can\n+     * express the numeric value just parsed.\n+     */\n+    public abstract Number getNumberValue()\n+        throws IOException, JsonParseException;\n+\n+    /**\n+     * If current token is of type \n+     * {@link JsonToken#VALUE_NUMBER_INT} or\n+     * {@link JsonToken#VALUE_NUMBER_FLOAT}, returns\n+     * one of {@link NumberType} constants; otherwise returns null.\n+     */\n+    public abstract NumberType getNumberType()\n+        throws IOException, JsonParseException;\n+\n+    /**\n+     * Numeric accessor that can be called when the current\n+     * token is of type {@link JsonToken#VALUE_NUMBER_INT} and\n+     * it can be expressed as a value of Java byte primitive type.\n+     * It can also be called for {@link JsonToken#VALUE_NUMBER_FLOAT};\n+     * if so, it is equivalent to calling {@link #getDoubleValue}\n+     * and then casting; except for possible overflow/underflow\n+     * exception.\n+     *<p>\n+     * Note: if the resulting integer value falls outside range of\n+     * Java byte, a {@link JsonParseException}\n+     * will be thrown to indicate numeric overflow/underflow.\n+     */\n+    public byte getByteValue()\n+        throws IOException, JsonParseException\n+    {\n+        int value = getIntValue();\n+        // So far so good: but does it fit?\n+        if (value < MIN_BYTE_I || value > MAX_BYTE_I) {\n+            throw _constructError(\"Numeric value (\"+getText()+\") out of range of Java byte\");\n+        }\n+        return (byte) value;\n+    }\n+\n+    /**\n+     * Numeric accessor that can be called when the current\n+     * token is of type {@link JsonToken#VALUE_NUMBER_INT} and\n+     * it can be expressed as a value of Java short primitive type.\n+     * It can also be called for {@link JsonToken#VALUE_NUMBER_FLOAT};\n+     * if so, it is equivalent to calling {@link #getDoubleValue}\n+     * and then casting; except for possible overflow/underflow\n+     * exception.\n+     *<p>\n+     * Note: if the resulting integer value falls outside range of\n+     * Java short, a {@link JsonParseException}\n+     * will be thrown to indicate numeric overflow/underflow.\n+     */\n+    public short getShortValue()\n+        throws IOException, JsonParseException\n+    {\n+        int value = getIntValue();\n+        if (value < MIN_SHORT_I || value > MAX_SHORT_I) {\n+            throw _constructError(\"Numeric value (\"+getText()+\") out of range of Java short\");\n+        }\n+        return (short) value;\n+    }\n+\n+    /**\n+     * Numeric accessor that can be called when the current\n+     * token is of type {@link JsonToken#VALUE_NUMBER_INT} and\n+     * it can be expressed as a value of Java int primitive type.\n+     * It can also be called for {@link JsonToken#VALUE_NUMBER_FLOAT};\n+     * if so, it is equivalent to calling {@link #getDoubleValue}\n+     * and then casting; except for possible overflow/underflow\n+     * exception.\n+     *<p>\n+     * Note: if the resulting integer value falls outside range of\n+     * Java int, a {@link JsonParseException}\n+     * may be thrown to indicate numeric overflow/underflow.\n+     */\n+    public abstract int getIntValue()\n+        throws IOException, JsonParseException;\n+\n+    /**\n+     * Numeric accessor that can be called when the current\n+     * token is of type {@link JsonToken#VALUE_NUMBER_INT} and\n+     * it can be expressed as a Java long primitive type.\n+     * It can also be called for {@link JsonToken#VALUE_NUMBER_FLOAT};\n+     * if so, it is equivalent to calling {@link #getDoubleValue}\n+     * and then casting to int; except for possible overflow/underflow\n+     * exception.\n+     *<p>\n+     * Note: if the token is an integer, but its value falls\n+     * outside of range of Java long, a {@link JsonParseException}\n+     * may be thrown to indicate numeric overflow/underflow.\n+     */\n+    public abstract long getLongValue()\n+        throws IOException, JsonParseException;\n+\n+    /**\n+     * Numeric accessor that can be called when the current\n+     * token is of type {@link JsonToken#VALUE_NUMBER_INT} and\n+     * it can not be used as a Java long primitive type due to its\n+     * magnitude.\n+     * It can also be called for {@link JsonToken#VALUE_NUMBER_FLOAT};\n+     * if so, it is equivalent to calling {@link #getDecimalValue}\n+     * and then constructing a {@link BigInteger} from that value.\n+     */\n+    public abstract BigInteger getBigIntegerValue()\n+        throws IOException, JsonParseException;\n+\n+    /**\n+     * Numeric accessor that can be called when the current\n+     * token is of type {@link JsonToken#VALUE_NUMBER_FLOAT} and\n+     * it can be expressed as a Java float primitive type.\n+     * It can also be called for {@link JsonToken#VALUE_NUMBER_INT};\n+     * if so, it is equivalent to calling {@link #getLongValue}\n+     * and then casting; except for possible overflow/underflow\n+     * exception.\n+     *<p>\n+     * Note: if the value falls\n+     * outside of range of Java float, a {@link JsonParseException}\n+     * will be thrown to indicate numeric overflow/underflow.\n+     */\n+    public abstract float getFloatValue()\n+        throws IOException, JsonParseException;\n+\n+    /**\n+     * Numeric accessor that can be called when the current\n+     * token is of type {@link JsonToken#VALUE_NUMBER_FLOAT} and\n+     * it can be expressed as a Java double primitive type.\n+     * It can also be called for {@link JsonToken#VALUE_NUMBER_INT};\n+     * if so, it is equivalent to calling {@link #getLongValue}\n+     * and then casting; except for possible overflow/underflow\n+     * exception.\n+     *<p>\n+     * Note: if the value falls\n+     * outside of range of Java double, a {@link JsonParseException}\n+     * will be thrown to indicate numeric overflow/underflow.\n+     */\n+    public abstract double getDoubleValue()\n+        throws IOException, JsonParseException;\n+\n+    /**\n+     * Numeric accessor that can be called when the current\n+     * token is of type {@link JsonToken#VALUE_NUMBER_FLOAT} or\n+     * {@link JsonToken#VALUE_NUMBER_INT}. No under/overflow exceptions\n+     * are ever thrown.\n+     */\n+    public abstract BigDecimal getDecimalValue()\n+        throws IOException, JsonParseException;\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, access to token information, other\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Convenience accessor that can be called when the current\n+     * token is {@link JsonToken#VALUE_TRUE} or\n+     * {@link JsonToken#VALUE_FALSE}.\n+     *<p>\n+     * Note: if the token is not of above-mentioned boolean types,\n+ an integer, but its value falls\n+     * outside of range of Java long, a {@link JsonParseException}\n+     * may be thrown to indicate numeric overflow/underflow.\n+     */\n+    public boolean getBooleanValue()\n+        throws IOException, JsonParseException\n+    {\n+        if (_currToken == JsonToken.VALUE_TRUE) return true;\n+        if (_currToken == JsonToken.VALUE_FALSE) return false;\n+        throw new JsonParseException(\"Current token (\"+_currToken+\") not of boolean type\", getCurrentLocation());\n+    }\n+\n+    /**\n+     * Accessor that can be called if (and only if) the current token\n+     * is {@link JsonToken#VALUE_EMBEDDED_OBJECT}. For other token types,\n+     * null is returned.\n+     *<p>\n+     * Note: only some specialized parser implementations support\n+     * embedding of objects (usually ones that are facades on top\n+     * of non-streaming sources, such as object trees).\n+     */\n+    public Object getEmbeddedObject()\n+        throws IOException, JsonParseException\n+    {\n+        // By default we will always return null\n+        return null;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, access to token information, binary\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that can be used to read (and consume -- results\n+     * may not be accessible using other methods after the call)\n+     * base64-encoded binary data\n+     * included in the current textual JSON value.\n+     * It works similar to getting String value via {@link #getText}\n+     * and decoding result (except for decoding part),\n+     * but should be significantly more performant.\n+     *<p>\n+     * Note that non-decoded textual contents of the current token\n+     * are not guaranteed to be accessible after this method\n+     * is called. Current implementation, for example, clears up\n+     * textual content during decoding.\n+     * Decoded binary content, however, will be retained until\n+     * parser is advanced to the next event.\n+     *\n+     * @param b64variant Expected variant of base64 encoded\n+     *   content (see {@link Base64Variants} for definitions\n+     *   of \"standard\" variants).\n+     *\n+     * @return Decoded binary data\n+     */\n+    public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException;\n+\n+    /**\n+     * Convenience alternative to {@link #getBinaryValue(Base64Variant)}\n+     * that defaults to using\n+     * {@link Base64Variants#getDefaultVariant} as the default encoding.\n+     */\n+    public byte[] getBinaryValue() throws IOException, JsonParseException\n+    {\n+        return getBinaryValue(Base64Variants.getDefaultVariant());\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, access to token information, coercion/conversion\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method that will try to convert value of current token to a\n+     * <b>int</b>.\n+     * Numbers are coerced using default Java rules; booleans convert to 0 (false)\n+     * and 1 (true), and Strings are parsed using default Java language integer\n+     * parsing rules.\n+     *<p>\n+     * If representation can not be converted to an int (including structured type\n+     * markers like start/end Object/Array)\n+     * default value of <b>0</b> will be returned; no exceptions are thrown.\n+     */\n+    public int getValueAsInt() throws IOException, JsonParseException {\n+        return getValueAsInt(0);\n+    }\n+    \n+    /**\n+     * Method that will try to convert value of current token to a\n+     * <b>int</b>.\n+     * Numbers are coerced using default Java rules; booleans convert to 0 (false)\n+     * and 1 (true), and Strings are parsed using default Java language integer\n+     * parsing rules.\n+     *<p>\n+     * If representation can not be converted to an int (including structured type\n+     * markers like start/end Object/Array)\n+     * specified <b>defaultValue</b> will be returned; no exceptions are thrown.\n+     */\n+    public int getValueAsInt(int defaultValue) throws IOException, JsonParseException {\n+        return defaultValue;\n+    }\n+\n+    /**\n+     * Method that will try to convert value of current token to a\n+     * <b>long</b>.\n+     * Numbers are coerced using default Java rules; booleans convert to 0 (false)\n+     * and 1 (true), and Strings are parsed using default Java language integer\n+     * parsing rules.\n+     *<p>\n+     * If representation can not be converted to an int (including structured type\n+     * markers like start/end Object/Array)\n+     * default value of <b>0</b> will be returned; no exceptions are thrown.\n+     */\n+    public long getValueAsLong() throws IOException, JsonParseException {\n+        return getValueAsInt(0);\n+    }\n+    \n+    /**\n+     * Method that will try to convert value of current token to a\n+     * <b>long</b>.\n+     * Numbers are coerced using default Java rules; booleans convert to 0 (false)\n+     * and 1 (true), and Strings are parsed using default Java language integer\n+     * parsing rules.\n+     *<p>\n+     * If representation can not be converted to an int (including structured type\n+     * markers like start/end Object/Array)\n+     * specified <b>defaultValue</b> will be returned; no exceptions are thrown.\n+     */\n+    public long getValueAsLong(long defaultValue) throws IOException, JsonParseException {\n+        return defaultValue;\n+    }\n+    \n+    /**\n+     * Method that will try to convert value of current token to a Java\n+     * <b>double</b>.\n+     * Numbers are coerced using default Java rules; booleans convert to 0.0 (false)\n+     * and 1.0 (true), and Strings are parsed using default Java language integer\n+     * parsing rules.\n+     *<p>\n+     * If representation can not be converted to an int (including structured types\n+     * like Objects and Arrays),\n+     * default value of <b>0.0</b> will be returned; no exceptions are thrown.\n+     */\n+    public double getValueAsDouble() throws IOException, JsonParseException {\n+        return getValueAsDouble(0.0);\n+    }\n+    \n+    /**\n+     * Method that will try to convert value of current token to a\n+     * Java <b>double</b>.\n+     * Numbers are coerced using default Java rules; booleans convert to 0.0 (false)\n+     * and 1.0 (true), and Strings are parsed using default Java language integer\n+     * parsing rules.\n+     *<p>\n+     * If representation can not be converted to an int (including structured types\n+     * like Objects and Arrays),\n+     * specified <b>defaultValue</b> will be returned; no exceptions are thrown.\n+     */\n+    public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException {\n+        return defaultValue;\n+    }\n+\n+    /**\n+     * Method that will try to convert value of current token to a\n+     * <b>boolean</b>.\n+     * JSON booleans map naturally; integer numbers other than 0 map to true, and\n+     * 0 maps to false\n+     * and Strings 'true' and 'false' map to corresponding values.\n+     *<p>\n+     * If representation can not be converted to a boolean value (including structured types\n+     * like Objects and Arrays),\n+     * default value of <b>false</b> will be returned; no exceptions are thrown.\n+     */\n+    public boolean getValueAsBoolean() throws IOException, JsonParseException {\n+        return getValueAsBoolean(false);\n+    }\n+\n+    /**\n+     * Method that will try to convert value of current token to a\n+     * <b>boolean</b>.\n+     * JSON booleans map naturally; integer numbers other than 0 map to true, and\n+     * 0 maps to false\n+     * and Strings 'true' and 'false' map to corresponding values.\n+     *<p>\n+     * If representation can not be converted to a boolean value (including structured types\n+     * like Objects and Arrays),\n+     * specified <b>defaultValue</b> will be returned; no exceptions are thrown.\n+     */\n+    public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException {\n+        return defaultValue;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, optional data binding functionality\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method to deserialize JSON content into a non-container\n+     * type (it can be an array type, however): typically a bean, array\n+     * or a wrapper type (like {@link java.lang.Boolean}).\n+     * <b>Note</b>: method can only be called if the parser has\n+     * an object codec assigned; this is true for parsers constructed\n+     * by {@link org.codehaus.jackson.map.MappingJsonFactory} but\n+     * not for {@link JsonFactory} (unless its <code>setCodec</code>\n+     * method has been explicitly called).\n+     *<p>\n+     * This method may advance the event stream, for structured types\n+     * the current token will be the closing end marker (END_ARRAY,\n+     * END_OBJECT) of the bound structure. For non-structured Json types\n+     * (and for {@link JsonToken#VALUE_EMBEDDED_OBJECT})\n+     * stream is not advanced.\n+     *<p>\n+     * Note: this method should NOT be used if the result type is a\n+     * container ({@link java.util.Collection} or {@link java.util.Map}.\n+     * The reason is that due to type erasure, key and value types\n+     * can not be introspected when using this method.\n+     */\n+    public <T> T readValueAs(Class<T> valueType)\n+        throws IOException, JsonProcessingException\n+    {\n+        ObjectCodec codec = getCodec();\n+        if (codec == null) {\n+            throw new IllegalStateException(\"No ObjectCodec defined for the parser, can not deserialize JSON into Java objects\");\n+        }\n+        return codec.readValue(this, valueType);\n+    }\n+\n+    /**\n+     * Method to deserialize JSON content into a Java type, reference\n+     * to which is passed as argument. Type is passed using so-called\n+     * \"super type token\"\n+     * and specifically needs to be used if the root type is a \n+     * parameterized (generic) container type.\n+     * <b>Note</b>: method can only be called if the parser has\n+     * an object codec assigned; this is true for parsers constructed\n+     * by {@link org.codehaus.jackson.map.MappingJsonFactory} but\n+     * not for {@link JsonFactory} (unless its <code>setCodec</code>\n+     * method has been explicitly called).\n+     *<p>\n+     * This method may advance the event stream, for structured types\n+     * the current token will be the closing end marker (END_ARRAY,\n+     * END_OBJECT) of the bound structure. For non-structured Json types\n+     * (and for {@link JsonToken#VALUE_EMBEDDED_OBJECT})\n+     * stream is not advanced.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T readValueAs(TypeReference<?> valueTypeRef)\n+        throws IOException, JsonProcessingException\n+    {\n+        ObjectCodec codec = getCodec();\n+        if (codec == null) {\n+            throw new IllegalStateException(\"No ObjectCodec defined for the parser, can not deserialize JSON into Java objects\");\n+        }\n+        /* Ugh. Stupid Java type erasure... can't just chain call,s\n+         * must cast here also.\n+         */\n+        return (T) codec.readValue(this, valueTypeRef);\n+    }\n+\n+    /**\n+     * Method for reading sequence of Objects from parser stream,\n+     * all with same specified value type.\n+     */\n+    public <T> Iterator<T> readValuesAs(Class<T> valueType)\n+        throws IOException, JsonProcessingException\n+    {\n+        ObjectCodec codec = getCodec();\n+        if (codec == null) {\n+            throw new IllegalStateException(\"No ObjectCodec defined for the parser, can not deserialize JSON into Java objects\");\n+        }\n+        return codec.readValues(this, valueType);\n+    }\n+\n+    /**\n+     * Method for reading sequence of Objects from parser stream,\n+     * all with same specified value type.\n+     */\n+    public <T> Iterator<T> readValuesAs(TypeReference<?> valueTypeRef)\n+        throws IOException, JsonProcessingException\n+    {\n+        ObjectCodec codec = getCodec();\n+        if (codec == null) {\n+            throw new IllegalStateException(\"No ObjectCodec defined for the parser, can not deserialize JSON into Java objects\");\n+        }\n+        return codec.readValues(this, valueTypeRef);\n+    }\n+    \n+    /**\n+     * Method to deserialize JSON content into equivalent \"tree model\",\n+     * represented by root {@link JsonNode} of resulting model.\n+     * For JSON Arrays it will an array node (with child nodes),\n+     * for objects object node (with child nodes), and for other types\n+     * matching leaf node type\n+     */\n+    public JsonNode readValueAsTree()\n+        throws IOException, JsonProcessingException\n+    {\n+        ObjectCodec codec = getCodec();\n+        if (codec == null) {\n+            throw new IllegalStateException(\"No ObjectCodec defined for the parser, can not deserialize JSON into JsonNode tree\");\n+        }\n+        return codec.readTree(this);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Helper method for constructing {@link JsonParseException}s\n+     * based on current state of the parser\n+     */\n+    protected JsonParseException _constructError(String msg)\n+    {\n+        return new JsonParseException(msg, getCurrentLocation());\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonProcessingException.java\n+package com.fasterxml.jackson.core;\n+\n+/**\n+ * Intermediate base class for all problems encountered when\n+ * processing (parsing, generating) JSON content\n+ * that are not pure I/O problems.\n+ * Regular {@link java.io.IOException}s will be passed through as is.\n+ * Sub-class of {@link java.io.IOException} for convenience.\n+ */\n+public class JsonProcessingException\n+    extends java.io.IOException\n+{\n+    final static long serialVersionUID = 123; // Stupid eclipse...\n+\t\n+    protected JsonLocation mLocation;\n+\n+    protected JsonProcessingException(String msg, JsonLocation loc, Throwable rootCause)\n+    {\n+        /* Argh. IOException(Throwable,String) is only available starting\n+         * with JDK 1.6...\n+         */\n+        super(msg);\n+        if (rootCause != null) {\n+            initCause(rootCause);\n+        }\n+        mLocation = loc;\n+    }\n+\n+    protected JsonProcessingException(String msg)\n+    {\n+        super(msg);\n+    }\n+\n+    protected JsonProcessingException(String msg, JsonLocation loc)\n+    {\n+        this(msg, loc, null);\n+    }\n+\n+    protected JsonProcessingException(String msg, Throwable rootCause)\n+    {\n+        this(msg, null, rootCause);\n+    }\n+\n+    protected JsonProcessingException(Throwable rootCause)\n+    {\n+        this(null, null, rootCause);\n+    }\n+\n+    public JsonLocation getLocation()\n+    {\n+        return mLocation;\n+    }\n+\n+    /**\n+     * Default method overridden so that we can add location information\n+     */\n+    @Override\n+    public String getMessage()\n+    {\n+        String msg = super.getMessage();\n+        if (msg == null) {\n+            msg = \"N/A\";\n+        }\n+        JsonLocation loc = getLocation();\n+        if (loc != null) {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(msg);\n+            sb.append('\\n');\n+            sb.append(\" at \");\n+            sb.append(loc.toString());\n+            return sb.toString();\n+        }\n+        return msg;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return getClass().getName()+\": \"+getMessage();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonStreamContext.java\n+/* Jackson JSON-processor.\n+ *\n+ * Copyright (c) 2007- Tatu Saloranta, tatu.saloranta@iki.fi\n+ *\n+ * Licensed under the License specified in file LICENSE, included with\n+ * the source code and binary code bundles.\n+ * You may not use this file except in compliance with the License.\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.fasterxml.jackson.core;\n+\n+/**\n+ * Shared base class for streaming processing contexts used during\n+ * reading and writing of Json content using Streaming API.\n+ * This context is also exposed to applications:\n+ * context object can be used by applications to get an idea of\n+ * relative position of the parser/generator within json content\n+ * being processed. This allows for some contextual processing: for\n+ * example, output within Array context can differ from that of\n+ * Object context.\n+ */\n+public abstract class JsonStreamContext\n+{\n+    // // // Type constants used internally\n+\n+    protected final static int TYPE_ROOT = 0;\n+    protected final static int TYPE_ARRAY = 1;\n+    protected final static int TYPE_OBJECT = 2;\n+\n+    protected int _type;\n+\n+    /**\n+     * Index of the currently processed entry. Starts with -1 to signal\n+     * that no entries have been started, and gets advanced each\n+     * time a new entry is started, either by encountering an expected\n+     * separator, or with new values if no separators are expected\n+     * (the case for root context).\n+     */\n+    protected int _index;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    protected JsonStreamContext() { }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, accessors\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Accessor for finding parent context of this context; will\n+     * return null for root context.\n+     */\n+    public abstract JsonStreamContext getParent();\n+\n+    /**\n+     * Method that returns true if this context is an Array context;\n+     * that is, content is being read from or written to a Json Array.\n+     */\n+    public final boolean inArray() { return _type == TYPE_ARRAY; }\n+\n+    /**\n+     * Method that returns true if this context is a Root context;\n+     * that is, content is being read from or written to without\n+     * enclosing array or object structure.\n+     */\n+    public final boolean inRoot() { return _type == TYPE_ROOT; }\n+\n+    /**\n+     * Method that returns true if this context is an Object context;\n+     * that is, content is being read from or written to a Json Object.\n+     */\n+    public final boolean inObject() { return _type == TYPE_OBJECT; }\n+\n+    /**\n+     * Method for accessing simple type description of current context;\n+     * either ROOT (for root-level values), OBJECT (for field names and\n+     * values of JSON Objects) or ARRAY (for values of JSON Arrays)\n+     */\n+    public final String getTypeDesc() {\n+        switch (_type) {\n+        case TYPE_ROOT: return \"ROOT\";\n+        case TYPE_ARRAY: return \"ARRAY\";\n+        case TYPE_OBJECT: return \"OBJECT\";\n+        }\n+        return \"?\";\n+    }\n+\n+    /**\n+     * @return Number of entries that are complete and started.\n+     */\n+    public final int getEntryCount()\n+    {\n+        return _index + 1;\n+    }\n+\n+    /**\n+     * @return Index of the currently processed entry, if any\n+     */\n+    public final int getCurrentIndex()\n+    {\n+        return (_index < 0) ? 0 : _index;\n+    }\n+\n+    /**\n+     * Method for accessing name associated with the current location.\n+     * Non-null for <code>FIELD_NAME</code> and value events that directly\n+     * follow field names; null for root level and array values.\n+     */\n+    public abstract String getCurrentName();\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonToken.java\n+package com.fasterxml.jackson.core;\n+\n+/**\n+ * Enumeration for basic token types used for returning results\n+ * of parsing JSON content.\n+ */\n+public enum JsonToken\n+{\n+    /* Some notes on implementation:\n+     *\n+     * - Entries are to be ordered such that start/end array/object\n+     *   markers come first, then field name marker (if any), and\n+     *   finally scalar value tokens. This is assumed by some\n+     *   typing checks.\n+     */\n+\n+    /**\n+     * NOT_AVAILABLE can be returned if {@link JsonParser}\n+     * implementation can not currently return the requested\n+     * token (usually next one), or even if any will be\n+     * available, but that may be able to determine this in\n+     * future. This is the case with non-blocking parsers --\n+     * they can not block to wait for more data to parse and\n+     * must return something.\n+     *\n+     * @since 0.9.7\n+     */\n+    NOT_AVAILABLE(null),\n+\n+    /**\n+     * START_OBJECT is returned when encountering '{'\n+     * which signals starting of an Object value.\n+     */\n+    START_OBJECT(\"{\"),\n+        \n+    /**\n+     * START_OBJECT is returned when encountering '}'\n+     * which signals ending of an Object value\n+     */\n+    END_OBJECT(\"}\"),\n+        \n+    /**\n+     * START_OBJECT is returned when encountering '['\n+     * which signals starting of an Array value\n+     */\n+    START_ARRAY(\"[\"),\n+\n+    /**\n+     * START_OBJECT is returned when encountering ']'\n+     * which signals ending of an Array value\n+     */\n+    END_ARRAY(\"]\"),\n+        \n+    /**\n+     * FIELD_NAME is returned when a String token is encountered\n+     * as a field name (same lexical value, different function)\n+     */\n+    FIELD_NAME(null),\n+        \n+    /**\n+     * Placeholder token returned when the input source has a concept\n+     * of embedded Object that are not accessible as usual structure\n+     * (of starting with {@link #START_OBJECT}, having values, ending with\n+     * {@link #END_OBJECT}), but as \"raw\" objects.\n+     *<p>\n+     * Note: this token is never returned by regular JSON readers, but\n+     * only by readers that expose other kinds of source (like\n+     * {@link JsonNode}-based JSON trees, Maps, Lists and such).\n+     *\n+     * @since 1.1\n+     */\n+    VALUE_EMBEDDED_OBJECT(null),\n+\n+    /**\n+     * VALUE_STRING is returned when a String token is encountered\n+     * in value context (array element, field value, or root-level\n+     * stand-alone value)\n+     */\n+    VALUE_STRING(null),\n+\n+    /**\n+     * VALUE_NUMBER_INT is returned when an integer numeric token is\n+     * encountered in value context: that is, a number that does\n+     * not have floating point or exponent marker in it (consists\n+     * only of an optional sign, followed by one or more digits)\n+     */\n+    VALUE_NUMBER_INT(null),\n+\n+    /**\n+     * VALUE_NUMBER_INT is returned when a numeric token other\n+     * that is not an integer is encountered: that is, a number that does\n+     * have floating point or exponent marker in it, in addition\n+     * to one or more digits.\n+     */\n+    VALUE_NUMBER_FLOAT(null),\n+\n+    /**\n+     * VALUE_TRUE is returned when encountering literal \"true\" in\n+     * value context\n+     */\n+    VALUE_TRUE(\"true\"),\n+\n+    /**\n+     * VALUE_FALSE is returned when encountering literal \"false\" in\n+     * value context\n+     */\n+    VALUE_FALSE(\"false\"),\n+\n+    /**\n+     * VALUE_NULL is returned when encountering literal \"null\" in\n+     * value context\n+     */\n+    VALUE_NULL(\"null\")\n+        ;\n+\n+    final String _serialized;\n+\n+    final char[] _serializedChars;\n+\n+    final byte[] _serializedBytes;\n+\n+    /**\n+     * @param Textual representation for this token, if there is a\n+     *   single static representation; null otherwise\n+     */\n+    JsonToken(String token)\n+    {\n+        if (token == null) {\n+            _serialized = null;\n+            _serializedChars = null;\n+            _serializedBytes = null;\n+        } else {\n+            _serialized = token;\n+            _serializedChars = token.toCharArray();\n+            // It's all in ascii, can just case...\n+            int len = _serializedChars.length;\n+            _serializedBytes = new byte[len];\n+            for (int i = 0; i < len; ++i) {\n+                _serializedBytes[i] = (byte) _serializedChars[i];\n+            }\n+        }\n+    }\n+\n+    public String asString() { return _serialized; }\n+    public char[] asCharArray() { return _serializedChars; }\n+    public byte[] asByteArray() { return _serializedBytes; }\n+\n+    public boolean isNumeric() {\n+        return (this == VALUE_NUMBER_INT) || (this == VALUE_NUMBER_FLOAT);\n+    }\n+\n+    /**\n+     * Method that can be used to check whether this token represents\n+     * a valid non-structured value. This means all tokens other than\n+     * Object/Array start/end markers all field names.\n+     */\n+    public boolean isScalarValue() {\n+        // note: up to 1.5, VALUE_EMBEDDED_OBJECT was incorrectly considered non-scalar!\n+        return ordinal() >= VALUE_EMBEDDED_OBJECT.ordinal();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/ObjectCodec.java\n+package com.fasterxml.jackson.core;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+\n+/**\n+ * Abstract class that defines the interface that {@link JsonParser} and\n+ * {@link JsonGenerator} use to serialize and deserialize regular\n+ * Java objects (POJOs aka Beans).\n+ *<p>\n+ * The standard implementation of this class is\n+ * {@link org.codehaus.jackson.map.ObjectMapper}.\n+ */\n+public abstract class ObjectCodec\n+{\n+    protected ObjectCodec() { }\n+\n+    /*\n+    /**********************************************************\n+    /* API for de-serialization (JSON-to-Object)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method to deserialize JSON content into a non-container\n+     * type (it can be an array type, however): typically a bean, array\n+     * or a wrapper type (like {@link java.lang.Boolean}).\n+     *<p>\n+     * Note: this method should NOT be used if the result type is a\n+     * container ({@link java.util.Collection} or {@link java.util.Map}.\n+     * The reason is that due to type erasure, key and value types\n+     * can not be introspected when using this method.\n+     */\n+    public abstract <T> T readValue(JsonParser jp, Class<T> valueType)\n+        throws IOException, JsonProcessingException;\n+\n+    /**\n+     * Method to deserialize JSON content into a Java type, reference\n+     * to which is passed as argument. Type is passed using so-called\n+     * \"super type token\" \n+     * and specifically needs to be used if the root type is a \n+     * parameterized (generic) container type.\n+     */\n+    public abstract <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef)\n+        throws IOException, JsonProcessingException;\n+\n+    /**\n+     * Method to deserialize JSON content as tree expressed\n+     * using set of {@link JsonNode} instances. Returns\n+     * root of the resulting tree (where root can consist\n+     * of just a single node if the current event is a\n+     * value event, not container).\n+     */\n+    public abstract <T> T readValue(JsonParser jp, JavaType valueType)\n+        throws IOException, JsonProcessingException;\n+\n+    /**\n+     * Method to deserialize JSON content as tree expressed\n+     * using set of {@link JsonNode} instances. Returns\n+     * root of the resulting tree (where root can consist\n+     * of just a single node if the current event is a\n+     * value event, not container).\n+     */\n+    public abstract JsonNode readTree(JsonParser jp)\n+        throws IOException, JsonProcessingException;\n+\n+    /**\n+     * Method for reading sequence of Objects from parser stream,\n+     * all with same specified value type.\n+     * \n+     * @since 1.9\n+     */\n+    public abstract <T> Iterator<T> readValues(JsonParser jp, Class<T> valueType)\n+        throws IOException, JsonProcessingException;\n+\n+    /**\n+     * Method for reading sequence of Objects from parser stream,\n+     * all with same specified value type.\n+     * \n+     * @since 1.9\n+     */\n+    public abstract <T> Iterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef)\n+        throws IOException, JsonProcessingException;\n+    \n+    /**\n+     * Method for reading sequence of Objects from parser stream,\n+     * all with same specified value type.\n+     * \n+     * @since 1.9\n+     */\n+    public abstract <T> Iterator<T> readValues(JsonParser jp, JavaType valueType)\n+        throws IOException, JsonProcessingException;\n+    \n+    /*\n+    /**********************************************************\n+    /* API for serialization (Object-to-JSON)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method to serialize given Java Object, using generator\n+     * provided.\n+     */\n+    public abstract void writeValue(JsonGenerator jgen, Object value)\n+        throws IOException, JsonProcessingException;\n+\n+    /**\n+     * Method to serialize given Json Tree, using generator\n+     * provided.\n+     */\n+    public abstract void writeTree(JsonGenerator jgen, JsonNode rootNode)\n+        throws IOException, JsonProcessingException;\n+\n+    /*\n+    /**********************************************************\n+    /* API for Tree Model handling\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for construct root level Object nodes\n+     * for Tree Model instances.\n+     *\n+     * @since 1.2\n+     */\n+    public abstract JsonNode createObjectNode();\n+\n+    /**\n+     * Method for construct root level Array nodes\n+     * for Tree Model instances.\n+     *\n+     * @since 1.2\n+     */\n+    public abstract JsonNode createArrayNode();\n+\n+    /**\n+     * Method for constructing a {@link JsonParser} for reading\n+     * contents of a JSON tree, as if it was external serialized\n+     * JSON content.\n+     *\n+     * @since 1.3\n+     */\n+    public abstract JsonParser treeAsTokens(JsonNode n);\n+\n+    /**\n+     * Convenience method for converting given JSON tree into instance of specified\n+     * value type. This is equivalent to first constructing a {@link JsonParser} to\n+     * iterate over contents of the tree, and using that parser for data binding.\n+     * \n+     * @since 1.3\n+     */\n+    public abstract <T> T treeToValue(JsonNode n, Class<T> valueType)\n+        throws IOException, JsonProcessingException;\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/PrettyPrinter.java\n+package com.fasterxml.jackson.core;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Interface for objects that implement pretty printer functionality, such\n+ * as indentation.\n+ * Pretty printers are used to add white space in output JSON content,\n+ * to make results more human readable. Usually this means things like adding\n+ * linefeeds and indentation.\n+ */\n+public interface PrettyPrinter\n+{\n+    /*\n+    /**********************************************************\n+    /* First methods that act both as events, and expect\n+    /* output for correct functioning (i.e something gets\n+    /* output even when not pretty-printing)\n+    /**********************************************************\n+     */\n+\n+    // // // Root-level handling:\n+\n+    /**\n+     * Method called after a root-level value has been completely\n+     * output, and before another value is to be output.\n+     *<p>\n+     * Default\n+     * handling (without pretty-printing) will output a space, to\n+     * allow values to be parsed correctly. Pretty-printer is\n+     * to output some other suitable and nice-looking separator\n+     * (tab(s), space(s), linefeed(s) or any combination thereof).\n+     */\n+    public void writeRootValueSeparator(JsonGenerator jg)\n+        throws IOException, JsonGenerationException;\n+\n+    // // Object handling\n+\n+    /**\n+     * Method called when an Object value is to be output, before\n+     * any fields are output.\n+     *<p>\n+     * Default handling (without pretty-printing) will output\n+     * the opening curly bracket.\n+     * Pretty-printer is\n+     * to output a curly bracket as well, but can surround that\n+     * with other (white-space) decoration.\n+     */\n+    public void writeStartObject(JsonGenerator jg)\n+        throws IOException, JsonGenerationException;\n+\n+    /**\n+     * Method called after an Object value has been completely output\n+     * (minus closing curly bracket).\n+     *<p>\n+     * Default handling (without pretty-printing) will output\n+     * the closing curly bracket.\n+     * Pretty-printer is\n+     * to output a curly bracket as well, but can surround that\n+     * with other (white-space) decoration.\n+     *\n+     * @param nrOfEntries Number of direct members of the array that\n+     *   have been output\n+     */\n+    public void writeEndObject(JsonGenerator jg, int nrOfEntries)\n+        throws IOException, JsonGenerationException;\n+\n+    /**\n+     * Method called after an object entry (field:value) has been completely\n+     * output, and before another value is to be output.\n+     *<p>\n+     * Default handling (without pretty-printing) will output a single\n+     * comma to separate the two. Pretty-printer is\n+     * to output a comma as well, but can surround that with other\n+     * (white-space) decoration.\n+     */\n+    public void writeObjectEntrySeparator(JsonGenerator jg)\n+        throws IOException, JsonGenerationException;\n+\n+    /**\n+     * Method called after an object field has been output, but\n+     * before the value is output.\n+     *<p>\n+     * Default handling (without pretty-printing) will output a single\n+     * colon to separate the two. Pretty-printer is\n+     * to output a colon as well, but can surround that with other\n+     * (white-space) decoration.\n+     */\n+    public void writeObjectFieldValueSeparator(JsonGenerator jg)\n+        throws IOException, JsonGenerationException;\n+\n+    // // // Array handling\n+\n+    /**\n+     * Method called when an Array value is to be output, before\n+     * any member/child values are output.\n+     *<p>\n+     * Default handling (without pretty-printing) will output\n+     * the opening bracket.\n+     * Pretty-printer is\n+     * to output a bracket as well, but can surround that\n+     * with other (white-space) decoration.\n+     */\n+    public void writeStartArray(JsonGenerator jg)\n+        throws IOException, JsonGenerationException;\n+\n+    /**\n+     * Method called after an Array value has been completely output\n+     * (minus closing bracket).\n+     *<p>\n+     * Default handling (without pretty-printing) will output\n+     * the closing bracket.\n+     * Pretty-printer is\n+     * to output a bracket as well, but can surround that\n+     * with other (white-space) decoration.\n+     *\n+     * @param nrOfValues Number of direct members of the array that\n+     *   have been output\n+     */\n+    public void writeEndArray(JsonGenerator jg, int nrOfValues)\n+        throws IOException, JsonGenerationException;\n+\n+    /**\n+     * Method called after an array value has been completely\n+     * output, and before another value is to be output.\n+     *<p>\n+     * Default handling (without pretty-printing) will output a single\n+     * comma to separate the two. Pretty-printer is\n+     * to output a comma as well, but can surround that with other\n+     * (white-space) decoration.\n+     */\n+    public void writeArrayValueSeparator(JsonGenerator jg)\n+        throws IOException, JsonGenerationException;\n+\n+    /*\n+    /**********************************************************\n+    /* Then events that by default do not produce any output\n+    /* but that are often overridden to add white space\n+    /* in pretty-printing mode\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called after array start marker has been output,\n+     * and right before the first value is to be output.\n+     * It is <b>not</b> called for arrays with no values.\n+     *<p>\n+     * Default handling does not output anything, but pretty-printer\n+     * is free to add any white space decoration.\n+     */\n+    public void beforeArrayValues(JsonGenerator jg)\n+        throws IOException, JsonGenerationException;\n+\n+    /**\n+     * Method called after object start marker has been output,\n+     * and right before the field name of the first entry is\n+     * to be output.\n+     * It is <b>not</b> called for objects without entries.\n+     *<p>\n+     * Default handling does not output anything, but pretty-printer\n+     * is free to add any white space decoration.\n+     */\n+    public void beforeObjectEntries(JsonGenerator jg)\n+        throws IOException, JsonGenerationException;\n+}\n+\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/SerializableString.java\n+package com.fasterxml.jackson.core;\n+\n+/**\n+ * Interface that defines how Jackson package can interact with efficient\n+ * pre-serialized or lazily-serialized and reused String representations.\n+ * Typically implementations store possible serialized version(s) so that\n+ * serialization of String can be done more efficiently, especially when\n+ * used multiple times.\n+ *\n+ * @since 1.7 (1.6 introduced implementation, but interface extracted later)\n+ * \n+ * @see com.fasterxml.jackson.core.io.SerializedString\n+ */\n+public interface SerializableString\n+{\n+    /**\n+     * Returns unquoted String that this object represents (and offers\n+     * serialized forms for)\n+     */\n+    public String getValue();\n+    \n+    /**\n+     * Returns length of the (unquoted) String as characters.\n+     * Functionally equvalent to:\n+     *<pre>\n+     *   getValue().length();\n+     *</pre>\n+     */\n+    public int charLength();\n+\n+    /**\n+     * Returns JSON quoted form of the String, as character array. Result\n+     * can be embedded as-is in textual JSON as property name or JSON String.\n+     */\n+    public char[] asQuotedChars();\n+\n+    /**\n+     * Returns UTF-8 encoded version of unquoted String.\n+     * Functionally equivalent to (but more efficient than):\n+     *<pre>\n+     * getValue().getBytes(\"UTF-8\");\n+     *</pre>\n+     */\n+    public byte[] asUnquotedUTF8();\n+\n+    /**\n+     * Returns UTF-8 encoded version of JSON-quoted String.\n+     * Functionally equivalent to (but more efficient than):\n+     *<pre>\n+     * new String(asQuotedChars()).getBytes(\"UTF-8\");\n+     *</pre>\n+     */\n+    public byte[] asQuotedUTF8();\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/Version.java\n+package com.fasterxml.jackson.core;\n+\n+/**\n+ * Object that encapsulates version information of a component,\n+ * and is return by {@link Versioned#version}.\n+ * \n+ * @since 1.6\n+ */\n+public class Version\n+    implements Comparable<Version>\n+{\n+    private final static Version UNKNOWN_VERSION = new Version(0, 0, 0, null);\n+\n+    protected final int _majorVersion;\n+\n+    protected final int _minorVersion;\n+\n+    protected final int _patchLevel;\n+\n+    /**\n+     * Additional information for snapshot versions; null for non-snapshot\n+     * (release) versions.\n+     */\n+    protected final String _snapshotInfo;\n+    \n+    public Version(int major, int minor, int patchLevel,\n+            String snapshotInfo)\n+    {\n+        _majorVersion = major;\n+        _minorVersion = minor;\n+        _patchLevel = patchLevel;\n+        _snapshotInfo = snapshotInfo;\n+    }\n+\n+    /**\n+     * Method returns canonical \"not known\" version, which is used as version\n+     * in cases where actual version information is not known (instead of null).\n+     */\n+    public static Version unknownVersion() { return UNKNOWN_VERSION; }\n+\n+    public boolean isUknownVersion() { return (this == UNKNOWN_VERSION); }\n+    public boolean isSnapshot() { return (_snapshotInfo != null && _snapshotInfo.length() > 0); }\n+    \n+    public int getMajorVersion() { return _majorVersion; }\n+    public int getMinorVersion() { return _minorVersion; }\n+    public int getPatchLevel() { return _patchLevel; }\n+\n+    @Override\n+    public String toString()\n+    {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(_majorVersion).append('.');\n+        sb.append(_minorVersion).append('.');\n+        sb.append(_patchLevel);\n+        if (isSnapshot()) {\n+            sb.append('-').append(_snapshotInfo);\n+        }\n+        return sb.toString();\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return _majorVersion + _minorVersion + _patchLevel;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (o.getClass() != getClass()) return false;\n+        Version other = (Version) o;\n+        return (other._majorVersion == _majorVersion)\n+            && (other._minorVersion == _minorVersion)\n+            && (other._patchLevel == _patchLevel);\n+    }\n+\n+    @Override\n+    public int compareTo(Version other)\n+    {\n+        int diff = _majorVersion - other._majorVersion;\n+        if (diff == 0) {\n+            diff = _minorVersion - other._minorVersion;\n+            if (diff == 0) {\n+                diff = _patchLevel - other._patchLevel;\n+            }\n+        }\n+        return diff;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/Versioned.java\n+package com.fasterxml.jackson.core;\n+\n+/**\n+ * Interface that those Jackson components that are explicitly versioned will implement.\n+ * Intention is to allow both plug-in components (custom extensions) and applications and\n+ * frameworks that use Jackson to detect exact version of Jackson in use.\n+ * This may be useful for example for ensuring that proper Jackson version is deployed\n+ * (beyond mechanisms that deployment system may have), as well as for possible\n+ * workarounds.\n+ * \n+ * @since 1.6\n+ */\n+public interface Versioned {\n+    /**\n+     * Method called to detect version of the component that implements this interface;\n+     * returned version should never be null, but may return specific \"not available\"\n+     * instance (see {@link Version} for details).\n+     */\n+    public Version version();\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n+package com.fasterxml.jackson.core.base;\n+\n+import java.io.*;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.json.JsonWriteContext;\n+import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\n+import com.fasterxml.jackson.core.util.VersionUtil;\n+\n+/**\n+ * This base class implements part of API that a JSON generator exposes\n+ * to applications, adds shared internal methods that sub-classes\n+ * can use and adds some abstract methods sub-classes must implement.\n+ */\n+public abstract class GeneratorBase\n+    extends JsonGenerator\n+{\n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+\n+    protected ObjectCodec _objectCodec;\n+\n+    /**\n+     * Bit flag composed of bits that indicate which\n+     * {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s\n+     * are enabled.\n+     */\n+    protected int _features;\n+\n+    /**\n+     * Flag set to indicate that implicit conversion from number\n+     * to JSON String is needed (as per\n+     * {@link com.fasterxml.jackson.core.JsonGenerator.Feature#WRITE_NUMBERS_AS_STRINGS}).\n+     */\n+    protected boolean _cfgNumbersAsStrings;\n+    \n+    /*\n+    /**********************************************************\n+    /* State\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Object that keeps track of the current contextual state\n+     * of the generator.\n+     */\n+    protected JsonWriteContext _writeContext;\n+\n+    /**\n+     * Flag that indicates whether generator is closed or not. Gets\n+     * set when it is closed by an explicit call\n+     * ({@link #close}).\n+     */\n+    protected boolean _closed;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    protected GeneratorBase(int features, ObjectCodec codec)\n+    {\n+        super();\n+        _features = features;\n+        _writeContext = JsonWriteContext.createRootContext();\n+        _objectCodec = codec;\n+        _cfgNumbersAsStrings = isEnabled(Feature.WRITE_NUMBERS_AS_STRINGS);\n+    }\n+\n+    @Override\n+    public Version version() {\n+        return VersionUtil.versionFor(getClass());\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JsonGenerator enable(Feature f) {\n+        _features |= f.getMask();\n+        if (f == Feature.WRITE_NUMBERS_AS_STRINGS) {\n+            _cfgNumbersAsStrings = true;\n+        } else if (f == Feature.ESCAPE_NON_ASCII) {\n+            setHighestNonEscapedChar(127);\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public JsonGenerator disable(Feature f) {\n+        _features &= ~f.getMask();\n+        if (f == Feature.WRITE_NUMBERS_AS_STRINGS) {\n+            _cfgNumbersAsStrings = false;\n+        } else if (f == Feature.ESCAPE_NON_ASCII) {\n+            setHighestNonEscapedChar(0);\n+        }\n+        return this;\n+    }\n+\n+    //public JsonGenerator configure(Feature f, boolean state) { }\n+\n+    @Override\n+    public final boolean isEnabled(Feature f) {\n+        return (_features & f.getMask()) != 0;\n+    }\n+\n+    @Override\n+    public JsonGenerator useDefaultPrettyPrinter() {\n+        return setPrettyPrinter(new DefaultPrettyPrinter());\n+    }\n+    \n+    @Override\n+    public JsonGenerator setCodec(ObjectCodec oc) {\n+        _objectCodec = oc;\n+        return this;\n+    }\n+\n+    @Override\n+    public final ObjectCodec getCodec() { return _objectCodec; }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, accessors\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Note: co-variant return type.\n+     */\n+    @Override\n+    public final JsonWriteContext getOutputContext() { return _writeContext; }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, structural\n+    /**********************************************************\n+     */\n+\n+    //public void writeStartArray() throws IOException, JsonGenerationException\n+    //public void writeEndArray() throws IOException, JsonGenerationException\n+    //public void writeStartObject() throws IOException, JsonGenerationException\n+    //public void writeEndObject() throws IOException, JsonGenerationException\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, textual\n+    /**********************************************************\n+     */\n+\n+    //public abstract void writeString(String text) throws IOException, JsonGenerationException;\n+\n+    //public abstract void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException;\n+\n+    //public abstract void writeRaw(String text) throws IOException, JsonGenerationException;\n+\n+    //public abstract void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException;\n+\n+    @Override\n+    public void writeRawValue(String text)\n+        throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write raw value\");\n+        writeRaw(text);\n+    }\n+\n+    @Override\n+    public void writeRawValue(String text, int offset, int len)\n+        throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write raw value\");\n+        writeRaw(text, offset, len);\n+    }\n+\n+    @Override\n+    public void writeRawValue(char[] text, int offset, int len)\n+        throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write raw value\");\n+        writeRaw(text, offset, len);\n+    }\n+    \n+    //public abstract void writeBinary(byte[] data, int offset, int len, boolean includeLFs) throws IOException, JsonGenerationException;\n+\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, primitive\n+    /**********************************************************\n+     */\n+\n+    // Not implemented at this level, added as placeholders\n+\n+     /*\n+    public abstract void writeNumber(int i)\n+    public abstract void writeNumber(long l)\n+    public abstract void writeNumber(double d)\n+    public abstract void writeNumber(float f)\n+    public abstract void writeNumber(BigDecimal dec)\n+    public abstract void writeBoolean(boolean state)\n+    public abstract void writeNull()\n+    */\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, POJOs, trees\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeObject(Object value)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (value == null) {\n+            // important: call method that does check value write:\n+            writeNull();\n+        } else {\n+            /* 02-Mar-2009, tatu: we are NOT to call _verifyValueWrite here,\n+             *   because that will be done when codec actually serializes\n+             *   contained POJO. If we did call it it would advance state\n+             *   causing exception later on\n+             */\n+            if (_objectCodec != null) {\n+                _objectCodec.writeValue(this, value);\n+                return;\n+            }\n+            _writeSimpleObject(value);\n+        }\n+    }\n+\n+    @Override\n+    public void writeTree(JsonNode rootNode)\n+        throws IOException, JsonProcessingException\n+    {\n+        // As with 'writeObject()', we are not check if write would work\n+        if (rootNode == null) {\n+            writeNull();\n+        } else {\n+            if (_objectCodec == null) {\n+                throw new IllegalStateException(\"No ObjectCodec defined for the generator, can not serialize JsonNode-based trees\");\n+            }\n+            _objectCodec.writeTree(this, rootNode);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, low-level output handling\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public abstract void flush() throws IOException;\n+\n+    @Override\n+    public void close() throws IOException\n+    {\n+        _closed = true;\n+    }\n+\n+    @Override\n+    public boolean isClosed() { return _closed; }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, copy-through methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public final void copyCurrentEvent(JsonParser jp)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonToken t = jp.getCurrentToken();\n+        // sanity check; what to do?\n+        if (t == null) {\n+            _reportError(\"No current event to copy\");\n+        }\n+        switch(t) {\n+        case START_OBJECT:\n+            writeStartObject();\n+            break;\n+        case END_OBJECT:\n+            writeEndObject();\n+            break;\n+        case START_ARRAY:\n+            writeStartArray();\n+            break;\n+        case END_ARRAY:\n+            writeEndArray();\n+            break;\n+        case FIELD_NAME:\n+            writeFieldName(jp.getCurrentName());\n+            break;\n+        case VALUE_STRING:\n+            if (jp.hasTextCharacters()) {\n+                writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength());\n+            } else {\n+                writeString(jp.getText());\n+            }\n+            break;\n+        case VALUE_NUMBER_INT:\n+            switch (jp.getNumberType()) {\n+            case INT:\n+                writeNumber(jp.getIntValue());\n+                break;\n+            case BIG_INTEGER:\n+                writeNumber(jp.getBigIntegerValue());\n+                break;\n+            default:\n+                writeNumber(jp.getLongValue());\n+            }\n+            break;\n+        case VALUE_NUMBER_FLOAT:\n+            switch (jp.getNumberType()) {\n+            case BIG_DECIMAL:\n+                writeNumber(jp.getDecimalValue());\n+                break;\n+            case FLOAT:\n+                writeNumber(jp.getFloatValue());\n+                break;\n+            default:\n+                writeNumber(jp.getDoubleValue());\n+            }\n+            break;\n+        case VALUE_TRUE:\n+            writeBoolean(true);\n+            break;\n+        case VALUE_FALSE:\n+            writeBoolean(false);\n+            break;\n+        case VALUE_NULL:\n+            writeNull();\n+            break;\n+        case VALUE_EMBEDDED_OBJECT:\n+            writeObject(jp.getEmbeddedObject());\n+            break;\n+        default:\n+            _cantHappen();\n+        }\n+    }\n+\n+    @Override\n+    public final void copyCurrentStructure(JsonParser jp)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonToken t = jp.getCurrentToken();\n+\n+        // Let's handle field-name separately first\n+        if (t == JsonToken.FIELD_NAME) {\n+            writeFieldName(jp.getCurrentName());\n+            t = jp.nextToken();\n+            // fall-through to copy the associated value\n+        }\n+\n+        switch (t) {\n+        case START_ARRAY:\n+            writeStartArray();\n+            while (jp.nextToken() != JsonToken.END_ARRAY) {\n+                copyCurrentStructure(jp);\n+            }\n+            writeEndArray();\n+            break;\n+        case START_OBJECT:\n+            writeStartObject();\n+            while (jp.nextToken() != JsonToken.END_OBJECT) {\n+                copyCurrentStructure(jp);\n+            }\n+            writeEndObject();\n+            break;\n+        default: // others are simple:\n+            copyCurrentEvent(jp);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Package methods for this, sub-classes\n+    /**********************************************************\n+     */\n+\n+    protected abstract void _releaseBuffers();\n+\n+    protected abstract void _verifyValueWrite(String typeMsg)\n+        throws IOException, JsonGenerationException;\n+\n+    protected void _reportError(String msg)\n+        throws JsonGenerationException\n+    {\n+        throw new JsonGenerationException(msg);\n+    }\n+\n+    protected void _cantHappen()\n+    {\n+        throw new RuntimeException(\"Internal error: should never end up through this code path\");\n+    }\n+\n+    /**\n+     * Helper method to try to call appropriate write method for given\n+     * untyped Object. At this point, no structural conversions should be done,\n+     * only simple basic types are to be coerced as necessary.\n+     *\n+     * @param value Non-null value to write\n+     */\n+    protected void _writeSimpleObject(Object value) \n+        throws IOException, JsonGenerationException\n+    {\n+        /* 31-Dec-2009, tatu: Actually, we could just handle some basic\n+         *    types even without codec. This can improve interoperability,\n+         *    and specifically help with TokenBuffer.\n+         */\n+        if (value == null) {\n+            writeNull();\n+            return;\n+        }\n+        if (value instanceof String) {\n+            writeString((String) value);\n+            return;\n+        }\n+        if (value instanceof Number) {\n+            Number n = (Number) value;\n+            if (n instanceof Integer) {\n+                writeNumber(n.intValue());\n+                return;\n+            } else if (n instanceof Long) {\n+                writeNumber(n.longValue());\n+                return;\n+            } else if (n instanceof Double) {\n+                writeNumber(n.doubleValue());\n+                return;\n+            } else if (n instanceof Float) {\n+                writeNumber(n.floatValue());\n+                return;\n+            } else if (n instanceof Short) {\n+                writeNumber(n.shortValue());\n+                return;\n+            } else if (n instanceof Byte) {\n+                writeNumber(n.byteValue());\n+                return;\n+            } else if (n instanceof BigInteger) {\n+                writeNumber((BigInteger) n);\n+                return;\n+            } else if (n instanceof BigDecimal) {\n+                writeNumber((BigDecimal) n);\n+                return;\n+                \n+            // then Atomic types\n+                \n+            } else if (n instanceof AtomicInteger) {\n+                writeNumber(((AtomicInteger) n).get());\n+                return;\n+            } else if (n instanceof AtomicLong) {\n+                writeNumber(((AtomicLong) n).get());\n+                return;\n+            }\n+        } else if (value instanceof byte[]) {\n+            writeBinary((byte[]) value);\n+            return;\n+        } else if (value instanceof Boolean) {\n+            writeBoolean(((Boolean) value).booleanValue());\n+            return;\n+        } else if (value instanceof AtomicBoolean) {\n+            writeBoolean(((AtomicBoolean) value).get());\n+            return;\n+        }\n+        throw new IllegalStateException(\"No ObjectCodec defined for the generator, can only serialize simple wrapper types (type passed \"\n+                +value.getClass().getName()+\")\");\n+    }    \n+\n+    protected final void _throwInternal() {\n+        throw new RuntimeException(\"Internal error: this code path should never get executed\");\n+    }\n+\n+    /**\n+     * @since 1.7\n+     */\n+    protected void _reportUnsupportedOperation() {\n+        throw new UnsupportedOperationException(\"Operation not supported by generator of type \"+getClass().getName());\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n+package com.fasterxml.jackson.core.base;\n+\n+import java.io.*;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.io.IOContext;\n+import com.fasterxml.jackson.core.io.NumberInput;\n+import com.fasterxml.jackson.core.json.JsonReadContext;\n+import com.fasterxml.jackson.core.util.ByteArrayBuilder;\n+import com.fasterxml.jackson.core.util.TextBuffer;\n+import com.fasterxml.jackson.core.util.VersionUtil;\n+\n+/**\n+ * Intermediate base class used by all Jackson {@link JsonParser}\n+ * implementations. Contains most common things that are independent\n+ * of actual underlying input source\n+ *\n+ * @author Tatu Saloranta\n+ */\n+public abstract class ParserBase\n+    extends ParserMinimalBase\n+{\n+    /*\n+    /**********************************************************\n+    /* Generic I/O state\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * I/O context for this reader. It handles buffer allocation\n+     * for the reader.\n+     */\n+    final protected IOContext _ioContext;\n+\n+    /**\n+     * Flag that indicates whether parser is closed or not. Gets\n+     * set when parser is either closed by explicit call\n+     * ({@link #close}) or when end-of-input is reached.\n+     */\n+    protected boolean _closed;\n+\n+    /*\n+    /**********************************************************\n+    /* Current input data\n+    /**********************************************************\n+     */\n+\n+    // Note: type of actual buffer depends on sub-class, can't include\n+\n+    /**\n+     * Pointer to next available character in buffer\n+     */\n+    protected int _inputPtr = 0;\n+\n+    /**\n+     * Index of character after last available one in the buffer.\n+     */\n+    protected int _inputEnd = 0;\n+\n+    /*\n+    /**********************************************************\n+    /* Current input location information\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Number of characters/bytes that were contained in previous blocks\n+     * (blocks that were already processed prior to the current buffer).\n+     */\n+    protected long _currInputProcessed = 0L;\n+\n+    /**\n+     * Current row location of current point in input buffer, starting\n+     * from 1, if available.\n+     */\n+    protected int _currInputRow = 1;\n+\n+    /**\n+     * Current index of the first character of the current row in input\n+     * buffer. Needed to calculate column position, if necessary; benefit\n+     * of not having column itself is that this only has to be updated\n+     * once per line.\n+     */\n+    protected int _currInputRowStart = 0;\n+\n+    /*\n+    /**********************************************************\n+    /* Information about starting location of event\n+    /* Reader is pointing to; updated on-demand\n+    /**********************************************************\n+     */\n+\n+    // // // Location info at point when current token was started\n+\n+    /**\n+     * Total number of bytes/characters read before start of current token.\n+     * For big (gigabyte-sized) sizes are possible, needs to be long,\n+     * unlike pointers and sizes related to in-memory buffers.\n+     */\n+    protected long _tokenInputTotal = 0; \n+\n+    /**\n+     * Input row on which current token starts, 1-based\n+     */\n+    protected int _tokenInputRow = 1;\n+\n+    /**\n+     * Column on input row that current token starts; 0-based (although\n+     * in the end it'll be converted to 1-based)\n+     */\n+    protected int _tokenInputCol = 0;\n+\n+    /*\n+    /**********************************************************\n+    /* Parsing state\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Information about parser context, context in which\n+     * the next token is to be parsed (root, array, object).\n+     */\n+    protected JsonReadContext _parsingContext;\n+\n+    /**\n+     * Secondary token related to the next token after current one;\n+     * used if its type is known. This may be value token that\n+     * follows FIELD_NAME, for example.\n+     */\n+    protected JsonToken _nextToken;\n+\n+    /*\n+    /**********************************************************\n+    /* Buffer(s) for local name(s) and text content\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Buffer that contains contents of String values, including\n+     * field names if necessary (name split across boundary,\n+     * contains escape sequence, or access needed to char array)\n+     */\n+    protected final TextBuffer _textBuffer;\n+\n+    /**\n+     * Temporary buffer that is needed if field name is accessed\n+     * using {@link #getTextCharacters} method (instead of String\n+     * returning alternatives)\n+     */\n+    protected char[] _nameCopyBuffer = null;\n+\n+    /**\n+     * Flag set to indicate whether the field name is available\n+     * from the name copy buffer or not (in addition to its String\n+     * representation  being available via read context)\n+     */\n+    protected boolean _nameCopied = false;\n+\n+    /**\n+     * ByteArrayBuilder is needed if 'getBinaryValue' is called. If so,\n+     * we better reuse it for remainder of content.\n+     */\n+    protected ByteArrayBuilder _byteArrayBuilder = null;\n+\n+    /**\n+     * We will hold on to decoded binary data, for duration of\n+     * current event, so that multiple calls to\n+     * {@link #getBinaryValue} will not need to decode data more\n+     * than once.\n+     */\n+    protected byte[] _binaryValue;\n+\n+    /*\n+    /**********************************************************\n+    /* Constants and fields of former 'JsonNumericParserBase'\n+    /**********************************************************\n+     */\n+\n+    final protected static int NR_UNKNOWN = 0;\n+\n+    // First, integer types\n+\n+    final protected static int NR_INT = 0x0001;\n+    final protected static int NR_LONG = 0x0002;\n+    final protected static int NR_BIGINT = 0x0004;\n+\n+    // And then floating point types\n+\n+    final protected static int NR_DOUBLE = 0x008;\n+    final protected static int NR_BIGDECIMAL = 0x0010;\n+\n+    // Also, we need some numeric constants\n+\n+    final static BigDecimal BD_MIN_LONG = new BigDecimal(Long.MIN_VALUE);\n+    final static BigDecimal BD_MAX_LONG = new BigDecimal(Long.MAX_VALUE);\n+\n+    final static BigDecimal BD_MIN_INT = new BigDecimal(Long.MIN_VALUE);\n+    final static BigDecimal BD_MAX_INT = new BigDecimal(Long.MAX_VALUE);\n+\n+    final static long MIN_INT_L = (long) Integer.MIN_VALUE;\n+    final static long MAX_INT_L = (long) Integer.MAX_VALUE;\n+\n+    // These are not very accurate, but have to do... (for bounds checks)\n+\n+    final static double MIN_LONG_D = (double) Long.MIN_VALUE;\n+    final static double MAX_LONG_D = (double) Long.MAX_VALUE;\n+\n+    final static double MIN_INT_D = (double) Integer.MIN_VALUE;\n+    final static double MAX_INT_D = (double) Integer.MAX_VALUE;\n+    \n+    \n+    // Digits, numeric\n+    final protected static int INT_0 = '0';\n+    final protected static int INT_1 = '1';\n+    final protected static int INT_2 = '2';\n+    final protected static int INT_3 = '3';\n+    final protected static int INT_4 = '4';\n+    final protected static int INT_5 = '5';\n+    final protected static int INT_6 = '6';\n+    final protected static int INT_7 = '7';\n+    final protected static int INT_8 = '8';\n+    final protected static int INT_9 = '9';\n+\n+    final protected static int INT_MINUS = '-';\n+    final protected static int INT_PLUS = '+';\n+    final protected static int INT_DECIMAL_POINT = '.';\n+\n+    final protected static int INT_e = 'e';\n+    final protected static int INT_E = 'E';\n+\n+    final protected static char CHAR_NULL = '\\0';\n+    \n+    // Numeric value holders: multiple fields used for\n+    // for efficiency\n+\n+    /**\n+     * Bitfield that indicates which numeric representations\n+     * have been calculated for the current type\n+     */\n+    protected int _numTypesValid = NR_UNKNOWN;\n+\n+    // First primitives\n+\n+    protected int _numberInt;\n+\n+    protected long _numberLong;\n+\n+    protected double _numberDouble;\n+\n+    // And then object types\n+\n+    protected BigInteger _numberBigInt;\n+\n+    protected BigDecimal _numberBigDecimal;\n+\n+    // And then other information about value itself\n+\n+    /**\n+     * Flag that indicates whether numeric value has a negative\n+     * value. That is, whether its textual representation starts\n+     * with minus character.\n+     */\n+    protected boolean _numberNegative;\n+\n+    /**\n+     * Length of integer part of the number, in characters\n+     */\n+    protected int _intLength;\n+\n+    /**\n+     * Length of the fractional part (not including decimal\n+     * point or exponent), in characters.\n+     * Not used for  pure integer values.\n+     */\n+    protected int _fractLength;\n+\n+    /**\n+     * Length of the exponent part of the number, if any, not\n+     * including 'e' marker or sign, just digits. \n+     * Not used for  pure integer values.\n+     */\n+    protected int _expLength;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    protected ParserBase(IOContext ctxt, int features)\n+    {\n+        super();\n+        _features = features;\n+        _ioContext = ctxt;\n+        _textBuffer = ctxt.constructTextBuffer();\n+        _parsingContext = JsonReadContext.createRootContext();\n+    }\n+    \n+    @Override\n+    public Version version() {\n+        return VersionUtil.versionFor(getClass());\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* JsonParser impl\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method that can be called to get the name associated with\n+     * the current event.\n+     */\n+    @Override\n+    public String getCurrentName()\n+        throws IOException, JsonParseException\n+    {\n+        // [JACKSON-395]: start markers require information from parent\n+        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n+            JsonReadContext parent = _parsingContext.getParent();\n+            return parent.getCurrentName();\n+        }\n+        return _parsingContext.getCurrentName();\n+    }\n+\n+    @Override\n+    public void close() throws IOException\n+    {\n+        if (!_closed) {\n+            _closed = true;\n+            try {\n+                _closeInput();\n+            } finally {\n+                // as per [JACKSON-324], do in finally block\n+                // Also, internal buffer(s) can now be released as well\n+                _releaseBuffers();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean isClosed() { return _closed; }\n+\n+    @Override\n+    public JsonReadContext getParsingContext()\n+    {\n+        return _parsingContext;\n+    }\n+\n+    /**\n+     * Method that return the <b>starting</b> location of the current\n+     * token; that is, position of the first character from input\n+     * that starts the current token.\n+     */\n+    @Override\n+    public JsonLocation getTokenLocation()\n+    {\n+        return new JsonLocation(_ioContext.getSourceReference(),\n+                                getTokenCharacterOffset(),\n+                                getTokenLineNr(),\n+                                getTokenColumnNr());\n+    }\n+\n+    /**\n+     * Method that returns location of the last processed character;\n+     * usually for error reporting purposes\n+     */\n+    @Override\n+    public JsonLocation getCurrentLocation()\n+    {\n+        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n+        return new JsonLocation(_ioContext.getSourceReference(),\n+                                _currInputProcessed + _inputPtr - 1,\n+                                _currInputRow, col);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, access to token information, text\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public boolean hasTextCharacters()\n+    {\n+        if (_currToken == JsonToken.VALUE_STRING) {\n+            return true; // usually true\n+        }        \n+        if (_currToken == JsonToken.FIELD_NAME) {\n+            return _nameCopied;\n+        }\n+        return false;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public low-level accessors\n+    /**********************************************************\n+     */\n+\n+    public final long getTokenCharacterOffset() { return _tokenInputTotal; }\n+    public final int getTokenLineNr() { return _tokenInputRow; }\n+    public final int getTokenColumnNr() {\n+        // note: value of -1 means \"not available\"; otherwise convert from 0-based to 1-based\n+        int col = _tokenInputCol;\n+        return (col < 0) ? col : (col + 1);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Low-level reading, other\n+    /**********************************************************\n+     */\n+\n+    protected final void loadMoreGuaranteed()\n+        throws IOException\n+    {\n+        if (!loadMore()) {\n+            _reportInvalidEOF();\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Abstract methods needed from sub-classes\n+    /**********************************************************\n+     */\n+\n+    protected abstract boolean loadMore() throws IOException;\n+    \n+    protected abstract void _finishString() throws IOException, JsonParseException;\n+\n+    protected abstract void _closeInput() throws IOException;\n+    \n+    /*\n+    /**********************************************************\n+    /* Low-level reading, other\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to release internal buffers owned by the base\n+     * reader. This may be called along with {@link #_closeInput} (for\n+     * example, when explicitly closing this reader instance), or\n+     * separately (if need be).\n+     */\n+    protected void _releaseBuffers() throws IOException\n+    {\n+        _textBuffer.releaseBuffers();\n+        char[] buf = _nameCopyBuffer;\n+        if (buf != null) {\n+            _nameCopyBuffer = null;\n+            _ioContext.releaseNameCopyBuffer(buf);\n+        }\n+    }\n+    \n+    /**\n+     * Method called when an EOF is encountered between tokens.\n+     * If so, it may be a legitimate EOF, but only iff there\n+     * is no open non-root context.\n+     */\n+    @Override\n+    protected void _handleEOF() throws JsonParseException\n+    {\n+        if (!_parsingContext.inRoot()) {\n+            _reportInvalidEOF(\": expected close marker for \"+_parsingContext.getTypeDesc()+\" (from \"+_parsingContext.getStartLocation(_ioContext.getSourceReference())+\")\");\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal/package methods: Error reporting\n+    /**********************************************************\n+     */\n+    \n+    protected void _reportMismatchedEndMarker(int actCh, char expCh)\n+        throws JsonParseException\n+    {\n+        String startDesc = \"\"+_parsingContext.getStartLocation(_ioContext.getSourceReference());\n+        _reportError(\"Unexpected close marker '\"+((char) actCh)+\"': expected '\"+expCh+\"' (for \"+_parsingContext.getTypeDesc()+\" starting at \"+startDesc+\")\");\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal/package methods: shared/reusable builders\n+    /**********************************************************\n+     */\n+    \n+    public ByteArrayBuilder _getByteArrayBuilder()\n+    {\n+        if (_byteArrayBuilder == null) {\n+            _byteArrayBuilder = new ByteArrayBuilder();\n+        } else {\n+            _byteArrayBuilder.reset();\n+        }\n+        return _byteArrayBuilder;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Methods from former JsonNumericParserBase\n+    /**********************************************************\n+     */\n+\n+    // // // Life-cycle of number-parsing\n+    \n+    protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen)\n+    {\n+        if (fractLen < 1 && expLen < 1) { // integer\n+            return resetInt(negative, intLen);\n+        }\n+        return resetFloat(negative, intLen, fractLen, expLen);\n+    }\n+        \n+    protected final JsonToken resetInt(boolean negative, int intLen)\n+    {\n+        _numberNegative = negative;\n+        _intLength = intLen;\n+        _fractLength = 0;\n+        _expLength = 0;\n+        _numTypesValid = NR_UNKNOWN; // to force parsing\n+        return JsonToken.VALUE_NUMBER_INT;\n+    }\n+    \n+    protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen)\n+    {\n+        _numberNegative = negative;\n+        _intLength = intLen;\n+        _fractLength = fractLen;\n+        _expLength = expLen;\n+        _numTypesValid = NR_UNKNOWN; // to force parsing\n+        return JsonToken.VALUE_NUMBER_FLOAT;\n+    }\n+    \n+    protected final JsonToken resetAsNaN(String valueStr, double value)\n+    {\n+        _textBuffer.resetWithString(valueStr);\n+        _numberDouble = value;\n+        _numTypesValid = NR_DOUBLE;\n+        return JsonToken.VALUE_NUMBER_FLOAT;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Numeric accessors of public API\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public Number getNumberValue() throws IOException, JsonParseException\n+    {\n+        if (_numTypesValid == NR_UNKNOWN) {\n+            _parseNumericValue(NR_UNKNOWN); // will also check event type\n+        }\n+        // Separate types for int types\n+        if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n+            if ((_numTypesValid & NR_INT) != 0) {\n+                return Integer.valueOf(_numberInt);\n+            }\n+            if ((_numTypesValid & NR_LONG) != 0) {\n+                return Long.valueOf(_numberLong);\n+            }\n+            if ((_numTypesValid & NR_BIGINT) != 0) {\n+                return _numberBigInt;\n+            }\n+            // Shouldn't get this far but if we do\n+            return _numberBigDecimal;\n+        }\n+    \n+        /* And then floating point types. But here optimal type\n+         * needs to be big decimal, to avoid losing any data?\n+         */\n+        if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n+            return _numberBigDecimal;\n+        }\n+        if ((_numTypesValid & NR_DOUBLE) == 0) { // sanity check\n+            _throwInternal();\n+        }\n+        return Double.valueOf(_numberDouble);\n+    }\n+    \n+    @Override\n+    public NumberType getNumberType() throws IOException, JsonParseException\n+    {\n+        if (_numTypesValid == NR_UNKNOWN) {\n+            _parseNumericValue(NR_UNKNOWN); // will also check event type\n+        }\n+        if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n+            if ((_numTypesValid & NR_INT) != 0) {\n+                return NumberType.INT;\n+            }\n+            if ((_numTypesValid & NR_LONG) != 0) {\n+                return NumberType.LONG;\n+            }\n+            return NumberType.BIG_INTEGER;\n+        }\n+    \n+        /* And then floating point types. Here optimal type\n+         * needs to be big decimal, to avoid losing any data?\n+         * However... using BD is slow, so let's allow returning\n+         * double as type if no explicit call has been made to access\n+         * data as BD?\n+         */\n+        if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n+            return NumberType.BIG_DECIMAL;\n+        }\n+        return NumberType.DOUBLE;\n+    }\n+    \n+    @Override\n+    public int getIntValue() throws IOException, JsonParseException\n+    {\n+        if ((_numTypesValid & NR_INT) == 0) {\n+            if (_numTypesValid == NR_UNKNOWN) { // not parsed at all\n+                _parseNumericValue(NR_INT); // will also check event type\n+            }\n+            if ((_numTypesValid & NR_INT) == 0) { // wasn't an int natively?\n+                convertNumberToInt(); // let's make it so, if possible\n+            }\n+        }\n+        return _numberInt;\n+    }\n+    \n+    @Override\n+    public long getLongValue() throws IOException, JsonParseException\n+    {\n+        if ((_numTypesValid & NR_LONG) == 0) {\n+            if (_numTypesValid == NR_UNKNOWN) {\n+                _parseNumericValue(NR_LONG);\n+            }\n+            if ((_numTypesValid & NR_LONG) == 0) {\n+                convertNumberToLong();\n+            }\n+        }\n+        return _numberLong;\n+    }\n+    \n+    @Override\n+    public BigInteger getBigIntegerValue() throws IOException, JsonParseException\n+    {\n+        if ((_numTypesValid & NR_BIGINT) == 0) {\n+            if (_numTypesValid == NR_UNKNOWN) {\n+                _parseNumericValue(NR_BIGINT);\n+            }\n+            if ((_numTypesValid & NR_BIGINT) == 0) {\n+                convertNumberToBigInteger();\n+            }\n+        }\n+        return _numberBigInt;\n+    }\n+    \n+    @Override\n+    public float getFloatValue() throws IOException, JsonParseException\n+    {\n+        double value = getDoubleValue();\n+        /* 22-Jan-2009, tatu: Bounds/range checks would be tricky\n+         *   here, so let's not bother even trying...\n+         */\n+        /*\n+        if (value < -Float.MAX_VALUE || value > MAX_FLOAT_D) {\n+            _reportError(\"Numeric value (\"+getText()+\") out of range of Java float\");\n+        }\n+        */\n+        return (float) value;\n+    }\n+    \n+    @Override\n+    public double getDoubleValue() throws IOException, JsonParseException\n+    {\n+        if ((_numTypesValid & NR_DOUBLE) == 0) {\n+            if (_numTypesValid == NR_UNKNOWN) {\n+                _parseNumericValue(NR_DOUBLE);\n+            }\n+            if ((_numTypesValid & NR_DOUBLE) == 0) {\n+                convertNumberToDouble();\n+            }\n+        }\n+        return _numberDouble;\n+    }\n+    \n+    @Override\n+    public BigDecimal getDecimalValue() throws IOException, JsonParseException\n+    {\n+        if ((_numTypesValid & NR_BIGDECIMAL) == 0) {\n+            if (_numTypesValid == NR_UNKNOWN) {\n+                _parseNumericValue(NR_BIGDECIMAL);\n+            }\n+            if ((_numTypesValid & NR_BIGDECIMAL) == 0) {\n+                convertNumberToBigDecimal();\n+            }\n+        }\n+        return _numberBigDecimal;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Conversion from textual to numeric representation\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method that will parse actual numeric value out of a syntactically\n+     * valid number value. Type it will parse into depends on whether\n+     * it is a floating point number, as well as its magnitude: smallest\n+     * legal type (of ones available) is used for efficiency.\n+     *\n+     * @param expType Numeric type that we will immediately need, if any;\n+     *   mostly necessary to optimize handling of floating point numbers\n+     */\n+    protected void _parseNumericValue(int expType)\n+        throws IOException, JsonParseException\n+    {\n+        // Int or float?\n+        if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n+            char[] buf = _textBuffer.getTextBuffer();\n+            int offset = _textBuffer.getTextOffset();\n+            int len = _intLength;\n+            if (_numberNegative) {\n+                ++offset;\n+            }\n+            if (len <= 9) { // definitely fits in int\n+                int i = NumberInput.parseInt(buf, offset, len);\n+                _numberInt = _numberNegative ? -i : i;\n+                _numTypesValid = NR_INT;\n+                return;\n+            }\n+            if (len <= 18) { // definitely fits AND is easy to parse using 2 int parse calls\n+                long l = NumberInput.parseLong(buf, offset, len);\n+                if (_numberNegative) {\n+                    l = -l;\n+                }\n+                // [JACKSON-230] Could still fit in int, need to check\n+                if (len == 10) {\n+                    if (_numberNegative) {\n+                        if (l >= MIN_INT_L) {\n+                            _numberInt = (int) l;\n+                            _numTypesValid = NR_INT;\n+                            return;\n+                        }\n+                    } else {\n+                        if (l <= MAX_INT_L) {\n+                            _numberInt = (int) l;\n+                            _numTypesValid = NR_INT;\n+                            return;\n+                        }\n+                    }\n+                }\n+                _numberLong = l;\n+                _numTypesValid = NR_LONG;\n+                return;\n+            }\n+            _parseSlowIntValue(expType, buf, offset, len);\n+            return;\n+        }\n+        if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n+            _parseSlowFloatValue(expType);\n+            return;\n+        }\n+        _reportError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\");\n+    }\n+    \n+    private final void _parseSlowFloatValue(int expType)\n+        throws IOException, JsonParseException\n+    {\n+        /* Nope: floating point. Here we need to be careful to get\n+         * optimal parsing strategy: choice is between accurate but\n+         * slow (BigDecimal) and lossy but fast (Double). For now\n+         * let's only use BD when explicitly requested -- it can\n+         * still be constructed correctly at any point since we do\n+         * retain textual representation\n+         */\n+        try {\n+            if (expType == NR_BIGDECIMAL) {\n+                _numberBigDecimal = _textBuffer.contentsAsDecimal();\n+                _numTypesValid = NR_BIGDECIMAL;\n+            } else {\n+                // Otherwise double has to do\n+                _numberDouble = _textBuffer.contentsAsDouble();\n+                _numTypesValid = NR_DOUBLE;\n+            }\n+        } catch (NumberFormatException nex) {\n+            // Can this ever occur? Due to overflow, maybe?\n+            _wrapError(\"Malformed numeric value '\"+_textBuffer.contentsAsString()+\"'\", nex);\n+        }\n+    }\n+    \n+    private final void _parseSlowIntValue(int expType, char[] buf, int offset, int len)\n+        throws IOException, JsonParseException\n+    {\n+        String numStr = _textBuffer.contentsAsString();\n+        try {\n+            // [JACKSON-230] Some long cases still...\n+            if (NumberInput.inLongRange(buf, offset, len, _numberNegative)) {\n+                // Probably faster to construct a String, call parse, than to use BigInteger\n+                _numberLong = Long.parseLong(numStr);\n+                _numTypesValid = NR_LONG;\n+            } else {\n+                // nope, need the heavy guns... (rare case)\n+                _numberBigInt = new BigInteger(numStr);\n+                _numTypesValid = NR_BIGINT;\n+            }\n+        } catch (NumberFormatException nex) {\n+            // Can this ever occur? Due to overflow, maybe?\n+            _wrapError(\"Malformed numeric value '\"+numStr+\"'\", nex);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Numeric conversions\n+    /**********************************************************\n+     */    \n+    \n+    protected void convertNumberToInt()\n+        throws IOException, JsonParseException\n+    {\n+        // First, converting from long ought to be easy\n+        if ((_numTypesValid & NR_LONG) != 0) {\n+            // Let's verify it's lossless conversion by simple roundtrip\n+            int result = (int) _numberLong;\n+            if (((long) result) != _numberLong) {\n+                _reportError(\"Numeric value (\"+getText()+\") out of range of int\");\n+            }\n+            _numberInt = result;\n+        } else if ((_numTypesValid & NR_BIGINT) != 0) {\n+            // !!! Should check for range...\n+            _numberInt = _numberBigInt.intValue();\n+        } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n+            // Need to check boundaries\n+            if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) {\n+                reportOverflowInt();\n+            }\n+            _numberInt = (int) _numberDouble;\n+        } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n+            if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 \n+                || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) {\n+                reportOverflowInt();\n+            }\n+            _numberInt = _numberBigDecimal.intValue();\n+        } else {\n+            _throwInternal(); // should never get here\n+        }\n+    \n+        _numTypesValid |= NR_INT;\n+    }\n+    \n+    protected void convertNumberToLong()\n+        throws IOException, JsonParseException\n+    {\n+        if ((_numTypesValid & NR_INT) != 0) {\n+            _numberLong = (long) _numberInt;\n+        } else if ((_numTypesValid & NR_BIGINT) != 0) {\n+            // !!! Should check for range...\n+            _numberLong = _numberBigInt.longValue();\n+        } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n+            // Need to check boundaries\n+            if (_numberDouble < MIN_LONG_D || _numberDouble > MAX_LONG_D) {\n+                reportOverflowLong();\n+            }\n+            _numberLong = (long) _numberDouble;\n+        } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n+            if (BD_MIN_LONG.compareTo(_numberBigDecimal) > 0 \n+                || BD_MAX_LONG.compareTo(_numberBigDecimal) < 0) {\n+                reportOverflowLong();\n+            }\n+            _numberLong = _numberBigDecimal.longValue();\n+        } else {\n+            _throwInternal(); // should never get here\n+        }\n+    \n+        _numTypesValid |= NR_LONG;\n+    }\n+    \n+    protected void convertNumberToBigInteger()\n+        throws IOException, JsonParseException\n+    {\n+        if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n+            // here it'll just get truncated, no exceptions thrown\n+            _numberBigInt = _numberBigDecimal.toBigInteger();\n+        } else if ((_numTypesValid & NR_LONG) != 0) {\n+            _numberBigInt = BigInteger.valueOf(_numberLong);\n+        } else if ((_numTypesValid & NR_INT) != 0) {\n+            _numberBigInt = BigInteger.valueOf(_numberInt);\n+        } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n+            _numberBigInt = BigDecimal.valueOf(_numberDouble).toBigInteger();\n+        } else {\n+            _throwInternal(); // should never get here\n+        }\n+        _numTypesValid |= NR_BIGINT;\n+    }\n+    \n+    protected void convertNumberToDouble()\n+        throws IOException, JsonParseException\n+    {\n+        /* 05-Aug-2008, tatus: Important note: this MUST start with\n+         *   more accurate representations, since we don't know which\n+         *   value is the original one (others get generated when\n+         *   requested)\n+         */\n+    \n+        if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n+            _numberDouble = _numberBigDecimal.doubleValue();\n+        } else if ((_numTypesValid & NR_BIGINT) != 0) {\n+            _numberDouble = _numberBigInt.doubleValue();\n+        } else if ((_numTypesValid & NR_LONG) != 0) {\n+            _numberDouble = (double) _numberLong;\n+        } else if ((_numTypesValid & NR_INT) != 0) {\n+            _numberDouble = (double) _numberInt;\n+        } else {\n+            _throwInternal(); // should never get here\n+        }\n+    \n+        _numTypesValid |= NR_DOUBLE;\n+    }\n+    \n+    protected void convertNumberToBigDecimal()\n+        throws IOException, JsonParseException\n+    {\n+        /* 05-Aug-2008, tatus: Important note: this MUST start with\n+         *   more accurate representations, since we don't know which\n+         *   value is the original one (others get generated when\n+         *   requested)\n+         */\n+    \n+        if ((_numTypesValid & NR_DOUBLE) != 0) {\n+            /* Let's actually parse from String representation,\n+             * to avoid rounding errors that non-decimal floating operations\n+             * would incur\n+             */\n+            _numberBigDecimal = new BigDecimal(getText());\n+        } else if ((_numTypesValid & NR_BIGINT) != 0) {\n+            _numberBigDecimal = new BigDecimal(_numberBigInt);\n+        } else if ((_numTypesValid & NR_LONG) != 0) {\n+            _numberBigDecimal = BigDecimal.valueOf(_numberLong);\n+        } else if ((_numTypesValid & NR_INT) != 0) {\n+            _numberBigDecimal = BigDecimal.valueOf((long) _numberInt);\n+        } else {\n+            _throwInternal(); // should never get here\n+        }\n+        _numTypesValid |= NR_BIGDECIMAL;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Number handling exceptions\n+    /**********************************************************\n+     */    \n+    \n+    protected void reportUnexpectedNumberChar(int ch, String comment)\n+        throws JsonParseException\n+    {\n+        String msg = \"Unexpected character (\"+_getCharDesc(ch)+\") in numeric value\";\n+        if (comment != null) {\n+            msg += \": \"+comment;\n+        }\n+        _reportError(msg);\n+    }\n+    \n+    protected void reportInvalidNumber(String msg)\n+        throws JsonParseException\n+    {\n+        _reportError(\"Invalid numeric value: \"+msg);\n+    }\n+    \n+    protected void reportOverflowInt()\n+        throws IOException, JsonParseException\n+    {\n+        _reportError(\"Numeric value (\"+getText()+\") out of range of int (\"+Integer.MIN_VALUE+\" - \"+Integer.MAX_VALUE+\")\");\n+    }\n+    \n+    protected void reportOverflowLong()\n+        throws IOException, JsonParseException\n+    {\n+        _reportError(\"Numeric value (\"+getText()+\") out of range of long (\"+Long.MIN_VALUE+\" - \"+Long.MAX_VALUE+\")\");\n+    }    \n+\n+    /*\n+    /**********************************************************\n+    /* Base64 handling support\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that sub-classes must implement to support escaped sequences\n+     * in base64-encoded sections.\n+     * Sub-classes that do not need base64 support can leave this as is\n+     */\n+    protected char _decodeEscaped()\n+        throws IOException, JsonParseException {\n+        throw new UnsupportedOperationException();\n+    }\n+    \n+    protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index)\n+        throws IOException, JsonParseException\n+    {\n+        // 17-May-2011, tatu: As per [JACKSON-xxx], need to handle escaped chars\n+        if (ch != '\\\\') {\n+            throw reportInvalidBase64Char(b64variant, ch, index);\n+        }\n+        int unescaped = _decodeEscaped();\n+        // if white space, skip if first triplet; otherwise errors\n+        if (unescaped <= INT_SPACE) {\n+            if (index == 0) { // whitespace only allowed to be skipped between triplets\n+                return -1;\n+            }\n+        }\n+        // otherwise try to find actual triplet value\n+        int bits = b64variant.decodeBase64Char(unescaped);\n+        if (bits < 0) {\n+            throw reportInvalidBase64Char(b64variant, unescaped, index);\n+        }\n+        return bits;\n+    }\n+    \n+    protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index)\n+        throws IOException, JsonParseException\n+    {\n+        // 17-May-2011, tatu: As per [JACKSON-xxx], need to handle escaped chars\n+        if (ch != '\\\\') {\n+            throw reportInvalidBase64Char(b64variant, ch, index);\n+        }\n+        char unescaped = _decodeEscaped();\n+        // if white space, skip if first triplet; otherwise errors\n+        if (unescaped <= INT_SPACE) {\n+            if (index == 0) { // whitespace only allowed to be skipped between triplets\n+                return -1;\n+            }\n+        }\n+        // otherwise try to find actual triplet value\n+        int bits = b64variant.decodeBase64Char(unescaped);\n+        if (bits < 0) {\n+            throw reportInvalidBase64Char(b64variant, unescaped, index);\n+        }\n+        return bits;\n+    }\n+    \n+    protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex)\n+        throws IllegalArgumentException\n+    {\n+        return reportInvalidBase64Char(b64variant, ch, bindex, null);\n+    }\n+\n+    /**\n+     * @param bindex Relative index within base64 character unit; between 0\n+     *   and 3 (as unit has exactly 4 characters)\n+     */\n+    protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg)\n+        throws IllegalArgumentException\n+    {\n+        String base;\n+        if (ch <= INT_SPACE) {\n+            base = \"Illegal white space character (code 0x\"+Integer.toHexString(ch)+\") as character #\"+(bindex+1)+\" of 4-char base64 unit: can only used between units\";\n+        } else if (b64variant.usesPaddingChar(ch)) {\n+            base = \"Unexpected padding character ('\"+b64variant.getPaddingChar()+\"') as character #\"+(bindex+1)+\" of 4-char base64 unit: padding only legal as 3rd or 4th character\";\n+        } else if (!Character.isDefined(ch) || Character.isISOControl(ch)) {\n+            // Not sure if we can really get here... ? (most illegal xml chars are caught at lower level)\n+            base = \"Illegal character (code 0x\"+Integer.toHexString(ch)+\") in base64 content\";\n+        } else {\n+            base = \"Illegal character '\"+((char)ch)+\"' (code 0x\"+Integer.toHexString(ch)+\") in base64 content\";\n+        }\n+        if (msg != null) {\n+            base = base + \": \" + msg;\n+        }\n+        return new IllegalArgumentException(base);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n+package com.fasterxml.jackson.core.base;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.JsonParser.Feature;\n+import com.fasterxml.jackson.core.io.NumberInput;\n+import com.fasterxml.jackson.core.util.ByteArrayBuilder;\n+\n+/**\n+ * Intermediate base class used by all Jackson {@link JsonParser}\n+ * implementations, but does not add any additional fields that depend\n+ * on particular method of obtaining input.\n+ *<p>\n+ * Note that 'minimal' here mostly refers to minimal number of fields\n+ * (size) and functionality that is specific to certain types\n+ * of parser implementations; but not necessarily to number of methods.\n+ * \n+ * @since 1.6\n+ *\n+ * @author Tatu Saloranta\n+ */\n+public abstract class ParserMinimalBase\n+    extends JsonParser\n+{\n+    // Control chars:\n+    protected final static int INT_TAB = '\\t';\n+    protected final static int INT_LF = '\\n';\n+    protected final static int INT_CR = '\\r';\n+    protected final static int INT_SPACE = 0x0020;\n+\n+    // Markup\n+    protected final static int INT_LBRACKET = '[';\n+    protected final static int INT_RBRACKET = ']';\n+    protected final static int INT_LCURLY = '{';\n+    protected final static int INT_RCURLY = '}';\n+    protected final static int INT_QUOTE = '\"';\n+    protected final static int INT_BACKSLASH = '\\\\';\n+    protected final static int INT_SLASH = '/';\n+    protected final static int INT_COLON = ':';\n+    protected final static int INT_COMMA = ',';\n+    protected final static int INT_ASTERISK = '*';\n+    protected final static int INT_APOSTROPHE = '\\'';\n+\n+    // Letters we need\n+    protected final static int INT_b = 'b';\n+    protected final static int INT_f = 'f';\n+    protected final static int INT_n = 'n';\n+    protected final static int INT_r = 'r';\n+    protected final static int INT_t = 't';\n+    protected final static int INT_u = 'u';\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    protected ParserMinimalBase() { }\n+    protected ParserMinimalBase(int features) {\n+        super(features);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration overrides if any\n+    /**********************************************************\n+     */\n+\n+    // from base class:\n+\n+    //public void enableFeature(Feature f)\n+    //public void disableFeature(Feature f)\n+    //public void setFeature(Feature f, boolean state)\n+    //public boolean isFeatureEnabled(Feature f)\n+\n+    /*\n+    /**********************************************************\n+    /* JsonParser impl\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public abstract JsonToken nextToken() throws IOException, JsonParseException;\n+\n+    //public final JsonToken nextValue()\n+\n+    @Override\n+    public JsonParser skipChildren() throws IOException, JsonParseException\n+    {\n+        if (_currToken != JsonToken.START_OBJECT\n+            && _currToken != JsonToken.START_ARRAY) {\n+            return this;\n+        }\n+        int open = 1;\n+\n+        /* Since proper matching of start/end markers is handled\n+         * by nextToken(), we'll just count nesting levels here\n+         */\n+        while (true) {\n+            JsonToken t = nextToken();\n+            if (t == null) {\n+                _handleEOF();\n+                /* given constraints, above should never return;\n+                 * however, FindBugs doesn't know about it and\n+                 * complains... so let's add dummy break here\n+                 */\n+                return this;\n+            }\n+            switch (t) {\n+            case START_OBJECT:\n+            case START_ARRAY:\n+                ++open;\n+                break;\n+            case END_OBJECT:\n+            case END_ARRAY:\n+                if (--open == 0) {\n+                    return this;\n+                }\n+                break;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method sub-classes need to implement\n+     */\n+    protected abstract void _handleEOF() throws JsonParseException;\n+\n+    //public JsonToken getCurrentToken()\n+\n+    //public boolean hasCurrentToken()\n+\n+    @Override\n+    public abstract String getCurrentName() throws IOException, JsonParseException;\n+    \n+    @Override\n+    public abstract void close() throws IOException;\n+\n+    @Override\n+    public abstract boolean isClosed();\n+\n+    @Override\n+    public abstract JsonStreamContext getParsingContext();\n+\n+//    public abstract JsonLocation getTokenLocation();\n+\n+//   public abstract JsonLocation getCurrentLocation();\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, access to token information, text\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public abstract String getText() throws IOException, JsonParseException;\n+\n+    @Override\n+    public abstract char[] getTextCharacters() throws IOException, JsonParseException;\n+\n+    @Override\n+    public abstract boolean hasTextCharacters();\n+\n+    @Override\n+    public abstract int getTextLength() throws IOException, JsonParseException;\n+\n+    @Override\n+    public abstract int getTextOffset() throws IOException, JsonParseException;  \n+\n+    /*\n+    /**********************************************************\n+    /* Public API, access to token information, binary\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public abstract byte[] getBinaryValue(Base64Variant b64variant)\n+        throws IOException, JsonParseException;\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, access with conversion/coercion\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException\n+    {\n+        if (_currToken != null) {\n+            switch (_currToken) {\n+            case VALUE_NUMBER_INT:\n+                return getIntValue() != 0;\n+            case VALUE_TRUE:\n+                return true;\n+            case VALUE_FALSE:\n+            case VALUE_NULL:\n+                return false;\n+            case VALUE_EMBEDDED_OBJECT:\n+                {\n+                    Object value = this.getEmbeddedObject();\n+                    if (value instanceof Boolean) {\n+                        return ((Boolean) value).booleanValue();\n+                    }\n+                }\n+            case VALUE_STRING:\n+                String str = getText().trim();\n+                if (\"true\".equals(str)) {\n+                    return true;\n+                }\n+                break;\n+            }\n+        }\n+        return defaultValue;\n+    }\n+    \n+    @Override\n+    public int getValueAsInt(int defaultValue) throws IOException, JsonParseException\n+    {\n+        if (_currToken != null) {\n+            switch (_currToken) {\n+            case VALUE_NUMBER_INT:\n+            case VALUE_NUMBER_FLOAT:\n+                return getIntValue();\n+            case VALUE_TRUE:\n+                return 1;\n+            case VALUE_FALSE:\n+            case VALUE_NULL:\n+                return 0;\n+            case VALUE_STRING:\n+                return NumberInput.parseAsInt(getText(), defaultValue);\n+            case VALUE_EMBEDDED_OBJECT:\n+                {\n+                    Object value = this.getEmbeddedObject();\n+                    if (value instanceof Number) {\n+                        return ((Number) value).intValue();\n+                    }\n+                }\n+            }\n+        }\n+        return defaultValue;\n+    }\n+    \n+    @Override\n+    public long getValueAsLong(long defaultValue) throws IOException, JsonParseException\n+    {\n+        if (_currToken != null) {\n+            switch (_currToken) {\n+            case VALUE_NUMBER_INT:\n+            case VALUE_NUMBER_FLOAT:\n+                return getLongValue();\n+            case VALUE_TRUE:\n+                return 1;\n+            case VALUE_FALSE:\n+            case VALUE_NULL:\n+                return 0;\n+            case VALUE_STRING:\n+                return NumberInput.parseAsLong(getText(), defaultValue);\n+            case VALUE_EMBEDDED_OBJECT:\n+                {\n+                    Object value = this.getEmbeddedObject();\n+                    if (value instanceof Number) {\n+                        return ((Number) value).longValue();\n+                    }\n+                }\n+            }\n+        }\n+        return defaultValue;\n+    }\n+\n+    @Override\n+    public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException\n+    {\n+        if (_currToken != null) {\n+            switch (_currToken) {\n+            case VALUE_NUMBER_INT:\n+            case VALUE_NUMBER_FLOAT:\n+                return getDoubleValue();\n+            case VALUE_TRUE:\n+                return 1;\n+            case VALUE_FALSE:\n+            case VALUE_NULL:\n+                return 0;\n+            case VALUE_STRING:\n+                return NumberInput.parseAsDouble(getText(), defaultValue);\n+            case VALUE_EMBEDDED_OBJECT:\n+                {\n+                    Object value = this.getEmbeddedObject();\n+                    if (value instanceof Number) {\n+                        return ((Number) value).doubleValue();\n+                    }\n+                }\n+            }\n+        }\n+        return defaultValue;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Base64 decoding\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Helper method that can be used for base64 decoding in cases where\n+     * encoded content has already been read as a String.\n+     * \n+     * @since 1.9.3\n+     */\n+    protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant)\n+        throws IOException, JsonParseException\n+    {\n+        int ptr = 0;\n+        int len = str.length();\n+        \n+        main_loop:\n+        while (ptr < len) {\n+            // first, we'll skip preceding white space, if any\n+            char ch;\n+            do {\n+                ch = str.charAt(ptr++);\n+                if (ptr >= len) {\n+                    break main_loop;\n+                }\n+            } while (ch <= INT_SPACE);\n+            int bits = b64variant.decodeBase64Char(ch);\n+            if (bits < 0) {\n+                _reportInvalidBase64(b64variant, ch, 0, null);\n+            }\n+            int decodedData = bits;\n+            // then second base64 char; can't get padding yet, nor ws\n+            if (ptr >= len) {\n+                _reportBase64EOF();\n+            }\n+            ch = str.charAt(ptr++);\n+            bits = b64variant.decodeBase64Char(ch);\n+            if (bits < 0) {\n+                _reportInvalidBase64(b64variant, ch, 1, null);\n+            }\n+            decodedData = (decodedData << 6) | bits;\n+            // third base64 char; can be padding, but not ws\n+            if (ptr >= len) {\n+                // but as per [JACKSON-631] can be end-of-input, iff not using padding\n+                if (!b64variant.usesPadding()) {\n+                    decodedData >>= 4;\n+                    builder.append(decodedData);\n+                    break;\n+                }\n+                _reportBase64EOF();\n+            }\n+            ch = str.charAt(ptr++);\n+            bits = b64variant.decodeBase64Char(ch);\n+            \n+            // First branch: can get padding (-> 1 byte)\n+            if (bits < 0) {\n+                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n+                    _reportInvalidBase64(b64variant, ch, 2, null);\n+                }\n+                // Ok, must get padding\n+                if (ptr >= len) {\n+                    _reportBase64EOF();\n+                }\n+                ch = str.charAt(ptr++);\n+                if (!b64variant.usesPaddingChar(ch)) {\n+                    _reportInvalidBase64(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n+                }\n+                // Got 12 bits, only need 8, need to shift\n+                decodedData >>= 4;\n+                builder.append(decodedData);\n+                continue;\n+            }\n+            // Nope, 2 or 3 bytes\n+            decodedData = (decodedData << 6) | bits;\n+            // fourth and last base64 char; can be padding, but not ws\n+            if (ptr >= len) {\n+                // but as per [JACKSON-631] can be end-of-input, iff not using padding\n+                if (!b64variant.usesPadding()) {\n+                    decodedData >>= 2;\n+                    builder.appendTwoBytes(decodedData);\n+                    break;\n+                }\n+                _reportBase64EOF();\n+            }\n+            ch = str.charAt(ptr++);\n+            bits = b64variant.decodeBase64Char(ch);\n+            if (bits < 0) {\n+                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n+                    _reportInvalidBase64(b64variant, ch, 3, null);\n+                }\n+                decodedData >>= 2;\n+                builder.appendTwoBytes(decodedData);\n+            } else {\n+                // otherwise, our triple is now complete\n+                decodedData = (decodedData << 6) | bits;\n+                builder.appendThreeBytes(decodedData);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * @param bindex Relative index within base64 character unit; between 0\n+     *   and 3 (as unit has exactly 4 characters)\n+     */\n+    protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg)\n+        throws JsonParseException\n+    {\n+        String base;\n+        if (ch <= INT_SPACE) {\n+            base = \"Illegal white space character (code 0x\"+Integer.toHexString(ch)+\") as character #\"+(bindex+1)+\" of 4-char base64 unit: can only used between units\";\n+        } else if (b64variant.usesPaddingChar(ch)) {\n+            base = \"Unexpected padding character ('\"+b64variant.getPaddingChar()+\"') as character #\"+(bindex+1)+\" of 4-char base64 unit: padding only legal as 3rd or 4th character\";\n+        } else if (!Character.isDefined(ch) || Character.isISOControl(ch)) {\n+            // Not sure if we can really get here... ? (most illegal xml chars are caught at lower level)\n+            base = \"Illegal character (code 0x\"+Integer.toHexString(ch)+\") in base64 content\";\n+        } else {\n+            base = \"Illegal character '\"+ch+\"' (code 0x\"+Integer.toHexString(ch)+\") in base64 content\";\n+        }\n+        if (msg != null) {\n+            base = base + \": \" + msg;\n+        }\n+        throw _constructError(base);\n+    }\n+\n+    protected void _reportBase64EOF() throws JsonParseException {\n+        throw _constructError(\"Unexpected end-of-String in base64 content\");\n+    }\n+    \n+    \n+    /*\n+    /**********************************************************\n+    /* Error reporting\n+    /**********************************************************\n+     */\n+    \n+    protected void _reportUnexpectedChar(int ch, String comment)\n+        throws JsonParseException\n+    {\n+        String msg = \"Unexpected character (\"+_getCharDesc(ch)+\")\";\n+        if (comment != null) {\n+            msg += \": \"+comment;\n+        }\n+        _reportError(msg);\n+    }\n+\n+    protected void _reportInvalidEOF()\n+        throws JsonParseException\n+    {\n+        _reportInvalidEOF(\" in \"+_currToken);\n+    }\n+\n+    protected void _reportInvalidEOF(String msg)\n+        throws JsonParseException\n+    {\n+        _reportError(\"Unexpected end-of-input\"+msg);\n+    }\n+\n+    protected void _reportInvalidEOFInValue() throws JsonParseException\n+    {\n+        _reportInvalidEOF(\" in a value\");\n+    }\n+    \n+    protected void _throwInvalidSpace(int i)\n+        throws JsonParseException\n+    {\n+        char c = (char) i;\n+        String msg = \"Illegal character (\"+_getCharDesc(c)+\"): only regular white space (\\\\r, \\\\n, \\\\t) is allowed between tokens\";\n+        _reportError(msg);\n+    }\n+\n+    /**\n+     * Method called to report a problem with unquoted control character.\n+     * Note: starting with version 1.4, it is possible to suppress\n+     * exception by enabling {@link Feature#ALLOW_UNQUOTED_CONTROL_CHARS}.\n+     */\n+    protected void _throwUnquotedSpace(int i, String ctxtDesc)\n+        throws JsonParseException\n+    {\n+        // JACKSON-208; possible to allow unquoted control chars:\n+        if (!isEnabled(Feature.ALLOW_UNQUOTED_CONTROL_CHARS) || i >= INT_SPACE) {\n+            char c = (char) i;\n+            String msg = \"Illegal unquoted character (\"+_getCharDesc(c)+\"): has to be escaped using backslash to be included in \"+ctxtDesc;\n+            _reportError(msg);\n+        }\n+    }\n+\n+    protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException\n+    {\n+        // as per [JACKSON-300]\n+        if (isEnabled(Feature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER)) {\n+            return ch;\n+        }\n+        // and [JACKSON-548]\n+        if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n+            return ch;\n+        }\n+        _reportError(\"Unrecognized character escape \"+_getCharDesc(ch));\n+        return ch;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Error reporting, generic\n+    /**********************************************************\n+     */\n+\n+    protected final static String _getCharDesc(int ch)\n+    {\n+        char c = (char) ch;\n+        if (Character.isISOControl(c)) {\n+            return \"(CTRL-CHAR, code \"+ch+\")\";\n+        }\n+        if (ch > 255) {\n+            return \"'\"+c+\"' (code \"+ch+\" / 0x\"+Integer.toHexString(ch)+\")\";\n+        }\n+        return \"'\"+c+\"' (code \"+ch+\")\";\n+    }\n+\n+    protected final void _reportError(String msg)\n+        throws JsonParseException\n+    {\n+        throw _constructError(msg);\n+    }\n+\n+    protected final void _wrapError(String msg, Throwable t)\n+        throws JsonParseException\n+    {\n+        throw _constructError(msg, t);\n+    }\n+\n+    protected final void _throwInternal()\n+    {\n+        throw new RuntimeException(\"Internal error: this code path should never get executed\");\n+    }\n+\n+    protected final JsonParseException _constructError(String msg, Throwable t)\n+    {\n+        return new JsonParseException(msg, getCurrentLocation(), t);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/base/package-info.java\n+/**\n+ * Base classes used by concrete Parser and Generator implementations;\n+ * contain functionality that is not specific to JSON or input\n+ * abstraction (byte vs char).\n+ * Most formats extend these types, although it is also possible to\n+ * directly extend {@link com.fasterxml.jackson.core.JsonParser} or\n+ * {@link com.fasterxml.jackson.core.JsonGenerator}.\n+ */\n+package com.fasterxml.jackson.core.base;\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/format/DataFormatDetector.java\n+package com.fasterxml.jackson.core.format;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+/**\n+ * Simple helper class that allows data format (content type) auto-detection,\n+ * given an ordered set of {@link JsonFactory} instances to use for actual low-level\n+ * detection.\n+ *\n+ * @since 1.7\n+ */\n+public class DataFormatDetector\n+{\n+    /**\n+     * By default we will look ahead at most 64 bytes; in most cases,\n+     * much less (4 bytes or so) is needed, but we will allow bit more\n+     * leniency to support data formats that need more complex heuristics.\n+     */\n+    public final static int DEFAULT_MAX_INPUT_LOOKAHEAD = 64;\n+    \n+    /**\n+     * Ordered list of factories which both represent data formats to\n+     * detect (in precedence order, starting with highest) and are used\n+     * for actual detection.\n+     */\n+    protected final JsonFactory[] _detectors;\n+\n+    /**\n+     * Strength of match we consider to be good enough to be used\n+     * without checking any other formats.\n+     * Default value is {@link MatchStrength#SOLID_MATCH}, \n+     */\n+    protected final MatchStrength _optimalMatch;\n+\n+    /**\n+     * Strength of minimal match we accept as the answer, unless\n+     * better matches are found. \n+     * Default value is {@link MatchStrength#WEAK_MATCH}, \n+     */\n+    protected final MatchStrength _minimalMatch;\n+\n+    /**\n+     * Maximum number of leading bytes of the input that we can read\n+     * to determine data format.\n+     *<p>\n+     * Default value is {@link #DEFAULT_MAX_INPUT_LOOKAHEAD}.\n+     */\n+    protected final int _maxInputLookahead;\n+    \n+    /*\n+    /**********************************************************\n+    /* Construction\n+    /**********************************************************\n+     */\n+    \n+    public DataFormatDetector(JsonFactory... detectors) {\n+        this(detectors, MatchStrength.SOLID_MATCH, MatchStrength.WEAK_MATCH,\n+            DEFAULT_MAX_INPUT_LOOKAHEAD);\n+    }\n+\n+    public DataFormatDetector(Collection<JsonFactory> detectors) {\n+        this(detectors.toArray(new JsonFactory[detectors.size()]));\n+    }\n+\n+    /**\n+     * Method that will return a detector instance that uses given\n+     * optimal match level (match that is considered sufficient to return, without\n+     * trying to find stronger matches with other formats).\n+     */\n+    public DataFormatDetector withOptimalMatch(MatchStrength optMatch) {\n+        if (optMatch == _optimalMatch) {\n+            return this;\n+        }\n+        return new DataFormatDetector(_detectors, optMatch, _minimalMatch, _maxInputLookahead);\n+    }\n+    /**\n+     * Method that will return a detector instance that uses given\n+     * minimal match level; match that may be returned unless a stronger match\n+     * is found with other format detectors.\n+     */\n+    public DataFormatDetector withMinimalMatch(MatchStrength minMatch) {\n+        if (minMatch == _minimalMatch) {\n+            return this;\n+        }\n+        return new DataFormatDetector(_detectors, _optimalMatch, minMatch, _maxInputLookahead);\n+    }\n+\n+    /**\n+     * Method that will return a detector instance that allows detectors to\n+     * read up to specified number of bytes when determining format match strength.\n+     */\n+    public DataFormatDetector withMaxInputLookahead(int lookaheadBytes)\n+    {\n+        if (lookaheadBytes == _maxInputLookahead) {\n+            return this;\n+        }\n+        return new DataFormatDetector(_detectors, _optimalMatch, _minimalMatch, lookaheadBytes);\n+    }\n+    \n+    private DataFormatDetector(JsonFactory[] detectors,\n+            MatchStrength optMatch, MatchStrength minMatch,\n+            int maxInputLookahead)\n+    {\n+        _detectors = detectors;\n+        _optimalMatch = optMatch;\n+        _minimalMatch = minMatch;\n+        _maxInputLookahead = maxInputLookahead;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method to call to find format that content (accessible via given\n+     * {@link InputStream}) given has, as per configuration of this detector\n+     * instance.\n+     * \n+     * @return Matcher object which contains result; never null, even in cases\n+     *    where no match (with specified minimal match strength) is found.\n+     */\n+    public DataFormatMatcher findFormat(InputStream in) throws IOException\n+    {\n+        return _findFormat(new InputAccessor.Std(in, new byte[_maxInputLookahead]));\n+    }\n+\n+    /**\n+     * Method to call to find format that given content (full document)\n+     * has, as per configuration of this detector instance.\n+     * \n+     * @return Matcher object which contains result; never null, even in cases\n+     *    where no match (with specified minimal match strength) is found.\n+     */\n+    public DataFormatMatcher findFormat(byte[] fullInputData) throws IOException\n+    {\n+        return _findFormat(new InputAccessor.Std(fullInputData));\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+\n+    private DataFormatMatcher _findFormat(InputAccessor.Std acc) throws IOException\n+    {\n+        JsonFactory bestMatch = null;\n+        MatchStrength bestMatchStrength = null;\n+        for (JsonFactory f : _detectors) {\n+            acc.reset();\n+            MatchStrength strength = f.hasFormat(acc);\n+            // if not better than what we have so far (including minimal level limit), skip\n+            if (strength == null || strength.ordinal() < _minimalMatch.ordinal()) {\n+                continue;\n+            }\n+            // also, needs to better match than before\n+            if (bestMatch != null) {\n+                if (bestMatchStrength.ordinal() >= strength.ordinal()) {\n+                    continue;\n+                }\n+            }\n+            // finally: if it's good enough match, we are done\n+            bestMatch = f;\n+            bestMatchStrength = strength;\n+            if (strength.ordinal() >= _optimalMatch.ordinal()) {\n+                break;\n+            }\n+        }\n+        return acc.createMatcher(bestMatch, bestMatchStrength);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/format/DataFormatMatcher.java\n+package com.fasterxml.jackson.core.format;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.JsonFactory;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.io.MergedStream;\n+\n+/**\n+ * Result object constructed by {@link DataFormatDetector} when requested\n+ * to detect format of given input data.\n+ */\n+public class DataFormatMatcher\n+{\n+    protected final InputStream _originalStream;\n+\n+    /**\n+     * Content read during format matching process\n+     */\n+    protected final byte[] _bufferedData;\n+\n+    /**\n+     * Number of bytes in {@link #_bufferedData} that were read.\n+     */\n+    protected final int _bufferedLength;\n+\n+    /**\n+     * Factory that produced sufficient match (if any)\n+     */\n+    protected final JsonFactory _match;\n+\n+    /**\n+     * Strength of match with {@link #_match}\n+     */\n+    protected final MatchStrength _matchStrength;\n+    \n+    protected DataFormatMatcher(InputStream in, byte[] buffered, int bufferedLength,\n+            JsonFactory match, MatchStrength strength)\n+    {\n+        _originalStream = in;\n+        _bufferedData = buffered;\n+        _bufferedLength = bufferedLength;\n+        _match = match;\n+        _matchStrength = strength;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, simple accessors\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Accessor to use to see if any formats matched well enough with\n+     * the input data.\n+     */\n+    public boolean hasMatch() { return _match != null; }\n+\n+    /**\n+     * Method for accessing strength of the match, if any; if no match,\n+     * will return {@link MatchStrength#INCONCLUSIVE}.\n+     */\n+    public MatchStrength getMatchStrength() {\n+        return (_matchStrength == null) ? MatchStrength.INCONCLUSIVE : _matchStrength;\n+    }\n+\n+    /**\n+     * Accessor for {@link JsonFactory} that represents format that data matched.\n+     */\n+    public JsonFactory getMatch() { return _match; }\n+\n+    /**\n+     * Accessor for getting brief textual name of matched format if any (null\n+     * if none). Equivalent to:\n+     *<pre>\n+     *   return hasMatch() ? getMatch().getFormatName() : null;\n+     *</pre>\n+     */\n+    public String getMatchedFormatName() {\n+        return _match.getFormatName();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, factory methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Convenience method for trying to construct a {@link JsonParser} for\n+     * parsing content which is assumed to be in detected data format.\n+     * If no match was found, returns null.\n+     */\n+    public JsonParser createParserWithMatch() throws IOException {\n+        if (_match == null) {\n+            return null;\n+        }\n+        if (_originalStream == null) {\n+            return _match.createJsonParser(_bufferedData, 0, _bufferedLength);\n+        }\n+        return _match.createJsonParser(getDataStream());\n+    }\n+    \n+    /**\n+     * Method to use for accessing input for which format detection has been done.\n+     * This <b>must</b> be used instead of using stream passed to detector\n+     * unless given stream itself can do buffering.\n+     * Stream will return all content that was read during matching process, as well\n+     * as remaining contents of the underlying stream.\n+     */\n+    public InputStream getDataStream() {\n+        if (_originalStream == null) {\n+            return new ByteArrayInputStream(_bufferedData, 0, _bufferedLength);\n+        }\n+        return new MergedStream(null, _originalStream, _bufferedData, 0, _bufferedLength);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/format/InputAccessor.java\n+package com.fasterxml.jackson.core.format;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.JsonFactory;\n+\n+/**\n+ * Interface used to expose beginning of a data file to data format\n+ * detection code.\n+ * \n+ * @since 1.8\n+ */\n+public interface InputAccessor\n+{\n+    /**\n+     * Method to call to check if more input is available.\n+     * Since this may result in more content to be read (at least\n+     * one more byte), a {@link IOException} may get thrown.\n+     */\n+    public boolean hasMoreBytes() throws IOException;\n+\n+    /**\n+     * Returns next byte available, if any; if no more bytes are\n+     * available, will throw {@link java.io.EOFException}.\n+     */\n+    public byte nextByte() throws IOException;\n+\n+    /**\n+     * Method that can be called to reset accessor to read from beginning\n+     * of input.\n+     */\n+    public void reset();\n+\n+    /*\n+    /**********************************************************\n+    /* Standard implementation\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Basic implementation that reads data from given\n+     * {@link InputStream} and buffers it as necessary.\n+     */\n+    public class Std implements InputAccessor\n+    {\n+        protected final InputStream _in;\n+\n+        protected final byte[] _buffer;\n+\n+        /**\n+         * Number of bytes in {@link #_buffer} that are valid\n+         * buffered content.\n+         */\n+        protected int _bufferedAmount;\n+        \n+        /**\n+         * Pointer to next available buffered byte in {@link #_buffer}.\n+         */\n+        protected int _ptr;\n+        \n+        /**\n+         * Constructor used when content to check is available via\n+         * input stream and must be read.\n+         */\n+        public Std(InputStream in, byte[] buffer)\n+        {\n+            _in = in;\n+            _buffer = buffer;\n+            _bufferedAmount = 0;\n+        }\n+\n+        /**\n+         * Constructor used when the full input (or at least enough leading bytes\n+         * of full input) is available.\n+         */\n+        public Std(byte[] inputDocument)\n+        {\n+            _in = null;\n+            _buffer = inputDocument;\n+            // we have it all:\n+            _bufferedAmount = inputDocument.length;\n+        }\n+        \n+        @Override\n+        public boolean hasMoreBytes() throws IOException\n+        {\n+            if (_ptr < _bufferedAmount) { // already got more\n+                return true;\n+            }\n+            int amount = _buffer.length - _ptr;\n+            if (amount < 1) { // can not load any more\n+                return false;\n+            }\n+            int count = _in.read(_buffer, _ptr, amount);\n+            if (count <= 0) { // EOF\n+                return false;\n+            }\n+            _bufferedAmount += count;\n+            return true;\n+        }\n+\n+        @Override\n+        public byte nextByte() throws IOException\n+        {\n+            // should we just try loading more automatically?\n+            if (_ptr >- _bufferedAmount) {\n+                if (!hasMoreBytes()) {\n+                    throw new EOFException(\"Could not read more than \"+_ptr+\" bytes (max buffer size: \"+_buffer.length+\")\");\n+                }\n+            }\n+            return _buffer[_ptr++];\n+        }\n+\n+        @Override\n+        public void reset() {\n+            _ptr = 0;\n+        }\n+\n+        /*\n+        /**********************************************************\n+        /* Extended API for DataFormatDetector/Matcher\n+        /**********************************************************\n+         */\n+\n+        public DataFormatMatcher createMatcher(JsonFactory match, MatchStrength matchStrength)\n+        {\n+            return new DataFormatMatcher(_in, _buffer, _bufferedAmount, match, matchStrength);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/format/MatchStrength.java\n+package com.fasterxml.jackson.core.format;\n+\n+/**\n+ * Enumeration used to indicate strength of match between data format\n+ * and piece of data (typically beginning of a data file).\n+ * Values are in increasing match strength; and detectors should return\n+ * \"strongest\" value: that is, it should start with strongest match\n+ * criteria, and downgrading if criteria is not fulfilled.\n+ * \n+ * @since 1.8\n+ */\n+public enum MatchStrength\n+{\n+    /**\n+     * Value that indicates that given data can not be in given format.\n+     */\n+    NO_MATCH,\n+    \n+    /**\n+     * Value that indicates that detector can not find out whether could\n+     * be a match or not.\n+     * This can occur for example for textual data formats t\n+     * when there are so many leading spaces that detector can not\n+     * find the first data byte (because detectors typically limit lookahead\n+     * to some smallish value).\n+     */\n+    INCONCLUSIVE,\n+\n+    /**\n+     * Value that indicates that given data could be of specified format (i.e.\n+     * it can not be ruled out). This can occur for example when seen data\n+     * is both not in canonical formats (for example: JSON data should be a JSON Array or Object\n+     * not a scalar value, as per JSON specification) and there are known use case\n+     * where a format detected is actually used (plain JSON Strings are actually used, even\n+     * though specification does not indicate that as valid usage: as such, seeing a leading\n+     * double-quote could indicate a JSON String, which plausibly <b>could</b> indicate\n+     * non-standard JSON usage).\n+     */\n+    WEAK_MATCH,\n+    \n+    /**\n+     * Value that indicates that given data conforms to (one of) canonical form(s) of\n+     * the data format.\n+     *<p>\n+     * For example, when testing for XML data format,\n+     * seeing a less-than character (\"&lt;\") alone (with possible leading spaces)\n+     * would be a strong indication that data could\n+     * be in xml format (but see below for {@link #FULL_MATCH} description for more)\n+     */\n+    SOLID_MATCH,\n+\n+    /**\n+     * Value that indicates that given data contains a signature that is deemed\n+     * specific enough to uniquely indicate data format used.\n+     *<p>\n+     * For example, when testing for XML data format,\n+     * seing \"&lt;xml\" as the first data bytes (\"XML declaration\", as per XML specification)\n+     * could give full confidence that data is indeed in XML format.\n+     * Not all data formats have unique leading identifiers to allow full matches; for example,\n+     * JSON only has heuristic matches and can have at most {@link #SOLID_MATCH}) match.\n+     */\n+    FULL_MATCH\n+    ;\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/format/package-info.java\n+/**\n+ * Package that contains interfaces needed for dynamic, pluggable\n+ * format (auto)detection; as well as basic utility classes for\n+ * simple format detection functionality.\n+ * \n+ * @since 1.8\n+ */\n+package com.fasterxml.jackson.core.format;\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/io/BaseReader.java\n+\n+package com.fasterxml.jackson.core.io;\n+\n+import java.io.*;\n+\n+/**\n+ * Simple basic class for optimized readers in this package; implements\n+ * \"cookie-cutter\" methods that are used by all actual implementations.\n+ */\n+abstract class BaseReader\n+    extends Reader\n+{\n+    /**\n+     * JSON actually limits available Unicode range in the high end\n+     * to the same as xml (to basically limit UTF-8 max byte sequence\n+     * length to 4)\n+     */\n+    final protected static int LAST_VALID_UNICODE_CHAR = 0x10FFFF;\n+\n+    final protected static char NULL_CHAR = (char) 0;\n+    final protected static char NULL_BYTE = (byte) 0;\n+\n+    final protected IOContext _context;\n+\n+    protected InputStream _in;\n+\n+    protected byte[] _buffer;\n+\n+    protected int _ptr;\n+    protected int _length;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    protected BaseReader(IOContext context,\n+                         InputStream in, byte[] buf, int ptr, int len)\n+    {\n+        _context = context;\n+        _in = in;\n+        _buffer = buf;\n+        _ptr = ptr;\n+        _length = len;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Reader API\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void close() throws IOException\n+    {\n+        InputStream in = _in;\n+\n+        if (in != null) {\n+            _in = null;\n+            freeBuffers();\n+            in.close();\n+        }\n+    }\n+\n+    protected char[] _tmpBuf = null;\n+\n+    /**\n+     * Although this method is implemented by the base class, AND it should\n+     * never be called by main code, let's still implement it bit more\n+     * efficiently just in case\n+     */\n+    @Override\n+    public int read() throws IOException\n+    {\n+        if (_tmpBuf == null) {\n+            _tmpBuf = new char[1];\n+        }\n+        if (read(_tmpBuf, 0, 1) < 1) {\n+            return -1;\n+        }\n+        return _tmpBuf[0];\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal/package methods:\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * This method should be called along with (or instead of) normal\n+     * close. After calling this method, no further reads should be tried.\n+     * Method will try to recycle read buffers (if any).\n+     */\n+    public final void freeBuffers()\n+    {\n+        byte[] buf = _buffer;\n+        if (buf != null) {\n+            _buffer = null;\n+            _context.releaseReadIOBuffer(buf);\n+        }\n+    }\n+\n+    protected void reportBounds(char[] cbuf, int start, int len)\n+        throws IOException\n+    {\n+        throw new ArrayIndexOutOfBoundsException(\"read(buf,\"+start+\",\"+len+\"), cbuf[\"+cbuf.length+\"]\");\n+    }\n+\n+    protected void reportStrangeStream()\n+        throws IOException\n+    {\n+        throw new IOException(\"Strange I/O stream, returned 0 bytes on read\");\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/io/CharTypes.java\n+package com.fasterxml.jackson.core.io;\n+\n+import java.util.Arrays;\n+\n+\n+public final class CharTypes\n+{\n+    private final static char[] HEX_CHARS = \"0123456789ABCDEF\".toCharArray();\n+    private final static byte[] HEX_BYTES;\n+    static {\n+        int len = HEX_CHARS.length;\n+        HEX_BYTES = new byte[len];\n+        for (int i = 0; i < len; ++i) {\n+            HEX_BYTES[i] = (byte) HEX_CHARS[i];\n+        }\n+    }\n+\n+\n+    /**\n+     * Lookup table used for determining which input characters\n+     * need special handling when contained in text segment.\n+     */\n+    final static int[] sInputCodes;\n+    static {\n+        /* 96 would do for most cases (backslash is ascii 94)\n+         * but if we want to do lookups by raw bytes it's better\n+         * to have full table\n+         */\n+        int[] table = new int[256];\n+        // Control chars and non-space white space are not allowed unquoted\n+        for (int i = 0; i < 32; ++i) {\n+            table[i] = -1;\n+        }\n+        // And then string end and quote markers are special too\n+        table['\"'] = 1;\n+        table['\\\\'] = 1;\n+        sInputCodes = table;\n+    }\n+\n+    /**\n+     * Additionally we can combine UTF-8 decoding info into similar\n+     * data table.\n+     */\n+    final static int[] sInputCodesUtf8;\n+    static {\n+        int[] table = new int[sInputCodes.length];\n+        System.arraycopy(sInputCodes, 0, table, 0, sInputCodes.length);\n+        for (int c = 128; c < 256; ++c) {\n+            int code;\n+\n+            // We'll add number of bytes needed for decoding\n+            if ((c & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)\n+                code = 2;\n+            } else if ((c & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF)\n+                code = 3;\n+            } else if ((c & 0xF8) == 0xF0) {\n+                // 4 bytes; double-char with surrogates and all...\n+                code = 4;\n+            } else {\n+                // And -1 seems like a good \"universal\" error marker...\n+                code = -1;\n+            }\n+            table[c] = code;\n+        }\n+        sInputCodesUtf8 = table;\n+    }\n+\n+    /**\n+     * To support non-default (and -standard) unquoted field names mode,\n+     * need to have alternate checking.\n+     * Basically this is list of 8-bit ASCII characters that are legal\n+     * as part of Javascript identifier\n+     *\n+     * @since 1.2\n+     */\n+    final static int[] sInputCodesJsNames;\n+    static {\n+        int[] table = new int[256];\n+        // Default is \"not a name char\", mark ones that are\n+        Arrays.fill(table, -1);\n+        // Assume rules with JS same as Java (change if/as needed)\n+        for (int i = 33; i < 256; ++i) {\n+            if (Character.isJavaIdentifierPart((char) i)) {\n+                table[i] = 0;\n+            }\n+        }\n+        /* As per [JACKSON-267], '@', '#' and '*' are also to be accepted as well.\n+         * And '-' (for hyphenated names); and '+' for sake of symmetricity...\n+         */\n+        table['@'] = 0;\n+        table['#'] = 0;\n+        table['*'] = 0;\n+        table['-'] = 0;\n+        table['+'] = 0;\n+        sInputCodesJsNames = table;\n+    }\n+\n+    /**\n+     * This table is similar to Latin-1, except that it marks all \"high-bit\"\n+     * code as ok. They will be validated at a later point, when decoding\n+     * name\n+     */\n+    final static int[] sInputCodesUtf8JsNames;\n+    static {\n+        int[] table = new int[256];\n+        // start with 8-bit JS names \n+        System.arraycopy(sInputCodesJsNames, 0, table, 0, sInputCodesJsNames.length);\n+        Arrays.fill(table, 128, 128, 0);\n+        sInputCodesUtf8JsNames = table;\n+    }\n+\n+    /**\n+     * Decoding table used to quickly determine characters that are\n+     * relevant within comment content\n+     */\n+    final static int[] sInputCodesComment = new int[256];\n+    static {\n+        // but first: let's start with UTF-8 multi-byte markers:\n+        System.arraycopy(sInputCodesUtf8, 128, sInputCodesComment, 128, 128);\n+    \n+        // default (0) means \"ok\" (skip); -1 invalid, others marked by char itself\n+        Arrays.fill(sInputCodesComment, 0, 32, -1); // invalid white space\n+        sInputCodesComment['\\t'] = 0; // tab is still fine\n+        sInputCodesComment['\\n'] = '\\n'; // lf/cr need to be observed, ends cpp comment\n+        sInputCodesComment['\\r'] = '\\r';\n+        sInputCodesComment['*'] = '*'; // end marker for c-style comments\n+    }\n+\n+    /**\n+     * Lookup table used for determining which output characters in \n+     * 7-bit ASCII range need to be quoted.\n+     */\n+    final static int[] sOutputEscapes128;\n+    static {\n+        int[] table = new int[128];\n+        // Control chars need generic escape sequence\n+        for (int i = 0; i < 32; ++i) {\n+            // 04-Mar-2011, tatu: Used to use \"-(i + 1)\", replaced with constants\n+            table[i] = CharacterEscapes.ESCAPE_STANDARD;\n+        }\n+        /* Others (and some within that range too) have explicit shorter\n+         * sequences\n+         */\n+        table['\"'] = '\"';\n+        table['\\\\'] = '\\\\';\n+        // Escaping of slash is optional, so let's not add it\n+        table[0x08] = 'b';\n+        table[0x09] = 't';\n+        table[0x0C] = 'f';\n+        table[0x0A] = 'n';\n+        table[0x0D] = 'r';\n+        sOutputEscapes128 = table;\n+    }\n+\n+    /**\n+     * Lookup table for the first 128 Unicode characters (7-bit ASCII)\n+     * range. For actual hex digits, contains corresponding value;\n+     * for others -1.\n+     */\n+    final static int[] sHexValues = new int[128];\n+    static {\n+        Arrays.fill(sHexValues, -1);\n+        for (int i = 0; i < 10; ++i) {\n+            sHexValues['0' + i] = i;\n+        }\n+        for (int i = 0; i < 6; ++i) {\n+            sHexValues['a' + i] = 10 + i;\n+            sHexValues['A' + i] = 10 + i;\n+        }\n+    }\n+\n+    public final static int[] getInputCodeLatin1() { return sInputCodes; }\n+    public final static int[] getInputCodeUtf8() { return sInputCodesUtf8; }\n+\n+    public final static int[] getInputCodeLatin1JsNames() { return sInputCodesJsNames; }\n+    public final static int[] getInputCodeUtf8JsNames() { return sInputCodesUtf8JsNames; }\n+\n+    public final static int[] getInputCodeComment() { return sInputCodesComment; }\n+    \n+    /**\n+     * Accessor for getting a read-only encoding table for first 128 Unicode\n+     * code points (single-byte UTF-8 characters).\n+     * Value of 0 means \"no escaping\"; other positive values that value is character\n+     * to use after backslash; and negative values that generic (backslash - u)\n+     * escaping is to be used.\n+     */\n+    public final static int[] get7BitOutputEscapes() { return sOutputEscapes128; }\n+\n+    public static int charToHex(int ch)\n+    {\n+        return (ch > 127) ? -1 : sHexValues[ch];\n+    }\n+\n+    public static void appendQuoted(StringBuilder sb, String content)\n+    {\n+        final int[] escCodes = sOutputEscapes128;\n+        int escLen = escCodes.length;\n+        for (int i = 0, len = content.length(); i < len; ++i) {\n+            char c = content.charAt(i);\n+            if (c >= escLen || escCodes[c] == 0) {\n+                sb.append(c);\n+                continue;\n+            }\n+            sb.append('\\\\');\n+            int escCode = escCodes[c];\n+            if (escCode < 0) { // generic quoting (hex value)\n+                // We know that it has to fit in just 2 hex chars\n+                sb.append('u');\n+                sb.append('0');\n+                sb.append('0');\n+                int value = -(escCode + 1);\n+                sb.append(HEX_CHARS[value >> 4]);\n+                sb.append(HEX_CHARS[value & 0xF]);\n+            } else { // \"named\", i.e. prepend with slash\n+                sb.append((char) escCode);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * @since 1.6\n+     */\n+    public static char[] copyHexChars()\n+    {\n+        return (char[]) HEX_CHARS.clone();\n+    }\n+\n+    /**\n+     * @since 1.6\n+     */\n+    public static byte[] copyHexBytes()\n+    {\n+        return (byte[]) HEX_BYTES.clone();\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/io/CharacterEscapes.java\n+package com.fasterxml.jackson.core.io;\n+\n+import com.fasterxml.jackson.core.SerializableString;\n+\n+/**\n+ * Abstract base class that defines interface for customizing character\n+ * escaping aspects for String values, for formats that use escaping.\n+ * For JSON this applies to both property names and String values.\n+ *\n+ * @since 1.8\n+ */\n+public abstract class CharacterEscapes\n+{\n+    /**\n+     * Value used for lookup tables to indicate that matching characters\n+     * do not need to be escaped.\n+     */\n+    public final static int ESCAPE_NONE = 0;\n+\n+    /**\n+     * Value used for lookup tables to indicate that matching characters\n+     * are to be escaped using standard escaping; for JSON this means\n+     * (for example) using \"backslash - u\" escape method.\n+     */\n+    public final static int ESCAPE_STANDARD = -1;\n+\n+    /**\n+     * Value used for lookup tables to indicate that matching characters\n+     * will need custom escapes; and that another call\n+     * to {@link #getEscapeSequence} is needed to figure out exact escape\n+     * sequence to output.\n+     */\n+    public final static int ESCAPE_CUSTOM = -2;\n+    \n+    /**\n+     * Method generators can call to get lookup table for determining\n+     * escape handling for first 128 characters of Unicode (ASCII\n+     * characters. Caller is not to modify contents of this array, since\n+     * this is expected to be a shared copy.\n+     * \n+     * @return Array with size of at least 128, where first 128 entries\n+     *    have either one of <code>ESCAPE_xxx</code> constants, or non-zero positive\n+     *    integer (meaning of which is data format specific; for JSON it means\n+     *    that combination of backslash and character with that value is to be used)\n+     *    to indicate that specific escape sequence is to be used.\n+     */\n+    public abstract int[] getEscapeCodesForAscii();\n+\n+    /**\n+     * Method generators can call to get lookup table for determining\n+     * exact escape sequence to use for given character.\n+     * It can be called for any character, but typically is called for\n+     * either for ASCII characters for which custom escape\n+     * sequence is needed; or for any non-ASCII character.\n+     */\n+    public abstract SerializableString getEscapeSequence(int ch);\n+\n+    /**\n+     * Helper method that can be used to get a copy of standard JSON\n+     * escape definitions; this is useful when just wanting to slightly\n+     * customize definitions. Caller can modify this array as it sees\n+     * fit and usually returns modified instance via {@link #getEscapeCodesForAscii}\n+     */\n+    public static int[] standardAsciiEscapesForJSON()\n+    {\n+        int[] esc = CharTypes.get7BitOutputEscapes();\n+        int len = esc.length;\n+        int[] result = new int[len];\n+        System.arraycopy(esc, 0, result, 0, esc.length);\n+        return result;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\n+package com.fasterxml.jackson.core.io;\n+\n+import com.fasterxml.jackson.core.JsonEncoding;\n+import com.fasterxml.jackson.core.util.BufferRecycler;\n+import com.fasterxml.jackson.core.util.TextBuffer;\n+\n+/**\n+ * To limit number of configuration and state objects to pass, all\n+ * contextual objects that need to be passed by the factory to\n+ * readers and writers are combined under this object. One instance\n+ * is created for each reader and writer.\n+ */\n+public final class IOContext\n+{\n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Reference to the source object, which can be used for displaying\n+     * location information\n+     */\n+    protected final Object _sourceRef;\n+\n+    /**\n+     * Encoding used by the underlying stream, if known.\n+     */\n+    protected JsonEncoding _encoding;\n+\n+    /**\n+     * Flag that indicates whether underlying input/output source/target\n+     * object is fully managed by the owner of this context (parser or\n+     * generator). If true, it is, and is to be closed by parser/generator;\n+     * if false, calling application has to do closing (unless auto-closing\n+     * feature is enabled for the parser/generator in question; in which\n+     * case it acts like the owner).\n+     */\n+    protected final boolean _managedResource;\n+\n+    /*\n+    /**********************************************************\n+    /* Buffer handling, recycling\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Recycler used for actual allocation/deallocation/reuse\n+     */\n+    protected final BufferRecycler _bufferRecycler;\n+\n+    /**\n+     * Reference to the allocated I/O buffer for low-level input reading,\n+     * if any allocated.\n+     */\n+    protected byte[] _readIOBuffer = null;\n+\n+    /**\n+     * Reference to the allocated I/O buffer used for low-level\n+     * encoding-related buffering.\n+     */\n+    protected byte[] _writeEncodingBuffer = null;\n+    \n+    /**\n+     * Reference to the buffer allocated for tokenization purposes,\n+     * in which character input is read, and from which it can be\n+     * further returned.\n+     */\n+    protected char[] _tokenCBuffer = null;\n+\n+    /**\n+     * Reference to the buffer allocated for buffering it for\n+     * output, before being encoded: generally this means concatenating\n+     * output, then encoding when buffer fills up.\n+     */\n+    protected char[] _concatCBuffer = null;\n+\n+    /**\n+     * Reference temporary buffer Parser instances need if calling\n+     * app decides it wants to access name via 'getTextCharacters' method.\n+     * Regular text buffer can not be used as it may contain textual\n+     * representation of the value token.\n+     */\n+    protected char[] _nameCopyBuffer = null;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource)\n+    {\n+        _bufferRecycler = br;\n+        _sourceRef = sourceRef;\n+        _managedResource = managedResource;\n+    }\n+\n+    public void setEncoding(JsonEncoding enc)\n+    {\n+        _encoding = enc;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, accessors\n+    /**********************************************************\n+     */\n+\n+    public final Object getSourceReference() { return _sourceRef; }\n+    public final JsonEncoding getEncoding() { return _encoding; }\n+    public final boolean isResourceManaged() { return _managedResource; }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, buffer management\n+    /**********************************************************\n+     */\n+\n+    public final TextBuffer constructTextBuffer() {\n+        return new TextBuffer(_bufferRecycler);\n+    }\n+\n+    /**\n+     *<p>\n+     * Note: the method can only be called once during its life cycle.\n+     * This is to protect against accidental sharing.\n+     */\n+    public final byte[] allocReadIOBuffer()\n+    {\n+        if (_readIOBuffer != null) {\n+            throw new IllegalStateException(\"Trying to call allocReadIOBuffer() second time\");\n+        }\n+        _readIOBuffer = _bufferRecycler.allocByteBuffer(BufferRecycler.ByteBufferType.READ_IO_BUFFER);\n+        return _readIOBuffer;\n+    }\n+\n+    public final byte[] allocWriteEncodingBuffer()\n+    {\n+        if (_writeEncodingBuffer != null) {\n+            throw new IllegalStateException(\"Trying to call allocWriteEncodingBuffer() second time\");\n+        }\n+        _writeEncodingBuffer = _bufferRecycler.allocByteBuffer(BufferRecycler.ByteBufferType.WRITE_ENCODING_BUFFER);\n+        return _writeEncodingBuffer;\n+    }\n+    \n+    public final char[] allocTokenBuffer()\n+    {\n+        if (_tokenCBuffer != null) {\n+            throw new IllegalStateException(\"Trying to call allocTokenBuffer() second time\");\n+        }\n+        _tokenCBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CharBufferType.TOKEN_BUFFER);\n+        return _tokenCBuffer;\n+    }\n+\n+    public final char[] allocConcatBuffer()\n+    {\n+        if (_concatCBuffer != null) {\n+            throw new IllegalStateException(\"Trying to call allocConcatBuffer() second time\");\n+        }\n+        _concatCBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CharBufferType.CONCAT_BUFFER);\n+        return _concatCBuffer;\n+    }\n+\n+    public final char[] allocNameCopyBuffer(int minSize)\n+    {\n+        if (_nameCopyBuffer != null) {\n+            throw new IllegalStateException(\"Trying to call allocNameCopyBuffer() second time\");\n+        }\n+        _nameCopyBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CharBufferType.NAME_COPY_BUFFER, minSize);\n+        return _nameCopyBuffer;\n+    }\n+\n+    /**\n+     * Method to call when all the processing buffers can be safely\n+     * recycled.\n+     */\n+    public final void releaseReadIOBuffer(byte[] buf)\n+    {\n+        if (buf != null) {\n+            /* Let's do sanity checks to ensure once-and-only-once release,\n+             * as well as avoiding trying to release buffers not owned\n+             */\n+            if (buf != _readIOBuffer) {\n+                throw new IllegalArgumentException(\"Trying to release buffer not owned by the context\");\n+            }\n+            _readIOBuffer = null;\n+            _bufferRecycler.releaseByteBuffer(BufferRecycler.ByteBufferType.READ_IO_BUFFER, buf);\n+        }\n+    }\n+\n+    public final void releaseWriteEncodingBuffer(byte[] buf)\n+    {\n+        if (buf != null) {\n+            /* Let's do sanity checks to ensure once-and-only-once release,\n+             * as well as avoiding trying to release buffers not owned\n+             */\n+            if (buf != _writeEncodingBuffer) {\n+                throw new IllegalArgumentException(\"Trying to release buffer not owned by the context\");\n+            }\n+            _writeEncodingBuffer = null;\n+            _bufferRecycler.releaseByteBuffer(BufferRecycler.ByteBufferType.WRITE_ENCODING_BUFFER, buf);\n+        }\n+    }\n+    \n+    public final void releaseTokenBuffer(char[] buf)\n+    {\n+        if (buf != null) {\n+            if (buf != _tokenCBuffer) {\n+                throw new IllegalArgumentException(\"Trying to release buffer not owned by the context\");\n+            }\n+            _tokenCBuffer = null;\n+            _bufferRecycler.releaseCharBuffer(BufferRecycler.CharBufferType.TOKEN_BUFFER, buf);\n+        }\n+    }\n+\n+    public final void releaseConcatBuffer(char[] buf)\n+    {\n+        if (buf != null) {\n+            if (buf != _concatCBuffer) {\n+                throw new IllegalArgumentException(\"Trying to release buffer not owned by the context\");\n+            }\n+            _concatCBuffer = null;\n+            _bufferRecycler.releaseCharBuffer(BufferRecycler.CharBufferType.CONCAT_BUFFER, buf);\n+        }\n+    }\n+\n+    public final void releaseNameCopyBuffer(char[] buf)\n+    {\n+        if (buf != null) {\n+            if (buf != _nameCopyBuffer) {\n+                throw new IllegalArgumentException(\"Trying to release buffer not owned by the context\");\n+            }\n+            _nameCopyBuffer = null;\n+            _bufferRecycler.releaseCharBuffer(BufferRecycler.CharBufferType.NAME_COPY_BUFFER, buf);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/io/InputDecorator.java\n+package com.fasterxml.jackson.core.io;\n+\n+import java.io.*;\n+\n+/**\n+ * Handler class that can be used to decorate input sources.\n+ * Typical use is to use a filter abstraction (filtered stream,\n+ * reader) around original input source, and apply additional\n+ * processing during read operations.\n+ * \n+ * @since 1.8\n+ */\n+public abstract class InputDecorator\n+{\n+    /**\n+     * Method called by {@link com.fasterxml.jackson.core.JsonFactory} instance when\n+     * creating parser given an {@link InputStream}, when this decorator\n+     * has been registered.\n+     * \n+     * @param ctxt IO context in use (provides access to declared encoding).\n+     *   NOTE: at this point context may not have all information initialized;\n+     *   specifically auto-detected encoding is only available once parsing starts,\n+     *   which may occur only after this method is called.\n+     * @param in Original input source\n+     * \n+     * @return InputStream to use; either passed in argument, or something that\n+     *   calls it\n+     */\n+    public abstract InputStream decorate(IOContext ctxt, InputStream in)\n+        throws IOException;\n+\n+    /**\n+     * Method called by {@link com.fasterxml.jackson.core.JsonFactory} instance when\n+     * creating parser on given \"raw\" byte source.\n+     * Method can either construct a {@link InputStream} for reading; or return\n+     * null to indicate that no wrapping should occur.\n+     * \n+     * @param ctxt IO context in use (provides access to declared encoding)\n+     *   NOTE: at this point context may not have all information initialized;\n+     *   specifically auto-detected encoding is only available once parsing starts,\n+     *   which may occur only after this method is called.\n+     * @param src Input buffer that contains contents to parse\n+     * @param offset Offset of the first available byte in the input buffer\n+     * @param length Number of bytes available in the input buffer\n+     * \n+     * @return Either {@link InputStream} to use as input source; or null to indicate\n+     *   that contents are to be processed as-is by caller\n+     */\n+    public abstract InputStream decorate(IOContext ctxt, byte[] src, int offset, int length)\n+        throws IOException;\n+    \n+    /**\n+     * Method called by {@link com.fasterxml.jackson.core.JsonFactory} instance when\n+     * creating parser given an {@link Reader}, when this decorator\n+     * has been registered.\n+     * \n+     * @param ctxt IO context in use (provides access to declared encoding)\n+     *   NOTE: at this point context may not have all information initialized;\n+     *   specifically auto-detected encoding is only available once parsing starts,\n+     *   which may occur only after this method is called.\n+     * @param src Original input source\n+     * \n+     * @return Reader to use; either passed in argument, or something that\n+     *   calls it (for example, a {@link FilterReader})\n+     */\n+    public abstract Reader decorate(IOContext ctxt, Reader src) throws IOException;\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/io/JsonStringEncoder.java\n+package com.fasterxml.jackson.core.io;\n+\n+import java.lang.ref.SoftReference;\n+\n+import com.fasterxml.jackson.core.util.BufferRecycler;\n+import com.fasterxml.jackson.core.util.ByteArrayBuilder;\n+import com.fasterxml.jackson.core.util.TextBuffer;\n+\n+/**\n+ * Helper class used for efficient encoding of JSON String values (including\n+ * JSON field names) into Strings or UTF-8 byte arrays.\n+ *<p>\n+ * Note that methods in here are somewhat optimized, but not ridiculously so.\n+ * Reason is that conversion method results are expected to be cached so that\n+ * these methods will not be hot spots during normal operation.\n+ *\n+ * @since 1.6\n+ */\n+public final class JsonStringEncoder\n+{\n+    private final static char[] HEX_CHARS = CharTypes.copyHexChars();\n+\n+    private final static byte[] HEX_BYTES = CharTypes.copyHexBytes();\n+\n+    private final static int SURR1_FIRST = 0xD800;\n+    private final static int SURR1_LAST = 0xDBFF;\n+    private final static int SURR2_FIRST = 0xDC00;\n+    private final static int SURR2_LAST = 0xDFFF;\n+\n+    private final static int INT_BACKSLASH = '\\\\';\n+    private final static int INT_U = 'u';\n+    private final static int INT_0 = '0';\n+    \n+    /**\n+     * This <code>ThreadLocal</code> contains a {@link java.lang.ref.SoftRerefence}\n+     * to a {@link BufferRecycler} used to provide a low-cost\n+     * buffer recycling between reader and writer instances.\n+     */\n+    final protected static ThreadLocal<SoftReference<JsonStringEncoder>> _threadEncoder\n+        = new ThreadLocal<SoftReference<JsonStringEncoder>>();\n+\n+    /**\n+     * Lazily constructed text buffer used to produce JSON encoded Strings\n+     * as characters (without UTF-8 encoding)\n+     */\n+    protected TextBuffer _textBuffer;\n+\n+    /**\n+     * Lazily-constructed builder used for UTF-8 encoding of text values\n+     * (quoted and unquoted)\n+     */\n+    protected ByteArrayBuilder _byteBuilder;\n+    \n+    /**\n+     * Temporary buffer used for composing quote/escape sequences\n+     */\n+    protected final char[] _quoteBuffer;\n+    \n+    /*\n+    /**********************************************************\n+    /* Construction, instance access\n+    /**********************************************************\n+     */\n+    \n+    public JsonStringEncoder()\n+    {\n+        _quoteBuffer = new char[6];\n+        _quoteBuffer[0] = '\\\\';\n+        _quoteBuffer[2] = '0';\n+        _quoteBuffer[3] = '0';\n+    }\n+    \n+    /**\n+     * Factory method for getting an instance; this is either recycled per-thread instance,\n+     * or a newly constructed one.\n+     */\n+    public static JsonStringEncoder getInstance()\n+    {\n+        SoftReference<JsonStringEncoder> ref = _threadEncoder.get();\n+        JsonStringEncoder enc = (ref == null) ? null : ref.get();\n+\n+        if (enc == null) {\n+            enc = new JsonStringEncoder();\n+            _threadEncoder.set(new SoftReference<JsonStringEncoder>(enc));\n+        }\n+        return enc;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that will quote text contents using JSON standard quoting,\n+     * and return results as a character array\n+     */\n+    public char[] quoteAsString(String input)\n+    {\n+        TextBuffer textBuffer = _textBuffer;\n+        if (textBuffer == null) {\n+            // no allocator; can add if we must, shouldn't need to\n+            _textBuffer = textBuffer = new TextBuffer(null);\n+        }\n+        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n+        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n+        final int escCodeCount = escCodes.length;\n+        int inPtr = 0;\n+        final int inputLen = input.length();\n+        int outPtr = 0;\n+ \n+        outer_loop:\n+        while (inPtr < inputLen) {\n+            tight_loop:\n+            while (true) {\n+                char c = input.charAt(inPtr);\n+                if (c < escCodeCount && escCodes[c] != 0) {\n+                    break tight_loop;\n+                }\n+                if (outPtr >= outputBuffer.length) {\n+                    outputBuffer = textBuffer.finishCurrentSegment();\n+                    outPtr = 0;\n+                }\n+                outputBuffer[outPtr++] = c;\n+                if (++inPtr >= inputLen) {\n+                    break outer_loop;\n+                }\n+            }\n+            // something to escape; 2 or 6-char variant? \n+            int escCode = escCodes[input.charAt(inPtr++)];\n+            int length = _appendSingleEscape(escCode, _quoteBuffer);\n+            if ((outPtr + length) > outputBuffer.length) {\n+                int first = outputBuffer.length - outPtr;\n+                if (first > 0) {\n+                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n+                }\n+                outputBuffer = textBuffer.finishCurrentSegment();\n+                int second = length - first;\n+                System.arraycopy(_quoteBuffer, first, outputBuffer, outPtr, second);\n+                outPtr += second;\n+            } else {\n+                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n+                outPtr += length;\n+            }\n+            \n+        }\n+        textBuffer.setCurrentLength(outPtr);\n+        return textBuffer.contentsAsArray();\n+    }\n+\n+    /**\n+     * Will quote given JSON String value using standard quoting, encode\n+     * results as UTF-8, and return result as a byte array.\n+     */\n+    public byte[] quoteAsUTF8(String text)\n+    {\n+        ByteArrayBuilder byteBuilder = _byteBuilder;\n+        if (byteBuilder == null) {\n+            // no allocator; can add if we must, shouldn't need to\n+            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n+        }\n+        int inputPtr = 0;\n+        int inputEnd = text.length();\n+        int outputPtr = 0;\n+        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n+        \n+        main_loop:\n+        while (inputPtr < inputEnd) {\n+            final int[] escCodes = CharTypes.get7BitOutputEscapes();\n+\n+            inner_loop: // ascii and escapes\n+            while (true) {\n+                int ch = text.charAt(inputPtr);\n+                if (ch > 0x7F || escCodes[ch] != 0) {\n+                    break inner_loop;\n+                }\n+                if (outputPtr >= outputBuffer.length) {\n+                    outputBuffer = byteBuilder.finishCurrentSegment();\n+                    outputPtr = 0;\n+                }\n+                outputBuffer[outputPtr++] = (byte) ch;\n+                if (++inputPtr >= inputEnd) {\n+                    break main_loop;\n+                }\n+            }                \n+            if (outputPtr >= outputBuffer.length) {\n+                outputBuffer = byteBuilder.finishCurrentSegment();\n+                outputPtr = 0;\n+            }\n+            // Ok, so what did we hit?\n+            int ch = (int) text.charAt(inputPtr++);\n+            if (ch <= 0x7F) { // needs quoting\n+                int escape = escCodes[ch];\n+                // ctrl-char, 6-byte escape...\n+                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n+                outputBuffer = byteBuilder.getCurrentSegment();\n+                continue main_loop;\n+            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n+                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n+                ch = (0x80 | (ch & 0x3f));\n+            } else { // 3 or 4 bytes\n+                // Surrogates?\n+                if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n+                    outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n+                    if (outputPtr >= outputBuffer.length) {\n+                        outputBuffer = byteBuilder.finishCurrentSegment();\n+                        outputPtr = 0;\n+                    }\n+                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n+                    ch = (0x80 | (ch & 0x3f));\n+                } else { // yes, surrogate pair\n+                    if (ch > SURR1_LAST) { // must be from first range\n+                        _throwIllegalSurrogate(ch);\n+                    }\n+                    // and if so, followed by another from next range\n+                    if (inputPtr >= inputEnd) {\n+                        _throwIllegalSurrogate(ch);\n+                    }\n+                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n+                    if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n+                        _throwIllegalSurrogate(ch);\n+                    }\n+                    outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n+                    if (outputPtr >= outputBuffer.length) {\n+                        outputBuffer = byteBuilder.finishCurrentSegment();\n+                        outputPtr = 0;\n+                    }\n+                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n+                    if (outputPtr >= outputBuffer.length) {\n+                        outputBuffer = byteBuilder.finishCurrentSegment();\n+                        outputPtr = 0;\n+                    }\n+                    outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n+                    ch = (0x80 | (ch & 0x3f));\n+                }\n+            }\n+            if (outputPtr >= outputBuffer.length) {\n+                outputBuffer = byteBuilder.finishCurrentSegment();\n+                outputPtr = 0;\n+            }\n+            outputBuffer[outputPtr++] = (byte) ch;\n+        }\n+        return _byteBuilder.completeAndCoalesce(outputPtr);\n+    }\n+    \n+    /**\n+     * Will encode given String as UTF-8 (without any quoting), return\n+     * resulting byte array.\n+     */\n+    public byte[] encodeAsUTF8(String text)\n+    {\n+        ByteArrayBuilder byteBuilder = _byteBuilder;\n+        if (byteBuilder == null) {\n+            // no allocator; can add if we must, shouldn't need to\n+            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n+        }\n+        int inputPtr = 0;\n+        int inputEnd = text.length();\n+        int outputPtr = 0;\n+        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n+        int outputEnd = outputBuffer.length;\n+        \n+        main_loop:\n+        while (inputPtr < inputEnd) {\n+            int c = text.charAt(inputPtr++);\n+\n+            // first tight loop for ascii\n+            while (c <= 0x7F) {\n+                if (outputPtr >= outputEnd) {\n+                    outputBuffer = byteBuilder.finishCurrentSegment();\n+                    outputEnd = outputBuffer.length;\n+                    outputPtr = 0;\n+                }\n+                outputBuffer[outputPtr++] = (byte) c;\n+                if (inputPtr >= inputEnd) {\n+                    break main_loop;\n+                }\n+                c = text.charAt(inputPtr++);\n+            }\n+\n+            // then multi-byte...\n+            if (outputPtr >= outputEnd) {\n+                outputBuffer = byteBuilder.finishCurrentSegment();\n+                outputEnd = outputBuffer.length;\n+                outputPtr = 0;\n+            }\n+            if (c < 0x800) { // 2-byte\n+                outputBuffer[outputPtr++] = (byte) (0xc0 | (c >> 6));\n+            } else { // 3 or 4 bytes\n+                // Surrogates?\n+                if (c < SURR1_FIRST || c > SURR2_LAST) { // nope\n+                    outputBuffer[outputPtr++] = (byte) (0xe0 | (c >> 12));\n+                    if (outputPtr >= outputEnd) {\n+                        outputBuffer = byteBuilder.finishCurrentSegment();\n+                        outputEnd = outputBuffer.length;\n+                        outputPtr = 0;\n+                    }\n+                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n+                } else { // yes, surrogate pair\n+                    if (c > SURR1_LAST) { // must be from first range\n+                        _throwIllegalSurrogate(c);\n+                    }\n+                    // and if so, followed by another from next range\n+                    if (inputPtr >= inputEnd) {\n+                        _throwIllegalSurrogate(c);\n+                    }\n+                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n+                    if (c > 0x10FFFF) { // illegal, as per RFC 4627\n+                        _throwIllegalSurrogate(c);\n+                    }\n+                    outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n+                    if (outputPtr >= outputEnd) {\n+                        outputBuffer = byteBuilder.finishCurrentSegment();\n+                        outputEnd = outputBuffer.length;\n+                        outputPtr = 0;\n+                    }\n+                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n+                    if (outputPtr >= outputEnd) {\n+                        outputBuffer = byteBuilder.finishCurrentSegment();\n+                        outputEnd = outputBuffer.length;\n+                        outputPtr = 0;\n+                    }\n+                    outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n+                }\n+            }\n+            if (outputPtr >= outputEnd) {\n+                outputBuffer = byteBuilder.finishCurrentSegment();\n+                outputEnd = outputBuffer.length;\n+                outputPtr = 0;\n+            }\n+            outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n+        }\n+        return _byteBuilder.completeAndCoalesce(outputPtr);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+\n+    private int _appendSingleEscape(int escCode, char[] quoteBuffer)\n+    {\n+        if (escCode < 0) { // control char, value -(char + 1)\n+            int value = -(escCode + 1);\n+            quoteBuffer[1] = 'u';\n+            // We know it's a control char, so only the last 2 chars are non-0\n+            quoteBuffer[4] = HEX_CHARS[value >> 4];\n+            quoteBuffer[5] = HEX_CHARS[value & 0xF];\n+            return 6;\n+        }\n+        quoteBuffer[1] = (char) escCode;\n+        return 2;\n+    }\n+\n+    private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr)\n+    {\n+        byteBuilder.setCurrentSegmentLength(ptr);\n+        byteBuilder.append(INT_BACKSLASH);\n+        if (escCode < 0) { // standard escape\n+            byteBuilder.append(INT_U);\n+            if (ch > 0xFF) {\n+                int hi = (ch >> 8);\n+                byteBuilder.append(HEX_BYTES[hi >> 4]);\n+                byteBuilder.append(HEX_BYTES[hi & 0xF]);\n+                ch &= 0xFF;\n+            } else {\n+                byteBuilder.append(INT_0);\n+                byteBuilder.append(INT_0);\n+            }\n+            byteBuilder.append(HEX_BYTES[ch >> 4]);\n+            byteBuilder.append(HEX_BYTES[ch & 0xF]);\n+        } else { // 2-char simple escape\n+            byteBuilder.append((byte) escCode);\n+        }\n+        return byteBuilder.getCurrentSegmentLength();\n+    }\n+    \n+    /**\n+     * Method called to calculate UTF code point, from a surrogate pair.\n+     */\n+    private int _convertSurrogate(int firstPart, int secondPart)\n+    {\n+        // Ok, then, is the second part valid?\n+        if (secondPart < SURR2_FIRST || secondPart > SURR2_LAST) {\n+            throw new IllegalArgumentException(\"Broken surrogate pair: first char 0x\"+Integer.toHexString(firstPart)+\", second 0x\"+Integer.toHexString(secondPart)+\"; illegal combination\");\n+        }\n+        return 0x10000 + ((firstPart - SURR1_FIRST) << 10) + (secondPart - SURR2_FIRST);\n+    }\n+    \n+    private void _throwIllegalSurrogate(int code)\n+    {\n+        if (code > 0x10FFFF) { // over max?\n+            throw new IllegalArgumentException(\"Illegal character point (0x\"+Integer.toHexString(code)+\") to output; max is 0x10FFFF as per RFC 4627\");\n+        }\n+        if (code >= SURR1_FIRST) {\n+            if (code <= SURR1_LAST) { // Unmatched first part (closing without second part?)\n+                throw new IllegalArgumentException(\"Unmatched first part of surrogate pair (0x\"+Integer.toHexString(code)+\")\");\n+            }\n+            throw new IllegalArgumentException(\"Unmatched second part of surrogate pair (0x\"+Integer.toHexString(code)+\")\");\n+        }\n+        // should we ever get this?\n+        throw new IllegalArgumentException(\"Illegal character point (0x\"+Integer.toHexString(code)+\") to output\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/io/MergedStream.java\n+package com.fasterxml.jackson.core.io;\n+\n+import java.io.*;\n+\n+/**\n+ * Simple {@link InputStream} implementation that is used to \"unwind\" some\n+ * data previously read from an input stream; so that as long as some of\n+ * that data remains, it's returned; but as long as it's read, we'll\n+ * just use data from the underlying original stream. \n+ * This is similar to {@link java.io.PushbackInputStream}, but here there's\n+ * only one implicit pushback, when instance is constructed.\n+ */\n+public final class MergedStream\n+    extends InputStream\n+{\n+    final protected IOContext _context;\n+\n+    final InputStream _in;\n+\n+    byte[] _buffer;\n+\n+    int _ptr;\n+\n+    final int _end;\n+\n+    public MergedStream(IOContext context,\n+            InputStream in, byte[] buf, int start, int end)\n+    {\n+        _context = context;\n+        _in = in;\n+        _buffer = buf;\n+        _ptr = start;\n+        _end = end;\n+    }\n+\n+    @Override\n+    public int available() throws IOException\n+    {\n+        if (_buffer != null) {\n+            return _end - _ptr;\n+        }\n+        return _in.available();\n+    }\n+\n+    @Override\n+    public void close() throws IOException\n+    {\n+        freeMergedBuffer();\n+        _in.close();\n+    }\n+\n+    @Override\n+    public void mark(int readlimit)\n+    {\n+        if (_buffer == null) {\n+            _in.mark(readlimit);\n+        }\n+    }\n+    \n+    @Override\n+    public boolean markSupported()\n+    {\n+        // Only supports marks past the initial rewindable section...\n+        return (_buffer == null) && _in.markSupported();\n+    }\n+    \n+    @Override\n+    public int read() throws IOException\n+    {\n+        if (_buffer != null) {\n+            int c = _buffer[_ptr++] & 0xFF;\n+            if (_ptr >= _end) {\n+                freeMergedBuffer();\n+            }\n+            return c;\n+        }\n+        return _in.read();\n+    }\n+    \n+    @Override\n+    public int read(byte[] b) throws IOException\n+    {\n+        return read(b, 0, b.length);\n+    }\n+\n+    @Override\n+    public int \tread(byte[] b, int off, int len) throws IOException\n+    {\n+        if (_buffer != null) {\n+            int avail = _end - _ptr;\n+            if (len > avail) {\n+                len = avail;\n+            }\n+            System.arraycopy(_buffer, _ptr, b, off, len);\n+            _ptr += len;\n+            if (_ptr >= _end) {\n+                freeMergedBuffer();\n+            }\n+            return len;\n+        }\n+        return _in.read(b, off, len);\n+    }\n+\n+    @Override\n+    public void reset() throws IOException\n+    {\n+        if (_buffer == null) {\n+            _in.reset();\n+        }\n+    }\n+\n+    @Override\n+    public long skip(long n) throws IOException\n+    {\n+        long count = 0L;\n+\n+        if (_buffer != null) {\n+            int amount = _end - _ptr;\n+\n+            if (amount > n) { // all in pushed back segment?\n+                _ptr += (int) n;\n+                return n;\n+            }\n+            freeMergedBuffer();\n+            count += amount;\n+            n -= amount;\n+        }\n+\n+        if (n > 0) {\n+            count += _in.skip(n);\n+        }\n+        return count;\n+    }\n+\n+    private void freeMergedBuffer()\n+    {\n+        byte[] buf = _buffer;\n+        if (buf != null) {\n+            _buffer = null;\n+            if (_context != null) {\n+                _context.releaseReadIOBuffer(buf);\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/io/NumberInput.java\n+package com.fasterxml.jackson.core.io;\n+\n+public final class NumberInput\n+{\n+    /**\n+     * Textual representation of a double constant that can cause nasty problems\n+     * with JDK (see http://www.exploringbinary.com/java-hangs-when-converting-2-2250738585072012e-308).\n+     */\n+    public final static String NASTY_SMALL_DOUBLE = \"2.2250738585072012e-308\";\n+\n+    /**\n+     * Constants needed for parsing longs from basic int parsing methods\n+     */\n+    final static long L_BILLION = 1000000000;\n+\n+    final static String MIN_LONG_STR_NO_SIGN = String.valueOf(Long.MIN_VALUE).substring(1);\n+    final static String MAX_LONG_STR = String.valueOf(Long.MAX_VALUE);\n+    \n+    /**\n+     * Fast method for parsing integers that are known to fit into\n+     * regular 32-bit signed int type. This means that length is\n+     * between 1 and 9 digits (inclusive)\n+     *<p>\n+     * Note: public to let unit tests call it\n+     */\n+    public final static int parseInt(char[] digitChars, int offset, int len)\n+    {\n+        int num = digitChars[offset] - '0';\n+        len += offset;\n+        // This looks ugly, but appears the fastest way (as per measurements)\n+        if (++offset < len) {\n+            num = (num * 10) + (digitChars[offset] - '0');\n+            if (++offset < len) {\n+                num = (num * 10) + (digitChars[offset] - '0');\n+                if (++offset < len) {\n+                    num = (num * 10) + (digitChars[offset] - '0');\n+                    if (++offset < len) {\n+                        num = (num * 10) + (digitChars[offset] - '0');\n+                        if (++offset < len) {\n+                            num = (num * 10) + (digitChars[offset] - '0');\n+                            if (++offset < len) {\n+                                num = (num * 10) + (digitChars[offset] - '0');\n+                                if (++offset < len) {\n+                                    num = (num * 10) + (digitChars[offset] - '0');\n+                                    if (++offset < len) {\n+                                        num = (num * 10) + (digitChars[offset] - '0');\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return num;\n+    }\n+\n+    /**\n+     * Helper method to (more) efficiently parse integer numbers from\n+     * String values.\n+     * \n+     * @since 1.7\n+     */\n+    public final static int parseInt(String str)\n+    {\n+        /* Ok: let's keep strategy simple: ignoring optional minus sign,\n+         * we'll accept 1 - 9 digits and parse things efficiently;\n+         * otherwise just defer to JDK parse functionality.\n+         */\n+        char c = str.charAt(0);\n+        int length = str.length();\n+        boolean negative = (c == '-');\n+        int offset = 1;\n+        // must have 1 - 9 digits after optional sign:\n+        // negative?\n+        if (negative) {\n+            if (length == 1 || length > 10) {\n+                return Integer.parseInt(str);\n+            }\n+            c = str.charAt(offset++);\n+        } else {\n+            if (length > 9) {\n+                return Integer.parseInt(str);\n+            }\n+        }\n+        if (c > '9' || c < '0') {\n+            return Integer.parseInt(str);\n+        }\n+        int num = c - '0';\n+        if (offset < length) {\n+            c = str.charAt(offset++);\n+            if (c > '9' || c < '0') {\n+                return Integer.parseInt(str);\n+            }\n+            num = (num * 10) + (c - '0');\n+            if (offset < length) {\n+                c = str.charAt(offset++);\n+                if (c > '9' || c < '0') {\n+                    return Integer.parseInt(str);\n+                }\n+                num = (num * 10) + (c - '0');\n+                // Let's just loop if we have more than 3 digits:\n+                if (offset < length) {\n+                    do {\n+                        c = str.charAt(offset++);\n+                        if (c > '9' || c < '0') {\n+                            return Integer.parseInt(str);\n+                        }\n+                        num = (num * 10) + (c - '0');\n+                    } while (offset < length);\n+                }\n+            }\n+        }\n+        return negative ? -num : num;\n+    }\n+    \n+    public final static long parseLong(char[] digitChars, int offset, int len)\n+    {\n+        // Note: caller must ensure length is [10, 18]\n+        int len1 = len-9;\n+        long val = parseInt(digitChars, offset, len1) * L_BILLION;\n+        return val + (long) parseInt(digitChars, offset+len1, 9);\n+    }\n+\n+    public final static long parseLong(String str)\n+    {\n+        /* Ok, now; as the very first thing, let's just optimize case of \"fake longs\";\n+         * that is, if we know they must be ints, call int parsing\n+         */\n+        int length = str.length();\n+        if (length <= 9) {\n+            return (long) parseInt(str);\n+        }\n+        // !!! TODO: implement efficient 2-int parsing...\n+        return Long.parseLong(str);\n+    }\n+    \n+    /**\n+     * Helper method for determining if given String representation of\n+     * an integral number would fit in 64-bit Java long or not.\n+     * Note that input String must NOT contain leading minus sign (even\n+     * if 'negative' is set to true).\n+     *\n+     * @param negative Whether original number had a minus sign (which is\n+     *    NOT passed to this method) or not\n+     */\n+    public final static boolean inLongRange(char[] digitChars, int offset, int len,\n+            boolean negative)\n+    {\n+        String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR;\n+        int cmpLen = cmpStr.length();\n+        if (len < cmpLen) return true;\n+        if (len > cmpLen) return false;\n+\n+        for (int i = 0; i < cmpLen; ++i) {\n+            int diff = digitChars[offset+i] - cmpStr.charAt(i);\n+            if (diff != 0) {\n+                return (diff < 0);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Similar to {@link #inLongRange(char[],int,int,boolean)}, but\n+     * with String argument\n+     *\n+     * @param negative Whether original number had a minus sign (which is\n+     *    NOT passed to this method) or not\n+     *\n+     * @since 1.5.0\n+     */\n+    public final static boolean inLongRange(String numberStr, boolean negative)\n+    {\n+        String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR;\n+        int cmpLen = cmpStr.length();\n+        int actualLen = numberStr.length();\n+        if (actualLen < cmpLen) return true;\n+        if (actualLen > cmpLen) return false;\n+\n+        // could perhaps just use String.compareTo()?\n+        for (int i = 0; i < cmpLen; ++i) {\n+            int diff = numberStr.charAt(i) - cmpStr.charAt(i);\n+            if (diff != 0) {\n+                return (diff < 0);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * @since 1.6\n+     */\n+    public static int parseAsInt(String input, int defaultValue)\n+    {\n+        if (input == null) {\n+            return defaultValue;\n+        }\n+        input = input.trim();\n+        int len = input.length();\n+        if (len == 0) {\n+            return defaultValue;\n+        }\n+        // One more thing: use integer parsing for 'simple'\n+        int i = 0;\n+        if (i < len) { // skip leading sign:\n+            char c = input.charAt(0);\n+            if (c == '+') { // for plus, actually physically remove\n+                input = input.substring(1);\n+                len = input.length();\n+            } else if (c == '-') { // minus, just skip for checks, must retain\n+                ++i;\n+            }\n+        }\n+        for (; i < len; ++i) {\n+            char c = input.charAt(i);\n+            // if other symbols, parse as Double, coerce\n+            if (c > '9' || c < '0') {\n+                try {\n+                    return (int) parseDouble(input);\n+                } catch (NumberFormatException e) {\n+                    return defaultValue;\n+                }\n+            }\n+        }\n+        try {\n+            return Integer.parseInt(input);\n+        } catch (NumberFormatException e) { }\n+        return defaultValue;\n+    }\n+\n+    /**\n+     * @since 1.6\n+     */\n+    public static long parseAsLong(String input, long defaultValue)\n+    {\n+        if (input == null) {\n+            return defaultValue;\n+        }\n+        input = input.trim();\n+        int len = input.length();\n+        if (len == 0) {\n+            return defaultValue;\n+        }\n+        // One more thing: use long parsing for 'simple'\n+        int i = 0;\n+        if (i < len) { // skip leading sign:\n+            char c = input.charAt(0);\n+            if (c == '+') { // for plus, actually physically remove\n+                input = input.substring(1);\n+                len = input.length();\n+            } else if (c == '-') { // minus, just skip for checks, must retain\n+                ++i;\n+            }\n+        }\n+        for (; i < len; ++i) {\n+            char c = input.charAt(i);\n+            // if other symbols, parse as Double, coerce\n+            if (c > '9' || c < '0') {\n+                try {\n+                    return (long) parseDouble(input);\n+                } catch (NumberFormatException e) {\n+                    return defaultValue;\n+                }\n+            }\n+        }\n+        try {\n+            return Long.parseLong(input);\n+        } catch (NumberFormatException e) { }\n+        return defaultValue;\n+    }\n+    \n+    /**\n+     * @since 1.6\n+     */\n+    public static double parseAsDouble(String input, double defaultValue)\n+    {\n+        if (input == null) {\n+            return defaultValue;\n+        }\n+        input = input.trim();\n+        int len = input.length();\n+        if (len == 0) {\n+            return defaultValue;\n+        }\n+        try {\n+            return parseDouble(input);\n+        } catch (NumberFormatException e) { }\n+        return defaultValue;\n+    }\n+    \n+    /**\n+     * @since 1.8\n+     */\n+    public final static double parseDouble(String numStr) throws NumberFormatException\n+    {\n+        // [JACKSON-486]: avoid some nasty float representations... but should it be MIN_NORMAL or MIN_VALUE?\n+        if (NASTY_SMALL_DOUBLE.equals(numStr)) {\n+            return Double.MIN_NORMAL;\n+        }\n+        return Double.parseDouble(numStr);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/io/NumberOutput.java\n+package com.fasterxml.jackson.core.io;\n+\n+public final class NumberOutput\n+{\n+    private final static char NULL_CHAR = (char) 0;\n+\n+    private static int MILLION = 1000000;\n+    private static int BILLION = 1000000000;\n+    private static long TEN_BILLION_L = 10000000000L;\n+    private static long THOUSAND_L = 1000L;\n+\n+    private static long MIN_INT_AS_LONG = (long) Integer.MIN_VALUE;\n+    private static long MAX_INT_AS_LONG = (long) Integer.MAX_VALUE;\n+\n+    final static String SMALLEST_LONG = String.valueOf(Long.MIN_VALUE);\n+\n+    final static char[] LEADING_TRIPLETS = new char[4000];\n+    final static char[] FULL_TRIPLETS = new char[4000];\n+    static {\n+        /* Let's fill it with NULLs for ignorable leading digits,\n+         * and digit chars for others\n+         */\n+        int ix = 0;\n+        for (int i1 = 0; i1 < 10; ++i1) {\n+            char f1 = (char) ('0' + i1);\n+            char l1 = (i1 == 0) ? NULL_CHAR : f1;\n+            for (int i2 = 0; i2 < 10; ++i2) {\n+                char f2 = (char) ('0' + i2);\n+                char l2 = (i1 == 0 && i2 == 0) ? NULL_CHAR : f2;\n+                for (int i3 = 0; i3 < 10; ++i3) {\n+                    // Last is never to be empty\n+                    char f3 = (char) ('0' + i3);\n+                    LEADING_TRIPLETS[ix] = l1;\n+                    LEADING_TRIPLETS[ix+1] = l2;\n+                    LEADING_TRIPLETS[ix+2] = f3;\n+                    FULL_TRIPLETS[ix] = f1;\n+                    FULL_TRIPLETS[ix+1] = f2;\n+                    FULL_TRIPLETS[ix+2] = f3;\n+                    ix += 4;\n+                }\n+            }\n+        }\n+    }\n+\n+    final static byte[] FULL_TRIPLETS_B = new byte[4000];\n+    static {\n+        for (int i = 0; i < 4000; ++i) {\n+            FULL_TRIPLETS_B[i] = (byte) FULL_TRIPLETS[i];\n+        }\n+    }\n+    \n+    final static String[] sSmallIntStrs = new String[] {\n+        \"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\"\n+    };\n+    final static String[] sSmallIntStrs2 = new String[] {\n+        \"-1\",\"-2\",\"-3\",\"-4\",\"-5\",\"-6\",\"-7\",\"-8\",\"-9\",\"-10\"\n+    };\n+\n+    /*\n+    /**********************************************************\n+    /* Efficient serialization methods using raw buffers\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @return Offset within buffer after outputting int\n+     */\n+    public static int outputInt(int value, char[] buffer, int offset)\n+    {\n+        if (value < 0) {\n+            if (value == Integer.MIN_VALUE) {\n+                /* Special case: no matching positive value within range;\n+                 * let's then \"upgrade\" to long and output as such.\n+                 */\n+                return outputLong((long) value, buffer, offset);\n+            }\n+            buffer[offset++] = '-';\n+            value = -value;\n+        }\n+\n+        if (value < MILLION) { // at most 2 triplets...\n+            if (value < 1000) {\n+                if (value < 10) {\n+                    buffer[offset++] = (char) ('0' + value);\n+                } else {\n+                    offset = outputLeadingTriplet(value, buffer, offset);\n+                }\n+            } else {\n+                int thousands = value / 1000;\n+                value -= (thousands * 1000); // == value % 1000\n+                offset = outputLeadingTriplet(thousands, buffer, offset);\n+                offset = outputFullTriplet(value, buffer, offset);\n+            }\n+            return offset;\n+        }\n+\n+        // ok, all 3 triplets included\n+        /* Let's first hand possible billions separately before\n+         * handling 3 triplets. This is possible since we know we\n+         * can have at most '2' as billion count.\n+         */\n+        boolean hasBillions = (value >= BILLION);\n+        if (hasBillions) {\n+            value -= BILLION;\n+            if (value >= BILLION) {\n+                value -= BILLION;\n+                buffer[offset++] = '2';\n+            } else {\n+                buffer[offset++] = '1';\n+            }\n+        }\n+        int newValue = value / 1000;\n+        int ones = (value - (newValue * 1000)); // == value % 1000\n+        value = newValue;\n+        newValue /= 1000;\n+        int thousands = (value - (newValue * 1000));\n+        \n+        // value now has millions, which have 1, 2 or 3 digits\n+        if (hasBillions) {\n+            offset = outputFullTriplet(newValue, buffer, offset);\n+        } else {\n+            offset = outputLeadingTriplet(newValue, buffer, offset);\n+        }\n+        offset = outputFullTriplet(thousands, buffer, offset);\n+        offset = outputFullTriplet(ones, buffer, offset);\n+        return offset;\n+    }\n+\n+    public static int outputInt(int value, byte[] buffer, int offset)\n+    {\n+        if (value < 0) {\n+            if (value == Integer.MIN_VALUE) {\n+                return outputLong((long) value, buffer, offset);\n+            }\n+            buffer[offset++] = '-';\n+            value = -value;\n+        }\n+\n+        if (value < MILLION) { // at most 2 triplets...\n+            if (value < 1000) {\n+                if (value < 10) {\n+                    buffer[offset++] = (byte) ('0' + value);\n+                } else {\n+                    offset = outputLeadingTriplet(value, buffer, offset);\n+                }\n+            } else {\n+                int thousands = value / 1000;\n+                value -= (thousands * 1000); // == value % 1000\n+                offset = outputLeadingTriplet(thousands, buffer, offset);\n+                offset = outputFullTriplet(value, buffer, offset);\n+            }\n+            return offset;\n+        }\n+        boolean hasBillions = (value >= BILLION);\n+        if (hasBillions) {\n+            value -= BILLION;\n+            if (value >= BILLION) {\n+                value -= BILLION;\n+                buffer[offset++] = '2';\n+            } else {\n+                buffer[offset++] = '1';\n+            }\n+        }\n+        int newValue = value / 1000;\n+        int ones = (value - (newValue * 1000)); // == value % 1000\n+        value = newValue;\n+        newValue /= 1000;\n+        int thousands = (value - (newValue * 1000));\n+        \n+        if (hasBillions) {\n+            offset = outputFullTriplet(newValue, buffer, offset);\n+        } else {\n+            offset = outputLeadingTriplet(newValue, buffer, offset);\n+        }\n+        offset = outputFullTriplet(thousands, buffer, offset);\n+        offset = outputFullTriplet(ones, buffer, offset);\n+        return offset;\n+    }\n+    \n+    /**\n+     * @return Offset within buffer after outputting int\n+     */\n+    public static int outputLong(long value, char[] buffer, int offset)\n+    {\n+        // First: does it actually fit in an int?\n+        if (value < 0L) {\n+            /* MIN_INT is actually printed as long, just because its\n+             * negation is not an int but long\n+             */\n+            if (value > MIN_INT_AS_LONG) {\n+                return outputInt((int) value, buffer, offset);\n+            }\n+            if (value == Long.MIN_VALUE) {\n+                // Special case: no matching positive value within range\n+                int len = SMALLEST_LONG.length();\n+                SMALLEST_LONG.getChars(0, len, buffer, offset);\n+                return (offset + len);\n+            }\n+            buffer[offset++] = '-';\n+            value = -value;\n+        } else {\n+            if (value <= MAX_INT_AS_LONG) {\n+                return outputInt((int) value, buffer, offset);\n+            }\n+        }\n+\n+        /* Ok: real long print. Need to first figure out length\n+         * in characters, and then print in from end to beginning\n+         */\n+        int origOffset = offset;\n+        offset += calcLongStrLength(value);\n+        int ptr = offset;\n+\n+        // First, with long arithmetics:\n+        while (value > MAX_INT_AS_LONG) { // full triplet\n+            ptr -= 3;\n+            long newValue = value / THOUSAND_L;\n+            int triplet = (int) (value - newValue * THOUSAND_L);\n+            outputFullTriplet(triplet, buffer, ptr);\n+            value = newValue;\n+        }\n+        // Then with int arithmetics:\n+        int ivalue = (int) value;\n+        while (ivalue >= 1000) { // still full triplet\n+            ptr -= 3;\n+            int newValue = ivalue / 1000;\n+            int triplet = ivalue - (newValue * 1000);\n+            outputFullTriplet(triplet, buffer, ptr);\n+            ivalue = newValue;\n+        }\n+        // And finally, if anything remains, partial triplet\n+        outputLeadingTriplet(ivalue, buffer, origOffset);\n+\n+        return offset;\n+    }\n+\n+    public static int outputLong(long value, byte[] buffer, int offset)\n+    {\n+        if (value < 0L) {\n+            if (value > MIN_INT_AS_LONG) {\n+                return outputInt((int) value, buffer, offset);\n+            }\n+            if (value == Long.MIN_VALUE) {\n+                // Special case: no matching positive value within range\n+                int len = SMALLEST_LONG.length();\n+                for (int i = 0; i < len; ++i) {\n+                    buffer[offset++] = (byte) SMALLEST_LONG.charAt(i);\n+                }\n+                return offset;\n+            }\n+            buffer[offset++] = '-';\n+            value = -value;\n+        } else {\n+            if (value <= MAX_INT_AS_LONG) {\n+                return outputInt((int) value, buffer, offset);\n+            }\n+        }\n+        int origOffset = offset;\n+        offset += calcLongStrLength(value);\n+        int ptr = offset;\n+\n+        // First, with long arithmetics:\n+        while (value > MAX_INT_AS_LONG) { // full triplet\n+            ptr -= 3;\n+            long newValue = value / THOUSAND_L;\n+            int triplet = (int) (value - newValue * THOUSAND_L);\n+            outputFullTriplet(triplet, buffer, ptr);\n+            value = newValue;\n+        }\n+        // Then with int arithmetics:\n+        int ivalue = (int) value;\n+        while (ivalue >= 1000) { // still full triplet\n+            ptr -= 3;\n+            int newValue = ivalue / 1000;\n+            int triplet = ivalue - (newValue * 1000);\n+            outputFullTriplet(triplet, buffer, ptr);\n+            ivalue = newValue;\n+        }\n+        outputLeadingTriplet(ivalue, buffer, origOffset);\n+        return offset;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Secondary convenience serialization methods\n+    /**********************************************************\n+     */\n+\n+    /* !!! 05-Aug-2008, tatus: Any ways to further optimize\n+     *   these? (or need: only called by diagnostics methods?)\n+     */\n+\n+    public static String toString(int value)\n+    {\n+        // Lookup table for small values\n+        if (value < sSmallIntStrs.length) {\n+            if (value >= 0) {\n+                return sSmallIntStrs[value];\n+            }\n+            int v2 = -value - 1;\n+            if (v2 < sSmallIntStrs2.length) {\n+                return sSmallIntStrs2[v2];\n+            }\n+        }\n+        return Integer.toString(value);\n+    }\n+\n+    public static String toString(long value)\n+    {\n+        if (value <= Integer.MAX_VALUE &&\n+            value >= Integer.MIN_VALUE) {\n+            return toString((int) value);\n+        }\n+        return Long.toString(value);\n+    }\n+\n+    public static String toString(double value)\n+    {\n+        return Double.toString(value);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+\n+    private static int outputLeadingTriplet(int triplet, char[] buffer, int offset)\n+    {\n+        int digitOffset = (triplet << 2);\n+        char c = LEADING_TRIPLETS[digitOffset++];\n+        if (c != NULL_CHAR) {\n+            buffer[offset++] = c;\n+        }\n+        c = LEADING_TRIPLETS[digitOffset++];\n+        if (c != NULL_CHAR) {\n+            buffer[offset++] = c;\n+        }\n+        // Last is required to be non-empty\n+        buffer[offset++] = LEADING_TRIPLETS[digitOffset];\n+        return offset;\n+    }\n+\n+    private static int outputLeadingTriplet(int triplet, byte[] buffer, int offset)\n+    {\n+        int digitOffset = (triplet << 2);\n+        char c = LEADING_TRIPLETS[digitOffset++];\n+        if (c != NULL_CHAR) {\n+            buffer[offset++] = (byte) c;\n+        }\n+        c = LEADING_TRIPLETS[digitOffset++];\n+        if (c != NULL_CHAR) {\n+            buffer[offset++] = (byte) c;\n+        }\n+        // Last is required to be non-empty\n+        buffer[offset++] = (byte) LEADING_TRIPLETS[digitOffset];\n+        return offset;\n+    }\n+    \n+    private static int outputFullTriplet(int triplet, char[] buffer, int offset)\n+    {\n+        int digitOffset = (triplet << 2);\n+        buffer[offset++] = FULL_TRIPLETS[digitOffset++];\n+        buffer[offset++] = FULL_TRIPLETS[digitOffset++];\n+        buffer[offset++] = FULL_TRIPLETS[digitOffset];\n+        return offset;\n+    }\n+\n+    private static int outputFullTriplet(int triplet, byte[] buffer, int offset)\n+    {\n+        int digitOffset = (triplet << 2);\n+        buffer[offset++] = FULL_TRIPLETS_B[digitOffset++];\n+        buffer[offset++] = FULL_TRIPLETS_B[digitOffset++];\n+        buffer[offset++] = FULL_TRIPLETS_B[digitOffset];\n+        return offset;\n+    }\n+    \n+    /**\n+     *<p>\n+     * Pre-conditions: posValue is positive, and larger than\n+     * Integer.MAX_VALUE (about 2 billions).\n+     */\n+    private static int calcLongStrLength(long posValue)\n+    {\n+        int len = 10;\n+        long comp = TEN_BILLION_L;\n+\n+        // 19 is longest, need to worry about overflow\n+        while (posValue >= comp) {\n+            if (len == 19) {\n+                break;\n+            }\n+            ++len;\n+            comp = (comp << 3) + (comp << 1); // 10x\n+        }\n+        return len;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/io/OutputDecorator.java\n+package com.fasterxml.jackson.core.io;\n+\n+import java.io.*;\n+\n+/**\n+ * Handler class that can be used to decorate output destinations.\n+ * Typical use is to use a filter abstraction (filtered output stream,\n+ * writer) around original output destination, and apply additional\n+ * processing during write operations.\n+ * \n+ * @since 1.8\n+ */\n+public abstract class OutputDecorator\n+{\n+    /**\n+     * Method called by {@link com.fasterxml.jackson.core.JsonFactory} instance when\n+     * creating generator for given {@link OutputStream}, when this decorator\n+     * has been registered.\n+     * \n+     * @param ctxt IO context in use (provides access to declared encoding)\n+     * @param out Original output destination\n+     * \n+     * @return OutputStream to use; either passed in argument, or something that\n+     *   calls it\n+     */\n+    public abstract OutputStream decorate(IOContext ctxt, OutputStream out)\n+        throws IOException;\n+\n+    /**\n+     * Method called by {@link com.fasterxml.jackson.core.JsonFactory} instance when\n+     * creating generator for given {@link Writer}, when this decorator\n+     * has been registered.\n+     * \n+     * @param ctxt IO context in use (provides access to declared encoding)\n+     * @param w Original output writer\n+     * \n+     * @return Writer to use; either passed in argument, or something that calls it\n+     */\n+    public abstract Writer decorate(IOContext ctxt, Writer w) throws IOException;\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/io/SegmentedStringWriter.java\n+package com.fasterxml.jackson.core.io;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.util.BufferRecycler;\n+import com.fasterxml.jackson.core.util.TextBuffer;\n+\n+/**\n+ * Efficient alternative to {@link StringWriter}, based on using segmented\n+ * internal buffer. Initial input buffer is also recyclable.\n+ *<p>\n+ * This class is most useful when serializing JSON content as a String:\n+ * if so, instance of this class can be given as the writer to\n+ * <code>JsonGenerator</code>.\n+ *\n+ * @since 1.3\n+ */\n+public final class SegmentedStringWriter\n+    extends Writer\n+{\n+    final protected TextBuffer _buffer;\n+\n+    public SegmentedStringWriter(BufferRecycler br)\n+    {\n+        super();\n+        _buffer = new TextBuffer(br);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* java.io.Writer implementation\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public Writer append(char c)\n+    {\n+        write(c);\n+        return this;\n+    }\n+\n+    @Override\n+    public Writer append(CharSequence csq)\n+    {\n+\tString str = csq.toString();\n+\t_buffer.append(str, 0, str.length());\n+        return this;\n+    }\n+\n+    @Override\n+    public Writer append(CharSequence csq, int start, int end)\n+    {\n+\tString str = csq.subSequence(start, end).toString();\n+\t_buffer.append(str, 0, str.length());\n+        return this;\n+    }\n+\n+    @Override public void close() { } // NOP\n+\n+    @Override public void flush() { } // NOP\n+\n+    @Override\n+    public void write(char[] cbuf) {\n+        _buffer.append(cbuf, 0, cbuf.length);\n+    }\n+\n+    @Override\n+    public void write(char[] cbuf, int off, int len) {\n+        _buffer.append(cbuf, off, len);\n+    }\n+\n+    @Override\n+    public void write(int c) {\n+        _buffer.append((char) c);\n+    }\n+\n+    @Override\n+    public void write(String str) { _buffer.append(str, 0, str.length()); }\n+\n+    @Override\n+    public void write(String str, int off, int len) {\n+        _buffer.append(str, 0, str.length());\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended API\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Main access method that will construct a String that contains\n+     * all the contents, release all internal buffers we may have,\n+     * and return result String.\n+     * Note that the method is not idempotent -- if called second time,\n+     * will just return an empty String.\n+     */\n+    public String getAndClear()\n+    {\n+        String result = _buffer.contentsAsString();\n+        _buffer.releaseBuffers();\n+        return result;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/io/SerializedString.java\n+package com.fasterxml.jackson.core.io;\n+\n+import com.fasterxml.jackson.core.SerializableString;\n+\n+/**\n+ * String token that can lazily serialize String contained and then reuse that\n+ * serialization later on. This is similar to JDBC prepared statements, for example,\n+ * in that instances should only be created when they are used more than use;\n+ * prime candidates are various serializers.\n+ *<p>\n+ * Class is final for performance reasons and since this is not designed to\n+ * be extensible or customizable (customizations would occur in calling code)\n+ *\n+ * @since 1.6\n+ */\n+public class SerializedString implements SerializableString\n+{\n+    protected final String _value;\n+\n+    /* 13-Dec-2010, tatu: Whether use volatile or not is actually an important\n+     *   decision for multi-core use cases. Cost of volatility can be non-trivial\n+     *   for heavy use cases, and serialized-string instances are accessed often.\n+     *   Given that all code paths with common Jackson usage patterns go through\n+     *   a few memory barriers (mostly with cache/reuse pool access) it seems safe\n+     *   enough to omit volatiles here, given how simple lazy initialization is.\n+     *   This can be compared to how {@link String#intern} works; lazily and\n+     *   without synchronization or use of volatile keyword.\n+     */\n+    \n+    protected /*volatile*/ byte[] _quotedUTF8Ref;\n+\n+    protected /*volatile*/ byte[] _unquotedUTF8Ref;\n+\n+    protected /*volatile*/ char[] _quotedChars;\n+\n+    public SerializedString(String v) { _value = v; }\n+\n+    /*\n+    /**********************************************************\n+    /* API\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public final String getValue() { return _value; }\n+    \n+    /**\n+     * Returns length of the String as characters\n+     */\n+    @Override\n+    public final int charLength() { return _value.length(); }\n+    \n+    @Override\n+    public final char[] asQuotedChars()\n+    {\n+        char[] result = _quotedChars;\n+        if (result == null) {\n+            result = JsonStringEncoder.getInstance().quoteAsString(_value);\n+            _quotedChars = result;\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Accessor for accessing value that has been quoted using JSON\n+     * quoting rules, and encoded using UTF-8 encoding.\n+     */\n+    @Override\n+    public final byte[] asUnquotedUTF8()\n+    {\n+        byte[] result = _unquotedUTF8Ref;\n+        if (result == null) {\n+            result = JsonStringEncoder.getInstance().encodeAsUTF8(_value);\n+            _unquotedUTF8Ref  = result;\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Accessor for accessing value as is (without JSON quoting)\n+     * encoded using UTF-8 encoding.\n+     */\n+    @Override\n+    public final byte[] asQuotedUTF8()\n+    {\n+        byte[] result = _quotedUTF8Ref;\n+        if (result == null) {\n+            result = JsonStringEncoder.getInstance().quoteAsUTF8(_value);\n+            _quotedUTF8Ref = result;\n+        }\n+        return result;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Standard method overrides\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public final String toString() { return _value; }\n+    \n+    @Override\n+    public final int hashCode() { return _value.hashCode(); }\n+\n+    @Override\n+    public final boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null || o.getClass() != getClass()) return false;\n+        SerializedString other = (SerializedString) o;\n+        return _value.equals(other._value);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/io/UTF32Reader.java\n+package com.fasterxml.jackson.core.io;\n+\n+import java.io.*;\n+\n+\n+/**\n+ * Since JDK does not come with UTF-32/UCS-4, let's implement a simple\n+ * decoder to use.\n+ */\n+public final class UTF32Reader\n+    extends BaseReader\n+{\n+    final boolean mBigEndian;\n+\n+    /**\n+     * Although input is fine with full Unicode set, Java still uses\n+     * 16-bit chars, so we may have to split high-order chars into\n+     * surrogate pairs.\n+     */\n+    char mSurrogate = NULL_CHAR;\n+\n+    /**\n+     * Total read character count; used for error reporting purposes\n+     */\n+    int mCharCount = 0;\n+\n+    /**\n+     * Total read byte count; used for error reporting purposes\n+     */\n+    int mByteCount = 0;\n+\n+    /*\n+    ////////////////////////////////////////\n+    // Life-cycle\n+    ////////////////////////////////////////\n+    */\n+\n+    public UTF32Reader(IOContext ctxt,\n+                       InputStream in, byte[] buf, int ptr, int len,\n+                       boolean isBigEndian)\n+    {\n+        super(ctxt, in, buf, ptr, len);\n+        mBigEndian = isBigEndian;\n+    }\n+\n+    /*\n+    ////////////////////////////////////////\n+    // Public API\n+    ////////////////////////////////////////\n+    */\n+\n+    @Override\n+\tpublic int read(char[] cbuf, int start, int len)\n+        throws IOException\n+    {\n+        // Already EOF?\n+        if (_buffer == null) {\n+            return -1;\n+        }\n+        if (len < 1) {\n+            return len;\n+        }\n+        // Let's then ensure there's enough room...\n+        if (start < 0 || (start+len) > cbuf.length) {\n+            reportBounds(cbuf, start, len);\n+        }\n+\n+        len += start;\n+        int outPtr = start;\n+\n+        // Ok, first; do we have a surrogate from last round?\n+        if (mSurrogate != NULL_CHAR) {\n+            cbuf[outPtr++] = mSurrogate;\n+            mSurrogate = NULL_CHAR;\n+            // No need to load more, already got one char\n+        } else {\n+            /* Note: we'll try to avoid blocking as much as possible. As a\n+             * result, we only need to get 4 bytes for a full char.\n+             */\n+            int left = (_length - _ptr);\n+            if (left < 4) {\n+                if (!loadMore(left)) { // (legal) EOF?\n+                    return -1;\n+                }\n+            }\n+        }\n+\n+        main_loop:\n+        while (outPtr < len) {\n+            int ptr = _ptr;\n+            int ch;\n+\n+            if (mBigEndian) {\n+                ch = (_buffer[ptr] << 24) | ((_buffer[ptr+1] & 0xFF) << 16)\n+                    | ((_buffer[ptr+2] & 0xFF) << 8) | (_buffer[ptr+3] & 0xFF);\n+            } else {\n+                ch = (_buffer[ptr] & 0xFF) | ((_buffer[ptr+1] & 0xFF) << 8)\n+                    | ((_buffer[ptr+2] & 0xFF) << 16) | (_buffer[ptr+3] << 24);\n+            }\n+            _ptr += 4;\n+\n+            // Does it need to be split to surrogates?\n+            // (also, we can and need to verify illegal chars)\n+            if (ch > 0xFFFF) { // need to split into surrogates?\n+                if (ch > LAST_VALID_UNICODE_CHAR) {\n+                    reportInvalid(ch, outPtr-start,\n+                                  \"(above \"+Integer.toHexString(LAST_VALID_UNICODE_CHAR)+\") \");\n+                }\n+                ch -= 0x10000; // to normalize it starting with 0x0\n+                cbuf[outPtr++] = (char) (0xD800 + (ch >> 10));\n+                // hmmh. can this ever be 0? (not legal, at least?)\n+                ch = (0xDC00 | (ch & 0x03FF));\n+                // Room for second part?\n+                if (outPtr >= len) { // nope\n+                    mSurrogate = (char) ch;\n+                    break main_loop;\n+                }\n+            }\n+            cbuf[outPtr++] = (char) ch;\n+            if (_ptr >= _length) {\n+                break main_loop;\n+            }\n+        }\n+\n+        len = outPtr - start;\n+        mCharCount += len;\n+        return len;\n+    }\n+\n+    /*\n+    ////////////////////////////////////////\n+    // Internal methods\n+    ////////////////////////////////////////\n+    */\n+\n+    private void reportUnexpectedEOF(int gotBytes, int needed)\n+        throws IOException\n+    {\n+        int bytePos = mByteCount + gotBytes;\n+        int charPos = mCharCount;\n+\n+        throw new CharConversionException(\"Unexpected EOF in the middle of a 4-byte UTF-32 char: got \"\n+                                          +gotBytes+\", needed \"+needed\n+                                          +\", at char #\"+charPos+\", byte #\"+bytePos+\")\");\n+    }\n+\n+    private void reportInvalid(int value, int offset, String msg)\n+        throws IOException\n+    {\n+        int bytePos = mByteCount + _ptr - 1;\n+        int charPos = mCharCount + offset;\n+\n+        throw new CharConversionException(\"Invalid UTF-32 character 0x\"\n+                                          +Integer.toHexString(value)\n+                                          +msg+\" at char #\"+charPos+\", byte #\"+bytePos+\")\");\n+    }\n+\n+    /**\n+     * @param available Number of \"unused\" bytes in the input buffer\n+     *\n+     * @return True, if enough bytes were read to allow decoding of at least\n+     *   one full character; false if EOF was encountered instead.\n+     */\n+    private boolean loadMore(int available)\n+        throws IOException\n+    {\n+        mByteCount += (_length - available);\n+\n+        // Bytes that need to be moved to the beginning of buffer?\n+        if (available > 0) {\n+            if (_ptr > 0) {\n+                for (int i = 0; i < available; ++i) {\n+                    _buffer[i] = _buffer[_ptr+i];\n+                }\n+                _ptr = 0;\n+            }\n+            _length = available;\n+        } else {\n+            /* Ok; here we can actually reasonably expect an EOF,\n+             * so let's do a separate read right away:\n+             */\n+            _ptr = 0;\n+            int count = _in.read(_buffer);\n+            if (count < 1) {\n+                _length = 0;\n+                if (count < 0) { // -1\n+                    freeBuffers(); // to help GC?\n+                    return false;\n+                }\n+                // 0 count is no good; let's err out\n+                reportStrangeStream();\n+            }\n+            _length = count;\n+        }\n+\n+        /* Need at least 4 bytes; if we don't get that many, it's an\n+         * error.\n+         */\n+        while (_length < 4) {\n+            int count = _in.read(_buffer, _length, _buffer.length - _length);\n+            if (count < 1) {\n+                if (count < 0) { // -1, EOF... no good!\n+                    freeBuffers(); // to help GC?\n+                    reportUnexpectedEOF(_length, 4);\n+                }\n+                // 0 count is no good; let's err out\n+                reportStrangeStream();\n+            }\n+            _length += count;\n+        }\n+        return true;\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/io/UTF8Writer.java\n+package com.fasterxml.jackson.core.io;\n+\n+import java.io.*;\n+\n+\n+public final class UTF8Writer\n+    extends Writer\n+{\n+    final static int SURR1_FIRST = 0xD800;\n+    final static int SURR1_LAST = 0xDBFF;\n+    final static int SURR2_FIRST = 0xDC00;\n+    final static int SURR2_LAST = 0xDFFF;\n+\n+    final protected IOContext _context;\n+\n+    OutputStream _out;\n+\n+    byte[] _outBuffer;\n+\n+    final int _outBufferEnd;\n+\n+    int _outPtr;\n+\n+    /**\n+     * When outputting chars from BMP, surrogate pairs need to be coalesced.\n+     * To do this, both pairs must be known first; and since it is possible\n+     * pairs may be split, we need temporary storage for the first half\n+     */\n+    int _surrogate = 0;\n+\n+    public UTF8Writer(IOContext ctxt, OutputStream out)\n+    {\n+        _context = ctxt;\n+        _out = out;\n+\n+        _outBuffer = ctxt.allocWriteEncodingBuffer();\n+        /* Max. expansion for a single char (in unmodified UTF-8) is\n+         * 4 bytes (or 3 depending on how you view it -- 4 when recombining\n+         * surrogate pairs)\n+         */\n+        _outBufferEnd = _outBuffer.length - 4;\n+        _outPtr = 0;\n+    }\n+\n+    @Override\n+    public Writer append(char c)\n+        throws IOException\n+    {\n+        write(c);\n+        return this;\n+    }\n+\n+    @Override\n+    public void close()\n+        throws IOException\n+    {\n+        if (_out != null) {\n+            if (_outPtr > 0) {\n+                _out.write(_outBuffer, 0, _outPtr);\n+                _outPtr = 0;\n+            }\n+            OutputStream out = _out;\n+            _out = null;\n+\n+            byte[] buf = _outBuffer;\n+            if (buf != null) {\n+                _outBuffer = null;\n+                _context.releaseWriteEncodingBuffer(buf);\n+            }\n+\n+            out.close();\n+\n+            /* Let's 'flush' orphan surrogate, no matter what; but only\n+             * after cleanly closing everything else.\n+             */\n+            int code = _surrogate;\n+            _surrogate = 0;\n+            if (code > 0) {\n+                throwIllegal(code);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void flush()\n+        throws IOException\n+    {\n+        if (_out != null) {\n+            if (_outPtr > 0) {\n+                _out.write(_outBuffer, 0, _outPtr);\n+                _outPtr = 0;\n+            }\n+            _out.flush();\n+        }\n+    }\n+\n+    @Override\n+    public void write(char[] cbuf)\n+        throws IOException\n+    {\n+        write(cbuf, 0, cbuf.length);\n+    }\n+\n+    @Override\n+    public void write(char[] cbuf, int off, int len)\n+        throws IOException\n+    {\n+        if (len < 2) {\n+            if (len == 1) {\n+                write(cbuf[off]);\n+            }\n+            return;\n+        }\n+\n+        // First: do we have a leftover surrogate to deal with?\n+        if (_surrogate > 0) {\n+            char second = cbuf[off++];\n+            --len;\n+            write(convertSurrogate(second));\n+            // will have at least one more char\n+        }\n+\n+        int outPtr = _outPtr;\n+        byte[] outBuf = _outBuffer;\n+        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n+\n+        // All right; can just loop it nice and easy now:\n+        len += off; // len will now be the end of input buffer\n+\n+        output_loop:\n+        for (; off < len; ) {\n+            /* First, let's ensure we can output at least 4 bytes\n+             * (longest UTF-8 encoded codepoint):\n+             */\n+            if (outPtr >= outBufLast) {\n+                _out.write(outBuf, 0, outPtr);\n+                outPtr = 0;\n+            }\n+\n+            int c = cbuf[off++];\n+            // And then see if we have an Ascii char:\n+            if (c < 0x80) { // If so, can do a tight inner loop:\n+                outBuf[outPtr++] = (byte)c;\n+                // Let's calc how many ascii chars we can copy at most:\n+                int maxInCount = (len - off);\n+                int maxOutCount = (outBufLast - outPtr);\n+\n+                if (maxInCount > maxOutCount) {\n+                    maxInCount = maxOutCount;\n+                }\n+                maxInCount += off;\n+                ascii_loop:\n+                while (true) {\n+                    if (off >= maxInCount) { // done with max. ascii seq\n+                        continue output_loop;\n+                    }\n+                    c = cbuf[off++];\n+                    if (c >= 0x80) {\n+                        break ascii_loop;\n+                    }\n+                    outBuf[outPtr++] = (byte) c;\n+                }\n+            }\n+\n+            // Nope, multi-byte:\n+            if (c < 0x800) { // 2-byte\n+                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n+                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n+            } else { // 3 or 4 bytes\n+                // Surrogates?\n+                if (c < SURR1_FIRST || c > SURR2_LAST) {\n+                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n+                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n+                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n+                    continue;\n+                }\n+                // Yup, a surrogate:\n+                if (c > SURR1_LAST) { // must be from first range\n+                    _outPtr = outPtr;\n+                    throwIllegal(c);\n+                }\n+                _surrogate = c;\n+                // and if so, followed by another from next range\n+                if (off >= len) { // unless we hit the end?\n+                    break;\n+                }\n+                c = convertSurrogate(cbuf[off++]);\n+                if (c > 0x10FFFF) { // illegal in JSON as well as in XML\n+                    _outPtr = outPtr;\n+                    throwIllegal(c);\n+                }\n+                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n+                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n+                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n+                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n+            }\n+        }\n+        _outPtr = outPtr;\n+    }\n+    \n+    @Override\n+    public void write(int c) throws IOException\n+    {\n+        // First; do we have a left over surrogate?\n+        if (_surrogate > 0) {\n+            c = convertSurrogate(c);\n+            // If not, do we start with a surrogate?\n+        } else if (c >= SURR1_FIRST && c <= SURR2_LAST) {\n+            // Illegal to get second part without first:\n+            if (c > SURR1_LAST) {\n+                throwIllegal(c);\n+            }\n+            // First part just needs to be held for now\n+            _surrogate = c;\n+            return;\n+        }\n+\n+        if (_outPtr >= _outBufferEnd) { // let's require enough room, first\n+            _out.write(_outBuffer, 0, _outPtr);\n+            _outPtr = 0;\n+        }\n+\n+        if (c < 0x80) { // ascii\n+            _outBuffer[_outPtr++] = (byte) c;\n+        } else {\n+            int ptr = _outPtr;\n+            if (c < 0x800) { // 2-byte\n+                _outBuffer[ptr++] = (byte) (0xc0 | (c >> 6));\n+                _outBuffer[ptr++] = (byte) (0x80 | (c & 0x3f));\n+            } else if (c <= 0xFFFF) { // 3 bytes\n+                _outBuffer[ptr++] = (byte) (0xe0 | (c >> 12));\n+                _outBuffer[ptr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n+                _outBuffer[ptr++] = (byte) (0x80 | (c & 0x3f));\n+            } else { // 4 bytes\n+                if (c > 0x10FFFF) { // illegal\n+                    throwIllegal(c);\n+                }\n+                _outBuffer[ptr++] = (byte) (0xf0 | (c >> 18));\n+                _outBuffer[ptr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n+                _outBuffer[ptr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n+                _outBuffer[ptr++] = (byte) (0x80 | (c & 0x3f));\n+            }\n+            _outPtr = ptr;\n+        }\n+    }\n+\n+    @Override\n+    public void write(String str) throws IOException\n+    {\n+        write(str, 0, str.length());\n+    }\n+\n+    @Override\n+    public void write(String str, int off, int len)  throws IOException\n+    {\n+        if (len < 2) {\n+            if (len == 1) {\n+                write(str.charAt(off));\n+            }\n+            return;\n+        }\n+\n+        // First: do we have a leftover surrogate to deal with?\n+        if (_surrogate > 0) {\n+            char second = str.charAt(off++);\n+            --len;\n+            write(convertSurrogate(second));\n+            // will have at least one more char (case of 1 char was checked earlier on)\n+        }\n+\n+        int outPtr = _outPtr;\n+        byte[] outBuf = _outBuffer;\n+        int outBufLast = _outBufferEnd; // has 4 'spare' bytes\n+\n+        // All right; can just loop it nice and easy now:\n+        len += off; // len will now be the end of input buffer\n+\n+        output_loop:\n+        for (; off < len; ) {\n+            /* First, let's ensure we can output at least 4 bytes\n+             * (longest UTF-8 encoded codepoint):\n+             */\n+            if (outPtr >= outBufLast) {\n+                _out.write(outBuf, 0, outPtr);\n+                outPtr = 0;\n+            }\n+\n+            int c = str.charAt(off++);\n+            // And then see if we have an Ascii char:\n+            if (c < 0x80) { // If so, can do a tight inner loop:\n+                outBuf[outPtr++] = (byte)c;\n+                // Let's calc how many ascii chars we can copy at most:\n+                int maxInCount = (len - off);\n+                int maxOutCount = (outBufLast - outPtr);\n+\n+                if (maxInCount > maxOutCount) {\n+                    maxInCount = maxOutCount;\n+                }\n+                maxInCount += off;\n+                ascii_loop:\n+                while (true) {\n+                    if (off >= maxInCount) { // done with max. ascii seq\n+                        continue output_loop;\n+                    }\n+                    c = str.charAt(off++);\n+                    if (c >= 0x80) {\n+                        break ascii_loop;\n+                    }\n+                    outBuf[outPtr++] = (byte) c;\n+                }\n+            }\n+\n+            // Nope, multi-byte:\n+            if (c < 0x800) { // 2-byte\n+                outBuf[outPtr++] = (byte) (0xc0 | (c >> 6));\n+                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n+            } else { // 3 or 4 bytes\n+                // Surrogates?\n+                if (c < SURR1_FIRST || c > SURR2_LAST) {\n+                    outBuf[outPtr++] = (byte) (0xe0 | (c >> 12));\n+                    outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n+                    outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n+                    continue;\n+                }\n+                // Yup, a surrogate:\n+                if (c > SURR1_LAST) { // must be from first range\n+                    _outPtr = outPtr;\n+                    throwIllegal(c);\n+                }\n+                _surrogate = c;\n+                // and if so, followed by another from next range\n+                if (off >= len) { // unless we hit the end?\n+                    break;\n+                }\n+                c = convertSurrogate(str.charAt(off++));\n+                if (c > 0x10FFFF) { // illegal, as per RFC 4627\n+                    _outPtr = outPtr;\n+                    throwIllegal(c);\n+                }\n+                outBuf[outPtr++] = (byte) (0xf0 | (c >> 18));\n+                outBuf[outPtr++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n+                outBuf[outPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n+                outBuf[outPtr++] = (byte) (0x80 | (c & 0x3f));\n+            }\n+        }\n+        _outPtr = outPtr;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to calculate UTF codepoint, from a surrogate pair.\n+     */\n+    private int convertSurrogate(int secondPart)\n+        throws IOException\n+    {\n+        int firstPart = _surrogate;\n+        _surrogate = 0;\n+\n+        // Ok, then, is the second part valid?\n+        if (secondPart < SURR2_FIRST || secondPart > SURR2_LAST) {\n+            throw new IOException(\"Broken surrogate pair: first char 0x\"+Integer.toHexString(firstPart)+\", second 0x\"+Integer.toHexString(secondPart)+\"; illegal combination\");\n+        }\n+        return 0x10000 + ((firstPart - SURR1_FIRST) << 10) + (secondPart - SURR2_FIRST);\n+    }\n+\n+    private void throwIllegal(int code)\n+        throws IOException\n+    {\n+        if (code > 0x10FFFF) { // over max?\n+            throw new IOException(\"Illegal character point (0x\"+Integer.toHexString(code)+\") to output; max is 0x10FFFF as per RFC 4627\");\n+        }\n+        if (code >= SURR1_FIRST) {\n+            if (code <= SURR1_LAST) { // Unmatched first part (closing without second part?)\n+                throw new IOException(\"Unmatched first part of surrogate pair (0x\"+Integer.toHexString(code)+\")\");\n+            }\n+            throw new IOException(\"Unmatched second part of surrogate pair (0x\"+Integer.toHexString(code)+\")\");\n+        }\n+\n+        // should we ever get this?\n+        throw new IOException(\"Illegal character point (0x\"+Integer.toHexString(code)+\") to output\");\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ByteSourceJsonBootstrapper.java\n+package com.fasterxml.jackson.core.json;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.format.InputAccessor;\n+import com.fasterxml.jackson.core.format.MatchStrength;\n+import com.fasterxml.jackson.core.io.*;\n+import com.fasterxml.jackson.core.sym.BytesToNameCanonicalizer;\n+import com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\n+\n+/**\n+ * This class is used to determine the encoding of byte stream\n+ * that is to contain JSON content. Rules are fairly simple, and\n+ * defined in JSON specification (RFC-4627 or newer), except\n+ * for BOM handling, which is a property of underlying\n+ * streams.\n+ */\n+public final class ByteSourceJsonBootstrapper\n+{\n+    final static byte UTF8_BOM_1 = (byte) 0xEF;\n+    final static byte UTF8_BOM_2 = (byte) 0xBB;\n+    final static byte UTF8_BOM_3 = (byte) 0xBF;\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+\n+    protected final IOContext _context;\n+\n+    protected final InputStream _in;\n+\n+    /*\n+    /**********************************************************\n+    /* Input buffering\n+    /**********************************************************\n+     */\n+\n+    protected final byte[] _inputBuffer;\n+\n+    private int _inputPtr;\n+\n+    private int _inputEnd;\n+\n+    /**\n+     * Flag that indicates whether buffer above is to be recycled\n+     * after being used or not.\n+     */\n+    private final boolean _bufferRecyclable;\n+\n+    /*\n+    /**********************************************************\n+    /* Input location\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Current number of input units (bytes or chars) that were processed in\n+     * previous blocks,\n+     * before contents of current input buffer.\n+     *<p>\n+     * Note: includes possible BOMs, if those were part of the input.\n+     */\n+    protected int _inputProcessed;\n+\n+    /*\n+    /**********************************************************\n+    /* Data gathered\n+    /**********************************************************\n+     */\n+\n+    protected boolean _bigEndian = true;\n+\n+    protected int _bytesPerChar = 0; // 0 means \"dunno yet\"\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    public ByteSourceJsonBootstrapper(IOContext ctxt, InputStream in)\n+    {\n+        _context = ctxt;\n+        _in = in;\n+        _inputBuffer = ctxt.allocReadIOBuffer();\n+        _inputEnd = _inputPtr = 0;\n+        _inputProcessed = 0;\n+        _bufferRecyclable = true;\n+    }\n+\n+    public ByteSourceJsonBootstrapper(IOContext ctxt, byte[] inputBuffer, int inputStart, int inputLen)\n+    {\n+        _context = ctxt;\n+        _in = null;\n+        _inputBuffer = inputBuffer;\n+        _inputPtr = inputStart;\n+        _inputEnd = (inputStart + inputLen);\n+        // Need to offset this for correct location info\n+        _inputProcessed = -inputStart;\n+        _bufferRecyclable = false;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /*  Encoding detection during bootstrapping\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method that should be called after constructing an instace.\n+     * It will figure out encoding that content uses, to allow\n+     * for instantiating a proper scanner object.\n+     */\n+    public JsonEncoding detectEncoding()\n+        throws IOException, JsonParseException\n+    {\n+        boolean foundEncoding = false;\n+\n+        // First things first: BOM handling\n+        /* Note: we can require 4 bytes to be read, since no\n+         * combination of BOM + valid JSON content can have\n+         * shorter length (shortest valid JSON content is single\n+         * digit char, but BOMs are chosen such that combination\n+         * is always at least 4 chars long)\n+         */\n+        if (ensureLoaded(4)) {\n+            int quad =  (_inputBuffer[_inputPtr] << 24)\n+                | ((_inputBuffer[_inputPtr+1] & 0xFF) << 16)\n+                | ((_inputBuffer[_inputPtr+2] & 0xFF) << 8)\n+                | (_inputBuffer[_inputPtr+3] & 0xFF);\n+            \n+            if (handleBOM(quad)) {\n+                foundEncoding = true;\n+            } else {\n+                /* If no BOM, need to auto-detect based on first char;\n+                 * this works since it must be 7-bit ascii (wrt. unicode\n+                 * compatible encodings, only ones JSON can be transferred\n+                 * over)\n+                 */\n+                // UTF-32?\n+                if (checkUTF32(quad)) {\n+                    foundEncoding = true;\n+                } else if (checkUTF16(quad >>> 16)) {\n+                    foundEncoding = true;\n+                }\n+            }\n+        } else if (ensureLoaded(2)) {\n+            int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n+                | (_inputBuffer[_inputPtr+1] & 0xFF);\n+            if (checkUTF16(i16)) {\n+                foundEncoding = true;\n+            }\n+        }\n+\n+        JsonEncoding enc;\n+\n+        /* Not found yet? As per specs, this means it must be UTF-8. */\n+        if (!foundEncoding) {\n+            enc = JsonEncoding.UTF8;\n+        } else {\n+            switch (_bytesPerChar) {\n+            case 1:\n+                enc = JsonEncoding.UTF8;\n+                break;\n+            case 2:\n+                enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\n+                break;\n+            case 4:\n+                enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\n+                break;\n+            default:\n+                throw new RuntimeException(\"Internal error\"); // should never get here\n+            }\n+        }\n+        _context.setEncoding(enc);\n+        return enc;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Constructing a Reader\n+    /**********************************************************\n+     */\n+    \n+    public Reader constructReader()\n+        throws IOException\n+    {\n+        JsonEncoding enc = _context.getEncoding();\n+        switch (enc) { \n+        case UTF32_BE:\n+        case UTF32_LE:\n+            return new UTF32Reader(_context, _in, _inputBuffer, _inputPtr, _inputEnd,\n+                                   _context.getEncoding().isBigEndian());\n+\n+        case UTF16_BE:\n+        case UTF16_LE:\n+        case UTF8: // only in non-common case where we don't want to do direct mapping\n+            {\n+                // First: do we have a Stream? If not, need to create one:\n+                InputStream in = _in;\n+\n+                if (in == null) {\n+                    in = new ByteArrayInputStream(_inputBuffer, _inputPtr, _inputEnd);\n+                } else {\n+                    /* Also, if we have any read but unused input (usually true),\n+                     * need to merge that input in:\n+                     */\n+                    if (_inputPtr < _inputEnd) {\n+                        in = new MergedStream(_context, in, _inputBuffer, _inputPtr, _inputEnd);\n+                    }\n+                }\n+                return new InputStreamReader(in, enc.getJavaName());\n+            }\n+        }\n+        throw new RuntimeException(\"Internal error\"); // should never get here\n+    }\n+\n+    public JsonParser constructParser(int features, ObjectCodec codec, BytesToNameCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols)\n+        throws IOException, JsonParseException\n+    {\n+        JsonEncoding enc = detectEncoding();\n+\n+        // As per [JACKSON-259], may want to fully disable canonicalization:\n+        boolean canonicalize = JsonParser.Feature.CANONICALIZE_FIELD_NAMES.enabledIn(features);\n+        boolean intern = JsonParser.Feature.INTERN_FIELD_NAMES.enabledIn(features);\n+        if (enc == JsonEncoding.UTF8) {\n+            /* and without canonicalization, byte-based approach is not performance; just use std UTF-8 reader\n+             * (which is ok for larger input; not so hot for smaller; but this is not a common case)\n+             */\n+            if (canonicalize) {\n+                BytesToNameCanonicalizer can = rootByteSymbols.makeChild(canonicalize, intern);\n+                return new UTF8StreamJsonParser(_context, features, _in, codec, can, _inputBuffer, _inputPtr, _inputEnd, _bufferRecyclable);\n+            }\n+        }\n+        return new ReaderBasedJsonParser(_context, features, constructReader(), codec, rootCharSymbols.makeChild(canonicalize, intern));\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /*  Encoding detection for data format auto-detection\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Current implementation is not as thorough as other functionality\n+     * ({@link com.fasterxml.jackson.core.json.ByteSourceJsonBootstrapper}); \n+     * supports UTF-8, for example. But it should work, for now, and can\n+     * be improved as necessary.\n+     * \n+     * @since 1.8\n+     */\n+    public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException\n+    {\n+        // Ideally we should see \"[\" or \"{\"; but if not, we'll accept double-quote (String)\n+        // in future could also consider accepting non-standard matches?\n+        \n+        if (!acc.hasMoreBytes()) {\n+            return MatchStrength.INCONCLUSIVE;\n+        }\n+        byte b = acc.nextByte();\n+        // Very first thing, a UTF-8 BOM?\n+        if (b == UTF8_BOM_1) { // yes, looks like UTF-8 BOM\n+            if (!acc.hasMoreBytes()) {\n+                return MatchStrength.INCONCLUSIVE;\n+            }\n+            if (acc.nextByte() != UTF8_BOM_2) {\n+                return MatchStrength.NO_MATCH;\n+            }\n+            if (!acc.hasMoreBytes()) {\n+                return MatchStrength.INCONCLUSIVE;\n+            }\n+            if (acc.nextByte() != UTF8_BOM_3) {\n+                return MatchStrength.NO_MATCH;\n+            }\n+            if (!acc.hasMoreBytes()) {\n+                return MatchStrength.INCONCLUSIVE;\n+            }\n+            b = acc.nextByte();\n+        }\n+        // Then possible leading space\n+        int ch = skipSpace(acc, b);\n+        if (ch < 0) {\n+            return MatchStrength.INCONCLUSIVE;\n+        }\n+        // First, let's see if it looks like a structured type:\n+        if (ch == '{') { // JSON object?\n+            // Ideally we need to find either double-quote or closing bracket\n+            ch = skipSpace(acc);\n+            if (ch < 0) {\n+                return MatchStrength.INCONCLUSIVE;\n+            }\n+            if (ch == '\"' || ch == '}') {\n+                return MatchStrength.SOLID_MATCH;\n+            }\n+            // ... should we allow non-standard? Let's not yet... can add if need be\n+            return MatchStrength.NO_MATCH;\n+        }\n+        MatchStrength strength;\n+        \n+        if (ch == '[') {\n+            ch = skipSpace(acc);\n+            if (ch < 0) {\n+                return MatchStrength.INCONCLUSIVE;\n+            }\n+            // closing brackets is easy; but for now, let's also accept opening...\n+            if (ch == ']' || ch == '[') {\n+                return MatchStrength.SOLID_MATCH;\n+            }\n+            return MatchStrength.SOLID_MATCH;\n+        } else {\n+            // plain old value is not very convincing...\n+            strength = MatchStrength.WEAK_MATCH;\n+        }\n+\n+        if (ch == '\"') { // string value\n+            return strength;\n+        }\n+        if (ch <= '9' && ch >= '0') { // number\n+            return strength;\n+        }\n+        if (ch == '-') { // negative number\n+            ch = skipSpace(acc);\n+            if (ch < 0) {\n+                return MatchStrength.INCONCLUSIVE;\n+            }\n+            return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH;\n+        }\n+        // or one of literals\n+        if (ch == 'n') { // null\n+            return tryMatch(acc, \"ull\", strength);\n+        }\n+        if (ch == 't') { // true\n+            return tryMatch(acc, \"rue\", strength);\n+        }\n+        if (ch == 'f') { // false\n+            return tryMatch(acc, \"alse\", strength);\n+        }\n+        return MatchStrength.NO_MATCH;\n+    }\n+\n+    private final static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength)\n+        throws IOException\n+    {\n+        for (int i = 0, len = matchStr.length(); i < len; ++i) {\n+            if (!acc.hasMoreBytes()) {\n+                return MatchStrength.INCONCLUSIVE;\n+            }\n+            if (acc.nextByte() != matchStr.charAt(i)) {\n+                return MatchStrength.NO_MATCH;\n+            }\n+        }\n+        return fullMatchStrength;\n+    }\n+    \n+    private final static int skipSpace(InputAccessor acc) throws IOException\n+    {\n+        if (!acc.hasMoreBytes()) {\n+            return -1;\n+        }\n+        return skipSpace(acc, acc.nextByte());\n+    }\n+    \n+    private final static int skipSpace(InputAccessor acc, byte b) throws IOException\n+    {\n+        while (true) {\n+            int ch = (int) b & 0xFF;\n+            if (!(ch == ' ' || ch == '\\r' || ch == '\\n' || ch == '\\t')) {\n+                return ch;\n+            }\n+            if (!acc.hasMoreBytes()) {\n+                return -1;\n+            }\n+            b = acc.nextByte();\n+            ch = (int) b & 0xFF;\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Internal methods, parsing\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @return True if a BOM was succesfully found, and encoding\n+     *   thereby recognized.\n+     */\n+    private boolean handleBOM(int quad)\n+        throws IOException\n+    {\n+        /* Handling of (usually) optional BOM (required for\n+         * multi-byte formats); first 32-bit charsets:\n+         */\n+        switch (quad) {\n+        case 0x0000FEFF:\n+            _bigEndian = true;\n+            _inputPtr += 4;\n+            _bytesPerChar = 4;\n+            return true;\n+        case 0xFFFE0000: // UCS-4, LE?\n+            _inputPtr += 4;\n+            _bytesPerChar = 4;\n+            _bigEndian = false;\n+            return true;\n+        case 0x0000FFFE: // UCS-4, in-order...\n+            reportWeirdUCS4(\"2143\"); // throws exception\n+        case 0xFEFF0000: // UCS-4, in-order...\n+            reportWeirdUCS4(\"3412\"); // throws exception\n+        }\n+        // Ok, if not, how about 16-bit encoding BOMs?\n+        int msw = quad >>> 16;\n+        if (msw == 0xFEFF) { // UTF-16, BE\n+            _inputPtr += 2;\n+            _bytesPerChar = 2;\n+            _bigEndian = true;\n+            return true;\n+        }\n+        if (msw == 0xFFFE) { // UTF-16, LE\n+            _inputPtr += 2;\n+            _bytesPerChar = 2;\n+            _bigEndian = false;\n+            return true;\n+        }\n+        // And if not, then UTF-8 BOM?\n+        if ((quad >>> 8) == 0xEFBBBF) { // UTF-8\n+            _inputPtr += 3;\n+            _bytesPerChar = 1;\n+            _bigEndian = true; // doesn't really matter\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private boolean checkUTF32(int quad)\n+        throws IOException\n+    {\n+        /* Handling of (usually) optional BOM (required for\n+         * multi-byte formats); first 32-bit charsets:\n+         */\n+        if ((quad >> 8) == 0) { // 0x000000?? -> UTF32-BE\n+            _bigEndian = true;\n+        } else if ((quad & 0x00FFFFFF) == 0) { // 0x??000000 -> UTF32-LE\n+            _bigEndian = false;\n+        } else if ((quad & ~0x00FF0000) == 0) { // 0x00??0000 -> UTF32-in-order\n+            reportWeirdUCS4(\"3412\");\n+        } else if ((quad & ~0x0000FF00) == 0) { // 0x0000??00 -> UTF32-in-order\n+            reportWeirdUCS4(\"2143\");\n+        } else {\n+            // Can not be valid UTF-32 encoded JSON...\n+            return false;\n+        }\n+        // Not BOM (just regular content), nothing to skip past:\n+        //_inputPtr += 4;\n+        _bytesPerChar = 4;\n+        return true;\n+    }\n+\n+    private boolean checkUTF16(int i16)\n+    {\n+        if ((i16 & 0xFF00) == 0) { // UTF-16BE\n+            _bigEndian = true;\n+        } else if ((i16 & 0x00FF) == 0) { // UTF-16LE\n+            _bigEndian = false;\n+        } else { // nope, not  UTF-16\n+            return false;\n+        }\n+        // Not BOM (just regular content), nothing to skip past:\n+        //_inputPtr += 2;\n+        _bytesPerChar = 2;\n+        return true;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods, problem reporting\n+    /**********************************************************\n+     */\n+\n+    private void reportWeirdUCS4(String type)\n+        throws IOException\n+    {\n+        throw new CharConversionException(\"Unsupported UCS-4 endianness (\"+type+\") detected\");\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods, raw input access\n+    /**********************************************************\n+     */\n+\n+    protected boolean ensureLoaded(int minimum)\n+        throws IOException\n+    {\n+        /* Let's assume here buffer has enough room -- this will always\n+         * be true for the limited used this method gets\n+         */\n+        int gotten = (_inputEnd - _inputPtr);\n+        while (gotten < minimum) {\n+            int count;\n+\n+            if (_in == null) { // block source\n+                count = -1;\n+            } else {\n+                count = _in.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd);\n+            }\n+            if (count < 1) {\n+                return false;\n+            }\n+            _inputEnd += count;\n+            gotten += count;\n+        }\n+        return true;\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonReadContext.java\n+package com.fasterxml.jackson.core.json;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.io.CharTypes;\n+\n+/**\n+ * Extension of {@link JsonStreamContext}, which implements\n+ * core methods needed, and also exposes\n+ * more complete API to parser implementation classes.\n+ */\n+public final class JsonReadContext\n+    extends JsonStreamContext\n+{\n+    // // // Configuration\n+\n+    protected final JsonReadContext _parent;\n+\n+    // // // Location information (minus source reference)\n+\n+    protected int _lineNr;\n+    protected int _columnNr;\n+\n+    protected String _currentName;\n+\n+    /*\n+    /**********************************************************\n+    /* Simple instance reuse slots; speeds up things\n+    /* a bit (10-15%) for docs with lots of small\n+    /* arrays/objects (for which allocation was\n+    /* visible in profile stack frames)\n+    /**********************************************************\n+     */\n+\n+    protected JsonReadContext _child = null;\n+\n+    /*\n+    /**********************************************************\n+    /* Instance construction, reuse\n+    /**********************************************************\n+     */\n+\n+    public JsonReadContext(JsonReadContext parent, int type, int lineNr, int colNr)\n+    {\n+        super();\n+        _type = type;\n+        _parent = parent;\n+        _lineNr = lineNr;\n+        _columnNr = colNr;\n+        _index = -1;\n+    }\n+\n+    protected final void reset(int type, int lineNr, int colNr)\n+    {\n+        _type = type;\n+        _index = -1;\n+        _lineNr = lineNr;\n+        _columnNr = colNr;\n+        _currentName = null;\n+    }\n+\n+    // // // Factory methods\n+\n+    public static JsonReadContext createRootContext(int lineNr, int colNr)\n+    {\n+        return new JsonReadContext(null, TYPE_ROOT, lineNr, colNr);\n+    }\n+\n+    /**\n+     * @since 1.9\n+     */\n+    public static JsonReadContext createRootContext()\n+    {\n+        return new JsonReadContext(null, TYPE_ROOT, 1, 0);\n+    }\n+    \n+    public final JsonReadContext createChildArrayContext(int lineNr, int colNr)\n+    {\n+        JsonReadContext ctxt = _child;\n+        if (ctxt == null) {\n+            _child = ctxt = new JsonReadContext(this, TYPE_ARRAY, lineNr, colNr);\n+            return ctxt;\n+        }\n+        ctxt.reset(TYPE_ARRAY, lineNr, colNr);\n+        return ctxt;\n+    }\n+\n+    public final JsonReadContext createChildObjectContext(int lineNr, int colNr)\n+    {\n+        JsonReadContext ctxt = _child;\n+        if (ctxt == null) {\n+            _child = ctxt = new JsonReadContext(this, TYPE_OBJECT, lineNr, colNr);\n+            return ctxt;\n+        }\n+        ctxt.reset(TYPE_OBJECT, lineNr, colNr);\n+        return ctxt;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Abstract method implementation\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public final String getCurrentName() { return _currentName; }\n+\n+    @Override\n+    public final JsonReadContext getParent() { return _parent; }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended API\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @return Location pointing to the point where the context\n+     *   start marker was found\n+     */\n+    public final JsonLocation getStartLocation(Object srcRef)\n+    {\n+        /* We don't keep track of offsets at this level (only\n+         * reader does)\n+         */\n+        long totalChars = -1L;\n+\n+        return new JsonLocation(srcRef, totalChars, _lineNr, _columnNr);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* State changes\n+    /**********************************************************\n+     */\n+\n+    public final boolean expectComma()\n+    {\n+        /* Assumption here is that we will be getting a value (at least\n+         * before calling this method again), and\n+         * so will auto-increment index to avoid having to do another call\n+         */\n+        int ix = ++_index; // starts from -1\n+        return (_type != TYPE_ROOT && ix > 0);\n+    }\n+\n+    public void setCurrentName(String name)\n+    {\n+        _currentName = name;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridden standard methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Overridden to provide developer readable \"JsonPath\" representation\n+     * of the context.\n+     */\n+    @Override\n+    public final String toString()\n+    {\n+        StringBuilder sb = new StringBuilder(64);\n+        switch (_type) {\n+        case TYPE_ROOT:\n+            sb.append(\"/\");\n+            break;\n+        case TYPE_ARRAY:\n+            sb.append('[');\n+            sb.append(getCurrentIndex());\n+            sb.append(']');\n+            break;\n+        case TYPE_OBJECT:\n+            sb.append('{');\n+            if (_currentName != null) {\n+                sb.append('\"');\n+                CharTypes.appendQuoted(sb, _currentName);\n+                sb.append('\"');\n+            } else {\n+                sb.append('?');\n+            }\n+            sb.append('}');\n+            break;\n+        }\n+        return sb.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java\n+package com.fasterxml.jackson.core.json;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+/**\n+ * Extension of {@link JsonStreamContext}, which implements\n+ * core methods needed, and also exposes\n+ * more complete API to generator implementation classes.\n+ */\n+public class JsonWriteContext\n+    extends JsonStreamContext\n+{\n+    // // // Return values for writeValue()\n+\n+    public final static int STATUS_OK_AS_IS = 0;\n+    public final static int STATUS_OK_AFTER_COMMA = 1;\n+    public final static int STATUS_OK_AFTER_COLON = 2;\n+    public final static int STATUS_OK_AFTER_SPACE = 3; // in root context\n+    public final static int STATUS_EXPECT_VALUE = 4;\n+    public final static int STATUS_EXPECT_NAME = 5;\n+\n+    protected final JsonWriteContext _parent;\n+\n+    /**\n+     * Name of the field of which value is to be parsed; only\n+     * used for OBJECT contexts\n+     */\n+    protected String _currentName;\n+    \n+    /*\n+    /**********************************************************\n+    /* Simple instance reuse slots; speed up things\n+    /* a bit (10-15%) for docs with lots of small\n+    /* arrays/objects\n+    /**********************************************************\n+     */\n+\n+    protected JsonWriteContext _child = null;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    protected JsonWriteContext(int type, JsonWriteContext parent)\n+    {\n+        super();\n+        _type = type;\n+        _parent = parent;\n+        _index = -1;\n+    }\n+    \n+    // // // Factory methods\n+\n+    public static JsonWriteContext createRootContext()\n+    {\n+        return new JsonWriteContext(TYPE_ROOT, null);\n+    }\n+\n+    private final JsonWriteContext reset(int type) {\n+        _type = type;\n+        _index = -1;\n+        _currentName = null;\n+        return this;\n+    }\n+    \n+    public final JsonWriteContext createChildArrayContext()\n+    {\n+        JsonWriteContext ctxt = _child;\n+        if (ctxt == null) {\n+            _child = ctxt = new JsonWriteContext(TYPE_ARRAY, this);\n+            return ctxt;\n+        }\n+        return ctxt.reset(TYPE_ARRAY);\n+    }\n+\n+    public final JsonWriteContext createChildObjectContext()\n+    {\n+        JsonWriteContext ctxt = _child;\n+        if (ctxt == null) {\n+            _child = ctxt = new JsonWriteContext(TYPE_OBJECT, this);\n+            return ctxt;\n+        }\n+        return ctxt.reset(TYPE_OBJECT);\n+    }\n+\n+    // // // Shared API\n+\n+    @Override\n+    public final JsonWriteContext getParent() { return _parent; }\n+\n+    @Override\n+    public final String getCurrentName() { return _currentName; }\n+    \n+    // // // API sub-classes are to implement\n+\n+    /**\n+     * Method that writer is to call before it writes a field name.\n+     *\n+     * @return Index of the field entry (0-based)\n+     */\n+    public final int writeFieldName(String name)\n+    {\n+        if (_type == TYPE_OBJECT) {\n+            if (_currentName != null) { // just wrote a name...\n+                return STATUS_EXPECT_VALUE;\n+            }\n+            _currentName = name;\n+            return (_index < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA;\n+        }\n+        return STATUS_EXPECT_VALUE;\n+    }\n+    \n+    public final int writeValue()\n+    {\n+        // Most likely, object:\n+        if (_type == TYPE_OBJECT) {\n+            if (_currentName == null) {\n+                return STATUS_EXPECT_NAME;\n+            }\n+            _currentName = null;\n+            ++_index;\n+            return STATUS_OK_AFTER_COLON;\n+        }\n+\n+        // Ok, array?\n+        if (_type == TYPE_ARRAY) {\n+            int ix = _index;\n+            ++_index;\n+            return (ix < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA;\n+        }\n+        \n+        // Nope, root context\n+        // No commas within root context, but need space\n+        ++_index;\n+        return (_index == 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE;\n+    }\n+\n+    // // // Internally used abstract methods\n+\n+    protected final void appendDesc(StringBuilder sb)\n+    {\n+        if (_type == TYPE_OBJECT) {\n+            sb.append('{');\n+            if (_currentName != null) {\n+                sb.append('\"');\n+                // !!! TODO: Name chars should be escaped?\n+                sb.append(_currentName);\n+                sb.append('\"');\n+            } else {\n+                sb.append('?');\n+            }\n+            sb.append('}');\n+        } else if (_type == TYPE_ARRAY) {\n+            sb.append('[');\n+            sb.append(getCurrentIndex());\n+            sb.append(']');\n+        } else {\n+            // nah, ROOT:\n+            sb.append(\"/\");\n+        }\n+    }\n+\n+    // // // Overridden standard methods\n+\n+    /**\n+     * Overridden to provide developer writeable \"JsonPath\" representation\n+     * of the context.\n+     */\n+    @Override\n+    public final String toString()\n+    {\n+        StringBuilder sb = new StringBuilder(64);\n+        appendDesc(sb);\n+        return sb.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+package com.fasterxml.jackson.core.json;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.base.ParserBase;\n+import com.fasterxml.jackson.core.io.CharTypes;\n+import com.fasterxml.jackson.core.io.IOContext;\n+import com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\n+import com.fasterxml.jackson.core.util.*;\n+\n+/**\n+ * This is a concrete implementation of {@link JsonParser}, which is\n+ * based on a {@link java.io.Reader} to handle low-level character\n+ * conversion tasks.\n+ */\n+public final class ReaderBasedJsonParser\n+    extends ParserBase\n+{\n+    /*\n+    /**********************************************************\n+    /* Input configuration\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Reader that can be used for reading more content, if one\n+     * buffer from input source, but in some cases pre-loaded buffer\n+     * is handed to the parser.\n+     */\n+    protected Reader _reader;\n+\n+    /**\n+     * Current buffer from which data is read; generally data is read into\n+     * buffer from input source.\n+     */\n+    protected char[] _inputBuffer;\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+\n+    protected ObjectCodec _objectCodec;\n+\n+    final protected CharsToNameCanonicalizer _symbols;\n+\n+    /*\n+    /**********************************************************\n+    /* Parsing state\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Flag that indicates that the current token has not yet\n+     * been fully processed, and needs to be finished for\n+     * some access (or skipped to obtain the next token)\n+     */\n+    protected boolean _tokenIncomplete = false;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n+                             ObjectCodec codec, CharsToNameCanonicalizer st)\n+    {\n+        super(ctxt, features);\n+        _reader = r;\n+        _inputBuffer = ctxt.allocTokenBuffer();\n+        _objectCodec = codec;\n+        _symbols = st;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Base method defs, overrides\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public ObjectCodec getCodec() {\n+        return _objectCodec;\n+    }\n+\n+    @Override\n+    public void setCodec(ObjectCodec c) {\n+        _objectCodec = c;\n+    }\n+\n+    @Override\n+    public int releaseBuffered(Writer w) throws IOException\n+    {\n+        int count = _inputEnd - _inputPtr;\n+        if (count < 1) {\n+            return 0;\n+        }\n+        // let's just advance ptr to end\n+        int origPtr = _inputPtr;\n+        w.write(_inputBuffer, origPtr, count);\n+        return count;\n+    }\n+\n+    @Override\n+    public Object getInputSource() {\n+        return _reader;\n+    }\n+\n+    @Override\n+    protected final boolean loadMore() throws IOException\n+    {\n+        _currInputProcessed += _inputEnd;\n+        _currInputRowStart -= _inputEnd;\n+\n+        if (_reader != null) {\n+            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n+            if (count > 0) {\n+                _inputPtr = 0;\n+                _inputEnd = count;\n+                return true;\n+            }\n+            // End of input\n+            _closeInput();\n+            // Should never return 0, so let's fail\n+            if (count == 0) {\n+                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n+            }\n+        }\n+        return false;\n+    }\n+\n+    protected char getNextChar(String eofMsg)\n+        throws IOException, JsonParseException\n+    {\n+        if (_inputPtr >= _inputEnd) {\n+            if (!loadMore()) {\n+                _reportInvalidEOF(eofMsg);\n+            }\n+        }\n+        return _inputBuffer[_inputPtr++];\n+    }\n+\n+    @Override\n+    protected void _closeInput() throws IOException\n+    {\n+        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n+         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n+         *   feature is enabled.\n+         *   One downside is that when using our optimized\n+         *   Reader (granted, we only do that for UTF-32...) this\n+         *   means that buffer recycling won't work correctly.\n+         */\n+        if (_reader != null) {\n+            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n+                _reader.close();\n+            }\n+            _reader = null;\n+        }\n+    }\n+\n+    /**\n+     * Method called to release internal buffers owned by the base\n+     * reader. This may be called along with {@link #_closeInput} (for\n+     * example, when explicitly closing this reader instance), or\n+     * separately (if need be).\n+     */\n+    @Override\n+    protected void _releaseBuffers()\n+        throws IOException\n+    {\n+        super._releaseBuffers();\n+        char[] buf = _inputBuffer;\n+        if (buf != null) {\n+            _inputBuffer = null;\n+            _ioContext.releaseTokenBuffer(buf);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, data access\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method for accessing textual representation of the current event;\n+     * if no current event (before first call to {@link #nextToken}, or\n+     * after encountering end-of-input), returns null.\n+     * Method can be called for any event.\n+     */\n+    @Override\n+    public final String getText()\n+        throws IOException, JsonParseException\n+    {\n+        JsonToken t = _currToken;\n+        if (t == JsonToken.VALUE_STRING) {\n+            if (_tokenIncomplete) {\n+                _tokenIncomplete = false;\n+                _finishString(); // only strings can be incomplete\n+            }\n+            return _textBuffer.contentsAsString();\n+        }\n+        return _getText2(t);\n+    }\n+    \n+    protected final String _getText2(JsonToken t)\n+    {\n+        if (t == null) {\n+            return null;\n+        }\n+        switch (t) {\n+        case FIELD_NAME:\n+            return _parsingContext.getCurrentName();\n+\n+        case VALUE_STRING:\n+            // fall through\n+        case VALUE_NUMBER_INT:\n+        case VALUE_NUMBER_FLOAT:\n+            return _textBuffer.contentsAsString();\n+        }\n+        return t.asString();\n+    }\n+\n+    @Override\n+    public char[] getTextCharacters()\n+        throws IOException, JsonParseException\n+    {\n+        if (_currToken != null) { // null only before/after document\n+            switch (_currToken) {\n+                \n+            case FIELD_NAME:\n+                if (!_nameCopied) {\n+                    String name = _parsingContext.getCurrentName();\n+                    int nameLen = name.length();\n+                    if (_nameCopyBuffer == null) {\n+                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n+                    } else if (_nameCopyBuffer.length < nameLen) {\n+                        _nameCopyBuffer = new char[nameLen];\n+                    }\n+                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n+                    _nameCopied = true;\n+                }\n+                return _nameCopyBuffer;\n+    \n+            case VALUE_STRING:\n+                if (_tokenIncomplete) {\n+                    _tokenIncomplete = false;\n+                    _finishString(); // only strings can be incomplete\n+                }\n+                // fall through\n+            case VALUE_NUMBER_INT:\n+            case VALUE_NUMBER_FLOAT:\n+                return _textBuffer.getTextBuffer();\n+                \n+            default:\n+                return _currToken.asCharArray();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public int getTextLength()\n+        throws IOException, JsonParseException\n+    {\n+        if (_currToken != null) { // null only before/after document\n+            switch (_currToken) {\n+                \n+            case FIELD_NAME:\n+                return _parsingContext.getCurrentName().length();\n+            case VALUE_STRING:\n+                if (_tokenIncomplete) {\n+                    _tokenIncomplete = false;\n+                    _finishString(); // only strings can be incomplete\n+                }\n+                // fall through\n+            case VALUE_NUMBER_INT:\n+            case VALUE_NUMBER_FLOAT:\n+                return _textBuffer.size();\n+                \n+            default:\n+                return _currToken.asCharArray().length;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getTextOffset() throws IOException, JsonParseException\n+    {\n+        // Most have offset of 0, only some may have other values:\n+        if (_currToken != null) {\n+            switch (_currToken) {\n+            case FIELD_NAME:\n+                return 0;\n+            case VALUE_STRING:\n+                if (_tokenIncomplete) {\n+                    _tokenIncomplete = false;\n+                    _finishString(); // only strings can be incomplete\n+                }\n+                // fall through\n+            case VALUE_NUMBER_INT:\n+            case VALUE_NUMBER_FLOAT:\n+                return _textBuffer.getTextOffset();\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    @Override\n+    public byte[] getBinaryValue(Base64Variant b64variant)\n+        throws IOException, JsonParseException\n+    {\n+        if (_currToken != JsonToken.VALUE_STRING &&\n+                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n+            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n+        }\n+        /* To ensure that we won't see inconsistent data, better clear up\n+         * state...\n+         */\n+        if (_tokenIncomplete) {\n+            try {\n+                _binaryValue = _decodeBase64(b64variant);\n+            } catch (IllegalArgumentException iae) {\n+                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n+            }\n+            /* let's clear incomplete only now; allows for accessing other\n+             * textual content in error cases\n+             */\n+            _tokenIncomplete = false;\n+        } else { // may actually require conversion...\n+            if (_binaryValue == null) {\n+                ByteArrayBuilder builder = _getByteArrayBuilder();\n+                _decodeBase64(getText(), builder, b64variant);\n+                _binaryValue = builder.toByteArray();\n+            }\n+        }\n+        return _binaryValue;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, traversal\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @return Next token from the stream, if any found, or null\n+     *   to indicate end-of-input\n+     */\n+    @Override\n+    public JsonToken nextToken()\n+        throws IOException, JsonParseException\n+    {\n+        _numTypesValid = NR_UNKNOWN;\n+\n+        /* First: field names are special -- we will always tokenize\n+         * (part of) value along with field name to simplify\n+         * state handling. If so, can and need to use secondary token:\n+         */\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+            return _nextAfterName();\n+        }\n+        if (_tokenIncomplete) {\n+            _skipString(); // only strings can be partial\n+        }\n+        int i = _skipWSOrEnd();\n+        if (i < 0) { // end-of-input\n+            /* 19-Feb-2009, tatu: Should actually close/release things\n+             *    like input source, symbol table and recyclable buffers now.\n+             */\n+            close();\n+            return (_currToken = null);\n+        }\n+\n+        /* First, need to ensure we know the starting location of token\n+         * after skipping leading white space\n+         */\n+        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n+        _tokenInputRow = _currInputRow;\n+        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n+\n+        // finally: clear any data retained so far\n+        _binaryValue = null;\n+\n+        // Closing scope?\n+        if (i == INT_RBRACKET) {\n+            if (!_parsingContext.inArray()) {\n+                _reportMismatchedEndMarker(i, '}');\n+            }\n+            _parsingContext = _parsingContext.getParent();\n+            return (_currToken = JsonToken.END_ARRAY);\n+        }\n+        if (i == INT_RCURLY) {\n+            if (!_parsingContext.inObject()) {\n+                _reportMismatchedEndMarker(i, ']');\n+            }\n+            _parsingContext = _parsingContext.getParent();\n+            return (_currToken = JsonToken.END_OBJECT);\n+        }\n+\n+        // Nope: do we then expect a comma?\n+        if (_parsingContext.expectComma()) {\n+            if (i != INT_COMMA) {\n+                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n+            }\n+            i = _skipWS();\n+        }\n+\n+        /* And should we now have a name? Always true for\n+         * Object contexts, since the intermediate 'expect-value'\n+         * state is never retained.\n+         */\n+        boolean inObject = _parsingContext.inObject();\n+        if (inObject) {\n+           // First, field name itself:\n+            String name = _parseFieldName(i);\n+            _parsingContext.setCurrentName(name);\n+            _currToken = JsonToken.FIELD_NAME;\n+            i = _skipWS();\n+            if (i != INT_COLON) {\n+                _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n+            }\n+            i = _skipWS();\n+        }\n+\n+        // Ok: we must have a value... what is it?\n+\n+        JsonToken t;\n+\n+        switch (i) {\n+        case INT_QUOTE:\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case INT_LBRACKET:\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case INT_LCURLY:\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case INT_RBRACKET:\n+        case INT_RCURLY:\n+            // Error: neither is valid at this point; valid closers have\n+            // been handled earlier\n+            _reportUnexpectedChar(i, \"expected a value\");\n+        case INT_t:\n+            _matchToken(\"true\", 1);\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case INT_f:\n+            _matchToken(\"false\", 1);\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case INT_n:\n+            _matchToken(\"null\", 1);\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+\n+        case INT_MINUS:\n+            /* Should we have separate handling for plus? Although\n+             * it is not allowed per se, it may be erroneously used,\n+             * and could be indicate by a more specific error message.\n+             */\n+        case INT_0:\n+        case INT_1:\n+        case INT_2:\n+        case INT_3:\n+        case INT_4:\n+        case INT_5:\n+        case INT_6:\n+        case INT_7:\n+        case INT_8:\n+        case INT_9:\n+            t = parseNumberText(i);\n+            break;\n+        default:\n+            t = _handleUnexpectedValue(i);\n+            break;\n+        }\n+\n+        if (inObject) {\n+            _nextToken = t;\n+            return _currToken;\n+        }\n+        _currToken = t;\n+        return t;\n+    }\n+\n+    private final JsonToken _nextAfterName()\n+    {\n+        _nameCopied = false; // need to invalidate if it was copied\n+        JsonToken t = _nextToken;\n+        _nextToken = null;\n+        // Also: may need to start new context?\n+        if (t == JsonToken.START_ARRAY) {\n+            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+        } else if (t == JsonToken.START_OBJECT) {\n+            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+        }\n+        return (_currToken = t);\n+    }\n+\n+    /*\n+    @Override\n+    public boolean nextFieldName(SerializableString str)\n+         throws IOException, JsonParseException\n+     */\n+\n+    // note: identical to one in Utf8StreamParser\n+    @Override\n+    public String nextTextValue()\n+        throws IOException, JsonParseException\n+    {\n+        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n+            _nameCopied = false;\n+            JsonToken t = _nextToken;\n+            _nextToken = null;\n+            _currToken = t;\n+            if (t == JsonToken.VALUE_STRING) {\n+                if (_tokenIncomplete) {\n+                    _tokenIncomplete = false;\n+                    _finishString();\n+                }\n+                return _textBuffer.contentsAsString();\n+            }\n+            if (t == JsonToken.START_ARRAY) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            } else if (t == JsonToken.START_OBJECT) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            return null;\n+        }\n+        // !!! TODO: optimize this case as well\n+        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n+    }\n+\n+    // note: identical to one in Utf8StreamParser\n+    @Override\n+    public int nextIntValue(int defaultValue)\n+        throws IOException, JsonParseException\n+    {\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+            _nameCopied = false;\n+            JsonToken t = _nextToken;\n+            _nextToken = null;\n+            _currToken = t;\n+            if (t == JsonToken.VALUE_NUMBER_INT) {\n+                return getIntValue();\n+            }\n+            if (t == JsonToken.START_ARRAY) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            } else if (t == JsonToken.START_OBJECT) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            return defaultValue;\n+        }\n+        // !!! TODO: optimize this case as well\n+        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n+    }\n+\n+    // note: identical to one in Utf8StreamParser\n+    @Override\n+    public long nextLongValue(long defaultValue)\n+        throws IOException, JsonParseException\n+    {\n+        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n+            _nameCopied = false;\n+            JsonToken t = _nextToken;\n+            _nextToken = null;\n+            _currToken = t;\n+            if (t == JsonToken.VALUE_NUMBER_INT) {\n+                return getLongValue();\n+            }\n+            if (t == JsonToken.START_ARRAY) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            } else if (t == JsonToken.START_OBJECT) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            return defaultValue;\n+        }\n+        // !!! TODO: optimize this case as well\n+        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n+    }\n+\n+    // note: identical to one in Utf8StreamParser\n+    @Override\n+    public Boolean nextBooleanValue()\n+        throws IOException, JsonParseException\n+    {\n+        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n+            _nameCopied = false;\n+            JsonToken t = _nextToken;\n+            _nextToken = null;\n+            _currToken = t;\n+            if (t == JsonToken.VALUE_TRUE) {\n+                return Boolean.TRUE;\n+            }\n+            if (t == JsonToken.VALUE_FALSE) {\n+                return Boolean.FALSE;\n+            }\n+            if (t == JsonToken.START_ARRAY) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            } else if (t == JsonToken.START_OBJECT) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            return null;\n+        }\n+        switch (nextToken()) {\n+        case VALUE_TRUE:\n+            return Boolean.TRUE;\n+        case VALUE_FALSE:\n+            return Boolean.FALSE;\n+        }\n+        return null;\n+    }\n+    \n+    @Override\n+    public void close() throws IOException\n+    {\n+        super.close();\n+        _symbols.release();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods, number parsing\n+    /* (note: in 1.8 and prior, part of \"ReaderBasedNumericParser\"\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Initial parsing method for number values. It needs to be able\n+     * to parse enough input to be able to determine whether the\n+     * value is to be considered a simple integer value, or a more\n+     * generic decimal value: latter of which needs to be expressed\n+     * as a floating point number. The basic rule is that if the number\n+     * has no fractional or exponential part, it is an integer; otherwise\n+     * a floating point number.\n+     *<p>\n+     * Because much of input has to be processed in any case, no partial\n+     * parsing is done: all input text will be stored for further\n+     * processing. However, actual numeric value conversion will be\n+     * deferred, since it is usually the most complicated and costliest\n+     * part of processing.\n+     */\n+    protected final JsonToken parseNumberText(int ch)\n+        throws IOException, JsonParseException\n+    {\n+        /* Although we will always be complete with respect to textual\n+         * representation (that is, all characters will be parsed),\n+         * actual conversion to a number is deferred. Thus, need to\n+         * note that no representations are valid yet\n+         */\n+        boolean negative = (ch == INT_MINUS);\n+        int ptr = _inputPtr;\n+        int startPtr = ptr-1; // to include sign/digit already read\n+        final int inputLen = _inputEnd;\n+\n+        dummy_loop:\n+        do { // dummy loop, to be able to break out\n+            if (negative) { // need to read the next digit\n+                if (ptr >= _inputEnd) {\n+                    break dummy_loop;\n+                }\n+                ch = _inputBuffer[ptr++];\n+                // First check: must have a digit to follow minus sign\n+                if (ch > INT_9 || ch < INT_0) {\n+                    _inputPtr = ptr;\n+                    return _handleInvalidNumberStart(ch, true);\n+                }\n+                /* (note: has been checked for non-negative already, in\n+                 * the dispatching code that determined it should be\n+                 * a numeric value)\n+                 */\n+            }\n+            // One special case, leading zero(es):\n+            if (ch == INT_0) {\n+                break dummy_loop;\n+            }\n+            \n+            /* First, let's see if the whole number is contained within\n+             * the input buffer unsplit. This should be the common case;\n+             * and to simplify processing, we will just reparse contents\n+             * in the alternative case (number split on buffer boundary)\n+             */\n+            \n+            int intLen = 1; // already got one\n+            \n+            // First let's get the obligatory integer part:\n+            \n+            int_loop:\n+            while (true) {\n+                if (ptr >= _inputEnd) {\n+                    break dummy_loop;\n+                }\n+                ch = (int) _inputBuffer[ptr++];\n+                if (ch < INT_0 || ch > INT_9) {\n+                    break int_loop;\n+                }\n+                ++intLen;\n+            }\n+\n+            int fractLen = 0;\n+            \n+            // And then see if we get other parts\n+            if (ch == INT_DECIMAL_POINT) { // yes, fraction\n+                fract_loop:\n+                while (true) {\n+                    if (ptr >= inputLen) {\n+                        break dummy_loop;\n+                    }\n+                    ch = (int) _inputBuffer[ptr++];\n+                    if (ch < INT_0 || ch > INT_9) {\n+                        break fract_loop;\n+                    }\n+                    ++fractLen;\n+                }\n+                // must be followed by sequence of ints, one minimum\n+                if (fractLen == 0) {\n+                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n+                }\n+            }\n+\n+            int expLen = 0;\n+            if (ch == INT_e || ch == INT_E) { // and/or exponent\n+                if (ptr >= inputLen) {\n+                    break dummy_loop;\n+                }\n+                // Sign indicator?\n+                ch = (int) _inputBuffer[ptr++];\n+                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n+                    if (ptr >= inputLen) {\n+                        break dummy_loop;\n+                    }\n+                    ch = (int) _inputBuffer[ptr++];\n+                }\n+                while (ch <= INT_9 && ch >= INT_0) {\n+                    ++expLen;\n+                    if (ptr >= inputLen) {\n+                        break dummy_loop;\n+                    }\n+                    ch = (int) _inputBuffer[ptr++];\n+                }\n+                // must be followed by sequence of ints, one minimum\n+                if (expLen == 0) {\n+                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n+                }\n+            }\n+\n+            // Got it all: let's add to text buffer for parsing, access\n+            --ptr; // need to push back following separator\n+            _inputPtr = ptr;\n+            int len = ptr-startPtr;\n+            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n+            return reset(negative, intLen, fractLen, expLen);\n+        } while (false);\n+\n+        _inputPtr = negative ? (startPtr+1) : startPtr;\n+        return parseNumberText2(negative);\n+    }\n+\n+    /**\n+     * Method called to parse a number, when the primary parse\n+     * method has failed to parse it, due to it being split on\n+     * buffer boundary. As a result code is very similar, except\n+     * that it has to explicitly copy contents to the text buffer\n+     * instead of just sharing the main input buffer.\n+     */\n+    private final JsonToken parseNumberText2(boolean negative)\n+        throws IOException, JsonParseException\n+    {\n+        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n+        int outPtr = 0;\n+\n+        // Need to prepend sign?\n+        if (negative) {\n+            outBuf[outPtr++] = '-';\n+        }\n+\n+        // This is the place to do leading-zero check(s) too:\n+        int intLen = 0;\n+        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n+        if (c == '0') {\n+            c = _verifyNoLeadingZeroes();\n+        }\n+        boolean eof = false;\n+\n+        // Ok, first the obligatory integer part:\n+        int_loop:\n+        while (c >= '0' && c <= '9') {\n+            ++intLen;\n+            if (outPtr >= outBuf.length) {\n+                outBuf = _textBuffer.finishCurrentSegment();\n+                outPtr = 0;\n+            }\n+            outBuf[outPtr++] = c;\n+            if (_inputPtr >= _inputEnd && !loadMore()) {\n+                // EOF is legal for main level int values\n+                c = CHAR_NULL;\n+                eof = true;\n+                break int_loop;\n+            }\n+            c = _inputBuffer[_inputPtr++];\n+        }\n+        // Also, integer part is not optional\n+        if (intLen == 0) {\n+            reportInvalidNumber(\"Missing integer part (next char \"+_getCharDesc(c)+\")\");\n+        }\n+\n+        int fractLen = 0;\n+        // And then see if we get other parts\n+        if (c == '.') { // yes, fraction\n+            outBuf[outPtr++] = c;\n+\n+            fract_loop:\n+            while (true) {\n+                if (_inputPtr >= _inputEnd && !loadMore()) {\n+                    eof = true;\n+                    break fract_loop;\n+                }\n+                c = _inputBuffer[_inputPtr++];\n+                if (c < INT_0 || c > INT_9) {\n+                    break fract_loop;\n+                }\n+                ++fractLen;\n+                if (outPtr >= outBuf.length) {\n+                    outBuf = _textBuffer.finishCurrentSegment();\n+                    outPtr = 0;\n+                }\n+                outBuf[outPtr++] = c;\n+            }\n+            // must be followed by sequence of ints, one minimum\n+            if (fractLen == 0) {\n+                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n+            }\n+        }\n+\n+        int expLen = 0;\n+        if (c == 'e' || c == 'E') { // exponent?\n+            if (outPtr >= outBuf.length) {\n+                outBuf = _textBuffer.finishCurrentSegment();\n+                outPtr = 0;\n+            }\n+            outBuf[outPtr++] = c;\n+            // Not optional, can require that we get one more char\n+            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n+                : getNextChar(\"expected a digit for number exponent\");\n+            // Sign indicator?\n+            if (c == '-' || c == '+') {\n+                if (outPtr >= outBuf.length) {\n+                    outBuf = _textBuffer.finishCurrentSegment();\n+                    outPtr = 0;\n+                }\n+                outBuf[outPtr++] = c;\n+                // Likewise, non optional:\n+                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n+                    : getNextChar(\"expected a digit for number exponent\");\n+            }\n+\n+            exp_loop:\n+            while (c <= INT_9 && c >= INT_0) {\n+                ++expLen;\n+                if (outPtr >= outBuf.length) {\n+                    outBuf = _textBuffer.finishCurrentSegment();\n+                    outPtr = 0;\n+                }\n+                outBuf[outPtr++] = c;\n+                if (_inputPtr >= _inputEnd && !loadMore()) {\n+                    eof = true;\n+                    break exp_loop;\n+                }\n+                c = _inputBuffer[_inputPtr++];\n+            }\n+            // must be followed by sequence of ints, one minimum\n+            if (expLen == 0) {\n+                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n+            }\n+        }\n+\n+        // Ok; unless we hit end-of-input, need to push last char read back\n+        if (!eof) {\n+            --_inputPtr;\n+        }\n+        _textBuffer.setCurrentLength(outPtr);\n+        // And there we have it!\n+        return reset(negative, intLen, fractLen, expLen);\n+    }\n+\n+    /**\n+     * Method called when we have seen one zero, and want to ensure\n+     * it is not followed by another\n+     */\n+    private final char _verifyNoLeadingZeroes()\n+        throws IOException, JsonParseException\n+    {\n+        // Ok to have plain \"0\"\n+        if (_inputPtr >= _inputEnd && !loadMore()) {\n+            return '0';\n+        }\n+        char ch = _inputBuffer[_inputPtr];\n+        // if not followed by a number (probably '.'); return zero as is, to be included\n+        if (ch < '0' || ch > '9') {\n+            return '0';\n+        }\n+        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n+            reportInvalidNumber(\"Leading zeroes not allowed\");\n+        }\n+        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n+        ++_inputPtr; // Leading zero to be skipped\n+        if (ch == INT_0) {\n+            while (_inputPtr < _inputEnd || loadMore()) {\n+                ch = _inputBuffer[_inputPtr];\n+                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n+                    return '0';\n+                }\n+                ++_inputPtr; // skip previous zero\n+                if (ch != '0') { // followed by other number; return \n+                    break;\n+                }\n+            }\n+        }\n+        return ch;\n+    }\n+\n+    /**\n+     * Method called if expected numeric value (due to leading sign) does not\n+     * look like a number\n+     */\n+    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative)\n+        throws IOException, JsonParseException\n+    {\n+        if (ch == 'I') {\n+            if (_inputPtr >= _inputEnd) {\n+                if (!loadMore()) {\n+                    _reportInvalidEOFInValue();\n+                }\n+            }\n+            ch = _inputBuffer[_inputPtr++];\n+            if (ch == 'N') {\n+                String match = negative ? \"-INF\" :\"+INF\";\n+                _matchToken(match, 3);\n+                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n+                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n+                }\n+                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n+            } else if (ch == 'n') {\n+                String match = negative ? \"-Infinity\" :\"+Infinity\";\n+                _matchToken(match, 3);\n+                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n+                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n+                }\n+                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n+            }\n+        }\n+        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n+        return null;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods, secondary parsing\n+    /**********************************************************\n+     */\n+\n+    protected final String _parseFieldName(int i)\n+        throws IOException, JsonParseException\n+    {\n+        if (i != INT_QUOTE) {\n+            return _handleUnusualFieldName(i);\n+        }\n+        /* First: let's try to see if we have a simple name: one that does\n+         * not cross input buffer boundary, and does not contain escape\n+         * sequences.\n+         */\n+        int ptr = _inputPtr;\n+        int hash = 0;\n+        final int inputLen = _inputEnd;\n+\n+        if (ptr < inputLen) {\n+            final int[] codes = CharTypes.getInputCodeLatin1();\n+            final int maxCode = codes.length;\n+\n+            do {\n+                int ch = _inputBuffer[ptr];\n+                if (ch < maxCode && codes[ch] != 0) {\n+                    if (ch == '\"') {\n+                        int start = _inputPtr;\n+                        _inputPtr = ptr+1; // to skip the quote\n+                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n+                    }\n+                    break;\n+                }\n+                hash = (hash * 31) + ch;\n+                ++ptr;\n+            } while (ptr < inputLen);\n+        }\n+\n+        int start = _inputPtr;\n+        _inputPtr = ptr;\n+        return _parseFieldName2(start, hash, INT_QUOTE);\n+    }\n+\n+    private String _parseFieldName2(int startPtr, int hash, int endChar)\n+        throws IOException, JsonParseException\n+    {\n+        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n+\n+        /* Output pointers; calls will also ensure that the buffer is\n+         * not shared and has room for at least one more char.\n+         */\n+        char[] outBuf = _textBuffer.getCurrentSegment();\n+        int outPtr = _textBuffer.getCurrentSegmentSize();\n+\n+        while (true) {\n+            if (_inputPtr >= _inputEnd) {\n+                if (!loadMore()) {\n+                    _reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\");\n+                }\n+            }\n+            char c = _inputBuffer[_inputPtr++];\n+            int i = (int) c;\n+            if (i <= INT_BACKSLASH) {\n+                if (i == INT_BACKSLASH) {\n+                    /* Although chars outside of BMP are to be escaped as\n+                     * an UTF-16 surrogate pair, does that affect decoding?\n+                     * For now let's assume it does not.\n+                     */\n+                    c = _decodeEscaped();\n+                } else if (i <= endChar) {\n+                    if (i == endChar) {\n+                        break;\n+                    }\n+                    if (i < INT_SPACE) {\n+                        _throwUnquotedSpace(i, \"name\");\n+                    }\n+                }\n+            }\n+            hash = (hash * 31) + i;\n+            // Ok, let's add char to output:\n+            outBuf[outPtr++] = c;\n+\n+            // Need more room?\n+            if (outPtr >= outBuf.length) {\n+                outBuf = _textBuffer.finishCurrentSegment();\n+                outPtr = 0;\n+            }\n+        }\n+        _textBuffer.setCurrentLength(outPtr);\n+        {\n+            TextBuffer tb = _textBuffer;\n+            char[] buf = tb.getTextBuffer();\n+            int start = tb.getTextOffset();\n+            int len = tb.size();\n+\n+            return _symbols.findSymbol(buf, start, len, hash);\n+        }\n+    }\n+\n+    /**\n+     * Method called when we see non-white space character other\n+     * than double quote, when expecting a field name.\n+     * In standard mode will just throw an expection; but\n+     * in non-standard modes may be able to parse name.\n+     *\n+     * @since 1.2\n+     */\n+    protected final String _handleUnusualFieldName(int i)\n+        throws IOException, JsonParseException\n+    {\n+        // [JACKSON-173]: allow single quotes\n+        if (i == INT_APOSTROPHE && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n+            return _parseApostropheFieldName();\n+        }\n+        // [JACKSON-69]: allow unquoted names if feature enabled:\n+        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n+            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n+        }\n+        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n+        final int maxCode = codes.length;\n+\n+        // Also: first char must be a valid name char, but NOT be number\n+        boolean firstOk;\n+\n+        if (i < maxCode) { // identifier, and not a number\n+            firstOk = (codes[i] == 0) && (i < INT_0 || i > INT_9);\n+        } else {\n+            firstOk = Character.isJavaIdentifierPart((char) i);\n+        }\n+        if (!firstOk) {\n+            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n+        }\n+        int ptr = _inputPtr;\n+        int hash = 0;\n+        final int inputLen = _inputEnd;\n+\n+        if (ptr < inputLen) {\n+            do {\n+                int ch = _inputBuffer[ptr];\n+                if (ch < maxCode) {\n+                    if (codes[ch] != 0) {\n+                        int start = _inputPtr-1; // -1 to bring back first char\n+                        _inputPtr = ptr;\n+                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n+                    }\n+                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n+                    int start = _inputPtr-1; // -1 to bring back first char\n+                    _inputPtr = ptr;\n+                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n+                }\n+                hash = (hash * 31) + ch;\n+                ++ptr;\n+            } while (ptr < inputLen);\n+        }\n+        int start = _inputPtr-1;\n+        _inputPtr = ptr;\n+        return _parseUnusualFieldName2(start, hash, codes);\n+    }\n+\n+    protected final String _parseApostropheFieldName()\n+        throws IOException, JsonParseException\n+    {\n+        // Note: mostly copy of_parseFieldName\n+        int ptr = _inputPtr;\n+        int hash = 0;\n+        final int inputLen = _inputEnd;\n+\n+        if (ptr < inputLen) {\n+            final int[] codes = CharTypes.getInputCodeLatin1();\n+            final int maxCode = codes.length;\n+\n+            do {\n+                int ch = _inputBuffer[ptr];\n+                if (ch == '\\'') {\n+                    int start = _inputPtr;\n+                    _inputPtr = ptr+1; // to skip the quote\n+                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n+                }\n+                if (ch < maxCode && codes[ch] != 0) {\n+                    break;\n+                }\n+                hash = (hash * 31) + ch;\n+                ++ptr;\n+            } while (ptr < inputLen);\n+        }\n+\n+        int start = _inputPtr;\n+        _inputPtr = ptr;\n+\n+        return _parseFieldName2(start, hash, INT_APOSTROPHE);\n+    }\n+\n+    /**\n+     * Method for handling cases where first non-space character\n+     * of an expected value token is not legal for standard JSON content.\n+     *\n+     * @since 1.3\n+     */\n+    protected final JsonToken _handleUnexpectedValue(int i)\n+        throws IOException, JsonParseException\n+    {\n+        // Most likely an error, unless we are to allow single-quote-strings\n+        switch (i) {\n+        case '\\'':\n+            /* [JACKSON-173]: allow single quotes. Unlike with regular\n+             * Strings, we'll eagerly parse contents; this so that there's\n+             * no need to store information on quote char used.\n+             *\n+             * Also, no separation to fast/slow parsing; we'll just do\n+             * one regular (~= slowish) parsing, to keep code simple\n+             */\n+            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n+                return _handleApostropheValue();\n+            }\n+            break;\n+        case 'N':\n+            _matchToken(\"NaN\", 1);\n+            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n+                return resetAsNaN(\"NaN\", Double.NaN);\n+            }\n+            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n+            break;\n+        case '+': // note: '-' is taken as number\n+            if (_inputPtr >= _inputEnd) {\n+                if (!loadMore()) {\n+                    _reportInvalidEOFInValue();\n+                }\n+            }\n+            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n+        }\n+        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n+        return null;\n+    }\n+    \n+    /**\n+     * @since 1.8\n+     */\n+    protected final JsonToken _handleApostropheValue()\n+        throws IOException, JsonParseException\n+    {\n+        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n+        int outPtr = _textBuffer.getCurrentSegmentSize();\n+\n+        while (true) {\n+            if (_inputPtr >= _inputEnd) {\n+                if (!loadMore()) {\n+                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n+                }\n+            }\n+            char c = _inputBuffer[_inputPtr++];\n+            int i = (int) c;\n+            if (i <= INT_BACKSLASH) {\n+                if (i == INT_BACKSLASH) {\n+                    /* Although chars outside of BMP are to be escaped as\n+                     * an UTF-16 surrogate pair, does that affect decoding?\n+                     * For now let's assume it does not.\n+                     */\n+                    c = _decodeEscaped();\n+                } else if (i <= INT_APOSTROPHE) {\n+                    if (i == INT_APOSTROPHE) {\n+                        break;\n+                    }\n+                    if (i < INT_SPACE) {\n+                        _throwUnquotedSpace(i, \"string value\");\n+                    }\n+                }\n+            }\n+            // Need more room?\n+            if (outPtr >= outBuf.length) {\n+                outBuf = _textBuffer.finishCurrentSegment();\n+                outPtr = 0;\n+            }\n+            // Ok, let's add char to output:\n+            outBuf[outPtr++] = c;\n+        }\n+        _textBuffer.setCurrentLength(outPtr);\n+        return JsonToken.VALUE_STRING;\n+    }\n+    \n+    /**\n+     * @since 1.2\n+     */\n+    private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes)\n+        throws IOException, JsonParseException\n+    {\n+        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n+        char[] outBuf = _textBuffer.getCurrentSegment();\n+        int outPtr = _textBuffer.getCurrentSegmentSize();\n+        final int maxCode = codes.length;\n+\n+        while (true) {\n+            if (_inputPtr >= _inputEnd) {\n+                if (!loadMore()) { // acceptable for now (will error out later)\n+                    break;\n+                }\n+            }\n+            char c = _inputBuffer[_inputPtr];\n+            int i = (int) c;\n+            if (i <= maxCode) {\n+                if (codes[i] != 0) {\n+                    break;\n+                }\n+            } else if (!Character.isJavaIdentifierPart(c)) {\n+                break;\n+            }\n+            ++_inputPtr;\n+            hash = (hash * 31) + i;\n+            // Ok, let's add char to output:\n+            outBuf[outPtr++] = c;\n+\n+            // Need more room?\n+            if (outPtr >= outBuf.length) {\n+                outBuf = _textBuffer.finishCurrentSegment();\n+                outPtr = 0;\n+            }\n+        }\n+        _textBuffer.setCurrentLength(outPtr);\n+        {\n+            TextBuffer tb = _textBuffer;\n+            char[] buf = tb.getTextBuffer();\n+            int start = tb.getTextOffset();\n+            int len = tb.size();\n+\n+            return _symbols.findSymbol(buf, start, len, hash);\n+        }\n+    }\n+  \n+    @Override\n+    protected void _finishString()\n+        throws IOException, JsonParseException\n+    {\n+        /* First: let's try to see if we have simple String value: one\n+         * that does not cross input buffer boundary, and does not\n+         * contain escape sequences.\n+         */\n+        int ptr = _inputPtr;\n+        final int inputLen = _inputEnd;\n+\n+        if (ptr < inputLen) {\n+            final int[] codes = CharTypes.getInputCodeLatin1();\n+            final int maxCode = codes.length;\n+\n+            do {\n+                int ch = _inputBuffer[ptr];\n+                if (ch < maxCode && codes[ch] != 0) {\n+                    if (ch == '\"') {\n+                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n+                        _inputPtr = ptr+1;\n+                        // Yes, we got it all\n+                        return;\n+                    }\n+                    break;\n+                }\n+                ++ptr;\n+            } while (ptr < inputLen);\n+        }\n+\n+        /* Either ran out of input, or bumped into an escape\n+         * sequence...\n+         */\n+        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n+        _inputPtr = ptr;\n+        _finishString2();\n+    }\n+\n+    protected void _finishString2()\n+        throws IOException, JsonParseException\n+    {\n+        char[] outBuf = _textBuffer.getCurrentSegment();\n+        int outPtr = _textBuffer.getCurrentSegmentSize();\n+\n+        while (true) {\n+            if (_inputPtr >= _inputEnd) {\n+                if (!loadMore()) {\n+                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n+                }\n+            }\n+            char c = _inputBuffer[_inputPtr++];\n+            int i = (int) c;\n+            if (i <= INT_BACKSLASH) {\n+                if (i == INT_BACKSLASH) {\n+                    /* Although chars outside of BMP are to be escaped as\n+                     * an UTF-16 surrogate pair, does that affect decoding?\n+                     * For now let's assume it does not.\n+                     */\n+                    c = _decodeEscaped();\n+                } else if (i <= INT_QUOTE) {\n+                    if (i == INT_QUOTE) {\n+                        break;\n+                    }\n+                    if (i < INT_SPACE) {\n+                        _throwUnquotedSpace(i, \"string value\");\n+                    }\n+                }\n+            }\n+            // Need more room?\n+            if (outPtr >= outBuf.length) {\n+                outBuf = _textBuffer.finishCurrentSegment();\n+                outPtr = 0;\n+            }\n+            // Ok, let's add char to output:\n+            outBuf[outPtr++] = c;\n+        }\n+        _textBuffer.setCurrentLength(outPtr);\n+    }\n+\n+    /**\n+     * Method called to skim through rest of unparsed String value,\n+     * if it is not needed. This can be done bit faster if contents\n+     * need not be stored for future access.\n+     */\n+    protected void _skipString()\n+        throws IOException, JsonParseException\n+    {\n+        _tokenIncomplete = false;\n+\n+        int inputPtr = _inputPtr;\n+        int inputLen = _inputEnd;\n+        char[] inputBuffer = _inputBuffer;\n+\n+        while (true) {\n+            if (inputPtr >= inputLen) {\n+                _inputPtr = inputPtr;\n+                if (!loadMore()) {\n+                    _reportInvalidEOF(\": was expecting closing quote for a string value\");\n+                }\n+                inputPtr = _inputPtr;\n+                inputLen = _inputEnd;\n+            }\n+            char c = inputBuffer[inputPtr++];\n+            int i = (int) c;\n+            if (i <= INT_BACKSLASH) {\n+                if (i == INT_BACKSLASH) {\n+                    /* Although chars outside of BMP are to be escaped as\n+                     * an UTF-16 surrogate pair, does that affect decoding?\n+                     * For now let's assume it does not.\n+                     */\n+                    _inputPtr = inputPtr;\n+                    c = _decodeEscaped();\n+                    inputPtr = _inputPtr;\n+                    inputLen = _inputEnd;\n+                } else if (i <= INT_QUOTE) {\n+                    if (i == INT_QUOTE) {\n+                        _inputPtr = inputPtr;\n+                        break;\n+                    }\n+                    if (i < INT_SPACE) {\n+                        _inputPtr = inputPtr;\n+                        _throwUnquotedSpace(i, \"string value\");\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods, other parsing\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * We actually need to check the character value here\n+     * (to see if we have \\n following \\r).\n+     */\n+    protected final void _skipCR() throws IOException\n+    {\n+        if (_inputPtr < _inputEnd || loadMore()) {\n+            if (_inputBuffer[_inputPtr] == '\\n') {\n+                ++_inputPtr;\n+            }\n+        }\n+        ++_currInputRow;\n+        _currInputRowStart = _inputPtr;\n+    }\n+\n+    protected final void _skipLF() throws IOException\n+    {\n+        ++_currInputRow;\n+        _currInputRowStart = _inputPtr;\n+    }\n+\n+    private final int _skipWS()\n+        throws IOException, JsonParseException\n+    {\n+        while (_inputPtr < _inputEnd || loadMore()) {\n+            int i = (int) _inputBuffer[_inputPtr++];\n+            if (i > INT_SPACE) {\n+                if (i != INT_SLASH) {\n+                    return i;\n+                }\n+                _skipComment();\n+            } else if (i != INT_SPACE) {\n+                if (i == INT_LF) {\n+                    _skipLF();\n+                } else if (i == INT_CR) {\n+                    _skipCR();\n+                } else if (i != INT_TAB) {\n+                    _throwInvalidSpace(i);\n+                }\n+            }\n+        }\n+        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n+    }\n+\n+    private final int _skipWSOrEnd()\n+        throws IOException, JsonParseException\n+    {\n+        while ((_inputPtr < _inputEnd) || loadMore()) {\n+            int i = (int) _inputBuffer[_inputPtr++];\n+            if (i > INT_SPACE) {\n+                 if (i == INT_SLASH) {\n+                     _skipComment();\n+                     continue;\n+                }\n+                 return i;\n+            }\n+            if (i != INT_SPACE) {\n+                if (i == INT_LF) {\n+                    _skipLF();\n+                } else if (i == INT_CR) {\n+                    _skipCR();\n+                } else if (i != INT_TAB) {\n+                    _throwInvalidSpace(i);\n+                }\n+            }\n+        }\n+        // We ran out of input...\n+        _handleEOF();\n+        return -1;\n+    }\n+\n+    private final void _skipComment()\n+        throws IOException, JsonParseException\n+    {\n+        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n+            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n+        }\n+        // First: check which comment (if either) it is:\n+        if (_inputPtr >= _inputEnd && !loadMore()) {\n+            _reportInvalidEOF(\" in a comment\");\n+        }\n+        char c = _inputBuffer[_inputPtr++];\n+        if (c == '/') {\n+            _skipCppComment();\n+        } else if (c == '*') {\n+            _skipCComment();\n+        } else {\n+            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n+        }\n+    }\n+\n+    private final void _skipCComment()\n+        throws IOException, JsonParseException\n+    {\n+        // Ok: need the matching '*/'\n+        main_loop:\n+        while ((_inputPtr < _inputEnd) || loadMore()) {\n+            int i = (int) _inputBuffer[_inputPtr++];\n+            if (i <= INT_ASTERISK) {\n+                if (i == INT_ASTERISK) { // end?\n+                    if ((_inputPtr >= _inputEnd) && !loadMore()) {\n+                        break main_loop;\n+                    }\n+                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n+                        ++_inputPtr;\n+                        return;\n+                    }\n+                    continue;\n+                }\n+                if (i < INT_SPACE) {\n+                    if (i == INT_LF) {\n+                        _skipLF();\n+                    } else if (i == INT_CR) {\n+                        _skipCR();\n+                    } else if (i != INT_TAB) {\n+                        _throwInvalidSpace(i);\n+                    }\n+                }\n+            }\n+        }\n+        _reportInvalidEOF(\" in a comment\");\n+    }\n+\n+    private final void _skipCppComment()\n+        throws IOException, JsonParseException\n+    {\n+        // Ok: need to find EOF or linefeed\n+        while ((_inputPtr < _inputEnd) || loadMore()) {\n+            int i = (int) _inputBuffer[_inputPtr++];\n+            if (i < INT_SPACE) {\n+                if (i == INT_LF) {\n+                    _skipLF();\n+                    break;\n+                } else if (i == INT_CR) {\n+                    _skipCR();\n+                    break;\n+                } else if (i != INT_TAB) {\n+                    _throwInvalidSpace(i);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected final char _decodeEscaped()\n+        throws IOException, JsonParseException\n+    {\n+        if (_inputPtr >= _inputEnd) {\n+            if (!loadMore()) {\n+                _reportInvalidEOF(\" in character escape sequence\");\n+            }\n+        }\n+        char c = _inputBuffer[_inputPtr++];\n+\n+        switch ((int) c) {\n+            // First, ones that are mapped\n+        case INT_b:\n+            return '\\b';\n+        case INT_t:\n+            return '\\t';\n+        case INT_n:\n+            return '\\n';\n+        case INT_f:\n+            return '\\f';\n+        case INT_r:\n+            return '\\r';\n+\n+            // And these are to be returned as they are\n+        case INT_QUOTE:\n+        case INT_SLASH:\n+        case INT_BACKSLASH:\n+            return c;\n+\n+        case INT_u: // and finally hex-escaped\n+            break;\n+\n+        default:\n+            return _handleUnrecognizedCharacterEscape(c);\n+        }\n+\n+        // Ok, a hex escape. Need 4 characters\n+        int value = 0;\n+        for (int i = 0; i < 4; ++i) {\n+            if (_inputPtr >= _inputEnd) {\n+                if (!loadMore()) {\n+                    _reportInvalidEOF(\" in character escape sequence\");\n+                }\n+            }\n+            int ch = (int) _inputBuffer[_inputPtr++];\n+            int digit = CharTypes.charToHex(ch);\n+            if (digit < 0) {\n+                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n+            }\n+            value = (value << 4) | digit;\n+        }\n+        return (char) value;\n+    }\n+    \n+    /**\n+     * Helper method for checking whether input matches expected token\n+     * \n+     * @since 1.8\n+     */\n+    protected final void _matchToken(String matchStr, int i)\n+        throws IOException, JsonParseException\n+    {\n+        final int len = matchStr.length();\n+\n+        do {\n+            if (_inputPtr >= _inputEnd) {\n+                if (!loadMore()) {\n+                    _reportInvalidEOFInValue();\n+                }\n+            }\n+            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n+                _reportInvalidToken(matchStr.substring(0, i), \"'null', 'true', 'false' or NaN\");\n+            }\n+            ++_inputPtr;\n+        } while (++i < len);\n+\n+        // but let's also ensure we either get EOF, or non-alphanum char...\n+        if (_inputPtr >= _inputEnd) {\n+            if (!loadMore()) {\n+                return;\n+            }\n+        }\n+        char c = _inputBuffer[_inputPtr];\n+        if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n+            return;\n+        }\n+        // if Java letter, it's a problem tho\n+        if (Character.isJavaIdentifierPart(c)) {\n+            ++_inputPtr;\n+            _reportInvalidToken(matchStr.substring(0, i), \"'null', 'true', 'false' or NaN\");\n+        }\n+        return;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Binary access\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Efficient handling for incremental parsing of base64-encoded\n+     * textual content.\n+     */\n+    protected byte[] _decodeBase64(Base64Variant b64variant)\n+        throws IOException, JsonParseException\n+    {\n+        ByteArrayBuilder builder = _getByteArrayBuilder();\n+\n+        //main_loop:\n+        while (true) {\n+            // first, we'll skip preceding white space, if any\n+            char ch;\n+            do {\n+                if (_inputPtr >= _inputEnd) {\n+                    loadMoreGuaranteed();\n+                }\n+                ch = _inputBuffer[_inputPtr++];\n+            } while (ch <= INT_SPACE);\n+            int bits = b64variant.decodeBase64Char(ch);\n+            if (bits < 0) {\n+                if (ch == '\"') { // reached the end, fair and square?\n+                    return builder.toByteArray();\n+                }\n+                bits = _decodeBase64Escape(b64variant, ch, 0);\n+                if (bits < 0) { // white space to skip\n+                    continue;\n+                }\n+            }\n+            int decodedData = bits;\n+            \n+            // then second base64 char; can't get padding yet, nor ws\n+            \n+            if (_inputPtr >= _inputEnd) {\n+                loadMoreGuaranteed();\n+            }\n+            ch = _inputBuffer[_inputPtr++];\n+            bits = b64variant.decodeBase64Char(ch);\n+            if (bits < 0) {\n+                bits = _decodeBase64Escape(b64variant, ch, 1);\n+            }\n+            decodedData = (decodedData << 6) | bits;\n+            \n+            // third base64 char; can be padding, but not ws\n+            if (_inputPtr >= _inputEnd) {\n+                loadMoreGuaranteed();\n+            }\n+            ch = _inputBuffer[_inputPtr++];\n+            bits = b64variant.decodeBase64Char(ch);\n+\n+            // First branch: can get padding (-> 1 byte)\n+            if (bits < 0) {\n+                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n+                    // as per [JACKSON-631], could also just be 'missing'  padding\n+                    if (ch == '\"' && !b64variant.usesPadding()) {\n+                        decodedData >>= 4;\n+                        builder.append(decodedData);\n+                        return builder.toByteArray();\n+                    }\n+                    bits = _decodeBase64Escape(b64variant, ch, 2);\n+                }\n+                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n+                    // Ok, must get more padding chars, then\n+                    if (_inputPtr >= _inputEnd) {\n+                        loadMoreGuaranteed();\n+                    }\n+                    ch = _inputBuffer[_inputPtr++];\n+                    if (!b64variant.usesPaddingChar(ch)) {\n+                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n+                    }\n+                    // Got 12 bits, only need 8, need to shift\n+                    decodedData >>= 4;\n+                    builder.append(decodedData);\n+                    continue;\n+                }\n+                // otherwise we got escaped other char, to be processed below\n+            }\n+            // Nope, 2 or 3 bytes\n+            decodedData = (decodedData << 6) | bits;\n+            // fourth and last base64 char; can be padding, but not ws\n+            if (_inputPtr >= _inputEnd) {\n+                loadMoreGuaranteed();\n+            }\n+            ch = _inputBuffer[_inputPtr++];\n+            bits = b64variant.decodeBase64Char(ch);\n+            if (bits < 0) {\n+                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n+                    // as per [JACKSON-631], could also just be 'missing'  padding\n+                    if (ch == '\"' && !b64variant.usesPadding()) {\n+                        decodedData >>= 2;\n+                        builder.appendTwoBytes(decodedData);\n+                        return builder.toByteArray();\n+                    }\n+                    bits = _decodeBase64Escape(b64variant, ch, 3);\n+                }\n+                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n+                    // With padding we only get 2 bytes; but we have\n+                    // to shift it a bit so it is identical to triplet\n+                    // case with partial output.\n+                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n+                    // dummies, need to discard:\n+                    decodedData >>= 2;\n+                    builder.appendTwoBytes(decodedData);\n+                    continue;\n+                }\n+                // otherwise we got escaped other char, to be processed below\n+            }\n+            // otherwise, our triplet is now complete\n+            decodedData = (decodedData << 6) | bits;\n+            builder.appendThreeBytes(decodedData);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Error reporting\n+    /**********************************************************\n+     */\n+\n+    protected void _reportInvalidToken(String matchedPart, String msg)\n+        throws IOException, JsonParseException\n+    {\n+        StringBuilder sb = new StringBuilder(matchedPart);\n+        /* Let's just try to find what appears to be the token, using\n+         * regular Java identifier character rules. It's just a heuristic,\n+         * nothing fancy here.\n+         */\n+        while (true) {\n+            if (_inputPtr >= _inputEnd) {\n+                if (!loadMore()) {\n+                    break;\n+                }\n+            }\n+            char c = _inputBuffer[_inputPtr];\n+            if (!Character.isJavaIdentifierPart(c)) {\n+                break;\n+            }\n+            ++_inputPtr;\n+            sb.append(c);\n+        }\n+        _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \");\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n+package com.fasterxml.jackson.core.json;\n+\n+import java.io.*;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.base.GeneratorBase;\n+import com.fasterxml.jackson.core.io.CharTypes;\n+import com.fasterxml.jackson.core.io.CharacterEscapes;\n+import com.fasterxml.jackson.core.io.IOContext;\n+import com.fasterxml.jackson.core.io.NumberOutput;\n+import com.fasterxml.jackson.core.io.SerializedString;\n+\n+public class UTF8JsonGenerator\n+    extends GeneratorBase\n+{\n+    private final static byte BYTE_u = (byte) 'u';\n+\n+    private final static byte BYTE_0 = (byte) '0';\n+    \n+    private final static byte BYTE_LBRACKET = (byte) '[';\n+    private final static byte BYTE_RBRACKET = (byte) ']';\n+    private final static byte BYTE_LCURLY = (byte) '{';\n+    private final static byte BYTE_RCURLY = (byte) '}';\n+ \n+    private final static byte BYTE_BACKSLASH = (byte) '\\\\';\n+    private final static byte BYTE_SPACE = (byte) ' ';\n+    private final static byte BYTE_COMMA = (byte) ',';\n+    private final static byte BYTE_COLON = (byte) ':';\n+    private final static byte BYTE_QUOTE = (byte) '\"';\n+\n+    protected final static int SURR1_FIRST = 0xD800;\n+    protected final static int SURR1_LAST = 0xDBFF;\n+    protected final static int SURR2_FIRST = 0xDC00;\n+    protected final static int SURR2_LAST = 0xDFFF;\n+\n+    // intermediate copies only made up to certain length...\n+    private final static int MAX_BYTES_TO_BUFFER = 512;\n+    \n+    final static byte[] HEX_CHARS = CharTypes.copyHexBytes();\n+\n+    private final static byte[] NULL_BYTES = { 'n', 'u', 'l', 'l' };\n+    private final static byte[] TRUE_BYTES = { 't', 'r', 'u', 'e' };\n+    private final static byte[] FALSE_BYTES = { 'f', 'a', 'l', 's', 'e' };\n+\n+    /**\n+     * This is the default set of escape codes, over 7-bit ASCII range\n+     * (first 128 character codes), used for single-byte UTF-8 characters.\n+     */\n+    protected final static int[] sOutputEscapes = CharTypes.get7BitOutputEscapes();\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration, basic I/O\n+    /**********************************************************\n+     */\n+\n+    final protected IOContext _ioContext;\n+\n+    /**\n+     * Underlying output stream used for writing JSON content.\n+     */\n+    final protected OutputStream _outputStream;\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration, output escaping\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Currently active set of output escape code definitions (whether\n+     * and how to escape or not) for 7-bit ASCII range (first 128\n+     * character codes). Defined separately to make potentially\n+     * customizable\n+     */\n+    protected int[] _outputEscapes = sOutputEscapes;\n+\n+    /**\n+     * Value between 128 (0x80) and 65535 (0xFFFF) that indicates highest\n+     * Unicode code point that will not need escaping; or 0 to indicate\n+     * that all characters can be represented without escaping.\n+     * Typically used to force escaping of some portion of character set;\n+     * for example to always escape non-ASCII characters (if value was 127).\n+     *<p>\n+     * NOTE: not all sub-classes make use of this setting.\n+     */\n+    protected int _maximumNonEscapedChar;\n+\n+    /**\n+     * Definition of custom character escapes to use for generators created\n+     * by this factory, if any. If null, standard data format specific\n+     * escapes are used.\n+     * \n+     * @since 1.8\n+     */\n+    protected CharacterEscapes _characterEscapes;\n+    \n+    /*\n+    /**********************************************************\n+    /* Output buffering\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Intermediate buffer in which contents are buffered before\n+     * being written using {@link #_outputStream}.\n+     */\n+    protected byte[] _outputBuffer;\n+\n+    /**\n+     * Pointer to the position right beyond the last character to output\n+     * (end marker; may be past the buffer)\n+     */\n+    protected int _outputTail = 0;\n+\n+    /**\n+     * End marker of the output buffer; one past the last valid position\n+     * within the buffer.\n+     */\n+    protected final int _outputEnd;\n+\n+    /**\n+     * Maximum number of <code>char</code>s that we know will always fit\n+     * in the output buffer after escaping\n+     */\n+    protected final int _outputMaxContiguous;\n+    \n+    /**\n+     * Intermediate buffer in which characters of a String are copied\n+     * before being encoded.\n+     */\n+    protected char[] _charBuffer;\n+    \n+    /**\n+     * Length of <code>_charBuffer</code>\n+     */\n+    protected final int _charBufferLength;\n+    \n+    /**\n+     * 6 character temporary buffer allocated if needed, for constructing\n+     * escape sequences\n+     */\n+    protected byte[] _entityBuffer;\n+\n+    /**\n+     * Flag that indicates whether the output buffer is recycable (and\n+     * needs to be returned to recycler once we are done) or not.\n+     */\n+    protected boolean _bufferRecyclable;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec,\n+            OutputStream out)\n+    {\n+        \n+        super(features, codec);\n+        _ioContext = ctxt;\n+        _outputStream = out;\n+        _bufferRecyclable = true;\n+        _outputBuffer = ctxt.allocWriteEncodingBuffer();\n+        _outputEnd = _outputBuffer.length;\n+        /* To be exact, each char can take up to 6 bytes when escaped (Unicode\n+         * escape with backslash, 'u' and 4 hex digits); but to avoid fluctuation,\n+         * we will actually round down to only do up to 1/8 number of chars\n+         */\n+        _outputMaxContiguous = _outputEnd >> 3;\n+        _charBuffer = ctxt.allocConcatBuffer();\n+        _charBufferLength = _charBuffer.length;\n+\n+        // By default we use this feature to determine additional quoting\n+        if (isEnabled(Feature.ESCAPE_NON_ASCII)) {\n+            setHighestNonEscapedChar(127);\n+        }\n+    }\n+\n+    public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec,\n+            OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable)\n+    {\n+        \n+        super(features, codec);\n+        _ioContext = ctxt;\n+        _outputStream = out;\n+        _bufferRecyclable = bufferRecyclable;\n+        _outputTail = outputOffset;\n+        _outputBuffer = outputBuffer;\n+        _outputEnd = _outputBuffer.length;\n+        // up to 6 bytes per char (see above), rounded up to 1/8\n+        _outputMaxContiguous = _outputEnd >> 3;\n+        _charBuffer = ctxt.allocConcatBuffer();\n+        _charBufferLength = _charBuffer.length;\n+\n+        if (isEnabled(Feature.ESCAPE_NON_ASCII)) {\n+            setHighestNonEscapedChar(127);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridden configuration methods\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public JsonGenerator setHighestNonEscapedChar(int charCode) {\n+        _maximumNonEscapedChar = (charCode < 0) ? 0 : charCode;\n+        return this;\n+    }\n+\n+    @Override\n+    public int getHighestEscapedChar() {\n+        return _maximumNonEscapedChar;\n+    }\n+\n+    @Override\n+    public JsonGenerator setCharacterEscapes(CharacterEscapes esc)\n+    {\n+        _characterEscapes = esc;\n+        if (esc == null) { // revert to standard escapes\n+            _outputEscapes = sOutputEscapes;\n+        } else {\n+            _outputEscapes = esc.getEscapeCodesForAscii();\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Method for accessing custom escapes factory uses for {@link JsonGenerator}s\n+     * it creates.\n+     * \n+     * @since 1.8\n+     */\n+    @Override\n+    public CharacterEscapes getCharacterEscapes() {\n+        return _characterEscapes;\n+    }\n+\n+    @Override\n+    public Object getOutputTarget() {\n+        return _outputStream;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Overridden methods\n+    /**********************************************************\n+     */\n+\n+    /* Most overrides in this section are just to make methods final,\n+     * to allow better inlining...\n+     */\n+    @Override\n+    public final void writeStringField(String fieldName, String value)\n+        throws IOException, JsonGenerationException\n+    {\n+        writeFieldName(fieldName);\n+        writeString(value);\n+    }\n+\n+    @Override\n+    public final void writeFieldName(String name)  throws IOException, JsonGenerationException\n+    {\n+        int status = _writeContext.writeFieldName(name);\n+        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n+            _reportError(\"Can not write a field name, expecting a value\");\n+        }\n+        if (_cfgPrettyPrinter != null) {\n+            _writePPFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA));\n+            return;\n+        }\n+        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { // need comma\n+            if (_outputTail >= _outputEnd) {\n+                _flushBuffer();\n+            }\n+            _outputBuffer[_outputTail++] = BYTE_COMMA;\n+        }\n+        _writeFieldName(name);\n+    }\n+    \n+    @Override\n+    public final void writeFieldName(SerializedString name)\n+        throws IOException, JsonGenerationException\n+    {\n+        // Object is a value, need to verify it's allowed\n+        int status = _writeContext.writeFieldName(name.getValue());\n+        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n+            _reportError(\"Can not write a field name, expecting a value\");\n+        }\n+        if (_cfgPrettyPrinter != null) {\n+            _writePPFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA));\n+            return;\n+        }\n+        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) {\n+            if (_outputTail >= _outputEnd) {\n+                _flushBuffer();\n+            }\n+            _outputBuffer[_outputTail++] = BYTE_COMMA;\n+        }\n+        _writeFieldName(name);\n+    }\n+\n+    @Override\n+    public final void writeFieldName(SerializableString name)\n+        throws IOException, JsonGenerationException\n+    {\n+        // Object is a value, need to verify it's allowed\n+        int status = _writeContext.writeFieldName(name.getValue());\n+        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n+            _reportError(\"Can not write a field name, expecting a value\");\n+        }\n+        if (_cfgPrettyPrinter != null) {\n+            _writePPFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA));\n+            return;\n+        }\n+        if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) {\n+            if (_outputTail >= _outputEnd) {\n+                _flushBuffer();\n+            }\n+            _outputBuffer[_outputTail++] = BYTE_COMMA;\n+        }\n+        _writeFieldName(name);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Output method implementations, structural\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public final void writeStartArray() throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"start an array\");\n+        _writeContext = _writeContext.createChildArrayContext();\n+        if (_cfgPrettyPrinter != null) {\n+            _cfgPrettyPrinter.writeStartArray(this);\n+        } else {\n+            if (_outputTail >= _outputEnd) {\n+                _flushBuffer();\n+            }\n+            _outputBuffer[_outputTail++] = BYTE_LBRACKET;\n+        }\n+    }\n+\n+    @Override\n+    public final void writeEndArray() throws IOException, JsonGenerationException\n+    {\n+        if (!_writeContext.inArray()) {\n+            _reportError(\"Current context not an ARRAY but \"+_writeContext.getTypeDesc());\n+        }\n+        if (_cfgPrettyPrinter != null) {\n+            _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());\n+        } else {\n+            if (_outputTail >= _outputEnd) {\n+                _flushBuffer();\n+            }\n+            _outputBuffer[_outputTail++] = BYTE_RBRACKET;\n+        }\n+        _writeContext = _writeContext.getParent();\n+    }\n+\n+    @Override\n+    public final void writeStartObject() throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"start an object\");\n+        _writeContext = _writeContext.createChildObjectContext();\n+        if (_cfgPrettyPrinter != null) {\n+            _cfgPrettyPrinter.writeStartObject(this);\n+        } else {\n+            if (_outputTail >= _outputEnd) {\n+                _flushBuffer();\n+            }\n+            _outputBuffer[_outputTail++] = BYTE_LCURLY;\n+        }\n+    }\n+\n+    @Override\n+    public final void writeEndObject() throws IOException, JsonGenerationException\n+    {\n+        if (!_writeContext.inObject()) {\n+            _reportError(\"Current context not an object but \"+_writeContext.getTypeDesc());\n+        }\n+        _writeContext = _writeContext.getParent();\n+        if (_cfgPrettyPrinter != null) {\n+            _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount());\n+        } else {\n+            if (_outputTail >= _outputEnd) {\n+                _flushBuffer();\n+            }\n+            _outputBuffer[_outputTail++] = BYTE_RCURLY;\n+        }\n+    }\n+\n+    protected final void _writeFieldName(String name)\n+        throws IOException, JsonGenerationException\n+    {\n+        /* To support [JACKSON-46], we'll do this:\n+         * (Question: should quoting of spaces (etc) still be enabled?)\n+         */\n+        if (!isEnabled(Feature.QUOTE_FIELD_NAMES)) {\n+            _writeStringSegments(name);\n+            return;\n+        }\n+        if (_outputTail >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n+        // The beef:\n+        final int len = name.length();\n+        if (len <= _charBufferLength) { // yes, fits right in\n+            name.getChars(0, len, _charBuffer, 0);\n+            // But as one segment, or multiple?\n+            if (len <= _outputMaxContiguous) {\n+                if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n+                    _flushBuffer();\n+                }\n+                _writeStringSegment(_charBuffer, 0, len);\n+            } else {\n+                _writeStringSegments(_charBuffer, 0, len);\n+            }\n+        } else {\n+            _writeStringSegments(name);\n+        }\n+\n+        // and closing quotes; need room for one more char:\n+        if (_outputTail >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n+    }\n+\n+    protected final void _writeFieldName(SerializableString name)\n+        throws IOException, JsonGenerationException\n+    {\n+        byte[] raw = name.asQuotedUTF8();\n+        if (!isEnabled(Feature.QUOTE_FIELD_NAMES)) {\n+            _writeBytes(raw);\n+            return;\n+        }\n+        if (_outputTail >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n+\n+        // Can do it all in buffer?\n+        final int len = raw.length;\n+        if ((_outputTail + len + 1) < _outputEnd) { // yup\n+            System.arraycopy(raw, 0, _outputBuffer, _outputTail, len);\n+            _outputTail += len;\n+            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n+        } else {\n+            _writeBytes(raw);\n+            if (_outputTail >= _outputEnd) {\n+                _flushBuffer();\n+            }\n+            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n+        }\n+    }    \n+    \n+    /**\n+     * Specialized version of <code>_writeFieldName</code>, off-lined\n+     * to keep the \"fast path\" as simple (and hopefully fast) as possible.\n+     */\n+    protected final void _writePPFieldName(String name, boolean commaBefore)\n+        throws IOException, JsonGenerationException\n+    {\n+        if (commaBefore) {\n+            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n+        } else {\n+            _cfgPrettyPrinter.beforeObjectEntries(this);\n+        }\n+\n+        if (isEnabled(Feature.QUOTE_FIELD_NAMES)) { // standard\n+            if (_outputTail >= _outputEnd) {\n+                _flushBuffer();\n+            }\n+            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n+            final int len = name.length();\n+            if (len <= _charBufferLength) { // yes, fits right in\n+                name.getChars(0, len, _charBuffer, 0);\n+                // But as one segment, or multiple?\n+                if (len <= _outputMaxContiguous) {\n+                    if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n+                        _flushBuffer();\n+                    }\n+                    _writeStringSegment(_charBuffer, 0, len);\n+                } else {\n+                    _writeStringSegments(_charBuffer, 0, len);\n+                }\n+            } else {\n+                _writeStringSegments(name);\n+            }\n+            if (_outputTail >= _outputEnd) {\n+                _flushBuffer();\n+            }\n+            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n+        } else { // non-standard, omit quotes\n+            _writeStringSegments(name);\n+        }\n+    }\n+\n+    protected final void _writePPFieldName(SerializableString name, boolean commaBefore)\n+        throws IOException, JsonGenerationException\n+    {\n+        if (commaBefore) {\n+            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n+        } else {\n+            _cfgPrettyPrinter.beforeObjectEntries(this);\n+        }\n+\n+        boolean addQuotes = isEnabled(Feature.QUOTE_FIELD_NAMES); // standard\n+        if (addQuotes) {\n+            if (_outputTail >= _outputEnd) {\n+                _flushBuffer();\n+            }\n+            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n+        }\n+        _writeBytes(name.asQuotedUTF8());\n+        if (addQuotes) {\n+            if (_outputTail >= _outputEnd) {\n+                _flushBuffer();\n+            }\n+            _outputBuffer[_outputTail++] = BYTE_QUOTE;\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Output method implementations, textual\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeString(String text)\n+        throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write text value\");\n+        if (text == null) {\n+            _writeNull();\n+            return;\n+        }\n+        // First: can we make a local copy of chars that make up text?\n+        final int len = text.length();\n+        if (len > _charBufferLength) { // nope: off-line handling\n+            _writeLongString(text);\n+            return;\n+        }\n+        // yes: good.\n+        text.getChars(0, len, _charBuffer, 0);\n+        // Output: if we can't guarantee it fits in output buffer, off-line as well:\n+        if (len > _outputMaxContiguous) {\n+            _writeLongString(_charBuffer, 0, len);\n+            return;\n+        }\n+        if ((_outputTail + len) >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n+        _writeStringSegment(_charBuffer, 0, len); // we checked space already above\n+        /* [JACKSON-462] But that method may have had to expand multi-byte Unicode\n+         *   chars, so we must check again\n+         */\n+        if (_outputTail >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n+    }\n+\n+    private final void _writeLongString(String text)\n+        throws IOException, JsonGenerationException\n+    {\n+        if (_outputTail >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n+        _writeStringSegments(text);\n+        if (_outputTail >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n+    }\n+\n+    private final void _writeLongString(char[] text, int offset, int len)\n+        throws IOException, JsonGenerationException\n+    {\n+        if (_outputTail >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n+        _writeStringSegments(_charBuffer, 0, len);\n+        if (_outputTail >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n+    }\n+\n+    @Override\n+    public void writeString(char[] text, int offset, int len)\n+        throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write text value\");\n+        if (_outputTail >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n+        // One or multiple segments?\n+        if (len <= _outputMaxContiguous) {\n+            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n+                _flushBuffer();\n+            }\n+            _writeStringSegment(text, offset, len);\n+        } else {\n+            _writeStringSegments(text, offset, len);\n+        }\n+        // And finally, closing quotes\n+        if (_outputTail >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n+    }\n+\n+    @Override\n+    public final void writeString(SerializableString text)\n+        throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write text value\");\n+        if (_outputTail >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n+        _writeBytes(text.asQuotedUTF8());\n+        if (_outputTail >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n+    }\n+\n+    @Override\n+    public void writeRawUTF8String(byte[] text, int offset, int length)\n+        throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write text value\");\n+        if (_outputTail >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n+        _writeBytes(text, offset, length);\n+        if (_outputTail >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n+    }\n+\n+    @Override\n+    public void writeUTF8String(byte[] text, int offset, int len)\n+        throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write text value\");\n+        if (_outputTail >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n+        // One or multiple segments?\n+        if (len <= _outputMaxContiguous) {\n+            _writeUTF8Segment(text, offset, len);\n+        } else {\n+            _writeUTF8Segments(text, offset, len);\n+        }\n+        if (_outputTail >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Output method implementations, unprocessed (\"raw\")\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeRaw(String text)\n+        throws IOException, JsonGenerationException\n+    {\n+        int start = 0;\n+        int len = text.length();\n+        while (len > 0) {\n+            char[] buf = _charBuffer;\n+            final int blen = buf.length;\n+            final int len2 = (len < blen) ? len : blen;\n+            text.getChars(start, start+len2, buf, 0);\n+            writeRaw(buf, 0, len2);\n+            start += len2;\n+            len -= len2;\n+        }\n+    }\n+\n+    @Override\n+    public void writeRaw(String text, int offset, int len)\n+        throws IOException, JsonGenerationException\n+    {\n+        while (len > 0) {\n+            char[] buf = _charBuffer;\n+            final int blen = buf.length;\n+            final int len2 = (len < blen) ? len : blen;\n+            text.getChars(offset, offset+len2, buf, 0);\n+            writeRaw(buf, 0, len2);\n+            offset += len2;\n+            len -= len2;\n+        }\n+    }\n+\n+    // @TODO: rewrite for speed...\n+    @Override\n+    public final void writeRaw(char[] cbuf, int offset, int len)\n+        throws IOException, JsonGenerationException\n+    {\n+        // First: if we have 3 x charCount spaces, we know it'll fit just fine\n+        {\n+            int len3 = len+len+len;\n+            if ((_outputTail + len3) > _outputEnd) {\n+                // maybe we could flush?\n+                if (_outputEnd < len3) { // wouldn't be enough...\n+                    _writeSegmentedRaw(cbuf, offset, len);\n+                    return;\n+                }\n+                // yes, flushing brings enough space\n+                _flushBuffer();\n+            }\n+        }\n+        len += offset; // now marks the end\n+\n+        // Note: here we know there is enough room, hence no output boundary checks\n+        main_loop:\n+        while (offset < len) {\n+            inner_loop:\n+            while (true) {\n+                int ch = (int) cbuf[offset];\n+                if (ch > 0x7F) {\n+                    break inner_loop;\n+                }\n+                _outputBuffer[_outputTail++] = (byte) ch;\n+                if (++offset >= len) {\n+                    break main_loop;\n+                }\n+            }\n+            char ch = cbuf[offset++];\n+            if (ch < 0x800) { // 2-byte?\n+                _outputBuffer[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n+                _outputBuffer[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n+            } else {\n+                _outputRawMultiByteChar(ch, cbuf, offset, len);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void writeRaw(char ch)\n+        throws IOException, JsonGenerationException\n+    {\n+        if ((_outputTail + 3) >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        final byte[] bbuf = _outputBuffer;\n+        if (ch <= 0x7F) {\n+            bbuf[_outputTail++] = (byte) ch;\n+        } else  if (ch < 0x800) { // 2-byte?\n+            bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n+            bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n+        } else {\n+            _outputRawMultiByteChar(ch, null, 0, 0);\n+        }\n+    }\n+\n+    /**\n+     * Helper method called when it is possible that output of raw section\n+     * to output may cross buffer boundary\n+     */\n+    private final void _writeSegmentedRaw(char[] cbuf, int offset, int len)\n+        throws IOException, JsonGenerationException\n+    {\n+        final int end = _outputEnd;\n+        final byte[] bbuf = _outputBuffer;\n+        \n+        main_loop:\n+        while (offset < len) {\n+            inner_loop:\n+            while (true) {\n+                int ch = (int) cbuf[offset];\n+                if (ch >= 0x80) {\n+                    break inner_loop;\n+                }\n+                // !!! TODO: fast(er) writes (roll input, output checks in one)\n+                if (_outputTail >= end) {\n+                    _flushBuffer();\n+                }\n+                bbuf[_outputTail++] = (byte) ch;\n+                if (++offset >= len) {\n+                    break main_loop;\n+                }\n+            }\n+            if ((_outputTail + 3) >= _outputEnd) {\n+                _flushBuffer();\n+            }\n+            char ch = cbuf[offset++];\n+            if (ch < 0x800) { // 2-byte?\n+                bbuf[_outputTail++] = (byte) (0xc0 | (ch >> 6));\n+                bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n+            } else {\n+                _outputRawMultiByteChar(ch, cbuf, offset, len);\n+            }\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Output method implementations, base64-encoded binary\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len)\n+        throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write binary value\");\n+        // Starting quotes\n+        if (_outputTail >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n+        _writeBinary(b64variant, data, offset, offset+len);\n+        // and closing quotes\n+        if (_outputTail >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Output method implementations, primitive\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeNumber(int i)\n+        throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write number\");\n+        // up to 10 digits and possible minus sign\n+        if ((_outputTail + 11) >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        if (_cfgNumbersAsStrings) {\n+            _writeQuotedInt(i);\n+            return;\n+        }\n+        _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);\n+    }\n+\n+    private final void _writeQuotedInt(int i) throws IOException {\n+        if ((_outputTail + 13) >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n+        _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);\n+        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n+    }    \n+\n+    @Override\n+    public void writeNumber(long l)\n+        throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write number\");\n+        if (_cfgNumbersAsStrings) {\n+            _writeQuotedLong(l);\n+            return;\n+        }\n+        if ((_outputTail + 21) >= _outputEnd) {\n+            // up to 20 digits, minus sign\n+            _flushBuffer();\n+        }\n+        _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);\n+    }\n+\n+    private final void _writeQuotedLong(long l) throws IOException {\n+        if ((_outputTail + 23) >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n+        _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);\n+        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n+    }\n+\n+    @Override\n+    public void writeNumber(BigInteger value)\n+        throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write number\");\n+        if (value == null) {\n+            _writeNull();\n+        } else if (_cfgNumbersAsStrings) {\n+            _writeQuotedRaw(value);\n+        } else {\n+            writeRaw(value.toString());\n+        }\n+    }\n+\n+    \n+    @Override\n+    public void writeNumber(double d)\n+        throws IOException, JsonGenerationException\n+    {\n+        if (_cfgNumbersAsStrings ||\n+            // [JACKSON-139]\n+            (((Double.isNaN(d) || Double.isInfinite(d))\n+                && isEnabled(Feature.QUOTE_NON_NUMERIC_NUMBERS)))) {\n+            writeString(String.valueOf(d));\n+            return;\n+        }\n+        // What is the max length for doubles? 40 chars?\n+        _verifyValueWrite(\"write number\");\n+        writeRaw(String.valueOf(d));\n+    }\n+\n+    @Override\n+    public void writeNumber(float f)\n+        throws IOException, JsonGenerationException\n+    {\n+        if (_cfgNumbersAsStrings ||\n+            // [JACKSON-139]\n+            (((Float.isNaN(f) || Float.isInfinite(f))\n+                && isEnabled(Feature.QUOTE_NON_NUMERIC_NUMBERS)))) {\n+            writeString(String.valueOf(f));\n+            return;\n+        }\n+        // What is the max length for floats?\n+        _verifyValueWrite(\"write number\");\n+        writeRaw(String.valueOf(f));\n+    }\n+\n+    @Override\n+    public void writeNumber(BigDecimal value)\n+        throws IOException, JsonGenerationException\n+    {\n+        // Don't really know max length for big decimal, no point checking\n+        _verifyValueWrite(\"write number\");\n+        if (value == null) {\n+            _writeNull();\n+        } else if (_cfgNumbersAsStrings) {\n+            _writeQuotedRaw(value);\n+        } else {\n+            writeRaw(value.toString());\n+        }\n+    }\n+\n+    @Override\n+    public void writeNumber(String encodedValue)\n+        throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write number\");\n+        if (_cfgNumbersAsStrings) {\n+            _writeQuotedRaw(encodedValue);            \n+        } else {\n+            writeRaw(encodedValue);\n+        }\n+    }\n+\n+    private final void _writeQuotedRaw(Object value) throws IOException\n+    {\n+        if (_outputTail >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n+        writeRaw(value.toString());\n+        if (_outputTail >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n+    }\n+    \n+    @Override\n+    public void writeBoolean(boolean state)\n+        throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write boolean value\");\n+        if ((_outputTail + 5) >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        byte[] keyword = state ? TRUE_BYTES : FALSE_BYTES;\n+        int len = keyword.length;\n+        System.arraycopy(keyword, 0, _outputBuffer, _outputTail, len);\n+        _outputTail += len;\n+    }\n+\n+    @Override\n+    public void writeNull()\n+        throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write null value\");\n+        _writeNull();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Implementations for other methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    protected final void _verifyValueWrite(String typeMsg)\n+        throws IOException, JsonGenerationException\n+    {\n+        int status = _writeContext.writeValue();\n+        if (status == JsonWriteContext.STATUS_EXPECT_NAME) {\n+            _reportError(\"Can not \"+typeMsg+\", expecting field name\");\n+        }\n+        if (_cfgPrettyPrinter == null) {\n+            byte b;\n+            switch (status) {\n+            case JsonWriteContext.STATUS_OK_AFTER_COMMA:\n+                b = BYTE_COMMA;\n+                break;\n+            case JsonWriteContext.STATUS_OK_AFTER_COLON:\n+                b = BYTE_COLON;\n+                break;\n+            case JsonWriteContext.STATUS_OK_AFTER_SPACE:\n+                b = BYTE_SPACE;\n+                break;\n+            case JsonWriteContext.STATUS_OK_AS_IS:\n+            default:\n+                return;\n+            }\n+            if (_outputTail >= _outputEnd) {\n+                _flushBuffer();\n+            }\n+            _outputBuffer[_outputTail] = b;\n+            ++_outputTail;\n+            return;\n+        }\n+        // Otherwise, pretty printer knows what to do...\n+        _verifyPrettyValueWrite(typeMsg, status);\n+    }\n+\n+    protected final void _verifyPrettyValueWrite(String typeMsg, int status)\n+        throws IOException, JsonGenerationException\n+    {\n+        // If we have a pretty printer, it knows what to do:\n+        switch (status) {\n+        case JsonWriteContext.STATUS_OK_AFTER_COMMA: // array\n+            _cfgPrettyPrinter.writeArrayValueSeparator(this);\n+            break;\n+        case JsonWriteContext.STATUS_OK_AFTER_COLON:\n+            _cfgPrettyPrinter.writeObjectFieldValueSeparator(this);\n+            break;\n+        case JsonWriteContext.STATUS_OK_AFTER_SPACE:\n+            _cfgPrettyPrinter.writeRootValueSeparator(this);\n+            break;\n+        case JsonWriteContext.STATUS_OK_AS_IS:\n+            // First entry, but of which context?\n+            if (_writeContext.inArray()) {\n+                _cfgPrettyPrinter.beforeArrayValues(this);\n+            } else if (_writeContext.inObject()) {\n+                _cfgPrettyPrinter.beforeObjectEntries(this);\n+            }\n+            break;\n+        default:\n+            _cantHappen();\n+            break;\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Low-level output handling\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public final void flush()\n+        throws IOException\n+    {\n+        _flushBuffer();\n+        if (_outputStream != null) {\n+            if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {\n+                _outputStream.flush();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void close()\n+        throws IOException\n+    {\n+        super.close();\n+\n+        /* 05-Dec-2008, tatu: To add [JACKSON-27], need to close open\n+         *   scopes.\n+         */\n+        // First: let's see that we still have buffers...\n+        if (_outputBuffer != null\n+            && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) {\n+            while (true) {\n+                JsonStreamContext ctxt = getOutputContext();\n+                if (ctxt.inArray()) {\n+                    writeEndArray();\n+                } else if (ctxt.inObject()) {\n+                    writeEndObject();\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+        _flushBuffer();\n+\n+        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n+         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n+         *   feature is enabled.\n+         *   One downside: when using UTF8Writer, underlying buffer(s)\n+         *   may not be properly recycled if we don't close the writer.\n+         */\n+        if (_outputStream != null) {\n+            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) {\n+                _outputStream.close();\n+            } else  if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {\n+                // If we can't close it, we should at least flush\n+                _outputStream.flush();\n+            }\n+        }\n+        // Internal buffer(s) generator has can now be released as well\n+        _releaseBuffers();\n+    }\n+\n+    @Override\n+    protected void _releaseBuffers()\n+    {\n+        byte[] buf = _outputBuffer;\n+        if (buf != null && _bufferRecyclable) {\n+            _outputBuffer = null;\n+            _ioContext.releaseWriteEncodingBuffer(buf);\n+        }\n+        char[] cbuf = _charBuffer;\n+        if (cbuf != null) {\n+            _charBuffer = null;\n+            _ioContext.releaseConcatBuffer(cbuf);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods, low-level writing, raw bytes\n+    /**********************************************************\n+     */\n+\n+    private final void _writeBytes(byte[] bytes) throws IOException\n+    {\n+        final int len = bytes.length;\n+        if ((_outputTail + len) > _outputEnd) {\n+            _flushBuffer();\n+            // still not enough?\n+            if (len > MAX_BYTES_TO_BUFFER) {\n+                _outputStream.write(bytes, 0, len);\n+                return;\n+            }\n+        }\n+        System.arraycopy(bytes, 0, _outputBuffer, _outputTail, len);\n+        _outputTail += len;\n+    }\n+\n+    private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException\n+    {\n+        if ((_outputTail + len) > _outputEnd) {\n+            _flushBuffer();\n+            // still not enough?\n+            if (len > MAX_BYTES_TO_BUFFER) {\n+                _outputStream.write(bytes, offset, len);\n+                return;\n+            }\n+        }\n+        System.arraycopy(bytes, offset, _outputBuffer, _outputTail, len);\n+        _outputTail += len;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods, mid-level writing, String segments\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method called when String to write is long enough not to fit\n+     * completely in temporary copy buffer. If so, we will actually\n+     * copy it in small enough chunks so it can be directly fed\n+     * to single-segment writes (instead of maximum slices that\n+     * would fit in copy buffer)\n+     */\n+    private final void _writeStringSegments(String text)\n+        throws IOException, JsonGenerationException\n+    {\n+        int left = text.length();\n+        int offset = 0;\n+        final char[] cbuf = _charBuffer;\n+\n+        while (left > 0) {\n+            int len = Math.min(_outputMaxContiguous, left);\n+            text.getChars(offset, offset+len, cbuf, 0);\n+            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n+                _flushBuffer();\n+            }\n+            _writeStringSegment(cbuf, 0, len);\n+            offset += len;\n+            left -= len;\n+        }\n+    }\n+\n+    /**\n+     * Method called when character sequence to write is long enough that\n+     * its maximum encoded and escaped form is not guaranteed to fit in\n+     * the output buffer. If so, we will need to choose smaller output\n+     * chunks to write at a time.\n+     */\n+    private final void _writeStringSegments(char[] cbuf, int offset, int totalLen)\n+        throws IOException, JsonGenerationException\n+    {\n+        do {\n+            int len = Math.min(_outputMaxContiguous, totalLen);\n+            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n+                _flushBuffer();\n+            }\n+            _writeStringSegment(cbuf, offset, len);\n+            offset += len;\n+            totalLen -= len;\n+        } while (totalLen > 0);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods, low-level writing, text segments\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * This method called when the string content is already in\n+     * a char buffer, and its maximum total encoded and escaped length\n+     * can not exceed size of the output buffer.\n+     * Caller must ensure that there is enough space in output buffer,\n+     * assuming case of all non-escaped ASCII characters, as well as\n+     * potentially enough space for other cases (but not necessarily flushed)\n+     */\n+    private final void _writeStringSegment(char[] cbuf, int offset, int len)\n+        throws IOException, JsonGenerationException\n+    {\n+        // note: caller MUST ensure (via flushing) there's room for ASCII only\n+        \n+        // Fast+tight loop for ASCII-only, no-escaping-needed output\n+        len += offset; // becomes end marker, then\n+\n+        int outputPtr = _outputTail;\n+        final byte[] outputBuffer = _outputBuffer;\n+        final int[] escCodes = _outputEscapes;\n+\n+        while (offset < len) {\n+            int ch = cbuf[offset];\n+            // note: here we know that (ch > 0x7F) will cover case of escaping non-ASCII too:\n+            if (ch > 0x7F || escCodes[ch] != 0) {\n+                break;\n+            }\n+            outputBuffer[outputPtr++] = (byte) ch;\n+            ++offset;\n+        }\n+        _outputTail = outputPtr;\n+        if (offset < len) {\n+            // [JACKSON-106]\n+            if (_characterEscapes != null) {\n+                _writeCustomStringSegment2(cbuf, offset, len);\n+            // [JACKSON-102]\n+            } else if (_maximumNonEscapedChar == 0) {\n+                _writeStringSegment2(cbuf, offset, len);\n+            } else {\n+                _writeStringSegmentASCII2(cbuf, offset, len);\n+            }\n+\n+        }\n+    }\n+\n+    /**\n+     * Secondary method called when content contains characters to escape,\n+     * and/or multi-byte UTF-8 characters.\n+     */\n+    private final void _writeStringSegment2(final char[] cbuf, int offset, final int end)\n+        throws IOException, JsonGenerationException\n+    {\n+        // Ok: caller guarantees buffer can have room; but that may require flushing:\n+        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n+            _flushBuffer();\n+        }\n+\n+        int outputPtr = _outputTail;\n+\n+        final byte[] outputBuffer = _outputBuffer;\n+        final int[] escCodes = _outputEscapes;\n+        \n+        while (offset < end) {\n+            int ch = cbuf[offset++];\n+            if (ch <= 0x7F) {\n+                 if (escCodes[ch] == 0) {\n+                     outputBuffer[outputPtr++] = (byte) ch;\n+                     continue;\n+                 }\n+                 int escape = escCodes[ch];\n+                 if (escape > 0) { // 2-char escape, fine\n+                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n+                     outputBuffer[outputPtr++] = (byte) escape;\n+                 } else {\n+                     // ctrl-char, 6-byte escape...\n+                     outputPtr = _writeGenericEscape(ch, outputPtr);\n+                }\n+                continue;\n+            }\n+            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n+                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n+                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n+            } else {\n+                outputPtr = _outputMultiByteChar(ch, outputPtr);\n+            }\n+        }\n+        _outputTail = outputPtr;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods, low-level writing, text segment\n+    /* with additional escaping (ASCII or such)\n+    /* (since 1.8; see [JACKSON-102])\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Same as <code>_writeStringSegment2(char[], ...)</code., but with\n+     * additional escaping for high-range code points\n+     * \n+     * @since 1.8\n+     */\n+    private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end)\n+        throws IOException, JsonGenerationException\n+    {\n+        // Ok: caller guarantees buffer can have room; but that may require flushing:\n+        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n+            _flushBuffer();\n+        }\n+    \n+        int outputPtr = _outputTail;\n+    \n+        final byte[] outputBuffer = _outputBuffer;\n+        final int[] escCodes = _outputEscapes;\n+        final int maxUnescaped = _maximumNonEscapedChar;\n+        \n+        while (offset < end) {\n+            int ch = cbuf[offset++];\n+            if (ch <= 0x7F) {\n+                 if (escCodes[ch] == 0) {\n+                     outputBuffer[outputPtr++] = (byte) ch;\n+                     continue;\n+                 }\n+                 int escape = escCodes[ch];\n+                 if (escape > 0) { // 2-char escape, fine\n+                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n+                     outputBuffer[outputPtr++] = (byte) escape;\n+                 } else {\n+                     // ctrl-char, 6-byte escape...\n+                     outputPtr = _writeGenericEscape(ch, outputPtr);\n+                 }\n+                 continue;\n+            }\n+            if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars:\n+                outputPtr = _writeGenericEscape(ch, outputPtr);\n+                continue;\n+            }\n+            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n+                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n+                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n+            } else {\n+                outputPtr = _outputMultiByteChar(ch, outputPtr);\n+            }\n+        }\n+        _outputTail = outputPtr;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods, low-level writing, text segment\n+    /* with fully custom escaping (and possibly escaping of non-ASCII\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Same as <code>_writeStringSegmentASCII2(char[], ...)</code., but with\n+     * additional checking for completely custom escapes\n+     * \n+     * @since 1.8\n+     */\n+    private final void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end)\n+        throws IOException, JsonGenerationException\n+    {\n+        // Ok: caller guarantees buffer can have room; but that may require flushing:\n+        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n+            _flushBuffer();\n+        }\n+        int outputPtr = _outputTail;\n+    \n+        final byte[] outputBuffer = _outputBuffer;\n+        final int[] escCodes = _outputEscapes;\n+        // may or may not have this limit\n+        final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar;\n+        final CharacterEscapes customEscapes = _characterEscapes; // non-null\n+        \n+        while (offset < end) {\n+            int ch = cbuf[offset++];\n+            if (ch <= 0x7F) {\n+                 if (escCodes[ch] == 0) {\n+                     outputBuffer[outputPtr++] = (byte) ch;\n+                     continue;\n+                 }\n+                 int escape = escCodes[ch];\n+                 if (escape > 0) { // 2-char escape, fine\n+                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n+                     outputBuffer[outputPtr++] = (byte) escape;\n+                 } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) {\n+                     SerializableString esc = customEscapes.getEscapeSequence(ch);\n+                     if (esc == null) {\n+                         throw new JsonGenerationException(\"Invalid custom escape definitions; custom escape not found for character code 0x\"\n+                                 +Integer.toHexString(ch)+\", although was supposed to have one\");\n+                     }\n+                     outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n+                 } else {\n+                     // ctrl-char, 6-byte escape...\n+                     outputPtr = _writeGenericEscape(ch, outputPtr);\n+                 }\n+                 continue;\n+            }\n+            if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars:\n+                outputPtr = _writeGenericEscape(ch, outputPtr);\n+                continue;\n+            }\n+            SerializableString esc = customEscapes.getEscapeSequence(ch);\n+            if (esc != null) {\n+                outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n+                continue;\n+            }\n+            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n+                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n+                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n+            } else {\n+                outputPtr = _outputMultiByteChar(ch, outputPtr);\n+            }\n+        }\n+        _outputTail = outputPtr;\n+    }\n+\n+    private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars)\n+        throws IOException, JsonGenerationException\n+    {\n+        byte[] raw = esc.asUnquotedUTF8(); // must be escaped at this point, shouldn't double-quote\n+        int len = raw.length;\n+        if (len > 6) { // may violate constraints we have, do offline\n+            return _handleLongCustomEscape(outputBuffer, outputPtr, _outputEnd, raw, remainingChars);\n+        }\n+        // otherwise will fit without issues, so:\n+        System.arraycopy(raw, 0, outputBuffer, outputPtr, len);\n+        return (outputPtr + len);\n+    }\n+    \n+    private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw,\n+            int remainingChars)\n+        throws IOException, JsonGenerationException\n+    {\n+        int len = raw.length;\n+        if ((outputPtr + len) > outputEnd) {\n+            _outputTail = outputPtr;\n+            _flushBuffer();\n+            outputPtr = _outputTail;\n+            if (len > outputBuffer.length) { // very unlikely, but possible...\n+                _outputStream.write(raw, 0, len);\n+                return outputPtr;\n+            }\n+            System.arraycopy(raw, 0, outputBuffer, outputPtr, len);\n+            outputPtr += len;\n+        }\n+        // but is the invariant still obeyed? If not, flush once more\n+        if ((outputPtr +  6 * remainingChars) > outputEnd) {\n+            _flushBuffer();\n+            return _outputTail;\n+        }\n+        return outputPtr;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods, low-level writing, \"raw UTF-8\" segments\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method called when UTF-8 encoded (but NOT yet escaped!) content is not guaranteed\n+     * to fit in the output buffer after escaping; as such, we just need to\n+     * chunk writes.\n+     */\n+    private final void _writeUTF8Segments(byte[] utf8, int offset, int totalLen)\n+        throws IOException, JsonGenerationException\n+    {\n+        do {\n+            int len = Math.min(_outputMaxContiguous, totalLen);\n+            _writeUTF8Segment(utf8, offset, len);\n+            offset += len;\n+            totalLen -= len;\n+        } while (totalLen > 0);\n+    }\n+    \n+    private final void _writeUTF8Segment(byte[] utf8, final int offset, final int len)\n+        throws IOException, JsonGenerationException\n+    {\n+        // fast loop to see if escaping is needed; don't copy, just look\n+        final int[] escCodes = _outputEscapes;\n+\n+        for (int ptr = offset, end = offset + len; ptr < end; ) {\n+            // 28-Feb-2011, tatu: escape codes just cover 7-bit range, so:\n+            int ch = utf8[ptr++];\n+            if ((ch >= 0) && escCodes[ch] != 0) {\n+                _writeUTF8Segment2(utf8, offset, len);\n+                return;\n+            }\n+        }\n+        \n+        // yes, fine, just copy the sucker\n+        if ((_outputTail + len) > _outputEnd) { // enough room or need to flush?\n+            _flushBuffer(); // but yes once we flush (caller guarantees length restriction)\n+        }\n+        System.arraycopy(utf8, offset, _outputBuffer, _outputTail, len);\n+        _outputTail += len;\n+    }\n+\n+    private final void _writeUTF8Segment2(final byte[] utf8, int offset, int len)\n+        throws IOException, JsonGenerationException\n+    {\n+        int outputPtr = _outputTail;\n+\n+        // Ok: caller guarantees buffer can have room; but that may require flushing:\n+        if ((outputPtr + (len * 6)) > _outputEnd) {\n+            _flushBuffer();\n+            outputPtr = _outputTail;\n+        }\n+        \n+        final byte[] outputBuffer = _outputBuffer;\n+        final int[] escCodes = _outputEscapes;\n+        len += offset; // so 'len' becomes 'end'\n+        \n+        while (offset < len) {\n+            byte b = utf8[offset++];\n+            int ch = b;\n+            if (ch < 0 || escCodes[ch] == 0) {\n+                outputBuffer[outputPtr++] = b;\n+                continue;\n+            }\n+            int escape = escCodes[ch];\n+            if (escape > 0) { // 2-char escape, fine\n+                outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n+                outputBuffer[outputPtr++] = (byte) escape;\n+            } else {\n+                // ctrl-char, 6-byte escape...\n+                outputPtr = _writeGenericEscape(ch, outputPtr);\n+            }\n+        }\n+        _outputTail = outputPtr;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Internal methods, low-level writing, base64 encoded\n+    /**********************************************************\n+     */\n+    \n+    protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd)\n+        throws IOException, JsonGenerationException\n+    {\n+        // Encoding is by chunks of 3 input, 4 output chars, so:\n+        int safeInputEnd = inputEnd - 3;\n+        // Let's also reserve room for possible (and quoted) lf char each round\n+        int safeOutputEnd = _outputEnd - 6;\n+        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n+\n+        // Ok, first we loop through all full triplets of data:\n+        while (inputPtr <= safeInputEnd) {\n+            if (_outputTail > safeOutputEnd) { // need to flush\n+                _flushBuffer();\n+            }\n+            // First, mash 3 bytes into lsb of 32-bit int\n+            int b24 = ((int) input[inputPtr++]) << 8;\n+            b24 |= ((int) input[inputPtr++]) & 0xFF;\n+            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n+            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n+            if (--chunksBeforeLF <= 0) {\n+                // note: must quote in JSON value\n+                _outputBuffer[_outputTail++] = '\\\\';\n+                _outputBuffer[_outputTail++] = 'n';\n+                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n+            }\n+        }\n+\n+        // And then we may have 1 or 2 leftover bytes to encode\n+        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n+        if (inputLeft > 0) { // yes, but do we have room for output?\n+            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n+                _flushBuffer();\n+            }\n+            int b24 = ((int) input[inputPtr++]) << 16;\n+            if (inputLeft == 2) {\n+                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n+            }\n+            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods, character escapes/encoding\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method called to output a character that is beyond range of\n+     * 1- and 2-byte UTF-8 encodings, when outputting \"raw\" \n+     * text (meaning it is not to be escaped or quoted)\n+     */\n+    private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen)\n+        throws IOException\n+    {\n+        // Let's handle surrogates gracefully (as 4 byte output):\n+        if (ch >= SURR1_FIRST) {\n+            if (ch <= SURR2_LAST) { // yes, outside of BMP\n+                // Do we have second part?\n+                if (inputOffset >= inputLen) { // nope... have to note down\n+                    _reportError(\"Split surrogate on writeRaw() input (last character)\");\n+                }\n+                _outputSurrogates(ch, cbuf[inputOffset]);\n+                return (inputOffset+1);\n+            }\n+        }\n+        final byte[] bbuf = _outputBuffer;\n+        bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));\n+        bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n+        bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));\n+        return inputOffset;\n+    }\n+\n+    protected final void _outputSurrogates(int surr1, int surr2)\n+        throws IOException\n+    {\n+        int c = _decodeSurrogate(surr1, surr2);\n+        if ((_outputTail + 4) > _outputEnd) {\n+            _flushBuffer();\n+        }\n+        final byte[] bbuf = _outputBuffer;\n+        bbuf[_outputTail++] = (byte) (0xf0 | (c >> 18));\n+        bbuf[_outputTail++] = (byte) (0x80 | ((c >> 12) & 0x3f));\n+        bbuf[_outputTail++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n+        bbuf[_outputTail++] = (byte) (0x80 | (c & 0x3f));\n+    }\n+    \n+    /**\n+     * \n+     * @param ch\n+     * @param outputPtr Position within output buffer to append multi-byte in\n+     * \n+     * @return New output position after appending\n+     * \n+     * @throws IOException\n+     */\n+    private final int _outputMultiByteChar(int ch, int outputPtr)\n+        throws IOException\n+    {\n+        byte[] bbuf = _outputBuffer;\n+        if (ch >= SURR1_FIRST && ch <= SURR2_LAST) { // yes, outside of BMP; add an escape\n+            bbuf[outputPtr++] = BYTE_BACKSLASH;\n+            bbuf[outputPtr++] = BYTE_u;\n+            \n+            bbuf[outputPtr++] = HEX_CHARS[(ch >> 12) & 0xF];\n+            bbuf[outputPtr++] = HEX_CHARS[(ch >> 8) & 0xF];\n+            bbuf[outputPtr++] = HEX_CHARS[(ch >> 4) & 0xF];\n+            bbuf[outputPtr++] = HEX_CHARS[ch & 0xF];\n+        } else {\n+            bbuf[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n+            bbuf[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n+            bbuf[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n+        }\n+        return outputPtr;\n+    }\n+\n+    protected final int _decodeSurrogate(int surr1, int surr2) throws IOException\n+    {\n+        // First is known to be valid, but how about the other?\n+        if (surr2 < SURR2_FIRST || surr2 > SURR2_LAST) {\n+            String msg = \"Incomplete surrogate pair: first char 0x\"+Integer.toHexString(surr1)+\", second 0x\"+Integer.toHexString(surr2);\n+            _reportError(msg);\n+        }\n+        int c = 0x10000 + ((surr1 - SURR1_FIRST) << 10) + (surr2 - SURR2_FIRST);\n+        return c;\n+    }\n+    \n+    private final void _writeNull() throws IOException\n+    {\n+        if ((_outputTail + 4) >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        System.arraycopy(NULL_BYTES, 0, _outputBuffer, _outputTail, 4);\n+        _outputTail += 4;\n+    }\n+        \n+    /**\n+     * Method called to write a generic Unicode escape for given character.\n+     * \n+     * @param charToEscape Character to escape using escape sequence (\\\\uXXXX)\n+     */\n+    private int _writeGenericEscape(int charToEscape, int outputPtr)\n+        throws IOException\n+    {\n+        final byte[] bbuf = _outputBuffer;\n+        bbuf[outputPtr++] = BYTE_BACKSLASH;\n+        bbuf[outputPtr++] = BYTE_u;\n+        if (charToEscape > 0xFF) {\n+            int hi = (charToEscape >> 8) & 0xFF;\n+            bbuf[outputPtr++] = HEX_CHARS[hi >> 4];\n+            bbuf[outputPtr++] = HEX_CHARS[hi & 0xF];\n+            charToEscape &= 0xFF;\n+        } else {\n+            bbuf[outputPtr++] = BYTE_0;\n+            bbuf[outputPtr++] = BYTE_0;\n+        }\n+        // We know it's a control char, so only the last 2 chars are non-0\n+        bbuf[outputPtr++] = HEX_CHARS[charToEscape >> 4];\n+        bbuf[outputPtr++] = HEX_CHARS[charToEscape & 0xF];\n+        return outputPtr;\n+    }\n+\n+    protected final void _flushBuffer() throws IOException\n+    {\n+        int len = _outputTail;\n+        if (len > 0) {\n+            _outputTail = 0;\n+            _outputStream.write(_outputBuffer, 0, len);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+package com.fasterxml.jackson.core.json;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.base.ParserBase;\n+import com.fasterxml.jackson.core.io.CharTypes;\n+import com.fasterxml.jackson.core.io.IOContext;\n+import com.fasterxml.jackson.core.sym.*;\n+import com.fasterxml.jackson.core.util.*;\n+\n+/**\n+ * This is a concrete implementation of {@link JsonParser}, which is\n+ * based on a {@link java.io.InputStream} as the input source.\n+ */\n+public final class UTF8StreamJsonParser\n+    extends ParserBase\n+{\n+    final static byte BYTE_LF = (byte) '\\n';\n+\n+    private final static int[] sInputCodesUtf8 = CharTypes.getInputCodeUtf8();\n+\n+    /**\n+     * Latin1 encoding is not supported, but we do use 8-bit subset for\n+     * pre-processing task, to simplify first pass, keep it fast.\n+     */\n+    private final static int[] sInputCodesLatin1 = CharTypes.getInputCodeLatin1();\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Codec used for data binding when (if) requested; typically full\n+     * <code>ObjectMapper</code>, but that abstract is not part of core\n+     * package.\n+     */\n+    protected ObjectCodec _objectCodec;\n+\n+    /**\n+     * Symbol table that contains field names encountered so far\n+     */\n+    final protected BytesToNameCanonicalizer _symbols;\n+    \n+    /*\n+    /**********************************************************\n+    /* Parsing state\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Temporary buffer used for name parsing.\n+     */\n+    protected int[] _quadBuffer = new int[16];\n+\n+    /**\n+     * Flag that indicates that the current token has not yet\n+     * been fully processed, and needs to be finished for\n+     * some access (or skipped to obtain the next token)\n+     */\n+    protected boolean _tokenIncomplete = false;\n+\n+    /**\n+     * Temporary storage for partially parsed name bytes.\n+     */\n+    private int _quad1;\n+    \n+    /*\n+    /**********************************************************\n+    /* Input buffering (from former 'StreamBasedParserBase')\n+    /**********************************************************\n+     */\n+    \n+    protected InputStream _inputStream;\n+\n+    /*\n+    /**********************************************************\n+    /* Current input data\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Current buffer from which data is read; generally data is read into\n+     * buffer from input source, but in some cases pre-loaded buffer\n+     * is handed to the parser.\n+     */\n+    protected byte[] _inputBuffer;\n+\n+    /**\n+     * Flag that indicates whether the input buffer is recycable (and\n+     * needs to be returned to recycler once we are done) or not.\n+     *<p>\n+     * If it is not, it also means that parser can NOT modify underlying\n+     * buffer.\n+     */\n+    protected boolean _bufferRecyclable;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in,\n+            ObjectCodec codec, BytesToNameCanonicalizer sym,\n+            byte[] inputBuffer, int start, int end,\n+            boolean bufferRecyclable)\n+    {\n+        super(ctxt, features);\n+        _inputStream = in;\n+        _objectCodec = codec;\n+        _symbols = sym;\n+        _inputBuffer = inputBuffer;\n+        _inputPtr = start;\n+        _inputEnd = end;\n+        _bufferRecyclable = bufferRecyclable;\n+        // 12-Mar-2010, tatus: Sanity check, related to [JACKSON-259]:\n+        if (!JsonParser.Feature.CANONICALIZE_FIELD_NAMES.enabledIn(features)) {\n+            // should never construct non-canonical UTF-8/byte parser (instead, use Reader)\n+            _throwInternal();\n+        }\n+    }\n+\n+    @Override\n+    public ObjectCodec getCodec() {\n+        return _objectCodec;\n+    }\n+\n+    @Override\n+    public void setCodec(ObjectCodec c) {\n+        _objectCodec = c;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Former StreamBasedParserBase methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public int releaseBuffered(OutputStream out) throws IOException\n+    {\n+        int count = _inputEnd - _inputPtr;\n+        if (count < 1) {\n+            return 0;\n+        }\n+        // let's just advance ptr to end\n+        int origPtr = _inputPtr;\n+        out.write(_inputBuffer, origPtr, count);\n+        return count;\n+    }\n+\n+    @Override\n+    public Object getInputSource() {\n+        return _inputStream;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Low-level reading, other\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    protected final boolean loadMore()\n+        throws IOException\n+    {\n+        _currInputProcessed += _inputEnd;\n+        _currInputRowStart -= _inputEnd;\n+        \n+        if (_inputStream != null) {\n+            int count = _inputStream.read(_inputBuffer, 0, _inputBuffer.length);\n+            if (count > 0) {\n+                _inputPtr = 0;\n+                _inputEnd = count;\n+                return true;\n+            }\n+            // End of input\n+            _closeInput();\n+            // Should never return 0, so let's fail\n+            if (count == 0) {\n+                throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+_inputBuffer.length+\" bytes\");\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Helper method that will try to load at least specified number bytes in\n+     * input buffer, possible moving existing data around if necessary\n+     * \n+     * @since 1.6\n+     */\n+    protected final boolean _loadToHaveAtLeast(int minAvailable)\n+        throws IOException\n+    {\n+        // No input stream, no leading (either we are closed, or have non-stream input source)\n+        if (_inputStream == null) {\n+            return false;\n+        }\n+        // Need to move remaining data in front?\n+        int amount = _inputEnd - _inputPtr;\n+        if (amount > 0 && _inputPtr > 0) {\n+            _currInputProcessed += _inputPtr;\n+            _currInputRowStart -= _inputPtr;\n+            System.arraycopy(_inputBuffer, _inputPtr, _inputBuffer, 0, amount);\n+            _inputEnd = amount;\n+        } else {\n+            _inputEnd = 0;\n+        }\n+        _inputPtr = 0;\n+        while (_inputEnd < minAvailable) {\n+            int count = _inputStream.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd);\n+            if (count < 1) {\n+                // End of input\n+                _closeInput();\n+                // Should never return 0, so let's fail\n+                if (count == 0) {\n+                    throw new IOException(\"InputStream.read() returned 0 characters when trying to read \"+amount+\" bytes\");\n+                }\n+                return false;\n+            }\n+            _inputEnd += count;\n+        }\n+        return true;\n+    }\n+    \n+    @Override\n+    protected void _closeInput() throws IOException\n+    {\n+        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n+         *   on the underlying InputStream, unless we \"own\" it, or auto-closing\n+         *   feature is enabled.\n+         */\n+        if (_inputStream != null) {\n+            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n+                _inputStream.close();\n+            }\n+            _inputStream = null;\n+        }\n+    }\n+\n+    /**\n+     * Method called to release internal buffers owned by the base\n+     * reader. This may be called along with {@link #_closeInput} (for\n+     * example, when explicitly closing this reader instance), or\n+     * separately (if need be).\n+     */\n+    @Override\n+    protected void _releaseBuffers() throws IOException\n+    {\n+        super._releaseBuffers();\n+        if (_bufferRecyclable) {\n+            byte[] buf = _inputBuffer;\n+            if (buf != null) {\n+                _inputBuffer = null;\n+                _ioContext.releaseReadIOBuffer(buf);\n+            }\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, data access\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String getText()\n+        throws IOException, JsonParseException\n+    {\n+        JsonToken t = _currToken;\n+        if (t == JsonToken.VALUE_STRING) {\n+            if (_tokenIncomplete) {\n+                _tokenIncomplete = false;\n+                _finishString(); // only strings can be incomplete\n+            }\n+            return _textBuffer.contentsAsString();\n+        }\n+        return _getText2(t);\n+    }\n+\n+    protected final String _getText2(JsonToken t)\n+    {\n+        if (t == null) {\n+            return null;\n+        }\n+        switch (t) {\n+        case FIELD_NAME:\n+            return _parsingContext.getCurrentName();\n+\n+        case VALUE_STRING:\n+            // fall through\n+        case VALUE_NUMBER_INT:\n+        case VALUE_NUMBER_FLOAT:\n+            return _textBuffer.contentsAsString();\n+        }\n+        return t.asString();\n+    }\n+\n+    @Override\n+    public char[] getTextCharacters()\n+        throws IOException, JsonParseException\n+    {\n+        if (_currToken != null) { // null only before/after document\n+            switch (_currToken) {\n+                \n+            case FIELD_NAME:\n+                if (!_nameCopied) {\n+                    String name = _parsingContext.getCurrentName();\n+                    int nameLen = name.length();\n+                    if (_nameCopyBuffer == null) {\n+                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n+                    } else if (_nameCopyBuffer.length < nameLen) {\n+                        _nameCopyBuffer = new char[nameLen];\n+                    }\n+                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n+                    _nameCopied = true;\n+                }\n+                return _nameCopyBuffer;\n+    \n+            case VALUE_STRING:\n+                if (_tokenIncomplete) {\n+                    _tokenIncomplete = false;\n+                    _finishString(); // only strings can be incomplete\n+                }\n+                // fall through\n+            case VALUE_NUMBER_INT:\n+            case VALUE_NUMBER_FLOAT:\n+                return _textBuffer.getTextBuffer();\n+                \n+            default:\n+                return _currToken.asCharArray();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public int getTextLength()\n+        throws IOException, JsonParseException\n+    {\n+        if (_currToken != null) { // null only before/after document\n+            switch (_currToken) {\n+                \n+            case FIELD_NAME:\n+                return _parsingContext.getCurrentName().length();\n+            case VALUE_STRING:\n+                if (_tokenIncomplete) {\n+                    _tokenIncomplete = false;\n+                    _finishString(); // only strings can be incomplete\n+                }\n+                // fall through\n+            case VALUE_NUMBER_INT:\n+            case VALUE_NUMBER_FLOAT:\n+                return _textBuffer.size();\n+                \n+            default:\n+                return _currToken.asCharArray().length;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getTextOffset() throws IOException, JsonParseException\n+    {\n+        // Most have offset of 0, only some may have other values:\n+        if (_currToken != null) {\n+            switch (_currToken) {\n+            case FIELD_NAME:\n+                return 0;\n+            case VALUE_STRING:\n+                if (_tokenIncomplete) {\n+                    _tokenIncomplete = false;\n+                    _finishString(); // only strings can be incomplete\n+                }\n+                // fall through\n+            case VALUE_NUMBER_INT:\n+            case VALUE_NUMBER_FLOAT:\n+                return _textBuffer.getTextOffset();\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    @Override\n+    public byte[] getBinaryValue(Base64Variant b64variant)\n+        throws IOException, JsonParseException\n+    {\n+        if (_currToken != JsonToken.VALUE_STRING &&\n+                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n+            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n+        }\n+        /* To ensure that we won't see inconsistent data, better clear up\n+         * state...\n+         */\n+        if (_tokenIncomplete) {\n+            try {\n+                _binaryValue = _decodeBase64(b64variant);\n+            } catch (IllegalArgumentException iae) {\n+                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n+            }\n+            /* let's clear incomplete only now; allows for accessing other\n+             * textual content in error cases\n+             */\n+            _tokenIncomplete = false;\n+        } else { // may actually require conversion...\n+            if (_binaryValue == null) {\n+                ByteArrayBuilder builder = _getByteArrayBuilder();\n+                _decodeBase64(getText(), builder, b64variant);\n+                _binaryValue = builder.toByteArray();\n+            }\n+        }\n+        return _binaryValue;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, traversal, basic\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @return Next token from the stream, if any found, or null\n+     *   to indicate end-of-input\n+     */\n+    @Override\n+    public JsonToken nextToken()\n+        throws IOException, JsonParseException\n+    {\n+        _numTypesValid = NR_UNKNOWN;\n+        /* First: field names are special -- we will always tokenize\n+         * (part of) value along with field name to simplify\n+         * state handling. If so, can and need to use secondary token:\n+         */\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+            return _nextAfterName();\n+        }\n+        if (_tokenIncomplete) {\n+            _skipString(); // only strings can be partial\n+        }\n+\n+        int i = _skipWSOrEnd();\n+        if (i < 0) { // end-of-input\n+            /* 19-Feb-2009, tatu: Should actually close/release things\n+             *    like input source, symbol table and recyclable buffers now.\n+             */\n+            close();\n+            return (_currToken = null);\n+        }\n+\n+        /* First, need to ensure we know the starting location of token\n+         * after skipping leading white space\n+         */\n+        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n+        _tokenInputRow = _currInputRow;\n+        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n+\n+        // finally: clear any data retained so far\n+        _binaryValue = null;\n+\n+        // Closing scope?\n+        if (i == INT_RBRACKET) {\n+            if (!_parsingContext.inArray()) {\n+                _reportMismatchedEndMarker(i, '}');\n+            }\n+            _parsingContext = _parsingContext.getParent();\n+            return (_currToken = JsonToken.END_ARRAY);\n+        }\n+        if (i == INT_RCURLY) {\n+            if (!_parsingContext.inObject()) {\n+                _reportMismatchedEndMarker(i, ']');\n+            }\n+            _parsingContext = _parsingContext.getParent();\n+            return (_currToken = JsonToken.END_OBJECT);\n+        }\n+\n+        // Nope: do we then expect a comma?\n+        if (_parsingContext.expectComma()) {\n+            if (i != INT_COMMA) {\n+                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n+            }\n+            i = _skipWS();\n+        }\n+\n+        /* And should we now have a name? Always true for\n+         * Object contexts, since the intermediate 'expect-value'\n+         * state is never retained.\n+         */\n+        if (!_parsingContext.inObject()) {\n+            return _nextTokenNotInObject(i);\n+        }\n+        // So first parse the field name itself:\n+        Name n = _parseFieldName(i);\n+        _parsingContext.setCurrentName(n.getName());\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipWS();\n+        if (i != INT_COLON) {\n+            _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n+        }\n+        i = _skipWS();\n+\n+        // Ok: we must have a value... what is it? Strings are very common, check first:\n+        if (i == INT_QUOTE) {\n+            _tokenIncomplete = true;\n+            _nextToken = JsonToken.VALUE_STRING;\n+            return _currToken;\n+        }        \n+        JsonToken t;\n+\n+        switch (i) {\n+        case INT_LBRACKET:\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case INT_LCURLY:\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case INT_RBRACKET:\n+        case INT_RCURLY:\n+            // Error: neither is valid at this point; valid closers have\n+            // been handled earlier\n+            _reportUnexpectedChar(i, \"expected a value\");\n+        case INT_t:\n+            _matchToken(\"true\", 1);\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case INT_f:\n+            _matchToken(\"false\", 1);\n+             t = JsonToken.VALUE_FALSE;\n+            break;\n+        case INT_n:\n+            _matchToken(\"null\", 1);\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+\n+        case INT_MINUS:\n+            /* Should we have separate handling for plus? Although\n+             * it is not allowed per se, it may be erroneously used,\n+             * and could be indicate by a more specific error message.\n+             */\n+        case INT_0:\n+        case INT_1:\n+        case INT_2:\n+        case INT_3:\n+        case INT_4:\n+        case INT_5:\n+        case INT_6:\n+        case INT_7:\n+        case INT_8:\n+        case INT_9:\n+            t = parseNumberText(i);\n+            break;\n+        default:\n+            t = _handleUnexpectedValue(i);\n+        }\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+\n+    private final JsonToken _nextTokenNotInObject(int i)\n+        throws IOException, JsonParseException\n+    {\n+        if (i == INT_QUOTE) {\n+            _tokenIncomplete = true;\n+            return (_currToken = JsonToken.VALUE_STRING);\n+        }\n+        switch (i) {\n+        case INT_LBRACKET:\n+            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            return (_currToken = JsonToken.START_ARRAY);\n+        case INT_LCURLY:\n+            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            return (_currToken = JsonToken.START_OBJECT);\n+        case INT_RBRACKET:\n+        case INT_RCURLY:\n+            // Error: neither is valid at this point; valid closers have\n+            // been handled earlier\n+            _reportUnexpectedChar(i, \"expected a value\");\n+        case INT_t:\n+            _matchToken(\"true\", 1);\n+            return (_currToken = JsonToken.VALUE_TRUE);\n+        case INT_f:\n+            _matchToken(\"false\", 1);\n+            return (_currToken = JsonToken.VALUE_FALSE);\n+        case INT_n:\n+            _matchToken(\"null\", 1);\n+            return (_currToken = JsonToken.VALUE_NULL);\n+        case INT_MINUS:\n+            /* Should we have separate handling for plus? Although\n+             * it is not allowed per se, it may be erroneously used,\n+             * and could be indicate by a more specific error message.\n+             */\n+        case INT_0:\n+        case INT_1:\n+        case INT_2:\n+        case INT_3:\n+        case INT_4:\n+        case INT_5:\n+        case INT_6:\n+        case INT_7:\n+        case INT_8:\n+        case INT_9:\n+            return (_currToken = parseNumberText(i));\n+        }\n+        return (_currToken = _handleUnexpectedValue(i));\n+    }\n+    \n+    private final JsonToken _nextAfterName()\n+    {\n+        _nameCopied = false; // need to invalidate if it was copied\n+        JsonToken t = _nextToken;\n+        _nextToken = null;\n+        // Also: may need to start new context?\n+        if (t == JsonToken.START_ARRAY) {\n+            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+        } else if (t == JsonToken.START_OBJECT) {\n+            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+        }\n+        return (_currToken = t);\n+    }\n+\n+    @Override\n+    public void close() throws IOException\n+    {\n+        super.close();\n+        // Merge found symbols, if any:\n+        _symbols.release();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, traversal, nextXxxValue/nextFieldName\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public boolean nextFieldName(SerializableString str)\n+        throws IOException, JsonParseException\n+    {\n+        // // // Note: most of code below is copied from nextToken()\n+        \n+        _numTypesValid = NR_UNKNOWN;\n+        if (_currToken == JsonToken.FIELD_NAME) { // can't have name right after name\n+            _nextAfterName();\n+            return false;\n+        }\n+        if (_tokenIncomplete) {\n+            _skipString();\n+        }\n+        int i = _skipWSOrEnd();\n+        if (i < 0) { // end-of-input\n+            close();\n+            _currToken = null;\n+            return false;\n+        }\n+        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n+        _tokenInputRow = _currInputRow;\n+        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n+\n+        // finally: clear any data retained so far\n+        _binaryValue = null;\n+\n+        // Closing scope?\n+        if (i == INT_RBRACKET) {\n+            if (!_parsingContext.inArray()) {\n+                _reportMismatchedEndMarker(i, '}');\n+            }\n+            _parsingContext = _parsingContext.getParent();\n+            _currToken = JsonToken.END_ARRAY;\n+            return false;\n+        }\n+        if (i == INT_RCURLY) {\n+            if (!_parsingContext.inObject()) {\n+                _reportMismatchedEndMarker(i, ']');\n+            }\n+            _parsingContext = _parsingContext.getParent();\n+            _currToken = JsonToken.END_OBJECT;\n+            return false;\n+        }\n+\n+        // Nope: do we then expect a comma?\n+        if (_parsingContext.expectComma()) {\n+            if (i != INT_COMMA) {\n+                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n+            }\n+            i = _skipWS();\n+        }\n+\n+        if (!_parsingContext.inObject()) {\n+            _nextTokenNotInObject(i);\n+            return false;\n+        }\n+        \n+        // // // This part differs, name parsing\n+        if (i == INT_QUOTE) {\n+            // when doing literal match, must consider escaping:\n+            byte[] nameBytes = str.asQuotedUTF8();\n+            final int len = nameBytes.length;\n+            if ((_inputPtr + len) < _inputEnd) { // maybe...\n+                // first check length match by\n+                final int end = _inputPtr+len;\n+                if (_inputBuffer[end] == INT_QUOTE) {\n+                    int offset = 0;\n+                    final int ptr = _inputPtr;\n+                    while (true) {\n+                        if (offset == len) { // yes, match!\n+                            _inputPtr = end+1; // skip current value first\n+                            // First part is simple; setting of name\n+                            _parsingContext.setCurrentName(str.getValue());\n+                            _currToken = JsonToken.FIELD_NAME;\n+                            // But then we also must handle following value etc\n+                            _isNextTokenNameYes();\n+                            return true;\n+                        }\n+                        if (nameBytes[offset] != _inputBuffer[ptr+offset]) {\n+                            break;\n+                        }\n+                        ++offset;\n+                    }\n+                }\n+            }\n+        }\n+        _isNextTokenNameNo(i);\n+        return false;\n+    }\n+\n+    private final void _isNextTokenNameYes()\n+        throws IOException, JsonParseException\n+    {\n+        // very first thing: common case, colon, value, no white space\n+        int i;\n+        if (_inputPtr < _inputEnd && _inputBuffer[_inputPtr] == INT_COLON) { // fast case first\n+            ++_inputPtr;\n+            i = _inputBuffer[_inputPtr++];\n+            if (i == INT_QUOTE) {\n+                _tokenIncomplete = true;\n+                _nextToken = JsonToken.VALUE_STRING;\n+                return;\n+            }\n+            if (i == INT_LCURLY) {\n+                _nextToken = JsonToken.START_OBJECT;\n+                return;\n+            }\n+            if (i == INT_LBRACKET) {\n+                _nextToken = JsonToken.START_ARRAY;\n+                return;\n+            }\n+            i &= 0xFF;\n+            if (i <= INT_SPACE || i == INT_SLASH) {\n+                --_inputPtr;\n+                i = _skipWS();\n+            }\n+        } else {\n+            i = _skipColon();\n+        }\n+        switch (i) {\n+        case INT_QUOTE:\n+            _tokenIncomplete = true;\n+            _nextToken = JsonToken.VALUE_STRING;\n+            return;\n+        case INT_LBRACKET:\n+            _nextToken = JsonToken.START_ARRAY;\n+            return;\n+        case INT_LCURLY:\n+            _nextToken = JsonToken.START_OBJECT;\n+            return;\n+        case INT_RBRACKET:\n+        case INT_RCURLY:\n+            _reportUnexpectedChar(i, \"expected a value\");\n+        case INT_t:\n+            _matchToken(\"true\", 1);\n+            _nextToken = JsonToken.VALUE_TRUE;\n+            return;\n+        case INT_f:\n+            _matchToken(\"false\", 1);\n+            _nextToken = JsonToken.VALUE_FALSE;\n+            return;\n+        case INT_n:\n+            _matchToken(\"null\", 1);\n+            _nextToken = JsonToken.VALUE_NULL;\n+            return;\n+        case INT_MINUS:\n+        case INT_0:\n+        case INT_1:\n+        case INT_2:\n+        case INT_3:\n+        case INT_4:\n+        case INT_5:\n+        case INT_6:\n+        case INT_7:\n+        case INT_8:\n+        case INT_9:\n+            _nextToken = parseNumberText(i);\n+            return;\n+        }\n+        _nextToken = _handleUnexpectedValue(i);\n+    }\n+    \n+    private final void _isNextTokenNameNo(int i)\n+            throws IOException, JsonParseException\n+    {\n+        // // // and this is back to standard nextToken()\n+            \n+        Name n = _parseFieldName(i);\n+        _parsingContext.setCurrentName(n.getName());\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipWS();\n+        if (i != INT_COLON) {\n+            _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n+        }\n+        i = _skipWS();\n+\n+        // Ok: we must have a value... what is it? Strings are very common, check first:\n+        if (i == INT_QUOTE) {\n+            _tokenIncomplete = true;\n+            _nextToken = JsonToken.VALUE_STRING;\n+            return;\n+        }        \n+        JsonToken t;\n+\n+        switch (i) {\n+        case INT_LBRACKET:\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case INT_LCURLY:\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case INT_RBRACKET:\n+        case INT_RCURLY:\n+            _reportUnexpectedChar(i, \"expected a value\");\n+        case INT_t:\n+            _matchToken(\"true\", 1);\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case INT_f:\n+            _matchToken(\"false\", 1);\n+             t = JsonToken.VALUE_FALSE;\n+            break;\n+        case INT_n:\n+            _matchToken(\"null\", 1);\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+\n+        case INT_MINUS:\n+        case INT_0:\n+        case INT_1:\n+        case INT_2:\n+        case INT_3:\n+        case INT_4:\n+        case INT_5:\n+        case INT_6:\n+        case INT_7:\n+        case INT_8:\n+        case INT_9:\n+            t = parseNumberText(i);\n+            break;\n+        default:\n+            t = _handleUnexpectedValue(i);\n+        }\n+        _nextToken = t;\n+    }\n+\n+    @Override\n+    public String nextTextValue()\n+        throws IOException, JsonParseException\n+    {\n+        // two distinct cases; either got name and we know next type, or 'other'\n+        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n+            _nameCopied = false;\n+            JsonToken t = _nextToken;\n+            _nextToken = null;\n+            _currToken = t;\n+            if (t == JsonToken.VALUE_STRING) {\n+                if (_tokenIncomplete) {\n+                    _tokenIncomplete = false;\n+                    _finishString();\n+                }\n+                return _textBuffer.contentsAsString();\n+            }\n+            if (t == JsonToken.START_ARRAY) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            } else if (t == JsonToken.START_OBJECT) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            return null;\n+        }\n+        // !!! TODO: optimize this case as well\n+        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n+    }\n+\n+    @Override\n+    public int nextIntValue(int defaultValue)\n+        throws IOException, JsonParseException\n+    {\n+        // two distinct cases; either got name and we know next type, or 'other'\n+        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n+            _nameCopied = false;\n+            JsonToken t = _nextToken;\n+            _nextToken = null;\n+            _currToken = t;\n+            if (t == JsonToken.VALUE_NUMBER_INT) {\n+                return getIntValue();\n+            }\n+            if (t == JsonToken.START_ARRAY) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            } else if (t == JsonToken.START_OBJECT) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            return defaultValue;\n+        }\n+        // !!! TODO: optimize this case as well\n+        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n+    }\n+\n+    @Override\n+    public long nextLongValue(long defaultValue)\n+        throws IOException, JsonParseException\n+    {\n+        // two distinct cases; either got name and we know next type, or 'other'\n+        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n+            _nameCopied = false;\n+            JsonToken t = _nextToken;\n+            _nextToken = null;\n+            _currToken = t;\n+            if (t == JsonToken.VALUE_NUMBER_INT) {\n+                return getLongValue();\n+            }\n+            if (t == JsonToken.START_ARRAY) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            } else if (t == JsonToken.START_OBJECT) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            return defaultValue;\n+        }\n+        // !!! TODO: optimize this case as well\n+        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n+    }\n+\n+    @Override\n+    public Boolean nextBooleanValue()\n+        throws IOException, JsonParseException\n+    {\n+        // two distinct cases; either got name and we know next type, or 'other'\n+        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n+            _nameCopied = false;\n+            JsonToken t = _nextToken;\n+            _nextToken = null;\n+            _currToken = t;\n+            if (t == JsonToken.VALUE_TRUE) {\n+                return Boolean.TRUE;\n+            }\n+            if (t == JsonToken.VALUE_FALSE) {\n+                return Boolean.FALSE;\n+            }\n+            if (t == JsonToken.START_ARRAY) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            } else if (t == JsonToken.START_OBJECT) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            return null;\n+        }\n+        switch (nextToken()) {\n+        case VALUE_TRUE:\n+            return Boolean.TRUE;\n+        case VALUE_FALSE:\n+            return Boolean.FALSE;\n+        }\n+        return null;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Internal methods, number parsing\n+    /* (note: in 1.6 and prior, part of \"Utf8NumericParser\"\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Initial parsing method for number values. It needs to be able\n+     * to parse enough input to be able to determine whether the\n+     * value is to be considered a simple integer value, or a more\n+     * generic decimal value: latter of which needs to be expressed\n+     * as a floating point number. The basic rule is that if the number\n+     * has no fractional or exponential part, it is an integer; otherwise\n+     * a floating point number.\n+     *<p>\n+     * Because much of input has to be processed in any case, no partial\n+     * parsing is done: all input text will be stored for further\n+     * processing. However, actual numeric value conversion will be\n+     * deferred, since it is usually the most complicated and costliest\n+     * part of processing.\n+     */\n+    protected final JsonToken parseNumberText(int c)\n+        throws IOException, JsonParseException\n+    {\n+        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n+        int outPtr = 0;\n+        boolean negative = (c == INT_MINUS);\n+\n+        // Need to prepend sign?\n+        if (negative) {\n+            outBuf[outPtr++] = '-';\n+            // Must have something after sign too\n+            if (_inputPtr >= _inputEnd) {\n+                loadMoreGuaranteed();\n+            }\n+            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n+            // Note: must be followed by a digit\n+            if (c < INT_0 || c > INT_9) {\n+                return _handleInvalidNumberStart(c, true);\n+            }\n+        }\n+\n+        // One special case: if first char is 0, must not be followed by a digit\n+        if (c == INT_0) {\n+            c = _verifyNoLeadingZeroes();\n+        }\n+        \n+        // Ok: we can first just add digit we saw first:\n+        outBuf[outPtr++] = (char) c;\n+        int intLen = 1;\n+\n+        // And then figure out how far we can read without further checks:\n+        int end = _inputPtr + outBuf.length;\n+        if (end > _inputEnd) {\n+            end = _inputEnd;\n+        }\n+\n+        // With this, we have a nice and tight loop:\n+        while (true) {\n+            if (_inputPtr >= end) {\n+                // Long enough to be split across boundary, so:\n+                return _parserNumber2(outBuf, outPtr, negative, intLen);\n+            }\n+            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n+            if (c < INT_0 || c > INT_9) {\n+                break;\n+            }\n+            ++intLen;\n+            outBuf[outPtr++] = (char) c;\n+        }\n+        if (c == '.' || c == 'e' || c == 'E') {\n+            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n+        }\n+\n+        --_inputPtr; // to push back trailing char (comma etc)\n+        _textBuffer.setCurrentLength(outPtr);\n+\n+        // And there we have it!\n+        return resetInt(negative, intLen);\n+    }\n+    \n+    /**\n+     * Method called to handle parsing when input is split across buffer boundary\n+     * (or output is longer than segment used to store it)\n+     */\n+    private final JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative,\n+            int intPartLength)\n+        throws IOException, JsonParseException\n+    {\n+        // Ok, parse the rest\n+        while (true) {\n+            if (_inputPtr >= _inputEnd && !loadMore()) {\n+                _textBuffer.setCurrentLength(outPtr);\n+                return resetInt(negative, intPartLength);\n+            }\n+            int c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n+            if (c > INT_9 || c < INT_0) {\n+                if (c == '.' || c == 'e' || c == 'E') {\n+                    return _parseFloatText(outBuf, outPtr, c, negative, intPartLength);\n+                }\n+                break;\n+            }\n+            if (outPtr >= outBuf.length) {\n+                outBuf = _textBuffer.finishCurrentSegment();\n+                outPtr = 0;\n+            }\n+            outBuf[outPtr++] = (char) c;\n+            ++intPartLength;\n+        }\n+        --_inputPtr; // to push back trailing char (comma etc)\n+        _textBuffer.setCurrentLength(outPtr);\n+\n+        // And there we have it!\n+        return resetInt(negative, intPartLength);\n+        \n+    }\n+    \n+    /**\n+     * Method called when we have seen one zero, and want to ensure\n+     * it is not followed by another\n+     */\n+    private final int _verifyNoLeadingZeroes()\n+        throws IOException, JsonParseException\n+    {\n+        // Ok to have plain \"0\"\n+        if (_inputPtr >= _inputEnd && !loadMore()) {\n+            return INT_0;\n+        }\n+        int ch = _inputBuffer[_inputPtr] & 0xFF;\n+        // if not followed by a number (probably '.'); return zero as is, to be included\n+        if (ch < INT_0 || ch > INT_9) {\n+            return INT_0;\n+        }\n+        // [JACKSON-358]: we may want to allow them, after all...\n+        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n+            reportInvalidNumber(\"Leading zeroes not allowed\");\n+        }\n+        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n+        ++_inputPtr; // Leading zero to be skipped\n+        if (ch == INT_0) {\n+            while (_inputPtr < _inputEnd || loadMore()) {\n+                ch = _inputBuffer[_inputPtr] & 0xFF;\n+                if (ch < INT_0 || ch > INT_9) { // followed by non-number; retain one zero\n+                    return INT_0;\n+                }\n+                ++_inputPtr; // skip previous zeroes\n+                if (ch != INT_0) { // followed by other number; return \n+                    break;\n+                }\n+            }\n+        }\n+        return ch;\n+    }\n+    \n+    private final JsonToken _parseFloatText(char[] outBuf, int outPtr, int c,\n+            boolean negative, int integerPartLength)\n+        throws IOException, JsonParseException\n+    {\n+        int fractLen = 0;\n+        boolean eof = false;\n+\n+        // And then see if we get other parts\n+        if (c == '.') { // yes, fraction\n+            outBuf[outPtr++] = (char) c;\n+\n+            fract_loop:\n+            while (true) {\n+                if (_inputPtr >= _inputEnd && !loadMore()) {\n+                    eof = true;\n+                    break fract_loop;\n+                }\n+                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n+                if (c < INT_0 || c > INT_9) {\n+                    break fract_loop;\n+                }\n+                ++fractLen;\n+                if (outPtr >= outBuf.length) {\n+                    outBuf = _textBuffer.finishCurrentSegment();\n+                    outPtr = 0;\n+                }\n+                outBuf[outPtr++] = (char) c;\n+            }\n+            // must be followed by sequence of ints, one minimum\n+            if (fractLen == 0) {\n+                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n+            }\n+        }\n+\n+        int expLen = 0;\n+        if (c == 'e' || c == 'E') { // exponent?\n+            if (outPtr >= outBuf.length) {\n+                outBuf = _textBuffer.finishCurrentSegment();\n+                outPtr = 0;\n+            }\n+            outBuf[outPtr++] = (char) c;\n+            // Not optional, can require that we get one more char\n+            if (_inputPtr >= _inputEnd) {\n+                loadMoreGuaranteed();\n+            }\n+            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n+            // Sign indicator?\n+            if (c == '-' || c == '+') {\n+                if (outPtr >= outBuf.length) {\n+                    outBuf = _textBuffer.finishCurrentSegment();\n+                    outPtr = 0;\n+                }\n+                outBuf[outPtr++] = (char) c;\n+                // Likewise, non optional:\n+                if (_inputPtr >= _inputEnd) {\n+                    loadMoreGuaranteed();\n+                }\n+                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n+            }\n+\n+            exp_loop:\n+            while (c <= INT_9 && c >= INT_0) {\n+                ++expLen;\n+                if (outPtr >= outBuf.length) {\n+                    outBuf = _textBuffer.finishCurrentSegment();\n+                    outPtr = 0;\n+                }\n+                outBuf[outPtr++] = (char) c;\n+                if (_inputPtr >= _inputEnd && !loadMore()) {\n+                    eof = true;\n+                    break exp_loop;\n+                }\n+                c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n+            }\n+            // must be followed by sequence of ints, one minimum\n+            if (expLen == 0) {\n+                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n+            }\n+        }\n+\n+        // Ok; unless we hit end-of-input, need to push last char read back\n+        if (!eof) {\n+            --_inputPtr;\n+        }\n+        _textBuffer.setCurrentLength(outPtr);\n+\n+        // And there we have it!\n+        return resetFloat(negative, integerPartLength, fractLen, expLen);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Internal methods, secondary parsing\n+    /**********************************************************\n+     */\n+    \n+    protected final Name _parseFieldName(int i)\n+        throws IOException, JsonParseException\n+    {\n+        if (i != INT_QUOTE) {\n+            return _handleUnusualFieldName(i);\n+        }\n+        // First: can we optimize out bounds checks?\n+        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n+            return slowParseFieldName();\n+        }\n+\n+        // If so, can also unroll loops nicely\n+        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n+         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n+         *   assume that part is ok (if not it will get caught\n+         *   later on), and just handle quotes and backslashes here.\n+         */\n+        final byte[] input = _inputBuffer;\n+        final int[] codes = sInputCodesLatin1;\n+\n+        int q = input[_inputPtr++] & 0xFF;\n+\n+        if (codes[q] == 0) {\n+            i = input[_inputPtr++] & 0xFF;\n+            if (codes[i] == 0) {\n+                q = (q << 8) | i;\n+                i = input[_inputPtr++] & 0xFF;\n+                if (codes[i] == 0) {\n+                    q = (q << 8) | i;\n+                    i = input[_inputPtr++] & 0xFF;\n+                    if (codes[i] == 0) {\n+                        q = (q << 8) | i;\n+                        i = input[_inputPtr++] & 0xFF;\n+                        if (codes[i] == 0) {\n+                            _quad1 = q;\n+                            return parseMediumFieldName(i, codes);\n+                        }\n+                        if (i == INT_QUOTE) { // one byte/char case or broken\n+                            return findName(q, 4);\n+                        }\n+                        return parseFieldName(q, i, 4);\n+                    }\n+                    if (i == INT_QUOTE) { // one byte/char case or broken\n+                        return findName(q, 3);\n+                    }\n+                    return parseFieldName(q, i, 3);\n+                }                \n+                if (i == INT_QUOTE) { // one byte/char case or broken\n+                    return findName(q, 2);\n+                }\n+                return parseFieldName(q, i, 2);\n+            }\n+            if (i == INT_QUOTE) { // one byte/char case or broken\n+                return findName(q, 1);\n+            }\n+            return parseFieldName(q, i, 1);\n+        }     \n+        if (q == INT_QUOTE) { // special case, \"\"\n+            return BytesToNameCanonicalizer.getEmptyName();\n+        }\n+        return parseFieldName(0, q, 0); // quoting or invalid char\n+    }\n+\n+    protected final Name parseMediumFieldName(int q2, final int[] codes)\n+        throws IOException, JsonParseException\n+    {\n+        // Ok, got 5 name bytes so far\n+        int i = _inputBuffer[_inputPtr++] & 0xFF;\n+        if (codes[i] != 0) {\n+            if (i == INT_QUOTE) { // 5 bytes\n+                return findName(_quad1, q2, 1);\n+            }\n+            return parseFieldName(_quad1, q2, i, 1); // quoting or invalid char\n+        }\n+        q2 = (q2 << 8) | i;\n+        i = _inputBuffer[_inputPtr++] & 0xFF;\n+        if (codes[i] != 0) {\n+            if (i == INT_QUOTE) { // 6 bytes\n+                return findName(_quad1, q2, 2);\n+            }\n+            return parseFieldName(_quad1, q2, i, 2);\n+        }\n+        q2 = (q2 << 8) | i;\n+        i = _inputBuffer[_inputPtr++] & 0xFF;\n+        if (codes[i] != 0) {\n+            if (i == INT_QUOTE) { // 7 bytes\n+                return findName(_quad1, q2, 3);\n+            }\n+            return parseFieldName(_quad1, q2, i, 3);\n+        }\n+        q2 = (q2 << 8) | i;\n+        i = _inputBuffer[_inputPtr++] & 0xFF;\n+        if (codes[i] != 0) {\n+            if (i == INT_QUOTE) { // 8 bytes\n+                return findName(_quad1, q2, 4);\n+            }\n+            return parseFieldName(_quad1, q2, i, 4);\n+        }\n+        _quadBuffer[0] = _quad1;\n+        _quadBuffer[1] = q2;\n+        return parseLongFieldName(i);\n+    }\n+\n+    protected Name parseLongFieldName(int q)\n+        throws IOException, JsonParseException\n+    {\n+        // As explained above, will ignore UTF-8 encoding at this point\n+        final int[] codes = sInputCodesLatin1;\n+        int qlen = 2;\n+\n+        while (true) {\n+            /* Let's offline if we hit buffer boundary (otherwise would\n+             * need to [try to] align input, which is bit complicated\n+             * and may not always be possible)\n+             */\n+            if ((_inputEnd - _inputPtr) < 4) {\n+                return parseEscapedFieldName(_quadBuffer, qlen, 0, q, 0);\n+            }\n+            // Otherwise can skip boundary checks for 4 bytes in loop\n+\n+            int i = _inputBuffer[_inputPtr++] & 0xFF;\n+            if (codes[i] != 0) {\n+                if (i == INT_QUOTE) {\n+                    return findName(_quadBuffer, qlen, q, 1);\n+                }\n+                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 1);\n+            }\n+\n+            q = (q << 8) | i;\n+            i = _inputBuffer[_inputPtr++] & 0xFF;\n+            if (codes[i] != 0) {\n+                if (i == INT_QUOTE) {\n+                    return findName(_quadBuffer, qlen, q, 2);\n+                }\n+                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 2);\n+            }\n+\n+            q = (q << 8) | i;\n+            i = _inputBuffer[_inputPtr++] & 0xFF;\n+            if (codes[i] != 0) {\n+                if (i == INT_QUOTE) {\n+                    return findName(_quadBuffer, qlen, q, 3);\n+                }\n+                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 3);\n+            }\n+\n+            q = (q << 8) | i;\n+            i = _inputBuffer[_inputPtr++] & 0xFF;\n+            if (codes[i] != 0) {\n+                if (i == INT_QUOTE) {\n+                    return findName(_quadBuffer, qlen, q, 4);\n+                }\n+                return parseEscapedFieldName(_quadBuffer, qlen, q, i, 4);\n+            }\n+\n+            // Nope, no end in sight. Need to grow quad array etc\n+            if (qlen >= _quadBuffer.length) {\n+                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n+            }\n+            _quadBuffer[qlen++] = q;\n+            q = i;\n+        }\n+    }\n+\n+    /**\n+     * Method called when not even first 8 bytes are guaranteed\n+     * to come consequtively. Happens rarely, so this is offlined;\n+     * plus we'll also do full checks for escaping etc.\n+     */\n+    protected Name slowParseFieldName()\n+        throws IOException, JsonParseException\n+    {\n+        if (_inputPtr >= _inputEnd) {\n+            if (!loadMore()) {\n+                _reportInvalidEOF(\": was expecting closing '\\\"' for name\");\n+            }\n+        }\n+        int i = _inputBuffer[_inputPtr++] & 0xFF;\n+        if (i == INT_QUOTE) { // special case, \"\"\n+            return BytesToNameCanonicalizer.getEmptyName();\n+        }\n+        return parseEscapedFieldName(_quadBuffer, 0, 0, i, 0);\n+    }\n+\n+    private final Name parseFieldName(int q1, int ch, int lastQuadBytes)\n+        throws IOException, JsonParseException\n+    {\n+        return parseEscapedFieldName(_quadBuffer, 0, q1, ch, lastQuadBytes);\n+    }\n+\n+    private final Name parseFieldName(int q1, int q2, int ch, int lastQuadBytes)\n+        throws IOException, JsonParseException\n+    {\n+        _quadBuffer[0] = q1;\n+        return parseEscapedFieldName(_quadBuffer, 1, q2, ch, lastQuadBytes);\n+    }\n+\n+    /**\n+     * Slower parsing method which is generally branched to when\n+     * an escape sequence is detected (or alternatively for long\n+     * names, or ones crossing input buffer boundary). In any case,\n+     * needs to be able to handle more exceptional cases, gets\n+     * slower, and hance is offlined to a separate method.\n+     */\n+    protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch,\n+                                         int currQuadBytes)\n+        throws IOException, JsonParseException\n+    {\n+        /* 25-Nov-2008, tatu: This may seem weird, but here we do\n+         *   NOT want to worry about UTF-8 decoding. Rather, we'll\n+         *   assume that part is ok (if not it will get caught\n+         *   later on), and just handle quotes and backslashes here.\n+         */\n+        final int[] codes = sInputCodesLatin1;\n+\n+        while (true) {\n+            if (codes[ch] != 0) {\n+                if (ch == INT_QUOTE) { // we are done\n+                    break;\n+                }\n+                // Unquoted white space?\n+                if (ch != INT_BACKSLASH) {\n+                    // As per [JACKSON-208], call can now return:\n+                    _throwUnquotedSpace(ch, \"name\");\n+                } else {\n+                    // Nope, escape sequence\n+                    ch = _decodeEscaped();\n+                }\n+                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n+                 * beyond 7-bit ascii. Gets pretty messy.\n+                 * If this happens often, may want to use different name\n+                 * canonicalization to avoid these hits.\n+                 */\n+                if (ch > 127) {\n+                    // Ok, we'll need room for first byte right away\n+                    if (currQuadBytes >= 4) {\n+                        if (qlen >= quads.length) {\n+                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n+                        }\n+                        quads[qlen++] = currQuad;\n+                        currQuad = 0;\n+                        currQuadBytes = 0;\n+                    }\n+                    if (ch < 0x800) { // 2-byte\n+                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n+                        ++currQuadBytes;\n+                        // Second byte gets output below:\n+                    } else { // 3 bytes; no need to worry about surrogates here\n+                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n+                        ++currQuadBytes;\n+                        // need room for middle byte?\n+                        if (currQuadBytes >= 4) {\n+                            if (qlen >= quads.length) {\n+                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n+                            }\n+                            quads[qlen++] = currQuad;\n+                            currQuad = 0;\n+                            currQuadBytes = 0;\n+                        }\n+                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n+                        ++currQuadBytes;\n+                    }\n+                    // And same last byte in both cases, gets output below:\n+                    ch = 0x80 | (ch & 0x3f);\n+                }\n+            }\n+            // Ok, we have one more byte to add at any rate:\n+            if (currQuadBytes < 4) {\n+                ++currQuadBytes;\n+                currQuad = (currQuad << 8) | ch;\n+            } else {\n+                if (qlen >= quads.length) {\n+                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n+                }\n+                quads[qlen++] = currQuad;\n+                currQuad = ch;\n+                currQuadBytes = 1;\n+            }\n+            if (_inputPtr >= _inputEnd) {\n+                if (!loadMore()) {\n+                    _reportInvalidEOF(\" in field name\");\n+                }\n+            }\n+            ch = _inputBuffer[_inputPtr++] & 0xFF;\n+        }\n+\n+        if (currQuadBytes > 0) {\n+            if (qlen >= quads.length) {\n+                _quadBuffer = quads = growArrayBy(quads, quads.length);\n+            }\n+            quads[qlen++] = currQuad;\n+        }\n+        Name name = _symbols.findName(quads, qlen);\n+        if (name == null) {\n+            name = addName(quads, qlen, currQuadBytes);\n+        }\n+        return name;\n+    }\n+\n+    /**\n+     * Method called when we see non-white space character other\n+     * than double quote, when expecting a field name.\n+     * In standard mode will just throw an expection; but\n+     * in non-standard modes may be able to parse name.\n+     */\n+    protected final Name _handleUnusualFieldName(int ch)\n+        throws IOException, JsonParseException\n+    {\n+        // [JACKSON-173]: allow single quotes\n+        if (ch == INT_APOSTROPHE && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n+            return _parseApostropheFieldName();\n+        }\n+        // [JACKSON-69]: allow unquoted names if feature enabled:\n+        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n+            _reportUnexpectedChar(ch, \"was expecting double-quote to start field name\");\n+        }\n+        /* Also: note that although we use a different table here,\n+         * it does NOT handle UTF-8 decoding. It'll just pass those\n+         * high-bit codes as acceptable for later decoding.\n+         */\n+        final int[] codes = CharTypes.getInputCodeUtf8JsNames();\n+        // Also: must start with a valid character...\n+        if (codes[ch] != 0) {\n+            _reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n+        }\n+\n+        /* Ok, now; instead of ultra-optimizing parsing here (as with\n+         * regular JSON names), let's just use the generic \"slow\"\n+         * variant. Can measure its impact later on if need be\n+         */\n+        int[] quads = _quadBuffer;\n+        int qlen = 0;\n+        int currQuad = 0;\n+        int currQuadBytes = 0;\n+\n+        while (true) {\n+            // Ok, we have one more byte to add at any rate:\n+            if (currQuadBytes < 4) {\n+                ++currQuadBytes;\n+                currQuad = (currQuad << 8) | ch;\n+            } else {\n+                if (qlen >= quads.length) {\n+                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n+                }\n+                quads[qlen++] = currQuad;\n+                currQuad = ch;\n+                currQuadBytes = 1;\n+            }\n+            if (_inputPtr >= _inputEnd) {\n+                if (!loadMore()) {\n+                    _reportInvalidEOF(\" in field name\");\n+                }\n+            }\n+            ch = _inputBuffer[_inputPtr] & 0xFF;\n+            if (codes[ch] != 0) {\n+                break;\n+            }\n+            ++_inputPtr;\n+        }\n+\n+        if (currQuadBytes > 0) {\n+            if (qlen >= quads.length) {\n+                _quadBuffer = quads = growArrayBy(quads, quads.length);\n+            }\n+            quads[qlen++] = currQuad;\n+        }\n+        Name name = _symbols.findName(quads, qlen);\n+        if (name == null) {\n+            name = addName(quads, qlen, currQuadBytes);\n+        }\n+        return name;\n+    }\n+\n+    /* Parsing to support [JACKSON-173]. Plenty of duplicated code;\n+     * main reason being to try to avoid slowing down fast path\n+     * for valid JSON -- more alternatives, more code, generally\n+     * bit slower execution.\n+     */\n+    protected final Name _parseApostropheFieldName()\n+        throws IOException, JsonParseException\n+    {\n+        if (_inputPtr >= _inputEnd) {\n+            if (!loadMore()) {\n+                _reportInvalidEOF(\": was expecting closing '\\'' for name\");\n+            }\n+        }\n+        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n+        if (ch == INT_APOSTROPHE) { // special case, ''\n+            return BytesToNameCanonicalizer.getEmptyName();\n+        }\n+        int[] quads = _quadBuffer;\n+        int qlen = 0;\n+        int currQuad = 0;\n+        int currQuadBytes = 0;\n+\n+        // Copied from parseEscapedFieldName, with minor mods:\n+\n+        final int[] codes = sInputCodesLatin1;\n+\n+        while (true) {\n+            if (ch == INT_APOSTROPHE) {\n+                break;\n+            }\n+            // additional check to skip handling of double-quotes\n+            if (ch != INT_QUOTE && codes[ch] != 0) {\n+                if (ch != INT_BACKSLASH) {\n+                    // Unquoted white space?\n+                    // As per [JACKSON-208], call can now return:\n+                    _throwUnquotedSpace(ch, \"name\");\n+                } else {\n+                    // Nope, escape sequence\n+                    ch = _decodeEscaped();\n+                }\n+                /* Oh crap. May need to UTF-8 (re-)encode it, if it's\n+                 * beyond 7-bit ascii. Gets pretty messy.\n+                 * If this happens often, may want to use different name\n+                 * canonicalization to avoid these hits.\n+                 */\n+                if (ch > 127) {\n+                    // Ok, we'll need room for first byte right away\n+                    if (currQuadBytes >= 4) {\n+                        if (qlen >= quads.length) {\n+                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n+                        }\n+                        quads[qlen++] = currQuad;\n+                        currQuad = 0;\n+                        currQuadBytes = 0;\n+                    }\n+                    if (ch < 0x800) { // 2-byte\n+                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n+                        ++currQuadBytes;\n+                        // Second byte gets output below:\n+                    } else { // 3 bytes; no need to worry about surrogates here\n+                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n+                        ++currQuadBytes;\n+                        // need room for middle byte?\n+                        if (currQuadBytes >= 4) {\n+                            if (qlen >= quads.length) {\n+                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n+                            }\n+                            quads[qlen++] = currQuad;\n+                            currQuad = 0;\n+                            currQuadBytes = 0;\n+                        }\n+                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n+                        ++currQuadBytes;\n+                    }\n+                    // And same last byte in both cases, gets output below:\n+                    ch = 0x80 | (ch & 0x3f);\n+                }\n+            }\n+            // Ok, we have one more byte to add at any rate:\n+            if (currQuadBytes < 4) {\n+                ++currQuadBytes;\n+                currQuad = (currQuad << 8) | ch;\n+            } else {\n+                if (qlen >= quads.length) {\n+                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n+                }\n+                quads[qlen++] = currQuad;\n+                currQuad = ch;\n+                currQuadBytes = 1;\n+            }\n+            if (_inputPtr >= _inputEnd) {\n+                if (!loadMore()) {\n+                    _reportInvalidEOF(\" in field name\");\n+                }\n+            }\n+            ch = _inputBuffer[_inputPtr++] & 0xFF;\n+        }\n+\n+        if (currQuadBytes > 0) {\n+            if (qlen >= quads.length) {\n+                _quadBuffer = quads = growArrayBy(quads, quads.length);\n+            }\n+            quads[qlen++] = currQuad;\n+        }\n+        Name name = _symbols.findName(quads, qlen);\n+        if (name == null) {\n+            name = addName(quads, qlen, currQuadBytes);\n+        }\n+        return name;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods, symbol (name) handling\n+    /**********************************************************\n+     */\n+\n+    private final Name findName(int q1, int lastQuadBytes)\n+        throws JsonParseException\n+    {\n+        // Usually we'll find it from the canonical symbol table already\n+        Name name = _symbols.findName(q1);\n+        if (name != null) {\n+            return name;\n+        }\n+        // If not, more work. We'll need add stuff to buffer\n+        _quadBuffer[0] = q1;\n+        return addName(_quadBuffer, 1, lastQuadBytes);\n+    }\n+\n+    private final Name findName(int q1, int q2, int lastQuadBytes)\n+        throws JsonParseException\n+    {\n+        // Usually we'll find it from the canonical symbol table already\n+        Name name = _symbols.findName(q1, q2);\n+        if (name != null) {\n+            return name;\n+        }\n+        // If not, more work. We'll need add stuff to buffer\n+        _quadBuffer[0] = q1;\n+        _quadBuffer[1] = q2;\n+        return addName(_quadBuffer, 2, lastQuadBytes);\n+    }\n+\n+    private final Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes)\n+        throws JsonParseException\n+    {\n+        if (qlen >= quads.length) {\n+            _quadBuffer = quads = growArrayBy(quads, quads.length);\n+        }\n+        quads[qlen++] = lastQuad;\n+        Name name = _symbols.findName(quads, qlen);\n+        if (name == null) {\n+            return addName(quads, qlen, lastQuadBytes);\n+        }\n+        return name;\n+    }\n+\n+    /**\n+     * This is the main workhorse method used when we take a symbol\n+     * table miss. It needs to demultiplex individual bytes, decode\n+     * multi-byte chars (if any), and then construct Name instance\n+     * and add it to the symbol table.\n+     */\n+    private final Name addName(int[] quads, int qlen, int lastQuadBytes)\n+        throws JsonParseException\n+    {\n+        /* Ok: must decode UTF-8 chars. No other validation is\n+         * needed, since unescaping has been done earlier as necessary\n+         * (as well as error reporting for unescaped control chars)\n+         */\n+        // 4 bytes per quad, except last one maybe less\n+        int byteLen = (qlen << 2) - 4 + lastQuadBytes;\n+\n+        /* And last one is not correctly aligned (leading zero bytes instead\n+         * need to shift a bit, instead of trailing). Only need to shift it\n+         * for UTF-8 decoding; need revert for storage (since key will not\n+         * be aligned, to optimize lookup speed)\n+         */\n+        int lastQuad;\n+\n+        if (lastQuadBytes < 4) {\n+            lastQuad = quads[qlen-1];\n+            // 8/16/24 bit left shift\n+            quads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3));\n+        } else {\n+            lastQuad = 0;\n+        }\n+\n+        // Need some working space, TextBuffer works well:\n+        char[] cbuf = _textBuffer.emptyAndGetCurrentSegment();\n+        int cix = 0;\n+\n+        for (int ix = 0; ix < byteLen; ) {\n+            int ch = quads[ix >> 2]; // current quad, need to shift+mask\n+            int byteIx = (ix & 3);\n+            ch = (ch >> ((3 - byteIx) << 3)) & 0xFF;\n+            ++ix;\n+\n+            if (ch > 127) { // multi-byte\n+                int needed;\n+                if ((ch & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)\n+                    ch &= 0x1F;\n+                    needed = 1;\n+                } else if ((ch & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF)\n+                    ch &= 0x0F;\n+                    needed = 2;\n+                } else if ((ch & 0xF8) == 0xF0) { // 4 bytes; double-char with surrogates and all...\n+                    ch &= 0x07;\n+                    needed = 3;\n+                } else { // 5- and 6-byte chars not valid xml chars\n+                    _reportInvalidInitial(ch);\n+                    needed = ch = 1; // never really gets this far\n+                }\n+                if ((ix + needed) > byteLen) {\n+                    _reportInvalidEOF(\" in field name\");\n+                }\n+                \n+                // Ok, always need at least one more:\n+                int ch2 = quads[ix >> 2]; // current quad, need to shift+mask\n+                byteIx = (ix & 3);\n+                ch2 = (ch2 >> ((3 - byteIx) << 3));\n+                ++ix;\n+                \n+                if ((ch2 & 0xC0) != 0x080) {\n+                    _reportInvalidOther(ch2);\n+                }\n+                ch = (ch << 6) | (ch2 & 0x3F);\n+                if (needed > 1) {\n+                    ch2 = quads[ix >> 2];\n+                    byteIx = (ix & 3);\n+                    ch2 = (ch2 >> ((3 - byteIx) << 3));\n+                    ++ix;\n+                    \n+                    if ((ch2 & 0xC0) != 0x080) {\n+                        _reportInvalidOther(ch2);\n+                    }\n+                    ch = (ch << 6) | (ch2 & 0x3F);\n+                    if (needed > 2) { // 4 bytes? (need surrogates on output)\n+                        ch2 = quads[ix >> 2];\n+                        byteIx = (ix & 3);\n+                        ch2 = (ch2 >> ((3 - byteIx) << 3));\n+                        ++ix;\n+                        if ((ch2 & 0xC0) != 0x080) {\n+                            _reportInvalidOther(ch2 & 0xFF);\n+                        }\n+                        ch = (ch << 6) | (ch2 & 0x3F);\n+                    }\n+                }\n+                if (needed > 2) { // surrogate pair? once again, let's output one here, one later on\n+                    ch -= 0x10000; // to normalize it starting with 0x0\n+                    if (cix >= cbuf.length) {\n+                        cbuf = _textBuffer.expandCurrentSegment();\n+                    }\n+                    cbuf[cix++] = (char) (0xD800 + (ch >> 10));\n+                    ch = 0xDC00 | (ch & 0x03FF);\n+                }\n+            }\n+            if (cix >= cbuf.length) {\n+                cbuf = _textBuffer.expandCurrentSegment();\n+            }\n+            cbuf[cix++] = (char) ch;\n+        }\n+\n+        // Ok. Now we have the character array, and can construct the String\n+        String baseName = new String(cbuf, 0, cix);\n+        // And finally, un-align if necessary\n+        if (lastQuadBytes < 4) {\n+            quads[qlen-1] = lastQuad;\n+        }\n+        return _symbols.addName(baseName, quads, qlen);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods, String value parsing\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    protected void _finishString()\n+        throws IOException, JsonParseException\n+    {\n+        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n+        int ptr = _inputPtr;\n+        if (ptr >= _inputEnd) {\n+            loadMoreGuaranteed();\n+            ptr = _inputPtr;\n+        }\n+        int outPtr = 0;\n+        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n+        final int[] codes = sInputCodesUtf8;\n+\n+        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n+        final byte[] inputBuffer = _inputBuffer;\n+        while (ptr < max) {\n+            int c = (int) inputBuffer[ptr] & 0xFF;\n+            if (codes[c] != 0) {\n+                if (c == INT_QUOTE) {\n+                    _inputPtr = ptr+1;\n+                    _textBuffer.setCurrentLength(outPtr);\n+                    return;\n+                }\n+                break;\n+            }\n+            ++ptr;\n+            outBuf[outPtr++] = (char) c;\n+        }\n+        _inputPtr = ptr;\n+        _finishString2(outBuf, outPtr);\n+    }\n+\n+    private final void _finishString2(char[] outBuf, int outPtr)\n+        throws IOException, JsonParseException\n+    {\n+        int c;\n+\n+        // Here we do want to do full decoding, hence:\n+        final int[] codes = sInputCodesUtf8;\n+        final byte[] inputBuffer = _inputBuffer;\n+\n+        main_loop:\n+        while (true) {\n+            // Then the tight ASCII non-funny-char loop:\n+            ascii_loop:\n+            while (true) {\n+                int ptr = _inputPtr;\n+                if (ptr >= _inputEnd) {\n+                    loadMoreGuaranteed();\n+                    ptr = _inputPtr;\n+                }\n+                if (outPtr >= outBuf.length) {\n+                    outBuf = _textBuffer.finishCurrentSegment();\n+                    outPtr = 0;\n+                }\n+                final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\n+                while (ptr < max) {\n+                    c = (int) inputBuffer[ptr++] & 0xFF;\n+                    if (codes[c] != 0) {\n+                        _inputPtr = ptr;\n+                        break ascii_loop;\n+                    }\n+                    outBuf[outPtr++] = (char) c;\n+                }\n+                _inputPtr = ptr;\n+            }\n+            // Ok: end marker, escape or multi-byte?\n+            if (c == INT_QUOTE) {\n+                break main_loop;\n+            }\n+\n+            switch (codes[c]) {\n+            case 1: // backslash\n+                c = _decodeEscaped();\n+                break;\n+            case 2: // 2-byte UTF\n+                c = _decodeUtf8_2(c);\n+                break;\n+            case 3: // 3-byte UTF\n+                if ((_inputEnd - _inputPtr) >= 2) {\n+                    c = _decodeUtf8_3fast(c);\n+                } else {\n+                    c = _decodeUtf8_3(c);\n+                }\n+                break;\n+            case 4: // 4-byte UTF\n+                c = _decodeUtf8_4(c);\n+                // Let's add first part right away:\n+                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n+                if (outPtr >= outBuf.length) {\n+                    outBuf = _textBuffer.finishCurrentSegment();\n+                    outPtr = 0;\n+                }\n+                c = 0xDC00 | (c & 0x3FF);\n+                // And let the other char output down below\n+                break;\n+            default:\n+                if (c < INT_SPACE) {\n+                    // As per [JACKSON-208], call can now return:\n+                    _throwUnquotedSpace(c, \"string value\");\n+                } else {\n+                    // Is this good enough error message?\n+                    _reportInvalidChar(c);\n+                }\n+            }\n+            // Need more room?\n+            if (outPtr >= outBuf.length) {\n+                outBuf = _textBuffer.finishCurrentSegment();\n+                outPtr = 0;\n+            }\n+            // Ok, let's add char to output:\n+            outBuf[outPtr++] = (char) c;\n+        }\n+        _textBuffer.setCurrentLength(outPtr);\n+    }\n+\n+    /**\n+     * Method called to skim through rest of unparsed String value,\n+     * if it is not needed. This can be done bit faster if contents\n+     * need not be stored for future access.\n+     */\n+    protected void _skipString()\n+        throws IOException, JsonParseException\n+    {\n+        _tokenIncomplete = false;\n+\n+        // Need to be fully UTF-8 aware here:\n+        final int[] codes = sInputCodesUtf8;\n+        final byte[] inputBuffer = _inputBuffer;\n+\n+        main_loop:\n+        while (true) {\n+            int c;\n+\n+            ascii_loop:\n+            while (true) {\n+                int ptr = _inputPtr;\n+                int max = _inputEnd;\n+                if (ptr >= max) {\n+                    loadMoreGuaranteed();\n+                    ptr = _inputPtr;\n+                    max = _inputEnd;\n+                }\n+                while (ptr < max) {\n+                    c = (int) inputBuffer[ptr++] & 0xFF;\n+                    if (codes[c] != 0) {\n+                        _inputPtr = ptr;\n+                        break ascii_loop;\n+                    }\n+                }\n+                _inputPtr = ptr;\n+            }\n+            // Ok: end marker, escape or multi-byte?\n+            if (c == INT_QUOTE) {\n+                break main_loop;\n+            }\n+            \n+            switch (codes[c]) {\n+            case 1: // backslash\n+                _decodeEscaped();\n+                break;\n+            case 2: // 2-byte UTF\n+                _skipUtf8_2(c);\n+                break;\n+            case 3: // 3-byte UTF\n+                _skipUtf8_3(c);\n+                break;\n+            case 4: // 4-byte UTF\n+                _skipUtf8_4(c);\n+                break;\n+            default:\n+                if (c < INT_SPACE) {\n+                    // As per [JACKSON-208], call can now return:\n+                    _throwUnquotedSpace(c, \"string value\");\n+                } else {\n+                    // Is this good enough error message?\n+                    _reportInvalidChar(c);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method for handling cases where first non-space character\n+     * of an expected value token is not legal for standard JSON content.\n+     *\n+     * @since 1.3\n+     */\n+    protected JsonToken _handleUnexpectedValue(int c)\n+        throws IOException, JsonParseException\n+    {\n+        // Most likely an error, unless we are to allow single-quote-strings\n+        switch (c) {\n+        case '\\'':\n+            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n+                return _handleApostropheValue();\n+            }\n+            break;\n+        case 'N':\n+            _matchToken(\"NaN\", 1);\n+            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n+                return resetAsNaN(\"NaN\", Double.NaN);\n+            }\n+            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n+            break;\n+        case '+': // note: '-' is taken as number\n+            if (_inputPtr >= _inputEnd) {\n+                if (!loadMore()) {\n+                    _reportInvalidEOFInValue();\n+                }\n+            }\n+            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false);\n+        }\n+\n+        _reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n+        return null;\n+    }\n+    \n+    protected JsonToken _handleApostropheValue()\n+        throws IOException, JsonParseException\n+    {\n+        int c = 0;\n+        // Otherwise almost verbatim copy of _finishString()\n+        int outPtr = 0;\n+        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n+\n+        // Here we do want to do full decoding, hence:\n+        final int[] codes = sInputCodesUtf8;\n+        final byte[] inputBuffer = _inputBuffer;\n+\n+        main_loop:\n+        while (true) {\n+            // Then the tight ascii non-funny-char loop:\n+            ascii_loop:\n+            while (true) {\n+                if (_inputPtr >= _inputEnd) {\n+                    loadMoreGuaranteed();\n+                }\n+                if (outPtr >= outBuf.length) {\n+                    outBuf = _textBuffer.finishCurrentSegment();\n+                    outPtr = 0;\n+                }\n+                int max = _inputEnd;\n+                {\n+                    int max2 = _inputPtr + (outBuf.length - outPtr);\n+                    if (max2 < max) {\n+                        max = max2;\n+                    }\n+                }\n+                while (_inputPtr < max) {\n+                    c = (int) inputBuffer[_inputPtr++] & 0xFF;\n+                    if (c == INT_APOSTROPHE || codes[c] != 0) {\n+                        break ascii_loop;\n+                    }\n+                    outBuf[outPtr++] = (char) c;\n+                }\n+            }\n+\n+            // Ok: end marker, escape or multi-byte?\n+            if (c == INT_APOSTROPHE) {\n+                break main_loop;\n+            }\n+\n+            switch (codes[c]) {\n+            case 1: // backslash\n+                if (c != INT_QUOTE) { // marked as special, isn't here\n+                    c = _decodeEscaped();\n+                }\n+                break;\n+            case 2: // 2-byte UTF\n+                c = _decodeUtf8_2(c);\n+                break;\n+            case 3: // 3-byte UTF\n+                if ((_inputEnd - _inputPtr) >= 2) {\n+                    c = _decodeUtf8_3fast(c);\n+                } else {\n+                    c = _decodeUtf8_3(c);\n+                }\n+                break;\n+            case 4: // 4-byte UTF\n+                c = _decodeUtf8_4(c);\n+                // Let's add first part right away:\n+                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n+                if (outPtr >= outBuf.length) {\n+                    outBuf = _textBuffer.finishCurrentSegment();\n+                    outPtr = 0;\n+                }\n+                c = 0xDC00 | (c & 0x3FF);\n+                // And let the other char output down below\n+                break;\n+            default:\n+                if (c < INT_SPACE) {\n+                    _throwUnquotedSpace(c, \"string value\");\n+                }\n+                // Is this good enough error message?\n+                _reportInvalidChar(c);\n+            }\n+            // Need more room?\n+            if (outPtr >= outBuf.length) {\n+                outBuf = _textBuffer.finishCurrentSegment();\n+                outPtr = 0;\n+            }\n+            // Ok, let's add char to output:\n+            outBuf[outPtr++] = (char) c;\n+        }\n+        _textBuffer.setCurrentLength(outPtr);\n+\n+        return JsonToken.VALUE_STRING;\n+    }\n+\n+    /**\n+     * Method called if expected numeric value (due to leading sign) does not\n+     * look like a number\n+     */\n+    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative)\n+        throws IOException, JsonParseException\n+    {\n+        if (ch == 'I') {\n+            if (_inputPtr >= _inputEnd) {\n+                if (!loadMore()) {\n+                    _reportInvalidEOFInValue();\n+                }\n+            }\n+            ch = _inputBuffer[_inputPtr++];\n+            if (ch == 'N') {\n+                String match = negative ? \"-INF\" :\"+INF\";\n+                _matchToken(match, 3);\n+                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n+                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n+                }\n+                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n+            } else if (ch == 'n') {\n+                String match = negative ? \"-Infinity\" :\"+Infinity\";\n+                _matchToken(match, 3);\n+                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n+                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n+                }\n+                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n+            }\n+        }\n+        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n+        return null;\n+    }\n+\n+    protected final void _matchToken(String matchStr, int i)\n+        throws IOException, JsonParseException\n+    {\n+        final int len = matchStr.length();\n+    \n+        do {\n+            if (_inputPtr >= _inputEnd) {\n+                if (!loadMore()) {\n+                    _reportInvalidEOF(\" in a value\");\n+                }\n+            }\n+            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n+                _reportInvalidToken(matchStr.substring(0, i), \"'null', 'true', 'false' or NaN\");\n+            }\n+            ++_inputPtr;\n+        } while (++i < len);\n+    \n+        // but let's also ensure we either get EOF, or non-alphanum char...\n+        if (_inputPtr >= _inputEnd) {\n+            if (!loadMore()) {\n+                return;\n+            }\n+        }\n+        int ch = _inputBuffer[_inputPtr] & 0xFF;\n+        if (ch < '0' || ch == ']' || ch == '}') { // expected/allowed chars\n+            return;\n+        }\n+        // but actually only alphanums are problematic\n+        char c = (char) _decodeCharForError(ch);\n+        if (Character.isJavaIdentifierPart(c)) {\n+            ++_inputPtr;\n+            _reportInvalidToken(matchStr.substring(0, i), \"'null', 'true', 'false' or NaN\");\n+        }\n+    }\n+    \n+    protected void _reportInvalidToken(String matchedPart, String msg)\n+        throws IOException, JsonParseException\n+    {\n+        StringBuilder sb = new StringBuilder(matchedPart);\n+        /* Let's just try to find what appears to be the token, using\n+         * regular Java identifier character rules. It's just a heuristic,\n+         * nothing fancy here (nor fast).\n+         */\n+        while (true) {\n+            if (_inputPtr >= _inputEnd && !loadMore()) {\n+                break;\n+            }\n+            int i = (int) _inputBuffer[_inputPtr++];\n+            char c = (char) _decodeCharForError(i);\n+            if (!Character.isJavaIdentifierPart(c)) {\n+                break;\n+            }\n+            ++_inputPtr;\n+            sb.append(c);\n+        }\n+        _reportError(\"Unrecognized token '\"+sb.toString()+\"': was expecting \"+msg);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Internal methods, ws skipping, escape/unescape\n+    /**********************************************************\n+     */\n+\n+    private final int _skipWS()\n+        throws IOException, JsonParseException\n+    {\n+        while (_inputPtr < _inputEnd || loadMore()) {\n+            int i = _inputBuffer[_inputPtr++] & 0xFF;\n+            if (i > INT_SPACE) {\n+                if (i != INT_SLASH) {\n+                    return i;\n+                }\n+                _skipComment();\n+            } else if (i != INT_SPACE) {\n+                if (i == INT_LF) {\n+                    _skipLF();\n+                } else if (i == INT_CR) {\n+                    _skipCR();\n+                } else if (i != INT_TAB) {\n+                    _throwInvalidSpace(i);\n+                }\n+            }\n+        }\n+        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n+    }\n+\n+    private final int _skipWSOrEnd()\n+        throws IOException, JsonParseException\n+    {\n+        while ((_inputPtr < _inputEnd) || loadMore()) {\n+            int i = _inputBuffer[_inputPtr++] & 0xFF;\n+            if (i > INT_SPACE) {\n+                if (i != INT_SLASH) {\n+                    return i;\n+                }\n+                _skipComment();\n+            } else if (i != INT_SPACE) {\n+                if (i == INT_LF) {\n+                    _skipLF();\n+                } else if (i == INT_CR) {\n+                    _skipCR();\n+                } else if (i != INT_TAB) {\n+                    _throwInvalidSpace(i);\n+                }\n+            }\n+        }\n+        // We ran out of input...\n+        _handleEOF();\n+        return -1;\n+    }\n+\n+    /**\n+     * Helper method for matching and skipping a colon character,\n+     * optionally surrounded by white space\n+     * \n+     * @since 1.9\n+     */\n+    private final int _skipColon()\n+        throws IOException, JsonParseException\n+    {\n+        if (_inputPtr >= _inputEnd) {\n+            loadMoreGuaranteed();\n+        }\n+        // first fast case: we just got a colon without white space:\n+        int i = _inputBuffer[_inputPtr++];\n+        if (i == INT_COLON) {\n+            if (_inputPtr < _inputEnd) {\n+                i = _inputBuffer[_inputPtr] & 0xFF;\n+                if (i > INT_SPACE && i != INT_SLASH) {\n+                    ++_inputPtr;\n+                    return i;\n+                }\n+            }\n+        } else {\n+            // need to skip potential leading space\n+            i &= 0xFF;\n+\n+            space_loop:\n+            while (true) {\n+                switch (i) {\n+                case INT_SPACE:\n+                case INT_TAB:\n+                case INT_CR:\n+                    _skipCR();\n+                    break;\n+                case INT_LF:\n+                    _skipLF();\n+                    break;\n+                case INT_SLASH:\n+                    _skipComment();\n+                    break;\n+                default:\n+                    if (i < INT_SPACE) {\n+                        _throwInvalidSpace(i);\n+                    }\n+                    break space_loop;\n+                }\n+            }\n+            if (_inputPtr >= _inputEnd) {\n+                loadMoreGuaranteed();\n+            }\n+            i = _inputBuffer[_inputPtr++] & 0xFF;\n+            if (i != INT_COLON) {\n+                _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n+            }\n+        }\n+\n+            // either way, found colon, skip through trailing WS\n+        while (_inputPtr < _inputEnd || loadMore()) {\n+            i = _inputBuffer[_inputPtr++] & 0xFF;\n+            if (i > INT_SPACE) {\n+                if (i != INT_SLASH) {\n+                    return i;\n+                }\n+                _skipComment();\n+            } else if (i != INT_SPACE) {\n+                if (i == INT_LF) {\n+                    _skipLF();\n+                } else if (i == INT_CR) {\n+                    _skipCR();\n+                } else if (i != INT_TAB) {\n+                    _throwInvalidSpace(i);\n+                }\n+            }\n+        }\n+        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n+    }\n+    \n+    private final void _skipComment()\n+        throws IOException, JsonParseException\n+    {\n+        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n+            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n+        }\n+        // First: check which comment (if either) it is:\n+        if (_inputPtr >= _inputEnd && !loadMore()) {\n+            _reportInvalidEOF(\" in a comment\");\n+        }\n+        int c = _inputBuffer[_inputPtr++] & 0xFF;\n+        if (c == INT_SLASH) {\n+            _skipCppComment();\n+        } else if (c == INT_ASTERISK) {\n+            _skipCComment();\n+        } else {\n+            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n+        }\n+    }\n+\n+    private final void _skipCComment()\n+        throws IOException, JsonParseException\n+    {\n+        // Need to be UTF-8 aware here to decode content (for skipping)\n+        final int[] codes = CharTypes.getInputCodeComment();\n+\n+        // Ok: need the matching '*/'\n+        while ((_inputPtr < _inputEnd) || loadMore()) {\n+            int i = (int) _inputBuffer[_inputPtr++] & 0xFF;\n+            int code = codes[i];\n+            if (code != 0) {\n+                switch (code) {\n+                case INT_ASTERISK:\n+                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n+                        ++_inputPtr;\n+                        return;\n+                    }\n+                    break;\n+                case INT_LF:\n+                    _skipLF();\n+                    break;\n+                case INT_CR:\n+                    _skipCR();\n+                    break;\n+                default: // e.g. -1\n+                    // Is this good enough error message?\n+                    _reportInvalidChar(i);\n+                }\n+            }\n+        }\n+        _reportInvalidEOF(\" in a comment\");\n+    }\n+\n+    private final void _skipCppComment()\n+        throws IOException, JsonParseException\n+    {\n+        // Ok: need to find EOF or linefeed\n+        final int[] codes = CharTypes.getInputCodeComment();\n+        while ((_inputPtr < _inputEnd) || loadMore()) {\n+            int i = (int) _inputBuffer[_inputPtr++] & 0xFF;\n+            int code = codes[i];\n+            if (code != 0) {\n+                switch (code) {\n+                case INT_LF:\n+                    _skipLF();\n+                    return;\n+                case INT_CR:\n+                    _skipCR();\n+                    return;\n+                case INT_ASTERISK: // nop for these comments\n+                    break;\n+                default: // e.g. -1\n+                    // Is this good enough error message?\n+                    _reportInvalidChar(i);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected final char _decodeEscaped()\n+        throws IOException, JsonParseException\n+    {\n+        if (_inputPtr >= _inputEnd) {\n+            if (!loadMore()) {\n+                _reportInvalidEOF(\" in character escape sequence\");\n+            }\n+        }\n+        int c = (int) _inputBuffer[_inputPtr++];\n+\n+        switch ((int) c) {\n+            // First, ones that are mapped\n+        case INT_b:\n+            return '\\b';\n+        case INT_t:\n+            return '\\t';\n+        case INT_n:\n+            return '\\n';\n+        case INT_f:\n+            return '\\f';\n+        case INT_r:\n+            return '\\r';\n+\n+            // And these are to be returned as they are\n+        case INT_QUOTE:\n+        case INT_SLASH:\n+        case INT_BACKSLASH:\n+            return (char) c;\n+\n+        case INT_u: // and finally hex-escaped\n+            break;\n+\n+        default:\n+            return _handleUnrecognizedCharacterEscape((char) _decodeCharForError(c));\n+        }\n+\n+        // Ok, a hex escape. Need 4 characters\n+        int value = 0;\n+        for (int i = 0; i < 4; ++i) {\n+            if (_inputPtr >= _inputEnd) {\n+                if (!loadMore()) {\n+                    _reportInvalidEOF(\" in character escape sequence\");\n+                }\n+            }\n+            int ch = (int) _inputBuffer[_inputPtr++];\n+            int digit = CharTypes.charToHex(ch);\n+            if (digit < 0) {\n+                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n+            }\n+            value = (value << 4) | digit;\n+        }\n+        return (char) value;\n+    }\n+\n+    protected int _decodeCharForError(int firstByte)\n+        throws IOException, JsonParseException\n+    {\n+        int c = (int) firstByte;\n+        if (c < 0) { // if >= 0, is ascii and fine as is\n+            int needed;\n+            \n+            // Ok; if we end here, we got multi-byte combination\n+            if ((c & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)\n+                c &= 0x1F;\n+                needed = 1;\n+            } else if ((c & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF)\n+                c &= 0x0F;\n+                needed = 2;\n+            } else if ((c & 0xF8) == 0xF0) {\n+                // 4 bytes; double-char with surrogates and all...\n+                c &= 0x07;\n+                needed = 3;\n+            } else {\n+                _reportInvalidInitial(c & 0xFF);\n+                needed = 1; // never gets here\n+            }\n+\n+            int d = nextByte();\n+            if ((d & 0xC0) != 0x080) {\n+                _reportInvalidOther(d & 0xFF);\n+            }\n+            c = (c << 6) | (d & 0x3F);\n+            \n+            if (needed > 1) { // needed == 1 means 2 bytes total\n+                d = nextByte(); // 3rd byte\n+                if ((d & 0xC0) != 0x080) {\n+                    _reportInvalidOther(d & 0xFF);\n+                }\n+                c = (c << 6) | (d & 0x3F);\n+                if (needed > 2) { // 4 bytes? (need surrogates)\n+                    d = nextByte();\n+                    if ((d & 0xC0) != 0x080) {\n+                        _reportInvalidOther(d & 0xFF);\n+                    }\n+                    c = (c << 6) | (d & 0x3F);\n+                }\n+            }\n+        }\n+        return c;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods,UTF8 decoding\n+    /**********************************************************\n+     */\n+\n+    private final int _decodeUtf8_2(int c)\n+        throws IOException, JsonParseException\n+    {\n+        if (_inputPtr >= _inputEnd) {\n+            loadMoreGuaranteed();\n+        }\n+        int d = (int) _inputBuffer[_inputPtr++];\n+        if ((d & 0xC0) != 0x080) {\n+            _reportInvalidOther(d & 0xFF, _inputPtr);\n+        }\n+        return ((c & 0x1F) << 6) | (d & 0x3F);\n+    }\n+\n+    private final int _decodeUtf8_3(int c1)\n+        throws IOException, JsonParseException\n+    {\n+        if (_inputPtr >= _inputEnd) {\n+            loadMoreGuaranteed();\n+        }\n+        c1 &= 0x0F;\n+        int d = (int) _inputBuffer[_inputPtr++];\n+        if ((d & 0xC0) != 0x080) {\n+            _reportInvalidOther(d & 0xFF, _inputPtr);\n+        }\n+        int c = (c1 << 6) | (d & 0x3F);\n+        if (_inputPtr >= _inputEnd) {\n+            loadMoreGuaranteed();\n+        }\n+        d = (int) _inputBuffer[_inputPtr++];\n+        if ((d & 0xC0) != 0x080) {\n+            _reportInvalidOther(d & 0xFF, _inputPtr);\n+        }\n+        c = (c << 6) | (d & 0x3F);\n+        return c;\n+    }\n+\n+    private final int _decodeUtf8_3fast(int c1)\n+        throws IOException, JsonParseException\n+    {\n+        c1 &= 0x0F;\n+        int d = (int) _inputBuffer[_inputPtr++];\n+        if ((d & 0xC0) != 0x080) {\n+            _reportInvalidOther(d & 0xFF, _inputPtr);\n+        }\n+        int c = (c1 << 6) | (d & 0x3F);\n+        d = (int) _inputBuffer[_inputPtr++];\n+        if ((d & 0xC0) != 0x080) {\n+            _reportInvalidOther(d & 0xFF, _inputPtr);\n+        }\n+        c = (c << 6) | (d & 0x3F);\n+        return c;\n+    }\n+\n+    /**\n+     * @return Character value <b>minus 0x10000</c>; this so that caller\n+     *    can readily expand it to actual surrogates\n+     */\n+    private final int _decodeUtf8_4(int c)\n+        throws IOException, JsonParseException\n+    {\n+        if (_inputPtr >= _inputEnd) {\n+            loadMoreGuaranteed();\n+        }\n+        int d = (int) _inputBuffer[_inputPtr++];\n+        if ((d & 0xC0) != 0x080) {\n+            _reportInvalidOther(d & 0xFF, _inputPtr);\n+        }\n+        c = ((c & 0x07) << 6) | (d & 0x3F);\n+\n+        if (_inputPtr >= _inputEnd) {\n+            loadMoreGuaranteed();\n+        }\n+        d = (int) _inputBuffer[_inputPtr++];\n+        if ((d & 0xC0) != 0x080) {\n+            _reportInvalidOther(d & 0xFF, _inputPtr);\n+        }\n+        c = (c << 6) | (d & 0x3F);\n+        if (_inputPtr >= _inputEnd) {\n+            loadMoreGuaranteed();\n+        }\n+        d = (int) _inputBuffer[_inputPtr++];\n+        if ((d & 0xC0) != 0x080) {\n+            _reportInvalidOther(d & 0xFF, _inputPtr);\n+        }\n+\n+        /* note: won't change it to negative here, since caller\n+         * already knows it'll need a surrogate\n+         */\n+        return ((c << 6) | (d & 0x3F)) - 0x10000;\n+    }\n+\n+    private final void _skipUtf8_2(int c)\n+        throws IOException, JsonParseException\n+    {\n+        if (_inputPtr >= _inputEnd) {\n+            loadMoreGuaranteed();\n+        }\n+        c = (int) _inputBuffer[_inputPtr++];\n+        if ((c & 0xC0) != 0x080) {\n+            _reportInvalidOther(c & 0xFF, _inputPtr);\n+        }\n+    }\n+\n+    /* Alas, can't heavily optimize skipping, since we still have to\n+     * do validity checks...\n+     */\n+    private final void _skipUtf8_3(int c)\n+        throws IOException, JsonParseException\n+    {\n+        if (_inputPtr >= _inputEnd) {\n+            loadMoreGuaranteed();\n+        }\n+        //c &= 0x0F;\n+        c = (int) _inputBuffer[_inputPtr++];\n+        if ((c & 0xC0) != 0x080) {\n+            _reportInvalidOther(c & 0xFF, _inputPtr);\n+        }\n+        if (_inputPtr >= _inputEnd) {\n+            loadMoreGuaranteed();\n+        }\n+        c = (int) _inputBuffer[_inputPtr++];\n+        if ((c & 0xC0) != 0x080) {\n+            _reportInvalidOther(c & 0xFF, _inputPtr);\n+        }\n+    }\n+\n+    private final void _skipUtf8_4(int c)\n+        throws IOException, JsonParseException\n+    {\n+        if (_inputPtr >= _inputEnd) {\n+            loadMoreGuaranteed();\n+        }\n+        int d = (int) _inputBuffer[_inputPtr++];\n+        if ((d & 0xC0) != 0x080) {\n+            _reportInvalidOther(d & 0xFF, _inputPtr);\n+        }\n+        if (_inputPtr >= _inputEnd) {\n+            loadMoreGuaranteed();\n+        }\n+        d = (int) _inputBuffer[_inputPtr++];\n+        if ((d & 0xC0) != 0x080) {\n+            _reportInvalidOther(d & 0xFF, _inputPtr);\n+        }\n+        if (_inputPtr >= _inputEnd) {\n+            loadMoreGuaranteed();\n+        }\n+        d = (int) _inputBuffer[_inputPtr++];\n+        if ((d & 0xC0) != 0x080) {\n+            _reportInvalidOther(d & 0xFF, _inputPtr);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods, input loading\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * We actually need to check the character value here\n+     * (to see if we have \\n following \\r).\n+     */\n+    protected final void _skipCR() throws IOException\n+    {\n+        if (_inputPtr < _inputEnd || loadMore()) {\n+            if (_inputBuffer[_inputPtr] == BYTE_LF) {\n+                ++_inputPtr;\n+            }\n+        }\n+        ++_currInputRow;\n+        _currInputRowStart = _inputPtr;\n+    }\n+\n+    protected final void _skipLF() throws IOException\n+    {\n+        ++_currInputRow;\n+        _currInputRowStart = _inputPtr;\n+    }\n+\n+    private int nextByte()\n+        throws IOException, JsonParseException\n+    {\n+        if (_inputPtr >= _inputEnd) {\n+            loadMoreGuaranteed();\n+        }\n+        return _inputBuffer[_inputPtr++] & 0xFF;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods, error reporting\n+    /**********************************************************\n+     */\n+\n+    protected void _reportInvalidChar(int c)\n+        throws JsonParseException\n+        {\n+            // Either invalid WS or illegal UTF-8 start char\n+            if (c < INT_SPACE) {\n+                _throwInvalidSpace(c);\n+            }\n+            _reportInvalidInitial(c);\n+        }\n+\n+    protected void _reportInvalidInitial(int mask)\n+        throws JsonParseException\n+    {\n+        _reportError(\"Invalid UTF-8 start byte 0x\"+Integer.toHexString(mask));\n+    }\n+\n+    protected void _reportInvalidOther(int mask)\n+        throws JsonParseException\n+    {\n+        _reportError(\"Invalid UTF-8 middle byte 0x\"+Integer.toHexString(mask));\n+    }\n+\n+    protected void _reportInvalidOther(int mask, int ptr)\n+        throws JsonParseException\n+    {\n+        _inputPtr = ptr;\n+        _reportInvalidOther(mask);\n+    }\n+\n+    public static int[] growArrayBy(int[] arr, int more)\n+    {\n+        if (arr == null) {\n+            return new int[more];\n+        }\n+        int[] old = arr;\n+        int len = arr.length;\n+        arr = new int[len + more];\n+        System.arraycopy(old, 0, arr, 0, len);\n+        return arr;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Binary access\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Efficient handling for incremental parsing of base64-encoded\n+     * textual content.\n+     */\n+    protected byte[] _decodeBase64(Base64Variant b64variant)\n+        throws IOException, JsonParseException\n+    {\n+        ByteArrayBuilder builder = _getByteArrayBuilder();\n+\n+        //main_loop:\n+        while (true) {\n+            // first, we'll skip preceding white space, if any\n+            int ch;\n+            do {\n+                if (_inputPtr >= _inputEnd) {\n+                    loadMoreGuaranteed();\n+                }\n+                ch = (int) _inputBuffer[_inputPtr++] & 0xFF;\n+            } while (ch <= INT_SPACE);\n+            int bits = b64variant.decodeBase64Char(ch);\n+            if (bits < 0) { // reached the end, fair and square?\n+                if (ch == INT_QUOTE) {\n+                    return builder.toByteArray();\n+                }\n+                bits = _decodeBase64Escape(b64variant, ch, 0);\n+                if (bits < 0) { // white space to skip\n+                    continue;\n+                }\n+            }\n+            int decodedData = bits;\n+            \n+            // then second base64 char; can't get padding yet, nor ws\n+            \n+            if (_inputPtr >= _inputEnd) {\n+                loadMoreGuaranteed();\n+            }\n+            ch = _inputBuffer[_inputPtr++] & 0xFF;\n+            bits = b64variant.decodeBase64Char(ch);\n+            if (bits < 0) {\n+                bits = _decodeBase64Escape(b64variant, ch, 1);\n+            }\n+            decodedData = (decodedData << 6) | bits;\n+            \n+            // third base64 char; can be padding, but not ws\n+            if (_inputPtr >= _inputEnd) {\n+                loadMoreGuaranteed();\n+            }\n+            ch = _inputBuffer[_inputPtr++] & 0xFF;\n+            bits = b64variant.decodeBase64Char(ch);\n+\n+            // First branch: can get padding (-> 1 byte)\n+            if (bits < 0) {\n+                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n+                    // as per [JACKSON-631], could also just be 'missing'  padding\n+                    if (ch == '\"' && !b64variant.usesPadding()) {\n+                        decodedData >>= 4;\n+                        builder.append(decodedData);\n+                        return builder.toByteArray();\n+                    }\n+                    bits = _decodeBase64Escape(b64variant, ch, 2);\n+                }\n+                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n+                    // Ok, must get padding\n+                    if (_inputPtr >= _inputEnd) {\n+                        loadMoreGuaranteed();\n+                    }\n+                    ch = _inputBuffer[_inputPtr++] & 0xFF;\n+                    if (!b64variant.usesPaddingChar(ch)) {\n+                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n+                    }\n+                    // Got 12 bits, only need 8, need to shift\n+                    decodedData >>= 4;\n+                    builder.append(decodedData);\n+                    continue;\n+                }\n+            }\n+            // Nope, 2 or 3 bytes\n+            decodedData = (decodedData << 6) | bits;\n+            // fourth and last base64 char; can be padding, but not ws\n+            if (_inputPtr >= _inputEnd) {\n+                loadMoreGuaranteed();\n+            }\n+            ch = _inputBuffer[_inputPtr++] & 0xFF;\n+            bits = b64variant.decodeBase64Char(ch);\n+            if (bits < 0) {\n+                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n+                    // as per [JACKSON-631], could also just be 'missing'  padding\n+                    if (ch == '\"' && !b64variant.usesPadding()) {\n+                        decodedData >>= 2;\n+                        builder.appendTwoBytes(decodedData);\n+                        return builder.toByteArray();\n+                    }\n+                    bits = _decodeBase64Escape(b64variant, ch, 3);\n+                }\n+                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n+                    /* With padding we only get 2 bytes; but we have\n+                     * to shift it a bit so it is identical to triplet\n+                     * case with partial output.\n+                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n+                     * dummies, need to discard:\n+                     */\n+                    decodedData >>= 2;\n+                    builder.appendTwoBytes(decodedData);\n+                    continue;\n+                }\n+            }\n+            // otherwise, our triplet is now complete\n+            decodedData = (decodedData << 6) | bits;\n+            builder.appendThreeBytes(decodedData);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java\n+package com.fasterxml.jackson.core.json;\n+\n+import java.io.*;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.base.GeneratorBase;\n+import com.fasterxml.jackson.core.io.*;\n+\n+/**\n+ * {@link JsonGenerator} that outputs JSON content using a {@link java.io.Writer}\n+ * which handles character encoding.\n+ */\n+public final class WriterBasedJsonGenerator\n+    extends GeneratorBase\n+{\n+    final protected static int SHORT_WRITE = 32;\n+\n+    final protected static char[] HEX_CHARS = CharTypes.copyHexChars();\n+\n+    /**\n+     * This is the default set of escape codes, over 7-bit ASCII range\n+     * (first 128 character codes), used for single-byte UTF-8 characters.\n+     */\n+    protected final static int[] sOutputEscapes = CharTypes.get7BitOutputEscapes();\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+\n+    final protected IOContext _ioContext;\n+\n+    final protected Writer _writer;\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration, output escaping\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Currently active set of output escape code definitions (whether\n+     * and how to escape or not) for 7-bit ASCII range (first 128\n+     * character codes). Defined separately to make potentially\n+     * customizable\n+     */\n+    protected int[] _outputEscapes = sOutputEscapes;\n+\n+    /**\n+     * Value between 128 (0x80) and 65535 (0xFFFF) that indicates highest\n+     * Unicode code point that will not need escaping; or 0 to indicate\n+     * that all characters can be represented without escaping.\n+     * Typically used to force escaping of some portion of character set;\n+     * for example to always escape non-ASCII characters (if value was 127).\n+     *<p>\n+     * NOTE: not all sub-classes make use of this setting.\n+     */\n+    protected int _maximumNonEscapedChar;\n+\n+    /**\n+     * Definition of custom character escapes to use for generators created\n+     * by this factory, if any. If null, standard data format specific\n+     * escapes are used.\n+     * \n+     * @since 1.8\n+     */\n+    protected CharacterEscapes _characterEscapes;\n+\n+    /**\n+     * When custom escapes are used, this member variable can be used to\n+     * store escape to use\n+     * \n+     * @since 1.8\n+     */\n+    protected SerializableString _currentEscape;\n+\n+    /*\n+    /**********************************************************\n+    /* Output buffering\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Intermediate buffer in which contents are buffered before\n+     * being written using {@link #_writer}.\n+     */\n+    protected char[] _outputBuffer;\n+\n+    /**\n+     * Pointer to the first buffered character to output\n+     */\n+    protected int _outputHead = 0;\n+\n+    /**\n+     * Pointer to the position right beyond the last character to output\n+     * (end marker; may point to position right beyond the end of the buffer)\n+     */\n+    protected int _outputTail = 0;\n+\n+    /**\n+     * End marker of the output buffer; one past the last valid position\n+     * within the buffer.\n+     */\n+    protected int _outputEnd;\n+\n+    /**\n+     * Short (14 char) temporary buffer allocated if needed, for constructing\n+     * escape sequences\n+     */\n+    protected char[] _entityBuffer;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    public WriterBasedJsonGenerator(IOContext ctxt, int features, ObjectCodec codec,\n+            Writer w)\n+    {\n+        super(features, codec);\n+        _ioContext = ctxt;\n+        _writer = w;\n+        _outputBuffer = ctxt.allocConcatBuffer();\n+        _outputEnd = _outputBuffer.length;\n+\n+        if (isEnabled(Feature.ESCAPE_NON_ASCII)) {\n+            setHighestNonEscapedChar(127);\n+        }\n+    }\n+ \n+    /*\n+    /**********************************************************\n+    /* Overridden configuration methods\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public JsonGenerator setHighestNonEscapedChar(int charCode) {\n+        _maximumNonEscapedChar = (charCode < 0) ? 0 : charCode;\n+        return this;\n+    }\n+\n+    @Override\n+    public int getHighestEscapedChar() {\n+        return _maximumNonEscapedChar;\n+    }\n+\n+    @Override\n+    public JsonGenerator setCharacterEscapes(CharacterEscapes esc)\n+    {\n+        _characterEscapes = esc;\n+        if (esc == null) { // revert to standard escapes\n+            _outputEscapes = sOutputEscapes;\n+        } else {\n+            _outputEscapes = esc.getEscapeCodesForAscii();\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Method for accessing custom escapes factory uses for {@link JsonGenerator}s\n+     * it creates.\n+     * \n+     * @since 1.8\n+     */\n+    @Override\n+    public CharacterEscapes getCharacterEscapes() {\n+        return _characterEscapes;\n+    }\n+\n+    @Override\n+    public Object getOutputTarget() {\n+        return _writer;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Overridden methods\n+    /**********************************************************\n+     */\n+\n+    /* Most overrides in this section are just to make methods final,\n+     * to allow better inlining...\n+     */\n+\n+    @Override\n+    public final void writeFieldName(String name)  throws IOException, JsonGenerationException\n+    {\n+        int status = _writeContext.writeFieldName(name);\n+        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n+            _reportError(\"Can not write a field name, expecting a value\");\n+        }\n+        _writeFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA));\n+    }\n+\n+    @Override\n+    public final void writeStringField(String fieldName, String value)\n+        throws IOException, JsonGenerationException\n+    {\n+        writeFieldName(fieldName);\n+        writeString(value);\n+    }\n+    \n+    @Override\n+    public final void writeFieldName(SerializedString name)\n+        throws IOException, JsonGenerationException\n+    {\n+        // Object is a value, need to verify it's allowed\n+        int status = _writeContext.writeFieldName(name.getValue());\n+        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n+            _reportError(\"Can not write a field name, expecting a value\");\n+        }\n+        _writeFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA));\n+    }\n+\n+    @Override\n+    public final void writeFieldName(SerializableString name)\n+        throws IOException, JsonGenerationException\n+    {\n+        // Object is a value, need to verify it's allowed\n+        int status = _writeContext.writeFieldName(name.getValue());\n+        if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {\n+            _reportError(\"Can not write a field name, expecting a value\");\n+        }\n+        _writeFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA));\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Output method implementations, structural\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public final void writeStartArray() throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"start an array\");\n+        _writeContext = _writeContext.createChildArrayContext();\n+        if (_cfgPrettyPrinter != null) {\n+            _cfgPrettyPrinter.writeStartArray(this);\n+        } else {\n+            if (_outputTail >= _outputEnd) {\n+                _flushBuffer();\n+            }\n+            _outputBuffer[_outputTail++] = '[';\n+        }\n+    }\n+\n+    @Override\n+    public final void writeEndArray() throws IOException, JsonGenerationException\n+    {\n+        if (!_writeContext.inArray()) {\n+            _reportError(\"Current context not an ARRAY but \"+_writeContext.getTypeDesc());\n+        }\n+        if (_cfgPrettyPrinter != null) {\n+            _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());\n+        } else {\n+            if (_outputTail >= _outputEnd) {\n+                _flushBuffer();\n+            }\n+            _outputBuffer[_outputTail++] = ']';\n+        }\n+        _writeContext = _writeContext.getParent();\n+    }\n+\n+    @Override\n+    public final void writeStartObject() throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"start an object\");\n+        _writeContext = _writeContext.createChildObjectContext();\n+        if (_cfgPrettyPrinter != null) {\n+            _cfgPrettyPrinter.writeStartObject(this);\n+        } else {\n+            if (_outputTail >= _outputEnd) {\n+                _flushBuffer();\n+            }\n+            _outputBuffer[_outputTail++] = '{';\n+        }\n+    }\n+\n+    @Override\n+    public final void writeEndObject() throws IOException, JsonGenerationException\n+    {\n+        if (!_writeContext.inObject()) {\n+            _reportError(\"Current context not an object but \"+_writeContext.getTypeDesc());\n+        }\n+        _writeContext = _writeContext.getParent();\n+        if (_cfgPrettyPrinter != null) {\n+            _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount());\n+        } else {\n+            if (_outputTail >= _outputEnd) {\n+                _flushBuffer();\n+            }\n+            _outputBuffer[_outputTail++] = '}';\n+        }\n+    }\n+\n+    protected void _writeFieldName(String name, boolean commaBefore)\n+        throws IOException, JsonGenerationException\n+    {\n+        if (_cfgPrettyPrinter != null) {\n+            _writePPFieldName(name, commaBefore);\n+            return;\n+        }\n+        // for fast+std case, need to output up to 2 chars, comma, dquote\n+        if ((_outputTail + 1) >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        if (commaBefore) {\n+            _outputBuffer[_outputTail++] = ',';\n+        }\n+\n+        /* To support [JACKSON-46], we'll do this:\n+         * (Question: should quoting of spaces (etc) still be enabled?)\n+         */\n+        if (!isEnabled(Feature.QUOTE_FIELD_NAMES)) {\n+            _writeString(name);\n+            return;\n+        }\n+\n+        // we know there's room for at least one more char\n+        _outputBuffer[_outputTail++] = '\"';\n+        // The beef:\n+        _writeString(name);\n+        // and closing quotes; need room for one more char:\n+        if (_outputTail >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = '\"';\n+    }\n+\n+    public void _writeFieldName(SerializableString name, boolean commaBefore)\n+        throws IOException, JsonGenerationException\n+    {\n+        if (_cfgPrettyPrinter != null) {\n+            _writePPFieldName(name, commaBefore);\n+            return;\n+        }\n+        // for fast+std case, need to output up to 2 chars, comma, dquote\n+        if ((_outputTail + 1) >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        if (commaBefore) {\n+            _outputBuffer[_outputTail++] = ',';\n+        }\n+        /* To support [JACKSON-46], we'll do this:\n+         * (Question: should quoting of spaces (etc) still be enabled?)\n+         */\n+        final char[] quoted = name.asQuotedChars();\n+        if (!isEnabled(Feature.QUOTE_FIELD_NAMES)) {\n+            writeRaw(quoted, 0, quoted.length);\n+            return;\n+        }\n+        // we know there's room for at least one more char\n+        _outputBuffer[_outputTail++] = '\"';\n+        // The beef:\n+        final int qlen = quoted.length;\n+        if ((_outputTail + qlen + 1) >= _outputEnd) {\n+            writeRaw(quoted, 0, qlen);\n+            // and closing quotes; need room for one more char:\n+            if (_outputTail >= _outputEnd) {\n+                _flushBuffer();\n+            }\n+            _outputBuffer[_outputTail++] = '\"';\n+        } else {\n+            System.arraycopy(quoted, 0, _outputBuffer, _outputTail, qlen);\n+            _outputTail += qlen;\n+            _outputBuffer[_outputTail++] = '\"';\n+        }\n+    }\n+    \n+    /**\n+     * Specialized version of <code>_writeFieldName</code>, off-lined\n+     * to keep the \"fast path\" as simple (and hopefully fast) as possible.\n+     */\n+    protected final void _writePPFieldName(String name, boolean commaBefore)\n+        throws IOException, JsonGenerationException\n+    {\n+        if (commaBefore) {\n+            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n+        } else {\n+            _cfgPrettyPrinter.beforeObjectEntries(this);\n+        }\n+\n+        if (isEnabled(Feature.QUOTE_FIELD_NAMES)) { // standard\n+            if (_outputTail >= _outputEnd) {\n+                _flushBuffer();\n+            }\n+            _outputBuffer[_outputTail++] = '\"';\n+            _writeString(name);\n+            if (_outputTail >= _outputEnd) {\n+                _flushBuffer();\n+            }\n+            _outputBuffer[_outputTail++] = '\"';\n+        } else { // non-standard, omit quotes\n+            _writeString(name);\n+        }\n+    }\n+\n+    protected final void _writePPFieldName(SerializableString name, boolean commaBefore)\n+        throws IOException, JsonGenerationException\n+    {\n+        if (commaBefore) {\n+            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n+        } else {\n+            _cfgPrettyPrinter.beforeObjectEntries(this);\n+        }\n+    \n+        final char[] quoted = name.asQuotedChars();\n+        if (isEnabled(Feature.QUOTE_FIELD_NAMES)) { // standard\n+            if (_outputTail >= _outputEnd) {\n+                _flushBuffer();\n+            }\n+            _outputBuffer[_outputTail++] = '\"';\n+            writeRaw(quoted, 0, quoted.length);\n+            if (_outputTail >= _outputEnd) {\n+                _flushBuffer();\n+            }\n+            _outputBuffer[_outputTail++] = '\"';\n+        } else { // non-standard, omit quotes\n+            writeRaw(quoted, 0, quoted.length);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Output method implementations, textual\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeString(String text)\n+        throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write text value\");\n+        if (text == null) {\n+            _writeNull();\n+            return;\n+        }\n+        if (_outputTail >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = '\"';\n+        _writeString(text);\n+        // And finally, closing quotes\n+        if (_outputTail >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = '\"';\n+    }\n+\n+    @Override\n+    public void writeString(char[] text, int offset, int len)\n+        throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write text value\");\n+        if (_outputTail >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = '\"';\n+        _writeString(text, offset, len);\n+        // And finally, closing quotes\n+        if (_outputTail >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = '\"';\n+    }\n+\n+    @Override\n+    public final void writeString(SerializableString sstr)\n+        throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write text value\");\n+        if (_outputTail >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = '\"';\n+        // Note: copied from writeRaw:\n+        char[] text = sstr.asQuotedChars();\n+        final int len = text.length;\n+        // Only worth buffering if it's a short write?\n+        if (len < SHORT_WRITE) {\n+            int room = _outputEnd - _outputTail;\n+            if (len > room) {\n+                _flushBuffer();\n+            }\n+            System.arraycopy(text, 0, _outputBuffer, _outputTail, len);\n+            _outputTail += len;\n+        } else {\n+            // Otherwise, better just pass through:\n+            _flushBuffer();\n+            _writer.write(text, 0, len);\n+        }\n+        if (_outputTail >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = '\"';\n+    }\n+\n+    @Override\n+    public void writeRawUTF8String(byte[] text, int offset, int length)\n+        throws IOException, JsonGenerationException\n+    {\n+        // could add support for buffering if we really want it...\n+        _reportUnsupportedOperation();\n+    }\n+\n+    @Override\n+    public void writeUTF8String(byte[] text, int offset, int length)\n+        throws IOException, JsonGenerationException\n+    {\n+        // could add support for buffering if we really want it...\n+        _reportUnsupportedOperation();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Output method implementations, unprocessed (\"raw\")\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeRaw(String text)\n+        throws IOException, JsonGenerationException\n+    {\n+        // Nothing to check, can just output as is\n+        int len = text.length();\n+        int room = _outputEnd - _outputTail;\n+\n+        if (room == 0) {\n+            _flushBuffer();\n+            room = _outputEnd - _outputTail;\n+        }\n+        // But would it nicely fit in? If yes, it's easy\n+        if (room >= len) {\n+            text.getChars(0, len, _outputBuffer, _outputTail);\n+            _outputTail += len;\n+        } else {\n+            writeRawLong(text);\n+        }\n+    }\n+\n+    @Override\n+    public void writeRaw(String text, int start, int len)\n+        throws IOException, JsonGenerationException\n+    {\n+        // Nothing to check, can just output as is\n+        int room = _outputEnd - _outputTail;\n+\n+        if (room < len) {\n+            _flushBuffer();\n+            room = _outputEnd - _outputTail;\n+        }\n+        // But would it nicely fit in? If yes, it's easy\n+        if (room >= len) {\n+            text.getChars(start, start+len, _outputBuffer, _outputTail);\n+            _outputTail += len;\n+        } else {            \t\n+            writeRawLong(text.substring(start, start+len));\n+        }\n+    }\n+\n+    @Override\n+    public void writeRaw(char[] text, int offset, int len)\n+        throws IOException, JsonGenerationException\n+    {\n+        // Only worth buffering if it's a short write?\n+        if (len < SHORT_WRITE) {\n+            int room = _outputEnd - _outputTail;\n+            if (len > room) {\n+                _flushBuffer();\n+            }\n+            System.arraycopy(text, offset, _outputBuffer, _outputTail, len);\n+            _outputTail += len;\n+            return;\n+        }\n+        // Otherwise, better just pass through:\n+        _flushBuffer();\n+        _writer.write(text, offset, len);\n+    }\n+\n+    @Override\n+    public void writeRaw(char c)\n+        throws IOException, JsonGenerationException\n+    {\n+        if (_outputTail >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = c;\n+    }\n+\n+    private void writeRawLong(String text)\n+        throws IOException, JsonGenerationException\n+    {\n+        int room = _outputEnd - _outputTail;\n+        // If not, need to do it by looping\n+        text.getChars(0, room, _outputBuffer, _outputTail);\n+        _outputTail += room;\n+        _flushBuffer();\n+        int offset = room;\n+        int len = text.length() - room;\n+\n+        while (len > _outputEnd) {\n+            int amount = _outputEnd;\n+            text.getChars(offset, offset+amount, _outputBuffer, 0);\n+            _outputHead = 0;\n+            _outputTail = amount;\n+            _flushBuffer();\n+            offset += amount;\n+            len -= amount;\n+        }\n+        // And last piece (at most length of buffer)\n+        text.getChars(offset, offset+len, _outputBuffer, 0);\n+        _outputHead = 0;\n+        _outputTail = len;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Output method implementations, base64-encoded binary\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len)\n+        throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write binary value\");\n+        // Starting quotes\n+        if (_outputTail >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = '\"';\n+        _writeBinary(b64variant, data, offset, offset+len);\n+        // and closing quotes\n+        if (_outputTail >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = '\"';\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Output method implementations, primitive\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeNumber(int i)\n+        throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write number\");\n+        if (_cfgNumbersAsStrings) {\n+            _writeQuotedInt(i);\n+            return;\n+        }\n+        // up to 10 digits and possible minus sign\n+        if ((_outputTail + 11) >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);\n+    }\n+\n+    private final void _writeQuotedInt(int i) throws IOException {\n+        if ((_outputTail + 13) >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = '\"';\n+        _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);\n+        _outputBuffer[_outputTail++] = '\"';\n+    }    \n+\n+    @Override\n+    public void writeNumber(long l)\n+        throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write number\");\n+        if (_cfgNumbersAsStrings) {\n+            _writeQuotedLong(l);\n+            return;\n+        }\n+        if ((_outputTail + 21) >= _outputEnd) {\n+            // up to 20 digits, minus sign\n+            _flushBuffer();\n+        }\n+        _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);\n+    }\n+\n+    private final void _writeQuotedLong(long l) throws IOException {\n+        if ((_outputTail + 23) >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = '\"';\n+        _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail);\n+        _outputBuffer[_outputTail++] = '\"';\n+    }\n+\n+    // !!! 05-Aug-2008, tatus: Any ways to optimize these?\n+\n+    @Override\n+    public void writeNumber(BigInteger value)\n+        throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write number\");\n+        if (value == null) {\n+            _writeNull();\n+        } else if (_cfgNumbersAsStrings) {\n+            _writeQuotedRaw(value);\n+        } else {\n+            writeRaw(value.toString());\n+        }\n+    }\n+\n+    \n+    @Override\n+    public void writeNumber(double d)\n+        throws IOException, JsonGenerationException\n+    {\n+        if (_cfgNumbersAsStrings ||\n+            // [JACKSON-139]\n+            (((Double.isNaN(d) || Double.isInfinite(d))\n+                && isEnabled(Feature.QUOTE_NON_NUMERIC_NUMBERS)))) {\n+            writeString(String.valueOf(d));\n+            return;\n+        }\n+        // What is the max length for doubles? 40 chars?\n+        _verifyValueWrite(\"write number\");\n+        writeRaw(String.valueOf(d));\n+    }\n+\n+    @Override\n+    public void writeNumber(float f)\n+        throws IOException, JsonGenerationException\n+    {\n+        if (_cfgNumbersAsStrings ||\n+            // [JACKSON-139]\n+            (((Float.isNaN(f) || Float.isInfinite(f))\n+                && isEnabled(Feature.QUOTE_NON_NUMERIC_NUMBERS)))) {\n+            writeString(String.valueOf(f));\n+            return;\n+        }\n+        // What is the max length for floats?\n+        _verifyValueWrite(\"write number\");\n+        writeRaw(String.valueOf(f));\n+    }\n+\n+    @Override\n+    public void writeNumber(BigDecimal value)\n+        throws IOException, JsonGenerationException\n+    {\n+        // Don't really know max length for big decimal, no point checking\n+        _verifyValueWrite(\"write number\");\n+        if (value == null) {\n+            _writeNull();\n+        } else if (_cfgNumbersAsStrings) {\n+            _writeQuotedRaw(value);\n+        } else {\n+            writeRaw(value.toString());\n+        }\n+    }\n+\n+    @Override\n+    public void writeNumber(String encodedValue)\n+        throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write number\");\n+        if (_cfgNumbersAsStrings) {\n+            _writeQuotedRaw(encodedValue);            \n+        } else {\n+            writeRaw(encodedValue);\n+        }\n+    }\n+\n+    private final void _writeQuotedRaw(Object value) throws IOException\n+    {\n+        if (_outputTail >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = '\"';\n+        writeRaw(value.toString());\n+        if (_outputTail >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        _outputBuffer[_outputTail++] = '\"';\n+    }\n+    \n+    @Override\n+    public void writeBoolean(boolean state)\n+        throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write boolean value\");\n+        if ((_outputTail + 5) >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        int ptr = _outputTail;\n+        char[] buf = _outputBuffer;\n+        if (state) {\n+            buf[ptr] = 't';\n+            buf[++ptr] = 'r';\n+            buf[++ptr] = 'u';\n+            buf[++ptr] = 'e';\n+        } else {\n+            buf[ptr] = 'f';\n+            buf[++ptr] = 'a';\n+            buf[++ptr] = 'l';\n+            buf[++ptr] = 's';\n+            buf[++ptr] = 'e';\n+        }\n+        _outputTail = ptr+1;\n+    }\n+\n+    @Override\n+    public void writeNull()\n+        throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write null value\");\n+        _writeNull();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Implementations for other methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    protected final void _verifyValueWrite(String typeMsg)\n+        throws IOException, JsonGenerationException\n+    {\n+        int status = _writeContext.writeValue();\n+        if (status == JsonWriteContext.STATUS_EXPECT_NAME) {\n+            _reportError(\"Can not \"+typeMsg+\", expecting field name\");\n+        }\n+        if (_cfgPrettyPrinter == null) {\n+            char c;\n+            switch (status) {\n+            case JsonWriteContext.STATUS_OK_AFTER_COMMA:\n+                c = ',';\n+                break;\n+            case JsonWriteContext.STATUS_OK_AFTER_COLON:\n+                c = ':';\n+                break;\n+            case JsonWriteContext.STATUS_OK_AFTER_SPACE:\n+                c = ' ';\n+                break;\n+            case JsonWriteContext.STATUS_OK_AS_IS:\n+            default:\n+                return;\n+            }\n+            if (_outputTail >= _outputEnd) {\n+                _flushBuffer();\n+            }\n+            _outputBuffer[_outputTail] = c;\n+            ++_outputTail;\n+            return;\n+        }\n+        // Otherwise, pretty printer knows what to do...\n+        _verifyPrettyValueWrite(typeMsg, status);\n+    }\n+\n+    protected final void _verifyPrettyValueWrite(String typeMsg, int status)\n+        throws IOException, JsonGenerationException\n+    {\n+        // If we have a pretty printer, it knows what to do:\n+        switch (status) {\n+        case JsonWriteContext.STATUS_OK_AFTER_COMMA: // array\n+            _cfgPrettyPrinter.writeArrayValueSeparator(this);\n+            break;\n+        case JsonWriteContext.STATUS_OK_AFTER_COLON:\n+            _cfgPrettyPrinter.writeObjectFieldValueSeparator(this);\n+            break;\n+        case JsonWriteContext.STATUS_OK_AFTER_SPACE:\n+            _cfgPrettyPrinter.writeRootValueSeparator(this);\n+            break;\n+        case JsonWriteContext.STATUS_OK_AS_IS:\n+            // First entry, but of which context?\n+            if (_writeContext.inArray()) {\n+                _cfgPrettyPrinter.beforeArrayValues(this);\n+            } else if (_writeContext.inObject()) {\n+                _cfgPrettyPrinter.beforeObjectEntries(this);\n+            }\n+            break;\n+        default:\n+            _cantHappen();\n+            break;\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Low-level output handling\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public final void flush()\n+        throws IOException\n+    {\n+        _flushBuffer();\n+        if (_writer != null) {\n+            if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {\n+                _writer.flush();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void close()\n+        throws IOException\n+    {\n+        super.close();\n+\n+        /* 05-Dec-2008, tatu: To add [JACKSON-27], need to close open\n+         *   scopes.\n+         */\n+        // First: let's see that we still have buffers...\n+        if (_outputBuffer != null\n+            && isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) {\n+            while (true) {\n+                JsonStreamContext ctxt = getOutputContext();\n+                if (ctxt.inArray()) {\n+                    writeEndArray();\n+                } else if (ctxt.inObject()) {\n+                    writeEndObject();\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+        _flushBuffer();\n+\n+        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n+         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n+         *   feature is enabled.\n+         *   One downside: when using UTF8Writer, underlying buffer(s)\n+         *   may not be properly recycled if we don't close the writer.\n+         */\n+        if (_writer != null) {\n+            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) {\n+                _writer.close();\n+            } else  if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {\n+                // If we can't close it, we should at least flush\n+                _writer.flush();\n+            }\n+        }\n+        // Internal buffer(s) generator has can now be released as well\n+        _releaseBuffers();\n+    }\n+\n+    @Override\n+    protected void _releaseBuffers()\n+    {\n+        char[] buf = _outputBuffer;\n+        if (buf != null) {\n+            _outputBuffer = null;\n+            _ioContext.releaseConcatBuffer(buf);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods, low-level writing; text, default\n+    /**********************************************************\n+     */\n+\n+    private void _writeString(String text)\n+        throws IOException, JsonGenerationException\n+    {\n+        /* One check first: if String won't fit in the buffer, let's\n+         * segment writes. No point in extending buffer to huge sizes\n+         * (like if someone wants to include multi-megabyte base64\n+         * encoded stuff or such)\n+         */\n+        final int len = text.length();\n+        if (len > _outputEnd) { // Let's reserve space for entity at begin/end\n+            _writeLongString(text);\n+            return;\n+        }\n+\n+        // Ok: we know String will fit in buffer ok\n+        // But do we need to flush first?\n+        if ((_outputTail + len) > _outputEnd) {\n+            _flushBuffer();\n+        }\n+        text.getChars(0, len, _outputBuffer, _outputTail);\n+\n+        if (_characterEscapes != null) {\n+            _writeStringCustom(len);\n+        } else if (_maximumNonEscapedChar != 0) {\n+            _writeStringASCII(len, _maximumNonEscapedChar);\n+        } else {\n+            _writeString2(len);\n+        }\n+    }\n+\n+    private void _writeString2(final int len)\n+        throws IOException, JsonGenerationException\n+    {\n+        // And then we'll need to verify need for escaping etc:\n+        int end = _outputTail + len;\n+        final int[] escCodes = _outputEscapes;\n+        final int escLen = escCodes.length;\n+\n+        output_loop:\n+        while (_outputTail < end) {\n+            // Fast loop for chars not needing escaping\n+            escape_loop:\n+            while (true) {\n+                char c = _outputBuffer[_outputTail];\n+                if (c < escLen && escCodes[c] != 0) {\n+                    break escape_loop;\n+                }\n+                if (++_outputTail >= end) {\n+                    break output_loop;\n+                }\n+            }\n+\n+            // Ok, bumped into something that needs escaping.\n+            /* First things first: need to flush the buffer.\n+             * Inlined, as we don't want to lose tail pointer\n+             */\n+            int flushLen = (_outputTail - _outputHead);\n+            if (flushLen > 0) {\n+                _writer.write(_outputBuffer, _outputHead, flushLen);\n+            }\n+            /* In any case, tail will be the new start, so hopefully\n+             * we have room now.\n+             */\n+            char c = _outputBuffer[_outputTail++];\n+            _prependOrWriteCharacterEscape(c, escCodes[c]);\n+        }\n+    }\n+\n+    /**\n+     * Method called to write \"long strings\", strings whose length exceeds\n+     * output buffer length.\n+     */\n+    private void _writeLongString(String text)\n+        throws IOException, JsonGenerationException\n+    {\n+        // First things first: let's flush the buffer to get some more room\n+        _flushBuffer();\n+\n+        // Then we can write \n+        final int textLen = text.length();\n+        int offset = 0;\n+        do {\n+            int max = _outputEnd;\n+            int segmentLen = ((offset + max) > textLen)\n+                ? (textLen - offset) : max;\n+            text.getChars(offset, offset+segmentLen, _outputBuffer, 0);\n+            if (_characterEscapes != null) {\n+                _writeSegmentCustom(segmentLen);\n+            } else if (_maximumNonEscapedChar != 0) {\n+                _writeSegmentASCII(segmentLen, _maximumNonEscapedChar);\n+            } else {\n+                _writeSegment(segmentLen);\n+            }\n+            offset += segmentLen;\n+        } while (offset < textLen);\n+    }\n+\n+    /**\n+     * Method called to output textual context which has been copied\n+     * to the output buffer prior to call. If any escaping is needed,\n+     * it will also be handled by the method.\n+     *<p>\n+     * Note: when called, textual content to write is within output\n+     * buffer, right after buffered content (if any). That's why only\n+     * length of that text is passed, as buffer and offset are implied.\n+     */\n+    private final void _writeSegment(int end)\n+        throws IOException, JsonGenerationException\n+    {\n+        final int[] escCodes = _outputEscapes;\n+        final int escLen = escCodes.length;\n+    \n+        int ptr = 0;\n+        int start = ptr;\n+\n+        output_loop:\n+        while (ptr < end) {\n+            // Fast loop for chars not needing escaping\n+            char c;\n+            while (true) {\n+                c = _outputBuffer[ptr];\n+                if (c < escLen && escCodes[c] != 0) {\n+                    break;\n+                }\n+                if (++ptr >= end) {\n+                    break;\n+                }\n+            }\n+\n+            // Ok, bumped into something that needs escaping.\n+            /* First things first: need to flush the buffer.\n+             * Inlined, as we don't want to lose tail pointer\n+             */\n+            int flushLen = (ptr - start);\n+            if (flushLen > 0) {\n+                _writer.write(_outputBuffer, start, flushLen);\n+                if (ptr >= end) {\n+                    break output_loop;\n+                }\n+            }\n+            ++ptr;\n+            // So; either try to prepend (most likely), or write directly:\n+            start = _prependOrWriteCharacterEscape(_outputBuffer, ptr, end, c, escCodes[c]);\n+        }\n+    }\n+    \n+    /**\n+     * This method called when the string content is already in\n+     * a char buffer, and need not be copied for processing.\n+     */\n+    private final void _writeString(char[] text, int offset, int len)\n+        throws IOException, JsonGenerationException\n+    {\n+        if (_characterEscapes != null) {\n+            _writeStringCustom(text, offset, len);\n+            return;\n+        }\n+        if (_maximumNonEscapedChar != 0) {\n+            _writeStringASCII(text, offset, len, _maximumNonEscapedChar);\n+            return;\n+        }\n+        \n+        /* Let's just find longest spans of non-escapable\n+         * content, and for each see if it makes sense\n+         * to copy them, or write through\n+         */\n+        len += offset; // -> len marks the end from now on\n+        final int[] escCodes = _outputEscapes;\n+        final int escLen = escCodes.length;\n+        while (offset < len) {\n+            int start = offset;\n+\n+            while (true) {\n+                char c = text[offset];\n+                if (c < escLen && escCodes[c] != 0) {\n+                    break;\n+                }\n+                if (++offset >= len) {\n+                    break;\n+                }\n+            }\n+\n+            // Short span? Better just copy it to buffer first:\n+            int newAmount = offset - start;\n+            if (newAmount < SHORT_WRITE) {\n+                // Note: let's reserve room for escaped char (up to 6 chars)\n+                if ((_outputTail + newAmount) > _outputEnd) {\n+                    _flushBuffer();\n+                }\n+                if (newAmount > 0) {\n+                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n+                    _outputTail += newAmount;\n+                }\n+            } else { // Nope: better just write through\n+                _flushBuffer();\n+                _writer.write(text, start, newAmount);\n+            }\n+            // Was this the end?\n+            if (offset >= len) { // yup\n+                break;\n+            }\n+            // Nope, need to escape the char.\n+            char c = text[offset++];\n+            _appendCharacterEscape(c, escCodes[c]);          \n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods, low-level writing, text segment\n+    /* with additional escaping (ASCII or such)\n+    /* (since 1.8; see [JACKSON-102])\n+    /**********************************************************\n+     */\n+\n+    /* Same as \"_writeString2()\", except needs additional escaping\n+     * for subset of characters\n+     */\n+    private void _writeStringASCII(final int len, final int maxNonEscaped)\n+        throws IOException, JsonGenerationException\n+    {\n+        // And then we'll need to verify need for escaping etc:\n+        int end = _outputTail + len;\n+        final int[] escCodes = _outputEscapes;\n+        final int escLimit = Math.min(escCodes.length, _maximumNonEscapedChar+1);\n+        int escCode = 0;\n+        \n+        output_loop:\n+        while (_outputTail < end) {\n+            char c;\n+            // Fast loop for chars not needing escaping\n+            escape_loop:\n+            while (true) {\n+                c = _outputBuffer[_outputTail];\n+                if (c < escLimit) {\n+                    escCode = escCodes[c];\n+                    if (escCode != 0) {\n+                        break escape_loop;\n+                    }\n+                } else if (c > maxNonEscaped) {\n+                    escCode = CharacterEscapes.ESCAPE_STANDARD;\n+                    break escape_loop;\n+                }\n+                if (++_outputTail >= end) {\n+                    break output_loop;\n+                }\n+            }\n+            int flushLen = (_outputTail - _outputHead);\n+            if (flushLen > 0) {\n+                _writer.write(_outputBuffer, _outputHead, flushLen);\n+            }\n+            ++_outputTail;\n+            _prependOrWriteCharacterEscape(c, escCode);\n+        }\n+    }\n+\n+    private final void _writeSegmentASCII(int end, final int maxNonEscaped)\n+        throws IOException, JsonGenerationException\n+    {\n+        final int[] escCodes = _outputEscapes;\n+        final int escLimit = Math.min(escCodes.length, _maximumNonEscapedChar+1);\n+    \n+        int ptr = 0;\n+        int escCode = 0;\n+        int start = ptr;\n+    \n+        output_loop:\n+        while (ptr < end) {\n+            // Fast loop for chars not needing escaping\n+            char c;\n+            while (true) {\n+                c = _outputBuffer[ptr];\n+                if (c < escLimit) {\n+                    escCode = escCodes[c];\n+                    if (escCode != 0) {\n+                        break;\n+                    }\n+                } else if (c > maxNonEscaped) {\n+                    escCode = CharacterEscapes.ESCAPE_STANDARD;\n+                    break;\n+                }\n+                if (++ptr >= end) {\n+                    break;\n+                }\n+            }\n+            int flushLen = (ptr - start);\n+            if (flushLen > 0) {\n+                _writer.write(_outputBuffer, start, flushLen);\n+                if (ptr >= end) {\n+                    break output_loop;\n+                }\n+            }\n+            ++ptr;\n+            start = _prependOrWriteCharacterEscape(_outputBuffer, ptr, end, c, escCode);\n+        }\n+    }\n+\n+    private final void _writeStringASCII(char[] text, int offset, int len,\n+            final int maxNonEscaped)\n+        throws IOException, JsonGenerationException\n+    {\n+        len += offset; // -> len marks the end from now on\n+        final int[] escCodes = _outputEscapes;\n+        final int escLimit = Math.min(escCodes.length, maxNonEscaped+1);\n+\n+        int escCode = 0;\n+        \n+        while (offset < len) {\n+            int start = offset;\n+            char c;\n+            \n+            while (true) {\n+                c = text[offset];\n+                if (c < escLimit) {\n+                    escCode = escCodes[c];\n+                    if (escCode != 0) {\n+                        break;\n+                    }\n+                } else if (c > maxNonEscaped) {\n+                    escCode = CharacterEscapes.ESCAPE_STANDARD;\n+                    break;\n+                }\n+                if (++offset >= len) {\n+                    break;\n+                }\n+            }\n+\n+            // Short span? Better just copy it to buffer first:\n+            int newAmount = offset - start;\n+            if (newAmount < SHORT_WRITE) {\n+                // Note: let's reserve room for escaped char (up to 6 chars)\n+                if ((_outputTail + newAmount) > _outputEnd) {\n+                    _flushBuffer();\n+                }\n+                if (newAmount > 0) {\n+                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n+                    _outputTail += newAmount;\n+                }\n+            } else { // Nope: better just write through\n+                _flushBuffer();\n+                _writer.write(text, start, newAmount);\n+            }\n+            // Was this the end?\n+            if (offset >= len) { // yup\n+                break;\n+            }\n+            // Nope, need to escape the char.\n+            ++offset;\n+            _appendCharacterEscape(c, escCode);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods, low-level writing, text segment\n+    /* with custom escaping (possibly coupling with ASCII limits)\n+    /* (since 1.8; see [JACKSON-106])\n+    /**********************************************************\n+     */\n+\n+    /* Same as \"_writeString2()\", except needs additional escaping\n+     * for subset of characters\n+     */\n+    private void _writeStringCustom(final int len)\n+        throws IOException, JsonGenerationException\n+    {\n+        // And then we'll need to verify need for escaping etc:\n+        int end = _outputTail + len;\n+        final int[] escCodes = _outputEscapes;\n+        final int maxNonEscaped = (_maximumNonEscapedChar < 1) ? 0xFFFF : _maximumNonEscapedChar;\n+        final int escLimit = Math.min(escCodes.length, maxNonEscaped+1);\n+        int escCode = 0;\n+        final CharacterEscapes customEscapes = _characterEscapes;\n+\n+        output_loop:\n+        while (_outputTail < end) {\n+            char c;\n+            // Fast loop for chars not needing escaping\n+            escape_loop:\n+            while (true) {\n+                c = _outputBuffer[_outputTail];\n+                if (c < escLimit) {\n+                    escCode = escCodes[c];\n+                    if (escCode != 0) {\n+                        break escape_loop;\n+                    }\n+                } else if (c > maxNonEscaped) {\n+                    escCode = CharacterEscapes.ESCAPE_STANDARD;\n+                    break escape_loop;\n+                } else {\n+                    if ((_currentEscape = customEscapes.getEscapeSequence(c)) != null) {\n+                        escCode = CharacterEscapes.ESCAPE_CUSTOM;\n+                        break escape_loop;\n+                    }\n+                }\n+                if (++_outputTail >= end) {\n+                    break output_loop;\n+                }\n+            }\n+            int flushLen = (_outputTail - _outputHead);\n+            if (flushLen > 0) {\n+                _writer.write(_outputBuffer, _outputHead, flushLen);\n+            }\n+            ++_outputTail;\n+            _prependOrWriteCharacterEscape(c, escCode);\n+        }\n+    }\n+\n+    private final void _writeSegmentCustom(int end)\n+        throws IOException, JsonGenerationException\n+    {\n+        final int[] escCodes = _outputEscapes;\n+        final int maxNonEscaped = (_maximumNonEscapedChar < 1) ? 0xFFFF : _maximumNonEscapedChar;\n+        final int escLimit = Math.min(escCodes.length, _maximumNonEscapedChar+1);\n+        final CharacterEscapes customEscapes = _characterEscapes;\n+    \n+        int ptr = 0;\n+        int escCode = 0;\n+        int start = ptr;\n+    \n+        output_loop:\n+        while (ptr < end) {\n+            // Fast loop for chars not needing escaping\n+            char c;\n+            while (true) {\n+                c = _outputBuffer[ptr];\n+                if (c < escLimit) {\n+                    escCode = escCodes[c];\n+                    if (escCode != 0) {\n+                        break;\n+                    }\n+                } else if (c > maxNonEscaped) {\n+                    escCode = CharacterEscapes.ESCAPE_STANDARD;\n+                    break;\n+                } else {\n+                    if ((_currentEscape = customEscapes.getEscapeSequence(c)) != null) {\n+                        escCode = CharacterEscapes.ESCAPE_CUSTOM;\n+                        break;\n+                    }\n+                }\n+                if (++ptr >= end) {\n+                    break;\n+                }\n+            }\n+            int flushLen = (ptr - start);\n+            if (flushLen > 0) {\n+                _writer.write(_outputBuffer, start, flushLen);\n+                if (ptr >= end) {\n+                    break output_loop;\n+                }\n+            }\n+            ++ptr;\n+            start = _prependOrWriteCharacterEscape(_outputBuffer, ptr, end, c, escCode);\n+        }\n+    }\n+\n+    private final void _writeStringCustom(char[] text, int offset, int len)\n+        throws IOException, JsonGenerationException\n+    {\n+        len += offset; // -> len marks the end from now on\n+        final int[] escCodes = _outputEscapes;\n+        final int maxNonEscaped = (_maximumNonEscapedChar < 1) ? 0xFFFF : _maximumNonEscapedChar;\n+        final int escLimit = Math.min(escCodes.length, maxNonEscaped+1);\n+        final CharacterEscapes customEscapes = _characterEscapes;\n+\n+        int escCode = 0;\n+        \n+        while (offset < len) {\n+            int start = offset;\n+            char c;\n+            \n+            while (true) {\n+                c = text[offset];\n+                if (c < escLimit) {\n+                    escCode = escCodes[c];\n+                    if (escCode != 0) {\n+                        break;\n+                    }\n+                } else if (c > maxNonEscaped) {\n+                    escCode = CharacterEscapes.ESCAPE_STANDARD;\n+                    break;\n+                } else {\n+                    if ((_currentEscape = customEscapes.getEscapeSequence(c)) != null) {\n+                        escCode = CharacterEscapes.ESCAPE_CUSTOM;\n+                        break;\n+                    }\n+                }\n+                if (++offset >= len) {\n+                    break;\n+                }\n+            }\n+    \n+            // Short span? Better just copy it to buffer first:\n+            int newAmount = offset - start;\n+            if (newAmount < SHORT_WRITE) {\n+                // Note: let's reserve room for escaped char (up to 6 chars)\n+                if ((_outputTail + newAmount) > _outputEnd) {\n+                    _flushBuffer();\n+                }\n+                if (newAmount > 0) {\n+                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);\n+                    _outputTail += newAmount;\n+                }\n+            } else { // Nope: better just write through\n+                _flushBuffer();\n+                _writer.write(text, start, newAmount);\n+            }\n+            // Was this the end?\n+            if (offset >= len) { // yup\n+                break;\n+            }\n+            // Nope, need to escape the char.\n+            ++offset;\n+            _appendCharacterEscape(c, escCode);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Internal methods, low-level writing; binary\n+    /**********************************************************\n+     */\n+    \n+    protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd)\n+        throws IOException, JsonGenerationException\n+    {\n+        // Encoding is by chunks of 3 input, 4 output chars, so:\n+        int safeInputEnd = inputEnd - 3;\n+        // Let's also reserve room for possible (and quoted) lf char each round\n+        int safeOutputEnd = _outputEnd - 6;\n+        int chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n+\n+        // Ok, first we loop through all full triplets of data:\n+        while (inputPtr <= safeInputEnd) {\n+            if (_outputTail > safeOutputEnd) { // need to flush\n+                _flushBuffer();\n+            }\n+            // First, mash 3 bytes into lsb of 32-bit int\n+            int b24 = ((int) input[inputPtr++]) << 8;\n+            b24 |= ((int) input[inputPtr++]) & 0xFF;\n+            b24 = (b24 << 8) | (((int) input[inputPtr++]) & 0xFF);\n+            _outputTail = b64variant.encodeBase64Chunk(b24, _outputBuffer, _outputTail);\n+            if (--chunksBeforeLF <= 0) {\n+                // note: must quote in JSON value\n+                _outputBuffer[_outputTail++] = '\\\\';\n+                _outputBuffer[_outputTail++] = 'n';\n+                chunksBeforeLF = b64variant.getMaxLineLength() >> 2;\n+            }\n+        }\n+\n+        // And then we may have 1 or 2 leftover bytes to encode\n+        int inputLeft = inputEnd - inputPtr; // 0, 1 or 2\n+        if (inputLeft > 0) { // yes, but do we have room for output?\n+            if (_outputTail > safeOutputEnd) { // don't really need 6 bytes but...\n+                _flushBuffer();\n+            }\n+            int b24 = ((int) input[inputPtr++]) << 16;\n+            if (inputLeft == 2) {\n+                b24 |= (((int) input[inputPtr++]) & 0xFF) << 8;\n+            }\n+            _outputTail = b64variant.encodeBase64Partial(b24, inputLeft, _outputBuffer, _outputTail);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods, low-level writing, other\n+    /**********************************************************\n+     */\n+    \n+    private final void _writeNull() throws IOException\n+    {\n+        if ((_outputTail + 4) >= _outputEnd) {\n+            _flushBuffer();\n+        }\n+        int ptr = _outputTail;\n+        char[] buf = _outputBuffer;\n+        buf[ptr] = 'n';\n+        buf[++ptr] = 'u';\n+        buf[++ptr] = 'l';\n+        buf[++ptr] = 'l';\n+        _outputTail = ptr+1;\n+    }\n+        \n+    /*\n+    /**********************************************************\n+    /* Internal methods, low-level writing, escapes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to try to either prepend character escape at front of\n+     * given buffer; or if not possible, to write it out directly.\n+     * Uses head and tail pointers (and updates as necessary)\n+     */\n+    private final void _prependOrWriteCharacterEscape(char ch, int escCode)\n+        throws IOException, JsonGenerationException\n+    {\n+        if (escCode >= 0) { // \\\\N (2 char)\n+            if (_outputTail >= 2) { // fits, just prepend\n+                int ptr = _outputTail - 2;\n+                _outputHead = ptr;\n+                _outputBuffer[ptr++] = '\\\\';\n+                _outputBuffer[ptr] = (char) escCode;\n+                return;\n+            }\n+            // won't fit, write\n+            char[] buf = _entityBuffer;\n+            if (buf == null) {\n+                buf = _allocateEntityBuffer();\n+            }\n+            _outputHead = _outputTail;\n+            buf[1] = (char) escCode;\n+            _writer.write(buf, 0, 2);\n+            return;\n+        }\n+        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n+            if (_outputTail >= 6) { // fits, prepend to buffer\n+                char[] buf = _outputBuffer;\n+                int ptr = _outputTail - 6;\n+                _outputHead = ptr;\n+                buf[ptr] = '\\\\';\n+                buf[++ptr] = 'u';\n+                // We know it's a control char, so only the last 2 chars are non-0\n+                if (ch > 0xFF) { // beyond 8 bytes\n+                    int hi = (ch >> 8) & 0xFF;\n+                    buf[++ptr] = HEX_CHARS[hi >> 4];\n+                    buf[++ptr] = HEX_CHARS[hi & 0xF];\n+                    ch &= 0xFF;\n+                } else {\n+                    buf[++ptr] = '0';\n+                    buf[++ptr] = '0';\n+                }\n+                buf[++ptr] = HEX_CHARS[ch >> 4];\n+                buf[++ptr] = HEX_CHARS[ch & 0xF];\n+                return;\n+            }\n+            // won't fit, flush and write\n+            char[] buf = _entityBuffer;\n+            if (buf == null) {\n+                buf = _allocateEntityBuffer();\n+            }\n+            _outputHead = _outputTail;\n+            if (ch > 0xFF) { // beyond 8 bytes\n+                int hi = (ch >> 8) & 0xFF;\n+                int lo = ch & 0xFF;\n+                buf[10] = HEX_CHARS[hi >> 4];\n+                buf[11] = HEX_CHARS[hi & 0xF];\n+                buf[12] = HEX_CHARS[lo >> 4];\n+                buf[13] = HEX_CHARS[lo & 0xF];\n+                _writer.write(buf, 8, 6);\n+            } else { // We know it's a control char, so only the last 2 chars are non-0\n+                buf[6] = HEX_CHARS[ch >> 4];\n+                buf[7] = HEX_CHARS[ch & 0xF];\n+                _writer.write(buf, 2, 6);\n+            }\n+            return;\n+        }\n+        String escape;\n+\n+        if (_currentEscape == null) {\n+            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n+        } else {\n+            escape = _currentEscape.getValue();\n+            _currentEscape = null;\n+        }\n+        int len = escape.length();\n+        if (_outputTail >= len) { // fits in, prepend\n+            int ptr = _outputTail - len;\n+            _outputHead = ptr;\n+            escape.getChars(0, len, _outputBuffer, ptr);\n+            return;\n+        }\n+        // won't fit, write separately\n+        _outputHead = _outputTail;\n+        _writer.write(escape);\n+    }\n+\n+    /**\n+     * Method called to try to either prepend character escape at front of\n+     * given buffer; or if not possible, to write it out directly.\n+     * \n+     * @return Pointer to start of prepended entity (if prepended); or 'ptr'\n+     *   if not.\n+     */\n+    private final int _prependOrWriteCharacterEscape(char[] buffer, int ptr, int end,\n+            char ch, int escCode)\n+        throws IOException, JsonGenerationException\n+    {\n+        if (escCode >= 0) { // \\\\N (2 char)\n+            if (ptr > 1 && ptr < end) { // fits, just prepend\n+                ptr -= 2;\n+                buffer[ptr] = '\\\\';\n+                buffer[ptr+1] = (char) escCode;\n+            } else { // won't fit, write\n+                char[] ent = _entityBuffer;\n+                if (ent == null) {\n+                    ent = _allocateEntityBuffer();\n+                }\n+                ent[1] = (char) escCode;\n+                _writer.write(ent, 0, 2);\n+            }\n+            return ptr;\n+        }\n+        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n+            if (ptr > 5 && ptr < end) { // fits, prepend to buffer\n+                ptr -= 6;\n+                buffer[ptr++] = '\\\\';\n+                buffer[ptr++] = 'u';\n+                // We know it's a control char, so only the last 2 chars are non-0\n+                if (ch > 0xFF) { // beyond 8 bytes\n+                    int hi = (ch >> 8) & 0xFF;\n+                    buffer[ptr++] = HEX_CHARS[hi >> 4];\n+                    buffer[ptr++] = HEX_CHARS[hi & 0xF];\n+                    ch &= 0xFF;\n+                } else {\n+                    buffer[ptr++] = '0';\n+                    buffer[ptr++] = '0';\n+                }\n+                buffer[ptr++] = HEX_CHARS[ch >> 4];\n+                buffer[ptr] = HEX_CHARS[ch & 0xF];\n+                ptr -= 5;\n+            } else {\n+                // won't fit, flush and write\n+                char[] ent = _entityBuffer;\n+                if (ent == null) {\n+                    ent = _allocateEntityBuffer();\n+                }\n+                _outputHead = _outputTail;\n+                if (ch > 0xFF) { // beyond 8 bytes\n+                    int hi = (ch >> 8) & 0xFF;\n+                    int lo = ch & 0xFF;\n+                    ent[10] = HEX_CHARS[hi >> 4];\n+                    ent[11] = HEX_CHARS[hi & 0xF];\n+                    ent[12] = HEX_CHARS[lo >> 4];\n+                    ent[13] = HEX_CHARS[lo & 0xF];\n+                    _writer.write(ent, 8, 6);\n+                } else { // We know it's a control char, so only the last 2 chars are non-0\n+                    ent[6] = HEX_CHARS[ch >> 4];\n+                    ent[7] = HEX_CHARS[ch & 0xF];\n+                    _writer.write(ent, 2, 6);\n+                }\n+            }\n+            return ptr;\n+        }\n+        String escape;\n+        if (_currentEscape == null) {\n+            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n+        } else {\n+            escape = _currentEscape.getValue();\n+            _currentEscape = null;\n+        }\n+        int len = escape.length();\n+        if (ptr >= len && ptr < end) { // fits in, prepend\n+            ptr -= len;\n+            escape.getChars(0, len, buffer, ptr);\n+        } else { // won't fit, write separately\n+            _writer.write(escape);\n+        }\n+        return ptr;\n+    }\n+\n+    /**\n+     * Method called to append escape sequence for given character, at the\n+     * end of standard output buffer; or if not possible, write out directly.\n+     */\n+    private final void _appendCharacterEscape(char ch, int escCode)\n+        throws IOException, JsonGenerationException\n+    {\n+        if (escCode >= 0) { // \\\\N (2 char)\n+            if ((_outputTail + 2) > _outputEnd) {\n+                _flushBuffer();\n+            }\n+            _outputBuffer[_outputTail++] = '\\\\';\n+            _outputBuffer[_outputTail++] = (char) escCode;\n+            return;\n+        }\n+        if (escCode != CharacterEscapes.ESCAPE_CUSTOM) { // std, \\\\uXXXX\n+            if ((_outputTail + 2) > _outputEnd) {\n+                _flushBuffer();\n+            }\n+            int ptr = _outputTail;\n+            char[] buf = _outputBuffer;\n+            buf[ptr++] = '\\\\';\n+            buf[ptr++] = 'u';\n+            // We know it's a control char, so only the last 2 chars are non-0\n+            if (ch > 0xFF) { // beyond 8 bytes\n+                int hi = (ch >> 8) & 0xFF;\n+                buf[ptr++] = HEX_CHARS[hi >> 4];\n+                buf[ptr++] = HEX_CHARS[hi & 0xF];\n+                ch &= 0xFF;\n+            } else {\n+                buf[ptr++] = '0';\n+                buf[ptr++] = '0';\n+            }\n+            buf[ptr++] = HEX_CHARS[ch >> 4];\n+            buf[ptr] = HEX_CHARS[ch & 0xF];\n+            _outputTail = ptr;\n+            return;\n+        }\n+        String escape;\n+        if (_currentEscape == null) {\n+            escape = _characterEscapes.getEscapeSequence(ch).getValue();\n+        } else {\n+            escape = _currentEscape.getValue();\n+            _currentEscape = null;\n+        }\n+        int len = escape.length();\n+        if ((_outputTail + len) > _outputEnd) {\n+            _flushBuffer();\n+            if (len > _outputEnd) { // very very long escape; unlikely but theoretically possible\n+                _writer.write(escape);\n+                return;\n+            }\n+        }\n+        escape.getChars(0, len, _outputBuffer, _outputTail);\n+        _outputTail += len;\n+    }\n+    \n+    private char[] _allocateEntityBuffer()\n+    {\n+        char[] buf = new char[14];\n+        // first 2 chars, non-numeric escapes (like \\n)\n+        buf[0] = '\\\\';\n+        // next 6; 8-bit escapes (control chars mostly)\n+        buf[2] = '\\\\';\n+        buf[3] = 'u';\n+        buf[4] = '0';\n+        buf[5] = '0';\n+        // last 6, beyond 8 bits\n+        buf[8] = '\\\\';\n+        buf[9] = 'u';\n+        _entityBuffer = buf;\n+        return buf;\n+    }\n+    \n+    protected final void _flushBuffer() throws IOException\n+    {\n+        int len = _outputTail - _outputHead;\n+        if (len > 0) {\n+            int offset = _outputHead;\n+            _outputTail = _outputHead = 0;\n+            _writer.write(_outputBuffer, offset, len);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/json/package-info.java\n+/**\n+ * JSON-specific parser and generator implementation classes that\n+ * Jackson defines and uses.\n+ * Application code should not (need to) use contents of this package;\n+ * nor are these implementations likely to be of use for sub-classing.\n+ */\n+package com.fasterxml.jackson.core.json;\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/package-info.java\n+/**\n+ * Main public API classes of the core streaming JSON\n+ * processor: most importantly {@link com.fasterxml.jackson.core.JsonFactory}\n+ * used for constructing\n+ * JSON parser ({@link com.fasterxml.jackson.core.JsonParser})\n+ * and generator\n+ * ({@link com.fasterxml.jackson.core.JsonParser})\n+ * instances.\n+ * <p>\n+ * Public API of the higher-level mapping interfaces (\"Mapping API\")\n+ * is found from\n+ * under {@link org.codehaus.jackson.map} and not included here,\n+ * except for following base interfaces:\n+ * <ul>\n+ *<li>{@link com.fasterxml.jackson.core.JsonNode} is included\n+ *within Streaming API to support integration of the Tree Model\n+ *(which is based on <code>JsonNode</code>) with the basic\n+ *parsers and generators (iff using mapping-supporting factory: which\n+ *is part of Mapping API, not core)\n+ *  </li>\n+ *<li>{@link com.fasterxml.jackson.core.ObjectCodec} is included so that\n+ *  reference to the object capable of serializing/deserializing\n+ *  Objects to/from JSON (usually, {@link org.codehaus.jackson.map.ObjectMapper})\n+ *  can be exposed, without adding direct dependency to implementation.\n+ *  </li>\n+ *</ul>\n+ * </ul>\n+ */\n+\n+package com.fasterxml.jackson.core;\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n+package com.fasterxml.jackson.core.sym;\n+\n+import java.util.Arrays;\n+\n+import com.fasterxml.jackson.core.util.InternCache;\n+\n+/**\n+ * This class is basically a caching symbol table implementation used for\n+ * canonicalizing {@link Name}s, constructed directly from a byte-based\n+ * input source.\n+ *\n+ * @author Tatu Saloranta\n+ */\n+public final class BytesToNameCanonicalizer\n+{\n+    protected static final int DEFAULT_TABLE_SIZE = 64;\n+\n+    /**\n+     * Let's not expand symbol tables past some maximum size;\n+     * this should protected against OOMEs caused by large documents\n+     * with uniquer (~= random) names.\n+     * \n+     * @since 1.5\n+     */\n+    protected static final int MAX_TABLE_SIZE = 0x10000; // 64k entries == 256k mem\n+    \n+    /**\n+     * Let's only share reasonably sized symbol tables. Max size set to 3/4 of 16k;\n+     * this corresponds to 64k main hash index. This should allow for enough distinct\n+     * names for almost any case.\n+     */\n+    final static int MAX_ENTRIES_FOR_REUSE = 6000;\n+\n+    final static int MIN_HASH_SIZE = 16;\n+\n+    final static int INITIAL_COLLISION_LEN = 32;\n+\n+    /**\n+     * Bucket index is 8 bits, and value 0 is reserved to represent\n+     * 'empty' status.\n+     */\n+    final static int LAST_VALID_BUCKET = 0xFE;\n+    \n+    /*\n+    /**********************************************************\n+    /* Linkage, needed for merging symbol tables\n+    /**********************************************************\n+     */\n+\n+    final BytesToNameCanonicalizer _parent;\n+\n+    /*\n+    /**********************************************************\n+    /* Main table state\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Whether canonial symbol Strings are to be intern()ed before added\n+     * to the table or not\n+     */\n+    final boolean _intern;\n+    \n+    // // // First, global information\n+\n+    /**\n+     * Total number of Names in the symbol table\n+     */\n+    private int _count;\n+\n+    // // // Then information regarding primary hash array and its\n+    // // // matching Name array\n+\n+    /**\n+     * Mask used to truncate 32-bit hash value to current hash array\n+     * size; essentially, hash array size - 1 (since hash array sizes\n+     * are 2^N).\n+     */\n+    private int _mainHashMask;\n+\n+    /**\n+     * Array of 2^N size, which contains combination\n+     * of 24-bits of hash (0 to indicate 'empty' slot),\n+     * and 8-bit collision bucket index (0 to indicate empty\n+     * collision bucket chain; otherwise subtract one from index)\n+     */\n+    private int[] _mainHash;\n+\n+    /**\n+     * Array that contains <code>Name</code> instances matching\n+     * entries in <code>_mainHash</code>. Contains nulls for unused\n+     * entries.\n+     */\n+    private Name[] _mainNames;\n+\n+    // // // Then the collision/spill-over area info\n+\n+    /**\n+     * Array of heads of collision bucket chains; size dynamically\n+     */\n+    private Bucket[] _collList;\n+\n+    /**\n+     * Total number of Names in collision buckets (included in\n+     * <code>_count</code> along with primary entries)\n+     */\n+    private int _collCount;\n+\n+    /**\n+     * Index of the first unused collision bucket entry (== size of\n+     * the used portion of collision list): less than\n+     * or equal to 0xFF (255), since max number of entries is 255\n+     * (8-bit, minus 0 used as 'empty' marker)\n+     */\n+    private int _collEnd;\n+\n+    // // // Info regarding pending rehashing...\n+\n+    /**\n+     * This flag is set if, after adding a new entry, it is deemed\n+     * that a rehash is warranted if any more entries are to be added.\n+     */\n+    private transient boolean _needRehash;\n+\n+    /*\n+    /**********************************************************\n+    /* Sharing, versioning\n+    /**********************************************************\n+     */\n+\n+    // // // Which of the buffers may be shared (and are copy-on-write)?\n+\n+    /**\n+     * Flag that indicates whether underlying data structures for\n+     * the main hash area are shared or not. If they are, then they\n+     * need to be handled in copy-on-write way, i.e. if they need\n+     * to be modified, a copy needs to be made first; at this point\n+     * it will not be shared any more, and can be modified.\n+     *<p>\n+     * This flag needs to be checked both when adding new main entries,\n+     * and when adding new collision list queues (i.e. creating a new\n+     * collision list head entry)\n+     */\n+    private boolean _mainHashShared;\n+\n+    private boolean _mainNamesShared;\n+\n+    /**\n+     * Flag that indicates whether underlying data structures for\n+     * the collision list are shared or not. If they are, then they\n+     * need to be handled in copy-on-write way, i.e. if they need\n+     * to be modified, a copy needs to be made first; at this point\n+     * it will not be shared any more, and can be modified.\n+     *<p>\n+     * This flag needs to be checked when adding new collision entries.\n+     */\n+    private boolean _collListShared;\n+\n+    /*\n+    /**********************************************************\n+    /* Construction, merging\n+    /**********************************************************\n+     */\n+\n+    public static BytesToNameCanonicalizer createRoot()\n+    {\n+        return new BytesToNameCanonicalizer(DEFAULT_TABLE_SIZE, true);\n+    }\n+\n+    /**\n+     * @param intern Whether canonical symbol Strings should be interned\n+     *   or not\n+     */\n+    public synchronized BytesToNameCanonicalizer makeChild(boolean canonicalize,\n+        boolean intern)\n+    {\n+        return new BytesToNameCanonicalizer(this, intern);\n+    }\n+\n+    /**\n+     * Method called by the using code to indicate it is done\n+     * with this instance. This lets instance merge accumulated\n+     * changes into parent (if need be), safely and efficiently,\n+     * and without calling code having to know about parent\n+     * information\n+     */\n+    public void release()\n+    {\n+        if (maybeDirty() && _parent != null) {\n+            _parent.mergeChild(this);\n+            /* Let's also mark this instance as dirty, so that just in\n+             * case release was too early, there's no corruption\n+             * of possibly shared data.\n+             */\n+            markAsShared();\n+        }\n+    }\n+\n+    private BytesToNameCanonicalizer(int hashSize, boolean intern)\n+    {\n+        _parent = null;\n+        _intern = intern;\n+        /* Sanity check: let's now allow hash sizes below certain\n+         * min. value\n+         */\n+        if (hashSize < MIN_HASH_SIZE) {\n+            hashSize = MIN_HASH_SIZE;\n+        } else {\n+            /* Also; size must be 2^N; otherwise hash algorithm won't\n+             * work... so let's just pad it up, if so\n+             */\n+            if ((hashSize & (hashSize - 1)) != 0) { // only true if it's 2^N\n+                int curr = MIN_HASH_SIZE;\n+                while (curr < hashSize) {\n+                    curr += curr;\n+                }\n+                hashSize = curr;\n+            }\n+        }\n+        initTables(hashSize);\n+    }\n+\n+    /**\n+     * Constructor used when creating a child instance\n+     */\n+    private BytesToNameCanonicalizer(BytesToNameCanonicalizer parent, boolean intern)\n+    {\n+        _parent = parent;\n+        _intern = intern;\n+\n+        // First, let's copy the state as is:\n+        _count = parent._count;\n+        _mainHashMask = parent._mainHashMask;\n+        _mainHash = parent._mainHash;\n+        _mainNames = parent._mainNames;\n+        _collList = parent._collList;\n+        _collCount = parent._collCount;\n+        _collEnd = parent._collEnd;\n+        _needRehash = false;\n+        // And consider all shared, so far:\n+        _mainHashShared = true;\n+        _mainNamesShared = true;\n+        _collListShared = true;\n+    }\n+\n+    private void initTables(int hashSize)\n+    {\n+        _count = 0;\n+        _mainHash = new int[hashSize];\n+        _mainNames = new Name[hashSize];\n+        _mainHashShared = false;\n+        _mainNamesShared = false;\n+        _mainHashMask = hashSize - 1;\n+\n+        _collListShared = true; // just since it'll need to be allocated\n+        _collList = null;\n+        _collEnd = 0;\n+\n+        _needRehash = false;\n+    }\n+\n+    private synchronized void mergeChild(BytesToNameCanonicalizer child)\n+    {\n+        // Only makes sense if child has more entries\n+        int childCount = child._count;\n+        if (childCount <= _count) {\n+            return;\n+        }\n+\n+        /* One caveat: let's try to avoid problems with\n+         * degenerate cases of documents with generated \"random\"\n+         * names: for these, symbol tables would bloat indefinitely.\n+         * One way to do this is to just purge tables if they grow\n+         * too large, and that's what we'll do here.\n+         */\n+        if (child.size() > MAX_ENTRIES_FOR_REUSE) {\n+            /* Should there be a way to get notified about this\n+             * event, to log it or such? (as it's somewhat abnormal\n+             * thing to happen)\n+             */\n+            // At any rate, need to clean up the tables, then:\n+            initTables(DEFAULT_TABLE_SIZE);\n+        } else {\n+            _count = child._count;\n+            _mainHash = child._mainHash;\n+            _mainNames = child._mainNames;\n+            _mainHashShared = true; // shouldn't matter for parent\n+            _mainNamesShared = true; // - \"\" -\n+            _mainHashMask = child._mainHashMask;\n+            _collList = child._collList;\n+            _collCount = child._collCount;\n+            _collEnd = child._collEnd;\n+        }\n+    }\n+\n+    private void markAsShared()\n+    {\n+        _mainHashShared = true;\n+        _mainNamesShared = true;\n+        _collListShared = true;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* API, accessors\n+    /**********************************************************\n+     */\n+\n+    public int size() { return _count; }\n+\n+    /**\n+     * Method called to check to quickly see if a child symbol table\n+     * may have gotten additional entries. Used for checking to see\n+     * if a child table should be merged into shared table.\n+     */\n+    public boolean maybeDirty()\n+    {\n+        return !_mainHashShared;\n+    }\n+\n+    public static Name getEmptyName()\n+    {\n+        return Name1.getEmptyName();\n+    }\n+\n+    /**\n+     * Finds and returns name matching the specified symbol, if such\n+     * name already exists in the table.\n+     * If not, will return null.\n+     *<p>\n+     * Note: separate methods to optimize common case of\n+     * short element/attribute names (4 or less ascii characters)\n+     *\n+     * @param firstQuad int32 containing first 4 bytes of the name;\n+     *   if the whole name less than 4 bytes, padded with zero bytes\n+     *   in front (zero MSBs, ie. right aligned)\n+     *\n+     * @return Name matching the symbol passed (or constructed for\n+     *   it)\n+     */\n+    public Name findName(int firstQuad)\n+    {\n+        int hash = calcHash(firstQuad);\n+        int ix = (hash & _mainHashMask);\n+        int val = _mainHash[ix];\n+        \n+        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n+         * are bucket index)... match?\n+         */\n+        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n+            // Ok, but do we have an actual match?\n+            Name name = _mainNames[ix];\n+            if (name == null) { // main slot empty; can't find\n+                return null;\n+            }\n+            if (name.equals(firstQuad)) {\n+                return name;\n+            }\n+        } else if (val == 0) { // empty slot? no match\n+            return null;\n+        }\n+        // Maybe a spill-over?\n+        val &= 0xFF;\n+        if (val > 0) { // 0 means 'empty'\n+            val -= 1; // to convert from 1-based to 0...\n+            Bucket bucket = _collList[val];\n+            if (bucket != null) {\n+                return bucket.find(hash, firstQuad, 0);\n+            }\n+        }\n+        // Nope, no match whatsoever\n+        return null;\n+    }\n+\n+    /**\n+     * Finds and returns name matching the specified symbol, if such\n+     * name already exists in the table.\n+     * If not, will return null.\n+     *<p>\n+     * Note: separate methods to optimize common case of relatively\n+     * short element/attribute names (8 or less ascii characters)\n+     *\n+     * @param firstQuad int32 containing first 4 bytes of the name.\n+     * @param secondQuad int32 containing bytes 5 through 8 of the\n+     *   name; if less than 8 bytes, padded with up to 3 zero bytes\n+     *   in front (zero MSBs, ie. right aligned)\n+     *\n+     * @return Name matching the symbol passed (or constructed for\n+     *   it)\n+     */\n+    public Name findName(int firstQuad, int secondQuad)\n+    {\n+        int hash = calcHash(firstQuad, secondQuad);\n+        int ix = (hash & _mainHashMask);\n+        int val = _mainHash[ix];\n+        \n+        /* High 24 bits of the value are low 24 bits of hash (low 8 bits\n+         * are bucket index)... match?\n+         */\n+        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n+            // Ok, but do we have an actual match?\n+            Name name = _mainNames[ix];\n+            if (name == null) { // main slot empty; can't find\n+                return null;\n+            }\n+            if (name.equals(firstQuad, secondQuad)) {\n+                return name;\n+            }\n+        } else if (val == 0) { // empty slot? no match\n+            return null;\n+        }\n+        // Maybe a spill-over?\n+        val &= 0xFF;\n+        if (val > 0) { // 0 means 'empty'\n+            val -= 1; // to convert from 1-based to 0...\n+            Bucket bucket = _collList[val];\n+            if (bucket != null) {\n+                return bucket.find(hash, firstQuad, secondQuad);\n+            }\n+        }\n+        // Nope, no match whatsoever\n+        return null;\n+    }\n+\n+    /**\n+     * Finds and returns name matching the specified symbol, if such\n+     * name already exists in the table; or if not, creates name object,\n+     * adds to the table, and returns it.\n+     *<p>\n+     * Note: this is the general purpose method that can be called for\n+     * names of any length. However, if name is less than 9 bytes long,\n+     * it is preferable to call the version optimized for short\n+     * names.\n+     *\n+     * @param quads Array of int32s, each of which contain 4 bytes of\n+     *   encoded name\n+     * @param qlen Number of int32s, starting from index 0, in quads\n+     *   parameter\n+     *\n+     * @return Name matching the symbol passed (or constructed for it)\n+     */\n+    public Name findName(int[] quads, int qlen)\n+    {\n+        /* // Not needed, never gets called\n+        if (qlen < 3) { // another sanity check\n+            return findName(quads[0], (qlen < 2) ? 0 : quads[1]);\n+        }\n+        */\n+        int hash = calcHash(quads, qlen);\n+        // (for rest of comments regarding logic, see method above)\n+        int ix = (hash & _mainHashMask);\n+        int val = _mainHash[ix];\n+        if ((((val >> 8) ^ hash) << 8) == 0) {\n+            Name name = _mainNames[ix];\n+            if (name == null // main slot empty; no collision list then either\n+                || name.equals(quads, qlen)) { // should be match, let's verify\n+                return name;\n+            }\n+        } else if (val == 0) { // empty slot? no match\n+            return null;\n+        }\n+        val &= 0xFF;\n+        if (val > 0) { // 0 means 'empty'\n+            val -= 1; // to convert from 1-based to 0...\n+            Bucket bucket = _collList[val];\n+            if (bucket != null) {\n+                return bucket.find(hash, quads, qlen);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* API, mutators\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @since 1.6.0\n+     */\n+    public Name addName(String symbolStr, int q1, int q2)\n+    {\n+        if (_intern) {\n+            symbolStr = InternCache.instance.intern(symbolStr);\n+        }\n+        int hash = (q2 == 0) ? calcHash(q1) : calcHash(q1, q2);\n+        Name symbol = constructName(hash, symbolStr, q1, q2);\n+        _addSymbol(hash, symbol);\n+        return symbol;\n+    }\n+    \n+    public Name addName(String symbolStr, int[] quads, int qlen)\n+    {\n+        if (_intern) {\n+            symbolStr = InternCache.instance.intern(symbolStr);\n+        }\n+        int hash = calcHash(quads, qlen);\n+        Name symbol = constructName(hash, symbolStr, quads, qlen);\n+        _addSymbol(hash, symbol);\n+        return symbol;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    public final static int calcHash(int firstQuad)\n+    {\n+        int hash = firstQuad;\n+        hash ^= (hash >>> 16); // to xor hi- and low- 16-bits\n+        hash ^= (hash >>> 8); // as well as lowest 2 bytes\n+        return hash;\n+    }\n+\n+    public final static int calcHash(int firstQuad, int secondQuad)\n+    {\n+        int hash = (firstQuad * 31) + secondQuad;\n+\n+        // If this was called for single-quad instance:\n+        //int hash = (secondQuad == 0) ? firstQuad : ((firstQuad * 31) + secondQuad);\n+\n+        hash ^= (hash >>> 16); // to xor hi- and low- 16-bits\n+        hash ^= (hash >>> 8); // as well as lowest 2 bytes\n+        return hash;\n+    }\n+\n+    public final static int calcHash(int[] quads, int qlen)\n+    {\n+        // Note: may be called for qlen < 3\n+        int hash = quads[0];\n+        for (int i = 1; i < qlen; ++i) {\n+            hash = (hash * 31) + quads[i];\n+        }\n+\n+        hash ^= (hash >>> 16); // to xor hi- and low- 16-bits\n+        hash ^= (hash >>> 8); // as well as lowest 2 bytes\n+\n+        return hash;\n+    }\n+\n+    /* 26-Nov-2008, tatu: not used currently; if not used in near future,\n+     *   let's just delete it.\n+     */\n+    /*\n+    public static int[] calcQuads(byte[] wordBytes)\n+    {\n+        int blen = wordBytes.length;\n+        int[] result = new int[(blen + 3) / 4];\n+        for (int i = 0; i < blen; ++i) {\n+            int x = wordBytes[i] & 0xFF;\n+\n+            if (++i < blen) {\n+                x = (x << 8) | (wordBytes[i] & 0xFF);\n+                if (++i < blen) {\n+                    x = (x << 8) | (wordBytes[i] & 0xFF);\n+                    if (++i < blen) {\n+                        x = (x << 8) | (wordBytes[i] & 0xFF);\n+                    }\n+                }\n+            }\n+            result[i >> 2] = x;\n+        }\n+        return result;\n+    }\n+    */\n+\n+    /*\n+    /**********************************************************\n+    /* Standard methods\n+    /**********************************************************\n+     */\n+\n+    /*\n+    @Override\n+    public String toString()\n+    {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"[BytesToNameCanonicalizer, size: \");\n+        sb.append(_count);\n+        sb.append('/');\n+        sb.append(_mainHash.length);\n+        sb.append(\", \");\n+        sb.append(_collCount);\n+        sb.append(\" coll; avg length: \");\n+\n+        // Average length: minimum of 1 for all (1 == primary hit);\n+        // and then 1 per each traversal for collisions/buckets\n+        //int maxDist = 1;\n+        int pathCount = _count;\n+        for (int i = 0; i < _collEnd; ++i) {\n+            int spillLen = _collList[i].length();\n+            for (int j = 1; j <= spillLen; ++j) {\n+                pathCount += j;\n+            }\n+        }\n+        double avgLength;\n+\n+        if (_count == 0) {\n+            avgLength = 0.0;\n+        } else {\n+            avgLength = (double) pathCount / (double) _count;\n+        }\n+        // let's round up a bit (two 2 decimal places)\n+        //avgLength -= (avgLength % 0.01);\n+\n+        sb.append(avgLength);\n+        sb.append(']');\n+        return sb.toString();\n+    }\n+    */\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+\n+    private void _addSymbol(int hash, Name symbol)\n+    {\n+        if (_mainHashShared) { // always have to modify main entry\n+            unshareMain();\n+        }\n+        // First, do we need to rehash?\n+        if (_needRehash) {\n+            rehash();\n+        }\n+\n+        ++_count;\n+\n+        /* Ok, enough about set up: now we need to find the slot to add\n+         * symbol in:\n+         */\n+        int ix = (hash & _mainHashMask);\n+        if (_mainNames[ix] == null) { // primary empty?\n+            _mainHash[ix] = (hash << 8);\n+            if (_mainNamesShared) {\n+                unshareNames();\n+            }\n+            _mainNames[ix] = symbol;\n+        } else { // nope, it's a collision, need to spill over\n+            /* How about spill-over area... do we already know the bucket\n+             * (is the case if it's not the first collision)\n+             */\n+            if (_collListShared) {\n+                unshareCollision(); // also allocates if list was null\n+            }\n+\n+            ++_collCount;\n+            int entryValue = _mainHash[ix];\n+            int bucket = entryValue & 0xFF;\n+            if (bucket == 0) { // first spill over?\n+                if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n+                    bucket = _collEnd;\n+                    ++_collEnd;\n+                    // need to expand?\n+                    if (bucket >= _collList.length) {\n+                        expandCollision();\n+                    }\n+                } else { // nope, have to share... let's find shortest?\n+                    bucket = findBestBucket();\n+                }\n+                // Need to mark the entry... and the spill index is 1-based\n+                _mainHash[ix] = (entryValue & ~0xFF) | (bucket + 1);\n+            } else {\n+                --bucket; // 1-based index in value\n+            }\n+            \n+            // And then just need to link the new bucket entry in\n+            _collList[bucket] = new Bucket(symbol, _collList[bucket]);\n+        }\n+\n+        /* Ok. Now, do we need a rehash next time? Need to have at least\n+         * 50% fill rate no matter what:\n+         */\n+        {\n+            int hashSize = _mainHash.length;\n+            if (_count > (hashSize >> 1)) {\n+                int hashQuarter = (hashSize >> 2);\n+                /* And either strictly above 75% (the usual) or\n+                 * just 50%, and collision count >= 25% of total hash size\n+                 */\n+                if (_count > (hashSize - hashQuarter)) {\n+                    _needRehash = true;\n+                } else if (_collCount >= hashQuarter) {\n+                    _needRehash = true;\n+                }\n+            }\n+        }\n+    }\n+\n+    private void rehash()\n+    {\n+        _needRehash = false;        \n+        // Note: since we'll make copies, no need to unshare, can just mark as such:\n+        _mainNamesShared = false;\n+\n+        /* And then we can first deal with the main hash area. Since we\n+         * are expanding linearly (double up), we know there'll be no\n+         * collisions during this phase.\n+         */\n+        int[] oldMainHash = _mainHash;\n+        int len = oldMainHash.length;\n+        int newLen = len+len;\n+\n+        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n+         *    large documents with unique (or mostly so) names\n+         */\n+        if (newLen > MAX_TABLE_SIZE) {\n+            nukeSymbols();\n+            return;\n+        }\n+        \n+        _mainHash = new int[newLen];\n+        _mainHashMask = (newLen - 1);\n+        Name[] oldNames = _mainNames;\n+        _mainNames = new Name[newLen];\n+        int symbolsSeen = 0; // let's do a sanity check\n+        for (int i = 0; i < len; ++i) {\n+            Name symbol = oldNames[i];\n+            if (symbol != null) {\n+                ++symbolsSeen;\n+                int hash = symbol.hashCode();\n+                int ix = (hash & _mainHashMask);\n+                _mainNames[ix] = symbol;\n+                _mainHash[ix] = hash << 8; // will clear spill index\n+            }\n+        }\n+\n+        /* And then the spill area. This may cause collisions, although\n+         * not necessarily as many as there were earlier. Let's allocate\n+         * same amount of space, however\n+         */\n+        int oldEnd = _collEnd;\n+        if (oldEnd == 0) { // no prior collisions...\n+            return;\n+        }\n+\n+        _collCount = 0;\n+        _collEnd = 0;\n+        _collListShared = false;\n+\n+        Bucket[] oldBuckets = _collList;\n+        _collList = new Bucket[oldBuckets.length];\n+        for (int i = 0; i < oldEnd; ++i) {\n+            for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) {\n+                ++symbolsSeen;\n+                Name symbol = curr._name;\n+                int hash = symbol.hashCode();\n+                int ix = (hash & _mainHashMask);\n+                int val = _mainHash[ix];\n+                if (_mainNames[ix] == null) { // no primary entry?\n+                    _mainHash[ix] = (hash << 8);\n+                    _mainNames[ix] = symbol;\n+                } else { // nope, it's a collision, need to spill over\n+                    ++_collCount;\n+                    int bucket = val & 0xFF;\n+                    if (bucket == 0) { // first spill over?\n+                        if (_collEnd <= LAST_VALID_BUCKET) { // yup, still unshared bucket\n+                            bucket = _collEnd;\n+                            ++_collEnd;\n+                            // need to expand?\n+                            if (bucket >= _collList.length) {\n+                                expandCollision();\n+                            }\n+                        } else { // nope, have to share... let's find shortest?\n+                            bucket = findBestBucket();\n+                        }\n+                        // Need to mark the entry... and the spill index is 1-based\n+                        _mainHash[ix] = (val & ~0xFF) | (bucket + 1);\n+                    } else {\n+                        --bucket; // 1-based index in value\n+                    }\n+                    // And then just need to link the new bucket entry in\n+                    _collList[bucket] = new Bucket(symbol, _collList[bucket]);\n+                }\n+            } // for (... buckets in the chain ...)\n+        } // for (... list of bucket heads ... )\n+\n+        if (symbolsSeen != _count) { // sanity check\n+            throw new RuntimeException(\"Internal error: count after rehash \"+symbolsSeen+\"; should be \"+_count);\n+        }\n+    }\n+\n+    /**\n+     * Helper method called to empty all shared symbols, but to leave\n+     * arrays allocated\n+     */\n+    private void nukeSymbols()\n+    {\n+        _count = 0;\n+        Arrays.fill(_mainHash, 0);\n+        Arrays.fill(_mainNames, null);\n+        Arrays.fill(_collList, null);\n+        _collCount = 0;\n+        _collEnd = 0;\n+    }\n+    \n+    /**\n+     * Method called to find the best bucket to spill a Name over to:\n+     * usually the first bucket that has only one entry, but in general\n+     * first one of the buckets with least number of entries\n+     */\n+    private int findBestBucket()\n+    {\n+        Bucket[] buckets = _collList;\n+        int bestCount = Integer.MAX_VALUE;\n+        int bestIx = -1;\n+\n+        for (int i = 0, len = _collEnd; i < len; ++i) {\n+            int count = buckets[i].length();\n+            if (count < bestCount) {\n+                if (count == 1) { // best possible\n+                    return i;\n+                }\n+                bestCount = count;\n+                bestIx = i;\n+            }\n+        }\n+        return bestIx;\n+    }\n+\n+    /**\n+     * Method that needs to be called, if the main hash structure\n+     * is (may be) shared. This happens every time something is added,\n+     * even if addition is to the collision list (since collision list\n+     * index comes from lowest 8 bits of the primary hash entry)\n+     */\n+    private void unshareMain()\n+    {\n+        int[] old = _mainHash;\n+        int len = _mainHash.length;\n+\n+        _mainHash = new int[len];\n+        System.arraycopy(old, 0, _mainHash, 0, len);\n+        _mainHashShared = false;\n+    }\n+\n+    private void unshareCollision()\n+    {\n+        Bucket[] old = _collList;\n+        if (old == null) {\n+            _collList = new Bucket[INITIAL_COLLISION_LEN];\n+        } else {\n+            int len = old.length;\n+            _collList = new Bucket[len];\n+            System.arraycopy(old, 0, _collList, 0, len);\n+        }\n+        _collListShared = false;\n+    }\n+\n+    private void unshareNames()\n+    {\n+        Name[] old = _mainNames;\n+        int len = old.length;\n+        _mainNames = new Name[len];\n+        System.arraycopy(old, 0, _mainNames, 0, len);\n+        _mainNamesShared = false;\n+    }\n+\n+    private void expandCollision()\n+    {\n+        Bucket[] old = _collList;\n+        int len = old.length;\n+        _collList = new Bucket[len+len];\n+        System.arraycopy(old, 0, _collList, 0, len);\n+    }\n+\n+\n+    /*\n+    /**********************************************************\n+    /* Constructing name objects\n+    /**********************************************************\n+     */\n+\n+    private static Name constructName(int hash, String name, int q1, int q2)\n+    {     \n+        if (q2 == 0) { // one quad only?\n+            return new Name1(name, hash, q1);\n+        }\n+        return new Name2(name, hash, q1, q2);\n+    }\n+\n+    private static Name constructName(int hash, String name, int[] quads, int qlen)\n+    {\n+        if (qlen < 4) { // Need to check for 3 quad one, can do others too\n+            switch (qlen) {\n+            case 1:\n+                return new Name1(name, hash, quads[0]);\n+            case 2:\n+                return new Name2(name, hash, quads[0], quads[1]);\n+            case 3:\n+                return new Name3(name, hash, quads[0], quads[1], quads[2]);\n+            default:\n+            }\n+        }\n+        // Otherwise, need to copy the incoming buffer\n+        int[] buf = new int[qlen];\n+        for (int i = 0; i < qlen; ++i) {\n+            buf[i] = quads[i];\n+        }\n+        return new NameN(name, hash, buf, qlen);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    final static class Bucket\n+    {\n+        protected final Name _name;\n+        protected final Bucket _next;\n+\n+        Bucket(Name name, Bucket next)\n+        {\n+            _name = name;\n+            _next = next;\n+        }\n+\n+        public int length()\n+        {\n+            int len = 1;\n+            for (Bucket curr = _next; curr != null; curr = curr._next) {\n+                ++len;\n+            }\n+            return len;\n+        }\n+\n+        public Name find(int hash, int firstQuad, int secondQuad)\n+        {\n+            if (_name.hashCode() == hash) {\n+                if (_name.equals(firstQuad, secondQuad)) {\n+                    return _name;\n+                }\n+            }\n+            for (Bucket curr = _next; curr != null; curr = curr._next) {\n+                Name currName = curr._name;\n+                if (currName.hashCode() == hash) {\n+                    if (currName.equals(firstQuad, secondQuad)) {\n+                        return currName;\n+                    }\n+                }\n+            }\n+            return null;\n+        }\n+\n+        public Name find(int hash, int[] quads, int qlen)\n+        {\n+            if (_name.hashCode() == hash) {\n+                if (_name.equals(quads, qlen)) {\n+                    return _name;\n+                }\n+            }\n+            for (Bucket curr = _next; curr != null; curr = curr._next) {\n+                Name currName = curr._name;\n+                if (currName.hashCode() == hash) {\n+                    if (currName.equals(quads, qlen)) {\n+                        return currName;\n+                    }\n+                }\n+            }\n+            return null;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java\n+package com.fasterxml.jackson.core.sym;\n+\n+import java.util.Arrays;\n+\n+import com.fasterxml.jackson.core.util.InternCache;\n+\n+/**\n+ * This class is a kind of specialized type-safe Map, from char array to\n+ * String value. Specialization means that in addition to type-safety\n+ * and specific access patterns (key char array, Value optionally interned\n+ * String; values added on access if necessary), and that instances are\n+ * meant to be used concurrently, but by using well-defined mechanisms\n+ * to obtain such concurrently usable instances. Main use for the class\n+ * is to store symbol table information for things like compilers and\n+ * parsers; especially when number of symbols (keywords) is limited.\n+ *<p>\n+ * For optimal performance, usage pattern should be one where matches\n+ * should be very common (esp. after \"warm-up\"), and as with most hash-based\n+ * maps/sets, that hash codes are uniformly distributed. Also, collisions\n+ * are slightly more expensive than with HashMap or HashSet, since hash codes\n+ * are not used in resolving collisions; that is, equals() comparison is\n+ * done with all symbols in same bucket index.<br />\n+ * Finally, rehashing is also more expensive, as hash codes are not\n+ * stored; rehashing requires all entries' hash codes to be recalculated.\n+ * Reason for not storing hash codes is reduced memory usage, hoping\n+ * for better memory locality.\n+ *<p>\n+ * Usual usage pattern is to create a single \"master\" instance, and either\n+ * use that instance in sequential fashion, or to create derived \"child\"\n+ * instances, which after use, are asked to return possible symbol additions\n+ * to master instance. In either case benefit is that symbol table gets\n+ * initialized so that further uses are more efficient, as eventually all\n+ * symbols needed will already be in symbol table. At that point no more\n+ * Symbol String allocations are needed, nor changes to symbol table itself.\n+ *<p>\n+ * Note that while individual SymbolTable instances are NOT thread-safe\n+ * (much like generic collection classes), concurrently used \"child\"\n+ * instances can be freely used without synchronization. However, using\n+ * master table concurrently with child instances can only be done if\n+ * access to master instance is read-only (ie. no modifications done).\n+ */\n+\n+public final class CharsToNameCanonicalizer\n+{\n+    /**\n+     * Default initial table size. Shouldn't be miniscule (as there's\n+     * cost to both array realloc and rehashing), but let's keep\n+     * it reasonably small nonetheless. For systems that properly \n+     * reuse factories it doesn't matter either way; but when\n+     * recreating factories often, initial overhead may dominate.\n+     */\n+    protected static final int DEFAULT_TABLE_SIZE = 64;\n+\n+    /**\n+     * Let's not expand symbol tables past some maximum size;\n+     * this should protected against OOMEs caused by large documents\n+     * with uniquer (~= random) names.\n+     * \n+     * @since 1.5\n+     */\n+    protected static final int MAX_TABLE_SIZE = 0x10000; // 64k entries == 256k mem\n+\n+    /**\n+     * Let's only share reasonably sized symbol tables. Max size set to 3/4 of 16k;\n+     * this corresponds to 64k main hash index. This should allow for enough distinct\n+     * names for almost any case.\n+     */\n+    final static int MAX_ENTRIES_FOR_REUSE = 12000;\n+\n+    final static CharsToNameCanonicalizer sBootstrapSymbolTable;\n+    static {\n+        sBootstrapSymbolTable = new CharsToNameCanonicalizer();\n+    }\n+\n+    /*\n+    /****************************************\n+    /* Configuration:\n+    /****************************************\n+     */\n+\n+    /**\n+     * Sharing of learnt symbols is done by optional linking of symbol\n+     * table instances with their parents. When parent linkage is\n+     * defined, and child instance is released (call to <code>release</code>),\n+     * parent's shared tables may be updated from the child instance.\n+     */\n+    protected CharsToNameCanonicalizer _parent;\n+\n+    /**\n+     * Whether canonical symbol Strings are to be intern()ed before added\n+     * to the table or not\n+     */\n+    final protected boolean _intern;\n+\n+    /**\n+     * Whether any canonicalization should be attempted (whether using\n+     * intern or not)\n+     */\n+    final protected boolean _canonicalize;\n+    \n+    /*\n+    /****************************************\n+    /* Actual symbol table data:\n+    /****************************************\n+     */\n+\n+    /**\n+     * Primary matching symbols; it's expected most match occur from\n+     * here.\n+     */\n+    protected String[] _symbols;\n+\n+    /**\n+     * Overflow buckets; if primary doesn't match, lookup is done\n+     * from here.\n+     *<p>\n+     * Note: Number of buckets is half of number of symbol entries, on\n+     * assumption there's less need for buckets.\n+     */\n+    protected Bucket[] _buckets;\n+\n+    /**\n+     * Current size (number of entries); needed to know if and when\n+     * rehash.\n+     */\n+    protected int _size;\n+\n+    /**\n+     * Limit that indicates maximum size this instance can hold before\n+     * it needs to be expanded and rehashed. Calculated using fill\n+     * factor passed in to constructor.\n+     */\n+    protected int _sizeThreshold;\n+\n+    /**\n+     * Mask used to get index from hash values; equal to\n+     * <code>_buckets.length - 1</code>, when _buckets.length is\n+     * a power of two.\n+     */\n+    protected int _indexMask;\n+\n+    /*\n+    /****************************************\n+    /* State regarding shared arrays\n+    /****************************************\n+     */\n+\n+    /**\n+     * Flag that indicates if any changes have been made to the data;\n+     * used to both determine if bucket array needs to be copied when\n+     * (first) change is made, and potentially if updated bucket list\n+     * is to be resync'ed back to master instance.\n+     */\n+    protected boolean _dirty;\n+\n+    /*\n+    /****************************************\n+    /* Life-cycle\n+    /****************************************\n+     */\n+\n+    /**\n+     * Method called to create root canonicalizer for a {@link com.fasterxml.jackson.core.JsonFactory}\n+     * instance. Root instance is never used directly; its main use is for\n+     * storing and sharing underlying symbol arrays as needed.\n+     */\n+    public static CharsToNameCanonicalizer createRoot()\n+    {\n+        return sBootstrapSymbolTable.makeOrphan();\n+    }\n+\n+    /**\n+     * Main method for constructing a master symbol table instance.\n+     *\n+     * @param initialSize Minimum initial size for bucket array; internally\n+     *   will always use a power of two equal to or bigger than this value.\n+     */\n+    private CharsToNameCanonicalizer()\n+    {\n+        // these settings don't really matter for the bootstrap instance\n+        _canonicalize = true;\n+        _intern = true;\n+        // And we'll also set flags so no copying of buckets is needed:\n+        _dirty = true;\n+        initTables(DEFAULT_TABLE_SIZE);\n+    }\n+\n+    private void initTables(int initialSize)\n+    {\n+        _symbols = new String[initialSize];\n+        _buckets = new Bucket[initialSize >> 1];\n+        // Mask is easy to calc for powers of two.\n+        _indexMask = initialSize - 1;\n+        _size = 0;\n+        // Hard-coded fill factor is 75%\n+        _sizeThreshold = (initialSize - (initialSize >> 2));\n+    }\n+\n+    /**\n+     * Internal constructor used when creating child instances.\n+     */\n+    private CharsToNameCanonicalizer(CharsToNameCanonicalizer parent,\n+            boolean canonicalize, boolean intern,\n+            String[] symbols, Bucket[] buckets, int size)\n+    {\n+        _parent = parent;\n+        _canonicalize = canonicalize;\n+        _intern = intern;\n+\n+        _symbols = symbols;\n+        _buckets = buckets;\n+        _size = size;\n+        // Hard-coded fill factor, 75%\n+        int arrayLen = (symbols.length);\n+        _sizeThreshold = arrayLen - (arrayLen >> 2);\n+        _indexMask =  (arrayLen - 1);\n+\n+        // Need to make copies of arrays, if/when adding new entries\n+        _dirty = false;\n+    }\n+\n+    /**\n+     * \"Factory\" method; will create a new child instance of this symbol\n+     * table. It will be a copy-on-write instance, ie. it will only use\n+     * read-only copy of parent's data, but when changes are needed, a\n+     * copy will be created.\n+     *<p>\n+     * Note: while this method is synchronized, it is generally not\n+     * safe to both use makeChild/mergeChild, AND to use instance\n+     * actively. Instead, a separate 'root' instance should be used\n+     * on which only makeChild/mergeChild are called, but instance itself\n+     * is not used as a symbol table.\n+     */\n+    public synchronized CharsToNameCanonicalizer makeChild(boolean canonicalize, boolean intern)\n+    {\n+        return new CharsToNameCanonicalizer(this, canonicalize, intern, _symbols, _buckets, _size);\n+    }\n+\n+    private CharsToNameCanonicalizer makeOrphan()\n+    {\n+        return new CharsToNameCanonicalizer(null, true, true, _symbols, _buckets, _size);\n+    }\n+\n+    /**\n+     * Method that allows contents of child table to potentially be\n+     * \"merged in\" with contents of this symbol table.\n+     *<p>\n+     * Note that caller has to make sure symbol table passed in is\n+     * really a child or sibling of this symbol table.\n+     */\n+    private synchronized void mergeChild(CharsToNameCanonicalizer child)\n+    {\n+        /* One caveat: let's try to avoid problems with\n+         * degenerate cases of documents with generated \"random\"\n+         * names: for these, symbol tables would bloat indefinitely.\n+         * One way to do this is to just purge tables if they grow\n+         * too large, and that's what we'll do here.\n+         */\n+        if (child.size() > MAX_ENTRIES_FOR_REUSE) {\n+            /* Should there be a way to get notified about this\n+             * event, to log it or such? (as it's somewhat abnormal\n+             * thing to happen)\n+             */\n+            // At any rate, need to clean up the tables, then:\n+            initTables(DEFAULT_TABLE_SIZE);\n+        } else {\n+            /* Otherwise, we'll merge changed stuff in, if there are\n+             * more entries (which may not be the case if one of siblings\n+             * has added symbols first or such)\n+             */\n+            if (child.size() <= size()) { // nothing to add\n+                return;\n+            }\n+            // Okie dokie, let's get the data in!\n+            _symbols = child._symbols;\n+            _buckets = child._buckets;\n+            _size = child._size;\n+            _sizeThreshold = child._sizeThreshold;\n+            _indexMask = child._indexMask;\n+        }\n+        /* Dirty flag... well, let's just clear it, to force copying just\n+         * in case. Shouldn't really matter, for master tables.\n+         * (which this is, given something is merged to it etc)\n+         */\n+        _dirty = false;\n+    }\n+\n+    public void release()\n+    {\n+        // If nothing has been added, nothing to do\n+        if (!maybeDirty()) {\n+            return;\n+        }\n+        if (_parent != null) {\n+            _parent.mergeChild(this);\n+            /* Let's also mark this instance as dirty, so that just in\n+             * case release was too early, there's no corruption\n+             * of possibly shared data.\n+             */\n+            _dirty = false;\n+        }\n+    }\n+\n+    /*\n+    /****************************************\n+    /* Public API, generic accessors:\n+    /****************************************\n+     */\n+\n+    public int size() { return _size; }\n+\n+    public boolean maybeDirty() { return _dirty; }\n+\n+    /*\n+    /****************************************\n+    /* Public API, accessing symbols:\n+    /****************************************\n+     */\n+\n+    public String findSymbol(char[] buffer, int start, int len, int hash)\n+    {\n+        if (len < 1) { // empty Strings are simplest to handle up front\n+            return \"\";\n+        }\n+        if (!_canonicalize) { // [JACKSON-259]\n+            return new String(buffer, start, len);\n+        }\n+\n+        hash &= _indexMask;\n+\n+        String sym = _symbols[hash];\n+\n+        // Optimal case; checking existing primary symbol for hash index:\n+        if (sym != null) {\n+            // Let's inline primary String equality checking:\n+            if (sym.length() == len) {\n+                int i = 0;\n+                do {\n+                    if (sym.charAt(i) != buffer[start+i]) {\n+                        break;\n+                    }\n+                } while (++i < len);\n+                // Optimal case; primary match found\n+                if (i == len) {\n+                    return sym;\n+                }\n+            }\n+            // How about collision bucket?\n+            Bucket b = _buckets[hash >> 1];\n+            if (b != null) {\n+                sym = b.find(buffer, start, len);\n+                if (sym != null) {\n+                    return sym;\n+                }\n+            }\n+        }\n+\n+        if (!_dirty) { //need to do copy-on-write?\n+            copyArrays();\n+            _dirty = true;\n+        } else if (_size >= _sizeThreshold) { // Need to expand?\n+           rehash();\n+            /* Need to recalc hash; rare occurence (index mask has been\n+             * recalculated as part of rehash)\n+             */\n+            hash = calcHash(buffer, start, len) & _indexMask;\n+        }\n+        ++_size;\n+\n+        String newSymbol = new String(buffer, start, len);\n+        if (_intern) {\n+            newSymbol = InternCache.instance.intern(newSymbol);\n+        }\n+        // Ok; do we need to add primary entry, or a bucket?\n+        if (_symbols[hash] == null) {\n+            _symbols[hash] = newSymbol;\n+        } else {\n+            int bix = hash >> 1;\n+            _buckets[bix] = new Bucket(newSymbol, _buckets[bix]);\n+        }\n+\n+        return newSymbol;\n+    }\n+\n+    /**\n+     * Implementation of a hashing method for variable length\n+     * Strings. Most of the time intention is that this calculation\n+     * is done by caller during parsing, not here; however, sometimes\n+     * it needs to be done for parsed \"String\" too.\n+     *\n+     * @param len Length of String; has to be at least 1 (caller guarantees\n+     *   this pre-condition)\n+     */\n+    public static int calcHash(char[] buffer, int start, int len) {\n+        int hash = (int) buffer[0];\n+        for (int i = 1; i < len; ++i) {\n+            hash = (hash * 31) + (int) buffer[i];\n+        }\n+        return hash;\n+    }\n+\n+    public static int calcHash(String key) {\n+        int hash = (int) key.charAt(0);\n+        for (int i = 1, len = key.length(); i < len; ++i) {\n+            hash = (hash * 31) + (int) key.charAt(i);\n+\n+        }\n+        return hash;\n+    }\n+\n+    /*\n+    /****************************************\n+    /* Internal methods\n+    /****************************************\n+     */\n+\n+    /**\n+     * Method called when copy-on-write is needed; generally when first\n+     * change is made to a derived symbol table.\n+     */\n+    private void copyArrays() {\n+        String[] oldSyms = _symbols;\n+        int size = oldSyms.length;\n+        _symbols = new String[size];\n+        System.arraycopy(oldSyms, 0, _symbols, 0, size);\n+        Bucket[] oldBuckets = _buckets;\n+        size = oldBuckets.length;\n+        _buckets = new Bucket[size];\n+        System.arraycopy(oldBuckets, 0, _buckets, 0, size);\n+    }\n+\n+    /**\n+     * Method called when size (number of entries) of symbol table grows\n+     * so big that load factor is exceeded. Since size has to remain\n+     * power of two, arrays will then always be doubled. Main work\n+     * is really redistributing old entries into new String/Bucket\n+     * entries.\n+     */\n+    private void rehash()\n+    {\n+        int size = _symbols.length;\n+        int newSize = size + size;\n+\n+        /* 12-Mar-2010, tatu: Let's actually limit maximum size we are\n+         *    prepared to use, to guard against OOME in case of unbounded\n+         *    name sets (unique [non-repeating] names)\n+         */\n+        if (newSize > MAX_TABLE_SIZE) {\n+            /* If this happens, there's no point in either growing or\n+             * shrinking hash areas. Rather, it's better to just clean\n+             * them up for reuse.\n+             */\n+            _size = 0;\n+            Arrays.fill(_symbols, null);\n+            Arrays.fill(_buckets, null);\n+            _dirty = true;\n+            return;\n+        }\n+        \n+        String[] oldSyms = _symbols;\n+        Bucket[] oldBuckets = _buckets;\n+        _symbols = new String[newSize];\n+        _buckets = new Bucket[newSize >> 1];\n+        // Let's update index mask, threshold, now (needed for rehashing)\n+        _indexMask = newSize - 1;\n+        _sizeThreshold += _sizeThreshold;\n+        \n+        int count = 0; // let's do sanity check\n+\n+        /* Need to do two loops, unfortunately, since spill-over area is\n+         * only half the size:\n+         */\n+        for (int i = 0; i < size; ++i) {\n+            String symbol = oldSyms[i];\n+            if (symbol != null) {\n+                ++count;\n+                int index = calcHash(symbol) & _indexMask;\n+                if (_symbols[index] == null) {\n+                    _symbols[index] = symbol;\n+                } else {\n+                    int bix = index >> 1;\n+                    _buckets[bix] = new Bucket(symbol, _buckets[bix]);\n+                }\n+            }\n+        }\n+\n+        size >>= 1;\n+        for (int i = 0; i < size; ++i) {\n+            Bucket b = oldBuckets[i];\n+            while (b != null) {\n+                ++count;\n+                String symbol = b.getSymbol();\n+                int index = calcHash(symbol) & _indexMask;\n+                if (_symbols[index] == null) {\n+                    _symbols[index] = symbol;\n+                } else {\n+                    int bix = index >> 1;\n+                    _buckets[bix] = new Bucket(symbol, _buckets[bix]);\n+                }\n+                b = b.getNext();\n+            }\n+        }\n+\n+        if (count != _size) {\n+            throw new Error(\"Internal error on SymbolTable.rehash(): had \"+_size+\" entries; now have \"+count+\".\");\n+        }\n+    }\n+\n+    /*\n+    /****************************************\n+    /* Bucket class\n+    /****************************************\n+     */\n+\n+    /**\n+     * This class is a symbol table entry. Each entry acts as a node\n+     * in a linked list.\n+     */\n+    static final class Bucket {\n+        private final String _symbol;\n+        private final Bucket mNext;\n+\n+        public Bucket(String symbol, Bucket next) {\n+            _symbol = symbol;\n+            mNext = next;\n+        }\n+\n+        public String getSymbol() { return _symbol; }\n+        public Bucket getNext() { return mNext; }\n+\n+        public String find(char[] buf, int start, int len) {\n+            String sym = _symbol;\n+            Bucket b = mNext;\n+\n+            while (true) { // Inlined equality comparison:\n+                if (sym.length() == len) {\n+                    int i = 0;\n+                    do {\n+                        if (sym.charAt(i) != buf[start+i]) {\n+                            break;\n+                        }\n+                    } while (++i < len);\n+                    if (i == len) {\n+                        return sym;\n+                    }\n+                }\n+                if (b == null) {\n+                    break;\n+                }\n+                sym = b.getSymbol();\n+                b = b.getNext();\n+            }\n+            return null;\n+        }\n+\n+    /* 26-Nov-2008, tatu: not used currently; if not used in near future,\n+     *   let's just delete it.\n+     */\n+        /*\n+        public String find(String str) {\n+            String sym = _symbol;\n+            Bucket b = mNext;\n+\n+            while (true) {\n+                if (sym.equals(str)) {\n+                    return sym;\n+                }\n+                if (b == null) {\n+                    break;\n+                }\n+                sym = b.getSymbol();\n+                b = b.getNext();\n+            }\n+            return null;\n+        }\n+        */\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/Name.java\n+package com.fasterxml.jackson.core.sym;\n+\n+/**\n+ * Base class for tokenized names (key strings in objects) that have\n+ * been tokenized from byte-based input sources (like\n+ * {@link java.io.InputStream}.\n+ *\n+ * @author Tatu Saloranta\n+ */\n+public abstract class Name\n+{\n+    protected final String _name;\n+\n+    protected final int _hashCode;\n+\n+    protected Name(String name, int hashCode) {\n+        _name = name;\n+        _hashCode = hashCode;\n+    }\n+\n+    public String getName() { return _name; }\n+\n+    /*\n+    /**********************************************************\n+    /* Methods for package/core parser\n+    /**********************************************************\n+     */\n+\n+    public abstract boolean equals(int quad1);\n+\n+    public abstract boolean equals(int quad1, int quad2);\n+\n+    public abstract boolean equals(int[] quads, int qlen);\n+\n+    /*\n+    /**********************************************************\n+    /* Overridden standard methods\n+    /**********************************************************\n+     */\n+\n+    @Override public String toString() { return _name; }\n+\n+    @Override public final int hashCode() { return _hashCode; }\n+\n+    @Override public boolean equals(Object o)\n+    {\n+        // Canonical instances, can usually just do identity comparison\n+        return (o == this);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/Name1.java\n+package com.fasterxml.jackson.core.sym;\n+\n+/**\n+ * Specialized implementation of PName: can be used for short Strings\n+ * that consists of at most 4 bytes. Usually this means short\n+ * ascii-only names.\n+ *<p>\n+ * The reason for such specialized classes is mostly space efficiency;\n+ * and to a lesser degree performance. Both are achieved for short\n+ * Strings by avoiding another level of indirection (via quad arrays)\n+ */\n+public final class Name1\n+    extends Name\n+{\n+    final static Name1 sEmptyName = new Name1(\"\", 0, 0);\n+\n+    final int mQuad;\n+\n+    Name1(String name, int hash, int quad)\n+    {\n+        super(name, hash);\n+        mQuad = quad;\n+    }\n+\n+    final static Name1 getEmptyName() { return sEmptyName; }\n+\n+    @Override\n+    public boolean equals(int quad)\n+    {\n+        return (quad == mQuad);\n+    }\n+\n+    @Override\n+    public boolean equals(int quad1, int quad2)\n+    {\n+        return (quad1 == mQuad) && (quad2 == 0);\n+    }\n+\n+    @Override\n+    public boolean equals(int[] quads, int qlen)\n+    {\n+        return (qlen == 1 && quads[0] == mQuad);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/Name2.java\n+package com.fasterxml.jackson.core.sym;\n+\n+/**\n+ * Specialized implementation of PName: can be used for short Strings\n+ * that consists of 5 to 8 bytes. Usually this means relatively short\n+ * ascii-only names.\n+ *<p>\n+ * The reason for such specialized classes is mostly space efficiency;\n+ * and to a lesser degree performance. Both are achieved for short\n+ * Strings by avoiding another level of indirection (via quad arrays)\n+ */\n+public final class Name2\n+    extends Name\n+{\n+    final int mQuad1;\n+\n+    final int mQuad2;\n+\n+    Name2(String name, int hash, int quad1, int quad2)\n+    {\n+        super(name, hash);\n+        mQuad1 = quad1;\n+        mQuad2 = quad2;\n+    }\n+\n+    @Override\n+    public boolean equals(int quad) { return false; }\n+\n+    @Override\n+    public boolean equals(int quad1, int quad2)\n+    {\n+        return (quad1 == mQuad1) && (quad2 == mQuad2);\n+    }\n+\n+    @Override\n+    public boolean equals(int[] quads, int qlen)\n+    {\n+        return (qlen == 2 && quads[0] == mQuad1 && quads[1] == mQuad2);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/Name3.java\n+package com.fasterxml.jackson.core.sym;\n+\n+/**\n+ * Specialized implementation of PName: can be used for short Strings\n+ * that consists of 9 to 12 bytes. It's the longest special purpose\n+ * implementaion; longer ones are expressed using {@link NameN}.\n+ */\n+public final class Name3\n+    extends Name\n+{\n+    final int mQuad1;\n+    final int mQuad2;\n+    final int mQuad3;\n+\n+    Name3(String name, int hash, int q1, int q2, int q3)\n+    {\n+        super(name, hash);\n+        mQuad1 = q1;\n+        mQuad2 = q2;\n+        mQuad3 = q3;\n+    }\n+\n+    // Implies quad length == 1, never matches\n+    @Override\n+    public boolean equals(int quad) { return false; }\n+\n+    // Implies quad length == 2, never matches\n+    @Override\n+    public boolean equals(int quad1, int quad2) { return false; }\n+\n+    @Override\n+    public boolean equals(int[] quads, int qlen)\n+    {\n+        return (qlen == 3)\n+            && (quads[0] == mQuad1)\n+            && (quads[1] == mQuad2)\n+            && (quads[2] == mQuad3);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/NameN.java\n+package com.fasterxml.jackson.core.sym;\n+\n+/**\n+ * Generic implementation of PName used for \"long\" names, where long\n+ * means that its byte (UTF-8) representation is 13 bytes or more.\n+ */\n+public final class NameN\n+    extends Name\n+{\n+    final int[] mQuads;\n+    final int mQuadLen;\n+\n+    NameN(String name, int hash, int[] quads, int quadLen)\n+    {\n+        super(name, hash);\n+        /* We have specialized implementations for shorter\n+         * names, so let's not allow runt instances here\n+         */\n+        if (quadLen < 3) {\n+            throw new IllegalArgumentException(\"Qlen must >= 3\");\n+        }\n+        mQuads = quads;\n+        mQuadLen = quadLen;\n+    }\n+\n+    // Implies quad length == 1, never matches\n+    @Override\n+\tpublic boolean equals(int quad) { return false; }\n+\n+    // Implies quad length == 2, never matches\n+    @Override\n+\tpublic boolean equals(int quad1, int quad2) { return false; }\n+\n+    @Override\n+\tpublic boolean equals(int[] quads, int qlen)\n+    {\n+        if (qlen != mQuadLen) {\n+            return false;\n+        }\n+\n+        /* 26-Nov-2008, tatus: Strange, but it does look like\n+         *   unrolling here is counter-productive, reducing\n+         *   speed. Perhaps it prevents inlining by HotSpot or\n+         *   something...\n+         */\n+        // Will always have >= 3 quads, can unroll\n+        /*\n+        if (quads[0] == mQuads[0]\n+            && quads[1] == mQuads[1]\n+            && quads[2] == mQuads[2]) {\n+            for (int i = 3; i < qlen; ++i) {\n+                if (quads[i] != mQuads[i]) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+        */\n+\n+        // or simpler way without unrolling:\n+        for (int i = 0; i < qlen; ++i) {\n+            if (quads[i] != mQuads[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/package-info.java\n+/**\n+ * Internal implementation classes for efficient handling of\n+ * of symbols in JSON (field names in Objects)\n+ */\n+package com.fasterxml.jackson.core.sym;\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/type/JavaType.java\n+package com.fasterxml.jackson.core.type;\n+\n+import java.lang.reflect.Modifier;\n+\n+/**\n+ * Base class for type token classes used both to contain information\n+ * and as keys for deserializers.\n+ *<p>\n+ * Instances can (only) be constructed by\n+ * {@link org.codehaus.jackson.map.type.TypeFactory}.\n+ */\n+public abstract class JavaType\n+{\n+    /**\n+     * This is the nominal type-erased Class that would be close to the\n+     * type represented (but not exactly type, due to type erasure: type\n+     * instance may have more information on this).\n+     * May be an interface or abstract class, so instantiation\n+     * may not be possible.\n+     */\n+    protected final Class<?> _class;\n+\n+    protected final int _hashCode;\n+\n+    /**\n+     * Optional handler (codec) that can be attached to indicate \n+     * what to use for handling (serializing, deserializing) values of\n+     * this specific type.\n+     *<p>\n+     * Note: untyped (i.e. caller has to cast) because it is used for\n+     * different kinds of handlers, with unrelated types.\n+     *<p>\n+     * TODO: make final and possibly promote to sub-classes\n+     */\n+    protected /*final*/ Object _valueHandler;\n+\n+    /**\n+     * Optional handler that can be attached to indicate how to handle\n+     * additional type metadata associated with this type.\n+     *<p>\n+     * Note: untyped (i.e. caller has to cast) because it is used for\n+     * different kinds of handlers, with unrelated types.\n+     *<p>\n+     * TODO: make final and possibly promote to sub-classes\n+     */\n+    protected /*final*/ Object _typeHandler;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @param raw \"Raw\" (type-erased) class for this type\n+     * @param additionalHash Additional hash code to use, in addition\n+     *   to hash code of the class name \n+     */\n+    protected JavaType(Class<?> raw, int additionalHash)\n+    {\n+        _class = raw;\n+        _hashCode = raw.getName().hashCode() + additionalHash;\n+        _valueHandler = null;\n+        _typeHandler = null;\n+    }\n+    \n+    /**\n+     * \"Copy method\" that will construct a new instance that is identical to\n+     * this instance, except that it will have specified type handler assigned.\n+     * \n+     * @return Newly created type instance\n+     */\n+    public abstract JavaType withTypeHandler(Object h);\n+\n+    /**\n+     * \"Copy method\" that will construct a new instance that is identical to\n+     * this instance, except that its content type will have specified\n+     * type handler assigned.\n+     * \n+     * @return Newly created type instance\n+     */\n+    public abstract JavaType withContentTypeHandler(Object h);\n+\n+    /**\n+     * \"Copy method\" that will construct a new instance that is identical to\n+     * this instance, except that it will have specified value handler assigned.\n+     * \n+     * @return Newly created type instance\n+     */\n+    public abstract JavaType withValueHandler(Object h);\n+\n+    /**\n+     * \"Copy method\" that will construct a new instance that is identical to\n+     * this instance, except that it will have specified content value handler assigned.\n+     * \n+     * @return Newly created type instance\n+     */\n+    public abstract JavaType withContentValueHandler(Object h);\n+    \n+    /*\n+    /**********************************************************\n+    /* Type coercion fluent factory methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method that can be called to do a \"narrowing\" conversions; that is,\n+     * to return a type with a raw class that is assignable to the raw\n+     * class of this type. If this is not possible, an\n+     * {@link IllegalArgumentException} is thrown.\n+     * If class is same as the current raw class, instance itself is\n+     * returned.\n+     */\n+    public JavaType narrowBy(Class<?> subclass)\n+    {\n+        // First: if same raw class, just return this instance\n+        if (subclass == _class) {\n+            return this;\n+        }\n+        // Otherwise, ensure compatibility\n+        _assertSubclass(subclass, _class);\n+        JavaType result = _narrow(subclass);\n+\n+        // TODO: these checks should NOT actually be needed; above should suffice:\n+        if (_valueHandler != result.getValueHandler()) {\n+            result = result.withValueHandler(_valueHandler);\n+        }\n+        if (_typeHandler != result.getTypeHandler()) {\n+            result = result.withTypeHandler(_typeHandler);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * More efficient version of {@link #narrowBy}, called by\n+     * internal framework in cases where compatibility checks\n+     * are to be skipped.\n+     */\n+    public JavaType forcedNarrowBy(Class<?> subclass)\n+    {\n+        if (subclass == _class) { // can still optimize for simple case\n+            return this;\n+        }\n+        JavaType result = _narrow(subclass);\n+        // TODO: these checks should NOT actually be needed; above should suffice:\n+        if (_valueHandler != result.getValueHandler()) {\n+            result = result.withValueHandler(_valueHandler);\n+        }\n+        if (_typeHandler != result.getTypeHandler()) {\n+            result = result.withTypeHandler(_typeHandler);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Method that can be called to do a \"widening\" conversions; that is,\n+     * to return a type with a raw class that could be assigned from this\n+     * type.\n+     * If such conversion is not possible, an\n+     * {@link IllegalArgumentException} is thrown.\n+     * If class is same as the current raw class, instance itself is\n+     * returned.\n+     */\n+    public JavaType widenBy(Class<?> superclass)\n+    {\n+        // First: if same raw class, just return this instance\n+        if (superclass == _class) {\n+            return this;\n+        }\n+        // Otherwise, ensure compatibility\n+        _assertSubclass(_class, superclass);\n+        return _widen(superclass);\n+    }\n+\n+    protected abstract JavaType _narrow(Class<?> subclass);\n+\n+    /**\n+     *<p>\n+     * Default implementation is just to call {@link #_narrow}, since\n+     * underlying type construction is usually identical\n+     */\n+    protected JavaType _widen(Class<?> superclass) {\n+        return _narrow(superclass);\n+    }\n+\n+    public abstract JavaType narrowContentsBy(Class<?> contentClass);\n+\n+    public abstract JavaType widenContentsBy(Class<?> contentClass);\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, simple accessors\n+    /**********************************************************\n+     */\n+\n+    public final Class<?> getRawClass() { return _class; }\n+\n+    /**\n+     * Method that can be used to check whether this type has\n+     * specified Class as its type erasure. Put another way, returns\n+     * true if instantiation of this Type is given (type-erased) Class.\n+     */\n+    public final boolean hasRawClass(Class<?> clz) {\n+        return _class == clz;\n+    }\n+\n+    public boolean isAbstract() {\n+        return Modifier.isAbstract(_class.getModifiers());\n+    }\n+\n+    /**\n+     * Convenience method for checking whether underlying Java type\n+     * is a concrete class or not: abstract classes and interfaces\n+     * are not.\n+     */\n+    public boolean isConcrete() {\n+        int mod = _class.getModifiers();\n+        if ((mod & (Modifier.INTERFACE | Modifier.ABSTRACT)) == 0) {\n+            return true;\n+        }\n+        /* 19-Feb-2010, tatus: Holy mackarel; primitive types\n+         *    have 'abstract' flag set...\n+         */\n+        if (_class.isPrimitive()) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public boolean isThrowable() {\n+        return Throwable.class.isAssignableFrom(_class);\n+    }\n+\n+    public boolean isArrayType() { return false; }\n+\n+    public final boolean isEnumType() { return _class.isEnum(); }\n+\n+    public final boolean isInterface() { return _class.isInterface(); }\n+\n+    public final boolean isPrimitive() { return _class.isPrimitive(); }\n+\n+    public final boolean isFinal() { return Modifier.isFinal(_class.getModifiers()); }\n+\n+    /**\n+     * @return True if type represented is a container type; this includes\n+     *    array, Map and Collection types.\n+     */\n+    public abstract boolean isContainerType();\n+\n+    /**\n+     * @return True if type is either true {@link java.util.Collection} type,\n+     *    or something similar (meaning it has at least one type parameter,\n+     *    which describes type of contents)\n+     */\n+    public boolean isCollectionLikeType() { return false; }\n+\n+    /**\n+     * @return True if type is either true {@link java.util.Map} type,\n+     *    or something similar (meaning it has at least two type parameter;\n+     *    first one describing key type, second value type)\n+     */\n+    public boolean isMapLikeType() { return false; }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, type parameter access\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method that can be used to find out if the type directly declares generic\n+     * parameters (for its direct super-class and/or super-interfaces).\n+     */\n+    public boolean hasGenericTypes()\n+    {\n+        return containedTypeCount() > 0;\n+    }\n+    \n+    /**\n+     * Method for accessing key type for this type, assuming type\n+     * has such a concept (only Map types do)\n+     */\n+    public JavaType getKeyType() { return null; }\n+\n+    /**\n+     * Method for accessing content type of this type, if type has\n+     * such a thing: simple types do not, structured types do\n+     * (like arrays, Collections and Maps)\n+     */\n+    public JavaType getContentType() { return null; }\n+\n+    /**\n+     * Method for checking how many contained types this type\n+     * has. Contained types are usually generic types, so that\n+     * generic Maps have 2 contained types.\n+     */\n+    public int containedTypeCount() { return 0; }\n+\n+    /**\n+     * Method for accessing definitions of contained (\"child\")\n+     * types.\n+     * \n+     * @param index Index of contained type to return\n+     * \n+     * @return Contained type at index, or null if no such type\n+     *    exists (no exception thrown)\n+     */\n+    public JavaType containedType(int index) { return null; }\n+    \n+    /**\n+     * Method for accessing name of type variable in indicated\n+     * position. If no name is bound, will use placeholders (derived\n+     * from 0-based index); if no type variable or argument exists\n+     * with given index, null is returned.\n+     * \n+     * @param index Index of contained type to return\n+     * \n+     * @return Contained type at index, or null if no such type\n+     *    exists (no exception thrown)\n+     */\n+    public String containedTypeName(int index) { return null; }\n+\n+    /*\n+    /**********************************************************\n+    /* Semi-public API, accessing handlers\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method for accessing value handler associated with this type, if any\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T getValueHandler() { return (T) _valueHandler; }\n+\n+    /**\n+     * Method for accessing type handler associated with this type, if any\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T getTypeHandler() { return (T) _typeHandler; }\n+\n+    /*\n+    /**********************************************************\n+    /* Support for producing signatures (1.6+)\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method that can be used to serialize type into form from which\n+     * it can be fully deserialized from at a later point (using\n+     * <code>TypeFactory</code> from mapper package).\n+     * For simple types this is same as calling\n+     * {@link Class#getName}, but for structured types it may additionally\n+     * contain type information about contents.\n+     */\n+    public abstract String toCanonical();\n+\n+    /**\n+     * Method for accessing signature that contains generic\n+     * type information, in form compatible with JVM 1.5\n+     * as per JLS. It is a superset of {@link #getErasedSignature},\n+     * in that generic information can be automatically removed\n+     * if necessary (just remove outermost\n+     * angle brackets along with content inside)\n+     */\n+    public String getGenericSignature() {\n+        StringBuilder sb = new StringBuilder(40);\n+        getGenericSignature(sb);\n+        return sb.toString();        \n+    }\n+\n+    /**\n+     * \n+     * @param sb StringBuilder to append signature to\n+     * \n+     * @return StringBuilder that was passed in; returned to allow\n+     * call chaining\n+     */\n+    public abstract StringBuilder getGenericSignature(StringBuilder sb);\n+    \n+    /**\n+     * Method for accessing signature without generic\n+     * type information, in form compatible with all versions\n+     * of JVM, and specifically used for type descriptions\n+     * when generating byte code.\n+     */\n+    public String getErasedSignature() {\n+        StringBuilder sb = new StringBuilder(40);\n+        getErasedSignature(sb);\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Method for accessing signature without generic\n+     * type information, in form compatible with all versions\n+     * of JVM, and specifically used for type descriptions\n+     * when generating byte code.\n+     * \n+     * @param sb StringBuilder to append signature to\n+     * \n+     * @return StringBuilder that was passed in; returned to allow\n+     * call chaining\n+     */\n+    public abstract StringBuilder getErasedSignature(StringBuilder sb);\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    protected void _assertSubclass(Class<?> subclass, Class<?> superClass)\n+    {\n+        if (!_class.isAssignableFrom(subclass)) {\n+            throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" is not assignable to \"+_class.getName());\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Standard methods; let's make them abstract to force override\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public abstract String toString();\n+\n+    @Override\n+    public abstract boolean equals(Object o);\n+\n+    @Override\n+    public final int hashCode() { return _hashCode; }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/type/TypeReference.java\n+package com.fasterxml.jackson.core.type;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+\n+/**\n+ * This class is used to pass full generics type information, and\n+ * avoid problems with type erasure (that basically removes most\n+ * usable type references from runtime Class objects).\n+ * It is based on ideas from\n+ * <a href=\"http://gafter.blogspot.com/2006/12/super-type-tokens.html\"\n+ * >http://gafter.blogspot.com/2006/12/super-type-tokens.html</a>,\n+ * Additional idea (from a suggestion made in comments of the article)\n+ * is to require bogus implementation of <code>Comparable</code>\n+ * (any such generic interface would do, as long as it forces a method\n+ * with generic type to be implemented).\n+ * to ensure that a Type argument is indeed given.\n+ *<p>\n+ * Usage is by sub-classing: here is one way to instantiate reference\n+ * to generic type <code>List&lt;Integer></code>:\n+ *<pre>\n+ *  TypeReference ref = new TypeReference&lt;List&lt;Integer>>() { };\n+ *</pre>\n+ * which can be passed to methods that accept TypeReference.\n+ */\n+public abstract class TypeReference<T>\n+    implements Comparable<TypeReference<T>>\n+{\n+    final Type _type;\n+\n+    protected TypeReference()\n+    {\n+        Type superClass = getClass().getGenericSuperclass();\n+        if (superClass instanceof Class<?>) { // sanity check, should never happen\n+            throw new IllegalArgumentException(\"Internal error: TypeReference constructed without actual type information\");\n+        }\n+        /* 22-Dec-2008, tatu: Not sure if this case is safe -- I suspect\n+         *   it is possible to make it fail?\n+         *   But let's deal with specifc\n+         *   case when we know an actual use case, and thereby suitable\n+         *   work arounds for valid case(s) and/or error to throw\n+         *   on invalid one(s).\n+         */\n+        _type = ((ParameterizedType) superClass).getActualTypeArguments()[0];\n+    }\n+\n+    public Type getType() { return _type; }\n+\n+    /**\n+     * The only reason we define this method (and require implementation\n+     * of <code>Comparable</code>) is to prevent constructing a\n+     * reference without type information.\n+     */\n+    @Override\n+    public int compareTo(TypeReference<T> o) {\n+        // just need an implementation, not a good one... hence:\n+        return 0;\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/type/package-info.java\n+/**\n+ * Contains classes needed for type introspection, mostly used by data binding\n+ * functionality. Most of this functionality is needed to properly handled\n+ * generic types, and to simplify and unify processing of things Jackson needs\n+ * to determine how contained types (of {@link java.util.Collection} and\n+ * {@link java.util.Map} classes) are to be handled.\n+ */\n+package com.fasterxml.jackson.core.type;\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/util/BufferRecycler.java\n+package com.fasterxml.jackson.core.util;\n+\n+/**\n+ * This is a small utility class, whose main functionality is to allow\n+ * simple reuse of raw byte/char buffers. It is usually used through\n+ * <code>ThreadLocal</code> member of the owning class pointing to\n+ * instance of this class through a <code>SoftReference</code>. The\n+ * end result is a low-overhead GC-cleanable recycling: hopefully\n+ * ideal for use by stream readers.\n+ */\n+public class BufferRecycler\n+{\n+    public final static int DEFAULT_WRITE_CONCAT_BUFFER_LEN = 2000;\n+    \n+    public enum ByteBufferType {\n+        READ_IO_BUFFER(4000)\n+        /**\n+         * Buffer used for temporarily storing encoded content; used\n+         * for example by UTF-8 encoding writer\n+         */\n+        ,WRITE_ENCODING_BUFFER(4000)\n+\n+        /**\n+         * Buffer used for temporarily concatenating output; used for\n+         * example when requesting output as byte array.\n+         */\n+        ,WRITE_CONCAT_BUFFER(2000)\n+        ;\n+            \n+        private final int size;\n+\n+        ByteBufferType(int size) { this.size = size; }\n+    }\n+\n+    public enum CharBufferType {\n+        TOKEN_BUFFER(2000) // Tokenizable input\n+            ,CONCAT_BUFFER(2000) // concatenated output\n+            ,TEXT_BUFFER(200) // Text content from input\n+            ,NAME_COPY_BUFFER(200) // Temporary buffer for getting name characters\n+            ;\n+        \n+        private final int size;\n+\n+        CharBufferType(int size) { this.size = size; }\n+    }\n+\n+    final protected byte[][] _byteBuffers = new byte[ByteBufferType.values().length][];\n+    final protected char[][] _charBuffers = new char[CharBufferType.values().length][];\n+\n+    public BufferRecycler() { }\n+\n+    public final byte[] allocByteBuffer(ByteBufferType type)\n+    {\n+        int ix = type.ordinal();\n+        byte[] buffer = _byteBuffers[ix];\n+        if (buffer == null) {\n+            buffer = balloc(type.size);\n+        } else {\n+            _byteBuffers[ix] = null;\n+        }\n+        return buffer;\n+    }\n+\n+    public final void releaseByteBuffer(ByteBufferType type, byte[] buffer)\n+    {\n+        _byteBuffers[type.ordinal()] = buffer;\n+    }\n+\n+    public final char[] allocCharBuffer(CharBufferType type)\n+    {\n+        return allocCharBuffer(type, 0);\n+    }\n+\n+    public final char[] allocCharBuffer(CharBufferType type, int minSize)\n+    {\n+        if (type.size > minSize) {\n+            minSize = type.size;\n+        }\n+        int ix = type.ordinal();\n+        char[] buffer = _charBuffers[ix];\n+        if (buffer == null || buffer.length < minSize) {\n+            buffer = calloc(minSize);\n+        } else {\n+            _charBuffers[ix] = null;\n+        }\n+        return buffer;\n+    }\n+\n+    public final void releaseCharBuffer(CharBufferType type, char[] buffer)\n+    {\n+        _charBuffers[type.ordinal()] = buffer;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Actual allocations separated for easier debugging/profiling\n+    /**********************************************************\n+     */\n+\n+    private final byte[] balloc(int size)\n+    {\n+        return new byte[size];\n+    }\n+\n+    private final char[] calloc(int size)\n+    {\n+        return new char[size];\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/util/ByteArrayBuilder.java\n+/* Jackson JSON-processor.\n+ *\n+ * Copyright (c) 2007- Tatu Saloranta, tatu.saloranta@iki.fi\n+ *\n+ * Licensed under the License specified in file LICENSE, included with\n+ * the source code and binary code bundles.\n+ * You may not use this file except in compliance with the License.\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.fasterxml.jackson.core.util;\n+\n+import java.io.OutputStream;\n+import java.util.*;\n+\n+/**\n+ * Helper class that is similar to {@link java.io.ByteArrayOutputStream}\n+ * in usage, but more geared to Jackson use cases internally.\n+ * Specific changes include segment storage (no need to have linear\n+ * backing buffer, can avoid reallocs, copying), as well API\n+ * not based on {@link java.io.OutputStream}. In short, a very much\n+ * specialized builder object.\n+ *<p>\n+ * Since version 1.5, also implements {@link OutputStream} to allow\n+ * efficient aggregation of output content as a byte array, similar\n+ * to how {@link java.io.ByteArrayOutputStream} works, but somewhat more\n+ * efficiently for many use cases.\n+ */\n+public final class ByteArrayBuilder\n+    extends OutputStream\n+{\n+    private final static byte[] NO_BYTES = new byte[0];\n+    \n+    /**\n+     * Size of the first block we will allocate.\n+     */\n+    private final static int INITIAL_BLOCK_SIZE = 500;\n+    \n+    /**\n+     * Maximum block size we will use for individual non-aggregated\n+     * blocks. Let's limit to using 256k chunks.\n+     */\n+    private final static int MAX_BLOCK_SIZE = (1 << 18);\n+    \n+    final static int DEFAULT_BLOCK_ARRAY_SIZE = 40;\n+\n+    /**\n+     * Optional buffer recycler instance that we can use for allocating\n+     * the first block.\n+     * \n+     * @since 1.5\n+     */\n+    private final BufferRecycler _bufferRecycler;\n+    \n+    private final LinkedList<byte[]> _pastBlocks = new LinkedList<byte[]>();\n+    \n+    /**\n+     * Number of bytes within byte arrays in {@link _pastBlocks}.\n+     */\n+    private int _pastLen;\n+\n+    private byte[] _currBlock;\n+\n+    private int _currBlockPtr;\n+    \n+    public ByteArrayBuilder() { this(null); }\n+\n+    public ByteArrayBuilder(BufferRecycler br) { this(br, INITIAL_BLOCK_SIZE); }\n+\n+    public ByteArrayBuilder(int firstBlockSize) { this(null, firstBlockSize); }\n+\n+    public ByteArrayBuilder(BufferRecycler br, int firstBlockSize)\n+    {\n+        _bufferRecycler = br;\n+        if (br == null) {\n+            _currBlock = new byte[firstBlockSize];\n+        } else {\n+            _currBlock = br.allocByteBuffer(BufferRecycler.ByteBufferType.WRITE_CONCAT_BUFFER);\n+        }\n+    }\n+\n+    public void reset()\n+    {\n+        _pastLen = 0;\n+        _currBlockPtr = 0;\n+\n+        if (!_pastBlocks.isEmpty()) {\n+            _pastBlocks.clear();\n+        }\n+    }\n+\n+    /**\n+     * Clean up method to call to release all buffers this object may be\n+     * using. After calling the method, no other accessors can be used (and\n+     * attempt to do so may result in an exception)\n+     */\n+    public void release() {\n+        reset();\n+        if (_bufferRecycler != null && _currBlock != null) {\n+            _bufferRecycler.releaseByteBuffer(BufferRecycler.ByteBufferType.WRITE_CONCAT_BUFFER, _currBlock);\n+            _currBlock = null;\n+        }\n+    }\n+\n+    public void append(int i)\n+    {\n+        if (_currBlockPtr >= _currBlock.length) {\n+            _allocMore();\n+        }\n+        _currBlock[_currBlockPtr++] = (byte) i;\n+    }\n+\n+    public void appendTwoBytes(int b16)\n+    {\n+        if ((_currBlockPtr + 1) < _currBlock.length) {\n+            _currBlock[_currBlockPtr++] = (byte) (b16 >> 8);\n+            _currBlock[_currBlockPtr++] = (byte) b16;\n+        } else {\n+            append(b16 >> 8);\n+            append(b16);\n+        }\n+    }\n+\n+    public void appendThreeBytes(int b24)\n+    {\n+        if ((_currBlockPtr + 2) < _currBlock.length) {\n+            _currBlock[_currBlockPtr++] = (byte) (b24 >> 16);\n+            _currBlock[_currBlockPtr++] = (byte) (b24 >> 8);\n+            _currBlock[_currBlockPtr++] = (byte) b24;\n+        } else {\n+            append(b24 >> 16);\n+            append(b24 >> 8);\n+            append(b24);\n+        }\n+    }\n+\n+    /**\n+     * Method called when results are finalized and we can get the\n+     * full aggregated result buffer to return to the caller\n+     */\n+    public byte[] toByteArray()\n+    {\n+        int totalLen = _pastLen + _currBlockPtr;\n+        \n+        if (totalLen == 0) { // quick check: nothing aggregated?\n+            return NO_BYTES;\n+        }\n+        \n+        byte[] result = new byte[totalLen];\n+        int offset = 0;\n+\n+        for (byte[] block : _pastBlocks) {\n+            int len = block.length;\n+            System.arraycopy(block, 0, result, offset, len);\n+            offset += len;\n+        }\n+        System.arraycopy(_currBlock, 0, result, offset, _currBlockPtr);\n+        offset += _currBlockPtr;\n+        if (offset != totalLen) { // just a sanity check\n+            throw new RuntimeException(\"Internal error: total len assumed to be \"+totalLen+\", copied \"+offset+\" bytes\");\n+        }\n+        // Let's only reset if there's sizable use, otherwise will get reset later on\n+        if (!_pastBlocks.isEmpty()) {\n+            reset();\n+        }\n+        return result;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Non-stream API (similar to TextBuffer), since 1.6\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called when starting \"manual\" output: will clear out\n+     * current state and return the first segment buffer to fill\n+     * \n+     * @since 1.6\n+     */\n+    public byte[] resetAndGetFirstSegment() {\n+        reset();\n+        return _currBlock;\n+    }\n+\n+    /**\n+     * Method called when the current segment buffer is full; will\n+     * append to current contents, allocate a new segment buffer\n+     * and return it\n+     * \n+     * @since 1.6\n+     */\n+    public byte[] finishCurrentSegment() {\n+        _allocMore();\n+        return _currBlock;\n+    }\n+\n+    /**\n+     * Method that will complete \"manual\" output process, coalesce\n+     * content (if necessary) and return results as a contiguous buffer.\n+     * \n+     * @param lastBlockLength Amount of content in the current segment\n+     * buffer.\n+     * \n+     * @return Coalesced contents\n+     */\n+    public byte[] completeAndCoalesce(int lastBlockLength)\n+    {\n+        _currBlockPtr = lastBlockLength;\n+        return toByteArray();\n+    }\n+\n+    public byte[] getCurrentSegment() {\n+        return _currBlock;\n+    }\n+\n+    public void setCurrentSegmentLength(int len) {\n+        _currBlockPtr = len;\n+    }\n+\n+    public int getCurrentSegmentLength() {\n+        return _currBlockPtr;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* OutputStream implementation\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public void write(byte[] b) {\n+        write(b, 0, b.length);\n+    }\n+\n+    @Override\n+    public void write(byte[] b, int off, int len)\n+    {\n+        while (true) {\n+            int max = _currBlock.length - _currBlockPtr;\n+            int toCopy = Math.min(max, len);\n+            if (toCopy > 0) {\n+                System.arraycopy(b, off, _currBlock, _currBlockPtr, toCopy);\n+                off += toCopy;\n+                _currBlockPtr += toCopy;\n+                len -= toCopy;\n+            }\n+            if (len <= 0) break;\n+            _allocMore();\n+        }\n+    }\n+\n+    @Override\n+    public void write(int b) {\n+        append(b);\n+    }\n+\n+    @Override public void close() { /* NOP */ }\n+\n+    @Override public void flush() { /* NOP */ }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+    \n+    private void _allocMore()\n+    {\n+        _pastLen += _currBlock.length;\n+\n+        /* Let's allocate block that's half the total size, except\n+         * never smaller than twice the initial block size.\n+         * The idea is just to grow with reasonable rate, to optimize\n+         * between minimal number of chunks and minimal amount of\n+         * wasted space.\n+         */\n+        int newSize = Math.max((_pastLen >> 1), (INITIAL_BLOCK_SIZE + INITIAL_BLOCK_SIZE));\n+        // plus not to exceed max we define...\n+        if (newSize > MAX_BLOCK_SIZE) {\n+            newSize = MAX_BLOCK_SIZE;\n+        }\n+        _pastBlocks.add(_currBlock);\n+        _currBlock = new byte[newSize];\n+        _currBlockPtr = 0;\n+    }\n+\n+}\n+\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java\n+package com.fasterxml.jackson.core.util;\n+\n+import java.io.*;\n+import java.util.Arrays;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+/**\n+ * Default {@link PrettyPrinter} implementation that uses 2-space\n+ * indentation with platform-default linefeeds.\n+ * Usually this class is not instantiated directly, but instead\n+ * method {@link JsonGenerator#useDefaultPrettyPrinter} is\n+ * used, which will use an instance of this class for operation.\n+ */\n+public class DefaultPrettyPrinter\n+    implements PrettyPrinter\n+{\n+    /**\n+     * Interface that defines objects that can produce indentation used\n+     * to separate object entries and array values. Indentation in this\n+     * context just means insertion of white space, independent of whether\n+     * linefeeds are output.\n+     */\n+    public interface Indenter\n+    {\n+        public void writeIndentation(JsonGenerator jg, int level)\n+            throws IOException, JsonGenerationException;\n+\n+        /**\n+         * @return True if indenter is considered inline (does not add linefeeds),\n+         *   false otherwise\n+         */\n+        public boolean isInline();\n+    }\n+    \n+    // // // Config, indentation\n+\n+    /**\n+     * By default, let's use only spaces to separate array values.\n+     */\n+    protected Indenter _arrayIndenter = new FixedSpaceIndenter();\n+\n+    /**\n+     * By default, let's use linefeed-adding indenter for separate\n+     * object entries. We'll further configure indenter to use\n+     * system-specific linefeeds, and 2 spaces per level (as opposed to,\n+     * say, single tabs)\n+     */\n+    protected Indenter _objectIndenter = new Lf2SpacesIndenter();\n+\n+    // // // Config, other white space configuration\n+\n+    /**\n+     * By default we will add spaces around colons used to\n+     * separate object fields and values.\n+     * If disabled, will not use spaces around colon.\n+     */\n+    protected boolean _spacesInObjectEntries = true;\n+\n+    // // // State:\n+\n+    /**\n+     * Number of open levels of nesting. Used to determine amount of\n+     * indentation to use.\n+     */\n+    protected int _nesting = 0;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle (construct, configure)\n+    /**********************************************************\n+    */\n+\n+    public DefaultPrettyPrinter() { }\n+\n+    public void indentArraysWith(Indenter i)\n+    {\n+        _arrayIndenter = (i == null) ? new NopIndenter() : i;\n+    }\n+\n+    public void indentObjectsWith(Indenter i)\n+    {\n+        _objectIndenter = (i == null) ? new NopIndenter() : i;\n+    }\n+\n+    public void spacesInObjectEntries(boolean b) { _spacesInObjectEntries = b; }\n+\n+    /*\n+    /**********************************************************\n+    /* PrettyPrinter impl\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeRootValueSeparator(JsonGenerator jg)\n+        throws IOException, JsonGenerationException\n+    {\n+        jg.writeRaw(' ');\n+    }\n+\n+    @Override\n+    public void writeStartObject(JsonGenerator jg)\n+        throws IOException, JsonGenerationException\n+    {\n+        jg.writeRaw('{');\n+        if (!_objectIndenter.isInline()) {\n+            ++_nesting;\n+        }\n+    }\n+\n+    @Override\n+    public void beforeObjectEntries(JsonGenerator jg)\n+        throws IOException, JsonGenerationException\n+    {\n+        _objectIndenter.writeIndentation(jg, _nesting);\n+    }\n+\n+    /**\n+     * Method called after an object field has been output, but\n+     * before the value is output.\n+     *<p>\n+     * Default handling (without pretty-printing) will output a single\n+     * colon to separate the two. Pretty-printer is\n+     * to output a colon as well, but can surround that with other\n+     * (white-space) decoration.\n+     */\n+    @Override\n+    public void writeObjectFieldValueSeparator(JsonGenerator jg)\n+        throws IOException, JsonGenerationException\n+    {\n+        if (_spacesInObjectEntries) {\n+            jg.writeRaw(\" : \");\n+        } else {\n+            jg.writeRaw(':');\n+        }\n+    }\n+\n+    /**\n+     * Method called after an object entry (field:value) has been completely\n+     * output, and before another value is to be output.\n+     *<p>\n+     * Default handling (without pretty-printing) will output a single\n+     * comma to separate the two. Pretty-printer is\n+     * to output a comma as well, but can surround that with other\n+     * (white-space) decoration.\n+     */\n+    @Override\n+    public void writeObjectEntrySeparator(JsonGenerator jg)\n+        throws IOException, JsonGenerationException\n+    {\n+        jg.writeRaw(',');\n+        _objectIndenter.writeIndentation(jg, _nesting);\n+    }\n+\n+    @Override\n+    public void writeEndObject(JsonGenerator jg, int nrOfEntries)\n+        throws IOException, JsonGenerationException\n+    {\n+        if (!_objectIndenter.isInline()) {\n+            --_nesting;\n+        }\n+        if (nrOfEntries > 0) {\n+            _objectIndenter.writeIndentation(jg, _nesting);\n+        } else {\n+            jg.writeRaw(' ');\n+        }\n+        jg.writeRaw('}');\n+    }\n+\n+    @Override\n+    public void writeStartArray(JsonGenerator jg)\n+        throws IOException, JsonGenerationException\n+    {\n+        if (!_arrayIndenter.isInline()) {\n+            ++_nesting;\n+        }\n+        jg.writeRaw('[');\n+    }\n+\n+    @Override\n+    public void beforeArrayValues(JsonGenerator jg)\n+        throws IOException, JsonGenerationException\n+    {\n+        _arrayIndenter.writeIndentation(jg, _nesting);\n+    }\n+\n+    /**\n+     * Method called after an array value has been completely\n+     * output, and before another value is to be output.\n+     *<p>\n+     * Default handling (without pretty-printing) will output a single\n+     * comma to separate the two. Pretty-printer is\n+     * to output a comma as well, but can surround that with other\n+     * (white-space) decoration.\n+     */\n+    @Override\n+    public void writeArrayValueSeparator(JsonGenerator jg)\n+        throws IOException, JsonGenerationException\n+    {\n+        jg.writeRaw(',');\n+        _arrayIndenter.writeIndentation(jg, _nesting);\n+    }\n+\n+    @Override\n+    public void writeEndArray(JsonGenerator jg, int nrOfValues)\n+        throws IOException, JsonGenerationException\n+    {\n+        if (!_arrayIndenter.isInline()) {\n+            --_nesting;\n+        }\n+        if (nrOfValues > 0) {\n+            _arrayIndenter.writeIndentation(jg, _nesting);\n+        } else {\n+            jg.writeRaw(' ');\n+        }\n+        jg.writeRaw(']');\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Dummy implementation that adds no indentation whatsoever\n+     */\n+    public static class NopIndenter\n+        implements Indenter\n+    {\n+        public NopIndenter() { }\n+        @Override\n+        public void writeIndentation(JsonGenerator jg, int level) { }\n+        @Override\n+        public boolean isInline() { return true; }\n+    }\n+\n+    /**\n+     * This is a very simple indenter that only every adds a\n+     * single space for indentation. It is used as the default\n+     * indenter for array values.\n+     */\n+    public static class FixedSpaceIndenter\n+        implements Indenter\n+    {\n+        public FixedSpaceIndenter() { }\n+\n+        @Override\n+        public void writeIndentation(JsonGenerator jg, int level)\n+            throws IOException, JsonGenerationException\n+        {\n+            jg.writeRaw(' ');\n+        }\n+\n+        @Override\n+        public boolean isInline() { return true; }\n+    }\n+\n+    /**\n+     * Default linefeed-based indenter uses system-specific linefeeds and\n+     * 2 spaces for indentation per level.\n+     */\n+    public static class Lf2SpacesIndenter\n+        implements Indenter\n+    {\n+        final static String SYSTEM_LINE_SEPARATOR;\n+        static {\n+            String lf = null;\n+            try {\n+                lf = System.getProperty(\"line.separator\");\n+            } catch (Throwable t) { } // access exception?\n+            SYSTEM_LINE_SEPARATOR = (lf == null) ? \"\\n\" : lf;\n+        }\n+\n+        final static int SPACE_COUNT = 64;\n+        final static char[] SPACES = new char[SPACE_COUNT];\n+        static {\n+            Arrays.fill(SPACES, ' ');\n+        }\n+\n+        public Lf2SpacesIndenter() { }\n+\n+        @Override\n+        public boolean isInline() { return false; }\n+\n+        @Override\n+        public void writeIndentation(JsonGenerator jg, int level)\n+            throws IOException, JsonGenerationException\n+        {\n+            jg.writeRaw(SYSTEM_LINE_SEPARATOR);\n+            level += level; // 2 spaces per level\n+            while (level > SPACE_COUNT) { // should never happen but...\n+                jg.writeRaw(SPACES, 0, SPACE_COUNT); \n+                level -= SPACES.length;\n+            }\n+            jg.writeRaw(SPACES, 0, level);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/util/InternCache.java\n+package com.fasterxml.jackson.core.util;\n+\n+import java.util.Map;\n+import java.util.LinkedHashMap;\n+\n+/**\n+ * Singleton class that adds a simple first-level cache in front of\n+ * regular String.intern() functionality. This is done as a minor\n+ * performance optimization, to avoid calling native intern() method\n+ * in cases where same String is being interned multiple times.\n+ *<p>\n+ * Note: that this class extends {@link LinkedHashMap} is an implementation\n+ * detail -- no code should ever directly call Map methods.\n+ */\n+@SuppressWarnings(\"serial\")\n+public final class InternCache\n+    extends LinkedHashMap<String,String>\n+{\n+    /**\n+     * Size to use is somewhat arbitrary, so let's choose something that's\n+     * neither too small (low hit ratio) nor too large (waste of memory)\n+     */\n+    private final static int MAX_ENTRIES = 192;\n+\n+    public final static InternCache instance = new InternCache();\n+\n+    private InternCache() {\n+        super(MAX_ENTRIES, 0.8f, true);\n+    }\n+\n+    @Override\n+    protected boolean removeEldestEntry(Map.Entry<String,String> eldest)\n+    {\n+        return size() > MAX_ENTRIES;\n+    }\n+\n+    public synchronized String intern(String input)\n+    {\n+        String result = get(input);\n+        if (result == null) {\n+            result = input.intern();\n+            put(result, result);\n+        }\n+        return result;\n+    }\n+\n+\n+}\n+\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n+package com.fasterxml.jackson.core.util;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.io.SerializedString;\n+\n+public class JsonGeneratorDelegate extends JsonGenerator\n+{\n+    /**\n+     * Delegate object that method calls are delegated to.\n+     */\n+    protected JsonGenerator delegate;\n+\n+    public JsonGeneratorDelegate(JsonGenerator d) {\n+        delegate = d;\n+    }   \n+\n+    @Override\n+    public void close() throws IOException {\n+        delegate.close();\n+    }\n+\n+    @Override\n+    public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException {\n+        delegate.copyCurrentEvent(jp);\n+    }\n+\n+    @Override\n+    public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException {\n+        delegate.copyCurrentStructure(jp);\n+    }\n+\n+    @Override\n+    public JsonGenerator disable(Feature f) {\n+        return delegate.disable(f);\n+    }\n+\n+    @Override\n+    public JsonGenerator enable(Feature f) {\n+        return delegate.enable(f);\n+    }\n+\n+    @Override\n+    public void flush() throws IOException {\n+        delegate.flush();\n+    }\n+\n+    @Override\n+    public ObjectCodec getCodec() {\n+        return delegate.getCodec();\n+    }\n+\n+    @Override\n+    public JsonStreamContext getOutputContext() {\n+        return delegate.getOutputContext();\n+    }\n+\n+    @Override\n+    public void setSchema(FormatSchema schema) {\n+        delegate.setSchema(schema);\n+    }\n+    \n+    @Override\n+    public boolean canUseSchema(FormatSchema schema) {\n+        return delegate.canUseSchema(schema);\n+    }\n+    \n+    @Override\n+    public Version version() {\n+        return delegate.version();\n+    }\n+    \n+    @Override\n+    public Object getOutputTarget() {\n+        return delegate.getOutputTarget();\n+    }\n+    \n+    @Override\n+    public boolean isClosed() {\n+        return delegate.isClosed();\n+    }\n+\n+    @Override\n+    public boolean isEnabled(Feature f) {\n+        return delegate.isEnabled(f);\n+    }\n+\n+    @Override\n+    public JsonGenerator setCodec(ObjectCodec oc) {\n+        delegate.setCodec(oc);\n+        return this;\n+    }\n+\n+    @Override\n+    public JsonGenerator useDefaultPrettyPrinter() {\n+        delegate.useDefaultPrettyPrinter();\n+        return this;\n+    }\n+\n+    @Override\n+    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len)\n+        throws IOException, JsonGenerationException\n+    {\n+        delegate.writeBinary(b64variant, data, offset, len);\n+    }\n+\n+    @Override\n+    public void writeBoolean(boolean state) throws IOException, JsonGenerationException {\n+        delegate.writeBoolean(state);\n+    }\n+\n+    @Override\n+    public void writeEndArray() throws IOException, JsonGenerationException {\n+        delegate.writeEndArray();\n+    }\n+\n+    @Override\n+    public void writeEndObject() throws IOException, JsonGenerationException {\n+        delegate.writeEndObject();\n+    }\n+\n+    @Override\n+    public void writeFieldName(String name)\n+        throws IOException, JsonGenerationException\n+    {\n+        delegate.writeFieldName(name);\n+    }\n+\n+    @Override\n+    public void writeFieldName(SerializedString name)\n+        throws IOException, JsonGenerationException\n+    {\n+        delegate.writeFieldName(name);\n+    }\n+\n+    @Override\n+    public void writeFieldName(SerializableString name)\n+        throws IOException, JsonGenerationException\n+    {\n+        delegate.writeFieldName(name);\n+    }\n+    \n+    @Override\n+    public void writeNull() throws IOException, JsonGenerationException {\n+        delegate.writeNull();\n+    }\n+\n+    @Override\n+    public void writeNumber(int v) throws IOException, JsonGenerationException {\n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(long v) throws IOException, JsonGenerationException {\n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(BigInteger v) throws IOException,\n+            JsonGenerationException {\n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(double v) throws IOException,\n+            JsonGenerationException {\n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(float v) throws IOException,\n+            JsonGenerationException {\n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(BigDecimal v) throws IOException,\n+            JsonGenerationException {\n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(String encodedValue) throws IOException, JsonGenerationException, UnsupportedOperationException {\n+        delegate.writeNumber(encodedValue);\n+    }\n+\n+    @Override\n+    public void writeObject(Object pojo) throws IOException,JsonProcessingException {\n+        delegate.writeObject(pojo);\n+    }\n+\n+    @Override\n+    public void writeRaw(String text) throws IOException, JsonGenerationException {\n+        delegate.writeRaw(text);\n+    }\n+\n+    @Override\n+    public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException {\n+        delegate.writeRaw(text, offset, len);\n+    }\n+\n+    @Override\n+    public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException {\n+        delegate.writeRaw(text, offset, len);\n+    }\n+\n+    @Override\n+    public void writeRaw(char c) throws IOException, JsonGenerationException {\n+        delegate.writeRaw(c);\n+    }\n+\n+    @Override\n+    public void writeRawValue(String text) throws IOException, JsonGenerationException {\n+        delegate.writeRawValue(text);\n+    }\n+\n+    @Override\n+    public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException {\n+         delegate.writeRawValue(text, offset, len);\n+    }\n+\n+    @Override\n+    public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException {\n+         delegate.writeRawValue(text, offset, len);\n+    }\n+\n+    @Override\n+    public void writeStartArray() throws IOException, JsonGenerationException {\n+         delegate.writeStartArray();\n+    }\n+\n+    @Override\n+    public void writeStartObject() throws IOException, JsonGenerationException {\n+        delegate.writeStartObject();\n+    }\n+\n+    @Override\n+    public void writeString(String text) throws IOException,JsonGenerationException {\n+        delegate.writeString(text);\n+    }\n+\n+    @Override\n+    public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException {\n+        delegate.writeString(text, offset, len);\n+    }\n+\n+    @Override\n+    public void writeString(SerializableString text) throws IOException, JsonGenerationException {\n+        delegate.writeString(text);\n+    }\n+\n+    @Override\n+    public void writeRawUTF8String(byte[] text, int offset, int length)\n+        throws IOException, JsonGenerationException\n+    {\n+        delegate.writeRawUTF8String(text, offset, length);\n+    }\n+\n+    @Override\n+    public void writeUTF8String(byte[] text, int offset, int length)\n+        throws IOException, JsonGenerationException\n+    {\n+        delegate.writeUTF8String(text, offset, length);\n+    }\n+    \n+    @Override\n+    public void writeTree(JsonNode rootNode) throws IOException, JsonProcessingException {\n+        delegate.writeTree(rootNode);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonParserDelegate.java\n+package com.fasterxml.jackson.core.util;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+/**\n+ * Helper class that implements\n+ * <a href=\"http://en.wikipedia.org/wiki/Delegation_pattern\">delegation pattern</a> for {@link JsonParser},\n+ * to allow for simple overridability of basic parsing functionality.\n+ * The idea is that any functionality to be modified can be simply\n+ * overridden; and anything else will be delegated by default.\n+ * \n+ * @since 1.4\n+ */\n+public class JsonParserDelegate extends JsonParser\n+{\n+    /**\n+     * Delegate object that method calls are delegated to.\n+     */\n+    protected JsonParser delegate;\n+\n+    public JsonParserDelegate(JsonParser d) {\n+        delegate = d;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, configuration\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void setCodec(ObjectCodec c) {\n+        delegate.setCodec(c);\n+    }\n+\n+    @Override\n+    public ObjectCodec getCodec() {\n+        return delegate.getCodec();\n+    }\n+\n+    @Override\n+    public JsonParser enable(Feature f) {\n+        delegate.enable(f);\n+        return this;\n+    }\n+\n+    @Override\n+    public JsonParser disable(Feature f) {\n+        delegate.disable(f);\n+        return this;\n+    }\n+ \n+    @Override\n+    public boolean isEnabled(Feature f) {\n+        return delegate.isEnabled(f);\n+    }\n+\n+    @Override\n+    public void setSchema(FormatSchema schema) {\n+        delegate.setSchema(schema);\n+    }\n+\n+    @Override\n+    public boolean canUseSchema(FormatSchema schema) {\n+        return delegate.canUseSchema(schema);\n+    }\n+    \n+    @Override\n+    public Version version() {\n+        return delegate.version();\n+    }\n+\n+    @Override\n+    public Object getInputSource() {\n+        return delegate.getInputSource();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Closeable impl\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void close() throws IOException {\n+        delegate.close();\n+    }\n+\n+    @Override\n+    public boolean isClosed() {\n+        return delegate.isClosed();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, token accessors\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JsonToken getCurrentToken() {\n+        return delegate.getCurrentToken();\n+    }\n+\n+    @Override\n+    public boolean hasCurrentToken() {\n+        return delegate.hasCurrentToken();\n+    }\n+\n+    @Override\n+    public void clearCurrentToken() {\n+        delegate.clearCurrentToken();        \n+    }\n+\n+    @Override\n+    public String getCurrentName() throws IOException, JsonParseException {\n+        return delegate.getCurrentName();\n+    }\n+\n+    @Override\n+    public JsonLocation getCurrentLocation() {\n+        return delegate.getCurrentLocation();\n+    }\n+\n+    @Override\n+    public JsonToken getLastClearedToken() {\n+        return delegate.getLastClearedToken();\n+    }\n+\n+    @Override\n+    public JsonStreamContext getParsingContext() {\n+        return delegate.getParsingContext();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, access to token information, text\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String getText() throws IOException, JsonParseException {\n+        return delegate.getText();\n+    }\n+\n+    @Override\n+    public char[] getTextCharacters() throws IOException, JsonParseException {\n+        return delegate.getTextCharacters();\n+    }\n+\n+    @Override\n+    public int getTextLength() throws IOException, JsonParseException {\n+        return delegate.getTextLength();\n+    }\n+\n+    @Override\n+    public int getTextOffset() throws IOException, JsonParseException {\n+        return delegate.getTextOffset();\n+    }\n+\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, access to token information, numeric\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public BigInteger getBigIntegerValue() throws IOException,JsonParseException {\n+        return delegate.getBigIntegerValue();\n+    }\n+\n+    @Override\n+    public byte getByteValue() throws IOException, JsonParseException {\n+        return delegate.getByteValue();\n+    }\n+\n+    @Override\n+    public short getShortValue() throws IOException, JsonParseException {\n+        return delegate.getShortValue();\n+    }\n+\n+    @Override\n+    public BigDecimal getDecimalValue() throws IOException, JsonParseException {\n+        return delegate.getDecimalValue();\n+    }\n+\n+    @Override\n+    public double getDoubleValue() throws IOException, JsonParseException {\n+        return delegate.getDoubleValue();\n+    }\n+\n+    @Override\n+    public float getFloatValue() throws IOException, JsonParseException {\n+        return delegate.getFloatValue();\n+    }\n+\n+    @Override\n+    public int getIntValue() throws IOException, JsonParseException {\n+        return delegate.getIntValue();\n+    }\n+\n+    @Override\n+    public long getLongValue() throws IOException, JsonParseException {\n+        return delegate.getLongValue();\n+    }\n+\n+    @Override\n+    public NumberType getNumberType() throws IOException, JsonParseException {\n+        return delegate.getNumberType();\n+    }\n+\n+    @Override\n+    public Number getNumberValue() throws IOException, JsonParseException {\n+        return delegate.getNumberValue();\n+    }\n+\n+    @Override\n+    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException {\n+        return delegate.getBinaryValue(b64variant);\n+    }\n+\n+    @Override\n+    public JsonLocation getTokenLocation() {\n+        return delegate.getTokenLocation();\n+    }\n+\n+    @Override\n+    public JsonToken nextToken() throws IOException, JsonParseException {\n+        return delegate.nextToken();\n+    }\n+    \n+    @Override\n+    public JsonParser skipChildren() throws IOException, JsonParseException {\n+        delegate.skipChildren();\n+        // NOTE: must NOT delegate this method to delegate, needs to be self-reference for chaining\n+        return this;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonParserSequence.java\n+package com.fasterxml.jackson.core.util;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+/**\n+ * Helper class that can be used to sequence multiple physical\n+ * {@link JsonParser}s to create a single logical sequence of\n+ * tokens, as a single {@link JsonParser}.\n+ *<p>\n+ * Fairly simple use of {@link JsonParserDelegate}: only need\n+ * to override {@link #nextToken} to handle transition\n+ * \n+ * @author tatu\n+ * @since 1.5\n+ */\n+public class JsonParserSequence extends JsonParserDelegate\n+{\n+    /**\n+     * Parsers other than the first one (which is initially assigned\n+     * as delegate)\n+     */\n+    protected final JsonParser[] _parsers;\n+    \n+    /**\n+     * Index of the next parser in {@link #_parsers}.\n+     */\n+    protected int _nextParser;\n+    \n+    /*\n+     *******************************************************\n+     * Construction\n+     *******************************************************\n+     */\n+\n+    protected JsonParserSequence(JsonParser[] parsers)\n+    {\n+        super(parsers[0]);\n+        _parsers = parsers;\n+        _nextParser = 1;\n+    }\n+\n+    /**\n+     * Method that will construct a parser (possibly a sequence) that\n+     * contains all given sub-parsers.\n+     * All parsers given are checked to see if they are sequences: and\n+     * if so, they will be \"flattened\", that is, contained parsers are\n+     * directly added in a new sequence instead of adding sequences\n+     * within sequences. This is done to minimize delegation depth,\n+     * ideally only having just a single level of delegation.\n+     */\n+    public static JsonParserSequence createFlattened(JsonParser first, JsonParser second)\n+    {\n+        if (!(first instanceof JsonParserSequence || second instanceof JsonParserSequence)) {\n+            // simple:\n+            return new JsonParserSequence(new JsonParser[] { first, second });\n+        }\n+        ArrayList<JsonParser> p = new ArrayList<JsonParser>();\n+        if (first instanceof JsonParserSequence) {\n+            ((JsonParserSequence) first).addFlattenedActiveParsers(p);\n+        } else {\n+            p.add(first);\n+        }\n+        if (second instanceof JsonParserSequence) {\n+            ((JsonParserSequence) second).addFlattenedActiveParsers(p);\n+        } else {\n+            p.add(second);\n+        }\n+        return new JsonParserSequence(p.toArray(new JsonParser[p.size()]));\n+    }\n+\n+    protected void addFlattenedActiveParsers(List<JsonParser> result)\n+    {\n+        for (int i = _nextParser-1, len = _parsers.length; i < len; ++i) {\n+            JsonParser p = _parsers[i];\n+            if (p instanceof JsonParserSequence) {\n+                ((JsonParserSequence) p).addFlattenedActiveParsers(result);\n+            } else {\n+                result.add(p);\n+            }\n+        }\n+    }\n+    \n+    /*\n+     *******************************************************\n+     * Overridden methods, needed: cases where default\n+     * delegation does not work\n+     *******************************************************\n+     */\n+    \n+    @Override\n+    public void close() throws IOException\n+    {\n+        do {\n+            delegate.close();\n+        } while (switchToNext());\n+    }\n+\n+    @Override\n+    public JsonToken nextToken() throws IOException, JsonParseException\n+    {\n+        JsonToken t = delegate.nextToken();\n+        if (t != null) return t;\n+        while (switchToNext()) {\n+            t = delegate.nextToken();\n+            if (t != null) return t;\n+        }\n+        return null;\n+    }\n+\n+    /*\n+    /*******************************************************\n+    /* Additional extended API\n+    /*******************************************************\n+     */\n+\n+    /**\n+     * Method that is most useful for debugging or testing;\n+     * returns actual number of underlying parsers sequence\n+     * was constructed with (nor just ones remaining active)\n+     */\n+    public int containedParsersCount() {\n+        return _parsers.length;\n+    }\n+    \n+    /*\n+    /*******************************************************\n+    /* Helper methods\n+    /*******************************************************\n+     */\n+\n+    /**\n+     * Method that will switch active parser from the current one\n+     * to next parser in sequence, if there is another parser left,\n+     * making this the new delegate. Old delegate is returned if\n+     * switch succeeds.\n+     * \n+     * @return True if switch succeeded; false otherwise\n+     */\n+    protected boolean switchToNext()\n+    {\n+        if (_nextParser >= _parsers.length) {\n+            return false;\n+        }\n+        delegate = _parsers[_nextParser++];\n+        return true;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/util/MinimalPrettyPrinter.java\n+package com.fasterxml.jackson.core.util;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.PrettyPrinter;\n+\n+/**\n+ * {@link PrettyPrinter} implementation that adds no indentation,\n+ * just implements everything necessary for value output to work\n+ * as expected, and provide simpler extension points to allow\n+ * for creating simple custom implementations that add specific\n+ * decoration or overrides. Since behavior then is very similar\n+ * to using no pretty printer at all, usually sub-classes are used.\n+ *<p>\n+ * Beyond purely minimal implementation, there is limited amount of\n+ * configurability which may be useful for actual use: for example,\n+ * it is possible to redefine separator used between root-level\n+ * values (default is single space; can be changed to line-feed).\n+ * \n+ * @since 1.6\n+ */\n+public class MinimalPrettyPrinter\n+    implements PrettyPrinter\n+{\n+    /**\n+     * Default String used for separating root values is single space.\n+     */\n+    public final static String DEFAULT_ROOT_VALUE_SEPARATOR = \" \";\n+    \n+    protected String _rootValueSeparator = DEFAULT_ROOT_VALUE_SEPARATOR;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle, construction, configuration\n+    /**********************************************************\n+     */\n+    \n+    public MinimalPrettyPrinter() {\n+        this(DEFAULT_ROOT_VALUE_SEPARATOR);\n+    }\n+\n+    /**\n+     * @since 1.9\n+     */\n+    public MinimalPrettyPrinter(String rootValueSeparator) {\n+        _rootValueSeparator = rootValueSeparator;\n+    }\n+    \n+    public void setRootValueSeparator(String sep) {\n+        _rootValueSeparator = sep;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* PrettyPrinter impl\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeRootValueSeparator(JsonGenerator jg) throws IOException, JsonGenerationException\n+    {\n+        if (_rootValueSeparator != null) {\n+            jg.writeRaw(_rootValueSeparator);    \n+        }\n+    }\n+    \n+    @Override\n+    public void writeStartObject(JsonGenerator jg)\n+        throws IOException, JsonGenerationException\n+    {\n+        jg.writeRaw('{');\n+    }\n+    \n+    @Override\n+    public void beforeObjectEntries(JsonGenerator jg)\n+        throws IOException, JsonGenerationException\n+    {\n+        // nothing special, since no indentation is added\n+    }\n+\n+    /**\n+     * Method called after an object field has been output, but\n+     * before the value is output.\n+     *<p>\n+     * Default handling will just output a single\n+     * colon to separate the two, without additional spaces.\n+     */\n+    @Override\n+    public void writeObjectFieldValueSeparator(JsonGenerator jg)\n+        throws IOException, JsonGenerationException\n+    {\n+        jg.writeRaw(':');\n+    }\n+    \n+    /**\n+     * Method called after an object entry (field:value) has been completely\n+     * output, and before another value is to be output.\n+     *<p>\n+     * Default handling (without pretty-printing) will output a single\n+     * comma to separate the two.\n+     */\n+    @Override\n+    public void writeObjectEntrySeparator(JsonGenerator jg)\n+        throws IOException, JsonGenerationException\n+    {\n+        jg.writeRaw(',');\n+    }\n+\n+    @Override\n+    public void writeEndObject(JsonGenerator jg, int nrOfEntries)\n+        throws IOException, JsonGenerationException\n+    {\n+        jg.writeRaw('}');\n+    }\n+    \n+    @Override\n+    public void writeStartArray(JsonGenerator jg)\n+        throws IOException, JsonGenerationException\n+    {\n+        jg.writeRaw('[');\n+    }\n+    \n+    @Override\n+    public void beforeArrayValues(JsonGenerator jg)\n+        throws IOException, JsonGenerationException\n+    {\n+        // nothing special, since no indentation is added\n+    }\n+\n+    /**\n+     * Method called after an array value has been completely\n+     * output, and before another value is to be output.\n+     *<p>\n+     * Default handling (without pretty-printing) will output a single\n+     * comma to separate values.\n+     */\n+    @Override\n+    public void writeArrayValueSeparator(JsonGenerator jg)\n+        throws IOException, JsonGenerationException\n+    {\n+        jg.writeRaw(',');\n+    }\n+    \n+    @Override\n+    public void writeEndArray(JsonGenerator jg, int nrOfValues)\n+        throws IOException, JsonGenerationException\n+    {\n+        jg.writeRaw(']');\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n+package com.fasterxml.jackson.core.util;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+\n+import com.fasterxml.jackson.core.io.NumberInput;\n+\n+/**\n+ * TextBuffer is a class similar to {@link StringBuffer}, with\n+ * following differences:\n+ *<ul>\n+ *  <li>TextBuffer uses segments character arrays, to avoid having\n+ *     to do additional array copies when array is not big enough.\n+ *     This means that only reallocating that is necessary is done only once:\n+ *     if and when caller\n+ *     wants to access contents in a linear array (char[], String).\n+ *    </li>\n+*  <li>TextBuffer can also be initialized in \"shared mode\", in which\n+*     it will just act as a wrapper to a single char array managed\n+*     by another object (like parser that owns it)\n+ *    </li>\n+ *  <li>TextBuffer is not synchronized.\n+ *    </li>\n+ * </ul>\n+ */\n+public final class TextBuffer\n+{\n+    final static char[] NO_CHARS = new char[0];\n+\n+    /**\n+     * Let's start with sizable but not huge buffer, will grow as necessary\n+     */\n+    final static int MIN_SEGMENT_LEN = 1000;\n+    \n+    /**\n+     * Let's limit maximum segment length to something sensible\n+     * like 256k\n+     */\n+    final static int MAX_SEGMENT_LEN = 0x40000;\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration:\n+    /**********************************************************\n+     */\n+\n+    private final BufferRecycler _allocator;\n+\n+    /*\n+    /**********************************************************\n+    /* Shared input buffers\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Shared input buffer; stored here in case some input can be returned\n+     * as is, without being copied to collector's own buffers. Note that\n+     * this is read-only for this Object.\n+     */\n+    private char[] _inputBuffer;\n+\n+    /**\n+     * Character offset of first char in input buffer; -1 to indicate\n+     * that input buffer currently does not contain any useful char data\n+     */\n+    private int _inputStart;\n+\n+    private int _inputLen;\n+\n+    /*\n+    /**********************************************************\n+    /* Aggregation segments (when not using input buf)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * List of segments prior to currently active segment.\n+     */\n+    private ArrayList<char[]> _segments;\n+\n+    /**\n+     * Flag that indicates whether _seqments is non-empty\n+     */\n+    private boolean _hasSegments = false;\n+\n+    // // // Currently used segment; not (yet) contained in _seqments\n+\n+    /**\n+     * Amount of characters in segments in {@link _segments}\n+     */\n+    private int _segmentSize;\n+\n+    private char[] _currentSegment;\n+\n+    /**\n+     * Number of characters in currently active (last) segment\n+     */\n+    private int _currentSize;\n+\n+    /*\n+    /**********************************************************\n+    /* Caching of results\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * String that will be constructed when the whole contents are\n+     * needed; will be temporarily stored in case asked for again.\n+     */\n+    private String _resultString;\n+\n+    private char[] _resultArray;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    public TextBuffer(BufferRecycler allocator)\n+    {\n+        _allocator = allocator;\n+    }\n+\n+    /**\n+     * Method called to indicate that the underlying buffers should now\n+     * be recycled if they haven't yet been recycled. Although caller\n+     * can still use this text buffer, it is not advisable to call this\n+     * method if that is likely, since next time a buffer is needed,\n+     * buffers need to reallocated.\n+     * Note: calling this method automatically also clears contents\n+     * of the buffer.\n+     */\n+    public void releaseBuffers()\n+    {\n+        if (_allocator == null) {\n+            resetWithEmpty();\n+        } else {\n+            if (_currentSegment != null) {\n+                // First, let's get rid of all but the largest char array\n+                resetWithEmpty();\n+                // And then return that array\n+                char[] buf = _currentSegment;\n+                _currentSegment = null;\n+                _allocator.releaseCharBuffer(BufferRecycler.CharBufferType.TEXT_BUFFER, buf);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method called to clear out any content text buffer may have, and\n+     * initializes buffer to use non-shared data.\n+     */\n+    public void resetWithEmpty()\n+    {\n+        _inputStart = -1; // indicates shared buffer not used\n+        _currentSize = 0;\n+        _inputLen = 0;\n+\n+        _inputBuffer = null;\n+        _resultString = null;\n+        _resultArray = null;\n+\n+        // And then reset internal input buffers, if necessary:\n+        if (_hasSegments) {\n+            clearSegments();\n+        }\n+    }\n+\n+    /**\n+     * Method called to initialize the buffer with a shared copy of data;\n+     * this means that buffer will just have pointers to actual data. It\n+     * also means that if anything is to be appended to the buffer, it\n+     * will first have to unshare it (make a local copy).\n+     */\n+    public void resetWithShared(char[] buf, int start, int len)\n+    {\n+        // First, let's clear intermediate values, if any:\n+        _resultString = null;\n+        _resultArray = null;\n+\n+        // Then let's mark things we need about input buffer\n+        _inputBuffer = buf;\n+        _inputStart = start;\n+        _inputLen = len;\n+\n+        // And then reset internal input buffers, if necessary:\n+        if (_hasSegments) {\n+            clearSegments();\n+        }\n+    }\n+\n+    public void resetWithCopy(char[] buf, int start, int len)\n+    {\n+        _inputBuffer = null;\n+        _inputStart = -1; // indicates shared buffer not used\n+        _inputLen = 0;\n+\n+        _resultString = null;\n+        _resultArray = null;\n+\n+        // And then reset internal input buffers, if necessary:\n+        if (_hasSegments) {\n+            clearSegments();\n+        } else if (_currentSegment == null) {\n+            _currentSegment = findBuffer(len);\n+        }\n+        _currentSize = _segmentSize = 0;\n+        append(buf, start, len);\n+    }\n+\n+    public void resetWithString(String value)\n+    {\n+        _inputBuffer = null;\n+        _inputStart = -1;\n+        _inputLen = 0;\n+\n+        _resultString = value;\n+        _resultArray = null;\n+\n+        if (_hasSegments) {\n+            clearSegments();\n+        }\n+        _currentSize = 0;\n+        \n+    }\n+    \n+    /**\n+     * Helper method used to find a buffer to use, ideally one\n+     * recycled earlier.\n+     */\n+    private final char[] findBuffer(int needed)\n+    {\n+        if (_allocator != null) {\n+            return _allocator.allocCharBuffer(BufferRecycler.CharBufferType.TEXT_BUFFER, needed);\n+        }\n+        return new char[Math.max(needed, MIN_SEGMENT_LEN)];\n+    }\n+\n+    private final void clearSegments()\n+    {\n+        _hasSegments = false;\n+        /* Let's start using _last_ segment from list; for one, it's\n+         * the biggest one, and it's also most likely to be cached\n+         */\n+        /* 28-Aug-2009, tatu: Actually, the current segment should\n+         *   be the biggest one, already\n+         */\n+        //_currentSegment = _segments.get(_segments.size() - 1);\n+        _segments.clear();\n+        _currentSize = _segmentSize = 0;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Accessors for implementing public interface\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @return Number of characters currently stored by this collector\n+     */\n+    public int size() {\n+        if (_inputStart >= 0) { // shared copy from input buf\n+            return _inputLen;\n+        }\n+        if (_resultArray != null) {\n+            return _resultArray.length;\n+        }\n+        if (_resultString != null) {\n+            return _resultString.length();\n+        }\n+        // local segmented buffers\n+        return _segmentSize + _currentSize;\n+    }\n+\n+    public int getTextOffset()\n+    {\n+        /* Only shared input buffer can have non-zero offset; buffer\n+         * segments start at 0, and if we have to create a combo buffer,\n+         * that too will start from beginning of the buffer\n+         */\n+        return (_inputStart >= 0) ? _inputStart : 0;\n+    }\n+\n+    /**\n+     * Method that can be used to check whether textual contents can\n+     * be efficiently accessed using {@link #getTextBuffer}.\n+     * \n+     * @since 1.9\n+     */\n+    public boolean hasTextAsCharacters()\n+    {\n+        // if we have array in some form, sure\n+        if (_inputStart >= 0 || _resultArray != null) {\n+            return true;\n+        }\n+        // not if we have String as value\n+        if (_resultString != null) {\n+            return false;\n+        }\n+        return true;\n+    }\n+    \n+    public char[] getTextBuffer()\n+    {\n+        // Are we just using shared input buffer?\n+        if (_inputStart >= 0) {\n+            return _inputBuffer;\n+        }\n+        if (_resultArray != null) {\n+            return _resultArray;\n+        }\n+        if (_resultString != null) {\n+            return (_resultArray = _resultString.toCharArray());\n+        }\n+        // Nope; but does it fit in just one segment?\n+        if (!_hasSegments) {\n+            return _currentSegment;\n+        }\n+        // Nope, need to have/create a non-segmented array and return it\n+        return contentsAsArray();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Other accessors:\n+    /**********************************************************\n+     */\n+\n+    public String contentsAsString()\n+    {\n+        if (_resultString == null) {\n+            // Has array been requested? Can make a shortcut, if so:\n+            if (_resultArray != null) {\n+                _resultString = new String(_resultArray);\n+            } else {\n+                // Do we use shared array?\n+                if (_inputStart >= 0) {\n+                    if (_inputLen < 1) {\n+                        return (_resultString = \"\");\n+                    }\n+                    _resultString = new String(_inputBuffer, _inputStart, _inputLen);\n+                } else { // nope... need to copy\n+                    // But first, let's see if we have just one buffer\n+                    int segLen = _segmentSize;\n+                    int currLen = _currentSize;\n+                    \n+                    if (segLen == 0) { // yup\n+                        _resultString = (currLen == 0) ? \"\" : new String(_currentSegment, 0, currLen);\n+                    } else { // no, need to combine\n+                        StringBuilder sb = new StringBuilder(segLen + currLen);\n+                        // First stored segments\n+                        if (_segments != null) {\n+                            for (int i = 0, len = _segments.size(); i < len; ++i) {\n+                                char[] curr = _segments.get(i);\n+                                sb.append(curr, 0, curr.length);\n+                            }\n+                        }\n+                        // And finally, current segment:\n+                        sb.append(_currentSegment, 0, _currentSize);\n+                        _resultString = sb.toString();\n+                    }\n+                }\n+            }\n+        }\n+        return _resultString;\n+    }\n+ \n+    public char[] contentsAsArray()\n+    {\n+        char[] result = _resultArray;\n+        if (result == null) {\n+            _resultArray = result = buildResultArray();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Convenience method for converting contents of the buffer\n+     * into a {@link BigDecimal}.\n+     */\n+    public BigDecimal contentsAsDecimal()\n+        throws NumberFormatException\n+    {\n+        // Already got a pre-cut array?\n+        if (_resultArray != null) {\n+            return new BigDecimal(_resultArray);\n+        }\n+        // Or a shared buffer?\n+        if (_inputStart >= 0) {\n+            return new BigDecimal(_inputBuffer, _inputStart, _inputLen);\n+        }\n+        // Or if not, just a single buffer (the usual case)\n+        if (_segmentSize == 0) {\n+            return new BigDecimal(_currentSegment, 0, _currentSize);\n+        }\n+        // If not, let's just get it aggregated...\n+        return new BigDecimal(contentsAsArray());\n+    }\n+\n+    /**\n+     * Convenience method for converting contents of the buffer\n+     * into a Double value.\n+     */\n+    public double contentsAsDouble()\n+        throws NumberFormatException\n+    {\n+        return NumberInput.parseDouble(contentsAsString());\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public mutators:\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to make sure that buffer is not using shared input\n+     * buffer; if it is, it will copy such contents to private buffer.\n+     */\n+    public void ensureNotShared() {\n+        if (_inputStart >= 0) {\n+            unshare(16);\n+        }\n+    }\n+\n+    public void append(char c) {\n+        // Using shared buffer so far?\n+        if (_inputStart >= 0) {\n+            unshare(16);\n+        }\n+        _resultString = null;\n+        _resultArray = null;\n+        // Room in current segment?\n+        char[] curr = _currentSegment;\n+        if (_currentSize >= curr.length) {\n+            expand(1);\n+            curr = _currentSegment;\n+        }\n+        curr[_currentSize++] = c;\n+    }\n+\n+    public void append(char[] c, int start, int len)\n+    {\n+        // Can't append to shared buf (sanity check)\n+        if (_inputStart >= 0) {\n+            unshare(len);\n+        }\n+        _resultString = null;\n+        _resultArray = null;\n+\n+        // Room in current segment?\n+        char[] curr = _currentSegment;\n+        int max = curr.length - _currentSize;\n+            \n+        if (max >= len) {\n+            System.arraycopy(c, start, curr, _currentSize, len);\n+            _currentSize += len;\n+        } else {\n+            // No room for all, need to copy part(s):\n+            if (max > 0) {\n+                System.arraycopy(c, start, curr, _currentSize, max);\n+                start += max;\n+                len -= max;\n+            }\n+            // And then allocate new segment; we are guaranteed to now\n+            // have enough room in segment.\n+            expand(len); // note: curr != _currentSegment after this\n+            System.arraycopy(c, start, _currentSegment, 0, len);\n+            _currentSize = len;\n+        }\n+    }\n+\n+    public void append(String str, int offset, int len)\n+    {\n+        // Can't append to shared buf (sanity check)\n+        if (_inputStart >= 0) {\n+            unshare(len);\n+        }\n+        _resultString = null;\n+        _resultArray = null;\n+\n+        // Room in current segment?\n+        char[] curr = _currentSegment;\n+        int max = curr.length - _currentSize;\n+        if (max >= len) {\n+            str.getChars(offset, offset+len, curr, _currentSize);\n+            _currentSize += len;\n+        } else {\n+            // No room for all, need to copy part(s):\n+            if (max > 0) {\n+                str.getChars(offset, offset+max, curr, _currentSize);\n+                len -= max;\n+                offset += max;\n+            }\n+            /* And then allocate new segment; we are guaranteed to now\n+             * have enough room in segment.\n+             */\n+            expand(len);\n+            str.getChars(offset, offset+len, _currentSegment, 0);\n+            _currentSize = len;\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Raw access, for high-performance use:\n+    /**********************************************************\n+     */\n+\n+    public char[] getCurrentSegment()\n+    {\n+        /* Since the intention of the caller is to directly add stuff into\n+         * buffers, we should NOT have anything in shared buffer... ie. may\n+         * need to unshare contents.\n+         */\n+        if (_inputStart >= 0) {\n+            unshare(1);\n+        } else {\n+            char[] curr = _currentSegment;\n+            if (curr == null) {\n+                _currentSegment = findBuffer(0);\n+            } else if (_currentSize >= curr.length) {\n+                // Plus, we better have room for at least one more char\n+                expand(1);\n+            }\n+        }\n+        return _currentSegment;\n+    }\n+\n+    public final char[] emptyAndGetCurrentSegment()\n+    {\n+        // inlined 'resetWithEmpty()'\n+        _inputStart = -1; // indicates shared buffer not used\n+        _currentSize = 0;\n+        _inputLen = 0;\n+\n+        _inputBuffer = null;\n+        _resultString = null;\n+        _resultArray = null;\n+\n+        // And then reset internal input buffers, if necessary:\n+        if (_hasSegments) {\n+            clearSegments();\n+        }\n+        char[] curr = _currentSegment;\n+        if (curr == null) {\n+            _currentSegment = curr = findBuffer(0);\n+        }\n+        return curr;\n+    }\n+\n+    public int getCurrentSegmentSize() {\n+        return _currentSize;\n+    }\n+\n+    public void setCurrentLength(int len) {\n+        _currentSize = len;\n+    }\n+\n+    public char[] finishCurrentSegment()\n+    {\n+        if (_segments == null) {\n+            _segments = new ArrayList<char[]>();\n+        }\n+        _hasSegments = true;\n+        _segments.add(_currentSegment);\n+        int oldLen = _currentSegment.length;\n+        _segmentSize += oldLen;\n+        // Let's grow segments by 50%\n+        int newLen = Math.min(oldLen + (oldLen >> 1), MAX_SEGMENT_LEN);\n+        char[] curr = _charArray(newLen);\n+        _currentSize = 0;\n+        _currentSegment = curr;\n+        return curr;\n+    }\n+\n+    /**\n+     * Method called to expand size of the current segment, to\n+     * accomodate for more contiguous content. Usually only\n+     * used when parsing tokens like names.\n+     */\n+    public char[] expandCurrentSegment()\n+    {\n+        char[] curr = _currentSegment;\n+        // Let's grow by 50%\n+        int len = curr.length;\n+        // Must grow by at least 1 char, no matter what\n+        int newLen = (len == MAX_SEGMENT_LEN) ?\n+            (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n+        _currentSegment = _charArray(newLen);\n+        System.arraycopy(curr, 0, _currentSegment, 0, len);\n+        return _currentSegment;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Standard methods:\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Note: calling this method may not be as efficient as calling\n+     * {@link #contentsAsString}, since it's not guaranteed that resulting\n+     * String is cached.\n+     */\n+    @Override\n+    public String toString() {\n+         return contentsAsString();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods:\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called if/when we need to append content when we have been\n+     * initialized to use shared buffer.\n+     */\n+    private void unshare(int needExtra)\n+    {\n+        int sharedLen = _inputLen;\n+        _inputLen = 0;\n+        char[] inputBuf = _inputBuffer;\n+        _inputBuffer = null;\n+        int start = _inputStart;\n+        _inputStart = -1;\n+\n+        // Is buffer big enough, or do we need to reallocate?\n+        int needed = sharedLen+needExtra;\n+        if (_currentSegment == null || needed > _currentSegment.length) {\n+            _currentSegment = findBuffer(needed);\n+        }\n+        if (sharedLen > 0) {\n+            System.arraycopy(inputBuf, start, _currentSegment, 0, sharedLen);\n+        }\n+        _segmentSize = 0;\n+        _currentSize = sharedLen;\n+    }\n+\n+    /**\n+     * Method called when current segment is full, to allocate new\n+     * segment.\n+     */\n+    private void expand(int minNewSegmentSize)\n+    {\n+        // First, let's move current segment to segment list:\n+        if (_segments == null) {\n+            _segments = new ArrayList<char[]>();\n+        }\n+        char[] curr = _currentSegment;\n+        _hasSegments = true;\n+        _segments.add(curr);\n+        _segmentSize += curr.length;\n+        int oldLen = curr.length;\n+        // Let's grow segments by 50% minimum\n+        int sizeAddition = oldLen >> 1;\n+        if (sizeAddition < minNewSegmentSize) {\n+            sizeAddition = minNewSegmentSize;\n+        }\n+        curr = _charArray(Math.min(MAX_SEGMENT_LEN, oldLen + sizeAddition));\n+        _currentSize = 0;\n+        _currentSegment = curr;\n+    }\n+\n+    private char[] buildResultArray()\n+    {\n+        if (_resultString != null) { // Can take a shortcut...\n+            return _resultString.toCharArray();\n+        }\n+        char[] result;\n+        \n+        // Do we use shared array?\n+        if (_inputStart >= 0) {\n+            if (_inputLen < 1) {\n+                return NO_CHARS;\n+            }\n+            result = _charArray(_inputLen);\n+            System.arraycopy(_inputBuffer, _inputStart, result, 0,\n+                             _inputLen);\n+        } else { // nope \n+            int size = size();\n+            if (size < 1) {\n+                return NO_CHARS;\n+            }\n+            int offset = 0;\n+            result = _charArray(size);\n+            if (_segments != null) {\n+                for (int i = 0, len = _segments.size(); i < len; ++i) {\n+                    char[] curr = (char[]) _segments.get(i);\n+                    int currLen = curr.length;\n+                    System.arraycopy(curr, 0, result, offset, currLen);\n+                    offset += currLen;\n+                }\n+            }\n+            System.arraycopy(_currentSegment, 0, result, offset, _currentSize);\n+        }\n+        return result;\n+    }\n+\n+    private final char[] _charArray(int len) {\n+        return new char[len];\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/util/TokenBuffer.java\n+package com.fasterxml.jackson.core.util;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.base.ParserMinimalBase;\n+import com.fasterxml.jackson.core.io.SerializedString;\n+import com.fasterxml.jackson.core.json.JsonReadContext;\n+import com.fasterxml.jackson.core.json.JsonWriteContext;\n+\n+/**\n+ * Utility class used for efficient storage of {@link JsonToken}\n+ * sequences, needed for temporary buffering.\n+ * Space efficient for different sequence lengths (especially so for smaller\n+ * ones; but not significantly less efficient for larger), highly efficient\n+ * for linear iteration and appending. Implemented as segmented/chunked\n+ * linked list of tokens; only modifications are via appends.\n+ * \n+ * @since 1.5\n+ */\n+public class TokenBuffer\n+/* Won't use JsonGeneratorBase, to minimize overhead for validity\n+ * checking\n+ */\n+    extends JsonGenerator\n+{\n+    protected final static int DEFAULT_PARSER_FEATURES = JsonParser.Feature.collectDefaults();\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Object codec to use for stream-based object\n+     *   conversion through parser/generator interfaces. If null,\n+     *   such methods can not be used.\n+     */\n+    protected ObjectCodec _objectCodec;\n+\n+    /**\n+     * Bit flag composed of bits that indicate which\n+     * {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s\n+     * are enabled.\n+     *<p>\n+     * NOTE: most features have no effect on this class\n+     */\n+    protected int _generatorFeatures;\n+\n+    protected boolean _closed;\n+    \n+    /*\n+    /**********************************************************\n+    /* Token buffering state\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * First segment, for contents this buffer has\n+     */\n+    protected Segment _first;\n+\n+    /**\n+     * Last segment of this buffer, one that is used\n+     * for appending more tokens\n+     */\n+    protected Segment _last;\n+    \n+    /**\n+     * Offset within last segment, \n+     */\n+    protected int _appendOffset;\n+\n+    /*\n+    /**********************************************************\n+    /* Output state\n+    /**********************************************************\n+     */\n+\n+    protected JsonWriteContext _writeContext;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @param codec Object codec to use for stream-based object\n+     *   conversion through parser/generator interfaces. If null,\n+     *   such methods can not be used.\n+     */\n+    public TokenBuffer(ObjectCodec codec)\n+    {\n+        _objectCodec = codec;\n+        _generatorFeatures = DEFAULT_PARSER_FEATURES;\n+        _writeContext = JsonWriteContext.createRootContext();\n+        // at first we have just one segment\n+        _first = _last = new Segment();\n+        _appendOffset = 0;\n+    }\n+    \n+    /**\n+     * Method used to create a {@link JsonParser} that can read contents\n+     * stored in this buffer. Will use default <code>_objectCodec</code> for\n+     * object conversions.\n+     *<p>\n+     * Note: instances are not synchronized, that is, they are not thread-safe\n+     * if there are concurrent appends to the underlying buffer.\n+     * \n+     * @return Parser that can be used for reading contents stored in this buffer\n+     */\n+    public JsonParser asParser()\n+    {\n+        return asParser(_objectCodec);\n+    }\n+\n+    /**\n+     * Method used to create a {@link JsonParser} that can read contents\n+     * stored in this buffer.\n+     *<p>\n+     * Note: instances are not synchronized, that is, they are not thread-safe\n+     * if there are concurrent appends to the underlying buffer.\n+     *\n+     * @param codec Object codec to use for stream-based object\n+     *   conversion through parser/generator interfaces. If null,\n+     *   such methods can not be used.\n+     * \n+     * @return Parser that can be used for reading contents stored in this buffer\n+     */\n+    public JsonParser asParser(ObjectCodec codec)\n+    {\n+        return new Parser(_first, codec);\n+    }\n+\n+    /**\n+     * @param src Parser to use for accessing source information\n+     *    like location, configured codec\n+     */\n+    public JsonParser asParser(JsonParser src)\n+    {\n+        Parser p = new Parser(_first, src.getCodec());\n+        p.setLocation(src.getTokenLocation());\n+        return p;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Other custom methods not needed for implementing interfaces\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Helper method that will write all contents of this buffer\n+     * using given {@link JsonGenerator}.\n+     *<p>\n+     * Note: this method would be enough to implement\n+     * <code>JsonSerializer</code>  for <code>TokenBuffer</code> type;\n+     * but we can not have upwards\n+     * references (from core to mapper package); and as such we also\n+     * can not take second argument.\n+     */\n+    public void serialize(JsonGenerator jgen)\n+        throws IOException, JsonGenerationException\n+    {\n+        Segment segment = _first;\n+        int ptr = -1;\n+\n+        while (true) {\n+            if (++ptr >= Segment.TOKENS_PER_SEGMENT) {\n+                ptr = 0;\n+                segment = segment.next();\n+                if (segment == null) break;\n+            }\n+            JsonToken t = segment.type(ptr);\n+            if (t == null) break;\n+\n+            // Note: copied from 'copyCurrentEvent'...\n+            switch (t) {\n+            case START_OBJECT:\n+                jgen.writeStartObject();\n+                break;\n+            case END_OBJECT:\n+                jgen.writeEndObject();\n+                break;\n+            case START_ARRAY:\n+                jgen.writeStartArray();\n+                break;\n+            case END_ARRAY:\n+                jgen.writeEndArray();\n+                break;\n+            case FIELD_NAME:\n+            {\n+                // 13-Dec-2010, tatu: Maybe we should start using different type tokens to reduce casting?\n+                Object ob = segment.get(ptr);\n+                if (ob instanceof SerializableString) {\n+                    jgen.writeFieldName((SerializableString) ob);\n+                } else {\n+                    jgen.writeFieldName((String) ob);\n+                }\n+            }\n+                break;\n+            case VALUE_STRING:\n+                {\n+                    Object ob = segment.get(ptr);\n+                    if (ob instanceof SerializableString) {\n+                        jgen.writeString((SerializableString) ob);\n+                    } else {\n+                        jgen.writeString((String) ob);\n+                    }\n+                }\n+                break;\n+            case VALUE_NUMBER_INT:\n+                {\n+                    Number n = (Number) segment.get(ptr);\n+                    if (n instanceof BigInteger) {\n+                        jgen.writeNumber((BigInteger) n);\n+                    } else if (n instanceof Long) {\n+                        jgen.writeNumber(n.longValue());\n+                    } else {\n+                        jgen.writeNumber(n.intValue());\n+                    }\n+                }\n+                break;\n+            case VALUE_NUMBER_FLOAT:\n+                {\n+                    Object n = segment.get(ptr);\n+                    if (n instanceof BigDecimal) {\n+                        jgen.writeNumber((BigDecimal) n);\n+                    } else if (n instanceof Float) {\n+                        jgen.writeNumber(((Float) n).floatValue());\n+                    } else if (n instanceof Double) {\n+                        jgen.writeNumber(((Double) n).doubleValue());\n+                    } else if (n == null) {\n+                        jgen.writeNull();\n+                    } else if (n instanceof String) {\n+                        jgen.writeNumber((String) n);\n+                    } else {\n+                        throw new JsonGenerationException(\"Unrecognized value type for VALUE_NUMBER_FLOAT: \"+n.getClass().getName()+\", can not serialize\");\n+                    }\n+                }\n+                break;\n+            case VALUE_TRUE:\n+                jgen.writeBoolean(true);\n+                break;\n+            case VALUE_FALSE:\n+                jgen.writeBoolean(false);\n+                break;\n+            case VALUE_NULL:\n+                jgen.writeNull();\n+                break;\n+            case VALUE_EMBEDDED_OBJECT:\n+                jgen.writeObject(segment.get(ptr));\n+                break;\n+            default:\n+                throw new RuntimeException(\"Internal error: should never end up through this code path\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        // Let's print up to 100 first tokens...\n+        final int MAX_COUNT = 100;\n+\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"[TokenBuffer: \");\n+        JsonParser jp = asParser();\n+        int count = 0;\n+\n+        while (true) {\n+            JsonToken t;\n+            try {\n+                t = jp.nextToken();\n+            } catch (IOException ioe) { // should never occur\n+                throw new IllegalStateException(ioe);\n+            }\n+            if (t == null) break;\n+            if (count < MAX_COUNT) {\n+                if (count > 0) {\n+                    sb.append(\", \");\n+                }\n+                sb.append(t.toString());\n+            }\n+            ++count;\n+        }\n+\n+        if (count >= MAX_COUNT) {\n+            sb.append(\" ... (truncated \").append(count-MAX_COUNT).append(\" entries)\");\n+        }\n+        sb.append(']');\n+        return sb.toString();\n+    }\n+        \n+    /*\n+    /**********************************************************\n+    /* JsonGenerator implementation: configuration\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JsonGenerator enable(Feature f) {\n+        _generatorFeatures |= f.getMask();\n+        return this;\n+    }\n+\n+    @Override\n+    public JsonGenerator disable(Feature f) {\n+        _generatorFeatures &= ~f.getMask();\n+        return this;\n+    }\n+\n+    //public JsonGenerator configure(Feature f, boolean state) { }\n+\n+    @Override\n+    public boolean isEnabled(Feature f) {\n+        return (_generatorFeatures & f.getMask()) != 0;\n+    }\n+\n+    @Override\n+    public JsonGenerator useDefaultPrettyPrinter() {\n+        // No-op: we don't indent\n+        return this;\n+    }\n+\n+    @Override\n+    public JsonGenerator setCodec(ObjectCodec oc) {\n+        _objectCodec = oc;\n+        return this;\n+    }\n+\n+    @Override\n+    public ObjectCodec getCodec() { return _objectCodec; }\n+\n+    @Override\n+    public final JsonWriteContext getOutputContext() { return _writeContext; }\n+\n+    /*\n+    /**********************************************************\n+    /* JsonGenerator implementation: low-level output handling\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void flush() throws IOException { /* NOP */ }\n+\n+    @Override\n+    public void close() throws IOException {\n+        _closed = true;\n+    }\n+\n+    @Override\n+    public boolean isClosed() { return _closed; }\n+\n+    /*\n+    /**********************************************************\n+    /* JsonGenerator implementation: write methods, structural\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public final void writeStartArray()\n+        throws IOException, JsonGenerationException\n+    {\n+        _append(JsonToken.START_ARRAY);\n+        _writeContext = _writeContext.createChildArrayContext();\n+    }\n+\n+    @Override\n+    public final void writeEndArray()\n+        throws IOException, JsonGenerationException\n+    {\n+        _append(JsonToken.END_ARRAY);\n+        // Let's allow unbalanced tho... i.e. not run out of root level, ever\n+        JsonWriteContext c = _writeContext.getParent();\n+        if (c != null) {\n+            _writeContext = c;\n+        }\n+    }\n+\n+    @Override\n+    public final void writeStartObject()\n+        throws IOException, JsonGenerationException\n+    {\n+        _append(JsonToken.START_OBJECT);\n+        _writeContext = _writeContext.createChildObjectContext();\n+    }\n+\n+    @Override\n+    public final void writeEndObject()\n+        throws IOException, JsonGenerationException\n+    {\n+        _append(JsonToken.END_OBJECT);\n+        // Let's allow unbalanced tho... i.e. not run out of root level, ever\n+        JsonWriteContext c = _writeContext.getParent();\n+        if (c != null) {\n+            _writeContext = c;\n+        }\n+    }\n+\n+    @Override\n+    public final void writeFieldName(String name)\n+        throws IOException, JsonGenerationException\n+    {\n+        _append(JsonToken.FIELD_NAME, name);\n+        _writeContext.writeFieldName(name);\n+    }\n+\n+    @Override\n+    public void writeFieldName(SerializableString name)\n+        throws IOException, JsonGenerationException\n+    {\n+        _append(JsonToken.FIELD_NAME, name);\n+        _writeContext.writeFieldName(name.getValue());\n+    }\n+\n+    @Override\n+    public void writeFieldName(SerializedString name)\n+        throws IOException, JsonGenerationException\n+    {\n+        _append(JsonToken.FIELD_NAME, name);\n+        _writeContext.writeFieldName(name.getValue());\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* JsonGenerator implementation: write methods, textual\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeString(String text) throws IOException,JsonGenerationException {\n+        if (text == null) {\n+            writeNull();\n+        } else {\n+            _append(JsonToken.VALUE_STRING, text);\n+        }\n+    }\n+\n+    @Override\n+    public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException {\n+        writeString(new String(text, offset, len));\n+    }\n+\n+    @Override\n+    public void writeString(SerializableString text) throws IOException, JsonGenerationException {\n+        if (text == null) {\n+            writeNull();\n+        } else {\n+            _append(JsonToken.VALUE_STRING, text);\n+        }\n+    }\n+    \n+    @Override\n+    public void writeRawUTF8String(byte[] text, int offset, int length)\n+        throws IOException, JsonGenerationException\n+    {\n+        // could add support for buffering if we really want it...\n+        _reportUnsupportedOperation();\n+    }\n+\n+    @Override\n+    public void writeUTF8String(byte[] text, int offset, int length)\n+        throws IOException, JsonGenerationException\n+    {\n+        // could add support for buffering if we really want it...\n+        _reportUnsupportedOperation();\n+    }\n+\n+    @Override\n+    public void writeRaw(String text) throws IOException, JsonGenerationException {\n+        _reportUnsupportedOperation();\n+    }\n+\n+    @Override\n+    public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException {\n+        _reportUnsupportedOperation();\n+    }\n+\n+    @Override\n+    public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException {\n+        _reportUnsupportedOperation();\n+    }\n+\n+    @Override\n+    public void writeRaw(char c) throws IOException, JsonGenerationException {\n+        _reportUnsupportedOperation();\n+    }\n+\n+    @Override\n+    public void writeRawValue(String text) throws IOException, JsonGenerationException {\n+        _reportUnsupportedOperation();\n+    }\n+\n+    @Override\n+    public void writeRawValue(String text, int offset, int len) throws IOException, JsonGenerationException {\n+        _reportUnsupportedOperation();\n+    }\n+\n+    @Override\n+    public void writeRawValue(char[] text, int offset, int len) throws IOException, JsonGenerationException {\n+        _reportUnsupportedOperation();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* JsonGenerator implementation: write methods, primitive types\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeNumber(int i) throws IOException, JsonGenerationException {\n+        _append(JsonToken.VALUE_NUMBER_INT, Integer.valueOf(i));\n+    }\n+\n+    @Override\n+    public void writeNumber(long l) throws IOException, JsonGenerationException {\n+        _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l));\n+    }\n+\n+    @Override\n+    public void writeNumber(double d) throws IOException,JsonGenerationException {\n+        _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d));\n+    }\n+\n+    @Override\n+    public void writeNumber(float f) throws IOException, JsonGenerationException {\n+        _append(JsonToken.VALUE_NUMBER_FLOAT, Float.valueOf(f));\n+    }\n+\n+    @Override\n+    public void writeNumber(BigDecimal dec) throws IOException,JsonGenerationException {\n+        if (dec == null) {\n+            writeNull();\n+        } else {\n+            _append(JsonToken.VALUE_NUMBER_FLOAT, dec);\n+        }\n+    }\n+\n+    @Override\n+    public void writeNumber(BigInteger v) throws IOException, JsonGenerationException {\n+        if (v == null) {\n+            writeNull();\n+        } else {\n+            _append(JsonToken.VALUE_NUMBER_INT, v);\n+        }\n+    }\n+\n+    @Override\n+    public void writeNumber(String encodedValue) throws IOException, JsonGenerationException {\n+        /* 03-Dec-2010, tatu: related to [JACKSON-423], should try to keep as numeric\n+         *   identity as long as possible\n+         */\n+        _append(JsonToken.VALUE_NUMBER_FLOAT, encodedValue);\n+    }\n+\n+    @Override\n+    public void writeBoolean(boolean state) throws IOException,JsonGenerationException {\n+        _append(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE);\n+    }\n+\n+    @Override\n+    public void writeNull() throws IOException, JsonGenerationException {\n+        _append(JsonToken.VALUE_NULL);\n+    }\n+\n+    /*\n+    /***********************************************************\n+    /* JsonGenerator implementation: write methods for POJOs/trees\n+    /***********************************************************\n+     */\n+\n+    @Override\n+    public void writeObject(Object value)\n+        throws IOException, JsonProcessingException\n+    {\n+        // embedded means that no conversions should be done...\n+        _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);\n+    }\n+\n+    @Override\n+    public void writeTree(JsonNode rootNode)\n+        throws IOException, JsonProcessingException\n+    {\n+        /* 31-Dec-2009, tatu: no need to convert trees either is there?\n+         *  (note: may need to re-evaluate at some point)\n+         */\n+        _append(JsonToken.VALUE_EMBEDDED_OBJECT, rootNode);\n+    }\n+\n+    /*\n+    /***********************************************************\n+    /* JsonGenerator implementation; binary\n+    /***********************************************************\n+     */\n+\n+    @Override\n+    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len)\n+        throws IOException, JsonGenerationException\n+    {\n+        /* 31-Dec-2009, tatu: can do this using multiple alternatives; but for\n+         *   now, let's try to limit number of conversions.\n+         *   The only (?) tricky thing is that of whether to preserve variant,\n+         *   seems pointless, so let's not worry about it unless there's some\n+         *   compelling reason to.\n+         */\n+        byte[] copy = new byte[len];\n+        System.arraycopy(data, offset, copy, 0, len);\n+        writeObject(copy);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* JsonGenerator implementation; pass-through copy\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException\n+    {\n+        switch (jp.getCurrentToken()) {\n+        case START_OBJECT:\n+            writeStartObject();\n+            break;\n+        case END_OBJECT:\n+            writeEndObject();\n+            break;\n+        case START_ARRAY:\n+            writeStartArray();\n+            break;\n+        case END_ARRAY:\n+            writeEndArray();\n+            break;\n+        case FIELD_NAME:\n+            writeFieldName(jp.getCurrentName());\n+            break;\n+        case VALUE_STRING:\n+            if (jp.hasTextCharacters()) {\n+                writeString(jp.getTextCharacters(), jp.getTextOffset(), jp.getTextLength());\n+            } else {\n+                writeString(jp.getText());\n+            }\n+            break;\n+        case VALUE_NUMBER_INT:\n+            switch (jp.getNumberType()) {\n+            case INT:\n+                writeNumber(jp.getIntValue());\n+                break;\n+            case BIG_INTEGER:\n+                writeNumber(jp.getBigIntegerValue());\n+                break;\n+            default:\n+                writeNumber(jp.getLongValue());\n+            }\n+            break;\n+        case VALUE_NUMBER_FLOAT:\n+            switch (jp.getNumberType()) {\n+            case BIG_DECIMAL:\n+                writeNumber(jp.getDecimalValue());\n+                break;\n+            case FLOAT:\n+                writeNumber(jp.getFloatValue());\n+                break;\n+            default:\n+                writeNumber(jp.getDoubleValue());\n+            }\n+            break;\n+        case VALUE_TRUE:\n+            writeBoolean(true);\n+            break;\n+        case VALUE_FALSE:\n+            writeBoolean(false);\n+            break;\n+        case VALUE_NULL:\n+            writeNull();\n+            break;\n+        case VALUE_EMBEDDED_OBJECT:\n+            writeObject(jp.getEmbeddedObject());\n+            break;\n+        default:\n+            throw new RuntimeException(\"Internal error: should never end up through this code path\");\n+        }\n+    }\n+\n+    @Override\n+    public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException {\n+        JsonToken t = jp.getCurrentToken();\n+\n+        // Let's handle field-name separately first\n+        if (t == JsonToken.FIELD_NAME) {\n+            writeFieldName(jp.getCurrentName());\n+            t = jp.nextToken();\n+            // fall-through to copy the associated value\n+        }\n+\n+        switch (t) {\n+        case START_ARRAY:\n+            writeStartArray();\n+            while (jp.nextToken() != JsonToken.END_ARRAY) {\n+                copyCurrentStructure(jp);\n+            }\n+            writeEndArray();\n+            break;\n+        case START_OBJECT:\n+            writeStartObject();\n+            while (jp.nextToken() != JsonToken.END_OBJECT) {\n+                copyCurrentStructure(jp);\n+            }\n+            writeEndObject();\n+            break;\n+        default: // others are simple:\n+            copyCurrentEvent(jp);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+    protected final void _append(JsonToken type) {\n+        Segment next = _last.append(_appendOffset, type);\n+        if (next == null) {\n+            ++_appendOffset;\n+        } else {\n+            _last = next;\n+            _appendOffset = 1; // since we added first at 0\n+        }\n+    }\n+\n+    protected final void _append(JsonToken type, Object value) {\n+        Segment next = _last.append(_appendOffset, type, value);\n+        if (next == null) {\n+            ++_appendOffset;\n+        } else {\n+            _last = next;\n+            _appendOffset = 1;\n+        }\n+    }\n+    \n+    protected void _reportUnsupportedOperation() {\n+        throw new UnsupportedOperationException(\"Called operation not supported for TokenBuffer\");\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Supporting classes\n+    /**********************************************************\n+     */\n+\n+    protected final static class Parser\n+        extends ParserMinimalBase\n+    {\n+        protected ObjectCodec _codec;\n+\n+        /*\n+        /**********************************************************\n+        /* Parsing state\n+        /**********************************************************\n+         */\n+\n+        /**\n+         * Currently active segment\n+         */\n+        protected Segment _segment;\n+\n+        /**\n+         * Pointer to current token within current segment\n+         */\n+        protected int _segmentPtr;\n+\n+        /**\n+         * Information about parser context, context in which\n+         * the next token is to be parsed (root, array, object).\n+         */\n+        protected JsonReadContext _parsingContext;\n+        \n+        protected boolean _closed;\n+\n+        protected transient ByteArrayBuilder _byteBuilder;\n+\n+        protected JsonLocation _location = null;\n+        \n+        /*\n+        /**********************************************************\n+        /* Construction, init\n+        /**********************************************************\n+         */\n+        \n+        public Parser(Segment firstSeg, ObjectCodec codec)\n+        {\n+            super(0);\n+            _segment = firstSeg;\n+            _segmentPtr = -1; // not yet read\n+            _codec = codec;\n+            _parsingContext = JsonReadContext.createRootContext(-1, -1);\n+        }\n+\n+        public void setLocation(JsonLocation l) {\n+            _location = l;\n+        }\n+        \n+        @Override\n+        public ObjectCodec getCodec() { return _codec; }\n+\n+        @Override\n+        public void setCodec(ObjectCodec c) { _codec = c; }\n+\n+        /*\n+        /**********************************************************\n+        /* Extended API beyond JsonParser\n+        /**********************************************************\n+         */\n+        \n+        public JsonToken peekNextToken()\n+            throws IOException, JsonParseException\n+        {\n+            // closed? nothing more to peek, either\n+            if (_closed) return null;\n+            Segment seg = _segment;\n+            int ptr = _segmentPtr+1;\n+            if (ptr >= Segment.TOKENS_PER_SEGMENT) {\n+                ptr = 0;\n+                seg = (seg == null) ? null : seg.next();\n+            }\n+            return (seg == null) ? null : seg.type(ptr);\n+        }\n+        \n+        /*\n+        /**********************************************************\n+        /* Closeable implementation\n+        /**********************************************************\n+         */\n+\n+        @Override\n+        public void close() throws IOException {\n+            if (!_closed) {\n+                _closed = true;\n+            }\n+        }\n+\n+        /*\n+        /**********************************************************\n+        /* Public API, traversal\n+        /**********************************************************\n+         */\n+        \n+        @Override\n+        public JsonToken nextToken() throws IOException, JsonParseException\n+        {\n+            // If we are closed, nothing more to do\n+            if (_closed || (_segment == null)) return null;\n+\n+            // Ok, then: any more tokens?\n+            if (++_segmentPtr >= Segment.TOKENS_PER_SEGMENT) {\n+                _segmentPtr = 0;\n+                _segment = _segment.next();\n+                if (_segment == null) {\n+                    return null;\n+                }\n+            }\n+            _currToken = _segment.type(_segmentPtr);\n+            // Field name? Need to update context\n+            if (_currToken == JsonToken.FIELD_NAME) {\n+                Object ob = _currentObject();\n+                String name = (ob instanceof String) ? ((String) ob) : ob.toString();\n+                _parsingContext.setCurrentName(name);\n+            } else if (_currToken == JsonToken.START_OBJECT) {\n+                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n+            } else if (_currToken == JsonToken.START_ARRAY) {\n+                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n+            } else if (_currToken == JsonToken.END_OBJECT\n+                    || _currToken == JsonToken.END_ARRAY) {\n+                // Closing JSON Object/Array? Close matching context\n+                _parsingContext = _parsingContext.getParent();\n+                // but allow unbalanced cases too (more close markers)\n+                if (_parsingContext == null) {\n+                    _parsingContext = JsonReadContext.createRootContext(-1, -1);\n+                }\n+            }\n+            return _currToken;\n+        }\n+\n+        @Override\n+        public boolean isClosed() { return _closed; }\n+\n+        /*\n+        /**********************************************************\n+        /* Public API, token accessors\n+        /**********************************************************\n+         */\n+        \n+        @Override\n+        public JsonStreamContext getParsingContext() { return _parsingContext; }\n+\n+        @Override\n+        public JsonLocation getTokenLocation() { return getCurrentLocation(); }\n+\n+        @Override\n+        public JsonLocation getCurrentLocation() {\n+            return (_location == null) ? JsonLocation.NA : _location;\n+        }\n+\n+        @Override\n+        public String getCurrentName() { return _parsingContext.getCurrentName(); }\n+        \n+        /*\n+        /**********************************************************\n+        /* Public API, access to token information, text\n+        /**********************************************************\n+         */\n+        \n+        @Override\n+        public String getText()\n+        {\n+            // common cases first:\n+            if (_currToken == JsonToken.VALUE_STRING\n+                    || _currToken == JsonToken.FIELD_NAME) {\n+                Object ob = _currentObject();\n+                if (ob instanceof String) {\n+                    return (String) ob;\n+                }\n+                return (ob == null) ? null : ob.toString();\n+            }\n+            if (_currToken == null) {\n+                return null;\n+            }\n+            switch (_currToken) {\n+            case VALUE_NUMBER_INT:\n+            case VALUE_NUMBER_FLOAT:\n+                Object ob = _currentObject();\n+                return (ob == null) ? null : ob.toString();\n+            }\n+            return _currToken.asString();\n+        }\n+\n+        @Override\n+        public char[] getTextCharacters() {\n+            String str = getText();\n+            return (str == null) ? null : str.toCharArray();\n+        }\n+\n+        @Override\n+        public int getTextLength() {\n+            String str = getText();\n+            return (str == null) ? 0 : str.length();\n+        }\n+\n+        @Override\n+        public int getTextOffset() { return 0; }\n+\n+        @Override\n+        public boolean hasTextCharacters() {\n+            // We never have raw buffer available, so:\n+            return false;\n+        }\n+        \n+        /*\n+        /**********************************************************\n+        /* Public API, access to token information, numeric\n+        /**********************************************************\n+         */\n+\n+        @Override\n+        public BigInteger getBigIntegerValue() throws IOException, JsonParseException\n+        {\n+            Number n = getNumberValue();\n+            if (n instanceof BigInteger) {\n+                return (BigInteger) n;\n+            }\n+            switch (getNumberType()) {\n+            case BIG_DECIMAL:\n+                return ((BigDecimal) n).toBigInteger();\n+            }\n+            // int/long is simple, but let's also just truncate float/double:\n+            return BigInteger.valueOf(n.longValue());\n+        }\n+\n+        @Override\n+        public BigDecimal getDecimalValue() throws IOException, JsonParseException\n+        {\n+            Number n = getNumberValue();\n+            if (n instanceof BigDecimal) {\n+                return (BigDecimal) n;\n+            }\n+            switch (getNumberType()) {\n+            case INT:\n+            case LONG:\n+                return BigDecimal.valueOf(n.longValue());\n+            case BIG_INTEGER:\n+                return new BigDecimal((BigInteger) n);\n+            }\n+            // float or double\n+            return BigDecimal.valueOf(n.doubleValue());\n+        }\n+\n+        @Override\n+        public double getDoubleValue() throws IOException, JsonParseException {\n+            return getNumberValue().doubleValue();\n+        }\n+\n+        @Override\n+        public float getFloatValue() throws IOException, JsonParseException {\n+            return getNumberValue().floatValue();\n+        }\n+\n+        @Override\n+        public int getIntValue() throws IOException, JsonParseException\n+        {\n+            // optimize common case:\n+            if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n+                return ((Number) _currentObject()).intValue();\n+            }\n+            return getNumberValue().intValue();\n+        }\n+\n+        @Override\n+        public long getLongValue() throws IOException, JsonParseException {\n+            return getNumberValue().longValue();\n+        }\n+\n+        @Override\n+        public NumberType getNumberType() throws IOException, JsonParseException\n+        {\n+            Number n = getNumberValue();\n+            if (n instanceof Integer) return NumberType.INT;\n+            if (n instanceof Long) return NumberType.LONG;\n+            if (n instanceof Double) return NumberType.DOUBLE;\n+            if (n instanceof BigDecimal) return NumberType.BIG_DECIMAL;\n+            if (n instanceof Float) return NumberType.FLOAT;\n+            if (n instanceof BigInteger) return NumberType.BIG_INTEGER;\n+            return null;\n+        }\n+\n+        @Override\n+        public final Number getNumberValue() throws IOException, JsonParseException {\n+            _checkIsNumber();\n+            return (Number) _currentObject();\n+        }\n+        \n+        /*\n+        /**********************************************************\n+        /* Public API, access to token information, other\n+        /**********************************************************\n+         */\n+\n+        @Override\n+        public Object getEmbeddedObject()\n+        {\n+            if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {\n+                return _currentObject();\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException\n+        {\n+            // First: maybe we some special types?\n+            if (_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) {\n+                // Embedded byte array would work nicely...\n+                Object ob = _currentObject();\n+                if (ob instanceof byte[]) {\n+                    return (byte[]) ob;\n+                }\n+                // fall through to error case\n+            }\n+            if (_currToken != JsonToken.VALUE_STRING) {\n+                throw _constructError(\"Current token (\"+_currToken+\") not VALUE_STRING (or VALUE_EMBEDDED_OBJECT with byte[]), can not access as binary\");\n+            }\n+            final String str = getText();\n+            if (str == null) {\n+                return null;\n+            }\n+            ByteArrayBuilder builder = _byteBuilder;\n+            if (builder == null) {\n+                _byteBuilder = builder = new ByteArrayBuilder(100);\n+            }\n+            _decodeBase64(str, builder, b64variant);\n+            return builder.toByteArray();\n+        }\n+\n+        /*\n+        /**********************************************************\n+        /* Internal methods\n+        /**********************************************************\n+         */\n+\n+        protected final Object _currentObject() {\n+            return _segment.get(_segmentPtr);\n+        }\n+\n+        protected final void _checkIsNumber() throws JsonParseException\n+        {\n+            if (_currToken == null || !_currToken.isNumeric()) {\n+                throw _constructError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\");\n+            }\n+        }\n+\n+        @Override\n+        protected void _handleEOF() throws JsonParseException {\n+            _throwInternal();\n+        }\n+    }\n+    \n+    /**\n+     * Individual segment of TokenBuffer that can store up to 16 tokens\n+     * (limited by 4 bits per token type marker requirement).\n+     * Current implementation uses fixed length array; could alternatively\n+     * use 16 distinct fields and switch statement (slightly more efficient\n+     * storage, slightly slower access)\n+     */\n+    protected final static class Segment \n+    {\n+        public final static int TOKENS_PER_SEGMENT = 16;\n+        \n+        /**\n+         * Static array used for fast conversion between token markers and\n+         * matching {@link JsonToken} instances\n+         */\n+        private final static JsonToken[] TOKEN_TYPES_BY_INDEX;\n+        static {\n+            // ... here we know that there are <= 16 values in JsonToken enum\n+            TOKEN_TYPES_BY_INDEX = new JsonToken[16];\n+            JsonToken[] t = JsonToken.values();\n+            System.arraycopy(t, 1, TOKEN_TYPES_BY_INDEX, 1, Math.min(15, t.length - 1));\n+        }\n+\n+        // // // Linking\n+        \n+        protected Segment _next;\n+        \n+        // // // State\n+\n+        /**\n+         * Bit field used to store types of buffered tokens; 4 bits per token.\n+         * Value 0 is reserved for \"not in use\"\n+         */\n+        protected long _tokenTypes;\n+\n+        \n+        // Actual tokens\n+\n+        protected final Object[] _tokens = new Object[TOKENS_PER_SEGMENT];\n+\n+        public Segment() { }\n+\n+        // // // Accessors\n+\n+        public JsonToken type(int index)\n+        {\n+            long l = _tokenTypes;\n+            if (index > 0) {\n+                l >>= (index << 2);\n+            }\n+            int ix = ((int) l) & 0xF;\n+            return TOKEN_TYPES_BY_INDEX[ix];\n+        }\n+        \n+        public Object get(int index) {\n+            return _tokens[index];\n+        }\n+\n+        public Segment next() { return _next; }\n+        \n+        // // // Mutators\n+\n+        public Segment append(int index, JsonToken tokenType)\n+        {\n+            if (index < TOKENS_PER_SEGMENT) {\n+                set(index, tokenType);\n+                return null;\n+            }\n+            _next = new Segment();\n+            _next.set(0, tokenType);\n+            return _next;\n+        }\n+\n+        public Segment append(int index, JsonToken tokenType, Object value)\n+        {\n+            if (index < TOKENS_PER_SEGMENT) {\n+                set(index, tokenType, value);\n+                return null;\n+            }\n+            _next = new Segment();\n+            _next.set(0, tokenType, value);\n+            return _next;\n+        }\n+        \n+        public void set(int index, JsonToken tokenType)\n+        {\n+            long typeCode = tokenType.ordinal();\n+            /* Assumption here is that there are no overwrites, just appends;\n+             * and so no masking is needed\n+             */\n+            if (index > 0) {\n+                typeCode <<= (index << 2);\n+            }\n+            _tokenTypes |= typeCode;\n+        }\n+\n+        public void set(int index, JsonToken tokenType, Object value)\n+        {\n+            _tokens[index] = value;\n+            long typeCode = tokenType.ordinal();\n+            /* Assumption here is that there are no overwrites, just appends;\n+             * and so no masking is needed\n+             */\n+            if (index > 0) {\n+                typeCode <<= (index << 2);\n+            }\n+            _tokenTypes |= typeCode;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/util/VersionUtil.java\n+package com.fasterxml.jackson.core.util;\n+\n+import java.io.*;\n+import java.util.regex.Pattern;\n+\n+import com.fasterxml.jackson.core.Version;\n+\n+/**\n+ * Functionality for supporting exposing of component {@link Version}s.\n+ * \n+ * @since 1.6\n+ */\n+public class VersionUtil\n+{\n+    public final static String VERSION_FILE = \"VERSION.txt\";\n+\n+    private final static Pattern VERSION_SEPARATOR = Pattern.compile(\"[-_./;:]\");\n+    \n+    /**\n+     * Helper method that will try to load version information for specified\n+     * class. Implementation is simple: class loader that loaded specified\n+     * class is asked to load resource with name \"VERSION\" from same\n+     * location (package) as class itself had.\n+     * If no version information is found, {@link Version#unknownVersion()} is\n+     * returned.\n+     */\n+    public static Version versionFor(Class<?> cls)\n+    {\n+        InputStream in;\n+        Version version = null;\n+        \n+        try {\n+            in = cls.getResourceAsStream(VERSION_FILE);\n+            if (in != null) {\n+                try {\n+                    BufferedReader br = new BufferedReader(new InputStreamReader(in, \"UTF-8\"));\n+                    version = parseVersion(br.readLine());\n+                } finally {\n+                    try {\n+                        in.close();\n+                    } catch (IOException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                }\n+            }\n+        } catch (IOException e) { }\n+        return (version == null) ? Version.unknownVersion() : version;\n+    }\n+\n+    public static Version parseVersion(String versionStr)\n+    {\n+        if (versionStr == null) return null;\n+        versionStr = versionStr.trim();\n+        if (versionStr.length() == 0) return null;\n+        String[] parts = VERSION_SEPARATOR.split(versionStr);\n+        // Let's not bother if there's no separate parts; otherwise use whatever we got\n+        if (parts.length < 2) {\n+            return null;\n+        }\n+        int major = parseVersionPart(parts[0]);\n+        int minor = parseVersionPart(parts[1]);\n+        int patch = (parts.length > 2) ? parseVersionPart(parts[2]) : 0;\n+        String snapshot = (parts.length > 3) ? parts[3] : null;\n+        return new Version(major, minor, patch, snapshot);\n+    }\n+\n+    protected static int parseVersionPart(String partStr)\n+    {\n+        partStr = partStr.toString();\n+        int len = partStr.length();\n+        int number = 0;\n+        for (int i = 0; i < len; ++i) {\n+            char c = partStr.charAt(i);\n+            if (c > '9' || c < '0') break;\n+            number = (number * 10) + (c - '0');\n+        }\n+        return number;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/util/package-info.java\n+/**\n+ * Utility classes used by Jackson Core functionality.\n+ */\n+package com.fasterxml.jackson.core.util;", "timestamp": 1324623640, "metainfo": ""}