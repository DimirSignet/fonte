{"sha": "f8d8856524fbaf9b72245ee84fd20c4afa996620", "log": "Code streamlining; removing internal (non-public) deprecated methods up to 2.5 level", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n      */\n     protected final transient ByteQuadsCanonicalizer _byteSymbolCanonicalizer = ByteQuadsCanonicalizer.createRoot();\n \n-    /**\n-     * Earlier byte-based symbol table; replaced with 2.6 with a new implementation.\n-     * Left in for version 2.6.0: will be removed in 2.7 or later.\n-     *\n-     * @deprecated Since 2.6.0, only use {@link #_byteSymbolCanonicalizer}\n-     */\n-    @Deprecated\n-    protected final transient com.fasterxml.jackson.core.sym.BytesToNameCanonicalizer _rootByteSymbols\n-        = com.fasterxml.jackson.core.sym.BytesToNameCanonicalizer.createRoot();\n-\n     /*\n     /**********************************************************\n     /* Configuration\n--- a/src/main/java/com/fasterxml/jackson/core/json/JsonReadContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonReadContext.java\n     /**********************************************************\n      */\n \n-    @Deprecated // since 2.3, use variant that takes dup detector\n-    public static JsonReadContext createRootContext(int lineNr, int colNr) {\n-        return createRootContext(lineNr, colNr, null);\n-    }\n-\n     public static JsonReadContext createRootContext(int lineNr, int colNr, DupDetector dups) {\n         return new JsonReadContext(null, dups, TYPE_ROOT, lineNr, colNr);\n-    }\n-\n-    @Deprecated // since 2.3, use variant that takes dup detector\n-    public static JsonReadContext createRootContext() {\n-        return createRootContext(null);\n     }\n \n     public static JsonReadContext createRootContext(DupDetector dups) {\n--- a/src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java\n      */\n \n     @Override\n-    public void writeRootValueSeparator(JsonGenerator jg)\n-        throws IOException, JsonGenerationException\n+    public void writeRootValueSeparator(JsonGenerator jg) throws IOException\n     {\n         if (_rootSeparator != null) {\n             jg.writeRaw(_rootSeparator);\n     }\n \n     @Override\n-    public void writeStartObject(JsonGenerator jg)\n-        throws IOException, JsonGenerationException\n+    public void writeStartObject(JsonGenerator jg) throws IOException\n     {\n         jg.writeRaw('{');\n         if (!_objectIndenter.isInline()) {\n     }\n \n     @Override\n-    public void beforeObjectEntries(JsonGenerator jg)\n-        throws IOException, JsonGenerationException\n+    public void beforeObjectEntries(JsonGenerator jg) throws IOException\n     {\n         _objectIndenter.writeIndentation(jg, _nesting);\n     }\n      * (white-space) decoration.\n      */\n     @Override\n-    public void writeObjectFieldValueSeparator(JsonGenerator jg)\n-        throws IOException, JsonGenerationException\n+    public void writeObjectFieldValueSeparator(JsonGenerator jg) throws IOException\n     {\n         if (_spacesInObjectEntries) {\n             jg.writeRaw(\" : \");\n      * (white-space) decoration.\n      */\n     @Override\n-    public void writeObjectEntrySeparator(JsonGenerator jg)\n-        throws IOException, JsonGenerationException\n+    public void writeObjectEntrySeparator(JsonGenerator jg) throws IOException\n     {\n         jg.writeRaw(',');\n         _objectIndenter.writeIndentation(jg, _nesting);\n     }\n \n     @Override\n-    public void writeEndObject(JsonGenerator jg, int nrOfEntries)\n-        throws IOException, JsonGenerationException\n+    public void writeEndObject(JsonGenerator jg, int nrOfEntries) throws IOException\n     {\n         if (!_objectIndenter.isInline()) {\n             --_nesting;\n     }\n \n     @Override\n-    public void writeStartArray(JsonGenerator jg)\n-        throws IOException, JsonGenerationException\n+    public void writeStartArray(JsonGenerator jg) throws IOException\n     {\n         if (!_arrayIndenter.isInline()) {\n             ++_nesting;\n     }\n \n     @Override\n-    public void beforeArrayValues(JsonGenerator jg)\n-        throws IOException, JsonGenerationException\n-    {\n+    public void beforeArrayValues(JsonGenerator jg) throws IOException {\n         _arrayIndenter.writeIndentation(jg, _nesting);\n     }\n \n         @Override\n         public boolean isInline() { return true; }\n     }\n-    \n-    /**\n-     * @deprecated Since 2.5 use {@link DefaultIndenter} instead\n-     */\n-    @Deprecated\n-    public static class Lf2SpacesIndenter extends DefaultIndenter\n-    {\n-        /** @deprecated Use {@link DefaultIndenter#SYSTEM_LINEFEED_INSTANCE} instead.\n-         */\n-        @SuppressWarnings(\"hiding\")\n-        @Deprecated\n-        public static final Lf2SpacesIndenter instance = new Lf2SpacesIndenter();\n-\n-        /** @deprecated Use {@code new DefaultIndenter(\"  \", DefaultIndenter.SYS_LF)} instead\n-         */\n-        @Deprecated\n-        public Lf2SpacesIndenter() {\n-            super(\"  \", DefaultIndenter.SYS_LF);\n-        }\n-        \n-        /** @deprecated Use {@code new DefaultIndenter(\"  \", lf)} instead\n-         */\n-        @Deprecated\n-        public Lf2SpacesIndenter(String lf) {\n-            super(\"  \", lf);\n-        }\n-\n-        /**\n-         * Note: method was accidentally missing from 2.5.0; put back for 2.5.1 and\n-         * later 2.5.x versions.\n-         */\n-        @Override\n-        public Lf2SpacesIndenter withLinefeed(String lf) {\n-            if (lf.equals(getEol())) {\n-                return this;\n-            }\n-            return new Lf2SpacesIndenter(lf);\n-        }\n-    }\n }\n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n         assertEquals(3431, symbols.collisionCount());\n \n         assertEquals(6, symbols.maxCollisionLength());\n-    }\n-\n-    // Test for verifying stability of hashCode, wrt collisions, using\n-    // synthetic field name generation and byte-based input (UTF-8)\n-    @SuppressWarnings(\"deprecation\")\n-    public void testSyntheticWithBytesOld() throws IOException\n-    {\n-        // pass seed, to keep results consistent:\n-        final int SEED = 33333;\n-        BytesToNameCanonicalizer symbols =\n-                BytesToNameCanonicalizer.createRoot(SEED).makeChild(JsonFactory.Feature.collectDefaults());\n-\n-        final int COUNT = 12000;\n-        for (int i = 0; i < COUNT; ++i) {\n-            String id = fieldNameFor(i);\n-            int[] quads = calcQuads(id.getBytes(\"UTF-8\"));\n-            symbols.addName(id, quads, quads.length);\n-        }\n-        assertEquals(COUNT, symbols.size());\n-        assertEquals(16384, symbols.bucketCount());\n-\n-//System.out.printf(\"Byte stuff: collisions %d, max-coll %d\\n\", symbols.collisionCount(), symbols.maxCollisionLength());\n-        assertEquals(3476, symbols.collisionCount());\n-        // longest collision chain not optimal but ok:\n-        assertEquals(15, symbols.maxCollisionLength());\n-\n-        // But also verify entries are actually found?\n     }\n \n     public void testSyntheticWithBytesNew() throws IOException\n         }\n     }\n \n-    @SuppressWarnings(\"deprecation\")\n-    public void testThousandsOfSymbolsWithOldBytes() throws IOException\n-    {\n-        final int SEED = 33333;\n-\n-        BytesToNameCanonicalizer symbolsBRoot = BytesToNameCanonicalizer.createRoot(SEED);\n-        final Charset utf8 = Charset.forName(\"UTF-8\");\n-        int exp = 0;\n-        \n-        for (int doc = 0; doc < 100; ++doc) {\n-            BytesToNameCanonicalizer symbolsB =\n-                    symbolsBRoot.makeChild(JsonFactory.Feature.collectDefaults());\n-            for (int i = 0; i < 250; ++i) {\n-                String name = \"f_\"+doc+\"_\"+i;\n-\n-                int[] quads = BytesToNameCanonicalizer.calcQuads(name.getBytes(utf8));\n-                symbolsB.addName(name, quads, quads.length);\n-                Name n = symbolsB.findName(quads, quads.length);\n-                assertEquals(name, n.getName());\n-            }\n-            symbolsB.release();\n-            exp += 250;\n-            if (exp > BytesToNameCanonicalizer.MAX_ENTRIES_FOR_REUSE) {\n-                exp = 0;\n-            }\n-            assertEquals(exp, symbolsBRoot.size());\n-        }\n-    }\n-\n     // Since 2.6\n     public void testThousandsOfSymbolsWithNew() throws IOException\n     {\n         Field syms = p.getClass().getDeclaredField(\"_symbols\");\n         syms.setAccessible(true);\n         return ((ByteQuadsCanonicalizer) syms.get(p));\n-    }\n-\n-    // [core#187]: unexpectedly high number of collisions for straight numbers\n-    @SuppressWarnings(\"deprecation\")\n-    public void testCollisionsWithBytes187() throws IOException\n-    {\n-        BytesToNameCanonicalizer symbols =\n-                BytesToNameCanonicalizer.createRoot(1).makeChild(JsonFactory.Feature.collectDefaults());\n-        final int COUNT = 30000;\n-        for (int i = 0; i < COUNT; ++i) {\n-            String id = String.valueOf(10000 + i);\n-            int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\"));\n-            symbols.addName(id, quads, quads.length);\n-        }\n-\n-//System.out.printf(\"Byte stuff: collisions %d, max-coll %d\\n\", symbols.collisionCount(), symbols.maxCollisionLength());\n-        \n-        assertEquals(COUNT, symbols.size());\n-        assertEquals(65536, symbols.bucketCount());\n-\n-        // collision count acceptable\n-        assertEquals(5782, symbols.collisionCount());\n-        // as well as collision counts\n-        assertEquals(24, symbols.maxCollisionLength());\n     }\n \n     // [core#187]: unexpectedly high number of collisions for straight numbers\n         assertEquals(2, symbols.maxCollisionLength());\n     }\n \n-    @SuppressWarnings(\"deprecation\")\n-    public void testShortQuotedDirectBytesOld() throws IOException\n-    {\n-        final int COUNT = 400;\n-        BytesToNameCanonicalizer symbols =\n-                BytesToNameCanonicalizer.createRoot(1).makeChild(JsonFactory.Feature.collectDefaults());\n-        for (int i = 0; i < COUNT; ++i) {\n-            String id = String.format(\"\\\\u%04x\", i);\n-            int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\"));\n-            symbols.addName(id, quads, quads.length);\n-        }\n-        assertEquals(COUNT, symbols.size());\n-        assertEquals(1024, symbols.bucketCount());\n-\n-        assertEquals(44, symbols.collisionCount());\n-        assertEquals(2, symbols.maxCollisionLength());\n-    }\n-\n     public void testShortQuotedDirectBytes() throws IOException\n     {\n         final int COUNT = 400;\n     }\n     \n     // [core#191]\n-    @SuppressWarnings(\"deprecation\")\n     public void testShortNameCollisionsDirect() throws IOException\n     {\n         final int COUNT = 600;\n             assertEquals(1024, symbols.bucketCount());\n     \n             assertEquals(16, symbols.collisionCount());\n-            assertEquals(1, symbols.maxCollisionLength());\n-        }\n-        \n-        // then byte-based\n-        {\n-            BytesToNameCanonicalizer symbols =\n-                    BytesToNameCanonicalizer.createRoot(1).makeChild(JsonFactory.Feature.collectDefaults());\n-            for (int i = 0; i < COUNT; ++i) {\n-                String id = String.valueOf((char) i);\n-                int[] quads = calcQuads(id.getBytes(\"UTF-8\"));\n-                symbols.addName(id, quads, quads.length);\n-            }\n-            assertEquals(COUNT, symbols.size());\n-            assertEquals(1024, symbols.bucketCount());\n-    \n-            assertEquals(209, symbols.collisionCount());\n             assertEquals(1, symbols.maxCollisionLength());\n         }\n     }", "timestamp": 1439873124, "metainfo": ""}