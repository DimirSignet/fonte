{"sha": "8dc12841329ff7e120802cc47082928bb8ad8e3a", "log": "Implement `nextFieldName(SerializableString)` efficiently for ReaderBasedJsonParser", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n     /**********************************************************\n      */\n \n-    /*\n+    // Implemented since 2.7\n     @Override\n-    public boolean nextFieldName(SerializableString str)\n-        throws IOException\n-    {\n-    \n-    }\n-    */\n+    public boolean nextFieldName(SerializableString sstr) throws IOException\n+    {\n+        // // // Note: most of code below is copied from nextToken()\n+\n+        _numTypesValid = NR_UNKNOWN;\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+            _nextAfterName();\n+            return false;\n+        }\n+        if (_tokenIncomplete) {\n+            _skipString();\n+        }\n+        int i = _skipWSOrEnd();\n+        if (i < 0) {\n+            close();\n+            _currToken = null;\n+            return false;\n+        }\n+        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n+        _tokenInputRow = _currInputRow;\n+        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n+        _binaryValue = null;\n+        if (i == INT_RBRACKET) {\n+            if (!_parsingContext.inArray()) {\n+                _reportMismatchedEndMarker(i, '}');\n+            }\n+            _parsingContext = _parsingContext.getParent();\n+            _currToken = JsonToken.END_ARRAY;\n+            return false;\n+        }\n+        if (i == INT_RCURLY) {\n+            if (!_parsingContext.inObject()) {\n+                _reportMismatchedEndMarker(i, ']');\n+            }\n+            _parsingContext = _parsingContext.getParent();\n+            _currToken = JsonToken.END_OBJECT;\n+            return false;\n+        }\n+        if (_parsingContext.expectComma()) {\n+            i = _skipComma(i);\n+        }\n+\n+        if (!_parsingContext.inObject()) {\n+            _nextTokenNotInObject(i);\n+            return false;\n+        }\n+\n+        if (i == INT_QUOTE) {\n+            // when doing literal match, must consider escaping:\n+            char[] nameChars = sstr.asQuotedChars();\n+            final int len = nameChars.length;\n+\n+            // Require 4 more bytes for faster skipping of colon that follows name\n+            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n+                // first check length match by\n+                final int end = _inputPtr+len;\n+                if (_inputBuffer[end] == '\"') {\n+                    int offset = 0;\n+                    int ptr = _inputPtr;\n+                    while (true) {\n+                        if (ptr == end) { // yes, match!\n+                            _parsingContext.setCurrentName(sstr.getValue());\n+                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n+                            return true;\n+                        }\n+                        if (nameChars[offset] != _inputBuffer[ptr]) {\n+                            break;\n+                        }\n+                        ++offset;\n+                        ++ptr;\n+                    }\n+                }\n+            }\n+        }\n+        return _isNextTokenNameMaybe(i, sstr.getValue());\n+    }\n \n     @Override\n     public String nextFieldName() throws IOException\n         }\n         _nextToken = t;\n         return name;\n+    }\n+\n+    private final void _isNextTokenNameYes(int i) throws IOException\n+    {\n+        _currToken = JsonToken.FIELD_NAME;\n+\n+        switch (i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            _nextToken = JsonToken.VALUE_STRING;\n+            return;\n+        case '[':\n+            _nextToken = JsonToken.START_ARRAY;\n+            return;\n+        case '{':\n+            _nextToken = JsonToken.START_OBJECT;\n+            return;\n+        case 't':\n+            _matchToken(\"true\", 1);\n+            _nextToken = JsonToken.VALUE_TRUE;\n+            return;\n+        case 'f':\n+            _matchToken(\"false\", 1);\n+            _nextToken = JsonToken.VALUE_FALSE;\n+            return;\n+        case 'n':\n+            _matchToken(\"null\", 1);\n+            _nextToken = JsonToken.VALUE_NULL;\n+            return;\n+        case '-':\n+            _nextToken = _parseNegNumber();\n+            return;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            _nextToken = _parsePosNumber(i);\n+            return;\n+        }\n+        _nextToken = _handleOddValue(i);\n+    }\n+\n+    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n+    {\n+        // // // and this is back to standard nextToken()\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n+        if (i == INT_QUOTE) {\n+            _tokenIncomplete = true;\n+            _nextToken = JsonToken.VALUE_STRING;\n+            return nameToMatch.equals(name);\n+        }\n+        // Ok: we must have a value... what is it?\n+        JsonToken t;\n+        switch (i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+        }\n+        _nextToken = t;\n+        return nameToMatch.equals(name);\n     }\n \n     private final JsonToken _nextTokenNotInObject(int i) throws IOException\n             }\n         }\n     }\n- \n+\n+    // Variant called when we know there's at least 4 more bytes available\n+    private final int _skipColonFast(int ptr) throws IOException\n+    {\n+        int i = (int) _inputBuffer[ptr++];\n+        if (i == INT_COLON) { // common case, no leading space\n+            i = _inputBuffer[ptr++];\n+            if (i > INT_SPACE) { // nor trailing\n+                if (i != INT_SLASH && i != INT_HASH) {\n+                    _inputPtr = ptr;\n+                    return i;\n+                }\n+            } else if (i == INT_SPACE || i == INT_TAB) {\n+                i = (int) _inputBuffer[ptr++];\n+                if (i > INT_SPACE) {\n+                    if (i != INT_SLASH && i != INT_HASH) {\n+                        _inputPtr = ptr;\n+                        return i;\n+                    }\n+                }\n+            }\n+            _inputPtr = ptr-1;\n+            return _skipColon2(true); // true -> skipped colon\n+        }\n+        if (i == INT_SPACE || i == INT_TAB) {\n+            i = _inputBuffer[ptr++];\n+        }\n+        if (i == INT_COLON) {\n+            i = _inputBuffer[ptr++];\n+            if (i > INT_SPACE) {\n+                if (i != INT_SLASH && i != INT_HASH) {\n+                    _inputPtr = ptr;\n+                    return i;\n+                }\n+            } else if (i == INT_SPACE || i == INT_TAB) {\n+                i = (int) _inputBuffer[ptr++];\n+                if (i > INT_SPACE) {\n+                    if (i != INT_SLASH && i != INT_HASH) {\n+                        _inputPtr = ptr;\n+                        return i;\n+                    }\n+                }\n+            }\n+        }\n+        _inputPtr = ptr-1;\n+        return _skipColon2(false);\n+    }\n+    \n     // Primary loop: no reloading, comment handling\n     private final int _skipComma(int i) throws IOException\n     {\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n                 }\n             }\n         }\n-        return _isNextTokenNameMaybe(i, str);\n+        return _isNextTokenNameMaybe(i, str.getValue());\n     }\n \n     @Override\n         _inputPtr = ptr-1;\n         return _skipColon2(false);\n     }\n-    \n+\n     private final void _isNextTokenNameYes(int i) throws IOException\n     {\n         _currToken = JsonToken.FIELD_NAME;\n         }\n         _nextToken = _handleUnexpectedValue(i);\n     }\n-    \n-    \n-    private final boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException\n+\n+    private final boolean _isNextTokenNameMaybe(int i, String str) throws IOException\n     {\n         // // // and this is back to standard nextToken()\n \n-        String n = _parseName(i);\n-        _parsingContext.setCurrentName(n);\n-        final boolean match = n.equals(str.getValue());\n+        String name = _parseName(i);\n+        _parsingContext.setCurrentName(name);\n         _currToken = JsonToken.FIELD_NAME;\n         i = _skipColon();\n \n         if (i == INT_QUOTE) {\n             _tokenIncomplete = true;\n             _nextToken = JsonToken.VALUE_STRING;\n-            return match;\n+            return name.equals(str);\n         }\n         JsonToken t;\n \n             t = _handleUnexpectedValue(i);\n         }\n         _nextToken = t;\n-        return match;\n+        return name.equals(str);\n     }\n \n     @Override", "timestamp": 1439411737, "metainfo": ""}