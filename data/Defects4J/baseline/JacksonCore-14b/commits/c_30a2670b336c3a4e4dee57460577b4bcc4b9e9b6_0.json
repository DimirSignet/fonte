{"sha": "30a2670b336c3a4e4dee57460577b4bcc4b9e9b6", "log": "First version of new symbol table that passes all unit tests", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java\n      * structure (details of which may be tweaked depending on expected rates\n      * of collisions).\n      */\n-    protected int[] _hash;\n-    \n-    /**\n-     * Mask used to truncate 32-bit hash value to current hash array\n-     * size; essentially, {@link _hashSize} - 1 (since hash array sizes\n-     * are 2^N).\n-     */\n-    protected int _hashMask;\n-\n-    /**\n-     * Number of slots for primary entries within {@link #_hash}; which is\n-     * <code>1/2</code> \n+    protected int[] _hashArea;\n+\n+    /**\n+     * Number of slots for primary entries within {@link #_hashArea}; which is\n+     * at most <code>1/8</code> of actual size of the underlying array (4-int slots,\n+     * primary covers only half of the area; plus, additional area for longer\n+     * symbols after hash area).\n      */\n     protected int _hashSize;\n \n     /**\n-     * Offset within {@link #_hash} where secondary entries start\n+     * Offset within {@link #_hashArea} where secondary entries start\n      */\n     protected int _secondaryOffset;\n     \n \n     /**\n      * Array that contains <code>String</code> instances matching\n-     * entries in {@link #_hash}.\n+     * entries in {@link #_hashArea}.\n      * Contains nulls for unused entries. Note that this size is twice\n      * that o\n      */\n     /**\n      * Pointer to the offset within spill-over area where there is room\n      * for more spilled over entries (if any).\n-     */\n-    protected int _spillOverEnd;\n-\n-    /**\n-     * Offset within {@link #_hash} that follows main slots and contains\n+     * Spill over area is within fixed-size portion of {@link #_hashArea}.\n+     */\n+    protected int _spilloverEnd;\n+\n+    /**\n+     * Offset within {@link #_hashArea} that follows main slots and contains\n      * quads for longer names (13 bytes or longers), and points to the\n      * first available int that may be used for appending quads of the next\n      * long name.\n+     * Note that long name area follows immediately after the fixed-size\n+     * main hash area ({@link #_hashArea}).\n      */\n     protected int _longNameOffset;\n \n         // Then copy shared state\n         _count = state.count;\n         _hashSize = state.size;\n-        _hashMask = _hashSize-1;\n         _secondaryOffset = _hashSize << 2; // 4 ints per entry\n-        _hash = state.mainHash;\n+        _hashArea = state.mainHash;\n         _names = state.names;\n \n+        _spilloverEnd = state.spilloverEnd;\n+        _longNameOffset = state.longNameOffset;\n+        \n         // and then set other state to reflect sharing status\n         _needRehash = false;\n         _hashShared = true;\n     {\n         int count = 0;\n         for (int offset = 3, end = _secondaryOffset; offset < end; offset += 4) {\n-            if (_hash[offset] != 0) {\n+            if (_hashArea[offset] != 0) {\n                 ++count;\n             }\n         }\n         int count = 0;\n         int offset = _secondaryOffset + 3;\n         for (int end = offset + (_hashSize << 1); offset < end; offset += 4) {\n-            if (_hash[offset] != 0) {\n+            if (_hashArea[offset] != 0) {\n                 ++count;\n             }\n         }\n         int count = 0;\n         int offset = _secondaryOffset + (_hashSize << 1) + 3; // to 1.5x, starting point of tertiary\n         for (int end = offset + _hashSize; offset < end; offset += 4) {\n-            if (_hash[offset] != 0) {\n+            if (_hashArea[offset] != 0) {\n                 ++count;\n             }\n         }\n      * Method mostly needed by unit tests; calculates number of entries\n      * in shared spillover area\n      */\n-    public int spillOverCount() {\n+    public int spilloverCount() {\n         // difference between spillover end, start, divided by 4 (four ints per slot)\n-        return (_spillOverEnd - _spilloverStart()) >> 2;\n+        return (_spilloverEnd - _spilloverStart()) >> 2;\n     }\n \n     /*\n     {\n         int offset = _calcOffset(calcHash(q1));\n         // first: primary match?\n-        final int[] hashArea = _hash;\n+        final int[] hashArea = _hashArea;\n \n         int q1b = hashArea[offset];\n         int len = hashArea[offset+3];\n     public String findName(int q1, int q2)\n     {\n         int offset = _calcOffset(calcHash(q1, q2));\n-        final int[] hashArea = _hash;\n+        final int[] hashArea = _hashArea;\n \n         int q1b = hashArea[offset];\n         int len = hashArea[offset+3];\n     {\n         int offset = _calcOffset(calcHash(q1, q2, q3));\n \n-        final int[] hashArea = _hash;\n+        final int[] hashArea = _hashArea;\n \n         int q1b = hashArea[offset];\n         int len = hashArea[offset+3];\n         final int hash = calcHash(q, qlen);\n         int offset = _calcOffset(hash);\n \n-        final int[] hashArea = _hash;\n+        final int[] hashArea = _hashArea;\n \n         final int len = hashArea[offset+3];\n         \n         // NOTE: simple for initial impl, but we may want to interleave it a bit\n         // in near future\n         // So: first, hash into primary hash index\n-        int ix = hash & _hashMask;\n+        int ix = hash & (_hashSize-1);\n         // keeping in mind we have 4 ints per entry\n         return (ix << 2);\n     }\n         int offset = _secondaryOffset + (_secondaryOffset >> 1);\n         offset += (origOffset >> 6) << 2;\n \n-        final int[] hashArea = _hash;\n+        final int[] hashArea = _hashArea;\n \n         // then check up to 4 slots; don't worry about empty slots yet\n         if ((q1 == hashArea[offset]) && (1 == hashArea[offset+3])) {\n         if (len != 0) {\n             // shared spillover starts at 7/8 of the main hash area\n             // (which is sized at 2 * _hashSize), so:\n-            offset = _spilloverStart();\n-            for (int i = 0; i < _spillOverEnd; ++i, offset += 4) {\n+            for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n                 if ((q1 == hashArea[offset]) && (1 == hashArea[offset+3])) {\n                     return _names[offset >> 2];\n                 }\n         int offset = _secondaryOffset + (_secondaryOffset >> 1);\n         offset += (origOffset >> 6) << 2;\n \n-        final int[] hashArea = _hash;\n+        final int[] hashArea = _hashArea;\n         \n         if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (2 == hashArea[offset+3])) {\n             return _names[offset >> 2];\n         if (len != 0) {\n             // shared spillover starts at 7/8 of the main hash area\n             // (which is sized at 2 * _hashSize), so:\n-            offset = _spilloverStart();\n-            for (int i = 0; i < _spillOverEnd; ++i, offset += 4) {\n+            for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n                 if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (2 == hashArea[offset+3])) {\n                     return _names[offset >> 2];\n                 }\n         int offset = _secondaryOffset + (_secondaryOffset >> 1);\n         offset += (origOffset >> 6) << 2;\n \n-        final int[] hashArea = _hash;\n+        final int[] hashArea = _hashArea;\n         \n         if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (q3 == hashArea[offset+2]) && (3 == hashArea[offset+3])) {\n             return _names[offset >> 2];\n         if (len != 0) {\n             // shared spillover starts at 7/8 of the main hash area\n             // (which is sized at 2 * _hashSize), so:\n-            offset = _spilloverStart();\n-            for (; offset < _spillOverEnd; offset += 4) {\n+            for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n                 if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (q3 == hashArea[offset+2])\n                         && (3 == hashArea[offset+3])) {\n                     return _names[offset >> 2];\n         int offset = _secondaryOffset + (_secondaryOffset >> 1);\n         offset += (origOffset >> 6) << 2;\n         \n-        final int[] hashArea = _hash;\n+        final int[] hashArea = _hashArea;\n         \n         if ((hash == hashArea[offset]) && (qlen == hashArea[offset+3])) {\n             if (_verifyLongName(q, qlen, hashArea[offset+1])) {\n         if (len != 0) {\n             // shared spillover starts at 7/8 of the main hash area\n             // (which is sized at 2 * _hashSize), so:\n-            offset = _spilloverStart();\n-            for (int i = 0; i < _spillOverEnd; ++i, offset += 4) {\n+            for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n                 if ((hash == hashArea[offset]) && (3 == len)) {\n                     if (_verifyLongName(q, qlen, hashArea[offset+1])) {\n                         return _names[offset >> 2];\n     \n     private boolean _verifyLongName(int[] q, int qlen, int spillOffset)\n     {\n-        final int[] hashArea = _hash;\n+        final int[] hashArea = _hashArea;\n         // spillOffset assumed to be physical index right into quad string\n-\n+        \n         int ix = 0;\n         do {\n             if (q[ix++] != hashArea[spillOffset++]) {\n         case 1:\n         {\n                 offset = _findOffsetForAdd(calcHash(q[0]));\n-                _hash[offset] = q[0];\n-                _hash[offset+3] = 1;\n+                _hashArea[offset] = q[0];\n+                _hashArea[offset+3] = 1;\n             }\n             break;\n         case 2:\n             {\n                 offset = _findOffsetForAdd(calcHash(q[0], q[1]));\n-                _hash[offset] = q[0];\n-                _hash[offset+1] = q[1];\n-                _hash[offset+3] = 2;\n+                _hashArea[offset] = q[0];\n+                _hashArea[offset+1] = q[1];\n+                _hashArea[offset+3] = 2;\n             }\n             break;\n         case 3:\n             {\n                 offset = _findOffsetForAdd(calcHash(q[0], q[1], q[2]));\n-                _hash[offset] = q[0];\n-                _hash[offset+1] = q[1];\n-                _hash[offset+2] = q[2];\n-                _hash[offset+3] = 3;\n+                _hashArea[offset] = q[0];\n+                _hashArea[offset+1] = q[1];\n+                _hashArea[offset+2] = q[2];\n+                _hashArea[offset+3] = 3;\n             }\n             break;\n         default:\n             final int hash = calcHash(q, qlen);\n             offset = _findOffsetForAdd(hash);\n-            _hash[offset] = hash;\n-            _hash[offset+3] = qlen;\n-            _hash[offset+1] = _appendLongName(q, qlen);\n+\n+            _hashArea[offset] = hash;\n+            int longStart = _appendLongName(q, qlen);\n+            _hashArea[offset+1] = longStart;\n+            _hashArea[offset+3] = qlen;\n         }\n         // plus add the actual String\n         _names[offset >> 2] = name;\n \n         // Yes if above 75%, or above 50% AND have spill-overs\n         if (_count > (_hashSize >> 1)) { // over 50%\n-            if ((_spillOverEnd > _spilloverStart())\n+            if ((_spilloverEnd > _spilloverStart())\n                     || (_count > (_hashSize - (_hashSize >> 2)))) {\n                 _needRehash = true;\n             }\n     private void _verifyRehashAndSharing()\n     {\n         if (_hashShared) {\n-            _hash = Arrays.copyOf(_hash, _hash.length);\n+            _hashArea = Arrays.copyOf(_hashArea, _hashArea.length);\n             _names = Arrays.copyOf(_names, _names.length);\n             _hashShared = false;\n         }\n         if (_needRehash) {\n-            throw new RuntimeException(\"Should resize: count \"+_count+\", hash size \"+_hashSize+\", not yet implemented!\");\n-//            rehash();\n+            rehash();\n         }\n     }\n     \n     {\n         // first, check the primary:\n         int offset = _calcOffset(hash);\n-        final int[] hashArea = _hash;\n+        final int[] hashArea = _hashArea;\n         if (hashArea[offset+3] == 0) {\n             return offset;\n         }\n         }\n \n         // and if even tertiary full, append at the end of spill area\n-        offset = _spillOverEnd;\n-        _spillOverEnd += 4;\n+        offset = _spilloverEnd;\n+        _spilloverEnd += 4;\n+\n+        // one caveat: in the unlikely event if spill-over filling up,\n+        // force rehash for the add that follows\n+        if (_spilloverEnd >= hashArea.length) {\n+            _needRehash = true;\n+        }\n         return offset;\n     }\n \n     private int _appendLongName(int[] quads, int qlen)\n     {\n         int start = _longNameOffset;\n+        \n         // note: at this point we must already be shared. But may not have enough space\n-        if ((start + qlen) > _hash.length) {\n+        if ((start + qlen) > _hashArea.length) {\n             // try to increment in reasonable chunks; at least space that we need\n-            int toAdd = (start + qlen) - _hash.length;\n+            int toAdd = (start + qlen) - _hashArea.length;\n             // but at least 1/8 of regular hash area size or 16kB (whichever smaller)\n             int minAdd = Math.min(4096, _hashSize);\n \n-            int newSize = _hash.length + Math.max(toAdd, minAdd);\n-            _hash = Arrays.copyOf(_hash, newSize);\n-        }\n-        System.arraycopy(quads, 0, _hash, start, qlen);\n+            int newSize = _hashArea.length + Math.max(toAdd, minAdd);\n+            _hashArea = Arrays.copyOf(_hashArea, newSize);\n+        }\n+        System.arraycopy(quads, 0, _hashArea, start, qlen);\n         _longNameOffset += qlen;\n         return start;\n     }\n \n     /*\n     /**********************************************************\n+    /* Rehashing\n+    /**********************************************************\n+     */\n+\n+    private void rehash()\n+    {\n+        _needRehash = false;        \n+        // Note: since we'll make copies, no need to unshare, can just mark as such:\n+        _hashShared = false;\n+\n+        // And then we can first deal with the main hash area. Since we are expanding\n+        // linearly (double up), we know there'll be no collisions during this phase.\n+        final int[] oldHashArea = _hashArea;\n+        final String[] oldNames = _names;\n+        final int oldSize = _hashSize;\n+        final int oldCount = _count;\n+        final int newSize = oldSize + oldSize;\n+\n+        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n+         *    large documents with unique (or mostly so) names\n+         */\n+        if (newSize > MAX_T_SIZE) {\n+            nukeSymbols(true);\n+            return;\n+        }\n+        // double up main hash area, but do not expand long-name area:\n+        _hashArea = new int[oldHashArea.length + (oldSize<<3)];\n+        _hashSize = newSize;\n+        \n+        // and simply double up name array\n+        _names = new String[oldNames.length << 1];\n+        nukeSymbols(false);\n+\n+        // Plus we can scan only through the primary hash area, looking for non-empty\n+        // slots, without worrying about ordering. This should never reduce priority\n+        // of existing entries: primaries remain primaries; however, due to increased\n+        // space, secondaries may become primaries etc\n+\n+        int copyCount = 0;\n+        int[] q = new int[16];\n+        for (int offset = 0, end = oldSize<<3; offset < end; offset += 4) {\n+            int len = oldHashArea[offset+3];\n+            if (len == 0) { // empty slot, skip\n+                continue;\n+            }\n+            ++copyCount;\n+            String name = oldNames[offset>>2];\n+            switch (len) {\n+            case 1:\n+                q[0] = oldHashArea[offset];\n+                addName(name, q, 1);\n+                break;\n+            case 2:\n+                q[0] = oldHashArea[offset];\n+                q[1] = oldHashArea[offset+1];\n+                addName(name, q, 2);\n+                break;\n+            case 3:\n+                q[0] = oldHashArea[offset];\n+                q[1] = oldHashArea[offset+1];\n+                q[2] = oldHashArea[offset+2];\n+                addName(name, q, 3);\n+                break;\n+            default:\n+                if (len > q.length) {\n+                    q = new int[len];\n+                }\n+                // #0 is hash, #1 offset\n+                int qoff = oldHashArea[offset+1];\n+                System.arraycopy(oldHashArea, qoff, q, 0, len);\n+                addName(name, q, len);\n+                break;\n+            }\n+        }\n+\n+        // Sanity checks: since corruption difficult to detect, assert explicitly\n+        // with production code\n+        if (copyCount != oldCount) {\n+            throw new IllegalStateException(\"Failed rehash(): old count=\"+oldCount+\", copyCount=\"+copyCount);\n+        }\n+    }\n+\n+    /**\n+     * Helper method called to empty all shared symbols, but to leave\n+     * arrays allocated\n+     */\n+    private void nukeSymbols(boolean fill) {\n+        _count = 0;\n+        // reset spill-over to empty (starting at 7/8 of hash area)\n+        _spilloverEnd = _spilloverStart();\n+        // and long name area to empty, starting immediately after hash area\n+        _longNameOffset = _hashSize << 3;\n+        if (fill) {\n+            Arrays.fill(_hashArea, 0);\n+            Arrays.fill(_names, null);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n     /* Helper classes\n     /**********************************************************\n      */\n         public final int count;\n         public final int[] mainHash;\n         public final String[] names;\n+        public final int spilloverEnd;\n+        public final int longNameOffset;\n \n         public TableInfo(int size, int count, int[] mainHash, String[] names,\n-                int collCount, int longestCollisionList)\n+                int spilloverEnd, int longNameOffset)\n         {\n             this.size = size;\n             this.count = count;\n             this.mainHash = mainHash;\n             this.names = names;\n+            this.spilloverEnd = spilloverEnd;\n+            this.longNameOffset = longNameOffset;\n         }\n \n         public TableInfo(ByteQuadsCanonicalizer src)\n         {\n             size = src._hashSize;\n             count = src._count;\n-            mainHash = src._hash;\n+            mainHash = src._hashArea;\n             names = src._names;\n+            spilloverEnd = src._spilloverEnd;\n+            longNameOffset = src._longNameOffset;\n         }\n \n         public static TableInfo createInitial(int sz) {\n+            int hashAreaSize = sz << 3;\n+\n             return new TableInfo(sz, // hashSize\n                     0, // count\n-                    new int[sz * 8], // mainHash, 2x slots, 4 ints per slot\n-                    new String[sz + sz],\n-                    0, // collCount,\n-                    0 // longestCollisionList\n+                    new int[hashAreaSize], // mainHash, 2x slots, 4 ints per slot\n+                    new String[sz << 1], // 2x slots\n+                    hashAreaSize - sz, // at 7/8 of the total area\n+                    hashAreaSize // longNameOffset, immediately after main hashes\n             );\n         }\n     }\n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n import java.nio.charset.Charset;\n \n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.core.json.UTF8StreamJsonParser;\n \n public class TestSymbolTables extends com.fasterxml.jackson.core.BaseTest\n {\n         p = f.createParser(JSON.getBytes(\"UTF-8\"));\n         _streamThrough(p);\n         symbols = _findSymbols(p);\n-//        assertEquals(8, symbols.size());\n+        assertEquals(8, symbols.size());\n         p.close();\n \n         p = f.createParser(JSON.getBytes(\"UTF-8\"));", "timestamp": 1423177873, "metainfo": ""}