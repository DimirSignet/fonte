{"sha": "a3de8a04b39930de101cba5e498876c721a6837a", "log": "First part of YAML comments support, for UTF-8-based pasrser", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/io/CharTypes.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/CharTypes.java\n          * but if we want to do lookups by raw bytes it's better\n          * to have full table\n          */\n-        int[] table = new int[256];\n+        final int[] table = new int[256];\n         // Control chars and non-space white space are not allowed unquoted\n         for (int i = 0; i < 32; ++i) {\n             table[i] = -1;\n      * Additionally we can combine UTF-8 decoding info into similar\n      * data table.\n      */\n-    final static int[] sInputCodesUtf8;\n-    static {\n-        int[] table = new int[sInputCodes.length];\n-        System.arraycopy(sInputCodes, 0, table, 0, sInputCodes.length);\n+    final static int[] sInputCodesUTF8;\n+    static {\n+        final int[] table = new int[sInputCodes.length];\n+        System.arraycopy(sInputCodes, 0, table, 0, table.length);\n         for (int c = 128; c < 256; ++c) {\n             int code;\n \n             }\n             table[c] = code;\n         }\n-        sInputCodesUtf8 = table;\n+        sInputCodesUTF8 = table;\n     }\n \n     /**\n      */\n     final static int[] sInputCodesJsNames;\n     static {\n-        int[] table = new int[256];\n+        final int[] table = new int[256];\n         // Default is \"not a name char\", mark ones that are\n         Arrays.fill(table, -1);\n         // Assume rules with JS same as Java (change if/as needed)\n      */\n     final static int[] sInputCodesUtf8JsNames;\n     static {\n-        int[] table = new int[256];\n+        final int[] table = new int[256];\n         // start with 8-bit JS names\n-        System.arraycopy(sInputCodesJsNames, 0, table, 0, sInputCodesJsNames.length);\n+        System.arraycopy(sInputCodesJsNames, 0, table, 0, table.length);\n         Arrays.fill(table, 128, 128, 0);\n         sInputCodesUtf8JsNames = table;\n     }\n \n     /**\n      * Decoding table used to quickly determine characters that are\n-     * relevant within comment content\n-     */\n-    final static int[] sInputCodesComment = new int[256];\n-    static {\n+     * relevant within comment content.\n+     */\n+    final static int[] sInputCodesComment;\n+    static {\n+        final int[] buf = new int[256];\n         // but first: let's start with UTF-8 multi-byte markers:\n-        System.arraycopy(sInputCodesUtf8, 128, sInputCodesComment, 128, 128);\n+        System.arraycopy(sInputCodesUTF8, 128, buf, 128, 128);\n \n         // default (0) means \"ok\" (skip); -1 invalid, others marked by char itself\n-        Arrays.fill(sInputCodesComment, 0, 32, -1); // invalid white space\n-        sInputCodesComment['\\t'] = 0; // tab is still fine\n-        sInputCodesComment['\\n'] = '\\n'; // lf/cr need to be observed, ends cpp comment\n-        sInputCodesComment['\\r'] = '\\r';\n-        sInputCodesComment['*'] = '*'; // end marker for c-style comments\n-    }\n-\n+        Arrays.fill(buf, 0, 32, -1); // invalid white space\n+        buf['\\t'] = 0; // tab is still fine\n+        buf['\\n'] = '\\n'; // lf/cr need to be observed, ends cpp comment\n+        buf['\\r'] = '\\r';\n+        buf['*'] = '*'; // end marker for c-style comments\n+        sInputCodesComment = buf;\n+    }\n+\n+    /**\n+     * Decoding table used for skipping white space and comments.\n+     * \n+     * @since 2.3\n+     */\n+    final static int[] sInputCodesWS;\n+    static {\n+        // but first: let's start with UTF-8 multi-byte markers:\n+        final int[] buf = new int[256];\n+        System.arraycopy(sInputCodesUTF8, 128, buf, 128, 128);\n+\n+        // default (0) means \"not whitespace\" (end); 1 \"whitespace\", -1 invalid,\n+        // 2-4 UTF-8 multi-bytes, others marked by char itself\n+        //\n+        Arrays.fill(buf, 0, 32, -1); // invalid white space\n+        buf[' '] = 1;\n+        buf['\\t'] = 1;\n+        buf['\\n'] = '\\n'; // lf/cr need to be observed, ends cpp comment\n+        buf['\\r'] = '\\r';\n+        buf['/'] = '/'; // start marker for c/cpp comments\n+        buf['#'] = '#'; // start marker for YAML comments\n+        sInputCodesWS = buf;\n+    }\n+    \n     /**\n      * Lookup table used for determining which output characters in\n      * 7-bit ASCII range need to be quoted.\n     }\n \n     public static int[] getInputCodeLatin1() { return sInputCodes; }\n-    public static int[] getInputCodeUtf8() { return sInputCodesUtf8; }\n+    public static int[] getInputCodeUtf8() { return sInputCodesUTF8; }\n \n     public static int[] getInputCodeLatin1JsNames() { return sInputCodesJsNames; }\n     public static int[] getInputCodeUtf8JsNames() { return sInputCodesUtf8JsNames; }\n \n     public static int[] getInputCodeComment() { return sInputCodesComment; }\n+    public static int[] getInputCodeWS() { return sInputCodesWS; }\n \n     /**\n      * Accessor for getting a read-only encoding table for first 128 Unicode\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n     /**********************************************************\n      */\n \n-    protected String _parseFieldName(int i)\n-        throws IOException, JsonParseException\n+    protected String _parseFieldName(int i) throws IOException\n     {\n         if (i != INT_QUOTE) {\n             return _handleUnusualFieldName(i);\n         return _parseFieldName2(start, hash, INT_QUOTE);\n     }\n \n-    private String _parseFieldName2(int startPtr, int hash, int endChar)\n-        throws IOException, JsonParseException\n+    private String _parseFieldName2(int startPtr, int hash, int endChar) throws IOException\n     {\n         _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n \n      * In standard mode will just throw an expection; but\n      * in non-standard modes may be able to parse name.\n      */\n-    protected String _handleUnusualFieldName(int i)\n-        throws IOException, JsonParseException\n+    protected String _handleUnusualFieldName(int i) throws IOException\n     {\n         // [JACKSON-173]: allow single quotes\n         if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n         return _parseUnusualFieldName2(start, hash, codes);\n     }\n \n-    protected String _parseApostropheFieldName()\n-        throws IOException, JsonParseException\n+    protected String _parseApostropheFieldName() throws IOException\n     {\n         // Note: mostly copy of_parseFieldName\n         int ptr = _inputPtr;\n      * Method for handling cases where first non-space character\n      * of an expected value token is not legal for standard JSON content.\n      */\n-    protected JsonToken _handleUnexpectedValue(int i)\n-        throws IOException, JsonParseException\n+    protected JsonToken _handleUnexpectedValue(int i) throws IOException\n     {\n         // Most likely an error, unless we are to allow single-quote-strings\n         switch (i) {\n              * one regular (~= slowish) parsing, to keep code simple\n              */\n             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n-                return _handleApostropheValue();\n+                return _handleApos();\n             }\n             break;\n         case 'N':\n         return null;\n     }\n     \n-    protected JsonToken _handleApostropheValue()\n-        throws IOException, JsonParseException\n+    protected JsonToken _handleApos() throws IOException\n     {\n         char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n         int outPtr = _textBuffer.getCurrentSegmentSize();\n             }\n             char c = _inputBuffer[_inputPtr++];\n             int i = (int) c;\n-            if (i <= '\\'') {\n-                if (i == '\\'') {\n+            if (i <= '\\\\') {\n+                if (i == '\\\\') {\n                     /* Although chars outside of BMP are to be escaped as\n                      * an UTF-16 surrogate pair, does that affect decoding?\n                      * For now let's assume it does not.\n     }\n     \n     private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes)\n-        throws IOException, JsonParseException\n+        throws IOException\n     {\n         _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n         char[] outBuf = _textBuffer.getCurrentSegment();\n     }\n   \n     @Override\n-    protected void _finishString()\n-        throws IOException, JsonParseException\n+    protected void _finishString() throws IOException\n     {\n         /* First: let's try to see if we have simple String value: one\n          * that does not cross input buffer boundary, and does not\n         _finishString2();\n     }\n \n-    protected void _finishString2()\n-        throws IOException, JsonParseException\n+    protected void _finishString2() throws IOException\n     {\n         char[] outBuf = _textBuffer.getCurrentSegment();\n         int outPtr = _textBuffer.getCurrentSegmentSize();\n      * if it is not needed. This can be done bit faster if contents\n      * need not be stored for future access.\n      */\n-    protected void _skipString()\n-        throws IOException, JsonParseException\n+    protected void _skipString() throws IOException\n     {\n         _tokenIncomplete = false;\n \n         _currInputRowStart = _inputPtr;\n     }\n \n-    private int _skipWS()\n-        throws IOException, JsonParseException\n+    private int _skipWS() throws IOException\n     {\n         while (_inputPtr < _inputEnd || loadMore()) {\n             int i = (int) _inputBuffer[_inputPtr++];\n         throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n     }\n \n-    private int _skipWSOrEnd()\n-        throws IOException, JsonParseException\n+    private int _skipWSOrEnd() throws IOException\n     {\n         while ((_inputPtr < _inputEnd) || loadMore()) {\n             int i = (int) _inputBuffer[_inputPtr++];\n         return -1;\n     }\n \n-    private void _skipComment()\n-        throws IOException, JsonParseException\n+    private void _skipComment() throws IOException\n     {\n         if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n             _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n         }\n     }\n \n-    private void _skipCComment()\n-        throws IOException, JsonParseException\n+    private void _skipCComment() throws IOException\n     {\n         // Ok: need the matching '*/'\n         main_loop:\n         _reportInvalidEOF(\" in a comment\");\n     }\n \n-    private void _skipCppComment()\n-        throws IOException, JsonParseException\n+    private void _skipCppComment() throws IOException\n     {\n         // Ok: need to find EOF or linefeed\n         while ((_inputPtr < _inputEnd) || loadMore()) {\n     }\n \n     @Override\n-    protected char _decodeEscaped()\n-        throws IOException, JsonParseException\n+    protected char _decodeEscaped() throws IOException\n     {\n         if (_inputPtr >= _inputEnd) {\n             if (!loadMore()) {\n     /**\n      * Helper method for checking whether input matches expected token\n      */\n-    protected void _matchToken(String matchStr, int i)\n-        throws IOException, JsonParseException\n+    protected void _matchToken(String matchStr, int i) throws IOException\n     {\n         final int len = matchStr.length();\n \n      * textual content.\n      */\n     @SuppressWarnings(\"resource\")\n-    protected byte[] _decodeBase64(Base64Variant b64variant)\n-        throws IOException, JsonParseException\n+    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n     {\n         ByteArrayBuilder builder = _getByteArrayBuilder();\n \n     /**********************************************************\n      */\n \n-    protected void _reportInvalidToken(String matchedPart)\n-            throws IOException, JsonParseException {\n+    protected void _reportInvalidToken(String matchedPart) throws IOException {\n         _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n     }\n     \n     protected void _reportInvalidToken(String matchedPart, String msg)\n-        throws IOException, JsonParseException\n+        throws IOException\n     {\n         StringBuilder sb = new StringBuilder(matchedPart);\n         /* Let's just try to find what appears to be the token, using\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n         Name n = _parseFieldName(i);\n         _parsingContext.setCurrentName(n.getName());\n         _currToken = JsonToken.FIELD_NAME;\n-        i = _skipWS();\n-        if (i != INT_COLON) {\n-            _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n+\n+        // Let's do a quickie check:\n+        if (_inputPtr < _inputEnd && _inputBuffer[_inputPtr] == ':') {\n+            ++_inputPtr;\n+        } else {\n+            i = _skipWS();\n+            if (i != INT_COLON) {\n+                _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n+            }\n         }\n         i = _skipWS();\n \n      */\n \n     @Override\n-    protected void _finishString()\n-        throws IOException, JsonParseException\n+    protected void _finishString() throws IOException\n     {\n         // First, single tight loop for ASCII content, not split across input buffer boundary:        \n         int ptr = _inputPtr;\n     }\n \n     private void _finishString2(char[] outBuf, int outPtr)\n-        throws IOException, JsonParseException\n+        throws IOException\n     {\n         int c;\n \n      * if it is not needed. This can be done bit faster if contents\n      * need not be stored for future access.\n      */\n-    protected void _skipString()\n-        throws IOException, JsonParseException\n+    protected void _skipString() throws IOException\n     {\n         _tokenIncomplete = false;\n \n      * of an expected value token is not legal for standard JSON content.\n      */\n     protected JsonToken _handleUnexpectedValue(int c)\n-        throws IOException, JsonParseException\n+        throws IOException\n     {\n         // Most likely an error, unless we are to allow single-quote-strings\n         switch (c) {\n         case '\\'':\n             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n-                return _handleApostropheValue();\n+                return _handleApos();\n             }\n             break;\n         case 'N':\n         return null;\n     }\n \n-    protected JsonToken _handleApostropheValue()\n-        throws IOException, JsonParseException\n+    protected JsonToken _handleApos()\n+        throws IOException\n     {\n         int c = 0;\n         // Otherwise almost verbatim copy of _finishString()\n \n         return JsonToken.VALUE_STRING;\n     }\n-\n+    \n     /**\n      * Method called if expected numeric value (due to leading sign) does not\n      * look like a number\n      */\n     protected JsonToken _handleInvalidNumberStart(int ch, boolean neg)\n-        throws IOException, JsonParseException\n+        throws IOException\n     {\n         while (ch == 'I') {\n             if (_inputPtr >= _inputEnd) {\n     }\n \n     protected void _matchToken(String matchStr, int i)\n-        throws IOException, JsonParseException\n+        throws IOException\n     {\n         final int len = matchStr.length();\n     \n     }\n \n     protected void _reportInvalidToken(String matchedPart)\n-       throws IOException, JsonParseException\n+       throws IOException\n     {\n         _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n     }\n     \n     protected void _reportInvalidToken(String matchedPart, String msg)\n-        throws IOException, JsonParseException\n+        throws IOException\n     {\n         StringBuilder sb = new StringBuilder(matchedPart);\n \n     /**********************************************************\n      */\n \n-    private int _skipWS()\n-        throws IOException, JsonParseException\n-    {\n+    private final int _skipWS() throws IOException\n+    {\n+        final int[] codes = CharTypes.getInputCodeWS();\n         while (_inputPtr < _inputEnd || loadMore()) {\n-            int i = _inputBuffer[_inputPtr++] & 0xFF;\n-            if (i > INT_SPACE) {\n-                if (i != INT_SLASH) {\n+            final int i = _inputBuffer[_inputPtr++] & 0xFF;\n+            switch (codes[i]) {\n+            case 0: // done!\n+                return i;\n+            case 1: // skip\n+                continue;\n+            case 2: // 2-byte UTF\n+                _skipUtf8_2(i);\n+                break;\n+            case 3: // 3-byte UTF\n+                _skipUtf8_3(i);\n+                break;\n+            case 4: // 4-byte UTF\n+                _skipUtf8_4(i);\n+                break;\n+            case INT_LF:\n+                _skipLF();\n+                break;\n+            case INT_CR:\n+                _skipCR();\n+                break;\n+            case '/':\n+                _skipComment();\n+                break;\n+            case '#':\n+                if (!_skipHashComment()) {\n                     return i;\n                 }\n+                break;\n+            default: // e.g. -1\n+                // Is this good enough error message?\n+                if (i < 32) {\n+                    _throwInvalidSpace(i);\n+                }\n+                _reportInvalidChar(i);\n+            }\n+        }\n+        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n+    }\n+\n+    private int _skipWSOrEnd() throws IOException\n+    {\n+        final int[] codes = CharTypes.getInputCodeWS();\n+        while ((_inputPtr < _inputEnd) || loadMore()) {\n+            final int i = _inputBuffer[_inputPtr++] & 0xFF;\n+            switch (codes[i]) {\n+            case 0: // done!\n+                return i;\n+            case 1: // skip\n+                continue;\n+            case 2: // 2-byte UTF\n+                _skipUtf8_2(i);\n+                break;\n+            case 3: // 3-byte UTF\n+                _skipUtf8_3(i);\n+                break;\n+            case 4: // 4-byte UTF\n+                _skipUtf8_4(i);\n+                break;\n+            case INT_LF:\n+                _skipLF();\n+                break;\n+            case INT_CR:\n+                _skipCR();\n+                break;\n+            case '/':\n                 _skipComment();\n-            } else if (i != INT_SPACE) {\n-                if (i == INT_LF) {\n-                    _skipLF();\n-                } else if (i == INT_CR) {\n-                    _skipCR();\n-                } else if (i != INT_TAB) {\n+                break;\n+            case '#':\n+                if (!_skipHashComment()) {\n+                    return i;\n+                }\n+                break;\n+            default: // e.g. -1\n+                // Is this good enough error message?\n+                if (i < 32) {\n                     _throwInvalidSpace(i);\n                 }\n-            }\n-        }\n-        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n-    }\n-\n-    private int _skipWSOrEnd()\n-        throws IOException, JsonParseException\n-    {\n-        while ((_inputPtr < _inputEnd) || loadMore()) {\n-            int i = _inputBuffer[_inputPtr++] & 0xFF;\n-            if (i > INT_SPACE) {\n-                if (i != INT_SLASH) {\n-                    return i;\n-                }\n-                _skipComment();\n-            } else if (i != INT_SPACE) {\n-                if (i == INT_LF) {\n-                    _skipLF();\n-                } else if (i == INT_CR) {\n-                    _skipCR();\n-                } else if (i != INT_TAB) {\n-                    _throwInvalidSpace(i);\n-                }\n+                _reportInvalidChar(i);\n             }\n         }\n         // We ran out of input...\n      * Helper method for matching and skipping a colon character,\n      * optionally surrounded by white space\n      */\n-    private int _skipColon()\n-        throws IOException, JsonParseException\n+    private int _skipColon() throws IOException\n     {\n         if (_inputPtr >= _inputEnd) {\n             loadMoreGuaranteed();\n         throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n     }\n     \n-    private void _skipComment()\n-        throws IOException, JsonParseException\n+    private void _skipComment() throws IOException\n     {\n         if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n             _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n         }\n     }\n \n-    private void _skipCComment()\n-        throws IOException, JsonParseException\n+    private void _skipCComment() throws IOException\n     {\n         // Need to be UTF-8 aware here to decode content (for skipping)\n         final int[] codes = CharTypes.getInputCodeComment();\n         _reportInvalidEOF(\" in a comment\");\n     }\n \n-    private void _skipCppComment()\n-        throws IOException, JsonParseException\n+    private void _skipCppComment() throws IOException\n     {\n         // Ok: need to find EOF or linefeed\n         final int[] codes = CharTypes.getInputCodeComment();\n         }\n     }\n \n+    protected boolean _skipHashComment() throws IOException\n+    {\n+        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n+            return false;\n+        }\n+        // would plain UTF-8 work?\n+        final int[] codes = CharTypes.getInputCodeComment();\n+        // Skip until line-feed\n+        while ((_inputPtr < _inputEnd) || loadMore()) {\n+            int i = (int) _inputBuffer[_inputPtr++] & 0xFF;\n+            int code = codes[i];\n+            if (code != 0) {\n+                switch (code) {\n+                case '\\n':\n+                    _skipLF();\n+                    return true;\n+                case '\\r':\n+                    _skipCR();\n+                    return true;\n+                case 2: // 2-byte UTF\n+                    _skipUtf8_2(i);\n+                    break;\n+                case 3: // 3-byte UTF\n+                    _skipUtf8_3(i);\n+                    break;\n+                case 4: // 4-byte UTF\n+                    _skipUtf8_4(i);\n+                    break;\n+                default: // e.g. -1\n+                    // Is this good enough error message?\n+                    _reportInvalidChar(i);\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+    \n     @Override\n-    protected char _decodeEscaped()\n-        throws IOException, JsonParseException\n+    protected char _decodeEscaped() throws IOException\n     {\n         if (_inputPtr >= _inputEnd) {\n             if (!loadMore()) {\n         return (char) value;\n     }\n \n-    protected int _decodeCharForError(int firstByte)\n-        throws IOException, JsonParseException\n+    protected int _decodeCharForError(int firstByte) throws IOException\n     {\n         int c = (int) firstByte;\n         if (c < 0) { // if >= 0, is ascii and fine as is\n     /**********************************************************\n      */\n \n-    private int _decodeUtf8_2(int c)\n-        throws IOException, JsonParseException\n+    private int _decodeUtf8_2(int c) throws IOException\n     {\n         if (_inputPtr >= _inputEnd) {\n             loadMoreGuaranteed();\n         return ((c & 0x1F) << 6) | (d & 0x3F);\n     }\n \n-    private int _decodeUtf8_3(int c1)\n-        throws IOException, JsonParseException\n+    private int _decodeUtf8_3(int c1) throws IOException\n     {\n         if (_inputPtr >= _inputEnd) {\n             loadMoreGuaranteed();\n         return c;\n     }\n \n-    private int _decodeUtf8_3fast(int c1)\n-        throws IOException, JsonParseException\n+    private int _decodeUtf8_3fast(int c1) throws IOException\n     {\n         c1 &= 0x0F;\n         int d = (int) _inputBuffer[_inputPtr++];\n      * @return Character value <b>minus 0x10000</c>; this so that caller\n      *    can readily expand it to actual surrogates\n      */\n-    private int _decodeUtf8_4(int c)\n-        throws IOException, JsonParseException\n+    private int _decodeUtf8_4(int c) throws IOException\n     {\n         if (_inputPtr >= _inputEnd) {\n             loadMoreGuaranteed();\n         return ((c << 6) | (d & 0x3F)) - 0x10000;\n     }\n \n-    private void _skipUtf8_2(int c)\n-        throws IOException, JsonParseException\n+    private void _skipUtf8_2(int c) throws IOException\n     {\n         if (_inputPtr >= _inputEnd) {\n             loadMoreGuaranteed();\n     /* Alas, can't heavily optimize skipping, since we still have to\n      * do validity checks...\n      */\n-    private void _skipUtf8_3(int c)\n-        throws IOException, JsonParseException\n+    private void _skipUtf8_3(int c) throws IOException\n     {\n         if (_inputPtr >= _inputEnd) {\n             loadMoreGuaranteed();\n         }\n     }\n \n-    private void _skipUtf8_4(int c)\n-        throws IOException, JsonParseException\n+    private void _skipUtf8_4(int c) throws IOException\n     {\n         if (_inputPtr >= _inputEnd) {\n             loadMoreGuaranteed();\n         _currInputRowStart = _inputPtr;\n     }\n \n-    private int nextByte()\n-        throws IOException, JsonParseException\n+    private int nextByte() throws IOException\n     {\n         if (_inputPtr >= _inputEnd) {\n             loadMoreGuaranteed();\n      * textual content.\n      */\n     @SuppressWarnings(\"resource\")\n-    protected byte[] _decodeBase64(Base64Variant b64variant)\n-        throws IOException, JsonParseException\n+    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n     {\n         ByteArrayBuilder builder = _getByteArrayBuilder();\n ", "timestamp": 1379615536, "metainfo": ""}