{"sha": "ca3efaaed83770ace62e6dd929e110240fbcdfc6", "log": "Merge branch '2.5'  Conflicts: \tpom.xml \trelease-notes/VERSION", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n import com.fasterxml.jackson.core.format.MatchStrength;\n import com.fasterxml.jackson.core.io.*;\n import com.fasterxml.jackson.core.json.*;\n-import com.fasterxml.jackson.core.sym.BytesToNameCanonicalizer;\n+import com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer;\n import com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\n import com.fasterxml.jackson.core.util.BufferRecycler;\n import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\n     implements Versioned,\n         java.io.Serializable // since 2.1 (for Android, mostly)\n {\n-    /**\n-     * Computed for Jackson 2.4.0 release\n-     */\n-    private static final long serialVersionUID = 3306684576057132431L;\n+    private static final long serialVersionUID = 1; // since 2.6.0\n \n     /*\n     /**********************************************************\n          */\n         FAIL_ON_SYMBOL_HASH_OVERFLOW(true),\n \n+        /**\n+         * Feature that determines whether we will use {@link BufferRecycler} with\n+         * {@link ThreadLocal} and {@link SoftReference}, for efficient reuse of\n+         * underlying input/output buffers.\n+         * This usually makes sense on normal J2SE/J2EE server-side processing;\n+         * but may not make sense on platforms where {@link SoftReference} handling\n+         * is broken (like Android), or if there are retention issues due to\n+         * {@link ThreadLocal} (see\n+         * <a href=\"https://github.com/FasterXML/jackson-core/issues/189\">Issue #189</a>\n+         * for a possible case)\n+         *\n+         * @since 2.6\n+         */\n+        USE_THREAD_LOCAL_FOR_BUFFER_RECYCLING(true)\n+        \n         ;\n \n         /**\n      *<p>\n      * TODO: should clean up this; looks messy having 2 alternatives\n      * with not very clear differences.\n-     */\n-    protected final transient BytesToNameCanonicalizer _rootByteSymbols = BytesToNameCanonicalizer.createRoot();\n+     * \n+     * @since 2.6.0\n+     */\n+    protected final transient ByteQuadsCanonicalizer _byteSymbolCanonicalizer = ByteQuadsCanonicalizer.createRoot();\n+\n+    /**\n+     * Earlier byte-based symbol table; replaced with 2.6 with a new implementation.\n+     * Left in for version 2.6.0: will be removed in 2.7 or later.\n+     *\n+     * @deprecated Since 2.6.0, only use {@link #_byteSymbolCanonicalizer}\n+     */\n+    @Deprecated\n+    protected final transient com.fasterxml.jackson.core.sym.BytesToNameCanonicalizer _rootByteSymbols\n+        = com.fasterxml.jackson.core.sym.BytesToNameCanonicalizer.createRoot();\n \n     /*\n     /**********************************************************\n     protected JsonParser _createParser(InputStream in, IOContext ctxt) throws IOException {\n         // As per [JACKSON-259], may want to fully disable canonicalization:\n         return new ByteSourceJsonBootstrapper(ctxt, in).constructParser(_parserFeatures,\n-                _objectCodec, _rootByteSymbols, _rootCharSymbols, _factoryFeatures);\n+                _objectCodec, _byteSymbolCanonicalizer, _rootCharSymbols, _factoryFeatures);\n     }\n \n     /**\n     protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException\n     {\n         return new ByteSourceJsonBootstrapper(ctxt, data, offset, len).constructParser(_parserFeatures,\n-                _objectCodec, _rootByteSymbols, _rootCharSymbols, _factoryFeatures);\n+                _objectCodec, _byteSymbolCanonicalizer, _rootCharSymbols, _factoryFeatures);\n     }\n \n     /*\n      */\n     public BufferRecycler _getBufferRecycler()\n     {\n-        SoftReference<BufferRecycler> ref = _recyclerRef.get();\n-        BufferRecycler br = (ref == null) ? null : ref.get();\n-\n-        if (br == null) {\n+        BufferRecycler br;\n+\n+        /* 23-Apr-2015, tatu: Let's allow disabling of buffer recycling\n+         *   scheme, for cases where it is considered harmful (possibly\n+         *   on Android, for example)\n+         */\n+        if (isEnabled(Feature.USE_THREAD_LOCAL_FOR_BUFFER_RECYCLING)) {\n+            SoftReference<BufferRecycler> ref = _recyclerRef.get();\n+            br = (ref == null) ? null : ref.get();\n+    \n+            if (br == null) {\n+                br = new BufferRecycler();\n+                _recyclerRef.set(new SoftReference<BufferRecycler>(br));\n+            }\n+        } else {\n             br = new BufferRecycler();\n-            _recyclerRef.set(new SoftReference<BufferRecycler>(br));\n         }\n         return br;\n     }\n--- a/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n  */\n package com.fasterxml.jackson.core;\n \n-import static com.fasterxml.jackson.core.JsonTokenId.ID_EMBEDDED_OBJECT;\n-import static com.fasterxml.jackson.core.JsonTokenId.ID_END_ARRAY;\n-import static com.fasterxml.jackson.core.JsonTokenId.ID_END_OBJECT;\n-import static com.fasterxml.jackson.core.JsonTokenId.ID_FALSE;\n-import static com.fasterxml.jackson.core.JsonTokenId.ID_FIELD_NAME;\n-import static com.fasterxml.jackson.core.JsonTokenId.ID_NOT_AVAILABLE;\n-import static com.fasterxml.jackson.core.JsonTokenId.ID_NULL;\n-import static com.fasterxml.jackson.core.JsonTokenId.ID_NUMBER_FLOAT;\n-import static com.fasterxml.jackson.core.JsonTokenId.ID_NUMBER_INT;\n-import static com.fasterxml.jackson.core.JsonTokenId.ID_START_ARRAY;\n-import static com.fasterxml.jackson.core.JsonTokenId.ID_START_OBJECT;\n-import static com.fasterxml.jackson.core.JsonTokenId.ID_STRING;\n-import static com.fasterxml.jackson.core.JsonTokenId.ID_TRUE;\n+import static com.fasterxml.jackson.core.JsonTokenId.*;\n \n import java.io.*;\n import java.math.BigDecimal;\n      * Enumeration that defines all togglable features for generators.\n      */\n     public enum Feature {\n+        // // Low-level I/O / content features\n+        \n         /**\n          * Feature that determines whether generator will automatically\n          * close underlying output target that is NOT owned by the\n          */\n         AUTO_CLOSE_JSON_CONTENT(true),\n \n+        /**\n+         * Feature that specifies that calls to {@link #flush} will cause\n+         * matching <code>flush()</code> to underlying {@link OutputStream}\n+         * or {@link Writer}; if disabled this will not be done.\n+         * Main reason to disable this feature is to prevent flushing at\n+         * generator level, if it is not possible to prevent method being\n+         * called by other code (like <code>ObjectMapper</code> or third\n+         * party libraries).\n+         *<p>\n+         * Feature is enabled by default.\n+         */\n+        FLUSH_PASSED_TO_STREAM(true),\n+\n+        // // Quoting-related features\n+        \n         /**\n          * Feature that determines whether JSON Object field names are\n          * quoted using double-quotes, as specified by JSON specification\n          * @since 2.3\n          */\n         WRITE_BIGDECIMAL_AS_PLAIN(false),\n-        \n-        /**\n-         * Feature that specifies that calls to {@link #flush} will cause\n-         * matching <code>flush()</code> to underlying {@link OutputStream}\n-         * or {@link Writer}; if disabled this will not be done.\n-         * Main reason to disable this feature is to prevent flushing at\n-         * generator level, if it is not possible to prevent method being\n-         * called by other code (like <code>ObjectMapper</code> or third\n-         * party libraries).\n-         *<p>\n-         * Feature is enabled by default.\n-         */\n-        FLUSH_PASSED_TO_STREAM(true),\n         \n         /**\n          * Feature that specifies that all characters beyond 7-bit ASCII\n          */\n         ESCAPE_NON_ASCII(false),\n \n+        // // Schema/Validity support features\n+\n         /**\n          * Feature that determines whether {@link JsonGenerator} will explicitly\n          * check that no duplicate JSON Object field names are written.\n          * @since 2.3\n          */\n         STRICT_DUPLICATE_DETECTION(false),\n-\n+        \n         /**\n          * Feature that determines what to do if the underlying data format requires knowledge\n          * of all properties to output, and if no definition is found for a property that\n      * are allowed: meaning everywhere except for when\n      * a field name is expected.\n      */\n-    public abstract void writeStartObject()\n-        throws IOException;\n+    public abstract void writeStartObject() throws IOException;\n \n     /**\n      * Method for writing closing marker of a JSON Object value\n      * complete value, or START-OBJECT marker (see JSON specification\n      * for more details).\n      */\n-    public abstract void writeEndObject()\n-        throws IOException;\n+    public abstract void writeEndObject() throws IOException;\n \n     /**\n      * Method for writing a field name (JSON String surrounded by\n      * JSON specification for details), when field name is expected\n      * (field names alternate with values).\n      */\n-    public abstract void writeFieldName(String name)\n-        throws IOException;\n+    public abstract void writeFieldName(String name) throws IOException;\n \n     /**\n      * Method similar to {@link #writeFieldName(String)}, main difference\n      * serialized String; implementations are strongly encouraged to make\n      * use of more efficient methods argument object has.\n      */\n-    public abstract void writeFieldName(SerializableString name)\n-        throws IOException;\n+    public abstract void writeFieldName(SerializableString name) throws IOException;\n \n     /*\n     /**********************************************************\n      * surrounded in double quotes, and contents will be properly\n      * escaped as required by JSON specification.\n      */\n-    public abstract void writeString(String text)\n-        throws IOException;\n+    public abstract void writeString(String text) throws IOException;\n \n     /**\n      * Method for outputting a String value. Depending on context\n      * surrounded in double quotes, and contents will be properly\n      * escaped as required by JSON specification.\n      */\n-    public abstract void writeString(char[] text, int offset, int len)\n-        throws IOException;\n+    public abstract void writeString(char[] text, int offset, int len) throws IOException;\n \n     /**\n      * Method similar to {@link #writeString(String)}, but that takes\n      * sub-classes should override it with more efficient implementation\n      * if possible.\n      */\n-    public abstract void writeString(SerializableString text)\n-        throws IOException;\n+    public abstract void writeString(SerializableString text) throws IOException;\n \n     /**\n      * Method similar to {@link #writeString(String)} but that takes as\n--- a/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n           * @since 2.3\n           */\n          STRICT_DUPLICATE_DETECTION(false),\n-            ;\n+\n+         /**\n+          * Feature that determines what to do if the underlying data format requires knowledge\n+          * of all properties to decode (usually via a Schema), and if no definition is\n+          * found for a property that input content contains.\n+          * Typically most textual data formats do NOT require schema information (although\n+          * some do, such as CSV), whereas many binary data formats do require definitions\n+          * (such as Avro, protobuf), although not all (Smile, CBOR, BSON and MessagePack do not).\n+          * Further note that some formats that do require schema information will not be able\n+          * to ignore undefined properties: for example, Avro is fully positional and there is\n+          * no possibility of undefined data. This leaves formats like Protobuf that have identifiers\n+          * that may or may not map; and as such Protobuf format does make use of this feature.\n+          *<p>\n+          * Note that support for this feature is implemented by individual data format\n+          * module, if (and only if) it makes sense for the format in question. For JSON,\n+          * for example, this feature has no effect as properties need not be pre-defined.\n+          *<p>\n+          * Feature is disabled by default, meaning that if the underlying data format\n+          * requires knowledge of all properties to output, attempts to read an unknown\n+          * property will result in a {@link JsonProcessingException}\n+          *\n+          * @since 2.6\n+          */\n+         IGNORE_UNDEFINED(false)\n+         ;\n \n         /**\n          * Whether feature is enabled or disabled by default.\n      * @since 2.5\n      */\n     public String nextFieldName() throws IOException, JsonParseException {\n-        return (nextToken() == JsonToken.FIELD_NAME)\n-                ? getCurrentName() : null;\n+        return (nextToken() == JsonToken.FIELD_NAME) ? getCurrentName() : null;\n     }\n \n     /**\n      */\n     public abstract boolean hasTokenId(int id);\n \n+    /**\n+     * Method that is functionally equivalent to:\n+     *<code>\n+     *  return getCurrentTokenId() == id\n+     *</code>\n+     * but may be more efficiently implemented.\n+     *<p>\n+     * Note that no traversal or conversion is performed; so in some\n+     * cases calling method like {@link #isExpectedStartArrayToken()}\n+     * is necessary instead.\n+     *\n+     * @since 2.6\n+     */\n+    public abstract boolean hasToken(JsonToken t);\n+    \n     /**\n      * Method that can be called to get the name associated with\n      * the current token: for {@link JsonToken#FIELD_NAME}s it will\n--- a/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\n     }\n     \n     public JsonPointer matchProperty(String name) {\n-        if (_nextSegment == null || !_matchingPropertyName.equals(name)) {\n-            return null;\n-        }\n-        return _nextSegment;\n+        if ((_nextSegment != null) && _matchingPropertyName.equals(name)) {\n+            return _nextSegment;\n+        }\n+        return null;\n     }\n \n     /**\n      */\n     public boolean matchesElement(int index) {\n         return (index == _matchingElementIndex) && (index >= 0);\n+    }\n+\n+    /**\n+     * @since 2.6\n+     */\n+    public JsonPointer matchElement(int index) {\n+        if ((index != _matchingElementIndex) || (index < 0)) {\n+            return null;\n+        }\n+        return _nextSegment;\n     }\n \n     /**\n--- a/src/main/java/com/fasterxml/jackson/core/PrettyPrinter.java\n+++ b/src/main/java/com/fasterxml/jackson/core/PrettyPrinter.java\n      * to output a curly bracket as well, but can surround that\n      * with other (white-space) decoration.\n      */\n-    void writeStartObject(JsonGenerator jg)\n+    void writeStartObject(JsonGenerator gen)\n         throws IOException, JsonGenerationException;\n \n     /**\n      * @param nrOfEntries Number of direct members of the array that\n      *   have been output\n      */\n-    void writeEndObject(JsonGenerator jg, int nrOfEntries)\n+    void writeEndObject(JsonGenerator gen, int nrOfEntries)\n         throws IOException, JsonGenerationException;\n \n     /**\n      * to output a comma as well, but can surround that with other\n      * (white-space) decoration.\n      */\n-    void writeObjectEntrySeparator(JsonGenerator jg)\n+    void writeObjectEntrySeparator(JsonGenerator gen)\n         throws IOException, JsonGenerationException;\n \n     /**\n      * to output a colon as well, but can surround that with other\n      * (white-space) decoration.\n      */\n-    void writeObjectFieldValueSeparator(JsonGenerator jg)\n+    void writeObjectFieldValueSeparator(JsonGenerator gen)\n         throws IOException, JsonGenerationException;\n \n     // // // Array handling\n      * to output a bracket as well, but can surround that\n      * with other (white-space) decoration.\n      */\n-    void writeStartArray(JsonGenerator jg)\n+    void writeStartArray(JsonGenerator gen)\n         throws IOException, JsonGenerationException;\n \n     /**\n      * @param nrOfValues Number of direct members of the array that\n      *   have been output\n      */\n-    void writeEndArray(JsonGenerator jg, int nrOfValues)\n+    void writeEndArray(JsonGenerator gen, int nrOfValues)\n         throws IOException, JsonGenerationException;\n \n     /**\n      * to output a comma as well, but can surround that with other\n      * (white-space) decoration.\n      */\n-    void writeArrayValueSeparator(JsonGenerator jg)\n+    void writeArrayValueSeparator(JsonGenerator gen)\n         throws IOException, JsonGenerationException;\n \n     /*\n      * Default handling does not output anything, but pretty-printer\n      * is free to add any white space decoration.\n      */\n-    void beforeArrayValues(JsonGenerator jg)\n+    void beforeArrayValues(JsonGenerator gen)\n         throws IOException, JsonGenerationException;\n \n     /**\n      * Default handling does not output anything, but pretty-printer\n      * is free to add any white space decoration.\n      */\n-    void beforeObjectEntries(JsonGenerator jg)\n+    void beforeObjectEntries(JsonGenerator gen)\n         throws IOException, JsonGenerationException;\n }\n \n--- a/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n             | Feature.STRICT_DUPLICATE_DETECTION.getMask()\n             ;\n \n+    // // // Constants for validation messages (since 2.6)\n+\n+    protected final String WRITE_BINARY = \"write a binary value\";\n+    protected final String WRITE_BOOLEAN = \"write a boolean value\";\n+    protected final String WRITE_NULL = \"write a null\";\n+    protected final String WRITE_NUMBER = \"write a number\";\n+    protected final String WRITE_RAW = \"write a raw (unencoded) value\";\n+    protected final String WRITE_STRING = \"write a string\";\n+\n     /*\n     /**********************************************************\n     /* Configuration\n     }\n \n     /**\n-     * Implemented with detection that tries to find \"VERSION.txt\" in same\n-     * package as the implementation class.\n+     * Implemented with standard version number detection algorithm, typically using\n+     * a simple generated class, with information extracted from Maven project file\n+     * during build.\n      */\n     @Override public Version version() { return VersionUtil.versionFor(getClass()); }\n \n         if (getPrettyPrinter() != null) {\n             return this;\n         }\n-        return setPrettyPrinter(new DefaultPrettyPrinter());\n+        return setPrettyPrinter(_constructDefaultPrettyPrinter());\n     }\n     \n     @Override public JsonGenerator setCodec(ObjectCodec oc) {\n      */\n     protected abstract void _verifyValueWrite(String typeMsg) throws IOException;\n \n+    /**\n+     * Overridable factory method called to instantiate an appropriate {@link PrettyPrinter}\n+     * for case of \"just use the default one\", when {@link #useDefaultPrettyPrinter()} is called.\n+     *\n+     * @since 2.6\n+     */\n+    protected PrettyPrinter _constructDefaultPrettyPrinter() {\n+        return new DefaultPrettyPrinter();\n+    }\n+\n     /*\n     /**********************************************************\n     /* UTF-8 related helper method(s)\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n      */\n \n     protected ParserBase(IOContext ctxt, int features) {\n-        super();\n-        _features = features;\n+        super(features);\n         _ioContext = ctxt;\n         _textBuffer = ctxt.constructTextBuffer();\n         DupDetector dups = Feature.STRICT_DUPLICATE_DETECTION.enabledIn(features)\n     {\n         if ((_numTypesValid & NR_INT) == 0) {\n             if (_numTypesValid == NR_UNKNOWN) { // not parsed at all\n-                _parseNumericValue(NR_INT); // will also check event type\n+                return _parseIntValue();\n             }\n             if ((_numTypesValid & NR_INT) == 0) { // wasn't an int natively?\n                 convertNumberToInt(); // let's make it so, if possible\n         }\n         _reportError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\");\n     }\n-    \n+\n+    /**\n+     * @since 2.6\n+     */\n+    protected int _parseIntValue() throws IOException\n+    {\n+        // Inlined variant of: _parseNumericValue(NR_INT)\n+\n+        if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n+            char[] buf = _textBuffer.getTextBuffer();\n+            int offset = _textBuffer.getTextOffset();\n+            int len = _intLength;\n+            if (_numberNegative) {\n+                ++offset;\n+            }\n+            if (len <= 9) {\n+                int i = NumberInput.parseInt(buf, offset, len);\n+                if (_numberNegative) {\n+                    i = -i;\n+                }\n+                _numberInt = i;\n+                _numTypesValid = NR_INT;\n+                return i;\n+            }\n+        }\n+        _parseNumericValue(NR_INT);\n+        if ((_numTypesValid & NR_INT) == 0) {\n+            convertNumberToInt();\n+        }\n+        return _numberInt;\n+    }\n+\n     private void _parseSlowFloat(int expType) throws IOException\n     {\n         /* Nope: floating point. Here we need to be careful to get\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n     /* Minimal generally useful state\n     /**********************************************************\n      */\n-    \n+\n     /**\n      * Last token retrieved via {@link #nextToken}, if any.\n      * Null before the first call to <code>nextToken()</code>,\n      * effect when {@link #clearCurrentToken} was called.\n      */\n     protected JsonToken _lastClearedToken;\n-    \n+\n     /*\n     /**********************************************************\n     /* Life-cycle\n \n     // NOTE: had base impl in 2.3 and before; but shouldn't\n     // public abstract Version version();\n-    \n+\n     /*\n     /**********************************************************\n     /* Configuration overrides if any\n         return t.id() == id;\n     }\n \n+    @Override public final boolean hasToken(JsonToken t) {\n+        return (_currToken == t);\n+    }\n+    \n     @Override public boolean isExpectedStartArrayToken() { return _currToken == JsonToken.START_ARRAY; }\n     @Override public boolean isExpectedStartObjectToken() { return _currToken == JsonToken.START_OBJECT; }\n     \n     }\n \n     @Override\n+    public int getValueAsInt() throws IOException\n+    {\n+        JsonToken t = _currToken;\n+        if (t == JsonToken.VALUE_NUMBER_INT) {\n+            return getIntValue();\n+        }\n+        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n+            return getIntValue();\n+        }\n+        return getValueAsInt(0);\n+    }\n+\n+    @Override\n     public int getValueAsInt(int defaultValue) throws IOException\n     {\n         JsonToken t = _currToken;\n+        if (t == JsonToken.VALUE_NUMBER_INT) {\n+            return getIntValue();\n+        }\n+        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n+            return getIntValue();\n+        }\n         if (t != null) {\n             switch (t.id()) {\n             case ID_STRING:\n                     return 0;\n                 }\n                 return NumberInput.parseAsInt(str, defaultValue);\n-            case ID_NUMBER_INT:\n-            case ID_NUMBER_FLOAT:\n-                return getIntValue();\n             case ID_TRUE:\n                 return 1;\n             case ID_FALSE:\n         }\n         return defaultValue;\n     }\n+\n+    @Override\n+    public long getValueAsLong() throws IOException\n+    {\n+        JsonToken t = _currToken;\n+        if (t == JsonToken.VALUE_NUMBER_INT) {\n+            return getLongValue();\n+        }\n+        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n+            return getLongValue();\n+        }\n+        return getValueAsLong(0L);\n+    }\n     \n     @Override\n     public long getValueAsLong(long defaultValue) throws IOException\n     {\n         JsonToken t = _currToken;\n+        if (t == JsonToken.VALUE_NUMBER_INT) {\n+            return getLongValue();\n+        }\n+        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n+            return getLongValue();\n+        }\n         if (t != null) {\n             switch (t.id()) {\n             case ID_STRING:\n                     return 0L;\n                 }\n                 return NumberInput.parseAsLong(str, defaultValue);\n-            case ID_NUMBER_INT:\n-            case ID_NUMBER_FLOAT:\n-                return getLongValue();\n             case ID_TRUE:\n                 return 1L;\n             case ID_FALSE:\n     }\n \n     @Override\n+    public String getValueAsString() throws IOException {\n+        if (_currToken == JsonToken.VALUE_STRING) {\n+            return getText();\n+        }\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+            return getCurrentName();\n+        }\n+        return getValueAsString(null);\n+    }\n+    \n+    @Override\n     public String getValueAsString(String defaultValue) throws IOException {\n-        if (_currToken != JsonToken.VALUE_STRING) {\n-            if (_currToken == null || _currToken == JsonToken.VALUE_NULL || !_currToken.isScalarValue()) {\n-                return defaultValue;\n-            }\n+        if (_currToken == JsonToken.VALUE_STRING) {\n+            return getText();\n+        }\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+            return getCurrentName();\n+        }\n+        if (_currToken == null || _currToken == JsonToken.VALUE_NULL || !_currToken.isScalarValue()) {\n+            return defaultValue;\n         }\n         return getText();\n     }\n         } catch (IllegalArgumentException e) {\n             _reportError(e.getMessage());\n         }\n-    }\n-\n-    /**\n-     * @param bindex Relative index within base64 character unit; between 0\n-     *   and 3 (as unit has exactly 4 characters)\n-     *   \n-     * @deprecated in 2.2.3; should migrate away\n-     */\n-    @Deprecated\n-    protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg)\n-        throws JsonParseException\n-    {\n-        String base;\n-        if (ch <= INT_SPACE) {\n-            base = \"Illegal white space character (code 0x\"+Integer.toHexString(ch)+\") as character #\"+(bindex+1)+\" of 4-char base64 unit: can only used between units\";\n-        } else if (b64variant.usesPaddingChar(ch)) {\n-            base = \"Unexpected padding character ('\"+b64variant.getPaddingChar()+\"') as character #\"+(bindex+1)+\" of 4-char base64 unit: padding only legal as 3rd or 4th character\";\n-        } else if (!Character.isDefined(ch) || Character.isISOControl(ch)) {\n-            // Not sure if we can really get here... ? (most illegal xml chars are caught at lower level)\n-            base = \"Illegal character (code 0x\"+Integer.toHexString(ch)+\") in base64 content\";\n-        } else {\n-            base = \"Illegal character '\"+ch+\"' (code 0x\"+Integer.toHexString(ch)+\") in base64 content\";\n-        }\n-        if (msg != null) {\n-            base = base + \": \" + msg;\n-        }\n-        throw _constructError(base);\n-    }\n-\n-    /**\n-     *   \n-     * @deprecated in 2.2.3; should migrate away\n-     */\n-    @Deprecated\n-    protected void _reportBase64EOF() throws JsonParseException {\n-        throw _constructError(\"Unexpected end-of-String in base64 content\");\n     }\n \n     /*\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/FilteringGeneratorDelegate.java\n+package com.fasterxml.jackson.core.filter;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.util.JsonGeneratorDelegate;\n+\n+/**\n+ * Specialized {@link JsonGeneratorDelegate} that allows use of\n+ * {@link TokenFilter} for outputting a subset of content that\n+ * caller tries to generate.\n+ * \n+ * @since 2.6\n+ */\n+public class FilteringGeneratorDelegate extends JsonGeneratorDelegate\n+{\n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Object consulted to determine whether to write parts of content generator\n+     * is asked to write or not.\n+     */\n+    protected TokenFilter rootFilter;\n+\n+    /**\n+     * Flag that determines whether filtering will continue after the first\n+     * match is indicated or not: if `false`, output is based on just the first\n+     * full match (returning {@link TokenFilter#INCLUDE_ALL}) and no more\n+     * checks are made; if `true` then filtering will be applied as necessary\n+     * until end of content.\n+     */\n+    protected boolean _allowMultipleMatches;\n+\n+    /**\n+     * Flag that determines whether path leading up to included content should\n+     * also be automatically included or not. If `false`, no path inclusion is\n+     * done and only explicitly included entries are output; if `true` then\n+     * path from main level down to match is also included as necessary.\n+     */\n+    protected boolean _includePath;\n+\n+    /* NOTE: this feature is included in the first version (2.6), but\n+     * there is no public API to enable it, yet, since there isn't an\n+     * actual use case. But it seemed possible need could arise, which\n+     * is feature has not yet been removed. If no use is found within\n+     * first version or two, just remove.\n+     * \n+     * Marked as deprecated since its status is uncertain.\n+     */\n+    @Deprecated\n+    protected boolean _includeImmediateParent = false;\n+\n+    /*\n+    /**********************************************************\n+    /* Additional state\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Although delegate has its own output context it is not sufficient since we actually\n+     * have to keep track of excluded (filtered out) structures as well as ones delegate\n+     * actually outputs.\n+     */\n+    protected TokenFilterContext _filterContext;\n+\n+    /**\n+     * State that applies to the item within container, used where applicable.\n+     * Specifically used to pass inclusion state between property name and\n+     * property, and also used for array elements.\n+     */\n+    protected TokenFilter _itemFilter;\n+    \n+    /**\n+     * Number of tokens for which {@link TokenFilter#INCLUDE_ALL}\n+     * has been returned\n+     */\n+    protected int _matchCount;\n+\n+    /*\n+    /**********************************************************\n+    /* Construction, initialization\n+    /**********************************************************\n+     */\n+\n+    public FilteringGeneratorDelegate(JsonGenerator d, TokenFilter f,\n+            boolean includePath, boolean allowMultipleMatches)\n+    {\n+        // By default, do NOT delegate copy methods\n+        super(d, false);\n+        rootFilter = f;\n+        // and this is the currently active filter for root values\n+        _itemFilter = f;\n+        _filterContext = TokenFilterContext.createRootContext(f);\n+        _includePath = includePath;\n+        _allowMultipleMatches = allowMultipleMatches;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended API\n+    /**********************************************************\n+     */\n+\n+    public TokenFilter getFilter() { return rootFilter; }\n+\n+    public JsonStreamContext getFilterContext() {\n+        return _filterContext;\n+    }\n+    \n+    /**\n+     * Accessor for finding number of matches, where specific token and sub-tree\n+     * starting (if structured type) are passed.\n+     */\n+    public int getMatchCount() {\n+        return _matchCount;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, accessors\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public JsonStreamContext getOutputContext() {\n+        /* 11-Apr-2015, tatu: Choice is between pre- and post-filter context;\n+         *   let's expose post-filter context that correlates with the view\n+         *   of caller.\n+         */\n+        return _filterContext;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, structural\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public void writeStartArray() throws IOException\n+    {\n+        // First things first: whole-sale skipping easy\n+        if (_itemFilter == null) {\n+            _filterContext = _filterContext.createChildArrayContext(null, false);\n+            return;\n+        }\n+        if (_itemFilter == TokenFilter.INCLUDE_ALL) { // include the whole sub-tree?\n+            _filterContext = _filterContext.createChildArrayContext(_itemFilter, true);\n+            delegate.writeStartArray();\n+            return;\n+        }\n+        // Ok; regular checking state then\n+        _itemFilter = _filterContext.checkValue(_itemFilter);\n+        if (_itemFilter == null) {\n+            _filterContext = _filterContext.createChildArrayContext(null, false);\n+            return;\n+        }\n+        if (_itemFilter != TokenFilter.INCLUDE_ALL) {\n+            _itemFilter = _itemFilter.filterStartArray();\n+        }\n+        if (_itemFilter == TokenFilter.INCLUDE_ALL) {\n+            _checkParentPath();\n+            _filterContext = _filterContext.createChildArrayContext(_itemFilter, true);\n+            delegate.writeStartArray();\n+        } else {\n+            _filterContext = _filterContext.createChildArrayContext(_itemFilter, false);\n+        }\n+    }\n+        \n+    @Override\n+    public void writeStartArray(int size) throws IOException\n+    {\n+        if (_itemFilter == null) {\n+            _filterContext = _filterContext.createChildArrayContext(null, false);\n+            return;\n+        }\n+        if (_itemFilter == TokenFilter.INCLUDE_ALL) {\n+            _filterContext = _filterContext.createChildArrayContext(_itemFilter, true);\n+            delegate.writeStartArray(size);\n+            return;\n+        }\n+        _itemFilter = _filterContext.checkValue(_itemFilter);\n+        if (_itemFilter == null) {\n+            _filterContext = _filterContext.createChildArrayContext(null, false);\n+            return;\n+        }\n+        if (_itemFilter != TokenFilter.INCLUDE_ALL) {\n+            _itemFilter = _itemFilter.filterStartArray();\n+        }\n+        if (_itemFilter == TokenFilter.INCLUDE_ALL) {\n+            _checkParentPath();\n+            _filterContext = _filterContext.createChildArrayContext(_itemFilter, true);\n+            delegate.writeStartArray(size);\n+        } else {\n+            _filterContext = _filterContext.createChildArrayContext(_itemFilter, false);\n+        }\n+    }\n+    \n+    @Override\n+    public void writeEndArray() throws IOException\n+    {\n+        _filterContext = _filterContext.closeArray(delegate);\n+\n+        if (_filterContext != null) {\n+            _itemFilter = _filterContext.getFilter();\n+        }\n+    }\n+\n+    @Override\n+    public void writeStartObject() throws IOException\n+    {\n+        if (_itemFilter == null) {\n+            _filterContext = _filterContext.createChildObjectContext(_itemFilter, false);\n+            return;\n+        }\n+        if (_itemFilter == TokenFilter.INCLUDE_ALL) {\n+            _filterContext = _filterContext.createChildObjectContext(_itemFilter, true);\n+            delegate.writeStartObject();\n+            return;\n+        }\n+\n+        TokenFilter f = _filterContext.checkValue(_itemFilter);\n+        if (f == null) {\n+            return;\n+        }\n+        \n+        if (f != TokenFilter.INCLUDE_ALL) {\n+            f = f.filterStartObject();\n+        }\n+        if (f == TokenFilter.INCLUDE_ALL) {\n+            _checkParentPath();\n+            _filterContext = _filterContext.createChildObjectContext(f, true);\n+            delegate.writeStartObject();\n+        } else { // filter out\n+            _filterContext = _filterContext.createChildObjectContext(f, false);\n+        }\n+    }\n+    \n+    @Override\n+    public void writeEndObject() throws IOException\n+    {\n+        _filterContext = _filterContext.closeObject(delegate);\n+        if (_filterContext != null) {\n+            _itemFilter = _filterContext.getFilter();\n+        }\n+    }\n+\n+    @Override\n+    public void writeFieldName(String name) throws IOException\n+    {\n+        TokenFilter state = _filterContext.setFieldName(name);\n+        if (state == null) {\n+            _itemFilter = null;\n+            return;\n+        }\n+        if (state == TokenFilter.INCLUDE_ALL) {\n+            _itemFilter = state;\n+            delegate.writeFieldName(name);\n+            return;\n+        }\n+        state = state.includeProperty(name);\n+        _itemFilter = state;\n+        if (state == TokenFilter.INCLUDE_ALL) {\n+            _checkPropertyParentPath();\n+        }\n+    }\n+\n+    @Override\n+    public void writeFieldName(SerializableString name) throws IOException\n+    {\n+        TokenFilter state = _filterContext.setFieldName(name.getValue());\n+        if (state == null) {\n+            _itemFilter = null;\n+            return;\n+        }\n+        if (state == TokenFilter.INCLUDE_ALL) {\n+            _itemFilter = state;\n+            delegate.writeFieldName(name);\n+            return;\n+        }\n+        state = state.includeProperty(name.getValue());\n+        _itemFilter = state;\n+        if (state == TokenFilter.INCLUDE_ALL) {\n+            _checkPropertyParentPath();\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, text/String values\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeString(String value) throws IOException\n+    {\n+        if (_itemFilter == null) {\n+            return;\n+        }\n+        if (_itemFilter != TokenFilter.INCLUDE_ALL) {\n+            TokenFilter state = _filterContext.checkValue(_itemFilter);\n+            if (state == null) {\n+                return;\n+            }\n+            if (state != TokenFilter.INCLUDE_ALL) {\n+                if (!state.includeString(value)) {\n+                    return;\n+                }\n+            }\n+            _checkParentPath();\n+        } \n+        delegate.writeString(value);\n+    }\n+\n+    @Override\n+    public void writeString(char[] text, int offset, int len) throws IOException\n+    {\n+        if (_itemFilter == null) {\n+            return;\n+        }\n+        if (_itemFilter != TokenFilter.INCLUDE_ALL) {\n+            String value = new String(text, offset, len);\n+            TokenFilter state = _filterContext.checkValue(_itemFilter);\n+            if (state == null) {\n+                return;\n+            }\n+            if (state != TokenFilter.INCLUDE_ALL) {\n+                if (!state.includeString(value)) {\n+                    return;\n+                }\n+            }\n+            _checkParentPath();\n+        } \n+        delegate.writeString(text, offset, len);\n+    }\n+\n+    @Override\n+    public void writeString(SerializableString value) throws IOException\n+    {\n+        if (_itemFilter == null) {\n+            return;\n+        }\n+        if (_itemFilter != TokenFilter.INCLUDE_ALL) {\n+            TokenFilter state = _filterContext.checkValue(_itemFilter);\n+            if (state == null) {\n+                return;\n+            }\n+            if (state != TokenFilter.INCLUDE_ALL) {\n+                if (!state.includeString(value.getValue())) {\n+                    return;\n+                }\n+            }\n+            _checkParentPath();\n+        } \n+        delegate.writeString(value);\n+    }\n+\n+    @Override\n+    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException\n+    {\n+        if (_checkRawValueWrite()) {\n+            delegate.writeRawUTF8String(text, offset, length);\n+        }\n+    }\n+\n+    @Override\n+    public void writeUTF8String(byte[] text, int offset, int length) throws IOException\n+    {\n+        // not exact match, but best we can do\n+        if (_checkRawValueWrite()) {\n+            delegate.writeRawUTF8String(text, offset, length);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, binary/raw content\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeRaw(String text) throws IOException\n+    {\n+        if (_checkRawValueWrite()) {\n+            delegate.writeRaw(text);\n+        }\n+    }\n+\n+    @Override\n+    public void writeRaw(String text, int offset, int len) throws IOException\n+    {\n+        if (_checkRawValueWrite()) {\n+            delegate.writeRaw(text);\n+        }\n+    }\n+\n+    @Override\n+    public void writeRaw(SerializableString text) throws IOException\n+    {\n+        if (_checkRawValueWrite()) {\n+            delegate.writeRaw(text);\n+        }\n+    }\n+\n+    @Override\n+    public void writeRaw(char[] text, int offset, int len) throws IOException\n+    {\n+        if (_checkRawValueWrite()) {\n+            delegate.writeRaw(text, offset, len);\n+        }\n+    }\n+\n+    @Override\n+    public void writeRaw(char c) throws IOException\n+    {\n+        if (_checkRawValueWrite()) {\n+            delegate.writeRaw(c);\n+        }\n+    }\n+\n+    @Override\n+    public void writeRawValue(String text) throws IOException\n+    {\n+        if (_checkRawValueWrite()) {\n+            delegate.writeRaw(text);\n+        }\n+    }\n+\n+    @Override\n+    public void writeRawValue(String text, int offset, int len) throws IOException\n+    {\n+        if (_checkRawValueWrite()) {\n+            delegate.writeRaw(text, offset, len);\n+        }\n+    }\n+\n+    @Override\n+    public void writeRawValue(char[] text, int offset, int len) throws IOException\n+    {\n+        if (_checkRawValueWrite()) {\n+            delegate.writeRaw(text, offset, len);\n+        }\n+    }\n+\n+    @Override\n+    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException\n+    {\n+        if (_checkBinaryWrite()) {\n+            delegate.writeBinary(b64variant, data, offset, len);\n+        }\n+    }\n+\n+    @Override\n+    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException\n+    {\n+        if (_checkBinaryWrite()) {\n+            return delegate.writeBinary(b64variant, data, dataLength);\n+        }\n+        return -1;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, other value types\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeNumber(short v) throws IOException\n+    {\n+        if (_itemFilter == null) {\n+            return;\n+        }\n+        if (_itemFilter != TokenFilter.INCLUDE_ALL) {\n+            TokenFilter state = _filterContext.checkValue(_itemFilter);\n+            if (state == null) {\n+                return;\n+            }\n+            if (state != TokenFilter.INCLUDE_ALL) {\n+                if (!state.includeNumber(v)) {\n+                    return;\n+                }\n+            }\n+            _checkParentPath();\n+        } \n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(int v) throws IOException\n+    {\n+        if (_itemFilter == null) {\n+            return;\n+        }\n+        if (_itemFilter != TokenFilter.INCLUDE_ALL) {\n+            TokenFilter state = _filterContext.checkValue(_itemFilter);\n+            if (state == null) {\n+                return;\n+            }\n+            if (state != TokenFilter.INCLUDE_ALL) {\n+                if (!state.includeNumber(v)) {\n+                    return;\n+                }\n+            }\n+            _checkParentPath();\n+        } \n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(long v) throws IOException\n+    {\n+        if (_itemFilter == null) {\n+            return;\n+        }\n+        if (_itemFilter != TokenFilter.INCLUDE_ALL) {\n+            TokenFilter state = _filterContext.checkValue(_itemFilter);\n+            if (state == null) {\n+                return;\n+            }\n+            if (state != TokenFilter.INCLUDE_ALL) {\n+                if (!state.includeNumber(v)) {\n+                    return;\n+                }\n+            }\n+            _checkParentPath();\n+        } \n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(BigInteger v) throws IOException\n+    {\n+        if (_itemFilter == null) {\n+            return;\n+        }\n+        if (_itemFilter != TokenFilter.INCLUDE_ALL) {\n+            TokenFilter state = _filterContext.checkValue(_itemFilter);\n+            if (state == null) {\n+                return;\n+            }\n+            if (state != TokenFilter.INCLUDE_ALL) {\n+                if (!state.includeNumber(v)) {\n+                    return;\n+                }\n+            }\n+            _checkParentPath();\n+        } \n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(double v) throws IOException\n+    {\n+        if (_itemFilter == null) {\n+            return;\n+        }\n+        if (_itemFilter != TokenFilter.INCLUDE_ALL) {\n+            TokenFilter state = _filterContext.checkValue(_itemFilter);\n+            if (state == null) {\n+                return;\n+            }\n+            if (state != TokenFilter.INCLUDE_ALL) {\n+                if (!state.includeNumber(v)) {\n+                    return;\n+                }\n+            }\n+            _checkParentPath();\n+        } \n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(float v) throws IOException\n+    {\n+        if (_itemFilter == null) {\n+            return;\n+        }\n+        if (_itemFilter != TokenFilter.INCLUDE_ALL) {\n+            TokenFilter state = _filterContext.checkValue(_itemFilter);\n+            if (state == null) {\n+                return;\n+            }\n+            if (state != TokenFilter.INCLUDE_ALL) {\n+                if (!state.includeNumber(v)) {\n+                    return;\n+                }\n+            }\n+            _checkParentPath();\n+        } \n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(BigDecimal v) throws IOException\n+    {\n+        if (_itemFilter == null) {\n+            return;\n+        }\n+        if (_itemFilter != TokenFilter.INCLUDE_ALL) {\n+            TokenFilter state = _filterContext.checkValue(_itemFilter);\n+            if (state == null) {\n+                return;\n+            }\n+            if (state != TokenFilter.INCLUDE_ALL) {\n+                if (!state.includeNumber(v)) {\n+                    return;\n+                }\n+            }\n+            _checkParentPath();\n+        } \n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(String encodedValue) throws IOException, UnsupportedOperationException\n+    {\n+        if (_itemFilter == null) {\n+            return;\n+        }\n+        if (_itemFilter != TokenFilter.INCLUDE_ALL) {\n+            TokenFilter state = _filterContext.checkValue(_itemFilter);\n+            if (state == null) {\n+                return;\n+            }\n+            if (state != TokenFilter.INCLUDE_ALL) {\n+                if (!state.includeRawValue()) { // close enough?\n+                    return;\n+                }\n+            }\n+            _checkParentPath();\n+        }\n+        delegate.writeNumber(encodedValue);\n+    }\n+\n+    @Override\n+    public void writeBoolean(boolean v) throws IOException\n+    {\n+        if (_itemFilter == null) {\n+            return;\n+        }\n+        if (_itemFilter != TokenFilter.INCLUDE_ALL) {\n+            TokenFilter state = _filterContext.checkValue(_itemFilter);\n+            if (state == null) {\n+                return;\n+            }\n+            if (state != TokenFilter.INCLUDE_ALL) {\n+                if (!state.includeBoolean(v)) {\n+                    return;\n+                }\n+            }\n+            _checkParentPath();\n+        } \n+        delegate.writeBoolean(v);\n+    }\n+\n+    @Override\n+    public void writeNull() throws IOException\n+    {\n+        if (_itemFilter == null) {\n+            return;\n+        }\n+        if (_itemFilter != TokenFilter.INCLUDE_ALL) {\n+            TokenFilter state = _filterContext.checkValue(_itemFilter);\n+            if (state == null) {\n+                return;\n+            }\n+            if (state != TokenFilter.INCLUDE_ALL) {\n+                if (!state.includeNull()) {\n+                    return;\n+                }\n+            }\n+            _checkParentPath();\n+        } \n+        delegate.writeNull();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridden field methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeOmittedField(String fieldName) throws IOException {\n+        // Hmmh. Not sure how this would work but...\n+        if (_itemFilter != null) {\n+            delegate.writeOmittedField(fieldName);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, Native Ids\n+    /**********************************************************\n+     */\n+\n+    // 25-Mar-2015, tatu: These are tricky as they sort of predate actual filtering calls.\n+    //   Let's try to use current state as a clue at least...\n+    \n+    @Override\n+    public void writeObjectId(Object id) throws IOException {\n+        if (_itemFilter != null) {\n+            delegate.writeObjectId(id);\n+        }\n+    }\n+\n+    @Override\n+    public void writeObjectRef(Object id) throws IOException {\n+        if (_itemFilter != null) {\n+            delegate.writeObjectRef(id);\n+        }\n+    }\n+    \n+    @Override\n+    public void writeTypeId(Object id) throws IOException {\n+        if (_itemFilter != null) {\n+            delegate.writeTypeId(id);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, serializing Java objects\n+    /**********************************************************\n+     */\n+\n+    // Base class definitions for these seems correct to me, iff not directly delegating:\n+\n+    /*\n+    @Override\n+    public void writeObject(Object pojo) throws IOException,JsonProcessingException {\n+        if (delegateCopyMethods) {\n+            delegate.writeObject(pojo);\n+            return;\n+        }\n+        // NOTE: copied from \n+        if (pojo == null) {\n+            writeNull();\n+        } else {\n+            if (getCodec() != null) {\n+                getCodec().writeValue(this, pojo);\n+                return;\n+            }\n+            _writeSimpleObject(pojo);\n+        }\n+    }\n+    \n+    @Override\n+    public void writeTree(TreeNode rootNode) throws IOException {\n+        if (delegateCopyMethods) {\n+            delegate.writeTree(rootNode);\n+            return;\n+        }\n+        // As with 'writeObject()', we are not check if write would work\n+        if (rootNode == null) {\n+            writeNull();\n+        } else {\n+            if (getCodec() == null) {\n+                throw new IllegalStateException(\"No ObjectCodec defined\");\n+            }\n+            getCodec().writeValue(this, rootNode);\n+        }\n+    }\n+    */\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, copy-through methods\n+    /**********************************************************\n+     */\n+\n+    // Base class definitions for these seems correct to me, iff not directly delegating:\n+\n+    /*\n+    @Override\n+    public void copyCurrentEvent(JsonParser jp) throws IOException {\n+        if (delegateCopyMethods) delegate.copyCurrentEvent(jp);\n+        else super.copyCurrentEvent(jp);\n+    }\n+\n+    @Override\n+    public void copyCurrentStructure(JsonParser jp) throws IOException {\n+        if (delegateCopyMethods) delegate.copyCurrentStructure(jp);\n+        else super.copyCurrentStructure(jp);\n+    }\n+    */\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    protected void _checkParentPath() throws IOException\n+    {\n+        ++_matchCount;\n+        // only need to construct path if parent wasn't written\n+        if (_includePath) {\n+            _filterContext.writePath(delegate);\n+        }\n+        // also: if no multiple matches desired, short-cut checks\n+        if (!_allowMultipleMatches) {\n+            // Mark parents as \"skip\" so that further check calls are not made\n+            _filterContext.skipParentChecks();\n+        }\n+    }\n+\n+    /**\n+     * Specialized variant of {@link #_checkParentPath} used when checking\n+     * parent for a property name to be included with value: rules are slightly\n+     * different.\n+     */\n+    protected void _checkPropertyParentPath() throws IOException\n+    {\n+        ++_matchCount;\n+        if (_includePath) {\n+            _filterContext.writePath(delegate);\n+        } else if (_includeImmediateParent) {\n+            // 21-Apr-2015, tatu: Note that there is no API to enable this currently...\n+            //    retained for speculative future use\n+            _filterContext.writeImmediatePath(delegate);\n+        }\n+\n+        // also: if no multiple matches desired, short-cut checks\n+        if (!_allowMultipleMatches) {\n+            // Mark parents as \"skip\" so that further check calls are not made\n+            _filterContext.skipParentChecks();\n+        }\n+    }\n+    \n+    protected boolean _checkBinaryWrite() throws IOException\n+    {\n+        if (_itemFilter == null) {\n+            return false;\n+        }\n+        if (_itemFilter == TokenFilter.INCLUDE_ALL) {\n+            return true;\n+        }\n+        if (_itemFilter.includeBinary()) { // close enough?\n+            _checkParentPath();\n+            return true;\n+        }\n+        return false;\n+    }\n+    \n+    protected boolean _checkRawValueWrite() throws IOException\n+    {\n+        if (_itemFilter == null) {\n+            return false;\n+        }\n+        if (_itemFilter == TokenFilter.INCLUDE_ALL) {\n+            return true;\n+        }\n+        if (_itemFilter.includeRawValue()) { // close enough?\n+            _checkParentPath();\n+            return true;\n+        }\n+        return false;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java\n+package com.fasterxml.jackson.core.filter;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.util.JsonParserDelegate;\n+\n+import static com.fasterxml.jackson.core.JsonTokenId.*;\n+\n+/**\n+ * Specialized {@link JsonParserDelegate} that allows use of\n+ * {@link TokenFilter} for outputting a subset of content that\n+ * is visible to caller\n+ * \n+ * @since 2.6\n+ */\n+public class FilteringParserDelegate extends JsonParserDelegate\n+{\n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Object consulted to determine whether to write parts of content generator\n+     * is asked to write or not.\n+     */\n+    protected TokenFilter rootFilter;\n+\n+    /**\n+     * Flag that determines whether filtering will continue after the first\n+     * match is indicated or not: if `false`, output is based on just the first\n+     * full match (returning {@link TokenFilter#INCLUDE_ALL}) and no more\n+     * checks are made; if `true` then filtering will be applied as necessary\n+     * until end of content.\n+     */\n+    protected boolean _allowMultipleMatches;\n+\n+    /**\n+     * Flag that determines whether path leading up to included content should\n+     * also be automatically included or not. If `false`, no path inclusion is\n+     * done and only explicitly included entries are output; if `true` then\n+     * path from main level down to match is also included as necessary.\n+     */\n+    protected boolean _includePath;\n+\n+    /* NOTE: this feature is included in the first version (2.6), but\n+     * there is no public API to enable it, yet, since there isn't an\n+     * actual use case. But it seemed possible need could arise, which\n+     * is feature has not yet been removed. If no use is found within\n+     * first version or two, just remove.\n+     * \n+     * Marked as deprecated since its status is uncertain.\n+     */\n+    @Deprecated\n+    protected boolean _includeImmediateParent = false;\n+    \n+    /*\n+    /**********************************************************\n+    /* State\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Last token retrieved via {@link #nextToken}, if any.\n+     * Null before the first call to <code>nextToken()</code>,\n+     * as well as if token has been explicitly cleared\n+     */\n+    protected JsonToken _currToken;\n+\n+    /**\n+     * Last cleared token, if any: that is, value that was in\n+     * effect when {@link #clearCurrentToken} was called.\n+     */\n+    protected JsonToken _lastClearedToken;\n+    \n+    /**\n+     * During traversal this is the actual \"open\" parse tree, which sometimes\n+     * is the same as {@link #_exposedContext}, and at other times is ahead\n+     * of it. Note that this context is never null.\n+     */\n+    protected TokenFilterContext _headContext;\n+\n+    /**\n+     * In cases where {@link #_headContext} is \"ahead\" of context exposed to\n+     * caller, this context points to what is currently exposed to caller.\n+     * When the two are in sync, this context reference will be <code>null</code>.\n+     */\n+    protected TokenFilterContext _exposedContext;\n+\n+    /**\n+     * State that applies to the item within container, used where applicable.\n+     * Specifically used to pass inclusion state between property name and\n+     * property, and also used for array elements.\n+     */\n+    protected TokenFilter _itemFilter;\n+    \n+    /**\n+     * Number of tokens for which {@link TokenFilter#INCLUDE_ALL}\n+     * has been returned.\n+     */\n+    protected int _matchCount;\n+\n+    /*\n+    /**********************************************************\n+    /* Construction, initialization\n+    /**********************************************************\n+     */\n+\n+    public FilteringParserDelegate(JsonParser p, TokenFilter f,\n+            boolean includePath, boolean allowMultipleMatches)\n+    {\n+        super(p);\n+        rootFilter = f;\n+        // and this is the currently active filter for root values\n+        _itemFilter = f;\n+        _headContext = TokenFilterContext.createRootContext(f);\n+        _includePath = includePath;\n+        _allowMultipleMatches = allowMultipleMatches;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended API\n+    /**********************************************************\n+     */\n+\n+    public TokenFilter getFilter() { return rootFilter; }\n+\n+    /**\n+     * Accessor for finding number of matches, where specific token and sub-tree\n+     * starting (if structured type) are passed.\n+     */\n+    public int getMatchCount() {\n+        return _matchCount;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, token accessors\n+    /**********************************************************\n+     */\n+\n+    @Override public JsonToken getCurrentToken() { return _currToken; }\n+\n+    @Override public final int getCurrentTokenId() {\n+        final JsonToken t = _currToken;\n+        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n+    }\n+\n+    @Override public boolean hasCurrentToken() { return _currToken != null; }\n+    @Override public boolean hasTokenId(int id) {\n+        final JsonToken t = _currToken;\n+        if (t == null) {\n+            return (JsonTokenId.ID_NO_TOKEN == id);\n+        }\n+        return t.id() == id;\n+    }\n+\n+    @Override public final boolean hasToken(JsonToken t) {\n+        return (_currToken == t);\n+    }\n+    \n+    @Override public boolean isExpectedStartArrayToken() { return _currToken == JsonToken.START_ARRAY; }\n+    @Override public boolean isExpectedStartObjectToken() { return _currToken == JsonToken.START_OBJECT; }\n+\n+    @Override public JsonLocation getCurrentLocation() { return delegate.getCurrentLocation(); }\n+\n+    @Override\n+    public JsonStreamContext getParsingContext() {\n+        return _filterContext();\n+    }\n+    \n+    // !!! TODO: Verify it works as expected: copied from standard JSON parser impl\n+    @Override\n+    public String getCurrentName() throws IOException {\n+        JsonStreamContext ctxt = _filterContext();\n+        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n+            JsonStreamContext parent = ctxt.getParent();\n+            return (parent == null) ? null : parent.getCurrentName();\n+        }\n+        return ctxt.getCurrentName();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, token state overrides\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void clearCurrentToken() {\n+        if (_currToken != null) {\n+            _lastClearedToken = _currToken;\n+            _currToken = null;\n+        }\n+    }\n+\n+    @Override\n+    public JsonToken getLastClearedToken() { return _lastClearedToken; }\n+\n+    @Override\n+    public void overrideCurrentName(String name) {\n+        /* 14-Apr-2015, tatu: Not sure whether this can be supported, and if so,\n+         *    what to do with it... Delegation won't work for sure, so let's for\n+         *    now throw an exception\n+         */\n+        throw new UnsupportedOperationException(\"Can not currently override name during filtering read\");\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, traversal\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JsonToken nextToken() throws IOException\n+    {\n+        // Anything buffered?\n+        TokenFilterContext ctxt = _exposedContext;\n+\n+        if (ctxt != null) {\n+            while (true) {\n+                JsonToken t = ctxt.nextTokenToRead();\n+                if (t != null) {\n+                    _currToken = t;\n+                    return t;\n+                }\n+                // all done with buffered stuff?\n+                if (ctxt == _headContext) {\n+                    _exposedContext = null;\n+                    if (ctxt.inArray()) {\n+                        t = delegate.getCurrentToken();\n+// Is this guaranteed to work without further checks?\n+//                        if (t != JsonToken.START_ARRAY) {\n+                        _currToken = t;\n+                        return t;\n+                    }\n+\n+                    // Almost! Most likely still have the current token;\n+                    // with the sole exception of \n+                    /*\n+                    t = delegate.getCurrentToken();\n+                    if (t != JsonToken.FIELD_NAME) {\n+                        _currToken = t;\n+                        return t;\n+                    }\n+                    */\n+                    break;\n+                }\n+                // If not, traverse down the context chain\n+                ctxt = _headContext.findChildOf(ctxt);\n+\n+                _exposedContext = ctxt;\n+                if (ctxt == null) { // should never occur\n+                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n+                }\n+            }\n+        }\n+\n+        // If not, need to read more. If we got any:\n+        JsonToken t = delegate.nextToken();\n+        if (t == null) {\n+            // no strict need to close, since we have no state here\n+            return (_currToken = t);\n+        }\n+\n+        // otherwise... to include or not?\n+        TokenFilter f;\n+        \n+        switch (t.id()) {\n+        case ID_START_ARRAY:\n+            f = _itemFilter;\n+            if (f == TokenFilter.INCLUDE_ALL) {\n+                _headContext = _headContext.createChildArrayContext(f, true);\n+                return (_currToken = t);\n+            }\n+            if (f == null) { // does this occur?\n+                delegate.skipChildren();\n+                break;\n+            }\n+            // Otherwise still iffy, need to check\n+            f = _headContext.checkValue(f);\n+            if (f == null) {\n+                delegate.skipChildren();\n+                break;\n+            }\n+            if (f != TokenFilter.INCLUDE_ALL) {\n+                f = f.filterStartArray();\n+            }\n+            _itemFilter = f;\n+            if (f == TokenFilter.INCLUDE_ALL) {\n+                _headContext = _headContext.createChildArrayContext(f, true);\n+                return (_currToken = t);\n+            }\n+            _headContext = _headContext.createChildArrayContext(f, false);\n+            \n+            // Also: only need buffering if parent path to be included\n+            if (_includePath) {\n+                t = _nextTokenWithBuffering(_headContext);\n+                if (t != null) {\n+                    _currToken = t;\n+                    return t;\n+                }\n+            }\n+            break;\n+\n+        case ID_START_OBJECT:\n+            f = _itemFilter;\n+            if (f == TokenFilter.INCLUDE_ALL) {\n+                _headContext = _headContext.createChildObjectContext(f, true);\n+                return (_currToken = t);\n+            }\n+            if (f == null) { // does this occur?\n+                delegate.skipChildren();\n+                break;\n+            }\n+            // Otherwise still iffy, need to check\n+            f = _headContext.checkValue(f);\n+            if (f == null) {\n+                delegate.skipChildren();\n+                break;\n+            }\n+            if (f != TokenFilter.INCLUDE_ALL) {\n+                f = f.filterStartObject();\n+            }\n+            _itemFilter = f;\n+            if (f == TokenFilter.INCLUDE_ALL) {\n+                _headContext = _headContext.createChildObjectContext(f, true);\n+                return (_currToken = t);\n+            }\n+            _headContext = _headContext.createChildObjectContext(f, false);\n+            // Also: only need buffering if parent path to be included\n+            if (_includePath) {\n+                t = _nextTokenWithBuffering(_headContext);\n+                if (t != null) {\n+                    _currToken = t;\n+                    return t;\n+                }\n+            }\n+            // note: inclusion of surrounding Object handled separately via\n+            // FIELD_NAME\n+            break;\n+\n+        case ID_END_ARRAY:\n+        case ID_END_OBJECT:\n+            {\n+                boolean returnEnd = _headContext.isStartHandled();\n+                f = _headContext.getFilter();\n+                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n+                    f.filterFinishArray();\n+                }\n+                _headContext = _headContext.getParent();\n+                _itemFilter = _headContext.getFilter();\n+                if (returnEnd) {\n+                    return (_currToken = t);\n+                }\n+            }\n+            break;\n+\n+        case ID_FIELD_NAME:\n+            {\n+                final String name = delegate.getCurrentName();\n+                // note: this will also set 'needToHandleName'\n+                f = _headContext.setFieldName(name);\n+                if (f == TokenFilter.INCLUDE_ALL) {\n+                    _itemFilter = f;\n+                    if (!_includePath) {\n+                        // Minor twist here: if parent NOT included, may need to induce output of\n+                        // surrounding START_OBJECT/END_OBJECT\n+                        if (_includeImmediateParent && !_headContext.isStartHandled()) {\n+                            t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n+                            _exposedContext = _headContext;\n+                        }\n+                    }\n+                    return (_currToken = t);\n+                }\n+                if (f == null) {\n+                    delegate.nextToken();\n+                    delegate.skipChildren();\n+                    break;\n+                }\n+                f = f.includeProperty(name);\n+                if (f == null) {\n+                    delegate.nextToken();\n+                    delegate.skipChildren();\n+                    break;\n+                }\n+                _itemFilter = f;\n+                if (f == TokenFilter.INCLUDE_ALL) {\n+                    if (_includePath) {\n+                        return (_currToken = t);\n+                    }\n+                }\n+                if (_includePath) {\n+                    t = _nextTokenWithBuffering(_headContext);\n+                    if (t != null) {\n+                        _currToken = t;\n+                        return t;\n+                    }\n+                }\n+                break;\n+            }\n+\n+        default: // scalar value\n+            f = _itemFilter;\n+            if (f == TokenFilter.INCLUDE_ALL) {\n+                return (_currToken = t);\n+            }\n+            if (f != null) {\n+                f = _headContext.checkValue(f);\n+                if ((f == TokenFilter.INCLUDE_ALL)\n+                        || ((f != null) && f.includeValue(delegate))) {\n+                    return (_currToken = t);\n+                }\n+            }\n+            // Otherwise not included (leaves must be explicitly included)\n+            break;\n+        }\n+\n+        // We get here if token was not yet found; offlined handling\n+        return _nextToken2();\n+    }\n+\n+    /**\n+     * Offlined handling for cases where there was no buffered token to\n+     * return, and the token read next could not be returned as-is,\n+     * at least not yet, but where we have not yet established that\n+     * buffering is needed.\n+     */\n+    protected final JsonToken _nextToken2() throws IOException\n+    {\n+        main_loop:\n+        while (true) {\n+            JsonToken t = delegate.nextToken();\n+            if (t == null) { // is this even legal?\n+                return (_currToken = t);\n+            }\n+            TokenFilter f;\n+\n+            switch (t.id()) {\n+            case ID_START_ARRAY:\n+                f = _itemFilter;\n+                if (f == TokenFilter.INCLUDE_ALL) {\n+                    _headContext = _headContext.createChildArrayContext(f, true);\n+                    return (_currToken = t);\n+                }\n+                if (f == null) { // does this occur?\n+                    delegate.skipChildren();\n+                    continue main_loop;\n+                }\n+                // Otherwise still iffy, need to check\n+                f = _headContext.checkValue(f);\n+                if (f == null) {\n+                    delegate.skipChildren();\n+                    continue main_loop;\n+                }\n+                if (f != TokenFilter.INCLUDE_ALL) {\n+                    f = f.filterStartArray();\n+                }\n+                _itemFilter = f;\n+                if (f == TokenFilter.INCLUDE_ALL) {\n+                    _headContext = _headContext.createChildArrayContext(f, true);\n+                    return (_currToken = t);\n+                }\n+                _headContext = _headContext.createChildArrayContext(f, false);\n+                // but if we didn't figure it out yet, need to buffer possible events\n+                if (_includePath) {\n+                    t = _nextTokenWithBuffering(_headContext);\n+                    if (t != null) {\n+                        _currToken = t;\n+                        return t;\n+                    }\n+                }\n+                continue main_loop;\n+\n+            case ID_START_OBJECT:\n+                f = _itemFilter;\n+                if (f == TokenFilter.INCLUDE_ALL) {\n+                    _headContext = _headContext.createChildObjectContext(f, true);\n+                    return (_currToken = t);\n+                }\n+                if (f == null) { // does this occur?\n+                    delegate.skipChildren();\n+                    continue main_loop;\n+                }\n+                // Otherwise still iffy, need to check\n+                f = _headContext.checkValue(f);\n+                if (f == null) {\n+                    delegate.skipChildren();\n+                    continue main_loop;\n+                }\n+                if (f != TokenFilter.INCLUDE_ALL) {\n+                    f = f.filterStartObject();\n+                }\n+                _itemFilter = f;\n+                if (f == TokenFilter.INCLUDE_ALL) {\n+                    _headContext = _headContext.createChildObjectContext(f, true);\n+                    return (_currToken = t);\n+                }\n+                _headContext = _headContext.createChildObjectContext(f, false);\n+                if (_includePath) {\n+                    t = _nextTokenWithBuffering(_headContext);\n+                    if (t != null) {\n+                        _currToken = t;\n+                        return t;\n+                    }\n+                }\n+                continue main_loop;\n+\n+            case ID_END_ARRAY:\n+            case ID_END_OBJECT:\n+                {\n+                    boolean returnEnd = _headContext.isStartHandled();\n+                    f = _headContext.getFilter();\n+                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n+                        f.filterFinishArray();\n+                    }\n+                    _headContext = _headContext.getParent();\n+                    _itemFilter = _headContext.getFilter();\n+                    if (returnEnd) {\n+                        return (_currToken = t);\n+                    }\n+                }\n+                continue main_loop;\n+\n+            case ID_FIELD_NAME:\n+                {\n+                    final String name = delegate.getCurrentName();\n+                    f = _headContext.setFieldName(name);\n+                    if (f == TokenFilter.INCLUDE_ALL) {\n+                        _itemFilter = f;\n+                        return (_currToken = t);\n+                    }\n+                    if (f == null) { // filter out the value\n+                        delegate.nextToken();\n+                        delegate.skipChildren();\n+                        continue main_loop;\n+                    }\n+                    f = f.includeProperty(name);\n+                    if (f == null) { // filter out the value\n+                        delegate.nextToken();\n+                        delegate.skipChildren();\n+                        continue main_loop;\n+                    }\n+                    _itemFilter = f;\n+                    if (f == TokenFilter.INCLUDE_ALL) {\n+                        if (_includePath) {\n+                            return (_currToken = t);\n+                        }\n+//                        if (_includeImmediateParent) { ...\n+                        continue main_loop;\n+                    }\n+                    if (_includePath) {\n+                        t = _nextTokenWithBuffering(_headContext);\n+                        if (t != null) {\n+                            _currToken = t;\n+                            return t;\n+                        }\n+                    }\n+                }\n+                continue main_loop;\n+\n+            default: // scalar value\n+                f = _itemFilter;\n+                if (f == TokenFilter.INCLUDE_ALL) {\n+                    return (_currToken = t);\n+                }\n+                if (f != null) {\n+                    f = _headContext.checkValue(f);\n+                    if ((f == TokenFilter.INCLUDE_ALL)\n+                            || ((f != null) && f.includeValue(delegate))) {\n+                        return (_currToken = t);\n+                    }\n+                }\n+                // Otherwise not included (leaves must be explicitly included)\n+                break;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method called when a new potentially included context is found.\n+     */\n+    protected final JsonToken _nextTokenWithBuffering(final TokenFilterContext buffRoot)\n+        throws IOException\n+    {\n+        _exposedContext = buffRoot;\n+\n+        main_loop:\n+        while (true) {\n+            JsonToken t = delegate.nextToken();\n+            if (t == null) { // is this even legal?\n+                return t;\n+            }\n+            TokenFilter f;\n+\n+            // One simplification here: we know for a fact that the item filter is\n+            // neither null nor 'include all', for most cases; the only exception\n+            // being FIELD_NAME handling\n+\n+            switch (t.id()) {\n+            case ID_START_ARRAY:\n+                f = _headContext.checkValue(_itemFilter);\n+                if (f == null) {\n+                    delegate.skipChildren();\n+                    continue main_loop;\n+                }\n+                if (f != TokenFilter.INCLUDE_ALL) {\n+                    f = f.filterStartArray();\n+                }\n+                _itemFilter = f;\n+                if (f == TokenFilter.INCLUDE_ALL) {\n+                    _headContext = _headContext.createChildArrayContext(f, true);\n+                    return _nextBuffered();\n+                }\n+                _headContext = _headContext.createChildArrayContext(f, false);\n+                continue main_loop;\n+\n+            case ID_START_OBJECT:\n+                f = _itemFilter;\n+                if (f == TokenFilter.INCLUDE_ALL) {\n+                    _headContext = _headContext.createChildObjectContext(f, true);\n+                    return t;\n+                }\n+                if (f == null) { // does this occur?\n+                    delegate.skipChildren();\n+                    continue main_loop;\n+                }\n+                // Otherwise still iffy, need to check\n+                f = _headContext.checkValue(f);\n+                if (f == null) {\n+                    delegate.skipChildren();\n+                    continue main_loop;\n+                }\n+                if (f != TokenFilter.INCLUDE_ALL) {\n+                    f = f.filterStartObject();\n+                }\n+                _itemFilter = f;\n+                if (f == TokenFilter.INCLUDE_ALL) {\n+                    _headContext = _headContext.createChildObjectContext(f, true);\n+                    return _nextBuffered();\n+                }\n+                _headContext = _headContext.createChildObjectContext(f, false);\n+                continue main_loop;\n+\n+            case ID_END_ARRAY:\n+            case ID_END_OBJECT:\n+                {\n+                    // Unlike with other loops, here we know that content was NOT\n+                    // included (won't get this far otherwise)\n+                    f = _headContext.getFilter();\n+                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n+                        f.filterFinishArray();\n+                    }\n+                    _headContext = _headContext.getParent();\n+                    _itemFilter = _headContext.getFilter();\n+                    \n+                    if (_headContext == buffRoot) {\n+                        return null;\n+                    }\n+                }\n+                continue main_loop;\n+\n+            case ID_FIELD_NAME:\n+                {\n+                    final String name = delegate.getCurrentName();\n+                    f = _headContext.setFieldName(name);\n+                    if (f == TokenFilter.INCLUDE_ALL) {\n+                        _itemFilter = f;\n+                        return _nextBuffered();\n+                    }\n+                    if (f == null) { // filter out the value\n+                        delegate.nextToken();\n+                        delegate.skipChildren();\n+                        continue main_loop;\n+                    }\n+                    f = f.includeProperty(name);\n+                    if (f == null) { // filter out the value\n+                        delegate.nextToken();\n+                        delegate.skipChildren();\n+                        continue main_loop;\n+                    }\n+                    _itemFilter = f;\n+                    if (f == TokenFilter.INCLUDE_ALL) {\n+                        return _nextBuffered();\n+                    }\n+                }\n+                continue main_loop;\n+\n+            default: // scalar value\n+                f = _itemFilter;\n+                if (f == TokenFilter.INCLUDE_ALL) {\n+                    return _nextBuffered();\n+                }\n+                if (f != null) {\n+                    f = _headContext.checkValue(f);\n+                    if ((f == TokenFilter.INCLUDE_ALL)\n+                            || ((f != null) && f.includeValue(delegate))) {\n+                        return _nextBuffered();\n+                    }\n+                }\n+                // Otherwise not included (leaves must be explicitly included)\n+                continue main_loop;\n+            }\n+        }\n+    }\n+\n+    private JsonToken _nextBuffered() throws IOException\n+    {\n+        TokenFilterContext ctxt = _exposedContext;\n+        JsonToken t = ctxt.nextTokenToRead();\n+        if (t != null) {\n+            return t;\n+        }\n+        while (true) {\n+            // all done with buffered stuff?\n+            if (ctxt == _headContext) {\n+                throw _constructError(\"Internal error: failed to locate expected buffered tokens\");\n+                /*\n+                _exposedContext = null;\n+                break;\n+                */\n+            }\n+            // If not, traverse down the context chain\n+            ctxt = _exposedContext.findChildOf(ctxt);\n+            _exposedContext = ctxt;\n+            if (ctxt == null) { // should never occur\n+                throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n+            }\n+            t = _exposedContext.nextTokenToRead();\n+            if (t != null) {\n+                return t;\n+            }\n+        }\n+    }\n+    \n+    @Override\n+    public JsonToken nextValue() throws IOException {\n+        // Re-implemented same as ParserMinimalBase:\n+        JsonToken t = nextToken();\n+        if (t == JsonToken.FIELD_NAME) {\n+            t = nextToken();\n+        }\n+        return t;\n+    }\n+\n+    /**\n+     * Need to override, re-implement similar to how method defined in\n+     * {@link com.fasterxml.jackson.core.base.ParserMinimalBase}, to keep\n+     * state correct here.\n+     */\n+    @Override\n+    public JsonParser skipChildren() throws IOException\n+    {\n+        if ((_currToken != JsonToken.START_OBJECT)\n+            && (_currToken != JsonToken.START_ARRAY)) {\n+            return this;\n+        }\n+        int open = 1;\n+\n+        // Since proper matching of start/end markers is handled\n+        // by nextToken(), we'll just count nesting levels here\n+        while (true) {\n+            JsonToken t = nextToken();\n+            if (t == null) { // not ideal but for now, just return\n+                return this;\n+            }\n+            if (t.isStructStart()) {\n+                ++open;\n+            } else if (t.isStructEnd()) {\n+                if (--open == 0) {\n+                    return this;\n+                }\n+            }\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, access to token information, text\n+    /**********************************************************\n+     */\n+\n+    @Override public String getText() throws IOException { return delegate.getText();  }\n+    @Override public boolean hasTextCharacters() { return delegate.hasTextCharacters(); }\n+    @Override public char[] getTextCharacters() throws IOException { return delegate.getTextCharacters(); }\n+    @Override public int getTextLength() throws IOException { return delegate.getTextLength(); }\n+    @Override public int getTextOffset() throws IOException { return delegate.getTextOffset(); }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, access to token information, numeric\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public BigInteger getBigIntegerValue() throws IOException { return delegate.getBigIntegerValue(); }\n+\n+    @Override\n+    public boolean getBooleanValue() throws IOException { return delegate.getBooleanValue(); }\n+    \n+    @Override\n+    public byte getByteValue() throws IOException { return delegate.getByteValue(); }\n+\n+    @Override\n+    public short getShortValue() throws IOException { return delegate.getShortValue(); }\n+\n+    @Override\n+    public BigDecimal getDecimalValue() throws IOException { return delegate.getDecimalValue(); }\n+\n+    @Override\n+    public double getDoubleValue() throws IOException { return delegate.getDoubleValue(); }\n+\n+    @Override\n+    public float getFloatValue() throws IOException { return delegate.getFloatValue(); }\n+\n+    @Override\n+    public int getIntValue() throws IOException { return delegate.getIntValue(); }\n+\n+    @Override\n+    public long getLongValue() throws IOException { return delegate.getLongValue(); }\n+\n+    @Override\n+    public NumberType getNumberType() throws IOException { return delegate.getNumberType(); }\n+\n+    @Override\n+    public Number getNumberValue() throws IOException { return delegate.getNumberValue(); }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, access to token information, coercion/conversion\n+    /**********************************************************\n+     */\n+    \n+    @Override public int getValueAsInt() throws IOException { return delegate.getValueAsInt(); }\n+    @Override public int getValueAsInt(int defaultValue) throws IOException { return delegate.getValueAsInt(defaultValue); }\n+    @Override public long getValueAsLong() throws IOException { return delegate.getValueAsLong(); }\n+    @Override public long getValueAsLong(long defaultValue) throws IOException { return delegate.getValueAsLong(defaultValue); }\n+    @Override public double getValueAsDouble() throws IOException { return delegate.getValueAsDouble(); }\n+    @Override public double getValueAsDouble(double defaultValue) throws IOException { return delegate.getValueAsDouble(defaultValue); }\n+    @Override public boolean getValueAsBoolean() throws IOException { return delegate.getValueAsBoolean(); }\n+    @Override public boolean getValueAsBoolean(boolean defaultValue) throws IOException { return delegate.getValueAsBoolean(defaultValue); }\n+    @Override public String getValueAsString() throws IOException { return delegate.getValueAsString(); }\n+    @Override public String getValueAsString(String defaultValue) throws IOException { return delegate.getValueAsString(defaultValue); }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, access to token values, other\n+    /**********************************************************\n+     */\n+\n+    @Override public Object getEmbeddedObject() throws IOException { return delegate.getEmbeddedObject(); }\n+    @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { return delegate.getBinaryValue(b64variant); }\n+    @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { return delegate.readBinaryValue(b64variant, out); }\n+    @Override public JsonLocation getTokenLocation() { return delegate.getTokenLocation(); }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal helper methods\n+    /**********************************************************\n+     */\n+\n+    protected JsonStreamContext _filterContext() {\n+        if (_exposedContext != null) {\n+            return _exposedContext;\n+        }\n+        return _headContext;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/JsonPointerBasedFilter.java\n+package com.fasterxml.jackson.core.filter;\n+\n+import com.fasterxml.jackson.core.JsonPointer;\n+\n+/**\n+ * Simple {@link TokenFilter} implementation that takes a single\n+ * {@link JsonPointer} and matches a single value accordingly.\n+ * Instances are immutable and fully thread-safe, shareable,\n+ * and efficient to use.\n+ * \n+ * @since 2.6\n+ */\n+public class JsonPointerBasedFilter extends TokenFilter\n+{\n+    protected final JsonPointer _pathToMatch;\n+\n+    public JsonPointerBasedFilter(String ptrExpr) {\n+        this(JsonPointer.compile(ptrExpr));\n+    }\n+\n+    public JsonPointerBasedFilter(JsonPointer match) {\n+        _pathToMatch = match;\n+    }\n+\n+    @Override\n+    public TokenFilter includeElement(int index) {\n+        JsonPointer next = _pathToMatch.matchElement(index);\n+        if (next == null) {\n+            return null;\n+        }\n+        if (next.matches()) {\n+            return TokenFilter.INCLUDE_ALL;\n+        }\n+        return new JsonPointerBasedFilter(next);\n+    }\n+\n+    @Override\n+    public TokenFilter includeProperty(String name) {\n+        JsonPointer next = _pathToMatch.matchProperty(name);\n+        if (next == null) {\n+            return null;\n+        }\n+        if (next.matches()) {\n+            return TokenFilter.INCLUDE_ALL;\n+        }\n+        return new JsonPointerBasedFilter(next);\n+    }\n+\n+    @Override\n+    public TokenFilter filterStartArray() {\n+        return this;\n+    }\n+    \n+    @Override\n+    public TokenFilter filterStartObject() {\n+        return this;\n+    }\n+    \n+    @Override\n+    protected boolean _includeScalar() {\n+        // should only occur for root-level scalars, path \"/\"\n+        return _pathToMatch.matches();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"[JsonPointerFilter at: \"+_pathToMatch+\"]\";\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/TokenFilter.java\n+package com.fasterxml.jackson.core.filter;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+\n+/**\n+ * Strategy class that can be implemented to specify actual inclusion/exclusion\n+ * criteria for filtering, used by {@link FilteringGeneratorDelegate}.\n+ *\n+ * @since 2.6\n+ */\n+public class TokenFilter\n+{\n+\n+    // // Marker values\n+\n+    /**\n+     * Marker value that should be used to indicate inclusion of a structured\n+     * value (sub-tree representing Object or Array), or value of a named\n+     * property (regardless of type).\n+     * Note that if this instance is returned, it will used as a marker, and \n+     * no actual callbacks need to be made. For this reason, it is more efficient\n+     * to return this instance if the whole sub-tree is to be included, instead\n+     * of implementing similar filter functionality explicitly.\n+     */\n+    public final static TokenFilter INCLUDE_ALL = new TokenFilter();\n+\n+    // Life-cycle\n+\n+    protected TokenFilter() { }\n+\n+    /*\n+    /**********************************************************\n+    /* API, structured values\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to check whether Object value at current output\n+     * location should be included in output.\n+     * Three kinds of return values may be used as follows:\n+     *<ul>\n+     * <li><code>null</code> to indicate that the Object should be skipped\n+     *   </li>\n+     * <li>{@link #INCLUDE_ALL} to indicate that the Object should be included\n+     * completely in output\n+     *   </li>\n+     * <li>Any other {@link TokenFilter} implementation (possibly this one) to mean\n+     *  that further inclusion calls on return filter object need to be made\n+     *  on contained properties, as necessary. {@link #filterFinishObject()} will\n+     *  also be called on returned filter object\n+     *   </li>\n+     * </ul>\n+     *<p>\n+     * Default implementation returns <code>this</code>, which means that checks\n+     * are made recursively for properties of the Object to determine possible inclusion.\n+     * \n+     * @return TokenFilter to use for further calls within Array, unless return value\n+     *   is <code>null</code> or {@link #INCLUDE_ALL} (which have simpler semantics)\n+     */\n+    public TokenFilter filterStartObject() {\n+        return this;\n+    }\n+\n+    /**\n+     * Method called to check whether Array value at current output\n+     * location should be included in output.\n+     * Three kinds of return values may be used as follows:\n+     *<ul>\n+     * <li><code>null</code> to indicate that the Array should be skipped\n+     *   </li>\n+     * <li>{@link #INCLUDE_ALL} to indicate that the Array should be included\n+     * completely in output\n+     *   </li>\n+     * <li>Any other {@link TokenFilter} implementation (possibly this one) to mean\n+     *  that further inclusion calls on return filter object need to be made\n+     *  on contained element values, as necessary. {@link #filterFinishArray()} will\n+     *  also be called on returned filter object\n+     *   </li>\n+     * </ul>\n+     *<p>\n+     * Default implementation returns <code>this</code>, which means that checks\n+     * are made recursively for elements of the array to determine possible inclusion.\n+     * \n+     * @return TokenFilter to use for further calls within Array, unless return value\n+     *   is <code>null</code> or {@link #INCLUDE_ALL} (which have simpler semantics)\n+     */\n+    public TokenFilter filterStartArray() {\n+        return this;\n+    }\n+\n+    /**\n+     * Method called to indicate that output of non-filtered Object (one that may\n+     * have been included either completely, or in part) is completed,\n+     * in cases where filter other that {@link #INCLUDE_ALL} was returned.\n+     * This occurs when {@link JsonGenerator#writeEndObject()} is called.\n+     */\n+    public void filterFinishObject() { }\n+\n+    /**\n+     * Method called to indicate that output of non-filtered Array (one that may\n+     * have been included either completely, or in part) is completed,\n+     * in cases where filter other that {@link #INCLUDE_ALL} was returned.\n+     * This occurs when {@link JsonGenerator#writeEndArray()} is called.\n+     */\n+    public void filterFinishArray() { }\n+\n+    /*\n+    /**********************************************************\n+    /* API, properties/elements\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to check whether property value with specified name,\n+     * at current output location, should be included in output.\n+     * Three kinds of return values may be used as follows:\n+     *<ul>\n+     * <li><code>null</code> to indicate that the property and its value should be skipped\n+     *   </li>\n+     * <li>{@link #INCLUDE_ALL} to indicate that the property and its value should be included\n+     * completely in output\n+     *   </li>\n+     * <li>Any other {@link TokenFilter} implementation (possibly this one) to mean\n+     *  that further inclusion calls on returned filter object need to be made\n+     *  as necessary, to determine inclusion.\n+     *   </li>\n+     * </ul>\n+     *<p>\n+     * The default implementation simply returns <code>this</code> to continue calling\n+     * methods on this filter object, without full inclusion or exclusion.\n+     * \n+     * @return TokenFilter to use for further calls within property value, unless return value\n+     *   is <code>null</code> or {@link #INCLUDE_ALL} (which have simpler semantics)\n+     */\n+    public TokenFilter includeProperty(String name) {\n+        return this;\n+    }\n+\n+    /**\n+     * Method called to check whether array element with specified index (zero-based),\n+     * at current output location, should be included in output.\n+     * Three kinds of return values may be used as follows:\n+     *<ul>\n+     * <li><code>null</code> to indicate that the Array element should be skipped\n+     *   </li>\n+     * <li>{@link #INCLUDE_ALL} to indicate that the Array element should be included\n+     * completely in output\n+     *   </li>\n+     * <li>Any other {@link TokenFilter} implementation (possibly this one) to mean\n+     *  that further inclusion calls on returned filter object need to be made\n+     *  as necessary, to determine inclusion.\n+     *   </li>\n+     * </ul>\n+     *<p>\n+     * The default implementation simply returns <code>this</code> to continue calling\n+     * methods on this filter object, without full inclusion or exclusion.\n+     * \n+     * @return TokenFilter to use for further calls within element value, unless return value\n+     *   is <code>null</code> or {@link #INCLUDE_ALL} (which have simpler semantics)\n+     */\n+    public TokenFilter includeElement(int index) {\n+        return this;\n+    }\n+\n+    /**\n+     * Method called to check whether root-level value,\n+     * at current output location, should be included in output.\n+     * Three kinds of return values may be used as follows:\n+     *<ul>\n+     * <li><code>null</code> to indicate that the root value should be skipped\n+     *   </li>\n+     * <li>{@link #INCLUDE_ALL} to indicate that the root value should be included\n+     * completely in output\n+     *   </li>\n+     * <li>Any other {@link TokenFilter} implementation (possibly this one) to mean\n+     *  that further inclusion calls on returned filter object need to be made\n+     *  as necessary, to determine inclusion.\n+     *   </li>\n+     * </ul>\n+     *<p>\n+     * The default implementation simply returns <code>this</code> to continue calling\n+     * methods on this filter object, without full inclusion or exclusion.\n+     * \n+     * @return TokenFilter to use for further calls within root value, unless return value\n+     *   is <code>null</code> or {@link #INCLUDE_ALL} (which have simpler semantics)\n+     */\n+    public TokenFilter includeRootValue(int index) {\n+        return this;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* API, scalar values (being read)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Call made when verifying whether a scaler value is being\n+     * read from a parser.\n+     *<p>\n+     * Default action is to call <code>_includeScalar()</code> and return\n+     * whatever it indicates.\n+     */\n+    public boolean includeValue(JsonParser p) throws IOException {\n+        return _includeScalar();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* API, scalar values (being written)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Call made to verify whether leaf-level\n+     * boolean value\n+     * should be included in output or not.\n+     */\n+    public boolean includeBoolean(boolean value) {\n+        return _includeScalar();\n+    }\n+\n+    /**\n+     * Call made to verify whether leaf-level\n+     * null value\n+     * should be included in output or not.\n+     */\n+    public boolean includeNull() {\n+        return _includeScalar();\n+    }\n+\n+    /**\n+     * Call made to verify whether leaf-level\n+     * String value\n+     * should be included in output or not.\n+     */\n+    public boolean includeString(String value) {\n+        return _includeScalar();\n+    }\n+\n+    /**\n+     * Call made to verify whether leaf-level\n+     * <code>int</code> value\n+     * should be included in output or not.\n+     * \n+     * NOTE: also called for `short`, `byte`\n+     */\n+    public boolean includeNumber(int v) {\n+        return _includeScalar();\n+    }\n+\n+    /**\n+     * Call made to verify whether leaf-level\n+     * <code>long</code> value\n+     * should be included in output or not.\n+     */\n+    public boolean includeNumber(long v) {\n+        return _includeScalar();\n+    }\n+\n+    /**\n+     * Call made to verify whether leaf-level\n+     * <code>float</code> value\n+     * should be included in output or not.\n+     */\n+    public boolean includeNumber(float v) {\n+        return _includeScalar();\n+    }\n+\n+    /**\n+     * Call made to verify whether leaf-level\n+     * <code>double</code> value\n+     * should be included in output or not.\n+     */\n+    public boolean includeNumber(double v) {\n+        return _includeScalar();\n+    }\n+    \n+    /**\n+     * Call made to verify whether leaf-level\n+     * {@link BigDecimal} value\n+     * should be included in output or not.\n+     */\n+    public boolean includeNumber(BigDecimal v) {\n+        return _includeScalar();\n+    }\n+\n+    /**\n+     * Call made to verify whether leaf-level\n+     * {@link BigInteger} value\n+     * should be included in output or not.\n+     */\n+    public boolean includeNumber(BigInteger v) {\n+        return _includeScalar();\n+    }\n+\n+    /**\n+     * Call made to verify whether leaf-level\n+     * Binary value\n+     * should be included in output or not.\n+     *<p>\n+     * NOTE: no binary payload passed; assumption is this won't be of much use.\n+     */\n+    public boolean includeBinary() {\n+        return _includeScalar();\n+    }\n+\n+    /**\n+     * Call made to verify whether leaf-level\n+     * raw (pre-encoded, not quoted by generator) value\n+     * should be included in output or not.\n+     *<p>\n+     * NOTE: value itself not passed since it may come on multiple forms\n+     * and is unlikely to be of much use in determining inclusion\n+     * criteria.\n+     */\n+    public boolean includeRawValue() {\n+        return _includeScalar();\n+    }\n+    \n+    /**\n+     * Call made to verify whether leaf-level\n+     * embedded (Opaque) value\n+     * should be included in output or not.\n+     */\n+    public boolean includeEmbeddedValue(Object ob) {\n+        return _includeScalar();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Overrides\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String toString() {\n+        if (this == INCLUDE_ALL) {\n+            return \"TokenFilter.INCLUDE_ALL\";\n+        }\n+        return super.toString();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Other methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Overridable default implementation delegated to all scalar value\n+     * inclusion check methods.\n+     * The default implementation simply includes all leaf values.\n+     */\n+    protected boolean _includeScalar() {\n+        return true;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/TokenFilterContext.java\n+package com.fasterxml.jackson.core.filter;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+/**\n+ * Alternative variant of {@link JsonStreamContext}, used when filtering\n+ * content being read or written (based on {@link TokenFilter}).\n+ * \n+ * @since 2.6\n+ */\n+public class TokenFilterContext extends JsonStreamContext\n+{\n+    /**\n+     * Parent context for this context; null for root context.\n+     */\n+    protected final TokenFilterContext _parent;\n+\n+    /*\n+    /**********************************************************\n+    /* Simple instance reuse slots; speed up things\n+    /* a bit (10-15%) for docs with lots of small\n+    /* arrays/objects\n+    /**********************************************************\n+     */\n+\n+    protected TokenFilterContext _child = null;\n+\n+    /*\n+    /**********************************************************\n+    /* Location/state information\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Name of the field of which value is to be parsed; only\n+     * used for OBJECT contexts\n+     */\n+    protected String _currentName;\n+\n+    /**\n+     * Filter to use for items in this state (for properties of Objects,\n+     * elements of Arrays, and root-level values of root context)\n+     */\n+    protected TokenFilter _filter;\n+\n+    /**\n+     * Flag that indicates that start token has been read/written,\n+     * so that matching close token needs to be read/written as well\n+     * when context is getting closed.\n+     */\n+    protected boolean _startHandled;\n+\n+    /**\n+     * Flag that indicates that the current name of this context\n+     * still needs to be read/written, if path from root down to\n+     * included leaf is to be exposed.\n+     */\n+    protected boolean _needToHandleName;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    protected TokenFilterContext(int type, TokenFilterContext parent,\n+            TokenFilter filter, boolean startHandled)\n+    {\n+        super();\n+        _type = type;\n+        _parent = parent;\n+        _filter = filter;\n+        _index = -1;\n+        _startHandled = startHandled;\n+        _needToHandleName = false;\n+    }\n+\n+    protected TokenFilterContext reset(int type,\n+            TokenFilter filter, boolean startWritten)\n+    {\n+        _type = type;\n+        _filter = filter;\n+        _index = -1;\n+        _currentName = null;\n+        _startHandled = startWritten;\n+        _needToHandleName = false;\n+        return this;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Factory methods\n+    /**********************************************************\n+     */\n+\n+    public static TokenFilterContext createRootContext(TokenFilter filter) {\n+        // true -> since we have no start/end marker, consider start handled\n+        return new TokenFilterContext(TYPE_ROOT, null, filter, true);\n+    }\n+\n+    public TokenFilterContext createChildArrayContext(TokenFilter filter, boolean writeStart) {\n+        TokenFilterContext ctxt = _child;\n+        if (ctxt == null) {\n+            _child = ctxt = new TokenFilterContext(TYPE_ARRAY, this, filter, writeStart);\n+            return ctxt;\n+        }\n+        return ctxt.reset(TYPE_ARRAY, filter, writeStart);\n+    }\n+\n+    public TokenFilterContext createChildObjectContext(TokenFilter filter, boolean writeStart) {\n+        TokenFilterContext ctxt = _child;\n+        if (ctxt == null) {\n+            _child = ctxt = new TokenFilterContext(TYPE_OBJECT, this, filter, writeStart);\n+            return ctxt;\n+        }\n+        return ctxt.reset(TYPE_OBJECT, filter, writeStart);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* State changes\n+    /**********************************************************\n+     */\n+    \n+    public TokenFilter setFieldName(String name) throws JsonProcessingException {\n+        _currentName = name;\n+        _needToHandleName = true;\n+        return _filter;\n+    }\n+\n+    /**\n+     * Method called to check whether value is to be included at current output\n+     * position, either as Object property, Array element, or root value.\n+     */\n+    public TokenFilter checkValue(TokenFilter filter) {\n+        // First, checks for Object properties have been made earlier:\n+        if (_type == TYPE_OBJECT) {\n+            return filter;\n+        }\n+        // We increase it first because at the beginning of array, value is -1\n+        int ix = ++_index;\n+        if (_type == TYPE_ARRAY) {\n+            return filter.includeElement(ix);\n+        }\n+        return filter.includeRootValue(ix);\n+    }\n+\n+    /**\n+     * Method called to ensure that parent path from root is written up to\n+     * and including this node.\n+     */\n+    public void writePath(JsonGenerator gen) throws IOException\n+    {\n+        if ((_filter == null) || (_filter == TokenFilter.INCLUDE_ALL)) {\n+            return;\n+        }\n+        if (_parent != null) {\n+            _parent._writePath(gen);\n+        }\n+        if (_startHandled) {\n+            // even if Object started, need to start leaf-level name\n+            if (_needToHandleName) {\n+                gen.writeFieldName(_currentName);\n+            }\n+        } else {\n+            _startHandled = true;\n+            if (_type == TYPE_OBJECT) {\n+                gen.writeStartObject();\n+                gen.writeFieldName(_currentName); // we know name must be written\n+            } else if (_type == TYPE_ARRAY) {\n+                gen.writeStartArray();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Variant of {@link #writePath(JsonGenerator)} called when all we\n+     * need is immediately surrounding Object. Method typically called\n+     * when including a single property but not including full path\n+     * to root.\n+     */\n+    public void writeImmediatePath(JsonGenerator gen) throws IOException\n+    {\n+        if ((_filter == null) || (_filter == TokenFilter.INCLUDE_ALL)) {\n+            return;\n+        }\n+        if (_startHandled) {\n+            // even if Object started, need to start leaf-level name\n+            if (_needToHandleName) {\n+                gen.writeFieldName(_currentName);\n+            }\n+        } else {\n+            _startHandled = true;\n+            if (_type == TYPE_OBJECT) {\n+                gen.writeStartObject();\n+                if (_needToHandleName) {\n+                    gen.writeFieldName(_currentName);\n+                }\n+            } else if (_type == TYPE_ARRAY) {\n+                gen.writeStartArray();\n+            }\n+        }\n+    }\n+\n+    private void _writePath(JsonGenerator gen) throws IOException\n+    {\n+        if ((_filter == null) || (_filter == TokenFilter.INCLUDE_ALL)) {\n+            return;\n+        }\n+        if (_parent != null) {\n+            _parent._writePath(gen);\n+        }\n+        if (_startHandled) {\n+            // even if Object started, need to start leaf-level name\n+            if (_needToHandleName) {\n+                _needToHandleName = false; // at parent must explicitly clear\n+                gen.writeFieldName(_currentName);\n+            }\n+        } else {\n+            _startHandled = true;\n+            if (_type == TYPE_OBJECT) {\n+                gen.writeStartObject();\n+                if (_needToHandleName) {\n+                    _needToHandleName = false; // at parent must explicitly clear\n+                    gen.writeFieldName(_currentName);\n+                }\n+            } else if (_type == TYPE_ARRAY) {\n+                gen.writeStartArray();\n+            }\n+        }\n+    }\n+\n+    public TokenFilterContext closeArray(JsonGenerator gen) throws IOException\n+    {\n+        if (_startHandled) {\n+            gen.writeEndArray();\n+        }\n+        if ((_filter != null) && (_filter != TokenFilter.INCLUDE_ALL)) {\n+            _filter.filterFinishArray();\n+        }\n+        return _parent;\n+    }\n+\n+    public TokenFilterContext closeObject(JsonGenerator gen) throws IOException\n+    {\n+        if (_startHandled) {\n+            gen.writeEndObject();\n+        }\n+        if ((_filter != null) && (_filter != TokenFilter.INCLUDE_ALL)) {\n+            _filter.filterFinishObject();\n+        }\n+        return _parent;\n+    }\n+    \n+    public void skipParentChecks() {\n+        _filter = null;\n+        for (TokenFilterContext ctxt = _parent; ctxt != null; ctxt = ctxt._parent) {\n+            _parent._filter = null;\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Accessors, mutators\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public Object getCurrentValue() { return null; }\n+\n+    @Override\n+    public void setCurrentValue(Object v) { }\n+\n+    @Override public final TokenFilterContext getParent() { return _parent; }\n+    @Override public final String getCurrentName() { return _currentName; }\n+\n+    public TokenFilter getFilter() { return _filter; }\n+    public boolean isStartHandled() { return _startHandled; }\n+\n+    public JsonToken nextTokenToRead() {\n+        if (!_startHandled) {\n+            _startHandled = true;\n+            if (_type == TYPE_OBJECT) {\n+                return JsonToken.START_OBJECT;\n+            }\n+            // Note: root should never be unhandled\n+            return JsonToken.START_ARRAY;\n+        }\n+        // But otherwise at most might have FIELD_NAME\n+        if (_needToHandleName && (_type == TYPE_OBJECT)) {\n+            _needToHandleName = false;\n+            return JsonToken.FIELD_NAME;\n+        }\n+        return null;\n+    }\n+\n+    public TokenFilterContext findChildOf(TokenFilterContext parent) {\n+        if (_parent == parent) {\n+            return this;\n+        }\n+        TokenFilterContext curr = _parent;\n+        while (curr != null) {\n+            TokenFilterContext p = curr._parent;\n+            if (p == parent) {\n+                return curr;\n+            }\n+            curr = p;\n+        }\n+        // should never occur but...\n+        return null;\n+    }\n+    \n+    // // // Internally used abstract methods\n+\n+    protected void appendDesc(StringBuilder sb) {\n+        if (_parent != null) {\n+            _parent.appendDesc(sb);\n+        }\n+        if (_type == TYPE_OBJECT) {\n+            sb.append('{');\n+            if (_currentName != null) {\n+                sb.append('\"');\n+                // !!! TODO: Name chars should be escaped?\n+                sb.append(_currentName);\n+                sb.append('\"');\n+            } else {\n+                sb.append('?');\n+            }\n+            sb.append('}');\n+        } else if (_type == TYPE_ARRAY) {\n+            sb.append('[');\n+            sb.append(getCurrentIndex());\n+            sb.append(']');\n+        } else {\n+            // nah, ROOT:\n+            sb.append(\"/\");\n+        }\n+    }\n+\n+    // // // Overridden standard methods\n+\n+    /**\n+     * Overridden to provide developer writeable \"JsonPath\" representation\n+     * of the context.\n+     */\n+    @Override public String toString() {\n+        StringBuilder sb = new StringBuilder(64);\n+        appendDesc(sb);\n+        return sb.toString();\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\n         _encoding = enc;\n     }\n \n+    /**\n+     * @since 1.6\n+     */\n+    public IOContext withEncoding(JsonEncoding enc) {\n+        _encoding = enc;\n+        return this;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Public API, accessors\n--- a/src/main/java/com/fasterxml/jackson/core/io/NumberOutput.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/NumberOutput.java\n         return Double.toString(v);\n     }\n \n+    /**\n+     * @since 2.6.0\n+     */\n+    public static String toString(float v) {\n+        return Float.toString(v);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Internal methods\n--- a/src/main/java/com/fasterxml/jackson/core/json/ByteSourceJsonBootstrapper.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ByteSourceJsonBootstrapper.java\n import com.fasterxml.jackson.core.format.InputAccessor;\n import com.fasterxml.jackson.core.format.MatchStrength;\n import com.fasterxml.jackson.core.io.*;\n-import com.fasterxml.jackson.core.sym.BytesToNameCanonicalizer;\n+import com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer;\n import com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\n \n /**\n     }\n \n     public JsonParser constructParser(int parserFeatures, ObjectCodec codec,\n-            BytesToNameCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols,\n+            ByteQuadsCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols,\n             int factoryFeatures) throws IOException\n     {\n         JsonEncoding enc = detectEncoding();\n              * (which is ok for larger input; not so hot for smaller; but this is not a common case)\n              */\n             if (JsonFactory.Feature.CANONICALIZE_FIELD_NAMES.enabledIn(factoryFeatures)) {\n-                BytesToNameCanonicalizer can = rootByteSymbols.makeChild(factoryFeatures);\n+                ByteQuadsCanonicalizer can = rootByteSymbols.makeChild(factoryFeatures);\n                 return new UTF8StreamJsonParser(_context, parserFeatures, _in, codec, can,\n                         _inputBuffer, _inputPtr, _inputEnd, _bufferRecyclable);\n             }\n--- a/src/main/java/com/fasterxml/jackson/core/json/JsonGeneratorImpl.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonGeneratorImpl.java\n     // // Overrides just to make things final, to possibly help with inlining\n     \n     @Override\n-    public final void writeStringField(String fieldName, String value)\n-        throws IOException, JsonGenerationException\n+    public final void writeStringField(String fieldName, String value) throws IOException\n     {\n         writeFieldName(fieldName);\n         writeString(value);\n--- a/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java\n         return ctxt.reset(TYPE_OBJECT);\n     }\n \n-    // // // Shared API\n-\n     @Override public final JsonWriteContext getParent() { return _parent; }\n     @Override public final String getCurrentName() { return _currentName; }\n \n     public DupDetector getDupDetector() {\n         return _dups;\n     }\n-    \n-    // // // API sub-classes are to implement\n \n     /**\n      * Method that writer is to call before it writes a field name.\n     public int writeValue() {\n         // Most likely, object:\n         if (_type == TYPE_OBJECT) {\n+            if (!_gotName) {\n+                return STATUS_EXPECT_NAME;\n+            }\n             _gotName = false;\n             ++_index;\n             return STATUS_OK_AFTER_COLON;\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n             }\n             return _textBuffer.contentsAsString();\n         }\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+            return getCurrentName();\n+        }\n         return super.getValueAsString(null);\n     }\n     \n                 _finishString(); // only strings can be incomplete\n             }\n             return _textBuffer.contentsAsString();\n+        }\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+            return getCurrentName();\n         }\n         return super.getValueAsString(defValue);\n     }\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n import java.math.BigInteger;\n \n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.core.JsonGenerator.Feature;\n import com.fasterxml.jackson.core.io.*;\n \n public class UTF8JsonGenerator\n     private final static byte BYTE_u = (byte) 'u';\n \n     private final static byte BYTE_0 = (byte) '0';\n-    \n+\n     private final static byte BYTE_LBRACKET = (byte) '[';\n     private final static byte BYTE_RBRACKET = (byte) ']';\n     private final static byte BYTE_LCURLY = (byte) '{';\n     private final static byte BYTE_RCURLY = (byte) '}';\n- \n+\n     private final static byte BYTE_BACKSLASH = (byte) '\\\\';\n     private final static byte BYTE_COMMA = (byte) ',';\n     private final static byte BYTE_COLON = (byte) ':';\n \n     // intermediate copies only made up to certain length...\n     private final static int MAX_BYTES_TO_BUFFER = 512;\n-    \n+\n     final static byte[] HEX_CHARS = CharTypes.copyHexBytes();\n \n     private final static byte[] NULL_BYTES = { 'n', 'u', 'l', 'l' };\n     /* Output buffering\n     /**********************************************************\n      */\n-    \n+\n     /**\n      * Underlying output stream used for writing JSON content.\n      */\n      * in the output buffer after escaping\n      */\n     protected final int _outputMaxContiguous;\n-    \n+\n     /**\n      * Intermediate buffer in which characters of a String are copied\n      * before being encoded.\n      */\n     protected char[] _charBuffer;\n-    \n+\n     /**\n      * Length of <code>_charBuffer</code>\n      */\n     protected final int _charBufferLength;\n-    \n+\n     /**\n      * 6 character temporary buffer allocated if needed, for constructing\n      * escape sequences\n             _flushBuffer();\n         }\n         _outputBuffer[_outputTail++] = BYTE_QUOTE;\n-        name.getChars(0, len, _charBuffer, 0);\n         // But as one segment, or multiple?\n         if (len <= _outputMaxContiguous) {\n             if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                 _flushBuffer();\n             }\n-            _writeStringSegment(_charBuffer, 0, len);\n+            _writeStringSegment(name, 0, len);\n         } else {\n-            _writeStringSegments(_charBuffer, 0, len);\n+            _writeStringSegments(name, 0, len);\n         }\n         // and closing quotes; need room for one more char:\n         if (_outputTail >= _outputEnd) {\n     @Override\n     public void writeString(String text) throws IOException\n     {\n-        _verifyValueWrite(\"write text value\");\n+        _verifyValueWrite(WRITE_STRING);\n         if (text == null) {\n             _writeNull();\n             return;\n             _writeStringSegments(text, true);\n             return;\n         }\n-        // yes: good.\n-        text.getChars(0, len, _charBuffer, 0);\n         // Output: if we can't guarantee it fits in output buffer, off-line as well:\n         if (len > _outputMaxContiguous) {\n             _writeLongString(_charBuffer, 0, len);\n             _flushBuffer();\n         }\n         _outputBuffer[_outputTail++] = BYTE_QUOTE;\n-        _writeStringSegment(_charBuffer, 0, len); // we checked space already above\n+        _writeStringSegment(text, 0, len); // we checked space already above\n         /* [JACKSON-462] But that method may have had to expand multi-byte Unicode\n          *   chars, so we must check again\n          */\n     @Override\n     public void writeString(char[] text, int offset, int len) throws IOException\n     {\n-        _verifyValueWrite(\"write text value\");\n+        _verifyValueWrite(WRITE_STRING);\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n         }\n     @Override\n     public final void writeString(SerializableString text) throws IOException\n     {\n-        _verifyValueWrite(\"write text value\");\n+        _verifyValueWrite(WRITE_STRING);\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n         }\n         }\n         _outputBuffer[_outputTail++] = BYTE_QUOTE;\n     }\n-\n+    \n     @Override\n     public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException\n     {\n-        _verifyValueWrite(\"write text value\");\n+        _verifyValueWrite(WRITE_STRING);\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n         }\n     @Override\n     public void writeUTF8String(byte[] text, int offset, int len) throws IOException\n     {\n-        _verifyValueWrite(\"write text value\");\n+        _verifyValueWrite(WRITE_STRING);\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n         }\n     // since 2.5\n     @Override\n     public void writeRawValue(SerializableString text) throws IOException {\n-        _verifyValueWrite(\"write raw value\");\n+        _verifyValueWrite(WRITE_RAW);\n         byte[] raw = text.asUnquotedUTF8();\n         if (raw.length > 0) {\n             _writeBytes(raw);\n             byte[] data, int offset, int len)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write binary value\");\n+        _verifyValueWrite(WRITE_BINARY);\n         // Starting quotes\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n             InputStream data, int dataLength)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write binary value\");\n+        _verifyValueWrite(WRITE_BINARY);\n         // Starting quotes\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n     public void writeNumber(short s)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         // up to 5 digits and possible minus sign\n         if ((_outputTail + 6) >= _outputEnd) {\n             _flushBuffer();\n     public void writeNumber(int i)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         // up to 10 digits and possible minus sign\n         if ((_outputTail + 11) >= _outputEnd) {\n             _flushBuffer();\n     public void writeNumber(long l)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (_cfgNumbersAsStrings) {\n             _writeQuotedLong(l);\n             return;\n     public void writeNumber(BigInteger value)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (value == null) {\n             _writeNull();\n         } else if (_cfgNumbersAsStrings) {\n             return;\n         }\n         // What is the max length for doubles? 40 chars?\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         writeRaw(String.valueOf(d));\n     }\n \n             return;\n         }\n         // What is the max length for floats?\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         writeRaw(String.valueOf(f));\n     }\n \n         throws IOException, JsonGenerationException\n     {\n         // Don't really know max length for big decimal, no point checking\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (value == null) {\n             _writeNull();\n         } else if (_cfgNumbersAsStrings) {\n     public void writeNumber(String encodedValue)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (_cfgNumbersAsStrings) {\n             _writeQuotedRaw(encodedValue);            \n         } else {\n     public void writeBoolean(boolean state)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write boolean value\");\n+        _verifyValueWrite(WRITE_BOOLEAN);\n         if ((_outputTail + 5) >= _outputEnd) {\n             _flushBuffer();\n         }\n     public void writeNull()\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write null value\");\n+        _verifyValueWrite(WRITE_NULL);\n         _writeNull();\n     }\n \n      */\n \n     @Override\n-    protected final void _verifyValueWrite(String typeMsg)\n-        throws IOException, JsonGenerationException\n+    protected final void _verifyValueWrite(String typeMsg) throws IOException\n     {\n         int status = _writeContext.writeValue();\n         if (status == JsonWriteContext.STATUS_EXPECT_NAME) {\n         _verifyPrettyValueWrite(typeMsg, status);\n     }\n \n-    protected final void _verifyPrettyValueWrite(String typeMsg, int status)\n-        throws IOException, JsonGenerationException\n+    protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException\n     {\n         // If we have a pretty printer, it knows what to do:\n         switch (status) {\n      */\n \n     @Override\n-    public void flush()\n-        throws IOException\n+    public void flush() throws IOException\n     {\n         _flushBuffer();\n         if (_outputStream != null) {\n     }\n \n     @Override\n-    public void close()\n-        throws IOException\n+    public void close() throws IOException\n     {\n         super.close();\n \n      * the output buffer. If so, we will need to choose smaller output\n      * chunks to write at a time.\n      */\n-    private final void _writeStringSegments(char[] cbuf, int offset, int totalLen)\n-        throws IOException, JsonGenerationException\n+    private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException\n     {\n         do {\n             int len = Math.min(_outputMaxContiguous, totalLen);\n                 _flushBuffer();\n             }\n             _writeStringSegment(cbuf, offset, len);\n+            offset += len;\n+            totalLen -= len;\n+        } while (totalLen > 0);\n+    }\n+\n+    private final void _writeStringSegments(String text, int offset, int totalLen) throws IOException\n+    {\n+        do {\n+            int len = Math.min(_outputMaxContiguous, totalLen);\n+            if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n+                _flushBuffer();\n+            }\n+            _writeStringSegment(text, offset, len);\n             offset += len;\n             totalLen -= len;\n         } while (totalLen > 0);\n      * potentially enough space for other cases (but not necessarily flushed)\n      */\n     private final void _writeStringSegment(char[] cbuf, int offset, int len)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n         // note: caller MUST ensure (via flushing) there's room for ASCII only\n         \n         }\n     }\n \n+    private final void _writeStringSegment(String text, int offset, int len) throws IOException\n+    {\n+        // note: caller MUST ensure (via flushing) there's room for ASCII only\n+        // Fast+tight loop for ASCII-only, no-escaping-needed output\n+        len += offset; // becomes end marker, then\n+\n+        int outputPtr = _outputTail;\n+        final byte[] outputBuffer = _outputBuffer;\n+        final int[] escCodes = _outputEscapes;\n+\n+        while (offset < len) {\n+            int ch = text.charAt(offset);\n+            // note: here we know that (ch > 0x7F) will cover case of escaping non-ASCII too:\n+            if (ch > 0x7F || escCodes[ch] != 0) {\n+                break;\n+            }\n+            outputBuffer[outputPtr++] = (byte) ch;\n+            ++offset;\n+        }\n+        _outputTail = outputPtr;\n+        if (offset < len) {\n+            if (_characterEscapes != null) {\n+                _writeCustomStringSegment2(text, offset, len);\n+            } else if (_maximumNonEscapedChar == 0) {\n+                _writeStringSegment2(text, offset, len);\n+            } else {\n+                _writeStringSegmentASCII2(text, offset, len);\n+            }\n+        }\n+    }\n+\n     /**\n      * Secondary method called when content contains characters to escape,\n      * and/or multi-byte UTF-8 characters.\n      */\n-    private final void _writeStringSegment2(final char[] cbuf, int offset, final int end)\n-        throws IOException, JsonGenerationException\n+    private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException\n     {\n         // Ok: caller guarantees buffer can have room; but that may require flushing:\n         if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n         _outputTail = outputPtr;\n     }\n \n+    private final void _writeStringSegment2(final String text, int offset, final int end) throws IOException\n+    {\n+        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n+            _flushBuffer();\n+        }\n+\n+        int outputPtr = _outputTail;\n+\n+        final byte[] outputBuffer = _outputBuffer;\n+        final int[] escCodes = _outputEscapes;\n+        \n+        while (offset < end) {\n+            int ch = text.charAt(offset++);\n+            if (ch <= 0x7F) {\n+                 if (escCodes[ch] == 0) {\n+                     outputBuffer[outputPtr++] = (byte) ch;\n+                     continue;\n+                 }\n+                 int escape = escCodes[ch];\n+                 if (escape > 0) { // 2-char escape, fine\n+                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n+                     outputBuffer[outputPtr++] = (byte) escape;\n+                 } else {\n+                     // ctrl-char, 6-byte escape...\n+                     outputPtr = _writeGenericEscape(ch, outputPtr);\n+                }\n+                continue;\n+            }\n+            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n+                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n+                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n+            } else {\n+                outputPtr = _outputMultiByteChar(ch, outputPtr);\n+            }\n+        }\n+        _outputTail = outputPtr;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Internal methods, low-level writing, text segment\n      * Same as <code>_writeStringSegment2(char[], ...)</code., but with\n      * additional escaping for high-range code points\n      */\n-    private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end)\n-        throws IOException, JsonGenerationException\n+    private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException\n     {\n         // Ok: caller guarantees buffer can have room; but that may require flushing:\n         if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n         _outputTail = outputPtr;\n     }\n \n+    private final void _writeStringSegmentASCII2(final String text, int offset, final int end) throws IOException\n+    {\n+        // Ok: caller guarantees buffer can have room; but that may require flushing:\n+        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n+            _flushBuffer();\n+        }\n+    \n+        int outputPtr = _outputTail;\n+    \n+        final byte[] outputBuffer = _outputBuffer;\n+        final int[] escCodes = _outputEscapes;\n+        final int maxUnescaped = _maximumNonEscapedChar;\n+        \n+        while (offset < end) {\n+            int ch = text.charAt(offset++);\n+            if (ch <= 0x7F) {\n+                 if (escCodes[ch] == 0) {\n+                     outputBuffer[outputPtr++] = (byte) ch;\n+                     continue;\n+                 }\n+                 int escape = escCodes[ch];\n+                 if (escape > 0) { // 2-char escape, fine\n+                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n+                     outputBuffer[outputPtr++] = (byte) escape;\n+                 } else {\n+                     // ctrl-char, 6-byte escape...\n+                     outputPtr = _writeGenericEscape(ch, outputPtr);\n+                 }\n+                 continue;\n+            }\n+            if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars:\n+                outputPtr = _writeGenericEscape(ch, outputPtr);\n+                continue;\n+            }\n+            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n+                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n+                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n+            } else {\n+                outputPtr = _outputMultiByteChar(ch, outputPtr);\n+            }\n+        }\n+        _outputTail = outputPtr;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Internal methods, low-level writing, text segment\n      * Same as <code>_writeStringSegmentASCII2(char[], ...)</code., but with\n      * additional checking for completely custom escapes\n      */\n-    private final void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end)\n-        throws IOException, JsonGenerationException\n+    private final void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException\n     {\n         // Ok: caller guarantees buffer can have room; but that may require flushing:\n         if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n         _outputTail = outputPtr;\n     }\n \n+    private final void _writeCustomStringSegment2(final String text, int offset, final int end) throws IOException\n+    {\n+        // Ok: caller guarantees buffer can have room; but that may require flushing:\n+        if ((_outputTail +  6 * (end - offset)) > _outputEnd) {\n+            _flushBuffer();\n+        }\n+        int outputPtr = _outputTail;\n+    \n+        final byte[] outputBuffer = _outputBuffer;\n+        final int[] escCodes = _outputEscapes;\n+        // may or may not have this limit\n+        final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar;\n+        final CharacterEscapes customEscapes = _characterEscapes; // non-null\n+        \n+        while (offset < end) {\n+            int ch = text.charAt(offset++);\n+            if (ch <= 0x7F) {\n+                 if (escCodes[ch] == 0) {\n+                     outputBuffer[outputPtr++] = (byte) ch;\n+                     continue;\n+                 }\n+                 int escape = escCodes[ch];\n+                 if (escape > 0) { // 2-char escape, fine\n+                     outputBuffer[outputPtr++] = BYTE_BACKSLASH;\n+                     outputBuffer[outputPtr++] = (byte) escape;\n+                 } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) {\n+                     SerializableString esc = customEscapes.getEscapeSequence(ch);\n+                     if (esc == null) {\n+                         _reportError(\"Invalid custom escape definitions; custom escape not found for character code 0x\"\n+                                 +Integer.toHexString(ch)+\", although was supposed to have one\");\n+                     }\n+                     outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n+                 } else {\n+                     // ctrl-char, 6-byte escape...\n+                     outputPtr = _writeGenericEscape(ch, outputPtr);\n+                 }\n+                 continue;\n+            }\n+            if (ch > maxUnescaped) { // [JACKSON-102] Allow forced escaping if non-ASCII (etc) chars:\n+                outputPtr = _writeGenericEscape(ch, outputPtr);\n+                continue;\n+            }\n+            SerializableString esc = customEscapes.getEscapeSequence(ch);\n+            if (esc != null) {\n+                outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end-offset);\n+                continue;\n+            }\n+            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n+                outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n+                outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f));\n+            } else {\n+                outputPtr = _outputMultiByteChar(ch, outputPtr);\n+            }\n+        }\n+        _outputTail = outputPtr;\n+    }\n+\n     private final int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars)\n         throws IOException, JsonGenerationException\n     {\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n import com.fasterxml.jackson.core.base.ParserBase;\n import com.fasterxml.jackson.core.io.CharTypes;\n import com.fasterxml.jackson.core.io.IOContext;\n-import com.fasterxml.jackson.core.sym.*;\n+import com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer;\n import com.fasterxml.jackson.core.util.*;\n \n import static com.fasterxml.jackson.core.JsonTokenId.*;\n     /**\n      * Symbol table that contains field names encountered so far\n      */\n-    final protected BytesToNameCanonicalizer _symbols;\n+    final protected ByteQuadsCanonicalizer _symbols;\n     \n     /*\n     /**********************************************************\n      */\n \n     public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in,\n-            ObjectCodec codec, BytesToNameCanonicalizer sym,\n+            ObjectCodec codec, ByteQuadsCanonicalizer sym,\n             byte[] inputBuffer, int start, int end,\n             boolean bufferRecyclable)\n     {\n      */\n \n     @Override\n-    public String getText()\n-        throws IOException, JsonParseException\n+    public String getText() throws IOException\n     {\n         if (_currToken == JsonToken.VALUE_STRING) {\n             if (_tokenIncomplete) {\n                 _tokenIncomplete = false;\n-                _finishString(); // only strings can be incomplete\n+                return _finishAndReturnString(); // only strings can be incomplete\n             }\n             return _textBuffer.contentsAsString();\n         }\n     \n     // @since 2.1\n     @Override\n-    public String getValueAsString() throws IOException, JsonParseException\n+    public String getValueAsString() throws IOException\n     {\n         if (_currToken == JsonToken.VALUE_STRING) {\n             if (_tokenIncomplete) {\n                 _tokenIncomplete = false;\n-                _finishString(); // only strings can be incomplete\n+                return _finishAndReturnString(); // only strings can be incomplete\n             }\n             return _textBuffer.contentsAsString();\n+        }\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+            return getCurrentName();\n         }\n         return super.getValueAsString(null);\n     }\n     \n     // @since 2.1\n     @Override\n-    public String getValueAsString(String defValue) throws IOException, JsonParseException\n+    public String getValueAsString(String defValue) throws IOException\n     {\n         if (_currToken == JsonToken.VALUE_STRING) {\n             if (_tokenIncomplete) {\n                 _tokenIncomplete = false;\n-                _finishString(); // only strings can be incomplete\n+                return _finishAndReturnString(); // only strings can be incomplete\n             }\n             return _textBuffer.contentsAsString();\n         }\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+            return getCurrentName();\n+        }\n         return super.getValueAsString(defValue);\n+    }\n+\n+    // since 2.6\n+    @Override\n+    public int getValueAsInt() throws IOException\n+    {\n+        JsonToken t = _currToken;\n+        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n+            // inlined 'getIntValue()'\n+            if ((_numTypesValid & NR_INT) == 0) {\n+                if (_numTypesValid == NR_UNKNOWN) {\n+                    return _parseIntValue();\n+                }\n+                if ((_numTypesValid & NR_INT) == 0) {\n+                    convertNumberToInt();\n+                }\n+            }\n+            return _numberInt;\n+        }\n+        return super.getValueAsInt(0);\n+    }\n+\n+    // since 2.6\n+    @Override\n+    public int getValueAsInt(int defValue) throws IOException\n+    {\n+        JsonToken t = _currToken;\n+        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n+            // inlined 'getIntValue()'\n+            if ((_numTypesValid & NR_INT) == 0) {\n+                if (_numTypesValid == NR_UNKNOWN) {\n+                    return _parseIntValue();\n+                }\n+                if ((_numTypesValid & NR_INT) == 0) {\n+                    convertNumberToInt();\n+                }\n+            }\n+            return _numberInt;\n+        }\n+        return super.getValueAsInt(defValue);\n     }\n     \n     protected final String _getText2(JsonToken t)\n     }\n \n     @Override\n-    public char[] getTextCharacters()\n-        throws IOException, JsonParseException\n+    public char[] getTextCharacters() throws IOException\n     {\n         if (_currToken != null) { // null only before/after document\n             switch (_currToken.id()) {\n     }\n \n     @Override\n-    public int getTextLength()\n-        throws IOException, JsonParseException\n+    public int getTextLength() throws IOException\n     {\n         if (_currToken != null) { // null only before/after document\n             switch (_currToken.id()) {\n     }\n \n     @Override\n-    public int getTextOffset() throws IOException, JsonParseException\n+    public int getTextOffset() throws IOException\n     {\n         // Most have offset of 0, only some may have other values:\n         if (_currToken != null) {\n     }\n     \n     @Override\n-    public byte[] getBinaryValue(Base64Variant b64variant)\n-        throws IOException, JsonParseException\n+    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n     {\n         if (_currToken != JsonToken.VALUE_STRING &&\n                 (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n     }\n \n     @Override\n-    public int readBinaryValue(Base64Variant b64variant, OutputStream out)\n-        throws IOException, JsonParseException\n+    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n     {\n         // if we have already read the token, just use whatever we may have\n         if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n     }\n \n     protected int _readBinary(Base64Variant b64variant, OutputStream out,\n-                              byte[] buffer)\n-        throws IOException, JsonParseException\n+                              byte[] buffer) throws IOException\n     {\n         int outputPtr = 0;\n         final int outputEnd = buffer.length - 3;\n             return _nextTokenNotInObject(i);\n         }\n         // So first parse the field name itself:\n-        Name n = _parseName(i);\n-        _parsingContext.setCurrentName(n.getName());\n+        String n = _parseName(i);\n+        _parsingContext.setCurrentName(n);\n         _currToken = JsonToken.FIELD_NAME;\n \n         i = _skipColon();\n             return null;\n         }\n \n-        Name n = _parseName(i);\n-        final String nameStr = n.getName();\n+        final String nameStr = _parseName(i);\n         _parsingContext.setCurrentName(nameStr);\n         _currToken = JsonToken.FIELD_NAME;\n \n     private final boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException\n     {\n         // // // and this is back to standard nextToken()\n-            \n-        Name n = _parseName(i);\n-        final boolean match;\n-        {\n-            String nameStr = n.getName();\n-            _parsingContext.setCurrentName(nameStr);\n-            match = nameStr.equals(str.getValue());\n-        }\n+\n+        String n = _parseName(i);\n+        _parsingContext.setCurrentName(n);\n+        final boolean match = n.equals(str.getValue());\n         _currToken = JsonToken.FIELD_NAME;\n         i = _skipColon();\n \n             if (t == JsonToken.VALUE_STRING) {\n                 if (_tokenIncomplete) {\n                     _tokenIncomplete = false;\n-                    _finishString();\n+                    return _finishAndReturnString();\n                 }\n                 return _textBuffer.contentsAsString();\n             }\n     /**********************************************************\n      */\n     \n-    protected final Name _parseName(int i) throws IOException\n+    protected final String _parseName(int i) throws IOException\n     {\n         if (i != INT_QUOTE) {\n             return _handleOddName(i);\n         }\n         // First: can we optimize out bounds checks?\n-        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n+        if ((_inputPtr + 13) > _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\n             return slowParseName();\n         }\n \n             return parseName(q, i, 1);\n         }     \n         if (q == INT_QUOTE) { // special case, \"\"\n-            return BytesToNameCanonicalizer.getEmptyName();\n+            return \"\";\n         }\n         return parseName(0, q, 0); // quoting or invalid char\n     }\n \n-    protected final Name parseMediumName(int q2) throws IOException\n+    protected final String parseMediumName(int q2) throws IOException\n     {\n         final byte[] input = _inputBuffer;\n         final int[] codes = _icLatin1;\n             }\n             return parseName(_quad1, q2, i, 4);\n         }\n-        return parseLongName(i, q2);\n-    }\n-\n-    protected final Name parseLongName(int q, final int q2) throws IOException\n+        return parseMediumName2(i, q2);\n+    }\n+\n+    /**\n+     * @since 2.6\n+     */\n+    protected final String parseMediumName2(int q3, final int q2) throws IOException\n+    {\n+        final byte[] input = _inputBuffer;\n+        final int[] codes = _icLatin1;\n+\n+        // Got 9 name bytes so far\n+        int i = input[_inputPtr++] & 0xFF;\n+        if (codes[i] != 0) {\n+            if (i == INT_QUOTE) { // 9 bytes\n+                return findName(_quad1, q2, q3, 1);\n+            }\n+            return parseName(_quad1, q2, q3, i, 1);\n+        }\n+        q3 = (q3 << 8) | i;\n+        i = input[_inputPtr++] & 0xFF;\n+        if (codes[i] != 0) {\n+            if (i == INT_QUOTE) { // 10 bytes\n+                return findName(_quad1, q2, q3, 2);\n+            }\n+            return parseName(_quad1, q2, q3, i, 2);\n+        }\n+        q3 = (q3 << 8) | i;\n+        i = input[_inputPtr++] & 0xFF;\n+        if (codes[i] != 0) {\n+            if (i == INT_QUOTE) { // 11 bytes\n+                return findName(_quad1, q2, q3, 3);\n+            }\n+            return parseName(_quad1, q2, q3, i, 3);\n+        }\n+        q3 = (q3 << 8) | i;\n+        i = input[_inputPtr++] & 0xFF;\n+        if (codes[i] != 0) {\n+            if (i == INT_QUOTE) { // 12 bytes\n+                return findName(_quad1, q2, q3, 4);\n+            }\n+            return parseName(_quad1, q2, q3, i, 4);\n+        }\n+        return parseLongName(i, q2, q3);\n+    }\n+    \n+    protected final String parseLongName(int q, final int q2, int q3) throws IOException\n     {\n         _quadBuffer[0] = _quad1;\n         _quadBuffer[1] = q2;\n+        _quadBuffer[2] = q3;\n \n         // As explained above, will ignore UTF-8 encoding at this point\n         final byte[] input = _inputBuffer;\n         final int[] codes = _icLatin1;\n-        int qlen = 2;\n+        int qlen = 3;\n \n         while ((_inputPtr + 4) <= _inputEnd) {\n             int i = input[_inputPtr++] & 0xFF;\n \n     /**\n      * Method called when not even first 8 bytes are guaranteed\n-     * to come consecutively. Happens rarely, so this is off-lined;\n+     * to come consequtively. Happens rarely, so this is offlined;\n      * plus we'll also do full checks for escaping etc.\n      */\n-    protected Name slowParseName() throws IOException\n+    protected String slowParseName() throws IOException\n     {\n         if (_inputPtr >= _inputEnd) {\n             if (!loadMore()) {\n         }\n         int i = _inputBuffer[_inputPtr++] & 0xFF;\n         if (i == INT_QUOTE) { // special case, \"\"\n-            return BytesToNameCanonicalizer.getEmptyName();\n+            return \"\";\n         }\n         return parseEscapedName(_quadBuffer, 0, 0, i, 0);\n     }\n \n-    private final Name parseName(int q1, int ch, int lastQuadBytes) throws IOException {\n+    private final String parseName(int q1, int ch, int lastQuadBytes) throws IOException {\n         return parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes);\n     }\n \n-    private final Name parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException {\n+    private final String parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException {\n         _quadBuffer[0] = q1;\n         return parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes);\n     }\n \n+    private final String parseName(int q1, int q2, int q3, int ch, int lastQuadBytes) throws IOException {\n+        _quadBuffer[0] = q1;\n+        _quadBuffer[1] = q2;\n+        return parseEscapedName(_quadBuffer, 2, q3, ch, lastQuadBytes);\n+    }\n+    \n     /**\n      * Slower parsing method which is generally branched to when\n      * an escape sequence is detected (or alternatively for long\n-     * names, or ones crossing input buffer boundary). In any case,\n-     * needs to be able to handle more exceptional cases, gets\n-     * slower, and hance is offlined to a separate method.\n-     */\n-    protected final Name parseEscapedName(int[] quads, int qlen, int currQuad, int ch,\n+     * names, one crossing input buffer boundary).\n+     * Needs to be able to handle more exceptional cases, gets slower,\n+     * and hance is offlined to a separate method.\n+     */\n+    protected final String parseEscapedName(int[] quads, int qlen, int currQuad, int ch,\n             int currQuadBytes) throws IOException\n     {\n         /* 25-Nov-2008, tatu: This may seem weird, but here we do not want to worry about\n             }\n             ch = _inputBuffer[_inputPtr++] & 0xFF;\n         }\n+\n         if (currQuadBytes > 0) {\n             if (qlen >= quads.length) {\n                 _quadBuffer = quads = growArrayBy(quads, quads.length);\n             }\n             quads[qlen++] = pad(currQuad, currQuadBytes);\n         }\n-        Name name = _symbols.findName(quads, qlen);\n+        String name = _symbols.findName(quads, qlen);\n         if (name == null) {\n             name = addName(quads, qlen, currQuadBytes);\n         }\n      * In standard mode will just throw an expection; but\n      * in non-standard modes may be able to parse name.\n      */\n-    protected Name _handleOddName(int ch) throws IOException\n+    protected String _handleOddName(int ch) throws IOException\n     {\n         // [JACKSON-173]: allow single quotes\n         if (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n             }\n             quads[qlen++] = currQuad;\n         }\n-        Name name = _symbols.findName(quads, qlen);\n+        String name = _symbols.findName(quads, qlen);\n         if (name == null) {\n             name = addName(quads, qlen, currQuadBytes);\n         }\n      * for valid JSON -- more alternatives, more code, generally\n      * bit slower execution.\n      */\n-    protected Name _parseAposName() throws IOException\n+    protected String _parseAposName() throws IOException\n     {\n         if (_inputPtr >= _inputEnd) {\n             if (!loadMore()) {\n         }\n         int ch = _inputBuffer[_inputPtr++] & 0xFF;\n         if (ch == '\\'') { // special case, ''\n-            return BytesToNameCanonicalizer.getEmptyName();\n+            return \"\";\n         }\n         int[] quads = _quadBuffer;\n         int qlen = 0;\n             }\n             quads[qlen++] = pad(currQuad, currQuadBytes);\n         }\n-        Name name = _symbols.findName(quads, qlen);\n+        String name = _symbols.findName(quads, qlen);\n         if (name == null) {\n             name = addName(quads, qlen, currQuadBytes);\n         }\n     /**********************************************************\n      */\n \n-    private final Name findName(int q1, int lastQuadBytes)\n-        throws JsonParseException\n+    private final String findName(int q1, int lastQuadBytes) throws JsonParseException\n     {\n         q1 = pad(q1, lastQuadBytes);\n         // Usually we'll find it from the canonical symbol table already\n-        Name name = _symbols.findName(q1);\n+        String name = _symbols.findName(q1);\n         if (name != null) {\n             return name;\n         }\n         return addName(_quadBuffer, 1, lastQuadBytes);\n     }\n \n-    private final Name findName(int q1, int q2, int lastQuadBytes)\n-        throws JsonParseException\n+    private final String findName(int q1, int q2, int lastQuadBytes) throws JsonParseException\n     {\n         q2 = pad(q2, lastQuadBytes);\n         // Usually we'll find it from the canonical symbol table already\n-        Name name = _symbols.findName(q1, q2);\n+        String name = _symbols.findName(q1, q2);\n         if (name != null) {\n             return name;\n         }\n         return addName(_quadBuffer, 2, lastQuadBytes);\n     }\n \n-    private final Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes)\n-        throws JsonParseException\n+    private final String findName(int q1, int q2, int q3, int lastQuadBytes) throws JsonParseException\n+    {\n+        q3 = pad(q3, lastQuadBytes);\n+        String name = _symbols.findName(q1, q2, q3);\n+        if (name != null) {\n+            return name;\n+        }\n+        int[] quads = _quadBuffer;\n+        quads[0] = q1;\n+        quads[1] = q2;\n+        quads[2] = pad(q3, lastQuadBytes);\n+        return addName(quads, 3, lastQuadBytes);\n+    }\n+    \n+    private final String findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException\n     {\n         if (qlen >= quads.length) {\n             _quadBuffer = quads = growArrayBy(quads, quads.length);\n         }\n         quads[qlen++] = pad(lastQuad, lastQuadBytes);\n-        Name name = _symbols.findName(quads, qlen);\n+        String name = _symbols.findName(quads, qlen);\n         if (name == null) {\n             return addName(quads, qlen, lastQuadBytes);\n         }\n      * multi-byte chars (if any), and then construct Name instance\n      * and add it to the symbol table.\n      */\n-    private final Name addName(int[] quads, int qlen, int lastQuadBytes)\n-        throws JsonParseException\n+    private final String addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException\n     {\n         /* Ok: must decode UTF-8 chars. No other validation is\n          * needed, since unescaping has been done earlier as necessary\n         _finishString2(outBuf, outPtr);\n     }\n \n+    /**\n+     * @since 2.6\n+     */\n+    protected String _finishAndReturnString() throws IOException\n+    {\n+        // First, single tight loop for ASCII content, not split across input buffer boundary:        \n+        int ptr = _inputPtr;\n+        if (ptr >= _inputEnd) {\n+            loadMoreGuaranteed();\n+            ptr = _inputPtr;\n+        }\n+        int outPtr = 0;\n+        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n+        final int[] codes = _icUTF8;\n+\n+        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n+        final byte[] inputBuffer = _inputBuffer;\n+        while (ptr < max) {\n+            int c = (int) inputBuffer[ptr] & 0xFF;\n+            if (codes[c] != 0) {\n+                if (c == INT_QUOTE) {\n+                    _inputPtr = ptr+1;\n+                    return _textBuffer.setCurrentAndReturn(outPtr);\n+                }\n+                break;\n+            }\n+            ++ptr;\n+            outBuf[outPtr++] = (char) c;\n+        }\n+        _inputPtr = ptr;\n+        _finishString2(outBuf, outPtr);\n+        return _textBuffer.contentsAsString();\n+    }\n+    \n     private final void _finishString2(char[] outBuf, int outPtr)\n         throws IOException\n     {\n--- a/src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java\n     @Override\n     public void writeString(String text) throws IOException\n     {\n-        _verifyValueWrite(\"write text value\");\n+        _verifyValueWrite(WRITE_STRING);\n         if (text == null) {\n             _writeNull();\n             return;\n     @Override\n     public void writeString(char[] text, int offset, int len) throws IOException\n     {\n-        _verifyValueWrite(\"write text value\");\n+        _verifyValueWrite(WRITE_STRING);\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n         }\n     @Override\n     public void writeString(SerializableString sstr) throws IOException\n     {\n-        _verifyValueWrite(\"write text value\");\n+        _verifyValueWrite(WRITE_STRING);\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n         }\n     public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write binary value\");\n+        _verifyValueWrite(WRITE_BINARY);\n         // Starting quotes\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n             InputStream data, int dataLength)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write binary value\");\n+        _verifyValueWrite(WRITE_BINARY);\n         // Starting quotes\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n     @Override\n     public void writeNumber(short s) throws IOException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (_cfgNumbersAsStrings) {\n             _writeQuotedShort(s);\n             return;\n     @Override\n     public void writeNumber(int i) throws IOException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (_cfgNumbersAsStrings) {\n             _writeQuotedInt(i);\n             return;\n     @Override\n     public void writeNumber(long l) throws IOException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (_cfgNumbersAsStrings) {\n             _writeQuotedLong(l);\n             return;\n     @Override\n     public void writeNumber(BigInteger value) throws IOException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (value == null) {\n             _writeNull();\n         } else if (_cfgNumbersAsStrings) {\n             return;\n         }\n         // What is the max length for doubles? 40 chars?\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         writeRaw(String.valueOf(d));\n     }\n \n             return;\n         }\n         // What is the max length for floats?\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         writeRaw(String.valueOf(f));\n     }\n \n     public void writeNumber(BigDecimal value) throws IOException\n     {\n         // Don't really know max length for big decimal, no point checking\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (value == null) {\n             _writeNull();\n         } else if (_cfgNumbersAsStrings) {\n     @Override\n     public void writeNumber(String encodedValue) throws IOException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (_cfgNumbersAsStrings) {\n             _writeQuotedRaw(encodedValue);            \n         } else {\n     @Override\n     public void writeBoolean(boolean state) throws IOException\n     {\n-        _verifyValueWrite(\"write boolean value\");\n+        _verifyValueWrite(WRITE_BOOLEAN);\n         if ((_outputTail + 5) >= _outputEnd) {\n             _flushBuffer();\n         }\n \n     @Override\n     public void writeNull() throws IOException {\n-        _verifyValueWrite(\"write null value\");\n+        _verifyValueWrite(WRITE_NULL);\n         _writeNull();\n     }\n \n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java\n+package com.fasterxml.jackson.core.sym;\n+\n+import java.util.Arrays;\n+import java.util.BitSet;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import com.fasterxml.jackson.core.JsonFactory;\n+import com.fasterxml.jackson.core.util.InternCache;\n+\n+/**\n+ * Replacement for <code>BytesToNameCanonicalizer</code> which aims at more localized\n+ * memory access due to flattening of name quad data.\n+ * Performance improvement modest for simple JSON document data binding (maybe 3%),\n+ * but should help more for larger symbol tables, or for binary formats like Smile.\n+ *\n+ * @since 2.6\n+ */\n+public final class ByteQuadsCanonicalizer\n+{\n+    /**\n+     * Initial size of the primary hash area. Each entry consumes 4 ints (16 bytes),\n+     * and secondary area is same as primary; so default size will use 2kB of memory_tertiaryStart\n+     * (plus 64x4 or 64x8 (256/512 bytes) for references to Strings, and Strings\n+     * themselves).\n+     */\n+    private static final int DEFAULT_T_SIZE = 64;\n+//    private static final int DEFAULT_T_SIZE = 256;\n+\n+    /**\n+     * Let's not expand symbol tables past some maximum size;\n+     * this should protected against OOMEs caused by large documents\n+     * with unique (~= random) names.\n+     * Size is in \n+     */\n+    private static final int MAX_T_SIZE = 0x10000; // 64k entries == 2M mem hash area\n+\n+    /**\n+     * No point in trying to construct tiny tables, just need to resize soon.\n+     */\n+    final static int MIN_HASH_SIZE = 16;\n+    \n+    /**\n+     * Let's only share reasonably sized symbol tables. Max size set to 3/4 of 8k;\n+     * this corresponds to 256k main hash index. This should allow for enough distinct\n+     * names for almost any case, while preventing ballooning for cases where names\n+     * are unique (or close thereof).\n+     */\n+    final static int MAX_ENTRIES_FOR_REUSE = 6000;\n+\n+    /*\n+    /**********************************************************\n+    /* Linkage, needed for merging symbol tables\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Reference to the root symbol table, for child tables, so\n+     * that they can merge table information back as necessary.\n+     */\n+    final protected ByteQuadsCanonicalizer _parent;\n+\n+    /**\n+     * Member that is only used by the root table instance: root\n+     * passes immutable state into child instances, and children\n+     * may return new state if they add entries to the table.\n+     * Child tables do NOT use the reference.\n+     */\n+    final protected AtomicReference<TableInfo> _tableInfo;\n+    \n+    /**\n+     * Seed value we use as the base to make hash codes non-static between\n+     * different runs, but still stable for lifetime of a single symbol table\n+     * instance.\n+     * This is done for security reasons, to avoid potential DoS attack via\n+     * hash collisions.\n+     */\n+    final private int _seed;\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Whether canonical symbol Strings are to be intern()ed before added\n+     * to the table or not.\n+     *<p>\n+     * NOTE: non-final to allow disabling intern()ing in case of excessive\n+     * collisions.\n+     */\n+    protected boolean _intern;\n+\n+    /**\n+     * Flag that indicates whether we should throw an exception if enough \n+     * hash collisions are detected (true); or just worked around (false).\n+     * \n+     * @since 2.4\n+     */\n+    protected final boolean _failOnDoS;\n+    \n+    /*\n+    /**********************************************************\n+    /* First, main hash area info\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Primary hash information area: consists of <code>2 * _hashSize</code>\n+     * entries of 16 bytes (4 ints), arranged in a cascading lookup\n+     * structure (details of which may be tweaked depending on expected rates\n+     * of collisions).\n+     */\n+    protected int[] _hashArea;\n+\n+    /**\n+     * Number of slots for primary entries within {@link #_hashArea}; which is\n+     * at most <code>1/8</code> of actual size of the underlying array (4-int slots,\n+     * primary covers only half of the area; plus, additional area for longer\n+     * symbols after hash area).\n+     */\n+    protected int _hashSize;\n+\n+    /**\n+     * Offset within {@link #_hashArea} where secondary entries start\n+     */\n+    protected int _secondaryStart;\n+\n+    /**\n+     * Offset within {@link #_hashArea} where tertiary entries start\n+     */\n+    protected int _tertiaryStart;\n+    \n+    /**\n+     * Constant that determines size of buckets for tertiary entries:\n+     * <code>1 << _tertiaryShift</code> is the size, and shift value\n+     * is also used for translating from primary offset into\n+     * tertiary bucket (shift right by <code>4 + _tertiaryShift</code>).\n+     *<p>\n+     * Default value is 2, for buckets of 4 slots; grows bigger with\n+     * bigger table sizes.\n+     */\n+    protected int _tertiaryShift;\n+\n+    /**\n+     * Total number of Strings in the symbol table; only used for child tables.\n+     */\n+    protected int _count;\n+\n+    /**\n+     * Array that contains <code>String</code> instances matching\n+     * entries in {@link #_hashArea}.\n+     * Contains nulls for unused entries. Note that this size is twice\n+     * that o\n+     */\n+    protected String[] _names;\n+\n+    /*\n+    /**********************************************************\n+    /* Then information on collisions etc\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Pointer to the offset within spill-over area where there is room\n+     * for more spilled over entries (if any).\n+     * Spill over area is within fixed-size portion of {@link #_hashArea}.\n+     */\n+    protected int _spilloverEnd;\n+\n+    /**\n+     * Offset within {@link #_hashArea} that follows main slots and contains\n+     * quads for longer names (13 bytes or longers), and points to the\n+     * first available int that may be used for appending quads of the next\n+     * long name.\n+     * Note that long name area follows immediately after the fixed-size\n+     * main hash area ({@link #_hashArea}).\n+     */\n+    protected int _longNameOffset;\n+\n+    /**\n+     * This flag is set if, after adding a new entry, it is deemed\n+     * that a rehash is warranted if any more entries are to be added.\n+     */\n+    private transient boolean _needRehash;\n+\n+    /*\n+    /**********************************************************\n+    /* Sharing, versioning\n+    /**********************************************************\n+     */\n+\n+    // // // Which of the buffers may be shared (and are copy-on-write)?\n+\n+    /**\n+     * Flag that indicates whether underlying data structures for\n+     * the main hash area are shared or not. If they are, then they\n+     * need to be handled in copy-on-write way, i.e. if they need\n+     * to be modified, a copy needs to be made first; at this point\n+     * it will not be shared any more, and can be modified.\n+     *<p>\n+     * This flag needs to be checked both when adding new main entries,\n+     * and when adding new collision list queues (i.e. creating a new\n+     * collision list head entry)\n+     */\n+    private boolean _hashShared;\n+\n+    /*\n+    /**********************************************************\n+    /* Bit of DoS detection goodness\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Lazily constructed structure that is used to keep track of\n+     * collision buckets that have overflowed once: this is used\n+     * to detect likely attempts at denial-of-service attacks that\n+     * uses hash collisions.\n+     * \n+     * @since 2.4\n+     */\n+    protected BitSet _overflows;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle: constructors\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Constructor used for creating per-<code>JsonFactory</code> \"root\"\n+     * symbol tables: ones used for merging and sharing common symbols\n+     * \n+     * @param sz Initial primary hash area size\n+     * @param intern Whether Strings contained should be {@link String#intern}ed\n+     * @param seed Random seed valued used to make it more difficult to cause\n+     *   collisions (used for collision-based DoS attacks).\n+     */\n+    private ByteQuadsCanonicalizer(int sz, boolean intern, int seed, boolean failOnDoS) {\n+        _parent = null;\n+        _seed = seed;\n+        _intern = intern;\n+        _failOnDoS = failOnDoS;\n+        // Sanity check: let's now allow hash sizes below certain minimum value\n+        if (sz < MIN_HASH_SIZE) {\n+            sz = MIN_HASH_SIZE;\n+        } else {\n+            // Also; size must be 2^N; otherwise hash algorithm won't\n+            // work... so let's just pad it up, if so\n+            if ((sz & (sz - 1)) != 0) { // only true if it's 2^N\n+                int curr = MIN_HASH_SIZE;\n+                while (curr < sz) {\n+                    curr += curr;\n+                }\n+                sz = curr;\n+            }\n+        }\n+        _tableInfo = new AtomicReference<TableInfo>(TableInfo.createInitial(sz));\n+    }\n+\n+    /**\n+     * Constructor used when creating a child instance\n+     */\n+    private ByteQuadsCanonicalizer(ByteQuadsCanonicalizer parent, boolean intern,\n+            int seed, boolean failOnDoS, TableInfo state)\n+    {\n+        _parent = parent;\n+        _seed = seed;\n+        _intern = intern;\n+        _failOnDoS = failOnDoS;\n+        _tableInfo = null; // not used by child tables\n+\n+        // Then copy shared state\n+        _count = state.count;\n+        _hashSize = state.size;\n+        _secondaryStart = _hashSize << 2; // right after primary area\n+        _tertiaryStart = _secondaryStart + (_secondaryStart >> 1); // right after secondary\n+        _tertiaryShift = state.tertiaryShift;\n+        \n+        _hashArea = state.mainHash;\n+        _names = state.names;\n+\n+        _spilloverEnd = state.spilloverEnd;\n+        _longNameOffset = state.longNameOffset;\n+        \n+        // and then set other state to reflect sharing status\n+        _needRehash = false;\n+        _hashShared = true;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle: factory methods, merging\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Factory method to call to create a symbol table instance with a\n+     * randomized seed value.\n+     */\n+    public static ByteQuadsCanonicalizer createRoot() {\n+        /* [Issue-21]: Need to use a variable seed, to thwart hash-collision\n+         * based attacks.\n+         */\n+        long now = System.currentTimeMillis();\n+        // ensure it's not 0; and might as well require to be odd so:\n+        int seed = (((int) now) + ((int) (now >>> 32))) | 1;\n+        return createRoot(seed);\n+    }\n+\n+    /**\n+     * Factory method that should only be called from unit tests, where seed\n+     * value should remain the same.\n+     */\n+    protected static ByteQuadsCanonicalizer createRoot(int seed) {\n+        return new ByteQuadsCanonicalizer(DEFAULT_T_SIZE, true, seed, true);\n+    }\n+    \n+    /**\n+     * Factory method used to create actual symbol table instance to\n+     * use for parsing.\n+     */\n+    public ByteQuadsCanonicalizer makeChild(int flags) {\n+        return new ByteQuadsCanonicalizer(this,\n+                JsonFactory.Feature.INTERN_FIELD_NAMES.enabledIn(flags),\n+                _seed,\n+                JsonFactory.Feature.FAIL_ON_SYMBOL_HASH_OVERFLOW.enabledIn(flags),\n+                _tableInfo.get());\n+    }\n+\n+    /**\n+     * Method called by the using code to indicate it is done\n+     * with this instance. This lets instance merge accumulated\n+     * changes into parent (if need be), safely and efficiently,\n+     * and without calling code having to know about parent\n+     * information\n+     */\n+    public void release()\n+    {\n+        // we will try to merge if child table has new entries\n+        if (_parent != null && maybeDirty()) {\n+            _parent.mergeChild(new TableInfo(this));\n+            /* Let's also mark this instance as dirty, so that just in\n+             * case release was too early, there's no corruption of possibly shared data.\n+             */\n+            _hashShared = true;\n+        }\n+    }\n+\n+    private void mergeChild(TableInfo childState)\n+    {\n+        final int childCount = childState.count;\n+        TableInfo currState = _tableInfo.get();\n+\n+        // Should usually grow; but occasionally could also shrink if (but only if)\n+        // collision list overflow ends up clearing some collision lists.\n+        if (childCount == currState.count) {\n+            return;\n+        }\n+\n+        // One caveat: let's try to avoid problems with degenerate cases of documents with\n+        // generated \"random\" names: for these, symbol tables would bloat indefinitely.\n+        // One way to do this is to just purge tables if they grow\n+        // too large, and that's what we'll do here.\n+        if (childCount > MAX_ENTRIES_FOR_REUSE) {\n+            // At any rate, need to clean up the tables\n+            childState = TableInfo.createInitial(DEFAULT_T_SIZE);\n+        }\n+        _tableInfo.compareAndSet(currState, childState);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* API, accessors\n+    /**********************************************************\n+     */\n+\n+    public int size()\n+    {\n+        if (_tableInfo != null) { // root table\n+            return _tableInfo.get().count;\n+        }\n+        // nope, child table\n+        return _count;\n+    }\n+\n+    /**\n+     * Returns number of primary slots table has currently\n+     */\n+    public int bucketCount() { return _hashSize; }\n+\n+    /**\n+     * Method called to check to quickly see if a child symbol table\n+     * may have gotten additional entries. Used for checking to see\n+     * if a child table should be merged into shared table.\n+     */\n+    public boolean maybeDirty() { return !_hashShared; }\n+\n+    public int hashSeed() { return _seed; }\n+    \n+    /**\n+     * Method mostly needed by unit tests; calculates number of\n+     * entries that are in the primary slot set. These are\n+     * \"perfect\" entries, accessible with a single lookup\n+     */\n+    public int primaryCount()\n+    {\n+        int count = 0;\n+        for (int offset = 3, end = _secondaryStart; offset < end; offset += 4) {\n+            if (_hashArea[offset] != 0) {\n+                ++count;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Method mostly needed by unit tests; calculates number of entries\n+     * in secondary buckets\n+     */\n+    public int secondaryCount() {\n+        int count = 0;\n+        int offset = _secondaryStart + 3;\n+        for (int end = _tertiaryStart; offset < end; offset += 4) {\n+            if (_hashArea[offset] != 0) {\n+                ++count;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Method mostly needed by unit tests; calculates number of entries\n+     * in tertiary buckets\n+     */\n+    public int tertiaryCount() {\n+        int count = 0;\n+        int offset = _tertiaryStart + 3; // to 1.5x, starting point of tertiary\n+        for (int end = offset + _hashSize; offset < end; offset += 4) {\n+            if (_hashArea[offset] != 0) {\n+                ++count;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Method mostly needed by unit tests; calculates number of entries\n+     * in shared spillover area\n+     */\n+    public int spilloverCount() {\n+        // difference between spillover end, start, divided by 4 (four ints per slot)\n+        return (_spilloverEnd - _spilloverStart()) >> 2;\n+    }\n+\n+    public int totalCount()\n+    {\n+        int count = 0;\n+        for (int offset = 3, end = (_hashSize << 3); offset < end; offset += 4) {\n+            if (_hashArea[offset] != 0) {\n+                ++count;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        int pri = primaryCount();\n+        int sec = secondaryCount();\n+        int tert = tertiaryCount();\n+        int spill = spilloverCount();\n+        int total = totalCount();\n+        return String.format(\"[%s: size=%d, hashSize=%d, %d/%d/%d/%d pri/sec/ter/spill (=%s), total:%d]\",\n+                getClass().getName(), _count, _hashSize,\n+                pri, sec, tert, spill, total, (pri+sec+tert+spill), total);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, accessing symbols\n+    /**********************************************************\n+     */\n+\n+    public String findName(int q1)\n+    {\n+        int offset = _calcOffset(calcHash(q1));\n+        // first: primary match?\n+        final int[] hashArea = _hashArea;\n+\n+        int len = hashArea[offset+3];\n+\n+        if (len == 1) {\n+            if (hashArea[offset] == q1) {\n+                return _names[offset >> 2];\n+            }\n+        } else if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n+            return null;\n+        }\n+        // secondary? single slot shared by N/2 primaries\n+        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n+\n+        len = hashArea[offset2+3];\n+\n+        if (len == 1) {\n+            if (hashArea[offset2] == q1) {\n+                return _names[offset2 >> 2];\n+            }\n+        } else if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n+            return null;\n+        }\n+\n+        // tertiary lookup & spillovers best to offline\n+        return _findSecondary(offset, q1);\n+    }\n+\n+    public String findName(int q1, int q2)\n+    {\n+        int offset = _calcOffset(calcHash(q1, q2));\n+\n+        final int[] hashArea = _hashArea;\n+\n+        int len = hashArea[offset+3];\n+\n+        if (len == 2) {\n+            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1])) {\n+                return _names[offset >> 2];\n+            }\n+        } else if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n+            return null;\n+        }\n+        // secondary?\n+        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n+\n+        len = hashArea[offset2+3];\n+\n+        if (len == 2) {\n+            if ((q1 == hashArea[offset2]) && (q2 == hashArea[offset2+1])) {\n+                return _names[offset2 >> 2];\n+            }\n+        } else if (len == 0) { // empty slot? Short-circuit if no more spillovers\n+            return null;\n+        }\n+        return _findSecondary(offset, q1, q2);\n+    }\n+\n+    public String findName(int q1, int q2, int q3)\n+    {\n+        int offset = _calcOffset(calcHash(q1, q2, q3));\n+        final int[] hashArea = _hashArea;\n+        int len = hashArea[offset+3];\n+\n+        if (len == 3) {\n+            if ((q1 == hashArea[offset]) && (hashArea[offset+1] == q2) && (hashArea[offset+2] == q3)) {\n+                return _names[offset >> 2];\n+            }\n+        } else if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n+            return null;\n+        }\n+        // secondary?\n+        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n+\n+        len = hashArea[offset2+3];\n+\n+        if (len == 3) {\n+            if ((q1 == hashArea[offset2]) && (hashArea[offset2+1] == q2) && (hashArea[offset2+2] == q3)) {\n+                return _names[offset2 >> 2];\n+            }\n+        } else if (len == 0) { // empty slot? Short-circuit if no more spillovers\n+            return null;\n+        }\n+        return _findSecondary(offset, q1, q2, q3);\n+    }\n+\n+    public String findName(int[] q, int qlen)\n+    {\n+        /* This version differs significantly, because longer names do not fit within cell.\n+         * Rather, they contain hash in main slot, and offset+length to extension area\n+         * that contains actual quads.\n+         */\n+        if (qlen < 4) { // another sanity check\n+            if (qlen == 3) {\n+                return findName(q[0], q[1], q[2]);\n+            }\n+            if (qlen == 2) {\n+                return findName(q[0], q[1]);\n+            }\n+            return findName(q[0]);\n+        }\n+        final int hash = calcHash(q, qlen);\n+        int offset = _calcOffset(hash);\n+\n+        final int[] hashArea = _hashArea;\n+\n+        final int len = hashArea[offset+3];\n+        \n+        if ((hash == hashArea[offset]) && (len == qlen)) {\n+            // probable but not guaranteed: verify\n+            if (_verifyLongName(q, qlen, hashArea[offset+1])) {\n+                return _names[offset >> 2];\n+            }\n+        }\n+        if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n+            return null;\n+        }\n+        // secondary?\n+        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n+\n+        final int len2 = hashArea[offset2+3];\n+        if ((hash == hashArea[offset2]) && (len2 == qlen)) {\n+            if (_verifyLongName(q, qlen, hashArea[offset2+1])) {\n+                return _names[offset2 >> 2];\n+            }\n+        }\n+        if (len == 0) { // empty slot? Short-circuit if no more spillovers\n+            return null;\n+        }\n+        return _findSecondary(offset, hash, q, qlen);\n+    }\n+    \n+    private final int _calcOffset(int hash)\n+    {\n+        // NOTE: simple for initial impl, but we may want to interleave it a bit\n+        // in near future\n+        // So: first, hash into primary hash index\n+        int ix = hash & (_hashSize-1);\n+        // keeping in mind we have 4 ints per entry\n+        return (ix << 2);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Access from spill-over areas\n+    /**********************************************************\n+     */\n+\n+    private String _findSecondary(int origOffset, int q1)\n+    {\n+        // tertiary area division is dynamic. First; its size is N/4 compared to\n+        // primary hash size; and offsets are for 4 int slots. So to get to logical\n+        // index would shift by 4. But! Tertiary area is further split into buckets,\n+        // determined by shift value. And finally, from bucket back into physical offsets\n+        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift);\n+        final int[] hashArea = _hashArea;\n+        final int bucketSize = (1 << _tertiaryShift);\n+        for (int end = offset + bucketSize; offset < end; offset += 4) {\n+            int len = hashArea[offset+3];\n+            if ((q1 == hashArea[offset]) && (1 == len)) {\n+                return _names[offset >> 2];\n+            }\n+            if (len == 0) {\n+                return null;\n+            }\n+        }\n+        // but if tertiary full, check out spill-over area as last resort\n+        // shared spillover starts at 7/8 of the main hash area\n+        // (which is sized at 2 * _hashSize), so:\n+        for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n+            if ((q1 == hashArea[offset]) && (1 == hashArea[offset+3])) {\n+                return _names[offset >> 2];\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private String _findSecondary(int origOffset, int q1, int q2)\n+    {\n+        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift);\n+        final int[] hashArea = _hashArea;\n+\n+        final int bucketSize = (1 << _tertiaryShift);\n+        for (int end = offset + bucketSize; offset < end; offset += 4) {\n+            int len = hashArea[offset+3];\n+            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (2 == len)) {\n+                return _names[offset >> 2];\n+            }\n+            if (len == 0) {\n+                return null;\n+            }\n+        }\n+        for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n+            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (2 == hashArea[offset+3])) {\n+                return _names[offset >> 2];\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private String _findSecondary(int origOffset, int q1, int q2, int q3)\n+    {\n+        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift);\n+        final int[] hashArea = _hashArea;\n+\n+        final int bucketSize = (1 << _tertiaryShift);\n+        for (int end = offset + bucketSize; offset < end; offset += 4) {\n+            int len = hashArea[offset+3];\n+            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (q3 == hashArea[offset+2]) && (3 == len)) {\n+                return _names[offset >> 2];\n+            }\n+            if (len == 0) {\n+                return null;\n+            }\n+        }\n+        for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n+            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (q3 == hashArea[offset+2])\n+                    && (3 == hashArea[offset+3])) {\n+                return _names[offset >> 2];\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private String _findSecondary(int origOffset, int hash, int[] q, int qlen)\n+    {\n+        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift);\n+        final int[] hashArea = _hashArea;\n+\n+        final int bucketSize = (1 << _tertiaryShift);\n+        for (int end = offset + bucketSize; offset < end; offset += 4) {\n+            int len = hashArea[offset+3];\n+            if ((hash == hashArea[offset]) && (qlen == len)) {\n+                return _names[offset >> 2];\n+            }\n+            if (len == 0) {\n+                return null;\n+            }\n+        }\n+        for (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\n+            if ((hash == hashArea[offset]) && (qlen == hashArea[offset+3])) {\n+                if (_verifyLongName(q, qlen, hashArea[offset+1])) {\n+                    return _names[offset >> 2];\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    private boolean _verifyLongName(int[] q, int qlen, int spillOffset)\n+    {\n+        final int[] hashArea = _hashArea;\n+        // spillOffset assumed to be physical index right into quad string\n+        int ix = 0;\n+\n+        switch (qlen) {\n+        default:\n+            return _verifyLongName2(q, qlen, spillOffset);\n+        case 8:\n+            if (q[ix++] != hashArea[spillOffset++]) return false;\n+        case 7:\n+            if (q[ix++] != hashArea[spillOffset++]) return false;\n+        case 6:\n+            if (q[ix++] != hashArea[spillOffset++]) return false;\n+        case 5:\n+            if (q[ix++] != hashArea[spillOffset++]) return false;\n+        case 4: // always at least 4\n+            if (q[ix++] != hashArea[spillOffset++]) return false;\n+            if (q[ix++] != hashArea[spillOffset++]) return false;\n+            if (q[ix++] != hashArea[spillOffset++]) return false;\n+            if (q[ix++] != hashArea[spillOffset++]) return false;\n+        }\n+        return true;\n+    }\n+\n+    private boolean _verifyLongName2(int[] q, int qlen, int spillOffset)\n+    {\n+        int ix = 0;\n+        do {\n+            if (q[ix++] != _hashArea[spillOffset++]) {\n+                return false;\n+            }\n+        } while (ix < qlen);\n+        return true;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* API, mutators\n+    /**********************************************************\n+     */\n+\n+    public String addName(String name, int q1) {\n+        _verifySharing();\n+        if (_intern) {\n+            name = InternCache.instance.intern(name);\n+        }\n+        int offset = _findOffsetForAdd(calcHash(q1));\n+        _hashArea[offset] = q1;\n+        _hashArea[offset+3] = 1;\n+        _names[offset >> 2] = name;\n+        ++_count;\n+        _verifyNeedForRehash();\n+        return name;\n+    }\n+\n+    public String addName(String name, int q1, int q2) {\n+        _verifySharing();\n+        if (_intern) {\n+            name = InternCache.instance.intern(name);\n+        }\n+        int hash = (q2 == 0) ? calcHash(q1) : calcHash(q1, q2);\n+        int offset = _findOffsetForAdd(hash);\n+        _hashArea[offset] = q1;\n+        _hashArea[offset+1] = q2;\n+        _hashArea[offset+3] = 2;\n+        _names[offset >> 2] = name;\n+        ++_count;\n+        _verifyNeedForRehash();\n+        return name;\n+    }\n+\n+    public String addName(String name, int q1, int q2, int q3) {\n+        _verifySharing();\n+        if (_intern) {\n+            name = InternCache.instance.intern(name);\n+        }\n+        int offset = _findOffsetForAdd(calcHash(q1, q2, q3));\n+        _hashArea[offset] = q1;\n+        _hashArea[offset+1] = q2;\n+        _hashArea[offset+2] = q3;\n+        _hashArea[offset+3] = 3;\n+        _names[offset >> 2] = name;\n+        ++_count;\n+        _verifyNeedForRehash();\n+        return name;\n+    }\n+\n+    public String addName(String name, int[] q, int qlen)\n+    {\n+        _verifySharing();\n+        if (_intern) {\n+            name = InternCache.instance.intern(name);\n+        }\n+        int offset;\n+        \n+        switch (qlen) {\n+        case 1:\n+        {\n+                offset = _findOffsetForAdd(calcHash(q[0]));\n+                _hashArea[offset] = q[0];\n+                _hashArea[offset+3] = 1;\n+            }\n+            break;\n+        case 2:\n+            {\n+                offset = _findOffsetForAdd(calcHash(q[0], q[1]));\n+                _hashArea[offset] = q[0];\n+                _hashArea[offset+1] = q[1];\n+                _hashArea[offset+3] = 2;\n+            }\n+            break;\n+        case 3:\n+            {\n+                offset = _findOffsetForAdd(calcHash(q[0], q[1], q[2]));\n+                _hashArea[offset] = q[0];\n+                _hashArea[offset+1] = q[1];\n+                _hashArea[offset+2] = q[2];\n+                _hashArea[offset+3] = 3;\n+            }\n+            break;\n+        default:\n+            final int hash = calcHash(q, qlen);\n+            offset = _findOffsetForAdd(hash);\n+\n+            _hashArea[offset] = hash;\n+            int longStart = _appendLongName(q, qlen);\n+            _hashArea[offset+1] = longStart;\n+            _hashArea[offset+3] = qlen;\n+        }\n+        // plus add the actual String\n+        _names[offset >> 2] = name;\n+\n+        // and finally; see if we really should rehash.\n+        ++_count;\n+        _verifyNeedForRehash();\n+        return name;\n+    }\n+    \n+    private void _verifyNeedForRehash() {\n+        // Yes if above 80%, or above 50% AND have ~1% spill-overs\n+        if (_count > (_hashSize >> 1)) { // over 50%\n+            int spillCount = (_spilloverEnd - _spilloverStart()) >> 2;\n+            \n+            if ((spillCount > (1 + _count >> 7))\n+                    || (_count > (_hashSize * 0.80))) {\n+                _needRehash = true;\n+            }\n+        }\n+    }\n+\n+    private void _verifySharing()\n+    {\n+        if (_hashShared) {\n+            _hashArea = Arrays.copyOf(_hashArea, _hashArea.length);\n+            _names = Arrays.copyOf(_names, _names.length);\n+            _hashShared = false;\n+        }\n+        if (_needRehash) {\n+            rehash();\n+        }\n+    }\n+    \n+    /**\n+     * Method called to find the location within hash table to add a new symbol in.\n+     */\n+    private int _findOffsetForAdd(int hash)\n+    {\n+        // first, check the primary:\n+        int offset = _calcOffset(hash);\n+        final int[] hashArea = _hashArea;\n+        if (hashArea[offset+3] == 0) {\n+            return offset;\n+        }\n+        // then secondary\n+        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n+        if (hashArea[offset2+3] == 0) {\n+            return offset2;\n+        }\n+        // if not, tertiary?\n+\n+        offset2 = _tertiaryStart + ((offset >> (_tertiaryShift + 2)) << _tertiaryShift);\n+        final int bucketSize = (1 << _tertiaryShift);\n+        for (int end = offset2 + bucketSize; offset2 < end; offset2 += 4) {\n+            if (hashArea[offset2+3] == 0) {\n+                return offset2;\n+            }\n+        }\n+\n+        // and if even tertiary full, append at the end of spill area\n+        offset = _spilloverEnd;\n+        _spilloverEnd += 4;\n+\n+        // one caveat: in the unlikely event if spill-over filling up,\n+        // check if that could be considered a DoS attack; handle appropriately\n+        // (NOTE: approximate for now; we could verify details if that becomes necessary)\n+        if (_spilloverEnd >= hashArea.length) {\n+            if (_failOnDoS) {\n+                _reportTooManyCollisions();\n+            }\n+            // and if we didn't fail, we'll simply force rehash for next add\n+            // (which, in turn, may double up or nuke contents, depending on size etc)\n+            _needRehash = true;\n+        }\n+        return offset;\n+    }\n+\n+    private int _appendLongName(int[] quads, int qlen)\n+    {\n+        int start = _longNameOffset;\n+        \n+        // note: at this point we must already be shared. But may not have enough space\n+        if ((start + qlen) > _hashArea.length) {\n+            // try to increment in reasonable chunks; at least space that we need\n+            int toAdd = (start + qlen) - _hashArea.length;\n+            // but at least 1/8 of regular hash area size or 16kB (whichever smaller)\n+            int minAdd = Math.min(4096, _hashSize);\n+\n+            int newSize = _hashArea.length + Math.max(toAdd, minAdd);\n+            _hashArea = Arrays.copyOf(_hashArea, newSize);\n+        }\n+        System.arraycopy(quads, 0, _hashArea, start, qlen);\n+        _longNameOffset += qlen;\n+        return start;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Hash calculation\n+    /**********************************************************\n+     */\n+\n+    /* Note on hash calculation: we try to make it more difficult to\n+     * generate collisions automatically; part of this is to avoid\n+     * simple \"multiply-add\" algorithm (like JDK String.hashCode()),\n+     * and add bit of shifting. And other part is to make this\n+     * non-linear, at least for shorter symbols.\n+     */\n+    \n+    // JDK uses 31; other fine choices are 33 and 65599, let's use 33\n+    // as it seems to give fewest collisions for us\n+    // (see [http://www.cse.yorku.ca/~oz/hash.html] for details)\n+    private final static int MULT = 33;\n+    private final static int MULT2 = 65599;\n+    private final static int MULT3 = 31;\n+    \n+    public int calcHash(int q1)\n+    {\n+        int hash = q1 ^ _seed;\n+        /* 29-Mar-2015, tatu: Earlier used 15 + 9 right shifts, which worked ok\n+         *    except for one specific problem case: numbers. So needed to make sure\n+         *    that all 4 least-significant bits participate in hash. Couple of ways\n+         *    to work it out, but this is the simplest, fast and seems to do ok.\n+         */\n+        hash += (hash >>> 16); // to xor hi- and low- 16-bits\n+        hash ^= (hash >>> 12); // as well as lowest 2 bytes\n+        return hash;\n+    }\n+\n+    public int calcHash(int q1, int q2)\n+    {\n+        // For two quads, let's change algorithm a bit, to spice\n+        // things up (can do bit more processing anyway)\n+        int hash = q1;\n+\n+        hash += (hash >>> 15); // try mixing first and second byte pairs first\n+        hash ^= (hash >>> 9); // as well as lowest 2 bytes\n+        hash += (q2 * MULT); // then add second quad\n+        hash ^= _seed;\n+        hash += (hash >>> 16); // and shuffle some more\n+        hash ^= (hash >>> 4);\n+        hash += (hash << 3);\n+        \n+        return hash;\n+    }\n+\n+    public int calcHash(int q1, int q2, int q3)\n+    { // use same algorithm as multi-byte, tested to work well\n+        int hash = q1 ^ _seed;\n+        hash += (hash >>> 9);\n+        hash *= MULT3;\n+        hash += q2;\n+        hash *= MULT;\n+        hash += (hash >>> 15);\n+        hash ^= q3;\n+        // 26-Mar-2015, tatu: As per two-quad case, a short shift seems to help more here\n+        hash += (hash >>> 4);\n+\n+        hash += (hash >>> 15);\n+        hash ^= (hash << 9);\n+\n+        return hash;\n+    }\n+\n+    public int calcHash(int[] q, int qlen)\n+    {\n+        if (qlen < 4) {\n+            throw new IllegalArgumentException();\n+        }\n+        /* And then change handling again for \"multi-quad\" case; mostly\n+         * to make calculation of collisions less fun. For example,\n+         * add seed bit later in the game, and switch plus/xor around,\n+         * use different shift lengths.\n+         */\n+        int hash = q[0] ^ _seed;\n+        hash += (hash >>> 9);\n+        hash += q[1];\n+        hash += (hash >>> 15);\n+        hash *= MULT;\n+        hash ^= q[2];\n+        hash += (hash >>> 4);\n+\n+        for (int i = 3; i < qlen; ++i) {\n+            int next = q[i];\n+            next = next ^ (next >> 21);\n+            hash += next;\n+        }\n+        hash *= MULT2;\n+        \n+        // and finally shuffle some more once done\n+        hash += (hash >>> 19);\n+        hash ^= (hash << 5);\n+        return hash;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Rehashing\n+    /**********************************************************\n+     */\n+\n+    private void rehash()\n+    {\n+        _needRehash = false;\n+        // Note: since we'll make copies, no need to unshare, can just mark as such:\n+        _hashShared = false;\n+\n+        // And then we can first deal with the main hash area. Since we are expanding\n+        // linearly (double up), we know there'll be no collisions during this phase.\n+        final int[] oldHashArea = _hashArea;\n+        final String[] oldNames = _names;\n+        final int oldSize = _hashSize;\n+        final int oldCount = _count;\n+        final int newSize = oldSize + oldSize;\n+        final int oldEnd = _spilloverEnd;\n+\n+        /* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n+         *    large documents with unique (or mostly so) names\n+         */\n+        if (newSize > MAX_T_SIZE) {\n+            nukeSymbols(true);\n+            return;\n+        }\n+        // double up main hash area, but do not expand long-name area:\n+        _hashArea = new int[oldHashArea.length + (oldSize<<3)];\n+        _hashSize = newSize;\n+        _secondaryStart = (newSize << 2); // 4 ints per entry\n+        _tertiaryStart = _secondaryStart + (_secondaryStart >> 1); // right after secondary\n+        _tertiaryShift = _calcTertiaryShift(newSize);\n+        \n+        // and simply double up name array\n+        _names = new String[oldNames.length << 1];\n+        nukeSymbols(false);\n+\n+        // Plus we can scan only through the primary hash area, looking for non-empty\n+        // slots, without worrying about ordering. This should never reduce priority\n+        // of existing entries: primaries remain primaries; however, due to increased\n+        // space, secondaries may become primaries etc\n+\n+        int copyCount = 0;\n+        int[] q = new int[16];\n+        for (int offset = 0, end = oldEnd; offset < end; offset += 4) {\n+            int len = oldHashArea[offset+3];\n+            if (len == 0) { // empty slot, skip\n+                continue;\n+            }\n+            ++copyCount;\n+            String name = oldNames[offset>>2];\n+            switch (len) {\n+            case 1:\n+                q[0] = oldHashArea[offset];\n+                addName(name, q, 1);\n+                break;\n+            case 2:\n+                q[0] = oldHashArea[offset];\n+                q[1] = oldHashArea[offset+1];\n+                addName(name, q, 2);\n+                break;\n+            case 3:\n+                q[0] = oldHashArea[offset];\n+                q[1] = oldHashArea[offset+1];\n+                q[2] = oldHashArea[offset+2];\n+                addName(name, q, 3);\n+                break;\n+            default:\n+                if (len > q.length) {\n+                    q = new int[len];\n+                }\n+                // #0 is hash, #1 offset\n+                int qoff = oldHashArea[offset+1];\n+                System.arraycopy(oldHashArea, qoff, q, 0, len);\n+                addName(name, q, len);\n+                break;\n+            }\n+        }\n+\n+        // Sanity checks: since corruption difficult to detect, assert explicitly\n+        // with production code\n+        if (copyCount != oldCount) {\n+            throw new IllegalStateException(\"Failed rehash(): old count=\"+oldCount+\", copyCount=\"+copyCount);\n+        }\n+    }\n+\n+    /**\n+     * Helper method called to empty all shared symbols, but to leave\n+     * arrays allocated\n+     */\n+    private void nukeSymbols(boolean fill) {\n+        _count = 0;\n+        // reset spill-over to empty (starting at 7/8 of hash area)\n+        _spilloverEnd = _spilloverStart();\n+        // and long name area to empty, starting immediately after hash area\n+        _longNameOffset = _hashSize << 3;\n+        if (fill) {\n+            Arrays.fill(_hashArea, 0);\n+            Arrays.fill(_names, null);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Helper method that calculates start of the spillover area\n+     */\n+    private final int _spilloverStart() {\n+        // we'll need slot at 1.75x of hashSize, but with 4-ints per slot.\n+        // So basically multiply by 7\n+        int offset = _hashSize;\n+        return (offset << 3) - offset;\n+    }\n+\n+    protected void _reportTooManyCollisions()\n+    {\n+        // First: do not fuzz about small symbol tables; may get balanced by doubling up\n+        if (_hashSize <= 1024) { // would have spill-over area of 128 entries\n+            return;\n+        }\n+        throw new IllegalStateException(\"Spill-over slots in symbol table with \"+_count\n+                +\" entries, hash area of \"+_hashSize+\" slots is now full (all \"\n+                +(_hashSize >> 3)+\" slots -- suspect a DoS attack based on hash collisions.\"\n+                +\" You can disable the check via `JsonFactory.Feature.FAIL_ON_SYMBOL_HASH_OVERFLOW`\");\n+    }\n+\n+    static int _calcTertiaryShift(int primarySlots)\n+    {\n+        // first: we only get 1/4 of slots of primary, to divide\n+        int tertSlots = (primarySlots) >> 2;\n+        \n+        // default is for buckets of 4 slots (each 4 ints, i.e. 1 << 4)\n+        if (tertSlots < 64) {\n+            return 4;\n+        }\n+        if (tertSlots <= 256) { // buckets of 8 slots (up to 256 == 32 x 8)\n+            return 5;\n+        }\n+        if (tertSlots <= 1024) { // buckets of 16 slots (up to 1024 == 64 x 16)\n+            return 6;\n+        }\n+        // and biggest buckets have 32 slots\n+        return 7;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Immutable value class used for sharing information as efficiently\n+     * as possible, by only require synchronization of reference manipulation\n+     * but not access to contents.\n+     * \n+     * @since 2.1\n+     */\n+    private final static class TableInfo\n+    {\n+        public final int size;\n+        public final int count;\n+        public final int tertiaryShift;\n+        public final int[] mainHash;\n+        public final String[] names;\n+        public final int spilloverEnd;\n+        public final int longNameOffset;\n+\n+        public TableInfo(int size, int count, int tertiaryShift, \n+                int[] mainHash, String[] names, int spilloverEnd, int longNameOffset)\n+        {\n+            this.size = size;\n+            this.count = count;\n+            this.tertiaryShift = tertiaryShift;\n+            this.mainHash = mainHash;\n+            this.names = names;\n+            this.spilloverEnd = spilloverEnd;\n+            this.longNameOffset = longNameOffset;\n+        }\n+\n+        public TableInfo(ByteQuadsCanonicalizer src)\n+        {\n+            size = src._hashSize;\n+            count = src._count;\n+            tertiaryShift = src._tertiaryShift;\n+            mainHash = src._hashArea;\n+            names = src._names;\n+            spilloverEnd = src._spilloverEnd;\n+            longNameOffset = src._longNameOffset;\n+        }\n+\n+        public static TableInfo createInitial(int sz) {\n+            int hashAreaSize = sz << 3;\n+            int tertShift = _calcTertiaryShift(sz);\n+\n+            return new TableInfo(sz, // hashSize\n+                    0, // count\n+                    tertShift,\n+                    new int[hashAreaSize], // mainHash, 2x slots, 4 ints per slot\n+                    new String[sz << 1], // 2x slots\n+                    hashAreaSize - sz, // at 7/8 of the total area\n+                    hashAreaSize // longNameOffset, immediately after main hashes\n+            );\n+        }\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n  * symbol tables, to be able to make use of usually shared vocabulary\n  * of subsequent parsing runs.\n  *\n- * @author Tatu Saloranta\n+ * @deprecated Since 2.6, replaced by {@link ByteQuadsCanonicalizer}\n  */\n+@Deprecated\n public final class BytesToNameCanonicalizer\n {\n     private static final int DEFAULT_T_SIZE = 64;\n      * this corresponds to 64k main hash index. This should allow for enough distinct\n      * names for almost any case.\n      */\n-    private final static int MAX_ENTRIES_FOR_REUSE = 6000;\n+    final static int MAX_ENTRIES_FOR_REUSE = 6000;\n \n     /**\n      * Also: to thwart attacks based on hash collisions (which may or may not\n                 0 // longestCollisionList\n         );\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Life-cycle: factory methods, merging\n     /**********************************************************\n      */\n-    \n+\n     /**\n      * Factory method to call to create a symbol table instance with a\n      * randomized seed value.\n     protected static BytesToNameCanonicalizer createRoot(int seed) {\n         return new BytesToNameCanonicalizer(DEFAULT_T_SIZE, true, seed, true);\n     }\n-    \n+\n     /**\n      * Factory method used to create actual symbol table instance to\n      * use for parsing.\n         return null;\n     }\n \n+    public Name findName(int q1, int q2, int q3)\n+    {\n+        int hash = calcHash(q1, q2, q3);\n+        int ix = (hash & _hashMask);\n+        int val = _hash[ix];\n+        \n+        if ((((val >> 8) ^ hash) << 8) == 0) { // match\n+            // Ok, but do we have an actual match?\n+            Name name = _mainNames[ix];\n+            if (name == null) { // main slot empty; can't find\n+                return null;\n+            }\n+            if (name.equals(q1, q2, q3)) {\n+                return name;\n+            }\n+        } else if (val == 0) { // empty slot? no match\n+            return null;\n+        }\n+        // Maybe a spill-over?\n+        val &= 0xFF;\n+        if (val > 0) { // 0 means 'empty'\n+            val -= 1; // to convert from 1-based to 0...\n+            Bucket bucket = _collList[val];\n+            if (bucket != null) {\n+                return bucket.find(hash, q1, q2, q3);\n+            }\n+        }\n+        // Nope, no match whatsoever\n+        return null;\n+    }\n+    \n     /**\n      * Finds and returns name matching the specified symbol, if such\n      * name already exists in the table; or if not, creates name object,\n      */\n     public Name findName(int[] q, int qlen)\n     {\n-        if (qlen < 3) { // another sanity check\n+        if (qlen < 4) { // another sanity check\n+            if (qlen == 3) {\n+                return findName(q[0], q[1], q[2]);\n+            }\n             return findName(q[0], (qlen < 2) ? 0 : q[1]);\n         }\n         int hash = calcHash(q, qlen);\n             name = InternCache.instance.intern(name);\n         }\n         int hash;\n-        if (qlen < 3) {\n-            hash = (qlen == 1) ? calcHash(q[0]) : calcHash(q[0], q[1]);\n+        if (qlen < 4) {\n+            if (qlen == 1) {\n+                hash = calcHash(q[0]);\n+            } else if (qlen == 2) {\n+                hash = calcHash(q[0], q[1]);\n+            } else {\n+                hash = calcHash(q[0], q[1], q[2]);\n+            }\n         } else {\n             hash = calcHash(q, qlen);\n         }\n         return hash;\n     }\n \n+    public int calcHash(int q1, int q2, int q3)\n+    {\n+        // use same algorithm as multi-byte, tested to work well\n+        int hash = q1 ^ _seed;\n+        hash += (hash >>> 9);\n+        hash *= MULT;\n+        hash += q2;\n+        hash *= MULT2;\n+        hash += (hash >>> 15);\n+        hash ^= q3;\n+        hash += (hash >>> 17);\n+\n+        // and finally shuffle some more once done\n+        hash += (hash >>> 15); // to get high-order bits to mix more\n+        hash ^= (hash << 9); // as well as lowest 2 bytes\n+\n+        return hash;\n+    }\n+    \n     public int calcHash(int[] q, int qlen)\n     {\n-        // Note: may be called for qlen < 3; but has at least one int\n-        if (qlen < 3) {\n+        if (qlen < 4) {\n             throw new IllegalArgumentException();\n         }\n \n             case 2:\n                 return new Name2(name, hash, quads[0], quads[1]);\n             case 3:\n+            default:\n                 return new Name3(name, hash, quads[0], quads[1], quads[2]);\n-            default:\n             }\n         }\n         return NameN.construct(name, hash, quads, qlen);\n     /* Other helper methods\n     /**********************************************************\n      */\n-    \n+\n     /**\n      * @since 2.1\n      */\n         throw new IllegalStateException(\"Longest collision chain in symbol table (of size \"+_count\n                 +\") now exceeds maximum, \"+maxLen+\" -- suspect a DoS attack based on hash collisions\");\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Helper classes\n             return null;\n         }\n \n+        public Name find(int h, int q1, int q2, int q3) {\n+            if (hash == h) {\n+                if (name.equals(q1, q2, q3)) {\n+                    return name;\n+                }\n+            }\n+            for (Bucket curr = next; curr != null; curr = curr.next) {\n+                if (curr.hash == h) {\n+                    Name currName = curr.name;\n+                    if (currName.equals(q1, q2, q3)) {\n+                        return currName;\n+                    }\n+                }\n+            }\n+            return null;\n+        }\n+        \n         public Name find(int h, int[] quads, int qlen) {\n             if (hash == h) {\n                 if (name.equals(quads, qlen)) {\n--- a/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java\n      * and truncates to be used as the index.\n      */\n     public int _hashToIndex(int rawHash) {\n-        rawHash += (rawHash >>> 15); // this seems to help quite a bit, at least for our tests\n+        // doing these seems to help a bit\n+        rawHash += (rawHash >>> 15);\n+        rawHash ^= (rawHash << 7);\n+        rawHash += (rawHash >>> 3);\n         return (rawHash & _indexMask);\n     }\n     \n--- a/src/main/java/com/fasterxml/jackson/core/sym/Name.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/Name.java\n     /**********************************************************\n      */\n \n-    public abstract boolean equals(int quad1);\n+    public abstract boolean equals(int q1);\n \n-    public abstract boolean equals(int quad1, int quad2);\n+    public abstract boolean equals(int q1, int q2);\n+\n+    /**\n+     * @since 2.6\n+     */\n+    public abstract boolean equals(int q1, int q2, int q3);\n \n     public abstract boolean equals(int[] quads, int qlen);\n \n--- a/src/main/java/com/fasterxml/jackson/core/sym/Name1.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/Name1.java\n \n     @Override public boolean equals(int quad) { return (quad == q); }\n     @Override public boolean equals(int quad1, int quad2) { return (quad1 == q) && (quad2 == 0); }\n+    @Override public boolean equals(int q1, int q2, int q3) { return false; }\n+\n     @Override public boolean equals(int[] quads, int qlen) { return (qlen == 1 && quads[0] == q); }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/sym/Name2.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/Name2.java\n     @Override\n     public boolean equals(int quad1, int quad2) { return (quad1 == q1) && (quad2 == q2); }\n \n+    @Override public boolean equals(int quad1, int quad2, int q3) { return false; }\n+    \n     @Override\n     public boolean equals(int[] quads, int qlen) { return (qlen == 2 && quads[0] == q1 && quads[1] == q2); }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/sym/Name3.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/Name3.java\n     public boolean equals(int quad1, int quad2) { return false; }\n \n     @Override\n+    public boolean equals(int quad1, int quad2, int quad3) {\n+        return (q1 == quad1) && (q2 == quad2) && (q3 == quad3);\n+    }\n+\n+    @Override\n     public boolean equals(int[] quads, int qlen) {\n         return (qlen == 3) && (quads[0] == q1) && (quads[1] == q2) && (quads[2] == q3);\n     }\n--- a/src/main/java/com/fasterxml/jackson/core/sym/NameN.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/NameN.java\n     @Override\n     public boolean equals(int quad1, int quad2) { return false; }\n \n+    // Implies quad length == 3, never matches\n+    @Override\n+    public boolean equals(int quad1, int quad2, int quad3) { return false; }\n+\n     @Override\n     public boolean equals(int[] quads, int len) {\n         if (len != qlen) { return false; }\n--- a/src/main/java/com/fasterxml/jackson/core/util/BufferRecycler.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/BufferRecycler.java\n     public final char[] allocCharBuffer(int ix) {\n         return allocCharBuffer(ix, 0);\n     }\n-    \n+\n     public char[] allocCharBuffer(int ix, int minSize) {\n         final int DEF_SIZE = charBufferLength(ix);\n         if (minSize < DEF_SIZE) {\n--- a/src/main/java/com/fasterxml/jackson/core/util/DefaultIndenter.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/DefaultIndenter.java\n     private final int charsPerLevel;\n     private final String eol;\n \n-    /** Indent with two spaces and the system's default line feed */\n+    /**\n+     * Indent with two spaces and the system's default line feed\n+     */\n     public DefaultIndenter() {\n         this(\"  \", SYS_LF);\n     }\n     \n-    /** Create an indenter which uses the <code>indent</code> string to indent one level\n+    /**\n+     * Create an indenter which uses the <code>indent</code> string to indent one level\n      *  and the <code>eol</code> string to separate lines.\n      */\n     public DefaultIndenter(String indent, String eol)\n--- a/src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java\n      * @since 2.6.0\n      */\n     public DefaultPrettyPrinter withRootSeparator(String rootSeparator) {\n-        return withRootSeparator(new SerializedString(rootSeparator));\n+        return withRootSeparator((rootSeparator == null) ? null : new SerializedString(rootSeparator));\n     }\n     \n     public void indentArraysWith(Indenter i) {\n      * (white-space) decoration.\n      */\n     @Override\n-    public void writeArrayValueSeparator(JsonGenerator jg)\n-        throws IOException, JsonGenerationException\n-    {\n-        jg.writeRaw(',');\n-        _arrayIndenter.writeIndentation(jg, _nesting);\n-    }\n-\n-    @Override\n-    public void writeEndArray(JsonGenerator jg, int nrOfValues)\n-        throws IOException, JsonGenerationException\n+    public void writeArrayValueSeparator(JsonGenerator gen) throws IOException\n+    {\n+        gen.writeRaw(',');\n+        _arrayIndenter.writeIndentation(gen, _nesting);\n+    }\n+\n+    @Override\n+    public void writeEndArray(JsonGenerator gen, int nrOfValues) throws IOException\n     {\n         if (!_arrayIndenter.isInline()) {\n             --_nesting;\n         }\n         if (nrOfValues > 0) {\n-            _arrayIndenter.writeIndentation(jg, _nesting);\n+            _arrayIndenter.writeIndentation(gen, _nesting);\n         } else {\n-            jg.writeRaw(' ');\n-        }\n-        jg.writeRaw(']');\n+            gen.writeRaw(' ');\n+        }\n+        gen.writeRaw(']');\n     }\n \n     /*\n     }\n \n     /**\n-     * This is a very simple indenter that only every adds a\n+     * This is a very simple indenter that only adds a\n      * single space for indentation. It is used as the default\n      * indenter for array values.\n      */\n         public static final FixedSpaceIndenter instance = new FixedSpaceIndenter();\n \n         @Override\n-        public void writeIndentation(JsonGenerator jg, int level)\n-            throws IOException, JsonGenerationException\n+        public void writeIndentation(JsonGenerator jg, int level) throws IOException\n         {\n             jg.writeRaw(' ');\n         }\n--- a/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n     /* Construction, initialization\n     /**********************************************************\n      */\n-    \n+\n     public JsonGeneratorDelegate(JsonGenerator d) {\n         this(d, true);\n     }\n--- a/src/main/java/com/fasterxml/jackson/core/util/JsonParserDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonParserDelegate.java\n     @Override public int getCurrentTokenId() { return delegate.getCurrentTokenId(); }\n     @Override public boolean hasCurrentToken() { return delegate.hasCurrentToken(); }\n     @Override public boolean hasTokenId(int id) { return delegate.hasTokenId(id); }\n-    \n-    @Override public String getCurrentName() throws IOException, JsonParseException { return delegate.getCurrentName(); }\n+    @Override public boolean hasToken(JsonToken t) { return delegate.hasToken(t); }\n+\n+    @Override public String getCurrentName() throws IOException { return delegate.getCurrentName(); }\n     @Override public JsonLocation getCurrentLocation() { return delegate.getCurrentLocation(); }\n     @Override public JsonStreamContext getParsingContext() { return delegate.getParsingContext(); }\n     @Override public boolean isExpectedStartArrayToken() { return delegate.isExpectedStartArrayToken(); }\n     /**********************************************************\n      */\n \n-    @Override public String getText() throws IOException, JsonParseException { return delegate.getText();  }\n+    @Override public String getText() throws IOException { return delegate.getText();  }\n     @Override public boolean hasTextCharacters() { return delegate.hasTextCharacters(); }\n-    @Override public char[] getTextCharacters() throws IOException, JsonParseException { return delegate.getTextCharacters(); }\n-    @Override public int getTextLength() throws IOException, JsonParseException { return delegate.getTextLength(); }\n-    @Override public int getTextOffset() throws IOException, JsonParseException { return delegate.getTextOffset(); }\n+    @Override public char[] getTextCharacters() throws IOException { return delegate.getTextCharacters(); }\n+    @Override public int getTextLength() throws IOException { return delegate.getTextLength(); }\n+    @Override public int getTextOffset() throws IOException { return delegate.getTextOffset(); }\n \n     /*\n     /**********************************************************\n      */\n     \n     @Override\n-    public BigInteger getBigIntegerValue() throws IOException,JsonParseException { return delegate.getBigIntegerValue(); }\n-\n-    @Override\n-    public boolean getBooleanValue() throws IOException, JsonParseException { return delegate.getBooleanValue(); }\n-    \n-    @Override\n-    public byte getByteValue() throws IOException, JsonParseException { return delegate.getByteValue(); }\n-\n-    @Override\n-    public short getShortValue() throws IOException, JsonParseException { return delegate.getShortValue(); }\n-\n-    @Override\n-    public BigDecimal getDecimalValue() throws IOException, JsonParseException { return delegate.getDecimalValue(); }\n-\n-    @Override\n-    public double getDoubleValue() throws IOException, JsonParseException { return delegate.getDoubleValue(); }\n-\n-    @Override\n-    public float getFloatValue() throws IOException, JsonParseException { return delegate.getFloatValue(); }\n-\n-    @Override\n-    public int getIntValue() throws IOException, JsonParseException { return delegate.getIntValue(); }\n-\n-    @Override\n-    public long getLongValue() throws IOException, JsonParseException { return delegate.getLongValue(); }\n-\n-    @Override\n-    public NumberType getNumberType() throws IOException, JsonParseException { return delegate.getNumberType(); }\n-\n-    @Override\n-    public Number getNumberValue() throws IOException, JsonParseException { return delegate.getNumberValue(); }\n+    public BigInteger getBigIntegerValue() throws IOException { return delegate.getBigIntegerValue(); }\n+\n+    @Override\n+    public boolean getBooleanValue() throws IOException { return delegate.getBooleanValue(); }\n+    \n+    @Override\n+    public byte getByteValue() throws IOException { return delegate.getByteValue(); }\n+\n+    @Override\n+    public short getShortValue() throws IOException { return delegate.getShortValue(); }\n+\n+    @Override\n+    public BigDecimal getDecimalValue() throws IOException { return delegate.getDecimalValue(); }\n+\n+    @Override\n+    public double getDoubleValue() throws IOException { return delegate.getDoubleValue(); }\n+\n+    @Override\n+    public float getFloatValue() throws IOException { return delegate.getFloatValue(); }\n+\n+    @Override\n+    public int getIntValue() throws IOException { return delegate.getIntValue(); }\n+\n+    @Override\n+    public long getLongValue() throws IOException { return delegate.getLongValue(); }\n+\n+    @Override\n+    public NumberType getNumberType() throws IOException { return delegate.getNumberType(); }\n+\n+    @Override\n+    public Number getNumberValue() throws IOException { return delegate.getNumberValue(); }\n \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n     \n-    @Override public int getValueAsInt() throws IOException, JsonParseException { return delegate.getValueAsInt(); }\n-    @Override public int getValueAsInt(int defaultValue) throws IOException, JsonParseException { return delegate.getValueAsInt(defaultValue); }\n-    @Override public long getValueAsLong() throws IOException, JsonParseException { return delegate.getValueAsLong(); }\n-    @Override public long getValueAsLong(long defaultValue) throws IOException, JsonParseException { return delegate.getValueAsLong(defaultValue); }\n-    @Override public double getValueAsDouble() throws IOException, JsonParseException { return delegate.getValueAsDouble(); }\n-    @Override public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException { return delegate.getValueAsDouble(defaultValue); }\n-    @Override public boolean getValueAsBoolean() throws IOException, JsonParseException { return delegate.getValueAsBoolean(); }\n-    @Override public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException { return delegate.getValueAsBoolean(defaultValue); }\n-    @Override public String getValueAsString() throws IOException, JsonParseException { return delegate.getValueAsString(); }\n-    @Override public String getValueAsString(String defaultValue) throws IOException, JsonParseException { return delegate.getValueAsString(defaultValue); }\n+    @Override public int getValueAsInt() throws IOException { return delegate.getValueAsInt(); }\n+    @Override public int getValueAsInt(int defaultValue) throws IOException { return delegate.getValueAsInt(defaultValue); }\n+    @Override public long getValueAsLong() throws IOException { return delegate.getValueAsLong(); }\n+    @Override public long getValueAsLong(long defaultValue) throws IOException { return delegate.getValueAsLong(defaultValue); }\n+    @Override public double getValueAsDouble() throws IOException { return delegate.getValueAsDouble(); }\n+    @Override public double getValueAsDouble(double defaultValue) throws IOException { return delegate.getValueAsDouble(defaultValue); }\n+    @Override public boolean getValueAsBoolean() throws IOException { return delegate.getValueAsBoolean(); }\n+    @Override public boolean getValueAsBoolean(boolean defaultValue) throws IOException { return delegate.getValueAsBoolean(defaultValue); }\n+    @Override public String getValueAsString() throws IOException { return delegate.getValueAsString(); }\n+    @Override public String getValueAsString(String defaultValue) throws IOException { return delegate.getValueAsString(defaultValue); }\n     \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n \n-    @Override public Object getEmbeddedObject() throws IOException, JsonParseException { return delegate.getEmbeddedObject(); }\n-    @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException { return delegate.getBinaryValue(b64variant); }\n-    @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException { return delegate.readBinaryValue(b64variant, out); }\n+    @Override public Object getEmbeddedObject() throws IOException { return delegate.getEmbeddedObject(); }\n+    @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { return delegate.getBinaryValue(b64variant); }\n+    @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { return delegate.readBinaryValue(b64variant, out); }\n     @Override public JsonLocation getTokenLocation() { return delegate.getTokenLocation(); }\n-    @Override public JsonToken nextToken() throws IOException, JsonParseException { return delegate.nextToken(); }\n-    @Override public JsonToken nextValue() throws IOException, JsonParseException { return delegate.nextValue(); }\n-    \n-    @Override\n-    public JsonParser skipChildren() throws IOException, JsonParseException {\n+    @Override public JsonToken nextToken() throws IOException { return delegate.nextToken(); }\n+    @Override public JsonToken nextValue() throws IOException { return delegate.nextValue(); }\n+    \n+    @Override\n+    public JsonParser skipChildren() throws IOException {\n         delegate.skipChildren();\n         // NOTE: must NOT delegate this method to delegate, needs to be self-reference for chaining\n         return this;\n \n     @Override public boolean canReadObjectId() { return delegate.canReadObjectId(); }\n     @Override public boolean canReadTypeId() { return delegate.canReadTypeId(); }\n-    @Override public Object getObjectId() throws IOException, JsonGenerationException { return delegate.getObjectId(); }\n-    @Override public Object getTypeId() throws IOException, JsonGenerationException { return delegate.getTypeId(); }\n+    @Override public Object getObjectId() throws IOException { return delegate.getObjectId(); }\n+    @Override public Object getTypeId() throws IOException { return delegate.getTypeId(); }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n         if (_resultString != null) return false;\n         return true;\n     }\n-    \n+\n+    /**\n+     * Accessor that may be used to get the contents of this buffer in a single\n+     * <code>char</code> array regardless of whether they were collected in a segmented\n+     * fashion or not.\n+     */\n     public char[] getTextBuffer()\n     {\n         // Are we just using shared input buffer?\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments)  return _currentSegment;\n+        if (!_hasSegments) {\n+            return (_currentSegment == null) ? NO_CHARS : _currentSegment;\n+        }\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }\n--- a/src/test/java/com/fasterxml/jackson/core/BaseTest.java\n+++ b/src/test/java/com/fasterxml/jackson/core/BaseTest.java\n \n     /*\n     /**********************************************************\n+    /* Helper read/write methods\n+    /**********************************************************\n+     */\n+    \n+    protected void writeJsonDoc(JsonFactory f, String doc, Writer w) throws IOException\n+    {\n+        writeJsonDoc(f, doc, f.createGenerator(w));\n+    }\n+\n+    protected void writeJsonDoc(JsonFactory f, String doc, JsonGenerator g) throws IOException\n+    {\n+        JsonParser p = f.createParser(aposToQuotes(doc));\n+        \n+        while (p.nextToken() != null) {\n+            g.copyCurrentStructure(p);\n+        }\n+        p.close();\n+        g.close();\n+    }\n+\n+    /*\n+    /**********************************************************\n     /* Additional assertion methods\n     /**********************************************************\n      */\n      * available methods, and ensures results are consistent, before\n      * returning them\n      */\n-    protected String getAndVerifyText(JsonParser jp)\n-        throws IOException, JsonParseException\n+    protected String getAndVerifyText(JsonParser jp) throws IOException\n     {\n         // Ok, let's verify other accessors\n         int actLen = jp.getTextLength();\n         return result;\n     }\n \n-    public String quote(String str) {\n+    protected String quote(String str) {\n         return '\"'+str+'\"';\n+    }\n+\n+    protected String aposToQuotes(String json) {\n+        return json.replace(\"'\", \"\\\"\");\n     }\n \n     protected void fieldNameFor(StringBuilder sb, int index)\n         return sb.toString();\n     }\n \n+    protected int[] calcQuads(byte[] wordBytes) {\n+        int blen = wordBytes.length;\n+        int[] result = new int[(blen + 3) / 4];\n+        for (int i = 0; i < blen; ++i) {\n+            int x = wordBytes[i] & 0xFF;\n+\n+            if (++i < blen) {\n+                x = (x << 8) | (wordBytes[i] & 0xFF);\n+                if (++i < blen) {\n+                    x = (x << 8) | (wordBytes[i] & 0xFF);\n+                    if (++i < blen) {\n+                        x = (x << 8) | (wordBytes[i] & 0xFF);\n+                    }\n+                }\n+            }\n+            result[i >> 2] = x;\n+        }\n+        return result;\n+    }\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/filter/BasicGeneratorFilteringTest.java\n+package com.fasterxml.jackson.core.filter;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+/**\n+ * Low-level tests for explicit, hand-written tests for generator-side\n+ * filtering.\n+ */\n+@SuppressWarnings(\"resource\")\n+public class BasicGeneratorFilteringTest extends com.fasterxml.jackson.core.BaseTest\n+{\n+    static class NameMatchFilter extends TokenFilter\n+    {\n+        private final Set<String> _names;\n+        \n+        public NameMatchFilter(String... names) {\n+            _names = new HashSet<String>(Arrays.asList(names));\n+        }\n+\n+        @Override\n+        public TokenFilter includeElement(int index) {\n+            return this;\n+        }\n+\n+        @Override\n+        public TokenFilter includeProperty(String name) {\n+            if (_names.contains(name)) {\n+                return TokenFilter.INCLUDE_ALL;\n+            }\n+            return this;\n+        }\n+\n+        @Override\n+        protected boolean _includeScalar() { return false; }\n+    }\n+\n+    static class IndexMatchFilter extends TokenFilter\n+    {\n+        private final BitSet _indices;\n+        \n+        public IndexMatchFilter(int... ixs) {\n+            _indices = new BitSet();\n+            for (int ix : ixs) {\n+                _indices.set(ix);\n+            }\n+        }\n+\n+        @Override\n+        public TokenFilter includeProperty(String name) {\n+            return this;\n+        }\n+        \n+        @Override\n+        public TokenFilter includeElement(int index) {\n+            if (_indices.get(index)) {\n+                return TokenFilter.INCLUDE_ALL;\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        protected boolean _includeScalar() { return false; }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    private final JsonFactory JSON_F = new JsonFactory();\n+\n+    public void testNonFiltering() throws Exception\n+    {\n+        // First, verify non-filtering\n+        StringWriter w = new StringWriter();\n+        JsonGenerator gen = JSON_F.createGenerator(w);\n+        final String JSON = \"{'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}\";\n+        writeJsonDoc(JSON_F, JSON, gen);\n+        assertEquals(aposToQuotes(\n+                \"{'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}\"),\n+                w.toString());\n+    }\n+\n+    public void testSingleMatchFilteringWithoutPath() throws Exception\n+    {\n+        StringWriter w = new StringWriter();\n+        JsonGenerator gen = new FilteringGeneratorDelegate(JSON_F.createGenerator(w),\n+                new NameMatchFilter(\"value\"),\n+                false, // includePath\n+                false // multipleMatches\n+                );\n+        final String JSON = \"{'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}\";\n+        writeJsonDoc(JSON_F, JSON, gen);\n+\n+        // 21-Apr-2015, tatu: note that there were plans to actually\n+        //     allow \"immediate parent inclusion\" for matches on property\n+        //    names. This behavior was NOT included in release however, so:\n+//        assertEquals(aposToQuotes(\"{'value':3}\"), w.toString());\n+\n+        assertEquals(aposToQuotes(\"3\"), w.toString());\n+    }\n+\n+    public void testSingleMatchFilteringWithPath() throws Exception\n+    {\n+        StringWriter w = new StringWriter();\n+        JsonGenerator gen = new FilteringGeneratorDelegate(JSON_F.createGenerator(w),\n+                new NameMatchFilter(\"value\"),\n+                true, // includePath\n+                false // multipleMatches\n+                );\n+        final String JSON = \"{'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}\";\n+        writeJsonDoc(JSON_F, JSON, gen);\n+        assertEquals(aposToQuotes(\"{'ob':{'value':3}}\"), w.toString());\n+    }\n+\n+    public void testMultipleMatchFilteringWithPath1() throws Exception\n+    {\n+        StringWriter w = new StringWriter();\n+        JsonGenerator gen = new FilteringGeneratorDelegate(JSON_F.createGenerator(w),\n+                new NameMatchFilter(\"value0\", \"value2\"),\n+                true, /* includePath */ true /* multipleMatches */ );\n+        final String JSON = \"{'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}\";\n+        writeJsonDoc(JSON_F, JSON, gen);\n+        assertEquals(aposToQuotes(\"{'ob':{'value0':2,'value2':4}}\"), w.toString());\n+    }\n+\n+    public void testMultipleMatchFilteringWithPath2() throws Exception\n+    {\n+        StringWriter w = new StringWriter();\n+        \n+        JsonGenerator gen = new FilteringGeneratorDelegate(JSON_F.createGenerator(w),\n+                new NameMatchFilter(\"array\", \"b\", \"value\"),\n+                true, true);\n+        final String JSON = \"{'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}\";\n+        writeJsonDoc(JSON_F, JSON, gen);\n+        assertEquals(aposToQuotes(\"{'array':[1,2],'ob':{'value':3},'b':true}\"), w.toString());\n+    }\n+\n+    public void testMultipleMatchFilteringWithPath3() throws Exception\n+    {\n+        StringWriter w = new StringWriter();\n+        \n+        JsonGenerator gen = new FilteringGeneratorDelegate(JSON_F.createGenerator(w),\n+                new NameMatchFilter(\"value\"),\n+                true, true);\n+        final String JSON = \"{'root':{'a0':true,'a':{'value':3},'b':{'value':4}},'b0':false}\";\n+        writeJsonDoc(JSON_F, JSON, gen);\n+        assertEquals(aposToQuotes(\"{'root':{'a':{'value':3},'b':{'value':4}}}\"), w.toString());\n+    }\n+    \n+    public void testIndexMatchWithPath1() throws Exception\n+    {\n+        StringWriter w = new StringWriter();\n+        JsonGenerator gen = new FilteringGeneratorDelegate(JSON_F.createGenerator(w),\n+                new IndexMatchFilter(1),\n+                true, true);\n+        final String JSON = \"{'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}\";\n+        writeJsonDoc(JSON_F, JSON, gen);\n+        assertEquals(aposToQuotes(\"{'array':[2]}\"), w.toString());\n+\n+        w = new StringWriter();\n+        gen = new FilteringGeneratorDelegate(JSON_F.createGenerator(w),\n+                new IndexMatchFilter(0),\n+                true, true);\n+        writeJsonDoc(JSON_F, JSON, gen);\n+        assertEquals(aposToQuotes(\"{'array':[1]}\"), w.toString());\n+    }\n+\n+    public void testIndexMatchWithPath2() throws Exception\n+    {\n+        StringWriter w = new StringWriter();\n+        JsonGenerator gen = new FilteringGeneratorDelegate(JSON_F.createGenerator(w),\n+                new IndexMatchFilter(0,1),\n+                true, true);\n+        final String JSON = \"{'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}\";\n+        writeJsonDoc(JSON_F, JSON, gen);\n+        assertEquals(aposToQuotes(\"{'array':[1,2]}\"), w.toString());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/filter/JsonPointerGeneratorFilteringTest.java\n+package com.fasterxml.jackson.core.filter;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+@SuppressWarnings(\"resource\")\n+public class JsonPointerGeneratorFilteringTest extends com.fasterxml.jackson.core.BaseTest\n+{\n+    private final JsonFactory JSON_F = new JsonFactory();\n+\n+    final String SIMPLE_INPUT = aposToQuotes(\"{'a':1,'b':[1,2,3],'c':{'d':{'a':true}},'d':null}\");\n+\n+    public void testSimplePropertyWithPath() throws Exception\n+    {\n+        _assert(SIMPLE_INPUT, \"/c\", true, \"{'c':{'d':{'a':true}}}\");\n+        _assert(SIMPLE_INPUT, \"/c/d\", true, \"{'c':{'d':{'a':true}}}\");\n+        _assert(SIMPLE_INPUT, \"/c/d/a\", true, \"{'c':{'d':{'a':true}}}\");\n+\n+        _assert(SIMPLE_INPUT, \"/c/d/a\", true, \"{'c':{'d':{'a':true}}}\");\n+        \n+        _assert(SIMPLE_INPUT, \"/a\", true, \"{'a':1}\");\n+        _assert(SIMPLE_INPUT, \"/d\", true, \"{'d':null}\");\n+\n+        // and then non-match\n+        _assert(SIMPLE_INPUT, \"/x\", true, \"\");\n+    }\n+    \n+    public void testSimplePropertyWithoutPath() throws Exception\n+    {\n+        _assert(SIMPLE_INPUT, \"/c\", false, \"{'d':{'a':true}}\");\n+        _assert(SIMPLE_INPUT, \"/c/d\", false, \"{'a':true}\");\n+        _assert(SIMPLE_INPUT, \"/c/d/a\", false, \"true\");\n+        \n+        _assert(SIMPLE_INPUT, \"/a\", false, \"1\");\n+        _assert(SIMPLE_INPUT, \"/d\", false, \"null\");\n+\n+        // and then non-match\n+        _assert(SIMPLE_INPUT, \"/x\", false, \"\");\n+    }\n+\n+    public void testArrayElementWithPath() throws Exception\n+    {\n+        _assert(SIMPLE_INPUT, \"/b\", true, \"{'b':[1,2,3]}\");\n+        _assert(SIMPLE_INPUT, \"/b/1\", true, \"{'b':[2]}\");\n+        _assert(SIMPLE_INPUT, \"/b/2\", true, \"{'b':[3]}\");\n+        \n+        // and then non-match\n+        _assert(SIMPLE_INPUT, \"/b/8\", true, \"\");\n+    }\n+\n+    public void testArrayNestedWithPath() throws Exception\n+    {\n+        _assert(\"{'a':[true,{'b':3,'d':2},false]}\", \"/a/1/b\", true, \"{'a':[{'b':3}]}\");\n+        _assert(\"[true,[1]]\", \"/0\", true, \"[true]\");\n+        _assert(\"[true,[1]]\", \"/1\", true, \"[[1]]\");\n+        _assert(\"[true,[1,2,[true],3],0]\", \"/0\", true, \"[true]\");\n+        _assert(\"[true,[1,2,[true],3],0]\", \"/1\", true, \"[[1,2,[true],3]]\");\n+\n+        _assert(\"[true,[1,2,[true],3],0]\", \"/1/2\", true, \"[[[true]]]\");\n+        _assert(\"[true,[1,2,[true],3],0]\", \"/1/2/0\", true, \"[[[true]]]\");\n+        _assert(\"[true,[1,2,[true],3],0]\", \"/1/3/0\", true, \"\");\n+    }\n+\n+    public void testArrayNestedWithoutPath() throws Exception\n+    {\n+        _assert(\"{'a':[true,{'b':3,'d':2},false]}\", \"/a/1/b\", false, \"3\");\n+        _assert(\"[true,[1,2,[true],3],0]\", \"/0\", false, \"true\");\n+        _assert(\"[true,[1,2,[true],3],0]\", \"/1\", false,\n+                \"[1,2,[true],3]\");\n+\n+        _assert(\"[true,[1,2,[true],3],0]\", \"/1/2\", false, \"[true]\");\n+        _assert(\"[true,[1,2,[true],3],0]\", \"/1/2/0\", false, \"true\");\n+        _assert(\"[true,[1,2,[true],3],0]\", \"/1/3/0\", false, \"\");\n+    }\n+    \n+//    final String SIMPLE_INPUT = aposToQuotes(\"{'a':1,'b':[1,2,3],'c':{'d':{'a':true}},'d':null}\");\n+    \n+    public void testArrayElementWithoutPath() throws Exception\n+    {\n+        _assert(SIMPLE_INPUT, \"/b\", false, \"[1,2,3]\");\n+        _assert(SIMPLE_INPUT, \"/b/1\", false, \"2\");\n+        _assert(SIMPLE_INPUT, \"/b/2\", false, \"3\");\n+\n+        _assert(SIMPLE_INPUT, \"/b/8\", false, \"\");\n+\n+        // and then non-match\n+        _assert(SIMPLE_INPUT, \"/x\", false, \"\");\n+    }\n+\n+    private void _assert(String input, String pathExpr, boolean includeParent, String exp)\n+        throws Exception\n+    {\n+        StringWriter w = new StringWriter();\n+\n+        JsonGenerator g0 = JSON_F.createGenerator(w);\n+        FilteringGeneratorDelegate g = new FilteringGeneratorDelegate(g0,\n+                new JsonPointerBasedFilter(pathExpr),\n+                includeParent, false);\n+\n+        try {\n+            writeJsonDoc(JSON_F, input, g);\n+        } catch (Exception e) {\n+            g0.flush();\n+            System.err.println(\"With input '\"+input+\"', output at point of failure: <\"+w+\">\");\n+            throw e;\n+        }\n+\n+        assertEquals(aposToQuotes(exp), w.toString());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/filter/JsonPointerParserFilteringTest.java\n+package com.fasterxml.jackson.core.filter;\n+\n+import java.io.StringWriter;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+public class JsonPointerParserFilteringTest extends com.fasterxml.jackson.core.BaseTest\n+{\n+    private final JsonFactory JSON_F = new JsonFactory();\n+\n+    final String SIMPLEST_INPUT = aposToQuotes(\"{'a':1,'b':2,'c':3}\");\n+\n+    final String SIMPLE_INPUT = aposToQuotes(\"{'a':1,'b':[1,2,3],'c':{'d':{'a':true}},'d':null}\");\n+\n+    public void testSimplestWithPath() throws Exception\n+    {\n+        _assert(SIMPLEST_INPUT, \"/a\", true, \"{'a':1}\");\n+        _assert(SIMPLEST_INPUT, \"/b\", true, \"{'b':2}\");\n+        _assert(SIMPLEST_INPUT, \"/c\", true, \"{'c':3}\");\n+        _assert(SIMPLEST_INPUT, \"/c/0\", true, \"\");\n+        _assert(SIMPLEST_INPUT, \"/d\", true, \"\");\n+    }\n+\n+    public void testSimplestNoPath() throws Exception\n+    {\n+        _assert(SIMPLEST_INPUT, \"/a\", false, \"1\");\n+        _assert(SIMPLEST_INPUT, \"/b\", false, \"2\");\n+        _assert(SIMPLEST_INPUT, \"/b/2\", false, \"\");\n+        _assert(SIMPLEST_INPUT, \"/c\", false, \"3\");\n+        _assert(SIMPLEST_INPUT, \"/d\", false, \"\");\n+    }\n+\n+    public void testSimpleWithPath() throws Exception\n+    {\n+        _assert(SIMPLE_INPUT, \"/c\", true, \"{'c':{'d':{'a':true}}}\");\n+        _assert(SIMPLE_INPUT, \"/c/d\", true, \"{'c':{'d':{'a':true}}}\");\n+        _assert(SIMPLE_INPUT, \"/a\", true, \"{'a':1}\");\n+        _assert(SIMPLE_INPUT, \"/b\", true, \"{'b':[1,2,3]}\");\n+        _assert(SIMPLE_INPUT, \"/b/0\", true, \"{'b':[1]}\");\n+        _assert(SIMPLE_INPUT, \"/b/1\", true, \"{'b':[2]}\");\n+        _assert(SIMPLE_INPUT, \"/b/2\", true, \"{'b':[3]}\");\n+        _assert(SIMPLE_INPUT, \"/b/3\", true, \"\");\n+    }\n+\n+    public void testSimpleNoPath() throws Exception\n+    {\n+        _assert(SIMPLE_INPUT, \"/c\", false, \"{'d':{'a':true}}\");\n+\n+        _assert(SIMPLE_INPUT, \"/c/d\", false, \"{'a':true}\");\n+        _assert(SIMPLE_INPUT, \"/a\", false, \"1\");\n+        _assert(SIMPLE_INPUT, \"/b\", false, \"[1,2,3]\");\n+        _assert(SIMPLE_INPUT, \"/b/0\", false, \"1\");\n+        _assert(SIMPLE_INPUT, \"/b/1\", false, \"2\");\n+        _assert(SIMPLE_INPUT, \"/b/2\", false, \"3\");\n+        _assert(SIMPLE_INPUT, \"/b/3\", false, \"\");\n+    }\n+\n+    @SuppressWarnings(\"resource\")\n+    void _assert(String input, String pathExpr, boolean includeParent, String exp)\n+        throws Exception\n+    {\n+        JsonParser p0 = JSON_F.createParser(input);\n+        FilteringParserDelegate p = new FilteringParserDelegate(p0,\n+                new JsonPointerBasedFilter(pathExpr),\n+                includeParent, false);\n+        StringWriter w = new StringWriter();\n+        JsonGenerator g = JSON_F.createGenerator(w);\n+\n+        try {\n+            while (p.nextToken() != null) {\n+                g.copyCurrentEvent(p);\n+            }\n+            p.close();\n+            g.close();\n+        } catch (Exception e) {\n+            g.flush();\n+            System.err.println(\"With input '\"+input+\"', output at point of failure: <\"+w+\">\");\n+            throw e;\n+        }\n+\n+        assertEquals(aposToQuotes(exp), w.toString());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/GeneratorFailTest.java\n+package com.fasterxml.jackson.core.json;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.OutputStreamWriter;\n+\n+import com.fasterxml.jackson.core.JsonEncoding;\n+import com.fasterxml.jackson.core.JsonFactory;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+\n+public class GeneratorFailTest\n+    extends com.fasterxml.jackson.core.BaseTest\n+{\n+    private final JsonFactory F = new JsonFactory();\n+\n+    // [core#167]: no error for writing field name twice\n+    public void testDupFieldNameWrites() throws Exception\n+    {\n+        _testDupFieldNameWrites(F, false);\n+        _testDupFieldNameWrites(F, true);        \n+    }\n+\n+    // [core#177]\n+    // Also: should not try writing JSON String if field name expected\n+    // (in future maybe take one as alias... but not yet)\n+    public void testFailOnWritingStringNotFieldNameBytes() throws Exception {\n+        _testFailOnWritingStringNotFieldName(F, false);\n+    }\n+\n+    // [core#177]\n+    public void testFailOnWritingStringNotFieldNameChars() throws Exception {\n+        _testFailOnWritingStringNotFieldName(F, true);        \n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+\n+    private void _testDupFieldNameWrites(JsonFactory f, boolean useReader) throws Exception\n+    {\n+        JsonGenerator gen;\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        if (useReader) {\n+            gen = f.createGenerator(new OutputStreamWriter(bout, \"UTF-8\"));\n+        } else {\n+            gen = f.createGenerator(bout, JsonEncoding.UTF8);\n+        }\n+        gen.writeStartObject();\n+        gen.writeFieldName(\"a\");\n+        \n+        try {\n+            gen.writeFieldName(\"b\");\n+            gen.flush();\n+            String json = bout.toString(\"UTF-8\");\n+            fail(\"Should not have let two consecutive field name writes succeed: output = \"+json);\n+        } catch (JsonProcessingException e) {\n+            verifyException(e, \"can not write a field name, expecting a value\");\n+        }\n+        gen.close();\n+    }\n+\n+    private void _testFailOnWritingStringNotFieldName(JsonFactory f, boolean useReader) throws Exception\n+    {\n+        JsonGenerator gen;\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        if (useReader) {\n+            gen = f.createGenerator(new OutputStreamWriter(bout, \"UTF-8\"));\n+        } else {\n+            gen = f.createGenerator(bout, JsonEncoding.UTF8);\n+        }\n+        gen.writeStartObject();\n+        \n+        try {\n+            gen.writeString(\"a\");\n+            gen.flush();\n+            String json = bout.toString(\"UTF-8\");\n+            fail(\"Should not have let \"+gen.getClass().getName()+\".writeString() be used in place of 'writeFieldName()': output = \"+json);\n+        } catch (JsonProcessingException e) {\n+            verifyException(e, \"can not write a String\");\n+        }\n+        gen.close();\n+    }\n+\n+\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/JsonFactoryTest.java\n+package com.fasterxml.jackson.core.json;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+public class JsonFactoryTest\n+    extends com.fasterxml.jackson.core.BaseTest\n+{\n+    public void testGeneratorFeatures() throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+        assertNull(f.getCodec());\n+\n+        f.configure(JsonGenerator.Feature.QUOTE_FIELD_NAMES, true);\n+        assertTrue(f.isEnabled(JsonGenerator.Feature.QUOTE_FIELD_NAMES));\n+        f.configure(JsonGenerator.Feature.QUOTE_FIELD_NAMES, false);\n+        assertFalse(f.isEnabled(JsonGenerator.Feature.QUOTE_FIELD_NAMES));\n+    }\n+\n+    public void testFactoryFeatures() throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+\n+        f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, true);\n+        assertTrue(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES));\n+        f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, false);\n+        assertFalse(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES));\n+\n+        // by default, should be enabled\n+        assertTrue(f.isEnabled(JsonFactory.Feature.USE_THREAD_LOCAL_FOR_BUFFER_RECYCLING));\n+        f.configure(JsonFactory.Feature.USE_THREAD_LOCAL_FOR_BUFFER_RECYCLING, false);\n+        assertFalse(f.isEnabled(JsonFactory.Feature.USE_THREAD_LOCAL_FOR_BUFFER_RECYCLING));\n+    }\n+\n+    // for [core#189]: verify that it's ok to disable recycling\n+    // Basically simply exercises basic functionality, to ensure\n+    // there are no obvious problems; needed since testing never\n+    // disables this handling otherwise\n+    public void testDisablingBufferRecycling() throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+\n+        f.disable(JsonFactory.Feature.USE_THREAD_LOCAL_FOR_BUFFER_RECYCLING);\n+\n+        // First, generation\n+        for (int i = 0; i < 3; ++i) {\n+            StringWriter w = new StringWriter();\n+            JsonGenerator gen = f.createGenerator(w);\n+            gen.writeStartObject();\n+            gen.writeEndObject();\n+            gen.close();\n+            assertEquals(\"{}\", w.toString());\n+        }\n+    \n+        for (int i = 0; i < 3; ++i) {\n+            ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n+            JsonGenerator gen = f.createGenerator(bytes);\n+            gen.writeStartArray();\n+            gen.writeEndArray();\n+            gen.close();\n+            assertEquals(\"[]\", bytes.toString(\"UTF-8\"));\n+        }\n+\n+        // Then parsing:\n+        for (int i = 0; i < 3; ++i) {\n+            JsonParser p = f.createParser(\"{}\");\n+            assertToken(JsonToken.START_OBJECT, p.nextToken());\n+            assertToken(JsonToken.END_OBJECT, p.nextToken());\n+            assertNull(p.nextToken());\n+            p.close();\n+\n+            p = f.createParser(\"{}\".getBytes(\"UTF-8\"));\n+            assertToken(JsonToken.START_OBJECT, p.nextToken());\n+            assertToken(JsonToken.END_OBJECT, p.nextToken());\n+            assertNull(p.nextToken());\n+            p.close();\n+        }\n+    }\n+    \n+    public void testJsonWithFiles() throws Exception\n+    {\n+        File file = File.createTempFile(\"jackson-test\", null);\n+        file.deleteOnExit();\n+        \n+        JsonFactory f = new JsonFactory();\n+\n+        // First: create file via generator.. and use an odd encoding\n+        JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE);\n+        jg.writeStartObject();\n+        jg.writeRaw(\"   \");\n+        jg.writeEndObject();\n+        jg.close();\n+\n+        // Ok: first read file directly\n+        JsonParser jp = f.createParser(file);\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+        assertNull(jp.nextToken());\n+        jp.close();\n+\n+        // Then via URL:\n+        jp = f.createParser(file.toURI().toURL());\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+        assertNull(jp.nextToken());\n+        jp.close();\n+\n+        // ok, delete once we are done\n+        file.delete();\n+    }\n+\n+    // #72\n+    public void testCopy() throws Exception\n+    {\n+        JsonFactory jf = new JsonFactory();\n+        // first, verify defaults\n+        assertTrue(jf.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES));\n+        assertFalse(jf.isEnabled(JsonParser.Feature.ALLOW_COMMENTS));\n+        assertFalse(jf.isEnabled(JsonGenerator.Feature.ESCAPE_NON_ASCII));\n+        jf.disable(JsonFactory.Feature.INTERN_FIELD_NAMES);\n+        jf.enable(JsonParser.Feature.ALLOW_COMMENTS);\n+        jf.enable(JsonGenerator.Feature.ESCAPE_NON_ASCII);\n+        // then change, verify that changes \"stick\"\n+        assertFalse(jf.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES));\n+        assertTrue(jf.isEnabled(JsonParser.Feature.ALLOW_COMMENTS));\n+        assertTrue(jf.isEnabled(JsonGenerator.Feature.ESCAPE_NON_ASCII));\n+\n+        JsonFactory jf2 = jf.copy();\n+        assertFalse(jf2.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES));\n+        assertTrue(jf.isEnabled(JsonParser.Feature.ALLOW_COMMENTS));\n+        assertTrue(jf.isEnabled(JsonGenerator.Feature.ESCAPE_NON_ASCII));\n+    }\n+}\n+\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestJsonGenerator.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestJsonGenerator.java\n         gen.close();\n     }\n \n-    // [core#167]: no error for writing field name twice\n-    public void testDupFieldNameWrites() throws Exception\n-    {\n-        JsonFactory f = new JsonFactory();\n-        _testDupFieldNameWrites(f, false);\n-        _testDupFieldNameWrites(f, true);        \n-    }\n-\n-    private void _testDupFieldNameWrites(JsonFactory f, boolean useReader) throws Exception\n-    {\n-        JsonGenerator gen;\n-        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n-        if (useReader) {\n-            gen = f.createGenerator(new OutputStreamWriter(bout, \"UTF-8\"));\n-        } else {\n-            gen = f.createGenerator(bout, JsonEncoding.UTF8);\n-        }\n-        gen.writeStartObject();\n-        gen.writeFieldName(\"a\");\n-        \n-        try {\n-            gen.writeFieldName(\"b\");\n-            gen.flush();\n-            String json = bout.toString(\"UTF-8\");\n-            fail(\"Should not have let two consequtive field name writes succeed: output = \"+json);\n-        } catch (JsonProcessingException e) {\n-            verifyException(e, \"can not write a field name, expecting a value\");\n-        }\n-        gen.close();\n-    }\n-\n     /*\n     /**********************************************************\n     /* Internal methods\n     /**********************************************************\n      */\n-    \n-    private void doTestIntWrite(boolean pad)\n-        throws Exception\n+\n+    private void doTestIntWrite(boolean pad) throws Exception\n     {\n         int[] VALUES = new int[] {\n             0, 1, -9, 32, -32, 57, 189, 2017, -9999, 13240, 123456,\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestJsonParser.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestJsonParser.java\n package com.fasterxml.jackson.core.json;\n \n import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.util.JsonParserDelegate;\n \n import java.io.*;\n import java.net.URL;\n         }\n         jp.close();\n     }\n+\n+    public void testGetValueAsTextBytes() throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+        _testGetValueAsText(f, true, false);\n+        _testGetValueAsText(f, true, true);\n+    }\n+\n+    public void testGetValueAsTextChars() throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+        _testGetValueAsText(f, false, false);\n+        _testGetValueAsText(f, false, true);\n+    }\n     \n+    @SuppressWarnings(\"resource\")\n+    private void _testGetValueAsText(JsonFactory f,\n+            boolean useBytes, boolean delegate) throws Exception\n+    {\n+        String JSON = \"{\\\"a\\\":1,\\\"b\\\":true,\\\"c\\\":null,\\\"d\\\":\\\"foo\\\"}\";\n+        JsonParser p = useBytes ? f.createParser(JSON.getBytes(\"UTF-8\"))\n+                : f.createParser(JSON);\n+\n+        if (delegate) {\n+            p = new JsonParserDelegate(p);\n+        }\n+        \n+        assertToken(JsonToken.START_OBJECT, p.nextToken());\n+        assertNull(p.getValueAsString());\n+\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n+        assertEquals(\"a\", p.getText());\n+        assertEquals(\"a\", p.getValueAsString());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n+        assertEquals(\"1\", p.getValueAsString());\n+\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n+        assertEquals(\"b\", p.getValueAsString());\n+        assertToken(JsonToken.VALUE_TRUE, p.nextToken());\n+        assertEquals(\"true\", p.getValueAsString());\n+\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n+        assertEquals(\"c\", p.getValueAsString());\n+        assertToken(JsonToken.VALUE_NULL, p.nextToken());\n+        // null token returned as Java null, as per javadoc\n+        assertNull(p.getValueAsString());\n+\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n+        assertEquals(\"d\", p.getValueAsString());\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertEquals(\"foo\", p.getValueAsString());\n+\n+        assertToken(JsonToken.END_OBJECT, p.nextToken());\n+        assertNull(p.getValueAsString());\n+\n+        assertNull(p.nextToken());\n+        p.close();\n+    }\n+\n     /*\n     /**********************************************************\n     /* Helper methods\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestParserSymbols.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestParserSymbols.java\n {\n     // For [Issue#148]\n     public void testSymbolsWithNullBytes() throws Exception {\n-        _testSymbolsWithNull(true);\n+        JsonFactory f = new JsonFactory();\n+        _testSymbolsWithNull(f, true);\n+        // and repeat with same factory, just for fun, and to ensure symbol table is fine\n+        _testSymbolsWithNull(f, true);\n     }\n \n     // For [Issue#148]\n     public void testSymbolsWithNullChars() throws Exception {\n-        _testSymbolsWithNull(false);\n+        JsonFactory f = new JsonFactory();\n+        _testSymbolsWithNull(f, false);\n+        _testSymbolsWithNull(f, false);\n     }\n-    \n-    private void _testSymbolsWithNull(boolean useBytes) throws Exception\n+\n+    private void _testSymbolsWithNull(JsonFactory f, boolean useBytes) throws Exception\n     {\n-        final JsonFactory f = new JsonFactory();\n         final String INPUT = \"{\\\"\\\\u0000abc\\\" : 1, \\\"abc\\\":2}\";\n         JsonParser parser = useBytes ? f.createParser(INPUT.getBytes(\"UTF-8\"))\n                 : f.createParser(INPUT);\n         assertToken(JsonToken.START_OBJECT, parser.nextToken());\n \n         assertToken(JsonToken.FIELD_NAME, parser.nextToken());\n-        assertEquals(\"\\u0000abc\", parser.getCurrentName());\n+        String currName = parser.getCurrentName();\n+        if (!\"\\u0000abc\".equals(currName)) {\n+            fail(\"Expected \\\\0abc (4 bytes), '\"+currName+\"' (\"+currName.length()+\")\");\n+        }\n         assertToken(JsonToken.VALUE_NUMBER_INT, parser.nextToken());\n         assertEquals(1, parser.getIntValue());\n \n         assertToken(JsonToken.FIELD_NAME, parser.nextToken());\n-        assertEquals(\"abc\", parser.getCurrentName());\n+        currName = parser.getCurrentName();\n+        if (!\"abc\".equals(currName)) {\n+            /*\n+            for (int i = 0; i < currName.length(); ++i) {\n+                System.out.println(\"#\"+i+\" -> 0x\"+Integer.toHexString(currName.charAt(i)));\n+            }\n+            */\n+            fail(\"Expected 'abc' (3 bytes), '\"+currName+\"' (\"+currName.length()+\")\");\n+        }\n         assertToken(JsonToken.VALUE_NUMBER_INT, parser.nextToken());\n         assertEquals(2, parser.getIntValue());\n         \n--- a/src/test/java/com/fasterxml/jackson/core/json/TestUtf8Parser.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestUtf8Parser.java\n         jp.close();\n     }\n \n-    public void testUtf8Name2Bytes()\n-        throws Exception\n+    public void testUtf8Name2Bytes() throws Exception\n     {\n         final String[] NAMES = UTF8_2BYTE_STRINGS;\n \n             String DOC = \"{ \\\"\"+NAME+\"\\\" : 0 }\";\n             JsonParser jp = createParserUsingStream(DOC, \"UTF-8\");\n             assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+\n+            assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+\n+            assertTrue(jp.hasToken(JsonToken.FIELD_NAME));\n+            assertTrue(jp.hasTokenId(JsonTokenId.ID_FIELD_NAME));\n             \n-            assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n             assertEquals(NAME, jp.getCurrentName());\n             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertTrue(jp.hasToken(JsonToken.VALUE_NUMBER_INT));\n+            assertTrue(jp.hasTokenId(JsonTokenId.ID_NUMBER_INT));\n+\n             // should retain name during value entry, too\n             assertEquals(NAME, jp.getCurrentName());\n             \n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestByteBasedSymbols.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestByteBasedSymbols.java\n import java.io.*;\n \n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.core.sym.BytesToNameCanonicalizer;\n-import com.fasterxml.jackson.core.sym.Name;\n \n /**\n  * Unit test(s) to verify that handling of (byte-based) symbol tables\n         jp0.close();\n     }\n \n-    public void testAuxMethods()\n-        throws Exception\n+    public void testAuxMethodsWithNewSymboTable() throws Exception\n     {\n         final int A_BYTES = 0x41414141; // \"AAAA\"\n         final int B_BYTES = 0x42424242; // \"BBBB\"\n \n-        BytesToNameCanonicalizer nc = BytesToNameCanonicalizer.createRoot()\n+        ByteQuadsCanonicalizer nc = ByteQuadsCanonicalizer.createRoot()\n                 .makeChild(JsonFactory.Feature.collectDefaults());\n         assertNull(nc.findName(A_BYTES));\n         assertNull(nc.findName(A_BYTES, B_BYTES));\n \n         nc.addName(\"AAAA\", new int[] { A_BYTES }, 1);\n-        Name n1 = nc.findName(A_BYTES);\n-        assertNotNull(n1);\n-        assertEquals(\"AAAA\", n1.getName());\n+        String n1 = nc.findName(A_BYTES);\n+        assertEquals(\"AAAA\", n1);\n         nc.addName(\"AAAABBBB\", new int[] { A_BYTES, B_BYTES }, 2);\n-        Name n2 = nc.findName(A_BYTES, B_BYTES);\n-        assertEquals(\"AAAABBBB\", n2.getName());\n+        String n2 = nc.findName(A_BYTES, B_BYTES);\n+        assertEquals(\"AAAABBBB\", n2);\n         assertNotNull(n2);\n \n         /* and let's then just exercise this method so it gets covered;\n          */\n         assertNotNull(nc.toString());\n     }\n-\n+    \n     /*\n     /**********************************************************\n     /* Helper methods\n     /**********************************************************\n      */\n \n-    protected JsonParser createParser(JsonFactory jf, String input)\n-        throws IOException, JsonParseException\n+    protected JsonParser createParser(JsonFactory jf, String input) throws IOException\n     {\n         byte[] data = input.getBytes(\"UTF-8\");\n         InputStream is = new ByteArrayInputStream(data);\n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestJsonParserSymbols.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestJsonParserSymbols.java\n      */\n     final static class MyJsonFactory extends JsonFactory\n     {\n-        public int byteSymbolCount() { return _rootByteSymbols.size(); }\n+        public int byteSymbolCount() { return _byteSymbolCanonicalizer.size(); }\n         public int charSymbolCount() { return _rootCharSymbols.size(); }\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n package com.fasterxml.jackson.core.sym;\n \n import java.io.IOException;\n+import java.lang.reflect.Field;\n import java.nio.charset.Charset;\n \n import com.fasterxml.jackson.core.*;\n     {\n         // pass seed, to keep results consistent:\n         CharsToNameCanonicalizer symbols = CharsToNameCanonicalizer.createRoot(1);\n-        final int COUNT = 6000;\n+        final int COUNT = 12000;\n         for (int i = 0; i < COUNT; ++i) {\n             String id = fieldNameFor(i);\n             char[] ch = id.toCharArray();\n             symbols.findSymbol(ch, 0, ch.length, symbols.calcHash(id));\n         }\n \n-        assertEquals(8192, symbols.bucketCount());\n+        assertEquals(16384, symbols.bucketCount());\n         assertEquals(COUNT, symbols.size());\n         \n //System.out.printf(\"Char stuff: collisions %d, max-coll %d\\n\", symbols.collisionCount(), symbols.maxCollisionLength());\n         \n         // holy guacamoley... there are way too many. 31 gives 3567 (!), 33 gives 2747\n         // ... at least before shuffling. Shuffling helps quite a lot, so:\n-\n-        assertEquals(1401, symbols.collisionCount()); // with 33\n-//        assertEquals(1858, symbols.collisionCount()); // with 31\n-\n-        // esp. with collisions; first got about 30;\n-        // with fixes 4 (for 33), 5 (for 31)\n-\n-        assertEquals(4, symbols.maxCollisionLength()); // 33\n-//        assertEquals(5, symbols.maxCollisionLength()); // 31\n+        \n+        assertEquals(3431, symbols.collisionCount());\n+\n+        assertEquals(6, symbols.maxCollisionLength());\n     }\n \n     // Test for verifying stability of hashCode, wrt collisions, using\n     // synthetic field name generation and byte-based input (UTF-8)\n-    public void testSyntheticWithBytes() throws IOException\n+    @SuppressWarnings(\"deprecation\")\n+    public void testSyntheticWithBytesOld() throws IOException\n     {\n         // pass seed, to keep results consistent:\n         final int SEED = 33333;\n         BytesToNameCanonicalizer symbols =\n                 BytesToNameCanonicalizer.createRoot(SEED).makeChild(JsonFactory.Feature.collectDefaults());\n-        final int COUNT = 6000;\n+\n+        final int COUNT = 12000;\n         for (int i = 0; i < COUNT; ++i) {\n             String id = fieldNameFor(i);\n-            int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\"));\n-            symbols.addName(id, quads, quads.length);\n-        }\n-        assertEquals(COUNT, symbols.size());\n-        assertEquals(8192, symbols.bucketCount());\n+            int[] quads = calcQuads(id.getBytes(\"UTF-8\"));\n+            symbols.addName(id, quads, quads.length);\n+        }\n+        assertEquals(COUNT, symbols.size());\n+        assertEquals(16384, symbols.bucketCount());\n \n //System.out.printf(\"Byte stuff: collisions %d, max-coll %d\\n\", symbols.collisionCount(), symbols.maxCollisionLength());\n-    \n-        assertEquals(1733, symbols.collisionCount());\n-        // but not super long collision chains:\n-        assertEquals(9, symbols.maxCollisionLength());\n+        assertEquals(3476, symbols.collisionCount());\n+        // longest collision chain not optimal but ok:\n+        assertEquals(15, symbols.maxCollisionLength());\n+\n+        // But also verify entries are actually found?\n+    }\n+\n+    public void testSyntheticWithBytesNew() throws IOException\n+    {\n+        // pass seed, to keep results consistent:\n+        final int SEED = 33333;\n+        ByteQuadsCanonicalizer symbols =\n+                ByteQuadsCanonicalizer.createRoot(SEED).makeChild(JsonFactory.Feature.collectDefaults());\n+\n+        final int COUNT = 12000;\n+        for (int i = 0; i < COUNT; ++i) {\n+            String id = fieldNameFor(i);\n+            int[] quads = calcQuads(id.getBytes(\"UTF-8\"));\n+            symbols.addName(id, quads, quads.length);\n+        }\n+        assertEquals(COUNT, symbols.size());\n+        assertEquals(16384, symbols.bucketCount());\n+        \n+        // fragile, but essential to verify low collision counts;\n+        // anywhere between 70-80% primary matches\n+        assertEquals(8524, symbols.primaryCount());\n+        // secondary between 10-20%\n+        assertEquals(2534, symbols.secondaryCount());\n+        // and most of remaining in tertiary\n+        assertEquals(942, symbols.tertiaryCount());\n+        // so that spill-over is empty or close to\n+        assertEquals(0, symbols.spilloverCount());\n     }\n \n     // [Issue#145]\n-    public void testThousandsOfSymbols() throws IOException\n+    public void testThousandsOfSymbolsWithChars() throws IOException\n     {\n         final int SEED = 33333;\n \n-        BytesToNameCanonicalizer symbolsBRoot = BytesToNameCanonicalizer.createRoot(SEED);\n         CharsToNameCanonicalizer symbolsCRoot = CharsToNameCanonicalizer.createRoot(SEED);\n-        final Charset utf8 = Charset.forName(\"UTF-8\");\n+        int exp = 0;\n         \n         for (int doc = 0; doc < 100; ++doc) {\n             CharsToNameCanonicalizer symbolsC =\n                     symbolsCRoot.makeChild(JsonFactory.Feature.collectDefaults());\n+            for (int i = 0; i < 250; ++i) {\n+                String name = \"f_\"+doc+\"_\"+i;\n+                char[] ch = name.toCharArray();\n+                String str = symbolsC.findSymbol(ch, 0, ch.length,\n+                        symbolsC.calcHash(name));\n+                assertNotNull(str);\n+            }\n+            symbolsC.release();\n+            exp += 250;\n+            if (exp > CharsToNameCanonicalizer.MAX_ENTRIES_FOR_REUSE) {\n+                exp = 0;\n+            }\n+            assertEquals(exp, symbolsCRoot.size());\n+        }\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    public void testThousandsOfSymbolsWithOldBytes() throws IOException\n+    {\n+        final int SEED = 33333;\n+\n+        BytesToNameCanonicalizer symbolsBRoot = BytesToNameCanonicalizer.createRoot(SEED);\n+        final Charset utf8 = Charset.forName(\"UTF-8\");\n+        int exp = 0;\n+        \n+        for (int doc = 0; doc < 100; ++doc) {\n             BytesToNameCanonicalizer symbolsB =\n                     symbolsBRoot.makeChild(JsonFactory.Feature.collectDefaults());\n             for (int i = 0; i < 250; ++i) {\n \n                 int[] quads = BytesToNameCanonicalizer.calcQuads(name.getBytes(utf8));\n                 symbolsB.addName(name, quads, quads.length);\n-\n-                char[] ch = name.toCharArray();\n-                String str = symbolsC.findSymbol(ch, 0, ch.length,\n-                        symbolsC.calcHash(name));\n-                assertNotNull(str);\n+                Name n = symbolsB.findName(quads, quads.length);\n+                assertEquals(name, n.getName());\n             }\n             symbolsB.release();\n-            symbolsC.release();\n-        }\n+            exp += 250;\n+            if (exp > BytesToNameCanonicalizer.MAX_ENTRIES_FOR_REUSE) {\n+                exp = 0;\n+            }\n+            assertEquals(exp, symbolsBRoot.size());\n+        }\n+    }\n+\n+    // Since 2.6\n+    public void testThousandsOfSymbolsWithNew() throws IOException\n+    {\n+        final int SEED = 33333;\n+\n+        ByteQuadsCanonicalizer symbolsBRoot = ByteQuadsCanonicalizer.createRoot(SEED);\n+        final Charset utf8 = Charset.forName(\"UTF-8\");\n+        int exp = 0;\n+        ByteQuadsCanonicalizer symbolsB = null;\n+\n+        // loop to get \n+        for (int doc = 0; doc < 100; ++doc) {\n+            symbolsB = symbolsBRoot.makeChild(JsonFactory.Feature.collectDefaults());\n+            for (int i = 0; i < 250; ++i) {\n+                String name = \"f_\"+doc+\"_\"+i;\n+\n+                int[] quads = calcQuads(name.getBytes(utf8));\n+                \n+                symbolsB.addName(name, quads, quads.length);\n+                String n = symbolsB.findName(quads, quads.length);\n+                assertEquals(name, n);\n+            }\n+            symbolsB.release();\n+            \n+            exp += 250;\n+            if (exp > ByteQuadsCanonicalizer.MAX_ENTRIES_FOR_REUSE) {\n+                exp = 0;\n+            }\n+            assertEquals(exp, symbolsBRoot.size());\n+        }\n+        /* 05-Feb-2015, tatu: Fragile, but it is important to ensure that collision\n+         *   rates are not accidentally increased...\n+         */\n+        assertEquals(6250, symbolsB.size());\n+        assertEquals(4761, symbolsB.primaryCount()); // 80% primary hit rate\n+        assertEquals(1190, symbolsB.secondaryCount()); // 13% secondary\n+        assertEquals(299, symbolsB.tertiaryCount()); // 7% tertiary\n+        assertEquals(0, symbolsB.spilloverCount()); // and couple of leftovers\n+    }\n+    \n+    // And then one more test just for Bytes-based symbol table\n+    public void testByteBasedSymbolTable() throws Exception\n+    {\n+        // combination of short, medium1/2, long names...\n+        final String JSON = aposToQuotes(\"{'abc':1, 'abc\\\\u0000':2, '\\\\u0000abc':3, \"\n+                // then some medium\n+                +\"'abc123':4,'abcd1234':5,\"\n+                +\"'abcd1234a':6,'abcd1234abcd':7,\"\n+                +\"'abcd1234abcd1':8\"\n+                +\"}\");\n+\n+        JsonFactory f = new JsonFactory();\n+        JsonParser p = f.createParser(JSON.getBytes(\"UTF-8\"));\n+        ByteQuadsCanonicalizer symbols = _findSymbols(p);\n+        assertEquals(0, symbols.size());\n+        _streamThrough(p);\n+        assertEquals(8, symbols.size());\n+        p.close();\n+\n+        // and, for fun, try again\n+        p = f.createParser(JSON.getBytes(\"UTF-8\"));\n+        _streamThrough(p);\n+        symbols = _findSymbols(p);\n+        assertEquals(8, symbols.size());\n+        p.close();\n+\n+        p = f.createParser(JSON.getBytes(\"UTF-8\"));\n+        _streamThrough(p);\n+        symbols = _findSymbols(p);\n+        assertEquals(8, symbols.size());\n+        p.close();\n+    }\n+\n+    private void _streamThrough(JsonParser p) throws IOException\n+    {\n+        while (p.nextToken() != null) { }\n+    }\n+    \n+    private ByteQuadsCanonicalizer _findSymbols(JsonParser p) throws Exception\n+    {\n+        Field syms = p.getClass().getDeclaredField(\"_symbols\");\n+        syms.setAccessible(true);\n+        return ((ByteQuadsCanonicalizer) syms.get(p));\n     }\n \n     // [core#187]: unexpectedly high number of collisions for straight numbers\n+    @SuppressWarnings(\"deprecation\")\n     public void testCollisionsWithBytes187() throws IOException\n     {\n         BytesToNameCanonicalizer symbols =\n         assertEquals(65536, symbols.bucketCount());\n \n         // collision count rather high, but has to do\n-        assertEquals(14408, symbols.collisionCount());\n+        assertEquals(7127, symbols.collisionCount());\n         // as well as collision counts\n-        assertEquals(10, symbols.maxCollisionLength());\n+        assertEquals(4, symbols.maxCollisionLength());\n+    }\n+\n+    // [core#187]: unexpectedly high number of collisions for straight numbers\n+    public void testCollisionsWithBytesNew187a() throws IOException\n+    {\n+        ByteQuadsCanonicalizer symbols =\n+                ByteQuadsCanonicalizer.createRoot(1).makeChild(JsonFactory.Feature.collectDefaults());\n+\n+        final int COUNT = 43000;\n+        for (int i = 0; i < COUNT; ++i) {\n+            String id = String.valueOf(10000 + i);\n+            int[] quads = calcQuads(id.getBytes(\"UTF-8\"));\n+            symbols.addName(id, quads, quads.length);\n+        }\n+\n+        assertEquals(COUNT, symbols.size());\n+        assertEquals(65536, symbols.bucketCount());\n+\n+        /* 29-Mar-2015, tatu: To get collision counts down for this\n+         *    test took quite a bit of tweaking...\n+         */\n+        assertEquals(32342, symbols.primaryCount());\n+        assertEquals(8863, symbols.secondaryCount());\n+        assertEquals(1795, symbols.tertiaryCount());\n+\n+        // finally managed to get this to 0; other variants produced thousands\n+        assertEquals(0, symbols.spilloverCount());\n+    }\n+\n+    // Another variant, but with 1-quad names\n+    public void testCollisionsWithBytesNew187b() throws IOException\n+    {\n+        ByteQuadsCanonicalizer symbols =\n+                ByteQuadsCanonicalizer.createRoot(1).makeChild(JsonFactory.Feature.collectDefaults());\n+\n+        final int COUNT = 10000;\n+        for (int i = 0; i < COUNT; ++i) {\n+            String id = String.valueOf(i);\n+            int[] quads = calcQuads(id.getBytes(\"UTF-8\"));\n+            symbols.addName(id, quads, quads.length);\n+        }\n+        assertEquals(COUNT, symbols.size());\n+        \n+        assertEquals(32768, symbols.bucketCount());\n+\n+        // fragile, but essential to verify low collision counts;\n+        // anywhere between 70-80% primary matches\n+        assertEquals(9386, symbols.primaryCount());\n+        // secondary between 10-20%\n+        assertEquals(345, symbols.secondaryCount());\n+        // and most of remaining in tertiary\n+        assertEquals(257, symbols.tertiaryCount());\n+        // but number of spill-overs starts to grow beyond 30k quite a lot:\n+        assertEquals(12, symbols.spilloverCount());\n     }\n \n     // [core#191]: similarly, but for \"short\" symbols:\n         p.close();\n     }\n \n+    private String _shortDoc191() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"{\\n\");\n+        for (int i = 0; i < 400; ++i) {\n+            if (i > 0) {\n+                sb.append(\",\\n\");\n+            }\n+            sb.append('\"');\n+            char c = (char) i;\n+            if (Character.isLetterOrDigit(c)) {\n+                sb.append((char) i);\n+            } else {\n+                sb.append(String.format(\"\\\\u%04x\", i));\n+            }\n+            sb.append(\"\\\" : \"+i);\n+        }\n+        sb.append(\"}\\n\");\n+        return sb.toString();\n+    }\n+    \n     // [core#191]\n     public void testShortQuotedDirectChars() throws IOException\n     {\n         assertEquals(COUNT, symbols.size());\n         assertEquals(1024, symbols.bucketCount());\n \n-        assertEquals(112, symbols.collisionCount());\n+        assertEquals(50, symbols.collisionCount());\n         assertEquals(2, symbols.maxCollisionLength());\n     }\n \n-    public void testShortQuotedDirectBytes() throws IOException\n+    @SuppressWarnings(\"deprecation\")\n+    public void testShortQuotedDirectBytesOld() throws IOException\n     {\n         final int COUNT = 400;\n         BytesToNameCanonicalizer symbols =\n         assertEquals(44, symbols.collisionCount());\n         assertEquals(2, symbols.maxCollisionLength());\n     }\n+\n+    public void testShortQuotedDirectBytes() throws IOException\n+    {\n+        final int COUNT = 400;\n+        ByteQuadsCanonicalizer symbols =\n+                ByteQuadsCanonicalizer.createRoot(123).makeChild(JsonFactory.Feature.collectDefaults());\n+        for (int i = 0; i < COUNT; ++i) {\n+            String id = String.format(\"\\\\u%04x\", i);\n+            int[] quads = calcQuads(id.getBytes(\"UTF-8\"));\n+            symbols.addName(id, quads, quads.length);\n+        }\n+        assertEquals(COUNT, symbols.size());\n+        assertEquals(512, symbols.bucketCount());\n+\n+        assertEquals(285, symbols.primaryCount());\n+        assertEquals(90, symbols.secondaryCount());\n+        assertEquals(25, symbols.tertiaryCount());\n+        assertEquals(0, symbols.spilloverCount());\n+    }\n     \n     // [core#191]\n+    @SuppressWarnings(\"deprecation\")\n     public void testShortNameCollisionsDirect() throws IOException\n     {\n-        final int COUNT = 400;\n+        final int COUNT = 600;\n \n         // First, char-based\n         {\n             assertEquals(COUNT, symbols.size());\n             assertEquals(1024, symbols.bucketCount());\n     \n-            assertEquals(0, symbols.collisionCount());\n-            assertEquals(0, symbols.maxCollisionLength());\n-        }\n-\n+            assertEquals(16, symbols.collisionCount());\n+            assertEquals(1, symbols.maxCollisionLength());\n+        }\n+        \n         // then byte-based\n         {\n             BytesToNameCanonicalizer symbols =\n                     BytesToNameCanonicalizer.createRoot(1).makeChild(JsonFactory.Feature.collectDefaults());\n             for (int i = 0; i < COUNT; ++i) {\n                 String id = String.valueOf((char) i);\n-                int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\"));\n+                int[] quads = calcQuads(id.getBytes(\"UTF-8\"));\n                 symbols.addName(id, quads, quads.length);\n             }\n             assertEquals(COUNT, symbols.size());\n             assertEquals(1024, symbols.bucketCount());\n     \n-            assertEquals(15, symbols.collisionCount());\n+            assertEquals(209, symbols.collisionCount());\n             assertEquals(1, symbols.maxCollisionLength());\n         }\n     }\n-    \n-    private String _shortDoc191() {\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(\"{\\n\");\n-        for (int i = 0; i < 400; ++i) {\n-            if (i > 0) {\n-                sb.append(\",\\n\");\n-            }\n-            sb.append(String.format(\"\\\"\\\\u%04x\\\" : %d\", i, i));\n-        }\n-        sb.append(\"}\\n\");\n-        return sb.toString();\n+\n+    public void testShortNameCollisionsDirectNew() throws IOException\n+    {\n+        final int COUNT = 700;\n+        {\n+            ByteQuadsCanonicalizer symbols =\n+                    ByteQuadsCanonicalizer.createRoot(333).makeChild(JsonFactory.Feature.collectDefaults());\n+            for (int i = 0; i < COUNT; ++i) {\n+                String id = String.valueOf((char) i);\n+                int[] quads = calcQuads(id.getBytes(\"UTF-8\"));\n+                symbols.addName(id, quads, quads.length);\n+            }\n+            assertEquals(COUNT, symbols.size());\n+\n+            assertEquals(2048, symbols.bucketCount());\n+\n+            // Primary is good, but secondary spills cluster in nasty way...\n+            assertEquals(640, symbols.primaryCount());\n+            assertEquals(30, symbols.secondaryCount());\n+            assertEquals(16, symbols.tertiaryCount());\n+            assertEquals(14, symbols.spilloverCount());\n+\n+            assertEquals(COUNT,\n+                    symbols.primaryCount() + symbols.secondaryCount() + symbols.tertiaryCount() + symbols.spilloverCount());\n+        }\n     }\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolsWithMediaItem.java\n+package com.fasterxml.jackson.core.sym;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+public class TestSymbolsWithMediaItem extends com.fasterxml.jackson.core.BaseTest\n+{\n+    private final String JSON = aposToQuotes(\n+            \"{'media' : {\\n\"\n+            +\"      'uri' : 'http://foo.com',\"\n+            +\"      'title' : 'Test title 1',\"\n+            +\"      'width' : 640, 'height' : 480,\"\n+            +\"      'format' : 'video/mpeg4',\"\n+            +\"      'duration' : 18000000,\"\n+            +\"      'size' : 58982400,\"\n+            +\"      'bitrate' : 262144,\"\n+            +\"      'persons' : [ ],\"\n+            +\"      'player' : 'native',\"\n+            +\"      'copyright' : 'None'\"\n+            +\"   },\\n\"\n+            +\"   'images' : [ {\\n\"\n+            +\"      'uri' : 'http://bar.com',\\n\"\n+            +\"      'title' : 'Test title 1',\\n\"\n+            +\"      'width' : 1024,'height' : 768,\\n\"\n+            +\"      'size' : 'LARGE'\\n\"\n+            +\"    }, {\\n\"\n+            +\"      'uri' : 'http://foobar.org',\\n\"\n+            +\"      'title' : 'Javaone Keynote',\\n\"\n+            +\"      'width' : 320, 'height' : 240,\\n\"\n+            +\"      'size' : 'SMALL'\\n\"\n+            +\"    } ]\\n\"\n+            +\"}\\n\");\n+\n+    public void testSmallSymbolSetWithBytes() throws IOException\n+    {\n+        final int SEED = 33333;\n+\n+        ByteQuadsCanonicalizer symbolsRoot = ByteQuadsCanonicalizer.createRoot(SEED);\n+        ByteQuadsCanonicalizer symbols = symbolsRoot.makeChild(JsonFactory.Feature.collectDefaults());\n+        JsonFactory f = new JsonFactory();\n+        JsonParser p = f.createParser(JSON.getBytes(\"UTF-8\"));\n+\n+        JsonToken t;\n+        while ((t = p.nextToken()) != null) {\n+            if (t != JsonToken.FIELD_NAME) {\n+                continue;\n+            }\n+            String name = p.getCurrentName();\n+            int[] quads = calcQuads(name.getBytes(\"UTF-8\"));\n+\n+            if (symbols.findName(quads, quads.length) != null) {\n+                continue;\n+            }\n+            symbols.addName(name, quads, quads.length);\n+        }\n+        p.close();\n+        \n+        assertEquals(13, symbols.size());\n+        assertEquals(12, symbols.primaryCount()); // 80% primary hit rate\n+        assertEquals(1, symbols.secondaryCount()); // 13% secondary\n+        assertEquals(0, symbols.tertiaryCount()); // 7% tertiary\n+        assertEquals(0, symbols.spilloverCount()); // and couple of leftovers\n+    }\n+\n+    public void testSmallSymbolSetWithChars() throws IOException\n+    {\n+        final int SEED = 33333;\n+\n+        CharsToNameCanonicalizer symbols = CharsToNameCanonicalizer.createRoot(SEED);\n+        JsonFactory f = new JsonFactory();\n+        JsonParser p = f.createParser(JSON);\n+\n+        JsonToken t;\n+        while ((t = p.nextToken()) != null) {\n+            if (t != JsonToken.FIELD_NAME) {\n+                continue;\n+            }\n+            String name = p.getCurrentName();\n+            char[] ch = name.toCharArray();\n+            symbols.findSymbol(ch, 0, ch.length, symbols.calcHash(name));\n+        }\n+        p.close();\n+        \n+        assertEquals(13, symbols.size());\n+        assertEquals(13, symbols.size());\n+        assertEquals(64, symbols.bucketCount());\n+\n+        // usually get 1 collision, but sometimes get lucky with 0; other times less so with 2\n+        // (with differing shifting for hash etc)\n+        assertEquals(0, symbols.collisionCount());\n+        assertEquals(0, symbols.maxCollisionLength());\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/core/util/TestTextBuffer.java\n+++ b/src/test/java/com/fasterxml/jackson/core/util/TestTextBuffer.java\n package com.fasterxml.jackson.core.util;\n-\n-import com.fasterxml.jackson.core.util.BufferRecycler;\n-import com.fasterxml.jackson.core.util.TextBuffer;\n \n public class TestTextBuffer\n     extends com.fasterxml.jackson.core.BaseTest\n               }\n           }\n       }\n+\n+    // [Core#182]\n+    public void testEmpty() {\n+        TextBuffer tb = new TextBuffer(new BufferRecycler());\n+        tb.resetWithEmpty();\n+\n+        assertTrue(tb.getTextBuffer().length == 0);\n+        tb.contentsAsString();\n+        assertTrue(tb.getTextBuffer().length == 0);\n+    }\n }\n--- /dev/null\n+++ b/src/test/java/perf/EnumByBytesLookup.java\n+package perf;\n+\n+import java.nio.charset.Charset;\n+import java.util.Arrays;\n+\n+/**\n+ * Trie container/wrapper, in this case implements Enum-value lookup.\n+ * Sample code to possibly use for streamlined-lookup by dictionary, using\n+ * UTF-8 bytes of {@link Enum#name()} as the key.\n+ */\n+public class EnumByBytesLookup<E extends Enum<E>>\n+{\n+    private final static Charset UTF8 = Charset.forName(\"UTF-8\");\n+\n+    private final Trie<E> _root;\n+    private final int _size;\n+\n+    private EnumByBytesLookup(Trie<E> root, int size) {\n+        _root = root;\n+        _size = size;\n+    }\n+\n+    public static <EIN extends Enum<EIN>> EnumByBytesLookup<EIN> buildFor(Class<EIN> enumClass)\n+    {\n+        Trie<EIN> root = new Trie<EIN>(null);\n+        int size = 0;\n+        for (EIN en : enumClass.getEnumConstants()) {\n+            byte[] key = en.name().getBytes(UTF8);\n+            root = root.with(en, key);\n+            ++size;\n+        }\n+        return new EnumByBytesLookup<EIN>(root, size);\n+    }\n+\n+    public E find(byte[] rawId) {\n+      return _root.find(rawId);\n+    }\n+\n+    public int size() { return _size; }\n+}\n+\n+/**\n+ * Trie nodes\n+ */\n+class Trie<T> {\n+    private final static byte[] NO_BYTES = new byte[0];\n+\n+    private final static Trie<?>[] NO_NODES = new Trie<?>[0];\n+\n+    /**\n+     * For leaves, value matched by sequence\n+     */\n+    private final T _match;\n+\n+    private final byte[] _nextBytes;\n+    private final Trie<T>[] nextNodes;\n+\n+    private final int nextCount;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    Trie(T match) {\n+      this(match, NO_BYTES, (Trie<T>[]) NO_NODES);\n+    }\n+\n+    private Trie(T match, byte[] nextBytes, Trie<T>[] nextNodes) {\n+      this._match = match;\n+      this._nextBytes = nextBytes;\n+      this.nextNodes = nextNodes;\n+      nextCount = nextBytes.length;\n+    }\n+\n+    private Trie(Trie<T> base, T match) {\n+      // should we allow duplicate calls with same match? For now, let's not\n+      if (base._match != null) {\n+        throw new IllegalArgumentException(\"Trying to add same match multiple times\");\n+      }\n+      this._match = match;\n+      _nextBytes = base._nextBytes;\n+      nextNodes = base.nextNodes;\n+      nextCount = base.nextCount;\n+    }\n+\n+    private Trie(Trie<T> base, byte nextByte, Trie<T> nextNode) {\n+      // should we allow duplicate calls with same match? For now, let's not\n+      if (base._match != null) {\n+        throw new IllegalArgumentException(\"Trying to add same match multiple times\");\n+      }\n+      _match = base._match;\n+      int size = base._nextBytes.length + 1;\n+      _nextBytes = Arrays.copyOf(base._nextBytes, size);\n+      _nextBytes[size-1] = nextByte;\n+      nextNodes = Arrays.copyOf(base.nextNodes, size);\n+      nextNodes[size-1] = nextNode;\n+      nextCount = size;\n+    }\n+\n+    /**\n+     * Constructor used when an existing branch needs to be replaced due to addition\n+     */\n+    private Trie(Trie<T> base, int offset, Trie<T> newNode) {\n+      _match = base._match;\n+      // can keep nextBytes, as they don't change\n+      _nextBytes = base._nextBytes;\n+      // but must create a copy of next nodes, to modify one entry\n+      nextNodes = Arrays.copyOf(base.nextNodes, base.nextNodes.length);\n+      nextNodes[offset] = newNode;\n+      nextCount = base.nextCount;\n+    }\n+\n+    /**\n+     * \"Mutant factory\" method: constructs a modified Trie, with specified raw id\n+     * added.\n+     */\n+    public Trie<T> with(T match, byte[] rawId) {\n+      return with(match, rawId, 0, rawId.length);\n+    }\n+\n+    private Trie<T> with(T match, byte[] rawId, int start, int end) {\n+      if (start == end) {\n+        return new Trie<T>(this, match);\n+      }\n+      // Ok: two choices; either we follow existing branch; or need to create new one\n+      final byte b = rawId[start++];\n+      for (int i = 0; i < nextCount; ++i) {\n+        if (_nextBytes[i] == b) {\n+          // existing branch: good day for delegation...\n+          Trie<T> old = nextNodes[i];\n+          // to keep things truly immutable, copy underlying arrays, then\n+          return new Trie<T>(this, i, old.with(match, rawId, start, end));\n+        }\n+      }\n+      // simplest recursively, but for fun let's convert to iteration. Start with tail\n+      Trie<T> curr = new Trie<T>(match);\n+\n+      for (int i = end-1; i >= start; --i) {\n+        curr = new Trie<T>(this, rawId[i], curr);\n+      }\n+      return new Trie<T>(this, b, curr);\n+    }\n+\n+    public T find(byte[] id) {\n+      return find(id, 0, id.length);\n+    }\n+\n+    public T find(byte[] id, int offset, int length) {\n+      Trie<T> t = this;\n+      final int end = offset+length;\n+\n+      for (; offset < end; ++offset) {\n+        byte b = id[offset];\n+        t = t.next(b);\n+        if (t == null) {\n+            // NOTE: if using null-padding, would trim here\n+            /*\n+          if (b == (byte) 0) {\n+            break;\n+          }\n+          */\n+          return null;\n+        }\n+      }\n+      return t._match;\n+    }\n+\n+    private Trie<T> next(int b) {\n+      for (int i = 0; i < nextCount; ++i) {\n+        if (_nextBytes[i] == b) {\n+          return nextNodes[i];\n+        }\n+      }\n+      return null;\n+    }\n+}", "timestamp": 1429896050, "metainfo": ""}