{"sha": "a01dcf1ff1277eeb4fa8ac9f2f23fecd65ec4f86", "log": "Merge branch '2.6'", "commit": "\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestRootValues.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestRootValues.java\n         jp.close();\n     }\n \n+    public void testBrokeanNumber() throws Exception\n+    {\n+    \t_testBrokeanNumber(false);\n+    \t_testBrokeanNumber(true);\n+    }\n+\n+    private void _testBrokeanNumber(boolean useStream) throws Exception\n+    {\n+    \tJsonFactory f = new JsonFactory();\n+        final String DOC = \"14:89:FD:D3:E7:8C\";\n+        JsonParser p = useStream ?\n+                createParserUsingStream(f, DOC, \"UTF-8\")\n+                : createParserUsingReader(f, DOC);\n+        // Should fail, right away\n+        try {\n+        \tp.nextToken();\n+        \tfail(\"Ought to fail! Instead, got token: \"+p.getCurrentToken());\n+        } catch (JsonParseException e) {\n+        \tverifyException(e, \"unexpected character\");\n+        }\n+        p.close();\n+    }\n+    \n     public void testSimpleBooleans() throws Exception\n     {\n         _testSimpleBooleans(false);\n--- a/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n      */\n     protected final transient ByteQuadsCanonicalizer _byteSymbolCanonicalizer = ByteQuadsCanonicalizer.createRoot();\n \n-    /**\n-     * Earlier byte-based symbol table; replaced with 2.6 with a new implementation.\n-     * Left in for version 2.6.0: will be removed in 2.7 or later.\n-     *\n-     * @deprecated Since 2.6.0, only use {@link #_byteSymbolCanonicalizer}\n-     */\n-    @Deprecated\n-    protected final transient com.fasterxml.jackson.core.sym.BytesToNameCanonicalizer _rootByteSymbols\n-        = com.fasterxml.jackson.core.sym.BytesToNameCanonicalizer.createRoot();\n-\n     /*\n     /**********************************************************\n     /* Configuration\n--- a/src/main/java/com/fasterxml/jackson/core/JsonGenerationException.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonGenerationException.java\n     extends JsonProcessingException\n {\n     private final static long serialVersionUID = 123; // Stupid eclipse...\n-    \n-    public JsonGenerationException(Throwable rootCause)\n-    {\n+\n+    protected JsonGenerator _processor;\n+\n+    // TODO: mark deprecated in 2.7\n+    public JsonGenerationException(Throwable rootCause) {\n         super(rootCause);\n     }\n \n-    public JsonGenerationException(String msg)\n-    {\n+    // TODO: mark deprecated in 2.7\n+    public JsonGenerationException(String msg) {\n         super(msg, (JsonLocation)null);\n     }\n \n-    public JsonGenerationException(String msg, Throwable rootCause)\n-    {\n+    // TODO: mark deprecated in 2.7\n+    public JsonGenerationException(String msg, Throwable rootCause) {\n         super(msg, null, rootCause);\n     }\n+\n+    /**\n+     * @since 2.7\n+     */\n+    public JsonGenerationException(Throwable rootCause, JsonGenerator g) {\n+        super(rootCause);\n+        _processor = g;\n+    }\n+\n+    /**\n+     * @since 2.7\n+     */\n+    public JsonGenerationException(String msg, JsonGenerator g) {\n+        super(msg, (JsonLocation) null);\n+        _processor = g;\n+    }\n+    \n+    /**\n+     * @since 2.7\n+     */\n+    public JsonGenerationException(String msg, Throwable rootCause, JsonGenerator g) {\n+        super(msg, null, rootCause);\n+        _processor = g;\n+    }\n+\n+    /**\n+     * Fluent method that may be used to assign originating {@link JsonGenerator},\n+     * to be accessed using {@link #getProcessor()}.\n+     *\n+     * @since 2.7\n+     */\n+    public JsonGenerationException withGenerator(JsonGenerator g) {\n+        _processor = g;\n+        return this;\n+    }\n+\n+    @Override\n+    public JsonGenerator getProcessor() { return _processor; }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n      */\n     public abstract boolean isEnabled(Feature f);\n \n-\n     /**\n      * Bulk access method for getting state of all standard (non-dataformat-specific)\n      * {@link JsonGenerator.Feature}s.\n      *    and which disabled\n      *\n      * @return This parser object, to allow chaining of calls\n-     */\n+     *\n+     * @deprecated Since 2.7, use {@link #overrideStdFeatures(int, int)} instead\n+     */\n+    @Deprecated\n     public abstract JsonGenerator setFeatureMask(int values);\n \n     /**\n      *    int newState = (oldState &amp; ~mask) | (values &amp; mask);\n      *    setFeatureMask(newState);\n      *</code>\n+     * but preferred as this lets caller more efficiently specify actual changes made.\n      * \n      * @param values Bit mask of set/clear state for features to change\n      * @param mask Bit mask of features to change\n      * @since 2.3\n      */\n     public void writeObjectId(Object id) throws IOException {\n-        throw new JsonGenerationException(\"No native support for writing Object Ids\");\n+        throw new JsonGenerationException(\"No native support for writing Object Ids\", this);\n     }\n \n     /**\n      * a {@link JsonGenerationException} will be thrown.\n      */\n     public void writeObjectRef(Object id) throws IOException {\n-        throw new JsonGenerationException(\"No native support for writing Object Ids\");\n+        throw new JsonGenerationException(\"No native support for writing Object Ids\", this);\n     }\n     \n     /**\n      * @since 2.3\n      */\n     public void writeTypeId(Object id) throws IOException {\n-        throw new JsonGenerationException(\"No native support for writing Type Ids\");\n+        throw new JsonGenerationException(\"No native support for writing Type Ids\", this);\n     }\n     \n     /*\n      * or use a {@link JsonGenerationException} sub-class.\n      */\n     protected void _reportError(String msg) throws JsonGenerationException {\n-        throw new JsonGenerationException(msg);\n+        throw new JsonGenerationException(msg, this);\n     }\n \n     protected final void _throwInternal() { VersionUtil.throwInternal(); }\n     protected void _reportUnsupportedOperation() {\n         throw new UnsupportedOperationException(\"Operation not supported by generator of type \"+getClass().getName());\n     }\n-    \n+\n     /**\n      * Helper method to try to call appropriate write method for given\n      * untyped Object. At this point, no structural conversions should be done,\n             } else if (n instanceof BigDecimal) {\n                 writeNumber((BigDecimal) n);\n                 return;\n-                \n+\n             // then Atomic types\n-                \n             } else if (n instanceof AtomicInteger) {\n                 writeNumber(((AtomicInteger) n).get());\n                 return;\n--- a/src/main/java/com/fasterxml/jackson/core/JsonParseException.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonParseException.java\n  * is encountered.\n  */\n public class JsonParseException extends JsonProcessingException {\n-    private static final long serialVersionUID = 1L;\n-    \n+    private static final long serialVersionUID = 2L; // 2.7\n+\n+    protected JsonParser _processor;\n+\n+    // TODO: mark deprecated in 2.7\n     public JsonParseException(String msg, JsonLocation loc) {\n         super(msg, loc);\n     }\n \n+    // TODO: mark deprecated in 2.7\n     public JsonParseException(String msg, JsonLocation loc, Throwable root) {\n         super(msg, loc, root);\n     }\n+\n+    /**\n+     * Constructor that uses current parsing location as location, and\n+     * sets processor (accessible via {@link #getProcessor()}) to\n+     * specified parser.\n+     *\n+     * @since 2.7\n+     */\n+    public JsonParseException(JsonParser p, String msg) {\n+        super(msg, (p == null) ? null : p.getCurrentLocation());\n+        _processor = p;\n+    }\n+\n+    /**\n+     * @since 2.7\n+     */\n+    public JsonParseException(JsonParser p, String msg, Throwable root) {\n+        super(msg, (p == null) ? null : p.getCurrentLocation(), root);\n+        _processor = p;\n+    }\n+    \n+    /**\n+     * @since 2.7\n+     */\n+    public JsonParseException(JsonParser p, String msg, JsonLocation loc) {\n+        super(msg, loc);\n+        _processor = p;\n+    }\n+\n+    /**\n+     * @since 2.7\n+     */\n+    public JsonParseException(JsonParser p, String msg, JsonLocation loc, Throwable root) {\n+        super(msg, loc, root);\n+        _processor = p;\n+    }\n+\n+    /**\n+     * Fluent method that may be used to assign originating {@link JsonParser},\n+     * to be accessed using {@link #getProcessor()}.\n+     *\n+     * @since 2.7\n+     */\n+    public JsonParseException withParser(JsonParser p) {\n+        _processor = p;\n+        return this;\n+    }\n+\n+    @Override\n+    public JsonParser getProcessor() {\n+        return _processor;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n          * Feature that determines whether parser will allow use\n          * of single quotes (apostrophe, character '\\'') for\n          * quoting Strings (names and String values). If so,\n-         * this is in addition to other acceptabl markers.\n+         * this is in addition to other acceptable markers.\n          * but not by JSON specification).\n          *<p>\n          * Since JSON specification requires use of double quotes for\n      * @return This parser object, to allow chaining of calls\n      * \n      * @since 2.3\n-     */\n+     * \n+     * @deprecated Since 2.7, use {@link #overrideStdFeatures(int, int)} instead\n+     */\n+    @Deprecated\n     public JsonParser setFeatureMask(int mask) {\n         _features = mask;\n         return this;\n      *    int newState = (oldState &amp; ~mask) | (values &amp; mask);\n      *    setFeatureMask(newState);\n      *</code>\n+     * but preferred as this lets caller more efficiently specify actual changes made.\n      * \n      * @param values Bit mask of set/clear state for features to change\n      * @param mask Bit mask of features to change\n      * @since 2.6\n      */\n     public JsonParser overrideStdFeatures(int values, int mask) {\n-        _features = (_features & ~mask) | (values & mask);\n-        return this;\n+        int newState = (_features & ~mask) | (values & mask);\n+        return setFeatureMask(newState);\n     }\n \n     /**\n         JsonToken t = getCurrentToken();\n         if (t == JsonToken.VALUE_TRUE) return true;\n         if (t == JsonToken.VALUE_FALSE) return false;\n-        throw new JsonParseException(\"Current token (\"+t+\") not of boolean type\", getCurrentLocation());\n+        throw new JsonParseException(this,\n+                String.format(\"Current token (%s) not of boolean type\", t));\n     }\n \n     /**\n      * based on current state of the parser\n      */\n     protected JsonParseException _constructError(String msg) {\n-        return new JsonParseException(msg, getCurrentLocation());\n+        return new JsonParseException(this, msg);\n     }\n \n     /**\n--- a/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\n \n     /*\n     /**********************************************************\n-    /* Cosntruction\n+    /* Construction\n     /**********************************************************\n      */\n     \n--- a/src/main/java/com/fasterxml/jackson/core/JsonProcessingException.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonProcessingException.java\n         this(null, null, rootCause);\n     }\n \n-    public JsonLocation getLocation() { return _location; }\n-\n     /*\n     /**********************************************************\n     /* Extended API\n     /**********************************************************\n      */\n \n+    public JsonLocation getLocation() { return _location; }\n+    \n     /**\n      * Method that allows accessing the original \"message\" argument,\n      * without additional decorations (like location information)\n      * @since 2.1\n      */\n     public String getOriginalMessage() { return super.getMessage(); }\n+\n+    /**\n+     * Method that allows accessing underlying processor that triggered\n+     * this exception; typically either {@link JsonParser} or {@link JsonGenerator}\n+     * for exceptions that originate from streaming API.\n+     * Note that it is possible that `null` may be returned if code throwing\n+     * exception either has no access to processor; or has not been retrofitted\n+     * to set it; this means that caller needs to take care to check for nulls.\n+     * Subtypes override this method with co-variant return type, for more\n+     * type-safe access.\n+     * \n+     * @return Originating processor, if available; null if not.\n+     *\n+     * @since 2.7\n+     */\n+    public Object getProcessor() { return null; }\n \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/core/Version.java\n+++ b/src/main/java/com/fasterxml/jackson/core/Version.java\n     private static final long serialVersionUID = 1L;\n \n     private final static Version UNKNOWN_VERSION = new Version(0, 0, 0, null, null, null);\n-    \n+\n     protected final int _majorVersion;\n \n     protected final int _minorVersion;\n     protected final int _patchLevel;\n \n     protected final String _groupId;\n-    \n+\n     protected final String _artifactId;\n-    \n+\n     /**\n      * Additional information for snapshot versions; null for non-snapshot\n      * (release) versions.\n     {\n         this(major, minor, patchLevel, snapshotInfo, null, null);\n     }\n-    \n+\n     public Version(int major, int minor, int patchLevel, String snapshotInfo,\n             String groupId, String artifactId)\n     {\n      */\n     public static Version unknownVersion() { return UNKNOWN_VERSION; }\n \n-    public boolean isUknownVersion() { return (this == UNKNOWN_VERSION); }\n+    /**\n+     * @since 2.7 to replace misspelled {@link #isUknownVersion()}\n+     */\n+    public boolean isUnknownVersion() { return (this == UNKNOWN_VERSION); }\n     public boolean isSnapshot() { return (_snapshotInfo != null && _snapshotInfo.length() > 0); }\n-    \n+\n+    /**\n+     * @deprecated Since 2.7 use correctly spelled method {@link #isUnknownVersion()}\n+     */\n+    @Deprecated\n+    public boolean isUknownVersion() { return isUnknownVersion(); }\n+\n     public int getMajorVersion() { return _majorVersion; }\n     public int getMinorVersion() { return _minorVersion; }\n     public int getPatchLevel() { return _patchLevel; }\n \n     public String getGroupId() { return _groupId; }\n     public String getArtifactId() { return _artifactId; }\n-    \n+\n     public String toFullString() {\n         return _groupId + '/' + _artifactId + '/' + toString();\n     }\n-    \n+\n     @Override public String toString() {\n         StringBuilder sb = new StringBuilder();\n         sb.append(_majorVersion).append('.');\n--- a/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n         return this;\n     }\n \n-    @Override public JsonGenerator setFeatureMask(int newMask) {\n+    @Override\n+    @Deprecated\n+    public JsonGenerator setFeatureMask(int newMask) {\n         int changed = newMask ^ _features;\n         _features = newMask;\n-        if ((changed & DERIVED_FEATURES_MASK) != 0) {\n-            _cfgNumbersAsStrings = Feature.WRITE_NUMBERS_AS_STRINGS.enabledIn(newMask);\n-            if (Feature.ESCAPE_NON_ASCII.enabledIn(changed)) {\n-                if (Feature.ESCAPE_NON_ASCII.enabledIn(newMask)) {\n-                    setHighestNonEscapedChar(127);\n-                } else {\n-                    setHighestNonEscapedChar(0);\n+        if (changed != 0) {\n+            _checkStdFeatureChanges(newMask, changed);\n+        }\n+        return this;\n+    }\n+\n+    @Override // since 2.7\n+    public JsonGenerator overrideStdFeatures(int values, int mask) {\n+        int oldState = _features;\n+        int newState = (oldState & ~mask) | (values & mask);\n+        int changed = oldState ^ newState;\n+        if (changed != 0) {\n+            _features = newState;\n+            _checkStdFeatureChanges(newState, changed);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Helper method called to verify changes to standard features.\n+     *\n+     * @param newFeatureFlags Bitflag of standard features after they were changed\n+     * @param changedFeatures Bitflag of standard features for which setting\n+     *    did change\n+     *\n+     * @since 2.7\n+     */\n+    protected void _checkStdFeatureChanges(int newFeatureFlags, int changedFeatures)\n+    {\n+        if ((changedFeatures & DERIVED_FEATURES_MASK) == 0) {\n+            return;\n+        }\n+        _cfgNumbersAsStrings = Feature.WRITE_NUMBERS_AS_STRINGS.enabledIn(newFeatureFlags);\n+        if (Feature.ESCAPE_NON_ASCII.enabledIn(changedFeatures)) {\n+            if (Feature.ESCAPE_NON_ASCII.enabledIn(newFeatureFlags)) {\n+                setHighestNonEscapedChar(127);\n+            } else {\n+                setHighestNonEscapedChar(0);\n+            }\n+        }\n+        if (Feature.STRICT_DUPLICATE_DETECTION.enabledIn(changedFeatures)) {\n+            if (Feature.STRICT_DUPLICATE_DETECTION.enabledIn(newFeatureFlags)) { // enabling\n+                if (_writeContext.getDupDetector() == null) { // but only if disabled currently\n+                    _writeContext = _writeContext.withDupDetector(DupDetector.rootDetector(this));\n                 }\n-            }\n-            if (Feature.STRICT_DUPLICATE_DETECTION.enabledIn(changed)) {\n-                if (Feature.STRICT_DUPLICATE_DETECTION.enabledIn(newMask)) { // enabling\n-                    if (_writeContext.getDupDetector() == null) { // but only if disabled currently\n-                        _writeContext = _writeContext.withDupDetector(DupDetector.rootDetector(this));\n-                    }\n-                } else { // disabling\n-                    _writeContext = _writeContext.withDupDetector(null);\n-                }\n-            }\n-        }\n-        return this;\n+            } else { // disabling\n+                _writeContext = _writeContext.withDupDetector(null);\n+            }\n+        }\n     }\n     \n     @Override public JsonGenerator useDefaultPrettyPrinter() {\n-        /* 28-Sep-2012, tatu: As per [Issue#84], should not override a\n-         *  pretty printer if one already assigned.\n-         */\n+        // Should not override a pretty printer if one already assigned.\n         if (getPrettyPrinter() != null) {\n             return this;\n         }\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n         }\n         return this;\n     }\n-    \n-    @Override\n+\n+    @Override\n+    @Deprecated\n     public JsonParser setFeatureMask(int newMask) {\n         int changes = (_features ^ newMask);\n         if (changes != 0) {\n             _features = newMask;\n-            if (Feature.STRICT_DUPLICATE_DETECTION.enabledIn(newMask)) { // enabling\n-                if (_parsingContext.getDupDetector() == null) { // but only if disabled currently\n+            _checkStdFeatureChanges(newMask, changes);\n+        }\n+        return this;\n+    }\n+\n+    @Override // since 2.7\n+    public JsonParser overrideStdFeatures(int values, int mask) {\n+        int oldState = _features;\n+        int newState = (oldState & ~mask) | (values & mask);\n+        int changed = oldState ^ newState;\n+        if (changed != 0) {\n+            _features = newState;\n+            _checkStdFeatureChanges(newState, changed);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Helper method called to verify changes to standard features.\n+     *\n+     * @param newFeatureFlags Bitflag of standard features after they were changed\n+     * @param changedFeatures Bitflag of standard features for which setting\n+     *    did change\n+     *\n+     * @since 2.7\n+     */\n+    protected void _checkStdFeatureChanges(int newFeatureFlags, int changedFeatures)\n+    {\n+        int f = Feature.STRICT_DUPLICATE_DETECTION.getMask();\n+        \n+        if ((changedFeatures & f) != 0) {\n+            if ((newFeatureFlags & f) != 0) {\n+                if (_parsingContext.getDupDetector() == null) {\n                     _parsingContext = _parsingContext.withDupDetector(DupDetector.rootDetector(this));\n+                } else { // disabling\n+                    _parsingContext = _parsingContext.withDupDetector(null);\n                 }\n-            } else { // disabling\n-                _parsingContext = _parsingContext.withDupDetector(null);\n-            }\n-        }\n-        return this;\n-    }\n-    \n+            }\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* JsonParser impl\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n     public int getValueAsInt() throws IOException\n     {\n         JsonToken t = _currToken;\n-        if (t == JsonToken.VALUE_NUMBER_INT) {\n+        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n             return getIntValue();\n         }\n-        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n-            return getIntValue();\n-        }\n         return getValueAsInt(0);\n     }\n \n     public int getValueAsInt(int defaultValue) throws IOException\n     {\n         JsonToken t = _currToken;\n-        if (t == JsonToken.VALUE_NUMBER_INT) {\n-            return getIntValue();\n-        }\n-        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n+        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n             return getIntValue();\n         }\n         if (t != null) {\n     public long getValueAsLong() throws IOException\n     {\n         JsonToken t = _currToken;\n-        if (t == JsonToken.VALUE_NUMBER_INT) {\n+        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n             return getLongValue();\n         }\n-        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n-            return getLongValue();\n-        }\n         return getValueAsLong(0L);\n     }\n     \n     public long getValueAsLong(long defaultValue) throws IOException\n     {\n         JsonToken t = _currToken;\n-        if (t == JsonToken.VALUE_NUMBER_INT) {\n-            return getLongValue();\n-        }\n-        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n+        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n             return getLongValue();\n         }\n         if (t != null) {\n     }\n \n     protected final JsonParseException _constructError(String msg, Throwable t) {\n-        return new JsonParseException(msg, getCurrentLocation(), t);\n+        return new JsonParseException(this, msg, t);\n     }\n \n     protected static byte[] _asciiBytes(String str) {\n         }\n         return b;\n     }\n-    \n+\n     protected static String _ascii(byte[] b) {\n         try {\n             return new String(b, \"US-ASCII\");\n--- a/src/main/java/com/fasterxml/jackson/core/json/DupDetector.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/DupDetector.java\n public class DupDetector\n {\n     /**\n-     * We need to store a back-reference here to parser/generator, unfortunately.\n+     * We need to store a back-reference here to parser/generator.\n      */\n     protected final Object _source;\n \n         // do generators have a way to provide Location? Apparently not...\n         return null;\n     }\n-    \n+\n+    /**\n+     * @since 2.7\n+     */\n+    public Object getSource() {\n+        return _source;\n+    }\n+\n     public boolean isDup(String name) throws JsonParseException\n     {\n         if (_firstName == null) {\n--- a/src/main/java/com/fasterxml/jackson/core/json/JsonReadContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonReadContext.java\n     /**********************************************************\n      */\n \n-    @Deprecated // since 2.3, use variant that takes dup detector\n-    public static JsonReadContext createRootContext(int lineNr, int colNr) {\n-        return createRootContext(lineNr, colNr, null);\n-    }\n-\n     public static JsonReadContext createRootContext(int lineNr, int colNr, DupDetector dups) {\n         return new JsonReadContext(null, dups, TYPE_ROOT, lineNr, colNr);\n-    }\n-\n-    @Deprecated // since 2.3, use variant that takes dup detector\n-    public static JsonReadContext createRootContext() {\n-        return createRootContext(null);\n     }\n \n     public static JsonReadContext createRootContext(DupDetector dups) {\n \n     private void _checkDup(DupDetector dd, String name) throws JsonProcessingException {\n         if (dd.isDup(name)) {\n-            throw new JsonParseException(\"Duplicate field '\"+name+\"'\", dd.findLocation());\n-        }\n-    }\n-    \n+            Object src = dd.getSource();\n+            throw new JsonParseException(((src instanceof JsonGenerator) ? ((JsonParser) src) : null),\n+                    \"Duplicate field '\"+name+\"'\");\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Overridden standard methods\n--- a/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java\n     }\n \n     private final void _checkDup(DupDetector dd, String name) throws JsonProcessingException {\n-        if (dd.isDup(name)) { throw new JsonGenerationException(\"Duplicate field '\"+name+\"'\"); }\n+        if (dd.isDup(name)) {\n+            Object src = dd.getSource();\n+            throw new JsonGenerationException(\"Duplicate field '\"+name+\"'\",\n+                    ((src instanceof JsonGenerator) ? ((JsonGenerator) src) : null));\n+        }\n     }\n     \n     public int writeValue() {\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n     @Override\n     public final JsonToken nextToken() throws IOException\n     {\n-        _numTypesValid = NR_UNKNOWN;\n-\n         /* First: field names are special -- we will always tokenize\n          * (part of) value along with field name to simplify\n          * state handling. If so, can and need to use secondary token:\n         if (_currToken == JsonToken.FIELD_NAME) {\n             return _nextAfterName();\n         }\n+        // But if we didn't already have a name, and (partially?) decode number,\n+        // need to ensure no numeric information is leaked\n+        _numTypesValid = NR_UNKNOWN;\n         if (_tokenIncomplete) {\n             _skipString(); // only strings can be partial\n         }\n     /**********************************************************\n      */\n \n-    /*\n+    // Implemented since 2.7\n     @Override\n-    public boolean nextFieldName(SerializableString str)\n-        throws IOException\n-    {\n-    \n-    }\n-    */\n+    public boolean nextFieldName(SerializableString sstr) throws IOException\n+    {\n+        // // // Note: most of code below is copied from nextToken()\n+\n+        _numTypesValid = NR_UNKNOWN;\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+            _nextAfterName();\n+            return false;\n+        }\n+        if (_tokenIncomplete) {\n+            _skipString();\n+        }\n+        int i = _skipWSOrEnd();\n+        if (i < 0) {\n+            close();\n+            _currToken = null;\n+            return false;\n+        }\n+        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n+        _tokenInputRow = _currInputRow;\n+        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n+        _binaryValue = null;\n+        if (i == INT_RBRACKET) {\n+            if (!_parsingContext.inArray()) {\n+                _reportMismatchedEndMarker(i, '}');\n+            }\n+            _parsingContext = _parsingContext.getParent();\n+            _currToken = JsonToken.END_ARRAY;\n+            return false;\n+        }\n+        if (i == INT_RCURLY) {\n+            if (!_parsingContext.inObject()) {\n+                _reportMismatchedEndMarker(i, ']');\n+            }\n+            _parsingContext = _parsingContext.getParent();\n+            _currToken = JsonToken.END_OBJECT;\n+            return false;\n+        }\n+        if (_parsingContext.expectComma()) {\n+            i = _skipComma(i);\n+        }\n+\n+        if (!_parsingContext.inObject()) {\n+            _nextTokenNotInObject(i);\n+            return false;\n+        }\n+\n+        if (i == INT_QUOTE) {\n+            // when doing literal match, must consider escaping:\n+            char[] nameChars = sstr.asQuotedChars();\n+            final int len = nameChars.length;\n+\n+            // Require 4 more bytes for faster skipping of colon that follows name\n+            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n+                // first check length match by\n+                final int end = _inputPtr+len;\n+                if (_inputBuffer[end] == '\"') {\n+                    int offset = 0;\n+                    int ptr = _inputPtr;\n+                    while (true) {\n+                        if (ptr == end) { // yes, match!\n+                            _parsingContext.setCurrentName(sstr.getValue());\n+                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n+                            return true;\n+                        }\n+                        if (nameChars[offset] != _inputBuffer[ptr]) {\n+                            break;\n+                        }\n+                        ++offset;\n+                        ++ptr;\n+                    }\n+                }\n+            }\n+        }\n+        return _isNextTokenNameMaybe(i, sstr.getValue());\n+    }\n \n     @Override\n     public String nextFieldName() throws IOException\n         }\n         _nextToken = t;\n         return name;\n+    }\n+\n+    private final void _isNextTokenNameYes(int i) throws IOException\n+    {\n+        _currToken = JsonToken.FIELD_NAME;\n+\n+        switch (i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            _nextToken = JsonToken.VALUE_STRING;\n+            return;\n+        case '[':\n+            _nextToken = JsonToken.START_ARRAY;\n+            return;\n+        case '{':\n+            _nextToken = JsonToken.START_OBJECT;\n+            return;\n+        case 't':\n+            _matchToken(\"true\", 1);\n+            _nextToken = JsonToken.VALUE_TRUE;\n+            return;\n+        case 'f':\n+            _matchToken(\"false\", 1);\n+            _nextToken = JsonToken.VALUE_FALSE;\n+            return;\n+        case 'n':\n+            _matchToken(\"null\", 1);\n+            _nextToken = JsonToken.VALUE_NULL;\n+            return;\n+        case '-':\n+            _nextToken = _parseNegNumber();\n+            return;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            _nextToken = _parsePosNumber(i);\n+            return;\n+        }\n+        _nextToken = _handleOddValue(i);\n+    }\n+\n+    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n+    {\n+        // // // and this is back to standard nextToken()\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n+        if (i == INT_QUOTE) {\n+            _tokenIncomplete = true;\n+            _nextToken = JsonToken.VALUE_STRING;\n+            return nameToMatch.equals(name);\n+        }\n+        // Ok: we must have a value... what is it?\n+        JsonToken t;\n+        switch (i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+        }\n+        _nextToken = t;\n+        return nameToMatch.equals(name);\n     }\n \n     private final JsonToken _nextTokenNotInObject(int i) throws IOException\n             }\n         }\n     }\n- \n+\n+    // Variant called when we know there's at least 4 more bytes available\n+    private final int _skipColonFast(int ptr) throws IOException\n+    {\n+        int i = (int) _inputBuffer[ptr++];\n+        if (i == INT_COLON) { // common case, no leading space\n+            i = _inputBuffer[ptr++];\n+            if (i > INT_SPACE) { // nor trailing\n+                if (i != INT_SLASH && i != INT_HASH) {\n+                    _inputPtr = ptr;\n+                    return i;\n+                }\n+            } else if (i == INT_SPACE || i == INT_TAB) {\n+                i = (int) _inputBuffer[ptr++];\n+                if (i > INT_SPACE) {\n+                    if (i != INT_SLASH && i != INT_HASH) {\n+                        _inputPtr = ptr;\n+                        return i;\n+                    }\n+                }\n+            }\n+            _inputPtr = ptr-1;\n+            return _skipColon2(true); // true -> skipped colon\n+        }\n+        if (i == INT_SPACE || i == INT_TAB) {\n+            i = _inputBuffer[ptr++];\n+        }\n+        boolean gotColon = (i == INT_COLON);\n+        if (gotColon) {\n+            i = _inputBuffer[ptr++];\n+            if (i > INT_SPACE) {\n+                if (i != INT_SLASH && i != INT_HASH) {\n+                    _inputPtr = ptr;\n+                    return i;\n+                }\n+            } else if (i == INT_SPACE || i == INT_TAB) {\n+                i = (int) _inputBuffer[ptr++];\n+                if (i > INT_SPACE) {\n+                    if (i != INT_SLASH && i != INT_HASH) {\n+                        _inputPtr = ptr;\n+                        return i;\n+                    }\n+                }\n+            }\n+        }\n+        _inputPtr = ptr-1;\n+        return _skipColon2(gotColon);\n+    }\n+    \n     // Primary loop: no reloading, comment handling\n     private final int _skipComma(int i) throws IOException\n     {\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n     @Override\n     public JsonToken nextToken() throws IOException\n     {\n-        _numTypesValid = NR_UNKNOWN;\n         /* First: field names are special -- we will always tokenize\n          * (part of) value along with field name to simplify\n          * state handling. If so, can and need to use secondary token:\n         if (_currToken == JsonToken.FIELD_NAME) {\n             return _nextAfterName();\n         }\n+        // But if we didn't already have a name, and (partially?) decode number,\n+        // need to ensure no numeric information is leaked\n+        _numTypesValid = NR_UNKNOWN;\n         if (_tokenIncomplete) {\n             _skipString(); // only strings can be partial\n         }\n \n     /**\n      * Method called when not even first 8 bytes are guaranteed\n-     * to come consequtively. Happens rarely, so this is offlined;\n+     * to come consecutively. Happens rarely, so this is offlined;\n      * plus we'll also do full checks for escaping etc.\n      */\n     protected String slowParseName() throws IOException\n     /**\n      * Method called when we see non-white space character other\n      * than double quote, when expecting a field name.\n-     * In standard mode will just throw an expection; but\n+     * In standard mode will just throw an exception; but\n      * in non-standard modes may be able to parse name.\n      */\n     protected String _handleOddName(int ch) throws IOException\n--- a/src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java\n      */\n \n     @Override\n-    public void writeRootValueSeparator(JsonGenerator jg)\n-        throws IOException, JsonGenerationException\n+    public void writeRootValueSeparator(JsonGenerator jg) throws IOException\n     {\n         if (_rootSeparator != null) {\n             jg.writeRaw(_rootSeparator);\n     }\n \n     @Override\n-    public void writeStartObject(JsonGenerator jg)\n-        throws IOException, JsonGenerationException\n+    public void writeStartObject(JsonGenerator jg) throws IOException\n     {\n         jg.writeRaw('{');\n         if (!_objectIndenter.isInline()) {\n     }\n \n     @Override\n-    public void beforeObjectEntries(JsonGenerator jg)\n-        throws IOException, JsonGenerationException\n+    public void beforeObjectEntries(JsonGenerator jg) throws IOException\n     {\n         _objectIndenter.writeIndentation(jg, _nesting);\n     }\n      * (white-space) decoration.\n      */\n     @Override\n-    public void writeObjectFieldValueSeparator(JsonGenerator jg)\n-        throws IOException, JsonGenerationException\n+    public void writeObjectFieldValueSeparator(JsonGenerator jg) throws IOException\n     {\n         if (_spacesInObjectEntries) {\n             jg.writeRaw(\" : \");\n      * (white-space) decoration.\n      */\n     @Override\n-    public void writeObjectEntrySeparator(JsonGenerator jg)\n-        throws IOException, JsonGenerationException\n+    public void writeObjectEntrySeparator(JsonGenerator jg) throws IOException\n     {\n         jg.writeRaw(',');\n         _objectIndenter.writeIndentation(jg, _nesting);\n     }\n \n     @Override\n-    public void writeEndObject(JsonGenerator jg, int nrOfEntries)\n-        throws IOException, JsonGenerationException\n+    public void writeEndObject(JsonGenerator jg, int nrOfEntries) throws IOException\n     {\n         if (!_objectIndenter.isInline()) {\n             --_nesting;\n     }\n \n     @Override\n-    public void writeStartArray(JsonGenerator jg)\n-        throws IOException, JsonGenerationException\n+    public void writeStartArray(JsonGenerator jg) throws IOException\n     {\n         if (!_arrayIndenter.isInline()) {\n             ++_nesting;\n     }\n \n     @Override\n-    public void beforeArrayValues(JsonGenerator jg)\n-        throws IOException, JsonGenerationException\n-    {\n+    public void beforeArrayValues(JsonGenerator jg) throws IOException {\n         _arrayIndenter.writeIndentation(jg, _nesting);\n     }\n \n         @Override\n         public boolean isInline() { return true; }\n     }\n-    \n-    /**\n-     * @deprecated Since 2.5 use {@link DefaultIndenter} instead\n-     */\n-    @Deprecated\n-    public static class Lf2SpacesIndenter extends DefaultIndenter\n-    {\n-        /** @deprecated Use {@link DefaultIndenter#SYSTEM_LINEFEED_INSTANCE} instead.\n-         */\n-        @SuppressWarnings(\"hiding\")\n-        @Deprecated\n-        public static final Lf2SpacesIndenter instance = new Lf2SpacesIndenter();\n-\n-        /** @deprecated Use {@code new DefaultIndenter(\"  \", DefaultIndenter.SYS_LF)} instead\n-         */\n-        @Deprecated\n-        public Lf2SpacesIndenter() {\n-            super(\"  \", DefaultIndenter.SYS_LF);\n-        }\n-        \n-        /** @deprecated Use {@code new DefaultIndenter(\"  \", lf)} instead\n-         */\n-        @Deprecated\n-        public Lf2SpacesIndenter(String lf) {\n-            super(\"  \", lf);\n-        }\n-\n-        /**\n-         * Note: method was accidentally missing from 2.5.0; put back for 2.5.1 and\n-         * later 2.5.x versions.\n-         */\n-        @Override\n-        public Lf2SpacesIndenter withLinefeed(String lf) {\n-            if (lf.equals(getEol())) {\n-                return this;\n-            }\n-            return new Lf2SpacesIndenter(lf);\n-        }\n-    }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n     public int getFeatureMask() { return delegate.getFeatureMask(); }\n \n     @Override\n+    @Deprecated\n     public JsonGenerator setFeatureMask(int mask) {\n         delegate.setFeatureMask(mask);\n+        return this;\n+    }\n+\n+    @Override\n+    public JsonGenerator overrideStdFeatures(int values, int mask) {\n+        delegate.overrideStdFeatures(values, mask);\n+        return this;\n+    }\n+\n+    @Override\n+    public JsonGenerator overrideFormatFeatures(int values, int mask) {\n+        delegate.overrideFormatFeatures(values, mask);\n         return this;\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/core/util/JsonParserDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonParserDelegate.java\n     @Override public int getFeatureMask() { return delegate.getFeatureMask(); }\n \n     @Override\n+    @Deprecated // since 2.7\n     public JsonParser setFeatureMask(int mask) {\n         delegate.setFeatureMask(mask);\n+        return this;\n+    }\n+\n+    @Override\n+    public JsonParser overrideStdFeatures(int values, int mask) {\n+        delegate.overrideStdFeatures(values, mask);\n+        return this;\n+    }\n+\n+    @Override\n+    public JsonParser overrideFormatFeatures(int values, int mask) {\n+        delegate.overrideFormatFeatures(values, mask);\n         return this;\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/core/TestExceptions.java\n+++ b/src/test/java/com/fasterxml/jackson/core/TestExceptions.java\n package com.fasterxml.jackson.core;\n \n+import java.io.StringWriter;\n \n public class TestExceptions extends BaseTest\n {\n-    // For [Issue#10]\n+    private final JsonFactory JSON_F = new JsonFactory();\n+    \n+    // For [core#10]\n     public void testOriginalMesssage()\n     {\n-        JsonProcessingException exc = new JsonParseException(\"Foobar\", JsonLocation.NA);\n+        JsonProcessingException exc = new JsonParseException(null, \"Foobar\", JsonLocation.NA);\n         String msg = exc.getMessage();\n         String orig = exc.getOriginalMessage();\n         assertEquals(\"Foobar\", orig);\n         assertTrue(msg.length() > orig.length());\n     }\n+\n+    // [core#198]\n+    public void testAccessToParser() throws Exception\n+    {\n+        JsonParser p = JSON_F.createParser(\"{}\");\n+        assertToken(JsonToken.START_OBJECT, p.nextToken());\n+        JsonParseException e = new JsonParseException(p, \"Test!\");\n+        assertSame(p, e.getProcessor());\n+        assertEquals(\"Test!\", e.getOriginalMessage());\n+        JsonLocation loc = e.getLocation();\n+        assertNotNull(loc);\n+        assertEquals(2, loc.getColumnNr());\n+        assertEquals(1, loc.getLineNr());\n+        p.close();\n+    }\n+\n+    // [core#198]\n+    public void testAccessToGenerator() throws Exception\n+    {\n+        StringWriter w = new StringWriter();\n+        JsonGenerator g = JSON_F.createGenerator(w);\n+        g.writeStartObject();\n+        JsonGenerationException e = new JsonGenerationException(\"Test!\", g);\n+        assertSame(g, e.getProcessor());\n+        assertEquals(\"Test!\", e.getOriginalMessage());\n+        g.close();\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestNextXxx.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestNextXxx.java\n     {\n         _testIsNextTokenName1(false);\n         _testIsNextTokenName1(true);\n+    }\n+\n+    public void testIsNextTokenName2() throws Exception {\n         _testIsNextTokenName2(false);\n         _testIsNextTokenName2(true);\n+    }        \n+    \n+    public void testIsNextTokenName3() throws Exception {\n         _testIsNextTokenName3(false);\n         _testIsNextTokenName3(true);\n     }\n \n+    public void testIsNextTokenName4() throws Exception {\n+        _testIsNextTokenName4(false);\n+        _testIsNextTokenName4(true);\n+    }\n+    \n     // [jackson-core#34]\n     public void testIssue34() throws Exception\n     {\n         assertToken(JsonToken.FIELD_NAME, jp.getCurrentToken());\n         assertEquals(\"name2\", jp.getCurrentName());\n         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        // do NOT check number value, to enforce skipping\n \n         assertFalse(jp.nextFieldName(NAME));\n         assertToken(JsonToken.FIELD_NAME, jp.getCurrentToken());\n         p.close();\n     }\n \n+    private void _testIsNextTokenName4(boolean useStream) throws Exception\n+    {\n+        final String DOC = \"{\\\"name\\\":-123,\\\"name2\\\":99}\";\n+        JsonParser jp = useStream ?\n+                JSON_F.createParser(new ByteArrayInputStream(DOC.getBytes(\"UTF-8\")))\n+            : JSON_F.createParser(new StringReader(DOC));\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+\n+        assertTrue(jp.nextFieldName(new SerializedString(\"name\")));\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(-123, jp.getIntValue());\n+\n+        assertTrue(jp.nextFieldName(new SerializedString(\"name2\")));\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(99, jp.getIntValue());\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+        assertNull(jp.nextToken());\n+\n+        jp.close();\n+    }\n+\n     private void _testNextFieldNameIndent(boolean useStream) throws Exception\n     {\n         final String DOC = \"{\\n  \\\"name\\\" : \\n  [\\n  ]\\n   }\";\n \n         p.close();\n     }\n-    \n+\n     private void _textNextText(boolean useStream) throws Exception\n     {\n         final String DOC = aposToQuotes(\"{'a':'123','b':5,'c':[false,'foo']}\");\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestNumericValues.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestNumericValues.java\n             }\n             sb.append(segment);\n             sb.append('\\n');\n-            // let's add somewhat arbitray number of spaces\n+            // let's add somewhat arbitrary number of spaces\n             int x = (i & 3);\n             if (i > 300) {\n                 x += i % 5;\n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n         assertEquals(6, symbols.maxCollisionLength());\n     }\n \n-    // Test for verifying stability of hashCode, wrt collisions, using\n-    // synthetic field name generation and byte-based input (UTF-8)\n-    @SuppressWarnings(\"deprecation\")\n-    public void testSyntheticWithBytesOld() throws IOException\n-    {\n-        // pass seed, to keep results consistent:\n-        final int SEED = 33333;\n-        BytesToNameCanonicalizer symbols =\n-                BytesToNameCanonicalizer.createRoot(SEED).makeChild(JsonFactory.Feature.collectDefaults());\n-\n-        final int COUNT = 12000;\n-        for (int i = 0; i < COUNT; ++i) {\n-            String id = fieldNameFor(i);\n-            int[] quads = calcQuads(id.getBytes(\"UTF-8\"));\n-            symbols.addName(id, quads, quads.length);\n-        }\n-        assertEquals(COUNT, symbols.size());\n-        assertEquals(16384, symbols.bucketCount());\n-\n-//System.out.printf(\"Byte stuff: collisions %d, max-coll %d\\n\", symbols.collisionCount(), symbols.maxCollisionLength());\n-        assertEquals(3476, symbols.collisionCount());\n-        // longest collision chain not optimal but ok:\n-        assertEquals(15, symbols.maxCollisionLength());\n-\n-        // But also verify entries are actually found?\n-    }\n-\n     public void testSyntheticWithBytesNew() throws IOException\n     {\n         // pass seed, to keep results consistent:\n         }\n     }\n \n-    @SuppressWarnings(\"deprecation\")\n-    public void testThousandsOfSymbolsWithOldBytes() throws IOException\n-    {\n-        final int SEED = 33333;\n-\n-        BytesToNameCanonicalizer symbolsBRoot = BytesToNameCanonicalizer.createRoot(SEED);\n-        final Charset utf8 = Charset.forName(\"UTF-8\");\n-        int exp = 0;\n-        \n-        for (int doc = 0; doc < 100; ++doc) {\n-            BytesToNameCanonicalizer symbolsB =\n-                    symbolsBRoot.makeChild(JsonFactory.Feature.collectDefaults());\n-            for (int i = 0; i < 250; ++i) {\n-                String name = \"f_\"+doc+\"_\"+i;\n-\n-                int[] quads = BytesToNameCanonicalizer.calcQuads(name.getBytes(utf8));\n-                symbolsB.addName(name, quads, quads.length);\n-                Name n = symbolsB.findName(quads, quads.length);\n-                assertEquals(name, n.getName());\n-            }\n-            symbolsB.release();\n-            exp += 250;\n-            if (exp > BytesToNameCanonicalizer.MAX_ENTRIES_FOR_REUSE) {\n-                exp = 0;\n-            }\n-            assertEquals(exp, symbolsBRoot.size());\n-        }\n-    }\n-\n     // Since 2.6\n     public void testThousandsOfSymbolsWithNew() throws IOException\n     {\n         Field syms = p.getClass().getDeclaredField(\"_symbols\");\n         syms.setAccessible(true);\n         return ((ByteQuadsCanonicalizer) syms.get(p));\n-    }\n-\n-    // [core#187]: unexpectedly high number of collisions for straight numbers\n-    @SuppressWarnings(\"deprecation\")\n-    public void testCollisionsWithBytes187() throws IOException\n-    {\n-        BytesToNameCanonicalizer symbols =\n-                BytesToNameCanonicalizer.createRoot(1).makeChild(JsonFactory.Feature.collectDefaults());\n-        final int COUNT = 30000;\n-        for (int i = 0; i < COUNT; ++i) {\n-            String id = String.valueOf(10000 + i);\n-            int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\"));\n-            symbols.addName(id, quads, quads.length);\n-        }\n-\n-//System.out.printf(\"Byte stuff: collisions %d, max-coll %d\\n\", symbols.collisionCount(), symbols.maxCollisionLength());\n-        \n-        assertEquals(COUNT, symbols.size());\n-        assertEquals(65536, symbols.bucketCount());\n-\n-        // collision count acceptable\n-        assertEquals(5782, symbols.collisionCount());\n-        // as well as collision counts\n-        assertEquals(24, symbols.maxCollisionLength());\n     }\n \n     // [core#187]: unexpectedly high number of collisions for straight numbers\n         assertEquals(2, symbols.maxCollisionLength());\n     }\n \n-    @SuppressWarnings(\"deprecation\")\n-    public void testShortQuotedDirectBytesOld() throws IOException\n-    {\n-        final int COUNT = 400;\n-        BytesToNameCanonicalizer symbols =\n-                BytesToNameCanonicalizer.createRoot(1).makeChild(JsonFactory.Feature.collectDefaults());\n-        for (int i = 0; i < COUNT; ++i) {\n-            String id = String.format(\"\\\\u%04x\", i);\n-            int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\"));\n-            symbols.addName(id, quads, quads.length);\n-        }\n-        assertEquals(COUNT, symbols.size());\n-        assertEquals(1024, symbols.bucketCount());\n-\n-        assertEquals(44, symbols.collisionCount());\n-        assertEquals(2, symbols.maxCollisionLength());\n-    }\n-\n     public void testShortQuotedDirectBytes() throws IOException\n     {\n         final int COUNT = 400;\n     }\n     \n     // [core#191]\n-    @SuppressWarnings(\"deprecation\")\n     public void testShortNameCollisionsDirect() throws IOException\n     {\n         final int COUNT = 600;\n             assertEquals(1024, symbols.bucketCount());\n     \n             assertEquals(16, symbols.collisionCount());\n-            assertEquals(1, symbols.maxCollisionLength());\n-        }\n-        \n-        // then byte-based\n-        {\n-            BytesToNameCanonicalizer symbols =\n-                    BytesToNameCanonicalizer.createRoot(1).makeChild(JsonFactory.Feature.collectDefaults());\n-            for (int i = 0; i < COUNT; ++i) {\n-                String id = String.valueOf((char) i);\n-                int[] quads = calcQuads(id.getBytes(\"UTF-8\"));\n-                symbols.addName(id, quads, quads.length);\n-            }\n-            assertEquals(COUNT, symbols.size());\n-            assertEquals(1024, symbols.bucketCount());\n-    \n-            assertEquals(209, symbols.collisionCount());\n             assertEquals(1, symbols.maxCollisionLength());\n         }\n     }\n--- a/src/test/java/com/fasterxml/jackson/core/util/TestNumberPrinting.java\n+++ b/src/test/java/com/fasterxml/jackson/core/util/TestNumberPrinting.java\n \n /**\n  * Set of basic unit tests for verifying that the low-level number\n- * printingg methods work as expected.\n+ * printing methods work as expected.\n  */\n public class TestNumberPrinting\n     extends com.fasterxml.jackson.core.BaseTest", "timestamp": 1447459851, "metainfo": ""}