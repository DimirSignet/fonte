{"sha": "fedd7950785eb43e4c6a815a44cbd0d8c34adc2c", "log": "Minor trimming", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/io/CharTypes.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/CharTypes.java\n \n public final class CharTypes\n {\n-    private final static char[] HEX_CHARS = \"0123456789ABCDEF\".toCharArray();\n-    private final static byte[] HEX_BYTES;\n-    static {\n-        int len = HEX_CHARS.length;\n-        HEX_BYTES = new byte[len];\n+    private final static char[] HC = \"0123456789ABCDEF\".toCharArray();\n+    private final static byte[] HB;\n+    static {\n+        int len = HC.length;\n+        HB = new byte[len];\n         for (int i = 0; i < len; ++i) {\n-            HEX_BYTES[i] = (byte) HEX_CHARS[i];\n+            HB[i] = (byte) HC[i];\n         }\n     }\n \n                 sb.append('0');\n                 sb.append('0');\n                 int value = c;  // widening\n-                sb.append(HEX_CHARS[value >> 4]);\n-                sb.append(HEX_CHARS[value & 0xF]);\n+                sb.append(HC[value >> 4]);\n+                sb.append(HC[value & 0xF]);\n             } else { // \"named\", i.e. prepend with slash\n                 sb.append((char) escCode);\n             }\n         }\n     }\n \n-    public static char[] copyHexChars()\n-    {\n-        return (char[]) HEX_CHARS.clone();\n-    }\n-\n-    public static byte[] copyHexBytes()\n-    {\n-        return (byte[]) HEX_BYTES.clone();\n+    public static char[] copyHexChars() {\n+        return (char[]) HC.clone();\n+    }\n+\n+    public static byte[] copyHexBytes() {\n+        return (byte[]) HB.clone();\n     }\n }\n \n--- a/src/main/java/com/fasterxml/jackson/core/io/CharacterEscapes.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/CharacterEscapes.java\n  * escaping aspects for String values, for formats that use escaping.\n  * For JSON this applies to both property names and String values.\n  */\n+@SuppressWarnings(\"serial\")\n public abstract class CharacterEscapes\n     implements java.io.Serializable // since 2.1\n {\n-    private static final long serialVersionUID = 1L;\n-\n     /**\n      * Value used for lookup tables to indicate that matching characters\n      * do not need to be escaped.\n--- a/src/main/java/com/fasterxml/jackson/core/io/JsonStringEncoder.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/JsonStringEncoder.java\n  */\n public final class JsonStringEncoder\n {\n-    private final static char[] HEX_CHARS = CharTypes.copyHexChars();\n-\n-    private final static byte[] HEX_BYTES = CharTypes.copyHexBytes();\n+    private final static char[] HC = CharTypes.copyHexChars();\n+\n+    private final static byte[] HB = CharTypes.copyHexBytes();\n \n     private final static int SURR1_FIRST = 0xD800;\n     private final static int SURR1_LAST = 0xDBFF;\n      * Lazily constructed text buffer used to produce JSON encoded Strings\n      * as characters (without UTF-8 encoding)\n      */\n-    protected TextBuffer _textBuffer;\n+    protected TextBuffer _text;\n \n     /**\n      * Lazily-constructed builder used for UTF-8 encoding of text values\n      * (quoted and unquoted)\n      */\n-    protected ByteArrayBuilder _byteBuilder;\n+    protected ByteArrayBuilder _bytes;\n     \n     /**\n      * Temporary buffer used for composing quote/escape sequences\n      */\n-    protected final char[] _quoteBuffer;\n+    protected final char[] _qbuf;\n     \n     /*\n     /**********************************************************\n      */\n     \n     public JsonStringEncoder() {\n-        _quoteBuffer = new char[6];\n-        _quoteBuffer[0] = '\\\\';\n-        _quoteBuffer[2] = '0';\n-        _quoteBuffer[3] = '0';\n+        _qbuf = new char[6];\n+        _qbuf[0] = '\\\\';\n+        _qbuf[2] = '0';\n+        _qbuf[3] = '0';\n     }\n     \n     /**\n      */\n     public char[] quoteAsString(String input)\n     {\n-        TextBuffer textBuffer = _textBuffer;\n+        TextBuffer textBuffer = _text;\n         if (textBuffer == null) {\n             // no allocator; can add if we must, shouldn't need to\n-            _textBuffer = textBuffer = new TextBuffer(null);\n+            _text = textBuffer = new TextBuffer(null);\n         }\n         char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n         final int[] escCodes = CharTypes.get7BitOutputEscapes();\n         final int inputLen = input.length();\n         int outPtr = 0;\n  \n-        outer_loop:\n+        outer:\n         while (inPtr < inputLen) {\n             tight_loop:\n             while (true) {\n                 }\n                 outputBuffer[outPtr++] = c;\n                 if (++inPtr >= inputLen) {\n-                    break outer_loop;\n+                    break outer;\n                 }\n             }\n             // something to escape; 2 or 6-char variant? \n             char d = input.charAt(inPtr++);\n             int escCode = escCodes[d];\n             int length = (escCode < 0)\n-                    ? _appendNumericEscape(d, _quoteBuffer)\n-                    : _appendNamedEscape(escCode, _quoteBuffer);\n+                    ? _appendNumeric(d, _qbuf)\n+                    : _appendNamed(escCode, _qbuf);\n                     ;\n             if ((outPtr + length) > outputBuffer.length) {\n                 int first = outputBuffer.length - outPtr;\n                 if (first > 0) {\n-                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n+                    System.arraycopy(_qbuf, 0, outputBuffer, outPtr, first);\n                 }\n                 outputBuffer = textBuffer.finishCurrentSegment();\n                 int second = length - first;\n-                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n+                System.arraycopy(_qbuf, first, outputBuffer, 0, second);\n                 outPtr = second;\n             } else {\n-                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n+                System.arraycopy(_qbuf, 0, outputBuffer, outPtr, length);\n                 outPtr += length;\n             }\n         }\n     @SuppressWarnings(\"resource\")\n     public byte[] quoteAsUTF8(String text)\n     {\n-        ByteArrayBuilder byteBuilder = _byteBuilder;\n-        if (byteBuilder == null) {\n+        ByteArrayBuilder bb = _bytes;\n+        if (bb == null) {\n             // no allocator; can add if we must, shouldn't need to\n-            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n+            _bytes = bb = new ByteArrayBuilder(null);\n         }\n         int inputPtr = 0;\n         int inputEnd = text.length();\n         int outputPtr = 0;\n-        byte[] outputBuffer = byteBuilder.resetAndGetFirstSegment();\n+        byte[] outputBuffer = bb.resetAndGetFirstSegment();\n         \n-        main_loop:\n+        main:\n         while (inputPtr < inputEnd) {\n             final int[] escCodes = CharTypes.get7BitOutputEscapes();\n \n                     break inner_loop;\n                 }\n                 if (outputPtr >= outputBuffer.length) {\n-                    outputBuffer = byteBuilder.finishCurrentSegment();\n+                    outputBuffer = bb.finishCurrentSegment();\n                     outputPtr = 0;\n                 }\n                 outputBuffer[outputPtr++] = (byte) ch;\n                 if (++inputPtr >= inputEnd) {\n-                    break main_loop;\n+                    break main;\n                 }\n             }                \n             if (outputPtr >= outputBuffer.length) {\n-                outputBuffer = byteBuilder.finishCurrentSegment();\n+                outputBuffer = bb.finishCurrentSegment();\n                 outputPtr = 0;\n             }\n             // Ok, so what did we hit?\n             if (ch <= 0x7F) { // needs quoting\n                 int escape = escCodes[ch];\n                 // ctrl-char, 6-byte escape...\n-                outputPtr = _appendByteEscape(ch, escape, byteBuilder, outputPtr);\n-                outputBuffer = byteBuilder.getCurrentSegment();\n-                continue main_loop;\n-            } else if (ch <= 0x7FF) { // fine, just needs 2 byte output\n+                outputPtr = _appendByte(ch, escape, bb, outputPtr);\n+                outputBuffer = bb.getCurrentSegment();\n+                continue main;\n+            }\n+            if (ch <= 0x7FF) { // fine, just needs 2 byte output\n                 outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6));\n                 ch = (0x80 | (ch & 0x3f));\n             } else { // 3 or 4 bytes\n                 if (ch < SURR1_FIRST || ch > SURR2_LAST) { // nope\n                     outputBuffer[outputPtr++] = (byte) (0xe0 | (ch >> 12));\n                     if (outputPtr >= outputBuffer.length) {\n-                        outputBuffer = byteBuilder.finishCurrentSegment();\n+                        outputBuffer = bb.finishCurrentSegment();\n                         outputPtr = 0;\n                     }\n                     outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                     ch = (0x80 | (ch & 0x3f));\n                 } else { // yes, surrogate pair\n                     if (ch > SURR1_LAST) { // must be from first range\n-                        _illegalSurrogate(ch);\n+                        _illegal(ch);\n                     }\n                     // and if so, followed by another from next range\n                     if (inputPtr >= inputEnd) {\n-                        _illegalSurrogate(ch);\n-                    }\n-                    ch = _convertSurrogate(ch, text.charAt(inputPtr++));\n+                        _illegal(ch);\n+                    }\n+                    ch = _convert(ch, text.charAt(inputPtr++));\n                     if (ch > 0x10FFFF) { // illegal, as per RFC 4627\n-                        _illegalSurrogate(ch);\n+                        _illegal(ch);\n                     }\n                     outputBuffer[outputPtr++] = (byte) (0xf0 | (ch >> 18));\n                     if (outputPtr >= outputBuffer.length) {\n-                        outputBuffer = byteBuilder.finishCurrentSegment();\n+                        outputBuffer = bb.finishCurrentSegment();\n                         outputPtr = 0;\n                     }\n                     outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 12) & 0x3f));\n                     if (outputPtr >= outputBuffer.length) {\n-                        outputBuffer = byteBuilder.finishCurrentSegment();\n+                        outputBuffer = bb.finishCurrentSegment();\n                         outputPtr = 0;\n                     }\n                     outputBuffer[outputPtr++] = (byte) (0x80 | ((ch >> 6) & 0x3f));\n                 }\n             }\n             if (outputPtr >= outputBuffer.length) {\n-                outputBuffer = byteBuilder.finishCurrentSegment();\n+                outputBuffer = bb.finishCurrentSegment();\n                 outputPtr = 0;\n             }\n             outputBuffer[outputPtr++] = (byte) ch;\n         }\n-        return _byteBuilder.completeAndCoalesce(outputPtr);\n+        return _bytes.completeAndCoalesce(outputPtr);\n     }\n     \n     /**\n     @SuppressWarnings(\"resource\")\n     public byte[] encodeAsUTF8(String text)\n     {\n-        ByteArrayBuilder byteBuilder = _byteBuilder;\n+        ByteArrayBuilder byteBuilder = _bytes;\n         if (byteBuilder == null) {\n             // no allocator; can add if we must, shouldn't need to\n-            _byteBuilder = byteBuilder = new ByteArrayBuilder(null);\n+            _bytes = byteBuilder = new ByteArrayBuilder(null);\n         }\n         int inputPtr = 0;\n         int inputEnd = text.length();\n                     outputBuffer[outputPtr++] = (byte) (0x80 | ((c >> 6) & 0x3f));\n                 } else { // yes, surrogate pair\n                     if (c > SURR1_LAST) { // must be from first range\n-                        _illegalSurrogate(c);\n+                        _illegal(c);\n                     }\n                     // and if so, followed by another from next range\n                     if (inputPtr >= inputEnd) {\n-                        _illegalSurrogate(c);\n-                    }\n-                    c = _convertSurrogate(c, text.charAt(inputPtr++));\n+                        _illegal(c);\n+                    }\n+                    c = _convert(c, text.charAt(inputPtr++));\n                     if (c > 0x10FFFF) { // illegal, as per RFC 4627\n-                        _illegalSurrogate(c);\n+                        _illegal(c);\n                     }\n                     outputBuffer[outputPtr++] = (byte) (0xf0 | (c >> 18));\n                     if (outputPtr >= outputEnd) {\n             }\n             outputBuffer[outputPtr++] = (byte) (0x80 | (c & 0x3f));\n         }\n-        return _byteBuilder.completeAndCoalesce(outputPtr);\n+        return _bytes.completeAndCoalesce(outputPtr);\n     }\n     \n     /*\n     /**********************************************************\n      */\n \n-    private int _appendNumericEscape(int value, char[] quoteBuffer) {\n-        quoteBuffer[1] = 'u';\n+    private int _appendNumeric(int value, char[] qbuf) {\n+        qbuf[1] = 'u';\n         // We know it's a control char, so only the last 2 chars are non-0\n-        quoteBuffer[4] = HEX_CHARS[value >> 4];\n-        quoteBuffer[5] = HEX_CHARS[value & 0xF];\n+        qbuf[4] = HC[value >> 4];\n+        qbuf[5] = HC[value & 0xF];\n         return 6;\n     }\n \n-    private int _appendNamedEscape(int escCode, char[] quoteBuffer) {\n-        quoteBuffer[1] = (char) escCode;\n+    private int _appendNamed(int esc, char[] qbuf) {\n+        qbuf[1] = (char) esc;\n         return 2;\n     }\n \n-    private int _appendByteEscape(int ch, int escCode, ByteArrayBuilder byteBuilder, int ptr)\n+    private int _appendByte(int ch, int esc, ByteArrayBuilder bb, int ptr)\n     {\n-        byteBuilder.setCurrentSegmentLength(ptr);\n-        byteBuilder.append('\\\\');\n-        if (escCode < 0) { // standard escape\n-            byteBuilder.append('u');\n+        bb.setCurrentSegmentLength(ptr);\n+        bb.append('\\\\');\n+        if (esc < 0) { // standard escape\n+            bb.append('u');\n             if (ch > 0xFF) {\n                 int hi = (ch >> 8);\n-                byteBuilder.append(HEX_BYTES[hi >> 4]);\n-                byteBuilder.append(HEX_BYTES[hi & 0xF]);\n+                bb.append(HB[hi >> 4]);\n+                bb.append(HB[hi & 0xF]);\n                 ch &= 0xFF;\n             } else {\n-                byteBuilder.append('0');\n-                byteBuilder.append('0');\n-            }\n-            byteBuilder.append(HEX_BYTES[ch >> 4]);\n-            byteBuilder.append(HEX_BYTES[ch & 0xF]);\n+                bb.append('0');\n+                bb.append('0');\n+            }\n+            bb.append(HB[ch >> 4]);\n+            bb.append(HB[ch & 0xF]);\n         } else { // 2-char simple escape\n-            byteBuilder.append((byte) escCode);\n-        }\n-        return byteBuilder.getCurrentSegmentLength();\n-    }\n-\n-    protected static int _convertSurrogate(int firstPart, int secondPart) {\n+            bb.append((byte) esc);\n+        }\n+        return bb.getCurrentSegmentLength();\n+    }\n+\n+    private static int _convert(int p1, int p2) {\n         // Ok, then, is the second part valid?\n-        if (secondPart < SURR2_FIRST || secondPart > SURR2_LAST) {\n-            throw new IllegalArgumentException(\"Broken surrogate pair: first char 0x\"+Integer.toHexString(firstPart)+\", second 0x\"+Integer.toHexString(secondPart)+\"; illegal combination\");\n-        }\n-        return 0x10000 + ((firstPart - SURR1_FIRST) << 10) + (secondPart - SURR2_FIRST);\n-    }\n-\n-    protected static void _illegalSurrogate(int code) {\n-        throw new IllegalArgumentException(UTF8Writer.illegalSurrogateDesc(code));\n+        if (p2 < SURR2_FIRST || p2 > SURR2_LAST) {\n+            throw new IllegalArgumentException(\"Broken surrogate pair: first char 0x\"+Integer.toHexString(p1)+\", second 0x\"+Integer.toHexString(p2)+\"; illegal combination\");\n+        }\n+        return 0x10000 + ((p1 - SURR1_FIRST) << 10) + (p2 - SURR2_FIRST);\n+    }\n+\n+    private static void _illegal(int c) {\n+        throw new IllegalArgumentException(UTF8Writer.illegalSurrogateDesc(c));\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/io/MergedStream.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/MergedStream.java\n  * This is similar to {@link java.io.PushbackInputStream}, but here there's\n  * only one implicit pushback, when instance is constructed.\n  */\n-public final class MergedStream\n-    extends InputStream\n+public final class MergedStream extends InputStream\n {\n-    final protected IOContext _context;\n+    final private IOContext _ctxt;\n \n-    final InputStream _in;\n+    final private InputStream _in;\n \n-    byte[] _buffer;\n+    private byte[] _b;\n \n-    int _ptr;\n+    private int _ptr;\n \n-    final int _end;\n+    final private int _end;\n \n-    public MergedStream(IOContext context,\n-            InputStream in, byte[] buf, int start, int end)\n-    {\n-        _context = context;\n+    public MergedStream(IOContext ctxt, InputStream in, byte[] buf, int start, int end) {\n+        _ctxt = ctxt;\n         _in = in;\n-        _buffer = buf;\n+        _b = buf;\n         _ptr = start;\n         _end = end;\n     }\n \n     @Override\n-    public int available() throws IOException\n-    {\n-        if (_buffer != null) {\n+    public int available() throws IOException {\n+        if (_b != null) {\n             return _end - _ptr;\n         }\n         return _in.available();\n     }\n \n-    @Override\n-    public void close() throws IOException\n-    {\n-        freeMergedBuffer();\n+    @Override public void close() throws IOException {\n+        _free();\n         _in.close();\n     }\n \n-    @Override\n-    public void mark(int readlimit)\n-    {\n-        if (_buffer == null) {\n-            _in.mark(readlimit);\n-        }\n+    @Override public void mark(int readlimit) {\n+        if (_b == null) { _in.mark(readlimit); }\n     }\n     \n-    @Override\n-    public boolean markSupported()\n-    {\n+    @Override public boolean markSupported() {\n         // Only supports marks past the initial rewindable section...\n-        return (_buffer == null) && _in.markSupported();\n+        return (_b == null) && _in.markSupported();\n     }\n     \n-    @Override\n-    public int read() throws IOException\n-    {\n-        if (_buffer != null) {\n-            int c = _buffer[_ptr++] & 0xFF;\n+    @Override public int read() throws IOException {\n+        if (_b != null) {\n+            int c = _b[_ptr++] & 0xFF;\n             if (_ptr >= _end) {\n-                freeMergedBuffer();\n+                _free();\n             }\n             return c;\n         }\n         return _in.read();\n     }\n     \n-    @Override\n-    public int read(byte[] b) throws IOException\n-    {\n+    @Override public int read(byte[] b) throws IOException {\n         return read(b, 0, b.length);\n     }\n \n     @Override\n-    public int \tread(byte[] b, int off, int len) throws IOException\n-    {\n-        if (_buffer != null) {\n+    public int read(byte[] b, int off, int len) throws IOException {\n+        if (_b != null) {\n             int avail = _end - _ptr;\n             if (len > avail) {\n                 len = avail;\n             }\n-            System.arraycopy(_buffer, _ptr, b, off, len);\n+            System.arraycopy(_b, _ptr, b, off, len);\n             _ptr += len;\n             if (_ptr >= _end) {\n-                freeMergedBuffer();\n+                _free();\n             }\n             return len;\n         }\n     }\n \n     @Override\n-    public void reset() throws IOException\n-    {\n-        if (_buffer == null) {\n-            _in.reset();\n-        }\n+    public void reset() throws IOException {\n+        if (_b == null) { _in.reset(); }\n     }\n \n     @Override\n-    public long skip(long n) throws IOException\n-    {\n+    public long skip(long n) throws IOException {\n         long count = 0L;\n \n-        if (_buffer != null) {\n+        if (_b != null) {\n             int amount = _end - _ptr;\n \n             if (amount > n) { // all in pushed back segment?\n                 _ptr += (int) n;\n                 return n;\n             }\n-            freeMergedBuffer();\n+            _free();\n             count += amount;\n             n -= amount;\n         }\n \n-        if (n > 0) {\n-            count += _in.skip(n);\n-        }\n+        if (n > 0) { count += _in.skip(n); }\n         return count;\n     }\n \n-    private void freeMergedBuffer()\n-    {\n-        byte[] buf = _buffer;\n+    private void _free() {\n+        byte[] buf = _b;\n         if (buf != null) {\n-            _buffer = null;\n-            if (_context != null) {\n-                _context.releaseReadIOBuffer(buf);\n+            _b = null;\n+            if (_ctxt != null) {\n+                _ctxt.releaseReadIOBuffer(buf);\n             }\n         }\n     }\n--- a/src/main/java/com/fasterxml/jackson/core/io/NumberInput.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/NumberInput.java\n      *<p>\n      * Note: public to let unit tests call it\n      */\n-    public static int parseInt(char[] digitChars, int offset, int len)\n-    {\n-        int num = digitChars[offset] - '0';\n-        len += offset;\n+    public static int parseInt(char[] ch, int off, int len)\n+    {\n+        int num = ch[off] - '0';\n+        len += off;\n         // This looks ugly, but appears the fastest way (as per measurements)\n-        if (++offset < len) {\n-            num = (num * 10) + (digitChars[offset] - '0');\n-            if (++offset < len) {\n-                num = (num * 10) + (digitChars[offset] - '0');\n-                if (++offset < len) {\n-                    num = (num * 10) + (digitChars[offset] - '0');\n-                    if (++offset < len) {\n-                        num = (num * 10) + (digitChars[offset] - '0');\n-                        if (++offset < len) {\n-                            num = (num * 10) + (digitChars[offset] - '0');\n-                            if (++offset < len) {\n-                                num = (num * 10) + (digitChars[offset] - '0');\n-                                if (++offset < len) {\n-                                    num = (num * 10) + (digitChars[offset] - '0');\n-                                    if (++offset < len) {\n-                                        num = (num * 10) + (digitChars[offset] - '0');\n+        if (++off < len) {\n+            num = (num * 10) + (ch[off] - '0');\n+            if (++off < len) {\n+                num = (num * 10) + (ch[off] - '0');\n+                if (++off < len) {\n+                    num = (num * 10) + (ch[off] - '0');\n+                    if (++off < len) {\n+                        num = (num * 10) + (ch[off] - '0');\n+                        if (++off < len) {\n+                            num = (num * 10) + (ch[off] - '0');\n+                            if (++off < len) {\n+                                num = (num * 10) + (ch[off] - '0');\n+                                if (++off < len) {\n+                                    num = (num * 10) + (ch[off] - '0');\n+                                    if (++off < len) {\n+                                        num = (num * 10) + (ch[off] - '0');\n                                     }\n                                 }\n                             }\n      * Helper method to (more) efficiently parse integer numbers from\n      * String values.\n      */\n-    public static int parseInt(String str)\n+    public static int parseInt(String s)\n     {\n         /* Ok: let's keep strategy simple: ignoring optional minus sign,\n          * we'll accept 1 - 9 digits and parse things efficiently;\n          * otherwise just defer to JDK parse functionality.\n          */\n-        char c = str.charAt(0);\n-        int length = str.length();\n-        boolean negative = (c == '-');\n+        char c = s.charAt(0);\n+        int len = s.length();\n+        boolean neg = (c == '-');\n         int offset = 1;\n         // must have 1 - 9 digits after optional sign:\n         // negative?\n-        if (negative) {\n-            if (length == 1 || length > 10) {\n-                return Integer.parseInt(str);\n-            }\n-            c = str.charAt(offset++);\n+        if (neg) {\n+            if (len == 1 || len > 10) {\n+                return Integer.parseInt(s);\n+            }\n+            c = s.charAt(offset++);\n         } else {\n-            if (length > 9) {\n-                return Integer.parseInt(str);\n+            if (len > 9) {\n+                return Integer.parseInt(s);\n             }\n         }\n         if (c > '9' || c < '0') {\n-            return Integer.parseInt(str);\n+            return Integer.parseInt(s);\n         }\n         int num = c - '0';\n-        if (offset < length) {\n-            c = str.charAt(offset++);\n+        if (offset < len) {\n+            c = s.charAt(offset++);\n             if (c > '9' || c < '0') {\n-                return Integer.parseInt(str);\n+                return Integer.parseInt(s);\n             }\n             num = (num * 10) + (c - '0');\n-            if (offset < length) {\n-                c = str.charAt(offset++);\n+            if (offset < len) {\n+                c = s.charAt(offset++);\n                 if (c > '9' || c < '0') {\n-                    return Integer.parseInt(str);\n+                    return Integer.parseInt(s);\n                 }\n                 num = (num * 10) + (c - '0');\n                 // Let's just loop if we have more than 3 digits:\n-                if (offset < length) {\n+                if (offset < len) {\n                     do {\n-                        c = str.charAt(offset++);\n+                        c = s.charAt(offset++);\n                         if (c > '9' || c < '0') {\n-                            return Integer.parseInt(str);\n+                            return Integer.parseInt(s);\n                         }\n                         num = (num * 10) + (c - '0');\n-                    } while (offset < length);\n-                }\n-            }\n-        }\n-        return negative ? -num : num;\n-    }\n-    \n-    public static long parseLong(char[] digitChars, int offset, int len)\n+                    } while (offset < len);\n+                }\n+            }\n+        }\n+        return neg ? -num : num;\n+    }\n+    \n+    public static long parseLong(char[] ch, int off, int len)\n     {\n         // Note: caller must ensure length is [10, 18]\n         int len1 = len-9;\n-        long val = parseInt(digitChars, offset, len1) * L_BILLION;\n-        return val + (long) parseInt(digitChars, offset+len1, 9);\n-    }\n-\n-    public static long parseLong(String str)\n+        long val = parseInt(ch, off, len1) * L_BILLION;\n+        return val + (long) parseInt(ch, off+len1, 9);\n+    }\n+\n+    public static long parseLong(String s)\n     {\n         /* Ok, now; as the very first thing, let's just optimize case of \"fake longs\";\n          * that is, if we know they must be ints, call int parsing\n          */\n-        int length = str.length();\n+        int length = s.length();\n         if (length <= 9) {\n-            return (long) parseInt(str);\n+            return (long) parseInt(s);\n         }\n         // !!! TODO: implement efficient 2-int parsing...\n-        return Long.parseLong(str);\n+        return Long.parseLong(s);\n     }\n     \n     /**\n      * @param negative Whether original number had a minus sign (which is\n      *    NOT passed to this method) or not\n      */\n-    public static boolean inLongRange(char[] digitChars, int offset, int len,\n+    public static boolean inLongRange(char[] ch, int off, int len,\n             boolean negative)\n     {\n         String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR;\n         if (len > cmpLen) return false;\n \n         for (int i = 0; i < cmpLen; ++i) {\n-            int diff = digitChars[offset+i] - cmpStr.charAt(i);\n+            int diff = ch[off+i] - cmpStr.charAt(i);\n             if (diff != 0) {\n                 return (diff < 0);\n             }\n      * @param negative Whether original number had a minus sign (which is\n      *    NOT passed to this method) or not\n      */\n-    public static boolean inLongRange(String numberStr, boolean negative)\n-    {\n-        String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR;\n-        int cmpLen = cmpStr.length();\n-        int actualLen = numberStr.length();\n-        if (actualLen < cmpLen) return true;\n-        if (actualLen > cmpLen) return false;\n+    public static boolean inLongRange(String s, boolean negative)\n+    {\n+        String cmp = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR;\n+        int cmpLen = cmp.length();\n+        int alen = s.length();\n+        if (alen < cmpLen) return true;\n+        if (alen > cmpLen) return false;\n \n         // could perhaps just use String.compareTo()?\n         for (int i = 0; i < cmpLen; ++i) {\n-            int diff = numberStr.charAt(i) - cmpStr.charAt(i);\n+            int diff = s.charAt(i) - cmp.charAt(i);\n             if (diff != 0) {\n                 return (diff < 0);\n             }\n         return true;\n     }\n \n-    public static int parseAsInt(String input, int defaultValue)\n-    {\n-        if (input == null) {\n-            return defaultValue;\n-        }\n-        input = input.trim();\n-        int len = input.length();\n+    public static int parseAsInt(String s, int def)\n+    {\n+        if (s == null) {\n+            return def;\n+        }\n+        s = s.trim();\n+        int len = s.length();\n         if (len == 0) {\n-            return defaultValue;\n+            return def;\n         }\n         // One more thing: use integer parsing for 'simple'\n         int i = 0;\n         if (i < len) { // skip leading sign:\n-            char c = input.charAt(0);\n+            char c = s.charAt(0);\n             if (c == '+') { // for plus, actually physically remove\n-                input = input.substring(1);\n-                len = input.length();\n+                s = s.substring(1);\n+                len = s.length();\n             } else if (c == '-') { // minus, just skip for checks, must retain\n                 ++i;\n             }\n         }\n         for (; i < len; ++i) {\n-            char c = input.charAt(i);\n+            char c = s.charAt(i);\n             // if other symbols, parse as Double, coerce\n             if (c > '9' || c < '0') {\n                 try {\n-                    return (int) parseDouble(input);\n+                    return (int) parseDouble(s);\n                 } catch (NumberFormatException e) {\n-                    return defaultValue;\n+                    return def;\n                 }\n             }\n         }\n         try {\n-            return Integer.parseInt(input);\n+            return Integer.parseInt(s);\n         } catch (NumberFormatException e) { }\n-        return defaultValue;\n-    }\n-\n-    public static long parseAsLong(String input, long defaultValue)\n-    {\n-        if (input == null) {\n-            return defaultValue;\n-        }\n-        input = input.trim();\n-        int len = input.length();\n+        return def;\n+    }\n+\n+    public static long parseAsLong(String s, long def)\n+    {\n+        if (s == null) {\n+            return def;\n+        }\n+        s = s.trim();\n+        int len = s.length();\n         if (len == 0) {\n-            return defaultValue;\n+            return def;\n         }\n         // One more thing: use long parsing for 'simple'\n         int i = 0;\n         if (i < len) { // skip leading sign:\n-            char c = input.charAt(0);\n+            char c = s.charAt(0);\n             if (c == '+') { // for plus, actually physically remove\n-                input = input.substring(1);\n-                len = input.length();\n+                s = s.substring(1);\n+                len = s.length();\n             } else if (c == '-') { // minus, just skip for checks, must retain\n                 ++i;\n             }\n         }\n         for (; i < len; ++i) {\n-            char c = input.charAt(i);\n+            char c = s.charAt(i);\n             // if other symbols, parse as Double, coerce\n             if (c > '9' || c < '0') {\n                 try {\n-                    return (long) parseDouble(input);\n+                    return (long) parseDouble(s);\n                 } catch (NumberFormatException e) {\n-                    return defaultValue;\n+                    return def;\n                 }\n             }\n         }\n         try {\n-            return Long.parseLong(input);\n+            return Long.parseLong(s);\n         } catch (NumberFormatException e) { }\n-        return defaultValue;\n-    }\n-    \n-    public static double parseAsDouble(String input, double defaultValue)\n-    {\n-        if (input == null) {\n-            return defaultValue;\n-        }\n-        input = input.trim();\n-        int len = input.length();\n+        return def;\n+    }\n+    \n+    public static double parseAsDouble(String s, double def)\n+    {\n+        if (s == null) { return def; }\n+        s = s.trim();\n+        int len = s.length();\n         if (len == 0) {\n-            return defaultValue;\n+            return def;\n         }\n         try {\n-            return parseDouble(input);\n+            return parseDouble(s);\n         } catch (NumberFormatException e) { }\n-        return defaultValue;\n-    }\n-\n-    public static double parseDouble(String numStr) throws NumberFormatException\n-    {\n+        return def;\n+    }\n+\n+    public static double parseDouble(String s) throws NumberFormatException {\n         // [JACKSON-486]: avoid some nasty float representations... but should it be MIN_NORMAL or MIN_VALUE?\n         /* as per [JACKSON-827], let's use MIN_VALUE as it is available on all JDKs; normalized\n          * only in JDK 1.6. In practice, should not really matter.\n          */\n-        if (NASTY_SMALL_DOUBLE.equals(numStr)) {\n+        if (NASTY_SMALL_DOUBLE.equals(s)) {\n             return Double.MIN_VALUE;\n         }\n-        return Double.parseDouble(numStr);\n-    }\n-\n-    public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException\n-    {\n-        try {\n-            return new BigDecimal(numStr);\n-        } catch (NumberFormatException e) {\n-            throw _badBigDecimal(numStr);\n-        }\n-    }\n-\n-    public static BigDecimal parseBigDecimal(char[] buffer) throws NumberFormatException {\n-        return parseBigDecimal(buffer, 0, buffer.length);\n-    }\n-    \n-    public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len)\n-            throws NumberFormatException\n-    {\n-        try {\n-            return new BigDecimal(buffer, offset, len);\n-        } catch (NumberFormatException e) {\n-            throw _badBigDecimal(new String(buffer, offset, len));\n-        }\n-    }\n-\n-    private static NumberFormatException _badBigDecimal(String str) {\n-        return new NumberFormatException(\"Value \\\"\"+str+\"\\\" can not be represented as BigDecimal\");\n+        return Double.parseDouble(s);\n+    }\n+\n+    public static BigDecimal parseBigDecimal(String s) throws NumberFormatException {\n+        try { return new BigDecimal(s); } catch (NumberFormatException e) {\n+            throw _badBD(s);\n+        }\n+    }\n+\n+    public static BigDecimal parseBigDecimal(char[] b) throws NumberFormatException {\n+        return parseBigDecimal(b, 0, b.length);\n+    }\n+    \n+    public static BigDecimal parseBigDecimal(char[] b, int off, int len) throws NumberFormatException {\n+        try { return new BigDecimal(b, off, len); } catch (NumberFormatException e) {\n+            throw _badBD(new String(b, off, len));\n+        }\n+    }\n+\n+    private static NumberFormatException _badBD(String s) {\n+        return new NumberFormatException(\"Value \\\"\"+s+\"\\\" can not be represented as BigDecimal\");\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/io/NumberOutput.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/NumberOutput.java\n \n public final class NumberOutput\n {\n-    private final static char NULL_CHAR = (char) 0;\n+    private final static char NC = (char) 0;\n \n     private static int MILLION = 1000000;\n     private static int BILLION = 1000000000;\n \n     final static String SMALLEST_LONG = String.valueOf(Long.MIN_VALUE);\n \n-    final static char[] LEADING_TRIPLETS = new char[4000];\n-    final static char[] FULL_TRIPLETS = new char[4000];\n+    final static char[] LEAD_3 = new char[4000];\n+    final static char[] FULL_3 = new char[4000];\n     static {\n         /* Let's fill it with NULLs for ignorable leading digits,\n          * and digit chars for others\n         int ix = 0;\n         for (int i1 = 0; i1 < 10; ++i1) {\n             char f1 = (char) ('0' + i1);\n-            char l1 = (i1 == 0) ? NULL_CHAR : f1;\n+            char l1 = (i1 == 0) ? NC : f1;\n             for (int i2 = 0; i2 < 10; ++i2) {\n                 char f2 = (char) ('0' + i2);\n-                char l2 = (i1 == 0 && i2 == 0) ? NULL_CHAR : f2;\n+                char l2 = (i1 == 0 && i2 == 0) ? NC : f2;\n                 for (int i3 = 0; i3 < 10; ++i3) {\n                     // Last is never to be empty\n                     char f3 = (char) ('0' + i3);\n-                    LEADING_TRIPLETS[ix] = l1;\n-                    LEADING_TRIPLETS[ix+1] = l2;\n-                    LEADING_TRIPLETS[ix+2] = f3;\n-                    FULL_TRIPLETS[ix] = f1;\n-                    FULL_TRIPLETS[ix+1] = f2;\n-                    FULL_TRIPLETS[ix+2] = f3;\n+                    LEAD_3[ix] = l1;\n+                    LEAD_3[ix+1] = l2;\n+                    LEAD_3[ix+2] = f3;\n+                    FULL_3[ix] = f1;\n+                    FULL_3[ix+1] = f2;\n+                    FULL_3[ix+2] = f3;\n                     ix += 4;\n                 }\n             }\n     final static byte[] FULL_TRIPLETS_B = new byte[4000];\n     static {\n         for (int i = 0; i < 4000; ++i) {\n-            FULL_TRIPLETS_B[i] = (byte) FULL_TRIPLETS[i];\n+            FULL_TRIPLETS_B[i] = (byte) FULL_3[i];\n         }\n     }\n     \n     /**\n      * @return Offset within buffer after outputting int\n      */\n-    public static int outputInt(int value, char[] buffer, int offset)\n-    {\n-        if (value < 0) {\n-            if (value == Integer.MIN_VALUE) {\n+    public static int outputInt(int v, char[] b, int off)\n+    {\n+        if (v < 0) {\n+            if (v == Integer.MIN_VALUE) {\n                 /* Special case: no matching positive value within range;\n                  * let's then \"upgrade\" to long and output as such.\n                  */\n-                return outputLong((long) value, buffer, offset);\n-            }\n-            buffer[offset++] = '-';\n-            value = -value;\n-        }\n-\n-        if (value < MILLION) { // at most 2 triplets...\n-            if (value < 1000) {\n-                if (value < 10) {\n-                    buffer[offset++] = (char) ('0' + value);\n+                return outputLong((long) v, b, off);\n+            }\n+            b[off++] = '-';\n+            v = -v;\n+        }\n+\n+        if (v < MILLION) { // at most 2 triplets...\n+            if (v < 1000) {\n+                if (v < 10) {\n+                    b[off++] = (char) ('0' + v);\n                 } else {\n-                    offset = outputLeadingTriplet(value, buffer, offset);\n+                    off = leading3(v, b, off);\n                 }\n             } else {\n-                int thousands = value / 1000;\n-                value -= (thousands * 1000); // == value % 1000\n-                offset = outputLeadingTriplet(thousands, buffer, offset);\n-                offset = outputFullTriplet(value, buffer, offset);\n-            }\n-            return offset;\n+                int thousands = v / 1000;\n+                v -= (thousands * 1000); // == value % 1000\n+                off = leading3(thousands, b, off);\n+                off = full3(v, b, off);\n+            }\n+            return off;\n         }\n \n         // ok, all 3 triplets included\n          * handling 3 triplets. This is possible since we know we\n          * can have at most '2' as billion count.\n          */\n-        boolean hasBillions = (value >= BILLION);\n+        boolean hasBillions = (v >= BILLION);\n         if (hasBillions) {\n-            value -= BILLION;\n-            if (value >= BILLION) {\n-                value -= BILLION;\n-                buffer[offset++] = '2';\n+            v -= BILLION;\n+            if (v >= BILLION) {\n+                v -= BILLION;\n+                b[off++] = '2';\n             } else {\n-                buffer[offset++] = '1';\n-            }\n-        }\n-        int newValue = value / 1000;\n-        int ones = (value - (newValue * 1000)); // == value % 1000\n-        value = newValue;\n+                b[off++] = '1';\n+            }\n+        }\n+        int newValue = v / 1000;\n+        int ones = (v - (newValue * 1000)); // == value % 1000\n+        v = newValue;\n         newValue /= 1000;\n-        int thousands = (value - (newValue * 1000));\n+        int thousands = (v - (newValue * 1000));\n         \n         // value now has millions, which have 1, 2 or 3 digits\n         if (hasBillions) {\n-            offset = outputFullTriplet(newValue, buffer, offset);\n+            off = full3(newValue, b, off);\n         } else {\n-            offset = outputLeadingTriplet(newValue, buffer, offset);\n-        }\n-        offset = outputFullTriplet(thousands, buffer, offset);\n-        offset = outputFullTriplet(ones, buffer, offset);\n-        return offset;\n-    }\n-\n-    public static int outputInt(int value, byte[] buffer, int offset)\n-    {\n-        if (value < 0) {\n-            if (value == Integer.MIN_VALUE) {\n-                return outputLong((long) value, buffer, offset);\n-            }\n-            buffer[offset++] = '-';\n-            value = -value;\n-        }\n-\n-        if (value < MILLION) { // at most 2 triplets...\n-            if (value < 1000) {\n-                if (value < 10) {\n-                    buffer[offset++] = (byte) ('0' + value);\n+            off = leading3(newValue, b, off);\n+        }\n+        off = full3(thousands, b, off);\n+        off = full3(ones, b, off);\n+        return off;\n+    }\n+\n+    public static int outputInt(int v, byte[] b, int off)\n+    {\n+        if (v < 0) {\n+            if (v == Integer.MIN_VALUE) {\n+                return outputLong((long) v, b, off);\n+            }\n+            b[off++] = '-';\n+            v = -v;\n+        }\n+\n+        if (v < MILLION) { // at most 2 triplets...\n+            if (v < 1000) {\n+                if (v < 10) {\n+                    b[off++] = (byte) ('0' + v);\n                 } else {\n-                    offset = outputLeadingTriplet(value, buffer, offset);\n+                    off = leading3(v, b, off);\n                 }\n             } else {\n-                int thousands = value / 1000;\n-                value -= (thousands * 1000); // == value % 1000\n-                offset = outputLeadingTriplet(thousands, buffer, offset);\n-                offset = outputFullTriplet(value, buffer, offset);\n-            }\n-            return offset;\n-        }\n-        boolean hasBillions = (value >= BILLION);\n-        if (hasBillions) {\n-            value -= BILLION;\n-            if (value >= BILLION) {\n-                value -= BILLION;\n-                buffer[offset++] = '2';\n+                int thousands = v / 1000;\n+                v -= (thousands * 1000); // == value % 1000\n+                off = leading3(thousands, b, off);\n+                off = full3(v, b, off);\n+            }\n+            return off;\n+        }\n+        boolean hasB = (v >= BILLION);\n+        if (hasB) {\n+            v -= BILLION;\n+            if (v >= BILLION) {\n+                v -= BILLION;\n+                b[off++] = '2';\n             } else {\n-                buffer[offset++] = '1';\n-            }\n-        }\n-        int newValue = value / 1000;\n-        int ones = (value - (newValue * 1000)); // == value % 1000\n-        value = newValue;\n+                b[off++] = '1';\n+            }\n+        }\n+        int newValue = v / 1000;\n+        int ones = (v - (newValue * 1000)); // == value % 1000\n+        v = newValue;\n         newValue /= 1000;\n-        int thousands = (value - (newValue * 1000));\n+        int thousands = (v - (newValue * 1000));\n         \n-        if (hasBillions) {\n-            offset = outputFullTriplet(newValue, buffer, offset);\n+        if (hasB) {\n+            off = full3(newValue, b, off);\n         } else {\n-            offset = outputLeadingTriplet(newValue, buffer, offset);\n-        }\n-        offset = outputFullTriplet(thousands, buffer, offset);\n-        offset = outputFullTriplet(ones, buffer, offset);\n-        return offset;\n+            off = leading3(newValue, b, off);\n+        }\n+        off = full3(thousands, b, off);\n+        off = full3(ones, b, off);\n+        return off;\n     }\n     \n     /**\n      * @return Offset within buffer after outputting int\n      */\n-    public static int outputLong(long value, char[] buffer, int offset)\n+    public static int outputLong(long v, char[] b, int off)\n     {\n         // First: does it actually fit in an int?\n-        if (value < 0L) {\n+        if (v < 0L) {\n             /* MIN_INT is actually printed as long, just because its\n              * negation is not an int but long\n              */\n-            if (value > MIN_INT_AS_LONG) {\n-                return outputInt((int) value, buffer, offset);\n-            }\n-            if (value == Long.MIN_VALUE) {\n+            if (v > MIN_INT_AS_LONG) {\n+                return outputInt((int) v, b, off);\n+            }\n+            if (v == Long.MIN_VALUE) {\n                 // Special case: no matching positive value within range\n                 int len = SMALLEST_LONG.length();\n-                SMALLEST_LONG.getChars(0, len, buffer, offset);\n-                return (offset + len);\n-            }\n-            buffer[offset++] = '-';\n-            value = -value;\n+                SMALLEST_LONG.getChars(0, len, b, off);\n+                return (off + len);\n+            }\n+            b[off++] = '-';\n+            v = -v;\n         } else {\n-            if (value <= MAX_INT_AS_LONG) {\n-                return outputInt((int) value, buffer, offset);\n+            if (v <= MAX_INT_AS_LONG) {\n+                return outputInt((int) v, b, off);\n             }\n         }\n \n         /* Ok: real long print. Need to first figure out length\n          * in characters, and then print in from end to beginning\n          */\n-        int origOffset = offset;\n-        offset += calcLongStrLength(value);\n-        int ptr = offset;\n+        int origOffset = off;\n+        off += calcLongStrLength(v);\n+        int ptr = off;\n \n         // First, with long arithmetics:\n-        while (value > MAX_INT_AS_LONG) { // full triplet\n+        while (v > MAX_INT_AS_LONG) { // full triplet\n             ptr -= 3;\n-            long newValue = value / THOUSAND_L;\n-            int triplet = (int) (value - newValue * THOUSAND_L);\n-            outputFullTriplet(triplet, buffer, ptr);\n-            value = newValue;\n+            long newValue = v / THOUSAND_L;\n+            int triplet = (int) (v - newValue * THOUSAND_L);\n+            full3(triplet, b, ptr);\n+            v = newValue;\n         }\n         // Then with int arithmetics:\n-        int ivalue = (int) value;\n+        int ivalue = (int) v;\n         while (ivalue >= 1000) { // still full triplet\n             ptr -= 3;\n             int newValue = ivalue / 1000;\n             int triplet = ivalue - (newValue * 1000);\n-            outputFullTriplet(triplet, buffer, ptr);\n+            full3(triplet, b, ptr);\n             ivalue = newValue;\n         }\n         // And finally, if anything remains, partial triplet\n-        outputLeadingTriplet(ivalue, buffer, origOffset);\n-\n-        return offset;\n-    }\n-\n-    public static int outputLong(long value, byte[] buffer, int offset)\n-    {\n-        if (value < 0L) {\n-            if (value > MIN_INT_AS_LONG) {\n-                return outputInt((int) value, buffer, offset);\n-            }\n-            if (value == Long.MIN_VALUE) {\n+        leading3(ivalue, b, origOffset);\n+\n+        return off;\n+    }\n+\n+    public static int outputLong(long v, byte[] b, int off)\n+    {\n+        if (v < 0L) {\n+            if (v > MIN_INT_AS_LONG) {\n+                return outputInt((int) v, b, off);\n+            }\n+            if (v == Long.MIN_VALUE) {\n                 // Special case: no matching positive value within range\n                 int len = SMALLEST_LONG.length();\n                 for (int i = 0; i < len; ++i) {\n-                    buffer[offset++] = (byte) SMALLEST_LONG.charAt(i);\n+                    b[off++] = (byte) SMALLEST_LONG.charAt(i);\n                 }\n-                return offset;\n-            }\n-            buffer[offset++] = '-';\n-            value = -value;\n+                return off;\n+            }\n+            b[off++] = '-';\n+            v = -v;\n         } else {\n-            if (value <= MAX_INT_AS_LONG) {\n-                return outputInt((int) value, buffer, offset);\n-            }\n-        }\n-        int origOffset = offset;\n-        offset += calcLongStrLength(value);\n-        int ptr = offset;\n+            if (v <= MAX_INT_AS_LONG) {\n+                return outputInt((int) v, b, off);\n+            }\n+        }\n+        int origOff = off;\n+        off += calcLongStrLength(v);\n+        int ptr = off;\n \n         // First, with long arithmetics:\n-        while (value > MAX_INT_AS_LONG) { // full triplet\n+        while (v > MAX_INT_AS_LONG) { // full triplet\n             ptr -= 3;\n-            long newValue = value / THOUSAND_L;\n-            int triplet = (int) (value - newValue * THOUSAND_L);\n-            outputFullTriplet(triplet, buffer, ptr);\n-            value = newValue;\n+            long newV = v / THOUSAND_L;\n+            int t = (int) (v - newV * THOUSAND_L);\n+            full3(t, b, ptr);\n+            v = newV;\n         }\n         // Then with int arithmetics:\n-        int ivalue = (int) value;\n+        int ivalue = (int) v;\n         while (ivalue >= 1000) { // still full triplet\n             ptr -= 3;\n-            int newValue = ivalue / 1000;\n-            int triplet = ivalue - (newValue * 1000);\n-            outputFullTriplet(triplet, buffer, ptr);\n-            ivalue = newValue;\n-        }\n-        outputLeadingTriplet(ivalue, buffer, origOffset);\n-        return offset;\n+            int newV = ivalue / 1000;\n+            int t = ivalue - (newV * 1000);\n+            full3(t, b, ptr);\n+            ivalue = newV;\n+        }\n+        leading3(ivalue, b, origOff);\n+        return off;\n     }\n     \n     /*\n      *   these? (or need: only called by diagnostics methods?)\n      */\n \n-    public static String toString(int value)\n+    public static String toString(int v)\n     {\n         // Lookup table for small values\n-        if (value < sSmallIntStrs.length) {\n-            if (value >= 0) {\n-                return sSmallIntStrs[value];\n-            }\n-            int v2 = -value - 1;\n+        if (v < sSmallIntStrs.length) {\n+            if (v >= 0) {\n+                return sSmallIntStrs[v];\n+            }\n+            int v2 = -v - 1;\n             if (v2 < sSmallIntStrs2.length) {\n                 return sSmallIntStrs2[v2];\n             }\n         }\n-        return Integer.toString(value);\n-    }\n-\n-    public static String toString(long value)\n-    {\n-        if (value <= Integer.MAX_VALUE &&\n-            value >= Integer.MIN_VALUE) {\n-            return toString((int) value);\n-        }\n-        return Long.toString(value);\n-    }\n-\n-    public static String toString(double value)\n-    {\n-        return Double.toString(value);\n+        return Integer.toString(v);\n+    }\n+\n+    public static String toString(long v) {\n+        if (v <= Integer.MAX_VALUE && v >= Integer.MIN_VALUE) {\n+            return toString((int) v);\n+        }\n+        return Long.toString(v);\n+    }\n+\n+    public static String toString(double v) {\n+        return Double.toString(v);\n     }\n \n     /*\n     /**********************************************************\n      */\n \n-    private static int outputLeadingTriplet(int triplet, char[] buffer, int offset)\n-    {\n-        int digitOffset = (triplet << 2);\n-        char c = LEADING_TRIPLETS[digitOffset++];\n-        if (c != NULL_CHAR) {\n-            buffer[offset++] = c;\n-        }\n-        c = LEADING_TRIPLETS[digitOffset++];\n-        if (c != NULL_CHAR) {\n-            buffer[offset++] = c;\n+    private static int leading3(int t, char[] b, int off)\n+    {\n+        int digitOffset = (t << 2);\n+        char c = LEAD_3[digitOffset++];\n+        if (c != NC) {\n+            b[off++] = c;\n+        }\n+        c = LEAD_3[digitOffset++];\n+        if (c != NC) {\n+            b[off++] = c;\n         }\n         // Last is required to be non-empty\n-        buffer[offset++] = LEADING_TRIPLETS[digitOffset];\n-        return offset;\n-    }\n-\n-    private static int outputLeadingTriplet(int triplet, byte[] buffer, int offset)\n-    {\n-        int digitOffset = (triplet << 2);\n-        char c = LEADING_TRIPLETS[digitOffset++];\n-        if (c != NULL_CHAR) {\n-            buffer[offset++] = (byte) c;\n-        }\n-        c = LEADING_TRIPLETS[digitOffset++];\n-        if (c != NULL_CHAR) {\n-            buffer[offset++] = (byte) c;\n+        b[off++] = LEAD_3[digitOffset];\n+        return off;\n+    }\n+\n+    private static int leading3(int t, byte[] b, int off)\n+    {\n+        int digitOffset = (t << 2);\n+        char c = LEAD_3[digitOffset++];\n+        if (c != NC) {\n+            b[off++] = (byte) c;\n+        }\n+        c = LEAD_3[digitOffset++];\n+        if (c != NC) {\n+            b[off++] = (byte) c;\n         }\n         // Last is required to be non-empty\n-        buffer[offset++] = (byte) LEADING_TRIPLETS[digitOffset];\n-        return offset;\n-    }\n-    \n-    private static int outputFullTriplet(int triplet, char[] buffer, int offset)\n-    {\n-        int digitOffset = (triplet << 2);\n-        buffer[offset++] = FULL_TRIPLETS[digitOffset++];\n-        buffer[offset++] = FULL_TRIPLETS[digitOffset++];\n-        buffer[offset++] = FULL_TRIPLETS[digitOffset];\n-        return offset;\n-    }\n-\n-    private static int outputFullTriplet(int triplet, byte[] buffer, int offset)\n-    {\n-        int digitOffset = (triplet << 2);\n-        buffer[offset++] = FULL_TRIPLETS_B[digitOffset++];\n-        buffer[offset++] = FULL_TRIPLETS_B[digitOffset++];\n-        buffer[offset++] = FULL_TRIPLETS_B[digitOffset];\n-        return offset;\n+        b[off++] = (byte) LEAD_3[digitOffset];\n+        return off;\n+    }\n+    \n+    private static int full3(int t, char[] b, int off)\n+    {\n+        int digitOffset = (t << 2);\n+        b[off++] = FULL_3[digitOffset++];\n+        b[off++] = FULL_3[digitOffset++];\n+        b[off++] = FULL_3[digitOffset];\n+        return off;\n+    }\n+\n+    private static int full3(int t, byte[] b, int off)\n+    {\n+        int digitOffset = (t << 2);\n+        b[off++] = FULL_TRIPLETS_B[digitOffset++];\n+        b[off++] = FULL_TRIPLETS_B[digitOffset++];\n+        b[off++] = FULL_TRIPLETS_B[digitOffset];\n+        return off;\n     }\n     \n     /**\n      *<p>\n-     * Pre-conditions: posValue is positive, and larger than\n+     * Pre-conditions: <code>c</code> is positive, and larger than\n      * Integer.MAX_VALUE (about 2 billions).\n      */\n-    private static int calcLongStrLength(long posValue)\n+    private static int calcLongStrLength(long v)\n     {\n         int len = 10;\n-        long comp = TEN_BILLION_L;\n+        long cmp = TEN_BILLION_L;\n \n         // 19 is longest, need to worry about overflow\n-        while (posValue >= comp) {\n+        while (v >= cmp) {\n             if (len == 19) {\n                 break;\n             }\n             ++len;\n-            comp = (comp << 3) + (comp << 1); // 10x\n+            cmp = (cmp << 3) + (cmp << 1); // 10x\n         }\n         return len;\n     }\n--- a/src/main/java/com/fasterxml/jackson/core/io/OutputDecorator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/OutputDecorator.java\n  * writer) around original output destination, and apply additional\n  * processing during write operations.\n  */\n+@SuppressWarnings(\"serial\")\n public abstract class OutputDecorator implements java.io.Serializable // since 2.1\n {\n-    private static final long serialVersionUID = 1L;\n-\n     /**\n      * Method called by {@link com.fasterxml.jackson.core.JsonFactory} instance when\n      * creating generator for given {@link OutputStream}, when this decorator\n--- a/src/main/java/com/fasterxml/jackson/core/util/InternCache.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/InternCache.java\n      * cases where multiple threads might try to concurrently\n      * flush the map.\n      */\n-    private final Object _flushLock = new Object();\n+    private final Object lock = new Object();\n     \n-    private InternCache() {\n-        super(MAX_ENTRIES, 0.8f, 4);\n-    }\n+    private InternCache() { super(MAX_ENTRIES, 0.8f, 4); }\n \n-    public String intern(String input)\n-    {\n+    public String intern(String input) {\n         String result = get(input);\n-        if (result != null) {\n-            return result;\n-        }\n+        if (result != null) { return result; }\n \n         /* 18-Sep-2013, tatu: We used to use LinkedHashMap, which has simple LRU\n          *   method. No such functionality exists with CHM; and let's use simplest\n              * storage gives close enough answer to real one here; and we are\n              * more concerned with flooding than starvation.\n              */\n-            synchronized (_flushLock) {\n+            synchronized (lock) {\n                 if (size() >= MAX_ENTRIES) {\n                     clear();\n                 }\n--- a/src/main/java/com/fasterxml/jackson/core/util/VersionUtil.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/VersionUtil.java\n  */\n public class VersionUtil\n {\n-    private final static Pattern VERSION_SEPARATOR = Pattern.compile(\"[-_./;:]\");\n-\n-    private final Version _version;\n+    private final static Pattern V_SEP = Pattern.compile(\"[-_./;:]\");\n+\n+    private final Version _v;\n \n     /*\n     /**********************************************************\n         if (v == null) {\n             v = Version.unknownVersion();\n         }\n-        _version = v;\n-    }\n-\n-    public Version version() { return _version; }\n+        _v = v;\n+    }\n+\n+    public Version version() { return _v; }\n     \n     /*\n     /**********************************************************\n         }\n     }\n \n-    private static Version doReadVersion(final Reader reader)\n+    private static Version doReadVersion(final Reader r)\n     {\n         String version = null, group = null, artifact = null;\n \n-        final BufferedReader br = new BufferedReader(reader);\n+        final BufferedReader br = new BufferedReader(r);\n         try {\n             version = br.readLine();\n             if (version != null) {\n      * META-INF/maven/groupId/artifactId, containing the groupId,\n      * artifactId and version of the library.\n      *\n-     * @param classLoader the ClassLoader to load the pom.properties file from\n+     * @param cl the ClassLoader to load the pom.properties file from\n      * @param groupId the groupId of the library\n      * @param artifactId the artifactId of the library\n      * @return The version\n      */\n     @SuppressWarnings(\"resource\")\n-    public static Version mavenVersionFor(ClassLoader classLoader, String groupId, String artifactId)\n-    {\n-        InputStream pomProperties = classLoader.getResourceAsStream(\"META-INF/maven/\"\n+    public static Version mavenVersionFor(ClassLoader cl, String groupId, String artifactId)\n+    {\n+        InputStream pomProperties = cl.getResourceAsStream(\"META-INF/maven/\"\n                 + groupId.replaceAll(\"\\\\.\", \"/\")+ \"/\" + artifactId + \"/pom.properties\");\n         if (pomProperties != null) {\n             try {\n         return Version.unknownVersion();\n     }\n \n-    public static Version parseVersion(String versionStr, String groupId, String artifactId)\n-    {\n-        if (versionStr != null && (versionStr = versionStr.trim()).length() > 0) {\n-            String[] parts = VERSION_SEPARATOR.split(versionStr);\n+    public static Version parseVersion(String s, String groupId, String artifactId)\n+    {\n+        if (s != null && (s = s.trim()).length() > 0) {\n+            String[] parts = V_SEP.split(s);\n             return new Version(parseVersionPart(parts[0]),\n                     (parts.length > 1) ? parseVersionPart(parts[1]) : 0,\n                     (parts.length > 2) ? parseVersionPart(parts[2]) : 0,\n         return null;\n     }\n \n-    protected static int parseVersionPart(String partStr)\n-    {\n+    protected static int parseVersionPart(String s) {\n         int number = 0;\n-        for (int i = 0, len = partStr.length(); i < len; ++i) {\n-            char c = partStr.charAt(i);\n+        for (int i = 0, len = s.length(); i < len; ++i) {\n+            char c = s.charAt(i);\n             if (c > '9' || c < '0') break;\n             number = (number * 10) + (c - '0');\n         }\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestCharEscaping.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestCharEscaping.java\n         public SerializableString getEscapeSequence(int ch) {\n           throw new UnsupportedOperationException(\"Not implemented for test\");\n         }\n-      };\n+    };\n+\n     /*\n     /**********************************************************\n     /* Unit tests\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestCustomEscaping.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestCustomEscaping.java\n     @SuppressWarnings(\"serial\")\n     static class MyEscapes extends CharacterEscapes\n     {\n-        \n         private final int[] _asciiEscapes;\n \n         public MyEscapes() {", "timestamp": 1389760864, "metainfo": ""}