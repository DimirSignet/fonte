{"sha": "aa65eaacdaa0aa35a14fa803c5bd217dc63ccdb9", "log": "last touchups for tests, mark old symbol table deprecated", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java\n import com.fasterxml.jackson.core.util.InternCache;\n \n /**\n- * Replacement for {@link BytesToNameCanonicalizer} which aims at more localized\n+ * Replacement for <code>BytesToNameCanonicalizer</code> which aims at more localized\n  * memory access due to flattening of name quad data.\n+ * Performance improvement modest for simple JSON document data binding (maybe 3%),\n+ * but should help more for larger symbol tables, or for binary formats like Smile.\n  *\n  * @since 2.6\n  */\n         // primary hash size; and offsets are for 4 int slots. So to get to logical\n         // index would shift by 4. But! Tertiary area is further split into buckets,\n         // determined by shift value. And finally, from bucket back into physical offsets\n-        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 4)) << (_tertiaryShift + 2));\n+        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift);\n         final int[] hashArea = _hashArea;\n-        final int bucketSize = (4 << _tertiaryShift);\n+        final int bucketSize = (1 << _tertiaryShift);\n         for (int end = offset + bucketSize; offset < end; offset += 4) {\n             int len = hashArea[offset+3];\n             if ((q1 == hashArea[offset]) && (1 == len)) {\n \n     private String _findSecondary(int origOffset, int q1, int q2)\n     {\n-        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 4)) << (_tertiaryShift + 2));\n+        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift);\n         final int[] hashArea = _hashArea;\n \n-        final int bucketSize = (4 << _tertiaryShift);\n+        final int bucketSize = (1 << _tertiaryShift);\n         for (int end = offset + bucketSize; offset < end; offset += 4) {\n             int len = hashArea[offset+3];\n             if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (2 == len)) {\n \n     private String _findSecondary(int origOffset, int q1, int q2, int q3)\n     {\n-        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 4)) << (_tertiaryShift + 2));\n+        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift);\n         final int[] hashArea = _hashArea;\n \n-        final int bucketSize = (4 << _tertiaryShift);\n+        final int bucketSize = (1 << _tertiaryShift);\n         for (int end = offset + bucketSize; offset < end; offset += 4) {\n             int len = hashArea[offset+3];\n             if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (q3 == hashArea[offset+2]) && (3 == len)) {\n \n     private String _findSecondary(int origOffset, int hash, int[] q, int qlen)\n     {\n-        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 4)) << (_tertiaryShift + 2));\n+        int offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift);\n         final int[] hashArea = _hashArea;\n \n-        final int bucketSize = (4 << _tertiaryShift);\n+        final int bucketSize = (1 << _tertiaryShift);\n         for (int end = offset + bucketSize; offset < end; offset += 4) {\n             int len = hashArea[offset+3];\n             if ((hash == hashArea[offset]) && (qlen == len)) {\n         }\n         // if not, tertiary?\n \n-        offset2 = _tertiaryStart + ((offset >> (_tertiaryShift + 4)) << (_tertiaryShift + 2));\n-        final int bucketSize = (4 << _tertiaryShift);\n+        offset2 = _tertiaryStart + ((offset >> (_tertiaryShift + 2)) << _tertiaryShift);\n+        final int bucketSize = (1 << _tertiaryShift);\n         for (int end = offset2 + bucketSize; offset2 < end; offset2 += 4) {\n             if (hashArea[offset2+3] == 0) {\n                 return offset2;\n         // first: we only get 1/4 of slots of primary, to divide\n         int tertSlots = (primarySlots) >> 2;\n         \n-        // default is 2, meaning buckets of 4 (1 << 2) slots, up to 32 which is 8 buckets of 4 slots\n+        // default is for buckets of 4 slots (each 4 ints, i.e. 1 << 4)\n         if (tertSlots < 64) {\n-            return 2;\n-        }\n-        // and then up to 256, with 32 buckets of 8 slots\n-        if (tertSlots < 256) {\n-            return 3;\n-        }\n-        // and 2048, with 128 buckets of 16 slots\n-        if (tertSlots < 1024) {\n             return 4;\n         }\n-        if (tertSlots < 4096) {\n+        if (tertSlots <= 256) { // buckets of 8 slots (up to 256 == 32 x 8)\n             return 5;\n         }\n-        // and biggest buckets have 64 slots\n-        return 6;\n+        if (tertSlots <= 2048) { // buckets of 16 slots (up to 1024 == 64 x 16)\n+            return 6;\n+        }\n+        // and biggest buckets have 32 slots\n+        return 7;\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n  * symbol tables, to be able to make use of usually shared vocabulary\n  * of subsequent parsing runs.\n  *\n- * @author Tatu Saloranta\n+ * @deprecated Since 2.6, replced by {@link ByteQuadsCanonicalizer}\n  */\n+@Deprecated\n public final class BytesToNameCanonicalizer\n {\n     private static final int DEFAULT_T_SIZE = 64;\n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestByteBasedSymbols.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestByteBasedSymbols.java\n import java.io.*;\n \n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.core.sym.BytesToNameCanonicalizer;\n-import com.fasterxml.jackson.core.sym.Name;\n \n /**\n  * Unit test(s) to verify that handling of (byte-based) symbol tables\n         jp0.close();\n     }\n \n-    public void testAuxMethodsWithOldSymboTable() throws Exception\n-    {\n-        final int A_BYTES = 0x41414141; // \"AAAA\"\n-        final int B_BYTES = 0x42424242; // \"BBBB\"\n-\n-        BytesToNameCanonicalizer nc = BytesToNameCanonicalizer.createRoot()\n-                .makeChild(JsonFactory.Feature.collectDefaults());\n-        assertNull(nc.findName(A_BYTES));\n-        assertNull(nc.findName(A_BYTES, B_BYTES));\n-\n-        nc.addName(\"AAAA\", new int[] { A_BYTES }, 1);\n-        Name n1 = nc.findName(A_BYTES);\n-        assertNotNull(n1);\n-        assertEquals(\"AAAA\", n1.getName());\n-        nc.addName(\"AAAABBBB\", new int[] { A_BYTES, B_BYTES }, 2);\n-        Name n2 = nc.findName(A_BYTES, B_BYTES);\n-        assertEquals(\"AAAABBBB\", n2.getName());\n-        assertNotNull(n2);\n-\n-        /* and let's then just exercise this method so it gets covered;\n-         * it's only used for debugging.\n-         */\n-        assertNotNull(nc.toString());\n-    }\n-\n     public void testAuxMethodsWithNewSymboTable() throws Exception\n     {\n         final int A_BYTES = 0x41414141; // \"AAAA\"\n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n \n     // Test for verifying stability of hashCode, wrt collisions, using\n     // synthetic field name generation and byte-based input (UTF-8)\n-    public void testSyntheticWithBytes() throws IOException\n+    @SuppressWarnings(\"deprecation\")\n+    public void testSyntheticWithBytesOld() throws IOException\n     {\n         // pass seed, to keep results consistent:\n         final int SEED = 33333;\n         final int COUNT = 6000;\n         for (int i = 0; i < COUNT; ++i) {\n             String id = fieldNameFor(i);\n-            int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\"));\n+            int[] quads = calcQuads(id.getBytes(\"UTF-8\"));\n             symbols.addName(id, quads, quads.length);\n         }\n         assertEquals(COUNT, symbols.size());\n         // But also verify entries are actually found?\n     }\n \n+    public void testSyntheticWithBytesNew() throws IOException\n+    {\n+        // pass seed, to keep results consistent:\n+        final int SEED = 33333;\n+        ByteQuadsCanonicalizer symbols =\n+                ByteQuadsCanonicalizer.createRoot(SEED).makeChild(JsonFactory.Feature.collectDefaults());\n+\n+        final int COUNT = 6000;\n+        for (int i = 0; i < COUNT; ++i) {\n+            String id = fieldNameFor(i);\n+            int[] quads = calcQuads(id.getBytes(\"UTF-8\"));\n+            symbols.addName(id, quads, quads.length);\n+        }\n+        assertEquals(COUNT, symbols.size());\n+        assertEquals(8192, symbols.bucketCount());\n+\n+        // fragile, but essential to verify low collision counts;\n+        // anywhere between 70-80% primary matches\n+        assertEquals(4270, symbols.primaryCount());\n+        // secondary between 10-20%\n+        assertEquals(1234, symbols.secondaryCount());\n+        // and most of remaining in tertiary\n+        assertEquals(496, symbols.tertiaryCount());\n+        // so that spill-over is empty or close to\n+        assertEquals(0, symbols.spilloverCount());\n+    }\n+    \n     // [Issue#145]\n     public void testThousandsOfSymbolsWithChars() throws IOException\n     {\n         }\n     }\n     \n+    @SuppressWarnings(\"deprecation\")\n     public void testThousandsOfSymbolsWithOldBytes() throws IOException\n     {\n         final int SEED = 33333;\n         ByteQuadsCanonicalizer symbolsBRoot = ByteQuadsCanonicalizer.createRoot(SEED);\n         final Charset utf8 = Charset.forName(\"UTF-8\");\n         int exp = 0;\n+        ByteQuadsCanonicalizer symbolsB = null;\n \n         // loop to get \n         for (int doc = 0; doc < 100; ++doc) {\n-            ByteQuadsCanonicalizer symbolsB =\n-                    symbolsBRoot.makeChild(JsonFactory.Feature.collectDefaults());\n+            symbolsB = symbolsBRoot.makeChild(JsonFactory.Feature.collectDefaults());\n             for (int i = 0; i < 250; ++i) {\n                 String name = \"f_\"+doc+\"_\"+i;\n \n-                int[] quads = BytesToNameCanonicalizer.calcQuads(name.getBytes(utf8));\n+                int[] quads = calcQuads(name.getBytes(utf8));\n                 \n                 symbolsB.addName(name, quads, quads.length);\n                 String n = symbolsB.findName(quads, quads.length);\n             }\n             assertEquals(exp, symbolsBRoot.size());\n         }\n+\n+        /* 05-Feb-2015, tatu: Fragile, but it is important to ensure that collision\n+         *   rates are not accidentally increased...\n+         */\n+        assertEquals(6250, symbolsB.size());\n+        assertEquals(4851, symbolsB.primaryCount()); // 77% primary hit rate\n+        assertEquals(872, symbolsB.secondaryCount()); // 14% secondary\n+        assertEquals(510, symbolsB.tertiaryCount()); // 8% tertiary\n+        assertEquals(17, symbolsB.spilloverCount()); // and couple of leftovers\n     }\n     \n     // And then one more test just for Bytes-based symbol table\n         syms.setAccessible(true);\n         return ((ByteQuadsCanonicalizer) syms.get(p));\n     }\n+\n+    // Method only used by unit tests\n+    protected static int[] calcQuads(byte[] wordBytes) {\n+        int blen = wordBytes.length;\n+        int[] result = new int[(blen + 3) / 4];\n+        for (int i = 0; i < blen; ++i) {\n+            int x = wordBytes[i] & 0xFF;\n+\n+            if (++i < blen) {\n+                x = (x << 8) | (wordBytes[i] & 0xFF);\n+                if (++i < blen) {\n+                    x = (x << 8) | (wordBytes[i] & 0xFF);\n+                    if (++i < blen) {\n+                        x = (x << 8) | (wordBytes[i] & 0xFF);\n+                    }\n+                }\n+            }\n+            result[i >> 2] = x;\n+        }\n+        return result;\n+    }\n }", "timestamp": 1423199336, "metainfo": ""}