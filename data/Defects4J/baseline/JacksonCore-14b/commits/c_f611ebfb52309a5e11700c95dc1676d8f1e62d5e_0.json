{"sha": "f611ebfb52309a5e11700c95dc1676d8f1e62d5e", "log": "yet more tweaking for symbol table access", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java\n         // first: primary match?\n         final int[] hashArea = _hashArea;\n \n-        int q1b = hashArea[offset];\n         int len = hashArea[offset+3];\n \n-        if ((q1b == q1) && (len == 1)) {\n-            return _names[offset >> 2];\n-        }\n-        if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n+        if (len == 1) {\n+            if (hashArea[offset] == q1) {\n+                return _names[offset >> 2];\n+            }\n+        } else if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n             return null;\n         }\n         // secondary? single slot shared by N/2 primaries\n         int offset2 = _secondaryStart + ((offset >> 3) << 2);\n \n-        q1b = hashArea[offset2];\n         len = hashArea[offset2+3];\n \n-        if ((q1b == q1) && (len == 1)) {\n-            return _names[offset2 >> 2];\n-        }\n-        if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n+        if (len == 1) {\n+            if (hashArea[offset2] == q1) {\n+                return _names[offset2 >> 2];\n+            }\n+        } else if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n             return null;\n         }\n \n \n         final int[] hashArea = _hashArea;\n \n-        int q1b = hashArea[offset];\n         int len = hashArea[offset+3];\n-        \n-        if ((q1 == q1b) && (hashArea[offset+1] == q2) && (len == 2)) {\n-            return _names[offset >> 2];\n-        }\n-        if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n+\n+        if (len == 2) {\n+            if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1])) {\n+                return _names[offset >> 2];\n+            }\n+        } else if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n             return null;\n         }\n         // secondary?\n         int offset2 = _secondaryStart + ((offset >> 3) << 2);\n \n-        q1b = hashArea[offset2];\n         len = hashArea[offset2+3];\n \n-        if ((q1 == q1b) && (hashArea[offset2+1] == q2) && (len == 2)) {\n-            return _names[offset2 >> 2];\n-        }\n-        if (len == 0) { // empty slot? Short-circuit if no more spillovers\n+        if (len == 2) {\n+            if ((q1 == hashArea[offset2]) && (q2 == hashArea[offset2+1])) {\n+                return _names[offset2 >> 2];\n+            }\n+        } else if (len == 0) { // empty slot? Short-circuit if no more spillovers\n             return null;\n         }\n         return _findSecondary(offset, q1, q2);\n     {\n         int offset = _calcOffset(calcHash(q1, q2, q3));\n         final int[] hashArea = _hashArea;\n-\n-        int q1b = hashArea[offset];\n         int len = hashArea[offset+3];\n \n-        if ((q1 == q1b) && (hashArea[offset+1] == q2) && (hashArea[offset+2] == q3) && (len == 3)) {\n-            return _names[offset >> 2];\n-        }\n-        if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n+        if (len == 3) {\n+            if ((q1 == hashArea[offset]) && (hashArea[offset+1] == q2) && (hashArea[offset+2] == q3)) {\n+                return _names[offset >> 2];\n+            }\n+        } else if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n             return null;\n         }\n         // secondary?\n         int offset2 = _secondaryStart + ((offset >> 3) << 2);\n \n-        q1b = hashArea[offset2];\n         len = hashArea[offset2+3];\n \n-        if ((q1 == q1b) && (hashArea[offset2+1] == q2) && (hashArea[offset2+2] == q3) && (len == 3)) {\n-            return _names[offset2 >> 2];\n-        }\n-        if (len == 0) { // empty slot? Short-circuit if no more spillovers\n+        if (len == 3) {\n+            if ((q1 == hashArea[offset2]) && (hashArea[offset2+1] == q2) && (hashArea[offset2+2] == q3)) {\n+                return _names[offset2 >> 2];\n+            }\n+        } else if (len == 0) { // empty slot? Short-circuit if no more spillovers\n             return null;\n         }\n         return _findSecondary(offset, q1, q2, q3);", "timestamp": 1425366061, "metainfo": ""}