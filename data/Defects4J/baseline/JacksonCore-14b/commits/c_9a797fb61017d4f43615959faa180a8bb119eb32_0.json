{"sha": "9a797fb61017d4f43615959faa180a8bb119eb32", "log": "Merge branch 'master' of github.com:FasterXML/jackson-core  Conflicts: \tsrc/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/filter/FilteringGeneratorDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/FilteringGeneratorDelegate.java\n             delegate.writeStartArray();\n         } else {\n             _filterContext = _filterContext.createChildArrayContext(_itemFilter, false);\n-            if (_itemFilter != null) {\n-                _filterContext.markNeedsCloseCheck();\n-            }\n         }\n     }\n         \n             delegate.writeStartArray(size);\n         } else {\n             _filterContext = _filterContext.createChildArrayContext(_itemFilter, false);\n-            if (_itemFilter != null) {\n-                _filterContext.markNeedsCloseCheck();\n-            }\n         }\n     }\n     \n             delegate.writeStartObject();\n         } else { // filter out\n             _filterContext = _filterContext.createChildObjectContext(state, false);\n-            if (state != null) {\n-                _filterContext.markNeedsCloseCheck();\n-            }\n         }\n     }\n     \n--- a/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java\n import java.math.BigInteger;\n \n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.core.json.JsonReadContext;\n import com.fasterxml.jackson.core.util.JsonParserDelegate;\n \n /**\n      * When the two are in sync, this context reference will be <code>null</code>.\n      */\n     protected TokenFilterContext _exposedContext;\n-    \n+\n     /**\n      * State that applies to the item within container, used where applicable.\n      * Specifically used to pass inclusion state between property name and\n     \n     /**\n      * Number of tokens for which {@link TokenFilter#INCLUDE_ALL}\n-     * has been returned\n+     * has been returned.\n      */\n     protected int _matchCount;\n \n     @Override\n     public JsonToken nextToken() throws IOException\n     {\n+        // Anything buffered?\n+        if (_exposedContext != null) {\n+            \n+        }\n         return delegate.nextToken();\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/core/filter/TokenFilterContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/TokenFilterContext.java\n     protected TokenFilter _filter;\n \n     /**\n-     * Flag that indicates that start token has been written, so\n-     * that matching close token needs to be written as well,\n-     * regardless of inclusion status.\n-     */\n-    protected boolean _startWritten;\n-\n-    /**\n-     * Flag that indicates that when context is closed, a call needs\n-     * to be made to {@link TokenFilter}\n-     */\n-    protected boolean _needCloseCheck;\n+     * Flag that indicates that start token has been read/written,\n+     * so that matching close token needs to be read/written as well\n+     * when context is getting closed.\n+     */\n+    protected boolean _startHandled;\n \n     /**\n      * Flag that indicates that the current name of this context\n-     * still needs to be written, if path from root is desired.\n-     */\n-    protected boolean _needToWriteName;\n+     * still needs to be read/written, if path from root down to\n+     * included leaf is to be exposed.\n+     */\n+    protected boolean _needToHandleName;\n     \n     /*\n     /**********************************************************\n         _parent = parent;\n         _filter = filter;\n         _index = -1;\n-        _startWritten = startWritten;\n-        _needToWriteName = false;\n-        _needCloseCheck = false;\n+        _startHandled = startWritten;\n+        _needToHandleName = false;\n     }\n \n     protected TokenFilterContext reset(int type,\n         _filter = filter;\n         _index = -1;\n         _currentName = null;\n-        _startWritten = startWritten;\n-        _needToWriteName = false;\n-        _needCloseCheck = false;\n+        _startHandled = startWritten;\n+        _needToHandleName = false;\n         return this;\n     }\n \n     \n     public TokenFilter setFieldName(String name) throws JsonProcessingException {\n         _currentName = name;\n-        _needToWriteName = true;\n+        _needToHandleName = true;\n         return _filter;\n     }\n \n         if (_parent != null) {\n             _parent._writePath(gen);\n         }\n-        if (_startWritten) {\n+        if (_startHandled) {\n             // even if Object started, need to start leaf-level name\n-            if (_needToWriteName) {\n+            if (_needToHandleName) {\n                 gen.writeFieldName(_currentName);\n             }\n         } else {\n-            _startWritten = true;\n+            _startHandled = true;\n             if (_type == TYPE_OBJECT) {\n                 gen.writeStartObject();\n                 gen.writeFieldName(_currentName); // we know name must be written\n         if ((_filter == null) || (_filter == TokenFilter.INCLUDE_ALL)) {\n             return;\n         }\n-        if (_startWritten) {\n+        if (_startHandled) {\n             // even if Object started, need to start leaf-level name\n-            if (_needToWriteName) {\n+            if (_needToHandleName) {\n                 gen.writeFieldName(_currentName);\n             }\n         } else {\n-            _startWritten = true;\n+            _startHandled = true;\n             if (_type == TYPE_OBJECT) {\n                 gen.writeStartObject();\n-                if (_needToWriteName) {\n+                if (_needToHandleName) {\n                     gen.writeFieldName(_currentName);\n                 }\n             } else if (_type == TYPE_ARRAY) {\n         if (_parent != null) {\n             _parent._writePath(gen);\n         }\n-        if (_startWritten) {\n+        if (_startHandled) {\n             // even if Object started, need to start leaf-level name\n-            if (_needToWriteName) {\n-                _needToWriteName = false; // at parent must explicitly clear\n+            if (_needToHandleName) {\n+                _needToHandleName = false; // at parent must explicitly clear\n                 gen.writeFieldName(_currentName);\n             }\n         } else {\n-            _startWritten = true;\n+            _startHandled = true;\n             if (_type == TYPE_OBJECT) {\n-//System.err.println(\" write object start, field '\"+_currentName+\"'\");                \n                 gen.writeStartObject();\n-                if (_needToWriteName) {\n-                    _needToWriteName = false; // at parent must explicitly clear\n+                if (_needToHandleName) {\n+                    _needToHandleName = false; // at parent must explicitly clear\n                     gen.writeFieldName(_currentName);\n                 }\n             } else if (_type == TYPE_ARRAY) {\n             }\n         }\n     }\n+\n+    public final TokenFilterContext closeArray(JsonGenerator gen) throws IOException\n+    {\n+        if (_startHandled) {\n+            gen.writeEndArray();\n+        }\n+        if ((_filter != null) && (_filter != TokenFilter.INCLUDE_ALL)) {\n+            _filter.filterFinishArray();\n+        }\n+        return _parent;\n+    }\n+    \n+    public final TokenFilterContext closeObject(JsonGenerator gen) throws IOException\n+    {\n+        if (_startHandled) {\n+            gen.writeEndObject();\n+        }\n+        if ((_filter != null) && (_filter != TokenFilter.INCLUDE_ALL)) {\n+            _filter.filterFinishObject();\n+        }\n+        return _parent;\n+    }\n     \n     public void skipParentChecks() {\n         _filter = null;\n \n     public TokenFilter getFilterState() { return _filter; }\n \n-    public void markNeedsCloseCheck() { _needCloseCheck = true; }\n-\n-    public final TokenFilterContext closeArray(JsonGenerator gen) throws IOException\n-    {\n-//System.err.println(\"closeArray, started? \"+_startWritten+\"; filter = \"+_filter);        \n-        if (_startWritten) {\n-            gen.writeEndArray();\n-        }\n-        if ((_filter != null) && (_filter != TokenFilter.INCLUDE_ALL)) {\n-            _filter.filterFinishArray();\n-        }\n-        return _parent;\n-    }\n-    \n-    public final TokenFilterContext closeObject(JsonGenerator gen) throws IOException\n-    {\n-        if (_startWritten) {\n-            gen.writeEndObject();\n-        }\n-        if ((_filter != null) && (_filter != TokenFilter.INCLUDE_ALL)) {\n-            _filter.filterFinishObject();\n-        }\n-        return _parent;\n-    }\n-\n+    public JsonToken nextTokenToRead(JsonToken curr) {\n+        if (!_startHandled) {\n+            if (_type == TYPE_OBJECT) {\n+                return JsonToken.START_OBJECT;\n+            }\n+            // Note: root should never be unhandled\n+            return JsonToken.START_ARRAY;\n+        }\n+        // But otherwise at most might have FIELD_NAME\n+        if ((curr == JsonToken.START_OBJECT) && (_type == TYPE_OBJECT)) {\n+            return JsonToken.FIELD_NAME;\n+        }\n+        return null;\n+    }\n+\n+    public TokenFilterContext findChildOf(TokenFilterContext parent) {\n+        if (_parent == parent) {\n+            return this;\n+        }\n+        TokenFilterContext curr = _parent;\n+        while (curr != null) {\n+            TokenFilterContext p = curr._parent;\n+            if (p == parent) {\n+                return curr;\n+            }\n+            curr = p;\n+        }\n+        // should never occur but...\n+        return null;\n+    }\n+    \n     // // // Internally used abstract methods\n \n     protected void appendDesc(StringBuilder sb) {\n--- a/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java\n     protected JsonToken _lastClearedToken;\n     \n     /**\n-     * Although delegate has its own output context it is not sufficient since we actually\n-     * have to keep track of excluded (filtered out) structures as well as ones delegate\n-     * actually outputs.\n-     */\n-    protected TokenFilterContext _filterContext;\n-\n-    /**\n-     * When parent tokens are buffered (during checking whether child tokens included),\n-     * we need to keep a reference back to the context closest to root that is yet to\n-     * be exposed.\n-     */\n-    protected TokenFilterContext _replayContext;\n-    \n+     * During traversal this is the actual \"open\" parse tree, which sometimes\n+     * is the same as {@link #_exposedContext}, and at other times is ahead\n+     * of it. Note that this context is never null.\n+     */\n+    protected TokenFilterContext _headContext;\n+\n+    /**\n+     * In cases where {@link #_headContext} is \"ahead\" of context exposed to\n+     * caller, this context points to what is currently exposed to caller.\n+     * When the two are in sync, this context reference will be <code>null</code>.\n+     */\n+    protected TokenFilterContext _exposedContext;\n+\n     /**\n      * State that applies to the item within container, used where applicable.\n      * Specifically used to pass inclusion state between property name and\n         rootFilter = f;\n         // and this is the currently active filter for root values\n         _itemFilter = f;\n-        _filterContext = TokenFilterContext.createRootContext(f);\n+        _headContext = TokenFilterContext.createRootContext(f);\n         _includePath = includePath;\n         _allowMultipleMatches = allowMultipleMatches;\n     }\n     @Override public boolean isExpectedStartObjectToken() { return _currToken == JsonToken.START_OBJECT; }\n \n     @Override public JsonLocation getCurrentLocation() { return delegate.getCurrentLocation(); }\n-    @Override public JsonStreamContext getParsingContext() { return _filterContext; }\n-\n-    // !!! TODO: not necessarily correct...\n-    @Override public String getCurrentName() throws IOException { return delegate.getCurrentName(); }\n-    \n+\n+    @Override\n+    public JsonStreamContext getParsingContext() {\n+        return _filterContext();\n+    }\n+    \n+    // !!! TODO: Verify it works as expected: copied from standard JSON parser impl\n+    @Override\n+    public String getCurrentName() throws IOException {\n+        JsonStreamContext ctxt = _filterContext();\n+        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n+            JsonStreamContext parent = ctxt.getParent();\n+            return (parent == null) ? null : parent.getCurrentName();\n+        }\n+        return ctxt.getCurrentName();\n+    }\n+\n     /*\n     /**********************************************************\n     /* Public API, token state overrides\n     @Override\n     public JsonToken getLastClearedToken() { return _lastClearedToken; }\n \n-    // !!! TODO: re-implement\n-    @Override\n-    public void overrideCurrentName(String name) { delegate.overrideCurrentName(name); }\n+    @Override\n+    public void overrideCurrentName(String name) {\n+        /* 14-Apr-2015, tatu: Not sure whether this can be supported, and if so,\n+         *    what to do with it... Delegation won't work for sure, so let's for\n+         *    now throw an exception\n+         */\n+        throw new UnsupportedOperationException(\"Can not currently override name during filtering read\");\n+    }\n \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n \n-    // !!! TODO: re-implement\n-    @Override public JsonToken nextToken() throws IOException { return delegate.nextToken(); }\n+    @Override\n+    public JsonToken nextToken() throws IOException\n+    {\n+        // Anything buffered?\n+        if (_exposedContext != null) {\n+            \n+        }\n+        return delegate.nextToken();\n+    }\n \n     @Override\n     public JsonToken nextValue() throws IOException {\n     @Override\n     public JsonParser skipChildren() throws IOException\n     {\n-        if (_currToken != JsonToken.START_OBJECT\n-            && _currToken != JsonToken.START_ARRAY) {\n+        if ((_currToken != JsonToken.START_OBJECT)\n+            && (_currToken != JsonToken.START_ARRAY)) {\n             return this;\n         }\n         int open = 1;\n     @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { return delegate.getBinaryValue(b64variant); }\n     @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { return delegate.readBinaryValue(b64variant, out); }\n     @Override public JsonLocation getTokenLocation() { return delegate.getTokenLocation(); }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal helper methods\n+    /**********************************************************\n+     */\n+\n+    protected JsonStreamContext _filterContext() {\n+        if (_exposedContext != null) {\n+            return _exposedContext;\n+        }\n+        return _headContext;\n+    }\n+\n }\n--- a/src/main/java/com/fasterxml/jackson/core/filter/TokenFilterContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/TokenFilterContext.java\n         } else {\n             _startHandled = true;\n             if (_type == TYPE_OBJECT) {\n-//System.err.println(\" write object start, field '\"+_currentName+\"'\");                \n                 gen.writeStartObject();\n                 if (_needToHandleName) {\n                     _needToHandleName = false; // at parent must explicitly clear\n             }\n         }\n     }\n+\n+    public final TokenFilterContext closeArray(JsonGenerator gen) throws IOException\n+    {\n+        if (_startHandled) {\n+            gen.writeEndArray();\n+        }\n+        if ((_filter != null) && (_filter != TokenFilter.INCLUDE_ALL)) {\n+            _filter.filterFinishArray();\n+        }\n+        return _parent;\n+    }\n+    \n+    public final TokenFilterContext closeObject(JsonGenerator gen) throws IOException\n+    {\n+        if (_startHandled) {\n+            gen.writeEndObject();\n+        }\n+        if ((_filter != null) && (_filter != TokenFilter.INCLUDE_ALL)) {\n+            _filter.filterFinishObject();\n+        }\n+        return _parent;\n+    }\n     \n     public void skipParentChecks() {\n         _filter = null;\n \n     public TokenFilter getFilterState() { return _filter; }\n \n-    public final TokenFilterContext closeArray(JsonGenerator gen) throws IOException\n-    {\n-//System.err.println(\"closeArray, started? \"+_startWritten+\"; filter = \"+_filter);        \n-        if (_startHandled) {\n-            gen.writeEndArray();\n-        }\n-        if ((_filter != null) && (_filter != TokenFilter.INCLUDE_ALL)) {\n-            _filter.filterFinishArray();\n-        }\n-        return _parent;\n-    }\n-    \n-    public final TokenFilterContext closeObject(JsonGenerator gen) throws IOException\n-    {\n-        if (_startHandled) {\n-            gen.writeEndObject();\n-        }\n-        if ((_filter != null) && (_filter != TokenFilter.INCLUDE_ALL)) {\n-            _filter.filterFinishObject();\n-        }\n-        return _parent;\n-    }\n-\n+    public JsonToken nextTokenToRead(JsonToken curr) {\n+        if (!_startHandled) {\n+            if (_type == TYPE_OBJECT) {\n+                return JsonToken.START_OBJECT;\n+            }\n+            // Note: root should never be unhandled\n+            return JsonToken.START_ARRAY;\n+        }\n+        // But otherwise at most might have FIELD_NAME\n+        if ((curr == JsonToken.START_OBJECT) && (_type == TYPE_OBJECT)) {\n+            return JsonToken.FIELD_NAME;\n+        }\n+        return null;\n+    }\n+\n+    public TokenFilterContext findChildOf(TokenFilterContext parent) {\n+        if (_parent == parent) {\n+            return this;\n+        }\n+        TokenFilterContext curr = _parent;\n+        while (curr != null) {\n+            TokenFilterContext p = curr._parent;\n+            if (p == parent) {\n+                return curr;\n+            }\n+            curr = p;\n+        }\n+        // should never occur but...\n+        return null;\n+    }\n+    \n     // // // Internally used abstract methods\n \n     protected void appendDesc(StringBuilder sb) {", "timestamp": 1429053132, "metainfo": ""}