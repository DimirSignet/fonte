{"sha": "38d6e35d1f1a9b48193804925517500de8efee1f", "log": "Fix #105, not detecting missing white-space between root-level numbers", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n                 _numTypesValid = NR_LONG;\n                 return;\n             }\n-            _parseSlowIntValue(expType, buf, offset, len);\n+            _parseSlowInt(expType, buf, offset, len);\n             return;\n         }\n         if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n-            _parseSlowFloatValue(expType);\n+            _parseSlowFloat(expType);\n             return;\n         }\n         _reportError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\");\n     }\n     \n-    private void _parseSlowFloatValue(int expType)\n+    private void _parseSlowFloat(int expType)\n         throws IOException, JsonParseException\n     {\n         /* Nope: floating point. Here we need to be careful to get\n         }\n     }\n     \n-    private void _parseSlowIntValue(int expType, char[] buf, int offset, int len)\n+    private void _parseSlowInt(int expType, char[] buf, int offset, int len)\n         throws IOException, JsonParseException\n     {\n         String numStr = _textBuffer.contentsAsString();\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n         _reportError(\"Unexpected end-of-input\"+msg);\n     }\n \n-    protected void _reportInvalidEOFInValue() throws JsonParseException\n-    {\n+    protected void _reportInvalidEOFInValue() throws JsonParseException {\n         _reportInvalidEOF(\" in a value\");\n+    }\n+\n+    protected void _reportMissingRootWS(int ch) throws JsonParseException {\n+        _reportUnexpectedChar(ch, \"Expected space separating root-level values\");\n     }\n     \n     protected void _throwInvalidSpace(int i)\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n                     reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                 }\n             }\n-\n             // Got it all: let's add to text buffer for parsing, access\n             --ptr; // need to push back following separator\n             _inputPtr = ptr;\n+            // As per #105, need separating space between root values; check here\n+            if (_parsingContext.inRoot()) {\n+                _verifyRootSpace(ch);\n+            }\n             int len = ptr-startPtr;\n             _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n             return reset(negative, intLen, fractLen, expLen);\n         // Ok; unless we hit end-of-input, need to push last char read back\n         if (!eof) {\n             --_inputPtr;\n+            if (_parsingContext.inRoot()) {\n+                _verifyRootSpace(c);\n+            }\n         }\n         _textBuffer.setCurrentLength(outPtr);\n         // And there we have it!\n         return null;\n     }\n \n+    /**\n+     * Method called to ensure that a root-value is followed by a space\n+     * token.\n+     *<p>\n+     * NOTE: caller MUST ensure there is at least one character available;\n+     * and that input pointer is AT given char (not past)\n+     */\n+    private final void _verifyRootSpace(int ch) throws IOException\n+    {\n+        // caller had pushed it back, before calling; reset\n+        ++_inputPtr;\n+        switch (ch) {\n+        case ' ':\n+        case '\\t':\n+            return;\n+        case '\\r':\n+            _skipCR();\n+            return;\n+        case '\\n':\n+            ++_currInputRow;\n+            _currInputRowStart = _inputPtr;\n+            return;\n+        }\n+        _reportMissingRootWS(ch);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Internal methods, secondary parsing\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n         case '7':\n         case '8':\n         case '9':\n-            t = parseNumberText(i);\n+            t = _parseNumber(i);\n             break;\n         default:\n             t = _handleUnexpectedValue(i);\n         case '7':\n         case '8':\n         case '9':\n-            return (_currToken = parseNumberText(i));\n+            return (_currToken = _parseNumber(i));\n         }\n         return (_currToken = _handleUnexpectedValue(i));\n     }\n         case '7':\n         case '8':\n         case '9':\n-            _nextToken = parseNumberText(i);\n+            _nextToken = _parseNumber(i);\n             return;\n         }\n         _nextToken = _handleUnexpectedValue(i);\n         case '8':\n         case '9':\n \n-            t = parseNumberText(i);\n+            t = _parseNumber(i);\n             break;\n         default:\n             t = _handleUnexpectedValue(i);\n      * deferred, since it is usually the most complicated and costliest\n      * part of processing.\n      */\n-    protected JsonToken parseNumberText(int c)\n+    protected JsonToken _parseNumber(int c)\n         throws IOException, JsonParseException\n     {\n         char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n             outBuf[outPtr++] = (char) c;\n         }\n         if (c == '.' || c == 'e' || c == 'E') {\n-            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n-        }\n-\n+            return _parseFloat(outBuf, outPtr, c, negative, intLen);\n+        }\n+        \n         --_inputPtr; // to push back trailing char (comma etc)\n         _textBuffer.setCurrentLength(outPtr);\n+        // As per #105, need separating space between root values; check here\n+        if (_parsingContext.inRoot()) {\n+            _verifyRootSpace(c);\n+        }\n \n         // And there we have it!\n         return resetInt(negative, intLen);\n             int c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n             if (c > INT_9 || c < INT_0) {\n                 if (c == '.' || c == 'e' || c == 'E') {\n-                    return _parseFloatText(outBuf, outPtr, c, negative, intPartLength);\n+                    return _parseFloat(outBuf, outPtr, c, negative, intPartLength);\n                 }\n                 break;\n             }\n         }\n         --_inputPtr; // to push back trailing char (comma etc)\n         _textBuffer.setCurrentLength(outPtr);\n+        // As per #105, need separating space between root values; check here\n+        if (_parsingContext.inRoot()) {\n+            _verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF);\n+        }\n \n         // And there we have it!\n         return resetInt(negative, intPartLength);\n         return ch;\n     }\n     \n-    private JsonToken _parseFloatText(char[] outBuf, int outPtr, int c,\n+    private JsonToken _parseFloat(char[] outBuf, int outPtr, int c,\n             boolean negative, int integerPartLength)\n         throws IOException, JsonParseException\n     {\n         // Ok; unless we hit end-of-input, need to push last char read back\n         if (!eof) {\n             --_inputPtr;\n+            // As per #105, need separating space between root values; check here\n+            if (_parsingContext.inRoot()) {\n+                _verifyRootSpace(c);\n+            }\n         }\n         _textBuffer.setCurrentLength(outPtr);\n \n         // And there we have it!\n         return resetFloat(negative, integerPartLength, fractLen, expLen);\n     }\n-    \n+\n+    /**\n+     * Method called to ensure that a root-value is followed by a space\n+     * token.\n+     *<p>\n+     * NOTE: caller MUST ensure there is at least one character available;\n+     * and that input pointer is AT given char (not past)\n+     */\n+    private final void _verifyRootSpace(int ch) throws IOException\n+    {\n+        // caller had pushed it back, before calling; reset\n+        ++_inputPtr;\n+        // TODO? Handle UTF-8 char decoding for error reporting\n+        switch (ch) {\n+        case ' ':\n+        case '\\t':\n+            return;\n+        case '\\r':\n+            _skipCR();\n+            return;\n+        case '\\n':\n+            ++_currInputRow;\n+            _currInputRowStart = _inputPtr;\n+            return;\n+        }\n+        _reportMissingRootWS(ch);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Internal methods, secondary parsing\n                 }\n                 break;\n             default: // e.g. -1\n-                // Is this good enough error message?\n-                if (i < 32) {\n-                    _throwInvalidSpace(i);\n-                }\n                 _reportInvalidChar(i);\n             }\n         }\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestParserErrorHandling.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestParserErrorHandling.java\n public class TestParserErrorHandling\n     extends com.fasterxml.jackson.test.BaseTest\n {\n-\n     public void testInvalidKeywordsStream() throws Exception {\n         _testInvalidKeywords(true);\n     }\n         _testInvalidKeywords(false);\n     }\n \n+    // Tests for #105 (\"eager number parsing misses errors\")\n+    public void testMangledNumbersBytes() throws Exception {\n+        _testMangledNumbers(true);\n+    }\n+\n+    public void testMangledNumbersChars() throws Exception {\n+        _testMangledNumbers(false);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Helper methods\n             jp.close();\n         }\n     }\n+\n+    private void _testMangledNumbers(boolean useStream) throws Exception\n+    {\n+        String doc = \"123true\";\n+        JsonParser jp = useStream ? createParserUsingStream(doc, \"UTF-8\")\n+                : createParserUsingReader(doc);\n+        try {\n+            JsonToken t = jp.nextToken();\n+            fail(\"Should have gotten an exception; instead got token: \"+t);\n+        } catch (JsonParseException e) {\n+            verifyException(e, \"expected space\");\n+        }\n+        jp.close();\n+\n+        // Also test with floats\n+        doc = \"1.5false\";\n+        jp = useStream ? createParserUsingStream(doc, \"UTF-8\")\n+                : createParserUsingReader(doc);\n+        try {\n+            JsonToken t = jp.nextToken();\n+            fail(\"Should have gotten an exception; instead got token: \"+t);\n+        } catch (JsonParseException e) {\n+            verifyException(e, \"expected space\");\n+        }\n+        jp.close();\n+    }\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestRootValueParsing.java\n+package com.fasterxml.jackson.core.json;\n+\n+import com.fasterxml.jackson.core.JsonFactory;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonToken;\n+\n+public class TestRootValueParsing\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    private final JsonFactory JSON_F = new JsonFactory();\n+\n+    public void testSimpleNumbers() throws Exception\n+    {\n+        _testSimpleNumbers(false);\n+        _testSimpleNumbers(true);\n+    }\n+\n+    private void _testSimpleNumbers(boolean useStream) throws Exception\n+    {\n+        final String DOC = \"1 2\\t3\\r4\\n5\\r\\n6\\r\\n   7\";\n+        JsonParser jp = useStream ?\n+                createParserUsingStream(JSON_F, DOC, \"UTF-8\")\n+                : createParserUsingReader(JSON_F, DOC);\n+        for (int i = 1; i <= 7; ++i) {\n+            assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(i, jp.getIntValue());\n+        }\n+        assertNull(jp.nextToken());\n+        jp.close();\n+    }\n+\n+    public void testSimpleBooleans() throws Exception\n+    {\n+        _testSimpleBooleans(false);\n+        _testSimpleBooleans(true);\n+    }\n+\n+    private void _testSimpleBooleans(boolean useStream) throws Exception\n+    {\n+        final String DOC = \"true false\\ttrue\\rfalse\\ntrue\\r\\nfalse\\r\\n   true\";\n+        JsonParser jp = useStream ?\n+                createParserUsingStream(JSON_F, DOC, \"UTF-8\")\n+                : createParserUsingReader(JSON_F, DOC);\n+        boolean exp = true;\n+        for (int i = 1; i <= 7; ++i) {\n+            assertToken(exp ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE, jp.nextToken());\n+            exp = !exp;\n+        }\n+        assertNull(jp.nextToken());\n+        jp.close();\n+    }\n+}", "timestamp": 1379788002, "metainfo": ""}