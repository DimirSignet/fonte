{"sha": "b48bcfa21a889bcfcf356e0e13c24ffa59f355ef", "log": "refactoring to support 12-byte symbols as separate case", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n             return _handleOddName(i);\n         }\n         // First: can we optimize out bounds checks?\n-        if ((_inputPtr + 9) > _inputEnd) { // Need 8 chars, plus one trailing (quote)\n+        if ((_inputPtr + 13) > _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\n             return slowParseName();\n         }\n \n             }\n             return parseName(_quad1, q2, i, 4);\n         }\n-        return parseLongName(i, q2);\n-    }\n-\n-    protected final Name parseLongName(int q, final int q2) throws IOException\n+        return parseMediumName2(i, q2);\n+    }\n+\n+    /**\n+     * @since 2.6\n+     */\n+    protected final Name parseMediumName2(int q3, final int q2) throws IOException\n+    {\n+        final byte[] input = _inputBuffer;\n+        final int[] codes = _icLatin1;\n+\n+        // Got 9 name bytes so far\n+        int i = input[_inputPtr++] & 0xFF;\n+        if (codes[i] != 0) {\n+            if (i == INT_QUOTE) { // 9 bytes\n+                return findName(_quad1, q2, q3, 1);\n+            }\n+            return parseName(_quad1, q2, q3, i, 1);\n+        }\n+        q3 = (q3 << 8) | i;\n+        i = input[_inputPtr++] & 0xFF;\n+        if (codes[i] != 0) {\n+            if (i == INT_QUOTE) { // 10 bytes\n+                return findName(_quad1, q2, q3, 2);\n+            }\n+            return parseName(_quad1, q2, q3, i, 2);\n+        }\n+        q3 = (q3 << 8) | i;\n+        i = input[_inputPtr++] & 0xFF;\n+        if (codes[i] != 0) {\n+            if (i == INT_QUOTE) { // 11 bytes\n+                return findName(_quad1, q2, q3, 3);\n+            }\n+            return parseName(_quad1, q2, q3, i, 3);\n+        }\n+        q3 = (q3 << 8) | i;\n+        i = input[_inputPtr++] & 0xFF;\n+        if (codes[i] != 0) {\n+            if (i == INT_QUOTE) { // 12 bytes\n+                return findName(_quad1, q2, q3, 4);\n+            }\n+            return parseName(_quad1, q2, q3, i, 4);\n+        }\n+        return parseLongName(i, q2, q3);\n+    }\n+    \n+    protected final Name parseLongName(int q, final int q2, int q3) throws IOException\n     {\n         _quadBuffer[0] = _quad1;\n         _quadBuffer[1] = q2;\n+        _quadBuffer[2] = q3;\n \n         // As explained above, will ignore UTF-8 encoding at this point\n         final byte[] input = _inputBuffer;\n         final int[] codes = _icLatin1;\n-        int qlen = 2;\n+        int qlen = 3;\n \n         while ((_inputPtr + 4) <= _inputEnd) {\n             int i = input[_inputPtr++] & 0xFF;\n \n     /**\n      * Method called when not even first 8 bytes are guaranteed\n-     * to come consecutively. Happens rarely, so this is off-lined;\n+     * to come consequtively. Happens rarely, so this is offlined;\n      * plus we'll also do full checks for escaping etc.\n      */\n     protected Name slowParseName() throws IOException\n         return parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes);\n     }\n \n+    private final Name parseName(int q1, int q2, int q3, int ch, int lastQuadBytes) throws IOException {\n+        _quadBuffer[0] = q1;\n+        _quadBuffer[1] = q2;\n+        return parseEscapedName(_quadBuffer, 2, q3, ch, lastQuadBytes);\n+    }\n+    \n     /**\n      * Slower parsing method which is generally branched to when\n      * an escape sequence is detected (or alternatively for long\n-     * names, or ones crossing input buffer boundary). In any case,\n-     * needs to be able to handle more exceptional cases, gets\n-     * slower, and hance is offlined to a separate method.\n+     * names, one crossing input buffer boundary).\n+     * Needs to be able to handle more exceptional cases, gets slower,\n+     * and hance is offlined to a separate method.\n      */\n     protected final Name parseEscapedName(int[] quads, int qlen, int currQuad, int ch,\n             int currQuadBytes) throws IOException\n             }\n             ch = _inputBuffer[_inputPtr++] & 0xFF;\n         }\n+\n         if (currQuadBytes > 0) {\n             if (qlen >= quads.length) {\n                 _quadBuffer = quads = growArrayBy(quads, quads.length);\n     /**********************************************************\n      */\n \n-    private final Name findName(int q1, int lastQuadBytes)\n-        throws JsonParseException\n+    private final Name findName(int q1, int lastQuadBytes) throws JsonParseException\n     {\n         q1 = pad(q1, lastQuadBytes);\n         // Usually we'll find it from the canonical symbol table already\n         return addName(_quadBuffer, 1, lastQuadBytes);\n     }\n \n-    private final Name findName(int q1, int q2, int lastQuadBytes)\n-        throws JsonParseException\n+    private final Name findName(int q1, int q2, int lastQuadBytes) throws JsonParseException\n     {\n         q2 = pad(q2, lastQuadBytes);\n         // Usually we'll find it from the canonical symbol table already\n         return addName(_quadBuffer, 2, lastQuadBytes);\n     }\n \n-    private final Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes)\n-        throws JsonParseException\n+    private final Name findName(int q1, int q2, int q3, int lastQuadBytes) throws JsonParseException\n+    {\n+        int[] quads = _quadBuffer;\n+        quads[0] = q1;\n+        quads[1] = q2;\n+        quads[2] = pad(q3, lastQuadBytes);\n+        Name name = _symbols.findName(quads, 3);\n+        if (name != null) {\n+            return name;\n+        }\n+        return addName(quads, 3, lastQuadBytes);\n+    }\n+    \n+    private final Name findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException\n     {\n         if (qlen >= quads.length) {\n             _quadBuffer = quads = growArrayBy(quads, quads.length);", "timestamp": 1422943866, "metainfo": ""}