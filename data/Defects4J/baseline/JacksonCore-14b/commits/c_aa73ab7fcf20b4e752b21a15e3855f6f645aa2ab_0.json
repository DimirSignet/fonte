{"sha": "aa73ab7fcf20b4e752b21a15e3855f6f645aa2ab", "log": "Merge pull request #237 from DevFactory/release/static-final-arrays-should-be-private-fix-1  Code quality fix - Static final arrays should be \"private\"", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/io/CharTypes.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/CharTypes.java\n      * Lookup table used for determining which input characters\n      * need special handling when contained in text segment.\n      */\n-    final static int[] sInputCodes;\n+    private final static int[] sInputCodes;\n     static {\n         /* 96 would do for most cases (backslash is ASCII 94)\n          * but if we want to do lookups by raw bytes it's better\n      * Additionally we can combine UTF-8 decoding info into similar\n      * data table.\n      */\n-    final static int[] sInputCodesUTF8;\n+    private final static int[] sInputCodesUTF8;\n     static {\n         final int[] table = new int[sInputCodes.length];\n         System.arraycopy(sInputCodes, 0, table, 0, table.length);\n      * Basically this is list of 8-bit ASCII characters that are legal\n      * as part of Javascript identifier\n      */\n-    final static int[] sInputCodesJsNames;\n+    private final static int[] sInputCodesJsNames;\n     static {\n         final int[] table = new int[256];\n         // Default is \"not a name char\", mark ones that are\n      * code as ok. They will be validated at a later point, when decoding\n      * name\n      */\n-    final static int[] sInputCodesUtf8JsNames;\n+    private final static int[] sInputCodesUtf8JsNames;\n     static {\n         final int[] table = new int[256];\n         // start with 8-bit JS names\n      * Decoding table used to quickly determine characters that are\n      * relevant within comment content.\n      */\n-    final static int[] sInputCodesComment;\n+    private final static int[] sInputCodesComment;\n     static {\n         final int[] buf = new int[256];\n         // but first: let's start with UTF-8 multi-byte markers:\n      * \n      * @since 2.3\n      */\n-    final static int[] sInputCodesWS;\n+    private final static int[] sInputCodesWS;\n     static {\n         // but first: let's start with UTF-8 multi-byte markers:\n         final int[] buf = new int[256];\n      * Lookup table used for determining which output characters in\n      * 7-bit ASCII range need to be quoted.\n      */\n-    final static int[] sOutputEscapes128;\n+    private final static int[] sOutputEscapes128;\n     static {\n         int[] table = new int[128];\n         // Control chars need generic escape sequence\n      * range. For actual hex digits, contains corresponding value;\n      * for others -1.\n      */\n-    final static int[] sHexValues = new int[128];\n+    private final static int[] sHexValues = new int[128];\n     static {\n         Arrays.fill(sHexValues, -1);\n         for (int i = 0; i < 10; ++i) {\n--- a/src/main/java/com/fasterxml/jackson/core/io/NumberOutput.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/NumberOutput.java\n \n     final static String SMALLEST_LONG = String.valueOf(Long.MIN_VALUE);\n \n-    final static char[] LEAD_3 = new char[4000];\n-    final static char[] FULL_3 = new char[4000];\n+    private final static char[] LEAD_3 = new char[4000];\n+    private final static char[] FULL_3 = new char[4000];\n     static {\n         /* Let's fill it with NULLs for ignorable leading digits,\n          * and digit chars for others\n         }\n     }\n \n-    final static byte[] FULL_TRIPLETS_B = new byte[4000];\n+    private final static byte[] FULL_TRIPLETS_B = new byte[4000];\n     static {\n         for (int i = 0; i < 4000; ++i) {\n             FULL_TRIPLETS_B[i] = (byte) FULL_3[i];\n         }\n     }\n     \n-    final static String[] sSmallIntStrs = new String[] {\n+    private final static String[] sSmallIntStrs = new String[] {\n         \"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\"\n     };\n-    final static String[] sSmallIntStrs2 = new String[] {\n+    private final static String[] sSmallIntStrs2 = new String[] {\n         \"-1\",\"-2\",\"-3\",\"-4\",\"-5\",\"-6\",\"-7\",\"-8\",\"-9\",\"-10\"\n     };\n \n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n     // intermediate copies only made up to certain length...\n     private final static int MAX_BYTES_TO_BUFFER = 512;\n \n-    final static byte[] HEX_CHARS = CharTypes.copyHexBytes();\n+    private final static byte[] HEX_CHARS = CharTypes.copyHexBytes();\n \n     private final static byte[] NULL_BYTES = { 'n', 'u', 'l', 'l' };\n     private final static byte[] TRUE_BYTES = { 't', 'r', 'u', 'e' };\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n     /**\n      * Pointer to next available character in buffer\n      */\n-    protected int _inputPtr = 0;\n+    protected int _inputPtr;\n \n     /**\n      * Index of character after last available one in the buffer.\n      */\n-    protected int _inputEnd = 0;\n+    protected int _inputEnd;\n \n     /*\n     /**********************************************************\n      * Number of characters/bytes that were contained in previous blocks\n      * (blocks that were already processed prior to the current buffer).\n      */\n-    protected long _currInputProcessed = 0L;\n+    protected long _currInputProcessed;\n \n     /**\n      * Current row location of current point in input buffer, starting\n      * of not having column itself is that this only has to be updated\n      * once per line.\n      */\n-    protected int _currInputRowStart = 0;\n+    protected int _currInputRowStart;\n \n     /*\n     /**********************************************************\n      * For big (gigabyte-sized) sizes are possible, needs to be long,\n      * unlike pointers and sizes related to in-memory buffers.\n      */\n-    protected long _tokenInputTotal = 0; \n+    protected long _tokenInputTotal;\n \n     /**\n      * Input row on which current token starts, 1-based\n      * Column on input row that current token starts; 0-based (although\n      * in the end it'll be converted to 1-based)\n      */\n-    protected int _tokenInputCol = 0;\n+    protected int _tokenInputCol;\n \n     /*\n     /**********************************************************\n      * using {@link #getTextCharacters} method (instead of String\n      * returning alternatives)\n      */\n-    protected char[] _nameCopyBuffer = null;\n+    protected char[] _nameCopyBuffer;\n \n     /**\n      * Flag set to indicate whether the field name is available\n      * from the name copy buffer or not (in addition to its String\n      * representation  being available via read context)\n      */\n-    protected boolean _nameCopied = false;\n+    protected boolean _nameCopied;\n \n     /**\n      * ByteArrayBuilder is needed if 'getBinaryValue' is called. If so,\n      * we better reuse it for remainder of content.\n      */\n-    protected ByteArrayBuilder _byteArrayBuilder = null;\n+    protected ByteArrayBuilder _byteArrayBuilder;\n \n     /**\n      * We will hold on to decoded binary data, for duration of\n--- a/src/main/java/com/fasterxml/jackson/core/filter/FilteringGeneratorDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/FilteringGeneratorDelegate.java\n      * Marked as deprecated since its status is uncertain.\n      */\n     @Deprecated\n-    protected boolean _includeImmediateParent = false;\n+    protected boolean _includeImmediateParent;\n \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java\n      * Marked as deprecated since its status is uncertain.\n      */\n     @Deprecated\n-    protected boolean _includeImmediateParent = false;\n+    protected boolean _includeImmediateParent;\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/core/filter/TokenFilterContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/TokenFilterContext.java\n     /**********************************************************\n      */\n \n-    protected TokenFilterContext _child = null;\n+    protected TokenFilterContext _child;\n \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\n      * Reference to the allocated I/O buffer for low-level input reading,\n      * if any allocated.\n      */\n-    protected byte[] _readIOBuffer = null;\n+    protected byte[] _readIOBuffer;\n \n     /**\n      * Reference to the allocated I/O buffer used for low-level\n      * encoding-related buffering.\n      */\n-    protected byte[] _writeEncodingBuffer = null;\n+    protected byte[] _writeEncodingBuffer;\n     \n     /**\n      * Reference to the buffer allocated for temporary use with\n      * base64 encoding or decoding.\n      */\n-    protected byte[] _base64Buffer = null;\n+    protected byte[] _base64Buffer;\n \n     /**\n      * Reference to the buffer allocated for tokenization purposes,\n      * in which character input is read, and from which it can be\n      * further returned.\n      */\n-    protected char[] _tokenCBuffer = null;\n+    protected char[] _tokenCBuffer;\n \n     /**\n      * Reference to the buffer allocated for buffering it for\n      * output, before being encoded: generally this means concatenating\n      * output, then encoding when buffer fills up.\n      */\n-    protected char[] _concatCBuffer = null;\n+    protected char[] _concatCBuffer;\n \n     /**\n      * Reference temporary buffer Parser instances need if calling\n      * Regular text buffer can not be used as it may contain textual\n      * representation of the value token.\n      */\n-    protected char[] _nameCopyBuffer = null;\n+    protected char[] _nameCopyBuffer;\n \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/core/io/UTF32Reader.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/UTF32Reader.java\n     /**\n      * Total read character count; used for error reporting purposes\n      */\n-    protected int _charCount = 0;\n+    protected int _charCount;\n \n     /**\n      * Total read byte count; used for error reporting purposes\n      */\n-    protected int _byteCount = 0;\n+    protected int _byteCount;\n \n     protected final boolean _managedBuffers;\n     \n         }\n     }\n \n-    protected char[] _tmpBuf = null;\n+    protected char[] _tmpBuf;\n \n     /**\n      * Although this method is implemented by the base class, AND it should\n--- a/src/main/java/com/fasterxml/jackson/core/io/UTF8Writer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/UTF8Writer.java\n      * To do this, both pairs must be known first; and since it is possible\n      * pairs may be split, we need temporary storage for the first half\n      */\n-    private int _surrogate = 0;\n+    private int _surrogate;\n \n     public UTF8Writer(IOContext ctxt, OutputStream out)\n     {\n--- a/src/main/java/com/fasterxml/jackson/core/json/ByteSourceJsonBootstrapper.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ByteSourceJsonBootstrapper.java\n \n     protected boolean _bigEndian = true;\n \n-    protected int _bytesPerChar = 0; // 0 means \"dunno yet\"\n+    protected int _bytesPerChar; // 0 means \"dunno yet\"\n \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/core/json/JsonGeneratorImpl.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonGeneratorImpl.java\n         super(features, codec);\n         _ioContext = ctxt;\n         if (isEnabled(Feature.ESCAPE_NON_ASCII)) {\n-            setHighestNonEscapedChar(127);\n+            // inlined `setHighestNonEscapedChar()`\n+            _maximumNonEscapedChar = 127;\n         }\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/core/json/JsonReadContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonReadContext.java\n     /**********************************************************\n      */\n \n-    protected JsonReadContext _child = null;\n+    protected JsonReadContext _child;\n \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java\n     /**********************************************************\n      */\n \n-    protected JsonWriteContext _child = null;\n+    protected JsonWriteContext _child;\n \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n      * been fully processed, and needs to be finished for\n      * some access (or skipped to obtain the next token)\n      */\n-    protected boolean _tokenIncomplete = false;\n+    protected boolean _tokenIncomplete;\n \n     /**\n      * Value of {@link #_inputPtr} at the time when the first character of\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n      * Pointer to the position right beyond the last character to output\n      * (end marker; may be past the buffer)\n      */\n-    protected int _outputTail = 0;\n+    protected int _outputTail;\n \n     /**\n      * End marker of the output buffer; one past the last valid position\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n      * been fully processed, and needs to be finished for\n      * some access (or skipped to obtain the next token)\n      */\n-    protected boolean _tokenIncomplete = false;\n+    protected boolean _tokenIncomplete;\n \n     /**\n      * Temporary storage for partially parsed name bytes.\n--- a/src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java\n     /**\n      * Pointer to the first buffered character to output\n      */\n-    protected int _outputHead = 0;\n+    protected int _outputHead;\n \n     /**\n      * Pointer to the position right beyond the last character to output\n      * (end marker; may point to position right beyond the end of the buffer)\n      */\n-    protected int _outputTail = 0;\n+    protected int _outputTail;\n \n     /**\n      * End marker of the output buffer; one past the last valid position\n--- a/src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java\n      * Number of open levels of nesting. Used to determine amount of\n      * indentation to use.\n      */\n-    protected transient int _nesting = 0;\n+    protected transient int _nesting;\n \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n     /**\n      * Flag that indicates whether _seqments is non-empty\n      */\n-    private boolean _hasSegments = false;\n+    private boolean _hasSegments;\n \n     // // // Currently used segment; not (yet) contained in _seqments\n ", "timestamp": 1450248711, "metainfo": ""}