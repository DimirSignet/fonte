{"sha": "404aebc80a44310e471d6d2a7596d3dc88036e40", "log": "more work on parsing-filter side; not complete.", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/filter/FilteringGeneratorDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/FilteringGeneratorDelegate.java\n             return;\n         }\n \n-        TokenFilter state = _filterContext.checkValue(_itemFilter);\n-        if (state == null) {\n+        TokenFilter f = _filterContext.checkValue(_itemFilter);\n+        if (f == null) {\n             return;\n         }\n         \n-        if (state != TokenFilter.INCLUDE_ALL) {\n-            state = state.filterStartObject();\n-        }\n-        if (state == TokenFilter.INCLUDE_ALL) {\n-            _checkParentPath();\n-            _filterContext = _filterContext.createChildObjectContext(state, true);\n+        if (f != TokenFilter.INCLUDE_ALL) {\n+            f = f.filterStartObject();\n+        }\n+        if (f == TokenFilter.INCLUDE_ALL) {\n+            _checkParentPath();\n+            _filterContext = _filterContext.createChildObjectContext(f, true);\n             delegate.writeStartObject();\n         } else { // filter out\n-            _filterContext = _filterContext.createChildObjectContext(state, false);\n+            _filterContext = _filterContext.createChildObjectContext(f, false);\n         }\n     }\n     \n--- a/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java\n         }\n \n         // otherwise... to include or not?\n-        switch (_currToken.id()) {\n+        TokenFilter f;\n+        \n+        switch (t.id()) {\n         case ID_START_ARRAY:\n-            if (_itemFilter == null) {\n+            f = _itemFilter;\n+            if (f == TokenFilter.INCLUDE_ALL) {\n+                _headContext = _headContext.createChildArrayContext(f, true);\n+                return (_currToken = t);\n+            }\n+            if (f == null) { // does this occur?\n                 delegate.skipChildren();\n                 break;\n             }\n-            if (_itemFilter == TokenFilter.INCLUDE_ALL) {\n-                _headContext = _headContext.createChildArrayContext(_itemFilter, true);\n+            // Otherwise still iffy, need to check\n+            f = _headContext.checkValue(f);\n+            if (f == null) {\n+                delegate.skipChildren();\n+                break;\n+            }\n+            if (f != TokenFilter.INCLUDE_ALL) {\n+                f = f.filterStartArray();\n+            }\n+            _itemFilter = f;\n+            _headContext = _headContext.createChildArrayContext(f, true);\n+            if (f == TokenFilter.INCLUDE_ALL) {\n                 return (_currToken = t);\n             }\n-            // TODO\n+            // but if we didn't figure it out yet, need to buffer possible events\n+            return _nextTokenWithBuffering(_headContext);\n \n         case ID_START_OBJECT:\n-            if (_itemFilter == null) {\n+            f = _itemFilter;\n+            if (f == TokenFilter.INCLUDE_ALL) {\n+                _headContext = _headContext.createChildObjectContext(f, true);\n+                return (_currToken = t);\n+            }\n+            if (f == null) { // does this occur?\n                 delegate.skipChildren();\n                 break;\n             }\n-            if (_itemFilter == TokenFilter.INCLUDE_ALL) {\n-                _headContext = _headContext.createChildObjectContext(_itemFilter, true);\n+            // Otherwise still iffy, need to check\n+            f = _headContext.checkValue(f);\n+            if (f == null) {\n+                delegate.skipChildren();\n+                break;\n+            }\n+            if (f != TokenFilter.INCLUDE_ALL) {\n+                f = f.filterStartObject();\n+            }\n+            _itemFilter = f;\n+            _headContext = _headContext.createChildObjectContext(f, true);\n+            if (f == TokenFilter.INCLUDE_ALL) {\n                 return (_currToken = t);\n             }\n-            // TODO\n+            // but if we didn't figure it out yet, need to buffer possible events\n+            return _nextTokenWithBuffering(_headContext);\n \n         case ID_END_ARRAY:\n         case ID_END_OBJECT:\n             {\n                 boolean returnEnd = _headContext.isStartHandled();\n-                TokenFilter f = _headContext.getFilter();\n+                f = _headContext.getFilter();\n                 if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                     f.filterFinishArray();\n                 }\n             break;\n \n         case ID_FIELD_NAME:\n+            {\n+                final String name = delegate.getCurrentName();\n+                f = _headContext.setFieldName(name);\n+                if (f == TokenFilter.INCLUDE_ALL) {\n+                    _itemFilter = f;\n+                    return (_currToken = t);\n+                }\n+                if (f == null) { // filter out the value\n+                    delegate.nextToken();\n+                    delegate.skipChildren();\n+                    break;\n+                }\n+                f = f.includeProperty(name);\n+                if (f == null) { // filter out the value\n+                    delegate.nextToken();\n+                    delegate.skipChildren();\n+                    break;\n+                }\n+                if (f == TokenFilter.INCLUDE_ALL) {\n+                    _itemFilter = f;\n+                    return (_currToken = t);\n+                }\n+                // !!! TODO: still not decided if to include, so...\n+                \n+                _itemFilter = f;\n+            }\n+            break;\n \n         default: // scalar value\n+            if (_itemFilter == TokenFilter.INCLUDE_ALL) {\n+                return (_currToken = t);\n+            }\n+            // Otherwise not included (leaves must be explicitly included)\n+            break;\n         }\n \n         // We get here if token was not yet found; offlined handling\n         return _nextToken2();\n     }\n \n+    /**\n+     * Offlined handling for cases where there was no buffered token to\n+     * return, and the token read next could not be returned as-is,\n+     * at least not yet.\n+     */\n     protected final JsonToken _nextToken2() throws IOException\n     {\n+        while (true) {\n+            JsonToken t = delegate.nextToken();\n+            if (t == null) { // is this really legal? For the moment, assume it is\n+                return (_currToken = t);\n+            }\n+            switch (_currToken.id()) {\n+            case ID_START_ARRAY:\n+                if (_itemFilter == TokenFilter.INCLUDE_ALL) {\n+                    _headContext = _headContext.createChildArrayContext(_itemFilter, true);\n+                    return (_currToken = t);\n+                }\n+                if (_itemFilter == null) { // does this occur?\n+                    delegate.skipChildren();\n+                    break;\n+                }\n+                _exposedContext = _headContext = _headContext.createChildArrayContext(_itemFilter, false);\n+                break;\n+    \n+            case ID_START_OBJECT:\n+                if (_itemFilter == TokenFilter.INCLUDE_ALL) {\n+                    _headContext = _headContext.createChildObjectContext(_itemFilter, true);\n+                    return (_currToken = t);\n+                }\n+                if (_itemFilter == null) { // does this occur?\n+                    delegate.skipChildren();\n+                    break;\n+                }\n+                _exposedContext = _headContext = _headContext.createChildObjectContext(_itemFilter, false);\n+                break;\n+    \n+            case ID_END_ARRAY:\n+            case ID_END_OBJECT:\n+                {\n+                    boolean returnEnd = _headContext.isStartHandled();\n+                    TokenFilter f = _headContext.getFilter();\n+                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n+                        f.filterFinishArray();\n+                    }\n+                    _headContext = _headContext.getParent();\n+                    _itemFilter = _headContext.getFilter();\n+                    if (returnEnd) {\n+                        return (_currToken = t);\n+                    }\n+                }\n+                break;\n+    \n+            case ID_FIELD_NAME:\n+                {\n+                    final String name = delegate.getCurrentName();\n+                    TokenFilter f = _headContext.setFieldName(name);\n+                    if (f == null) { // filter out the value\n+                        delegate.nextToken();\n+                        delegate.skipChildren();\n+                        break;\n+                    }\n+                    if (_itemFilter == TokenFilter.INCLUDE_ALL) {\n+                        _itemFilter = f;\n+                        return (_currToken = t);\n+                    }\n+                    f = f.includeProperty(name);\n+                    _itemFilter = f;\n+                }\n+                break;\n+\n+            default: // scalar value\n+                if (_itemFilter == TokenFilter.INCLUDE_ALL) {\n+                    return (_currToken = t);\n+                }\n+                // Otherwise not included (leaves must be explicitly included)\n+                break;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method called when a new potentially included context is found.\n+     */\n+    protected final JsonToken _nextTokenWithBuffering(TokenFilterContext buffRoot) throws IOException\n+    {\n+        _exposedContext = _headContext;\n         // !!! TODO\n         return null;\n     }\n--- a/src/main/java/com/fasterxml/jackson/core/filter/TokenFilter.java\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/TokenFilter.java\n      * Call made when verifying whether a scaler value is being\n      * read from a parser.\n      *<p>\n-     * Default action is to call {@link #_includeScalar()} and return\n+     * Default action is to call <code>_includeScalar()</code> and return\n      * whatever it indicates.\n      */\n     public boolean includeValue(JsonParser p) throws IOException {", "timestamp": 1429076827, "metainfo": ""}