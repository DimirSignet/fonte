{"sha": "b0ceb4eeb69f20f0e4242736ae3e19ed2b9c5da3", "log": "Add `IOContext withEncoding()`, some unrelated sample code", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\n         _encoding = enc;\n     }\n \n+    /**\n+     * @since 1.6\n+     */\n+    public IOContext withEncoding(JsonEncoding enc) {\n+        _encoding = enc;\n+        return this;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Public API, accessors\n--- /dev/null\n+++ b/src/test/java/perf/EnumByBytesLookup.java\n+package perf;\n+\n+import java.nio.charset.Charset;\n+import java.util.Arrays;\n+\n+/**\n+ * Trie container/wrapper, in this case implements Enum-value lookup.\n+ * Sample code to possibly use for streamlined-lookup by dictionary, using\n+ * UTF-8 bytes of {@link Enum#name()} as the key.\n+ */\n+public class EnumByBytesLookup<E extends Enum<E>>\n+{\n+    private final static Charset UTF8 = Charset.forName(\"UTF-8\");\n+\n+    private final Trie<E> _root;\n+    private final int _size;\n+\n+    private EnumByBytesLookup(Trie<E> root, int size) {\n+        _root = root;\n+        _size = size;\n+    }\n+\n+    public static <EIN extends Enum<EIN>> EnumByBytesLookup<EIN> buildFor(Class<EIN> enumClass)\n+    {\n+        Trie<EIN> root = new Trie<EIN>(null);\n+        int size = 0;\n+        for (EIN en : enumClass.getEnumConstants()) {\n+            byte[] key = en.name().getBytes(UTF8);\n+            root = root.with(en, key);\n+            ++size;\n+        }\n+        return new EnumByBytesLookup<EIN>(root, size);\n+    }\n+\n+    public E find(byte[] rawId) {\n+      return _root.find(rawId);\n+    }\n+\n+    public int size() { return _size; }\n+}\n+\n+/**\n+ * Trie nodes\n+ */\n+class Trie<T> {\n+    private final static byte[] NO_BYTES = new byte[0];\n+\n+    private final static Trie<?>[] NO_NODES = new Trie<?>[0];\n+\n+    /**\n+     * For leaves, value matched by sequence\n+     */\n+    private final T _match;\n+\n+    private final byte[] _nextBytes;\n+    private final Trie<T>[] nextNodes;\n+\n+    private final int nextCount;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    Trie(T match) {\n+      this(match, NO_BYTES, (Trie<T>[]) NO_NODES);\n+    }\n+\n+    private Trie(T match, byte[] nextBytes, Trie<T>[] nextNodes) {\n+      this._match = match;\n+      this._nextBytes = nextBytes;\n+      this.nextNodes = nextNodes;\n+      nextCount = nextBytes.length;\n+    }\n+\n+    private Trie(Trie<T> base, T match) {\n+      // should we allow duplicate calls with same match? For now, let's not\n+      if (base._match != null) {\n+        throw new IllegalArgumentException(\"Trying to add same match multiple times\");\n+      }\n+      this._match = match;\n+      _nextBytes = base._nextBytes;\n+      nextNodes = base.nextNodes;\n+      nextCount = base.nextCount;\n+    }\n+\n+    private Trie(Trie<T> base, byte nextByte, Trie<T> nextNode) {\n+      // should we allow duplicate calls with same match? For now, let's not\n+      if (base._match != null) {\n+        throw new IllegalArgumentException(\"Trying to add same match multiple times\");\n+      }\n+      _match = base._match;\n+      int size = base._nextBytes.length + 1;\n+      _nextBytes = Arrays.copyOf(base._nextBytes, size);\n+      _nextBytes[size-1] = nextByte;\n+      nextNodes = Arrays.copyOf(base.nextNodes, size);\n+      nextNodes[size-1] = nextNode;\n+      nextCount = size;\n+    }\n+\n+    /**\n+     * Constructor used when an existing branch needs to be replaced due to addition\n+     */\n+    private Trie(Trie<T> base, int offset, Trie<T> newNode) {\n+      _match = base._match;\n+      // can keep nextBytes, as they don't change\n+      _nextBytes = base._nextBytes;\n+      // but must create a copy of next nodes, to modify one entry\n+      nextNodes = Arrays.copyOf(base.nextNodes, base.nextNodes.length);\n+      nextNodes[offset] = newNode;\n+      nextCount = base.nextCount;\n+    }\n+\n+    /**\n+     * \"Mutant factory\" method: constructs a modified Trie, with specified raw id\n+     * added.\n+     */\n+    public Trie<T> with(T match, byte[] rawId) {\n+      return with(match, rawId, 0, rawId.length);\n+    }\n+\n+    private Trie<T> with(T match, byte[] rawId, int start, int end) {\n+      if (start == end) {\n+        return new Trie<T>(this, match);\n+      }\n+      // Ok: two choices; either we follow existing branch; or need to create new one\n+      final byte b = rawId[start++];\n+      for (int i = 0; i < nextCount; ++i) {\n+        if (_nextBytes[i] == b) {\n+          // existing branch: good day for delegation...\n+          Trie<T> old = nextNodes[i];\n+          // to keep things truly immutable, copy underlying arrays, then\n+          return new Trie<T>(this, i, old.with(match, rawId, start, end));\n+        }\n+      }\n+      // simplest recursively, but for fun let's convert to iteration. Start with tail\n+      Trie<T> curr = new Trie<T>(match);\n+\n+      for (int i = end-1; i >= start; --i) {\n+        curr = new Trie<T>(this, rawId[i], curr);\n+      }\n+      return new Trie<T>(this, b, curr);\n+    }\n+\n+    public T find(byte[] id) {\n+      return find(id, 0, id.length);\n+    }\n+\n+    public T find(byte[] id, int offset, int length) {\n+      Trie<T> t = this;\n+      final int end = offset+length;\n+\n+      for (; offset < end; ++offset) {\n+        byte b = id[offset];\n+        t = t.next(b);\n+        if (t == null) {\n+            // NOTE: if using null-padding, would trim here\n+            /*\n+          if (b == (byte) 0) {\n+            break;\n+          }\n+          */\n+          return null;\n+        }\n+      }\n+      return t._match;\n+    }\n+\n+    private Trie<T> next(int b) {\n+      for (int i = 0; i < nextCount; ++i) {\n+        if (_nextBytes[i] == b) {\n+          return nextNodes[i];\n+        }\n+      }\n+      return null;\n+    }\n+}", "timestamp": 1421100060, "metainfo": ""}