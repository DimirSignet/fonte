{"sha": "32e4e9152823258764c91262d94d54989397c5b7", "log": "More stylistic tweaks, moving to more compact format (sorry!)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n      * Method for accessing custom escapes factory uses for {@link JsonGenerator}s\n      * it creates.\n      */\n-    public CharacterEscapes getCharacterEscapes() {\n-        return _characterEscapes;\n-    }\n+    public CharacterEscapes getCharacterEscapes() { return _characterEscapes; }\n \n     /**\n      * Method for defining custom escapes factory uses for {@link JsonGenerator}s\n      * \n      * @since 2.1\n      */\n-    public JsonParser createParser(File f)\n-        throws IOException, JsonParseException\n-    {\n+    public JsonParser createParser(File f) throws IOException, JsonParseException {\n         // true, since we create InputStream from File\n         IOContext ctxt = _createContext(f, true);\n         InputStream in = new FileInputStream(f);\n      * \n      * @since 2.1\n      */\n-    public JsonParser createParser(URL url)\n-        throws IOException, JsonParseException\n-    {\n+    public JsonParser createParser(URL url) throws IOException, JsonParseException {\n         // true, since we create InputStream from URL\n         IOContext ctxt = _createContext(url, true);\n         InputStream in = _optimizedStreamFromURL(url);\n      * \n      * @since 2.1\n      */\n-    public JsonParser createParser(InputStream in)\n-        throws IOException, JsonParseException\n-    {\n+    public JsonParser createParser(InputStream in) throws IOException, JsonParseException {\n         IOContext ctxt = _createContext(in, false);\n         // [JACKSON-512]: allow wrapping with InputDecorator\n         if (_inputDecorator != null) {\n      * \n      * @since 2.1\n      */\n-    public JsonParser createParser(Reader r)\n-        throws IOException, JsonParseException\n-    {\n+    public JsonParser createParser(Reader r) throws IOException, JsonParseException {\n         // false -> we do NOT own Reader (did not create it)\n         IOContext ctxt = _createContext(r, false);\n         // [JACKSON-512]: allow wrapping with InputDecorator\n      * \n      * @since 2.1\n      */\n-    public JsonParser createParser(byte[] data)\n-        throws IOException, JsonParseException\n-    {\n+    public JsonParser createParser(byte[] data) throws IOException, JsonParseException {\n         IOContext ctxt = _createContext(data, true);\n         // [JACKSON-512]: allow wrapping with InputDecorator\n         if (_inputDecorator != null) {\n      * \n      * @since 2.1\n      */\n-    public JsonParser createParser(byte[] data, int offset, int len)\n-        throws IOException, JsonParseException\n-    {\n+    public JsonParser createParser(byte[] data, int offset, int len) throws IOException, JsonParseException {\n         IOContext ctxt = _createContext(data, true);\n         // [JACKSON-512]: allow wrapping with InputDecorator\n         if (_inputDecorator != null) {\n      * \n      * @since 2.1\n      */\n-    public JsonParser createParser(String content) throws IOException, JsonParseException\n-    {\n+    public JsonParser createParser(String content) throws IOException, JsonParseException {\n         Reader r = new StringReader(content);\n         // true -> we own the Reader (and must close); not a big deal\n         IOContext ctxt = _createContext(r, true);\n--- a/src/main/java/com/fasterxml/jackson/core/JsonParseException.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonParseException.java\n  * (content that does not conform to JSON syntax as per specification)\n  * is encountered.\n  */\n-public class JsonParseException\n-    extends JsonProcessingException\n-{\n+public class JsonParseException extends JsonProcessingException {\n     private static final long serialVersionUID = 1L;\n     \n-    public JsonParseException(String msg, JsonLocation loc)\n-    {\n+    public JsonParseException(String msg, JsonLocation loc) {\n         super(msg, loc);\n     }\n \n-    public JsonParseException(String msg, JsonLocation loc, Throwable root)\n-    {\n+    public JsonParseException(String msg, JsonLocation loc, Throwable root) {\n         super(msg, loc, root);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n      * @return Next token from the stream, if any found, or null\n      *   to indicate end-of-input\n      */\n-    public abstract JsonToken nextToken() throws IOException;\n+    public abstract JsonToken nextToken() throws IOException, JsonParseException;\n \n     /**\n      * Iteration method that will advance stream enough\n      *   parsers, {@link JsonToken#NOT_AVAILABLE} if no tokens were\n      *   available yet)\n      */\n-    public abstract JsonToken nextValue() throws IOException;\n+    public abstract JsonToken nextValue() throws IOException, JsonParseException;\n \n     /**\n      * Method that fetches next token (as if calling {@link #nextToken}) and\n      * \n      * @param str Property name to compare next token to (if next token is <code>JsonToken.FIELD_NAME<code>)\n      */\n-    public boolean nextFieldName(SerializableString str) throws IOException {\n+    public boolean nextFieldName(SerializableString str) throws IOException, JsonParseException {\n         return (nextToken() == JsonToken.FIELD_NAME) && str.getValue().equals(getCurrentName());\n     }\n \n      * but may be faster for parser to process, and can therefore be used if caller\n      * expects to get a String value next from input.\n      */\n-    public String nextTextValue() throws IOException {\n+    public String nextTextValue() throws IOException, JsonParseException {\n         return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n     }\n \n      * but may be faster for parser to process, and can therefore be used if caller\n      * expects to get a String value next from input.\n      */\n-    public int nextIntValue(int defaultValue) throws IOException {\n+    public int nextIntValue(int defaultValue) throws IOException, JsonParseException {\n         return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n     }\n \n      * but may be faster for parser to process, and can therefore be used if caller\n      * expects to get a String value next from input.\n      */\n-    public long nextLongValue(long defaultValue) throws IOException {\n+    public long nextLongValue(long defaultValue) throws IOException, JsonParseException {\n         return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n     }\n \n      * but may be faster for parser to process, and can therefore be used if caller\n      * expects to get a String value next from input.\n      */\n-    public Boolean nextBooleanValue() throws IOException {\n+    public Boolean nextBooleanValue() throws IOException, JsonParseException {\n         JsonToken t = nextToken();\n         if (t == JsonToken.VALUE_TRUE) { return Boolean.TRUE; }\n         if (t == JsonToken.VALUE_FALSE) { return Boolean.FALSE; }\n      * will call {@link #nextToken} to point to the next\n      * available token, if any.\n      */\n-    public abstract JsonParser skipChildren() throws IOException;\n+    public abstract JsonParser skipChildren() throws IOException, JsonParseException;\n     \n     /**\n      * Method that can be called to determine whether this parser\n--- a/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\n      * Constructor used for creating \"empty\" instance, used to represent\n      * state that matches current node.\n      */\n-    protected JsonPointer()\n-    {\n+    protected JsonPointer() {\n         _nextSegment = null;\n         _matchingPropertyName = \"\";\n         _matchingElementIndex = -1;\n     /**\n      * Constructor used for creating non-empty Segments\n      */\n-    protected JsonPointer(String fullString, String segment, JsonPointer next)\n-    {\n+    protected JsonPointer(String fullString, String segment, JsonPointer next) {\n         _asString = fullString;\n         _nextSegment = next;\n         // Ok; may always be a property\n      *   expression: currently the only such expression is one that does NOT start with\n      *   a slash ('/').\n      */\n-    public static JsonPointer compile(String input)\n-        throws IllegalArgumentException\n+    public static JsonPointer compile(String input) throws IllegalArgumentException\n     {\n         // First quick checks for well-known 'empty' pointer\n         if ((input == null) || input.length() == 0) {\n         }\n         // And then quick validity check:\n         if (input.charAt(0) != '/') {\n-            throw new IllegalArgumentException(\"Invalid input: JSON Pointer expression must start with '/': \"\n-                    +\"\\\"\"+input+\"\\\"\");\n+            throw new IllegalArgumentException(\"Invalid input: JSON Pointer expression must start with '/': \"+\"\\\"\"+input+\"\\\"\");\n         }\n         return _parseTail(input);\n     }\n      */\n     public static JsonPointer valueOf(String input) { return compile(input); }\n \n-    /*\n-    \n-    /**\n-     * Factory method that composes a pointer instance, given a set\n+    /* Factory method that composes a pointer instance, given a set\n      * of 'raw' segments: raw meaning that no processing will be done,\n      * no escaping may is present.\n      * \n     /**********************************************************\n      */\n \n-    public boolean matches() {\n-        return _nextSegment == null;\n-    }\n-    \n-    public String getMatchingProperty() {\n-        return _matchingPropertyName;\n-    }\n-\n-    public int getMatchingIndex() {\n-        return _matchingElementIndex;\n-    }\n-\n-    public boolean mayMatchProperty() {\n-        return _matchingPropertyName != null;\n-    }\n-\n-    public boolean mayMatchElement() {\n-        return _matchingElementIndex >= 0;\n-    }\n+    public boolean matches() { return _nextSegment == null; }\n+    public String getMatchingProperty() { return _matchingPropertyName; }\n+    public int getMatchingIndex() { return _matchingElementIndex; }\n+    public boolean mayMatchProperty() { return _matchingPropertyName != null; }\n+    public boolean mayMatchElement() { return _matchingElementIndex >= 0; }\n \n     public JsonPointer matchProperty(String name) {\n         if (_nextSegment == null || !_matchingPropertyName.equals(name)) {\n     /**********************************************************\n      */\n \n-    @Override\n-    public String toString() {\n-        return _asString;\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return _asString.hashCode();\n-    }\n-\n-    @Override\n-    public boolean equals(Object o)\n-    {\n+    @Override public String toString() { return _asString; }\n+    @Override public int hashCode() { return _asString.hashCode(); }\n+\n+    @Override public boolean equals(Object o) {\n         if (o == this) return true;\n         if (o == null) return false;\n-        if (!(o instanceof JsonPointer)) {\n-            return false;\n-        }\n+        if (!(o instanceof JsonPointer)) return false;\n         return _asString.equals(((JsonPointer) o)._asString);\n     }\n     \n     /**********************************************************\n      */\n \n-    private final static int _parseInt(String str)\n-    {\n+    private final static int _parseInt(String str) {\n         final int len = str.length();\n         if (len == 0) {\n             return -1;\n         return NumberInput.parseInt(str);\n     }\n     \n-    protected static JsonPointer _parseTail(String input)\n-    {\n+    protected static JsonPointer _parseTail(String input) {\n         final int end = input.length();\n \n         // first char is the contextual slash, skip\n      * @param input Full input for the tail being parsed\n      * @param i Offset to character after tilde\n      */\n-    protected static JsonPointer _parseQuotedTail(String input, int i)\n-    {\n+    protected static JsonPointer _parseQuotedTail(String input, int i) {\n         final int end = input.length();\n         StringBuilder sb = new StringBuilder(Math.max(16, end));\n         if (i > 2) {\n         return new JsonPointer(input, sb.toString(), EMPTY);\n     }\n     \n-    private static void _appendEscape(StringBuilder sb, char c)\n-    {\n+    private static void _appendEscape(StringBuilder sb, char c) {\n         if (c == '0') {\n             c = '~';\n         } else if (c == '1') {\n--- a/src/main/java/com/fasterxml/jackson/core/JsonProcessingException.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonProcessingException.java\n  * Regular {@link java.io.IOException}s will be passed through as is.\n  * Sub-class of {@link java.io.IOException} for convenience.\n  */\n-public class JsonProcessingException\n-    extends java.io.IOException\n+public class JsonProcessingException extends java.io.IOException\n {\n     final static long serialVersionUID = 123; // Stupid eclipse...\n \t\n     protected JsonLocation _location;\n \n-    protected JsonProcessingException(String msg, JsonLocation loc, Throwable rootCause)\n-    {\n+    protected JsonProcessingException(String msg, JsonLocation loc, Throwable rootCause) {\n         /* Argh. IOException(Throwable,String) is only available starting\n          * with JDK 1.6...\n          */\n         _location = loc;\n     }\n \n-    protected JsonProcessingException(String msg)\n-    {\n+    protected JsonProcessingException(String msg) {\n         super(msg);\n     }\n \n-    protected JsonProcessingException(String msg, JsonLocation loc)\n-    {\n+    protected JsonProcessingException(String msg, JsonLocation loc) {\n         this(msg, loc, null);\n     }\n \n-    protected JsonProcessingException(String msg, Throwable rootCause)\n-    {\n+    protected JsonProcessingException(String msg, Throwable rootCause) {\n         this(msg, null, rootCause);\n     }\n \n-    protected JsonProcessingException(Throwable rootCause)\n-    {\n+    protected JsonProcessingException(Throwable rootCause) {\n         this(null, null, rootCause);\n     }\n \n-    public JsonLocation getLocation() {\n-        return _location;\n-    }\n+    public JsonLocation getLocation() { return _location; }\n \n     /*\n     /**********************************************************\n      * \n      * @since 2.1\n      */\n-    public String getOriginalMessage()\n-    {\n-        return super.getMessage();\n-    }\n+    public String getOriginalMessage() { return super.getMessage(); }\n \n     /*\n     /**********************************************************\n      * information right after the main message, but before\n      * source location information.\n      */\n-    protected String getMessageSuffix() {\n-        return null;\n-    }\n+    protected String getMessageSuffix() { return null; }\n \n     /*\n     /**********************************************************\n     /**\n      * Default method overridden so that we can add location information\n      */\n-    @Override\n-    public String getMessage()\n-    {\n+    @Override public String getMessage() {\n         String msg = super.getMessage();\n         if (msg == null) {\n             msg = \"N/A\";\n         return msg;\n     }\n \n-    @Override\n-    public String toString() {\n-        return getClass().getName()+\": \"+getMessage();\n-    }\n+    @Override public String toString() { return getClass().getName()+\": \"+getMessage(); }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/JsonStreamContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonStreamContext.java\n     /**\n      * @return Number of entries that are complete and started.\n      */\n-    public final int getEntryCount()\n-    {\n-        return _index + 1;\n-    }\n+    public final int getEntryCount() { return _index + 1; }\n \n     /**\n      * @return Index of the currently processed entry, if any\n      */\n-    public final int getCurrentIndex()\n-    {\n-        return (_index < 0) ? 0 : _index;\n-    }\n+    public final int getCurrentIndex() { return (_index < 0) ? 0 : _index; }\n \n     /**\n      * Method for accessing name associated with the current location.\n--- a/src/main/java/com/fasterxml/jackson/core/JsonToken.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonToken.java\n     public final char[] asCharArray() { return _serializedChars; }\n     public final byte[] asByteArray() { return _serializedBytes; }\n \n-    public final boolean isNumeric() {\n-        return _isNumber;\n-    }\n+    public final boolean isNumeric() { return _isNumber; }\n \n     /**\n      * Accessor that is functionally equivalent to:\n      * \n      * @since 2.3\n      */\n-    public final boolean isStructStart() {\n-        return _isStructStart;\n-    }\n+    public final boolean isStructStart() { return _isStructStart; }\n \n     /**\n      * Accessor that is functionally equivalent to:\n      * \n      * @since 2.3\n      */\n-    public final boolean isStructEnd() {\n-        return _isStructEnd;\n-    }\n+    public final boolean isStructEnd() { return _isStructEnd; }\n \n     /**\n      * Method that can be used to check whether this token represents\n      * a valid non-structured value. This means all tokens other than\n      * Object/Array start/end markers all field names.\n      */\n-    public final boolean isScalarValue() {\n-        return _isScalar;\n-    }\n-\n-    public final boolean isBoolean() {\n-        return _isBoolean;\n-    }\n+    public final boolean isScalarValue() { return _isScalar; }\n+    public final boolean isBoolean() { return _isBoolean; }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/TreeCodec.java\n+++ b/src/main/java/com/fasterxml/jackson/core/TreeCodec.java\n  */\n public abstract class TreeCodec\n {\n-    public abstract <T extends TreeNode> T readTree(JsonParser jp)\n-        throws IOException, JsonProcessingException;\n-\n-    public abstract void writeTree(JsonGenerator jg, TreeNode tree)\n-        throws IOException, JsonProcessingException;\n-\n+    public abstract <T extends TreeNode> T readTree(JsonParser jp) throws IOException, JsonProcessingException;\n+    public abstract void writeTree(JsonGenerator jg, TreeNode tree) throws IOException, JsonProcessingException;\n     public abstract TreeNode createArrayNode();\n     public abstract TreeNode createObjectNode();\n-\n     public abstract JsonParser treeAsTokens(TreeNode node);\n }\n--- a/src/main/java/com/fasterxml/jackson/core/TreeNode.java\n+++ b/src/main/java/com/fasterxml/jackson/core/TreeNode.java\n      * \n      * @since 2.3\n      */\n-    TreeNode at(String jsonPointerExpression)\n-        throws IllegalArgumentException;\n+    TreeNode at(String jsonPointerExpression) throws IllegalArgumentException;\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/core/Version.java\n+++ b/src/main/java/com/fasterxml/jackson/core/Version.java\n  * if provided, they should align with Maven artifact information.\n  */\n public class Version\n-    implements Comparable<Version>,\n-        java.io.Serializable\n+    implements Comparable<Version>, java.io.Serializable\n {\n     private static final long serialVersionUID = 1L;\n \n         return _groupId + '/' + _artifactId + '/' + toString();\n     }\n     \n-    @Override\n-    public String toString()\n-    {\n+    @Override public String toString() {\n         StringBuilder sb = new StringBuilder();\n         sb.append(_majorVersion).append('.');\n         sb.append(_minorVersion).append('.');\n         return sb.toString();\n     }\n \n-    @Override\n-    public int hashCode() {\n+    @Override public int hashCode() {\n         return _artifactId.hashCode() ^ _groupId.hashCode() + _majorVersion - _minorVersion + _patchLevel;\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n  * to applications, adds shared internal methods that sub-classes\n  * can use and adds some abstract methods sub-classes must implement.\n  */\n-public abstract class GeneratorBase\n-    extends JsonGenerator\n+public abstract class GeneratorBase extends JsonGenerator\n {\n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n \n-    protected GeneratorBase(int features, ObjectCodec codec)\n-    {\n+    protected GeneratorBase(int features, ObjectCodec codec) {\n         super();\n         _features = features;\n         DupDetector dups = Feature.STRICT_DUPLICATE_DETECTION.enabledIn(features)\n      * Implemented with detection that tries to find \"VERSION.txt\" in same\n      * package as the implementation class.\n      */\n-    @Override\n-    public Version version() {\n-        return VersionUtil.versionFor(getClass());\n-    }\n+    @Override public Version version() { return VersionUtil.versionFor(getClass()); }\n     \n     /*\n     /**********************************************************\n \n     //public JsonGenerator configure(Feature f, boolean state) { }\n \n-    @Override\n-    public final boolean isEnabled(Feature f) {\n-        return (_features & f.getMask()) != 0;\n-    }\n-\n-    @Override\n-    public int getFeatureMask() {\n-        return _features;\n-    }\n-\n-    @Override\n-    public JsonGenerator setFeatureMask(int mask) {\n+    @Override public final boolean isEnabled(Feature f) { return (_features & f.getMask()) != 0; }\n+    @Override public int getFeatureMask() { return _features; }\n+\n+    @Override public JsonGenerator setFeatureMask(int mask) {\n         _features = mask;\n         return this;\n     }\n     \n-    @Override\n-    public JsonGenerator useDefaultPrettyPrinter() {\n+    @Override public JsonGenerator useDefaultPrettyPrinter() {\n         /* 28-Sep-2012, tatu: As per [Issue#84], should not override a\n          *  pretty printer if one already assigned.\n          */\n         return setPrettyPrinter(new DefaultPrettyPrinter());\n     }\n     \n-    @Override\n-    public JsonGenerator setCodec(ObjectCodec oc) {\n+    @Override public JsonGenerator setCodec(ObjectCodec oc) {\n         _objectCodec = oc;\n         return this;\n     }\n \n-    @Override\n-    public final ObjectCodec getCodec() { return _objectCodec; }\n+    @Override public final ObjectCodec getCodec() { return _objectCodec; }\n \n     /*\n     /**********************************************************\n     /**\n      * Note: co-variant return type.\n      */\n-    @Override\n-    public final JsonWriteContext getOutputContext() { return _writeContext; }\n+    @Override public final JsonWriteContext getOutputContext() { return _writeContext; }\n \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n \n-    //public void writeStartArray() throws IOException, JsonGenerationException\n-    //public void writeEndArray() throws IOException, JsonGenerationException\n-    //public void writeStartObject() throws IOException, JsonGenerationException\n-    //public void writeEndObject() throws IOException, JsonGenerationException\n+    //public void writeStartArray() throws IOException\n+    //public void writeEndArray() throws IOException\n+    //public void writeStartObject() throws IOException\n+    //public void writeEndObject() throws IOException\n \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n \n-    @Override\n-    public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException {\n+    @Override public void writeFieldName(SerializableString name) throws IOException {\n         writeFieldName(name.getValue());\n     }\n     \n-    //public abstract void writeString(String text) throws IOException, JsonGenerationException;\n-\n-    //public abstract void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException;\n-\n-    //public abstract void writeRaw(String text) throws IOException, JsonGenerationException;\n-\n-    //public abstract void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException;\n-\n-    @Override\n-    public void writeString(SerializableString text) throws IOException, JsonGenerationException {\n+    //public abstract void writeString(String text) throws IOException;\n+\n+    //public abstract void writeString(char[] text, int offset, int len) throws IOException;\n+\n+    //public abstract void writeRaw(String text) throws IOException,;\n+\n+    //public abstract void writeRaw(char[] text, int offset, int len) throws IOException;\n+\n+    @Override\n+    public void writeString(SerializableString text) throws IOException {\n         writeString(text.getValue());\n     }\n     \n-    @Override\n-    public void writeRawValue(String text) throws IOException, JsonGenerationException\n-    {\n+    @Override public void writeRawValue(String text) throws IOException {\n         _verifyValueWrite(\"write raw value\");\n         writeRaw(text);\n     }\n \n-    @Override\n-    public void writeRawValue(String text, int offset, int len)\n-        throws IOException, JsonGenerationException\n-    {\n+    @Override public void writeRawValue(String text, int offset, int len) throws IOException {\n         _verifyValueWrite(\"write raw value\");\n         writeRaw(text, offset, len);\n     }\n \n-    @Override\n-    public void writeRawValue(char[] text, int offset, int len)\n-        throws IOException, JsonGenerationException\n-    {\n+    @Override public void writeRawValue(char[] text, int offset, int len) throws IOException {\n         _verifyValueWrite(\"write raw value\");\n         writeRaw(text, offset, len);\n     }\n \n     @Override\n-    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength)\n-        throws IOException, JsonGenerationException {\n+    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException {\n         // Let's implement this as \"unsupported\" to make it easier to add new parser impls\n         _reportUnsupportedOperation();\n         return 0;\n      */\n \n     @Override\n-    public void writeObject(Object value)\n-        throws IOException, JsonProcessingException\n-    {\n+    public void writeObject(Object value) throws IOException {\n         if (value == null) {\n             // important: call method that does check value write:\n             writeNull();\n     }\n \n     @Override\n-    public void writeTree(TreeNode rootNode)\n-        throws IOException, JsonProcessingException\n-    {\n+    public void writeTree(TreeNode rootNode) throws IOException {\n         // As with 'writeObject()', we are not check if write would work\n         if (rootNode == null) {\n             writeNull();\n     /**********************************************************\n      */\n \n-    @Override\n-    public abstract void flush() throws IOException;\n-\n-    @Override\n-    public void close() throws IOException\n-    {\n-        _closed = true;\n-    }\n-\n-    @Override\n-    public boolean isClosed() { return _closed; }\n+    @Override public abstract void flush() throws IOException;\n+    @Override public void close() throws IOException { _closed = true; }\n+    @Override public boolean isClosed() { return _closed; }\n \n     /*\n     /**********************************************************\n      * @param typeMsg Additional message used for generating exception message\n      *   if value output is NOT legal in current generator output state.\n      */\n-    protected abstract void _verifyValueWrite(String typeMsg)\n-        throws IOException, JsonGenerationException;\n-\n-    // @Deprecated in 2.3 -- now defined in super-class; remove in 2.4\n-    @Override \n-    protected void _writeSimpleObject(Object value) \n-        throws IOException, JsonGenerationException\n-    {\n-        // TODO: \n-        super._writeSimpleObject(value);\n-    }\n+    protected abstract void _verifyValueWrite(String typeMsg) throws IOException;\n }\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n  * implementations. Contains most common things that are independent\n  * of actual underlying input source.\n  */\n-public abstract class ParserBase\n-    extends ParserMinimalBase\n+public abstract class ParserBase extends ParserMinimalBase\n {\n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n \n-    protected ParserBase(IOContext ctxt, int features)\n-    {\n+    protected ParserBase(IOContext ctxt, int features) {\n         super();\n         _features = features;\n         _ioContext = ctxt;\n         _parsingContext = JsonReadContext.createRootContext(dups);\n     }\n \n-    @Override\n-    public Version version() {\n-        return PackageVersion.VERSION;\n-    }\n+    @Override public Version version() { return PackageVersion.VERSION; }\n \n     /*\n     /**********************************************************\n      * Method that can be called to get the name associated with\n      * the current event.\n      */\n-    @Override\n-    public String getCurrentName() throws IOException\n-    {\n+    @Override public String getCurrentName() throws IOException {\n         // [JACKSON-395]: start markers require information from parent\n         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n             JsonReadContext parent = _parsingContext.getParent();\n         return _parsingContext.getCurrentName();\n     }\n \n-    @Override\n-    public void overrideCurrentName(String name)\n-    {\n+    @Override public void overrideCurrentName(String name) {\n         // Simple, but need to look for START_OBJECT/ARRAY's \"off-by-one\" thing:\n         JsonReadContext ctxt = _parsingContext;\n         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n         }\n     }\n     \n-    @Override\n-    public void close() throws IOException {\n+    @Override public void close() throws IOException {\n         if (!_closed) {\n             _closed = true;\n             try {\n         }\n     }\n \n-    @Override\n-    public boolean isClosed() { return _closed; }\n-\n-    @Override\n-    public JsonReadContext getParsingContext() {\n-        return _parsingContext;\n-    }\n+    @Override public boolean isClosed() { return _closed; }\n+    @Override public JsonReadContext getParsingContext() { return _parsingContext; }\n \n     /**\n      * Method that return the <b>starting</b> location of the current\n      * that starts the current token.\n      */\n     @Override\n-    public JsonLocation getTokenLocation()\n-    {\n+    public JsonLocation getTokenLocation() {\n         return new JsonLocation(_ioContext.getSourceReference(),\n                 -1L, getTokenCharacterOffset(), // bytes, chars\n                 getTokenLineNr(),\n      * usually for error reporting purposes\n      */\n     @Override\n-    public JsonLocation getCurrentLocation()\n-    {\n+    public JsonLocation getCurrentLocation() {\n         int col = _inputPtr - _currInputRowStart + 1; // 1-based\n         return new JsonLocation(_ioContext.getSourceReference(),\n                 -1L, _currInputProcessed + _inputPtr, // bytes, chars\n      */\n \n     @Override\n-    public boolean hasTextCharacters()\n-    {\n-        if (_currToken == JsonToken.VALUE_STRING) {\n-            return true; // usually true\n-        }        \n-        if (_currToken == JsonToken.FIELD_NAME) {\n-            return _nameCopied;\n-        }\n+    public boolean hasTextCharacters() {\n+        if (_currToken == JsonToken.VALUE_STRING) { return true; } // usually true        \n+        if (_currToken == JsonToken.FIELD_NAME) { return _nameCopied; }\n         return false;\n     }\n \n     // No embedded objects with base impl...\n-    @Override\n-    public Object getEmbeddedObject() throws IOException {\n-        return null;\n-    }\n+    @Override public Object getEmbeddedObject() throws IOException { return null; }\n     \n     /*\n     /**********************************************************\n      */\n \n     protected abstract boolean loadMore() throws IOException;\n-    \n     protected abstract void _finishString() throws IOException;\n-\n     protected abstract void _closeInput() throws IOException;\n     \n     /*\n      * example, when explicitly closing this reader instance), or\n      * separately (if need be).\n      */\n-    protected void _releaseBuffers() throws IOException\n-    {\n+    protected void _releaseBuffers() throws IOException {\n         _textBuffer.releaseBuffers();\n         char[] buf = _nameCopyBuffer;\n         if (buf != null) {\n      * is no open non-root context.\n      */\n     @Override\n-    protected void _handleEOF() throws JsonParseException\n-    {\n+    protected void _handleEOF() throws JsonParseException {\n         if (!_parsingContext.inRoot()) {\n             _reportInvalidEOF(\": expected close marker for \"+_parsingContext.getTypeDesc()+\" (from \"+_parsingContext.getStartLocation(_ioContext.getSourceReference())+\")\");\n         }\n     /**********************************************************\n      */\n     \n-    protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException\n-    {\n+    protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException {\n         String startDesc = \"\"+_parsingContext.getStartLocation(_ioContext.getSourceReference());\n         _reportError(\"Unexpected close marker '\"+((char) actCh)+\"': expected '\"+expCh+\"' (for \"+_parsingContext.getTypeDesc()+\" starting at \"+startDesc+\")\");\n     }\n         return bits;\n     }\n     \n-    protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex)\n-        throws IllegalArgumentException\n-    {\n+    protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex) throws IllegalArgumentException {\n         return reportInvalidBase64Char(b64variant, ch, bindex, null);\n     }\n \n      * @param bindex Relative index within base64 character unit; between 0\n      *   and 3 (as unit has exactly 4 characters)\n      */\n-    protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg)\n-        throws IllegalArgumentException\n-    {\n+    protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException {\n         String base;\n         if (ch <= INT_SPACE) {\n             base = \"Illegal white space character (code 0x\"+Integer.toHexString(ch)+\") as character #\"+(bindex+1)+\" of 4-char base64 unit: can only used between units\";\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n  * (size) and functionality that is specific to certain types\n  * of parser implementations; but not necessarily to number of methods.\n  */\n-public abstract class ParserMinimalBase\n-    extends JsonParser\n+public abstract class ParserMinimalBase extends JsonParser\n {\n     // Control chars:\n     protected final static int INT_TAB = '\\t';\n      */\n \n     protected ParserMinimalBase() { }\n-    protected ParserMinimalBase(int features) {\n-        super(features);\n-    }\n-\n-    @Override\n-    public Version version() {\n-        return VersionUtil.versionFor(getClass());\n-    }\n+    protected ParserMinimalBase(int features) { super(features); }\n+\n+    // NOTE: had base impl in 2.3 and before; but shouldn't\n+    // public abstract Version version();\n     \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n \n-    @Override\n-    public abstract JsonToken nextToken() throws IOException, JsonParseException;\n-\n-    @Override\n-    public JsonToken getCurrentToken() {\n-        return _currToken;\n-    }\n-\n-    @Override\n-    public final int getCurrentTokenId() {\n+    @Override public abstract JsonToken nextToken() throws IOException, JsonParseException;\n+    @Override public JsonToken getCurrentToken() { return _currToken; }\n+\n+    @Override public final int getCurrentTokenId() {\n         final JsonToken t = _currToken;\n         return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n     }\n     \n-    @Override\n-    public boolean hasCurrentToken() {\n-        return _currToken != null;\n-    }\n-    \n-    @Override\n-    public JsonToken nextValue()\n-        throws IOException, JsonParseException\n-    {\n+    @Override public boolean hasCurrentToken() { return _currToken != null; }\n+    \n+    @Override\n+    public JsonToken nextValue() throws IOException {\n         /* Implementation should be as trivial as follows; only\n          * needs to change if we are to skip other tokens (for\n          * example, if comments were exposed as tokens)\n     }\n \n     @Override\n-    public JsonParser skipChildren() throws IOException, JsonParseException\n+    public JsonParser skipChildren() throws IOException\n     {\n         if (_currToken != JsonToken.START_OBJECT\n             && _currToken != JsonToken.START_ARRAY) {\n     protected abstract void _handleEOF() throws JsonParseException;\n \n     //public JsonToken getCurrentToken()\n-\n     //public boolean hasCurrentToken()\n \n-    @Override\n-    public abstract String getCurrentName() throws IOException, JsonParseException;\n-    \n-    @Override\n-    public abstract void close() throws IOException;\n-\n-    @Override\n-    public abstract boolean isClosed();\n-\n-    @Override\n-    public abstract JsonStreamContext getParsingContext();\n+    @Override public abstract String getCurrentName() throws IOException;\n+    @Override public abstract void close() throws IOException;\n+    @Override public abstract boolean isClosed();\n+\n+    @Override public abstract JsonStreamContext getParsingContext();\n \n //    public abstract JsonLocation getTokenLocation();\n \n     /**********************************************************\n      */\n \n-    @Override\n-    public void clearCurrentToken() {\n+    @Override public void clearCurrentToken() {\n         if (_currToken != null) {\n             _lastClearedToken = _currToken;\n             _currToken = null;\n         }\n     }\n \n-    @Override\n-    public JsonToken getLastClearedToken() {\n-        return _lastClearedToken;\n-    }\n-\n-    @Override\n-    public abstract void overrideCurrentName(String name);\n+    @Override public JsonToken getLastClearedToken() { return _lastClearedToken; }\n+\n+    @Override public abstract void overrideCurrentName(String name);\n     \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n \n-    @Override\n-    public abstract String getText() throws IOException, JsonParseException;\n-\n-    @Override\n-    public abstract char[] getTextCharacters() throws IOException, JsonParseException;\n-\n-    @Override\n-    public abstract boolean hasTextCharacters();\n-\n-    @Override\n-    public abstract int getTextLength() throws IOException, JsonParseException;\n-\n-    @Override\n-    public abstract int getTextOffset() throws IOException, JsonParseException;  \n+    @Override public abstract String getText() throws IOException;\n+    @Override public abstract char[] getTextCharacters() throws IOException;\n+    @Override public abstract boolean hasTextCharacters();\n+    @Override public abstract int getTextLength() throws IOException;\n+    @Override public abstract int getTextOffset() throws IOException;  \n \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n \n-    @Override\n-    public abstract byte[] getBinaryValue(Base64Variant b64variant)\n-        throws IOException, JsonParseException;\n+    @Override public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException;\n \n     /*\n     /**********************************************************\n      */\n \n     @Override\n-    public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException\n+    public boolean getValueAsBoolean(boolean defaultValue) throws IOException\n     {\n         JsonToken t = _currToken;\n         if (t != null) {\n     }\n \n     @Override\n-    public int getValueAsInt(int defaultValue) throws IOException, JsonParseException\n+    public int getValueAsInt(int defaultValue) throws IOException\n     {\n         JsonToken t = _currToken;\n         if (t != null) {\n     }\n     \n     @Override\n-    public long getValueAsLong(long defaultValue) throws IOException, JsonParseException\n+    public long getValueAsLong(long defaultValue) throws IOException\n     {\n         JsonToken t = _currToken;\n         if (t != null) {\n     }\n \n     @Override\n-    public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException\n+    public double getValueAsDouble(double defaultValue) throws IOException\n     {\n         JsonToken t = _currToken;\n         if (t != null) {\n     }\n \n     @Override\n-    public String getValueAsString(String defaultValue) throws IOException, JsonParseException\n-    {\n+    public String getValueAsString(String defaultValue) throws IOException {\n         if (_currToken != JsonToken.VALUE_STRING) {\n             if (_currToken == null || _currToken == JsonToken.VALUE_NULL || !_currToken.isScalarValue()) {\n                 return defaultValue;\n      * Helper method that can be used for base64 decoding in cases where\n      * encoded content has already been read as a String.\n      */\n-    protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant)\n-        throws IOException, JsonParseException\n+    protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException\n     {\n         // just call helper method introduced in 2.2.3\n         try {\n      * \n      * @since 2.3\n      */\n-    protected boolean _hasTextualNull(String value) {\n-        return \"null\".equals(value);\n-    }\n+    protected boolean _hasTextualNull(String value) { return \"null\".equals(value); }\n     \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n     \n-    protected void _reportUnexpectedChar(int ch, String comment)\n-        throws JsonParseException\n+    protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException\n     {\n         if (ch < 0) { // sanity check\n             _reportInvalidEOF();\n         _reportError(msg);\n     }\n \n-    protected void _reportInvalidEOF()\n-        throws JsonParseException\n-    {\n+    protected void _reportInvalidEOF() throws JsonParseException {\n         _reportInvalidEOF(\" in \"+_currToken);\n     }\n \n-    protected void _reportInvalidEOF(String msg)\n-        throws JsonParseException\n-    {\n+    protected void _reportInvalidEOF(String msg) throws JsonParseException {\n         _reportError(\"Unexpected end-of-input\"+msg);\n     }\n \n         _reportUnexpectedChar(ch, \"Expected space separating root-level values\");\n     }\n     \n-    protected void _throwInvalidSpace(int i)\n-        throws JsonParseException\n-    {\n+    protected void _throwInvalidSpace(int i) throws JsonParseException {\n         char c = (char) i;\n         String msg = \"Illegal character (\"+_getCharDesc(c)+\"): only regular white space (\\\\r, \\\\n, \\\\t) is allowed between tokens\";\n         _reportError(msg);\n      * Note: starting with version 1.4, it is possible to suppress\n      * exception by enabling {@link Feature#ALLOW_UNQUOTED_CONTROL_CHARS}.\n      */\n-    protected void _throwUnquotedSpace(int i, String ctxtDesc)\n-        throws JsonParseException\n-    {\n+    protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException {\n         // JACKSON-208; possible to allow unquoted control chars:\n         if (!isEnabled(Feature.ALLOW_UNQUOTED_CONTROL_CHARS) || i >= INT_SPACE) {\n             char c = (char) i;\n         }\n     }\n \n-    protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException\n-    {\n+    protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException {\n         // as per [JACKSON-300]\n         if (isEnabled(Feature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER)) {\n             return ch;\n--- a/src/main/java/com/fasterxml/jackson/core/format/DataFormatDetector.java\n+++ b/src/main/java/com/fasterxml/jackson/core/format/DataFormatDetector.java\n      * Method that will return a detector instance that allows detectors to\n      * read up to specified number of bytes when determining format match strength.\n      */\n-    public DataFormatDetector withMaxInputLookahead(int lookaheadBytes)\n-    {\n+    public DataFormatDetector withMaxInputLookahead(int lookaheadBytes) {\n         if (lookaheadBytes == _maxInputLookahead) {\n             return this;\n         }\n     }\n     \n     private DataFormatDetector(JsonFactory[] detectors,\n-            MatchStrength optMatch, MatchStrength minMatch,\n-            int maxInputLookahead)\n-    {\n+            MatchStrength optMatch, MatchStrength minMatch, int maxInputLookahead) {\n         _detectors = detectors;\n         _optimalMatch = optMatch;\n         _minimalMatch = minMatch;\n      * @return Matcher object which contains result; never null, even in cases\n      *    where no match (with specified minimal match strength) is found.\n      */\n-    public DataFormatMatcher findFormat(InputStream in) throws IOException\n-    {\n+    public DataFormatMatcher findFormat(InputStream in) throws IOException {\n         return _findFormat(new InputAccessor.Std(in, new byte[_maxInputLookahead]));\n     }\n \n      * @return Matcher object which contains result; never null, even in cases\n      *    where no match (with specified minimal match strength) is found.\n      */\n-    public DataFormatMatcher findFormat(byte[] fullInputData) throws IOException\n-    {\n+    public DataFormatMatcher findFormat(byte[] fullInputData) throws IOException {\n         return _findFormat(new InputAccessor.Std(fullInputData));\n     }\n \n      * \n      * @since 2.1\n      */\n-    public DataFormatMatcher findFormat(byte[] fullInputData, int offset, int len) throws IOException\n-    {\n+    public DataFormatMatcher findFormat(byte[] fullInputData, int offset, int len) throws IOException {\n         return _findFormat(new InputAccessor.Std(fullInputData, offset, len));\n     }\n     \n     /**********************************************************\n      */\n \n-    @Override\n-    public String toString()\n-    {\n+    @Override public String toString() {\n         StringBuilder sb = new StringBuilder();\n         sb.append('[');\n         final int len = _detectors.length;\n     /**********************************************************\n      */\n \n-    private DataFormatMatcher _findFormat(InputAccessor.Std acc) throws IOException\n-    {\n+    private DataFormatMatcher _findFormat(InputAccessor.Std acc) throws IOException {\n         JsonFactory bestMatch = null;\n         MatchStrength bestMatchStrength = null;\n         for (JsonFactory f : _detectors) {", "timestamp": 1390795168, "metainfo": ""}