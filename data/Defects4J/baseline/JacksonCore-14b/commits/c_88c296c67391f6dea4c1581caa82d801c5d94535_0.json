{"sha": "88c296c67391f6dea4c1581caa82d801c5d94535", "log": "Unit test coverage improvements, to get to 70%/60% level (line/branch) for 2.6", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/util/VersionUtil.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/VersionUtil.java\n  * 2.1 and 2.2; earlier code used file named \"VERSION.txt\"; but this has serious\n  * performance issues on some platforms (Android), so a replacement system\n  * was implemented to use class generation and dynamic class loading.\n+ *<p>\n+ * Note that functionality for reading \"VERSION.txt\" was removed completely\n+ * from Jackson 2.6.\n  */\n public class VersionUtil\n {\n      * First, tries to load version info from a class named\n      * \"PackageVersion\" in the same package as the class.\n      *\n-     * Next, if that fails, class loader that loaded specified class is\n-     * asked to load resource with name \"VERSION\" from same location\n-     * (package) as class itself had.\n-     *\n      * If no version information is found, {@link Version#unknownVersion()} is returned.\n      */\n-    @SuppressWarnings(\"resource\")\n     public static Version versionFor(Class<?> cls)\n     {\n-        Version packageVersion = packageVersionFor(cls);\n-        if (packageVersion != null) {\n-            return packageVersion;\n-        }\n-        final InputStream in = cls.getResourceAsStream(\"VERSION.txt\");\n-        if (in == null) {\n-            return Version.unknownVersion();\n-        }\n-        try {\n-            InputStreamReader reader = new InputStreamReader(in, \"UTF-8\");\n-            return doReadVersion(reader);\n-        } catch (UnsupportedEncodingException e) {\n-            return Version.unknownVersion();\n-        } finally {\n-            _close(in);\n-        }\n+        return packageVersionFor(cls);\n     }\n \n     /**\n             } catch (Exception e) {\n                 throw new IllegalArgumentException(\"Failed to get Versioned out of \"+vClass);\n             }\n-        } catch (Exception e) { // ok to be missing (not good, acceptable)\n+        } catch (Exception e) { // ok to be missing (not good but acceptable)\n             return null;\n         }\n-    }\n-\n-    private static Version doReadVersion(final Reader r)\n-    {\n-        String version = null, group = null, artifact = null;\n-\n-        final BufferedReader br = new BufferedReader(r);\n-        try {\n-            version = br.readLine();\n-            if (version != null) {\n-                group = br.readLine();\n-                if (group != null) {\n-                    artifact = br.readLine();\n-                }\n-            }\n-        } catch (IOException ignored) {\n-        } finally {\n-            _close(br);\n-        }\n-        // We don't trim() version: parseVersion() takes care ot that\n-        if (group != null) {\n-            group = group.trim();\n-        }\n-        if (artifact != null) {\n-            artifact = artifact.trim();\n-        }\n-        return parseVersion(version, group, artifact);\n     }\n \n     /**\n      * @param groupId the groupId of the library\n      * @param artifactId the artifactId of the library\n      * @return The version\n+     * \n+     * @deprecated Since 2.6: functionality not used by any official Jackson component, should be\n+     *   moved out if anyone needs it\n      */\n     @SuppressWarnings(\"resource\")\n+    @Deprecated // since 2.6\n     public static Version mavenVersionFor(ClassLoader cl, String groupId, String artifactId)\n     {\n         InputStream pomProperties = cl.getResourceAsStream(\"META-INF/maven/\"\n         return Version.unknownVersion();\n     }\n \n+    /**\n+     * Method used by {@link PackageVersion} to decode version injected by Maven build.\n+     */\n     public static Version parseVersion(String s, String groupId, String artifactId)\n     {\n         if (s != null && (s = s.trim()).length() > 0) {\n--- a/src/test/java/com/fasterxml/jackson/core/filter/BasicGeneratorFilteringTest.java\n+++ b/src/test/java/com/fasterxml/jackson/core/filter/BasicGeneratorFilteringTest.java\n package com.fasterxml.jackson.core.filter;\n \n import java.io.*;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n         assertEquals(1, gen.getMatchCount());\n     }\n \n+    public void testSingleMatchFilteringWithPathSkippedArray() throws Exception\n+    {\n+        StringWriter w = new StringWriter();\n+        JsonGenerator origGen = JSON_F.createGenerator(w);\n+        NameMatchFilter filter = new NameMatchFilter(\"value\");\n+        FilteringGeneratorDelegate gen = new FilteringGeneratorDelegate(origGen,\n+                filter,\n+                true, // includePath\n+                false // multipleMatches\n+                );\n+\n+        // Hmmh. Should we get access to eventual target?\n+        assertSame(w, gen.getOutputTarget());\n+        assertNotNull(gen.getFilterContext());\n+        assertSame(filter, gen.getFilter());\n+\n+        final String JSON = \"{'array':[1,[2,3]],'ob':[{'value':'bar'}],'b':{'foo':[1,'foo']}}\";\n+        writeJsonDoc(JSON_F, JSON, gen);\n+        assertEquals(aposToQuotes(\"{'ob':[{'value':'bar'}]}\"), w.toString());\n+        assertEquals(1, gen.getMatchCount());\n+    }\n+\n     // Alternative take, using slightly different calls for FIELD_NAME, START_ARRAY\n-    public void testSingleMatchFilteringWithPathAlternate() throws Exception\n+    public void testSingleMatchFilteringWithPathAlternate1() throws Exception\n     {\n         StringWriter w = new StringWriter();\n         FilteringGeneratorDelegate gen = new FilteringGeneratorDelegate(JSON_F.createGenerator(w),\n                 true, // includePath\n                 false // multipleMatches\n                 );\n-        //final String JSON = \"{'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':'foo'},'b':true}\";\n+        //final String JSON = \"{'a':123,'array':[1,2],'ob':{'value0':2,'value':[3],'value2':'foo'},'b':true}\";\n \n         gen.writeStartObject();\n         gen.writeFieldName(new SerializedString(\"a\"));\n         gen.writeFieldName(\"array\");\n         gen.writeStartArray(2);\n         gen.writeNumber(\"1\");\n-        gen.writeNumber(2);\n+        gen.writeNumber((short) 2);\n         gen.writeEndArray();\n \n         gen.writeFieldName(new SerializedString(\"ob\"));\n         gen.writeStartObject();\n         gen.writeNumberField(\"value0\", 2);\n         gen.writeFieldName(new SerializedString(\"value\"));\n-        gen.writeNumber(3); // just to vary generation method\n+        gen.writeStartArray(1);\n+        gen.writeString(new SerializedString(\"x\")); // just to vary generation method\n+        gen.writeEndArray();\n         gen.writeStringField(\"value2\", \"foo\");\n \n         gen.writeEndObject();\n         gen.writeEndObject();\n         gen.close();\n \n-        assertEquals(aposToQuotes(\"{'ob':{'value':3}}\"), w.toString());\n+        assertEquals(aposToQuotes(\"{'ob':{'value':['x']}}\"), w.toString());\n+    }\n+\n+    public void testSingleMatchFilteringWithPathRawBinary() throws Exception\n+    {\n+        StringWriter w = new StringWriter();\n+        FilteringGeneratorDelegate gen = new FilteringGeneratorDelegate(JSON_F.createGenerator(w),\n+                new NameMatchFilter(\"array\"),\n+                true, // includePath\n+                false // multipleMatches\n+                );\n+        //final String JSON = \"{'header':['ENCODED',raw],'array':['base64stuff',1,2,3,4,5,6.25,7.5],'extra':[1,2,3,4,5,6.25,7.5]}\";\n+\n+        gen.writeStartObject();\n+\n+        gen.writeFieldName(\"header\");\n+        gen.writeStartArray();\n+        gen.writeBinary(new byte[] { 1 });\n+        gen.writeRawValue(new SerializedString(\"1\"));\n+        gen.writeRawValue(\"2\");\n+        gen.writeEndArray();\n+        \n+        gen.writeFieldName(\"array\");\n+\n+        gen.writeStartArray();\n+        gen.writeBinary(new byte[] { 1 });\n+        gen.writeNumber((short) 1);\n+        gen.writeNumber((int) 2);\n+        gen.writeNumber((long) 3);\n+        gen.writeNumber(BigInteger.valueOf(4));\n+        gen.writeRaw(\" \");\n+        gen.writeNumber(new BigDecimal(\"5.0\"));\n+        gen.writeRaw(new SerializedString(\" /*x*/\"));\n+        gen.writeNumber(6.25f);\n+        gen.writeNumber(7.5);\n+        gen.writeEndArray();\n+\n+        gen.writeArrayFieldStart(\"extra\");\n+        gen.writeNumber((short) 1);\n+        gen.writeNumber((int) 2);\n+        gen.writeNumber((long) 3);\n+        gen.writeNumber(BigInteger.valueOf(4));\n+        gen.writeNumber(new BigDecimal(\"5.0\"));\n+        gen.writeNumber(6.25f);\n+        gen.writeNumber(7.5);\n+        gen.writeEndArray();\n+        \n+        gen.writeEndObject();\n+        gen.close();\n+\n+        assertEquals(aposToQuotes(\"{'array':['AQ==',1,2,3,4 ,5.0 /*x*/,6.25,7.5]}\"), w.toString());\n     }\n     \n     public void testMultipleMatchFilteringWithPath1() throws Exception\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/ParserSequenceTest.java\n+package com.fasterxml.jackson.core.json;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.util.JsonParserSequence;\n+\n+public class ParserSequenceTest\n+    extends com.fasterxml.jackson.core.BaseTest\n+{\n+    private final JsonFactory JSON_FACTORY = new JsonFactory();\n+\n+    public void testSimple() throws Exception\n+    {\n+        JsonParser p1 = JSON_FACTORY.createParser(\"[ 1 ]\");\n+        JsonParser p2 = JSON_FACTORY.createParser(\"[ 2 ]\");\n+        JsonParserSequence seq = JsonParserSequence.createFlattened(p1, p2);\n+        assertEquals(2, seq.containedParsersCount());\n+\n+        assertFalse(p1.isClosed());\n+        assertFalse(p2.isClosed());\n+        assertFalse(seq.isClosed());\n+        assertToken(JsonToken.START_ARRAY, seq.nextToken());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, seq.nextToken());\n+        assertEquals(1, seq.getIntValue());\n+        assertToken(JsonToken.END_ARRAY, seq.nextToken());\n+        assertFalse(p1.isClosed());\n+        assertFalse(p2.isClosed());\n+        assertFalse(seq.isClosed());\n+        assertToken(JsonToken.START_ARRAY, seq.nextToken());\n+\n+        // first parser ought to be closed now\n+        assertTrue(p1.isClosed());\n+        assertFalse(p2.isClosed());\n+        assertFalse(seq.isClosed());\n+\n+        assertToken(JsonToken.VALUE_NUMBER_INT, seq.nextToken());\n+        assertEquals(2, seq.getIntValue());\n+        assertToken(JsonToken.END_ARRAY, seq.nextToken());\n+        assertTrue(p1.isClosed());\n+        assertFalse(p2.isClosed());\n+        assertFalse(seq.isClosed());\n+\n+        assertNull(seq.nextToken());\n+        assertTrue(p1.isClosed());\n+        assertTrue(p2.isClosed());\n+        assertTrue(seq.isClosed());\n+\n+        seq.close();\n+        // redundant, but call to remove IDE warnings\n+        p1.close();\n+        p2.close();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/type/TypeReferenceTest.java\n+package com.fasterxml.jackson.core.type;\n+\n+import java.util.List;\n+\n+import com.fasterxml.jackson.core.BaseTest;\n+\n+// Not much to test, but exercise to prevent code coverage tool from showing all red for package\n+public class TypeReferenceTest extends BaseTest\n+{\n+    public void testSimple()\n+    {\n+        TypeReference<?> ref = new TypeReference<List<String>>() { };\n+        assertNotNull(ref);\n+        ref.equals(null);\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    public void testInvalid()\n+    {\n+        try { \n+            new TypeReference() { };\n+            fail(\"Should not pass!\");\n+        } catch (IllegalArgumentException e) {\n+            verifyException(e, \"without actual type information\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/util/ByteArrayBuilderTest.java\n+package com.fasterxml.jackson.core.util;\n+\n+import org.junit.Assert;\n+\n+public class ByteArrayBuilderTest extends com.fasterxml.jackson.core.BaseTest\n+{\n+    public void testSimple() throws Exception\n+    {\n+        ByteArrayBuilder b = new ByteArrayBuilder(null, 20);\n+        Assert.assertArrayEquals(new byte[0], b.toByteArray());\n+\n+        b.write((byte) 0);\n+        b.append(1);\n+\n+        byte[] foo = new byte[98];\n+        for (int i = 0; i < foo.length; ++i) {\n+            foo[i] = (byte) (2 + i);\n+        }\n+        b.write(foo);\n+\n+        byte[] result = b.toByteArray();\n+        assertEquals(100, result.length);\n+        for (int i = 0; i < 100; ++i) {\n+            assertEquals(i, (int) result[i]);\n+        }\n+        \n+        b.release();\n+        b.close();\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/core/util/TestDefaultPrettyPrinter.java\n+++ b/src/test/java/com/fasterxml/jackson/core/util/TestDefaultPrettyPrinter.java\n \n     public void testRootSeparator() throws IOException\n     {\n-        PrettyPrinter pp = new DefaultPrettyPrinter()\n+        DefaultPrettyPrinter pp = new DefaultPrettyPrinter()\n             .withRootSeparator(\"|\");\n         final String EXP = \"1|2|3\";\n \n         gen.writeNumber(3);\n         gen.close();\n         assertEquals(EXP, bytes.toString(\"UTF-8\"));\n+\n+        // Also: let's try removing separator altogether\n+        pp = pp.withRootSeparator((String) null)\n+                .withArrayIndenter(null)\n+                .withObjectIndenter(null)\n+                .withoutSpacesInObjectEntries();\n+        sw = new StringWriter();\n+        gen = JSON_F.createGenerator(sw);\n+        gen.setPrettyPrinter(pp);\n+\n+        gen.writeNumber(1);\n+        gen.writeStartArray();\n+        gen.writeNumber(2);\n+        gen.writeEndArray();\n+        gen.writeStartObject();\n+        gen.writeFieldName(\"a\");\n+        gen.writeNumber(3);\n+        gen.writeEndObject();\n+        gen.close();\n+        // no root separator, nor array, object\n+        assertEquals(\"1[2]{\\\"a\\\":3}\", sw.toString());\n     }\n     \n     private String _printTestData(PrettyPrinter pp, boolean useBytes) throws IOException\n--- a/src/test/java/com/fasterxml/jackson/core/util/TestDelegates.java\n+++ b/src/test/java/com/fasterxml/jackson/core/util/TestDelegates.java\n      */\n     public void testParserDelegate() throws IOException\n     {\n-        JsonParser jp0 = JSON_F.createParser(\"[ 1, true, null, { } ]\");\n-        JsonParserDelegate jp = new JsonParserDelegate(jp0);\n+        final String TOKEN =\"foo\";\n+\n+        JsonParser parser = JSON_F.createParser(\"[ 1, true, null, { } ]\");\n+        JsonParserDelegate del = new JsonParserDelegate(parser);\n         \n-        assertNull(jp.getCurrentToken());\n-        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n-        assertEquals(\"[\", jp.getText());\n-        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n-        assertEquals(1, jp.getIntValue());\n+        assertNull(del.getCurrentToken());\n+        assertToken(JsonToken.START_ARRAY, del.nextToken());\n+        assertEquals(\"[\", del.getText());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, del.nextToken());\n+        assertEquals(1, del.getIntValue());\n \n-        assertToken(JsonToken.VALUE_TRUE, jp.nextToken());\n-        assertTrue(jp.getBooleanValue());\n+        assertToken(JsonToken.VALUE_TRUE, del.nextToken());\n+        assertTrue(del.getBooleanValue());\n \n-        assertToken(JsonToken.VALUE_NULL, jp.nextToken());\n-        \n-        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n-        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+        assertToken(JsonToken.VALUE_NULL, del.nextToken());\n+        assertNull(del.getCurrentValue());\n+        del.setCurrentValue(TOKEN);\n \n-        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.START_OBJECT, del.nextToken());\n+        assertNull(del.getCurrentValue());\n \n-        jp.close();\n-        assertTrue(jp.isClosed());\n-        assertTrue(jp0.isClosed());\n+        assertToken(JsonToken.END_OBJECT, del.nextToken());\n+        assertEquals(TOKEN, del.getCurrentValue());\n \n-        jp0.close();\n+        assertToken(JsonToken.END_ARRAY, del.nextToken());\n+\n+        del.close();\n+        assertTrue(del.isClosed());\n+        assertTrue(parser.isClosed());\n+\n+        parser.close();\n     }\n \n     /**\n      */\n     public void testGeneratorDelegate() throws IOException\n     {\n+        final String TOKEN =\"foo\";\n+\n         StringWriter sw = new StringWriter();\n         JsonGenerator g0 = JSON_F.createGenerator(sw);\n-        JsonGeneratorDelegate jg = new JsonGeneratorDelegate(g0);\n-        jg.writeStartArray();\n+        JsonGeneratorDelegate del = new JsonGeneratorDelegate(g0);\n+        del.writeStartArray();\n \n-        assertEquals(1, jg.getOutputBuffered());\n+        assertEquals(1, del.getOutputBuffered());\n         \n-        jg.writeNumber(13);\n-        jg.writeNull();\n-        jg.writeBoolean(false);\n-        jg.writeString(\"foo\");\n-        jg.writeStartObject();\n-        jg.writeEndObject();\n+        del.writeNumber(13);\n+        del.writeNull();\n+        del.writeBoolean(false);\n+        del.writeString(\"foo\");\n \n-        jg.writeStartArray(0);\n-        jg.writeEndArray();\n+        // verify that we can actually set/get \"current value\" as expected, even with delegates\n+        assertNull(del.getCurrentValue());\n+        del.setCurrentValue(TOKEN);\n \n-        jg.writeEndArray();\n+        del.writeStartObject();\n+        assertNull(del.getCurrentValue());\n+        del.writeEndObject();\n+        assertEquals(TOKEN, del.getCurrentValue());\n+\n+        del.writeStartArray(0);\n+        del.writeEndArray();\n+\n+        del.writeEndArray();\n         \n-        jg.flush();\n-        jg.close();\n-        assertTrue(jg.isClosed());        \n+        del.flush();\n+        del.close();\n+        assertTrue(del.isClosed());        \n         assertTrue(g0.isClosed());        \n         assertEquals(\"[13,null,false,\\\"foo\\\",{},[]]\", sw.toString());\n \n--- a/src/test/java/com/fasterxml/jackson/core/util/TestVersionUtil.java\n+++ b/src/test/java/com/fasterxml/jackson/core/util/TestVersionUtil.java\n                 VersionUtil.parseVersion(\"1.2.15-foo\", \"group\", \"artifact\"));\n     }\n \n+    @SuppressWarnings(\"deprecation\")\n     public void testMavenVersionParsing() {\n         assertEquals(new Version(1, 2, 3, \"SNAPSHOT\", \"foo.bar\", \"foo-bar\"),\n                 VersionUtil.mavenVersionFor(TestVersionUtil.class.getClassLoader(), \"foo.bar\", \"foo-bar\"));", "timestamp": 1432753704, "metainfo": ""}