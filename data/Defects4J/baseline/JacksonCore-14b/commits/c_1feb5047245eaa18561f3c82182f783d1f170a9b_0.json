{"sha": "1feb5047245eaa18561f3c82182f783d1f170a9b", "log": "minor cleanup for error handling", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n      *   to indicate end-of-input\n      */\n     @Override\n-    public JsonToken nextToken()\n-        throws IOException, JsonParseException\n+    public JsonToken nextToken() throws IOException\n     {\n         _numTypesValid = NR_UNKNOWN;\n         /* First: field names are special -- we will always tokenize\n         case '{':\n             t = JsonToken.START_OBJECT;\n             break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n         case 't':\n             _matchToken(\"true\", 1);\n             t = JsonToken.VALUE_TRUE;\n         return _currToken;\n     }\n \n-    private final JsonToken _nextTokenNotInObject(int i)\n-        throws IOException, JsonParseException\n+    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n     {\n         if (i == INT_QUOTE) {\n             _tokenIncomplete = true;\n         case '{':\n             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n             return (_currToken = JsonToken.START_OBJECT);\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n         case 't':\n             _matchToken(\"true\", 1);\n             return (_currToken = JsonToken.VALUE_TRUE);\n         case '-':\n             /* Should we have separate handling for plus? Although\n              * it is not allowed per se, it may be erroneously used,\n-             * and could be indicate by a more specific error message.\n+             * and could be indicated by a more specific error message.\n              */\n         case '0':\n         case '1':\n      */\n     \n     @Override\n-    public boolean nextFieldName(SerializableString str)\n-        throws IOException, JsonParseException\n+    public boolean nextFieldName(SerializableString str) throws IOException\n     {\n         // // // Note: most of code below is copied from nextToken()\n         \n         return _isNextTokenNameMaybe(i, str);\n     }\n \n-    private final void _isNextTokenNameYes()\n-        throws IOException, JsonParseException\n+    private final void _isNextTokenNameYes() throws IOException\n     {\n         // very first thing: common case, colon, value, no white space\n         int i = _skipColon();\n         case '{':\n             _nextToken = JsonToken.START_OBJECT;\n             return;\n-        case ']':\n-        case '}':\n-            _reportUnexpectedChar(i, \"expected a value\");\n         case 't':\n             _matchToken(\"true\", 1);\n             _nextToken = JsonToken.VALUE_TRUE;\n         _nextToken = _handleUnexpectedValue(i);\n     }\n     \n-    private final boolean _isNextTokenNameMaybe(int i, SerializableString str)\n-        throws IOException, JsonParseException\n+    private final boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException\n     {\n         // // // and this is back to standard nextToken()\n             \n         case '{':\n             t = JsonToken.START_OBJECT;\n             break;\n-        case ']':\n-        case '}':\n-            _reportUnexpectedChar(i, \"expected a value\");\n         case 't':\n             _matchToken(\"true\", 1);\n             t = JsonToken.VALUE_TRUE;\n     }\n \n     @Override\n-    public String nextTextValue()\n-        throws IOException, JsonParseException\n+    public String nextTextValue() throws IOException\n     {\n         // two distinct cases; either got name and we know next type, or 'other'\n         if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n     }\n \n     @Override\n-    public int nextIntValue(int defaultValue)\n-        throws IOException, JsonParseException\n+    public int nextIntValue(int defaultValue) throws IOException\n     {\n         // two distinct cases; either got name and we know next type, or 'other'\n         if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n     }\n \n     @Override\n-    public long nextLongValue(long defaultValue)\n-        throws IOException, JsonParseException\n+    public long nextLongValue(long defaultValue) throws IOException\n     {\n         // two distinct cases; either got name and we know next type, or 'other'\n         if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n     }\n \n     @Override\n-    public Boolean nextBooleanValue()\n-        throws IOException, JsonParseException\n+    public Boolean nextBooleanValue() throws IOException\n     {\n         // two distinct cases; either got name and we know next type, or 'other'\n         if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n      * deferred, since it is usually the most complicated and costliest\n      * part of processing.\n      */\n-    protected JsonToken _parseNumber(int c)\n-        throws IOException, JsonParseException\n+    protected JsonToken _parseNumber(int c) throws IOException\n     {\n         char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n         int outPtr = 0;\n      * (or output is longer than segment used to store it)\n      */\n     private final JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative,\n-            int intPartLength)\n-        throws IOException, JsonParseException\n+            int intPartLength) throws IOException\n     {\n         // Ok, parse the rest\n         while (true) {\n      * Method called when we have seen one zero, and want to ensure\n      * it is not followed by another\n      */\n-    private final int _verifyNoLeadingZeroes()\n-        throws IOException, JsonParseException\n+    private final int _verifyNoLeadingZeroes() throws IOException\n     {\n         // Ok to have plain \"0\"\n         if (_inputPtr >= _inputEnd && !loadMore()) {\n     }\n     \n     private final JsonToken _parseFloat(char[] outBuf, int outPtr, int c,\n-            boolean negative, int integerPartLength)\n-        throws IOException, JsonParseException\n+            boolean negative, int integerPartLength) throws IOException\n     {\n         int fractLen = 0;\n         boolean eof = false;\n     {\n         // Most likely an error, unless we are to allow single-quote-strings\n         switch (c) {\n+        case ']':\n+        case '}':\n+            // Error: neither is valid at this point; valid closers have\n+            // been handled earlier\n+            _reportUnexpectedChar(c, \"expected a value\");\n         case '\\'':\n             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                 return _handleApos();", "timestamp": 1398404198, "metainfo": ""}