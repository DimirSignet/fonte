{"sha": "996c3ff339489838b25fe1849895a55cc428e648", "log": "complete rewriting of number parsing for char-based sources as well", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n          * note that no representations are valid yet\n          */\n         int ptr = _inputPtr;\n-        int startPtr = ptr-1; // to include sign/digit already read\n+        int startPtr = ptr-1; // to include digit already read\n         final int inputLen = _inputEnd;\n \n         // One special case, leading zero(es):\n             }\n             ++intLen;\n         }\n-\n+        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n+            _inputPtr = ptr;\n+            return _parseFloat(ch, startPtr, ptr, false, intLen);\n+        }\n+        // Got it all: let's add to text buffer for parsing, access\n+        --ptr; // need to push back following separator\n+        _inputPtr = ptr;\n+        // As per #105, need separating space between root values; check here\n+        if (_parsingContext.inRoot()) {\n+            _verifyRootSpace(ch);\n+        }\n+        int len = ptr-startPtr;\n+        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n+        return resetInt(false, intLen);\n+    }\n+\n+    private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\n+        throws IOException\n+    {\n+        final int inputLen = _inputEnd;\n         int fractLen = 0;\n+\n         // And then see if we get other parts\n         if (ch == '.') { // yes, fraction\n             fract_loop:\n                 reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n             }\n         }\n-        // Got it all: let's add to text buffer for parsing, access\n         --ptr; // need to push back following separator\n         _inputPtr = ptr;\n         // As per #105, need separating space between root values; check here\n         }\n         int len = ptr-startPtr;\n         _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n-        return reset(false, intLen, fractLen, expLen);\n+        // And there we have it!\n+        return resetFloat(neg, intLen, fractLen, expLen);\n     }\n \n     protected final JsonToken _parseNegNumber() throws IOException\n             ++intLen;\n         }\n \n-        int fractLen = 0;\n-        // And then see if we get other parts\n-        if (ch == '.') { // yes, fraction\n-            fract_loop:\n-            while (true) {\n-                if (ptr >= inputLen) {\n-                    _inputPtr = (startPtr+1);\n-                    return _parseNumber2(true);\n-                }\n-                ch = (int) _inputBuffer[ptr++];\n-                if (ch < INT_0 || ch > INT_9) {\n-                    break fract_loop;\n-                }\n-                ++fractLen;\n-            }\n-            // must be followed by sequence of ints, one minimum\n-            if (fractLen == 0) {\n-                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n-            }\n-        }\n-        int expLen = 0;\n-        if (ch == 'e' || ch == 'E') { // and/or exponent\n-            if (ptr >= inputLen) {\n-                _inputPtr = (startPtr+1);\n-                return _parseNumber2(true);\n-            }\n-            // Sign indicator?\n-            ch = (int) _inputBuffer[ptr++];\n-            if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n-                if (ptr >= inputLen) {\n-                    _inputPtr = (startPtr+1);\n-                    return _parseNumber2(true);\n-                }\n-                ch = (int) _inputBuffer[ptr++];\n-            }\n-            while (ch <= INT_9 && ch >= INT_0) {\n-                ++expLen;\n-                if (ptr >= inputLen) {\n-                    _inputPtr = (startPtr+1);\n-                    return _parseNumber2(true);\n-                }\n-                ch = (int) _inputBuffer[ptr++];\n-            }\n-            // must be followed by sequence of ints, one minimum\n-            if (expLen == 0) {\n-                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n-            }\n-        }\n-        // Got it all: let's add to text buffer for parsing, access\n-        --ptr; // need to push back following separator\n+        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n+            _inputPtr = ptr;\n+            return _parseFloat(ch, startPtr, ptr, true, intLen);\n+        }\n+        --ptr;\n         _inputPtr = ptr;\n-        // As per #105, need separating space between root values; check here\n         if (_parsingContext.inRoot()) {\n             _verifyRootSpace(ch);\n         }\n         int len = ptr-startPtr;\n         _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n-        return reset(true, intLen, fractLen, expLen);\n-    }\n-    \n+        return resetInt(true, intLen);\n+    }\n+\n     /**\n      * Method called to parse a number, when the primary parse\n      * method has failed to parse it, due to it being split on", "timestamp": 1399148521, "metainfo": ""}