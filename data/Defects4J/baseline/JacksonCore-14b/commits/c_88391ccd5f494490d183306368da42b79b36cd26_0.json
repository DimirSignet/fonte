{"sha": "88391ccd5f494490d183306368da42b79b36cd26", "log": "Simplifying N-byte hashing a bit", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java\n         hash ^= _seed;\n         hash += (hash >>> 16); // and shuffle some more\n         hash ^= (hash >>> 4);\n+        hash += (hash << 3);\n         \n         return hash;\n     }\n          */\n         int hash = q[0] ^ _seed;\n         hash += (hash >>> 9);\n+        hash += q[1];\n+        hash += (hash >>> 15);\n         hash *= MULT;\n-        hash += q[1];\n-        hash *= MULT2;\n-        hash += (hash >>> 15);\n         hash ^= q[2];\n         hash += (hash >>> 4);\n \n         for (int i = 3; i < qlen; ++i) {\n-            hash = (hash * MULT3) ^ q[i];\n-            // for longer entries, mess a bit in-between too\n-            hash += (hash >>> 3);\n-        }\n+            int next = q[i];\n+            next = next ^ (next >> 21);\n+            hash += next;\n+        }\n+        hash *= MULT2;\n+        \n         // and finally shuffle some more once done\n-        hash += (hash >>> 4); // to get high-order bits to mix more\n+        hash += (hash >>> 19);\n+        hash ^= (hash << 5);\n         return hash;\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n         }\n         assertEquals(COUNT, symbols.size());\n         assertEquals(16384, symbols.bucketCount());\n-\n+        \n         // fragile, but essential to verify low collision counts;\n         // anywhere between 70-80% primary matches\n-        assertEquals(8533, symbols.primaryCount());\n+        assertEquals(8515, symbols.primaryCount());\n         // secondary between 10-20%\n-        assertEquals(2468, symbols.secondaryCount());\n+        assertEquals(2525, symbols.secondaryCount());\n         // and most of remaining in tertiary\n-        assertEquals(999, symbols.tertiaryCount());\n+        assertEquals(960, symbols.tertiaryCount());\n         // so that spill-over is empty or close to\n         assertEquals(0, symbols.spilloverCount());\n     }\n          */\n         assertEquals(6250, symbolsB.size());\n         assertEquals(4761, symbolsB.primaryCount()); // 80% primary hit rate\n-        assertEquals(1019, symbolsB.secondaryCount()); // 13% secondary\n-        assertEquals(456, symbolsB.tertiaryCount()); // 7% tertiary\n-        assertEquals(14, symbolsB.spilloverCount()); // and couple of leftovers\n+        assertEquals(1190, symbolsB.secondaryCount()); // 13% secondary\n+        assertEquals(299, symbolsB.tertiaryCount()); // 7% tertiary\n+        assertEquals(0, symbolsB.spilloverCount()); // and couple of leftovers\n     }\n     \n     // And then one more test just for Bytes-based symbol table\n         assertEquals(COUNT, symbols.size());\n         assertEquals(65536, symbols.bucketCount());\n \n-        // fragile, but essential to verify low collision counts;\n-        // anywhere between 70-80% primary matches\n+        /* 29-Mar-2015, tatu: To get collision counts down for this\n+         *    test took quite a bit of tweaking...\n+         */\n         assertEquals(32342, symbols.primaryCount());\n-        // secondary between 10-20%\n-        assertEquals(6759, symbols.secondaryCount());\n-        // and most of remaining in tertiary\n-        assertEquals(3715, symbols.tertiaryCount());\n-        // but number of spill-overs starts to grow beyond 30k quite a lot:\n-        assertEquals(184, symbols.spilloverCount());\n+        assertEquals(8863, symbols.secondaryCount());\n+        assertEquals(1795, symbols.tertiaryCount());\n+\n+        // finally managed to get this to 0; other variants produced thousands\n+        assertEquals(0, symbols.spilloverCount());\n     }\n \n     // Another variant, but with 1-quad names", "timestamp": 1427700421, "metainfo": ""}