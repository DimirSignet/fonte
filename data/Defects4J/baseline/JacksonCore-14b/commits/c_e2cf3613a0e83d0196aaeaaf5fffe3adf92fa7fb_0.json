{"sha": "e2cf3613a0e83d0196aaeaaf5fffe3adf92fa7fb", "log": "Add efficient impl of `nextFieldName()` for UTF-8 parser", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n     /* Public API, traversal, nextXxxValue/nextFieldName\n     /**********************************************************\n      */\n-    \n+\n     @Override\n     public boolean nextFieldName(SerializableString str) throws IOException\n     {\n             }\n         }\n         return _isNextTokenNameMaybe(i, str);\n+    }\n+\n+    @Override\n+    public String nextFieldName() throws IOException\n+    {\n+        // // // Note: this is almost a verbatim copy of nextToken()\n+\n+        _numTypesValid = NR_UNKNOWN;\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+            _nextAfterName();\n+            return null;\n+        }\n+        if (_tokenIncomplete) {\n+            _skipString();\n+        }\n+        int i = _skipWSOrEnd();\n+        if (i < 0) {\n+            close();\n+            _currToken = null;\n+            return null;\n+        }\n+        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n+        _tokenInputRow = _currInputRow;\n+        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n+\n+        _binaryValue = null;\n+\n+        if (i == INT_RBRACKET) {\n+            if (!_parsingContext.inArray()) {\n+                _reportMismatchedEndMarker(i, '}');\n+            }\n+            _parsingContext = _parsingContext.getParent();\n+            _currToken = JsonToken.END_ARRAY;\n+            return null;\n+        }\n+        if (i == INT_RCURLY) {\n+            if (!_parsingContext.inObject()) {\n+                _reportMismatchedEndMarker(i, ']');\n+            }\n+            _parsingContext = _parsingContext.getParent();\n+            _currToken = JsonToken.END_OBJECT;\n+            return null;\n+        }\n+\n+        // Nope: do we then expect a comma?\n+        if (_parsingContext.expectComma()) {\n+            if (i != INT_COMMA) {\n+                _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n+            }\n+            i = _skipWS();\n+        }\n+\n+        if (!_parsingContext.inObject()) {\n+            _nextTokenNotInObject(i);\n+            return null;\n+        }\n+\n+        Name n = _parseName(i);\n+        final String nameStr = n.getName();\n+        _parsingContext.setCurrentName(nameStr);\n+        _currToken = JsonToken.FIELD_NAME;\n+\n+        i = _skipColon();\n+        if (i == INT_QUOTE) {\n+            _tokenIncomplete = true;\n+            _nextToken = JsonToken.VALUE_STRING;\n+            return nameStr;\n+        }\n+        JsonToken t;\n+        switch (i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+\n+            /* Should we have separate handling for plus? Although\n+             * it is not allowed per se, it may be erroneously used,\n+             * and could be indicate by a more specific error message.\n+             */\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchToken(\"false\", 1);\n+             t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchToken(\"null\", 1);\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchToken(\"true\", 1);\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+\n+        default:\n+            t = _handleUnexpectedValue(i);\n+        }\n+        _nextToken = t;\n+        return nameStr;\n     }\n \n     // Variant called when we know there's at least 4 more bytes available", "timestamp": 1418324836, "metainfo": ""}