{"sha": "ac956fe5eed337c516beb504aadf82917c26d6ba", "log": "minor change to text value secondary parsing, hoping to speed it up a bit", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/io/CharTypes.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/CharTypes.java\n      */\n     final static int[] sInputCodes;\n     static {\n-        /* 96 would do for most cases (backslash is ascii 94)\n+        /* 96 would do for most cases (backslash is ASCII 94)\n          * but if we want to do lookups by raw bytes it's better\n          * to have full table\n          */\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n     {\n         char[] outBuf = _textBuffer.getCurrentSegment();\n         int outPtr = _textBuffer.getCurrentSegmentSize();\n+        final int[] codes = _icLatin1;\n+        final int maxCode = codes.length;\n \n         while (true) {\n             if (_inputPtr >= _inputEnd) {\n             }\n             char c = _inputBuffer[_inputPtr++];\n             int i = (int) c;\n-            if (i <= INT_BACKSLASH) {\n-                if (i == INT_BACKSLASH) {\n+            if (i < maxCode && codes[i] != 0) {\n+                if (i == INT_QUOTE) {\n+                    break;\n+                } else if (i == INT_BACKSLASH) {\n                     /* Although chars outside of BMP are to be escaped as\n                      * an UTF-16 surrogate pair, does that affect decoding?\n                      * For now let's assume it does not.\n                      */\n                     c = _decodeEscaped();\n-                } else if (i <= INT_QUOTE) {\n-                    if (i == INT_QUOTE) {\n-                        break;\n-                    }\n-                    if (i < INT_SPACE) {\n-                        _throwUnquotedSpace(i, \"string value\");\n-                    }\n-                }\n+                } else if (i < INT_SPACE) {\n+                    _throwUnquotedSpace(i, \"string value\");\n+                } // anything else?\n             }\n             // Need more room?\n             if (outPtr >= outBuf.length) {\n--- /dev/null\n+++ b/src/test/java/perf/ManualCharAccessTest.java\n+package perf;\n+\n+public class ManualCharAccessTest\n+{\n+    protected int hash;\n+\n+    protected final static byte[] SMALL_BYTE_CODES = new byte[256];\n+\n+    protected final static int[] SMALL_INT_CODES = new int[256];\n+\n+    protected final static int[] INT_CODES = new int[0x10000];\n+    protected final static byte[] BYTE_CODES = new byte[0x10000];\n+\n+    static {\n+        for (int i = 0; i < 32; ++i) {\n+            if (!(i == '\\r' || i == '\\n' || i == '\\t')) {\n+                INT_CODES[i] = 1;\n+                BYTE_CODES[i] = 1;\n+                SMALL_BYTE_CODES[i] = 1;\n+                SMALL_INT_CODES[i] = 1;\n+            }\n+        }\n+        INT_CODES['\\\\'] = 2;\n+        BYTE_CODES['\\\\'] = 2;\n+        SMALL_BYTE_CODES['\\\\'] = 2;\n+        SMALL_INT_CODES['\\\\'] = 2;\n+    }\n+    \n+    protected String generateString(int len)\n+    {\n+        int counter = 0;\n+        StringBuilder sb = new StringBuilder(len + 20);\n+        do {\n+            sb.append(\"Some stuff: \").append(len).append(\"\\n\");\n+            if ((++counter % 31) == 0) {\n+                sb.append(\"\\\\\");\n+            }\n+        } while (sb.length() < len);\n+        return sb.toString();\n+    }\n+\n+    private void test() throws Exception\n+    {\n+        final String INPUT_STR = generateString(23000);\n+        final char[] INPUT_CHARS = INPUT_STR.toCharArray();\n+        final char[] OUTPUT = new char[INPUT_CHARS.length];\n+        \n+        // Let's try to guestimate suitable size, N megs of output\n+        final int REPS = (int) ((double) (80 * 1000 * 1000) / (double) INPUT_CHARS.length);\n+        System.out.printf(\"%d bytes to scan, will do %d repetitions\\n\",\n+                INPUT_CHARS.length, REPS);\n+        \n+        int i = 0;\n+        int roundsDone = 0;\n+        final int TYPES = 3;\n+        final int WARMUP_ROUNDS = 5;\n+\n+        final long[] times = new long[TYPES];\n+\n+        while (true) {\n+            int round = (i++ % TYPES);\n+\n+            String msg;\n+            boolean lf = (round == 0);\n+\n+            long msecs;\n+            \n+            switch (round) {\n+            case 0:\n+                msg = \"Read classic\";\n+                msecs = readClassic(REPS, INPUT_CHARS, OUTPUT);\n+                break;\n+            case 1:\n+                msg = \"Read, byte[]\";\n+                msecs = readWithByte(REPS, INPUT_CHARS, OUTPUT);\n+                break;\n+            case 2:\n+                msg = \"Read, int[]\";\n+                msecs = readWithInt(REPS, INPUT_CHARS, OUTPUT);\n+                break;\n+            default:\n+                throw new Error();\n+            }\n+            // skip first 5 rounds to let results stabilize\n+            if (roundsDone >= WARMUP_ROUNDS) {\n+                times[round] += msecs;\n+            }\n+            \n+            System.out.printf(\"Test '%s' [hash: 0x%s] -> %d msecs\\n\", msg, this.hash, msecs);\n+            if (lf) {\n+                ++roundsDone;\n+                if ((roundsDone % 7) == 0 && roundsDone > WARMUP_ROUNDS) {\n+                    double den = (double) (roundsDone - WARMUP_ROUNDS);\n+                    System.out.printf(\"Averages after %d rounds (classic, byte[], int[]): \"\n+                            +\"%.1f / %.1f / %.1f msecs\\n\",\n+                            (int) den\n+                            ,times[0] / den, times[1] / den, times[2] / den\n+                            );\n+                            \n+                }\n+                System.out.println();\n+            }\n+            if ((i % 17) == 0) {\n+                System.out.println(\"[GC]\");\n+                Thread.sleep(100L);\n+                System.gc();\n+                Thread.sleep(100L);\n+            }\n+        }\n+    }\n+\n+    private final long readClassic(int REPS, char[] input, char[] output) throws Exception\n+    {\n+        long start = System.currentTimeMillis();\n+        final byte[] codes = BYTE_CODES;\n+        final int MAX = 256;\n+\n+        while (--REPS >= 0) {\n+            int outPtr = 0;\n+            for (int i = 0, end = input.length; i < end; ++i) {\n+                int ch = input[i];\n+                if (ch < MAX && codes[ch] == NULL_BYTE) {\n+                    output[outPtr++] = (char) ch;\n+                    continue;\n+                }\n+                if (ch == '\\\\') {\n+                    output[outPtr++] = '_';\n+                } else if (ch == '\\n') { \n+                    output[outPtr++] = '_';\n+                }\n+            }\n+        }\n+        long time = System.currentTimeMillis() - start;\n+        return time;\n+    }\n+\n+    private final long readWithByte(int REPS, char[] input, char[] output) throws Exception\n+    {\n+        long start = System.currentTimeMillis();\n+        final byte[] codes = BYTE_CODES;\n+        while (--REPS >= 0) {\n+            int outPtr = 0;\n+            for (int i = 0, end = input.length; i < end; ++i) {\n+                char ch = input[i];\n+                if (codes[ch] == NULL_BYTE) {\n+                    output[outPtr++] = ch;\n+                    continue;\n+                }\n+                if (ch == '\\\\') {\n+                    output[outPtr++] = '_';\n+                } else if (ch == '\\n') { \n+                    output[outPtr++] = '_';\n+                }\n+            }\n+        }\n+        long time = System.currentTimeMillis() - start;\n+        return time;\n+    }\n+\n+    final static byte NULL_BYTE = (byte) 0;\n+    \n+    private final long readWithInt(int REPS, char[] input, char[] output) throws Exception\n+    {\n+        long start = System.currentTimeMillis();\n+        final int[] codes = INT_CODES;\n+        while (--REPS >= 0) {\n+            int outPtr = 0;\n+    \n+            for (int i = 0, end = input.length; i < end; ++i) {\n+                char ch = input[i];\n+                if (codes[ch] != 0) {\n+                    output[outPtr++] = ch;\n+                    continue;\n+                }\n+                if (ch == '\\\\') {\n+                    output[outPtr++] = '_';\n+                } else if (ch == '\\n') { \n+                    output[outPtr++] = '_';\n+                }\n+            }\n+        }\n+        long time = System.currentTimeMillis() - start;\n+        return time;\n+    }\n+    \n+    public static void main(String[] args) throws Exception\n+    {\n+        if (args.length != 0) {\n+            System.err.println(\"Usage: java ...\");\n+            System.exit(1);\n+        }\n+        new ManualCharAccessTest().test();\n+    }\n+}", "timestamp": 1390887553, "metainfo": ""}