{"sha": "b55721a3b5d0e6e2cf8d4075eb191d715d38b962", "log": "more incremental work for token filtering, for writes.", "commit": "\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/FilteringGeneratorDelegate.java\n+package com.fasterxml.jackson.core.filter;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.util.JsonGeneratorDelegate;\n+\n+/**\n+ * @since 2.6.0\n+ */\n+public class FilteringGeneratorDelegate extends JsonGeneratorDelegate\n+{\n+    /**\n+     * Object consulted to determine whether to write parts of content generator\n+     * is asked to write or not.\n+     */\n+    protected TokenFilter filter;\n+\n+    /**\n+     * Although delegate has its own output context it is not sufficient since we actually\n+     * have to keep track of excluded (filtered out) structures as well as ones delegate\n+     * actually outputs.\n+     */\n+    protected TokenFilterContext _filterContext;\n+\n+    /**\n+     * The current state constant is kept here as well, not just at the tip of {@link #_filterContext}.\n+     */\n+    protected int _currentState;\n+\n+    /*\n+    /**********************************************************\n+    /* Construction, initialization\n+    /**********************************************************\n+     */\n+\n+    public FilteringGeneratorDelegate(JsonGenerator d, TokenFilter f) {\n+        // By default, do NOT delegate copy methods\n+        super(d, false);\n+        filter = f;\n+        // Doesn't matter if it's include or exclude current, but shouldn't be including/excluding sub-tree\n+        _currentState = TokenFilter.FILTER_INCLUDE_CURRENT;\n+        _filterContext = TokenFilterContext.createRootContext(_currentState);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended API\n+    /**********************************************************\n+     */\n+\n+    public TokenFilter getTokenFilter() { return filter; }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, structural\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeStartArray() throws IOException\n+    {\n+        /*\n+        switch (_currentState) {\n+        case TokenFilter.FILTER_SKIP_TREE: // filter all down the tree?\n+            _filterContext = _filterContext.createChildArrayContext(_currentState);\n+            return;\n+        case TokenFilter.FILTER_SKIP_CURRENT: // may or may not include, need to check\n+        case TokenFilter.FILTER_INCLUDE_CURRENT:\n+            int newState = filter.startArray();\n+            _filterContext = _filterContext.createChildArrayContext(newState);\n+            if (newState >= TokenFilter.FILTER_INCLUDE_CURRENT) {\n+                delegate.writeStartArray();\n+            }\n+            return;\n+        case TokenFilter.FILTER_INCLUDE_TREE: // include the whole sub-tree?\n+        default:\n+            _filterContext = _filterContext.createChildArrayContext(_currentState);\n+            delegate.writeStartArray();\n+            return;\n+        }\n+        */\n+    }\n+\n+    @Override\n+    public void writeStartArray(int size) throws IOException\n+    {\n+        /*\n+        switch (_currentState) {\n+        case TokenFilter.FILTER_SKIP_TREE: // filter all down the tree?\n+            _filterContext = _filterContext.createChildArrayContext(_currentState);\n+            return;\n+        case TokenFilter.FILTER_SKIP_CURRENT: // may or may not include, need to check\n+        case TokenFilter.FILTER_INCLUDE_CURRENT:\n+            int newState = filter.startArray();\n+            _filterContext = _filterContext.createChildArrayContext(newState);\n+            if (newState >= TokenFilter.FILTER_INCLUDE_CURRENT) {\n+                delegate.writeStartArray(size);\n+            }\n+            return;\n+        case TokenFilter.FILTER_INCLUDE_TREE: // include the whole sub-tree?\n+        default:\n+            _filterContext = _filterContext.createChildArrayContext(_currentState);\n+            delegate.writeStartArray(size);\n+            return;\n+        }\n+        */\n+    }\n+    \n+    @Override\n+    public void writeEndArray() throws IOException\n+    {\n+        if (_currentState >= TokenFilter.FILTER_INCLUDE_CURRENT) {\n+            delegate.writeEndArray();\n+        }\n+        _filterContext = _filterContext.getParent();\n+        if (_filterContext != null) {\n+            _currentState = _filterContext.getFilterState();\n+        }\n+    }\n+\n+    @Override\n+    public void writeStartObject() throws IOException\n+    {\n+        /*\n+        switch (_currentState) {\n+        case TokenFilter.FILTER_SKIP_TREE: // filter all down the tree?\n+            _filterContext = _filterContext.createChildObjectContext(_currentState);\n+            return;\n+        case TokenFilter.FILTER_SKIP_CURRENT: // may or may not include, need to check\n+        case TokenFilter.FILTER_INCLUDE_CURRENT:\n+            int newState = filter.startObject();\n+            _filterContext = _filterContext.createChildObjectContext(newState);\n+            if (newState >= TokenFilter.FILTER_INCLUDE_CURRENT) {\n+                delegate.writeStartObject();\n+            }\n+            return;\n+        case TokenFilter.FILTER_INCLUDE_TREE: // include the whole sub-tree?\n+        default:\n+            _filterContext = _filterContext.createChildObjectContext(_currentState);\n+            delegate.writeStartObject();\n+            return;\n+        }\n+        */\n+    }\n+    \n+    @Override\n+    public void writeEndObject() throws IOException\n+    {\n+        if (_currentState >= TokenFilter.FILTER_INCLUDE_CURRENT) {\n+            delegate.writeEndObject();\n+        }\n+        _filterContext = _filterContext.getParent();\n+        if (_filterContext != null) {\n+            _currentState = _filterContext.getFilterState();\n+        }\n+    }\n+\n+    @Override\n+    public void writeFieldName(String name) throws IOException\n+    {\n+        /*\n+        switch (_currentState) {\n+        case TokenFilter.FILTER_SKIP_TREE:\n+            return;\n+        case TokenFilter.FILTER_SKIP_CURRENT: // may or may not include, need to check\n+        case TokenFilter.FILTER_INCLUDE_CURRENT:\n+            _propertyState = filter.\n+            int state = filter.startObject();\n+            if (state >= TokenFilter.FILTER_INCLUDE_CURRENT) {\n+                delegate.writeStartObject();\n+            }\n+            return;\n+        case TokenFilter.FILTER_INCLUDE_TREE: // include the whole sub-tree?\n+        default:\n+            delegate.writeFieldName(name);\n+            return;\n+        }\n+        */\n+    }\n+\n+    @Override\n+    public void writeFieldName(SerializableString name) throws IOException {\n+        delegate.writeFieldName(name);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, text/String values\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeString(String text) throws IOException {\n+        delegate.writeString(text);\n+    }\n+\n+    @Override\n+    public void writeString(char[] text, int offset, int len) throws IOException {\n+        delegate.writeString(text, offset, len);\n+    }\n+\n+    @Override\n+    public void writeString(SerializableString text) throws IOException {\n+        delegate.writeString(text);\n+    }\n+\n+    @Override\n+    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException {\n+        delegate.writeRawUTF8String(text, offset, length);\n+    }\n+\n+    @Override\n+    public void writeUTF8String(byte[] text, int offset, int length) throws IOException {\n+        delegate.writeUTF8String(text, offset, length);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, binary/raw content\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeRaw(String text) throws IOException {\n+        delegate.writeRaw(text);\n+    }\n+\n+    @Override\n+    public void writeRaw(String text, int offset, int len) throws IOException {\n+        delegate.writeRaw(text, offset, len);\n+    }\n+\n+    @Override\n+    public void writeRaw(SerializableString raw) throws IOException {\n+        delegate.writeRaw(raw);\n+    }\n+\n+    @Override\n+    public void writeRaw(char[] text, int offset, int len) throws IOException {\n+        delegate.writeRaw(text, offset, len);\n+    }\n+\n+    @Override\n+    public void writeRaw(char c) throws IOException {\n+        delegate.writeRaw(c);\n+    }\n+\n+    @Override\n+    public void writeRawValue(String text) throws IOException {\n+        delegate.writeRawValue(text);\n+    }\n+\n+    @Override\n+    public void writeRawValue(String text, int offset, int len) throws IOException {\n+        delegate.writeRawValue(text, offset, len);\n+    }\n+\n+    @Override\n+    public void writeRawValue(char[] text, int offset, int len) throws IOException {\n+        delegate.writeRawValue(text, offset, len);\n+    }\n+\n+    @Override\n+    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException {\n+        delegate.writeBinary(b64variant, data, offset, len);\n+    }\n+\n+    @Override\n+    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException {\n+        return delegate.writeBinary(b64variant, data, dataLength);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, other value types\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeNumber(short v) throws IOException {\n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(int v) throws IOException {\n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(long v) throws IOException {\n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(BigInteger v) throws IOException {\n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(double v) throws IOException {\n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(float v) throws IOException {\n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(BigDecimal v) throws IOException {\n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(String encodedValue) throws IOException, UnsupportedOperationException {\n+        delegate.writeNumber(encodedValue);\n+    }\n+\n+    @Override\n+    public void writeBoolean(boolean state) throws IOException {\n+        delegate.writeBoolean(state);\n+    }\n+\n+    @Override\n+    public void writeNull() throws IOException {\n+        delegate.writeNull();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridden field methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeOmittedField(String fieldName) throws IOException {\n+        delegate.writeOmittedField(fieldName);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, Native Ids\n+    /**********************************************************\n+     */\n+\n+    // 25-Mar-2015, tatu: These are tricky as they sort of predate actual filtering calls.\n+    //   Let's try to use current state as a clue at least...\n+    \n+    @Override\n+    public void writeObjectId(Object id) throws IOException {\n+        delegate.writeObjectId(id);\n+    }\n+\n+    @Override\n+    public void writeObjectRef(Object id) throws IOException {\n+        delegate.writeObjectRef(id);\n+    }\n+    \n+    @Override\n+    public void writeTypeId(Object id) throws IOException {\n+        delegate.writeTypeId(id);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, serializing Java objects\n+    /**********************************************************\n+     */\n+\n+    // Base class definitions for these seems correct to me, iff not directly delegating:\n+\n+    /*\n+    @Override\n+    public void writeObject(Object pojo) throws IOException,JsonProcessingException {\n+        if (delegateCopyMethods) {\n+            delegate.writeObject(pojo);\n+            return;\n+        }\n+        // NOTE: copied from \n+        if (pojo == null) {\n+            writeNull();\n+        } else {\n+            if (getCodec() != null) {\n+                getCodec().writeValue(this, pojo);\n+                return;\n+            }\n+            _writeSimpleObject(pojo);\n+        }\n+    }\n+    \n+    @Override\n+    public void writeTree(TreeNode rootNode) throws IOException {\n+        if (delegateCopyMethods) {\n+            delegate.writeTree(rootNode);\n+            return;\n+        }\n+        // As with 'writeObject()', we are not check if write would work\n+        if (rootNode == null) {\n+            writeNull();\n+        } else {\n+            if (getCodec() == null) {\n+                throw new IllegalStateException(\"No ObjectCodec defined\");\n+            }\n+            getCodec().writeValue(this, rootNode);\n+        }\n+    }\n+    */\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, copy-through methods\n+    /**********************************************************\n+     */\n+\n+    // Base class definitions for these seems correct to me, iff not directly delegating:\n+\n+    /*\n+    @Override\n+    public void copyCurrentEvent(JsonParser jp) throws IOException {\n+        if (delegateCopyMethods) delegate.copyCurrentEvent(jp);\n+        else super.copyCurrentEvent(jp);\n+    }\n+\n+    @Override\n+    public void copyCurrentStructure(JsonParser jp) throws IOException {\n+        if (delegateCopyMethods) delegate.copyCurrentStructure(jp);\n+        else super.copyCurrentStructure(jp);\n+    }\n+    */\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/TokenFilter.java\n+package com.fasterxml.jackson.core.filter;\n+\n+import com.fasterxml.jackson.core.JsonToken;\n+\n+/**\n+ * @since 2.6\n+ */\n+public abstract class TokenFilter\n+{\n+    // Constants\n+\n+    public final static int FILTER_SKIP_TREE = 1;\n+    public final static int FILTER_SKIP_CURRENT = 2;\n+    public final static int FILTER_INCLUDE_CURRENT = 3;\n+    public final static int FILTER_INCLUDE_TREE = 4;\n+\n+    // API, scalar values\n+\n+    public int writeRootScalarValue(JsonToken type) {\n+        return FILTER_SKIP_TREE;\n+    }\n+\n+    public int writeScalarProperty(String name, JsonToken type) {\n+        return FILTER_SKIP_TREE;\n+    }\n+\n+    public int writeScalarElement(int index, JsonToken type) {\n+        return FILTER_SKIP_TREE;\n+    }\n+\n+    // API, Objects\n+    \n+    public int startRootObject() {\n+        return FILTER_SKIP_TREE;\n+    }\n+    \n+    public int startObjectProperty(String name) {\n+        return FILTER_SKIP_TREE;\n+    }\n+    \n+    public int startObjectElement(int index) {\n+        return FILTER_SKIP_TREE;\n+    }\n+    \n+    public void finishObject() { }\n+\n+    // API, Arrays\n+    \n+    public int startRootArray() {\n+        return FILTER_SKIP_TREE;\n+    }\n+    \n+    public int startArrayProperty(String name) {\n+        return FILTER_SKIP_TREE;\n+    }\n+    \n+    public int startArrayElement(int index) {\n+        return FILTER_SKIP_TREE;\n+    }\n+    \n+    public void finishArray() { }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/TokenFilterContext.java\n+package com.fasterxml.jackson.core.filter;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+/**\n+ * Alternative variant of {@link JsonStreamContext}, used when filtering\n+ * content being read or written (based on {@link TokenFilter}).\n+ */\n+public class TokenFilterContext extends JsonStreamContext\n+{\n+    /**\n+     * Parent context for this context; null for root context.\n+     */\n+    protected final TokenFilterContext _parent;\n+\n+    /*\n+    /**********************************************************\n+    /* Simple instance reuse slots; speed up things\n+    /* a bit (10-15%) for docs with lots of small\n+    /* arrays/objects\n+    /**********************************************************\n+     */\n+\n+    protected TokenFilterContext _child = null;\n+\n+    /*\n+    /**********************************************************\n+    /* Location/state information\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Name of the field of which value is to be parsed; only\n+     * used for OBJECT contexts\n+     */\n+    protected String _currentName;\n+\n+    protected int _filterState;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    protected TokenFilterContext(int type, TokenFilterContext parent, int fstate) {\n+        super();\n+        _type = type;\n+        _parent = parent;\n+        _filterState = fstate;\n+        _index = -1;\n+    }\n+\n+    protected TokenFilterContext reset(int type, int fstate) {\n+        _type = type;\n+        _filterState = fstate;\n+        _index = -1;\n+        _currentName = null;\n+        return this;\n+    }\n+\n+    @Override\n+    public Object getCurrentValue() {\n+        return null;\n+    }\n+\n+    @Override\n+    public void setCurrentValue(Object v) { }\n+    \n+    /*\n+    /**********************************************************\n+    /* Factory methods\n+    /**********************************************************\n+     */\n+\n+    public static TokenFilterContext createRootContext(int fstate) {\n+        return new TokenFilterContext(TYPE_ROOT, null, fstate);\n+    }\n+\n+    public TokenFilterContext createChildArrayContext(int fstate) {\n+        TokenFilterContext ctxt = _child;\n+        if (ctxt == null) {\n+            _child = ctxt = new TokenFilterContext(TYPE_ARRAY, this, fstate);\n+            return ctxt;\n+        }\n+        return ctxt.reset(TYPE_ARRAY, fstate);\n+    }\n+\n+    public TokenFilterContext createChildObjectContext(int fstate) {\n+        TokenFilterContext ctxt = _child;\n+        if (ctxt == null) {\n+            _child = ctxt = new TokenFilterContext(TYPE_OBJECT, this, fstate);\n+            return ctxt;\n+        }\n+        return ctxt.reset(TYPE_OBJECT, fstate);\n+    }\n+\n+    @Override public final TokenFilterContext getParent() { return _parent; }\n+    @Override public final String getCurrentName() { return _currentName; }\n+\n+    public int getFilterState() { return _filterState; }\n+\n+    public void writeFieldName(String name) throws JsonProcessingException {\n+        _currentName = name;\n+    }\n+\n+    public void writeValue() {\n+        ++_index;\n+    }\n+\n+    // // // Internally used abstract methods\n+\n+    protected void appendDesc(StringBuilder sb) {\n+        if (_type == TYPE_OBJECT) {\n+            sb.append('{');\n+            if (_currentName != null) {\n+                sb.append('\"');\n+                // !!! TODO: Name chars should be escaped?\n+                sb.append(_currentName);\n+                sb.append('\"');\n+            } else {\n+                sb.append('?');\n+            }\n+            sb.append('}');\n+        } else if (_type == TYPE_ARRAY) {\n+            sb.append('[');\n+            sb.append(getCurrentIndex());\n+            sb.append(']');\n+        } else {\n+            // nah, ROOT:\n+            sb.append(\"/\");\n+        }\n+    }\n+\n+    // // // Overridden standard methods\n+\n+    /**\n+     * Overridden to provide developer writeable \"JsonPath\" representation\n+     * of the context.\n+     */\n+    @Override public String toString() {\n+        StringBuilder sb = new StringBuilder(64);\n+        appendDesc(sb);\n+        return sb.toString();\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java\n         return ctxt.reset(TYPE_OBJECT);\n     }\n \n-    // // // Shared API\n-\n     @Override public final JsonWriteContext getParent() { return _parent; }\n     @Override public final String getCurrentName() { return _currentName; }\n \n     public DupDetector getDupDetector() {\n         return _dups;\n     }\n-    \n-    // // // API sub-classes are to implement\n \n     /**\n      * Method that writer is to call before it writes a field name.", "timestamp": 1427329335, "metainfo": ""}