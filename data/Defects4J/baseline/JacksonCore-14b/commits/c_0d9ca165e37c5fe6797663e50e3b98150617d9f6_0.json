{"sha": "0d9ca165e37c5fe6797663e50e3b98150617d9f6", "log": "Merge branch '2.6'", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java\n             _hashArea = Arrays.copyOf(_hashArea, _hashArea.length);\n             _names = Arrays.copyOf(_names, _names.length);\n             _hashShared = false;\n+            // 09-Sep-2015, tatu: As per [jackson-core#216], also need to ensure\n+            //    we rehash as needed, as need-rehash flag is not copied from parent\n+            _verifyNeedForRehash();\n         }\n         if (_needRehash) {\n             rehash();\n         }\n     }\n-    \n+\n     /**\n      * Method called to find the location within hash table to add a new symbol in.\n      */\n--- a/src/test/java/com/fasterxml/jackson/core/sym/SymbolsViaParserTest.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/SymbolsViaParserTest.java\n package com.fasterxml.jackson.core.sym;\n \n+import java.io.ByteArrayInputStream;\n import java.io.IOException;\n import java.util.HashSet;\n \n     extends com.fasterxml.jackson.core.BaseTest\n {\n     // for [jackson-core#213]\n-    public void test17CharSymbols() throws Exception\n-    {\n+    public void test17CharSymbols() throws Exception {\n         _test17Chars(false);\n     }\n \n     // for [jackson-core#213]\n-    public void test17ByteSymbols() throws Exception\n-    {\n+    public void test17ByteSymbols() throws Exception {\n         _test17Chars(true);\n     }\n \n+    // for [jackson-core#216]\n+    public void testSymbolTableExpansionChars() throws Exception {\n+        _testSymbolTableExpansion(false);\n+    }\n+\n+    // for [jackson-core#216]\n+    public void testSymbolTableExpansionBytes() throws Exception {\n+        _testSymbolTableExpansion(true);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Secondary test methods\n+    /**********************************************************\n+     */\n+\n     private void _test17Chars(boolean useBytes) throws IOException\n     {\n-        String doc = _createDoc();\n+        String doc = _createDoc17();\n         JsonFactory f = new JsonFactory();\n         \n-        JsonParser p;\n-        if (useBytes) {\n-            p = f.createParser(doc.getBytes(\"UTF-8\"));\n-        } else {\n-            p = f.createParser(doc);\n-        }\n+        JsonParser p = useBytes\n+                ? f.createParser(doc.getBytes(\"UTF-8\"))\n+                : f.createParser(doc);\n         HashSet<String> syms = new HashSet<String>();\n         assertToken(JsonToken.START_OBJECT, p.nextToken());\n         for (int i = 0; i < 50; ++i) {\n         p.close();\n     }\n \n-    private String _createDoc() {\n+    private String _createDoc17() {\n         StringBuilder sb = new StringBuilder(1000);\n         sb.append(\"{\\n\");\n         for (int i = 1; i <= 50; ++i) {\n         sb.append(\"\\n}\");\n         return sb.toString();\n     }\n+\n+    public void _testSymbolTableExpansion(boolean useBytes) throws Exception\n+    {\n+        JsonFactory jsonFactory = new JsonFactory();\n+        // Important: must create separate documents to gradually build up symbol table\n+        for (int i = 0; i < 200; i++) {\n+            String field = Integer.toString(i);\n+            final String doc = \"{ \\\"\" + field + \"\\\" : \\\"test\\\" }\";\n+            JsonParser parser = useBytes\n+                    ? jsonFactory.createParser(doc.getBytes(\"UTF-8\"))\n+                    : jsonFactory.createParser(doc);\n+            assertToken(JsonToken.START_OBJECT, parser.nextToken());\n+            assertToken(JsonToken.FIELD_NAME, parser.nextToken());\n+            assertEquals(field, parser.getCurrentName());\n+            assertToken(JsonToken.VALUE_STRING, parser.nextToken());\n+            assertToken(JsonToken.END_OBJECT, parser.nextToken());\n+            assertNull(parser.nextToken());\n+            parser.close();\n+        }\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n      */\n     protected final transient ByteQuadsCanonicalizer _byteSymbolCanonicalizer = ByteQuadsCanonicalizer.createRoot();\n \n-    /**\n-     * Earlier byte-based symbol table; replaced with 2.6 with a new implementation.\n-     * Left in for version 2.6.0: will be removed in 2.7 or later.\n-     *\n-     * @deprecated Since 2.6.0, only use {@link #_byteSymbolCanonicalizer}\n-     */\n-    @Deprecated\n-    protected final transient com.fasterxml.jackson.core.sym.BytesToNameCanonicalizer _rootByteSymbols\n-        = com.fasterxml.jackson.core.sym.BytesToNameCanonicalizer.createRoot();\n-\n     /*\n     /**********************************************************\n     /* Configuration\n--- a/src/main/java/com/fasterxml/jackson/core/JsonGenerationException.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonGenerationException.java\n     extends JsonProcessingException\n {\n     private final static long serialVersionUID = 123; // Stupid eclipse...\n-    \n-    public JsonGenerationException(Throwable rootCause)\n-    {\n+\n+    protected JsonGenerator _processor;\n+\n+    // TODO: mark deprecated in 2.7\n+    public JsonGenerationException(Throwable rootCause) {\n         super(rootCause);\n     }\n \n-    public JsonGenerationException(String msg)\n-    {\n+    // TODO: mark deprecated in 2.7\n+    public JsonGenerationException(String msg) {\n         super(msg, (JsonLocation)null);\n     }\n \n-    public JsonGenerationException(String msg, Throwable rootCause)\n-    {\n+    // TODO: mark deprecated in 2.7\n+    public JsonGenerationException(String msg, Throwable rootCause) {\n         super(msg, null, rootCause);\n     }\n+\n+    /**\n+     * @since 2.7\n+     */\n+    public JsonGenerationException(Throwable rootCause, JsonGenerator g) {\n+        super(rootCause);\n+        _processor = g;\n+    }\n+\n+    /**\n+     * @since 2.7\n+     */\n+    public JsonGenerationException(String msg, JsonGenerator g) {\n+        super(msg, (JsonLocation) null);\n+        _processor = g;\n+    }\n+    \n+    /**\n+     * @since 2.7\n+     */\n+    public JsonGenerationException(String msg, Throwable rootCause, JsonGenerator g) {\n+        super(msg, null, rootCause);\n+        _processor = g;\n+    }\n+\n+    /**\n+     * Fluent method that may be used to assign originating {@link JsonGenerator},\n+     * to be accessed using {@link #getProcessor()}.\n+     *\n+     * @since 2.7\n+     */\n+    public JsonGenerationException withGenerator(JsonGenerator g) {\n+        _processor = g;\n+        return this;\n+    }\n+\n+    @Override\n+    public JsonGenerator getProcessor() { return _processor; }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n      * @since 2.3\n      */\n     public void writeObjectId(Object id) throws IOException {\n-        throw new JsonGenerationException(\"No native support for writing Object Ids\");\n+        throw new JsonGenerationException(\"No native support for writing Object Ids\", this);\n     }\n \n     /**\n      * a {@link JsonGenerationException} will be thrown.\n      */\n     public void writeObjectRef(Object id) throws IOException {\n-        throw new JsonGenerationException(\"No native support for writing Object Ids\");\n+        throw new JsonGenerationException(\"No native support for writing Object Ids\", this);\n     }\n     \n     /**\n      * @since 2.3\n      */\n     public void writeTypeId(Object id) throws IOException {\n-        throw new JsonGenerationException(\"No native support for writing Type Ids\");\n+        throw new JsonGenerationException(\"No native support for writing Type Ids\", this);\n     }\n     \n     /*\n      * or use a {@link JsonGenerationException} sub-class.\n      */\n     protected void _reportError(String msg) throws JsonGenerationException {\n-        throw new JsonGenerationException(msg);\n+        throw new JsonGenerationException(msg, this);\n     }\n \n     protected final void _throwInternal() { VersionUtil.throwInternal(); }\n     protected void _reportUnsupportedOperation() {\n         throw new UnsupportedOperationException(\"Operation not supported by generator of type \"+getClass().getName());\n     }\n-    \n+\n     /**\n      * Helper method to try to call appropriate write method for given\n      * untyped Object. At this point, no structural conversions should be done,\n             } else if (n instanceof BigDecimal) {\n                 writeNumber((BigDecimal) n);\n                 return;\n-                \n+\n             // then Atomic types\n-                \n             } else if (n instanceof AtomicInteger) {\n                 writeNumber(((AtomicInteger) n).get());\n                 return;\n--- a/src/main/java/com/fasterxml/jackson/core/JsonParseException.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonParseException.java\n  * is encountered.\n  */\n public class JsonParseException extends JsonProcessingException {\n-    private static final long serialVersionUID = 1L;\n-    \n+    private static final long serialVersionUID = 2L; // 2.7\n+\n+    protected JsonParser _processor;\n+\n+    // TODO: mark deprecated in 2.7\n     public JsonParseException(String msg, JsonLocation loc) {\n         super(msg, loc);\n     }\n \n+    // TODO: mark deprecated in 2.7\n     public JsonParseException(String msg, JsonLocation loc, Throwable root) {\n         super(msg, loc, root);\n     }\n+\n+    /**\n+     * Constructor that uses current parsing location as location, and\n+     * sets processor (accessible via {@link #getProcessor()}) to\n+     * specified parser.\n+     *\n+     * @since 2.7\n+     */\n+    public JsonParseException(JsonParser p, String msg) {\n+        super(msg, (p == null) ? null : p.getCurrentLocation());\n+        _processor = p;\n+    }\n+\n+    /**\n+     * @since 2.7\n+     */\n+    public JsonParseException(JsonParser p, String msg, Throwable root) {\n+        super(msg, (p == null) ? null : p.getCurrentLocation(), root);\n+        _processor = p;\n+    }\n+    \n+    /**\n+     * @since 2.7\n+     */\n+    public JsonParseException(JsonParser p, String msg, JsonLocation loc) {\n+        super(msg, loc);\n+        _processor = p;\n+    }\n+\n+    /**\n+     * @since 2.7\n+     */\n+    public JsonParseException(JsonParser p, String msg, JsonLocation loc, Throwable root) {\n+        super(msg, loc, root);\n+        _processor = p;\n+    }\n+\n+    /**\n+     * Fluent method that may be used to assign originating {@link JsonParser},\n+     * to be accessed using {@link #getProcessor()}.\n+     *\n+     * @since 2.7\n+     */\n+    public JsonParseException withParser(JsonParser p) {\n+        _processor = p;\n+        return this;\n+    }\n+\n+    @Override\n+    public JsonParser getProcessor() {\n+        return _processor;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n         JsonToken t = getCurrentToken();\n         if (t == JsonToken.VALUE_TRUE) return true;\n         if (t == JsonToken.VALUE_FALSE) return false;\n-        throw new JsonParseException(\"Current token (\"+t+\") not of boolean type\", getCurrentLocation());\n+        throw new JsonParseException(this,\n+                String.format(\"Current token (%s) not of boolean type\", t));\n     }\n \n     /**\n      * based on current state of the parser\n      */\n     protected JsonParseException _constructError(String msg) {\n-        return new JsonParseException(msg, getCurrentLocation());\n+        return new JsonParseException(this, msg);\n     }\n \n     /**\n--- a/src/main/java/com/fasterxml/jackson/core/JsonProcessingException.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonProcessingException.java\n         this(null, null, rootCause);\n     }\n \n-    public JsonLocation getLocation() { return _location; }\n-\n     /*\n     /**********************************************************\n     /* Extended API\n     /**********************************************************\n      */\n \n+    public JsonLocation getLocation() { return _location; }\n+    \n     /**\n      * Method that allows accessing the original \"message\" argument,\n      * without additional decorations (like location information)\n      * @since 2.1\n      */\n     public String getOriginalMessage() { return super.getMessage(); }\n+\n+    /**\n+     * Method that allows accessing underlying processor that triggered\n+     * this exception; typically either {@link JsonParser} or {@link JsonGenerator}\n+     * for exceptions that originate from streaming API.\n+     * Note that it is possible that `null` may be returned if code throwing\n+     * exception either has no access to processor; or has not been retrofitted\n+     * to set it; this means that caller needs to take care to check for nulls.\n+     * Subtypes override this method with co-variant return type, for more\n+     * type-safe access.\n+     * \n+     * @return Originating processor, if available; null if not.\n+     *\n+     * @since 2.7\n+     */\n+    public Object getProcessor() { return null; }\n \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/core/Version.java\n+++ b/src/main/java/com/fasterxml/jackson/core/Version.java\n     private static final long serialVersionUID = 1L;\n \n     private final static Version UNKNOWN_VERSION = new Version(0, 0, 0, null, null, null);\n-    \n+\n     protected final int _majorVersion;\n \n     protected final int _minorVersion;\n     protected final int _patchLevel;\n \n     protected final String _groupId;\n-    \n+\n     protected final String _artifactId;\n-    \n+\n     /**\n      * Additional information for snapshot versions; null for non-snapshot\n      * (release) versions.\n     {\n         this(major, minor, patchLevel, snapshotInfo, null, null);\n     }\n-    \n+\n     public Version(int major, int minor, int patchLevel, String snapshotInfo,\n             String groupId, String artifactId)\n     {\n      */\n     public static Version unknownVersion() { return UNKNOWN_VERSION; }\n \n-    public boolean isUknownVersion() { return (this == UNKNOWN_VERSION); }\n+    /**\n+     * @since 2.7 to replace misspelled {@link #isUknownVersion()}\n+     */\n+    public boolean isUnknownVersion() { return (this == UNKNOWN_VERSION); }\n     public boolean isSnapshot() { return (_snapshotInfo != null && _snapshotInfo.length() > 0); }\n-    \n+\n+    /**\n+     * @deprecated Since 2.7 use correctly spelled method {@link #isUnknownVersion()}\n+     */\n+    @Deprecated\n+    public boolean isUknownVersion() { return isUnknownVersion(); }\n+\n     public int getMajorVersion() { return _majorVersion; }\n     public int getMinorVersion() { return _minorVersion; }\n     public int getPatchLevel() { return _patchLevel; }\n \n     public String getGroupId() { return _groupId; }\n     public String getArtifactId() { return _artifactId; }\n-    \n+\n     public String toFullString() {\n         return _groupId + '/' + _artifactId + '/' + toString();\n     }\n-    \n+\n     @Override public String toString() {\n         StringBuilder sb = new StringBuilder();\n         sb.append(_majorVersion).append('.');\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n     public int getValueAsInt() throws IOException\n     {\n         JsonToken t = _currToken;\n-        if (t == JsonToken.VALUE_NUMBER_INT) {\n+        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n             return getIntValue();\n         }\n-        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n-            return getIntValue();\n-        }\n         return getValueAsInt(0);\n     }\n \n     public int getValueAsInt(int defaultValue) throws IOException\n     {\n         JsonToken t = _currToken;\n-        if (t == JsonToken.VALUE_NUMBER_INT) {\n-            return getIntValue();\n-        }\n-        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n+        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n             return getIntValue();\n         }\n         if (t != null) {\n     public long getValueAsLong() throws IOException\n     {\n         JsonToken t = _currToken;\n-        if (t == JsonToken.VALUE_NUMBER_INT) {\n+        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n             return getLongValue();\n         }\n-        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n-            return getLongValue();\n-        }\n         return getValueAsLong(0L);\n     }\n     \n     public long getValueAsLong(long defaultValue) throws IOException\n     {\n         JsonToken t = _currToken;\n-        if (t == JsonToken.VALUE_NUMBER_INT) {\n-            return getLongValue();\n-        }\n-        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n+        if ((t == JsonToken.VALUE_NUMBER_INT) || (t == JsonToken.VALUE_NUMBER_FLOAT)) {\n             return getLongValue();\n         }\n         if (t != null) {\n     }\n \n     protected final JsonParseException _constructError(String msg, Throwable t) {\n-        return new JsonParseException(msg, getCurrentLocation(), t);\n+        return new JsonParseException(this, msg, t);\n     }\n \n     protected static byte[] _asciiBytes(String str) {\n         }\n         return b;\n     }\n-    \n+\n     protected static String _ascii(byte[] b) {\n         try {\n             return new String(b, \"US-ASCII\");\n--- a/src/main/java/com/fasterxml/jackson/core/json/DupDetector.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/DupDetector.java\n public class DupDetector\n {\n     /**\n-     * We need to store a back-reference here to parser/generator, unfortunately.\n+     * We need to store a back-reference here to parser/generator.\n      */\n     protected final Object _source;\n \n         // do generators have a way to provide Location? Apparently not...\n         return null;\n     }\n-    \n+\n+    /**\n+     * @since 2.7\n+     */\n+    public Object getSource() {\n+        return _source;\n+    }\n+\n     public boolean isDup(String name) throws JsonParseException\n     {\n         if (_firstName == null) {\n--- a/src/main/java/com/fasterxml/jackson/core/json/JsonReadContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonReadContext.java\n     /**********************************************************\n      */\n \n-    @Deprecated // since 2.3, use variant that takes dup detector\n-    public static JsonReadContext createRootContext(int lineNr, int colNr) {\n-        return createRootContext(lineNr, colNr, null);\n-    }\n-\n     public static JsonReadContext createRootContext(int lineNr, int colNr, DupDetector dups) {\n         return new JsonReadContext(null, dups, TYPE_ROOT, lineNr, colNr);\n-    }\n-\n-    @Deprecated // since 2.3, use variant that takes dup detector\n-    public static JsonReadContext createRootContext() {\n-        return createRootContext(null);\n     }\n \n     public static JsonReadContext createRootContext(DupDetector dups) {\n \n     private void _checkDup(DupDetector dd, String name) throws JsonProcessingException {\n         if (dd.isDup(name)) {\n-            throw new JsonParseException(\"Duplicate field '\"+name+\"'\", dd.findLocation());\n-        }\n-    }\n-    \n+            Object src = dd.getSource();\n+            throw new JsonParseException(((src instanceof JsonGenerator) ? ((JsonParser) src) : null),\n+                    \"Duplicate field '\"+name+\"'\");\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Overridden standard methods\n--- a/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java\n     }\n \n     private final void _checkDup(DupDetector dd, String name) throws JsonProcessingException {\n-        if (dd.isDup(name)) { throw new JsonGenerationException(\"Duplicate field '\"+name+\"'\"); }\n+        if (dd.isDup(name)) {\n+            Object src = dd.getSource();\n+            throw new JsonGenerationException(\"Duplicate field '\"+name+\"'\",\n+                    ((src instanceof JsonGenerator) ? ((JsonGenerator) src) : null));\n+        }\n     }\n     \n     public int writeValue() {\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n     @Override\n     public final JsonToken nextToken() throws IOException\n     {\n-        _numTypesValid = NR_UNKNOWN;\n-\n         /* First: field names are special -- we will always tokenize\n          * (part of) value along with field name to simplify\n          * state handling. If so, can and need to use secondary token:\n         if (_currToken == JsonToken.FIELD_NAME) {\n             return _nextAfterName();\n         }\n+        // But if we didn't already have a name, and (partially?) decode number,\n+        // need to ensure no numeric information is leaked\n+        _numTypesValid = NR_UNKNOWN;\n         if (_tokenIncomplete) {\n             _skipString(); // only strings can be partial\n         }\n     /**********************************************************\n      */\n \n-    /*\n+    // Implemented since 2.7\n     @Override\n-    public boolean nextFieldName(SerializableString str)\n-        throws IOException\n-    {\n-    \n-    }\n-    */\n+    public boolean nextFieldName(SerializableString sstr) throws IOException\n+    {\n+        // // // Note: most of code below is copied from nextToken()\n+\n+        _numTypesValid = NR_UNKNOWN;\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+            _nextAfterName();\n+            return false;\n+        }\n+        if (_tokenIncomplete) {\n+            _skipString();\n+        }\n+        int i = _skipWSOrEnd();\n+        if (i < 0) {\n+            close();\n+            _currToken = null;\n+            return false;\n+        }\n+        _tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n+        _tokenInputRow = _currInputRow;\n+        _tokenInputCol = _inputPtr - _currInputRowStart - 1;\n+        _binaryValue = null;\n+        if (i == INT_RBRACKET) {\n+            if (!_parsingContext.inArray()) {\n+                _reportMismatchedEndMarker(i, '}');\n+            }\n+            _parsingContext = _parsingContext.getParent();\n+            _currToken = JsonToken.END_ARRAY;\n+            return false;\n+        }\n+        if (i == INT_RCURLY) {\n+            if (!_parsingContext.inObject()) {\n+                _reportMismatchedEndMarker(i, ']');\n+            }\n+            _parsingContext = _parsingContext.getParent();\n+            _currToken = JsonToken.END_OBJECT;\n+            return false;\n+        }\n+        if (_parsingContext.expectComma()) {\n+            i = _skipComma(i);\n+        }\n+\n+        if (!_parsingContext.inObject()) {\n+            _nextTokenNotInObject(i);\n+            return false;\n+        }\n+\n+        if (i == INT_QUOTE) {\n+            // when doing literal match, must consider escaping:\n+            char[] nameChars = sstr.asQuotedChars();\n+            final int len = nameChars.length;\n+\n+            // Require 4 more bytes for faster skipping of colon that follows name\n+            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n+                // first check length match by\n+                final int end = _inputPtr+len;\n+                if (_inputBuffer[end] == '\"') {\n+                    int offset = 0;\n+                    int ptr = _inputPtr;\n+                    while (true) {\n+                        if (ptr == end) { // yes, match!\n+                            _parsingContext.setCurrentName(sstr.getValue());\n+                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n+                            return true;\n+                        }\n+                        if (nameChars[offset] != _inputBuffer[ptr]) {\n+                            break;\n+                        }\n+                        ++offset;\n+                        ++ptr;\n+                    }\n+                }\n+            }\n+        }\n+        return _isNextTokenNameMaybe(i, sstr.getValue());\n+    }\n \n     @Override\n     public String nextFieldName() throws IOException\n         }\n         _nextToken = t;\n         return name;\n+    }\n+\n+    private final void _isNextTokenNameYes(int i) throws IOException\n+    {\n+        _currToken = JsonToken.FIELD_NAME;\n+\n+        switch (i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            _nextToken = JsonToken.VALUE_STRING;\n+            return;\n+        case '[':\n+            _nextToken = JsonToken.START_ARRAY;\n+            return;\n+        case '{':\n+            _nextToken = JsonToken.START_OBJECT;\n+            return;\n+        case 't':\n+            _matchToken(\"true\", 1);\n+            _nextToken = JsonToken.VALUE_TRUE;\n+            return;\n+        case 'f':\n+            _matchToken(\"false\", 1);\n+            _nextToken = JsonToken.VALUE_FALSE;\n+            return;\n+        case 'n':\n+            _matchToken(\"null\", 1);\n+            _nextToken = JsonToken.VALUE_NULL;\n+            return;\n+        case '-':\n+            _nextToken = _parseNegNumber();\n+            return;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            _nextToken = _parsePosNumber(i);\n+            return;\n+        }\n+        _nextToken = _handleOddValue(i);\n+    }\n+\n+    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n+    {\n+        // // // and this is back to standard nextToken()\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n+        if (i == INT_QUOTE) {\n+            _tokenIncomplete = true;\n+            _nextToken = JsonToken.VALUE_STRING;\n+            return nameToMatch.equals(name);\n+        }\n+        // Ok: we must have a value... what is it?\n+        JsonToken t;\n+        switch (i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+        }\n+        _nextToken = t;\n+        return nameToMatch.equals(name);\n     }\n \n     private final JsonToken _nextTokenNotInObject(int i) throws IOException\n             }\n         }\n     }\n- \n+\n+    // Variant called when we know there's at least 4 more bytes available\n+    private final int _skipColonFast(int ptr) throws IOException\n+    {\n+        int i = (int) _inputBuffer[ptr++];\n+        if (i == INT_COLON) { // common case, no leading space\n+            i = _inputBuffer[ptr++];\n+            if (i > INT_SPACE) { // nor trailing\n+                if (i != INT_SLASH && i != INT_HASH) {\n+                    _inputPtr = ptr;\n+                    return i;\n+                }\n+            } else if (i == INT_SPACE || i == INT_TAB) {\n+                i = (int) _inputBuffer[ptr++];\n+                if (i > INT_SPACE) {\n+                    if (i != INT_SLASH && i != INT_HASH) {\n+                        _inputPtr = ptr;\n+                        return i;\n+                    }\n+                }\n+            }\n+            _inputPtr = ptr-1;\n+            return _skipColon2(true); // true -> skipped colon\n+        }\n+        if (i == INT_SPACE || i == INT_TAB) {\n+            i = _inputBuffer[ptr++];\n+        }\n+        if (i == INT_COLON) {\n+            i = _inputBuffer[ptr++];\n+            if (i > INT_SPACE) {\n+                if (i != INT_SLASH && i != INT_HASH) {\n+                    _inputPtr = ptr;\n+                    return i;\n+                }\n+            } else if (i == INT_SPACE || i == INT_TAB) {\n+                i = (int) _inputBuffer[ptr++];\n+                if (i > INT_SPACE) {\n+                    if (i != INT_SLASH && i != INT_HASH) {\n+                        _inputPtr = ptr;\n+                        return i;\n+                    }\n+                }\n+            }\n+        }\n+        _inputPtr = ptr-1;\n+        return _skipColon2(false);\n+    }\n+    \n     // Primary loop: no reloading, comment handling\n     private final int _skipComma(int i) throws IOException\n     {\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n     @Override\n     public JsonToken nextToken() throws IOException\n     {\n-        _numTypesValid = NR_UNKNOWN;\n         /* First: field names are special -- we will always tokenize\n          * (part of) value along with field name to simplify\n          * state handling. If so, can and need to use secondary token:\n         if (_currToken == JsonToken.FIELD_NAME) {\n             return _nextAfterName();\n         }\n+        // But if we didn't already have a name, and (partially?) decode number,\n+        // need to ensure no numeric information is leaked\n+        _numTypesValid = NR_UNKNOWN;\n         if (_tokenIncomplete) {\n             _skipString(); // only strings can be partial\n         }\n--- a/src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java\n      */\n \n     @Override\n-    public void writeRootValueSeparator(JsonGenerator jg)\n-        throws IOException, JsonGenerationException\n+    public void writeRootValueSeparator(JsonGenerator jg) throws IOException\n     {\n         if (_rootSeparator != null) {\n             jg.writeRaw(_rootSeparator);\n     }\n \n     @Override\n-    public void writeStartObject(JsonGenerator jg)\n-        throws IOException, JsonGenerationException\n+    public void writeStartObject(JsonGenerator jg) throws IOException\n     {\n         jg.writeRaw('{');\n         if (!_objectIndenter.isInline()) {\n     }\n \n     @Override\n-    public void beforeObjectEntries(JsonGenerator jg)\n-        throws IOException, JsonGenerationException\n+    public void beforeObjectEntries(JsonGenerator jg) throws IOException\n     {\n         _objectIndenter.writeIndentation(jg, _nesting);\n     }\n      * (white-space) decoration.\n      */\n     @Override\n-    public void writeObjectFieldValueSeparator(JsonGenerator jg)\n-        throws IOException, JsonGenerationException\n+    public void writeObjectFieldValueSeparator(JsonGenerator jg) throws IOException\n     {\n         if (_spacesInObjectEntries) {\n             jg.writeRaw(\" : \");\n      * (white-space) decoration.\n      */\n     @Override\n-    public void writeObjectEntrySeparator(JsonGenerator jg)\n-        throws IOException, JsonGenerationException\n+    public void writeObjectEntrySeparator(JsonGenerator jg) throws IOException\n     {\n         jg.writeRaw(',');\n         _objectIndenter.writeIndentation(jg, _nesting);\n     }\n \n     @Override\n-    public void writeEndObject(JsonGenerator jg, int nrOfEntries)\n-        throws IOException, JsonGenerationException\n+    public void writeEndObject(JsonGenerator jg, int nrOfEntries) throws IOException\n     {\n         if (!_objectIndenter.isInline()) {\n             --_nesting;\n     }\n \n     @Override\n-    public void writeStartArray(JsonGenerator jg)\n-        throws IOException, JsonGenerationException\n+    public void writeStartArray(JsonGenerator jg) throws IOException\n     {\n         if (!_arrayIndenter.isInline()) {\n             ++_nesting;\n     }\n \n     @Override\n-    public void beforeArrayValues(JsonGenerator jg)\n-        throws IOException, JsonGenerationException\n-    {\n+    public void beforeArrayValues(JsonGenerator jg) throws IOException {\n         _arrayIndenter.writeIndentation(jg, _nesting);\n     }\n \n         @Override\n         public boolean isInline() { return true; }\n     }\n-    \n-    /**\n-     * @deprecated Since 2.5 use {@link DefaultIndenter} instead\n-     */\n-    @Deprecated\n-    public static class Lf2SpacesIndenter extends DefaultIndenter\n-    {\n-        /** @deprecated Use {@link DefaultIndenter#SYSTEM_LINEFEED_INSTANCE} instead.\n-         */\n-        @SuppressWarnings(\"hiding\")\n-        @Deprecated\n-        public static final Lf2SpacesIndenter instance = new Lf2SpacesIndenter();\n-\n-        /** @deprecated Use {@code new DefaultIndenter(\"  \", DefaultIndenter.SYS_LF)} instead\n-         */\n-        @Deprecated\n-        public Lf2SpacesIndenter() {\n-            super(\"  \", DefaultIndenter.SYS_LF);\n-        }\n-        \n-        /** @deprecated Use {@code new DefaultIndenter(\"  \", lf)} instead\n-         */\n-        @Deprecated\n-        public Lf2SpacesIndenter(String lf) {\n-            super(\"  \", lf);\n-        }\n-\n-        /**\n-         * Note: method was accidentally missing from 2.5.0; put back for 2.5.1 and\n-         * later 2.5.x versions.\n-         */\n-        @Override\n-        public Lf2SpacesIndenter withLinefeed(String lf) {\n-            if (lf.equals(getEol())) {\n-                return this;\n-            }\n-            return new Lf2SpacesIndenter(lf);\n-        }\n-    }\n }\n--- a/src/test/java/com/fasterxml/jackson/core/TestExceptions.java\n+++ b/src/test/java/com/fasterxml/jackson/core/TestExceptions.java\n package com.fasterxml.jackson.core;\n \n+import java.io.StringWriter;\n \n public class TestExceptions extends BaseTest\n {\n-    // For [Issue#10]\n+    private final JsonFactory JSON_F = new JsonFactory();\n+    \n+    // For [core#10]\n     public void testOriginalMesssage()\n     {\n-        JsonProcessingException exc = new JsonParseException(\"Foobar\", JsonLocation.NA);\n+        JsonProcessingException exc = new JsonParseException(null, \"Foobar\", JsonLocation.NA);\n         String msg = exc.getMessage();\n         String orig = exc.getOriginalMessage();\n         assertEquals(\"Foobar\", orig);\n         assertTrue(msg.length() > orig.length());\n     }\n+\n+    // [core#198]\n+    public void testAccessToParser() throws Exception\n+    {\n+        JsonParser p = JSON_F.createParser(\"{}\");\n+        assertToken(JsonToken.START_OBJECT, p.nextToken());\n+        JsonParseException e = new JsonParseException(p, \"Test!\");\n+        assertSame(p, e.getProcessor());\n+        assertEquals(\"Test!\", e.getOriginalMessage());\n+        JsonLocation loc = e.getLocation();\n+        assertNotNull(loc);\n+        assertEquals(2, loc.getColumnNr());\n+        assertEquals(1, loc.getLineNr());\n+        p.close();\n+    }\n+\n+    // [core#198]\n+    public void testAccessToGenerator() throws Exception\n+    {\n+        StringWriter w = new StringWriter();\n+        JsonGenerator g = JSON_F.createGenerator(w);\n+        g.writeStartObject();\n+        JsonGenerationException e = new JsonGenerationException(\"Test!\", g);\n+        assertSame(g, e.getProcessor());\n+        assertEquals(\"Test!\", e.getOriginalMessage());\n+        g.close();\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestNextXxx.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestNextXxx.java\n \n     private final JsonFactory JSON_F = new JsonFactory();\n \n-    // [JACKSON-653]\n     public void testIsNextTokenName() throws Exception\n     {\n         _testIsNextTokenName1(false);\n         _testIsNextTokenName1(true);\n+    }\n+\n+    public void testIsNextTokenName2() throws Exception {\n         _testIsNextTokenName2(false);\n         _testIsNextTokenName2(true);\n+    }        \n+    \n+    public void testIsNextTokenName3() throws Exception {\n         _testIsNextTokenName3(false);\n         _testIsNextTokenName3(true);\n     }\n-\n+    \n+    public void testIsNextTokenName4() throws Exception {\n+        _testIsNextTokenName4(false);\n+        _testIsNextTokenName4(true);\n+    }\n+    \n     // [Issue#34]\n     public void testIssue34() throws Exception\n     {\n         assertToken(JsonToken.FIELD_NAME, jp.getCurrentToken());\n         assertEquals(\"name2\", jp.getCurrentName());\n         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        // do NOT check number value, to enforce skipping\n \n         assertFalse(jp.nextFieldName(NAME));\n         assertToken(JsonToken.FIELD_NAME, jp.getCurrentToken());\n \n         assertNull(jp.nextFieldName());\n         assertNull(jp.getCurrentToken());\n+\n+        jp.close();\n+    }\n+\n+    private void _testIsNextTokenName4(boolean useStream) throws Exception\n+    {\n+        final String DOC = \"{\\\"name\\\":-123,\\\"name2\\\":99}\";\n+        JsonParser jp = useStream ?\n+                JSON_F.createParser(new ByteArrayInputStream(DOC.getBytes(\"UTF-8\")))\n+            : JSON_F.createParser(new StringReader(DOC));\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+\n+        assertTrue(jp.nextFieldName(new SerializedString(\"name\")));\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(-123, jp.getIntValue());\n+\n+        assertTrue(jp.nextFieldName(new SerializedString(\"name2\")));\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(99, jp.getIntValue());\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+        assertNull(jp.nextToken());\n \n         jp.close();\n     }\n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n         assertEquals(6, symbols.maxCollisionLength());\n     }\n \n-    // Test for verifying stability of hashCode, wrt collisions, using\n-    // synthetic field name generation and byte-based input (UTF-8)\n-    @SuppressWarnings(\"deprecation\")\n-    public void testSyntheticWithBytesOld() throws IOException\n-    {\n-        // pass seed, to keep results consistent:\n-        final int SEED = 33333;\n-        BytesToNameCanonicalizer symbols =\n-                BytesToNameCanonicalizer.createRoot(SEED).makeChild(JsonFactory.Feature.collectDefaults());\n-\n-        final int COUNT = 12000;\n-        for (int i = 0; i < COUNT; ++i) {\n-            String id = fieldNameFor(i);\n-            int[] quads = calcQuads(id.getBytes(\"UTF-8\"));\n-            symbols.addName(id, quads, quads.length);\n-        }\n-        assertEquals(COUNT, symbols.size());\n-        assertEquals(16384, symbols.bucketCount());\n-\n-//System.out.printf(\"Byte stuff: collisions %d, max-coll %d\\n\", symbols.collisionCount(), symbols.maxCollisionLength());\n-        assertEquals(3476, symbols.collisionCount());\n-        // longest collision chain not optimal but ok:\n-        assertEquals(15, symbols.maxCollisionLength());\n-\n-        // But also verify entries are actually found?\n-    }\n-\n     public void testSyntheticWithBytesNew() throws IOException\n     {\n         // pass seed, to keep results consistent:\n         }\n     }\n \n-    @SuppressWarnings(\"deprecation\")\n-    public void testThousandsOfSymbolsWithOldBytes() throws IOException\n-    {\n-        final int SEED = 33333;\n-\n-        BytesToNameCanonicalizer symbolsBRoot = BytesToNameCanonicalizer.createRoot(SEED);\n-        final Charset utf8 = Charset.forName(\"UTF-8\");\n-        int exp = 0;\n-        \n-        for (int doc = 0; doc < 100; ++doc) {\n-            BytesToNameCanonicalizer symbolsB =\n-                    symbolsBRoot.makeChild(JsonFactory.Feature.collectDefaults());\n-            for (int i = 0; i < 250; ++i) {\n-                String name = \"f_\"+doc+\"_\"+i;\n-\n-                int[] quads = BytesToNameCanonicalizer.calcQuads(name.getBytes(utf8));\n-                symbolsB.addName(name, quads, quads.length);\n-                Name n = symbolsB.findName(quads, quads.length);\n-                assertEquals(name, n.getName());\n-            }\n-            symbolsB.release();\n-            exp += 250;\n-            if (exp > BytesToNameCanonicalizer.MAX_ENTRIES_FOR_REUSE) {\n-                exp = 0;\n-            }\n-            assertEquals(exp, symbolsBRoot.size());\n-        }\n-    }\n-\n     // Since 2.6\n     public void testThousandsOfSymbolsWithNew() throws IOException\n     {\n         Field syms = p.getClass().getDeclaredField(\"_symbols\");\n         syms.setAccessible(true);\n         return ((ByteQuadsCanonicalizer) syms.get(p));\n-    }\n-\n-    // [core#187]: unexpectedly high number of collisions for straight numbers\n-    @SuppressWarnings(\"deprecation\")\n-    public void testCollisionsWithBytes187() throws IOException\n-    {\n-        BytesToNameCanonicalizer symbols =\n-                BytesToNameCanonicalizer.createRoot(1).makeChild(JsonFactory.Feature.collectDefaults());\n-        final int COUNT = 30000;\n-        for (int i = 0; i < COUNT; ++i) {\n-            String id = String.valueOf(10000 + i);\n-            int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\"));\n-            symbols.addName(id, quads, quads.length);\n-        }\n-\n-//System.out.printf(\"Byte stuff: collisions %d, max-coll %d\\n\", symbols.collisionCount(), symbols.maxCollisionLength());\n-        \n-        assertEquals(COUNT, symbols.size());\n-        assertEquals(65536, symbols.bucketCount());\n-\n-        // collision count acceptable\n-        assertEquals(5782, symbols.collisionCount());\n-        // as well as collision counts\n-        assertEquals(24, symbols.maxCollisionLength());\n     }\n \n     // [core#187]: unexpectedly high number of collisions for straight numbers\n         assertEquals(2, symbols.maxCollisionLength());\n     }\n \n-    @SuppressWarnings(\"deprecation\")\n-    public void testShortQuotedDirectBytesOld() throws IOException\n-    {\n-        final int COUNT = 400;\n-        BytesToNameCanonicalizer symbols =\n-                BytesToNameCanonicalizer.createRoot(1).makeChild(JsonFactory.Feature.collectDefaults());\n-        for (int i = 0; i < COUNT; ++i) {\n-            String id = String.format(\"\\\\u%04x\", i);\n-            int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\"));\n-            symbols.addName(id, quads, quads.length);\n-        }\n-        assertEquals(COUNT, symbols.size());\n-        assertEquals(1024, symbols.bucketCount());\n-\n-        assertEquals(44, symbols.collisionCount());\n-        assertEquals(2, symbols.maxCollisionLength());\n-    }\n-\n     public void testShortQuotedDirectBytes() throws IOException\n     {\n         final int COUNT = 400;\n     }\n     \n     // [core#191]\n-    @SuppressWarnings(\"deprecation\")\n     public void testShortNameCollisionsDirect() throws IOException\n     {\n         final int COUNT = 600;\n             assertEquals(1024, symbols.bucketCount());\n     \n             assertEquals(16, symbols.collisionCount());\n-            assertEquals(1, symbols.maxCollisionLength());\n-        }\n-        \n-        // then byte-based\n-        {\n-            BytesToNameCanonicalizer symbols =\n-                    BytesToNameCanonicalizer.createRoot(1).makeChild(JsonFactory.Feature.collectDefaults());\n-            for (int i = 0; i < COUNT; ++i) {\n-                String id = String.valueOf((char) i);\n-                int[] quads = calcQuads(id.getBytes(\"UTF-8\"));\n-                symbols.addName(id, quads, quads.length);\n-            }\n-            assertEquals(COUNT, symbols.size());\n-            assertEquals(1024, symbols.bucketCount());\n-    \n-            assertEquals(209, symbols.collisionCount());\n             assertEquals(1, symbols.maxCollisionLength());\n         }\n     }", "timestamp": 1441821684, "metainfo": ""}