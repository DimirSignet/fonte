{"sha": "5cddffa133e7de41fa9efb5962cf3d0cff9b3e89", "log": "Fix #177", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n      * are allowed: meaning everywhere except for when\n      * a field name is expected.\n      */\n-    public abstract void writeStartObject()\n-        throws IOException;\n+    public abstract void writeStartObject() throws IOException;\n \n     /**\n      * Method for writing closing marker of a JSON Object value\n      * complete value, or START-OBJECT marker (see JSON specification\n      * for more details).\n      */\n-    public abstract void writeEndObject()\n-        throws IOException;\n+    public abstract void writeEndObject() throws IOException;\n \n     /**\n      * Method for writing a field name (JSON String surrounded by\n      * JSON specification for details), when field name is expected\n      * (field names alternate with values).\n      */\n-    public abstract void writeFieldName(String name)\n-        throws IOException;\n+    public abstract void writeFieldName(String name) throws IOException;\n \n     /**\n      * Method similar to {@link #writeFieldName(String)}, main difference\n      * serialized String; implementations are strongly encouraged to make\n      * use of more efficient methods argument object has.\n      */\n-    public abstract void writeFieldName(SerializableString name)\n-        throws IOException;\n+    public abstract void writeFieldName(SerializableString name) throws IOException;\n \n     /*\n     /**********************************************************\n      * surrounded in double quotes, and contents will be properly\n      * escaped as required by JSON specification.\n      */\n-    public abstract void writeString(String text)\n-        throws IOException;\n+    public abstract void writeString(String text) throws IOException;\n \n     /**\n      * Method for outputting a String value. Depending on context\n      * surrounded in double quotes, and contents will be properly\n      * escaped as required by JSON specification.\n      */\n-    public abstract void writeString(char[] text, int offset, int len)\n-        throws IOException;\n+    public abstract void writeString(char[] text, int offset, int len) throws IOException;\n \n     /**\n      * Method similar to {@link #writeString(String)}, but that takes\n      * sub-classes should override it with more efficient implementation\n      * if possible.\n      */\n-    public abstract void writeString(SerializableString text)\n-        throws IOException;\n+    public abstract void writeString(SerializableString text) throws IOException;\n \n     /**\n      * Method similar to {@link #writeString(String)} but that takes as\n--- a/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java\n             | Feature.ESCAPE_NON_ASCII.getMask()\n             | Feature.STRICT_DUPLICATE_DETECTION.getMask()\n             ;\n+\n+    // // // Constants for validation messages (since 2.6)\n+\n+    protected final String WRITE_BINARY = \"write a binary value\";\n+    protected final String WRITE_BOOLEAN = \"write a boolean value\";\n+    protected final String WRITE_NULL = \"write a null\";\n+    protected final String WRITE_NUMBER = \"write a number\";\n+    protected final String WRITE_RAW = \"write a raw (unencoded) value\";\n+    protected final String WRITE_STRING = \"write a string\";\n \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/core/json/JsonGeneratorImpl.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonGeneratorImpl.java\n     // // Overrides just to make things final, to possibly help with inlining\n     \n     @Override\n-    public final void writeStringField(String fieldName, String value)\n-        throws IOException, JsonGenerationException\n+    public final void writeStringField(String fieldName, String value) throws IOException\n     {\n         writeFieldName(fieldName);\n         writeString(value);\n--- a/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java\n     public int writeValue() {\n         // Most likely, object:\n         if (_type == TYPE_OBJECT) {\n+            if (!_gotName) {\n+                return STATUS_EXPECT_NAME;\n+            }\n             _gotName = false;\n             ++_index;\n             return STATUS_OK_AFTER_COLON;\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n     private final static byte BYTE_u = (byte) 'u';\n \n     private final static byte BYTE_0 = (byte) '0';\n-    \n+\n     private final static byte BYTE_LBRACKET = (byte) '[';\n     private final static byte BYTE_RBRACKET = (byte) ']';\n     private final static byte BYTE_LCURLY = (byte) '{';\n     private final static byte BYTE_RCURLY = (byte) '}';\n- \n+\n     private final static byte BYTE_BACKSLASH = (byte) '\\\\';\n     private final static byte BYTE_COMMA = (byte) ',';\n     private final static byte BYTE_COLON = (byte) ':';\n \n     // intermediate copies only made up to certain length...\n     private final static int MAX_BYTES_TO_BUFFER = 512;\n-    \n+\n     final static byte[] HEX_CHARS = CharTypes.copyHexBytes();\n \n     private final static byte[] NULL_BYTES = { 'n', 'u', 'l', 'l' };\n     /* Output buffering\n     /**********************************************************\n      */\n-    \n+\n     /**\n      * Underlying output stream used for writing JSON content.\n      */\n      * in the output buffer after escaping\n      */\n     protected final int _outputMaxContiguous;\n-    \n+\n     /**\n      * Intermediate buffer in which characters of a String are copied\n      * before being encoded.\n      */\n     protected char[] _charBuffer;\n-    \n+\n     /**\n      * Length of <code>_charBuffer</code>\n      */\n     protected final int _charBufferLength;\n-    \n+\n     /**\n      * 6 character temporary buffer allocated if needed, for constructing\n      * escape sequences\n     @Override\n     public void writeString(String text) throws IOException\n     {\n-        _verifyValueWrite(\"write text value\");\n+        _verifyValueWrite(WRITE_STRING);\n         if (text == null) {\n             _writeNull();\n             return;\n     @Override\n     public void writeString(char[] text, int offset, int len) throws IOException\n     {\n-        _verifyValueWrite(\"write text value\");\n+        _verifyValueWrite(WRITE_STRING);\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n         }\n     @Override\n     public final void writeString(SerializableString text) throws IOException\n     {\n-        _verifyValueWrite(\"write text value\");\n+        _verifyValueWrite(WRITE_STRING);\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n         }\n         }\n         _outputBuffer[_outputTail++] = BYTE_QUOTE;\n     }\n-\n+    \n     @Override\n     public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException\n     {\n-        _verifyValueWrite(\"write text value\");\n+        _verifyValueWrite(WRITE_STRING);\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n         }\n     @Override\n     public void writeUTF8String(byte[] text, int offset, int len) throws IOException\n     {\n-        _verifyValueWrite(\"write text value\");\n+        _verifyValueWrite(WRITE_STRING);\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n         }\n     // since 2.5\n     @Override\n     public void writeRawValue(SerializableString text) throws IOException {\n-        _verifyValueWrite(\"write raw value\");\n+        _verifyValueWrite(WRITE_RAW);\n         byte[] raw = text.asUnquotedUTF8();\n         if (raw.length > 0) {\n             _writeBytes(raw);\n             byte[] data, int offset, int len)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write binary value\");\n+        _verifyValueWrite(WRITE_BINARY);\n         // Starting quotes\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n             InputStream data, int dataLength)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write binary value\");\n+        _verifyValueWrite(WRITE_BINARY);\n         // Starting quotes\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n     public void writeNumber(short s)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         // up to 5 digits and possible minus sign\n         if ((_outputTail + 6) >= _outputEnd) {\n             _flushBuffer();\n     public void writeNumber(int i)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         // up to 10 digits and possible minus sign\n         if ((_outputTail + 11) >= _outputEnd) {\n             _flushBuffer();\n     public void writeNumber(long l)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (_cfgNumbersAsStrings) {\n             _writeQuotedLong(l);\n             return;\n     public void writeNumber(BigInteger value)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (value == null) {\n             _writeNull();\n         } else if (_cfgNumbersAsStrings) {\n             return;\n         }\n         // What is the max length for doubles? 40 chars?\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         writeRaw(String.valueOf(d));\n     }\n \n             return;\n         }\n         // What is the max length for floats?\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         writeRaw(String.valueOf(f));\n     }\n \n         throws IOException, JsonGenerationException\n     {\n         // Don't really know max length for big decimal, no point checking\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (value == null) {\n             _writeNull();\n         } else if (_cfgNumbersAsStrings) {\n     public void writeNumber(String encodedValue)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (_cfgNumbersAsStrings) {\n             _writeQuotedRaw(encodedValue);            \n         } else {\n     public void writeBoolean(boolean state)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write boolean value\");\n+        _verifyValueWrite(WRITE_BOOLEAN);\n         if ((_outputTail + 5) >= _outputEnd) {\n             _flushBuffer();\n         }\n     public void writeNull()\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write null value\");\n+        _verifyValueWrite(WRITE_NULL);\n         _writeNull();\n     }\n \n      */\n \n     @Override\n-    protected final void _verifyValueWrite(String typeMsg)\n-        throws IOException, JsonGenerationException\n+    protected final void _verifyValueWrite(String typeMsg) throws IOException\n     {\n         int status = _writeContext.writeValue();\n         if (status == JsonWriteContext.STATUS_EXPECT_NAME) {\n         _verifyPrettyValueWrite(typeMsg, status);\n     }\n \n-    protected final void _verifyPrettyValueWrite(String typeMsg, int status)\n-        throws IOException, JsonGenerationException\n+    protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException\n     {\n         // If we have a pretty printer, it knows what to do:\n         switch (status) {\n      */\n \n     @Override\n-    public void flush()\n-        throws IOException\n+    public void flush() throws IOException\n     {\n         _flushBuffer();\n         if (_outputStream != null) {\n     }\n \n     @Override\n-    public void close()\n-        throws IOException\n+    public void close() throws IOException\n     {\n         super.close();\n \n--- a/src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java\n     @Override\n     public void writeString(String text) throws IOException\n     {\n-        _verifyValueWrite(\"write text value\");\n+        _verifyValueWrite(WRITE_STRING);\n         if (text == null) {\n             _writeNull();\n             return;\n     @Override\n     public void writeString(char[] text, int offset, int len) throws IOException\n     {\n-        _verifyValueWrite(\"write text value\");\n+        _verifyValueWrite(WRITE_STRING);\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n         }\n     @Override\n     public void writeString(SerializableString sstr) throws IOException\n     {\n-        _verifyValueWrite(\"write text value\");\n+        _verifyValueWrite(WRITE_STRING);\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n         }\n     public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write binary value\");\n+        _verifyValueWrite(WRITE_BINARY);\n         // Starting quotes\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n             InputStream data, int dataLength)\n         throws IOException, JsonGenerationException\n     {\n-        _verifyValueWrite(\"write binary value\");\n+        _verifyValueWrite(WRITE_BINARY);\n         // Starting quotes\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n     @Override\n     public void writeNumber(short s) throws IOException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (_cfgNumbersAsStrings) {\n             _writeQuotedShort(s);\n             return;\n     @Override\n     public void writeNumber(int i) throws IOException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (_cfgNumbersAsStrings) {\n             _writeQuotedInt(i);\n             return;\n     @Override\n     public void writeNumber(long l) throws IOException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (_cfgNumbersAsStrings) {\n             _writeQuotedLong(l);\n             return;\n     @Override\n     public void writeNumber(BigInteger value) throws IOException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (value == null) {\n             _writeNull();\n         } else if (_cfgNumbersAsStrings) {\n             return;\n         }\n         // What is the max length for doubles? 40 chars?\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         writeRaw(String.valueOf(d));\n     }\n \n             return;\n         }\n         // What is the max length for floats?\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         writeRaw(String.valueOf(f));\n     }\n \n     public void writeNumber(BigDecimal value) throws IOException\n     {\n         // Don't really know max length for big decimal, no point checking\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (value == null) {\n             _writeNull();\n         } else if (_cfgNumbersAsStrings) {\n     @Override\n     public void writeNumber(String encodedValue) throws IOException\n     {\n-        _verifyValueWrite(\"write number\");\n+        _verifyValueWrite(WRITE_NUMBER);\n         if (_cfgNumbersAsStrings) {\n             _writeQuotedRaw(encodedValue);            \n         } else {\n     @Override\n     public void writeBoolean(boolean state) throws IOException\n     {\n-        _verifyValueWrite(\"write boolean value\");\n+        _verifyValueWrite(WRITE_BOOLEAN);\n         if ((_outputTail + 5) >= _outputEnd) {\n             _flushBuffer();\n         }\n \n     @Override\n     public void writeNull() throws IOException {\n-        _verifyValueWrite(\"write null value\");\n+        _verifyValueWrite(WRITE_NULL);\n         _writeNull();\n     }\n \n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/GeneratorFailTest.java\n+package com.fasterxml.jackson.core.json;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.OutputStreamWriter;\n+\n+import com.fasterxml.jackson.core.JsonEncoding;\n+import com.fasterxml.jackson.core.JsonFactory;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+\n+public class GeneratorFailTest\n+    extends com.fasterxml.jackson.core.BaseTest\n+{\n+    private final JsonFactory F = new JsonFactory();\n+\n+    // [core#167]: no error for writing field name twice\n+    public void testDupFieldNameWrites() throws Exception\n+    {\n+        _testDupFieldNameWrites(F, false);\n+        _testDupFieldNameWrites(F, true);        \n+    }\n+\n+    // [core#177]\n+    // Also: should not try writing JSON String if field name expected\n+    // (in future maybe take one as alias... but not yet)\n+    public void testFailOnWritingStringNotFieldNameBytes() throws Exception {\n+        _testFailOnWritingStringNotFieldName(F, false);\n+    }\n+\n+    // [core#177]\n+    public void testFailOnWritingStringNotFieldNameChars() throws Exception {\n+        _testFailOnWritingStringNotFieldName(F, true);        \n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+\n+    private void _testDupFieldNameWrites(JsonFactory f, boolean useReader) throws Exception\n+    {\n+        JsonGenerator gen;\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        if (useReader) {\n+            gen = f.createGenerator(new OutputStreamWriter(bout, \"UTF-8\"));\n+        } else {\n+            gen = f.createGenerator(bout, JsonEncoding.UTF8);\n+        }\n+        gen.writeStartObject();\n+        gen.writeFieldName(\"a\");\n+        \n+        try {\n+            gen.writeFieldName(\"b\");\n+            gen.flush();\n+            String json = bout.toString(\"UTF-8\");\n+            fail(\"Should not have let two consecutive field name writes succeed: output = \"+json);\n+        } catch (JsonProcessingException e) {\n+            verifyException(e, \"can not write a field name, expecting a value\");\n+        }\n+        gen.close();\n+    }\n+\n+    private void _testFailOnWritingStringNotFieldName(JsonFactory f, boolean useReader) throws Exception\n+    {\n+        JsonGenerator gen;\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        if (useReader) {\n+            gen = f.createGenerator(new OutputStreamWriter(bout, \"UTF-8\"));\n+        } else {\n+            gen = f.createGenerator(bout, JsonEncoding.UTF8);\n+        }\n+        gen.writeStartObject();\n+        \n+        try {\n+            gen.writeString(\"a\");\n+            gen.flush();\n+            String json = bout.toString(\"UTF-8\");\n+            fail(\"Should not have let \"+gen.getClass().getName()+\".writeString() be used in place of 'writeFieldName()': output = \"+json);\n+        } catch (JsonProcessingException e) {\n+            verifyException(e, \"can not write a String\");\n+        }\n+        gen.close();\n+    }\n+\n+\n+}\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestJsonGenerator.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestJsonGenerator.java\n         gen.close();\n     }\n \n-    // [core#167]: no error for writing field name twice\n-    public void testDupFieldNameWrites() throws Exception\n-    {\n-        JsonFactory f = new JsonFactory();\n-        _testDupFieldNameWrites(f, false);\n-        _testDupFieldNameWrites(f, true);        \n-    }\n-\n-    // [core#177]\n-    // Also: should not try writing JSON String if field name expected\n-    // (in future maybe take one as alias... but not yet)\n-    /*\n-    public void testFailOnWritingStringNotFieldName() throws Exception\n-    {\n-        JsonFactory f = new JsonFactory();\n-        _testFailOnWritingStringNotFieldName(f, false);\n-        _testFailOnWritingStringNotFieldName(f, true);        \n-    }\n-    */\n-    \n     /*\n     /**********************************************************\n     /* Internal methods\n     /**********************************************************\n      */\n-\n-    private void _testDupFieldNameWrites(JsonFactory f, boolean useReader) throws Exception\n-    {\n-        JsonGenerator gen;\n-        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n-        if (useReader) {\n-            gen = f.createGenerator(new OutputStreamWriter(bout, \"UTF-8\"));\n-        } else {\n-            gen = f.createGenerator(bout, JsonEncoding.UTF8);\n-        }\n-        gen.writeStartObject();\n-        gen.writeFieldName(\"a\");\n-        \n-        try {\n-            gen.writeFieldName(\"b\");\n-            gen.flush();\n-            String json = bout.toString(\"UTF-8\");\n-            fail(\"Should not have let two consecutive field name writes succeed: output = \"+json);\n-        } catch (JsonProcessingException e) {\n-            verifyException(e, \"can not write a field name, expecting a value\");\n-        }\n-        gen.close();\n-    }\n-\n-    private void _testFailOnWritingStringNotFieldName(JsonFactory f, boolean useReader) throws Exception\n-    {\n-        JsonGenerator gen;\n-        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n-        if (useReader) {\n-            gen = f.createGenerator(new OutputStreamWriter(bout, \"UTF-8\"));\n-        } else {\n-            gen = f.createGenerator(bout, JsonEncoding.UTF8);\n-        }\n-        gen.writeStartObject();\n-        \n-        try {\n-            gen.writeString(\"a\");\n-            gen.flush();\n-            String json = bout.toString(\"UTF-8\");\n-            fail(\"Should not have let 'writeString()' be used in place of 'writeFieldName()': output = \"+json);\n-        } catch (JsonProcessingException e) {\n-            verifyException(e, \"can not write a field name, expecting a value\");\n-        }\n-        gen.close();\n-    }\n \n     private void doTestIntWrite(boolean pad) throws Exception\n     {", "timestamp": 1421367026, "metainfo": ""}