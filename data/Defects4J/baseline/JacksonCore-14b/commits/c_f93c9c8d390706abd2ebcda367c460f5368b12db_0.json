{"sha": "f93c9c8d390706abd2ebcda367c460f5368b12db", "log": "Fix #194", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n             _writeNull();\n             return;\n         }\n-        // First: can we make a local copy of chars that make up text?\n+        // First: if we can't guarantee it all fits, quoted, within output, offline\n         final int len = text.length();\n-        if (len > _charBufferLength) { // nope: off-line handling\n+        if (len > _outputMaxContiguous) { // nope: off-line handling\n             _writeStringSegments(text, true);\n             return;\n         }\n-        // Output: if we can't guarantee it fits in output buffer, off-line as well:\n-        if (len > _outputMaxContiguous) {\n-            _writeLongString(_charBuffer, 0, len);\n-            return;\n-        }\n         if ((_outputTail + len) >= _outputEnd) {\n             _flushBuffer();\n         }\n         _outputBuffer[_outputTail++] = BYTE_QUOTE;\n         _writeStringSegment(text, 0, len); // we checked space already above\n-        /* [JACKSON-462] But that method may have had to expand multi-byte Unicode\n-         *   chars, so we must check again\n-         */\n-        if (_outputTail >= _outputEnd) {\n-            _flushBuffer();\n-        }\n-        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n-    }\n-\n-    private void _writeLongString(char[] text, int offset, int len) throws IOException\n-    {\n-        if (_outputTail >= _outputEnd) {\n-            _flushBuffer();\n-        }\n-        _outputBuffer[_outputTail++] = BYTE_QUOTE;\n-        _writeStringSegments(text, 0, len);\n         if (_outputTail >= _outputEnd) {\n             _flushBuffer();\n         }\n \n         int left = text.length();\n         int offset = 0;\n-        final char[] cbuf = _charBuffer;\n \n         while (left > 0) {\n             int len = Math.min(_outputMaxContiguous, left);\n-            text.getChars(offset, offset+len, cbuf, 0);\n             if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                 _flushBuffer();\n             }\n-            _writeStringSegment(cbuf, 0, len);\n+            _writeStringSegment(text, offset, len);\n             offset += len;\n             left -= len;\n         }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/StringGenerationTest.java\n+package com.fasterxml.jackson.core.json;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+import java.util.Random;\n+\n+/**\n+ * Set of basic unit tests for verifying that the string\n+ * generation, including character escaping, works as expected.\n+ */\n+public class StringGenerationTest\n+    extends BaseTest\n+{\n+    final static String[] SAMPLES = new String[] {\n+        \"\\\"test\\\"\",\n+        \"\\n\", \"\\\\n\", \"\\r\\n\", \"a\\\\b\", \"tab:\\nok?\",\n+        \"a\\tb\\tc\\n\\fdef\\t \\tg\\\"\\\"\\\"h\\\"\\\\ijklmn\\b\",\n+        \"\\\"\\\"\\\"\", \"\\\\r)'\\\"\",\n+        \"Longer text & other stuff:\\twith some\\r\\n\\r\\n random linefeeds etc added in to cause some \\\"special\\\" handling \\\\\\\\ to occur...\\n\"\n+    };\n+ \n+    private final JsonFactory FACTORY = new JsonFactory();\n+    \n+    public void testBasicEscaping() throws Exception\n+    {\n+        doTestBasicEscaping(false);\n+        doTestBasicEscaping(true);\n+    }\n+\n+    // for [core#194]\n+    public void testMediumStringsBytes() throws Exception\n+    {\n+        _testMediumStrings(true, 1100);\n+        _testMediumStrings(true, 2300);\n+        _testMediumStrings(true, 3800);\n+        _testMediumStrings(true, 7500);\n+        _testMediumStrings(true, 19000);\n+    }\n+\n+    // for [core#194]\n+    public void testMediumStringsChars() throws Exception\n+    {\n+        _testMediumStrings(false, 1100);\n+        _testMediumStrings(false, 2300);\n+        _testMediumStrings(false, 3800);\n+        _testMediumStrings(false, 7500);\n+        _testMediumStrings(false, 19000);\n+    }\n+\n+    public void testLongerRandomSingleChunk() throws Exception\n+    {\n+        /* Let's first generate 100k of pseudo-random characters, favoring\n+         * 7-bit ascii range\n+         */\n+        for (int round = 0; round < 80; ++round) {\n+            String content = generateRandom(75000+round);\n+            doTestLongerRandom(content, false);\n+            doTestLongerRandom(content, true);\n+        }\n+    }\n+\n+    public void testLongerRandomMultiChunk() throws Exception\n+    {\n+        /* Let's first generate 100k of pseudo-random characters, favoring\n+         * 7-bit ascii range\n+         */\n+        for (int round = 0; round < 70; ++round) {\n+            String content = generateRandom(73000+round);\n+            doTestLongerRandomMulti(content, false, round);\n+            doTestLongerRandomMulti(content, true, round);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+\n+    private String _generareMediumText(int minLen)\n+    {\n+        StringBuilder sb = new StringBuilder(minLen + 1000);\n+        Random rnd = new Random(minLen);\n+        do {\n+            switch (rnd.nextInt() % 4) {\n+            case 0:\n+                sb.append(\" foo\");\n+                break;\n+            case 1:\n+                sb.append(\" bar\");\n+                break;\n+            case 2:\n+                sb.append(String.valueOf(sb.length()));\n+                break;\n+            default:\n+                sb.append(\" \\\"stuff\\\"\");\n+                break;\n+            }\n+        } while (sb.length() < minLen);\n+        return sb.toString();\n+    }\n+    \n+    private String generateRandom(int len)\n+    {\n+        StringBuilder sb = new StringBuilder(len+1000); // pad for surrogates\n+        Random r = new Random(len);\n+        for (int i = 0; i < len; ++i) {\n+            if (r.nextBoolean()) { // non-ascii\n+                int value = r.nextInt() & 0xFFFF;\n+                // Otherwise easy, except that need to ensure that\n+                // surrogates are properly paired: and, also\n+                // their values do not exceed 0x10FFFF\n+                if (value >= 0xD800 && value <= 0xDFFF) {\n+                    // Let's discard first value, then, and produce valid pair\n+                    int fullValue = (r.nextInt() & 0xFFFFF);\n+                    sb.append((char) (0xD800 + (fullValue >> 10)));\n+                    value = 0xDC00 + (fullValue & 0x3FF);\n+                }\n+                sb.append((char) value);\n+            } else { // ascii\n+                sb.append((char) (r.nextInt() & 0x7F));\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+    private void _testMediumStrings(boolean useBinary, int length) throws Exception\n+    {\n+        String text = _generareMediumText(length);\n+        StringWriter sw = new StringWriter();\n+        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n+\n+        JsonGenerator gen = useBinary ? FACTORY.createGenerator(bytes)\n+                : FACTORY.createGenerator(sw);\n+        gen.writeStartArray();\n+        gen.writeString(text);\n+        gen.writeEndArray();\n+        gen.close();\n+\n+        String json;\n+        if (useBinary) {\n+            json = bytes.toString(\"UTF-8\");\n+        } else {\n+            json = sw.toString();\n+        }\n+\n+        JsonParser p = FACTORY.createParser(json);\n+        assertToken(JsonToken.START_ARRAY, p.nextToken());\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertEquals(text, p.getText());\n+        assertToken(JsonToken.END_ARRAY, p.nextToken());\n+        p.close();\n+    }\n+    \n+    private void doTestBasicEscaping(boolean charArray)\n+        throws Exception\n+    {\n+        for (int i = 0; i < SAMPLES.length; ++i) {\n+            String VALUE = SAMPLES[i];\n+            StringWriter sw = new StringWriter();\n+            JsonGenerator gen = FACTORY.createGenerator(sw);\n+            gen.writeStartArray();\n+            if (charArray) {\n+                char[] buf = new char[VALUE.length() + i];\n+                VALUE.getChars(0, VALUE.length(), buf, i);\n+                gen.writeString(buf, i, VALUE.length());\n+            } else {\n+                gen.writeString(VALUE);\n+            }\n+            gen.writeEndArray();\n+            gen.close();\n+            String docStr = sw.toString();\n+            JsonParser jp = createParserUsingReader(docStr);\n+            assertEquals(JsonToken.START_ARRAY, jp.nextToken());\n+            JsonToken t = jp.nextToken();\n+            assertEquals(JsonToken.VALUE_STRING, t);\n+            assertEquals(VALUE, jp.getText());\n+            assertEquals(JsonToken.END_ARRAY, jp.nextToken());\n+            assertEquals(null, jp.nextToken());\n+            jp.close();\n+        }\n+    }\n+\n+    private void doTestLongerRandom(String text, boolean charArray)\n+        throws Exception\n+    {\n+        ByteArrayOutputStream bow = new ByteArrayOutputStream(text.length());\n+        JsonGenerator gen = FACTORY.createGenerator(bow, JsonEncoding.UTF8);\n+\n+        gen.writeStartArray();\n+        if (charArray) {\n+            char[] buf = new char[text.length()];\n+            text.getChars(0, text.length(), buf, 0);\n+            gen.writeString(buf, 0, text.length());\n+        } else {\n+            gen.writeString(text);\n+        }\n+        gen.writeEndArray();\n+        gen.close();\n+        byte[] docData = bow.toByteArray();\n+        JsonParser jp = FACTORY.createParser(new ByteArrayInputStream(docData));\n+        assertEquals(JsonToken.START_ARRAY, jp.nextToken());\n+        JsonToken t = jp.nextToken();\n+        assertEquals(JsonToken.VALUE_STRING, t);\n+        String act = jp.getText();\n+        if (!text.equals(act)) {\n+            if (text.length() != act.length()) {\n+                fail(\"Expected string length \"+text.length()+\", actual \"+act.length());\n+            }\n+            int i = 0;\n+            for (int len = text.length(); i < len; ++i) {\n+                if (text.charAt(i) != act.charAt(i)) {\n+                    break;\n+                }\n+            }\n+            fail(\"Strings differ at position #\"+i+\" (len \"+text.length()+\"): expected char 0x\"+Integer.toHexString(text.charAt(i))+\", actual 0x\"+Integer.toHexString(act.charAt(i)));\n+        }\n+        assertEquals(JsonToken.END_ARRAY, jp.nextToken());\n+        assertEquals(null, jp.nextToken());\n+        jp.close();\n+    }\n+\n+    private void doTestLongerRandomMulti(String text, boolean charArray, int round)\n+        throws Exception\n+    {\n+        ByteArrayOutputStream bow = new ByteArrayOutputStream(text.length());\n+        JsonGenerator gen = FACTORY.createGenerator(bow, JsonEncoding.UTF8);\n+        gen.writeStartArray();\n+\n+        gen.writeString(text);\n+        gen.writeEndArray();\n+        gen.close();\n+        \n+        gen = FACTORY.createGenerator(bow, JsonEncoding.UTF8);\n+        gen.writeStartArray();\n+        gen.writeStartArray();\n+\n+        Random rnd = new Random(text.length());\n+        int offset = 0;\n+\n+        while (offset < text.length()) {\n+            int shift = 1 + ((rnd.nextInt() & 0xFFFFF) % 12); // 1 - 12\n+            int len = (1 << shift) + shift; // up to 4k\n+            if ((offset + len) >= text.length()) {\n+                len = text.length() - offset;\n+            } else {\n+            \t// Need to avoid splitting surrogates though\n+            \tchar c = text.charAt(offset+len-1);\n+            \tif (c >= 0xD800 && c < 0xDC00) {\n+            \t\t++len;\n+            \t}\n+            }\n+            if (charArray) {\n+                char[] buf = new char[len];\n+                text.getChars(offset, offset+len, buf, 0);\n+                gen.writeString(buf, 0, len);\n+            } else {\n+                gen.writeString(text.substring(offset, offset+len));\n+            }\n+            offset += len;\n+        }\n+\n+        gen.writeEndArray();\n+        gen.close();\n+        byte[] docData = bow.toByteArray();\n+        JsonParser jp = FACTORY.createParser(new ByteArrayInputStream(docData));\n+        assertEquals(JsonToken.START_ARRAY, jp.nextToken());\n+\n+        offset = 0;\n+        while (jp.nextToken() == JsonToken.VALUE_STRING) {\n+            // Let's verify, piece by piece\n+            String act = jp.getText();\n+            String exp = text.substring(offset, offset+act.length());\n+            if (act.length() != exp.length()) {\n+                fail(\"String segment [\"+offset+\" - \"+(offset+act.length())+\"[ differs; exp length \"+exp+\", actual \"+act);                \n+            }\n+            if (!act.equals(exp)) {\n+                int i = 0;\n+                while (act.charAt(i) == exp.charAt(i)) {\n+                    ++i;\n+                }\n+                fail(\"String segment [\"+offset+\" - \"+(offset+act.length())+\"[ different at offset #\"+i\n+                        +\"; exp char 0x\"+Integer.toHexString(exp.charAt(i))\n+                        +\", actual 0x\"+Integer.toHexString(act.charAt(i)));\n+            }\n+            offset += act.length();\n+        }\n+        assertEquals(JsonToken.END_ARRAY, jp.getCurrentToken());\n+        jp.close();\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestJsonGenerator.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestJsonGenerator.java\n public class TestJsonGenerator\n     extends com.fasterxml.jackson.core.BaseTest\n {\n+    private final JsonFactory JSON_F = new JsonFactory();\n+\n     // // // First, tests for primitive (non-structured) values\n \n     public void testStringWrite() throws Exception\n     {\n-        JsonFactory jf = new JsonFactory();\n         String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" };\n         for (int useReader = 0; useReader < 2; ++useReader) {\n             for (int writeString = 0; writeString < 2; ++writeString) {\n                     JsonGenerator gen;\n                     ByteArrayOutputStream bout = new ByteArrayOutputStream();\n                     if (useReader != 0) {\n-                        gen = jf.createGenerator(new OutputStreamWriter(bout, \"UTF-8\"));\n+                        gen = JSON_F.createGenerator(new OutputStreamWriter(bout, \"UTF-8\"));\n                     } else {\n-                        gen = jf.createGenerator(bout, JsonEncoding.UTF8);\n+                        gen = JSON_F.createGenerator(bout, JsonEncoding.UTF8);\n                     }\n                     if (writeString > 0) {\n                         gen.writeString(input);\n                     }\n                     gen.flush();\n                     gen.close();\n-                    JsonParser jp = jf.createParser(new ByteArrayInputStream(bout.toByteArray()));\n+                    JsonParser jp = JSON_F.createParser(new ByteArrayInputStream(bout.toByteArray()));\n                 \n                     JsonToken t = jp.nextToken();\n                     assertNotNull(\"Document \\\"\"+bout.toString(\"UTF-8\")+\"\\\" yielded no tokens\", t);\n         }\n     }\n \n-    public void testIntWrite() throws Exception\n-    {\n-        doTestIntWrite(false);\n-        doTestIntWrite(true);\n-    }\n-\n-    public void testLongWrite() throws Exception\n-    {\n-        doTestLongWrite(false);\n-        doTestLongWrite(true);\n+    public void testIntValueWrite() throws Exception\n+    {\n+        doTestIntValueWrite(false);\n+        doTestIntValueWrite(true);\n+    }\n+\n+    public void testLongValueWrite() throws Exception\n+    {\n+        doTestLongValueWrite(false);\n+        doTestLongValueWrite(true);\n     }\n \n     public void testBooleanWrite() throws Exception\n             boolean state = (i & 1) == 0;\n             boolean pad = (i & 2) == 0;\n             StringWriter sw = new StringWriter();\n-            JsonGenerator gen = new JsonFactory().createGenerator(sw);\n+            JsonGenerator gen = JSON_F.createGenerator(sw);\n             gen.writeBoolean(state);\n             if (pad) {\n                 gen.writeRaw(\" \");\n         for (int i = 0; i < 2; ++i) {\n             boolean pad = (i & 1) == 0;\n             StringWriter sw = new StringWriter();\n-            JsonGenerator gen = new JsonFactory().createGenerator(sw);\n+            JsonGenerator gen = JSON_F.createGenerator(sw);\n             gen.writeNull();\n             if (pad) {\n                 gen.writeRaw(\" \");\n          throws Exception\n      {\n          StringWriter sw = new StringWriter();\n-         JsonGenerator gen = new JsonFactory().createGenerator(sw);\n+         JsonGenerator gen = JSON_F.createGenerator(sw);\n          gen.writeNumber(1);\n          gen.writeNumber(2);\n          gen.writeNumber(-13);\n          throws Exception\n      {\n          StringWriter sw = new StringWriter();\n-         JsonGenerator gen = new JsonFactory().createGenerator(sw);\n+         JsonGenerator gen = JSON_F.createGenerator(sw);\n          gen.writeStartObject();\n          gen.writeNumberField(\"long\", 3L);\n          gen.writeNumberField(\"double\", 0.25);\n     public void testOutputContext() throws Exception\n     {\n         StringWriter sw = new StringWriter();\n-        JsonGenerator gen = new JsonFactory().createGenerator(sw);\n+        JsonGenerator gen = JSON_F.createGenerator(sw);\n         JsonStreamContext ctxt = gen.getOutputContext();\n         assertTrue(ctxt.inRoot());\n \n     /**********************************************************\n      */\n \n-    private void doTestIntWrite(boolean pad) throws Exception\n+    private void doTestIntValueWrite(boolean pad) throws Exception\n     {\n         int[] VALUES = new int[] {\n             0, 1, -9, 32, -32, 57, 189, 2017, -9999, 13240, 123456,\n         for (int i = 0; i < VALUES.length; ++i) {\n             int VALUE = VALUES[i];\n             StringWriter sw = new StringWriter();\n-            JsonGenerator gen = new JsonFactory().createGenerator(sw);\n+            JsonGenerator gen = JSON_F.createGenerator(sw);\n             gen.writeNumber(VALUE);\n             if (pad) {\n                 gen.writeRaw(\" \");\n         }\n     }\n \n-    private void doTestLongWrite(boolean pad)\n-        throws Exception\n+    private void doTestLongValueWrite(boolean pad) throws Exception\n     {\n         long[] VALUES = new long[] {\n             0L, 1L, -1L, -12005002294L, Long.MIN_VALUE, Long.MAX_VALUE\n         for (int i = 0; i < VALUES.length; ++i) {\n             long VALUE = VALUES[i];\n             StringWriter sw = new StringWriter();\n-            JsonGenerator gen = new JsonFactory().createGenerator(sw);\n+            JsonGenerator gen = JSON_F.createGenerator(sw);\n             gen.writeNumber(VALUE);\n             if (pad) {\n                 gen.writeRaw(\" \");\n         }\n     }\n }\n+", "timestamp": 1432609241, "metainfo": ""}