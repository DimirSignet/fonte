{"sha": "41bd0ebb84272e349fbbfeec2cb757bbfd0b8ba7", "log": "...", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/Base64Variant.java\n+++ b/src/main/java/com/fasterxml/jackson/core/Base64Variant.java\n  * @author Tatu Saloranta\n  */\n public final class Base64Variant\n+    implements java.io.Serializable\n {\n+    // We'll only serialize name\n+    private static final long serialVersionUID = 1L;\n+\n     /**\n      * Placeholder used by \"no padding\" variant, to be used when a character\n      * value is needed.\n     /**\n      * Decoding table used for base 64 decoding.\n      */\n-    private final int[] _asciiToBase64 = new int[128];\n+    private final transient int[] _asciiToBase64 = new int[128];\n \n     /**\n      * Encoding table used for base 64 decoding when output is done\n      * as characters.\n      */\n-    private final char[] _base64ToAsciiC = new char[64];\n+    private final transient char[] _base64ToAsciiC = new char[64];\n \n     /**\n      * Alternative encoding table used for base 64 decoding when output is done\n      * as ascii bytes.\n      */\n-    private final byte[] _base64ToAsciiB = new byte[64];\n+    private final transient byte[] _base64ToAsciiB = new byte[64];\n \n     /*\n     /**********************************************************\n \n     /**\n      * Symbolic name of variant; used for diagnostics/debugging.\n-     */\n-    final String _name;\n+     *<p>\n+     * Note that this is the only non-transient field; used when reading\n+     * back from serialized state\n+     */\n+    protected final String _name;\n \n     /**\n      * Whether this variant uses padding or not.\n      */\n-    final boolean _usesPadding;\n+    protected final transient boolean _usesPadding;\n \n     /**\n      * Characted used for padding, if any ({@link #PADDING_CHAR_NONE} if not).\n      */\n-    final char _paddingChar;\n+    protected final transient char _paddingChar;\n     \n     /**\n      * Maximum number of encoded base64 characters to output during encoding\n      * Note: for some output modes (when writing attributes) linefeeds may\n      * need to be avoided, and this value ignored.\n      */\n-    final int _maxLineLength;\n+    protected final transient int _maxLineLength;\n \n     /*\n     /**********************************************************\n         _maxLineLength = maxLineLength;\n     }\n \n+    /*\n+    /**********************************************************\n+    /* Serializable overrides\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method used to \"demote\" deserialized instances back to \n+     * canonical ones\n+     */\n+    protected Object readResolve() {\n+        return Base64Variants.valueOf(_name);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Public accessors\n--- a/src/main/java/com/fasterxml/jackson/core/Base64Variants.java\n+++ b/src/main/java/com/fasterxml/jackson/core/Base64Variants.java\n package com.fasterxml.jackson.core;\n \n /**\n- * Container for commonly used Base64 variants.\n+ * Container for commonly used Base64 variants:\n+ *<ul>\n+ * <li> {@link #MIME}\n+ * <li> {@link #MIME_NO_LINEFEEDS}\n+ * <li> {@link #PEM}\n+ * <li> {@link #MODIFIED_FOR_URL}\n+ * </ul>\n  * \n  * @author Tatu Saloranta\n  */\n     public static Base64Variant getDefaultVariant() {\n         return MIME_NO_LINEFEEDS;\n     }\n+\n+    /**\n+     * @since 2.1\n+     */\n+    public static Base64Variant valueOf(String name) throws IllegalArgumentException\n+    {\n+        if (MIME._name.equals(name)) {\n+            return MIME;\n+        }\n+        if (MIME_NO_LINEFEEDS._name.equals(name)) {\n+            return MIME_NO_LINEFEEDS;\n+        }\n+        if (PEM._name.equals(name)) {\n+            return PEM;\n+        }\n+        if (MODIFIED_FOR_URL._name.equals(name)) {\n+            return MODIFIED_FOR_URL;\n+        }\n+        if (name == null) {\n+            name = \"<null>\";\n+        } else {\n+            name = \"'\"+name+\"'\";\n+        }\n+        throw new IllegalArgumentException(\"No Base64Variant with name \"+name);\n+    }\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/TestJDKSerializability.java\n+package com.fasterxml.jackson.core;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.test.BaseTest;\n+\n+/**\n+ * Unit tests for [Issue#31] (https://github.com/FasterXML/jackson-core/issues/31)\n+ */\n+public class TestJDKSerializability extends BaseTest\n+{\n+    public void testJsonFactorySerializable() throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+        String origJson = \"{\\\"simple\\\":[1,true,{}]}\";\n+        assertEquals(origJson, _copyJson(f, origJson, false));\n+\n+        // Ok: freeze dry factory, thaw, and try to use again:\n+        byte[] frozen = jdkSerialize(f);\n+        JsonFactory f2 = jdkDeserialize(frozen);\n+        assertNotNull(f2);\n+        assertEquals(origJson, _copyJson(f2, origJson, false));\n+\n+        // Let's also try byte-based variant, for fun...\n+        assertEquals(origJson, _copyJson(f2, origJson, true));\n+    }\n+\n+    public void testBase64Variant() throws Exception\n+    {\n+        Base64Variant orig = Base64Variants.PEM;\n+        byte[] stuff = jdkSerialize(orig);\n+        Base64Variant back = jdkDeserialize(stuff);\n+        assertSame(orig, back);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+    \n+    protected byte[] jdkSerialize(Object o) throws IOException\n+    {\n+        ByteArrayOutputStream bytes = new ByteArrayOutputStream(1000);\n+        ObjectOutputStream obOut = new ObjectOutputStream(bytes);\n+        obOut.writeObject(o);\n+        obOut.close();\n+        return bytes.toByteArray();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected <T> T jdkDeserialize(byte[] raw) throws IOException\n+    {\n+        ObjectInputStream objIn = new ObjectInputStream(new ByteArrayInputStream(raw));\n+        try {\n+            return (T) objIn.readObject();\n+        } catch (ClassNotFoundException e) {\n+            fail(\"Missing class: \"+e.getMessage());\n+            return null;\n+        } finally {\n+            objIn.close();\n+        }\n+    }\n+    \n+    protected String _copyJson(JsonFactory f, String json, boolean useBytes) throws IOException\n+    {\n+        if (useBytes) {\n+            ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n+            JsonGenerator jg = f.createGenerator(bytes);\n+            _copyJson(f, json, jg);\n+            return bytes.toString(\"UTF-8\");\n+        }\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator jg = f.createGenerator(sw);\n+        _copyJson(f, json, jg);\n+        return sw.toString();\n+    }\n+        \n+    protected void _copyJson(JsonFactory f, String json, JsonGenerator jg) throws IOException\n+    {\n+        JsonParser jp = f.createParser(json);\n+        while (jp.nextToken() != null) {\n+            jg.copyCurrentEvent(jp);\n+        }\n+        jp.close();\n+        jg.close();\n+    }\n+}", "timestamp": 1349474465, "metainfo": ""}