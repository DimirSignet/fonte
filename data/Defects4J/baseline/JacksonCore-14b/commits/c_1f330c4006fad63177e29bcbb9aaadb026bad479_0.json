{"sha": "1f330c4006fad63177e29bcbb9aaadb026bad479", "log": "Merge branch 'master' of github.com:FasterXML/jackson-core", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java\n         hash += (q2 * MULT); // then add second quad\n         hash ^= _seed;\n         hash += (hash >>> 7); // and shuffle some more\n-        hash ^= (hash >>> 19);\n+        hash ^= (hash >>> 4);\n         \n         return hash;\n     }\n         hash *= MULT2;\n         hash += (hash >>> 15);\n         hash ^= q3;\n-        hash += (hash >>> 17);\n+        // 26-Mar-2015, tatu: As per two-quad case, a short shift seems to help more here\n+        hash += (hash >>> 4);\n \n         hash += (hash >>> 15);\n         hash ^= (hash << 9);\n         hash *= MULT2;\n         hash += (hash >>> 15);\n         hash ^= q[2];\n-        hash += (hash >>> 17);\n+        hash += (hash >>> 4);\n \n         for (int i = 3; i < qlen; ++i) {\n             hash = (hash * MULT3) ^ q[i];\n             // for longer entries, mess a bit in-between too\n             hash += (hash >>> 3);\n-            hash ^= (hash << 7);\n         }\n         // and finally shuffle some more once done\n-        hash += (hash >>> 15); // to get high-order bits to mix more\n-        hash ^= (hash << 9); // as well as lowest 2 bytes\n+        hash += (hash >>> 4); // to get high-order bits to mix more\n         return hash;\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n      * chains are shared between multiple primary cells, which could cause\n      * problems for lower values.\n      *<p>\n-     * Also note that value was lowered from 255 (2.3 and earlier) to 100 for 2.4\n+     * Also note that value was lowered from 255 (2.3 and earlier) to 100 for 2.4,\n+     * but raised again to 200 for 2.5.2 (as per [core#187])\n      * \n      * @since 2.1\n      */\n-    private final static int MAX_COLL_CHAIN_LENGTH = 100;\n+    private final static int MAX_COLL_CHAIN_LENGTH = 200;\n \n     /**\n      * No point in trying to construct tiny tables, just need to resize soon.\n \n     public int calcHash(int q1, int q2)\n     {\n-        /* For two quads, let's change algorithm a bit, to spice\n-         * things up (can do bit more processing anyway)\n-         */\n+        // For two quads, let's change algorithm a bit, to spice\n+        // things up (can do bit more processing anyway)\n         int hash = q1;\n         hash ^= (hash >>> 15); // try mixing first and second byte pairs first\n         hash += (q2 * MULT); // then add second quad\n         hash ^= _seed;\n         hash += (hash >>> 7); // and shuffle some more\n-        hash ^= (hash >>> 19);\n+        // 26-Mar-2015, tatu: As per [core#187] need bit more shuffling. This may\n+        //   seem like a magical number (and in a way, it is), but it was the sweet\n+        //   spot for some reason (5 and 3 work ok but converges for 4, for tested case)\n+        hash ^= (hash >>> 4);\n         return hash;\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n     {\n         // pass seed, to keep results consistent:\n         CharsToNameCanonicalizer symbols = CharsToNameCanonicalizer.createRoot(1);\n-        final int COUNT = 6000;\n+        final int COUNT = 12000;\n         for (int i = 0; i < COUNT; ++i) {\n             String id = fieldNameFor(i);\n             char[] ch = id.toCharArray();\n             symbols.findSymbol(ch, 0, ch.length, symbols.calcHash(id));\n         }\n \n-        assertEquals(8192, symbols.bucketCount());\n+        assertEquals(16384, symbols.bucketCount());\n         assertEquals(COUNT, symbols.size());\n         \n //System.out.printf(\"Char stuff: collisions %d, max-coll %d\\n\", symbols.collisionCount(), symbols.maxCollisionLength());\n         // holy guacamoley... there are way too many. 31 gives 3567 (!), 33 gives 2747\n         // ... at least before shuffling. Shuffling helps quite a lot, so:\n \n-        assertEquals(1401, symbols.collisionCount()); // with 33\n-//        assertEquals(1858, symbols.collisionCount()); // with 31\n-\n-        // esp. with collisions; first got about 30;\n-        // with fixes 4 (for 33), 5 (for 31)\n-\n-        assertEquals(4, symbols.maxCollisionLength()); // 33\n-//        assertEquals(5, symbols.maxCollisionLength()); // 31\n+        assertEquals(2691, symbols.collisionCount());\n+\n+        assertEquals(3, symbols.maxCollisionLength());\n     }\n \n     // Test for verifying stability of hashCode, wrt collisions, using\n         BytesToNameCanonicalizer symbols =\n                 BytesToNameCanonicalizer.createRoot(SEED).makeChild(JsonFactory.Feature.collectDefaults());\n \n-        final int COUNT = 6000;\n+        final int COUNT = 12000;\n         for (int i = 0; i < COUNT; ++i) {\n             String id = fieldNameFor(i);\n             int[] quads = calcQuads(id.getBytes(\"UTF-8\"));\n             symbols.addName(id, quads, quads.length);\n         }\n         assertEquals(COUNT, symbols.size());\n-        assertEquals(8192, symbols.bucketCount());\n+        assertEquals(16384, symbols.bucketCount());\n \n //System.out.printf(\"Byte stuff: collisions %d, max-coll %d\\n\", symbols.collisionCount(), symbols.maxCollisionLength());\n-    \n-        // Fewer collisions than with chars, but still quite a few\n-        assertEquals(1715, symbols.collisionCount());\n-        // but not super long collision chains:\n-        assertEquals(9, symbols.maxCollisionLength());\n+        assertEquals(3476, symbols.collisionCount());\n+        // longest collision chain not optimal but ok:\n+        assertEquals(15, symbols.maxCollisionLength());\n \n         // But also verify entries are actually found?\n     }\n         ByteQuadsCanonicalizer symbols =\n                 ByteQuadsCanonicalizer.createRoot(SEED).makeChild(JsonFactory.Feature.collectDefaults());\n \n-        final int COUNT = 6000;\n+        final int COUNT = 12000;\n         for (int i = 0; i < COUNT; ++i) {\n             String id = fieldNameFor(i);\n             int[] quads = calcQuads(id.getBytes(\"UTF-8\"));\n             symbols.addName(id, quads, quads.length);\n         }\n         assertEquals(COUNT, symbols.size());\n-        assertEquals(8192, symbols.bucketCount());\n+        assertEquals(16384, symbols.bucketCount());\n \n         // fragile, but essential to verify low collision counts;\n         // anywhere between 70-80% primary matches\n-        assertEquals(4270, symbols.primaryCount());\n+        assertEquals(8566, symbols.primaryCount());\n         // secondary between 10-20%\n-        assertEquals(1234, symbols.secondaryCount());\n+        assertEquals(2440, symbols.secondaryCount());\n         // and most of remaining in tertiary\n-        assertEquals(496, symbols.tertiaryCount());\n+        assertEquals(994, symbols.tertiaryCount());\n         // so that spill-over is empty or close to\n         assertEquals(0, symbols.spilloverCount());\n     }\n-    \n+\n     // [Issue#145]\n     public void testThousandsOfSymbolsWithChars() throws IOException\n     {\n             assertEquals(exp, symbolsCRoot.size());\n         }\n     }\n-    \n+\n     @SuppressWarnings(\"deprecation\")\n     public void testThousandsOfSymbolsWithOldBytes() throws IOException\n     {\n          *   rates are not accidentally increased...\n          */\n         assertEquals(6250, symbolsB.size());\n-        assertEquals(4851, symbolsB.primaryCount()); // 77% primary hit rate\n-        assertEquals(872, symbolsB.secondaryCount()); // 14% secondary\n-        assertEquals(510, symbolsB.tertiaryCount()); // 8% tertiary\n-        assertEquals(17, symbolsB.spilloverCount()); // and couple of leftovers\n+        assertEquals(4992, symbolsB.primaryCount()); // 80% primary hit rate\n+        assertEquals(803, symbolsB.secondaryCount()); // 13% secondary\n+        assertEquals(445, symbolsB.tertiaryCount()); // 7% tertiary\n+        assertEquals(10, symbolsB.spilloverCount()); // and couple of leftovers\n     }\n     \n     // And then one more test just for Bytes-based symbol table\n         }\n         return result;\n     }\n+\n+    // [core#187]: unexpectedly high number of collisions for straight numbers\n+    @SuppressWarnings(\"deprecation\")\n+    public void testCollisionsWithBytes187() throws IOException\n+    {\n+        BytesToNameCanonicalizer symbols =\n+                BytesToNameCanonicalizer.createRoot(1).makeChild(JsonFactory.Feature.collectDefaults());\n+        final int COUNT = 30000;\n+        for (int i = 0; i < COUNT; ++i) {\n+            String id = String.valueOf(10000 + i);\n+            int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\"));\n+            symbols.addName(id, quads, quads.length);\n+        }\n+\n+//System.out.printf(\"Byte stuff: collisions %d, max-coll %d\\n\", symbols.collisionCount(), symbols.maxCollisionLength());\n+        \n+        assertEquals(COUNT, symbols.size());\n+        assertEquals(65536, symbols.bucketCount());\n+\n+        // collision count acceptable\n+        assertEquals(5782, symbols.collisionCount());\n+        // as well as collision counts\n+        assertEquals(24, symbols.maxCollisionLength());\n+    }\n+\n+    // [core#187]: unexpectedly high number of collisions for straight numbers\n+    public void testCollisionsWithChars187() throws IOException\n+    {\n+        CharsToNameCanonicalizer symbols = CharsToNameCanonicalizer.createRoot(1);\n+        final int COUNT = 30000;\n+        for (int i = 0; i < COUNT; ++i) {\n+            String id = String.valueOf(10000 + i);\n+            char[] ch = id.toCharArray();\n+            symbols.findSymbol(ch, 0, ch.length, symbols.calcHash(id));\n+        }\n+        assertEquals(COUNT, symbols.size());\n+        assertEquals(65536, symbols.bucketCount());\n+\n+        // collision count rather high, but has to do\n+        assertEquals(14408, symbols.collisionCount());\n+        // as well as collision counts\n+        assertEquals(10, symbols.maxCollisionLength());\n+    }\n+\n+    // [core#187]: unexpectedly high number of collisions for straight numbers\n+    public void testCollisionsWithBytesNew187() throws IOException\n+    {\n+        ByteQuadsCanonicalizer symbols =\n+                ByteQuadsCanonicalizer.createRoot(1).makeChild(JsonFactory.Feature.collectDefaults());\n+\n+        final int COUNT = 43000;\n+        for (int i = 0; i < COUNT; ++i) {\n+            String id = String.valueOf(10000 + i);\n+            int[] quads = calcQuads(id.getBytes(\"UTF-8\"));\n+            symbols.addName(id, quads, quads.length);\n+        }\n+        assertEquals(COUNT, symbols.size());\n+        assertEquals(65536, symbols.bucketCount());\n+\n+        // fragile, but essential to verify low collision counts;\n+        // anywhere between 70-80% primary matches\n+        assertEquals(32446, symbols.primaryCount());\n+        // secondary between 10-20%\n+        assertEquals(6472, symbols.secondaryCount());\n+        // and most of remaining in tertiary\n+        assertEquals(3773, symbols.tertiaryCount());\n+        // but number of spill-overs starts to grow beyond 30k quite a lot:\n+        assertEquals(309, symbols.spilloverCount());\n+    }\n }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/FilteringGeneratorDelegate.java\n+package com.fasterxml.jackson.core.filter;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.util.JsonGeneratorDelegate;\n+\n+/**\n+ * @since 2.6.0\n+ */\n+public class FilteringGeneratorDelegate extends JsonGeneratorDelegate\n+{\n+    /**\n+     * Object consulted to determine whether to write parts of content generator\n+     * is asked to write or not.\n+     */\n+    protected TokenFilter filter;\n+\n+    /**\n+     * Although delegate has its own output context it is not sufficient since we actually\n+     * have to keep track of excluded (filtered out) structures as well as ones delegate\n+     * actually outputs.\n+     */\n+    protected TokenFilterContext _filterContext;\n+\n+    /**\n+     * The current state constant is kept here as well, not just at the tip of {@link #_filterContext}.\n+     */\n+    protected int _currentState;\n+\n+    /*\n+    /**********************************************************\n+    /* Construction, initialization\n+    /**********************************************************\n+     */\n+\n+    public FilteringGeneratorDelegate(JsonGenerator d, TokenFilter f) {\n+        // By default, do NOT delegate copy methods\n+        super(d, false);\n+        filter = f;\n+        // Doesn't matter if it's include or exclude current, but shouldn't be including/excluding sub-tree\n+        _currentState = TokenFilter.FILTER_INCLUDE_CURRENT;\n+        _filterContext = TokenFilterContext.createRootContext(_currentState);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended API\n+    /**********************************************************\n+     */\n+\n+    public TokenFilter getTokenFilter() { return filter; }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, structural\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeStartArray() throws IOException\n+    {\n+        /*\n+        switch (_currentState) {\n+        case TokenFilter.FILTER_SKIP_TREE: // filter all down the tree?\n+            _filterContext = _filterContext.createChildArrayContext(_currentState);\n+            return;\n+        case TokenFilter.FILTER_SKIP_CURRENT: // may or may not include, need to check\n+        case TokenFilter.FILTER_INCLUDE_CURRENT:\n+            int newState = filter.startArray();\n+            _filterContext = _filterContext.createChildArrayContext(newState);\n+            if (newState >= TokenFilter.FILTER_INCLUDE_CURRENT) {\n+                delegate.writeStartArray();\n+            }\n+            return;\n+        case TokenFilter.FILTER_INCLUDE_TREE: // include the whole sub-tree?\n+        default:\n+            _filterContext = _filterContext.createChildArrayContext(_currentState);\n+            delegate.writeStartArray();\n+            return;\n+        }\n+        */\n+    }\n+\n+    @Override\n+    public void writeStartArray(int size) throws IOException\n+    {\n+        /*\n+        switch (_currentState) {\n+        case TokenFilter.FILTER_SKIP_TREE: // filter all down the tree?\n+            _filterContext = _filterContext.createChildArrayContext(_currentState);\n+            return;\n+        case TokenFilter.FILTER_SKIP_CURRENT: // may or may not include, need to check\n+        case TokenFilter.FILTER_INCLUDE_CURRENT:\n+            int newState = filter.startArray();\n+            _filterContext = _filterContext.createChildArrayContext(newState);\n+            if (newState >= TokenFilter.FILTER_INCLUDE_CURRENT) {\n+                delegate.writeStartArray(size);\n+            }\n+            return;\n+        case TokenFilter.FILTER_INCLUDE_TREE: // include the whole sub-tree?\n+        default:\n+            _filterContext = _filterContext.createChildArrayContext(_currentState);\n+            delegate.writeStartArray(size);\n+            return;\n+        }\n+        */\n+    }\n+    \n+    @Override\n+    public void writeEndArray() throws IOException\n+    {\n+        if (_currentState >= TokenFilter.FILTER_INCLUDE_CURRENT) {\n+            delegate.writeEndArray();\n+        }\n+        _filterContext = _filterContext.getParent();\n+        if (_filterContext != null) {\n+            _currentState = _filterContext.getFilterState();\n+        }\n+    }\n+\n+    @Override\n+    public void writeStartObject() throws IOException\n+    {\n+        /*\n+        switch (_currentState) {\n+        case TokenFilter.FILTER_SKIP_TREE: // filter all down the tree?\n+            _filterContext = _filterContext.createChildObjectContext(_currentState);\n+            return;\n+        case TokenFilter.FILTER_SKIP_CURRENT: // may or may not include, need to check\n+        case TokenFilter.FILTER_INCLUDE_CURRENT:\n+            int newState = filter.startObject();\n+            _filterContext = _filterContext.createChildObjectContext(newState);\n+            if (newState >= TokenFilter.FILTER_INCLUDE_CURRENT) {\n+                delegate.writeStartObject();\n+            }\n+            return;\n+        case TokenFilter.FILTER_INCLUDE_TREE: // include the whole sub-tree?\n+        default:\n+            _filterContext = _filterContext.createChildObjectContext(_currentState);\n+            delegate.writeStartObject();\n+            return;\n+        }\n+        */\n+    }\n+    \n+    @Override\n+    public void writeEndObject() throws IOException\n+    {\n+        if (_currentState >= TokenFilter.FILTER_INCLUDE_CURRENT) {\n+            delegate.writeEndObject();\n+        }\n+        _filterContext = _filterContext.getParent();\n+        if (_filterContext != null) {\n+            _currentState = _filterContext.getFilterState();\n+        }\n+    }\n+\n+    @Override\n+    public void writeFieldName(String name) throws IOException\n+    {\n+        /*\n+        switch (_currentState) {\n+        case TokenFilter.FILTER_SKIP_TREE:\n+            return;\n+        case TokenFilter.FILTER_SKIP_CURRENT: // may or may not include, need to check\n+        case TokenFilter.FILTER_INCLUDE_CURRENT:\n+            _propertyState = filter.\n+            int state = filter.startObject();\n+            if (state >= TokenFilter.FILTER_INCLUDE_CURRENT) {\n+                delegate.writeStartObject();\n+            }\n+            return;\n+        case TokenFilter.FILTER_INCLUDE_TREE: // include the whole sub-tree?\n+        default:\n+            delegate.writeFieldName(name);\n+            return;\n+        }\n+        */\n+    }\n+\n+    @Override\n+    public void writeFieldName(SerializableString name) throws IOException {\n+        delegate.writeFieldName(name);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, text/String values\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeString(String text) throws IOException {\n+        delegate.writeString(text);\n+    }\n+\n+    @Override\n+    public void writeString(char[] text, int offset, int len) throws IOException {\n+        delegate.writeString(text, offset, len);\n+    }\n+\n+    @Override\n+    public void writeString(SerializableString text) throws IOException {\n+        delegate.writeString(text);\n+    }\n+\n+    @Override\n+    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException {\n+        delegate.writeRawUTF8String(text, offset, length);\n+    }\n+\n+    @Override\n+    public void writeUTF8String(byte[] text, int offset, int length) throws IOException {\n+        delegate.writeUTF8String(text, offset, length);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, binary/raw content\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeRaw(String text) throws IOException {\n+        delegate.writeRaw(text);\n+    }\n+\n+    @Override\n+    public void writeRaw(String text, int offset, int len) throws IOException {\n+        delegate.writeRaw(text, offset, len);\n+    }\n+\n+    @Override\n+    public void writeRaw(SerializableString raw) throws IOException {\n+        delegate.writeRaw(raw);\n+    }\n+\n+    @Override\n+    public void writeRaw(char[] text, int offset, int len) throws IOException {\n+        delegate.writeRaw(text, offset, len);\n+    }\n+\n+    @Override\n+    public void writeRaw(char c) throws IOException {\n+        delegate.writeRaw(c);\n+    }\n+\n+    @Override\n+    public void writeRawValue(String text) throws IOException {\n+        delegate.writeRawValue(text);\n+    }\n+\n+    @Override\n+    public void writeRawValue(String text, int offset, int len) throws IOException {\n+        delegate.writeRawValue(text, offset, len);\n+    }\n+\n+    @Override\n+    public void writeRawValue(char[] text, int offset, int len) throws IOException {\n+        delegate.writeRawValue(text, offset, len);\n+    }\n+\n+    @Override\n+    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException {\n+        delegate.writeBinary(b64variant, data, offset, len);\n+    }\n+\n+    @Override\n+    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException {\n+        return delegate.writeBinary(b64variant, data, dataLength);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, other value types\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeNumber(short v) throws IOException {\n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(int v) throws IOException {\n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(long v) throws IOException {\n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(BigInteger v) throws IOException {\n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(double v) throws IOException {\n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(float v) throws IOException {\n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(BigDecimal v) throws IOException {\n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(String encodedValue) throws IOException, UnsupportedOperationException {\n+        delegate.writeNumber(encodedValue);\n+    }\n+\n+    @Override\n+    public void writeBoolean(boolean state) throws IOException {\n+        delegate.writeBoolean(state);\n+    }\n+\n+    @Override\n+    public void writeNull() throws IOException {\n+        delegate.writeNull();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridden field methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeOmittedField(String fieldName) throws IOException {\n+        delegate.writeOmittedField(fieldName);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, Native Ids\n+    /**********************************************************\n+     */\n+\n+    // 25-Mar-2015, tatu: These are tricky as they sort of predate actual filtering calls.\n+    //   Let's try to use current state as a clue at least...\n+    \n+    @Override\n+    public void writeObjectId(Object id) throws IOException {\n+        delegate.writeObjectId(id);\n+    }\n+\n+    @Override\n+    public void writeObjectRef(Object id) throws IOException {\n+        delegate.writeObjectRef(id);\n+    }\n+    \n+    @Override\n+    public void writeTypeId(Object id) throws IOException {\n+        delegate.writeTypeId(id);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, serializing Java objects\n+    /**********************************************************\n+     */\n+\n+    // Base class definitions for these seems correct to me, iff not directly delegating:\n+\n+    /*\n+    @Override\n+    public void writeObject(Object pojo) throws IOException,JsonProcessingException {\n+        if (delegateCopyMethods) {\n+            delegate.writeObject(pojo);\n+            return;\n+        }\n+        // NOTE: copied from \n+        if (pojo == null) {\n+            writeNull();\n+        } else {\n+            if (getCodec() != null) {\n+                getCodec().writeValue(this, pojo);\n+                return;\n+            }\n+            _writeSimpleObject(pojo);\n+        }\n+    }\n+    \n+    @Override\n+    public void writeTree(TreeNode rootNode) throws IOException {\n+        if (delegateCopyMethods) {\n+            delegate.writeTree(rootNode);\n+            return;\n+        }\n+        // As with 'writeObject()', we are not check if write would work\n+        if (rootNode == null) {\n+            writeNull();\n+        } else {\n+            if (getCodec() == null) {\n+                throw new IllegalStateException(\"No ObjectCodec defined\");\n+            }\n+            getCodec().writeValue(this, rootNode);\n+        }\n+    }\n+    */\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, copy-through methods\n+    /**********************************************************\n+     */\n+\n+    // Base class definitions for these seems correct to me, iff not directly delegating:\n+\n+    /*\n+    @Override\n+    public void copyCurrentEvent(JsonParser jp) throws IOException {\n+        if (delegateCopyMethods) delegate.copyCurrentEvent(jp);\n+        else super.copyCurrentEvent(jp);\n+    }\n+\n+    @Override\n+    public void copyCurrentStructure(JsonParser jp) throws IOException {\n+        if (delegateCopyMethods) delegate.copyCurrentStructure(jp);\n+        else super.copyCurrentStructure(jp);\n+    }\n+    */\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/TokenFilter.java\n+package com.fasterxml.jackson.core.filter;\n+\n+import com.fasterxml.jackson.core.JsonToken;\n+\n+/**\n+ * @since 2.6\n+ */\n+public abstract class TokenFilter\n+{\n+    // Constants\n+\n+    public final static int FILTER_SKIP_TREE = 1;\n+    public final static int FILTER_SKIP_CURRENT = 2;\n+    public final static int FILTER_INCLUDE_CURRENT = 3;\n+    public final static int FILTER_INCLUDE_TREE = 4;\n+\n+    // API, scalar values\n+\n+    public int writeRootScalarValue(JsonToken type) {\n+        return FILTER_SKIP_TREE;\n+    }\n+\n+    public int writeScalarProperty(String name, JsonToken type) {\n+        return FILTER_SKIP_TREE;\n+    }\n+\n+    public int writeScalarElement(int index, JsonToken type) {\n+        return FILTER_SKIP_TREE;\n+    }\n+\n+    // API, Objects\n+    \n+    public int startRootObject() {\n+        return FILTER_SKIP_TREE;\n+    }\n+    \n+    public int startObjectProperty(String name) {\n+        return FILTER_SKIP_TREE;\n+    }\n+    \n+    public int startObjectElement(int index) {\n+        return FILTER_SKIP_TREE;\n+    }\n+    \n+    public void finishObject() { }\n+\n+    // API, Arrays\n+    \n+    public int startRootArray() {\n+        return FILTER_SKIP_TREE;\n+    }\n+    \n+    public int startArrayProperty(String name) {\n+        return FILTER_SKIP_TREE;\n+    }\n+    \n+    public int startArrayElement(int index) {\n+        return FILTER_SKIP_TREE;\n+    }\n+    \n+    public void finishArray() { }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/TokenFilterContext.java\n+package com.fasterxml.jackson.core.filter;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+/**\n+ * Alternative variant of {@link JsonStreamContext}, used when filtering\n+ * content being read or written (based on {@link TokenFilter}).\n+ */\n+public class TokenFilterContext extends JsonStreamContext\n+{\n+    /**\n+     * Parent context for this context; null for root context.\n+     */\n+    protected final TokenFilterContext _parent;\n+\n+    /*\n+    /**********************************************************\n+    /* Simple instance reuse slots; speed up things\n+    /* a bit (10-15%) for docs with lots of small\n+    /* arrays/objects\n+    /**********************************************************\n+     */\n+\n+    protected TokenFilterContext _child = null;\n+\n+    /*\n+    /**********************************************************\n+    /* Location/state information\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Name of the field of which value is to be parsed; only\n+     * used for OBJECT contexts\n+     */\n+    protected String _currentName;\n+\n+    protected int _filterState;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    protected TokenFilterContext(int type, TokenFilterContext parent, int fstate) {\n+        super();\n+        _type = type;\n+        _parent = parent;\n+        _filterState = fstate;\n+        _index = -1;\n+    }\n+\n+    protected TokenFilterContext reset(int type, int fstate) {\n+        _type = type;\n+        _filterState = fstate;\n+        _index = -1;\n+        _currentName = null;\n+        return this;\n+    }\n+\n+    @Override\n+    public Object getCurrentValue() {\n+        return null;\n+    }\n+\n+    @Override\n+    public void setCurrentValue(Object v) { }\n+    \n+    /*\n+    /**********************************************************\n+    /* Factory methods\n+    /**********************************************************\n+     */\n+\n+    public static TokenFilterContext createRootContext(int fstate) {\n+        return new TokenFilterContext(TYPE_ROOT, null, fstate);\n+    }\n+\n+    public TokenFilterContext createChildArrayContext(int fstate) {\n+        TokenFilterContext ctxt = _child;\n+        if (ctxt == null) {\n+            _child = ctxt = new TokenFilterContext(TYPE_ARRAY, this, fstate);\n+            return ctxt;\n+        }\n+        return ctxt.reset(TYPE_ARRAY, fstate);\n+    }\n+\n+    public TokenFilterContext createChildObjectContext(int fstate) {\n+        TokenFilterContext ctxt = _child;\n+        if (ctxt == null) {\n+            _child = ctxt = new TokenFilterContext(TYPE_OBJECT, this, fstate);\n+            return ctxt;\n+        }\n+        return ctxt.reset(TYPE_OBJECT, fstate);\n+    }\n+\n+    @Override public final TokenFilterContext getParent() { return _parent; }\n+    @Override public final String getCurrentName() { return _currentName; }\n+\n+    public int getFilterState() { return _filterState; }\n+\n+    public void writeFieldName(String name) throws JsonProcessingException {\n+        _currentName = name;\n+    }\n+\n+    public void writeValue() {\n+        ++_index;\n+    }\n+\n+    // // // Internally used abstract methods\n+\n+    protected void appendDesc(StringBuilder sb) {\n+        if (_type == TYPE_OBJECT) {\n+            sb.append('{');\n+            if (_currentName != null) {\n+                sb.append('\"');\n+                // !!! TODO: Name chars should be escaped?\n+                sb.append(_currentName);\n+                sb.append('\"');\n+            } else {\n+                sb.append('?');\n+            }\n+            sb.append('}');\n+        } else if (_type == TYPE_ARRAY) {\n+            sb.append('[');\n+            sb.append(getCurrentIndex());\n+            sb.append(']');\n+        } else {\n+            // nah, ROOT:\n+            sb.append(\"/\");\n+        }\n+    }\n+\n+    // // // Overridden standard methods\n+\n+    /**\n+     * Overridden to provide developer writeable \"JsonPath\" representation\n+     * of the context.\n+     */\n+    @Override public String toString() {\n+        StringBuilder sb = new StringBuilder(64);\n+        appendDesc(sb);\n+        return sb.toString();\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java\n         return ctxt.reset(TYPE_OBJECT);\n     }\n \n-    // // // Shared API\n-\n     @Override public final JsonWriteContext getParent() { return _parent; }\n     @Override public final String getCurrentName() { return _currentName; }\n \n     public DupDetector getDupDetector() {\n         return _dups;\n     }\n-    \n-    // // // API sub-classes are to implement\n \n     /**\n      * Method that writer is to call before it writes a field name.\n--- a/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n     /* Construction, initialization\n     /**********************************************************\n      */\n-    \n+\n     public JsonGeneratorDelegate(JsonGenerator d) {\n         this(d, true);\n     }", "timestamp": 1427472205, "metainfo": ""}