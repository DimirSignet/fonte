{"sha": "cfe32d097af194273b3f7160caec7e662f49e85f", "log": "Cleaning up filtering, to disable use of \"include immediate parent\" for properties; not useful, complicates things.", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/filter/FilteringGeneratorDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/FilteringGeneratorDelegate.java\n      * path from main level down to match is also included as necessary.\n      */\n     protected boolean _includePath;\n-    \n+\n+    /* NOTE: this feature is included in the first version (2.6), but\n+     * there is no public API to enable it, yet, since there isn't an\n+     * actual use case. But it seemed possible need could arise, which\n+     * is feature has not yet been removed. If no use is found within\n+     * first version or two, just remove.\n+     * \n+     * Marked as deprecated since its status is uncertain.\n+     */\n+    @Deprecated\n+    protected boolean _includeImmediateParent = false;\n+\n     /*\n     /**********************************************************\n     /* Additional state\n         ++_matchCount;\n         if (_includePath) {\n             _filterContext.writePath(delegate);\n-        } else {\n+        } else if (_includeImmediateParent) {\n+            // 21-Apr-2015, tatu: Note that there is no API to enable this currently...\n+            //    retained for speculative future use\n             _filterContext.writeImmediatePath(delegate);\n         }\n \n--- a/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java\n      * path from main level down to match is also included as necessary.\n      */\n     protected boolean _includePath;\n+\n+    /* NOTE: this feature is included in the first version (2.6), but\n+     * there is no public API to enable it, yet, since there isn't an\n+     * actual use case. But it seemed possible need could arise, which\n+     * is feature has not yet been removed. If no use is found within\n+     * first version or two, just remove.\n+     * \n+     * Marked as deprecated since its status is uncertain.\n+     */\n+    @Deprecated\n+    protected boolean _includeImmediateParent = false;\n     \n     /*\n     /**********************************************************\n                 f = _headContext.setFieldName(name);\n                 if (f == TokenFilter.INCLUDE_ALL) {\n                     _itemFilter = f;\n-                    // Minor twist here: if parent NOT included, may need to induce output of\n-                    // surrounding START_OBJECT/END_OBJECT\n-                    if (!_includePath && !_headContext.isStartHandled()) {\n-                        t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n-                        _exposedContext = _headContext;\n+                    if (!_includePath) {\n+                        // Minor twist here: if parent NOT included, may need to induce output of\n+                        // surrounding START_OBJECT/END_OBJECT\n+                        if (_includeImmediateParent && !_headContext.isStartHandled()) {\n+                            t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n+                            _exposedContext = _headContext;\n+                        }\n                     }\n                     return (_currToken = t);\n                 }\n                 }\n                 _itemFilter = f;\n                 if (f == TokenFilter.INCLUDE_ALL) {\n-                    return (_currToken = t);\n+                    if (_includePath) {\n+                        return (_currToken = t);\n+                    }\n                 }\n                 if (_includePath) {\n                     return _nextTokenWithBuffering(_headContext);\n                     }\n                     _itemFilter = f;\n                     if (f == TokenFilter.INCLUDE_ALL) {\n-                        return (_currToken = t);\n+                        if (_includePath) {\n+                            return (_currToken = t);\n+                        }\n+//                        if (_includeImmediateParent) { ...\n+                        continue main_loop;\n                     }\n                     if (_includePath) {\n                         return _nextTokenWithBuffering(_headContext);\n         }\n         return _headContext;\n     }\n-\n }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/JsonPointerBasedFilter.java\n+package com.fasterxml.jackson.core.filter;\n+\n+import com.fasterxml.jackson.core.JsonPointer;\n+\n+/**\n+ * Simple {@link TokenFilter} implementation that takes a single\n+ * {@link JsonPointer} and matches a single value accordingly.\n+ * Instances are immutable and fully thread-safe, shareable,\n+ * and efficient to use.\n+ * \n+ * @since 2.6\n+ */\n+public class JsonPointerBasedFilter extends TokenFilter\n+{\n+    protected final JsonPointer _pathToMatch;\n+\n+    public JsonPointerBasedFilter(String ptrExpr) {\n+        this(JsonPointer.compile(ptrExpr));\n+    }\n+\n+    public JsonPointerBasedFilter(JsonPointer match) {\n+        _pathToMatch = match;\n+    }\n+\n+    @Override\n+    public TokenFilter includeElement(int index) {\n+        JsonPointer next = _pathToMatch.matchElement(index);\n+        if (next == null) {\n+            return null;\n+        }\n+        if (next.matches()) {\n+            return TokenFilter.INCLUDE_ALL;\n+        }\n+        return new JsonPointerBasedFilter(next);\n+    }\n+\n+    @Override\n+    public TokenFilter includeProperty(String name) {\n+        JsonPointer next = _pathToMatch.matchProperty(name);\n+        if (next == null) {\n+            return null;\n+        }\n+        if (next.matches()) {\n+            return TokenFilter.INCLUDE_ALL;\n+        }\n+        return new JsonPointerBasedFilter(next);\n+    }\n+\n+    @Override\n+    public TokenFilter filterStartArray() {\n+        return this;\n+    }\n+    \n+    @Override\n+    public TokenFilter filterStartObject() {\n+        return this;\n+    }\n+    \n+    @Override\n+    protected boolean _includeScalar() {\n+        // should only occur for root-level scalars, path \"/\"\n+        return _pathToMatch.matches();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"[JsonPointerFilter at: \"+_pathToMatch+\"]\";\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/core/filter/BasicGeneratorFilteringTest.java\n+++ b/src/test/java/com/fasterxml/jackson/core/filter/BasicGeneratorFilteringTest.java\n                 );\n         final String JSON = \"{'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}\";\n         writeJsonDoc(JSON_F, JSON, gen);\n-        // Since properties MUST be contained within an Object, inclusion needs\n-         // to materialize surrounding Object too!\n-        assertEquals(aposToQuotes(\"{'value':3}\"), w.toString());\n+\n+        // 21-Apr-2015, tatu: note that there were plans to actually\n+        //     allow \"immediate parent inclusion\" for matches on property\n+        //    names. This behavior was NOT included in release however, so:\n+//        assertEquals(aposToQuotes(\"{'value':3}\"), w.toString());\n+\n+        assertEquals(aposToQuotes(\"3\"), w.toString());\n     }\n \n     public void testSingleMatchFilteringWithPath() throws Exception\n--- a/src/test/java/com/fasterxml/jackson/core/filter/JsonPointerGeneratorFilteringTest.java\n+++ b/src/test/java/com/fasterxml/jackson/core/filter/JsonPointerGeneratorFilteringTest.java\n \n         JsonGenerator g0 = JSON_F.createGenerator(w);\n         FilteringGeneratorDelegate g = new FilteringGeneratorDelegate(g0,\n-                new JsonPointerBasedFilter(pathExpr, includeParent),\n+                new JsonPointerBasedFilter(pathExpr),\n                 includeParent, false);\n \n         try {\n--- a/src/test/java/com/fasterxml/jackson/core/filter/JsonPointerParserFilteringTest.java\n+++ b/src/test/java/com/fasterxml/jackson/core/filter/JsonPointerParserFilteringTest.java\n \n     public void testSimpleNoPath() throws Exception\n     {\n-        _assert(SIMPLE_INPUT, \"/c\", false, \"{'d':{'a':true}}\");\n+//        _assert(SIMPLE_INPUT, \"/c\", false, \"{'d':{'a':true}}\");\n+\n         _assert(SIMPLE_INPUT, \"/c/d\", false, \"{'a':true}\");\n         _assert(SIMPLE_INPUT, \"/a\", false, \"1\");\n         _assert(SIMPLE_INPUT, \"/b\", false, \"[1,2,3]\");\n     {\n         JsonParser p0 = JSON_F.createParser(input);\n         FilteringParserDelegate p = new FilteringParserDelegate(p0,\n-                new JsonPointerBasedFilter(pathExpr, includeParent),\n+                new JsonPointerBasedFilter(pathExpr),\n                 includeParent, false);\n         StringWriter w = new StringWriter();\n         JsonGenerator g = JSON_F.createGenerator(w);", "timestamp": 1429683442, "metainfo": ""}