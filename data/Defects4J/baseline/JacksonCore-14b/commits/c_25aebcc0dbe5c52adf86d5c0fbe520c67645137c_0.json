{"sha": "25aebcc0dbe5c52adf86d5c0fbe520c67645137c", "log": "Merge branch 'master' of github.com:FasterXML/jackson-core", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n          */\n         FAIL_ON_SYMBOL_HASH_OVERFLOW(true),\n \n+        /**\n+         * Feature that determines whether we will use {@link BufferRecycler} with\n+         * {@link ThreadLocal} and {@link SoftReference}, for efficient reuse of\n+         * underlying input/output buffers.\n+         * This usually makes sense on normal J2SE/J2EE server-side processing;\n+         * but may not make sense on platforms where {@link SoftReference} handling\n+         * is broken (like Android), or if there are retention issues due to\n+         * {@link ThreadLocal} (see\n+         * <a href=\"https://github.com/FasterXML/jackson-core/issues/189\">Issue #189</a>\n+         * for a possible case)\n+         *\n+         * @since 2.6\n+         */\n+        USE_THREAD_LOCAL_FOR_BUFFER_RECYCLING(true)\n+        \n         ;\n \n         /**\n      */\n     public BufferRecycler _getBufferRecycler()\n     {\n-        SoftReference<BufferRecycler> ref = _recyclerRef.get();\n-        BufferRecycler br = (ref == null) ? null : ref.get();\n-\n-        if (br == null) {\n+        BufferRecycler br;\n+\n+        /* 23-Apr-2015, tatu: Let's allow disabling of buffer recycling\n+         *   scheme, for cases where it is considered harmful (possibly\n+         *   on Android, for example)\n+         */\n+        if (isEnabled(Feature.USE_THREAD_LOCAL_FOR_BUFFER_RECYCLING)) {\n+            SoftReference<BufferRecycler> ref = _recyclerRef.get();\n+            br = (ref == null) ? null : ref.get();\n+    \n+            if (br == null) {\n+                br = new BufferRecycler();\n+                _recyclerRef.set(new SoftReference<BufferRecycler>(br));\n+            }\n+        } else {\n             br = new BufferRecycler();\n-            _recyclerRef.set(new SoftReference<BufferRecycler>(br));\n         }\n         return br;\n     }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/JsonFactoryTest.java\n+package com.fasterxml.jackson.core.json;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+public class JsonFactoryTest\n+    extends com.fasterxml.jackson.core.BaseTest\n+{\n+    public void testGeneratorFeatures() throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+        assertNull(f.getCodec());\n+\n+        f.configure(JsonGenerator.Feature.QUOTE_FIELD_NAMES, true);\n+        assertTrue(f.isEnabled(JsonGenerator.Feature.QUOTE_FIELD_NAMES));\n+        f.configure(JsonGenerator.Feature.QUOTE_FIELD_NAMES, false);\n+        assertFalse(f.isEnabled(JsonGenerator.Feature.QUOTE_FIELD_NAMES));\n+    }\n+\n+    public void testFactoryFeatures() throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+\n+        f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, true);\n+        assertTrue(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES));\n+        f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, false);\n+        assertFalse(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES));\n+\n+        // by default, should be enabled\n+        assertTrue(f.isEnabled(JsonFactory.Feature.USE_THREAD_LOCAL_FOR_BUFFER_RECYCLING));\n+        f.configure(JsonFactory.Feature.USE_THREAD_LOCAL_FOR_BUFFER_RECYCLING, false);\n+        assertFalse(f.isEnabled(JsonFactory.Feature.USE_THREAD_LOCAL_FOR_BUFFER_RECYCLING));\n+    }\n+\n+    // for [core#189]: verify that it's ok to disable recycling\n+    // Basically simply exercises basic functionality, to ensure\n+    // there are no obvious problems; needed since testing never\n+    // disables this handling otherwise\n+    public void testDisablingBufferRecycling() throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+\n+        f.disable(JsonFactory.Feature.USE_THREAD_LOCAL_FOR_BUFFER_RECYCLING);\n+\n+        // First, generation\n+        for (int i = 0; i < 3; ++i) {\n+            StringWriter w = new StringWriter();\n+            JsonGenerator gen = f.createGenerator(w);\n+            gen.writeStartObject();\n+            gen.writeEndObject();\n+            gen.close();\n+            assertEquals(\"{}\", w.toString());\n+        }\n+    \n+        for (int i = 0; i < 3; ++i) {\n+            ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n+            JsonGenerator gen = f.createGenerator(bytes);\n+            gen.writeStartArray();\n+            gen.writeEndArray();\n+            gen.close();\n+            assertEquals(\"[]\", bytes.toString(\"UTF-8\"));\n+        }\n+\n+        // Then parsing:\n+        for (int i = 0; i < 3; ++i) {\n+            JsonParser p = f.createParser(\"{}\");\n+            assertToken(JsonToken.START_OBJECT, p.nextToken());\n+            assertToken(JsonToken.END_OBJECT, p.nextToken());\n+            assertNull(p.nextToken());\n+            p.close();\n+\n+            p = f.createParser(\"{}\".getBytes(\"UTF-8\"));\n+            assertToken(JsonToken.START_OBJECT, p.nextToken());\n+            assertToken(JsonToken.END_OBJECT, p.nextToken());\n+            assertNull(p.nextToken());\n+            p.close();\n+        }\n+    }\n+    \n+    public void testJsonWithFiles() throws Exception\n+    {\n+        File file = File.createTempFile(\"jackson-test\", null);\n+        file.deleteOnExit();\n+        \n+        JsonFactory f = new JsonFactory();\n+\n+        // First: create file via generator.. and use an odd encoding\n+        JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE);\n+        jg.writeStartObject();\n+        jg.writeRaw(\"   \");\n+        jg.writeEndObject();\n+        jg.close();\n+\n+        // Ok: first read file directly\n+        JsonParser jp = f.createParser(file);\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+        assertNull(jp.nextToken());\n+        jp.close();\n+\n+        // Then via URL:\n+        jp = f.createParser(file.toURI().toURL());\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+        assertNull(jp.nextToken());\n+        jp.close();\n+\n+        // ok, delete once we are done\n+        file.delete();\n+    }\n+\n+    // #72\n+    public void testCopy() throws Exception\n+    {\n+        JsonFactory jf = new JsonFactory();\n+        // first, verify defaults\n+        assertTrue(jf.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES));\n+        assertFalse(jf.isEnabled(JsonParser.Feature.ALLOW_COMMENTS));\n+        assertFalse(jf.isEnabled(JsonGenerator.Feature.ESCAPE_NON_ASCII));\n+        jf.disable(JsonFactory.Feature.INTERN_FIELD_NAMES);\n+        jf.enable(JsonParser.Feature.ALLOW_COMMENTS);\n+        jf.enable(JsonGenerator.Feature.ESCAPE_NON_ASCII);\n+        // then change, verify that changes \"stick\"\n+        assertFalse(jf.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES));\n+        assertTrue(jf.isEnabled(JsonParser.Feature.ALLOW_COMMENTS));\n+        assertTrue(jf.isEnabled(JsonGenerator.Feature.ESCAPE_NON_ASCII));\n+\n+        JsonFactory jf2 = jf.copy();\n+        assertFalse(jf2.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES));\n+        assertTrue(jf.isEnabled(JsonParser.Feature.ALLOW_COMMENTS));\n+        assertTrue(jf.isEnabled(JsonGenerator.Feature.ESCAPE_NON_ASCII));\n+    }\n+}\n+\n--- a/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java\n                 // all done with buffered stuff?\n                 if (ctxt == _headContext) {\n                     _exposedContext = null;\n+                    if (ctxt.inArray()) {\n+                        t = delegate.getCurrentToken();\n+// Is this guaranteed to work without further checks?\n+//                        if (t != JsonToken.START_ARRAY) {\n+                        _currToken = t;\n+                        return t;\n+                    }\n+\n                     // Almost! Most likely still have the current token;\n                     // with the sole exception of \n                     /*\n             \n             // Also: only need buffering if parent path to be included\n             if (_includePath) {\n-                return _nextTokenWithBuffering(_headContext);\n+                t = _nextTokenWithBuffering(_headContext);\n+                if (t != null) {\n+                    _currToken = t;\n+                    return t;\n+                }\n             }\n             break;\n \n             _headContext = _headContext.createChildObjectContext(f, false);\n             // Also: only need buffering if parent path to be included\n             if (_includePath) {\n-                return _nextTokenWithBuffering(_headContext);\n+                t = _nextTokenWithBuffering(_headContext);\n+                if (t != null) {\n+                    _currToken = t;\n+                    return t;\n+                }\n             }\n             // note: inclusion of surrounding Object handled separately via\n             // FIELD_NAME\n                     }\n                 }\n                 if (_includePath) {\n-                    return _nextTokenWithBuffering(_headContext);\n+                    t = _nextTokenWithBuffering(_headContext);\n+                    if (t != null) {\n+                        _currToken = t;\n+                        return t;\n+                    }\n                 }\n                 break;\n             }\n                 _headContext = _headContext.createChildArrayContext(f, false);\n                 // but if we didn't figure it out yet, need to buffer possible events\n                 if (_includePath) {\n-                    return _nextTokenWithBuffering(_headContext);\n+                    t = _nextTokenWithBuffering(_headContext);\n+                    if (t != null) {\n+                        _currToken = t;\n+                        return t;\n+                    }\n                 }\n                 continue main_loop;\n \n                 }\n                 _headContext = _headContext.createChildObjectContext(f, false);\n                 if (_includePath) {\n-                    return _nextTokenWithBuffering(_headContext);\n+                    t = _nextTokenWithBuffering(_headContext);\n+                    if (t != null) {\n+                        _currToken = t;\n+                        return t;\n+                    }\n                 }\n                 continue main_loop;\n \n                         continue main_loop;\n                     }\n                     if (_includePath) {\n-                        return _nextTokenWithBuffering(_headContext);\n+                        t = _nextTokenWithBuffering(_headContext);\n+                        if (t != null) {\n+                            _currToken = t;\n+                            return t;\n+                        }\n                     }\n                 }\n                 continue main_loop;\n         main_loop:\n         while (true) {\n             JsonToken t = delegate.nextToken();\n-\n             if (t == null) { // is this even legal?\n-                return (_currToken = t);\n+                return t;\n             }\n             TokenFilter f;\n \n                     f = f.filterStartArray();\n                 }\n                 _itemFilter = f;\n-                _headContext = _headContext.createChildArrayContext(f, true);\n-                if (f == TokenFilter.INCLUDE_ALL) {\n+                if (f == TokenFilter.INCLUDE_ALL) {\n+                    _headContext = _headContext.createChildArrayContext(f, true);\n                     return _nextBuffered();\n                 }\n+                _headContext = _headContext.createChildArrayContext(f, false);\n                 continue main_loop;\n \n             case ID_START_OBJECT:\n                 f = _itemFilter;\n                 if (f == TokenFilter.INCLUDE_ALL) {\n                     _headContext = _headContext.createChildObjectContext(f, true);\n-                    return (_currToken = t);\n+                    return t;\n                 }\n                 if (f == null) { // does this occur?\n                     delegate.skipChildren();\n                     _itemFilter = _headContext.getFilter();\n                     \n                     if (_headContext == buffRoot) {\n-                        // !!! TBI\n-                        throw _constructError(\"Internal error: end of possible inclusion -- TBI\");\n+                        return null;\n                     }\n                 }\n                 continue main_loop;\n         TokenFilterContext ctxt = _exposedContext;\n         JsonToken t = ctxt.nextTokenToRead();\n         if (t != null) {\n-            _currToken = t;\n             return t;\n         }\n         while (true) {\n             }\n             t = _exposedContext.nextTokenToRead();\n             if (t != null) {\n-                _currToken = t;\n                 return t;\n             }\n         }\n--- a/src/test/java/com/fasterxml/jackson/core/filter/JsonPointerParserFilteringTest.java\n+++ b/src/test/java/com/fasterxml/jackson/core/filter/JsonPointerParserFilteringTest.java\n         _assert(SIMPLE_INPUT, \"/c/d\", true, \"{'c':{'d':{'a':true}}}\");\n         _assert(SIMPLE_INPUT, \"/a\", true, \"{'a':1}\");\n         _assert(SIMPLE_INPUT, \"/b\", true, \"{'b':[1,2,3]}\");\n-\n-//        _assert(SIMPLE_INPUT, \"/b/1\", true, \"{'b':[2]}\");\n+        _assert(SIMPLE_INPUT, \"/b/0\", true, \"{'b':[1]}\");\n+        _assert(SIMPLE_INPUT, \"/b/1\", true, \"{'b':[2]}\");\n+        _assert(SIMPLE_INPUT, \"/b/2\", true, \"{'b':[3]}\");\n+        _assert(SIMPLE_INPUT, \"/b/3\", true, \"\");\n     }\n \n     public void testSimpleNoPath() throws Exception\n     {\n-//        _assert(SIMPLE_INPUT, \"/c\", false, \"{'d':{'a':true}}\");\n+        _assert(SIMPLE_INPUT, \"/c\", false, \"{'d':{'a':true}}\");\n \n         _assert(SIMPLE_INPUT, \"/c/d\", false, \"{'a':true}\");\n         _assert(SIMPLE_INPUT, \"/a\", false, \"1\");", "timestamp": 1429895197, "metainfo": ""}