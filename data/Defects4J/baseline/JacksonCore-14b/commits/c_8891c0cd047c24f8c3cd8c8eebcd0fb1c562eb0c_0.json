{"sha": "8891c0cd047c24f8c3cd8c8eebcd0fb1c562eb0c", "log": "Fix #189: add `JsonFactory.Feature.USE_THREAD_LOCAL_FOR_BUFFER_RECYCLING` (default: enabled)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonFactory.java\n          */\n         FAIL_ON_SYMBOL_HASH_OVERFLOW(true),\n \n+        /**\n+         * Feature that determines whether we will use {@link BufferRecycler} with\n+         * {@link ThreadLocal} and {@link SoftReference}, for efficient reuse of\n+         * underlying input/output buffers.\n+         * This usually makes sense on normal J2SE/J2EE server-side processing;\n+         * but may not make sense on platforms where {@link SoftReference} handling\n+         * is broken (like Android), or if there are retention issues due to\n+         * {@link ThreadLocal} (see\n+         * <a href=\"https://github.com/FasterXML/jackson-core/issues/189\">Issue #189</a>\n+         * for a possible case)\n+         *\n+         * @since 2.6\n+         */\n+        USE_THREAD_LOCAL_FOR_BUFFER_RECYCLING(true)\n+        \n         ;\n \n         /**\n      */\n     public BufferRecycler _getBufferRecycler()\n     {\n-        SoftReference<BufferRecycler> ref = _recyclerRef.get();\n-        BufferRecycler br = (ref == null) ? null : ref.get();\n-\n-        if (br == null) {\n+        BufferRecycler br;\n+\n+        /* 23-Apr-2015, tatu: Let's allow disabling of buffer recycling\n+         *   scheme, for cases where it is considered harmful (possibly\n+         *   on Android, for example)\n+         */\n+        if (isEnabled(Feature.USE_THREAD_LOCAL_FOR_BUFFER_RECYCLING)) {\n+            SoftReference<BufferRecycler> ref = _recyclerRef.get();\n+            br = (ref == null) ? null : ref.get();\n+    \n+            if (br == null) {\n+                br = new BufferRecycler();\n+                _recyclerRef.set(new SoftReference<BufferRecycler>(br));\n+            }\n+        } else {\n             br = new BufferRecycler();\n-            _recyclerRef.set(new SoftReference<BufferRecycler>(br));\n         }\n         return br;\n     }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/JsonFactoryTest.java\n+package com.fasterxml.jackson.core.json;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+public class JsonFactoryTest\n+    extends com.fasterxml.jackson.core.BaseTest\n+{\n+    public void testGeneratorFeatures() throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+        assertNull(f.getCodec());\n+\n+        f.configure(JsonGenerator.Feature.QUOTE_FIELD_NAMES, true);\n+        assertTrue(f.isEnabled(JsonGenerator.Feature.QUOTE_FIELD_NAMES));\n+        f.configure(JsonGenerator.Feature.QUOTE_FIELD_NAMES, false);\n+        assertFalse(f.isEnabled(JsonGenerator.Feature.QUOTE_FIELD_NAMES));\n+    }\n+\n+    public void testFactoryFeatures() throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+\n+        f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, true);\n+        assertTrue(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES));\n+        f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, false);\n+        assertFalse(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES));\n+\n+        // by default, should be enabled\n+        assertTrue(f.isEnabled(JsonFactory.Feature.USE_THREAD_LOCAL_FOR_BUFFER_RECYCLING));\n+        f.configure(JsonFactory.Feature.USE_THREAD_LOCAL_FOR_BUFFER_RECYCLING, false);\n+        assertFalse(f.isEnabled(JsonFactory.Feature.USE_THREAD_LOCAL_FOR_BUFFER_RECYCLING));\n+    }\n+\n+    // for [core#189]: verify that it's ok to disable recycling\n+    // Basically simply exercises basic functionality, to ensure\n+    // there are no obvious problems; needed since testing never\n+    // disables this handling otherwise\n+    public void testDisablingBufferRecycling() throws Exception\n+    {\n+        JsonFactory f = new JsonFactory();\n+\n+        f.disable(JsonFactory.Feature.USE_THREAD_LOCAL_FOR_BUFFER_RECYCLING);\n+\n+        // First, generation\n+        for (int i = 0; i < 3; ++i) {\n+            StringWriter w = new StringWriter();\n+            JsonGenerator gen = f.createGenerator(w);\n+            gen.writeStartObject();\n+            gen.writeEndObject();\n+            gen.close();\n+            assertEquals(\"{}\", w.toString());\n+        }\n+    \n+        for (int i = 0; i < 3; ++i) {\n+            ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n+            JsonGenerator gen = f.createGenerator(bytes);\n+            gen.writeStartArray();\n+            gen.writeEndArray();\n+            gen.close();\n+            assertEquals(\"[]\", bytes.toString(\"UTF-8\"));\n+        }\n+\n+        // Then parsing:\n+        for (int i = 0; i < 3; ++i) {\n+            JsonParser p = f.createParser(\"{}\");\n+            assertToken(JsonToken.START_OBJECT, p.nextToken());\n+            assertToken(JsonToken.END_OBJECT, p.nextToken());\n+            assertNull(p.nextToken());\n+            p.close();\n+\n+            p = f.createParser(\"{}\".getBytes(\"UTF-8\"));\n+            assertToken(JsonToken.START_OBJECT, p.nextToken());\n+            assertToken(JsonToken.END_OBJECT, p.nextToken());\n+            assertNull(p.nextToken());\n+            p.close();\n+        }\n+    }\n+    \n+    public void testJsonWithFiles() throws Exception\n+    {\n+        File file = File.createTempFile(\"jackson-test\", null);\n+        file.deleteOnExit();\n+        \n+        JsonFactory f = new JsonFactory();\n+\n+        // First: create file via generator.. and use an odd encoding\n+        JsonGenerator jg = f.createGenerator(file, JsonEncoding.UTF16_LE);\n+        jg.writeStartObject();\n+        jg.writeRaw(\"   \");\n+        jg.writeEndObject();\n+        jg.close();\n+\n+        // Ok: first read file directly\n+        JsonParser jp = f.createParser(file);\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+        assertNull(jp.nextToken());\n+        jp.close();\n+\n+        // Then via URL:\n+        jp = f.createParser(file.toURI().toURL());\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+        assertNull(jp.nextToken());\n+        jp.close();\n+\n+        // ok, delete once we are done\n+        file.delete();\n+    }\n+\n+    // #72\n+    public void testCopy() throws Exception\n+    {\n+        JsonFactory jf = new JsonFactory();\n+        // first, verify defaults\n+        assertTrue(jf.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES));\n+        assertFalse(jf.isEnabled(JsonParser.Feature.ALLOW_COMMENTS));\n+        assertFalse(jf.isEnabled(JsonGenerator.Feature.ESCAPE_NON_ASCII));\n+        jf.disable(JsonFactory.Feature.INTERN_FIELD_NAMES);\n+        jf.enable(JsonParser.Feature.ALLOW_COMMENTS);\n+        jf.enable(JsonGenerator.Feature.ESCAPE_NON_ASCII);\n+        // then change, verify that changes \"stick\"\n+        assertFalse(jf.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES));\n+        assertTrue(jf.isEnabled(JsonParser.Feature.ALLOW_COMMENTS));\n+        assertTrue(jf.isEnabled(JsonGenerator.Feature.ESCAPE_NON_ASCII));\n+\n+        JsonFactory jf2 = jf.copy();\n+        assertFalse(jf2.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES));\n+        assertTrue(jf.isEnabled(JsonParser.Feature.ALLOW_COMMENTS));\n+        assertTrue(jf.isEnabled(JsonGenerator.Feature.ESCAPE_NON_ASCII));\n+    }\n+}\n+", "timestamp": 1429854425, "metainfo": ""}