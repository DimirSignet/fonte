{"sha": "c77847efb6b62b9feac5cee435a4ebaec949c655", "log": "Rewrite filtering to use filters themselves instead of value tokens.", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/filter/FilteringGeneratorDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/FilteringGeneratorDelegate.java\n      * Object consulted to determine whether to write parts of content generator\n      * is asked to write or not.\n      */\n-    protected TokenFilter filter;\n+    protected TokenFilter rootFilter;\n \n     /**\n      * Flag that determines whether filtering will continue after the first\n      * Specifically used to pass inclusion state between property name and\n      * property, and also used for array elements.\n      */\n-    protected int _itemState;\n+    protected TokenFilter _itemFilter;\n     \n     /**\n      * Number of tokens for which {@link TokenFilter#FILTER_INCLUDE}\n     {\n         // By default, do NOT delegate copy methods\n         super(d, false);\n-        filter = f;\n-        // Doesn't matter if it's include or exclude current, but shouldn't be including/excluding sub-tree\n-        _itemState = TokenFilter.FILTER_CHECK;\n-        _filterContext = TokenFilterContext.createRootContext(_itemState);\n+        rootFilter = f;\n+        // and this is the currently active filter for root values\n+        _itemFilter = f;\n+        _filterContext = TokenFilterContext.createRootContext(f);\n         _includePath = includePath;\n         _allowMultipleMatches = allowMultipleMatches;\n     }\n     /**********************************************************\n      */\n \n-    public TokenFilter getTokenFilter() { return filter; }\n+    public TokenFilter getFilter() { return rootFilter; }\n \n     /**\n      * Accessor for finding number of matches, where specific token and sub-tree\n     public void writeStartArray() throws IOException\n     {\n         // First things first: whole-sale skipping easy\n-        if (_itemState == TokenFilter.FILTER_SKIP) {\n-            _filterContext = _filterContext.createChildArrayContext(_itemState, false);\n-            return;\n-        }\n-        if (_itemState == TokenFilter.FILTER_INCLUDE) { // include the whole sub-tree?\n-            _filterContext = _filterContext.createChildArrayContext(_itemState, true);\n+        if (_itemFilter == null) {\n+            _filterContext = _filterContext.createChildArrayContext(null, false);\n+            return;\n+        }\n+        if (_itemFilter == TokenFilter.INCLUDE_ALL) { // include the whole sub-tree?\n+            _filterContext = _filterContext.createChildArrayContext(_itemFilter, true);\n             delegate.writeStartArray();\n             return;\n         }\n         // Ok; regular checking state then\n-        _itemState = filter.filterStartArray();\n-        if (_itemState == TokenFilter.FILTER_INCLUDE) {\n+        _itemFilter = _itemFilter.filterStartArray();\n+        if (_itemFilter == TokenFilter.INCLUDE_ALL) {\n             // First: may need to re-create path\n             _checkParentPath();\n-            _filterContext = _filterContext.createChildArrayContext(_itemState, true);\n+            _filterContext = _filterContext.createChildArrayContext(_itemFilter, true);\n             delegate.writeStartArray();\n-        } else { // filter out\n-            _filterContext = _filterContext.createChildArrayContext(_itemState, false);\n-        }\n-        if (_itemState != TokenFilter.FILTER_SKIP) {\n+        } else { // either skip (null), or check (non-null)\n+            _filterContext = _filterContext.createChildArrayContext(_itemFilter, false);\n+        }\n+        if (_itemFilter != null) {\n             _filterContext.markNeedsCloseCheck();\n         }\n     }\n     @Override\n     public void writeStartArray(int size) throws IOException\n     {\n-        if (_itemState == TokenFilter.FILTER_SKIP) {\n-            _filterContext = _filterContext.createChildArrayContext(_itemState, false);\n-            return;\n-        }\n-        if (_itemState == TokenFilter.FILTER_INCLUDE) {\n-            _filterContext = _filterContext.createChildArrayContext(_itemState, true);\n+        if (_itemFilter == null) {\n+            _filterContext = _filterContext.createChildArrayContext(null, false);\n+            return;\n+        }\n+        if (_itemFilter == TokenFilter.INCLUDE_ALL) {\n+            _filterContext = _filterContext.createChildArrayContext(_itemFilter, true);\n             delegate.writeStartArray(size);\n             return;\n         }\n-        _itemState = filter.filterStartArray();\n-        if (_itemState == TokenFilter.FILTER_INCLUDE) {\n-            _checkParentPath();\n-            _filterContext = _filterContext.createChildArrayContext(_itemState, true);\n+        _itemFilter = _itemFilter.filterStartArray();\n+        if (_itemFilter == TokenFilter.INCLUDE_ALL) {\n+            _checkParentPath();\n+            _filterContext = _filterContext.createChildArrayContext(_itemFilter, true);\n             delegate.writeStartArray(size);\n         } else {\n-            _filterContext = _filterContext.createChildArrayContext(_itemState, false);\n-        }\n-        if (_itemState != TokenFilter.FILTER_SKIP) {\n+            _filterContext = _filterContext.createChildArrayContext(_itemFilter, false);\n+        }\n+        if (_itemFilter != null) {\n             _filterContext.markNeedsCloseCheck();\n         }\n     }\n     @Override\n     public void writeEndArray() throws IOException\n     {\n-        if (_filterContext.needsCloseToken()) {\n-            delegate.writeEndArray();\n-        }\n-        if (_filterContext.needsCloseCheck()) {\n-            filter.filterFinishArray();\n-        }\n-        _filterContext = _filterContext.getParent();\n+        _filterContext = _filterContext.closeArray(delegate);\n         if (_filterContext != null) {\n-            _itemState = _filterContext.getFilterState();\n+            _itemFilter = _filterContext.getFilterState();\n         }\n     }\n \n     @Override\n     public void writeStartObject() throws IOException\n     {\n-        if (_itemState == TokenFilter.FILTER_SKIP) {\n-            _filterContext = _filterContext.createChildObjectContext(_itemState, false);\n-            return;\n-        }\n-        if (_itemState == TokenFilter.FILTER_INCLUDE) {\n-            _filterContext = _filterContext.createChildArrayContext(_itemState, true);\n+        if (_itemFilter == null) {\n+            _filterContext = _filterContext.createChildObjectContext(_itemFilter, false);\n+            return;\n+        }\n+        if (_itemFilter == TokenFilter.INCLUDE_ALL) {\n+            _filterContext = _filterContext.createChildArrayContext(_itemFilter, true);\n             delegate.writeStartObject();\n             return;\n         }\n-        _itemState = filter.filterStartObject();\n-        if (_itemState == TokenFilter.FILTER_INCLUDE) {\n-            _checkParentPath();\n-            _filterContext = _filterContext.createChildObjectContext(_itemState, true);\n+        _itemFilter = _itemFilter.filterStartObject();\n+        if (_itemFilter == TokenFilter.INCLUDE_ALL) {\n+            _checkParentPath();\n+            _filterContext = _filterContext.createChildObjectContext(_itemFilter, true);\n             delegate.writeStartObject();\n         } else { // filter out\n-            _filterContext = _filterContext.createChildObjectContext(_itemState, false);\n-        }\n-        if (_itemState != TokenFilter.FILTER_SKIP) {\n+            _filterContext = _filterContext.createChildObjectContext(_itemFilter, false);\n+        }\n+        if (_itemFilter != null) {\n             _filterContext.markNeedsCloseCheck();\n         }\n     }\n     @Override\n     public void writeEndObject() throws IOException\n     {\n-        if (_filterContext.needsCloseToken()) {\n-            delegate.writeEndObject();\n-        }\n-        if (_filterContext.needsCloseCheck()) {\n-            filter.filterFinishObject();\n-        }\n-        _filterContext = _filterContext.getParent();\n+        _filterContext = _filterContext.closeObject(delegate);\n         if (_filterContext != null) {\n-            _itemState = _filterContext.getFilterState();\n+            _itemFilter = _filterContext.getFilterState();\n         }\n     }\n \n     @Override\n     public void writeFieldName(String name) throws IOException\n     {\n-        int state = _filterContext.setFieldName(name);\n-\n-//System.err.println(\"writeField '\"+name+\"', state = \"+state);\n-\n-        if (state == TokenFilter.FILTER_SKIP) {\n-            _itemState = state;\n-            return;\n-        }\n-        if (state == TokenFilter.FILTER_INCLUDE) {\n-            _itemState = state;\n+        TokenFilter state = _filterContext.setFieldName(name);\n+\n+System.err.println(\"writeField '\"+name+\"', state = \"+state);\n+\n+        if (state == null) {\n+            _itemFilter = null;\n+            return;\n+        }\n+        if (state == TokenFilter.INCLUDE_ALL) {\n+            _itemFilter = state;\n             delegate.writeFieldName(name);\n             return;\n         }\n \n-        state = filter.includeProperty(name);\n-\n-//System.err.println(\" -> include '\"+name+\"'? \"+state);\n+        state = _itemFilter.includeProperty(name);\n+\n+System.err.println(\" -> include '\"+name+\"'? \"+state);\n         \n-        _itemState = state;\n-        if (state == TokenFilter.FILTER_INCLUDE) {\n+        _itemFilter = state;\n+        if (state == TokenFilter.INCLUDE_ALL) {\n             _checkParentPath();\n         }\n     }\n     @Override\n     public void writeFieldName(SerializableString name) throws IOException\n     {\n-        int state = _filterContext.setFieldName(name.getValue());\n-        if (state == TokenFilter.FILTER_SKIP) {\n-            _itemState = state;\n-            return;\n-        }\n-        if (_itemState == TokenFilter.FILTER_INCLUDE) {\n-            _itemState = state;\n+        TokenFilter state = _filterContext.setFieldName(name.getValue());\n+        if (state == null) {\n+            _itemFilter = null;\n+            return;\n+        }\n+        if (_itemFilter == TokenFilter.INCLUDE_ALL) {\n+            _itemFilter = state;\n             delegate.writeFieldName(name);\n             return;\n         }\n-        state = filter.includeProperty(name.getValue());\n-        _itemState = state;\n-        if (state == TokenFilter.FILTER_INCLUDE) {\n+        state = _itemFilter.includeProperty(name.getValue());\n+        _itemFilter = state;\n+        if (state == TokenFilter.INCLUDE_ALL) {\n             _checkParentPath();\n         }\n     }\n     @Override\n     public void writeString(String value) throws IOException\n     {\n-        if (_itemState == TokenFilter.FILTER_SKIP) {\n-            return;\n-        }\n-        if (_itemState == TokenFilter.FILTER_CHECK) {\n-            int state = _filterContext.checkValue(filter);\n-            if (state == TokenFilter.FILTER_SKIP) {\n-                return;\n-            }\n-            if (state == TokenFilter.FILTER_CHECK) {\n-                if (!filter.includeString(value)) {\n+        if (_itemFilter == null) {\n+            return;\n+        }\n+        if (_itemFilter != TokenFilter.INCLUDE_ALL) {\n+            TokenFilter state = _filterContext.checkValue(_itemFilter);\n+            if (state == null) {\n+                return;\n+            }\n+            if (state != TokenFilter.INCLUDE_ALL) {\n+                if (!state.includeString(value)) {\n                     return;\n                 }\n             }\n             _checkParentPath();\n-            // one important thing: may need to write element name now\n+        } \n+        delegate.writeString(value);\n+    }\n+\n+    @Override\n+    public void writeString(char[] text, int offset, int len) throws IOException\n+    {\n+        if (_itemFilter == null) {\n+            return;\n+        }\n+        if (_itemFilter != TokenFilter.INCLUDE_ALL) {\n+            String value = new String(text, offset, len);\n+            TokenFilter state = _filterContext.checkValue(_itemFilter);\n+            if (state == null) {\n+                return;\n+            }\n+            if (state != TokenFilter.INCLUDE_ALL) {\n+                if (!state.includeString(value)) {\n+                    return;\n+                }\n+            }\n+            _checkParentPath();\n+        } \n+        delegate.writeString(text, offset, len);\n+    }\n+\n+    @Override\n+    public void writeString(SerializableString value) throws IOException\n+    {\n+        if (_itemFilter == null) {\n+            return;\n+        }\n+        if (_itemFilter != TokenFilter.INCLUDE_ALL) {\n+            TokenFilter state = _filterContext.checkValue(_itemFilter);\n+            if (state == null) {\n+                return;\n+            }\n+            if (state != TokenFilter.INCLUDE_ALL) {\n+                if (!state.includeString(value.getValue())) {\n+                    return;\n+                }\n+            }\n+            _checkParentPath();\n+        } \n+        delegate.writeString(value);\n+    }\n+\n+    @Override\n+    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException\n+    {\n+        if (_checkRawValueWrite()) {\n+            delegate.writeRawUTF8String(text, offset, length);\n+        }\n+    }\n+\n+    @Override\n+    public void writeUTF8String(byte[] text, int offset, int length) throws IOException\n+    {\n+        // not exact match, but best we can do\n+        if (_checkRawValueWrite()) {\n+            delegate.writeRawUTF8String(text, offset, length);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, binary/raw content\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeRaw(String text) throws IOException\n+    {\n+        if (_checkRawValueWrite()) {\n+            delegate.writeRaw(text);\n+        }\n+    }\n+\n+    @Override\n+    public void writeRaw(String text, int offset, int len) throws IOException\n+    {\n+        if (_checkRawValueWrite()) {\n+            delegate.writeRaw(text);\n+        }\n+    }\n+\n+    @Override\n+    public void writeRaw(SerializableString text) throws IOException\n+    {\n+        if (_checkRawValueWrite()) {\n+            delegate.writeRaw(text);\n+        }\n+    }\n+\n+    @Override\n+    public void writeRaw(char[] text, int offset, int len) throws IOException\n+    {\n+        if (_checkRawValueWrite()) {\n+            delegate.writeRaw(text, offset, len);\n+        }\n+    }\n+\n+    @Override\n+    public void writeRaw(char c) throws IOException\n+    {\n+        if (_checkRawValueWrite()) {\n+            delegate.writeRaw(c);\n+        }\n+    }\n+\n+    @Override\n+    public void writeRawValue(String text) throws IOException\n+    {\n+        if (_checkRawValueWrite()) {\n+            delegate.writeRaw(text);\n+        }\n+    }\n+\n+    @Override\n+    public void writeRawValue(String text, int offset, int len) throws IOException\n+    {\n+        if (_checkRawValueWrite()) {\n+            delegate.writeRaw(text, offset, len);\n+        }\n+    }\n+\n+    @Override\n+    public void writeRawValue(char[] text, int offset, int len) throws IOException\n+    {\n+        if (_checkRawValueWrite()) {\n+            delegate.writeRaw(text, offset, len);\n+        }\n+    }\n+\n+    @Override\n+    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException\n+    {\n+        if (_checkBinaryWrite()) {\n+            delegate.writeBinary(b64variant, data, offset, len);\n+        }\n+    }\n+\n+    @Override\n+    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException\n+    {\n+        if (_checkBinaryWrite()) {\n+            return delegate.writeBinary(b64variant, data, dataLength);\n+        }\n+        return -1;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, write methods, other value types\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeNumber(short v) throws IOException\n+    {\n+        if (_itemFilter == null) {\n+            return;\n+        }\n+        if (_itemFilter != TokenFilter.INCLUDE_ALL) {\n+            if (!_itemFilter.includeNumber(v)) { // close enough?\n+                return;\n+            }\n+            _checkParentPath();\n+        } \n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(int v) throws IOException\n+    {\n+System.err.println(\"WriteNumber(\"+v+\"), state == \"+_itemFilter);        \n+        if (_itemFilter == null) {\n+            return;\n+        }\n+        if (_itemFilter != TokenFilter.INCLUDE_ALL) {\n+            if (!_itemFilter.includeNumber(v)) { // close enough?\n+                return;\n+            }\n+            _checkParentPath();\n+        } \n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(long v) throws IOException\n+    {\n+        if (_itemFilter == null) {\n+            return;\n+        }\n+        if (_itemFilter != TokenFilter.INCLUDE_ALL) {\n+            if (!_itemFilter.includeNumber(v)) { // close enough?\n+                return;\n+            }\n+            _checkParentPath();\n+        } \n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(BigInteger v) throws IOException\n+    {\n+        if (_itemFilter == null) {\n+            return;\n+        }\n+        if (_itemFilter != TokenFilter.INCLUDE_ALL) {\n+            if (!_itemFilter.includeNumber(v)) { // close enough?\n+                return;\n+            }\n+            _checkParentPath();\n+        } \n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(double v) throws IOException\n+    {\n+        if (_itemFilter == null) {\n+            return;\n+        }\n+        if (_itemFilter != TokenFilter.INCLUDE_ALL) {\n+            if (!_itemFilter.includeNumber(v)) { // close enough?\n+                return;\n+            }\n+            _checkParentPath();\n+        } \n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(float v) throws IOException\n+    {\n+        if (_itemFilter == null) {\n+            return;\n+        }\n+        if (_itemFilter != TokenFilter.INCLUDE_ALL) {\n+            if (!_itemFilter.includeNumber(v)) { // close enough?\n+                return;\n+            }\n+            _checkParentPath();\n+        } \n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(BigDecimal v) throws IOException\n+    {\n+        if (_itemFilter == null) {\n+            return;\n+        }\n+        if (_itemFilter != TokenFilter.INCLUDE_ALL) {\n+            if (!_itemFilter.includeNumber(v)) { // close enough?\n+                return;\n+            }\n+            _checkParentPath();\n+        } \n+        delegate.writeNumber(v);\n+    }\n+\n+    @Override\n+    public void writeNumber(String encodedValue) throws IOException, UnsupportedOperationException\n+    {\n+        if (_itemFilter == null) {\n+            return;\n+        }\n+        if (_itemFilter != TokenFilter.INCLUDE_ALL) {\n+            if (!_itemFilter.includeRawValue()) { // close enough?\n+                return;\n+            }\n+            _checkParentPath();\n+        } \n+        delegate.writeNumber(encodedValue);\n+    }\n+\n+    @Override\n+    public void writeBoolean(boolean v) throws IOException\n+    {\n+        if (_itemFilter == null) {\n+            return;\n+        }\n+        if (_itemFilter != TokenFilter.INCLUDE_ALL) {\n+            if (!_itemFilter.includeBoolean(v)) { // close enough?\n+                return;\n+            }\n+            _checkParentPath();\n             /*\n             if (_filterContext.inObject()) {\n                 delegate.writeFieldName(_filterContext.getCurrentName());\n             }\n             */\n         } \n-        delegate.writeString(value);\n-    }\n-\n-    @Override\n-    public void writeString(char[] text, int offset, int len) throws IOException\n-    {\n-        if (_itemState == TokenFilter.FILTER_SKIP) {\n-            return;\n-        }\n-        if (_itemState == TokenFilter.FILTER_CHECK) {\n-            String value = new String(text, offset, len);\n-            int state = _filterContext.checkValue(filter);\n-            if (state == TokenFilter.FILTER_SKIP) {\n-                return;\n-            }\n-            if (state == TokenFilter.FILTER_CHECK) {\n-                if (!filter.includeString(value)) {\n-                    return;\n-                }\n-            }\n-            _checkParentPath();\n-            /*\n-            if (_filterContext.inObject()) {\n-                delegate.writeFieldName(_filterContext.getCurrentName());\n-            }\n-            */\n-        } \n-        delegate.writeString(text, offset, len);\n-    }\n-\n-    @Override\n-    public void writeString(SerializableString value) throws IOException\n-    {\n-        if (_itemState == TokenFilter.FILTER_SKIP) {\n-            return;\n-        }\n-        if (_itemState == TokenFilter.FILTER_CHECK) {\n-            int state = _filterContext.checkValue(filter);\n-            if (state == TokenFilter.FILTER_SKIP) {\n-                return;\n-            }\n-            if (state == TokenFilter.FILTER_CHECK) {\n-                if (!filter.includeString(value.getValue())) {\n-                    return;\n-                }\n-            }\n-            _checkParentPath();\n-            /*\n-            if (_filterContext.inObject()) {\n-                delegate.writeFieldName(_filterContext.getCurrentName());\n-            }\n-            */\n-        } \n-        delegate.writeString(value);\n-    }\n-\n-    @Override\n-    public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException\n-    {\n-        if (_checkRawValueWrite()) {\n-            delegate.writeRawUTF8String(text, offset, length);\n-        }\n-    }\n-\n-    @Override\n-    public void writeUTF8String(byte[] text, int offset, int length) throws IOException\n-    {\n-        // not exact match, but best we can do\n-        if (_checkRawValueWrite()) {\n-            delegate.writeRawUTF8String(text, offset, length);\n-        }\n-    }\n-\n-    /*\n-    /**********************************************************\n-    /* Public API, write methods, binary/raw content\n-    /**********************************************************\n-     */\n-\n-    @Override\n-    public void writeRaw(String text) throws IOException\n-    {\n-        if (_checkRawValueWrite()) {\n-            delegate.writeRaw(text);\n-        }\n-    }\n-\n-    @Override\n-    public void writeRaw(String text, int offset, int len) throws IOException\n-    {\n-        if (_checkRawValueWrite()) {\n-            delegate.writeRaw(text);\n-        }\n-    }\n-\n-    @Override\n-    public void writeRaw(SerializableString text) throws IOException\n-    {\n-        if (_checkRawValueWrite()) {\n-            delegate.writeRaw(text);\n-        }\n-    }\n-\n-    @Override\n-    public void writeRaw(char[] text, int offset, int len) throws IOException\n-    {\n-        if (_checkRawValueWrite()) {\n-            delegate.writeRaw(text, offset, len);\n-        }\n-    }\n-\n-    @Override\n-    public void writeRaw(char c) throws IOException\n-    {\n-        if (_checkRawValueWrite()) {\n-            delegate.writeRaw(c);\n-        }\n-    }\n-\n-    @Override\n-    public void writeRawValue(String text) throws IOException\n-    {\n-        if (_checkRawValueWrite()) {\n-            delegate.writeRaw(text);\n-        }\n-    }\n-\n-    @Override\n-    public void writeRawValue(String text, int offset, int len) throws IOException\n-    {\n-        if (_checkRawValueWrite()) {\n-            delegate.writeRaw(text, offset, len);\n-        }\n-    }\n-\n-    @Override\n-    public void writeRawValue(char[] text, int offset, int len) throws IOException\n-    {\n-        if (_checkRawValueWrite()) {\n-            delegate.writeRaw(text, offset, len);\n-        }\n-    }\n-\n-    @Override\n-    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException\n-    {\n-        if (_checkBinaryWrite()) {\n-            delegate.writeBinary(b64variant, data, offset, len);\n-        }\n-    }\n-\n-    @Override\n-    public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException\n-    {\n-        if (_checkBinaryWrite()) {\n-            return delegate.writeBinary(b64variant, data, dataLength);\n-        }\n-        return -1;\n-    }\n-\n-    /*\n-    /**********************************************************\n-    /* Public API, write methods, other value types\n-    /**********************************************************\n-     */\n-\n-    @Override\n-    public void writeNumber(short v) throws IOException\n-    {\n-        if (_itemState == TokenFilter.FILTER_SKIP) {\n-            return;\n-        }\n-        if (_itemState == TokenFilter.FILTER_CHECK) {\n-            if (!filter.includeNumber(v)) { // close enough?\n-                return;\n-            }\n-            _checkParentPath();\n-            /*\n-            if (_filterContext.inObject()) {\n-                delegate.writeFieldName(_filterContext.getCurrentName());\n-            }\n-            */\n-        } \n-        delegate.writeNumber(v);\n-    }\n-\n-    @Override\n-    public void writeNumber(int v) throws IOException\n-    {\n-//System.err.println(\"WriteNumber(\"+v+\"), state == \"+_itemState);        \n-        if (_itemState == TokenFilter.FILTER_SKIP) {\n-            return;\n-        }\n-        if (_itemState == TokenFilter.FILTER_CHECK) {\n-            if (!filter.includeNumber(v)) { // close enough?\n-                return;\n-            }\n-            _checkParentPath();\n-            /*\n-            if (_filterContext.inObject()) {\n-                delegate.writeFieldName(_filterContext.getCurrentName());\n-            }\n-            */\n-        } \n-        delegate.writeNumber(v);\n-    }\n-\n-    @Override\n-    public void writeNumber(long v) throws IOException\n-    {\n-        if (_itemState == TokenFilter.FILTER_SKIP) {\n-            return;\n-        }\n-        if (_itemState == TokenFilter.FILTER_CHECK) {\n-            if (!filter.includeNumber(v)) { // close enough?\n-                return;\n-            }\n-            _checkParentPath();\n-            /*\n-            if (_filterContext.inObject()) {\n-                delegate.writeFieldName(_filterContext.getCurrentName());\n-            }\n-            */\n-        } \n-        delegate.writeNumber(v);\n-    }\n-\n-    @Override\n-    public void writeNumber(BigInteger v) throws IOException\n-    {\n-        if (_itemState == TokenFilter.FILTER_SKIP) {\n-            return;\n-        }\n-        if (_itemState == TokenFilter.FILTER_CHECK) {\n-            if (!filter.includeNumber(v)) { // close enough?\n-                return;\n-            }\n-            _checkParentPath();\n-            /*\n-            if (_filterContext.inObject()) {\n-                delegate.writeFieldName(_filterContext.getCurrentName());\n-            }\n-            */\n-        } \n-        delegate.writeNumber(v);\n-    }\n-\n-    @Override\n-    public void writeNumber(double v) throws IOException\n-    {\n-        if (_itemState == TokenFilter.FILTER_SKIP) {\n-            return;\n-        }\n-        if (_itemState == TokenFilter.FILTER_CHECK) {\n-            if (!filter.includeNumber(v)) { // close enough?\n-                return;\n-            }\n-            _checkParentPath();\n-            /*\n-            if (_filterContext.inObject()) {\n-                delegate.writeFieldName(_filterContext.getCurrentName());\n-            }\n-            */\n-        } \n-        delegate.writeNumber(v);\n-    }\n-\n-    @Override\n-    public void writeNumber(float v) throws IOException\n-    {\n-        if (_itemState == TokenFilter.FILTER_SKIP) {\n-            return;\n-        }\n-        if (_itemState == TokenFilter.FILTER_CHECK) {\n-            if (!filter.includeNumber(v)) { // close enough?\n-                return;\n-            }\n-            _checkParentPath();\n-            /*\n-            if (_filterContext.inObject()) {\n-                delegate.writeFieldName(_filterContext.getCurrentName());\n-            }\n-            */\n-        } \n-        delegate.writeNumber(v);\n-    }\n-\n-    @Override\n-    public void writeNumber(BigDecimal v) throws IOException\n-    {\n-        if (_itemState == TokenFilter.FILTER_SKIP) {\n-            return;\n-        }\n-        if (_itemState == TokenFilter.FILTER_CHECK) {\n-            if (!filter.includeNumber(v)) { // close enough?\n-                return;\n-            }\n-            _checkParentPath();\n-            /*\n-            if (_filterContext.inObject()) {\n-                delegate.writeFieldName(_filterContext.getCurrentName());\n-            }\n-            */\n-        } \n-        delegate.writeNumber(v);\n-    }\n-\n-    @Override\n-    public void writeNumber(String encodedValue) throws IOException, UnsupportedOperationException\n-    {\n-        if (_itemState == TokenFilter.FILTER_SKIP) {\n-            return;\n-        }\n-        if (_itemState == TokenFilter.FILTER_CHECK) {\n-            if (!filter.includeRawValue()) { // close enough?\n-                return;\n-            }\n-            _checkParentPath();\n-            /*\n-            if (_filterContext.inObject()) {\n-                delegate.writeFieldName(_filterContext.getCurrentName());\n-            }\n-            */\n-        } \n-        delegate.writeNumber(encodedValue);\n-    }\n-\n-    @Override\n-    public void writeBoolean(boolean v) throws IOException\n-    {\n-        if (_itemState == TokenFilter.FILTER_SKIP) {\n-            return;\n-        }\n-        if (_itemState == TokenFilter.FILTER_CHECK) {\n-            if (!filter.includeBoolean(v)) { // close enough?\n-                return;\n-            }\n-            _checkParentPath();\n-            /*\n-            if (_filterContext.inObject()) {\n-                delegate.writeFieldName(_filterContext.getCurrentName());\n-            }\n-            */\n-        } \n         delegate.writeBoolean(v);\n     }\n \n     @Override\n     public void writeNull() throws IOException\n     {\n-        if (_itemState == TokenFilter.FILTER_SKIP) {\n-            return;\n-        }\n-        if (_itemState == TokenFilter.FILTER_CHECK) {\n-            if (!filter.includeNull()) { // close enough?\n-                return;\n-            }\n-            _checkParentPath();\n-            /*\n-            if (_filterContext.inObject()) {\n-                delegate.writeFieldName(_filterContext.getCurrentName());\n-            }\n-            */\n+        if (_itemFilter == null) {\n+            return;\n+        }\n+        if (_itemFilter != TokenFilter.INCLUDE_ALL) {\n+            if (!_itemFilter.includeNull()) { // close enough?\n+                return;\n+            }\n+            _checkParentPath();\n         } \n         delegate.writeNull();\n     }\n     @Override\n     public void writeOmittedField(String fieldName) throws IOException {\n         // Hmmh. Not sure how this would work but...\n-        if (_itemState != TokenFilter.FILTER_SKIP) {\n+        if (_itemFilter != null) {\n             return;\n         }\n         delegate.writeOmittedField(fieldName);\n     \n     @Override\n     public void writeObjectId(Object id) throws IOException {\n-        if (_itemState != TokenFilter.FILTER_SKIP) {\n+        if (_itemFilter != null) {\n             delegate.writeObjectId(id);\n         }\n     }\n \n     @Override\n     public void writeObjectRef(Object id) throws IOException {\n-        if (_itemState != TokenFilter.FILTER_SKIP) {\n+        if (_itemFilter != null) {\n             delegate.writeObjectRef(id);\n         }\n     }\n     \n     @Override\n     public void writeTypeId(Object id) throws IOException {\n-        if (_itemState != TokenFilter.FILTER_SKIP) {\n+        if (_itemFilter != null) {\n             delegate.writeTypeId(id);\n         }\n     }\n \n     protected boolean _checkBinaryWrite() throws IOException\n     {\n-        if (_itemState == TokenFilter.FILTER_SKIP) {\n+        if (_itemFilter == null) {\n             return false;\n         }\n-        if (_itemState == TokenFilter.FILTER_INCLUDE) {\n+        if (_itemFilter == TokenFilter.INCLUDE_ALL) {\n             return true;\n         }\n-        if (filter.includeBinary()) { // close enough?\n-            _checkParentPath();\n-            /*\n-            if (_filterContext.inObject()) {\n-                delegate.writeFieldName(_filterContext.getCurrentName());\n-            }\n-            */\n+        if (_itemFilter.includeBinary()) { // close enough?\n+            _checkParentPath();\n             return true;\n         }\n         return false;\n     \n     protected boolean _checkRawValueWrite() throws IOException\n     {\n-        if (_itemState == TokenFilter.FILTER_SKIP) {\n+        if (_itemFilter == null) {\n             return false;\n         }\n-        if (_itemState == TokenFilter.FILTER_INCLUDE) {\n+        if (_itemFilter == TokenFilter.INCLUDE_ALL) {\n             return true;\n         }\n-        if (filter.includeRawValue()) { // close enough?\n-            _checkParentPath();\n-            /*\n-            if (_filterContext.inObject()) {\n-                delegate.writeFieldName(_filterContext.getCurrentName());\n-            }\n-            */\n+        if (_itemFilter.includeRawValue()) { // close enough?\n+            _checkParentPath();\n             return true;\n         }\n         return false;\n--- a/src/main/java/com/fasterxml/jackson/core/filter/TokenFilter.java\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/TokenFilter.java\n \n import java.math.BigDecimal;\n import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n \n /**\n  * Strategy class that can be implemented to specify actual inclusion/exclusion\n  *\n  * @since 2.6\n  */\n-public abstract class TokenFilter\n+public class TokenFilter\n {\n     // Constants\n \n      */\n     public final static int FILTER_INCLUDE = 3;\n \n-\n-    // API, container values\n-\n-    public int filterStartObject() {\n-        return FILTER_CHECK;\n-    }\n-\n-    public int filterStartArray() {\n-        return FILTER_CHECK;\n+    // // Marker values\n+\n+    /**\n+     * Marker value that should be used to indicate inclusion of a structured\n+     * value (sub-tree representing Object or Array), or value of a named\n+     * property (regardless of type).\n+     */\n+    public final static TokenFilter INCLUDE_ALL = new TokenFilter();\n+\n+    // Life-cycle\n+\n+    protected TokenFilter() { }\n+\n+    /*\n+    /**********************************************************\n+    /* API, structured values\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to check whether Object value at current output\n+     * location should be included in output.\n+     * Three kinds of return values may be used as follows:\n+     *<ul>\n+     * <li><code>null</code> to indicate that the Object should be skipped\n+     *   </li>\n+     * <li>{@link #INCLUDE_ALL} to indicate that the Object should be included\n+     * completely in output\n+     *   </li>\n+     * <li>Any other {@link TokenFilter} implementation (possibly this one) to mean\n+     *  that further inclusion calls on return filter object need to be made\n+     *  on contained properties, as necessary. {@link #filterFinishObject()} will\n+     *  also be called on returned filter object\n+     *   </li>\n+     * </ul>\n+     *<p>\n+     * The default implementation simply returns <code>this</code> to continue calling\n+     * methods on this filter object, without full inclusion or exclusion.\n+     * \n+     * @return TokenFilter to use for further calls within Array, unless return value\n+     *   is <code>null</code> or {@link #INCLUDE_ALL} (which have simpler semantics)\n+     */\n+    public TokenFilter filterStartObject() {\n+        return this;\n+    }\n+\n+    /**\n+     * Method called to check whether Array value at current output\n+     * location should be included in output.\n+     * Three kinds of return values may be used as follows:\n+     *<ul>\n+     * <li><code>null</code> to indicate that the Array should be skipped\n+     *   </li>\n+     * <li>{@link #INCLUDE_ALL} to indicate that the Array should be included\n+     * completely in output\n+     *   </li>\n+     * <li>Any other {@link TokenFilter} implementation (possibly this one) to mean\n+     *  that further inclusion calls on return filter object need to be made\n+     *  on contained element values, as necessary. {@link #filterFinishArray()} will\n+     *  also be called on returned filter object\n+     *   </li>\n+     * </ul>\n+     * \n+     * @return TokenFilter to use for further calls within Array, unless return value\n+     *   is <code>null</code> or {@link #INCLUDE_ALL} (which have simpler semantics)\n+     */\n+    public TokenFilter filterStartArray() {\n+        return this;\n+    }\n+\n+    /**\n+     * Method called to indicate that output of non-filtered Object (one that may\n+     * have been included either completely, or in part) is completed.\n+     * This occurs when {@link JsonGenerator#writeEndObject()} is called.\n+     */\n+    public void filterFinishObject() { }\n+\n+    /**\n+     * Method called to indicate that output of non-filtered Array (one that may\n+     * have been included either completely, or in part) is completed.\n+     * This occurs when {@link JsonGenerator#writeEndArray()} is called.\n+     */\n+    public void filterFinishArray() { }\n+\n+    /*\n+    /**********************************************************\n+    /* API, properties/elements\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to check whether property value with specified name,\n+     * at current output location, should be included in output.\n+     * Three kinds of return values may be used as follows:\n+     *<ul>\n+     * <li><code>null</code> to indicate that the property and its value should be skipped\n+     *   </li>\n+     * <li>{@link #INCLUDE_ALL} to indicate that the property and its value should be included\n+     * completely in output\n+     *   </li>\n+     * <li>Any other {@link TokenFilter} implementation (possibly this one) to mean\n+     *  that further inclusion calls on returned filter object need to be made\n+     *  as necessary, to determine inclusion.\n+     *   </li>\n+     * </ul>\n+     *<p>\n+     * The default implementation simply returns <code>this</code> to continue calling\n+     * methods on this filter object, without full inclusion or exclusion.\n+     * \n+     * @return TokenFilter to use for further calls within property value, unless return value\n+     *   is <code>null</code> or {@link #INCLUDE_ALL} (which have simpler semantics)\n+     */\n+    public TokenFilter includeProperty(String name) {\n+        return this;\n+    }\n+\n+    /**\n+     * Method called to check whether array element with specified index (zero-based),\n+     * at current output location, should be included in output.\n+     * Three kinds of return values may be used as follows:\n+     *<ul>\n+     * <li><code>null</code> to indicate that the Array element should be skipped\n+     *   </li>\n+     * <li>{@link #INCLUDE_ALL} to indicate that the Array element should be included\n+     * completely in output\n+     *   </li>\n+     * <li>Any other {@link TokenFilter} implementation (possibly this one) to mean\n+     *  that further inclusion calls on returned filter object need to be made\n+     *  as necessary, to determine inclusion.\n+     *   </li>\n+     * </ul>\n+     *<p>\n+     * The default implementation simply returns <code>this</code> to continue calling\n+     * methods on this filter object, without full inclusion or exclusion.\n+     * \n+     * @return TokenFilter to use for further calls within element value, unless return value\n+     *   is <code>null</code> or {@link #INCLUDE_ALL} (which have simpler semantics)\n+     */\n+    public TokenFilter includeElement(int index) {\n+        return this;\n+    }\n+\n+    /**\n+     * Method called to check whether root-level value,\n+     * at current output location, should be included in output.\n+     * Three kinds of return values may be used as follows:\n+     *<ul>\n+     * <li><code>null</code> to indicate that the root value should be skipped\n+     *   </li>\n+     * <li>{@link #INCLUDE_ALL} to indicate that the root value should be included\n+     * completely in output\n+     *   </li>\n+     * <li>Any other {@link TokenFilter} implementation (possibly this one) to mean\n+     *  that further inclusion calls on returned filter object need to be made\n+     *  as necessary, to determine inclusion.\n+     *   </li>\n+     * </ul>\n+     *<p>\n+     * The default implementation simply returns <code>this</code> to continue calling\n+     * methods on this filter object, without full inclusion or exclusion.\n+     * \n+     * @return TokenFilter to use for further calls within root value, unless return value\n+     *   is <code>null</code> or {@link #INCLUDE_ALL} (which have simpler semantics)\n+     */\n+    public TokenFilter includeRootValue(int index) {\n+        return this;\n     }\n     \n-    public void filterFinishObject() { }\n-    public void filterFinishArray() { }\n-\n-    // API, properties/elements\n-\n-    /**\n-     * Called to see if Object property with specified name (of any type)\n-     * should be included or not\n-     */\n-    public int includeProperty(String name) {\n-        return FILTER_CHECK;\n-    }\n-\n-    /**\n-     * Called to see if Array element with specified index (of any type)\n-     * should be included or not\n-     */\n-    public int includeElement(int index) {\n-        return FILTER_CHECK;\n-    }\n-\n-    /**\n-     * Called to see if root value about to be written should be included or not\n-     */\n-    public int includeRootValue(int index) {\n-        return FILTER_CHECK;\n+    /*\n+    /**********************************************************\n+    /* API, scalas values\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Call made to verify whether leaf-level\n+     * boolean value\n+     * should be included in output or not.\n+     */\n+    public boolean includeBoolean(boolean value) {\n+        return _includeScalar();\n+    }\n+\n+    /**\n+     * Call made to verify whether leaf-level\n+     * null value\n+     * should be included in output or not.\n+     */\n+    public boolean includeNull() {\n+        return _includeScalar();\n+    }\n+\n+    /**\n+     * Call made to verify whether leaf-level\n+     * String value\n+     * should be included in output or not.\n+     */\n+    public boolean includeString(String value) {\n+        return _includeScalar();\n+    }\n+\n+    /**\n+     * Call made to verify whether leaf-level\n+     * <code>int</code> value\n+     * should be included in output or not.\n+     * \n+     * NOTE: also called for `short`, `byte`\n+     */\n+    public boolean includeNumber(int v) {\n+        return _includeScalar();\n+    }\n+\n+    /**\n+     * Call made to verify whether leaf-level\n+     * <code>long</code> value\n+     * should be included in output or not.\n+     */\n+    public boolean includeNumber(long v) {\n+        return _includeScalar();\n+    }\n+\n+    /**\n+     * Call made to verify whether leaf-level\n+     * <code>float</code> value\n+     * should be included in output or not.\n+     */\n+    public boolean includeNumber(float v) {\n+        return _includeScalar();\n+    }\n+\n+    /**\n+     * Call made to verify whether leaf-level\n+     * <code>double</code> value\n+     * should be included in output or not.\n+     */\n+    public boolean includeNumber(double v) {\n+        return _includeScalar();\n     }\n     \n-    // API, scalar\n-\n-    public boolean includeBoolean(boolean value) {\n-        return _includeScalar();\n-    }\n-\n-    public boolean includeNull() {\n-        return _includeScalar();\n-    }\n-\n-    public boolean includeString(String value) {\n-        return _includeScalar();\n-    }\n-\n-    /**\n-     * NOTE: also called for `short`, `byte`\n-     */\n-    public boolean includeNumber(int v) {\n-        return _includeScalar();\n-    }\n-\n-    public boolean includeNumber(long v) {\n-        return _includeScalar();\n-    }\n-\n-    public boolean includeNumber(float v) {\n-        return _includeScalar();\n-    }\n-\n-    public boolean includeNumber(double v) {\n-        return _includeScalar();\n-    }\n-    \n+    /**\n+     * Call made to verify whether leaf-level\n+     * {@link BigDecimal} value\n+     * should be included in output or not.\n+     */\n     public boolean includeNumber(BigDecimal v) {\n         return _includeScalar();\n     }\n \n+    /**\n+     * Call made to verify whether leaf-level\n+     * {@link BigInteger} value\n+     * should be included in output or not.\n+     */\n     public boolean includeNumber(BigInteger v) {\n         return _includeScalar();\n     }\n \n     /**\n-     * NOTE: no binary payload passed; assumption is this won't be of much\n-     * use.\n+     * Call made to verify whether leaf-level\n+     * Binary value\n+     * should be included in output or not.\n+     *<p>\n+     * NOTE: no binary payload passed; assumption is this won't be of much use.\n      */\n     public boolean includeBinary() {\n         return _includeScalar();\n     }\n \n     /**\n+     * Call made to verify whether leaf-level\n+     * raw (pre-encoded, not quoted by generator) value\n+     * should be included in output or not.\n+     *<p>\n      * NOTE: value itself not passed since it may come on multiple forms\n      * and is unlikely to be of much use in determining inclusion\n      * criteria.\n         return _includeScalar();\n     }\n     \n+    /**\n+     * Call made to verify whether leaf-level\n+     * embedded (Opaque) value\n+     * should be included in output or not.\n+     */\n     public boolean includeEmbeddedValue(Object ob) {\n         return _includeScalar();\n     }\n \n+    /*\n+    /**********************************************************\n+    /* Other methods\n+    /**********************************************************\n+     */\n+    \n     /**\n      * Overridable default implementation delegated to all scalar value\n      * inclusion check methods\n--- a/src/main/java/com/fasterxml/jackson/core/filter/TokenFilterContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/TokenFilterContext.java\n     protected String _currentName;\n \n     /**\n-     * State of this context.\n-     */\n-    protected int _filterState;\n+     * Filter to use for items in this state (for properties of Objects,\n+     * elements of Arrays, and root-level values of root context)\n+     */\n+    protected TokenFilter _filter;\n \n     /**\n      * Flag that indicates that start token has been written, so\n      */\n \n     protected TokenFilterContext(int type, TokenFilterContext parent,\n-            int fstate, boolean startWritten)\n+            TokenFilter filter, boolean startWritten)\n     {\n         super();\n         _type = type;\n         _parent = parent;\n-        _filterState = fstate;\n+        _filter = filter;\n         _index = -1;\n         _startWritten = false;\n     }\n \n     protected TokenFilterContext reset(int type,\n-            int fstate, boolean startWritten)\n+            TokenFilter filter, boolean startWritten)\n     {\n         _type = type;\n-        _filterState = fstate;\n+        _filter = filter;\n         _index = -1;\n         _currentName = null;\n         _startWritten = startWritten;\n     /**********************************************************\n      */\n \n-    public static TokenFilterContext createRootContext(int fstate) {\n-        return new TokenFilterContext(TYPE_ROOT, null, fstate, false);\n-    }\n-\n-    public TokenFilterContext createChildArrayContext(int fstate, boolean writeStart) {\n+    public static TokenFilterContext createRootContext(TokenFilter filter) {\n+        return new TokenFilterContext(TYPE_ROOT, null, filter, false);\n+    }\n+\n+    public TokenFilterContext createChildArrayContext(TokenFilter filter, boolean writeStart) {\n         TokenFilterContext ctxt = _child;\n         if (ctxt == null) {\n-            _child = ctxt = new TokenFilterContext(TYPE_ARRAY, this, fstate, writeStart);\n+            _child = ctxt = new TokenFilterContext(TYPE_ARRAY, this, filter, writeStart);\n             return ctxt;\n         }\n-        return ctxt.reset(TYPE_ARRAY, fstate, writeStart);\n-    }\n-\n-    public TokenFilterContext createChildObjectContext(int fstate, boolean writeStart) {\n+        return ctxt.reset(TYPE_ARRAY, filter, writeStart);\n+    }\n+\n+    public TokenFilterContext createChildObjectContext(TokenFilter filter, boolean writeStart) {\n         TokenFilterContext ctxt = _child;\n         if (ctxt == null) {\n-            _child = ctxt = new TokenFilterContext(TYPE_OBJECT, this, fstate, writeStart);\n+            _child = ctxt = new TokenFilterContext(TYPE_OBJECT, this, filter, writeStart);\n             return ctxt;\n         }\n-        return ctxt.reset(TYPE_OBJECT, fstate, writeStart);\n+        return ctxt.reset(TYPE_OBJECT, filter, writeStart);\n     }\n \n     /*\n     /**********************************************************\n      */\n     \n-    public int setFieldName(String name) throws JsonProcessingException {\n+    public TokenFilter setFieldName(String name) throws JsonProcessingException {\n         _currentName = name;\n-        return _filterState;\n+        return _filter;\n     }\n \n     /**\n      * Method called to check whether value is to be included at current output\n      * position, either as Object property, Array element, or root value.\n      */\n-    public int checkValue(TokenFilter filter) {\n+    public TokenFilter checkValue(TokenFilter filter) {\n         // First, checks for Object properties have been made earlier:\n         if (_type == TYPE_OBJECT) {\n-            return TokenFilter.FILTER_CHECK;\n+            return filter;\n         }\n         int ix = ++_index;\n         if (_type == TYPE_ARRAY) {\n      */\n     public void writePath(JsonGenerator gen) throws IOException\n     {\n-        if (_filterState != TokenFilter.FILTER_CHECK) {\n+        if ((_filter == null) || (_filter == TokenFilter.INCLUDE_ALL)) {\n             return;\n         }\n //System.err.println(\"writePath(), startWritten? \"+_startWritten+\" at \"+toString());\n     private void _writePath(JsonGenerator gen) throws IOException\n     {\n //System.err.println(\"_writePath(), startWritten? \"+_startWritten+\" at \"+toString());\n-        if (_filterState != TokenFilter.FILTER_CHECK) {\n+        if ((_filter == null) || (_filter == TokenFilter.INCLUDE_ALL)) {\n             return;\n         }\n         if (_parent != null) {\n         if (!_startWritten) {\n             _startWritten = true;\n             if (_type == TYPE_OBJECT) {\n-System.err.println(\" write object start, field '\"+_currentName+\"'\");                \n+//System.err.println(\" write object start, field '\"+_currentName+\"'\");                \n                 gen.writeStartObject();\n                 gen.writeFieldName(_currentName);\n             } else if (_type == TYPE_ARRAY) {\n     }\n     \n     public void skipParentChecks() {\n-        _filterState = TokenFilter.FILTER_SKIP;\n+        _filter = null;\n         for (TokenFilterContext ctxt = _parent; ctxt != null; ctxt = ctxt._parent) {\n-            _parent._filterState = TokenFilter.FILTER_SKIP;\n+            _parent._filter = null;\n         }\n     }\n \n     @Override public final TokenFilterContext getParent() { return _parent; }\n     @Override public final String getCurrentName() { return _currentName; }\n \n-    public int getFilterState() { return _filterState; }\n-    public boolean needsCloseToken() { return _startWritten; }\n+    public TokenFilter getFilterState() { return _filter; }\n \n     public void markNeedsCloseCheck() { _needCloseCheck = true; }\n-    public boolean needsCloseCheck() { return _needCloseCheck; }\n-    \n+\n+    public final TokenFilterContext closeArray(JsonGenerator gen) throws IOException\n+    {\n+        if (_startWritten) {\n+            gen.writeEndArray();\n+        }\n+        if ((_filter != null) && (_filter != TokenFilter.INCLUDE_ALL)) {\n+            _filter.filterFinishArray();\n+        }\n+        return _parent;\n+    }\n+    \n+    public final TokenFilterContext closeObject(JsonGenerator gen) throws IOException\n+    {\n+        if (_startWritten) {\n+            gen.writeEndObject();\n+        }\n+        if ((_filter != null) && (_filter != TokenFilter.INCLUDE_ALL)) {\n+            _filter.filterFinishObject();\n+        }\n+        return _parent;\n+    }\n+\n     // // // Internally used abstract methods\n \n     protected void appendDesc(StringBuilder sb) {\n--- a/src/test/java/com/fasterxml/jackson/core/filter/BasicFilteringTest.java\n+++ b/src/test/java/com/fasterxml/jackson/core/filter/BasicFilteringTest.java\n         public NameMatchFilter(String n) { _name = n; }\n         \n         @Override\n-        public int includeProperty(String name) {\n+        public TokenFilter includeProperty(String name) {\n             if (name.equals(_name)) {\n //System.err.println(\"Include? \"+name+\" -> true\");\n-                return TokenFilter.FILTER_INCLUDE;\n+                return TokenFilter.INCLUDE_ALL;\n             }\n //System.err.println(\"Include? \"+name+\" -> false\");\n-            return TokenFilter.FILTER_CHECK;\n+            return this;\n         }\n     }\n ", "timestamp": 1428385766, "metainfo": ""}