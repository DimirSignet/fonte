{"sha": "cb93db34555c6d00301d2cb599d1f05a7fe6205c", "log": "Improve unit test coverage", "commit": "\n--- a/src/test/java/com/fasterxml/jackson/core/filter/BasicGeneratorFilteringTest.java\n+++ b/src/test/java/com/fasterxml/jackson/core/filter/BasicGeneratorFilteringTest.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.io.SerializedString;\n \n /**\n  * Low-level tests for explicit, hand-written tests for generator-side\n     public void testSingleMatchFilteringWithPath() throws Exception\n     {\n         StringWriter w = new StringWriter();\n-        JsonGenerator gen = new FilteringGeneratorDelegate(JSON_F.createGenerator(w),\n+        JsonGenerator origGen = JSON_F.createGenerator(w);\n+        NameMatchFilter filter = new NameMatchFilter(\"value\");\n+        FilteringGeneratorDelegate gen = new FilteringGeneratorDelegate(origGen,\n+                filter,\n+                true, // includePath\n+                false // multipleMatches\n+                );\n+\n+        // Hmmh. Should we get access to eventual target?\n+        assertSame(w, gen.getOutputTarget());\n+        assertNotNull(gen.getFilterContext());\n+        assertSame(filter, gen.getFilter());\n+\n+        final String JSON = \"{'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}\";\n+        writeJsonDoc(JSON_F, JSON, gen);\n+        assertEquals(aposToQuotes(\"{'ob':{'value':3}}\"), w.toString());\n+\n+        assertEquals(1, gen.getMatchCount());\n+    }\n+\n+    // Alternative take, using slightly different calls for FIELD_NAME, START_ARRAY\n+    public void testSingleMatchFilteringWithPathAlternate() throws Exception\n+    {\n+        StringWriter w = new StringWriter();\n+        FilteringGeneratorDelegate gen = new FilteringGeneratorDelegate(JSON_F.createGenerator(w),\n                 new NameMatchFilter(\"value\"),\n                 true, // includePath\n                 false // multipleMatches\n                 );\n-        final String JSON = \"{'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}\";\n-        writeJsonDoc(JSON_F, JSON, gen);\n+        //final String JSON = \"{'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':'foo'},'b':true}\";\n+\n+        gen.writeStartObject();\n+        gen.writeFieldName(new SerializedString(\"a\"));\n+        gen.writeNumber(123);\n+\n+        gen.writeFieldName(\"array\");\n+        gen.writeStartArray(2);\n+        gen.writeNumber(\"1\");\n+        gen.writeNumber(2);\n+        gen.writeEndArray();\n+\n+        gen.writeFieldName(new SerializedString(\"ob\"));\n+        gen.writeStartObject();\n+        gen.writeNumberField(\"value0\", 2);\n+        gen.writeFieldName(new SerializedString(\"value\"));\n+        gen.writeNumber(3); // just to vary generation method\n+        gen.writeStringField(\"value2\", \"foo\");\n+\n+        gen.writeEndObject();\n+\n+        gen.writeBooleanField(\"b\", true);\n+        \n+        gen.writeEndObject();\n+        gen.close();\n+\n         assertEquals(aposToQuotes(\"{'ob':{'value':3}}\"), w.toString());\n     }\n-\n+    \n     public void testMultipleMatchFilteringWithPath1() throws Exception\n     {\n         StringWriter w = new StringWriter();\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/io/SegmentedStringWriterTest.java\n+package com.fasterxml.jackson.core.io;\n+\n+import com.fasterxml.jackson.core.io.SegmentedStringWriter;\n+import com.fasterxml.jackson.core.util.BufferRecycler;\n+\n+public class SegmentedStringWriterTest\n+    extends com.fasterxml.jackson.core.BaseTest\n+{\n+    public void testSimple() throws Exception\n+    {\n+        BufferRecycler br = new BufferRecycler();\n+        SegmentedStringWriter w = new SegmentedStringWriter(br);\n+\n+        StringBuilder exp = new StringBuilder();\n+\n+        for (int i = 0; exp.length() < 100; ++i) {\n+            String nr = String.valueOf(i);\n+            exp.append(' ').append(nr);\n+            w.append(' ');\n+            switch (i % 4) {\n+            case 0:\n+                w.append(nr);\n+                break;\n+            case 1:\n+                {\n+                    String str = \"  \"+nr;\n+                    w.append(str, 2, str.length());\n+                }\n+                break;\n+            case 2:\n+                w.write(nr.toCharArray());\n+                break;\n+            default:\n+                {\n+                    char[] ch = (\" \"+nr+\" \").toCharArray();\n+                    w.write(ch, 1, nr.length());\n+                }\n+                break;\n+            }\n+        }\n+        // flush, close are nops but trigger just for fun\n+        w.flush();\n+        w.close();\n+\n+        String act = w.getAndClear();\n+        assertEquals(exp.toString(), act);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/io/UTF8WriterTest.java\n+package com.fasterxml.jackson.core.io;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.io.IOContext;\n+import com.fasterxml.jackson.core.io.UTF8Writer;\n+import com.fasterxml.jackson.core.util.BufferRecycler;\n+\n+public class UTF8WriterTest\n+    extends com.fasterxml.jackson.core.BaseTest\n+{\n+    public void testSimple() throws Exception\n+    {\n+        BufferRecycler rec = new BufferRecycler();\n+        IOContext ctxt = new IOContext(rec, null, false);\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        UTF8Writer w = new UTF8Writer(ctxt, out);\n+\n+        String str = \"AB\\u00A0\\u1AE9\\uFFFC\";\n+        char[] ch = str.toCharArray();\n+\n+        // Let's write 3 times, using different methods\n+        w.write(str);\n+\n+        w.append(ch[0]);\n+        w.write(ch[1]);\n+        w.write(ch, 2, 3);\n+        w.flush();\n+\n+        w.write(str, 0, str.length());\n+        w.close();\n+\n+        // and thus should have 3 times contents\n+        byte[] data = out.toByteArray();\n+        assertEquals(3*10, data.length);\n+        String act = out.toString(\"UTF-8\");\n+        assertEquals(15, act.length());\n+\n+        assertEquals(3 * str.length(), act.length());\n+        assertEquals(str+str+str, act);\n+    }\n+\n+    public void testSimpleAscii() throws Exception\n+    {\n+        BufferRecycler rec = new BufferRecycler();\n+        IOContext ctxt = new IOContext(rec, null, false);\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        UTF8Writer w = new UTF8Writer(ctxt, out);\n+\n+        String str = \"abcdefghijklmnopqrst\\u00A0\";\n+        char[] ch = str.toCharArray();\n+\n+        w.write(ch, 0, ch.length);\n+        w.close();\n+\n+        byte[] data = out.toByteArray();\n+        // one 2-byte encoded char\n+        assertEquals(ch.length+1, data.length);\n+        String act = out.toString(\"UTF-8\");\n+        assertEquals(str, act);\n+    }\n+    \n+    public void testFlushAfterClose() throws Exception\n+    {\n+        BufferRecycler rec = new BufferRecycler();\n+        IOContext ctxt = new IOContext(rec, null, false);\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        UTF8Writer w = new UTF8Writer(ctxt, out);\n+        \n+        w.write('X');\n+        \n+        w.close();\n+        assertEquals(1, out.size());\n+\n+        // and this ought to be fine...\n+        w.flush();\n+        // as well as some more...\n+        w.close();\n+        w.flush();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/json/GeneratorBasicTest.java\n+package com.fasterxml.jackson.core.json;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+import java.io.*;\n+\n+/**\n+ * Set of basic unit tests for verifying that the basic generator\n+ * functionality works as expected.\n+ */\n+public class GeneratorBasicTest\n+    extends com.fasterxml.jackson.core.BaseTest\n+{\n+    private final JsonFactory JSON_F = new JsonFactory();\n+\n+    // // // First, tests for primitive (non-structured) values\n+\n+    public void testStringWrite() throws Exception\n+    {\n+        String[] inputStrings = new String[] { \"\", \"X\", \"1234567890\" };\n+        for (int useReader = 0; useReader < 2; ++useReader) {\n+            for (int writeString = 0; writeString < 2; ++writeString) {\n+                for (int strIx = 0; strIx < inputStrings.length; ++strIx) {\n+                    String input = inputStrings[strIx];\n+                    JsonGenerator gen;\n+                    ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+                    if (useReader != 0) {\n+                        gen = JSON_F.createGenerator(new OutputStreamWriter(bout, \"UTF-8\"));\n+                    } else {\n+                        gen = JSON_F.createGenerator(bout, JsonEncoding.UTF8);\n+                    }\n+                    if (writeString > 0) {\n+                        gen.writeString(input);\n+                    } else {\n+                        int len = input.length();\n+                        char[] buffer = new char[len + 20];\n+                        // Let's use non-zero base offset too...\n+                        input.getChars(0, len, buffer, strIx);\n+                        gen.writeString(buffer, strIx, len);\n+                    }\n+                    gen.flush();\n+                    gen.close();\n+                    JsonParser jp = JSON_F.createParser(new ByteArrayInputStream(bout.toByteArray()));\n+                \n+                    JsonToken t = jp.nextToken();\n+                    assertNotNull(\"Document \\\"\"+bout.toString(\"UTF-8\")+\"\\\" yielded no tokens\", t);\n+                    assertEquals(JsonToken.VALUE_STRING, t);\n+                    assertEquals(input, jp.getText());\n+                    assertEquals(null, jp.nextToken());\n+                    jp.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    public void testIntValueWrite() throws Exception\n+    {\n+        doTestIntValueWrite(false);\n+        doTestIntValueWrite(true);\n+    }\n+\n+    public void testLongValueWrite() throws Exception\n+    {\n+        doTestLongValueWrite(false);\n+        doTestLongValueWrite(true);\n+    }\n+\n+    public void testBooleanWrite() throws Exception\n+    {\n+        for (int i = 0; i < 4; ++i) {\n+            boolean state = (i & 1) == 0;\n+            boolean pad = (i & 2) == 0;\n+            StringWriter sw = new StringWriter();\n+            JsonGenerator gen = JSON_F.createGenerator(sw);\n+            gen.writeBoolean(state);\n+            if (pad) {\n+                gen.writeRaw(\" \");\n+            }\n+            gen.close();\n+            String docStr = sw.toString();\n+            JsonParser jp = createParserUsingReader(docStr);\n+            JsonToken t = jp.nextToken();\n+            String exp = Boolean.valueOf(state).toString();\n+            if (!exp.equals(jp.getText())) {\n+                fail(\"Expected '\"+exp+\"', got '\"+jp.getText());\n+            }\n+            assertEquals(state ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE, t);\n+            assertEquals(null, jp.nextToken());\n+            jp.close();\n+        }\n+    }\n+\n+    public void testNullWrite()\n+        throws Exception\n+    {\n+        for (int i = 0; i < 2; ++i) {\n+            boolean pad = (i & 1) == 0;\n+            StringWriter sw = new StringWriter();\n+            JsonGenerator gen = JSON_F.createGenerator(sw);\n+            gen.writeNull();\n+            if (pad) {\n+                gen.writeRaw(\" \");\n+            }\n+            gen.close();\n+            String docStr = sw.toString();\n+            JsonParser jp = createParserUsingReader(docStr);\n+            JsonToken t = jp.nextToken();\n+            String exp = \"null\";\n+            if (!exp.equals(jp.getText())) {\n+                fail(\"Expected '\"+exp+\"', got '\"+jp.getText());\n+            }\n+            assertEquals(JsonToken.VALUE_NULL, t);\n+            assertEquals(null, jp.nextToken());\n+            jp.close();\n+        }\n+    }\n+    \n+    // // Then root-level output testing\n+\n+     public void testRootIntsWrite()\n+         throws Exception\n+     {\n+         StringWriter sw = new StringWriter();\n+         JsonGenerator gen = JSON_F.createGenerator(sw);\n+         gen.writeNumber(1);\n+         gen.writeNumber(2);\n+         gen.writeNumber(-13);\n+         gen.close();\n+\n+         String docStr = sw.toString();\n+\n+         JsonParser jp = createParserUsingReader(docStr);\n+         assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+         assertEquals(1, jp.getIntValue());\n+         assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+         assertEquals(2, jp.getIntValue());\n+         assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+         assertEquals(-13, jp.getIntValue());\n+         jp.close();\n+     }\n+    \n+    // Convenience methods\n+    \n+    public void testFieldValueWrites()\n+         throws Exception\n+     {\n+         StringWriter sw = new StringWriter();\n+         JsonGenerator gen = JSON_F.createGenerator(sw);\n+         gen.writeStartObject();\n+         gen.writeNumberField(\"long\", 3L);\n+         gen.writeNumberField(\"double\", 0.25);\n+         gen.writeNumberField(\"float\", -0.25f);\n+         gen.writeEndObject();\n+         gen.close();\n+\n+         assertEquals(\"{\\\"long\\\":3,\\\"double\\\":0.25,\\\"float\\\":-0.25}\", sw.toString().trim());\n+     }\n+\n+    /**\n+     * Test to verify that output context actually contains useful information\n+     */\n+    public void testOutputContext() throws Exception\n+    {\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator gen = JSON_F.createGenerator(sw);\n+        JsonStreamContext ctxt = gen.getOutputContext();\n+        assertTrue(ctxt.inRoot());\n+\n+        gen.writeStartObject();\n+        assertTrue(gen.getOutputContext().inObject());\n+\n+        gen.writeFieldName(\"a\");\n+        assertEquals(\"a\", gen.getOutputContext().getCurrentName());\n+\n+        gen.writeStartArray();\n+        assertTrue(gen.getOutputContext().inArray());\n+\n+        gen.writeStartObject();\n+        assertTrue(gen.getOutputContext().inObject());\n+\n+        gen.writeFieldName(\"b\");\n+        ctxt = gen.getOutputContext();\n+        assertEquals(\"b\", ctxt.getCurrentName());\n+        gen.writeNumber(123);\n+        assertEquals(\"b\", ctxt.getCurrentName());\n+\n+        gen.writeFieldName(\"c\");\n+        assertEquals(\"c\", gen.getOutputContext().getCurrentName());\n+        gen.writeNumber(5);\n+//        assertEquals(\"c\", gen.getOutputContext().getCurrentName());\n+\n+        gen.writeFieldName(\"d\");\n+        assertEquals(\"d\", gen.getOutputContext().getCurrentName());\n+\n+        gen.writeStartArray();\n+        ctxt = gen.getOutputContext();\n+        assertTrue(ctxt.inArray());\n+        assertEquals(0, ctxt.getCurrentIndex());\n+        assertEquals(0, ctxt.getEntryCount());\n+\n+        gen.writeBoolean(true);\n+        ctxt = gen.getOutputContext();\n+        assertTrue(ctxt.inArray());\n+        // NOTE: index still refers to currently output entry\n+        assertEquals(0, ctxt.getCurrentIndex());\n+        assertEquals(1, ctxt.getEntryCount());\n+\n+        gen.writeNumber(3);\n+        ctxt = gen.getOutputContext();\n+        assertTrue(ctxt.inArray());\n+        assertEquals(1, ctxt.getCurrentIndex());\n+        assertEquals(2, ctxt.getEntryCount());\n+        \n+        gen.writeEndArray();\n+        assertTrue(gen.getOutputContext().inObject());\n+        \n+        gen.writeEndObject();\n+        assertTrue(gen.getOutputContext().inArray());\n+\n+        gen.writeEndArray();\n+        assertTrue(gen.getOutputContext().inObject());\n+\n+        gen.writeEndObject();\n+\n+        assertTrue(gen.getOutputContext().inRoot());\n+        \n+        gen.close();\n+    }\n+\n+    public void testGetOutputTarget() throws Exception\n+    {\n+        OutputStream out = new ByteArrayOutputStream();\n+        JsonGenerator gen = JSON_F.createGenerator(out);\n+        assertSame(out, gen.getOutputTarget());\n+        gen.close();\n+\n+        StringWriter sw = new StringWriter();\n+        gen = JSON_F.createGenerator(sw);\n+        assertSame(sw, gen.getOutputTarget());\n+        gen.close();\n+    }\n+\n+    // for [core#195]\n+    public void testGetOutputBufferd() throws Exception\n+    {\n+        OutputStream out = new ByteArrayOutputStream();\n+        JsonGenerator gen = JSON_F.createGenerator(out);\n+        _testOutputBuffered(gen);\n+        gen.close();\n+\n+        StringWriter sw = new StringWriter();\n+        gen = JSON_F.createGenerator(sw);\n+        _testOutputBuffered(gen);\n+        gen.close();\n+    }\n+\n+    private void _testOutputBuffered(JsonGenerator gen) throws IOException\n+    {\n+        gen.writeStartArray(); // 1 byte\n+        gen.writeNumber(1234); // 4 bytes\n+        assertEquals(5, gen.getOutputBuffered());\n+        gen.flush();\n+        assertEquals(0, gen.getOutputBuffered());\n+        gen.writeEndArray();\n+        assertEquals(1, gen.getOutputBuffered());\n+        gen.close();\n+        assertEquals(0, gen.getOutputBuffered());\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+\n+    private void doTestIntValueWrite(boolean pad) throws Exception\n+    {\n+        int[] VALUES = new int[] {\n+            0, 1, -9, 32, -32, 57, 189, 2017, -9999, 13240, 123456,\n+            1111111, 22222222, 123456789, Integer.MAX_VALUE, Integer.MAX_VALUE\n+        };\n+        for (int i = 0; i < VALUES.length; ++i) {\n+            int VALUE = VALUES[i];\n+            StringWriter sw = new StringWriter();\n+            JsonGenerator gen = JSON_F.createGenerator(sw);\n+            gen.writeNumber(VALUE);\n+            if (pad) {\n+                gen.writeRaw(\" \");\n+            }\n+            gen.close();\n+            String docStr = sw.toString();\n+            JsonParser jp = createParserUsingReader(docStr);\n+            JsonToken t = jp.nextToken();\n+            assertNotNull(\"Document \\\"\"+docStr+\"\\\" yielded no tokens\", t);\n+            // Number are always available as lexical representation too\n+            String exp = \"\"+VALUE;\n+            if (!exp.equals(jp.getText())) {\n+                fail(\"Expected '\"+exp+\"', got '\"+jp.getText());\n+            }\n+            assertEquals(JsonToken.VALUE_NUMBER_INT, t);\n+            assertEquals(VALUE, jp.getIntValue());\n+            assertEquals(null, jp.nextToken());\n+            jp.close();\n+        }\n+    }\n+\n+    private void doTestLongValueWrite(boolean pad) throws Exception\n+    {\n+        long[] VALUES = new long[] {\n+            0L, 1L, -1L, -12005002294L, Long.MIN_VALUE, Long.MAX_VALUE\n+        };\n+        for (int i = 0; i < VALUES.length; ++i) {\n+            long VALUE = VALUES[i];\n+            StringWriter sw = new StringWriter();\n+            JsonGenerator gen = JSON_F.createGenerator(sw);\n+            gen.writeNumber(VALUE);\n+            if (pad) {\n+                gen.writeRaw(\" \");\n+            }\n+            gen.close();\n+            String docStr = sw.toString();\n+            JsonParser jp = createParserUsingReader(docStr);\n+            JsonToken t = jp.nextToken();\n+            assertNotNull(\"Document \\\"\"+docStr+\"\\\" yielded no tokens\", t);\n+            String exp = \"\"+VALUE;\n+            if (!exp.equals(jp.getText())) {\n+                fail(\"Expected '\"+exp+\"', got '\"+jp.getText());\n+            }\n+            assertEquals(JsonToken.VALUE_NUMBER_INT, t);\n+            assertEquals(VALUE, jp.getLongValue());\n+            assertEquals(null, jp.nextToken());\n+            jp.close();\n+        }\n+    }\n+}\n+\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestUtf8Generator.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestUtf8Generator.java\n package com.fasterxml.jackson.core.json;\n \n-import java.io.ByteArrayOutputStream;\n+import java.io.*;\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.io.IOContext;\n import com.fasterxml.jackson.core.util.BufferRecycler;\n \n-public class TestUtf8Generator\n-    extends BaseTest\n+public class TestUtf8Generator extends BaseTest\n {\n+    private final JsonFactory JSON_F = new JsonFactory();\n+\n     public void testUtf8Issue462() throws Exception\n     {\n         ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n         gen.close();\n         \n         // Also verify it's parsable?\n-        JsonFactory f = new JsonFactory();\n-        JsonParser p = f.createParser(bytes.toByteArray());\n+        JsonParser p = JSON_F.createParser(bytes.toByteArray());\n         for (int i = 1; i <= length; ++i) {\n             assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n             assertEquals(1, p.getIntValue());\n     public void testSurrogatesWithRaw() throws Exception\n     {\n         final String VALUE = quote(\"\\ud83d\\ude0c\");\n-        JsonFactory f = new JsonFactory();\n         ByteArrayOutputStream out = new ByteArrayOutputStream();\n-        JsonGenerator jgen = f.createGenerator(out);\n+        JsonGenerator jgen = JSON_F.createGenerator(out);\n         jgen.writeStartArray();\n         jgen.writeRaw(VALUE);\n         jgen.writeEndArray();\n \n         final byte[] JSON = out.toByteArray();\n \n-        JsonParser jp = f.createParser(JSON);\n+        JsonParser jp = JSON_F.createParser(JSON);\n         assertToken(JsonToken.START_ARRAY, jp.nextToken());\n         assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n         String str = jp.getText();", "timestamp": 1432688330, "metainfo": ""}