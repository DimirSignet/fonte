{"sha": "d2c602341294de5f3762af478b79d984997f271c", "log": "Minor improvement to #169: construct `head` lazily", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\n     /**\n      * Reference from currently matching segment (if any) to node\n      * before leaf.\n-     * \n-     * @since 2.5\n-     */\n-    protected final JsonPointer _headSegment;\n+     * Lazily constructed if/as needed.\n+     *<p>\n+     * NOTE: we'll use `volatile` here assuming that this is unlikely to\n+     * become a performance bottleneck. If it becomes one we can probably\n+     * just drop it and things still should work (despite warnings as per JMM\n+     * regarding visibility (and lack thereof) of unguarded changes).\n+     * \n+     * @since 2.5\n+     */\n+    protected volatile JsonPointer _head;\n \n     /**\n      * We will retain representation of the pointer, as a String,\n      */\n     protected JsonPointer() {\n         _nextSegment = null;\n-        _headSegment = null;\n         _matchingPropertyName = \"\";\n         _matchingElementIndex = -1;\n         _asString = \"\";\n     /**\n      * Constructor used for creating non-empty Segments\n      */\n-    protected JsonPointer(String fullString, String segment, JsonPointer next, JsonPointer head) {\n+    protected JsonPointer(String fullString, String segment, JsonPointer next) {\n         _asString = fullString;\n         _nextSegment = next;\n-        _headSegment = head;\n         // Ok; may always be a property\n         _matchingPropertyName = segment;\n+        // but could be an index, if parsable\n         _matchingElementIndex = _parseIndex(segment);\n     }\n     \n         if (input.charAt(0) != '/') {\n             throw new IllegalArgumentException(\"Invalid input: JSON Pointer expression must start with '/': \"+\"\\\"\"+input+\"\\\"\");\n         }\n-        return _parseTailAndHead(input);\n+        return _parseTail(input);\n     }\n \n     /**\n      * @since 2.5\n      */\n     public JsonPointer head() {\n-        return _headSegment;\n+        JsonPointer h = _head;\n+        if (h == null) {\n+            if (this != EMPTY) {\n+                h = _constructHead();\n+            }\n+            _head = h;\n+        }\n+        return h;\n     }\n \n     /*\n         return NumberInput.parseInt(str);\n     }\n     \n-    protected static JsonPointer _parseTailAndHead(String input) {\n+    protected static JsonPointer _parseTail(String input) {\n         final int end = input.length();\n \n         // first char is the contextual slash, skip\n         for (int i = 1; i < end; ) {\n             char c = input.charAt(i);\n             if (c == '/') { // common case, got a segment\n-                int lastSlash = input.lastIndexOf('/');\n-                if (lastSlash < 0) {\n-                    return new JsonPointer(input, input.substring(1, i),\n-                            _parseTailAndHead(input.substring(i)), EMPTY);\n-                }\n                 return new JsonPointer(input, input.substring(1, i),\n-                        _parseTailAndHead(input.substring(i)), compile(input.substring(0, lastSlash)));\n+                        _parseTail(input.substring(i)));\n             }\n             ++i;\n             // quoting is different; offline this case\n             if (c == '~' && i < end) { // possibly, quote\n-                return _parseQuotedTailAndHead(input, i);\n+                return _parseQuotedTail(input, i);\n             }\n             // otherwise, loop on\n         }\n         // end of the road, no escapes\n-        return new JsonPointer(input, input.substring(1), EMPTY, EMPTY);\n+        return new JsonPointer(input, input.substring(1), EMPTY);\n     }\n \n     /**\n      * @param input Full input for the tail being parsed\n      * @param i Offset to character after tilde\n      */\n-    protected static JsonPointer _parseQuotedTailAndHead(String input, int i) {\n+    protected static JsonPointer _parseQuotedTail(String input, int i) {\n         final int end = input.length();\n         StringBuilder sb = new StringBuilder(Math.max(16, end));\n         if (i > 2) {\n             sb.append(input, 1, i-1);\n         }\n         _appendEscape(sb, input.charAt(i++));\n-\n         while (i < end) {\n             char c = input.charAt(i);\n             if (c == '/') { // end is nigh!\n-                int lastSlash = input.lastIndexOf('/');\n-                if (lastSlash < 0) {\n-                    return new JsonPointer(input, sb.toString(),\n-                            _parseTailAndHead(input.substring(i)), EMPTY);\n-                }\n                 return new JsonPointer(input, sb.toString(),\n-                        _parseTailAndHead(input.substring(i)), compile(input.substring(0, lastSlash)));\n+                        _parseTail(input.substring(i)));\n             }\n             ++i;\n             if (c == '~' && i < end) {\n             sb.append(c);\n         }\n         // end of the road, last segment\n-        return new JsonPointer(input, sb.toString(), EMPTY, EMPTY);\n+        return new JsonPointer(input, sb.toString(), EMPTY);\n+    }\n+\n+    protected JsonPointer _constructHead()\n+    {\n+        int ix = _asString.lastIndexOf('/');\n+        if (ix <= 0) { // not sure if we should ever not find, but 0 is the case for last segment so\n+            return EMPTY;\n+        }\n+        return compile(_asString.substring(0, ix));\n     }\n     \n     private static void _appendEscape(StringBuilder sb, char c) {\n--- a/src/test/java/com/fasterxml/jackson/core/TestJsonPointer.java\n+++ b/src/test/java/com/fasterxml/jackson/core/TestJsonPointer.java\n         JsonPointer leaf = ptr.last();\n \n         assertEquals(\"name\", leaf.getMatchingProperty());\n+    }\n+\n+    public void testEmpty()\n+    {\n+        // note: this is acceptable, to match property in '{\"\":3}', for example\n+        // and NOT same as what empty point, \"\", is.\n+        JsonPointer ptr = JsonPointer.compile(\"/\");\n+        assertNotNull(ptr);\n+        assertNotSame(JsonPointer.EMPTY, ptr);\n+        assertEquals(\"/\", ptr.toString());\n     }\n \n     public void testAppend()", "timestamp": 1418164757, "metainfo": ""}