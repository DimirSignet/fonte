{"sha": "791e288ff3c8e509bc5da11b3f0d7145610cb792", "log": "Add partial version of the experimental new symbol table", "commit": "\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java\n+package com.fasterxml.jackson.core.sym;\n+\n+import java.util.BitSet;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import com.fasterxml.jackson.core.JsonFactory;\n+import com.fasterxml.jackson.core.util.InternCache;\n+\n+/**\n+ * Replacement for {@link BytesToNameCanonicalizer} which aims at more localized\n+ * memory access due to flattening of name quad data.\n+ *\n+ * @since 2.6\n+ */\n+public final class ByteQuadsCanonicalizer\n+{\n+    /**\n+     * Initial size of the primary hash area. Each entry consumes 4 ints (16 bytes),\n+     * and secondary area is same as primary; so default size will use 2kB of memory\n+     * (plus 64x4 or 64x8 (256/512 bytes) for references to Strings, and Strings\n+     * themselves).\n+     */\n+    private static final int DEFAULT_T_SIZE = 64;\n+\n+    /**\n+     * Let's not expand symbol tables past some maximum size;\n+     * this should protected against OOMEs caused by large documents\n+     * with unique (~= random) names.\n+     * Size is in \n+     */\n+    private static final int MAX_T_SIZE = 0x10000; // 64k entries == 2M mem hash area\n+\n+    /**\n+     * No point in trying to construct tiny tables, just need to resize soon.\n+     */\n+    final static int MIN_HASH_SIZE = 16;\n+    \n+    /**\n+     * Let's only share reasonably sized symbol tables. Max size set to 3/4 of 16k;\n+     * this corresponds to 64k main hash index. This should allow for enough distinct\n+     * names for almost any case.\n+     */\n+    private final static int MAX_ENTRIES_FOR_REUSE = 6000;\n+\n+    /*\n+    /**********************************************************\n+    /* Linkage, needed for merging symbol tables\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Reference to the root symbol table, for child tables, so\n+     * that they can merge table information back as necessary.\n+     */\n+    final protected ByteQuadsCanonicalizer _parent;\n+\n+    /**\n+     * Member that is only used by the root table instance: root\n+     * passes immutable state into child instances, and children\n+     * may return new state if they add entries to the table.\n+     * Child tables do NOT use the reference.\n+     */\n+    final protected AtomicReference<TableInfo> _tableInfo;\n+    \n+    /**\n+     * Seed value we use as the base to make hash codes non-static between\n+     * different runs, but still stable for lifetime of a single symbol table\n+     * instance.\n+     * This is done for security reasons, to avoid potential DoS attack via\n+     * hash collisions.\n+     * \n+     * @since 2.1\n+     */\n+    final private int _seed;\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Whether canonical symbol Strings are to be intern()ed before added\n+     * to the table or not.\n+     *<p>\n+     * NOTE: non-final to allow disabling intern()ing in case of excessive\n+     * collisions.\n+     */\n+    protected boolean _intern;\n+\n+    /**\n+     * Flag that indicates whether we should throw an exception if enough \n+     * hash collisions are detected (true); or just worked around (false).\n+     * \n+     * @since 2.4\n+     */\n+    protected final boolean _failOnDoS;\n+    \n+    /*\n+    /**********************************************************\n+    /* First, main hash area info\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Primary hash information area: consists of <code>2 * _hashSize</code>\n+     * entries of 16 bytes (4 ints), arranged in a cascading lookup\n+     * structure (details of which may be tweaked depending on expected rates\n+     * of collisions).\n+     */\n+    protected int[] _hash;\n+    \n+    /**\n+     * Mask used to truncate 32-bit hash value to current hash array\n+     * size; essentially, {@link _hashSize} - 1 (since hash array sizes\n+     * are 2^N).\n+     */\n+    protected int _hashMask;\n+\n+    /**\n+     * Number of slots for primary entries within {@link #_hash}; which is\n+     * <code>1/2</code> \n+     */\n+    protected int _hashSize;\n+    \n+    /**\n+     * Total number of Strings in the symbol table; only used for child tables.\n+     */\n+    protected int _count;\n+\n+    /**\n+     * Array that contains <code>String</code> instances matching\n+     * entries in {@link #_hash}.\n+     * Contains nulls for unused entries. Note that this size is twice\n+     * that o\n+     */\n+    protected String[] _names;\n+\n+    /*\n+    /**********************************************************\n+    /* Then information on collisions etc\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Number of entries that ended up in the shared spill-over\n+     * area (that is, did not fit in primary, secondary or tertiary slots).\n+     */\n+    protected int _spillOverCount;\n+\n+    /**\n+     * Offset within {@link #_hash} that follows main slots and contains\n+     * quads for longer names (13 bytes or longers), and points to the\n+     * first available int that may be used for appending quads of the next\n+     * long name.\n+     */\n+    protected int _longNameOffset;\n+\n+    /**\n+     * We need to keep track of the longest collision list; this is needed\n+     * both to indicate problems with attacks and to allow flushing for\n+     * other cases.\n+     */\n+    protected int _longestCollisionList;\n+\n+    /**\n+     * Total number of Names in collision buckets (included in\n+     * <code>_count</code> along with primary entries)\n+     */\n+    protected int _collCount;\n+\n+    /**\n+     * This flag is set if, after adding a new entry, it is deemed\n+     * that a rehash is warranted if any more entries are to be added.\n+     */\n+    private transient boolean _needRehash;\n+\n+    /*\n+    /**********************************************************\n+    /* Sharing, versioning\n+    /**********************************************************\n+     */\n+\n+    // // // Which of the buffers may be shared (and are copy-on-write)?\n+\n+    /**\n+     * Flag that indicates whether underlying data structures for\n+     * the main hash area are shared or not. If they are, then they\n+     * need to be handled in copy-on-write way, i.e. if they need\n+     * to be modified, a copy needs to be made first; at this point\n+     * it will not be shared any more, and can be modified.\n+     *<p>\n+     * This flag needs to be checked both when adding new main entries,\n+     * and when adding new collision list queues (i.e. creating a new\n+     * collision list head entry)\n+     */\n+    private boolean _hashShared;\n+\n+    /*\n+    /**********************************************************\n+    /* Bit of DoS detection goodness\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Lazily constructed structure that is used to keep track of\n+     * collision buckets that have overflowed once: this is used\n+     * to detect likely attempts at denial-of-service attacks that\n+     * uses hash collisions.\n+     * \n+     * @since 2.4\n+     */\n+    protected BitSet _overflows;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle: constructors\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Constructor used for creating per-<code>JsonFactory</code> \"root\"\n+     * symbol tables: ones used for merging and sharing common symbols\n+     * \n+     * @param sz Initial primary hash area size\n+     * @param intern Whether Strings contained should be {@link String#intern}ed\n+     * @param seed Random seed valued used to make it more difficult to cause\n+     *   collisions (used for collision-based DoS attacks).\n+     */\n+    private ByteQuadsCanonicalizer(int sz, boolean intern, int seed, boolean failOnDoS) {\n+        _parent = null;\n+        _seed = seed;\n+        _intern = intern;\n+        _failOnDoS = failOnDoS;\n+        // Sanity check: let's now allow hash sizes below certain minimum value\n+        if (sz < MIN_HASH_SIZE) {\n+            sz = MIN_HASH_SIZE;\n+        } else {\n+            // Also; size must be 2^N; otherwise hash algorithm won't\n+            // work... so let's just pad it up, if so\n+            if ((sz & (sz - 1)) != 0) { // only true if it's 2^N\n+                int curr = MIN_HASH_SIZE;\n+                while (curr < sz) {\n+                    curr += curr;\n+                }\n+                sz = curr;\n+            }\n+        }\n+        _tableInfo = new AtomicReference<TableInfo>(TableInfo.createInitial(sz));\n+    }\n+\n+    /**\n+     * Constructor used when creating a child instance\n+     */\n+    private ByteQuadsCanonicalizer(ByteQuadsCanonicalizer parent, boolean intern,\n+            int seed, boolean failOnDoS, TableInfo state)\n+    {\n+        _parent = parent;\n+        _seed = seed;\n+        _intern = intern;\n+        _failOnDoS = failOnDoS;\n+        _tableInfo = null; // not used by child tables\n+\n+        // Then copy shared state\n+        _count = state.count;\n+        _hashSize = state.size;\n+        _hashMask = _hashSize-1;\n+        _hash = state.mainHash;\n+        _names = state.names;\n+        _collCount = state.collCount;\n+        _longestCollisionList = state.longestCollisionList;\n+\n+        // and then set other state to reflect sharing status\n+        _needRehash = false;\n+        _hashShared = true;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle: factory methods, merging\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Factory method to call to create a symbol table instance with a\n+     * randomized seed value.\n+     */\n+    public static ByteQuadsCanonicalizer createRoot() {\n+        /* [Issue-21]: Need to use a variable seed, to thwart hash-collision\n+         * based attacks.\n+         */\n+        long now = System.currentTimeMillis();\n+        // ensure it's not 0; and might as well require to be odd so:\n+        int seed = (((int) now) + ((int) (now >>> 32))) | 1;\n+        return createRoot(seed);\n+    }\n+\n+    /**\n+     * Factory method that should only be called from unit tests, where seed\n+     * value should remain the same.\n+     */\n+    protected static ByteQuadsCanonicalizer createRoot(int seed) {\n+        return new ByteQuadsCanonicalizer(DEFAULT_T_SIZE, true, seed, true);\n+    }\n+    \n+    /**\n+     * Factory method used to create actual symbol table instance to\n+     * use for parsing.\n+     */\n+    public ByteQuadsCanonicalizer makeChild(int flags) {\n+        return new ByteQuadsCanonicalizer(this,\n+                JsonFactory.Feature.INTERN_FIELD_NAMES.enabledIn(flags),\n+                _seed,\n+                JsonFactory.Feature.FAIL_ON_SYMBOL_HASH_OVERFLOW.enabledIn(flags),\n+                _tableInfo.get());\n+    }\n+\n+    /**\n+     * Method called by the using code to indicate it is done\n+     * with this instance. This lets instance merge accumulated\n+     * changes into parent (if need be), safely and efficiently,\n+     * and without calling code having to know about parent\n+     * information\n+     */\n+    public void release()\n+    {\n+        // we will try to merge if child table has new entries\n+        if (_parent != null && maybeDirty()) {\n+            _parent.mergeChild(new TableInfo(this));\n+            /* Let's also mark this instance as dirty, so that just in\n+             * case release was too early, there's no corruption of possibly shared data.\n+             */\n+            _hashShared = true;\n+        }\n+    }\n+\n+    private void mergeChild(TableInfo childState)\n+    {\n+        final int childCount = childState.count;\n+        TableInfo currState = _tableInfo.get();\n+\n+        // Should usually grow; but occasionally could also shrink if (but only if)\n+        // collision list overflow ends up clearing some collision lists.\n+        if (childCount == currState.count) {\n+            return;\n+        }\n+\n+        // One caveat: let's try to avoid problems with degenerate cases of documents with\n+        // generated \"random\" names: for these, symbol tables would bloat indefinitely.\n+        // One way to do this is to just purge tables if they grow\n+        // too large, and that's what we'll do here.\n+        if (childCount > MAX_ENTRIES_FOR_REUSE) {\n+            // At any rate, need to clean up the tables\n+            childState = TableInfo.createInitial(DEFAULT_T_SIZE);\n+        }\n+        _tableInfo.compareAndSet(currState, childState);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* API, accessors\n+    /**********************************************************\n+     */\n+\n+    public int size()\n+    {\n+        if (_tableInfo != null) { // root table\n+            return _tableInfo.get().count;\n+        }\n+        // nope, child table\n+        return _count;\n+    }\n+\n+    /**\n+     * Returns number of primary slots table has currently\n+     */\n+    public int bucketCount() { return _hashSize; }\n+\n+    /**\n+     * Method called to check to quickly see if a child symbol table\n+     * may have gotten additional entries. Used for checking to see\n+     * if a child table should be merged into shared table.\n+     */\n+    public boolean maybeDirty() { return !_hashShared; }\n+\n+    public int hashSeed() { return _seed; }\n+    \n+    /**\n+     * Method mostly needed by unit tests; calculates number of\n+     * entries that are in collision list. Value can be at most\n+     * ({@link #size} - 1), but should usually be much lower, ideally 0.\n+     */\n+    public int collisionCount() { return _collCount; }\n+\n+    /**\n+     * Method mostly needed by unit tests; calculates length of the\n+     * longest collision chain. This should typically be a low number,\n+     * but may be up to {@link #size} - 1 in the pathological case\n+     */\n+    public int maxCollisionLength() {\n+        return _longestCollisionList;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, accessing symbols\n+    /**********************************************************\n+     */\n+\n+    public String findName(int q1)\n+    {\n+        int offset = _calcOffset(calcHash(q1));\n+        // first: primary match?\n+        final int[] hashArea = _hash;\n+\n+        int q1b = hashArea[offset];\n+        int len = hashArea[offset+3];\n+        \n+        if ((q1b == q1) && (len == 1)) {\n+            return _names[offset >> 4];\n+        }\n+        if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n+            return null;\n+        }\n+        // secondary? single slot shared by N/2 primaries\n+        int offset2 = _hashSize + (offset>>1);\n+\n+        q1b = hashArea[offset2];\n+        len = hashArea[offset2+3];\n+\n+        if ((q1b == q1) && (len == 1)) {\n+            return _names[offset2 >> 4];\n+        }\n+        if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n+            return null;\n+        }\n+\n+        // tertiary lookup & spillovers best to offline\n+        return _findSecondary(offset, q1);\n+    }\n+\n+    public String findName(int q1, int q2)\n+    {\n+        int hash = (q2 == 0) ? calcHash(q1) : calcHash(q1, q2);\n+        int offset = _calcOffset(hash);\n+\n+        final int[] hashArea = _hash;\n+\n+        int q1b = hashArea[offset];\n+        int len = hashArea[offset+3];\n+\n+        if ((q1 == q1b) && (hashArea[offset+1] == q2) && (len == 2)) {\n+            return _names[offset >> 2];\n+        }\n+        if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n+            return null;\n+        }\n+        // secondary?\n+        int offset2 = _hashSize + (offset>>1);\n+\n+        q1b = hashArea[offset2];\n+        len = hashArea[offset2+3];\n+\n+        if ((q1 == q1b) && (hashArea[offset2+1] == q2) && (len == 2)) {\n+            return _names[offset2 >> 2];\n+        }\n+        if (len == 0) { // empty slot? Short-circuit if no more spillovers\n+            return null;\n+        }\n+        return _findSecondary(offset, q1, q2);\n+    }\n+\n+    public String findName(int q1, int q2, int q3)\n+    {\n+        int offset = _calcOffset(calcHash(q1, q2, q3));\n+\n+        final int[] hashArea = _hash;\n+\n+        int q1b = hashArea[offset];\n+        int len = hashArea[offset+3];\n+        \n+        if ((q1 == q1b) && (hashArea[offset+1] == q2) && (hashArea[offset+2] == q3) && (len == 3)) {\n+            return _names[offset >> 2];\n+        }\n+        if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n+            return null;\n+        }\n+        // secondary?\n+        int offset2 = _hashSize + (offset>>1);\n+\n+        q1b = hashArea[offset2];\n+        len = hashArea[offset2+3];\n+\n+        if ((q1 == q1b) && (hashArea[offset2+1] == q2) && (hashArea[offset2+2] == q3) && (len == 3)) {\n+            return _names[offset2 >> 2];\n+        }\n+        if (len == 0) { // empty slot? Short-circuit if no more spillovers\n+            return null;\n+        }\n+        return _findSecondary(offset, q1, q2, q3);\n+    }\n+\n+    public String findName(int[] q, int qlen)\n+    {\n+        /* This version differs significantly, because longer names do not fit within cell.\n+         * Rather, they contain hash in main slot, and offset+length to extension area\n+         * that contains actual quads.\n+         */\n+        if (qlen < 4) { // another sanity check\n+            if (qlen == 3) {\n+                return findName(q[0], q[1], q[2]);\n+            }\n+            return findName(q[0], (qlen < 2) ? 0 : q[1]);\n+        }\n+        final int hash = calcHash(calcHash(q, qlen));\n+        int offset = _calcOffset(hash);\n+\n+        final int[] hashArea = _hash;\n+\n+        int h = hashArea[offset];\n+        int len = hashArea[offset+3];\n+        \n+        if ((hash == h) && (len == qlen)) {\n+            // probable but not guaranteed: verify\n+            if (_verifyLongName(q, qlen, hashArea[offset+1])) {\n+                return _names[offset >> 2];\n+            }\n+        }\n+        if (len == 0) { // empty slot; unlikely but avoid further lookups if so\n+            return null;\n+        }\n+        // secondary?\n+        int offset2 = _hashSize + (offset>>1);\n+\n+        h = hashArea[offset2];\n+        len = hashArea[offset2+3];\n+\n+        if ((hash == h) && (len == qlen)) {\n+            if (_verifyLongName(q, qlen, hashArea[offset2+1])) {\n+                return _names[offset2 >> 2];\n+            }\n+        }\n+        if (len == 0) { // empty slot? Short-circuit if no more spillovers\n+            return null;\n+        }\n+        return _findSecondary(offset, hash, q, qlen);\n+    }\n+    \n+    private final int _calcOffset(int hash)\n+    {\n+        // NOTE: simple for initial impl, but we may want to interleave it a bit\n+        // in near future\n+        // So: first, hash into primary hash index\n+        int ix = hash & _hashMask;\n+        // keeping in mind we have 4 ints per entry\n+        return (ix << 2);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Access from spill-over areas\n+    /**********************************************************\n+     */\n+\n+    private String _findSecondary(int origOffset, int q1)\n+    {\n+        // so, first tertiary, 4 cells shared by N/16 primary slots\n+        int offset = _hashSize;\n+        offset += (offset >> 1); // to skip secondary area\n+        offset += (origOffset >> 4);\n+\n+        final int[] hashArea = _hash;\n+        \n+        // then check up to 4 slots; don't worry about empty slots yet\n+        if ((q1 == hashArea[offset]) && (1 == hashArea[offset+3])) {\n+            return _names[offset >> 2];\n+        }\n+        offset += 4;\n+        if ((q1 == hashArea[offset]) && (1 == hashArea[offset+3])) {\n+            return _names[offset >> 2];\n+        }\n+        offset += 4;\n+        if ((q1 == hashArea[offset]) && (1 == hashArea[offset+3])) {\n+            return _names[offset >> 2];\n+        }\n+        offset += 4;\n+        int len = hashArea[offset+3];\n+        if ((q1 == hashArea[offset]) && (1 == len)) {\n+            return _names[offset >> 2];\n+        }\n+        // and only at this point see if last slot was occupied or not, to see whether to continue\n+        if (len != 0) {\n+            // shared spillover starts at 7/8 of the main hash area\n+            // (which is sized at 2 * _hashSize), so:\n+            offset = (_hashSize << 1) - (_hashSize >> 8);\n+            for (int i = 0, end = _spillOverCount; i < end; ++i, offset += 16) {\n+                if ((q1 == hashArea[offset]) && (1 == hashArea[offset+3])) {\n+                    return _names[offset >> 2];\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private String _findSecondary(int origOffset, int q1, int q2)\n+    {\n+        int offset = _hashSize;\n+        offset += (offset >> 1);\n+        offset += (origOffset >> 4);\n+\n+        final int[] hashArea = _hash;\n+        \n+        if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (2 == hashArea[offset+3])) {\n+            return _names[offset >> 2];\n+        }\n+        offset += 4;\n+        if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (2 == hashArea[offset+3])) {\n+            return _names[offset >> 2];\n+        }\n+        offset += 4;\n+        if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (2 == hashArea[offset+3])) {\n+            return _names[offset >> 2];\n+        }\n+        offset += 4;\n+        int len = hashArea[offset+3];\n+        if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (2 == len)) {\n+            return _names[offset >> 2];\n+        }\n+        // and only at this point see if last slot was occupied or not, to see whether to continue\n+        if (len != 0) {\n+            // shared spillover starts at 7/8 of the main hash area\n+            // (which is sized at 2 * _hashSize), so:\n+            offset = (_hashSize << 1) - (_hashSize >> 8);\n+            for (int i = 0, end = _spillOverCount; i < end; ++i, offset += 4) {\n+                if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (2 == hashArea[offset+3])) {\n+                    return _names[offset >> 2];\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private String _findSecondary(int origOffset, int q1, int q2, int q3)\n+    {\n+        int offset = _hashSize;\n+        offset += (offset >> 1);\n+        offset += (origOffset >> 4);\n+\n+        final int[] hashArea = _hash;\n+        \n+        if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (q3 == hashArea[offset+2]) && (3 == hashArea[offset+3])) {\n+            return _names[offset >> 2];\n+        }\n+        offset += 4;\n+        if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (q3 == hashArea[offset+2]) && (3 == hashArea[offset+3])) {\n+            return _names[offset >> 2];\n+        }\n+        offset += 4;\n+        if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (q3 == hashArea[offset+2]) && (3 == hashArea[offset+3])) {\n+            return _names[offset >> 2];\n+        }\n+        offset += 4;\n+        int len = hashArea[offset+3];\n+        if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (q3 == hashArea[offset+2]) && (3 == len)) {\n+            return _names[offset >> 2];\n+        }\n+        // and only at this point see if last slot was occupied or not, to see whether to continue\n+        if (len != 0) {\n+            // shared spillover starts at 7/8 of the main hash area\n+            // (which is sized at 2 * _hashSize), so:\n+            offset = (_hashSize << 1) - (_hashSize >> 8);\n+            for (int i = 0, end = _spillOverCount; i < end; ++i, offset += 4) {\n+                if ((q1 == hashArea[offset]) && (q2 == hashArea[offset+1]) && (q3 == hashArea[offset+2])\n+                        && (3 == hashArea[offset+3])) {\n+                    return _names[offset >> 2];\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private String _findSecondary(int origOffset, int hash, int[] q, int qlen)\n+    {\n+        int offset = _hashSize;\n+        offset += (offset >> 1);\n+        offset += (origOffset >> 4);\n+        \n+        final int[] hashArea = _hash;\n+        \n+        if ((hash == hashArea[offset]) && (qlen == hashArea[offset+3])) {\n+            if (_verifyLongName(q, qlen, hashArea[offset+1])) {\n+                return _names[offset >> 2];\n+            }\n+        }\n+        offset += 4;\n+        if ((hash == hashArea[offset]) && (qlen == hashArea[offset+3])) {\n+            if (_verifyLongName(q, qlen, hashArea[offset+1])) {\n+                return _names[offset >> 2];\n+            }\n+        }\n+        offset += 4;\n+        if ((hash == hashArea[offset]) && (qlen == hashArea[offset+3])) {\n+            if (_verifyLongName(q, qlen, hashArea[offset+1])) {\n+                return _names[offset >> 2];\n+            }\n+        }\n+        offset += 4;\n+        int len = hashArea[offset+3];\n+        if ((hash == hashArea[offset]) && (qlen == len)) {\n+            if (_verifyLongName(q, qlen, hashArea[offset+1])) {\n+                return _names[offset >> 2];\n+            }\n+        }\n+        // and only at this point see if last slot was occupied or not, to see whether to continue\n+        if (len != 0) {\n+            // shared spillover starts at 7/8 of the main hash area\n+            // (which is sized at 2 * _hashSize), so:\n+            offset = (_hashSize << 1) - (_hashSize >> 8);\n+            for (int i = 0, end = _spillOverCount; i < end; ++i, offset += 4) {\n+                if ((hash == hashArea[offset]) && (3 == len)) {\n+                    if (_verifyLongName(q, qlen, hashArea[offset+1])) {\n+                        return _names[offset >> 2];\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    private boolean _verifyLongName(int[] q, int qlen, int spillOffset)\n+    {\n+        final int[] hashArea = _hash;\n+        // spillOffset assumed to be physical index right into quad string\n+\n+        int ix = 0;\n+        do {\n+            if (q[ix++] != hashArea[spillOffset++]) {\n+                return false;\n+            }\n+        } while (ix < qlen);\n+        return true;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* API, mutators\n+    /**********************************************************\n+     */\n+\n+    public String addName(String name, int q1, int q2)\n+    {\n+        if (_intern) {\n+            name = InternCache.instance.intern(name);\n+        }\n+        int hash = (q2 == 0) ? calcHash(q1) : calcHash(q1, q2);\n+//        return _addSymbol(hash, name);\n+        return null;\n+    }\n+    \n+    public String addName(String name, int[] q, int qlen)\n+    {\n+        if (_intern) {\n+            name = InternCache.instance.intern(name);\n+        }\n+        int hash;\n+        if (qlen < 4) {\n+            if (qlen == 1) {\n+                hash = calcHash(q[0]);\n+            } else if (qlen == 2) {\n+                hash = calcHash(q[0], q[1]);\n+            } else {\n+                hash = calcHash(q[0], q[1], q[2]);\n+            }\n+        } else {\n+            hash = calcHash(q, qlen);\n+        }\n+//        return _addSymbol(hash, name);\n+        return null;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Hash calculation\n+    /**********************************************************\n+     */\n+\n+    /* Note on hash calculation: we try to make it more difficult to\n+     * generate collisions automatically; part of this is to avoid\n+     * simple \"multiply-add\" algorithm (like JDK String.hashCode()),\n+     * and add bit of shifting. And other part is to make this\n+     * non-linear, at least for shorter symbols.\n+     */\n+    \n+    // JDK uses 31; other fine choices are 33 and 65599, let's use 33\n+    // as it seems to give fewest collisions for us\n+    // (see [http://www.cse.yorku.ca/~oz/hash.html] for details)\n+    private final static int MULT = 33;\n+    private final static int MULT2 = 65599;\n+    private final static int MULT3 = 31;\n+    \n+    public int calcHash(int q1)\n+    {\n+        int hash = q1 ^ _seed;\n+        hash += (hash >>> 15); // to xor hi- and low- 16-bits\n+        hash ^= (hash >>> 9); // as well as lowest 2 bytes\n+        return hash;\n+    }\n+\n+    public int calcHash(int q1, int q2)\n+    {\n+        int hash = q1;\n+        hash ^= (hash >>> 15); // try mixing first and second byte pairs first\n+        hash += (q2 * MULT); // then add second quad\n+        hash ^= _seed;\n+        hash += (hash >>> 7); // and shuffle some more\n+        return hash;\n+    }\n+\n+    public int calcHash(int q1, int q2, int q3)\n+    { // use same algorithm as multi-byte, tested to work well\n+        int hash = q1 ^ _seed;\n+        hash += (hash >>> 9);\n+        hash *= MULT;\n+        hash += q2;\n+        hash *= MULT2;\n+        hash += (hash >>> 15);\n+        hash ^= q3;\n+        hash += (hash >>> 17);\n+\n+        hash += (hash >>> 15);\n+        hash ^= (hash << 9);\n+\n+        return hash;\n+    }\n+    \n+    public int calcHash(int[] q, int qlen)\n+    {\n+        if (qlen < 4) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        /* And then change handling again for \"multi-quad\" case; mostly\n+         * to make calculation of collisions less fun. For example,\n+         * add seed bit later in the game, and switch plus/xor around,\n+         * use different shift lengths.\n+         */\n+        int hash = q[0] ^ _seed;\n+        hash += (hash >>> 9);\n+        hash *= MULT;\n+        hash += q[1];\n+        hash *= MULT2;\n+        hash += (hash >>> 15);\n+        hash ^= q[2];\n+        hash += (hash >>> 17);\n+        \n+        for (int i = 3; i < qlen; ++i) {\n+            hash = (hash * MULT3) ^ q[i];\n+            // for longer entries, mess a bit in-between too\n+            hash += (hash >>> 3);\n+            hash ^= (hash << 7);\n+        }\n+        // and finally shuffle some more once done\n+        hash += (hash >>> 15); // to get high-order bits to mix more\n+        hash ^= (hash << 9); // as well as lowest 2 bytes\n+        return hash;\n+    }\n+   \n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Immutable value class used for sharing information as efficiently\n+     * as possible, by only require synchronization of reference manipulation\n+     * but not access to contents.\n+     * \n+     * @since 2.1\n+     */\n+    private final static class TableInfo\n+    {\n+        public final int size;\n+        public final int count;\n+        public final int[] mainHash;\n+        public final String[] names;\n+        public final int collCount;\n+        public final int longestCollisionList;\n+\n+        public TableInfo(int size, int count, int[] mainHash, String[] names,\n+                int collCount, int longestCollisionList)\n+        {\n+            this.size = size;\n+            this.count = count;\n+            this.mainHash = mainHash;\n+            this.names = names;\n+            this.collCount = collCount;\n+            this.longestCollisionList = longestCollisionList;\n+        }\n+\n+        public TableInfo(ByteQuadsCanonicalizer src)\n+        {\n+            size = src._hashSize;\n+            count = src._count;\n+            mainHash = src._hash;\n+            names = src._names;\n+            collCount = src._collCount;\n+            longestCollisionList = src._longestCollisionList;\n+        }\n+\n+        public static TableInfo createInitial(int sz) {\n+            return new TableInfo(sz, // hashSize\n+                    0, // count\n+                    new int[sz * 2], // mainHash\n+                    new String[sz], // mainNames\n+                    0, // collCount,\n+                    0 // longestCollisionList\n+            );\n+        }\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n                 0 // longestCollisionList\n         );\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Life-cycle: factory methods, merging", "timestamp": 1423098298, "metainfo": ""}