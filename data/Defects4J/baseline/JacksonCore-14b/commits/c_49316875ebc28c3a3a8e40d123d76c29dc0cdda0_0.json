{"sha": "49316875ebc28c3a3a8e40d123d76c29dc0cdda0", "log": "Merge branch 'master' of github.com:FasterXML/jackson-core", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n     @Override public abstract JsonToken nextToken() throws IOException;\n     @Override public JsonToken getCurrentToken() { return _currToken; }\n \n-    @Override public final int getCurrentTokenId() {\n+    @Override public int getCurrentTokenId() {\n         final JsonToken t = _currToken;\n         return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n     }\n         return t.id() == id;\n     }\n \n-    @Override public final boolean hasToken(JsonToken t) {\n+    @Override public boolean hasToken(JsonToken t) {\n         return (_currToken == t);\n     }\n     \n--- a/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java\n                 }\n                 // If not, traverse down the context chain\n                 ctxt = _headContext.findChildOf(ctxt);\n-\n                 _exposedContext = ctxt;\n                 if (ctxt == null) { // should never occur\n                     throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n     protected final JsonToken _nextTokenWithBuffering(final TokenFilterContext buffRoot)\n         throws IOException\n     {\n-        _exposedContext = buffRoot;\n-\n         main_loop:\n         while (true) {\n             JsonToken t = delegate.nextToken();\n                 _itemFilter = f;\n                 if (f == TokenFilter.INCLUDE_ALL) {\n                     _headContext = _headContext.createChildArrayContext(f, true);\n-                    return _nextBuffered();\n+                    return _nextBuffered(buffRoot);\n                 }\n                 _headContext = _headContext.createChildArrayContext(f, false);\n                 continue main_loop;\n                 _itemFilter = f;\n                 if (f == TokenFilter.INCLUDE_ALL) {\n                     _headContext = _headContext.createChildObjectContext(f, true);\n-                    return _nextBuffered();\n+                    return _nextBuffered(buffRoot);\n                 }\n                 _headContext = _headContext.createChildObjectContext(f, false);\n                 continue main_loop;\n                     if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                         f.filterFinishArray();\n                     }\n+                    boolean gotEnd = (_headContext == buffRoot);\n+                    boolean returnEnd = gotEnd && _headContext.isStartHandled();\n+\n                     _headContext = _headContext.getParent();\n                     _itemFilter = _headContext.getFilter();\n-                    \n-                    if (_headContext == buffRoot) {\n+\n+                    if (returnEnd) {\n+                        return t;\n+                    }\n+                    // Hmmh. Do we need both checks, or should above suffice?\n+                    if (gotEnd || (_headContext == buffRoot)) {\n                         return null;\n                     }\n                 }\n                     f = _headContext.setFieldName(name);\n                     if (f == TokenFilter.INCLUDE_ALL) {\n                         _itemFilter = f;\n-                        return _nextBuffered();\n+                        return _nextBuffered(buffRoot);\n                     }\n                     if (f == null) { // filter out the value\n                         delegate.nextToken();\n                     }\n                     _itemFilter = f;\n                     if (f == TokenFilter.INCLUDE_ALL) {\n-                        return _nextBuffered();\n+                        return _nextBuffered(buffRoot);\n                     }\n                 }\n                 continue main_loop;\n             default: // scalar value\n                 f = _itemFilter;\n                 if (f == TokenFilter.INCLUDE_ALL) {\n-                    return _nextBuffered();\n+                    return _nextBuffered(buffRoot);\n                 }\n                 if (f != null) {\n                     f = _headContext.checkValue(f);\n                     if ((f == TokenFilter.INCLUDE_ALL)\n                             || ((f != null) && f.includeValue(delegate))) {\n-                        return _nextBuffered();\n+                        return _nextBuffered(buffRoot);\n                     }\n                 }\n                 // Otherwise not included (leaves must be explicitly included)\n         }\n     }\n \n-    private JsonToken _nextBuffered() throws IOException\n+    private JsonToken _nextBuffered(TokenFilterContext buffRoot) throws IOException\n     {\n-        TokenFilterContext ctxt = _exposedContext;\n+        _exposedContext = buffRoot;\n+        TokenFilterContext ctxt = buffRoot;\n         JsonToken t = ctxt.nextTokenToRead();\n         if (t != null) {\n             return t;\n--- a/src/test/java/com/fasterxml/jackson/core/BaseTest.java\n+++ b/src/test/java/com/fasterxml/jackson/core/BaseTest.java\n         g.close();\n     }\n \n+    protected String readAndWrite(JsonFactory f, JsonParser p) throws IOException\n+    {\n+        StringWriter sw = new StringWriter(100);\n+        JsonGenerator g = f.createGenerator(sw);\n+        try {\n+            while (p.nextToken() != null) {\n+                g.copyCurrentEvent(p);\n+            }\n+        } catch (IOException e) {\n+            g.flush();\n+            fail(\"Unexpected problem during `readAndWrite`. Output so far: '\"+sw+\"'; problem: \"+e);\n+        }\n+        p.close();\n+        g.close();\n+        return sw.toString();\n+    }\n+\n     /*\n     /**********************************************************\n     /* Additional assertion methods\n--- a/src/test/java/com/fasterxml/jackson/core/filter/BasicGeneratorFilteringTest.java\n+++ b/src/test/java/com/fasterxml/jackson/core/filter/BasicGeneratorFilteringTest.java\n  * filtering.\n  */\n @SuppressWarnings(\"resource\")\n-public class BasicGeneratorFilteringTest extends com.fasterxml.jackson.core.BaseTest\n+public class BasicGeneratorFilteringTest extends BaseTest\n {\n     static class NameMatchFilter extends TokenFilter\n     {\n         @Override\n         protected boolean _includeScalar() { return false; }\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Test methods\n         writeJsonDoc(JSON_F, JSON, gen);\n         assertEquals(aposToQuotes(\"{'root':{'a':{'value':3},'b':{'value':4}}}\"), w.toString());\n     }\n-    \n+\n     public void testIndexMatchWithPath1() throws Exception\n     {\n         StringWriter w = new StringWriter();\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/filter/BasicParserFilteringTest.java\n+package com.fasterxml.jackson.core.filter;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+public class BasicParserFilteringTest extends BaseTest\n+{\n+    static class NameMatchFilter extends TokenFilter\n+    {\n+        private final Set<String> _names;\n+        \n+        public NameMatchFilter(String... names) {\n+            _names = new HashSet<String>(Arrays.asList(names));\n+        }\n+\n+        @Override\n+        public TokenFilter includeElement(int index) {\n+            return this;\n+        }\n+\n+        @Override\n+        public TokenFilter includeProperty(String name) {\n+            if (_names.contains(name)) {\n+                return TokenFilter.INCLUDE_ALL;\n+            }\n+            return this;\n+        }\n+\n+        @Override\n+        protected boolean _includeScalar() { return false; }\n+    }\n+\n+    static class IndexMatchFilter extends TokenFilter\n+    {\n+        private final BitSet _indices;\n+        \n+        public IndexMatchFilter(int... ixs) {\n+            _indices = new BitSet();\n+            for (int ix : ixs) {\n+                _indices.set(ix);\n+            }\n+        }\n+\n+        @Override\n+        public TokenFilter includeProperty(String name) {\n+            return this;\n+        }\n+        \n+        @Override\n+        public TokenFilter includeElement(int index) {\n+            if (_indices.get(index)) {\n+                return TokenFilter.INCLUDE_ALL;\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        protected boolean _includeScalar() { return false; }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    private final JsonFactory JSON_F = new JsonFactory();\n+\n+    private final String SIMPLE = aposToQuotes(\"{'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}\");\n+\n+    @SuppressWarnings(\"resource\")\n+    public void testNonFiltering() throws Exception\n+    {\n+        JsonParser p = JSON_F.createParser(SIMPLE);\n+        String result = readAndWrite(JSON_F, p);\n+        assertEquals(SIMPLE, result);\n+    }\n+\n+    @SuppressWarnings(\"resource\")\n+    public void testSingleMatchFilteringWithoutPath() throws Exception\n+    {\n+        JsonParser p0 = JSON_F.createParser(SIMPLE);\n+        JsonParser p = new FilteringParserDelegate(p0,\n+               new NameMatchFilter(\"value\"),\n+                   false, // includePath\n+                   false // multipleMatches\n+                );\n+        String result = readAndWrite(JSON_F, p);\n+        assertEquals(aposToQuotes(\"3\"), result);\n+    }\n+\n+    @SuppressWarnings(\"resource\")\n+    public void testSingleMatchFilteringWithPath() throws Exception\n+    {\n+        JsonParser p0 = JSON_F.createParser(SIMPLE);\n+        JsonParser p = new FilteringParserDelegate(p0,\n+               new NameMatchFilter(\"value\"),\n+                   true, // includePath\n+                   false // multipleMatches\n+                );\n+        String result = readAndWrite(JSON_F, p);\n+        assertEquals(aposToQuotes(\"{'ob':{'value':3}}\"), result);\n+    }\n+\n+    @SuppressWarnings(\"resource\")\n+    public void testMultipleMatchFilteringWithPath1() throws Exception\n+    {\n+        JsonParser p0 = JSON_F.createParser(SIMPLE);\n+        JsonParser p = new FilteringParserDelegate(p0,\n+                new NameMatchFilter(\"value0\", \"value2\"),\n+                true, /* includePath */ true /* multipleMatches */ );\n+        String result = readAndWrite(JSON_F, p);\n+        assertEquals(aposToQuotes(\"{'ob':{'value0':2,'value2':4}}\"), result);\n+    }\n+\n+    @SuppressWarnings(\"resource\")\n+    public void testMultipleMatchFilteringWithPath2() throws Exception\n+    {\n+        String INPUT = aposToQuotes(\"{'a':123,'ob':{'value0':2,'value':3,'value2':4},'b':true}\");\n+        JsonParser p0 = JSON_F.createParser(INPUT);\n+        JsonParser p = new FilteringParserDelegate(p0,\n+                new NameMatchFilter(\"b\", \"value\"),\n+                true, true);\n+\n+        String result = readAndWrite(JSON_F, p);\n+        assertEquals(aposToQuotes(\"{'ob':{'value':3},'b':true}\"), result);\n+    }\n+\n+    @SuppressWarnings(\"resource\")\n+    public void testMultipleMatchFilteringWithPath3() throws Exception\n+    {\n+        final String JSON = aposToQuotes(\"{'root':{'a0':true,'a':{'value':3},'b':{'value':4}},'b0':false}\");\n+        JsonParser p0 = JSON_F.createParser(JSON);\n+        JsonParser p = new FilteringParserDelegate(p0,\n+                new NameMatchFilter(\"value\"),\n+                true, true);\n+        String result = readAndWrite(JSON_F, p);\n+        assertEquals(aposToQuotes(\"{'root':{'a':{'value':3},'b':{'value':4}}}\"), result);\n+    }\n+\n+    @SuppressWarnings(\"resource\")\n+    public void testIndexMatchWithPath1() throws Exception\n+    {\n+        JsonParser p = new FilteringParserDelegate(JSON_F.createParser(SIMPLE),\n+                new IndexMatchFilter(1), true, true);\n+        String result = readAndWrite(JSON_F, p);\n+        assertEquals(aposToQuotes(\"{'array':[2]}\"), result);\n+\n+        p = new FilteringParserDelegate(JSON_F.createParser(SIMPLE),\n+                new IndexMatchFilter(0), true, true);\n+        result = readAndWrite(JSON_F, p);\n+        assertEquals(aposToQuotes(\"{'array':[1]}\"), result);\n+    }\n+\n+    @SuppressWarnings(\"resource\")\n+    public void testIndexMatchWithPath2() throws Exception\n+    {\n+        JsonParser p = new FilteringParserDelegate(JSON_F.createParser(SIMPLE),\n+                new IndexMatchFilter(0, 1), true, true);\n+        assertEquals(aposToQuotes(\"{'array':[1,2]}\"), readAndWrite(JSON_F, p));\n+    \n+        String JSON = aposToQuotes(\"{'a':123,'array':[1,2,3,4,5],'b':[1,2,3]}\");\n+        p = new FilteringParserDelegate(JSON_F.createParser(JSON),\n+                new IndexMatchFilter(1, 3), true, true);\n+        assertEquals(aposToQuotes(\"{'array':[2,4],'b':[2]}\"), readAndWrite(JSON_F, p));\n+    }\n+}", "timestamp": 1430759265, "metainfo": ""}