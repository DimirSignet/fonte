{"sha": "8d200d4ac45a37d4fba68064961b0c68d0f076b2", "log": "Fix location handling for byte-backed parser", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n     /**********************************************************\n      */\n \n+    @Override\n+    public JsonLocation getTokenLocation()\n+    {\n+        final Object src = _ioContext.getSourceReference();\n+        return new JsonLocation(src,\n+                -1L, getTokenCharacterOffset(),\n+                getTokenLineNr(),\n+                getTokenColumnNr());\n+    }\n+\n+    @Override\n+    public JsonLocation getCurrentLocation() {\n+        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n+        return new JsonLocation(_ioContext.getSourceReference(),\n+                -1L, _currInputProcessed + _inputPtr,\n+                _currInputRow, col);\n+    }\n+    \n     // @since 2.7\n     private final void _updateLocation()\n     {\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n         return outputCount;\n     }\n \n-    // As per [Issue#108], must ensure we call the right method\n-    @Override\n-    public JsonLocation getTokenLocation()\n-    {\n-        return new JsonLocation(_ioContext.getSourceReference(),\n-                getTokenCharacterOffset(), -1L, // bytes, chars\n-                getTokenLineNr(),\n-                getTokenColumnNr());\n-    }\n-\n-    // As per [Issue#108], must ensure we call the right method\n-    @Override\n-    public JsonLocation getCurrentLocation()\n-    {\n-        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n-        return new JsonLocation(_ioContext.getSourceReference(),\n-                _currInputProcessed + _inputPtr, -1L, // bytes, chars\n-                _currInputRow, col);\n-    }\n-    \n     /*\n     /**********************************************************\n     /* Public API, traversal, basic\n             }\n             i = _skipWS();\n         }\n-        _updateLocation();\n \n         /* And should we now have a name? Always true for\n          * Object contexts, since the intermediate 'expect-value'\n          * state is never retained.\n          */\n         if (!_parsingContext.inObject()) {\n+            _updateLocation();\n             return _nextTokenNotInObject(i);\n         }\n         // So first parse the field name itself:\n+        _updateNameLocation();\n         String n = _parseName(i);\n         _parsingContext.setCurrentName(n);\n         _currToken = JsonToken.FIELD_NAME;\n \n         i = _skipColon();\n+        _updateLocation();\n \n         // Ok: we must have a value... what is it? Strings are very common, check first:\n         if (i == INT_QUOTE) {\n             i = _skipWS();\n         }\n \n-        _updateLocation();\n         if (!_parsingContext.inObject()) {\n+            _updateLocation();\n             _nextTokenNotInObject(i);\n             return false;\n         }\n         \n         // // // This part differs, name parsing\n+        _updateNameLocation();\n         if (i == INT_QUOTE) {\n             // when doing literal match, must consider escaping:\n             byte[] nameBytes = str.asQuotedUTF8();\n             }\n             i = _skipWS();\n         }\n-        _updateLocation();\n         if (!_parsingContext.inObject()) {\n+            _updateLocation();\n             _nextTokenNotInObject(i);\n             return null;\n         }\n \n+        _updateNameLocation();\n         final String nameStr = _parseName(i);\n         _parsingContext.setCurrentName(nameStr);\n         _currToken = JsonToken.FIELD_NAME;\n \n         i = _skipColon();\n+        _updateLocation();\n         if (i == INT_QUOTE) {\n             _tokenIncomplete = true;\n             _nextToken = JsonToken.VALUE_STRING;\n     private final void _isNextTokenNameYes(int i) throws IOException\n     {\n         _currToken = JsonToken.FIELD_NAME;\n+        _updateLocation();\n \n         switch (i) {\n         case '\"':\n         }\n         _nextToken = _handleUnexpectedValue(i);\n     }\n-    \n-    \n+\n     private final boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException\n     {\n         // // // and this is back to standard nextToken()\n         final boolean match = n.equals(str.getValue());\n         _currToken = JsonToken.FIELD_NAME;\n         i = _skipColon();\n+        _updateLocation();\n \n         // Ok: we must have a value... what is it? Strings are very common, check first:\n         if (i == INT_QUOTE) {\n     /**********************************************************\n      */\n \n+    // As per [core#108], must ensure we call the right method\n+    @Override\n+    public JsonLocation getTokenLocation()\n+    {\n+        final Object src = _ioContext.getSourceReference();\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+            return new JsonLocation(src,\n+                    _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        }\n+        return new JsonLocation(src,\n+                getTokenCharacterOffset(), -1L,\n+                getTokenLineNr(),\n+                getTokenColumnNr());\n+    }\n+\n+    // As per [core#108], must ensure we call the right method\n+    @Override\n+    public JsonLocation getCurrentLocation()\n+    {\n+        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n+        return new JsonLocation(_ioContext.getSourceReference(),\n+                _currInputProcessed + _inputPtr, -1L, // bytes, chars\n+                _currInputRow, col);\n+    }\n+\n     // @since 2.7\n     private final void _updateLocation()\n     {", "timestamp": 1448513413, "metainfo": ""}