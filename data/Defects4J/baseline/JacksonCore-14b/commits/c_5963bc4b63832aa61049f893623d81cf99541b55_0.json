{"sha": "5963bc4b63832aa61049f893623d81cf99541b55", "log": "clean up; adding skeletal methods for native Object Id handling", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/Base64Variant.java\n+++ b/src/main/java/com/fasterxml/jackson/core/Base64Variant.java\n      *\n      * @throws IllegalArgumentException if input is not valid base64 encoded data\n      */\n+    @SuppressWarnings(\"resource\")\n     public byte[] decode(String input) throws IllegalArgumentException\n     {\n         ByteArrayBuilder b = new ByteArrayBuilder();\n--- a/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n \n     /*\n     /**********************************************************\n-    /* Public API, write methods, Native Ids\n-    /**********************************************************\n-     */\n+    /* Public API, write methods, Native Ids (type, object)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Introspection method that may be called to see if the underlying\n+     * data format supports some kind of Object Ids natively (many do not;\n+     * for example, JSON doesn't).\n+     * This method <b>must</b> be called prior to calling\n+     * {@link #writeObjectId}.\n+     *<p>\n+     * Default implementation returns false; overridden by data formats\n+     * that do support native Object Ids. Caller is expected to either\n+     * use a non-native notation (explicit property or such), or fail,\n+     * in case it can not use native object ids.\n+     * \n+     * @since 2.3\n+     */\n+    public boolean canWriteObjectId() {\n+        return false;\n+    }\n \n     /**\n      * Introspection method that may be called to see if the underlying\n         return false;\n     }\n \n+    /**\n+     * Method that can be called to output so-called native Object Id.\n+     * Note that it may only be called after ensuring this is legal\n+     * (with {@link #canWriteObjectId()}), as not all data formats\n+     * have native type id support; and some may only allow them in\n+     * certain positions or locations.\n+     * If output is not allowed by the data format in this position,\n+     * a {@link JsonGenerationException} will be thrown.\n+     * \n+     * @since 2.3\n+     */\n+    public void writeObjectId(String typeId)\n+        throws IOException, JsonGenerationException {\n+        throw new JsonGenerationException(\"No native support for writing Object Ids\");\n+    }\n+    \n     /**\n      * Method that can be called to output so-called native Type Id.\n      * Note that it may only be called after ensuring this is legal\n--- a/src/main/java/com/fasterxml/jackson/core/JsonParseException.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonParseException.java\n public class JsonParseException\n     extends JsonProcessingException\n {\n-    final static long serialVersionUID = 123; // Stupid eclipse...\n+    private static final long serialVersionUID = 1L;\n \n     public JsonParseException(String msg, JsonLocation loc)\n     {\n--- a/src/main/java/com/fasterxml/jackson/core/io/JsonStringEncoder.java\n+++ b/src/main/java/com/fasterxml/jackson/core/io/JsonStringEncoder.java\n      * Will quote given JSON String value using standard quoting, encode\n      * results as UTF-8, and return result as a byte array.\n      */\n+    @SuppressWarnings(\"resource\")\n     public byte[] quoteAsUTF8(String text)\n     {\n         ByteArrayBuilder byteBuilder = _byteBuilder;\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n             _tokenIncomplete = false;\n         } else { // may actually require conversion...\n             if (_binaryValue == null) {\n+                @SuppressWarnings(\"resource\")\n                 ByteArrayBuilder builder = _getByteArrayBuilder();\n                 _decodeBase64(getText(), builder, b64variant);\n                 _binaryValue = builder.toByteArray();\n      * Efficient handling for incremental parsing of base64-encoded\n      * textual content.\n      */\n+    @SuppressWarnings(\"resource\")\n     protected byte[] _decodeBase64(Base64Variant b64variant)\n         throws IOException, JsonParseException\n     {\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n import java.math.BigInteger;\n \n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.core.JsonGenerator.Feature;\n import com.fasterxml.jackson.core.io.*;\n \n public class UTF8JsonGenerator\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n             _tokenIncomplete = false;\n         } else { // may actually require conversion...\n             if (_binaryValue == null) {\n+                @SuppressWarnings(\"resource\")\n                 ByteArrayBuilder builder = _getByteArrayBuilder();\n                 _decodeBase64(getText(), builder, b64variant);\n                 _binaryValue = builder.toByteArray();\n      * Efficient handling for incremental parsing of base64-encoded\n      * textual content.\n      */\n+    @SuppressWarnings(\"resource\")\n     protected byte[] _decodeBase64(Base64Variant b64variant)\n         throws IOException, JsonParseException\n     {\n--- a/src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java\n      * single space for indentation. It is used as the default\n      * indenter for array values.\n      */\n-    public static class FixedSpaceIndenter\n-        extends NopIndenter\n-    {\n+    public static class FixedSpaceIndenter extends NopIndenter\n+    {\n+        @SuppressWarnings(\"hiding\")\n         public static final FixedSpaceIndenter instance = new FixedSpaceIndenter();\n \n         @Override\n      * Default linefeed-based indenter uses system-specific linefeeds and\n      * 2 spaces for indentation per level.\n      */\n-    public static class Lf2SpacesIndenter\n-        extends NopIndenter\n-    {\n+    public static class Lf2SpacesIndenter extends NopIndenter\n+    {\n+        @SuppressWarnings(\"hiding\")\n         public static final Lf2SpacesIndenter instance = new Lf2SpacesIndenter();\n \n         private final static String SYS_LF;\n--- a/src/main/java/com/fasterxml/jackson/core/util/JsonParserSequence.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonParserSequence.java\n         return new JsonParserSequence(p.toArray(new JsonParser[p.size()]));\n     }\n \n+    @SuppressWarnings(\"resource\")\n     protected void addFlattenedActiveParsers(List<JsonParser> result)\n     {\n         for (int i = _nextParser-1, len = _parsers.length; i < len; ++i) {\n--- a/src/test/java/com/fasterxml/jackson/core/base64/TestBase64Generation.java\n+++ b/src/test/java/com/fasterxml/jackson/core/base64/TestBase64Generation.java\n             +\" be long enough include a line wrap or two...\";\n     private final static String TEXT4 = TEXT + TEXT + TEXT + TEXT;\n \n+    @SuppressWarnings(\"resource\")\n     private void _testStreamingWrites(JsonFactory jf, boolean useBytes) throws Exception\n     {\n         final byte[] INPUT = TEXT4.getBytes(\"UTF-8\");\n--- a/src/test/java/com/fasterxml/jackson/core/base64/TestBase64Parsing.java\n+++ b/src/test/java/com/fasterxml/jackson/core/base64/TestBase64Parsing.java\n      */\n     \n     // Test for [JACKSON-631]\n+    @SuppressWarnings(\"resource\")\n     public void _testBase64Text(boolean useBytes) throws Exception\n     {\n         // let's actually iterate over sets of encoding modes, lengths\n--- a/src/test/java/com/fasterxml/jackson/core/base64/TestJsonParserBinary.java\n+++ b/src/test/java/com/fasterxml/jackson/core/base64/TestJsonParserBinary.java\n         byte[] data = jp.getBinaryValue();\n         assertNotNull(data);\n         assertArrayEquals(RESULT_BYTES, data);\n+        jp.close();\n     }\n \n     private void _testInArray(boolean useStream)\n             assertArrayEquals(entries[i], b);\n         }\n         assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        jp.close();\n     }\n \n     private void _testEscaped(boolean useStream) throws IOException\n--- a/src/test/java/com/fasterxml/jackson/core/io/TestJDKSerializable.java\n+++ b/src/test/java/com/fasterxml/jackson/core/io/TestJDKSerializable.java\n         \n         assertEquals(loc.getLineNr(), loc2.getLineNr());\n         assertEquals(loc.getColumnNr(), loc2.getColumnNr());\n+        jp.close();\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/core/json/TestUnicode.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/TestUnicode.java\n             assertEquals(\"\\uD83D\\uDE03\", jp.getText());\n         }\n         assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+        jp.close();\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/core/main/TestArrayParsing.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestArrayParsing.java\n public class TestArrayParsing\n     extends com.fasterxml.jackson.test.BaseTest\n {\n-    public void testValidEmpty()\n-        throws Exception\n+    public void testValidEmpty() throws Exception\n     {\n         final String DOC = \"[   \\n  ]\";\n \n         jp.close();\n     }\n \n-    public void testInvalidEmptyMissingClose()\n-        throws Exception\n+    public void testInvalidEmptyMissingClose() throws Exception\n     {\n         final String DOC = \"[ \";\n \n         } catch (JsonParseException jex) {\n             verifyException(jex, \"expected close marker for ARRAY\");\n         }\n+        jp.close();\n     }\n \n-    public void testInvalidMissingFieldName()\n-        throws Exception\n+    public void testInvalidMissingFieldName() throws Exception\n     {\n         final String DOC = \"[  : 3 ] \";\n \n         } catch (JsonParseException jex) {\n             verifyException(jex, \"Unexpected character\");\n         }\n+        jp.close();\n     }\n \n-    public void testInvalidExtraComma()\n-        throws Exception\n+    public void testInvalidExtraComma() throws Exception\n     {\n         final String DOC = \"[ 24, ] \";\n \n         } catch (JsonParseException jex) {\n             verifyException(jex, \"expected a value\");\n         }\n+        jp.close();\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/core/main/TestGeneratorClosing.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestGeneratorClosing.java\n  * <code>JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT</code>\n  * are tested.\n  */\n-public class TestGeneratorClosing\n-    extends BaseTest\n+public class TestGeneratorClosing extends BaseTest\n {\n     /*\n     /**********************************************************\n \n     final static class MyWriter extends StringWriter\n     {\n-        boolean mIsClosed = false;\n+        boolean _isClosed = false;\n \n         public MyWriter() { }\n \n         @Override\n         public void close() throws IOException {\n-            mIsClosed = true;\n+            _isClosed = true;\n             super.close();\n         }\n-        public boolean isClosed() { return mIsClosed; }\n+        public boolean isClosed() { return _isClosed; }\n     }\n \n     final static class MyStream extends ByteArrayOutputStream\n     {\n-        boolean mIsClosed = false;\n+        boolean _isClosed = false;\n \n         public MyStream() { }\n \n         @Override\n         public void close() throws IOException {\n-            mIsClosed = true;\n+            _isClosed = true;\n             super.close();\n         }\n-        public boolean isClosed() { return mIsClosed; }\n+        public boolean isClosed() { return _isClosed; }\n     }\n \n     static class MyBytes extends ByteArrayOutputStream\n      * automatic closing should occur, nor explicit one unless specific\n      * forcing method is used.\n      */\n-    public void testNoAutoCloseGenerator()\n-        throws Exception\n+    public void testNoAutoCloseGenerator() throws Exception\n     {\n         JsonFactory f = new JsonFactory();\n \n         // then change\n         f.disable(JsonGenerator.Feature.AUTO_CLOSE_TARGET);\n         assertFalse(f.isEnabled(JsonGenerator.Feature.AUTO_CLOSE_TARGET));\n+        @SuppressWarnings(\"resource\")\n         MyWriter output = new MyWriter();\n         JsonGenerator jg = f.createGenerator(output);\n \n         assertFalse(output.isClosed());\n     }\n \n-    public void testCloseGenerator()\n-        throws Exception\n+    public void testCloseGenerator() throws Exception\n     {\n         JsonFactory f = new JsonFactory();\n         f.enable(JsonGenerator.Feature.AUTO_CLOSE_TARGET);\n+        @SuppressWarnings(\"resource\")\n         MyWriter output = new MyWriter();\n         JsonGenerator jg = f.createGenerator(output);\n \n         assertTrue(output.isClosed());\n     }\n \n-    public void testNoAutoCloseOutputStream()\n-        throws Exception\n+    public void testNoAutoCloseOutputStream() throws Exception\n     {\n         JsonFactory f = new JsonFactory();\n         f.disable(JsonGenerator.Feature.AUTO_CLOSE_TARGET);\n+        @SuppressWarnings(\"resource\")\n         MyStream output = new MyStream();\n         JsonGenerator jg = f.createGenerator(output, JsonEncoding.UTF8);\n \n     }\n \n     // [JACKSON-401]\n+    @SuppressWarnings(\"resource\")\n     public void testAutoFlushOrNot() throws Exception\n     {\n         JsonFactory f = new JsonFactory();\n--- a/src/test/java/com/fasterxml/jackson/core/main/TestParserWithObjects.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestParserWithObjects.java\n         _testNextValueNested(true);\n     }\n \n-    public void testIsClosed()\n-        throws IOException\n+    @SuppressWarnings(\"resource\")\n+    public void testIsClosed() throws IOException\n     {\n         for (int i = 0; i < 4; ++i) {\n             String JSON = \"[ 1, 2, 3 ]\";\n--- a/src/test/java/com/fasterxml/jackson/core/main/TestRawStringWriting.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestRawStringWriting.java\n             assertArrayEquals(inputBytes, outputBytes);\n         }\n         assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        jp.close();\n     }\n \n     /**\n             assertArrayEquals(inputBytes, outputBytes);\n         }\n         assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        jp.close();\n     }\n     \n     /*\n--- a/src/test/java/com/fasterxml/jackson/core/main/TestScopeMatching.java\n+++ b/src/test/java/com/fasterxml/jackson/core/main/TestScopeMatching.java\n public class TestScopeMatching\n     extends BaseTest\n {\n-    public void testUnclosedArray()\n-        throws Exception\n+    public void testUnclosedArray() throws Exception\n     {\n+        @SuppressWarnings(\"resource\")\n         JsonParser jp = createParserUsingReader(\"[ 1, 2\");\n         assertToken(JsonToken.START_ARRAY, jp.nextToken());\n         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n         }\n     }\n \n-    public void testUnclosedObject()\n-        throws Exception\n+    public void testUnclosedObject() throws Exception\n     {\n+        @SuppressWarnings(\"resource\")\n         JsonParser jp = createParserUsingReader(\"{ \\\"key\\\" : 3  \");\n         assertToken(JsonToken.START_OBJECT, jp.nextToken());\n         assertToken(JsonToken.FIELD_NAME, jp.nextToken());", "timestamp": 1375585633, "metainfo": ""}