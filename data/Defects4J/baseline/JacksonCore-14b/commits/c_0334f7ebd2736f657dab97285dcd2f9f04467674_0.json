{"sha": "0334f7ebd2736f657dab97285dcd2f9f04467674", "log": "Minor robustification, javadoc improvements", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/TreeNode.java\n+++ b/src/main/java/com/fasterxml/jackson/core/TreeNode.java\n      * Functionally equivalent to first serializing tree using\n      * {@link ObjectCodec} and then re-parsing but\n      * more efficient.\n+     *<p>\n+     * NOTE: constructed parser instance will NOT initially point to a token,\n+     * so before passing it to deserializers, it is typically necessary to\n+     * advance it to the first available token by calling {@link JsonParser#nextToken()}.\n+     *<p>\n+     * Also note that calling this method will <b>NOT</b> pass {@link ObjectCodec}\n+     * reference, so data-binding callback methods like {@link JsonParser#readValueAs(Class)}\n+     * will not work with calling {@link JsonParser#setCodec}).\n+     * It is often better to call {@link #traverse(ObjectCodec)} to pass the codec explicitly.\n      */\n     JsonParser traverse();\n \n      * Same as {@link #traverse()}, but additionally passes {@link com.fasterxml.jackson.core.ObjectCodec}\n      * to use if {@link JsonParser#readValueAs(Class)} is used (otherwise caller must call\n      * {@link JsonParser#setCodec} on response explicitly).\n+     *<p>\n+     * NOTE: constructed parser instance will NOT initially point to a token,\n+     * so before passing it to deserializers, it is typically necessary to\n+     * advance it to the first available token by calling {@link JsonParser#nextToken()}.\n      * \n      * @since 2.1\n      */\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n      */\n \n     @Override\n-    protected final boolean loadMore()\n-        throws IOException\n+    protected final boolean loadMore() throws IOException\n     {\n         _currInputProcessed += _inputEnd;\n         _currInputRowStart -= _inputEnd;\n         \n         if (_inputStream != null) {\n-            int count = _inputStream.read(_inputBuffer, 0, _inputBuffer.length);\n+            int space = _inputBuffer.length;\n+            if (space == 0) { // only occurs when we've been closed\n+                return false;\n+            }\n+            \n+            int count = _inputStream.read(_inputBuffer, 0, space);\n             if (count > 0) {\n                 _inputPtr = 0;\n                 _inputEnd = count;\n      * Helper method that will try to load at least specified number bytes in\n      * input buffer, possible moving existing data around if necessary\n      */\n-    protected final boolean _loadToHaveAtLeast(int minAvailable)\n-        throws IOException\n+    protected final boolean _loadToHaveAtLeast(int minAvailable) throws IOException\n     {\n         // No input stream, no leading (either we are closed, or have non-stream input source)\n         if (_inputStream == null) {\n         if (_bufferRecyclable) {\n             byte[] buf = _inputBuffer;\n             if (buf != null) {\n-                _inputBuffer = null;\n+                /* 21-Nov-2014, tatu: Let's not set it to null; this way should\n+                 *   get slightly more meaningful error messages in case someone\n+                 *   closes parser indirectly, without realizing.\n+                 */\n+                _inputBuffer = ByteArrayBuilder.NO_BYTES;\n                 _ioContext.releaseReadIOBuffer(buf);\n             }\n         }\n--- a/src/main/java/com/fasterxml/jackson/core/util/ByteArrayBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/ByteArrayBuilder.java\n  */\n public final class ByteArrayBuilder extends OutputStream\n {\n-    private final static byte[] NO_BYTES = new byte[0];\n+    public final static byte[] NO_BYTES = new byte[0];\n     \n     // Size of the first block we will allocate.\n     private final static int INITIAL_BLOCK_SIZE = 500;", "timestamp": 1416614098, "metainfo": ""}