{"sha": "b1ac057b038805530cf83d952b708be5fa9bb8fb", "log": "Incremental work for parser-filtering", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java\n     {\n         // Anything buffered?\n         TokenFilterContext ctxt = _exposedContext;\n+\n         if (ctxt != null) {\n             while (true) {\n-                JsonToken t = _exposedContext.nextTokenToRead(_currToken);\n+                JsonToken t = _exposedContext.nextTokenToRead();\n                 if (t != null) {\n                     _currToken = t;\n                     return t;\n     /**\n      * Offlined handling for cases where there was no buffered token to\n      * return, and the token read next could not be returned as-is,\n-     * at least not yet.\n+     * at least not yet, but where we have not yet established that\n+     * buffering is needed.\n      */\n     protected final JsonToken _nextToken2() throws IOException\n     {\n+        main_loop:\n         while (true) {\n             JsonToken t = delegate.nextToken();\n-            if (t == null) { // is this really legal? For the moment, assume it is\n+\n+            if (t == null) { // is this even legal?\n                 return (_currToken = t);\n             }\n-            switch (_currToken.id()) {\n+            TokenFilter f;\n+\n+            switch (t.id()) {\n             case ID_START_ARRAY:\n-                if (_itemFilter == TokenFilter.INCLUDE_ALL) {\n-                    _headContext = _headContext.createChildArrayContext(_itemFilter, true);\n-                    return (_currToken = t);\n-                }\n-                if (_itemFilter == null) { // does this occur?\n-                    delegate.skipChildren();\n-                    break;\n-                }\n-                _exposedContext = _headContext = _headContext.createChildArrayContext(_itemFilter, false);\n-                break;\n-    \n+                f = _itemFilter;\n+                if (f == TokenFilter.INCLUDE_ALL) {\n+                    _headContext = _headContext.createChildArrayContext(f, true);\n+                    return (_currToken = t);\n+                }\n+                if (f == null) { // does this occur?\n+                    delegate.skipChildren();\n+                    continue main_loop;\n+                }\n+                // Otherwise still iffy, need to check\n+                f = _headContext.checkValue(f);\n+                if (f == null) {\n+                    delegate.skipChildren();\n+                    continue main_loop;\n+                }\n+                if (f != TokenFilter.INCLUDE_ALL) {\n+                    f = f.filterStartArray();\n+                }\n+                _itemFilter = f;\n+                _headContext = _headContext.createChildArrayContext(f, true);\n+                if (f == TokenFilter.INCLUDE_ALL) {\n+                    return (_currToken = t);\n+                }\n+                // but if we didn't figure it out yet, need to buffer possible events\n+                return _nextTokenWithBuffering(_headContext);\n+\n             case ID_START_OBJECT:\n-                if (_itemFilter == TokenFilter.INCLUDE_ALL) {\n-                    _headContext = _headContext.createChildObjectContext(_itemFilter, true);\n-                    return (_currToken = t);\n-                }\n-                if (_itemFilter == null) { // does this occur?\n-                    delegate.skipChildren();\n-                    break;\n-                }\n-                _exposedContext = _headContext = _headContext.createChildObjectContext(_itemFilter, false);\n-                break;\n-    \n+                f = _itemFilter;\n+                if (f == TokenFilter.INCLUDE_ALL) {\n+                    _headContext = _headContext.createChildObjectContext(f, true);\n+                    return (_currToken = t);\n+                }\n+                if (f == null) { // does this occur?\n+                    delegate.skipChildren();\n+                    continue main_loop;\n+                }\n+                // Otherwise still iffy, need to check\n+                f = _headContext.checkValue(f);\n+                if (f == null) {\n+                    delegate.skipChildren();\n+                    continue main_loop;\n+                }\n+                if (f != TokenFilter.INCLUDE_ALL) {\n+                    f = f.filterStartObject();\n+                }\n+                _itemFilter = f;\n+                _headContext = _headContext.createChildObjectContext(f, true);\n+                if (f == TokenFilter.INCLUDE_ALL) {\n+                    return (_currToken = t);\n+                }\n+                // but if we didn't figure it out yet, need to buffer possible events\n+                return _nextTokenWithBuffering(_headContext);\n+\n             case ID_END_ARRAY:\n             case ID_END_OBJECT:\n                 {\n                     boolean returnEnd = _headContext.isStartHandled();\n-                    TokenFilter f = _headContext.getFilter();\n+                    f = _headContext.getFilter();\n                     if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                         f.filterFinishArray();\n                     }\n                         return (_currToken = t);\n                     }\n                 }\n-                break;\n-    \n+                continue main_loop;\n+\n             case ID_FIELD_NAME:\n                 {\n                     final String name = delegate.getCurrentName();\n-                    TokenFilter f = _headContext.setFieldName(name);\n+                    f = _headContext.setFieldName(name);\n+                    if (f == TokenFilter.INCLUDE_ALL) {\n+                        _itemFilter = f;\n+                        return (_currToken = t);\n+                    }\n                     if (f == null) { // filter out the value\n                         delegate.nextToken();\n                         delegate.skipChildren();\n                         break;\n                     }\n-                    if (_itemFilter == TokenFilter.INCLUDE_ALL) {\n+                    f = f.includeProperty(name);\n+                    if (f == null) { // filter out the value\n+                        delegate.nextToken();\n+                        delegate.skipChildren();\n+                        break;\n+                    }\n+                    if (f == TokenFilter.INCLUDE_ALL) {\n                         _itemFilter = f;\n                         return (_currToken = t);\n                     }\n-                    f = f.includeProperty(name);\n+                    // !!! TODO: still not decided if to include, so...\n+                    \n                     _itemFilter = f;\n                 }\n-                break;\n+                continue main_loop;\n \n             default: // scalar value\n                 if (_itemFilter == TokenFilter.INCLUDE_ALL) {\n                     return (_currToken = t);\n                 }\n                 // Otherwise not included (leaves must be explicitly included)\n-                break;\n+                continue main_loop;\n             }\n         }\n     }\n     protected final JsonToken _nextTokenWithBuffering(TokenFilterContext buffRoot) throws IOException\n     {\n         _exposedContext = _headContext;\n-        // !!! TODO\n-        return null;\n-    }\n+\n+        while (true) {\n+            JsonToken t = delegate.nextToken();\n+\n+            if (t == null) { // is this even legal?\n+                return (_currToken = t);\n+            }\n+            TokenFilter f;\n+\n+            switch (t.id()) {\n+            case ID_START_ARRAY:\n+                f = _itemFilter;\n+                if (f == TokenFilter.INCLUDE_ALL) {\n+                    _headContext = _headContext.createChildArrayContext(f, true);\n+                    return (_currToken = t);\n+                }\n+                if (f == null) { // does this occur?\n+                    delegate.skipChildren();\n+                    break;\n+                }\n+                // Otherwise still iffy, need to check\n+                f = _headContext.checkValue(f);\n+                if (f == null) {\n+                    delegate.skipChildren();\n+                    break;\n+                }\n+                if (f != TokenFilter.INCLUDE_ALL) {\n+                    f = f.filterStartArray();\n+                }\n+                _itemFilter = f;\n+                _headContext = _headContext.createChildArrayContext(f, true);\n+                if (f == TokenFilter.INCLUDE_ALL) {\n+                    return (_currToken = t);\n+                }\n+                break;\n+\n+            case ID_START_OBJECT:\n+                f = _itemFilter;\n+                if (f == TokenFilter.INCLUDE_ALL) {\n+                    _headContext = _headContext.createChildObjectContext(f, true);\n+                    return (_currToken = t);\n+                }\n+                if (f == null) { // does this occur?\n+                    delegate.skipChildren();\n+                    break;\n+                }\n+                // Otherwise still iffy, need to check\n+                f = _headContext.checkValue(f);\n+                if (f == null) {\n+                    delegate.skipChildren();\n+                    break;\n+                }\n+                if (f != TokenFilter.INCLUDE_ALL) {\n+                    f = f.filterStartObject();\n+                }\n+                _itemFilter = f;\n+                _headContext = _headContext.createChildObjectContext(f, true);\n+                if (f == TokenFilter.INCLUDE_ALL) {\n+                    return (_currToken = t);\n+                }\n+                break;\n+\n+            case ID_END_ARRAY:\n+            case ID_END_OBJECT:\n+                {\n+                    boolean returnEnd = _headContext.isStartHandled();\n+                    f = _headContext.getFilter();\n+                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n+                        f.filterFinishArray();\n+                    }\n+                    _headContext = _headContext.getParent();\n+                    _itemFilter = _headContext.getFilter();\n+                    if (returnEnd) {\n+                        return (_currToken = t);\n+                    }\n+                }\n+                break;\n+\n+            case ID_FIELD_NAME:\n+                {\n+                    final String name = delegate.getCurrentName();\n+                    f = _headContext.setFieldName(name);\n+                    if (f == TokenFilter.INCLUDE_ALL) {\n+                        _itemFilter = f;\n+                        return (_currToken = t);\n+                    }\n+                    if (f == null) { // filter out the value\n+                        delegate.nextToken();\n+                        delegate.skipChildren();\n+                        break;\n+                    }\n+                    f = f.includeProperty(name);\n+                    if (f == null) { // filter out the value\n+                        delegate.nextToken();\n+                        delegate.skipChildren();\n+                        break;\n+                    }\n+                    if (f == TokenFilter.INCLUDE_ALL) {\n+                        _itemFilter = f;\n+                        return (_currToken = t);\n+                    }\n+                    // !!! TODO: still not decided if to include, so...\n+                    \n+                    _itemFilter = f;\n+                }\n+                break;\n+\n+            default: // scalar value\n+                if (_itemFilter == TokenFilter.INCLUDE_ALL) {\n+                    return (_currToken = t);\n+                }\n+                // Otherwise not included (leaves must be explicitly included)\n+                break;\n+            }\n+        }\n+   }\n     \n     @Override\n     public JsonToken nextValue() throws IOException {\n--- a/src/main/java/com/fasterxml/jackson/core/filter/TokenFilterContext.java\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/TokenFilterContext.java\n     public TokenFilter getFilter() { return _filter; }\n     public boolean isStartHandled() { return _startHandled; }\n \n-    public JsonToken nextTokenToRead(JsonToken curr) {\n+    public JsonToken nextTokenToRead() {\n         if (!_startHandled) {\n             if (_type == TYPE_OBJECT) {\n                 return JsonToken.START_OBJECT;\n             return JsonToken.START_ARRAY;\n         }\n         // But otherwise at most might have FIELD_NAME\n-        if ((curr == JsonToken.START_OBJECT) && (_type == TYPE_OBJECT)) {\n+        if (_needToHandleName && (_type == TYPE_OBJECT)) {\n+            _needToHandleName = false;\n             return JsonToken.FIELD_NAME;\n         }\n         return null;\n--- a/src/test/java/com/fasterxml/jackson/core/filter/JsonPointerGeneratorFilteringTest.java\n+++ b/src/test/java/com/fasterxml/jackson/core/filter/JsonPointerGeneratorFilteringTest.java\n         // and then non-match\n         _assert(SIMPLE_INPUT, \"/x\", false, \"\");\n     }\n-    \n+\n     private void _assert(String input, String pathExpr, boolean includeParent, String exp)\n         throws Exception\n     {\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/filter/JsonPointerParserFilteringTest.java\n+package com.fasterxml.jackson.core.filter;\n+\n+import java.io.StringWriter;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+public class JsonPointerParserFilteringTest extends com.fasterxml.jackson.core.BaseTest\n+{\n+    private final JsonFactory JSON_F = new JsonFactory();\n+\n+    final String SIMPLEST_INPUT = aposToQuotes(\"{'a':1,'b':2,'c':3}\");\n+\n+    final String SIMPLE_INPUT = aposToQuotes(\"{'a':1,'b':[1,2,3],'c':{'d':{'a':true}},'d':null}\");\n+\n+    public void testSimplestWithPath() throws Exception\n+    {\n+        _assert(SIMPLEST_INPUT, \"/b\", true, \"{'b':2}\");\n+    }\n+\n+    public void testSimplestNoPath() throws Exception\n+    {\n+        _assert(SIMPLEST_INPUT, \"/b\", false, \"2\");\n+    }\n+\n+    @SuppressWarnings(\"resource\")\n+    void _assert(String input, String pathExpr, boolean includeParent, String exp)\n+        throws Exception\n+    {\n+        JsonParser p0 = JSON_F.createParser(input);\n+        FilteringParserDelegate p = new FilteringParserDelegate(p0,\n+                new JsonPointerBasedFilter(pathExpr, includeParent),\n+                includeParent, false);\n+        StringWriter w = new StringWriter();\n+        JsonGenerator g = JSON_F.createGenerator(w);\n+\n+        try {\n+System.err.println(\"Start\");            \n+            while (p.nextToken() != null) {\n+System.err.println(\"Token -> \"+p.getCurrentToken());                \n+                g.copyCurrentEvent(p);\n+            }\n+System.err.println(\"Finish\");            \n+            p.close();\n+            g.close();\n+        } catch (Exception e) {\n+            g.flush();\n+            System.err.println(\"With input '\"+input+\"', output at point of failure: <\"+w+\">\");\n+            throw e;\n+        }\n+\n+        assertEquals(aposToQuotes(exp), w.toString());\n+    }\n+}", "timestamp": 1429162500, "metainfo": ""}