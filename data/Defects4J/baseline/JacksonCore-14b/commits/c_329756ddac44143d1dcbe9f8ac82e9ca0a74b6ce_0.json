{"sha": "329756ddac44143d1dcbe9f8ac82e9ca0a74b6ce", "log": "...", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n     /**\n      * Method called when caller wants to provide input buffer directly,\n      * and it may or may not be recyclable use standard recycle context.\n-     * \n+     *\n      * @since 2.4\n      */\n     public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n \n     @Override public ObjectCodec getCodec() { return _objectCodec; }\n     @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n-    \n+\n     @Override\n     public int releaseBuffered(Writer w) throws IOException {\n         int count = _inputEnd - _inputPtr;\n             }\n         }\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Public API, data access\n         }\n         return (_currToken = _handleOddValue(i));\n     }\n-    \n+\n     // note: identical to one in UTF8StreamJsonParser\n     @Override\n     public final String nextTextValue() throws IOException\n         if (ch == INT_0) {\n             return _parseNumber2(false, startPtr);\n         }\n-            \n+\n         /* First, let's see if the whole number is contained within\n          * the input buffer unsplit. This should be the common case;\n          * and to simplify processing, we will just reparse contents\n          * in the alternative case (number split on buffer boundary)\n          */\n-        \n+\n         int intLen = 1; // already got one\n-        \n+\n         // First let's get the obligatory integer part:\n         int_loop:\n         while (true) {\n             return _parseNumber2(true, startPtr);\n         }\n         int intLen = 1; // already got one\n-        \n+\n         // First let's get the obligatory integer part:\n         int_loop:\n         while (true) {\n                     return '0';\n                 }\n                 ++_inputPtr; // skip previous zero\n-                if (ch != '0') { // followed by other number; return \n+                if (ch != '0') { // followed by other number; return\n                     break;\n                 }\n             }\n         _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n         return null;\n     }\n-    \n+\n     protected JsonToken _handleApos() throws IOException\n     {\n         char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n         _textBuffer.setCurrentLength(outPtr);\n         return JsonToken.VALUE_STRING;\n     }\n-    \n+\n     private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n     {\n         _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n             return _symbols.findSymbol(buf, start, len, hash);\n         }\n     }\n-  \n+\n     @Override\n     protected final void _finishString() throws IOException\n     {\n     /* Internal methods, other parsing\n     /**********************************************************\n      */\n-    \n+\n     /**\n      * We actually need to check the character value here\n      * (to see if we have \\n following \\r).\n         ++_currInputRow;\n         _currInputRowStart = _inputPtr;\n     }\n-    \n+\n     private final int _skipColon() throws IOException\n     {\n         if ((_inputPtr + 4) >= _inputEnd) {\n                     if (i == INT_SLASH || i == INT_HASH) {\n                         return _skipColon2(true);\n                     }\n-                    ++_inputPtr;                    \n+                    ++_inputPtr;\n                     return i;\n                 }\n             }\n         _inputPtr = ptr-1;\n         return _skipColon2(gotColon);\n     }\n-    \n+\n     // Primary loop: no reloading, comment handling\n     private final int _skipComma(int i) throws IOException\n     {\n         }\n         throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n     }\n-    \n+\n     private final int _skipWSOrEnd() throws IOException\n     {\n         // Let's handle first character separately since it is likely that\n                 _throwInvalidSpace(i);\n             }\n         }\n-        \n+\n         while (_inputPtr < _inputEnd) {\n             i = (int) _inputBuffer[_inputPtr++];\n             if (i > INT_SPACE) {\n             }\n         }\n     }\n-    \n+\n     private void _skipComment() throws IOException\n     {\n         if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n         _skipLine();\n         return true;\n     }\n-    \n+\n     private void _skipLine() throws IOException\n     {\n         // Ok: need to find EOF or linefeed\n         }\n         return (char) value;\n     }\n-    \n+\n     private final void _matchTrue() throws IOException {\n         int ptr = _inputPtr;\n         if ((ptr + 3) < _inputEnd) {\n                 }\n             }\n             int decodedData = bits;\n-            \n+\n             // then second base64 char; can't get padding yet, nor ws\n-            \n+\n             if (_inputPtr >= _inputEnd) {\n                 loadMoreGuaranteed();\n             }\n                 bits = _decodeBase64Escape(b64variant, ch, 1);\n             }\n             decodedData = (decodedData << 6) | bits;\n-            \n+\n             // third base64 char; can be padding, but not ws\n             if (_inputPtr >= _inputEnd) {\n                 loadMoreGuaranteed();\n     protected void _reportInvalidToken(String matchedPart) throws IOException {\n         _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n     }\n-    \n+\n     protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n     {\n         StringBuilder sb = new StringBuilder(matchedPart);", "timestamp": 1447742135, "metainfo": ""}