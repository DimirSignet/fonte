{"sha": "e0a02273c70bb5d44ebbe70e97aec06e83a28f99", "log": "Improve situation wrt #187, both by increasing limit to 200, and by adding one more operation for 2-quad (5-8 byte) case, resulting in significantly shorter max collision chain length", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/sym/BytesToNameCanonicalizer.java\n      * chains are shared between multiple primary cells, which could cause\n      * problems for lower values.\n      *<p>\n-     * Also note that value was lowered from 255 (2.3 and earlier) to 100 for 2.4\n+     * Also note that value was lowered from 255 (2.3 and earlier) to 100 for 2.4,\n+     * but raised again to 200 for 2.5.2 (as per [core#187])\n      * \n      * @since 2.1\n      */\n-    private final static int MAX_COLL_CHAIN_LENGTH = 100;\n+    private final static int MAX_COLL_CHAIN_LENGTH = 200;\n \n     /**\n      * No point in trying to construct tiny tables, just need to resize soon.\n \n     public int calcHash(int q1, int q2)\n     {\n-        /* For two quads, let's change algorithm a bit, to spice\n-         * things up (can do bit more processing anyway)\n-         */\n+        // For two quads, let's change algorithm a bit, to spice\n+        // things up (can do bit more processing anyway)\n         int hash = q1;\n         hash ^= (hash >>> 15); // try mixing first and second byte pairs first\n         hash += (q2 * MULT); // then add second quad\n         hash ^= _seed;\n         hash += (hash >>> 7); // and shuffle some more\n+        // 26-Mar-2015, tatu: As per [core#187] need bit more shuffling. This may\n+        //   seem like a magical number (and in a way, it is), but it was the sweet\n+        //   spot for some reason (5 and 3 work ok but converges for 4, for tested case)\n+        hash ^= (hash >>> 4);\n         return hash;\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n+++ b/src/test/java/com/fasterxml/jackson/core/sym/TestSymbolTables.java\n \n //System.out.printf(\"Byte stuff: collisions %d, max-coll %d\\n\", symbols.collisionCount(), symbols.maxCollisionLength());\n     \n-        // Fewer collisions than with chars, but still quite a few\n-        assertEquals(1686, symbols.collisionCount());\n+        assertEquals(1733, symbols.collisionCount());\n         // but not super long collision chains:\n         assertEquals(9, symbols.maxCollisionLength());\n     }\n             symbolsC.release();\n         }\n     }\n+\n+    // [core#187]: unexpectedly high number of collisions for straight numbers\n+    public void testCollisionsWithBytes187() throws IOException\n+    {\n+        BytesToNameCanonicalizer symbols =\n+                BytesToNameCanonicalizer.createRoot(1).makeChild(JsonFactory.Feature.collectDefaults());\n+        final int COUNT = 30000;\n+        for (int i = 0; i < COUNT; ++i) {\n+            String id = String.valueOf(10000 + i);\n+            int[] quads = BytesToNameCanonicalizer.calcQuads(id.getBytes(\"UTF-8\"));\n+            symbols.addName(id, quads, quads.length);\n+        }\n+\n+//System.out.printf(\"Byte stuff: collisions %d, max-coll %d\\n\", symbols.collisionCount(), symbols.maxCollisionLength());\n+        \n+        assertEquals(COUNT, symbols.size());\n+        assertEquals(65536, symbols.bucketCount());\n+\n+        // collision count acceptable\n+        assertEquals(5782, symbols.collisionCount());\n+        // as well as collision counts\n+        assertEquals(24, symbols.maxCollisionLength());\n+    }\n+\n+    // [core#187]: unexpectedly high number of collisions for straight numbers\n+    public void testCollisionsWithChars187() throws IOException\n+    {\n+        CharsToNameCanonicalizer symbols = CharsToNameCanonicalizer.createRoot(1);\n+        final int COUNT = 30000;\n+        for (int i = 0; i < COUNT; ++i) {\n+            String id = String.valueOf(10000 + i);\n+            char[] ch = id.toCharArray();\n+            symbols.findSymbol(ch, 0, ch.length, symbols.calcHash(id));\n+        }\n+        assertEquals(COUNT, symbols.size());\n+        assertEquals(65536, symbols.bucketCount());\n+\n+        // collision count rather high, but has to do\n+        assertEquals(14408, symbols.collisionCount());\n+        // as well as collision counts\n+        assertEquals(10, symbols.maxCollisionLength());\n+    }\n }", "timestamp": 1427429139, "metainfo": ""}