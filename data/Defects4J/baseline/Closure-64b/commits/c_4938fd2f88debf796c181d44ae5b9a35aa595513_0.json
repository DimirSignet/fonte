{"sha": "4938fd2f88debf796c181d44ae5b9a35aa595513", "log": "Add a pass type that just reports an error (Brad)  Add externs for new events. (Eric)  Make CrossModuleCodeMotion detect more recursions. (Alan)  Run cross module code motion before and after devirtualization. (Alan)  Revision created by MOE tool push_codebase. MOE_MIGRATION=   ", "commit": "\n--- a/src/com/google/javascript/jscomp/CrossModuleCodeMotion.java\n+++ b/src/com/google/javascript/jscomp/CrossModuleCodeMotion.java\n       }\n       \n       // CASE #2:\n-      Node rootParent = rootNode.getParent();\n-      if (rootParent.getType() == Token.ASSIGN) {\n-        Node owner = rootParent.getFirstChild();\n-        while (owner.getType() == Token.GETPROP) {\n-          owner = owner.getFirstChild();\n-        }\n-        if (owner.getType() == Token.NAME && owner.getString().equals(name)) {\n-          recursive = true;\n+\n+\n+      // Suppose name is Foo, we keep look up the scope stack to look for\n+      // a scope with \"Foo.prototype.bar = function() { ..... \"\n+      for  (Scope s = t.getScope(); s.getParent() != null; s = s.getParent()) {\n+        Node curRoot = s.getRootNode();\n+        if (curRoot.getParent().getType() == Token.ASSIGN) {\n+          Node owner = curRoot.getParent().getFirstChild();\n+          while (owner.getType() == Token.GETPROP) {\n+            owner = owner.getFirstChild();\n+          }\n+          if (owner.getType() == Token.NAME && owner.getString().equals(name)) {\n+            recursive = true;\n+            break;\n+          }\n         }\n       }\n     }\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n     if (options.smartNameRemoval || options.reportPath != null) {\n       passes.addAll(getCodeRemovingPasses());\n       passes.add(smartNamePass);\n+    }\n+\n+    // TODO(user): This forces a first crack at crossModuleCodeMotion\n+    // before devirtualization. Once certain functions are devirtualized,\n+    // it confuses crossModuleCodeMotion ability to recognized that\n+    // it is recursive.\n+\n+    // TODO(user): This is meant for a temporary quick win.\n+    // In the future, we might want to improve our analysis in\n+    // CrossModuleCodeMotion so we don't need to do this.\n+    if (options.crossModuleCodeMotion) {\n+      passes.add(crossModuleCodeMotion);\n     }\n \n     // Method devirtualization benefits from property disambiguiation so\n     return additionalReplacements;\n   }\n \n-  /** A compiler pass that just reports an error. */\n-  private static class ErrorPass implements CompilerPass {\n-    private final AbstractCompiler compiler;\n-    private final JSError error;\n-\n-    private ErrorPass(AbstractCompiler compiler, DiagnosticType error) {\n-      this(compiler, JSError.make(error));\n-    }\n-\n-    private ErrorPass(AbstractCompiler compiler, JSError error) {\n-      this.compiler = compiler;\n-      this.error = error;\n-    }\n-\n-    @Override\n-    public void process(Node externs, Node root) {\n-      compiler.report(error);\n-    }\n-  }\n-\n   /** A compiler pass that marks pure functions. */\n   private static class PureFunctionMarker implements CompilerPass {\n     private final AbstractCompiler compiler;\n--- /dev/null\n+++ b/src/com/google/javascript/jscomp/ErrorPass.java\n+/*\n+ * Copyright 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.javascript.jscomp;\n+\n+import com.google.javascript.rhino.Node;\n+\n+/**\n+ * A compiler pass that just reports an error.\n+ *\n+*\n+ */\n+\n+public class ErrorPass implements CompilerPass {\n+    private final AbstractCompiler compiler;\n+    private final JSError error;\n+    \n+    public ErrorPass(AbstractCompiler compiler, DiagnosticType error) {\n+      this(compiler, JSError.make(error));\n+    }\n+\n+    public ErrorPass(AbstractCompiler compiler, JSError error) {\n+      this.compiler = compiler;\n+      this.error = error;\n+    }\n+\n+    @Override\n+    public void process(Node externs, Node root) {\n+      compiler.report(error);\n+    }\n+  }\n--- a/src/com/google/javascript/jscomp/NameGenerator.java\n+++ b/src/com/google/javascript/jscomp/NameGenerator.java\n    * @return An array of characters to use. Will return the chars array if\n    *    reservedCharacters is null or empty, otherwise creates a new array.\n    */\n-  private char[] reserveCharacters(char[] chars, char[] reservedCharacters) {\n+  static char[] reserveCharacters(char[] chars, char[] reservedCharacters) {\n     if (reservedCharacters == null || reservedCharacters.length == 0) {\n       return chars;\n     }    \n--- a/test/com/google/javascript/jscomp/CrossModuleCodeMotionTest.java\n+++ b/test/com/google/javascript/jscomp/CrossModuleCodeMotionTest.java\n       \"function g(){};\"));\n   }\n   \n-  public void testRecursiveReference() {\n+  public void testClone1() {\n     test(createModuleChain(\n              // m1\n              \"function f(){} f.prototype.clone = function() { return new f };\",\n            \"var a = (new f).clone();\"\n          });\n   }\n-}\n+\n+  public void testClone2() {\n+    test(createModuleChain(\n+             // m1\n+             \"function f(){}\" +\n+             \"f.prototype.cloneFun = function() {\" +\n+             \"  return function() {new f}\" +\n+             \"};\",\n+             // m2\n+             \"var a = (new f).cloneFun();\"),\n+         new String[] {\n+           // m1\n+           \"\",\n+           \"function f(){}\" +\n+           \"f.prototype.cloneFun = function() {\" +\n+           \"  return function() {new f}\" +\n+           \"};\" +\n+           // m2\n+           \"var a = (new f).cloneFun();\"\n+         });\n+  }  \n+}", "timestamp": 1268202247, "metainfo": ""}