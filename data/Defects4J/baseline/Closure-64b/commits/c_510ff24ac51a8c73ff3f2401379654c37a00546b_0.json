{"sha": "510ff24ac51a8c73ff3f2401379654c37a00546b", "log": "Fold a few more comparison cases.  R=nicksantos DELTA=215  (169 added, 20 deleted, 26 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=98   ", "commit": "\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n \n       case Token.VOID:\n         return \"undefined\";\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Gets the value of a node as a Number, or null if it cannot be converted.\n+   * When it returns a non-null Double, this method effectively emulates the\n+   * <code>Number()</code> JavaScript cast function.\n+   */\n+  static Double getNumberValue(Node n) {\n+    switch (n.getType()) {\n+      case Token.TRUE:\n+        return 1.0;\n+      case Token.FALSE:\n+      case Token.NULL:\n+        return 0.0;\n+\n+      case Token.NUMBER:\n+        return n.getDouble();\n+\n+      case Token.VOID:\n+        return Double.NaN;\n+\n+      case Token.NAME:\n+        String name = n.getString();\n+        if (name.equals(\"undefined\")) {\n+          return Double.NaN;\n+        }\n+        if (name.equals(\"NaN\")) {\n+          return Double.NaN;\n+        }\n+        if (name.equals(\"Infinity\")) {\n+          return Double.POSITIVE_INFINITY;\n+        }\n+        return null;\n     }\n     return null;\n   }\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n       case Token.MUL:\n       case Token.BITAND:\n       case Token.BITOR:\n-        if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) {\n-          return tryFoldArithmeticOp(subtree, left, right);\n-        } else {\n-          return tryFoldLeftChildOp(subtree, left, right);\n-        }\n+        Node result = tryFoldArithmeticOp(subtree, left, right);\n+        if (result != subtree) {\n+          return result;\n+        }\n+        return tryFoldLeftChildOp(subtree, left, right);\n \n       case Token.LT:\n       case Token.GT:\n    * Try to fold arithmetic binary operators\n    */\n   private Node tryFoldArithmeticOp(Node n, Node left, Node right) {\n-    if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) {\n-      Node result = performArithmeticOp(n.getType(), left, right);\n-      if (result != null) {\n-        n.getParent().replaceChild(n, result);\n-        reportCodeChange();\n-        return result;\n-      }\n+    Node result = performArithmeticOp(n.getType(), left, right);\n+    if (result != null) {\n+      n.getParent().replaceChild(n, result);\n+      reportCodeChange();\n+      return result;\n     }\n     return n;\n   }\n    * Try to fold arithmetic binary operators\n    */\n   private Node performArithmeticOp(int opType, Node left, Node right) {\n-    Preconditions.checkState(left.getType() == Token.NUMBER);\n-    Preconditions.checkState(right.getType() == Token.NUMBER);\n+    // Unlike other operations, ADD operands are not always converted\n+    // to Number.\n+    if (opType == Token.ADD\n+        && (left.getType() != Token.NUMBER\n+            || right.getType() != Token.NUMBER)) {\n+      return null;\n+    }\n+\n     double result;\n-    double lval = left.getDouble();\n-    double rval = right.getDouble();\n+\n+    Double lValObj = NodeUtil.getNumberValue(left);\n+    if (lValObj == null) {\n+      return null;\n+    }\n+    Double rValObj = NodeUtil.getNumberValue(right);\n+    if (rValObj == null) {\n+      return null;\n+    }\n+\n+    double lval = lValObj;\n+    double rval = rValObj;\n \n     switch (opType) {\n       case Token.BITAND:\n         Math.abs(result) <= MAX_FOLD_NUMBER) {\n       Node newNumber = Node.newNumber(result);\n       return newNumber;\n+    } else if (Double.isNaN(result)) {\n+      return Node.newString(Token.NAME, \"NaN\");\n+    } else if (result == Double.POSITIVE_INFINITY) {\n+      return Node.newString(Token.NAME, \"Infinity\");\n+    } else if (result == Double.NEGATIVE_INFINITY) {\n+      return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n     }\n \n     return null;\n         break;\n \n       case Token.NULL:\n-        if (undefinedRight) {\n-          result = compareToUndefined(left, op);\n-          break;\n-        }\n-        // fall through\n       case Token.TRUE:\n       case Token.FALSE:\n         if (undefinedRight) {\n           result = compareToUndefined(left, op);\n           break;\n         }\n-        // fall through\n-      case Token.THIS:\n-        int tt = right.getType();\n-        if (tt != Token.THIS &&\n-            tt != Token.TRUE &&\n-            tt != Token.FALSE &&\n-            tt != Token.NULL) {\n+        int rhType = right.getType();\n+        if (rhType != Token.TRUE &&\n+            rhType != Token.FALSE &&\n+            rhType != Token.NULL) {\n           return n;\n         }\n         switch (op) {\n             result = left.getType() != right.getType();\n             break;\n \n+          case Token.GE:\n+          case Token.LE:\n+          case Token.GT:\n+          case Token.LT:\n+            Boolean compareResult = compareAsNumbers(op, left, right);\n+            if (compareResult != null) {\n+              result = compareResult;\n+            } else {\n+              return n;\n+            }\n+            break;\n+\n           default:\n             return n;  // we only handle == and != here\n+        }\n+        break;\n+\n+      case Token.THIS:\n+        if (right.getType() != Token.THIS) {\n+          return n;\n+        }\n+        switch (op) {\n+          case Token.SHEQ:\n+          case Token.EQ:\n+            result = true;\n+            break;\n+\n+          case Token.SHNE:\n+          case Token.NE:\n+            result = false;\n+            break;\n+\n+          // We can only handle == and != here.\n+          // GT, LT, GE, LE depend on the type of \"this\" and how it will\n+          // be converted to number.  The results are different depending on\n+          // whether it is a string, NaN or other number value.\n+          default:\n+            return n;\n         }\n         break;\n \n         if (Token.NUMBER != right.getType()) {\n           return n;  // Only eval if they are the same type\n         }\n-        double lv = left.getDouble();\n-        double rv = right.getDouble();\n-\n-        switch (op) {\n-          case Token.SHEQ:\n-          case Token.EQ: result = lv == rv; break;\n-          case Token.SHNE:\n-          case Token.NE: result = lv != rv; break;\n-          case Token.LE: result = lv <= rv; break;\n-          case Token.LT: result = lv <  rv; break;\n-          case Token.GE: result = lv >= rv; break;\n-          case Token.GT: result = lv >  rv; break;\n-          default:\n-            return n;  // don't handle that op\n+        Boolean compareResult = compareAsNumbers(op, left, right);\n+        if (compareResult != null) {\n+          result = compareResult;\n+        } else {\n+          return null;\n         }\n         break;\n \n     reportCodeChange();\n \n     return newNode;\n+  }\n+\n+  /**\n+   * The result of the comparison as a Boolean or null if the\n+   * result could not be determined.\n+   */\n+  private Boolean compareAsNumbers(int op, Node left, Node right) {\n+    Double leftValue = NodeUtil.getNumberValue(left);\n+    if (leftValue == null) {\n+      return null;\n+    }\n+    Double rightValue = NodeUtil.getNumberValue(right);\n+    if (rightValue == null) {\n+      return null;\n+    }\n+\n+    double lv = leftValue;\n+    double rv = rightValue;\n+\n+    Boolean result;\n+    switch (op) {\n+      case Token.SHEQ:\n+      case Token.EQ:\n+        Preconditions.checkState(\n+            left.getType() == Token.NUMBER && right.getType() == Token.NUMBER);\n+        result = lv == rv;\n+        break;\n+      case Token.SHNE:\n+      case Token.NE:\n+        Preconditions.checkState(\n+            left.getType() == Token.NUMBER && right.getType() == Token.NUMBER);\n+        result = lv != rv;\n+        break;\n+      case Token.LE: result = lv <= rv; break;\n+      case Token.LT: result = lv <  rv; break;\n+      case Token.GE: result = lv >= rv; break;\n+      case Token.GT: result = lv >  rv; break;\n+      default:\n+        return null;  // don't handle that op\n+    }\n+    return result;\n   }\n \n   /**\n--- a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n     fold(\"x = y + (z * 24 * 60 * 60 * 1000)\", \"x = y + z * 864E5\");\n   }\n \n+  public void testFoldArithmetic3() {\n+    fold(\"x = null * undefined\", \"x = NaN\");\n+    fold(\"x = null * 1\", \"x = 0\");\n+    fold(\"x = (null - 1) * 2\", \"x = -2\");\n+    foldSame(\"x = (null + 1) * 2\"); // We don't fold \"+\" with mixed types yet.\n+  }\n+\n   public void testFoldArithmeticStringComp() {\n     // Negative Numbers.\n     assertResultString(\"x = 10 - 20\", \"x=-10\");\n \n     foldSame(\"Infinity >= Infinity\");\n     foldSame(\"NaN >= NaN\");\n+  }\n+\n+  public void testFoldLiteralsTypeMismatches() {\n+    fold(\"true == true\", \"true\");\n+    fold(\"true == false\", \"false\");\n+    fold(\"true == null\", \"false\");\n+    fold(\"false == null\", \"false\");\n+\n+    // relational operators convert its operands\n+    fold(\"null <= null\", \"true\"); // 0 = 0\n+    fold(\"null >= null\", \"true\");\n+    fold(\"null > null\", \"false\");\n+    fold(\"null < null\", \"false\");\n+\n+    fold(\"false >= null\", \"true\"); // 0 = 0\n+    fold(\"false <= null\", \"true\");\n+    fold(\"false > null\", \"false\");\n+    fold(\"false < null\", \"false\");\n+\n+    fold(\"true >= null\", \"true\");  // 1 > 0\n+    fold(\"true <= null\", \"false\");\n+    fold(\"true > null\", \"true\");\n+    fold(\"true < null\", \"false\");\n+\n+    fold(\"true >= false\", \"true\");  // 1 > 0\n+    fold(\"true <= false\", \"false\");\n+    fold(\"true > false\", \"true\");\n+    fold(\"true < false\", \"false\");\n   }\n \n   private static final List<String> LITERAL_OPERANDS =\n         .build();\n     Set<String> comparators = ImmutableSet.of(\"<=\", \"<\", \">=\", \">\");\n     Set<String> equalitors = ImmutableSet.of(\"==\", \"===\");\n-    Set<String> uncomparables = ImmutableSet.of(\"null\", \"undefined\", \"void 0\");\n+    Set<String> uncomparables = ImmutableSet.of(\"undefined\", \"void 0\");\n     List<String> operators = ImmutableList.copyOf(inverses.values());\n     for (int iOperandA = 0; iOperandA < LITERAL_OPERANDS.size(); iOperandA++) {\n       for (int iOperandB = 0;\n           // Test invertability.\n           if (comparators.contains(op) &&\n               (uncomparables.contains(a) || uncomparables.contains(b))) {\n-            // TODO(nicksantos): Eventually, all cases should be collapsed.\n-            assertSameResultsOrUncollapsed(join(a, op, b), \"false\");\n-            assertSameResultsOrUncollapsed(join(a, inverse, b), \"false\");\n+            assertSameResults(join(a, op, b), \"false\");\n+            assertSameResults(join(a, inverse, b), \"false\");\n           } else if (a.equals(b) && equalitors.contains(op)) {\n             if (a.equals(\"NaN\") || a.equals(\"Infinity\")) {\n               foldSame(join(a, op, b));", "timestamp": 1291847480, "metainfo": ""}