{"sha": "48701cc70fde194c05ecd008fc1015b9d82921d1", "log": "- Generalize unused operation removal and remove a couple of special cases (HOOK, NOT). - Add handling for other AST locations that can have unused ops removed (COMMA lhs and FOR increment expressions).  R=acleung DELTA=358  (260 added, 80 deleted, 18 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=197245   ", "commit": "\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n       }\n     }\n     return true;\n+  }\n+\n+  static boolean isSimpleOperator(Node n) {\n+    return isSimpleOperatorType(n.getType());\n   }\n \n   /**\n    * @param callNode - construtor call node\n    */\n   static boolean constructorCallHasSideEffects(Node callNode) {\n+    return constructorCallHasSideEffects(callNode, null);\n+  }\n+\n+  static boolean constructorCallHasSideEffects(\n+      Node callNode, AbstractCompiler compiler) {\n     Preconditions.checkArgument(\n         callNode.getType() == Token.NEW,\n         \"Expected NEW node, got \" + Token.name(callNode.getType()));\n    * the reason's why a subtree has side effects.\n    */\n   static boolean nodeTypeMayHaveSideEffects(Node n) {\n+    return nodeTypeMayHaveSideEffects(n, null);\n+  }\n+\n+  static boolean nodeTypeMayHaveSideEffects(Node n, AbstractCompiler compiler) {\n     if (isAssignmentOp(n)) {\n       return true;\n     }\n \n     switch(n.getType()) {\n-      case Token.CALL:\n       case Token.DELPROP:\n-      case Token.NEW:\n       case Token.DEC:\n       case Token.INC:\n       case Token.THROW:\n         return true;\n+      case Token.CALL:\n+        return NodeUtil.functionCallHasSideEffects(n, compiler);\n+      case Token.NEW:\n+        return NodeUtil.constructorCallHasSideEffects(n, compiler);\n       case Token.NAME:\n         // A variable definition.\n         return n.hasChildren();\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n \n     if (left == null) {\n       return n;\n-    }\n-\n-    // TODO(dcc): Just dropping the unary op makes some tests\n-    // (e.g. PeepholeIntegration.testMinimizeExpr) very confusing because it\n-    // leads to transformations like \"!!true\" --> \"!false\" --> \"false\".\n-    // Do we really need to do this here?\n-\n-    if (NodeUtil.isExpressionNode(parent)) {\n-      // If the value isn't used, then just throw\n-      // away the operator\n-      Node replacement = n.removeFirstChild();\n-      parent.replaceChild(n, replacement);\n-      reportCodeChange();\n-      return replacement;\n     }\n \n     TernaryValue leftVal = NodeUtil.getBooleanValue(left);\n--- a/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n+++ b/src/com/google/javascript/jscomp/PeepholeRemoveDeadCode.java\n       case Token.BLOCK:\n         return tryOptimizeBlock(subtree);\n       case Token.EXPR_RESULT:\n-        return tryFoldHookExpr(subtree);\n+        subtree = tryFoldExpr(subtree);\n+        return subtree;\n       case Token.HOOK:\n         return tryFoldHook(subtree);\n       case Token.SWITCH:\n         default:\n           return subtree;\n     }\n+  }\n+\n+  /**\n+   * Try folding EXPR_RESULT nodes by removing useless Ops and expressions.\n+   * @return the replacement node, if changed, or the original if not\n+   */\n+  private Node tryFoldExpr(Node subtree) {\n+    if (subtree.getParent().getType() != Token.LABEL) {\n+      Node result = trySimpilifyUnusedResult(subtree.getFirstChild());\n+      if (result == null) {\n+        // If the EXPR_RESULT no longer has any children, remove it as well.\n+        subtree.detachFromParent();\n+        subtree = null;\n+      }\n+    }\n+    return subtree;\n+  }\n+\n+  /**\n+   * General cascading unused operation node removal.\n+   * @param n The root of the expression to simplify.\n+   * @return The replacement node, or null if the node was is not useful.\n+   */\n+  private Node trySimpilifyUnusedResult(Node n) {\n+    return trySimpilifyUnusedResult(n, true);\n+  }\n+\n+  /**\n+   * General cascading unused operation node removal.\n+   * @param n The root of the expression to simplify.\n+   * @param removeUnused If true, the node is removed from the AST if\n+   *     it is not useful, otherwise it replaced with an EMPTY node.\n+   * @return The replacement node, or null if the node was is not useful.\n+   */\n+  private Node trySimpilifyUnusedResult(Node n, boolean removeUnused) {\n+    Node result = n;\n+\n+    // Simplify the results of conditional expressions\n+    switch (n.getType()) {\n+      case Token.HOOK:\n+        Node trueNode = trySimpilifyUnusedResult(n.getFirstChild().getNext());\n+        Node falseNode = trySimpilifyUnusedResult(n.getLastChild());\n+        // If one or more of the conditional children were removed,\n+        // transform the HOOK to an equivalent operation:\n+        //    x() ? foo() : 1 --> x() && foo()\n+        //    x() ? 1 : foo() --> x() || foo()\n+        //    x() ? 1 : 1 --> x()\n+        //    x ? 1 : 1 --> null\n+        if (trueNode == null && falseNode != null) {\n+          n.setType(Token.OR);\n+          Preconditions.checkState(n.getChildCount() == 2);\n+        } else if (trueNode != null && falseNode == null) {\n+          n.setType(Token.AND);\n+          Preconditions.checkState(n.getChildCount() == 2);\n+        } else if (trueNode == null && falseNode == null) {\n+          result = trySimpilifyUnusedResult(n.getFirstChild());\n+        } else {\n+          // The structure didn't change.\n+          result = n;\n+        }\n+        break;\n+      case Token.AND:\n+      case Token.OR:\n+        // Try to remove the second operand from a AND or OR operations:\n+        //    x() || f --> x()\n+        //    x() && f --> x()\n+        Node conditionalResultNode = trySimpilifyUnusedResult(\n+            n.getLastChild());\n+        if (conditionalResultNode == null) {\n+          Preconditions.checkState(n.hasOneChild());\n+          // The conditionally executed code was removed, so\n+          // replace the AND/OR with its LHS or remove it if it isn't useful.\n+          result = trySimpilifyUnusedResult(n.getFirstChild());\n+        }\n+        break;\n+      case Token.FUNCTION:\n+        // A function expression isn't useful if it isn't used, remove it and\n+        // don't bother to look at its children.\n+        result = null;\n+        break;\n+      case Token.COMMA:\n+        // We rewrite other operations as COMMA expressions (which will later\n+        // get split into individual EXPR_RESULT statement, if possible), so\n+        // we special case COMMA (we don't want to rewrite COMMAs as new COMMAs\n+        // nodes.\n+        Node left = trySimpilifyUnusedResult(n.getFirstChild());\n+        Node right = trySimpilifyUnusedResult(n.getLastChild());\n+        if (left == null && right == null) {\n+          result = null;\n+        } else if (left == null) {\n+          result = right;\n+        } else if (right == null){\n+          result = left;\n+        } else {\n+          // The structure didn't change.\n+          result = n;\n+        }\n+        break;\n+      default:\n+        if (!NodeUtil.nodeTypeMayHaveSideEffects(n)) {\n+          // This is the meat of this function. The node itself doesn't generate\n+          // any side-effects but preserve any side-effects in the children.\n+          Node resultList = null;\n+          for (Node next, c = n.getFirstChild(); c != null; c = next) {\n+            next = c.getNext();\n+            c = trySimpilifyUnusedResult(c);\n+            if (c != null) {\n+              c.detachFromParent();\n+              if (resultList == null)  {\n+                // The first side-effect can be used stand-alone.\n+                resultList = c;\n+              } else {\n+                // Leave the side-effects in-place, simplifying it to a COMMA\n+                // expression.\n+                resultList = new Node(Token.COMMA, resultList, c)\n+                    .copyInformationFrom(c);\n+              }\n+            }\n+          }\n+          result = resultList;\n+        }\n+    }\n+\n+    // Fix up the AST, replace or remove the an unused node (if requested).\n+    if (n != result) {\n+      Node parent = n.getParent();\n+      if (result == null) {\n+        if (removeUnused) {\n+          parent.removeChild(n);\n+        } else {\n+          result = new Node(Token.EMPTY).copyInformationFrom(n);\n+          parent.replaceChild(n, result);\n+        }\n+      } else {\n+        // A new COMMA expression may not have an existing parent.\n+        if (result.getParent() != null) {\n+          result.detachFromParent();\n+        }\n+        n.getParent().replaceChild(n, result);\n+      }\n+      reportCodeChange();\n+    }\n+\n+    return result;\n   }\n \n   /**\n     Node left = n.getFirstChild();\n     Node right = left.getNext();\n \n-    if (!mayHaveSideEffects(left)) {\n+    left = trySimpilifyUnusedResult(left, false);\n+    if (left == null || !mayHaveSideEffects(left)) {\n       // Fold it!\n       n.removeChild(right);\n       parent.replaceChild(n, right);\n     for (Node c = n.getFirstChild(); c != null; ) {\n       Node next = c.getNext();  // save c.next, since 'c' may be removed\n       if (!mayHaveSideEffects(c)) {\n+        // TODO(johnlenz): determine what this is actually removing. Candidates\n+        //    include: EMPTY nodes, control structures without children\n+        //    (removing infinite loops), empty try blocks.  What else?\n         n.removeChild(c);  // lazy kids\n         reportCodeChange();\n       } else {\n   }\n \n   /**\n-   * Transform HOOK (?:) to IF if this allows the removal of useless branches.\n-   * @return the replacement node, if changed, or the original if not\n-   */\n-  private Node tryFoldHookExpr(Node n) {\n-    Preconditions.checkState(NodeUtil.isExpressionNode(n));\n-    Node hook = n.getFirstChild();\n-    // Only looking at hooks here.\n-    if (hook.getType() != Token.HOOK) {\n-      return n;\n-    }\n-\n-    Node parent = n.getParent();\n-    Preconditions.checkNotNull(parent);\n-    Node cond = hook.getFirstChild();\n-    Node thenBody = cond.getNext();\n-    Node elseBody = thenBody.getNext();\n-\n-    // Try to remove useless conditions and branches.\n-    if (!mayHaveSideEffects(thenBody)) {\n-      // x?void 0:y --> if(!x)y\n-      Node ifNode = new Node(Token.IF);\n-      if (cond.getType() == Token.NOT) {\n-        Node expr = cond.getFirstChild();\n-        cond.removeChild(expr);\n-        ifNode.addChildToBack(expr);\n-      } else {\n-        Node not = new Node(Token.NOT).copyInformationFrom(cond);\n-        hook.removeChild(cond);\n-        not.addChildToBack(cond);\n-        ifNode.addChildToBack(not);\n-      }\n-\n-      hook.removeChild(elseBody);\n-      ifNode.addChildToBack(\n-          new Node(Token.BLOCK, NodeUtil.newExpr(elseBody))\n-              .copyInformationFrom(elseBody));\n-\n-      parent.replaceChild(n, ifNode);\n-      reportCodeChange();\n-      return ifNode;\n-    } else if (!mayHaveSideEffects(elseBody)) {\n-      // x?y:void 0 --> if(x)y\n-      Node ifNode = new Node(Token.IF);\n-      hook.removeChild(cond);\n-      ifNode.addChildToBack(cond);\n-      hook.removeChild(thenBody);\n-\n-      ifNode.addChildToBack(\n-          new Node(Token.BLOCK, NodeUtil.newExpr(thenBody))\n-              .copyInformationFrom(thenBody));\n-\n-      parent.replaceChild(n, ifNode);\n-      reportCodeChange();\n-      return ifNode;\n-    }\n-\n-    return n;\n-  }\n-\n-  /**\n    * Try folding HOOK (?:) if the condition results of the condition is known.\n    * @return the replacement node, if changed, or the original if not\n    */\n    */\n   Node tryFoldFor(Node n) {\n     Preconditions.checkArgument(n.getType() == Token.FOR);\n-    // This is not a FOR-IN loop\n-    if (n.getChildCount() != 4) {\n+    // If this is a FOR-IN loop skip it.\n+    if (NodeUtil.isForIn(n)) {\n       return n;\n     }\n-    // There isn't an initializer\n+\n+    Node init = n.getFirstChild();\n+    Node cond = init.getNext();\n+    Node increment = cond.getNext();\n+\n+    if (init.getType() != Token.EMPTY && init.getType() != Token.VAR) {\n+      init = trySimpilifyUnusedResult(init, false);\n+    }\n+\n+    if (increment.getType() != Token.EMPTY) {\n+      increment = trySimpilifyUnusedResult(increment, false);\n+    }\n+\n+    // There is an initializer skip it\n     if (n.getFirstChild().getType() != Token.EMPTY) {\n       return n;\n     }\n \n-    Node cond = NodeUtil.getConditionExpression(n);\n     if (NodeUtil.getBooleanValue(cond) != TernaryValue.FALSE) {\n       return n;\n     }\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n \n       case Token.WHILE:\n       case Token.DO:\n+        tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n+        return node;\n+\n       case Token.FOR:\n-        if (NodeUtil.getConditionExpression(node) != null) {\n+        if (!NodeUtil.isForIn(node)) {\n           tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n         }\n         return node;\n         return tryFoldLiteralConstructor(node);\n \n       default:\n-          return node; //Nothing changed\n+        return node; //Nothing changed\n     }\n   }\n \n--- a/test/com/google/javascript/jscomp/CreateSyntheticBlocksTest.java\n+++ b/test/com/google/javascript/jscomp/CreateSyntheticBlocksTest.java\n \n   public void testInvalid1() {\n     test(\"startMarker() && true\",\n-        \"startMarker()&&1\", null,\n+        \"startMarker()\", null,\n          CreateSyntheticBlocks.INVALID_MARKER_USAGE);\n   }\n \n--- a/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeFoldConstantsTest.java\n   }\n \n   public void testUnaryOps() {\n-    fold(\"!foo()\", \"foo()\");\n-    fold(\"~foo()\", \"foo()\");\n-    fold(\"-foo()\", \"foo()\");\n+    // These cases are handled by PeepholeRemoveDeadCode.\n+    foldSame(\"!foo()\");\n+    foldSame(\"~foo()\");\n+    foldSame(\"-foo()\");\n+\n+    // These cases are handled here.\n     fold(\"a=!true\", \"a=false\");\n     fold(\"a=!10\", \"a=false\");\n     fold(\"a=!false\", \"a=true\");\n--- a/test/com/google/javascript/jscomp/PeepholeIntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeIntegrationTest.java\n          \"x=cond?2:3\");\n \n     fold(\"x?void 0:y()\", \"x||y()\");\n-    fold(\"!x?void 0:y()\", \"x&&y()\");\n+    fold(\"!x?void 0:y()\", \"(!x)||y()\");\n     fold(\"x?y():void 0\", \"x&&y()\");\n   }\n \n     fold(\"if(x || 3) z()\", \"z()\");\n     fold(\"if(x || false) z()\", \"x&&z()\");\n     test(\"if(x==y && false) z()\", \"\");\n-\n-    // This would be foldable, but it isn't detected, because 'if' isn't\n-    // the parent of 'x || 3'. Cf. FoldConstants.tryFoldAndOr().\n-    fold(\"if(y() || x || 3) z()\", \"y()||x||1;z()\");\n+    fold(\"if(y() || x || 3) z()\", \"y();z()\");\n   }\n \n   public void testFoldBitwiseOpStringCompareIntegration() {\n     test(\"!!true\", \"\");\n \n     fold(\"!!x()\", \"x()\");\n-    test(\"!(!x()&&!y())\", \"!x()&&!y()\");\n+    test(\"!(!x()&&!y())\", \"x()||y()\");\n     fold(\"x()||!!y()\", \"x()||y()\");\n \n     /* This is similar to the !!true case */\n--- a/test/com/google/javascript/jscomp/PeepholeRemoveDeadCodeTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeRemoveDeadCodeTest.java\n     fold(\"if (null){ x = 1; } else { x = 2; }\", \"x=2\");\n     fold(\"if (void 0){ x = 1; } else { x = 2; }\", \"x=2\");\n     fold(\"if (void foo()){ x = 1; } else { x = 2; }\",\n-         \"void foo();x=2\");\n+         \"foo();x=2\");\n     fold(\"if (false){ x = 1; } else if (true) { x = 3; } else { x = 2; }\",\n          \"x=3\");\n     fold(\"if (x){ x = 1; } else if (false) { x = 3; }\",\n     fold(\"true ? a() : b()\", \"a()\");\n     fold(\"false ? a() : b()\", \"b()\");\n \n-    fold(\"a() ? b() : true\", \"if (a()) b()\");\n-    fold(\"a() ? true : b()\", \"if (!a()) b()\");\n+    fold(\"a() ? b() : true\", \"a() && b()\");\n+    fold(\"a() ? true : b()\", \"a() || b()\");\n \n     fold(\"(a = true) ? b() : c()\", \"a = true; b()\");\n     fold(\"(a = false) ? b() : c()\", \"a = false; c()\");\n     fold(\"function x(){foo(), true}\", \"function x(){foo();}\");\n   }\n \n+  public void testRemoveUselessOps() {\n+    // There are four place where expression results are discarded:\n+    //  - a top level expression EXPR_RESULT\n+    //  - the LHS of a COMMA\n+    //  - the FOR init expression\n+    //  - the FOR increment expression\n+\n+\n+    // Known side-effect free functions calls are removed.\n+    fold(\"Math.random()\", \"\");\n+    fold(\"Math.random(f() + g())\", \"f(); g();\");\n+    fold(\"Math.random(f(),g(),h())\", \"f();g();h();\");\n+\n+    // Calls to functions with unknown side-effects are are left.\n+    foldSame(\"f();\");\n+    foldSame(\"(function () {})();\");\n+\n+    // Uncalled function expressions are removed\n+    fold(\"(function () {});\", \"\");\n+    fold(\"(function f() {});\", \"\");\n+    // ... including any code they contain.\n+    fold(\"(function () {foo();});\", \"\");\n+\n+    // Useless operators are removed.\n+    fold(\"+f()\", \"f()\");\n+    fold(\"a=(+f(),g())\", \"a=(f(),g())\");\n+    fold(\"a=(true,g())\", \"a=g()\");\n+    fold(\"f(),true\", \"f()\");\n+    fold(\"f() + g()\", \"f();g()\");\n+\n+    fold(\"for(;;+f()){}\", \"for(;;f()){}\");\n+    fold(\"for(+f();;g()){}\", \"for(f();;g()){}\");\n+    fold(\"for(;;Math.random(f(),g(),h())){}\", \"for(;;f(),g(),h()){}\");\n+\n+    // The optimization cascades into conditional expressions:\n+    fold(\"g() && +f()\", \"g() && f()\");\n+    fold(\"g() || +f()\", \"g() || f()\");\n+    fold(\"x ? g() : +f()\", \"x ? g() : f()\");\n+\n+    fold(\"+x()\", \"x()\");\n+    fold(\"+x() * 2\", \"x()\");\n+    fold(\"-(+x() * 2)\", \"x()\");\n+    fold(\"2 -(+x() * 2)\", \"x()\");\n+    fold(\"x().foo\", \"x()\");\n+    foldSame(\"x().foo()\");\n+\n+    foldSame(\"x++\");\n+    foldSame(\"++x\");\n+    foldSame(\"x--\");\n+    foldSame(\"--x\");\n+    foldSame(\"x = 2\");\n+    foldSame(\"x *= 2\");\n+\n+    // Sanity check, other expression are left alone.\n+    foldSame(\"function f() {}\");\n+    foldSame(\"var x;\");\n+  }\n+\n   public void testOptimizeSwitch() {\n     fold(\"switch(a){}\", \"\");\n     fold(\"switch(foo()){}\", \"foo()\");\n--- a/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n package com.google.javascript.jscomp;\n \n /**\n- * Tests for PeepholeSubstituteAlternateSyntaxTest in isolation. \n- * Tests for the interaction of multiple peephole passes are in \n+ * Tests for PeepholeSubstituteAlternateSyntaxTest in isolation.\n+ * Tests for the interaction of multiple peephole passes are in\n  * PeepholeIntegrationTest.\n  */\n public class PeepholeSubstituteAlternateSyntaxTest extends CompilerTestCase {\n-  \n+\n   // Externs for builtin constructors\n   // Needed for testFoldLiteralObjectConstructors(),\n   // testFoldLiteralArrayConstructors() and testFoldRegExp...()\n-  private static final String FOLD_CONSTANTS_TEST_EXTERNS = \n+  private static final String FOLD_CONSTANTS_TEST_EXTERNS =\n       \"var Object = function(){};\\n\" +\n       \"var RegExp = function(a){};\\n\" +\n       \"var Array = function(a){};\\n\";\n   @Override\n   public void setUp() throws Exception {\n     super.setUp();\n-    \n+\n     enableLineNumberCheck(true);\n   }\n \n     CompilerPass peepholePass =\n       new PeepholeOptimizationsPass(compiler,\n           new PeepholeSubstituteAlternateSyntax());\n-    \n+\n     return peepholePass;\n   }\n \n   void assertResultString(String js, String expected) {\n     assertResultString(js, expected, false);\n   }\n-  \n+\n   // TODO(user): This is same as fold() except it uses string comparison. Any\n   // test that needs tell us where a folding is constructing an invalid AST.\n   void assertResultString(String js, String expected, boolean normalize) {\n-    PeepholeSubstituteAlternateSyntaxTest scTest \n+    PeepholeSubstituteAlternateSyntaxTest scTest\n         = new PeepholeSubstituteAlternateSyntaxTest(false);\n-    \n+\n     if (normalize) {\n       scTest.enableNormalize();\n     } else {\n       scTest.disableNormalize();\n     }\n-    \n+\n     scTest.test(js, expected);\n   }\n-  \n+\n   /** Check that removing blocks with 1 child works */\n   public void testFoldOneChildBlocks() {\n     fold(\"function(){if(x)a();x=3}\",\n     // Try it out with switch statements\n     fold(\"function(){switch(x){case 1:break}}\",\n          \"function(){switch(x){case 1:break}}\");\n-    \n+\n     // Do while loops stay in a block if that's where they started\n     fold(\"function(){if(e1){do foo();while(e2)}else foo2()}\",\n          \"function(){if(e1){do foo();while(e2)}else foo2()}\");\n     fold(\"function z() {if (a) { foo(); x = true; return true \" +\n          \"} else { goo(); x = true; return true }}\",\n          \"function z() {(a) ? foo() : goo(); x = true; return true}\");\n-    \n+\n     fold(\"function z() {\" +\n          \"  if (a) { bar(); foo(); return true }\" +\n          \"    else { bar(); goo(); return true }\" +\n     foldSame(\"while(!(x<=NaN)){a=b;}\");\n   }\n \n-  public void testFoldRegExpConstructor() {    \n+  public void testFoldRegExpConstructor() {\n     enableNormalize();\n-    \n+\n     // Cannot fold all the way to a literal because there are too few arguments.\n     fold(\"x = new RegExp\",                    \"x = RegExp()\");\n     // Empty regexp should not fold to // since that is a line comment in js\n     String longRegexp = \"\";\n     for (int i = 0; i < 200; i++) longRegexp += \"x\";\n     foldSame(\"x = RegExp(\\\"\" + longRegexp + \"\\\")\");\n-    \n+\n     // Shouldn't fold RegExp unnormalized because\n-    // we can't be sure that RegExp hasn't been redefined     \n+    // we can't be sure that RegExp hasn't been redefined\n     disableNormalize();\n-       \n+\n     foldSame(\"x = new RegExp(\\\"foobar\\\")\");\n   }\n \n     // it is used in node comparison.\n     assertResultString(\"x=new RegExp(\\\"\\\\n\\\", \\\"i\\\")\", \"x=/\\\\n/i\", true);\n   }\n-  \n+\n   public void testContainsUnicodeEscape() throws Exception {\n     assertTrue(!PeepholeSubstituteAlternateSyntax.containsUnicodeEscape(\"\"));\n     assertTrue(!PeepholeSubstituteAlternateSyntax.containsUnicodeEscape(\"foo\"));\n \n   public void testFoldLiteralObjectConstructors() {\n     enableNormalize();\n-    \n+\n     // Can fold when normalized\n     fold(\"x = new Object\", \"x = ({})\");\n     fold(\"x = new Object()\", \"x = ({})\");\n          \"x = [{}, [\\\"abc\\\", {}, [[]]]\");\n     fold(\"x = new Array(Object(), Array(\\\"abc\\\", Object(), Array(Array())))\",\n          \"x = [{}, [\\\"abc\\\", {}, [[]]]\");\n-    \n+\n     disableNormalize();\n     // Cannot fold above when not normalized\n     foldSame(\"x = new Array\");\n     foldSame(\"x = new Array(Object(), Array(\\\"abc\\\", Object(), Array(Array())))\");\n   }\n \n-  public void testMinimizeCondition() {\n+  public void testMinimizeWhileCondition() {\n     // This test uses constant folding logic, so is only here for completeness.\n     fold(\"while(!!true) foo()\", \"while(1) foo()\");\n     // These test tryMinimizeCondition\n     fold(\"while(!(!x&&!y)) foo()\", \"while(x||y) foo()\");\n     fold(\"while(x||!!y) foo()\", \"while(x||y) foo()\");\n     fold(\"while(!(!!x&&y)) foo()\", \"while(!(x&&y)) foo()\");\n+  }\n+\n+  public void testMinimizeForCondition() {\n+    // This test uses constant folding logic, so is only here for completeness.\n+    // These could be simplified to \"for(;;) ...\"\n+    fold(\"for(;!!true;) foo()\", \"for(;1;) foo()\");\n+    // Don't bother with FOR inits as there are normalized out.\n+    foldSame(\"for(!!true;;) foo()\");\n+\n+    // These test tryMinimizeCondition\n+    fold(\"for(;!!x;) foo()\", \"for(;x;) foo()\");\n+\n+    // sanity check\n+    foldSame(\"for(a in b) foo()\");\n+    foldSame(\"for(a in {}) foo()\");\n+    foldSame(\"for(a in []) foo()\");\n+    foldSame(\"for(a in !!true) foo()\");\n   }\n \n   public void testMinimizeCondition_example1() {\n     foldSame(\"var x = new String(1)\");\n     foldSame(\"var x = new Number(1)\");\n     foldSame(\"var x = new Boolean(1)\");\n-    \n+\n     enableNormalize();\n-    \n+\n     fold(\"var x = new Object('a')\", \"var x = Object('a')\");\n     fold(\"var x = new RegExp('')\", \"var x = RegExp('')\");\n     fold(\"var x = new Error('20')\", \"var x = Error(\\\"20\\\")\");", "timestamp": 1282946982, "metainfo": ""}