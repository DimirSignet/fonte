{"sha": "82a9956c6337d2f5d4a94ebe624d64faa54d9182", "log": "Change on 2010/07/09 08:36:29 by nicksantos          when injecting param checks, do not inject them before any function         declarations, because that will break normalization constraints.          R=johnlenz         DELTA=22  (18 added, 0 deleted, 4 changed)  Change on 2010/07/09 09:36:54 by johnlenz          Prefer FileWriter to PrintStream when charset translation isn't needed.          R=acleung         DELTA=68  (13 added, 2 deleted, 53 changed)  Change on 2010/07/09 10:54:42 by nicksantos          our mechanism for injecting boilerplate does not work         for code that uses @const externs. So just don't use         any @const externs.          R=johnlenz         DELTA=3  (1 added, 0 deleted, 2 changed)  Change on 2010/07/09 11:30:29 by nicksantos          Scan functional properties of object literals for invalid use         of \"this\".         Fixes issue 182.          R=acleung         DELTA=21  (19 added, 0 deleted, 2 changed)  Change on 2010/07/09 12:40:16 by dcc          Separate pass instance for peephole preprocessing.         Now that I'm writing instructions for how people can add their own         peephole passes, I want to make sure that the preprocessing         peephole optimizations that relies on don't get disturbed.          R=johnlenz         DELTA=18  (15 added, 0 deleted, 3 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=49008   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n import com.google.javascript.rhino.TokenStream;\n import com.google.protobuf.CodedOutputStream;\n \n-import java.io.BufferedOutputStream;\n+import java.io.BufferedWriter;\n import java.io.File;\n import java.io.FileOutputStream;\n+import java.io.FileWriter;\n import java.io.IOException;\n+import java.io.OutputStreamWriter;\n import java.io.PrintStream;\n+import java.io.Writer;\n import java.nio.charset.Charset;\n import java.util.ArrayList;\n import java.util.Collections;\n \n   private final CommandLineConfig config;\n \n-  private PrintStream out;\n+  private Appendable out;\n   private final PrintStream err;\n   private A compiler;\n \n    * Writes code to an output stream, optionally wrapping it in an arbitrary\n    * wrapper that contains a placeholder where the code should be inserted.\n    */\n-  static void writeOutput(PrintStream out, Compiler compiler, String code,\n-      String wrapper, String codePlaceholder) {\n+  static void writeOutput(Appendable out, Compiler compiler, String code,\n+      String wrapper, String codePlaceholder) throws IOException {\n     int pos = wrapper.indexOf(codePlaceholder);\n     if (pos != -1) {\n       String prefix = \"\";\n \n       if (pos > 0) {\n         prefix = wrapper.substring(0, pos);\n-        out.print(prefix);\n-      }\n-\n-      out.print(code);\n+        out.append(prefix);\n+      }\n+\n+      out.append(code);\n \n       int suffixStart = pos + codePlaceholder.length();\n-      if (suffixStart == wrapper.length()) {\n-        // Nothing after placeholder?\n-        // Make sure we always end output with a line feed.\n-        out.println();\n-      } else {\n-        out.println(wrapper.substring(suffixStart));\n-      }\n+      if (suffixStart != wrapper.length()) {\n+        // Something after placeholder?\n+        out.append(wrapper.substring(suffixStart));\n+      }\n+      // Make sure we always end output with a line feed.\n+      out.append('\\n');\n \n       // If we have a source map, adjust its offsets to match\n       // the code WITHIN the wrapper.\n       }\n \n     } else {\n-      out.println(code);\n+      out.append(code);\n+      out.append('\\n');\n     }\n   }\n \n \n     boolean writeOutputToFile = !options.jsOutputFile.isEmpty();\n     if (writeOutputToFile) {\n-      out = toPrintStream(options.jsOutputFile, inputCharset.name());\n+      out = toWriter(options.jsOutputFile, inputCharset.name());\n     }\n \n     List<String> jsFiles = config.js;\n     int errCode = processResults(result, modules, options);\n     // Close the output if we are writing to a file.\n     if (writeOutputToFile) {\n-      out.close();\n+      ((Writer)out).close();\n     }\n     return errCode;\n   }\n         return 1;\n       } else {\n         out.append(DotFormatter.toDot(compiler.getPassConfig().getPassGraph()));\n-        out.println();\n+        out.append('\\n');\n         return 0;\n       }\n     }\n       } else {\n         ControlFlowGraph<Node> cfg = compiler.computeCFG();\n         DotFormatter.appendDot(compiler.getRoot(), cfg, out);\n-        out.println();\n+        out.append('\\n');\n         return 0;\n       }\n     }\n \n     if (config.printTree) {\n       if (compiler.getRoot() == null) {\n-        out.println(\"Code contains errors; no tree was generated.\");\n+        out.append(\"Code contains errors; no tree was generated.\\n\");\n         return 1;\n       } else {\n         compiler.getRoot().appendStringTree(out);\n-        out.println(\"\");\n+        out.append(\"\\n\");\n         return 0;\n       }\n     }\n         // If the source map path is in fact a pattern for each\n         // module, create a stream per-module. Otherwise, create\n         // a single source map.\n-        PrintStream mapOut = null;\n+        Writer mapOut = null;\n \n         if (!shouldGenerateMapPerModule(options)) {\n-          mapOut = toPrintStream(expandSourceMapPath(options, null));\n+          mapOut = toWriter(expandSourceMapPath(options, null));\n         }\n \n         for (JSModule m : modules) {\n           if (shouldGenerateMapPerModule(options)) {\n-            mapOut = toPrintStream(expandSourceMapPath(options, m));\n+            mapOut = toWriter(expandSourceMapPath(options, m));\n           }\n \n-          PrintStream ps = toPrintStream(\n+          Writer writer = toWriter(\n               moduleFilePrefix + m.getName() + \".js\");\n \n           if (options.sourceMapOutputPath != null) {\n             compiler.getSourceMap().reset();\n           }\n \n-          writeOutput(ps, compiler, compiler.toSource(m), moduleWrappers.get(\n+          writeOutput(writer, compiler, compiler.toSource(m), moduleWrappers.get(\n               m.getName()), \"%s\");\n \n           if (options.sourceMapOutputPath != null) {\n             compiler.getSourceMap().appendTo(mapOut, m.getName());\n           }\n \n-          ps.close();\n+          writer.close();\n \n           if (shouldGenerateMapPerModule(options) && mapOut != null) {\n             mapOut.close();\n \n       // Output the externs if required.\n       if (options.externExportsPath != null) {\n-        PrintStream eeOut =\n+        Writer eeOut =\n             openExternExportsStream(options, options.jsOutputFile);\n         eeOut.append(result.externExport);\n         eeOut.close();\n    *\n    * @return The stream or null if no extern-ed exports are being generated.\n    */\n-  private PrintStream openExternExportsStream(B options,\n+  private Writer openExternExportsStream(B options,\n       String path) throws IOException {\n     if (options.externExportsPath == null) {\n       return null;\n       exPath = outputFile.getParent() + File.separatorChar + exPath;\n     }\n \n-    return toPrintStream(exPath);\n+    return toWriter(exPath);\n   }\n \n   /**\n   }\n \n   /**\n-   * Converts a file name into a print stream.\n+   * Converts a file name into a Writer.\n    * Returns null if the file name is null.\n    */\n-  private PrintStream toPrintStream(String fileName) throws IOException {\n+  private Writer toWriter(String fileName) throws IOException {\n     if (fileName == null) {\n       return null;\n     }\n-    return new PrintStream(\n-        new BufferedOutputStream(\n-            new FileOutputStream(fileName)), false);\n-  }\n-\n-  /**\n-   * Coverts a file name into a print stream.\n+    // Use a FileWriter if the charset translation isn't required.\n+    return new BufferedWriter(new FileWriter(fileName));\n+  }\n+\n+  /**\n+   * Converts a file name into a Writer.\n    * Returns null if the file name is null.\n    */\n-  private PrintStream toPrintStream(String fileName, String charSet)\n+  private Writer toWriter(String fileName, String charSet)\n       throws IOException {\n     if (fileName == null) {\n       return null;\n     }\n-    return new PrintStream(\n-        new BufferedOutputStream(\n-            new FileOutputStream(fileName)), false, charSet);\n+    // Use a FileOutputStream for a non-default charset.\n+    return new BufferedWriter(\n+        new OutputStreamWriter(new FileOutputStream(fileName), charSet));\n   }\n \n   /**\n     }\n \n     String outName = expandSourceMapPath(options, null);\n-    PrintStream out = toPrintStream(outName);\n+    Writer out = toWriter(outName);\n     compiler.getSourceMap().appendTo(out, outName);\n     out.close();\n   }\n       // Generate per-module manifests.\n       Iterable<JSModule> modules = graph.getAllModules();\n       for (JSModule module : modules) {\n-        PrintStream out = toPrintStream(expandManifest(module));\n+        Writer out = toWriter(expandManifest(module));\n         printManifestTo(module.getInputs(), out);\n         out.close();\n       }\n     } else {\n       // Generate a single file manifest.\n-      PrintStream out = toPrintStream(expandManifest(null));\n+      Writer out = toWriter(expandManifest(null));\n       if (graph == null) {\n         printManifestTo(compiler.getInputsInOrder(), out);\n       } else {\n      * Print the best phase loop to stderr.\n      */\n     private void outputBestPhaseOrdering() {\n-      out.println(\"Best time: \" + bestRunTime);\n-      out.println(\"Worst time: \" + worstRunTime);\n-\n-      int i = 1;\n-      for (List<String> loop : loopedPassesInBestRun) {\n-        out.println(\"\\nLoop \" + i + \":\\n\" + Joiner.on(\"\\n\").join(loop));\n-        i++;\n+      try {\n+        out.append(\"Best time: \" + bestRunTime + \"\\n\");\n+        out.append(\"Worst time: \" + worstRunTime + \"\\n\");\n+\n+        int i = 1;\n+        for (List<String> loop : loopedPassesInBestRun) {\n+          out.append(\"\\nLoop \" + i + \":\\n\" + Joiner.on(\"\\n\").join(loop)+ \"\\n\");\n+          i++;\n+        }\n+      } catch (IOException e) {\n+        throw new RuntimeException(\"unexpected exception\", e);\n       }\n     }\n   }\n--- a/src/com/google/javascript/jscomp/CheckGlobalThis.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalThis.java\n       // be able to have a @this annotation associated with them. e.g.,\n       // var a = function() { }; // or\n       // function a() {} // or\n-      // a.x = function() {};\n+      // a.x = function() {}; // or\n+      // var a = {x: function() {}};\n       int pType = parent.getType();\n       if (!(pType == Token.BLOCK ||\n             pType == Token.SCRIPT ||\n             pType == Token.NAME ||\n-            pType == Token.ASSIGN)) {\n+            pType == Token.ASSIGN ||\n+            pType == Token.OBJECTLIT)) {\n         return false;\n       }\n     }\n--- a/src/com/google/javascript/jscomp/DefaultPassConfig.java\n+++ b/src/com/google/javascript/jscomp/DefaultPassConfig.java\n   };\n \n   /** Various peephole optimizations. */\n-  static final PassFactory peepholeOptimizations =\n+  private final PassFactory peepholeOptimizations =\n       new PassFactory(\"peepholeOptimizations\", false) {\n     @Override\n     protected CompilerPass createInternal(AbstractCompiler compiler) {\n--- a/src/com/google/javascript/jscomp/RuntimeTypeCheck.java\n+++ b/src/com/google/javascript/jscomp/RuntimeTypeCheck.java\n       FunctionType funType = (FunctionType) n.getJSType();\n       Node block = n.getLastChild();\n       Node paramName = NodeUtil.getFnParameters(n).getFirstChild();\n-      Node prev = null;\n+      Node insertionPoint = null;\n+\n+      // To satisfy normalization constraints, the type checking must be\n+      // added after any inner function declarations.\n+      for (Node next = block.getFirstChild();\n+           next != null && NodeUtil.isFunctionDeclaration(next);\n+           next = next.getNext()) {\n+        insertionPoint = next;\n+      }\n+\n       for (Node paramType : funType.getParameters()) {\n         // Can this ever happen?\n         if (paramName == null) {\n         }\n \n         checkNode = new Node(Token.EXPR_RESULT, checkNode);\n-        if (prev == null) {\n+        if (insertionPoint == null) {\n           block.addChildToFront(checkNode);\n         } else {\n-          block.addChildAfter(checkNode, prev);\n+          block.addChildAfter(checkNode, insertionPoint);\n         }\n \n         compiler.reportCodeChange();\n         paramName = paramName.getNext();\n-        prev = checkNode;\n+        insertionPoint = checkNode;\n       }\n     }\n \n--- a/test/com/google/javascript/jscomp/CheckGlobalThisTest.java\n+++ b/test/com/google/javascript/jscomp/CheckGlobalThisTest.java\n     testSame(\n         \"function f() { var x = {}; x.y(function() { return this.x; }); }\");\n   }\n+\n+  public void testIssue182a() {\n+    testFailure(\"var NS = {read: function() { return this.foo; }};\");\n+  }\n+\n+  public void testIssue182b() {\n+    testFailure(\"var NS = {write: function() { this.foo = 3; }};\");\n+  }\n+\n+  public void testIssue182c() {\n+    testFailure(\"var NS = {}; NS.write2 = function() { this.foo = 3; };\");\n+  }\n+\n+  public void testIssue182d() {\n+    testSame(\"function Foo() {} \" +\n+        \"Foo.prototype = {write: function() { this.foo = 3; }};\");\n+  }\n }\n--- a/test/com/google/javascript/jscomp/RuntimeTypeCheckTest.java\n+++ b/test/com/google/javascript/jscomp/RuntimeTypeCheckTest.java\n   private Node runtimeTypeCheckCode = null;\n \n   public RuntimeTypeCheckTest() {\n+    super(\"/** @const */ var undefined;\");\n     enableTypeCheck(CheckLevel.WARNING);\n   }\n \n     testChecks(\"/** @param {number} CONST */ function f(CONST) {}\",\n         \"function f(CONST) {\" +\n         \"  jscomp.typecheck.checkType(CONST, \" +\n+        \"      [jscomp.typecheck.valueChecker('number')]);\" +\n+        \"}\");\n+  }\n+\n+  public void testValueWithInnerFn() {\n+    testChecks(\"/** @param {number} i */ function f(i) { function g() {} }\",\n+        \"function f(i) {\" +\n+        \"  function g() {}\" +\n+        \"  jscomp.typecheck.checkType(i, \" +\n         \"      [jscomp.typecheck.valueChecker('number')]);\" +\n         \"}\");\n   }", "timestamp": 1278716556, "metainfo": ""}