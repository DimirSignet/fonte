{"sha": "449fdd3c1163cf42d9caa4e7382e37f20f2ca6ac", "log": "Make CompilerRunner package-private. There's no good reason for it to be public. And right now, users of the Java API are confused about whether they should use Compiler or CompilerRunner.  Also, make sure that ProcessClosurePrimitives always preserves original source information.    ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCompilerRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCompilerRunner.java\n import java.util.logging.Level;\n \n /**\n- * AbstractCompilerRunner encapsulates the logic required to run the Compiler.\n- * This class is designed to be extended and used to create other Java classes\n- * that behave the same as running the Compiler. Example:\n+ * Implementations of AbstractCompilerRunner translate flags into Java\n+ * API calls on the Compiler. AbstractCompiler contains common flags and logic\n+ * to make that happen.\n+ *\n+ * This class may be extended and used to create other Java classes\n+ * that behave the same as running the Compiler from the command line. Example:\n  *\n  * <pre>\n  * class MyCompilerRunner extends\n  *\n *\n  */\n-public abstract class AbstractCompilerRunner<A extends Compiler,\n+abstract class AbstractCompilerRunner<A extends Compiler,\n     B extends CompilerOptions> {\n \n   @FlagSpec(help = \"Prints out the parse tree and exits\",\n       docLevel = DocLevel.SECRET)\n-  public static final Flag<Boolean> FLAG_print_tree = Flag.value(false);\n+  static final Flag<Boolean> FLAG_print_tree = Flag.value(false);\n \n   @FlagSpec(help = \"Runs the compile job many times, then prints out the \" +\n       \"best phase ordering from this run\",\n       docLevel = DocLevel.SECRET)\n-  public static final Flag<Boolean> FLAG_compute_phase_ordering =\n+  static final Flag<Boolean> FLAG_compute_phase_ordering =\n       Flag.value(false);\n \n   @FlagSpec(help = \"Prints a dot file describing the internal abstract syntax\"\n       + \" tree and exits\",\n       docLevel = DocLevel.SECRET)\n-  public static final Flag<Boolean> FLAG_print_ast = Flag.value(false);\n+  static final Flag<Boolean> FLAG_print_ast = Flag.value(false);\n \n   @FlagSpec(help = \"Turns on extra sanity checks\", altName = \"dev_mode\",\n       docLevel = DocLevel.SECRET)\n-  public static final Flag<CompilerOptions.DevMode> FLAG_jscomp_dev_mode =\n+  static final Flag<CompilerOptions.DevMode> FLAG_jscomp_dev_mode =\n       Flag.value(CompilerOptions.DevMode.OFF);\n \n+  // TODO(nicksantos): Make the next 2 flags package-private.\n   @FlagSpec(help = \"The logging level (standard java.util.logging.Level\"\n       + \" values) for Compiler progress. Does not control errors or\"\n       + \" warnings for the JavaScript code under compilation\",\n   public static final Flag<List<String>> FLAG_externs = Flag.stringCollector();\n \n   @FlagSpec(help = \"The javascript filename. You may specify multiple\")\n-  public static final Flag<List<String>> FLAG_js = Flag.stringCollector();\n+  static final Flag<List<String>> FLAG_js = Flag.stringCollector();\n \n   @FlagSpec(help = \"Primary output filename. If not specified, output is \" +\n             \"written to stdout\")\n       + \"depends on. Modules must be listed in dependency order, and js \"\n       + \"source files must be listed in the corresponding order. Where \"\n       + \"--module flags occur in relation to --js flags is unimportant\")\n-  public static final Flag<List<String>> FLAG_module = Flag.stringCollector();\n+  static final Flag<List<String>> FLAG_module = Flag.stringCollector();\n \n   @FlagSpec(help = \"File containing the serialized version of the variable \"\n       + \"renaming map produced by a previous compilation\")\n-  public static final Flag<String> FLAG_variable_map_input_file =\n+  static final Flag<String> FLAG_variable_map_input_file =\n       Flag.value(\"\");\n \n   @FlagSpec(help = \"File containing the serialized version of the property \"\n       + \"renaming map produced by a previous compilation\",\n       docLevel = DocLevel.SECRET)\n-  public static final Flag<String> FLAG_property_map_input_file =\n+  static final Flag<String> FLAG_property_map_input_file =\n       Flag.value(\"\");\n \n   @FlagSpec(help = \"File where the serialized version of the variable \"\n       + \"renaming map produced should be saved\",\n       docLevel = DocLevel.SECRET)\n-  public static final Flag<String> FLAG_variable_map_output_file =\n+  static final Flag<String> FLAG_variable_map_output_file =\n       Flag.value(\"\");\n \n   @FlagSpec(help = \"If true, variable renaming and property renaming map \"\n       + \"in conjunction with either variable_map_output_file or \"\n       + \"property_map_output_file\",\n       docLevel = DocLevel.SECRET)\n-  public static final Flag<Boolean> FLAG_create_name_map_files =\n+  static final Flag<Boolean> FLAG_create_name_map_files =\n       Flag.value(false);\n \n   @FlagSpec(help = \"File where the serialized version of the property \"\n       + \"renaming map produced should be saved\")\n-  public static final Flag<String> FLAG_property_map_output_file =\n+  static final Flag<String> FLAG_property_map_output_file =\n       Flag.value(\"\");\n \n   @FlagSpec(help = \"Check source validity but do not enforce Closure style \"\n       + \"rules and conventions\")\n-  public static final Flag<Boolean> FLAG_third_party = Flag.value(false);\n+  static final Flag<Boolean> FLAG_third_party = Flag.value(false);\n \n \n   @FlagSpec(help = \"Controls how detailed the compilation summary is. Values:\"\n       + \"errors or warnings), 2 (print summary if type checking is on, \"\n       + \"see --check_types), 3 (always print summary). The default level \"\n       + \"is 1\")\n-  public static final Flag<Integer> FLAG_summary_detail_level = Flag.value(1);\n+  static final Flag<Integer> FLAG_summary_detail_level = Flag.value(1);\n \n   @FlagSpec(help = \"Interpolate output into this string at the place denoted\"\n       + \" by the marker token %output%. See --output_wrapper_marker\")\n-  public static final Flag<String> FLAG_output_wrapper = Flag.value(\"\");\n+  static final Flag<String> FLAG_output_wrapper = Flag.value(\"\");\n \n   @FlagSpec(help = \"Use this token as output marker in the value of\"\n       + \" --output_wrapper\")\n-  public static final Flag<String> FLAG_output_wrapper_marker =\n+  static final Flag<String> FLAG_output_wrapper_marker =\n       Flag.value(\"%output%\");\n \n   @FlagSpec(help = \"An output wrapper for a javascript module (optional). \"\n       + \"The format is <name>:<wrapper>. The module name must correspond \"\n       + \"with a module specified using --module. The wrapper must \"\n       + \"contain %s as the code placeholder\")\n-  public static final Flag<List<String>> FLAG_module_wrapper =\n+  static final Flag<List<String>> FLAG_module_wrapper =\n       Flag.stringCollector();\n \n   @FlagSpec(help = \"Prefix for filenames of compiled js modules. \"\n       + \"<module-name>.js will be appended to this prefix. Directories \"\n       + \"will be created as needed. Use with --module\")\n-  public static final Flag<String> FLAG_module_output_path_prefix =\n+  static final Flag<String> FLAG_module_output_path_prefix =\n       Flag.value(\"./\");\n \n   @FlagSpec(help = \"If specified, a source map file mapping the generated \" +\n             \"output to the specified path. The %outname% placeholder will \" +\n             \"expand to the name of the output file that the source map \" +\n             \"corresponds to.\")\n-  public static final Flag<String> FLAG_create_source_map =\n+  static final Flag<String> FLAG_create_source_map =\n       Flag.value(\"\");\n \n   @FlagSpec(help = \"Make the named class of warnings an error. Options:\" +\n       DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES)\n-  public static final Flag<List<String>> FLAG_jscomp_error =\n+  static final Flag<List<String>> FLAG_jscomp_error =\n       Flag.stringCollector();\n \n   @FlagSpec(help = \"Make the named class of warnings a normal warning. \" +\n                 \"Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES)\n-  public static final Flag<List<String>> FLAG_jscomp_warning =\n+  static final Flag<List<String>> FLAG_jscomp_warning =\n       Flag.stringCollector();\n \n   @FlagSpec(help = \"Turn off the named class of warnings. Options:\" +\n       DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES)\n-  public static final Flag<List<String>> FLAG_jscomp_off =\n+  static final Flag<List<String>> FLAG_jscomp_off =\n       Flag.stringCollector();\n \n   @FlagSpec(altName = \"D\",\n       \"variable and <val> is a boolean, number, or a single-quoted string \" +\n       \"that contains no single quotes. If [=<val>] is omitted, \" +\n       \"the variable is marked true\")\n-  public static final Flag<List<String>> FLAG_define = Flag.stringCollector();\n+  static final Flag<List<String>> FLAG_define = Flag.stringCollector();\n \n   @FlagSpec(help = \"Input charset for all files.\")\n   static final Flag<String> FLAG_charset = Flag.value(\"\");\n \n   private final RunTimeStats runTimeStats = new RunTimeStats();\n \n-  public AbstractCompilerRunner(String[] args) {\n+  AbstractCompilerRunner(String[] args) {\n     this(args, System.out, System.err);\n   }\n \n-  public AbstractCompilerRunner(String[] args, PrintStream out,\n+  AbstractCompilerRunner(String[] args, PrintStream out,\n       PrintStream err) {\n     // Flags are read when a compiler is instantiated, so we parse them first.\n     Flags.parse(args);\n   /**\n    * An exception thrown when command-line flags are used incorrectly.\n    */\n-  public static class FlagUsageException extends Exception {\n+  static class FlagUsageException extends Exception {\n     private static final long serialVersionUID = 1L;\n \n     FlagUsageException(String message) {\n--- a/src/com/google/javascript/jscomp/CompilerRunner.java\n+++ b/src/com/google/javascript/jscomp/CompilerRunner.java\n import java.util.zip.ZipInputStream;\n \n /**\n- * CompilerRunner encapsulates the logic required to run the Compiler.\n- * This class is designed to be extended and used to create other Java classes\n- * that behave the same as running the Compiler from the command line. Example:\n+ * CompilerRunner translates flags into Java API calls on the Compiler.\n+ *\n+ * This class may be extended and used to create other Java classes\n+ * that behave the same as running the Compiler from the command line. If you\n+ * want to run the compiler in-process in Java, you should look at this class\n+ * for hints on what API calls to make, but you should not use this class directly.\n+ *\n+ * Example:\n  * <pre>\n  * class MyCompilerRunner extends CompilerRunner {\n  *   MyCompilerRunner(String[] args) { super(args); }\n  * </pre>\n *\n  */\n-public class CompilerRunner extends\n+class CompilerRunner extends\n     AbstractCompilerRunner<Compiler, CompilerOptions> {\n \n   @FlagSpec(help = \"Specifies the compilation level to use. Options: \" +\n   static final Flag<Boolean> FLAG_process_closure_primitives\n       = Flag.value(true);\n \n-  public CompilerRunner(String[] args) {\n+  CompilerRunner(String[] args) {\n     super(args);\n   }\n \n-  public CompilerRunner(String[] args, PrintStream out, PrintStream err) {\n+  CompilerRunner(String[] args, PrintStream out, PrintStream err) {\n     super(args, out, err);\n   }\n \n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n    */\n   static void setDebugInformation(Node node, Node basisNode,\n                                   String originalName) {\n-    node.copyInformationFrom(basisNode);\n+    node.copyInformationFromForTree(basisNode);\n     node.putProp(Node.ORIGINALNAME_PROP, originalName);\n   }\n \n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n       NodeTraversal t, Node node, Node parent, String ns) {\n     Node newNode;\n     if (ns.indexOf('.') == -1) {\n-      newNode = makeVarDeclNode(ns);\n+      newNode = makeVarDeclNode(ns, node);\n       parent.replaceChild(node, newNode);\n     } else {\n       newNode = makeAssignmentExprNode(ns, node);\n         // been declared implicitly and is not removable.\n         providedNodes.put(prefixNs, null);\n         Node newNode = (pos == -1\n-                        ? makeVarDeclNode(prefixNs)\n+                        ? makeVarDeclNode(prefixNs, node)\n                         : makeAssignmentExprNode(prefixNs, node));\n         parent.addChildBefore(newNode, nodeToAddBefore);\n         nodeToAddBefore = newNode;\n    * (e.g. <code>var foo = {};</code>).\n    *\n    * @param namespace A simple namespace (must be a valid js identifier)\n-   */\n-  private Node makeVarDeclNode(String namespace) {\n+   * @param sourceNode The node to get source information from.\n+   */\n+  private Node makeVarDeclNode(String namespace, Node sourceNode) {\n     Node name = Node.newString(Token.NAME, namespace);\n     name.addChildToFront(new Node(Token.OBJECTLIT));\n+\n     Node decl = new Node(Token.VAR, name);\n     decl.putBooleanProp(Node.IS_NAMESPACE, true);\n \n     }\n \n     Preconditions.checkState(isNamespacePlaceholder(decl));\n+    decl.copyInformationFromForTree(sourceNode);\n     return decl;\n   }\n \n             new Node(Token.OBJECTLIT)));\n     decl.putBooleanProp(Node.IS_NAMESPACE, true);\n     Preconditions.checkState(isNamespacePlaceholder(decl));\n+    decl.copyInformationFromForTree(node);\n     return decl;\n   }\n \n             assignNode.removeChild(valueNode);\n             nameNode.addChildToFront(valueNode);\n             Node varNode = new Node(Token.VAR, nameNode);\n+            varNode.copyInformationFrom(replacementCandidate);\n             replacementCandidateParent.replaceChild(replacementCandidate,\n                                                     varNode);\n             nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n--- a/src/com/google/javascript/jscomp/ant/CompileTask.java\n+++ b/src/com/google/javascript/jscomp/ant/CompileTask.java\n import com.google.javascript.jscomp.CompilationLevel;\n import com.google.javascript.jscomp.Compiler;\n import com.google.javascript.jscomp.CompilerOptions;\n-import com.google.javascript.jscomp.CompilerRunner;\n import com.google.javascript.jscomp.JSSourceFile;\n import com.google.javascript.jscomp.MessageFormatter;\n import com.google.javascript.jscomp.Result;\n    */\n   private List<JSSourceFile> getDefaultExterns() {\n     try {\n-      InputStream input = CompilerRunner.class.getResourceAsStream(\n+      InputStream input = Compiler.class.getResourceAsStream(\n           \"/externs.zip\");\n       ZipInputStream zip = new ZipInputStream(input);\n       List<JSSourceFile> externs = Lists.newLinkedList();\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n         }\n     }\n \n+    /**\n+     * Copies source file and name information from the other node to the\n+     * entire tree rooted at this node.\n+     */\n+    public void copyInformationFromForTree(Node other) {\n+      copyInformationFrom(other);\n+      for (Node child = getFirstChild();\n+           child != null; child = child.getNext()) {\n+        child.copyInformationFromForTree(other);\n+      }\n+    }\n+\n     //==========================================================================\n     // Custom annotations\n \n--- a/test/com/google/javascript/jscomp/CompilerTestCase.java\n+++ b/test/com/google/javascript/jscomp/CompilerTestCase.java\n   /** Whether the Normalize pass runs before pass being tested. */\n   private boolean normalizeEnabled = false;\n \n+  /** Whether to check that all line number information is preserved. */\n+  private boolean checkLineNumbers = false;\n+\n   /**\n    * An expected symbol table error. Only useful for testing the\n    * symbol table error-handling.\n   public void enableTypeCheck(CheckLevel level) {\n     typeCheckEnabled  = true;\n     typeCheckLevel = level;\n+  }\n+\n+  /**\n+   * Check to make sure that line numbers were preserved.\n+   */\n+  public void enableLineNumberCheck(boolean newVal) {\n+    checkLineNumbers = newVal;\n   }\n \n   /**\n         recentChange.reset();\n \n         getProcessor(compiler).process(externsRoot, mainRoot);\n+        if (checkLineNumbers) {\n+          (new LineNumberCheck(compiler)).process(externsRoot, mainRoot);\n+        }\n \n         hasCodeChanged = hasCodeChanged || recentChange.hasCodeChanged();\n         aggregateWarningCount += errorManagers[i].getWarningCount();\n--- a/test/com/google/javascript/jscomp/ProcessClosurePrimitivesTest.java\n+++ b/test/com/google/javascript/jscomp/ProcessClosurePrimitivesTest.java\n   private String additionalCode;\n   private String additionalEndCode;\n   private boolean addAdditionalNamespace;\n+\n+  public ProcessClosurePrimitivesTest() {\n+    enableLineNumberCheck(true);\n+  }\n \n   @Override protected void setUp() {\n     additionalCode = null;", "timestamp": 1265210771, "metainfo": ""}