{"sha": "6bbac115c9a7928a7053b2da3a78df9569df8570", "log": "Adding getPropertyNode functionality to ObjectType. This needs associating nodes to properties in defineProperty.  R=nicksantos DELTA=307  (127 added, 0 deleted, 180 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=223   ", "commit": "\n--- a/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n       FunctionType childCtor, SubclassType type) {\n     if (type == SubclassType.INHERITS) {\n       childCtor.defineDeclaredProperty(\"superClass_\",\n-          parentCtor.getPrototype(), false);\n+          parentCtor.getPrototype(), false, parentCtor.getSource());\n       childCtor.getPrototype().defineDeclaredProperty(\"constructor\",\n-          childCtor, false);\n+          childCtor, false, parentCtor.getSource());\n     }\n   }\n \n   @Override\n   public void applySingletonGetter(FunctionType functionType,\n       FunctionType getterType, ObjectType objectType) {\n-    functionType.defineDeclaredProperty(\"getInstance\", getterType, false);\n-    functionType.defineDeclaredProperty(\"instance_\", objectType, false);\n+    functionType.defineDeclaredProperty(\"getInstance\", getterType, false,\n+        functionType.getSource());\n+    functionType.defineDeclaredProperty(\"instance_\", objectType, false,\n+        functionType.getSource());\n   }\n \n   @Override\n--- a/src/com/google/javascript/jscomp/InferJSDocInfo.java\n+++ b/src/com/google/javascript/jscomp/InferJSDocInfo.java\n class InferJSDocInfo extends AbstractPostOrderCallback\n     implements CompilerPass {\n \n-  private AbstractCompiler compiler;\n+  private final AbstractCompiler compiler;\n   private boolean inExterns;\n \n   InferJSDocInfo(AbstractCompiler compiler) {\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n         if (objectType.hasProperty(propName) ||\n             !objectType.isInstanceType()) {\n           if (\"prototype\".equals(propName)) {\n-            objectType.defineDeclaredProperty(propName, rightType, false);\n+            objectType.defineDeclaredProperty(propName, rightType, false, getprop);\n           } else {\n-            objectType.defineInferredProperty(propName, rightType, false);\n+            objectType.defineInferredProperty(propName, rightType, false, getprop);\n           }\n         } else {\n           if (getprop.getFirstChild().getType() == Token.THIS &&\n               getJSType(syntacticScope.getRootNode()).isConstructor()) {\n-            objectType.defineInferredProperty(propName, rightType, false);\n+            objectType.defineInferredProperty(propName, rightType, false, getprop);\n           } else {\n             registry.registerPropertyOnType(propName, objectType);\n           }\n              (!objectType.isInstanceType() ||\n                  (var.isExtern() && !objectType.isNativeObjectType())))) {\n           return objectType.defineDeclaredProperty(\n-              propName, var.getType(), var.isExtern());\n+              propName, var.getType(), var.isExtern(), getprop);\n         }\n       }\n     }\n       scope = traverse(value, scope);\n       String memberName = NodeUtil.getStringValue(name);\n       if (memberName != null) {\n-        objectType.defineInferredProperty(memberName, getJSType(value), false);\n+        objectType.defineInferredProperty(memberName, getJSType(value), false,\n+            name);\n       } else {\n         n.setJSType(getNativeType(UNKNOWN_TYPE));\n         return scope;\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n   private final TypeValidator validator;\n   private final CodingConvention codingConvention;\n   private final JSTypeRegistry typeRegistry;\n-  private List<ObjectType> delegateProxyPrototypes = Lists.newArrayList();\n+  private final List<ObjectType> delegateProxyPrototypes = Lists.newArrayList();\n \n   /**\n    * Defer attachment of types to nodes until all type names\n               compiler.report(\n                   JSError.make(sourceName, key, ENUM_NOT_CONSTANT, keyName));\n             } else {\n-              enumType.defineElement(keyName);\n+              enumType.defineElement(keyName, key);\n             }\n             key = key.getNext();\n           }\n                 type == null ?\n                     getNativeType(JSTypeNative.NO_TYPE) :\n                     type,\n-                isExtern);\n+                isExtern, n);\n           } else {\n-            globalThis.defineDeclaredProperty(variableName, type, isExtern);\n+            globalThis.defineDeclaredProperty(variableName, type, isExtern, n);\n           }\n         }\n \n               ((isExtern && !ownerType.isNativeObjectType()) ||\n                !ownerType.isInstanceType())) {\n             // If the property is undeclared or inferred, declare it now.\n-            ownerType.defineDeclaredProperty(propName, valueType, isExtern);\n+            ownerType.defineDeclaredProperty(propName, valueType, isExtern, n);\n           }\n         }\n \n           // If this is a stub for a prototype, just declare it\n           // as an unknown type. These are seen often in externs.\n           ownerType.defineInferredProperty(\n-              propName, unknownType, isExtern);\n+              propName, unknownType, isExtern, n);\n         } else {\n           typeRegistry.registerPropertyOnType(\n               propName, ownerType == null ? unknownType : ownerType);\n           thisType.defineDeclaredProperty(\n               name.getString(),\n               jsType,\n-              false /* functions with implementations are not in externs */);\n+              false /* functions with implementations are not in externs */,\n+              member);\n         }\n       }\n     } // end CollectProperties\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n   private final ErrorReporter errorReporter;\n   private final ErrorReporterParser parser = new ErrorReporterParser();\n \n+  // Use a template node for properties set on all nodes to minimize the\n+  // memory footprint associated with these (similar to IRFactory).\n+  private final Node templateNode;\n+\n   private class ErrorReporterParser {\n     void addWarning(String messageId, String messageArg, int lineno,\n                     int charno) {\n     this.suppressionNames = config.suppressionNames;\n \n     this.errorReporter = errorReporter;\n+    this.templateNode = this.createTemplateNode();\n   }\n \n   /**\n \n   private Node wrapNode(int type, Node n) {\n     return n == null ? null :\n-        new Node(type, n, stream.getLineno(), stream.getCharno());\n+        new Node(type, n, stream.getLineno(),\n+            stream.getCharno()).clonePropsFrom(templateNode);\n   }\n \n   private Node newNode(int type) {\n-    return new Node(type, stream.getLineno(), stream.getCharno());\n+    return new Node(type, stream.getLineno(),\n+        stream.getCharno()).clonePropsFrom(templateNode);\n   }\n \n   private Node newStringNode(String s) {\n-    return Node.newString(s, stream.getLineno(), stream.getCharno());\n+    return Node.newString(s, stream.getLineno(),\n+        stream.getCharno()).clonePropsFrom(templateNode);\n+  }\n+\n+  // This is similar to IRFactory.createTemplateNode to share common props\n+  // e.g., source-name, between all nodes.\n+  private Node createTemplateNode() {\n+    // The Node type choice is arbitrary.\n+    Node templateNode = new Node(Token.SCRIPT);\n+    templateNode.putProp(Node.SOURCENAME_PROP, sourceName);\n+    return templateNode;\n   }\n \n   private Node reportTypeSyntaxWarning(String warning) {\n--- a/src/com/google/javascript/rhino/jstype/EnumElementType.java\n+++ b/src/com/google/javascript/rhino/jstype/EnumElementType.java\n \n \n import com.google.javascript.rhino.ErrorReporter;\n+import com.google.javascript.rhino.Node;\n \n import java.util.Set;\n \n \n   @Override\n   boolean defineProperty(String propertyName, JSType type,\n-      boolean inferred, boolean inExterns) {\n+      boolean inferred, boolean inExterns, Node propertyNode) {\n     // nothing\n     return true;\n   }\n--- a/src/com/google/javascript/rhino/jstype/EnumType.java\n+++ b/src/com/google/javascript/rhino/jstype/EnumType.java\n import static com.google.javascript.rhino.jstype.TernaryValue.TRUE;\n \n import com.google.javascript.rhino.ErrorReporter;\n+import com.google.javascript.rhino.Node;\n \n import java.util.Collections;\n import java.util.HashSet;\n     return Collections.unmodifiableSet(elements);\n   }\n \n-  public boolean defineElement(String name) {\n+  /**\n+   * Defines a new element on this enum.\n+   * @param name the name of the new element\n+   * @param definingNode the {@code Node} that defines this new element\n+   * @return true iff the new element is added successfully\n+   */\n+  public boolean defineElement(String name, Node definingNode) {\n     elements.add(name);\n-    return defineDeclaredProperty(name, elementsType, false);\n+    return defineDeclaredProperty(name, elementsType, false, definingNode);\n   }\n \n   /**\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n                 new FunctionBuilder(registry)\n                     .withReturnType(getReturnType())\n                     .build(),\n-                false);\n+                false, source);\n           } else {\n             params = params.cloneTree();\n             Node thisTypeNode = Node.newString(Token.NAME, \"thisType\");\n                     .withParamsNode(params)\n                     .withReturnType(getReturnType())\n                     .build(),\n-                false);\n+                false, source);\n           }\n         } else if (\"apply\".equals(name)) {\n           // Define the \"apply\" function lazily.\n                   .withParams(builder)\n                   .withReturnType(getReturnType())\n                   .build(),\n-              false);\n+              false, source);\n         }\n       }\n \n \n   @Override\n   boolean defineProperty(String name, JSType type,\n-      boolean inferred, boolean inExterns) {\n+      boolean inferred, boolean inExterns, Node propertyNode) {\n     if (\"prototype\".equals(name)) {\n       ObjectType objType = type.toObjectType();\n       if (objType != null) {\n         return false;\n       }\n     }\n-    return super.defineProperty(name, type, inferred, inExterns);\n+    return super.defineProperty(name, type, inferred, inExterns, propertyNode);\n   }\n \n   @Override\n--- a/src/com/google/javascript/rhino/jstype/InstanceObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/InstanceObjectType.java\n \n \n import com.google.common.base.Preconditions;\n+import com.google.javascript.rhino.Node;\n \n /**\n  * An object type that is an instance of some function constructor.\n \n   @Override\n   boolean defineProperty(String name, JSType type, boolean inferred,\n-      boolean inExterns) {\n+      boolean inExterns, Node propertyNode) {\n     ObjectType proto = getImplicitPrototype();\n     if (proto != null && proto.hasOwnDeclaredProperty(name)) {\n       return false;\n     }\n-    return super.defineProperty(name, type, inferred, inExterns);\n+    return super.defineProperty(name, type, inferred, inExterns, propertyNode);\n   }\n \n   @Override\n--- a/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n+++ b/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.ScriptRuntime;\n import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.RecordTypeBuilder.RecordProperty;\n \n import java.io.Serializable;\n import java.util.Collection;\n             createArrowType(createOptionalParameters(ALL_TYPE), UNKNOWN_TYPE),\n             null, null, true, true);\n     OBJECT_FUNCTION_TYPE.defineDeclaredProperty(\n-        \"prototype\", TOP_LEVEL_PROTOTYPE, true);\n+        \"prototype\", TOP_LEVEL_PROTOTYPE, true, null);\n     registerNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE, OBJECT_FUNCTION_TYPE);\n \n     ObjectType OBJECT_PROTOTYPE = OBJECT_FUNCTION_TYPE.getPrototype();\n   /**\n    * Creates a record type.\n    */\n-  public RecordType createRecordType(Map<String, JSType> properties) {\n+  public RecordType createRecordType(Map<String, RecordProperty> properties) {\n     return new RecordType(this, properties);\n   }\n \n       }\n \n       // Add the property to the record.\n-      builder.addProperty(fieldName, fieldType);\n+      builder.addProperty(fieldName, fieldType, fieldNameNode);\n     }\n \n     return builder.build();\n--- a/src/com/google/javascript/rhino/jstype/NoObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/NoObjectType.java\n \n import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.JSDocInfo;\n+import com.google.javascript.rhino.Node;\n \n import java.io.Serializable;\n \n \n   @Override\n   boolean defineProperty(String propertyName, JSType type,\n-      boolean inferred, boolean inExterns) {\n+      boolean inferred, boolean inExterns, Node propertyNode) {\n     // nothing, all properties are defined\n     return true;\n   }\n--- a/src/com/google/javascript/rhino/jstype/ObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ObjectType.java\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Sets;\n import com.google.javascript.rhino.JSDocInfo;\n+import com.google.javascript.rhino.Node;\n \n import java.util.Set;\n \n    *        file. TightenTypes assumes that any function passed to an externs\n    *        property could be called, so setting this incorrectly could result\n    *        in live code being removed.\n+   * @param propertyNode the node corresponding to the declaration of property\n+   *        which might later be accessed using {@code getPropertyNode}.\n    */\n   public final boolean defineDeclaredProperty(String propertyName,\n-      JSType type, boolean inExterns) {\n-    boolean result = defineProperty(propertyName, type, false, inExterns);\n+      JSType type, boolean inExterns, Node propertyNode) {\n+    boolean result = defineProperty(propertyName, type, false, inExterns,\n+        propertyNode);\n \n     // All property definitions go through this method\n     // or defineDeclaredProperty. Because the properties defined an an\n    *        file. TightenTypes assumes that any function passed to an externs\n    *        property could be called, so setting this incorrectly could result\n    *        in live code being removed.\n+   * @param propertyNode the node corresponding to the inferred definition of\n+   *        property that might later be accessed using {@code getPropertyNode}.\n    */\n   public final boolean defineInferredProperty(String propertyName,\n-      JSType type, boolean inExterns) {\n+      JSType type, boolean inExterns, Node propertyNode) {\n     if (hasProperty(propertyName)) {\n       JSType originalType = getPropertyType(propertyName);\n       type = originalType == null ? type :\n           originalType.getLeastSupertype(type);\n     }\n \n-    boolean result = defineProperty(propertyName, type, true, inExterns);\n+    boolean result = defineProperty(propertyName, type, true, inExterns,\n+        propertyNode);\n \n     // All property definitions go through this method\n     // or defineDeclaredProperty. Because the properties defined an an\n    *        file. TightenTypes assumes that any function passed to an externs\n    *        property could be called, so setting this incorrectly could result\n    *        in live code being removed.\n+   * @param propertyNode the node that represents the definition of property.\n+   *        Depending on the actual sub-type the node type might be different.\n+   *        The general idea is to have an estimate of where in the source code\n+   *        this property is defined.\n    * @return True if the property was registered successfully, false if this\n    *        conflicts with a previous property type declaration.\n    */\n   abstract boolean defineProperty(String propertyName, JSType type,\n-      boolean inferred, boolean inExterns);\n+      boolean inferred, boolean inExterns, Node propertyNode);\n+\n+  /**\n+   * Gets the node corresponding to the definition of the specified property.\n+   * This could be the node corresponding to declaration of the property or the\n+   * node corresponding to the first reference to this property, e.g.,\n+   * \"this.propertyName\" in a constructor. Note this is mainly intended to be\n+   * an estimate of where in the source code a property is defined. Sometime\n+   * the returned node is not even part of the global AST but in the AST of the\n+   * JsDoc that defines a type.\n+   *\n+   * @param propertyName the name of the property\n+   * @return the {@code Node} corresponding to the property or null.\n+   */\n+  public Node getPropertyNode(String propertyName) {\n+    return null;\n+  }\n \n   /**\n    * Gets the docInfo on the specified property on this type.  This should not\n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n import com.google.common.collect.Sets;\n import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.JSDocInfo;\n+import com.google.javascript.rhino.Node;\n \n import java.io.Serializable;\n import java.util.Map;\n \n   @Override\n   boolean defineProperty(String name, JSType type, boolean inferred,\n-      boolean inExterns) {\n+      boolean inExterns, Node propertyNode) {\n     if (hasOwnDeclaredProperty(name)) {\n       return false;\n     }\n-    properties.put(name, new Property(type, inferred, inExterns));\n+    properties.put(name, new Property(type, inferred, inExterns, propertyNode));\n     return true;\n+  }\n+\n+  @Override\n+  public Node getPropertyNode(String propertyName) {\n+    Property p = properties.get(propertyName);\n+    if (p != null) {\n+      return p.propertyNode;\n+    }\n+    ObjectType implicitPrototype = getImplicitPrototype();\n+    if (implicitPrototype != null) {\n+      return implicitPrototype.getPropertyNode(propertyName);\n+    }\n+    return null;\n   }\n \n   @Override\n         // was not defined anywhere, then we consider this an explicit\n         // declaration of the property.\n         defineInferredProperty(propertyName, getPropertyType(propertyName),\n-            inExterns);\n+            inExterns, null);\n       }\n \n       // The prototype property is not represented as a normal Property.\n      */\n     private final boolean inExterns;\n \n+    /**\n+     * The node corresponding to this property, e.g., a GETPROP node that\n+     * declares this property.\n+     */\n+    private final Node propertyNode;\n+\n     /**  The JSDocInfo for this property. */\n     private JSDocInfo docInfo = null;\n \n-    private Property(JSType type, boolean inferred, boolean inExterns) {\n+    private Property(JSType type, boolean inferred, boolean inExterns, Node propertyNode) {\n       this.type = type;\n       this.inferred = inferred;\n       this.inExterns = inExterns;\n+      this.propertyNode = propertyNode;\n     }\n   }\n \n--- a/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/ProxyObjectType.java\n import com.google.common.collect.ImmutableSet;\n import com.google.javascript.rhino.ErrorReporter;\n import com.google.javascript.rhino.JSDocInfo;\n+import com.google.javascript.rhino.Node;\n \n import java.util.Collections;\n import java.util.Set;\n \n   @Override\n   boolean defineProperty(String propertyName, JSType type,\n-      boolean inferred, boolean inExterns) {\n+      boolean inferred, boolean inExterns, Node propertyNode) {\n     return referencedObjType == null ? true :\n         referencedObjType.defineProperty(\n-            propertyName, type, inferred, inExterns);\n+            propertyName, type, inferred, inExterns, propertyNode);\n   }\n \n   @Override\n   public boolean isPropertyTypeDeclared(String propertyName) {\n     return referencedObjType == null ? false :\n         referencedObjType.isPropertyTypeDeclared(propertyName);\n+  }\n+\n+  @Override\n+  public Node getPropertyNode(String propertyName) {\n+    return referencedObjType == null ? null :\n+        referencedObjType.getPropertyNode(propertyName);\n   }\n \n   @Override\n--- a/src/com/google/javascript/rhino/jstype/RecordType.java\n+++ b/src/com/google/javascript/rhino/jstype/RecordType.java\n \n import com.google.common.collect.Maps;\n import com.google.javascript.rhino.ErrorReporter;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.jstype.RecordTypeBuilder.RecordProperty;\n \n import java.util.Map;\n import java.util.Set;\n public class RecordType extends PrototypeObjectType {\n   private static final long serialVersionUID = 1L;\n \n-  private SortedMap<String, JSType> properties = Maps.newTreeMap();\n+  private final SortedMap<String, JSType> properties = Maps.newTreeMap();\n   private boolean isFrozen = false;\n \n   /**\n    *\n    * @param registry The type registry under which this type lives.\n    * @param properties A map of all the properties of this record type.\n+   * @throws IllegalStateException if the {@code RecordProperty} associated\n+   *         with a property is null.\n    */\n-  RecordType(JSTypeRegistry registry, Map<String, JSType> properties) {\n+  RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties) {\n     super(registry, null, null);\n \n     for (String property : properties.keySet()) {\n-      defineDeclaredProperty(property, properties.get(property), false);\n+      RecordProperty prop = properties.get(property);\n+      if (prop == null) {\n+        throw new IllegalStateException(\n+            \"RecordProperty associated with a property should not be null!\");\n+      }\n+      defineDeclaredProperty(property, prop.getType(), false, prop.getPropertyNode());\n     }\n \n     // Freeze the record type.\n \n   @Override\n   boolean defineProperty(String propertyName, JSType type,\n-      boolean inferred, boolean inExterns) {\n+      boolean inferred, boolean inExterns, Node propertyNode) {\n     if (isFrozen) {\n       return false;\n     }\n       properties.put(propertyName, type);\n     }\n \n-    return super.defineProperty(propertyName, type, inferred, inExterns);\n+    return super.defineProperty(propertyName, type, inferred, inExterns,\n+        propertyNode);\n   }\n \n   @Override\n       if (thatRecord.hasProperty(property) &&\n           thatRecord.getPropertyType(property).isEquivalentTo(\n               getPropertyType(property))) {\n-        builder.addProperty(property, getPropertyType(property));\n+        builder.addProperty(property, getPropertyType(property),\n+            getPropertyNode(property));\n       }\n     }\n \n           return registry.getNativeObjectType(JSTypeNative.NO_TYPE);\n         }\n \n-        builder.addProperty(property, getPropertyType(property));\n+        builder.addProperty(property, getPropertyType(property),\n+            getPropertyNode(property));\n       }\n \n       for (String property : thatRecord.properties.keySet()) {\n         if (!hasProperty(property)) {\n-          builder.addProperty(property, thatRecord.getPropertyType(property));\n+          builder.addProperty(property, thatRecord.getPropertyType(property),\n+              thatRecord.getPropertyNode(property));\n         }\n       }\n \n--- a/src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java\n+++ b/src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java\n package com.google.javascript.rhino.jstype;\n \n import com.google.common.collect.ImmutableMap;\n+import com.google.javascript.rhino.Node;\n \n /**\n  * A builder for record types.\n  */\n public class RecordTypeBuilder {\n   private boolean isEmpty = true;\n-  private JSTypeRegistry registry;\n-  private final ImmutableMap.Builder<String, JSType> properties =\n+  private final JSTypeRegistry registry;\n+  private final ImmutableMap.Builder<String, RecordProperty> properties =\n       ImmutableMap.builder();\n \n   public RecordTypeBuilder(JSTypeRegistry registry) {\n \n   /**\n    * Adds a property with the given name and type to the record type.\n-   *\n+   * @param name the name of the new property\n+   * @param type the JSType of the new property\n+   * @param propertyNode the node that holds this property definition\n    * @return The builder itself for chaining purposes.\n    */\n-  public RecordTypeBuilder addProperty(String name, JSType type) {\n+  public RecordTypeBuilder addProperty(String name, JSType type, Node\n+      propertyNode) {\n     isEmpty = false;\n-    properties.put(name, type);\n+    properties.put(name, new RecordProperty(type, propertyNode));\n     return this;\n   }\n \n \n     return registry.createRecordType(properties.build());\n   }\n+\n+  static class RecordProperty {\n+    private final JSType type;\n+    private final Node propertyNode;\n+\n+    RecordProperty(JSType type, Node propertyNode) {\n+      this.type = type;\n+      this.propertyNode = propertyNode;\n+    }\n+\n+    public JSType getType() {\n+      return type;\n+    }\n+\n+    public Node getPropertyNode() {\n+      return propertyNode;\n+    }\n+  }\n }\n--- a/src/com/google/javascript/rhino/jstype/UnknownType.java\n+++ b/src/com/google/javascript/rhino/jstype/UnknownType.java\n import static com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN;\n \n import com.google.javascript.rhino.ErrorReporter;\n+import com.google.javascript.rhino.Node;\n \n import java.util.Set;\n \n \n   @Override\n   boolean defineProperty(String propertyName, JSType type,\n-      boolean inferred, boolean inExterns) {\n+      boolean inferred, boolean inExterns, Node propertyNode) {\n     // nothing to define\n     return true;\n   }\n--- a/src/com/google/javascript/rhino/testing/BaseJSTypeTestCase.java\n+++ b/src/com/google/javascript/rhino/testing/BaseJSTypeTestCase.java\n     addMethod(registry, arrayPrototype, \"sort\", arrayType);\n     addMethod(registry, arrayPrototype, \"splice\", arrayType);\n     addMethod(registry, arrayPrototype, \"unshift\", numberType);\n-    arrayType.defineDeclaredProperty(\"length\", numberType, true);\n+    arrayType.defineDeclaredProperty(\"length\", numberType, true, null);\n \n     ObjectType booleanPrototype = registry\n         .getNativeFunctionType(JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE)\n         registry.createNullableType(arrayType));\n     addMethod(registry, regexpPrototype, \"test\", booleanType);\n     addMethod(registry, regexpPrototype, \"toString\", stringType);\n-    regexpType.defineDeclaredProperty(\"source\", stringType, true);\n-    regexpType.defineDeclaredProperty(\"global\", booleanType, true);\n-    regexpType.defineDeclaredProperty(\"ignoreCase\", booleanType, true);\n-    regexpType.defineDeclaredProperty(\"multiline\", booleanType, true);\n-    regexpType.defineDeclaredProperty(\"lastIndex\", numberType, true);\n+    regexpType.defineDeclaredProperty(\"source\", stringType, true, null);\n+    regexpType.defineDeclaredProperty(\"global\", booleanType, true, null);\n+    regexpType.defineDeclaredProperty(\"ignoreCase\", booleanType, true, null);\n+    regexpType.defineDeclaredProperty(\"multiline\", booleanType, true, null);\n+    regexpType.defineDeclaredProperty(\"lastIndex\", numberType, true, null);\n \n     ObjectType stringPrototype = registry\n         .getNativeFunctionType(JSTypeNative.STRING_OBJECT_FUNCTION_TYPE)\n     addMethod(registry, stringPrototype, \"toLocaleLowerCase\", stringType);\n     addMethod(registry, stringPrototype, \"toUpperCase\", stringType);\n     addMethod(registry, stringPrototype, \"toLocaleUpperCase\", stringType);\n-    stringObjectType.defineDeclaredProperty(\"length\", numberType, true);\n+    stringObjectType.defineDeclaredProperty(\"length\", numberType, true, null);\n   }\n \n   private static void addMethod(\n       JSTypeRegistry registry, ObjectType receivingType, String methodName,\n       JSType returnType) {\n     receivingType.defineDeclaredProperty(methodName,\n-        new FunctionBuilder(registry).withReturnType(returnType).build(), true);\n+        new FunctionBuilder(registry).withReturnType(returnType).build(), true, null);\n   }\n \n   protected JSType createUnionType(JSType... variants) {\n--- a/test/com/google/javascript/jscomp/ConcreteTypeTest.java\n+++ b/test/com/google/javascript/jscomp/ConcreteTypeTest.java\n     ObjectType objType = typeRegistry.createObjectType(name, null,\n         typeRegistry.createObjectType(name + \".prototype\", null, null));\n     for (int i = 0; i < propNames.length; ++i) {\n-      objType.defineDeclaredProperty(propNames[i], unknownType, false);\n+      objType.defineDeclaredProperty(propNames[i], unknownType, false, null);\n     }\n     return new ConcreteInstanceType(factory, objType);\n   }\n--- a/test/com/google/javascript/jscomp/parsing/ParserTest.java\n+++ b/test/com/google/javascript/jscomp/parsing/ParserTest.java\n     assertNotNull(info);\n \n     assertTypeEquals(createRecordTypeBuilder().\n-                     addProperty(\"x\", NUMBER_TYPE).\n-                     addProperty(\"y\", STRING_TYPE).\n-                     addProperty(\"z\", UNKNOWN_TYPE).\n+                     addProperty(\"x\", NUMBER_TYPE, null).\n+                     addProperty(\"y\", STRING_TYPE, null).\n+                     addProperty(\"z\", UNKNOWN_TYPE, null).\n                      build(),\n                      info.getType());\n \n--- a/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n+++ b/test/com/google/javascript/rhino/jstype/JSTypeTest.java\n import com.google.javascript.rhino.Token;\n import com.google.javascript.rhino.jstype.ArrowType;\n import com.google.javascript.rhino.jstype.JSType.TypePair;\n+import com.google.javascript.rhino.jstype.RecordTypeBuilder.RecordProperty;\n import com.google.javascript.rhino.testing.Asserts;\n import com.google.javascript.rhino.testing.BaseJSTypeTestCase;\n import com.google.javascript.rhino.testing.EmptyScope;\n     super.setUp();\n \n     RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    builder.addProperty(\"a\", NUMBER_TYPE);\n-    builder.addProperty(\"b\", STRING_TYPE);\n+    builder.addProperty(\"a\", NUMBER_TYPE, null);\n+    builder.addProperty(\"b\", STRING_TYPE, null);\n     recordType = builder.build();\n \n     enumType = new EnumType(registry, \"Enum\", NUMBER_TYPE);\n     interfaceInstType = interfaceType.getInstanceType();\n \n     googBar = registry.createConstructorType(\"goog.Bar\", null, null, null);\n-    googBar.getPrototype().defineDeclaredProperty(\"date\", DATE_TYPE, true);\n+    googBar.getPrototype().defineDeclaredProperty(\"date\", DATE_TYPE, true,\n+        null);\n     googBar.setImplementedInterfaces(\n         Lists.<ObjectType>newArrayList(interfaceInstType));\n     googBarInst = googBar.getInstanceType();\n     googSubSubBarInst = googSubSubBar.getInstanceType();\n \n     final ObjectType googObject = registry.createAnonymousObjectType();\n-    googObject.defineDeclaredProperty(\"Bar\", googBar, false);\n+    googObject.defineDeclaredProperty(\"Bar\", googBar, false, null);\n \n     namedGoogBar.resolve(null, new StaticScope<JSType>() {\n           public StaticSlot<JSType> getSlot(String name) {\n    */\n   public void testRecordTypeSubtyping() {\n     RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    builder.addProperty(\"a\", NUMBER_TYPE);\n-    builder.addProperty(\"b\", STRING_TYPE);\n-    builder.addProperty(\"c\", STRING_TYPE);\n+    builder.addProperty(\"a\", NUMBER_TYPE, null);\n+    builder.addProperty(\"b\", STRING_TYPE, null);\n+    builder.addProperty(\"c\", STRING_TYPE, null);\n     JSType subRecordType = builder.build();\n \n     assertTrue(subRecordType.isSubtype(recordType));\n     assertFalse(recordType.isSubtype(subRecordType));\n \n     builder = new RecordTypeBuilder(registry);\n-    builder.addProperty(\"a\", OBJECT_TYPE);\n-    builder.addProperty(\"b\", STRING_TYPE);\n+    builder.addProperty(\"a\", OBJECT_TYPE, null);\n+    builder.addProperty(\"b\", STRING_TYPE, null);\n     JSType differentRecordType = builder.build();\n \n     assertFalse(differentRecordType.isSubtype(recordType));\n    */\n   public void testRecordTypeSubtypingWithInferredProperties() {\n     RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    builder.addProperty(\"a\", googSubBarInst);\n+    builder.addProperty(\"a\", googSubBarInst, null);\n     JSType record = builder.build();\n \n     ObjectType subtypeProp = registry.createAnonymousObjectType();\n-    subtypeProp.defineInferredProperty(\"a\", googSubSubBarInst, false);\n+    subtypeProp.defineInferredProperty(\"a\", googSubSubBarInst, false, null);\n     assertTrue(subtypeProp.isSubtype(record));\n     assertFalse(record.isSubtype(subtypeProp));\n \n     ObjectType supertypeProp = registry.createAnonymousObjectType();\n-    supertypeProp.defineInferredProperty(\"a\", googBarInst, false);\n+    supertypeProp.defineInferredProperty(\"a\", googBarInst, false, null);\n     assertFalse(supertypeProp.isSubtype(record));\n     assertFalse(record.isSubtype(supertypeProp));\n \n     ObjectType declaredSubtypeProp = registry.createAnonymousObjectType();\n-    declaredSubtypeProp.defineDeclaredProperty(\"a\", googSubSubBarInst, false);\n+    declaredSubtypeProp.defineDeclaredProperty(\"a\", googSubSubBarInst,\n+        false, null);\n     assertFalse(declaredSubtypeProp.isSubtype(record));\n     assertFalse(record.isSubtype(declaredSubtypeProp));\n   }\n    */\n   public void testRecordTypeLeastSuperType1() {\n     RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    builder.addProperty(\"a\", NUMBER_TYPE);\n-    builder.addProperty(\"b\", STRING_TYPE);\n-    builder.addProperty(\"c\", STRING_TYPE);\n+    builder.addProperty(\"a\", NUMBER_TYPE, null);\n+    builder.addProperty(\"b\", STRING_TYPE, null);\n+    builder.addProperty(\"c\", STRING_TYPE, null);\n     JSType subRecordType = builder.build();\n \n     JSType leastSupertype = recordType.getLeastSupertype(subRecordType);\n \n   public void testRecordTypeLeastSuperType2() {\n     RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    builder.addProperty(\"e\", NUMBER_TYPE);\n-    builder.addProperty(\"b\", STRING_TYPE);\n-    builder.addProperty(\"c\", STRING_TYPE);\n+    builder.addProperty(\"e\", NUMBER_TYPE, null);\n+    builder.addProperty(\"b\", STRING_TYPE, null);\n+    builder.addProperty(\"c\", STRING_TYPE, null);\n     JSType subRecordType = builder.build();\n \n     JSType leastSupertype = recordType.getLeastSupertype(subRecordType);\n \n     builder = new RecordTypeBuilder(registry);\n-    builder.addProperty(\"b\", STRING_TYPE);\n+    builder.addProperty(\"b\", STRING_TYPE, null);\n \n     assertTypeEquals(leastSupertype, builder.build());\n   }\n \n   public void testRecordTypeLeastSuperType3() {\n     RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    builder.addProperty(\"d\", NUMBER_TYPE);\n-    builder.addProperty(\"e\", STRING_TYPE);\n-    builder.addProperty(\"f\", STRING_TYPE);\n+    builder.addProperty(\"d\", NUMBER_TYPE, null);\n+    builder.addProperty(\"e\", STRING_TYPE, null);\n+    builder.addProperty(\"f\", STRING_TYPE, null);\n     JSType subRecordType = builder.build();\n \n     JSType leastSupertype = recordType.getLeastSupertype(subRecordType);\n    */\n   public void testRecordTypeGreatestSubType1() {\n     RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    builder.addProperty(\"d\", NUMBER_TYPE);\n-    builder.addProperty(\"e\", STRING_TYPE);\n-    builder.addProperty(\"f\", STRING_TYPE);\n+    builder.addProperty(\"d\", NUMBER_TYPE, null);\n+    builder.addProperty(\"e\", STRING_TYPE, null);\n+    builder.addProperty(\"f\", STRING_TYPE, null);\n \n     JSType subRecordType = builder.build();\n \n     JSType subtype = recordType.getGreatestSubtype(subRecordType);\n \n     builder = new RecordTypeBuilder(registry);\n-    builder.addProperty(\"d\", NUMBER_TYPE);\n-    builder.addProperty(\"e\", STRING_TYPE);\n-    builder.addProperty(\"f\", STRING_TYPE);\n-    builder.addProperty(\"a\", NUMBER_TYPE);\n-    builder.addProperty(\"b\", STRING_TYPE);\n+    builder.addProperty(\"d\", NUMBER_TYPE, null);\n+    builder.addProperty(\"e\", STRING_TYPE, null);\n+    builder.addProperty(\"f\", STRING_TYPE, null);\n+    builder.addProperty(\"a\", NUMBER_TYPE, null);\n+    builder.addProperty(\"b\", STRING_TYPE, null);\n \n     assertTypeEquals(subtype, builder.build());\n   }\n     JSType subtype = recordType.getGreatestSubtype(subRecordType);\n \n     builder = new RecordTypeBuilder(registry);\n-    builder.addProperty(\"a\", NUMBER_TYPE);\n-    builder.addProperty(\"b\", STRING_TYPE);\n+    builder.addProperty(\"a\", NUMBER_TYPE, null);\n+    builder.addProperty(\"b\", STRING_TYPE, null);\n \n     assertTypeEquals(subtype, builder.build());\n   }\n \n   public void testRecordTypeGreatestSubType3() {\n     RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    builder.addProperty(\"a\", NUMBER_TYPE);\n-    builder.addProperty(\"b\", STRING_TYPE);\n-    builder.addProperty(\"c\", STRING_TYPE);\n+    builder.addProperty(\"a\", NUMBER_TYPE, null);\n+    builder.addProperty(\"b\", STRING_TYPE, null);\n+    builder.addProperty(\"c\", STRING_TYPE, null);\n \n     JSType subRecordType = builder.build();\n \n     JSType subtype = recordType.getGreatestSubtype(subRecordType);\n \n     builder = new RecordTypeBuilder(registry);\n-    builder.addProperty(\"a\", NUMBER_TYPE);\n-    builder.addProperty(\"b\", STRING_TYPE);\n-    builder.addProperty(\"c\", STRING_TYPE);\n+    builder.addProperty(\"a\", NUMBER_TYPE, null);\n+    builder.addProperty(\"b\", STRING_TYPE, null);\n+    builder.addProperty(\"c\", STRING_TYPE, null);\n \n     assertTypeEquals(subtype, builder.build());\n   }\n \n   public void testRecordTypeGreatestSubType4() {\n     RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    builder.addProperty(\"a\", STRING_TYPE);\n-    builder.addProperty(\"b\", STRING_TYPE);\n-    builder.addProperty(\"c\", STRING_TYPE);\n+    builder.addProperty(\"a\", STRING_TYPE, null);\n+    builder.addProperty(\"b\", STRING_TYPE, null);\n+    builder.addProperty(\"c\", STRING_TYPE, null);\n \n     JSType subRecordType = builder.build();\n \n \n   public void testRecordTypeGreatestSubType5() {\n     RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    builder.addProperty(\"a\", STRING_TYPE);\n+    builder.addProperty(\"a\", STRING_TYPE, null);\n \n     JSType recordType = builder.build();\n \n \n     // if Function is given a property \"a\" of type \"string\", then it's\n     // a subtype of the record type {a: string}.\n-    U2U_CONSTRUCTOR_TYPE.defineDeclaredProperty(\"a\", STRING_TYPE, false);\n+    U2U_CONSTRUCTOR_TYPE.defineDeclaredProperty(\"a\", STRING_TYPE, false, null);\n     assertTypeEquals(U2U_CONSTRUCTOR_TYPE,\n                  recordType.getGreatestSubtype(U2U_CONSTRUCTOR_TYPE));\n     assertTypeEquals(U2U_CONSTRUCTOR_TYPE,\n \n   public void testRecordTypeGreatestSubType6() {\n     RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    builder.addProperty(\"x\", UNKNOWN_TYPE);\n+    builder.addProperty(\"x\", UNKNOWN_TYPE, null);\n \n     JSType recordType = builder.build();\n \n \n     // if Function is given a property \"x\" of type \"string\", then it's\n     // also a subtype of the record type {x: ?}.\n-    U2U_CONSTRUCTOR_TYPE.defineDeclaredProperty(\"x\", STRING_TYPE, false);\n+    U2U_CONSTRUCTOR_TYPE.defineDeclaredProperty(\"x\", STRING_TYPE, false, null);\n     assertTypeEquals(U2U_CONSTRUCTOR_TYPE,\n                  recordType.getGreatestSubtype(U2U_CONSTRUCTOR_TYPE));\n     assertTypeEquals(U2U_CONSTRUCTOR_TYPE,\n \n   public void testRecordTypeGreatestSubType7() {\n     RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    builder.addProperty(\"x\", NUMBER_TYPE);\n+    builder.addProperty(\"x\", NUMBER_TYPE, null);\n \n     JSType recordType = builder.build();\n \n     // if Function is given a property \"x\" of type \"string\", then it's\n     // not a subtype of the record type {x: number}.\n-    U2U_CONSTRUCTOR_TYPE.defineDeclaredProperty(\"x\", STRING_TYPE, false);\n+    U2U_CONSTRUCTOR_TYPE.defineDeclaredProperty(\"x\", STRING_TYPE, false, null);\n     assertTypeEquals(NO_OBJECT_TYPE,\n                  recordType.getGreatestSubtype(U2U_CONSTRUCTOR_TYPE));\n   }\n   public void testRecordTypeGreatestSubType8() {\n     RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    builder.addProperty(\"xyz\", UNKNOWN_TYPE);\n+    builder.addProperty(\"xyz\", UNKNOWN_TYPE, null);\n \n     JSType recordType = builder.build();\n \n \n     // if goog.Bar is given a property \"xyz\" of type \"string\", then it's\n     // also a subtype of the record type {x: ?}.\n-    googBar.defineDeclaredProperty(\"xyz\", STRING_TYPE, false);\n+    googBar.defineDeclaredProperty(\"xyz\", STRING_TYPE, false, null);\n \n     assertTypeEquals(googBar,\n                  recordType.getGreatestSubtype(U2U_CONSTRUCTOR_TYPE));\n     // adding one property on the prototype\n     ObjectType prototype =\n         (ObjectType) constructor.getPropertyType(\"prototype\");\n-    prototype.defineDeclaredProperty(\"foo\", DATE_TYPE, false);\n+    prototype.defineDeclaredProperty(\"foo\", DATE_TYPE, false, null);\n \n     assertEquals(NATIVE_PROPERTIES_COUNT + 1, instance.getPropertiesCount());\n   }\n \n     // replacing the prototype\n     ObjectType prototype = registry.createAnonymousObjectType();\n-    prototype.defineDeclaredProperty(\"foo\", DATE_TYPE, false);\n-    constructor.defineDeclaredProperty(\"prototype\", prototype, true);\n+    prototype.defineDeclaredProperty(\"foo\", DATE_TYPE, false, null);\n+    constructor.defineDeclaredProperty(\"prototype\", prototype, true, null);\n \n     assertEquals(NATIVE_PROPERTIES_COUNT + 1, instance.getPropertiesCount());\n   }\n     ObjectType sup = registry.createAnonymousObjectType();\n     int nativeProperties = sup.getPropertiesCount();\n \n-    sup.defineDeclaredProperty(\"a\", DATE_TYPE, false);\n+    sup.defineDeclaredProperty(\"a\", DATE_TYPE, false, null);\n     assertEquals(nativeProperties + 1, sup.getPropertiesCount());\n \n-    sup.defineDeclaredProperty(\"b\", DATE_TYPE, false);\n+    sup.defineDeclaredProperty(\"b\", DATE_TYPE, false, null);\n     assertEquals(nativeProperties + 2, sup.getPropertiesCount());\n \n     ObjectType sub = registry.createObjectType(sup);\n \n     // Test declarations.\n     assertTrue(\n-        prototype.defineDeclaredProperty(\"declared\", NUMBER_TYPE, false));\n+        prototype.defineDeclaredProperty(\"declared\", NUMBER_TYPE, false, null));\n     assertFalse(\n-        prototype.defineDeclaredProperty(\"declared\", NUMBER_TYPE, false));\n+        prototype.defineDeclaredProperty(\"declared\", NUMBER_TYPE, false, null));\n     assertFalse(\n-        instance.defineDeclaredProperty(\"declared\", NUMBER_TYPE, false));\n+        instance.defineDeclaredProperty(\"declared\", NUMBER_TYPE, false, null));\n     assertTypeEquals(NUMBER_TYPE, instance.getPropertyType(\"declared\"));\n \n     // Test inferring different types.\n-    assertTrue(\n-        prototype.defineInferredProperty(\"inferred1\", STRING_TYPE, false));\n-    assertTrue(\n-        prototype.defineInferredProperty(\"inferred1\", NUMBER_TYPE, false));\n+    assertTrue(prototype.defineInferredProperty(\"inferred1\", STRING_TYPE,\n+        false, null));\n+    assertTrue(prototype.defineInferredProperty(\"inferred1\", NUMBER_TYPE,\n+        false, null));\n     assertTypeEquals(\n         createUnionType(NUMBER_TYPE, STRING_TYPE),\n         instance.getPropertyType(\"inferred1\"));\n \n     // Test inferring different types on different objects.\n-    assertTrue(\n-        prototype.defineInferredProperty(\"inferred2\", STRING_TYPE, false));\n-    assertTrue(\n-        instance.defineInferredProperty(\"inferred2\", NUMBER_TYPE, false));\n+    assertTrue(prototype.defineInferredProperty(\"inferred2\", STRING_TYPE,\n+        false, null));\n+    assertTrue(instance.defineInferredProperty(\"inferred2\", NUMBER_TYPE,\n+        false, null));\n     assertTypeEquals(\n         createUnionType(NUMBER_TYPE, STRING_TYPE),\n         instance.getPropertyType(\"inferred2\"));\n \n     // Test inferring on the supertype and declaring on the subtype.\n     assertTrue(\n-        prototype.defineInferredProperty(\"prop\", STRING_TYPE, false));\n+        prototype.defineInferredProperty(\"prop\", STRING_TYPE, false, null));\n     assertTrue(\n-        instance.defineDeclaredProperty(\"prop\", NUMBER_TYPE, false));\n+        instance.defineDeclaredProperty(\"prop\", NUMBER_TYPE, false, null));\n     assertTypeEquals(NUMBER_TYPE, instance.getPropertyType(\"prop\"));\n     assertTypeEquals(STRING_TYPE, prototype.getPropertyType(\"prop\"));\n   }\n     ObjectType sup = registry.createAnonymousObjectType();\n     int nativeProperties = sup.getPropertiesCount();\n \n-    sup.defineDeclaredProperty(\"a\", OBJECT_TYPE, false);\n+    sup.defineDeclaredProperty(\"a\", OBJECT_TYPE, false, null);\n     assertEquals(nativeProperties + 1, sup.getPropertiesCount());\n \n     ObjectType sub = registry.createObjectType(sup);\n-    sub.defineDeclaredProperty(\"a\", OBJECT_TYPE, false);\n+    sub.defineDeclaredProperty(\"a\", OBJECT_TYPE, false, null);\n     assertEquals(nativeProperties + 1, sub.getPropertiesCount());\n   }\n \n         registry.createObjectType(registry.createAnonymousObjectType());\n     ObjectType sub = registry.createObjectType(sup);\n \n-    sup.defineProperty(\"externProp\", null, false, /* inExterns */ true);\n-    sub.defineProperty(\"externProp\", null, false, /* inExterns */ false);\n+    sup.defineProperty(\"externProp\", null, false, /* inExterns */ true, null);\n+    sub.defineProperty(\"externProp\", null, false, /* inExterns */ false, null);\n \n     assertTrue(sup.isPropertyInExterns(\"externProp\"));\n     assertFalse(sub.isPropertyInExterns(\"externProp\"));\n \n   public void testRecordSubtypeChain() throws Exception {\n     RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    builder.addProperty(\"a\", STRING_TYPE);\n+    builder.addProperty(\"a\", STRING_TYPE, null);\n     JSType aType = builder.build();\n \n     builder = new RecordTypeBuilder(registry);\n-    builder.addProperty(\"a\", STRING_TYPE);\n-    builder.addProperty(\"b\", STRING_TYPE);\n+    builder.addProperty(\"a\", STRING_TYPE, null);\n+    builder.addProperty(\"b\", STRING_TYPE, null);\n     JSType abType = builder.build();\n \n     builder = new RecordTypeBuilder(registry);\n-    builder.addProperty(\"a\", STRING_TYPE);\n-    builder.addProperty(\"b\", STRING_TYPE);\n-    builder.addProperty(\"c\", NUMBER_TYPE);\n+    builder.addProperty(\"a\", STRING_TYPE, null);\n+    builder.addProperty(\"b\", STRING_TYPE, null);\n+    builder.addProperty(\"c\", NUMBER_TYPE, null);\n     JSType abcType = builder.build();\n \n     List<JSType> typeChain = Lists.newArrayList(\n \n   public void testRecordAndObjectChain2() throws Exception {\n     RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    builder.addProperty(\"date\", DATE_TYPE);\n+    builder.addProperty(\"date\", DATE_TYPE, null);\n     JSType hasDateProperty = builder.build();\n \n     List<JSType> typeChain = Lists.newArrayList(\n \n   public void testRecordAndObjectChain3() throws Exception {\n     RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    builder.addProperty(\"date\", UNKNOWN_TYPE);\n+    builder.addProperty(\"date\", UNKNOWN_TYPE, null);\n     JSType hasUnknownDateProperty = builder.build();\n \n     List<JSType> typeChain = Lists.newArrayList(\n       if (type instanceof ObjectType) {\n \n         ObjectType objType = (ObjectType) type;\n-        objType.defineDeclaredProperty(propName, UNKNOWN_TYPE, false);\n-        objType.defineDeclaredProperty(\"allHaz\", UNKNOWN_TYPE, false);\n+        objType.defineDeclaredProperty(propName, UNKNOWN_TYPE, false, null);\n+        objType.defineDeclaredProperty(\"allHaz\", UNKNOWN_TYPE, false, null);\n \n         assertTypeEquals(type,\n             registry.getGreatestSubtypeWithProperty(type, propName));\n     ObjectType derived1 = registry.createObjectType(\"d1\", null, namedGoogBar);\n     ObjectType derived2 = registry.createObjectType(\"d2\", null, namedGoogBar);\n \n-    derived1.defineDeclaredProperty(\"propz\", UNKNOWN_TYPE, false);\n+    derived1.defineDeclaredProperty(\"propz\", UNKNOWN_TYPE, false, null);\n \n     assertTypeEquals(derived1,\n         registry.getGreatestSubtypeWithProperty(derived1, \"propz\"));\n     assertTypeEquals(NO_OBJECT_TYPE,\n         registry.getGreatestSubtypeWithProperty(derived2, \"propz\"));\n \n-    derived2.defineDeclaredProperty(\"propz\", UNKNOWN_TYPE, false);\n+    derived2.defineDeclaredProperty(\"propz\", UNKNOWN_TYPE, false, null);\n \n     assertTypeEquals(derived1,\n         registry.getGreatestSubtypeWithProperty(derived1, \"propz\"));\n     ObjectType foo = registry.createObjectType(\"foo\", null, OBJECT_TYPE);\n     ObjectType bar = registry.createObjectType(\"bar\", null, namedGoogBar);\n \n-    foo.defineDeclaredProperty(\"propz\", UNKNOWN_TYPE, false);\n-    bar.defineDeclaredProperty(\"propz\", UNKNOWN_TYPE, false);\n+    foo.defineDeclaredProperty(\"propz\", UNKNOWN_TYPE, false, null);\n+    bar.defineDeclaredProperty(\"propz\", UNKNOWN_TYPE, false, null);\n \n     assertTypeEquals(bar,\n         registry.getGreatestSubtypeWithProperty(namedGoogBar, \"propz\"));\n    * {@link JSTypeRegistry#createRecordType}.\n    */\n   public void testCreateRecordType() throws Exception {\n-    Map<String, JSType> properties = new HashMap<String, JSType>();\n-    properties.put(\"hello\", NUMBER_TYPE);\n+    Map<String, RecordProperty> properties = new HashMap<String, RecordProperty>();\n+    properties.put(\"hello\", new RecordProperty(NUMBER_TYPE, null));\n \n     JSType recordType = registry.createRecordType(properties);\n     assertEquals(\"{ hello : number }\", recordType.toString());\n     // anonymous\n     ObjectType anonymous = registry.createAnonymousObjectType();\n     anonymous.defineDeclaredProperty(\n-        \"a\", NUMBER_TYPE, false);\n+        \"a\", NUMBER_TYPE, false, null);\n     anonymous.defineDeclaredProperty(\n-        \"b\", NUMBER_TYPE, false);\n+        \"b\", NUMBER_TYPE, false, null);\n     anonymous.defineDeclaredProperty(\n-        \"c\", NUMBER_TYPE, false);\n+        \"c\", NUMBER_TYPE, false, null);\n     anonymous.defineDeclaredProperty(\n-        \"d\", NUMBER_TYPE, false);\n+        \"d\", NUMBER_TYPE, false, null);\n     anonymous.defineDeclaredProperty(\n-        \"e\", NUMBER_TYPE, false);\n+        \"e\", NUMBER_TYPE, false, null);\n     anonymous.defineDeclaredProperty(\n-        \"f\", NUMBER_TYPE, false);\n+        \"f\", NUMBER_TYPE, false, null);\n     assertEquals(\"{a: number, b: number, c: number, d: number, ...}\",\n         anonymous.toString());\n   }\n         registry.createObjectType(registry.createAnonymousObjectType());\n     ObjectType sub = registry.createObjectType(sup);\n \n-    sup.defineProperty(\"base\", null, false, false);\n-    sub.defineProperty(\"sub\", null, false, false);\n+    sup.defineProperty(\"base\", null, false, false, null);\n+    sub.defineProperty(\"sub\", null, false, false, null);\n \n     assertTrue(sup.hasProperty(\"base\"));\n     assertFalse(sup.hasProperty(\"sub\"));\n \n   public void testNamedTypeHasOwnProperty() throws Exception {\n     namedGoogBar.getImplicitPrototype().defineProperty(\"base\", null, false,\n-        false);\n-    namedGoogBar.defineProperty(\"sub\", null, false, false);\n+        false, null);\n+    namedGoogBar.defineProperty(\"sub\", null, false, false, null);\n \n     assertFalse(namedGoogBar.hasOwnProperty(\"base\"));\n     assertTrue(namedGoogBar.hasProperty(\"base\"));\n         registry.createObjectType(registry.createAnonymousObjectType());\n     ObjectType sub = registry.createObjectType(sup);\n \n-    sup.defineProperty(\"base\", null, false, false);\n-    sub.defineProperty(\"sub\", null, false, false);\n+    sup.defineProperty(\"base\", null, false, false, null);\n+    sub.defineProperty(\"sub\", null, false, false, null);\n \n     assertEquals(Sets.newHashSet(\"isPrototypeOf\", \"toLocaleString\",\n           \"propertyIsEnumerable\", \"toString\", \"valueOf\", \"hasOwnProperty\",\n     JSDocInfo privateInfo = new JSDocInfo();\n     privateInfo.setVisibility(Visibility.PRIVATE);\n \n-    sup.defineProperty(\"X\", NUMBER_TYPE, false, false);\n+    sup.defineProperty(\"X\", NUMBER_TYPE, false, false, null);\n     sup.setPropertyJSDocInfo(\"X\", privateInfo, false);\n \n     sub.setPropertyJSDocInfo(\"X\", deprecated, false);", "timestamp": 1294420753, "metainfo": ""}