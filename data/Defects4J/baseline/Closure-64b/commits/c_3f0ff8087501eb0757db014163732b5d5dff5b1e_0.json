{"sha": "3f0ff8087501eb0757db014163732b5d5dff5b1e", "log": "Before blindly unfolding a compound assignment, make sure that the left-hand side doesn't have side-effects.  R=johnlenz DELTA=29  (26 added, 3 deleted, 0 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=179085   ", "commit": "\n--- a/src/com/google/javascript/jscomp/UnfoldCompoundAssignments.java\n+++ b/src/com/google/javascript/jscomp/UnfoldCompoundAssignments.java\n  * <p>\n  * Notice the prefix '+' when unfolding ++. This is needed because the operand\n  * is implicitly converted to a number.\n+ * <p>\n+ * These transformations can only be performed if the left-hand side of the\n+ * assignment has no side-effects.\n  *\n  * @author elnatan@google.com (Elnatan Reisner)\n  */\n    *\n    * @param node an increment or decrement node\n    * @param isIncrement true if the operator is ++; false if it is --\n-   * @throws RuntimeException if node is a postfix expression whose value is\n-   *         used (that is, node is <em>not</em> used only for its side-effect)\n    */\n   private void unfoldIncrDecr(Node node, boolean isIncrement) {\n     Preconditions.checkArgument(\n         isPrefix(node) || valueIsDiscarded(node),\n         \"Unfolding postfix ++/-- requires that the result be ignored.\");\n     Node lhs = node.getFirstChild().cloneTree();\n+    Preconditions.checkArgument(!NodeUtil.mayHaveSideEffects(lhs),\n+        \"Cannot unfold compound assignment if LHS can have side effects\");\n     // TODO(elnatan): We might want to use type information to only add this '+'\n     // when lhs isn't already a number.\n     if (isIncrement) {\n    * @param node a compound assignment node\n    */\n   private void unfoldCompoundAssignment(Node node) {\n+    Node lhs = node.getFirstChild();\n+    Preconditions.checkArgument(!NodeUtil.mayHaveSideEffects(lhs),\n+        \"Cannot unfold compound assignment if LHS can have side effects\");\n     Node newRhs = node.cloneTree();\n     newRhs.setType(NodeUtil.getOpFromAssignmentOp(node));\n-    Node lhs = node.getFirstChild();\n     node.replaceChildAfter(lhs, newRhs);\n     node.setType(Token.ASSIGN);\n     compiler.reportCodeChange();\n--- a/test/com/google/javascript/jscomp/UnfoldCompoundAssignmentsTest.java\n+++ b/test/com/google/javascript/jscomp/UnfoldCompoundAssignmentsTest.java\n     test(\"x++, 5; for (a.x++;0;x++) {}; x++;\",\n         \"x = +x + 1, 5; for (a.x = +a.x + 1; 0; x = +x + 1) {}; x = +x + 1;\");\n   }\n+\n+  public void testIncrementSideEffects() {\n+    try {\n+      // Expanding '++' causes f to be called twice.\n+      testSame(\"++a[f()];\");\n+      fail(\"Should raise an exception\");\n+    } catch (RuntimeException e) {\n+    }\n+  }\n+\n+  public void testCompoundAssignmentSideEffects() {\n+    try {\n+      // Expanding causes f to be called twice.\n+      testSame(\"a[f()] *= 2;\");\n+      fail(\"Should raise an exception\");\n+    } catch (RuntimeException e) {\n+    }\n+  }\n }", "timestamp": 1282600102, "metainfo": ""}