{"sha": "606015f2b48ebaefb3cb1193d2b9d0310f3dc2f5", "log": "-Add command line options for the ProcessTweaks pass.  R=nicksantos DELTA=202  (151 added, 22 deleted, 29 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=277   ", "commit": "\n--- a/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Lists;\n import com.google.common.collect.Maps;\n+import com.google.javascript.jscomp.CompilerOptions.TweakProcessing;\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.TokenStream;\n import com.google.protobuf.CodedOutputStream;\n     diagnosticGroups.setWarningLevels(\n         options, config.jscompOff, CheckLevel.OFF);\n \n-    createDefineReplacements(config.define, options);\n+    createDefineOrTweakReplacements(config.define, options, false);\n+\n+    options.setTweakProcessing(config.tweakProcessing);\n+    createDefineOrTweakReplacements(config.tweak, options, true);\n \n     options.manageClosureDependencies = config.manageClosureDependencies;\n     if (config.closureEntryPoints.size() > 0) {\n    *     single-quoted string without single quotes.\n    */\n   @VisibleForTesting\n-  static void createDefineReplacements(List<String> definitions,\n-      CompilerOptions options) {\n+  static void createDefineOrTweakReplacements(List<String> definitions,\n+      CompilerOptions options, boolean tweaks) {\n     // Parse the definitions\n     for (String override : definitions) {\n       String[] assignment = override.split(\"=\", 2);\n       String defName = assignment[0];\n \n       if (defName.length() > 0) {\n-        if (assignment.length == 1) {\n-          options.setDefineToBooleanLiteral(defName, true);\n+        String defValue = assignment.length == 1 ? \"true\" : assignment[1];\n+\n+        boolean isTrue = defValue.equals(\"true\");\n+        boolean isFalse = defValue.equals(\"false\");\n+        if (isTrue || isFalse) {\n+          if (tweaks) {\n+            options.setTweakToBooleanLiteral(defName, isTrue);\n+          } else {\n+            options.setDefineToBooleanLiteral(defName, isTrue);\n+          }\n           continue;\n+        } else if (defValue.length() > 1\n+            && ((defValue.charAt(0) == '\\'' &&\n+                defValue.charAt(defValue.length() - 1) == '\\'')\n+                || (defValue.charAt(0) == '\\\"' &&\n+                    defValue.charAt(defValue.length() - 1) == '\\\"'))) {\n+          // If the value starts and ends with a single quote,\n+          // we assume that it's a string.\n+          String maybeStringVal =\n+              defValue.substring(1, defValue.length() - 1);\n+          if (maybeStringVal.indexOf(defValue.charAt(0)) == -1) {\n+            if (tweaks) {\n+              options.setTweakToStringLiteral(defName, maybeStringVal);\n+            } else {\n+              options.setDefineToStringLiteral(defName, maybeStringVal);\n+            }\n+            continue;\n+          }\n         } else {\n-          String defValue = assignment[1];\n-\n-          if (defValue.equals(\"true\")) {\n-            options.setDefineToBooleanLiteral(defName, true);\n+          try {\n+            double value = Double.parseDouble(defValue);\n+            if (tweaks) {\n+              options.setTweakToDoubleLiteral(defName, value);\n+            } else {\n+              options.setDefineToDoubleLiteral(defName, value);\n+            }\n             continue;\n-          } else if (defValue.equals(\"false\")) {\n-            options.setDefineToBooleanLiteral(defName, false);\n-            continue;\n-          } else if (defValue.length() > 1\n-              && ((defValue.charAt(0) == '\\'' &&\n-                  defValue.charAt(defValue.length() - 1) == '\\'')\n-                  || (defValue.charAt(0) == '\\\"' &&\n-                      defValue.charAt(defValue.length() - 1) == '\\\"'))) {\n-            // If the value starts and ends with a single quote,\n-            // we assume that it's a string.\n-            String maybeStringVal =\n-                defValue.substring(1, defValue.length() - 1);\n-            if (maybeStringVal.indexOf(defValue.charAt(0)) == -1) {\n-              options.setDefineToStringLiteral(defName, maybeStringVal);\n-              continue;\n-            }\n-          } else {\n-            try {\n-              options.setDefineToDoubleLiteral(defName,\n-                  Double.parseDouble(defValue));\n-              continue;\n-            } catch (NumberFormatException e) {\n-              // do nothing, it will be caught at the end\n-            }\n+          } catch (NumberFormatException e) {\n+            // do nothing, it will be caught at the end\n           }\n         }\n       }\n \n+      if (tweaks) {\n+        throw new RuntimeException(\n+            \"--tweak flag syntax invalid: \" + override);\n+      }\n       throw new RuntimeException(\n           \"--define flag syntax invalid: \" + override);\n     }\n       return this;\n     }\n \n+    private final List<String> tweak = Lists.newArrayList();\n+\n+    /**\n+     * Override the default value of a registered tweak. The format is\n+     * <name>[=<val>], where <name> is the ID of a tweak and <val> is a boolean,\n+     * number, or a single-quoted string that contains no single quotes. If\n+     * [=<val>] is omitted, then true is assumed.\n+     */\n+    CommandLineConfig setTweak(List<String> tweak) {\n+      this.tweak.clear();\n+      this.tweak.addAll(tweak);\n+      return this;\n+    }\n+\n+    private TweakProcessing tweakProcessing = TweakProcessing.OFF;\n+    \n+    /**\n+     * Sets the kind of processing to do for goog.tweak functions.\n+     */\n+    CommandLineConfig setTweakProcessing(TweakProcessing tweakProcessing) {\n+      this.tweakProcessing = tweakProcessing;\n+      return this;\n+    }\n+\n     private String charset = \"\";\n \n     /**\n--- a/src/com/google/javascript/jscomp/DiagnosticGroups.java\n+++ b/src/com/google/javascript/jscomp/DiagnosticGroups.java\n   public static DiagnosticGroup TWEAKS =\n       DiagnosticGroups.registerGroup(\"tweakValidation\",\n           new DiagnosticGroup(\n+              ProcessTweaks.INVALID_TWEAK_DEFAULT_VALUE_WARNING,\n               ProcessTweaks.TWEAK_WRONG_GETTER_TYPE_WARNING,\n               ProcessTweaks.UNKNOWN_TWEAK_WARNING));\n \n--- a/src/com/google/javascript/jscomp/ProcessTweaks.java\n+++ b/src/com/google/javascript/jscomp/ProcessTweaks.java\n           \"JSC_NON_LITERAL_TWEAK_ID_ERROR\",\n           \"tweak ID must be a string literal\");\n   \n-  static final DiagnosticType INVALID_TWEAK_DEFAULT_VALUE_ERROR =\n-      DiagnosticType.error(\n-          \"JSC_INVALID_TWEAK_DEFAULT_VALUE_ERROR\",\n-          \"tweak registered with {0} must have a default value that is a \" +\n-          \"literal of type {0}\");\n+  static final DiagnosticType INVALID_TWEAK_DEFAULT_VALUE_WARNING =\n+      DiagnosticType.warning(\n+          \"JSC_INVALID_TWEAK_DEFAULT_VALUE_WARNING\",\n+          \"tweak {0} registered with {1} must have a default value that is a \" +\n+          \"literal of type {2}\");\n \n   static final DiagnosticType NON_GLOBAL_TWEAK_INIT_ERROR =\n       DiagnosticType.error(\n   static final DiagnosticType TWEAK_WRONG_GETTER_TYPE_WARNING =\n       DiagnosticType.warning(\n           \"JSC_TWEAK_WRONG_GETTER_TYPE_WARNING\",\n-          \"tweak getter function {0} used for tweak registered using {0}\");\n+          \"tweak getter function {0} used for tweak registered using {1}\");\n \n   static final DiagnosticType INVALID_TWEAK_ID_ERROR =\n       DiagnosticType.error(\n       if (tweakInfo == null) {\n         compiler.report(JSError.make(UNKNOWN_TWEAK_WARNING, tweakId));\n       } else {\n-        tweakInfo.defaultValueNode = entry.getValue();\n+        TweakFunction registerFunc = tweakInfo.registerCall.tweakFunc;\n+        Node value = entry.getValue();\n+        if (!registerFunc.isValidNodeType(value.getType())) {\n+          compiler.report(JSError.make(INVALID_TWEAK_DEFAULT_VALUE_WARNING,\n+              tweakId, registerFunc.getName(),\n+              registerFunc.getExpectedTypeName()));\n+        } else {\n+          tweakInfo.defaultValueNode = value;\n+        }\n       }\n     }\n   }\n           // value is a literal of the correct type.\n           if (!registerFunc.isValidNodeType(valueNode.getType())) {\n             compiler.report(JSError.make(call.sourceName,\n-                valueNode, INVALID_TWEAK_DEFAULT_VALUE_ERROR,\n-                registerFunc.getName(),\n+                valueNode, INVALID_TWEAK_DEFAULT_VALUE_WARNING,\n+                tweakId, registerFunc.getName(),\n                 registerFunc.getExpectedTypeName()));\n           }\n         } else if (tweakFunc.isGetterFunction()) {\n--- a/test/com/google/javascript/jscomp/ProcessTweaksTest.java\n+++ b/test/com/google/javascript/jscomp/ProcessTweaksTest.java\n import com.google.javascript.rhino.Node;\n import com.google.javascript.rhino.Token;\n \n+import java.util.Collections;\n import java.util.Map;\n+import java.util.Set;\n \n /**\n  * @author agrieve@google.com (Andrew Grieve)\n   }\n \n   @Override\n-  protected CompilerPass getProcessor(Compiler compiler) {\n-    return new ProcessTweaks(compiler, stripTweaks, defaultValueOverrides);\n+  protected CompilerPass getProcessor(final Compiler compiler) {\n+    return new CompilerPass() {     \n+      @Override\n+      public void process(Node externs, Node root) {\n+        ProcessTweaks processTweak =\n+            new ProcessTweaks(compiler, stripTweaks, defaultValueOverrides);\n+        processTweak.process(externs, root);\n+        \n+        if (stripTweaks) {\n+          Set<String> emptySet = Collections.emptySet();\n+          final StripCode stripCode = new StripCode(compiler, emptySet,\n+              emptySet, emptySet, emptySet);\n+          stripCode.enableTweakStripping();\n+          stripCode.process(externs, root);\n+        }\n+      }\n+    };\n   }\n \n   @Override\n   }\n   \n   public void testInvalidDefaultValue1() {\n-    test(\"var val = true; goog.tweak.registerBoolean('Foo', 'desc', val)\", null,\n-         ProcessTweaks.INVALID_TWEAK_DEFAULT_VALUE_ERROR);\n+    testSame(\"var val = true; goog.tweak.registerBoolean('Foo', 'desc', val)\",\n+         ProcessTweaks.INVALID_TWEAK_DEFAULT_VALUE_WARNING);\n   }\n   \n   public void testInvalidDefaultValue2() {\n-    test(\"goog.tweak.overrideDefaultValue('Foo', 3 + 1);\" +\n-        \"goog.tweak.registerNumber('Foo', 'desc')\", null,\n-        ProcessTweaks.INVALID_TWEAK_DEFAULT_VALUE_ERROR);\n+    testSame(\"goog.tweak.overrideDefaultValue('Foo', 3 + 1);\" +\n+        \"goog.tweak.registerNumber('Foo', 'desc')\",\n+        ProcessTweaks.INVALID_TWEAK_DEFAULT_VALUE_WARNING);\n   }\n \n   public void testUnknownGetString() {\n         \"alert('')\", null, ProcessTweaks.UNKNOWN_TWEAK_WARNING);\n   }\n   \n+  public void testStrippingOfManuallyRegistered1() {\n+    stripTweaks = true;\n+    test(\"var reg = goog.tweak.getRegistry();\" +\n+         \"if (reg) {\" +\n+         \"  reg.register(new goog.tweak.BooleanSetting('foo', 'desc'));\" +\n+         \"  reg.getEntry('foo').setDefaultValue(1);\" +\n+         \"}\",\n+         \"if (null);\");\n+  }\n+\n   public void testOverridesWithStripping() {\n     stripTweaks = true;\n     defaultValueOverrides.put(\"TweakA\", Node.newNumber(1));\n     defaultValueOverrides.put(\"TweakA\", Node.newString(\"!\"));\n     testSame(\"var a\", ProcessTweaks.UNKNOWN_TWEAK_WARNING); \n   }\n+\n+  public void testCompilerOverrideWithWrongType() {\n+    allowSourcelessWarnings();\n+    defaultValueOverrides.put(\"TweakA\", Node.newString(\"!\"));\n+    testSame(\"goog.tweak.registerBoolean('TweakA', 'desc')\",\n+        ProcessTweaks.INVALID_TWEAK_DEFAULT_VALUE_WARNING); \n+  }\n }", "timestamp": 1294945639, "metainfo": ""}