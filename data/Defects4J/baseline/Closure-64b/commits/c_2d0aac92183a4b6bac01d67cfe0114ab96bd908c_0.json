{"sha": "2d0aac92183a4b6bac01d67cfe0114ab96bd908c", "log": "Fixes Issue 3424764  R=acleung DELTA=74  (59 added, 1 deleted, 14 changed)   Revision created by MOE tool push_codebase. MOE_MIGRATION=520   ", "commit": "\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n \n   private static final int AND_PRECEDENCE = NodeUtil.precedence(Token.AND);\n   private static final int OR_PRECEDENCE = NodeUtil.precedence(Token.OR);\n+  private static final int NOT_PRECEDENCE = NodeUtil.precedence(Token.NOT);\n \n   static final DiagnosticType INVALID_REGULAR_EXPRESSION_FLAGS =\n     DiagnosticType.error(\n   }\n \n   /**\n+   * Whether the node type has lower precedence than \"precedence\"\n+   */\n+  private boolean isLowerPrecedence(Node n, final int precedence) {\n+    return NodeUtil.precedence(n.getType()) < precedence;\n+  }\n+\n+  /**\n+   * Whether the node type has higher precedence than \"precedence\"\n+   */\n+  private boolean isHigherPrecedence(Node n, final int precedence) {\n+    return NodeUtil.precedence(n.getType()) > precedence;\n+  }\n+  /**\n    * Does the expression contain a property assignment?\n    */\n   private boolean isPropertyAssignmentInExpression(Node n) {\n             }\n           case Token.AND:\n           case Token.OR: {\n+              // !(!x && !y) --> x || y\n+              // !(!x || !y) --> x && y\n+              // !(!x && y) --> x || !y\n+              // !(!x || y) --> x && !y\n+              // !(x && !y) --> !x || y\n+              // !(x || !y) --> !x && y\n+              // !(x && y) --> !x || !y\n+              // !(x || y) --> !x && !y\n               Node leftParent = first.getFirstChild();\n               Node rightParent = first.getLastChild();\n-              if (leftParent.getType() == Token.NOT\n-                  && rightParent.getType() == Token.NOT) {\n-                Node left = leftParent.removeFirstChild();\n-                Node right = rightParent.removeFirstChild();\n-\n-                int newOp = (first.getType() == Token.AND) ? Token.OR : Token.AND;\n-                Node newRoot = new Node(newOp, left, right);\n-                parent.replaceChild(n, newRoot);\n-                reportCodeChange();\n-                // No need to traverse, tryMinimizeCondition is called on the\n-                // AND and OR children below.\n-                return newRoot;\n+              Node left, right;\n+\n+              // Check special case when such transformation cannot reduce\n+              // due to the added ()\n+              // It only occurs when both of expressions are not NOT expressions\n+              if (leftParent.getType() != Token.NOT\n+                  && rightParent.getType() != Token.NOT) {\n+                // If an expression has higher precendence than && or ||,\n+                // but lower precedence than NOT, an additional () is needed\n+                // Thus we do not preceed\n+                int op_precedence = NodeUtil.precedence(first.getType());\n+                if ((isLowerPrecedence(leftParent, NOT_PRECEDENCE)\n+                    && isHigherPrecedence(leftParent, op_precedence))\n+                    || (isLowerPrecedence(rightParent, NOT_PRECEDENCE)\n+                    && isHigherPrecedence(rightParent, op_precedence))) {\n+                  return n;\n+                }\n               }\n+\n+              if (leftParent.getType() == Token.NOT) {\n+                left = leftParent.removeFirstChild();\n+              } else {\n+                leftParent.detachFromParent();\n+                left = new Node(Token.NOT, leftParent)\n+                  .copyInformationFrom(leftParent);\n+              }\n+              if (rightParent.getType() == Token.NOT) {\n+                right = rightParent.removeFirstChild();\n+              } else {\n+                rightParent.detachFromParent();\n+                right = new Node(Token.NOT, rightParent)\n+                  .copyInformationFrom(rightParent);\n+              }\n+\n+              int newOp = (first.getType() == Token.AND) ? Token.OR : Token.AND;\n+              Node newRoot = new Node(newOp, left, right);\n+              parent.replaceChild(n, newRoot);\n+              reportCodeChange();\n+              // No need to traverse, tryMinimizeCondition is called on the\n+              // AND and OR children below.\n+              return newRoot;\n             }\n-            break;\n \n            default:\n              TernaryValue nVal = NodeUtil.getBooleanValue(first);\n--- a/test/com/google/javascript/jscomp/PeepholeIntegrationTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeIntegrationTest.java\n     fold(\"x()||!!y()\", \"x()||y()\");\n \n     /* This is similar to the !!true case */\n-    fold(\"!(!!x()&&y())\", \"x()&&y()\");\n+    fold(\"!!x()&&y()\", \"x()&&y()\");\n   }\n \n   public void testBug1509085() {\n--- a/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n+++ b/test/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntaxTest.java\n     fold(\"while(!!x) foo()\", \"while(x) foo()\");\n     fold(\"while(!(!x&&!y)) foo()\", \"while(x||y) foo()\");\n     fold(\"while(x||!!y) foo()\", \"while(x||y) foo()\");\n-    fold(\"while(!(!!x&&y)) foo()\", \"while(!(x&&y)) foo()\");\n+    fold(\"while(!(!!x&&y)) foo()\", \"while(!x||!y) foo()\");\n+    fold(\"while(!(!x&&y)) foo()\", \"while(x||!y) foo()\");\n+    fold(\"while(!(x||!y)) foo()\", \"while(!x&&y) foo()\");\n+    fold(\"while(!(x||y)) foo()\", \"while(!x&&!y) foo()\");\n+    fold(\"while(!(!x||y-z)) foo()\", \"while(x&&!(y-z)) foo()\");\n+    fold(\"while(!(!(x/y)||z+w)) foo()\", \"while(x/y&&!(z+w)) foo()\");\n+    foldSame(\"while(!(x+y||z)) foo()\");\n+    foldSame(\"while(!(x&&y*z)) foo()\");\n+    fold(\"while(!(!!x&&y)) foo()\", \"while(!x||!y) foo()\");\n     fold(\"while(x&&!0) foo()\", \"while(x) foo()\");\n     fold(\"while(x||!1) foo()\", \"while(x) foo()\");\n+    fold(\"while(!((x,y)&&z)) foo()\", \"while(!(x,y)||!z) foo()\");\n   }\n \n   public void testMinimizeForCondition() {", "timestamp": 1297720460, "metainfo": ""}