{"sha": "8ba5e1f86eaf3c31b9279f92823b4fa2a50574a3", "log": "Print indirect calls to eval correctly (issue 81)    ", "commit": "\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n       }\n \n       case Token.CALL:\n-        addLeftExpr(first, NodeUtil.precedence(type), context);\n+        // If the left hand side of the call is a direct reference to eval,\n+        // then it must have a DIRECT_EVAL annotation. If it does not, then\n+        // that means it was originally an indirect call to eval, and that\n+        // indirectness must be preserved.\n+        if (first.getType() == Token.NAME &&\n+            \"eval\".equals(first.getString()) &&\n+            !first.getBooleanProp(Node.DIRECT_EVAL)) {\n+          add(\"(0,eval)\");\n+        } else {\n+          addLeftExpr(first, NodeUtil.precedence(type), context);\n+        }\n         add(\"(\");\n         addList(first.getNext());\n         add(\")\");\n--- a/src/com/google/javascript/jscomp/CodingConventionAnnotator.java\n+++ b/src/com/google/javascript/jscomp/CodingConventionAnnotator.java\n  *\n *\n  */\n+// TODO(nicksantos): This pass should really be merged together with\n+// NodeTypeNormalizer. They really do one task: they fill in information\n+// on the AST that we expect to be there.\n class CodingConventionAnnotator extends NodeTraversal.AbstractPostOrderCallback\n     implements CompilerPass {\n \n \n   @Override\n   public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch (n.getType()) {\n+    int nType = n.getType();\n+    switch (nType) {\n       case Token.NAME:\n       case Token.STRING:\n-        if (convention.isConstant(n.getString())) {\n+        String nString = n.getString();\n+        if (nType == Token.NAME &&\n+            n.getParent().getType() == Token.CALL &&\n+            \"eval\".equals(nString)) {\n+          n.putBooleanProp(Node.DIRECT_EVAL, true);\n+        }\n+        if (convention.isConstant(nString)) {\n           n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n         }\n         break;\n--- a/src/com/google/javascript/rhino/Node.java\n+++ b/src/com/google/javascript/rhino/Node.java\n                                     // should be resolved to the proper\n                                     // overload if possible.\n         DIRECTIVES         = 48,    // The ES5 directives on this node.\n-        LAST_PROP          = 48;\n+        DIRECT_EVAL        = 49,    // ES5 distinguishes between direct and\n+                                    // indirect calls to eval.\n+        LAST_PROP          = 49;\n \n     // values of ISNUMBER_PROP to specify\n     // which of the children are Number types\n             case IS_NAMESPACE:       return \"is_namespace\";\n             case IS_DISPATCHER:      return \"is_dispatcher\";\n             case DIRECTIVES:         return \"directives\";\n+            case DIRECT_EVAL:        return \"direct_eval\";\n             default:\n               Kit.codeBug();\n \n--- a/test/com/google/javascript/jscomp/CodePrinterTest.java\n+++ b/test/com/google/javascript/jscomp/CodePrinterTest.java\n     \n     assertPrint(\"0.000001\", \"1.0E-6\");\n   }\n+\n+  public void testDirectEval() {\n+    assertPrint(\"eval('1');\", \"eval(\\\"1\\\")\");\n+  }\n+\n+  public void testIndirectEval() {\n+    Node n = parse(\"eval('1');\");\n+    assertPrintNode(\"eval(\\\"1\\\")\", n);\n+    n.getFirstChild().getFirstChild().getFirstChild().putBooleanProp(\n+        Node.DIRECT_EVAL, false);\n+    assertPrintNode(\"(0,eval)(\\\"1\\\")\", n);\n+  }\n }\n--- a/test/com/google/javascript/jscomp/CompilerRunnerTest.java\n+++ b/test/com/google/javascript/jscomp/CompilerRunnerTest.java\n \n   private Compiler lastCompiler = null;\n \n+  // If set to true, uses comparison by string instead of by AST.\n+  private boolean useStringComparison = false;\n+\n   /** Externs for the test */\n   private final JSSourceFile[] externs = new JSSourceFile[] {\n     JSSourceFile.fromCode(\"externs\",\n     Flags.disableStateCheckingForTest();\n     Flags.resetAllFlagsForTest();\n     lastCompiler = null;\n+    useStringComparison = false;\n   }\n \n   @Override\n \n   public void testIssue70() {\n     test(\"function foo({}) {}\", RhinoErrorReporter.PARSE_ERROR);\n+  }\n+\n+  public void testIssue81() {\n+    CompilerRunner.FLAG_compilation_level.setForTest(\n+        CompilationLevel.ADVANCED_OPTIMIZATIONS);\n+    useStringComparison = true;\n+    test(\"eval('1'); var x = eval; x('2');\",\n+         \"eval(\\\"1\\\");(0,eval)(\\\"2\\\");\");\n   }\n \n   public void testDebugFlag1() {\n         0, compiler.getErrors().length + compiler.getWarnings().length);\n \n     Node root = compiler.getRoot().getLastChild();\n-    Node expectedRoot = parse(compiled);\n-    String explanation = expectedRoot.checkTreeEquals(root);\n-    assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n-        \"\\nResult: \" + compiler.toSource(root) +\n-        \"\\n\" + explanation, explanation);\n+    if (useStringComparison) {\n+      assertEquals(Joiner.on(\"\").join(compiled), compiler.toSource());\n+    } else {\n+      Node expectedRoot = parse(compiled);\n+      String explanation = expectedRoot.checkTreeEquals(root);\n+      assertNull(\"\\nExpected: \" + compiler.toSource(expectedRoot) +\n+          \"\\nResult: \" + compiler.toSource(root) +\n+          \"\\n\" + explanation, explanation);\n+    }\n   }\n \n   /**", "timestamp": 1264641760, "metainfo": ""}