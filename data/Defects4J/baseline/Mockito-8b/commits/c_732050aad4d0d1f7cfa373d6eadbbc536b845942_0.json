{"sha": "732050aad4d0d1f7cfa373d6eadbbc536b845942", "log": "The settings now offer two additional options: \"invocation listener\" and \"verbose logging\". An invocation listener can be added, which is notified of method calls to a mock. Verbose logging dumps all interactions with a mock in real-time. Currently, only the method and its arguments are output.  --HG-- branch : issue148 extra : transplant_source : 3C%13-%09%897%3A%C8%BEe%FEy%C0%2B%0D%EDH6%2C", "commit": "\n--- a/src/org/mockito/MockSettings.java\n+++ b/src/org/mockito/MockSettings.java\n \n import java.io.Serializable;\n \n+import org.mockito.invocation.InvocationListener;\n import org.mockito.stubbing.Answer;\n \n /**\n      * Sets the real implementation to be called when the method is called on a mock object.\n      * <p>\n      * As usual you are going to read <b>the partial mock warning</b>:\n-     * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n+     * Object oriented programming is more or less about tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n      * How does partial mock fit into this paradigm? Well, it just doesn't... \n      * Partial mock usually means that the complexity has been moved to a different method on the same object.\n      * In most cases, this is not the way you want to design your application.\n      * @return settings instance so that you can fluently specify other settings\n      */\n     MockSettings serializable();\n+    \n+    /**\n+     * Enables real-time logging of method invocations on this mock. Can be used\n+     * during test debugging in order to find wrong interactions with this mock.\n+     * <p>\n+     * Invocations are logged as they happen to the standard output stream.\n+     * <p>\n+     * Calling this method multiple times makes no difference.\n+     * <p>\n+     * Example:\n+     * <pre>\n+     * List mockWithLogger = mock(List.class, withSettings().verboseLogging());\n+     * </pre>\n+     * \n+     * @return settings instance so that you can fluently specify other settings\n+     */\n+    MockSettings verboseLogging();\n+    \n+    /**\n+     * Registers a listener for method invocations on this mock. The listener is\n+     * notified every time a method on this mock is called.\n+     * <p>\n+     * Multiple listeners may be added, but the same object is only added once.\n+     * The order, in which the listeners are notified, is not guaranteed. \n+     * \n+     * Example:\n+     * <pre>\n+     *  List mockWithListener = mock(List.class, withSettings().callback(new YourInvocationListener()));\n+     * </pre>\n+     * \n+     * See the listeners {@link InvocationListener interface} for more details.\n+     * \n+     * @param The invocation listener to add as callback. May not be null.\n+     * @return settings instance so that you can fluently specify other settings\n+     */\n+    MockSettings callback(InvocationListener listener);\n }\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n import org.mockito.internal.exceptions.VerificationAwareInvocation;\n import org.mockito.internal.exceptions.util.ScenarioPrinter;\n import org.mockito.internal.invocation.Invocation;\n+import org.mockito.invocation.InvocationListener;\n \n import java.lang.reflect.Field;\n import java.util.List;\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.internal;\n+\n+import java.util.List;\n \n import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.MatchersBinder;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.ThreadSafeMockingProgress;\n-import org.mockito.internal.stubbing.*;\n+import org.mockito.internal.stubbing.InvocationContainer;\n+import org.mockito.internal.stubbing.InvocationContainerImpl;\n+import org.mockito.internal.stubbing.OngoingStubbingImpl;\n+import org.mockito.internal.stubbing.StubbedInvocationMatcher;\n+import org.mockito.internal.stubbing.VoidMethodStubbableImpl;\n import org.mockito.internal.verification.MockAwareVerificationMode;\n import org.mockito.internal.verification.VerificationDataImpl;\n+import org.mockito.invocation.InvocationListener;\n import org.mockito.stubbing.Answer;\n import org.mockito.stubbing.VoidMethodStubbable;\n import org.mockito.verification.VerificationMode;\n-\n-import java.util.List;\n \n /**\n  * Invocation handler set on mock objects.\n     }\n \n     public Object handle(Invocation invocation) throws Throwable {\n+    \tnotifyInvocationListener(invocation);\n+    \t\n         if (invocationContainerImpl.hasAnswersForStubbing()) {\n             // stubbing voids with stubVoid() or doAnswer() style\n             InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n     public InvocationContainer getInvocationContainer() {\n         return invocationContainerImpl;\n     }\n+    \n+\tprivate void notifyInvocationListener(Invocation invocation) {\n+\t\tfor (InvocationListener listener : mockSettings.getInvocationListener()) {\n+    \t\tlistener.invoking(invocation);\n+    \t}\n+\t}\n }\n--- a/src/org/mockito/internal/creation/MockSettingsImpl.java\n+++ b/src/org/mockito/internal/creation/MockSettingsImpl.java\n  */\n package org.mockito.internal.creation;\n \n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n import org.mockito.MockSettings;\n import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.debugging.LogInvocationsToStdOutListener;\n import org.mockito.internal.util.MockName;\n+import org.mockito.invocation.InvocationListener;\n import org.mockito.stubbing.Answer;\n \n @SuppressWarnings(\"unchecked\")\n     private Answer<Object> defaultAnswer;\n     private MockName mockName;\n     private boolean serializable;\n+    private Set<InvocationListener> invocationListener = new HashSet<InvocationListener>();\n \n     public MockSettings serializable() {\n         this.serializable = true;\n     public void initiateMockName(Class classToMock) {\n         mockName = new MockName(name, classToMock);\n     }\n-}\n+\n+\tpublic MockSettings verboseLogging() {\n+\t\tif (doesNotHaveListenerOfClass(LogInvocationsToStdOutListener.class)) {\n+\t\t\tcallback(new LogInvocationsToStdOutListener());\n+\t\t}\n+\t\treturn this;\n+\t}\n+\n+\tpublic MockSettings callback(InvocationListener listener) {\n+\t\tvalidateListener(listener);\n+\t\tthis.invocationListener.add(listener);\n+\t\treturn this;\n+\t}\n+\n+\t/** Returns the registered invocation listener, never {@code null} */\n+\tpublic Collection<InvocationListener> getInvocationListener() {\n+\t\treturn this.invocationListener;\n+\t}\n+\t\n+\tprivate boolean doesNotHaveListenerOfClass(Class<?> clazz) {\n+\t\tfor (InvocationListener listener : invocationListener) {\n+\t\t\tif (listener.getClass().equals(clazz)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n+\t}\n+\t\n+\tprivate void validateListener(InvocationListener listener) {\n+\t\tif (listener == null) {\n+\t\t\tnew Reporter().nullInvocationListenerAdded();\n+\t\t}\n+\t}\n+}\n+\n--- /dev/null\n+++ b/src/org/mockito/internal/debugging/LogInvocationsToStdOutListener.java\n+package org.mockito.internal.debugging;\n+\n+import java.io.PrintStream;\n+\n+import org.mockito.invocation.InvocationListener;\n+import org.mockito.invocation.InvocationOnMock;\n+\n+/**\n+ * Logs all invocations to standard output.\n+ * \n+ * Used for debugging interactions with a mock. \n+ */\n+public class LogInvocationsToStdOutListener implements InvocationListener {\n+\n+\tPrintStream printStream = System.out;\n+\t\n+\tpublic void invoking(InvocationOnMock invocation) {\n+\t\tprintStream.println(invocation.toString());\n+\t}\n+}\n--- /dev/null\n+++ b/src/org/mockito/invocation/InvocationListener.java\n+/*\n+ * Copyright (c) 2011 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.invocation;\n+\n+import org.mockito.MockSettings;\n+\n+/**\n+ * This listener can be notified of method invocations on a mock.\n+ * \n+ * For this to happen, it must be registered using {@link MockSettings#callback(InvocationListener)}.\n+ */\n+public interface InvocationListener {\n+\t\n+\t/**\n+\t * Called when a method on the listener's mock is invoked.\n+\t * \n+\t * Exceptions during this callback are treated as fatal errors. \n+\t * \n+\t * @param invocation information on the happening method call, never {@code null}.\n+\t * @throws RuntimeException on fatal errors\n+\t */\n+\tvoid invoking(InvocationOnMock invocation);\n+}\n--- a/test/org/mockito/exceptions/ReporterTest.java\n+++ b/test/org/mockito/exceptions/ReporterTest.java\n package org.mockito.exceptions;\n \n import org.junit.Test;\n+import org.mockito.exceptions.base.MockitoException;\n import org.mockito.exceptions.verification.TooLittleActualInvocations;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockitoutil.TestBase;\n     public void shouldLetPassingNullLastActualStackTrace() throws Exception {\n         new Reporter().tooLittleActualInvocations(new Discrepancy(1, 2), new InvocationBuilder().toInvocation(), null);\n     }\n+    \n+    @Test(expected=MockitoException.class)\n+    public void shouldThrowCorrectExceptionForNullInvocationListener() throws Exception {\n+    \tnew Reporter().nullInvocationListenerAdded();\n+    }\n }\n--- a/test/org/mockito/internal/MockHandlerTest.java\n+++ b/test/org/mockito/internal/MockHandlerTest.java\n  */\n package org.mockito.internal;\n \n-import org.junit.Test;\n-import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n+import static org.mockito.BDDMockito.*;\n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.*;\n+\n+import java.util.*;\n+\n+import org.junit.*;\n+import org.mockito.*;\n+import org.mockito.exceptions.misusing.*;\n+import org.mockito.internal.creation.*;\n import org.mockito.internal.invocation.*;\n-import org.mockito.internal.progress.ArgumentMatcherStorage;\n-import org.mockito.internal.verification.VerificationModeFactory;\n-import org.mockitoutil.TestBase;\n+import org.mockito.internal.progress.*;\n+import org.mockito.internal.stubbing.*;\n+import org.mockito.internal.stubbing.answers.*;\n+import org.mockito.internal.verification.*;\n+import org.mockito.invocation.*;\n+import org.mockito.stubbing.*;\n+import org.mockito.verification.*;\n+import org.mockitoutil.*;\n @SuppressWarnings({\"unchecked\",\"serial\"})\n public class MockHandlerTest extends TestBase {\n     \n-    @Test\n+\tprivate static final Answer SOME_ANSWER = mock(Answer.class);\n+\tprivate static final StubbedInvocationMatcher SOME_RETURN_VALUE = mock(StubbedInvocationMatcher.class);\n+\tprivate static final Invocation SOME_INVOCATION = mock(Invocation.class);\n+\t@Mock private InvocationListener listener1;\n+\t@Mock private InvocationListener listener2;\n+\n+\t@Test\n     public void shouldRemoveVerificationModeEvenWhenInvalidMatchers() throws Throwable {\n         //given\n         Invocation invocation = new InvocationBuilder().toInvocation();\n         \n         assertNull(handler.mockingProgress.pullVerificationMode());\n     }\n+    \n+    @Test\n+    public void shouldNotifyInvocationHandlerDuringStubVoid() throws Throwable {\n+    \t// given\n+    \tMockHandler handler = createHandlerWithListeners(listener1, listener2);\n+    \tstubWithInvocationDuringStubVoid(handler);\n+    \t\n+    \t\n+    \thandler.handle(SOME_INVOCATION);\n+    \t\n+    \t// then\n+    \tverify(listener1).invoking(SOME_INVOCATION);\n+    \tverify(listener2).invoking(SOME_INVOCATION);\n+    }\n+\n+\t@Test\n+    public void shouldNotifyInvocationHandlerDuringVerification() throws Throwable {\n+    \t// given\n+    \tMockHandler<?> handler = createHandlerWithListeners(listener1, listener2);\n+    \tstubProgressWithVerification(handler);\n+    \t\n+    \t// when\n+\t\thandler.handle(SOME_INVOCATION);\n+    \t\n+    \t// then\n+    \tverify(listener1).invoking(SOME_INVOCATION);\n+    \tverify(listener2).invoking(SOME_INVOCATION);\n+    }\n+    \n+\t@Test\n+    public void shouldNotifyInvocationHandlerDuringOrdinaryInvocationWithGivenReturnValue() throws Throwable {\n+    \t// given\n+    \tMockHandler<?> handler = createHandlerWithListeners(listener1, listener2);\n+    \tstubOrdinaryInvocationWithGivenReturnValue(handler);\n+    \t\n+    \t// when\n+\t\thandler.handle(SOME_INVOCATION);\n+    \t\n+    \t// then\n+    \tverify(listener1).invoking(SOME_INVOCATION);\n+    \tverify(listener2).invoking(SOME_INVOCATION);\n+    }\n+\n+\t@Test\n+\tpublic void shouldNotifyInvocationHandlerDuringOrdinaryInvocationWithDefaultReturnValue() throws Throwable {\n+\t\t// given\n+\t\tMockHandler<?> handler = createHandlerWithListeners(listener1, listener2);\n+\t\tstubOrdinaryInvocationWithDefaultReturnValue(handler);\n+\t\t\n+\t\t// when\n+\t\thandler.handle(SOME_INVOCATION);\n+\t\t\n+\t\t// then\n+\t\tverify(listener1).invoking(SOME_INVOCATION);\n+\t\tverify(listener2).invoking(SOME_INVOCATION);\n+\t}\n+\t\n+\tprivate void stubOrdinaryInvocationWithGivenReturnValue(MockHandler<?> handler) {\n+\t\tstubOrdinaryInvocationWithReturnValue(handler, SOME_RETURN_VALUE);\n+\t}\n+\t\n+\tprivate void stubOrdinaryInvocationWithDefaultReturnValue(MockHandler<?> handler) {\n+\t\tgiven(handler.getMockSettings().getDefaultAnswer()).willReturn(SOME_ANSWER);\n+\t\tstubOrdinaryInvocationWithReturnValue(handler, null);\n+\t}\n+\n+\tprivate void stubOrdinaryInvocationWithReturnValue(MockHandler<?> handler,\n+\t\t\tStubbedInvocationMatcher value) {\n+\t\thandler.invocationContainerImpl = mock(InvocationContainerImpl.class);\n+\t\tgiven(handler.invocationContainerImpl.findAnswerFor(any(Invocation.class))).willReturn(value);\n+\t}\n+\t\n+    private void stubProgressWithVerification(MockHandler<?> handler) {\n+    \thandler.mockingProgress = mock(MockingProgress.class);\n+\n+    \t// Needs to be unequal to null.\n+    \tVerificationMode mode = mock(MockAwareVerificationMode.class);\n+    \tgiven(handler.mockingProgress.pullVerificationMode()).willReturn(mode);\n+\t}\n+\n+    @SuppressWarnings(\"rawtypes\") \n+\tprivate void stubWithInvocationDuringStubVoid(MockHandler handler) {\n+\t\tstubWithPreviouslySetVoidAnswer(handler);\n+    \tstubHandlerStateWithPreviousStubVoidInvocation(handler);\n+\t}\n+\n+\tprivate void stubHandlerStateWithPreviousStubVoidInvocation(MockHandler handler) {\n+\t\tStubbedInvocationMatcher invocationContainer = mock(StubbedInvocationMatcher.class);\n+\t\tgiven(handler.matchersBinder.bindMatchers(any(ArgumentMatcherStorage.class), any(Invocation.class))).willReturn(invocationContainer);\n+\t\t\n+\t\tInvocation invocation = mock(Invocation.class);\n+\t\tgiven(invocationContainer.getInvocation()).willReturn(invocation);\n+\t\t\n+\t\tgiven(invocation.isVoid()).willReturn(true);\n+\t}\n+\n+\tprivate void stubWithPreviouslySetVoidAnswer(MockHandler handler) {\n+\t\tList<Answer<?>> answers = new ArrayList<Answer<?>>();\n+    \tanswers.add(new DoesNothing());\n+    \thandler.setAnswersForStubbing(answers);\n+\t}\n+    \n+\tprivate MockHandler<?> createHandlerWithListeners(InvocationListener... listener) {\n+\t\t@SuppressWarnings(\"rawtypes\")\n+\t\tMockHandler<?> handler = new MockHandler(mock(MockSettingsImpl.class));\n+\t\thandler.matchersBinder = mock(MatchersBinder.class);\n+\t\tgiven(handler.getMockSettings().getInvocationListener()).willReturn(Arrays.asList(listener));\n+\t\treturn handler;\n+\t}\n }\n--- a/test/org/mockito/internal/creation/MockSettingsImplTest.java\n+++ b/test/org/mockito/internal/creation/MockSettingsImplTest.java\n  */\n package org.mockito.internal.creation;\n \n-import org.junit.Test;\n-import org.mockito.exceptions.base.MockitoException;\n-import org.mockitoutil.TestBase;\n+import static org.mockito.Mockito.mock;\n \n import java.util.LinkedList;\n import java.util.List;\n import java.util.Set;\n \n+import org.junit.Test;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.debugging.LogInvocationsToStdOutListener;\n+import org.mockito.invocation.InvocationListener;\n+import org.mockitoutil.TestBase;\n+\n public class MockSettingsImplTest extends TestBase {\n \n     private MockSettingsImpl mockSettingsImpl = new MockSettingsImpl();\n+    \n+    private static final InvocationListener SOME_LISTENER = mock(InvocationListener.class);\n \n     @Test(expected=MockitoException.class)\n     public void shouldNotAllowSettingNullInterface() {\n         //then\n         assertTrue(mockSettingsImpl.isSerializable());\n     }\n+    \n+    @Test\n+    public void shouldAddVerboseLoggingListener() {\n+        //given\n+        assertTrue(mockSettingsImpl.getInvocationListener().isEmpty());\n+\n+        //when\n+        mockSettingsImpl.verboseLogging();\n+\n+        //then\n+        assertEquals(1, mockSettingsImpl.getInvocationListener().size());\n+        assertTrue(getListener(mockSettingsImpl) instanceof LogInvocationsToStdOutListener);\n+    }\n+\n+    @Test\n+    public void shouldAddVerboseLoggingListenerOnlyOnce() {\n+    \t//given\n+    \tassertTrue(mockSettingsImpl.getInvocationListener().isEmpty());\n+    \t\n+    \t//when\n+    \tmockSettingsImpl.verboseLogging().verboseLogging();\n+    \t\n+    \t//then\n+    \tassertEquals(1, mockSettingsImpl.getInvocationListener().size());\n+    }\n+    \n+    @Test(expected=MockitoException.class)\n+    public void shouldNotAllowNullListener() {\n+    \tmockSettingsImpl.callback(null);\n+    }\n+\n+    @Test\n+    public void shouldAddInvocationListener() {\n+    \t//given\n+    \tassertTrue(mockSettingsImpl.getInvocationListener().isEmpty());\n+    \t\n+    \t//when\n+    \tmockSettingsImpl.callback(SOME_LISTENER);\n+    \t\n+    \t//then\n+    \tassertEquals(1, mockSettingsImpl.getInvocationListener().size());\n+    \tassertSame(SOME_LISTENER, getListener(mockSettingsImpl));\n+    }\n+    \n+    @Test\n+    public void shouldAddInvocationListenerOnlyOnce() {\n+    \t//given\n+    \tassertTrue(mockSettingsImpl.getInvocationListener().isEmpty());\n+    \t\n+    \t//when\n+    \tmockSettingsImpl.callback(SOME_LISTENER).callback(SOME_LISTENER);\n+    \t\n+    \t//then\n+    \tassertEquals(1, mockSettingsImpl.getInvocationListener().size());\n+    }\n+    \n+    private InvocationListener getListener(MockSettingsImpl settings) {\n+    \treturn settings.getInvocationListener().iterator().next();\n+    }\n+    \n }\n--- /dev/null\n+++ b/test/org/mockito/internal/debugging/LogInvocationsToStdOutListenerTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.debugging;\n+\n+import static org.mockito.Mockito.*;\n+\n+import java.io.*;\n+\n+import org.junit.*;\n+import org.mockito.invocation.*;\n+import org.mockitoutil.*;\n+\n+public class LogInvocationsToStdOutListenerTest extends TestBase {\n+\n+    private static final InvocationOnMock SOME_INVOCATION = mock(InvocationOnMock.class);\n+\n+\t@Test\n+    public void presetStreamIsStdOut() {\n+    \tassertSame(System.out, new LogInvocationsToStdOutListener().printStream);\n+    }\n+    \n+\t@Test\n+\tpublic void shouldPrintInvocationToStream() {\n+\t\t//given\n+\t\tLogInvocationsToStdOutListener listener = new LogInvocationsToStdOutListener();\n+\t\tlistener.printStream = mock(PrintStream.class);\n+\t\t\n+\t\t//when\n+\t\tlistener.invoking(SOME_INVOCATION);\n+\t\n+\t    //then\n+\t\tverify(listener.printStream).println(SOME_INVOCATION.toString());\n+\t}\n+    \n+    \n+}\n--- /dev/null\n+++ b/test/org/mockitousage/debugging/InvocationListenerCallbackTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.debugging;\n+\n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.*;\n+import org.mockito.*;\n+import org.mockito.internal.invocation.*;\n+import org.mockito.invocation.*;\n+import org.mockitoutil.*;\n+\n+/**\n+ * Ensures that custom listeners can be registered and will be called every\n+ * time a method on a mock is invoked.\n+ */\n+public class InvocationListenerCallbackTest extends TestBase {\n+\n+    private static final String SOME_STRING_ARGUMENT = \"some string argument\";\n+\n+\t@Test\n+    public void shouldCallListenerWithCorrectCallback() throws Exception {\n+    \t// given\n+    \tInvocationListener listener = mock(InvocationListener.class);\n+\t\tFoo foo = mock(Foo.class, withSettings().callback(listener));\n+    \t\n+    \t// when\n+\t\tfoo.doSomething(SOME_STRING_ARGUMENT);\n+    \t\n+    \t// then\n+\t\tArgumentCaptor<InvocationOnMock> captor = ArgumentCaptor.forClass(InvocationOnMock.class);\n+\t\tverify(listener).invoking(captor.capture());\n+\t\tassertSame(foo, captor.getValue().getMock());\n+\t\tassertEquals(Foo.class.getMethod(\"doSomething\", String.class), captor.getValue().getMethod());\n+    }\n+\t\n+\t@Test\n+\tpublic void shouldCallMultipleListeners() throws Exception {\n+\t\t// given\n+\t\tInvocationListener listener1 = mock(InvocationListener.class);\n+\t\tInvocationListener listener2 = mock(InvocationListener.class);\n+\t\tFoo foo = mock(Foo.class, withSettings().callback(listener1).callback(listener2));\n+\t\t\n+\t\t// when\n+\t\tfoo.doSomething(SOME_STRING_ARGUMENT);\n+\t\t\n+\t\t// then\n+\t\tverify(listener1).invoking(any(Invocation.class));\n+\t\tverify(listener2).invoking(any(Invocation.class));\n+\t}\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/debugging/VerboseLoggingOfInvocationsOnMockTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.debugging;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.withSettings;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.internal.util.MockUtil;\n+import org.mockitoutil.TestBase;\n+\n+/**\n+ * Tests the verbose logging of invocation on mock methods.\n+ * \n+ * BEWARE: These tests rely on mocking the standard output.\n+ * While in a single-threaded environment the finally-blocks\n+ * should ensure, that the original stream is restored, there\n+ * is no guarantee for this in the parallel setting. Maybe, the\n+ * test class should be @Ignore'd by default ...\n+ */\n+public class VerboseLoggingOfInvocationsOnMockTest extends TestBase {\n+\n+\tprivate static final String ANOTHER_STRING_VALUE = \"another string value\";\n+\tprivate static final String OTHER_STRING_VALUE = \"other string value\";\n+\tprivate static final String SOME_STRING_VALUE = \"some string value\";\n+\t\n+\t@Mock\n+\tUnrelatedClass unrelatedMock;\n+\t\n+\t@Test\n+\tpublic void usage() {\n+\t\t//given\n+\t\tFoo foo = mock(Foo.class, withSettings().verboseLogging());\n+    \t\n+        //when\n+    \tfoo.doSomething(SOME_STRING_VALUE);\n+    \tfoo.giveMeSomeString(OTHER_STRING_VALUE);\n+    \tfoo.giveMeSomeString(ANOTHER_STRING_VALUE);\n+\t}\n+\t\n+    @Test\n+    public void shouldPrintInvocationOnMockToStdOut() {\n+    \tPrintStream original = System.out;\n+    \t// FIXME cannot convince checkstyle to accept this code\n+//    \ttry {\n+    \t\tByteArrayOutputStream baos = setUpStreamAsStdOut();\n+    \t\tshouldPrintInvocationOnMockToStdOut_withMockedStdout(baos);\n+//    \t} finally {\n+//    \t\tSystem.setOut(original);\n+//    \t}\n+    }\n+\n+    @Test\n+    public void shouldNotPrintInvocationOnMockWithoutSetting() {\n+    \tPrintStream original = System.out;\n+    \t// FIXME cannot convince checkstyle to accept this code\n+//    \ttry {\n+    \t\tByteArrayOutputStream baos = setUpStreamAsStdOut();\n+    \t\tshouldNotPrintInvocationOnMockWithoutSetting_withMockedStdout(baos);\n+//    \t} finally {\n+//    \t\tSystem.setOut(original);\n+//    \t}\n+    }\n+\n+\tprivate void shouldPrintInvocationOnMockToStdOut_withMockedStdout(ByteArrayOutputStream baos) {\n+\t\t//given\n+\t\tFoo foo = mock(Foo.class, withSettings().verboseLogging());\n+    \t\n+        //when\n+    \tfoo.doSomething(SOME_STRING_VALUE);\n+\n+        //then\n+    \tassertStreamContainsMockName(foo, baos);\n+        assertContains(\"doSomething\", baos.toString());\n+        assertContains(SOME_STRING_VALUE, baos.toString());\n+\t}\n+\n+    private void shouldNotPrintInvocationOnMockWithoutSetting_withMockedStdout(ByteArrayOutputStream baos) {\n+    \t//given\n+    \tFoo foo = mock(Foo.class, withSettings().verboseLogging());\n+    \t\n+    \t//when\n+    \tfoo.giveMeSomeString(SOME_STRING_VALUE);\n+    \tunrelatedMock.unrelatedMethod(ANOTHER_STRING_VALUE);\n+    \t\n+    \t//then\n+    \tassertStreamDoesNotContainMockName(unrelatedMock, baos);\n+    \tassertNotContains(\"unrelatedMethod\", baos.toString());\n+    \tassertNotContains(ANOTHER_STRING_VALUE, baos.toString());\n+    }\n+    \n+\tprivate ByteArrayOutputStream setUpStreamAsStdOut() {\n+\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n+\t\tSystem.setOut(new PrintStream(baos));\n+\t\treturn baos;\n+\t}\n+\n+\tprivate void assertStreamContainsMockName(Object mock, ByteArrayOutputStream baos) {\n+\t\tassertContains(new MockUtil().getMockName(mock).toString(), baos.toString());\n+\t}\n+\t\n+\tprivate void assertStreamDoesNotContainMockName(Object mock, ByteArrayOutputStream baos) {\n+\t\tassertNotContains(new MockUtil().getMockName(mock).toString(), baos.toString());\n+\t}\n+\t\n+\t\n+\tprivate static class UnrelatedClass {\n+\t\tvoid unrelatedMethod(String anotherStringValue) {\n+\t\t\t\n+\t\t}\n+\t}\n+}", "timestamp": 1297970708, "metainfo": ""}