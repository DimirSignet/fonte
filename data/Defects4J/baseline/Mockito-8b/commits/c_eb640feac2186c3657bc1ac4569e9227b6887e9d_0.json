{"sha": "eb640feac2186c3657bc1ac4569e9227b6887e9d", "log": "Renamed invocation verbose logger, made InvocationListener with one method only with one parameter object  --HG-- branch : issue148 rename : src/org/mockito/internal/debugging/LogInvocationsToStdOutListener.java => src/org/mockito/internal/debugging/VerboseMockInvocationLogger.java rename : test/org/mockito/internal/debugging/LogInvocationsToStdOutListenerTest.java => test/org/mockito/internal/debugging/VerboseMockInvocationLoggerTest.java", "commit": "\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n import org.mockito.internal.verification.MockAwareVerificationMode;\n import org.mockito.internal.verification.VerificationDataImpl;\n import org.mockito.invocation.InvocationListener;\n+import org.mockito.invocation.MethodCallReport;\n import org.mockito.stubbing.Answer;\n import org.mockito.stubbing.VoidMethodStubbable;\n import org.mockito.verification.VerificationMode;\n \t\t\tthrows Throwable {\n \t\tif (invocationContainerImpl.hasAnswersForStubbing()) {\n             // stubbing voids with stubVoid() or doAnswer() style\n-            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n-                            .getArgumentMatcherStorage(), invocation);\n+            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(\n+                    mockingProgress.getArgumentMatcherStorage(),\n+                    invocation\n+            );\n             invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n             return null;\n         }\n         VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n \n-        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n-                        invocation);\n+        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(\n+                mockingProgress.getArgumentMatcherStorage(),\n+                invocation\n+        );\n \n         mockingProgress.validateState();\n \n-        //if verificationMode is not null then someone is doing verify()        \n+        // if verificationMode is not null then someone is doing verify()\n         if (verificationMode != null) {\n-            //We need to check if verification was started on the correct mock \n+            // We need to check if verification was started on the correct mock\n             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            //TODO: can I avoid this cast here?\n+            // TODO: can I avoid this cast here?\n             if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                 verificationMode.verify(data);\n \t\n \tprivate void notifyListenerOfInvocationWithReturnValue(Invocation invocation, Object returnValue, InvocationListener listener) {\n \t\ttry {\n-\t\t\tlistener.invokingWithReturnValue(invocation, returnValue, getStubbingLocationOrNull(invocation));\n+\t\t\tlistener.reportInvocation(MethodCallReport.of(invocation, returnValue, getStubbingLocationOrNull(invocation)));\n \t\t} catch(RuntimeException e) {\n \t\t\tthrow new MockitoException(StringJoiner.join(\"An invocation listener threw an exception.\",\n \t\t\t\t\t\"The listener has the class \" + listener.getClass().getName()), e);\n \t\n \tprivate void notifyListenerOfInvocationWithException(Invocation invocation, Exception exception, InvocationListener listener) {\n \t\ttry {\n-\t\t\tlistener.invokingWithException(invocation, exception, getStubbingLocationOrNull(invocation));\n+\t\t\tlistener.reportInvocation(MethodCallReport.of(invocation, exception, getStubbingLocationOrNull(invocation)));\n \t\t} catch(RuntimeException e) {\n \t\t\tthrow new MockitoException(StringJoiner.join(\"An invocation listener threw an exception.\",\n \t\t\t\t\t\"The listener has the class \" + listener.getClass().getName()), e);\n--- a/src/org/mockito/internal/creation/MockSettingsImpl.java\n+++ b/src/org/mockito/internal/creation/MockSettingsImpl.java\n \n import org.mockito.MockSettings;\n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.debugging.LogInvocationsToStdOutListener;\n+import org.mockito.internal.debugging.VerboseMockInvocationLogger;\n import org.mockito.internal.util.MockName;\n import org.mockito.invocation.InvocationListener;\n import org.mockito.stubbing.Answer;\n     }\n \n \tpublic MockSettings verboseLogging() {\n-        if (!invocationListenersContainsType(LogInvocationsToStdOutListener.class)) {\n-            invocationListeners(new LogInvocationsToStdOutListener());\n+        if (!invocationListenersContainsType(VerboseMockInvocationLogger.class)) {\n+            invocationListeners(new VerboseMockInvocationLogger());\n         }\n         return this;\n \t}\n--- /dev/null\n+++ b/src/org/mockito/internal/debugging/VerboseMockInvocationLogger.java\n+package org.mockito.internal.debugging;\n+\n+import org.mockito.exceptions.PrintableInvocation;\n+import org.mockito.invocation.InvocationListener;\n+import org.mockito.invocation.MethodCallReport;\n+\n+import java.io.PrintStream;\n+\n+/**\n+ * Logs all invocations to standard output.\n+ * \n+ * Used for debugging interactions with a mock. \n+ */\n+public class VerboseMockInvocationLogger implements InvocationListener {\n+\n+    // visible for testing\n+\tfinal PrintStream printStream;\n+\n+\tprivate int mockInvocationsCounter = 0;\n+\n+    public VerboseMockInvocationLogger() {\n+        this(System.out);\n+    }\n+\n+    public VerboseMockInvocationLogger(PrintStream printStream) {\n+        this.printStream = printStream;\n+    }\n+\n+    public void reportInvocation(MethodCallReport methodCallReport) {\n+        if (methodCallReport.threwException()) {\n+            onCallWithThrowable(\n+                    methodCallReport.getInvocation(),\n+                    methodCallReport.getThrowable(),\n+                    methodCallReport.getLocationOfStubbing()\n+            );\n+        } else {\n+            onNormalCall(\n+                    methodCallReport.getInvocation(),\n+                    methodCallReport.getReturnedValue(),\n+                    methodCallReport.getLocationOfStubbing()\n+            );\n+        }\n+    }\n+\n+    private void onNormalCall(PrintableInvocation invocation, Object returnedValue, String locationOfStubbing) {\n+\t\tprintHeader();\n+\t\tprintCommonInfos(invocation);\n+\t\tprintlnIndented(\"has returned: \\\"\" + returnedValue + \"\\\"\" + ((returnedValue == null) ? \"\" : \" (\" + returnedValue.getClass().getName() + \")\"));\n+\t\tif (locationOfStubbing == null) {\n+\t\t\tprintMethodHasNotBeenStubbed();\n+\t\t} else {\n+\t\t\tprintMethodHasBeenStubbed(locationOfStubbing);\n+\t\t}\n+\t\tprintFooter();\n+\t}\n+\n+\tprivate void onCallWithThrowable(PrintableInvocation invocation, Throwable throwable, String locationOfStubbing) {\n+\t\tprintHeader();\n+\t\tprintCommonInfos(invocation);\n+\t\tprintlnIndented(\"has thrown: \" + throwable.getClass() + \" with message \" + throwable.getMessage());\n+\t\tif (locationOfStubbing == null) {\n+\t\t\tprintMethodHasNotBeenStubbed();\n+\t\t} else {\n+\t\t\tprintMethodHasBeenStubbed(locationOfStubbing);\n+\t\t}\n+\t\tprintFooter();\n+\t}\n+\n+\tprivate void printHeader() {\n+\t\tmockInvocationsCounter++;\n+\t\tprintStream.println(\"############ Logging method invocation #\" + mockInvocationsCounter + \" on mock/spy ########\");\n+\t}\n+\t\n+\tprivate void printMethodHasNotBeenStubbed() {\n+\t\tprintlnIndented(\"Method has not been stubbed.\");\n+\t}\n+\n+\tprivate void printMethodHasBeenStubbed(String locationOfStubbing) {\n+\t\tprintlnIndented(\"Method has been stubbed.\");\n+\t\tprintlnIndented(locationOfStubbing);\n+\t}\n+\n+\tprivate void printCommonInfos(PrintableInvocation invocation) {\n+\t\tprintStream.println(invocation.toString());\n+//\t\tprintStream.println(\"Handling method call on a mock/spy.\");\n+\t\tprintlnIndented(invocation.getLocation().toString());\n+\t}\n+\n+\tprivate void printFooter() {\n+\t\tprintStream.println(\"\");\n+\t}\n+\t\n+\tprivate void printlnIndented(String message) {\n+\t\tprintStream.println(\"   \" + message);\n+\t}\n+\t\n+}\n--- a/src/org/mockito/invocation/InvocationListener.java\n+++ b/src/org/mockito/invocation/InvocationListener.java\n package org.mockito.invocation;\n \n import org.mockito.MockSettings;\n-import org.mockito.exceptions.PrintableInvocation;\n \n /**\n  * This listener can be notified of method invocations on a mock.\n  * \n- * For this to happen, it must be registered using {@link MockSettings#callback(InvocationListener)}.\n+ * For this to happen, it must be registered using {@link MockSettings#invocationListeners(InvocationListener...)}.\n  */\n public interface InvocationListener {\n \t\n \t/**\n-\t * Called when a method on the listener's mock was invoked and returned normally.\n-\t * \n-\t * Exceptions during this invocationListeners are treated as fatal errors.\n-\t * \n-\t * @param invocation information on the happening method call, never {@code null}\n-\t * @param returnValue whatever it was that the method returned, may be {@code null}\n-\t * @param locationOfStubbing Indicates where the method was stubbed, and {@code null} if it was not\n-\t * @throws RuntimeException on fatal errors\n+\t * Called after the invocation of the listener's mock if it returned normally.\n+\t *\n+     * <p>\n+     * Exceptions caused by this invocationListener will raise a {@link org.mockito.exceptions.base.MockitoException}.\n+     * </p>\n+\t *\n+\t * @param methodCallReport Information about the method call that just happened.\n+     *\n+     * @see MethodCallReport\n \t */\n-\tvoid invokingWithReturnValue(PrintableInvocation invocation, Object returnValue, String locationOfStubbing);\n-\t\n-\t/**\n-\t * Called when a method on the listener's mock was invoked and threw an exception.\n-\t * \n-\t * Errors are not reported, as they usually indicate some severe VM error, that ought\n-\t * to be propagated and is typically not thrown by your code to begin with.\n-\t * \n-\t * Note that the exception is not necessarily caused by stubbing the method with it, but may also\n-\t * be the result of incorrect usage of the mockito API or even a bug inside mockito.\n-\t * \n-\t * Exceptions during this invocationListeners are treated as fatal errors.\n-\t * \n-\t * @param invocation information on the happening method call, never {@code null}\n-\t * @param exception the exception that was thrown\n-\t * @param locationOfStubbing Indicates where the method was stubbed, and {@code null} if it was not\n-\t * @throws RuntimeException on fatal errors\n-\t */\n-\tvoid invokingWithException(PrintableInvocation invocation, Exception exception, String locationOfStubbing);\n+\tvoid reportInvocation(MethodCallReport methodCallReport);\n }\n--- /dev/null\n+++ b/src/org/mockito/invocation/MethodCallReport.java\n+package org.mockito.invocation;\n+\n+import org.mockito.exceptions.PrintableInvocation;\n+\n+/**\n+ * Represent a method call on a mock.\n+ *\n+ * <p>\n+ *     Contains the information on the mock, the location of the stub\n+ *     the return value if it returned something (maybe null), or an\n+ *     exception if one was thrown when the method was invoked.\n+ * </p>\n+ */\n+public class MethodCallReport {\n+    private final PrintableInvocation invocation;\n+    private Object returnedValue;\n+    private Throwable throwable;\n+    private final String locationOfStubbing;\n+\n+    /**\n+     * Build a new {@link MethodCallReport} with a return value.\n+     *\n+     * @param printableInvocation Information on the method call\n+     * @param returnedValue The value returned by the method invocation\n+     * @param location The location of the stub\n+     * @return A new MethodCallReport\n+     */\n+    public static MethodCallReport of(PrintableInvocation printableInvocation, Object returnedValue, String location) {\n+        return new MethodCallReport(printableInvocation, returnedValue, location);\n+    }\n+\n+    /**\n+     * Build a new {@link MethodCallReport} with a return value.\n+     *\n+     * @param printableInvocation Information on the method call\n+     * @param throwable Tha throwable raised by the method invocation\n+     * @param location THe location of the stub\n+     * @return A new MethodCallReport\n+     */\n+    public static MethodCallReport of(PrintableInvocation printableInvocation, Throwable throwable, String location) {\n+        return new MethodCallReport(printableInvocation, throwable, location);\n+    }\n+\n+    private MethodCallReport(PrintableInvocation invocation, Object returnedValue, String locationOfStubbing) {\n+        this.invocation = invocation;\n+        this.returnedValue = returnedValue;\n+        this.locationOfStubbing = locationOfStubbing;\n+    }\n+\n+    private MethodCallReport(PrintableInvocation invocation, Throwable throwable, String locationOfStubbing) {\n+        this.invocation = invocation;\n+        this.throwable = throwable;\n+        this.locationOfStubbing = locationOfStubbing;\n+    }\n+\n+    /**\n+     * @return Information on the method call, never {@code null}\n+     */\n+    public PrintableInvocation getInvocation() {\n+        return invocation;\n+    }\n+\n+    /**\n+     * @return The resulting value of the method invocation, may be <code>null</code>\n+     */\n+    public Object getReturnedValue() {\n+        return returnedValue;\n+    }\n+\n+    /**\n+     * @return The throwable raised by the method invocation, maybe <code>null</code>\n+     */\n+    public Throwable getThrowable() {\n+        return throwable;\n+    }\n+\n+    /**\n+     * @return <code>true</code> if an exception was raised, <code>false</code> otherwise\n+     */\n+    public boolean threwException() {\n+        return throwable != null;\n+    }\n+\n+    /**\n+     * @return Location of the stub invocation\n+     */\n+    public String getLocationOfStubbing() {\n+        return locationOfStubbing;\n+    }\n+\n+    // Generated\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+\n+        MethodCallReport that = (MethodCallReport) o;\n+\n+        if (invocation != null ? !invocation.equals(that.invocation) : that.invocation != null) return false;\n+        if (locationOfStubbing != null ? !locationOfStubbing.equals(that.locationOfStubbing) : that.locationOfStubbing != null)\n+            return false;\n+        if (returnedValue != null ? !returnedValue.equals(that.returnedValue) : that.returnedValue != null)\n+            return false;\n+        if (throwable != null ? !throwable.equals(that.throwable) : that.throwable != null) return false;\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result = invocation != null ? invocation.hashCode() : 0;\n+        result = 31 * result + (returnedValue != null ? returnedValue.hashCode() : 0);\n+        result = 31 * result + (throwable != null ? throwable.hashCode() : 0);\n+        result = 31 * result + (locationOfStubbing != null ? locationOfStubbing.hashCode() : 0);\n+        return result;\n+    }\n+}\n--- a/test/org/mockito/internal/MockHandlerTest.java\n+++ b/test/org/mockito/internal/MockHandlerTest.java\n import org.mockito.internal.verification.VerificationModeFactory;\n import org.mockito.invocation.InvocationListener;\n import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.invocation.MethodCallReport;\n import org.mockito.stubbing.Answer;\n import org.mockito.verification.VerificationMode;\n import org.mockitoutil.TestBase;\n \t\thandler.handle(invocation);\n \n \t\t// then\n-\t\tverify(listener1).invokingWithReturnValue(invocation, null, SOME_LOCATION);\n-\t\tverify(listener2).invokingWithReturnValue(invocation, null, SOME_LOCATION);\n+\t\tverify(listener1).reportInvocation(MethodCallReport.of(invocation, null, SOME_LOCATION));\n+\t\tverify(listener2).reportInvocation(MethodCallReport.of(invocation, null, SOME_LOCATION));\n \t}\n \n \tprivate Invocation createInvocationWithStubbingLocation(String stubbingLocation) {\n \t\thandler.handle(invocation);\n \n \t\t// then\n-\t\tverify(listener1).invokingWithReturnValue(invocation, null, SOME_LOCATION);\n-\t\tverify(listener2).invokingWithReturnValue(invocation, null, SOME_LOCATION);\n+\t\tverify(listener1).reportInvocation(MethodCallReport.of(invocation, null, SOME_LOCATION));\n+\t\tverify(listener2).reportInvocation(MethodCallReport.of(invocation, null, SOME_LOCATION));\n \t}\n \n \t@Test\n \t\thandler.handle(invocation);\n \n \t\t// then\n-\t\tverify(listener1).invokingWithReturnValue(invocation, SOME_RETURN_VALUE, SOME_LOCATION);\n-\t\tverify(listener2).invokingWithReturnValue(invocation, SOME_RETURN_VALUE, SOME_LOCATION);\n+\t\tverify(listener1).reportInvocation(MethodCallReport.of(invocation, SOME_RETURN_VALUE, SOME_LOCATION));\n+\t\tverify(listener2).reportInvocation(MethodCallReport.of(invocation, SOME_RETURN_VALUE, SOME_LOCATION));\n \t}\n \n \t@Test\n \t\t\tfail(\"Exception was not rethrown.\");\n \t\t} catch (RuntimeException e) {\n \t\t\t// then\n-\t\t\tverify(listener1).invokingWithException(invocation, SOME_EXCEPTION, SOME_LOCATION);\n-\t\t\tverify(listener2).invokingWithException(invocation, SOME_EXCEPTION, SOME_LOCATION);\n+\t\t\tverify(listener1).reportInvocation(MethodCallReport.of(invocation, SOME_EXCEPTION, SOME_LOCATION));\n+\t\t\tverify(listener2).reportInvocation(MethodCallReport.of(invocation, SOME_EXCEPTION, SOME_LOCATION));\n \t\t}\n \t}\n \n \t\thandler.handle(invocation);\n \n \t\t// then\n-\t\tverify(listener1).invokingWithReturnValue(invocation, null, SOME_LOCATION);\n-\t\tverify(listener2).invokingWithReturnValue(invocation, null, SOME_LOCATION);\n+\t\tverify(listener1).reportInvocation(MethodCallReport.of(invocation, null, SOME_LOCATION));\n+\t\tverify(listener2).reportInvocation(MethodCallReport.of(invocation, null, SOME_LOCATION));\n \t}\n \n \t@Test(expected = MockitoException.class)\n \tpublic void shouldThrowMockitoExceptionWhenInvocationHandlerThrowsAnything() throws Throwable {\n \t\t// given\n \t\tInvocationListener throwingListener = mock(InvocationListener.class);\n-\t\tdoThrow(SOME_EXCEPTION).when(throwingListener).invokingWithReturnValue(any(Invocation.class),\n-\t\t\t\tany(String.class), any(String.class));\n+\t\tdoThrow(SOME_EXCEPTION).when(throwingListener).reportInvocation(any(MethodCallReport.class));\n \t\tMockHandler<?> handler = createCorrectlyStubbedHandler(throwingListener);\n \n \t\t// when\n--- a/test/org/mockito/internal/creation/MockSettingsImplTest.java\n+++ b/test/org/mockito/internal/creation/MockSettingsImplTest.java\n import org.junit.Test;\n import org.mockito.Mock;\n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.debugging.LogInvocationsToStdOutListener;\n+import org.mockito.internal.debugging.VerboseMockInvocationLogger;\n import org.mockito.invocation.InvocationListener;\n import org.mockitoutil.TestBase;\n \n         mockSettingsImpl.verboseLogging();\n \n         //then\n-        assertContainsType(mockSettingsImpl.getInvocationListeners(), LogInvocationsToStdOutListener.class);\n+        assertContainsType(mockSettingsImpl.getInvocationListeners(), VerboseMockInvocationLogger.class);\n     }\n \n     @Test\n--- /dev/null\n+++ b/test/org/mockito/internal/debugging/VerboseMockInvocationLoggerTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.debugging;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.exceptions.PrintableInvocation;\n+import org.mockito.invocation.MethodCallReport;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Mockito.mock;\n+\n+public class VerboseMockInvocationLoggerTest {\n+\n+    private VerboseMockInvocationLogger listener;\n+    private ByteArrayOutputStream output;\n+    private PrintableInvocation invocation;\n+\n+    @Before public void init_Listener() throws Exception {\n+        output = new ByteArrayOutputStream();\n+        listener = new VerboseMockInvocationLogger(new PrintStream(output));\n+    }\n+\n+    @Before public void init_Invocation() {\n+        invocation = mock(PrintableInvocation.class);\n+        given(invocation.getLocation()).willReturn(mock(Location.class));\n+    }\n+\n+    @Test\n+\tpublic void shouldPrintToSystemOut() {\n+\t\tassertThat(new VerboseMockInvocationLogger().printStream).isSameAs(System.out);\n+\t}\n+\n+\t@Test\n+\tpublic void shouldPrintInvocationWithReturnValueToStream() {\n+        // when\n+\t\tlistener.reportInvocation(MethodCallReport.of(invocation, \"return value\", \"location of stubbing\"));\n+\n+\t\t// then\n+        assertThat(printed())\n+                .contains(invocation.toString())\n+                .contains(invocation.getLocation().toString())\n+                .contains(\"return value\")\n+                .contains(\"location of stubbing\");\n+\t}\n+\n+\t@Test\n+\tpublic void shouldPrintInvocationWithExceptionToStream() {\n+\t\t// when\n+\t\tlistener.reportInvocation(MethodCallReport.of(invocation, new ThirdPartyException(), \"location of stubbing\"));\n+\n+\t\t// then\n+        assertThat(printed())\n+\t\t\t\t.contains(invocation.toString())\n+\t\t\t\t.contains(invocation.getLocation().toString())\n+\t\t\t\t.contains(ThirdPartyException.class.getName())\n+\t\t\t\t.contains(\"location of stubbing\");\n+\t}\n+\n+\t@Test\n+\tpublic void shouldLogNumberOfInteractions() {\n+\t\t// when & then\n+        listener.reportInvocation(MethodCallReport.of(invocation, new ThirdPartyException(), \"location of stubbing\"));\n+\t\tassertThat(printed()).contains(\"#1\");\n+\n+        listener.reportInvocation(MethodCallReport.of(invocation, new ThirdPartyException(), \"other location\"));\n+\t\tassertThat(printed()).contains(\"#2\");\n+\n+        listener.reportInvocation(MethodCallReport.of(invocation, new ThirdPartyException(), \"location of stubbing\"));\n+\t\tassertThat(printed()).contains(\"#3\");\n+\t}\n+\n+    private String printed() {\n+        return output.toString();\n+    }\n+\n+\tprivate static class ThirdPartyException extends Exception {\n+\t\tprivate static final long serialVersionUID = 3022739107688491354L;\n+\t}\n+}\n--- a/test/org/mockitousage/debugging/InvocationListenerCallbackTest.java\n+++ b/test/org/mockitousage/debugging/InvocationListenerCallbackTest.java\n  */\n package org.mockitousage.debugging;\n \n+import org.junit.Ignore;\n import org.junit.Test;\n+import org.mockito.InOrder;\n import org.mockito.exceptions.PrintableInvocation;\n import org.mockito.internal.matchers.Contains;\n import org.mockito.internal.matchers.Equals;\n import org.mockito.internal.matchers.InstanceOf;\n import org.mockito.invocation.InvocationListener;\n+import org.mockito.invocation.MethodCallReport;\n import org.mockitousage.debugging.VerboseLoggingOfInvocationsOnMockTest.ThirdPartyException;\n import org.mockitoutil.TestBase;\n \n import static org.mockito.BDDMockito.given;\n-import static org.mockito.Matchers.eq;\n import static org.mockito.Matchers.isA;\n import static org.mockito.Mockito.*;\n \n  */\n public class InvocationListenerCallbackTest extends TestBase {\n \n-\tprivate static final String SOME_RETURN_VALUE = \"some return value\";\n-\tprivate static final String SOME_STRING_ARGUMENT = \"some string argument\";\n-\n-\t@Test\n+    @Test\n \tpublic void givenInvocationReturningValue_shouldCallSingleListenerWithCorrectCallback() throws Exception {\n \t\t// given\n \t\t// Cannot use a mockito-mock here: during stubbing, the listener will be called\n \t\t// and mockito will confuse the mocks.\n \t\tRememberingListener listener = new RememberingListener();\n \t\tFoo foo = mock(Foo.class, withSettings().invocationListeners(listener));\n-\t\tgiven(foo.giveMeSomeString(SOME_STRING_ARGUMENT)).willReturn(SOME_RETURN_VALUE);\n+\t\tgiven(foo.giveMeSomeString(\"argument\")).willReturn(\"returned\");\n \n \t\t// when\n-\t\tfoo.giveMeSomeString(SOME_STRING_ARGUMENT);\n+\t\tfoo.giveMeSomeString(\"argument\");\n \n \t\tassertHasBeenNotified(listener, new InstanceOf(PrintableInvocation.class),\n-\t\t\t\tnew Equals(SOME_RETURN_VALUE), new Contains(getClass().getSimpleName().toString()));\n+\t\t\t\tnew Equals(\"returned\"), new Contains(getClass().getSimpleName()));\n \t}\n \n \t@Test\n \t\t// and mockito will confuse the mocks.\n \t\tRememberingListener listener1 = new RememberingListener();\n \t\tRememberingListener listener2 = new RememberingListener();\n-\t\tFoo foo = mock(Foo.class, withSettings().invocationListeners(listener1).invocationListeners(listener2));\n-\t\tgiven(foo.giveMeSomeString(SOME_STRING_ARGUMENT)).willReturn(SOME_RETURN_VALUE);\n+\t\tFoo foo = mock(Foo.class, withSettings().invocationListeners(listener1, listener2));\n+\t\tgiven(foo.giveMeSomeString(\"argument\")).willReturn(\"returned\");\n \n \t\t// when\n-\t\tfoo.giveMeSomeString(SOME_STRING_ARGUMENT);\n+\t\tfoo.giveMeSomeString(\"argument\");\n \n \t\t// then\n \t\tassertHasBeenNotified(listener1, new InstanceOf(PrintableInvocation.class),\n-\t\t\t\tnew Equals(SOME_RETURN_VALUE), new Contains(getClass().getSimpleName().toString()));\n+\t\t\t\tnew Equals(\"returned\"), new Contains(getClass().getSimpleName()));\n \t\tassertHasBeenNotified(listener2, new InstanceOf(PrintableInvocation.class),\n-\t\t\t\tnew Equals(SOME_RETURN_VALUE), new Contains(getClass().getSimpleName().toString()));\n+\t\t\t\tnew Equals(\"returned\"), new Contains(getClass().getSimpleName()));\n \t}\n \n \t@Test\n+    @Ignore(\"not anymore, waiting complete refactoring to be removed\")\n \tpublic void givenInvocationThrowingException_shouldCallSingleListenerWithCorrectCallback() throws Exception {\n \t\t// given\n \t\tInvocationListener listener = mock(InvocationListener.class);\n \t\tRuntimeException expectedException = new ThirdPartyException();\n \t\tFoo foo = mock(Foo.class, withSettings().invocationListeners(listener));\n-\t\tdoThrow(expectedException).when(foo).doSomething(SOME_STRING_ARGUMENT);\n+\t\tdoThrow(expectedException).when(foo).doSomething(\"argument\");\n \n \t\t// when\n \t\ttry {\n-\t\t\tfoo.doSomething(SOME_STRING_ARGUMENT);\n+\t\t\tfoo.doSomething(\"argument\");\n \t\t\tfail(\"Exception expected.\");\n \t\t} catch (ThirdPartyException actualException) {\n \t\t\t// then\n \t\t\tassertSame(expectedException, actualException);\n-\t\t\tverify(listener).invokingWithException(isA(PrintableInvocation.class), eq(actualException),\n-\t\t\t\t\tisA(String.class));\n+\t\t\tverify(listener).reportInvocation(isA(MethodCallReport.class));\n \t\t}\n \t}\n \n \t@Test\n \tpublic void givenInvocationThrowingException_shouldCallMultipleListeners() throws Exception {\n \t\t// given\n-\t\tInvocationListener listener1 = mock(InvocationListener.class);\n-\t\tInvocationListener listener2 = mock(InvocationListener.class);\n-\t\tFoo foo = mock(Foo.class, withSettings().invocationListeners(listener1).invocationListeners(listener2));\n-\t\tdoThrow(new ThirdPartyException()).when(foo).doSomething(SOME_STRING_ARGUMENT);\n+\t\tInvocationListener listener1 = mock(InvocationListener.class, \"listener1\");\n+\t\tInvocationListener listener2 = mock(InvocationListener.class, \"listener2\");\n+\t\tFoo foo = mock(Foo.class, withSettings().invocationListeners(listener1, listener2));\n+\t\tdoThrow(new ThirdPartyException()).when(foo).doSomething(\"argument\");\n \n \t\t// when\n \t\ttry {\n-\t\t\tfoo.doSomething(SOME_STRING_ARGUMENT);\n+\t\t\tfoo.doSomething(\"argument\");\n \t\t\tfail(\"Exception expected.\");\n \t\t} catch (ThirdPartyException actualException) {\n \t\t\t// then\n-\t\t\tverify(listener1).invokingWithException(isA(PrintableInvocation.class), isA(RuntimeException.class),\n-\t\t\t\t\tisA(String.class));\n-\t\t\tverify(listener2).invokingWithException(isA(PrintableInvocation.class), isA(RuntimeException.class),\n-\t\t\t\t\tisA(String.class));\n+            InOrder orderedVerify = inOrder(listener1, listener2);\n+            orderedVerify.verify(listener1).reportInvocation(any(MethodCallReport.class));\n+\t\t\torderedVerify.verify(listener2).reportInvocation(any(MethodCallReport.class));\n \t\t}\n \t}\n \t\n \t\tObject returnValue;\n \t\tString locationOfStubbing;\n \n-\t\tpublic void invokingWithReturnValue(PrintableInvocation invocation, Object returnValue,\n-\t\t\t\tString locationOfStubbing) {\n-\t\t\tthis.invocation = invocation;\n-\t\t\tthis.returnValue = returnValue;\n-\t\t\tthis.locationOfStubbing = locationOfStubbing;\n+\t\tpublic void reportInvocation(MethodCallReport mcr) {\n+\t\t\tthis.invocation = mcr.getInvocation();\n+\t\t\tthis.returnValue = mcr.getReturnedValue();\n+\t\t\tthis.locationOfStubbing = mcr.getLocationOfStubbing();\n \t\t}\n \n-\t\tpublic void invokingWithException(PrintableInvocation invocation, Exception exception, String locationOfStubbing) {\n-\t\t\tthrow new UnsupportedOperationException();\n-\t\t}\n-\t\t\n \t}\n }\n--- a/test/org/mockitousage/debugging/VerboseLoggingOfInvocationsOnMockTest.java\n+++ b/test/org/mockitousage/debugging/VerboseLoggingOfInvocationsOnMockTest.java\n  */\n package org.mockitousage.debugging;\n \n+import org.fest.assertions.Assertions;\n import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.Mock;\n import org.mockito.internal.util.MockUtil;\n-import org.mockitoutil.TestBase;\n \n import java.io.ByteArrayOutputStream;\n import java.io.PrintStream;\n \n+import static org.junit.Assert.fail;\n import static org.mockito.BDDMockito.given;\n import static org.mockito.Mockito.*;\n \n  * in the parallel setting.\n  * Maybe, the test class should be @Ignore'd by default ...\n  */\n-public class VerboseLoggingOfInvocationsOnMockTest extends TestBase {\n+public class VerboseLoggingOfInvocationsOnMockTest {\n \n-\tprivate static final String SOME_RETURN_VALUE = \"some return value\";\n-\tprivate static final String ANOTHER_STRING_VALUE = \"another string value\";\n-\tprivate static final String OTHER_STRING_VALUE = \"other string value\";\n-\tprivate static final String SOME_STRING_VALUE = \"some string value\";\n+    private ByteArrayOutputStream output;\n+    private PrintStream original;\n \n-\tprivate PrintStream original;\n+    @Mock UnrelatedClass unrelatedMock;\n \n-\t@Mock UnrelatedClass unrelatedMock;\n-\t\n-\t@Before\n+    @Before\n \tpublic void setUp() {\n \t\toriginal = System.out;\n+        output = new ByteArrayOutputStream();\n+        System.setOut(new PrintStream(output));\n \t}\n \n \t@After\n \n \t@Test\n \tpublic void shouldNotPrintInvocationOnMockWithoutSetting() {\n-\t\tByteArrayOutputStream baos = setUpStreamAsStdOut();\n \t\t// given\n \t\tFoo foo = mock(Foo.class, withSettings().verboseLogging());\n \n \t\t// when\n-\t\tfoo.giveMeSomeString(SOME_STRING_VALUE);\n-\t\tunrelatedMock.unrelatedMethod(ANOTHER_STRING_VALUE);\n+\t\tfoo.giveMeSomeString(\"Klipsch\");\n+\t\tunrelatedMock.unrelatedMethod(\"Apple\");\n \n \t\t// then\n-\t\tassertStreamDoesNotContainMockName(unrelatedMock, baos);\n-\t\tassertNotContains(\"unrelatedMethod\", baos.toString());\n-\t\tassertNotContains(ANOTHER_STRING_VALUE, baos.toString());\n+        Assertions.assertThat(printed())\n+                .doesNotContain(mockName(unrelatedMock))\n+                .doesNotContain(\"unrelatedMethod\")\n+                .doesNotContain(\"Apple\");\n \t}\n \n \t@Test\n \tpublic void shouldPrintUnstubbedInvocationOnMockToStdOut() {\n-\t\tByteArrayOutputStream baos = setUpStreamAsStdOut();\n \t\t// given\n \t\tFoo foo = mock(Foo.class, withSettings().verboseLogging());\n \n \t\t// when\n-\t\tfoo.doSomething(SOME_STRING_VALUE);\n+\t\tfoo.doSomething(\"Klipsch\");\n \n \t\t// then\n-\t\tassertStreamContainsClassName(getClass(), baos);\n-\t\tassertStreamContainsMockName(foo, baos);\n-\t\tassertContains(\"doSomething\", baos.toString());\n-\t\tassertContains(SOME_STRING_VALUE, baos.toString());\n+        Assertions.assertThat(printed())\n+                .contains(getClass().getName())\n+                .contains(mockName(foo))\n+\t\t\t\t.contains(\"doSomething\")\n+\t\t\t\t.contains(\"Klipsch\");\n \t}\n \n \t@Test\n \tpublic void shouldPrintStubbedInvocationOnMockToStdOut() {\n-\t\tByteArrayOutputStream baos = setUpStreamAsStdOut();\n \t\t// given\n \t\tFoo foo = mock(Foo.class, withSettings().verboseLogging());\n-\t\tgiven(foo.giveMeSomeString(SOME_STRING_VALUE)).willReturn(SOME_RETURN_VALUE);\n+\t\tgiven(foo.giveMeSomeString(\"Klipsch\")).willReturn(\"earbuds\");\n \n \t\t// when\n-\t\tfoo.giveMeSomeString(SOME_STRING_VALUE);\n+\t\tfoo.giveMeSomeString(\"Klipsch\");\n \n \t\t// then\n-\t\tassertStreamContainsClassName(getClass(), baos);\n-\t\tassertStreamContainsMockName(foo, baos);\n-\t\tassertContains(\"giveMeSomeString\", baos.toString());\n-\t\tassertContains(SOME_STRING_VALUE, baos.toString());\n-\t\tassertContains(SOME_RETURN_VALUE, baos.toString());\n+        Assertions.assertThat(printed())\n+                .contains(getClass().getName())\n+                .contains(mockName(foo))\n+\t\t\t\t.contains(\"giveMeSomeString\")\n+\t\t\t\t.contains(\"Klipsch\")\n+\t\t\t\t.contains(\"earbuds\");\n \t}\n \n \t@Test\n \tpublic void shouldPrintThrowingInvocationOnMockToStdOut() {\n-\t\tByteArrayOutputStream baos = setUpStreamAsStdOut();\n \t\t// given\n \t\tFoo foo = mock(Foo.class, withSettings().verboseLogging());\n-\t\tdoThrow(new ThirdPartyException()).when(foo).doSomething(SOME_STRING_VALUE);\n+\t\tdoThrow(new ThirdPartyException()).when(foo).doSomething(\"Klipsch\");\n \n \t\ttry {\n \t\t\t// when\n-\t\t\tfoo.doSomething(SOME_STRING_VALUE);\n-\t\t\tfail(\"Exception erwartet.\");\n+\t\t\tfoo.doSomething(\"Klipsch\");\n+\t\t\tfail(\"Exception excepted.\");\n \t\t} catch (ThirdPartyException e) {\n \t\t\t// then\n-\t\t\tassertStreamContainsClassName(getClass(), baos);\n-\t\t\tassertStreamContainsMockName(foo, baos);\n-\t\t\tassertContains(\"doSomething\", baos.toString());\n-\t\t\tassertContains(SOME_STRING_VALUE, baos.toString());\n-\t\t\tassertStreamContainsClassName(ThirdPartyException.class, baos);\n+            Assertions.assertThat(printed())\n+                    .contains(getClass().getName())\n+                    .contains(mockName(foo))\n+\t\t\t\t\t.contains(\"doSomething\")\n+\t\t\t\t\t.contains(\"Klipsch\")\n+                    .contains(ThirdPartyException.class.getName());\n \t\t}\n \t}\n \n \t@Test\n \tpublic void shouldPrintRealInvocationOnSpyToStdOut() {\n-\t\tByteArrayOutputStream baos = setUpStreamAsStdOut();\n \t\t// given\n \t\tFooImpl fooSpy = mock(FooImpl.class,\n \t\t\t\twithSettings().spiedInstance(new FooImpl()).verboseLogging());\n-\t\tdoCallRealMethod().when(fooSpy).doSomething(SOME_STRING_VALUE);\n+\t\tdoCallRealMethod().when(fooSpy).doSomething(\"Klipsch\");\n \t\t\n \t\t// when\n-\t\tfooSpy.doSomething(SOME_STRING_VALUE);\n+\t\tfooSpy.doSomething(\"Klipsch\");\n \t\t\n \t\t// then\n-\t\tassertStreamContainsClassName(getClass(), baos);\n-\t\tassertStreamContainsMockName(fooSpy, baos);\n-\t\tassertContains(\"doSomething\", baos.toString());\n-\t\tassertContains(SOME_STRING_VALUE, baos.toString());\n+        Assertions.assertThat(printed())\n+                .contains(getClass().getName())\n+                .contains(mockName(fooSpy))\n+\t\t\t\t.contains(\"doSomething\")\n+\t\t\t\t.contains(\"Klipsch\");\n \t}\n \n-\t@Test\n+    @Test\n \tpublic void usage() {\n \t\t// given\n \t\tFoo foo = mock(Foo.class, withSettings().verboseLogging());\n-\t\tgiven(foo.giveMeSomeString(ANOTHER_STRING_VALUE)).willReturn(\n-\t\t\t\tSOME_RETURN_VALUE);\n+\t\tgiven(foo.giveMeSomeString(\"Apple\")).willReturn(\n+                \"earbuds\");\n \n \t\t// when\n-\t\tfoo.giveMeSomeString(OTHER_STRING_VALUE);\n-\t\tfoo.giveMeSomeString(ANOTHER_STRING_VALUE);\n-\t\tfoo.doSomething(SOME_STRING_VALUE);\n+\t\tfoo.giveMeSomeString(\"Shure\");\n+\t\tfoo.giveMeSomeString(\"Apple\");\n+\t\tfoo.doSomething(\"Klipsch\");\n \t}\n \n+    private String printed() {\n+        return output.toString();\n+    }\n \n-    private void assertStreamContainsClassName(Class<?> clazz,ByteArrayOutputStream baos) {\n-\t\tassertContains(clazz.getName().toString(), baos.toString());\n-\t}\n+    private String mockName(Object mock) {\n+        return new MockUtil().getMockName(mock).toString();\n+    }\n \n-\tprivate ByteArrayOutputStream setUpStreamAsStdOut() {\n-\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n-\t\tSystem.setOut(new PrintStream(baos));\n-\t\treturn baos;\n-\t}\n+    private static class UnrelatedClass {\n+        void unrelatedMethod(String anotherStringValue) {\n+        }\n+    }\n \n-\tprivate void assertStreamContainsMockName(Object mock, ByteArrayOutputStream baos) {\n-\t\tassertContains(new MockUtil().getMockName(mock).toString(), baos.toString());\n-\t}\n-\n-\tprivate void assertStreamDoesNotContainMockName(Object mock, ByteArrayOutputStream baos) {\n-\t\tassertNotContains(new MockUtil().getMockName(mock).toString(), baos.toString());\n-\t}\n-\n-\tprivate static class UnrelatedClass {\n-\t\tvoid unrelatedMethod(String anotherStringValue) {\n-\n-\t\t}\n-\t}\n-\n-\t/**\n+    /**\n \t * An exception that isn't defined by Mockito or the JDK and therefore does\n \t * not appear in the logging result by chance alone.\n \t */\n \t}\n \n \tstatic class FooImpl implements Foo {\n-\n \t\tpublic String giveMeSomeString(String param) {\n-\t\t\t// nothing to do\n \t\t\treturn null;\n \t\t}\n \n \t\tpublic void doSomething(String param) {\n-\t\t\t// nothing to do\n \t\t}\n-\n \t}\n }", "timestamp": 1304895374, "metainfo": ""}