{"sha": "265aad7ab0fbfec5e7ca569b31612446e86ff77e", "log": "Steps towards insulating cglib-dependent code", "commit": "\n--- a/src/org/mockito/exceptions/base/MockitoSerializationIssue.java\n+++ b/src/org/mockito/exceptions/base/MockitoSerializationIssue.java\n  *     However note that other calls related to the stackTrace will refer to the filter stacktrace.\n  * </p>\n  *\n- * @since 1.9.6\n+ * @since 1.10.0\n  */\n public class MockitoSerializationIssue extends ObjectStreamException {\n \n--- a/src/org/mockito/internal/configuration/ClassPathLoader.java\n+++ b/src/org/mockito/internal/configuration/ClassPathLoader.java\n  */\n public class ClassPathLoader {\n     private static final String DEFAULT_MOCK_MAKER_CLASS =\n-            \"org.mockito.internal.creation.CglibMockMaker\";\n+            \"org.mockito.internal.creation.cglib.CglibMockMaker\";\n     private static final String DEFAULT_STACK_TRACE_CLEANER_PROVIDER_CLASS =\n             \"org.mockito.internal.exceptions.stacktrace.DefaultStackTraceCleanerProvider\";\n     public static final String MOCKITO_CONFIGURATION_CLASS_NAME = \"org.mockito.configuration.MockitoConfiguration\";\n     /**\n      * Returns the implementation of the mock maker available for the current runtime.\n      *\n-     * <p>Returns {@link org.mockito.internal.creation.CglibMockMaker} if no\n+     * <p>Returns {@link org.mockito.internal.creation.cglib.CglibMockMaker} if no\n      * {@link MockMaker} extension exists or is visible in the current classpath.</p>\n      */\n     public static MockMaker getMockMaker() {\n--- a/src/org/mockito/internal/creation/AcrossJVMSerializationFeature.java\n+++ b/src/org/mockito/internal/creation/AcrossJVMSerializationFeature.java\n  * </p>\n  *\n  * <p>\n- *     Then in the {@link MethodInterceptorFilter} of mockito, if the <code>writeReplace</code> method is called,\n+ *     Then in the {@link org.mockito.internal.creation.cglib.MethodInterceptorFilter} of mockito, if the <code>writeReplace</code> method is called,\n  *     it will use the custom implementation of this class {@link #writeReplace(Object)}. This method has a specific\n  *     knowledge on how to serialize a mockito mock that is based on CGLIB.\n  * </p>\n  *\n- * <p><strong>Only one instance per mock! See {@link MethodInterceptorFilter}</strong></p>\n+ * <p><strong>Only one instance per mock! See {@link org.mockito.internal.creation.cglib.MethodInterceptorFilter}</strong></p>\n  *\n  * TODO use a proper way to add the interface\n  * TODO offer a way to disable completely this behavior, or maybe enable this behavior only with a specific setting\n  * TODO check the class is mockable in the deserialization side\n  *\n- * @see CglibMockMaker\n- * @see MethodInterceptorFilter\n+ * @see org.mockito.internal.creation.cglib.CglibMockMaker\n+ * @see org.mockito.internal.creation.cglib.MethodInterceptorFilter\n  * @author Brice Dutheil\n- * @since 1.9.6\n+ * @since 1.10.0\n  */\n @Incubating\n public class AcrossJVMSerializationFeature implements Serializable {\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/cglib/AbstractMockitoMethodProxy.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation.cglib;\n+\n+public abstract class AbstractMockitoMethodProxy implements MockitoMethodProxy {\n+\n+    public Object invokeSuper(Object target, Object[] arguments) throws Throwable {\n+        return getMethodProxy().invokeSuper(target, arguments);\n+    }\n+}\n--- a/src/org/mockito/internal/creation/cglib/CGLIBHacker.java\n+++ b/src/org/mockito/internal/creation/cglib/CGLIBHacker.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.creation.cglib;\n+\n+import org.mockito.cglib.proxy.MethodProxy;\n \n import java.io.Serializable;\n import java.lang.reflect.Field;\n-\n-import org.mockito.internal.creation.MockitoMethodProxy;\n-import org.mockito.cglib.proxy.MethodProxy;\n \n public class CGLIBHacker implements Serializable {\n \n--- /dev/null\n+++ b/src/org/mockito/internal/creation/cglib/CglibMockMaker.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation.cglib;\n+\n+import org.mockito.cglib.proxy.Callback;\n+import org.mockito.cglib.proxy.Factory;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.InternalMockHandler;\n+import org.mockito.internal.creation.AcrossJVMSerializationFeature;\n+import org.mockito.internal.creation.instance.InstantiatorProvider;\n+import org.mockito.internal.creation.jmock.CglibClassImposterizer;\n+import org.mockito.invocation.MockHandler;\n+import org.mockito.mock.MockCreationSettings;\n+import org.mockito.plugins.MockMaker;\n+\n+/**\n+ * A MockMaker that uses cglib to generate mocks on a JVM.\n+ */\n+public final class CglibMockMaker implements MockMaker {\n+\n+    public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {\n+        InternalMockHandler mockitoHandler = cast(handler);\n+        new AcrossJVMSerializationFeature().enableSerializationAcrossJVM(settings);\n+        return new CglibClassImposterizer(new InstantiatorProvider().getInstantiator()).imposterise(\n+                new MethodInterceptorFilter(mockitoHandler, settings), settings.getTypeToMock(), settings.getExtraInterfaces());\n+    }\n+\n+    private InternalMockHandler cast(MockHandler handler) {\n+        if (!(handler instanceof InternalMockHandler)) {\n+            throw new MockitoException(\"At the moment you cannot provide own implementations of MockHandler.\" +\n+                    \"\\nPlease see the javadocs for the MockMaker interface.\");\n+        }\n+        return (InternalMockHandler) handler;\n+    }\n+\n+    public void resetMock(Object mock, MockHandler newHandler, MockCreationSettings settings) {\n+        ((Factory) mock).setCallback(0, new MethodInterceptorFilter(cast(newHandler), settings));\n+    }\n+\n+    public MockHandler getHandler(Object mock) {\n+        if (!(mock instanceof Factory)) {\n+            return null;\n+        }\n+        Factory factory = (Factory) mock;\n+        Callback callback = factory.getCallback(0);\n+        if (!(callback instanceof MethodInterceptorFilter)) {\n+            return null;\n+        }\n+        return ((MethodInterceptorFilter) callback).getHandler();\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/cglib/DelegatingMockitoMethodProxy.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation.cglib;\n+\n+import org.mockito.cglib.proxy.MethodProxy;\n+\n+public class DelegatingMockitoMethodProxy extends AbstractMockitoMethodProxy {\n+\n+    private final MethodProxy methodProxy;\n+\n+    public DelegatingMockitoMethodProxy(MethodProxy methodProxy) {\n+        this.methodProxy = methodProxy;\n+    }\n+\n+    public MethodProxy getMethodProxy() {\n+        return methodProxy;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/cglib/MethodInterceptorFilter.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal.creation.cglib;\n+\n+import org.mockito.cglib.proxy.MethodInterceptor;\n+import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockito.internal.InternalMockHandler;\n+import org.mockito.internal.creation.AcrossJVMSerializationFeature;\n+import org.mockito.internal.creation.DelegatingMethod;\n+import org.mockito.internal.invocation.InvocationImpl;\n+import org.mockito.internal.invocation.MockitoMethod;\n+import org.mockito.internal.invocation.SerializableMethod;\n+import org.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod;\n+import org.mockito.internal.progress.SequenceNumber;\n+import org.mockito.internal.util.ObjectMethodsGuru;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.MockHandler;\n+import org.mockito.mock.MockCreationSettings;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Method;\n+\n+/**\n+ * Should be one instance per mock instance, see CglibMockMaker.\n+ */\n+public class MethodInterceptorFilter implements MethodInterceptor, Serializable {\n+\n+    private static final long serialVersionUID = 6182795666612683784L;\n+    private final InternalMockHandler handler;\n+    CGLIBHacker cglibHacker = new CGLIBHacker();\n+    final ObjectMethodsGuru objectMethodsGuru = new ObjectMethodsGuru();\n+    private final MockCreationSettings mockSettings;\n+    private final AcrossJVMSerializationFeature acrossJVMSerializationFeature = new AcrossJVMSerializationFeature();\n+\n+    public MethodInterceptorFilter(InternalMockHandler handler, MockCreationSettings mockSettings) {\n+        this.handler = handler;\n+        this.mockSettings = mockSettings;\n+    }\n+\n+    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy)\n+            throws Throwable {\n+        if (objectMethodsGuru.isEqualsMethod(method)) {\n+            return proxy == args[0];\n+        } else if (objectMethodsGuru.isHashCodeMethod(method)) {\n+            return hashCodeForMock(proxy);\n+        } else if (acrossJVMSerializationFeature.isWriteReplace(method)) {\n+            return acrossJVMSerializationFeature.writeReplace(proxy);\n+        }\n+        \n+        MockitoMethodProxy mockitoMethodProxy = createMockitoMethodProxy(methodProxy);\n+        cglibHacker.setMockitoNamingPolicy(mockitoMethodProxy);\n+        \n+        MockitoMethod mockitoMethod = createMockitoMethod(method);\n+        \n+        FilteredCGLIBProxyRealMethod realMethod = new FilteredCGLIBProxyRealMethod(mockitoMethodProxy);\n+        Invocation invocation = new InvocationImpl(proxy, mockitoMethod, args, SequenceNumber.next(), realMethod);\n+        return handler.handle(invocation);\n+    }\n+   \n+    public MockHandler getHandler() {\n+        return handler;\n+    }\n+\n+    private int hashCodeForMock(Object mock) {\n+        return System.identityHashCode(mock);\n+    }\n+\n+    public MockitoMethodProxy createMockitoMethodProxy(MethodProxy methodProxy) {\n+        if (mockSettings.isSerializable())\n+            return new SerializableMockitoMethodProxy(methodProxy);\n+        return new DelegatingMockitoMethodProxy(methodProxy);\n+    }\n+    \n+    public MockitoMethod createMockitoMethod(Method method) {\n+        if (mockSettings.isSerializable()) {\n+            return new SerializableMethod(method);\n+        } else {\n+            return new DelegatingMethod(method);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/cglib/MockitoMethodProxy.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation.cglib;\n+\n+import org.mockito.cglib.proxy.MethodProxy;\n+\n+public interface MockitoMethodProxy {\n+\n+    Object invokeSuper(Object target, Object[] arguments) throws Throwable;\n+\n+    MethodProxy getMethodProxy();\n+\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/cglib/SerializableMockitoMethodProxy.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation.cglib;\n+\n+import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockito.internal.util.reflection.Whitebox;\n+\n+import java.io.Serializable;\n+\n+public class SerializableMockitoMethodProxy extends AbstractMockitoMethodProxy implements Serializable {\n+\n+    private static final long serialVersionUID = -5337859962876770632L;\n+    private final Class<?> c1;\n+    private final Class<?> c2;\n+    private final String desc;\n+    private final String name;\n+    private final String superName;\n+    private transient MethodProxy methodProxy;\n+\n+    public SerializableMockitoMethodProxy(MethodProxy methodProxy) {\n+        Object info = Whitebox.getInternalState(methodProxy, \"createInfo\");\n+        c1 = (Class<?>) Whitebox.getInternalState(info, \"c1\");\n+        c2 = (Class<?>) Whitebox.getInternalState(info, \"c2\");\n+        desc = methodProxy.getSignature().getDescriptor();\n+        name = methodProxy.getSignature().getName();\n+        superName = methodProxy.getSuperName();\n+        this.methodProxy = methodProxy;\n+    }\n+\n+    public MethodProxy getMethodProxy() {\n+        if (methodProxy == null)\n+            methodProxy = MethodProxy.create(c1, c2, desc, name, superName);\n+        return methodProxy;\n+    }\n+}\n--- a/src/org/mockito/internal/invocation/realmethod/CGLIBProxyRealMethod.java\n+++ b/src/org/mockito/internal/invocation/realmethod/CGLIBProxyRealMethod.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.invocation.realmethod;\n \n+import org.mockito.internal.creation.cglib.MockitoMethodProxy;\n+\n import java.io.Serializable;\n-\n-import org.mockito.internal.creation.MockitoMethodProxy;\n \n \n public class CGLIBProxyRealMethod implements RealMethod, HasCGLIBMethodProxy, Serializable {\n--- a/src/org/mockito/internal/invocation/realmethod/FilteredCGLIBProxyRealMethod.java\n+++ b/src/org/mockito/internal/invocation/realmethod/FilteredCGLIBProxyRealMethod.java\n  */\n package org.mockito.internal.invocation.realmethod;\n \n-import org.mockito.internal.creation.MockitoMethodProxy;\n+import org.mockito.internal.creation.cglib.MockitoMethodProxy;\n import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;\n \n import java.io.Serializable;\n--- a/src/org/mockito/internal/invocation/realmethod/HasCGLIBMethodProxy.java\n+++ b/src/org/mockito/internal/invocation/realmethod/HasCGLIBMethodProxy.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.invocation.realmethod;\n \n+import org.mockito.internal.creation.cglib.MockitoMethodProxy;\n+\n import java.io.Serializable;\n-\n-import org.mockito.internal.creation.MockitoMethodProxy;\n \n public interface HasCGLIBMethodProxy extends Serializable {\n \n--- a/test/org/mockito/internal/creation/cglib/CGLIBHackerTest.java\n+++ b/test/org/mockito/internal/creation/cglib/CGLIBHackerTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.creation.cglib;\n-\n-import static org.mockito.Mockito.spy;\n \n import org.junit.Test;\n import org.mockito.cglib.core.NamingPolicy;\n-import org.mockito.internal.creation.MockitoMethodProxy;\n import org.mockitoutil.TestBase;\n import org.powermock.reflect.Whitebox;\n+\n+import static org.mockito.Mockito.spy;\n \n public class CGLIBHackerTest extends TestBase {\n \n--- /dev/null\n+++ b/test/org/mockito/internal/creation/cglib/MethodInterceptorFilterTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation.cglib;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockito.internal.InternalMockHandler;\n+import org.mockito.internal.creation.DelegatingMethod;\n+import org.mockito.internal.creation.MockSettingsImpl;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.invocation.InvocationImpl;\n+import org.mockito.internal.invocation.MockitoMethod;\n+import org.mockito.internal.invocation.SerializableMethod;\n+import org.mockitousage.MethodsImpl;\n+import org.mockitoutil.TestBase;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectOutputStream;\n+import java.lang.reflect.Method;\n+\n+import static org.hamcrest.core.IsInstanceOf.instanceOf;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.withSettings;\n+\n+public class MethodInterceptorFilterTest extends TestBase {\n+\n+    InternalMockHandler handler = Mockito.mock(InternalMockHandler.class);\n+    MethodInterceptorFilter filter = new MethodInterceptorFilter(handler, (MockSettingsImpl) withSettings());\n+\n+    @Before\n+    public void setUp() {\n+        filter.cglibHacker = Mockito.mock(CGLIBHacker.class);        \n+    }\n+\n+    @Test\n+    public void shouldBeSerializable() throws Exception {\n+        new ObjectOutputStream(new ByteArrayOutputStream()).writeObject(new MethodInterceptorFilter(null, null));\n+    }\n+\n+    @Test\n+    public void shouldProvideOwnImplementationOfHashCode() throws Throwable {\n+        //when\n+        Object ret = filter.intercept(new MethodsImpl(), MethodsImpl.class.getMethod(\"hashCode\"), new Object[0], null);\n+\n+        //then\n+        assertTrue((Integer) ret != 0);\n+        Mockito.verify(handler, never()).handle(any(InvocationImpl.class));\n+    }\n+\n+    @Test\n+    public void shouldProvideOwnImplementationOfEquals() throws Throwable {\n+        //when\n+        MethodsImpl proxy = new MethodsImpl();\n+        Object ret = filter.intercept(proxy, MethodsImpl.class.getMethod(\"equals\", Object.class), new Object[] {proxy}, null);\n+\n+        //then\n+        assertTrue((Boolean) ret);\n+        Mockito.verify(handler, never()).handle(any(InvocationImpl.class));\n+    }\n+    \n+    //TODO: move to separate factory\n+    @Test\n+    public void shouldCreateSerializableMethodProxyIfIsSerializableMock() throws Exception {\n+        MethodInterceptorFilter filter = new MethodInterceptorFilter(handler, (MockSettingsImpl) withSettings().serializable());\n+        MethodProxy methodProxy = MethodProxy.create(String.class, String.class, \"\", \"toString\", \"toString\");\n+        \n+        // when\n+        MockitoMethodProxy mockitoMethodProxy = filter.createMockitoMethodProxy(methodProxy);\n+        \n+        // then\n+        assertThat(mockitoMethodProxy, instanceOf(SerializableMockitoMethodProxy.class));\n+    }\n+    \n+    @Test\n+    public void shouldCreateNONSerializableMethodProxyIfIsNotSerializableMock() throws Exception {\n+        MethodInterceptorFilter filter = new MethodInterceptorFilter(handler, (MockSettingsImpl) withSettings());\n+        MethodProxy methodProxy = MethodProxy.create(String.class, String.class, \"\", \"toString\", \"toString\");\n+        \n+        // when\n+        MockitoMethodProxy mockitoMethodProxy = filter.createMockitoMethodProxy(methodProxy);\n+        \n+        // then\n+        assertThat(mockitoMethodProxy, instanceOf(DelegatingMockitoMethodProxy.class));\n+    }\n+    \n+    @Test\n+    public void shouldCreateSerializableMethodIfIsSerializableMock() throws Exception {\n+        MethodInterceptorFilter filter = new MethodInterceptorFilter(handler, (MockSettingsImpl) withSettings().serializable());\n+        Method method = new InvocationBuilder().toInvocation().getMethod();\n+        \n+        // when\n+        MockitoMethod mockitoMethod = filter.createMockitoMethod(method);\n+        \n+        // then\n+        assertThat(mockitoMethod, instanceOf(SerializableMethod.class));\n+    }\n+    \n+    @Test\n+    public void shouldCreateJustDelegatingMethodIfIsNotSerializableMock() throws Exception {\n+        MethodInterceptorFilter filter = new MethodInterceptorFilter(handler, (MockSettingsImpl) withSettings());\n+        Method method = new InvocationBuilder().toInvocation().getMethod();\n+        \n+        // when\n+        MockitoMethod mockitoMethod = filter.createMockitoMethod(method);\n+        \n+        // then\n+        assertThat(mockitoMethod, instanceOf(DelegatingMethod.class));\n+    }\n+}\n--- a/test/org/mockito/internal/creation/cglib/MethodProxyBuilder.java\n+++ b/test/org/mockito/internal/creation/cglib/MethodProxyBuilder.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.creation.cglib;\n \n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.when;\n-\n-import org.mockito.internal.creation.MockitoMethodProxy;\n import org.mockito.internal.invocation.ExposedInvocation;\n import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.invocation.InvocationOnMock;\n import org.mockito.stubbing.Answer;\n import org.mockitousage.IMethods;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n \n public class MethodProxyBuilder {\n \n--- /dev/null\n+++ b/test/org/mockito/internal/creation/cglib/SerializableMockitoMethodProxyTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation.cglib;\n+\n+import org.junit.Test;\n+import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockitoutil.TestBase;\n+import org.powermock.reflect.Whitebox;\n+\n+public class SerializableMockitoMethodProxyTest extends TestBase {\n+\n+    @Test\n+    public void shouldCreateCorrectCreationInfo() throws Exception {\n+        // given\n+        MethodProxy proxy = MethodProxy.create(String.class, Integer.class, \"\", \"\", \"\");\n+        SerializableMockitoMethodProxy serializableMockitoMethodProxy = new SerializableMockitoMethodProxy(proxy);\n+\n+        // when\n+        Object methodProxy = Whitebox.invokeMethod(serializableMockitoMethodProxy, \"getMethodProxy\",  new Object[0]);\n+\n+        // then\n+        Object info = Whitebox.getInternalState(methodProxy, \"createInfo\");\n+        assertEquals(String.class, Whitebox.getInternalState(info, \"c1\"));\n+        assertEquals(Integer.class, Whitebox.getInternalState(info, \"c2\"));\n+    }\n+\n+    @Test\n+    public void shouldCreateCorrectSignatures() throws Exception {\n+        // given\n+        MethodProxy proxy = MethodProxy.create(String.class, Integer.class, \"a\", \"b\", \"c\");\n+        SerializableMockitoMethodProxy serializableMockitoMethodProxy = new SerializableMockitoMethodProxy(proxy);\n+\n+        // when\n+        MethodProxy methodProxy = (MethodProxy) Whitebox.invokeMethod(serializableMockitoMethodProxy, \"getMethodProxy\",  new Object[0]);\n+\n+        // then\n+        assertEquals(\"a\", methodProxy.getSignature().getDescriptor());\n+        assertEquals(\"b\", methodProxy.getSignature().getName());\n+        assertEquals(\"c\", methodProxy.getSuperName());\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"SerializableMockitoMethodProxyTest []\";\n+    }\n+\n+}\n--- a/test/org/mockito/internal/invocation/ExposedInvocation.java\n+++ b/test/org/mockito/internal/invocation/ExposedInvocation.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.invocation;\n \n-import org.mockito.internal.creation.MockitoMethodProxy;\n+import org.mockito.internal.creation.cglib.MockitoMethodProxy;\n import org.mockito.internal.invocation.realmethod.HasCGLIBMethodProxy;\n \n public class ExposedInvocation {", "timestamp": 1413585508, "metainfo": ""}