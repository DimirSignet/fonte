{"sha": "98f7799a2bf0e2016eb4c7e0cce46e17fb796966", "log": "Externalized the reponsiblity to notify listeners from MockHandler. Some renaming here and there.  --HG-- branch : issue148 rename : src/org/mockito/invocation/InvocationListener.java => src/org/mockito/listeners/InvocationListener.java rename : src/org/mockito/invocation/MethodCallReport.java => src/org/mockito/listeners/MethodInvocationReport.java", "commit": "\n--- a/src/org/mockito/MockSettings.java\n+++ b/src/org/mockito/MockSettings.java\n  */\n package org.mockito;\n \n-import org.mockito.invocation.InvocationListener;\n+import org.mockito.listeners.InvocationListener;\n import org.mockito.stubbing.Answer;\n \n import java.io.Serializable;\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n import org.mockito.internal.exceptions.VerificationAwareInvocation;\n import org.mockito.internal.exceptions.util.ScenarioPrinter;\n import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.util.StringJoiner;\n+import org.mockito.listeners.InvocationListener;\n \n import java.lang.reflect.Field;\n import java.util.List;\n     }\n \n     public void invocationListenerDoesNotAcceptNullParameters() {\n-        throw new MockitoException(join(\n-                \"invocationListeners() does not accept null parameters\"\n-        ));\n+        throw new MockitoException(\"invocationListeners() does not accept null parameters\");\n     }\n \n     public void invocationListenersRequiresAtLeastOneListener() {\n-        throw new MockitoException(join(\n-                \"invocationListeners() requires at least one listener\"\n-        ));\n-    }\n+        throw new MockitoException(\"invocationListeners() requires at least one listener\");\n+    }\n+\n+    public void invocationListenerThrewException(InvocationListener listener, Throwable listenerThrowable) {\n+        throw new MockitoException(StringJoiner.join(\n+                \"The invocation listener with type \" + listener.getClass().getName(),\n+                \"threw an exception : \" + listenerThrowable.getClass().getName() + listenerThrowable.getMessage()), listenerThrowable);\n+    }\n+\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/InvocationNotifierHandler.java\n+package org.mockito.internal;\n+\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.creation.MockSettingsImpl;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.listeners.NotifiedMethodInvocationReport;\n+import org.mockito.internal.stubbing.InvocationContainer;\n+import org.mockito.listeners.InvocationListener;\n+import org.mockito.stubbing.Answer;\n+import org.mockito.stubbing.VoidMethodStubbable;\n+\n+import java.util.List;\n+\n+/**\n+ * Handler, that call all listeners wanted for this mock, before delegating it\n+ * to the parameterized handler.\n+ *\n+ * Also imposterize MockHandler, delegate all call of MockHandlerInterface to the real mockHandler\n+ */\n+public class InvocationNotifierHandler<T> implements MockitoInvocationHandler, MockHandlerInterface<T>  {\n+\n+    private List<InvocationListener> invocationListeners;\n+    private MockHandler<T> mockHandler;\n+\n+    public InvocationNotifierHandler(MockHandler<T> mockHandler, MockSettingsImpl settings) {\n+        this.mockHandler = mockHandler;\n+        this.invocationListeners = settings.getInvocationListeners();\n+    }\n+\n+    public Object handle(Invocation invocation) throws Throwable {\n+        try {\n+            Object returnedValue = mockHandler.handle(invocation);\n+            notifyMethodCall(invocation, returnedValue);\n+            return returnedValue;\n+        } catch (Throwable t){\n+            notifyMethodCallException(invocation, t);\n+            throw t;\n+        }\n+    }\n+\n+\n+\tprivate void notifyMethodCall(Invocation invocation, Object returnValue) {\n+\t\tfor (InvocationListener listener : invocationListeners) {\n+            try {\n+                listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, returnValue));\n+            } catch(Throwable listenerThrowable) {\n+                new Reporter().invocationListenerThrewException(listener, listenerThrowable);\n+            }\n+        }\n+\t}\n+\n+    private void notifyMethodCallException(Invocation invocation, Throwable exception) {\n+\t\tfor (InvocationListener listener : invocationListeners) {\n+            try {\n+                listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, exception));\n+            } catch(Throwable listenerThrowable) {\n+                new Reporter().invocationListenerThrewException(listener, listenerThrowable);\n+            }\n+        }\n+\t}\n+\n+    public MockSettingsImpl getMockSettings() {\n+        return mockHandler.getMockSettings();\n+    }\n+\n+    public VoidMethodStubbable<T> voidMethodStubbable(T mock) {\n+        return mockHandler.voidMethodStubbable(mock);\n+    }\n+\n+    public void setAnswersForStubbing(List<Answer> answers) {\n+        mockHandler.setAnswersForStubbing(answers);\n+    }\n+\n+    public InvocationContainer getInvocationContainer() {\n+        return mockHandler.getInvocationContainer();\n+    }\n+\n+}\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n  */\n package org.mockito.internal;\n \n-import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.ThreadSafeMockingProgress;\n import org.mockito.internal.stubbing.*;\n-import org.mockito.internal.util.StringJoiner;\n import org.mockito.internal.verification.MockAwareVerificationMode;\n import org.mockito.internal.verification.VerificationDataImpl;\n-import org.mockito.invocation.InvocationListener;\n-import org.mockito.invocation.MethodCallReport;\n import org.mockito.stubbing.Answer;\n import org.mockito.stubbing.VoidMethodStubbable;\n import org.mockito.verification.VerificationMode;\n     }\n \n     public Object handle(Invocation invocation) throws Throwable {\n-    \ttry {\n-    \t\tObject returnValue = handleAllTypesOfInvocations(invocation);\n-    \t\tnotifyAllListenerOfInvocationWithReturnValue(invocation, returnValue);\n-    \t\treturn returnValue;\n-    \t} catch(Exception e) {\n-    \t\tnotifyAllListenerOfInvocationWithException(invocation, e);\n-    \t\tthrow e;\n-    \t}\n-    }\n-\n-\tprivate Object handleAllTypesOfInvocations(Invocation invocation)\n-\t\t\tthrows Throwable {\n \t\tif (invocationContainerImpl.hasAnswersForStubbing()) {\n             // stubbing voids with stubVoid() or doAnswer() style\n             InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(\n             // We need to check if verification was started on the correct mock\n             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n             // TODO: can I avoid this cast here?\n-            if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n-                VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n+            if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {\n+                VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);\n                 verificationMode.verify(data);\n                 return null;\n             } else {\n-                // this means there is an invocation on a different mock. Re-adding verification mode \n+                // this means there is an invocation on a different mock. Re-adding verification mode\n                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n                 mockingProgress.verificationStarted(verificationMode);\n             }\n     public InvocationContainer getInvocationContainer() {\n         return invocationContainerImpl;\n     }\n-    \n-\tprivate void notifyAllListenerOfInvocationWithReturnValue(Invocation invocation, Object returnValue) {\n-\t\tfor (InvocationListener listener : mockSettings.getInvocationListeners()) {\n-\t\t\tnotifyListenerOfInvocationWithReturnValue(invocation, returnValue, listener);\n-    \t} \n-\t}\n+}\n \n-\tprivate void notifyAllListenerOfInvocationWithException(Invocation invocation, Exception exception) {\n-\t\tfor (InvocationListener listener : mockSettings.getInvocationListeners()) {\n-\t\t\tnotifyListenerOfInvocationWithException(invocation, exception, listener);\n-\t\t} \n-\t}\n-\t\n-\tprivate void notifyListenerOfInvocationWithReturnValue(Invocation invocation, Object returnValue, InvocationListener listener) {\n-\t\ttry {\n-\t\t\tlistener.reportInvocation(MethodCallReport.of(invocation, returnValue, getStubbingLocationOrNull(invocation)));\n-\t\t} catch(RuntimeException e) {\n-\t\t\tthrow new MockitoException(StringJoiner.join(\"An invocation listener threw an exception.\",\n-\t\t\t\t\t\"The listener has the class \" + listener.getClass().getName()), e);\n-\t\t}\n-\t}\n-\t\n-\tprivate void notifyListenerOfInvocationWithException(Invocation invocation, Exception exception, InvocationListener listener) {\n-\t\ttry {\n-\t\t\tlistener.reportInvocation(MethodCallReport.of(invocation, exception, getStubbingLocationOrNull(invocation)));\n-\t\t} catch(RuntimeException e) {\n-\t\t\tthrow new MockitoException(StringJoiner.join(\"An invocation listener threw an exception.\",\n-\t\t\t\t\t\"The listener has the class \" + listener.getClass().getName()), e);\n-\t\t}\n-\t}\n-\n-\tprivate String getStubbingLocationOrNull(Invocation invocation) {\n-\t\treturn (invocation.stubInfo() == null) ? null : invocation.stubInfo().stubbedAt();\n-\t}\n-}\n--- a/src/org/mockito/internal/creation/MockSettingsImpl.java\n+++ b/src/org/mockito/internal/creation/MockSettingsImpl.java\n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.debugging.VerboseMockInvocationLogger;\n import org.mockito.internal.util.MockName;\n-import org.mockito.invocation.InvocationListener;\n+import org.mockito.listeners.InvocationListener;\n import org.mockito.stubbing.Answer;\n \n import java.util.ArrayList;\n--- a/src/org/mockito/internal/debugging/VerboseMockInvocationLogger.java\n+++ b/src/org/mockito/internal/debugging/VerboseMockInvocationLogger.java\n package org.mockito.internal.debugging;\n \n import org.mockito.exceptions.PrintableInvocation;\n-import org.mockito.invocation.InvocationListener;\n-import org.mockito.invocation.MethodCallReport;\n+import org.mockito.listeners.InvocationListener;\n+import org.mockito.listeners.MethodInvocationReport;\n \n import java.io.PrintStream;\n \n         this.printStream = printStream;\n     }\n \n-    public void reportInvocation(MethodCallReport methodCallReport) {\n-        if (methodCallReport.threwException()) {\n-            onCallWithThrowable(\n-                    methodCallReport.getInvocation(),\n-                    methodCallReport.getThrowable(),\n-                    methodCallReport.getLocationOfStubbing()\n-            );\n+    public void reportInvocation(MethodInvocationReport methodInvocationReport) {\n+        printHeader();\n+        printStubInfo(methodInvocationReport);\n+        printInvocation(methodInvocationReport.getInvocation());\n+        printReturnedValueOrThrowable(methodInvocationReport);\n+        printFooter();\n+    }\n+\n+    private void printReturnedValueOrThrowable(MethodInvocationReport methodInvocationReport) {\n+        if (methodInvocationReport.threwException()) {\n+            String message = methodInvocationReport.getThrowable().getMessage() == null ? \"\" : \" with message \" + methodInvocationReport.getThrowable().getMessage();\n+            printlnIndented(\"has thrown: \" + methodInvocationReport.getThrowable().getClass() + message);\n         } else {\n-            onNormalCall(\n-                    methodCallReport.getInvocation(),\n-                    methodCallReport.getReturnedValue(),\n-                    methodCallReport.getLocationOfStubbing()\n-            );\n+            String type = (methodInvocationReport.getReturnedValue() == null) ? \"\" : \" (\" + methodInvocationReport.getReturnedValue().getClass().getName() + \")\";\n+            printlnIndented(\"has returned: \\\"\" + methodInvocationReport.getReturnedValue() + \"\\\"\" + type);\n         }\n     }\n \n-    private void onNormalCall(PrintableInvocation invocation, Object returnedValue, String locationOfStubbing) {\n-\t\tprintHeader();\n-\t\tprintCommonInfos(invocation);\n-\t\tprintlnIndented(\"has returned: \\\"\" + returnedValue + \"\\\"\" + ((returnedValue == null) ? \"\" : \" (\" + returnedValue.getClass().getName() + \")\"));\n-\t\tif (locationOfStubbing == null) {\n-\t\t\tprintMethodHasNotBeenStubbed();\n-\t\t} else {\n-\t\t\tprintMethodHasBeenStubbed(locationOfStubbing);\n-\t\t}\n-\t\tprintFooter();\n-\t}\n+    private void printStubInfo(MethodInvocationReport methodInvocationReport) {\n+        if (methodInvocationReport.getLocationOfStubbing() != null) {\n+            printlnIndented(\"stubbed: \" + methodInvocationReport.getLocationOfStubbing());\n+        }\n+    }\n \n-\tprivate void onCallWithThrowable(PrintableInvocation invocation, Throwable throwable, String locationOfStubbing) {\n-\t\tprintHeader();\n-\t\tprintCommonInfos(invocation);\n-\t\tprintlnIndented(\"has thrown: \" + throwable.getClass() + \" with message \" + throwable.getMessage());\n-\t\tif (locationOfStubbing == null) {\n-\t\t\tprintMethodHasNotBeenStubbed();\n-\t\t} else {\n-\t\t\tprintMethodHasBeenStubbed(locationOfStubbing);\n-\t\t}\n-\t\tprintFooter();\n-\t}\n-\n-\tprivate void printHeader() {\n+    private void printHeader() {\n \t\tmockInvocationsCounter++;\n \t\tprintStream.println(\"############ Logging method invocation #\" + mockInvocationsCounter + \" on mock/spy ########\");\n \t}\n-\t\n-\tprivate void printMethodHasNotBeenStubbed() {\n-\t\tprintlnIndented(\"Method has not been stubbed.\");\n-\t}\n \n-\tprivate void printMethodHasBeenStubbed(String locationOfStubbing) {\n-\t\tprintlnIndented(\"Method has been stubbed.\");\n-\t\tprintlnIndented(locationOfStubbing);\n-\t}\n-\n-\tprivate void printCommonInfos(PrintableInvocation invocation) {\n+    private void printInvocation(PrintableInvocation invocation) {\n \t\tprintStream.println(invocation.toString());\n //\t\tprintStream.println(\"Handling method call on a mock/spy.\");\n-\t\tprintlnIndented(invocation.getLocation().toString());\n+\t\tprintlnIndented(\"invoked: \" + invocation.getLocation().toString());\n \t}\n \n \tprivate void printFooter() {\n--- /dev/null\n+++ b/src/org/mockito/internal/listeners/NotifiedMethodInvocationReport.java\n+package org.mockito.internal.listeners;\n+\n+import org.mockito.exceptions.PrintableInvocation;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.listeners.MethodInvocationReport;\n+\n+/**\n+ * Report on a method call\n+ */\n+public class NotifiedMethodInvocationReport implements MethodInvocationReport {\n+        private final Invocation invocation;\n+        private Object returnedValue;\n+        private Throwable throwable;\n+\n+\n+        /**\n+         * Build a new {@link org.mockito.listeners.MethodInvocationReport} with a return value.\n+         *\n+         *\n+         * @param invocation Information on the method call\n+         * @param returnedValue The value returned by the method invocation\n+         */\n+        public NotifiedMethodInvocationReport(Invocation invocation, Object returnedValue) {\n+            this.invocation = invocation;\n+            this.returnedValue = returnedValue;\n+        }\n+\n+        /**\n+         * Build a new {@link org.mockito.listeners.MethodInvocationReport} with a return value.\n+         *\n+         *\n+         * @param invocation Information on the method call\n+         * @param throwable Tha throwable raised by the method invocation\n+         */\n+        public NotifiedMethodInvocationReport(Invocation invocation, Throwable throwable) {\n+            this.invocation = invocation;\n+            this.throwable = throwable;\n+        }\n+\n+        public PrintableInvocation getInvocation() {\n+            return invocation;\n+        }\n+\n+        public Object getReturnedValue() {\n+            return returnedValue;\n+        }\n+\n+        public Throwable getThrowable() {\n+            return throwable;\n+        }\n+\n+        public boolean threwException() {\n+            return throwable != null;\n+        }\n+\n+        public String getLocationOfStubbing() {\n+            return (invocation.stubInfo() == null) ? null : invocation.stubInfo().stubbedAt();\n+        }\n+\n+\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+\n+            NotifiedMethodInvocationReport that = (NotifiedMethodInvocationReport) o;\n+\n+            if (invocation != null ? !invocation.equals(that.invocation) : that.invocation != null) return false;\n+            if (returnedValue != null ? !returnedValue.equals(that.returnedValue) : that.returnedValue != null)\n+                return false;\n+            if (throwable != null ? !throwable.equals(that.throwable) : that.throwable != null) return false;\n+\n+            return true;\n+        }\n+\n+        public int hashCode() {\n+            int result = invocation != null ? invocation.hashCode() : 0;\n+            result = 31 * result + (returnedValue != null ? returnedValue.hashCode() : 0);\n+            result = 31 * result + (throwable != null ? throwable.hashCode() : 0);\n+            return result;\n+        }\n+    }\n--- a/src/org/mockito/internal/util/ConsoleMockitoLogger.java\n+++ b/src/org/mockito/internal/util/ConsoleMockitoLogger.java\n      * @see org.mockito.internal.util.Logger#print(java.lang.Object)\n      */\n     public void log(Object what) {\n-        System.out.print(what.toString());\n+        System.out.print(what);\n     }\n-}\n+}\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n  */\n package org.mockito.internal.util;\n \n-import static org.mockito.Mockito.RETURNS_DEFAULTS;\n-import static org.mockito.Mockito.withSettings;\n-\n-import org.mockito.cglib.proxy.*;\n+import org.mockito.cglib.proxy.Callback;\n+import org.mockito.cglib.proxy.Factory;\n import org.mockito.exceptions.misusing.NotAMockException;\n+import org.mockito.internal.InvocationNotifierHandler;\n import org.mockito.internal.MockHandler;\n import org.mockito.internal.MockHandlerInterface;\n import org.mockito.internal.creation.MethodInterceptorFilter;\n import org.mockito.internal.util.reflection.LenientCopyTool;\n \n import java.io.Serializable;\n+\n+import static org.mockito.Mockito.RETURNS_DEFAULTS;\n+import static org.mockito.Mockito.withSettings;\n \n @SuppressWarnings(\"unchecked\")\n public class MockUtil {\n         settings.initiateMockName(classToMock);\n \n         MockHandler<T> mockHandler = new MockHandler<T>(settings);\n-        MethodInterceptorFilter filter = new MethodInterceptorFilter(mockHandler, settings);\n+        InvocationNotifierHandler<T> invocationNotifierHandler = new InvocationNotifierHandler<T>(mockHandler, settings);\n+        MethodInterceptorFilter filter = new MethodInterceptorFilter(invocationNotifierHandler, settings);\n         Class<?>[] interfaces = settings.getExtraInterfaces();\n \n         Class<?>[] ancillaryTypes;\n     public MockName getMockName(Object mock) {\n         return getMockHandler(mock).getMockSettings().getMockName();\n     }\n-}\n+}\n--- a/src/org/mockito/internal/util/StringJoiner.java\n+++ b/src/org/mockito/internal/util/StringJoiner.java\n \n     public static String join(Object ... linesToBreak) {\n         StringBuilder out = new StringBuilder(\"\\n\");\n+        return join(out, linesToBreak);\n+    }\n+\n+    private static String join(StringBuilder out, Object[] linesToBreak) {\n         for (Object line : linesToBreak) {\n             out.append(line.toString()).append(\"\\n\");\n         }\n         int lastBreak = out.lastIndexOf(\"\\n\");\n         return out.replace(lastBreak, lastBreak+1, \"\").toString();\n     }\n-}\n+}\n--- /dev/null\n+++ b/src/org/mockito/listeners/InvocationListener.java\n+/*\n+ * Copyright (c) 2011 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.listeners;\n+\n+import org.mockito.MockSettings;\n+\n+/**\n+ * This listener can be notified of method invocations on a mock.\n+ * \n+ * For this to happen, it must be registered using {@link MockSettings#invocationListeners(InvocationListener...)}.\n+ */\n+public interface InvocationListener {\n+\t\n+\t/**\n+\t * Called after the invocation of the listener's mock if it returned normally.\n+\t *\n+     * <p>\n+     * Exceptions caused by this invocationListener will raise a {@link org.mockito.exceptions.base.MockitoException}.\n+     * </p>\n+\t *\n+\t * @param methodInvocationReport Information about the method call that just happened.\n+     *\n+     * @see MethodInvocationReport\n+\t */\n+\tvoid reportInvocation(MethodInvocationReport methodInvocationReport);\n+}\n--- /dev/null\n+++ b/src/org/mockito/listeners/MethodInvocationReport.java\n+package org.mockito.listeners;\n+\n+import org.mockito.exceptions.PrintableInvocation;\n+\n+/**\n+ * Represent a method call on a mock.\n+ *\n+ * <p>\n+ *     Contains the information on the mock, the location of the stub\n+ *     the return value if it returned something (maybe null), or an\n+ *     exception if one was thrown when the method was invoked.\n+ * </p>\n+ */\n+public interface MethodInvocationReport {\n+    /**\n+     * @return Information on the method call, never {@code null}\n+     */\n+    PrintableInvocation getInvocation();\n+\n+    /**\n+     * @return The resulting value of the method invocation, may be <code>null</code>\n+     */\n+    Object getReturnedValue();\n+\n+    /**\n+     * @return The throwable raised by the method invocation, maybe <code>null</code>\n+     */\n+    Throwable getThrowable();\n+\n+    /**\n+     * @return <code>true</code> if an exception was raised, <code>false</code> otherwise\n+     */\n+    boolean threwException();\n+\n+    /**\n+     * @return Location of the stub invocation\n+     */\n+    String getLocationOfStubbing();\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/InvocationNotifierHandlerTest.java\n+package org.mockito.internal;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.creation.MockSettingsImpl;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.listeners.NotifiedMethodInvocationReport;\n+import org.mockito.listeners.InvocationListener;\n+import org.mockito.listeners.MethodInvocationReport;\n+import org.mockito.runners.MockitoJUnitRunner;\n+import org.mockito.stubbing.Answer;\n+import org.mockitousage.IMethods;\n+\n+import java.text.ParseException;\n+import java.util.ArrayList;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.BDDMockito.willThrow;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyList;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+\n+\n+@RunWith(MockitoJUnitRunner.class)\n+@SuppressWarnings(\"unchecked\")\n+public class InvocationNotifierHandlerTest {\n+    private static final String SOME_LOCATION = \"some location\";\n+    private static final RuntimeException SOME_EXCEPTION = new RuntimeException();\n+    private static final OutOfMemoryError SOME_ERROR = new OutOfMemoryError();\n+    private static final Answer SOME_ANSWER = mock(Answer.class);\n+\n+\n+    @Mock private InvocationListener listener1;\n+    @Mock private InvocationListener listener2;\n+    @Spy private CustomListener customListener;\n+\n+    @Mock private Invocation invocation;\n+    @Mock private MockHandler mockHandler;\n+\n+    private InvocationNotifierHandler notifier;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        notifier = new InvocationNotifierHandler(\n+                mockHandler,\n+                (MockSettingsImpl) new MockSettingsImpl().invocationListeners(customListener, listener1, listener2)\n+        );\n+    }\n+\n+    @Test\n+    public void should_notify_all_listeners_when_calling_delegate_handler() throws Throwable {\n+        // given\n+        given(mockHandler.handle(invocation)).willReturn(\"returned value\");\n+\n+        // when\n+        notifier.handle(invocation);\n+\n+        // then\n+        verify(listener1).reportInvocation(new NotifiedMethodInvocationReport(invocation, \"returned value\"));\n+        verify(listener2).reportInvocation(new NotifiedMethodInvocationReport(invocation, \"returned value\"));\n+    }\n+\n+    @Test\n+    public void should_notify_all_listeners_when_called_delegate_handler_returns_ex() throws Throwable {\n+        // given\n+        Exception computedException = new Exception(\"computed\");\n+        given(mockHandler.handle(invocation)).willReturn(computedException);\n+\n+        // when\n+        notifier.handle(invocation);\n+\n+        // then\n+        verify(listener1).reportInvocation(new NotifiedMethodInvocationReport(invocation, (Object) computedException));\n+        verify(listener2).reportInvocation(new NotifiedMethodInvocationReport(invocation, (Object) computedException));\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    public void should_notify_all_listeners_when_called_delegate_handler_throws_exception_and_rethrow_it() throws Throwable {\n+        // given\n+        ParseException parseException = new ParseException(\"\", 0);\n+        given(mockHandler.handle(invocation)).willThrow(parseException);\n+\n+        // when\n+        try {\n+            notifier.handle(invocation);\n+        } finally {\n+            // then\n+            verify(listener1).reportInvocation(new NotifiedMethodInvocationReport(invocation, parseException));\n+            verify(listener2).reportInvocation(new NotifiedMethodInvocationReport(invocation, parseException));\n+        }\n+    }\n+\n+    @Test\n+    public void should_report_listener_exception() throws Throwable {\n+        willThrow(new NullPointerException()).given(customListener).reportInvocation(any(MethodInvocationReport.class));\n+\n+        try {\n+            notifier.handle(invocation);\n+        } catch (MockitoException me) {\n+            assertThat(me.getMessage())\n+                    .contains(\"invocation listener\")\n+                    .contains(\"CustomListener\")\n+                    .contains(\"threw an exception\")\n+                    .contains(\"NullPointerException\");\n+        }\n+    }\n+\n+    @Test\n+    public void should_delegate_all_MockHandlerInterface_to_the_parameterized_MockHandler() throws Exception {\n+        notifier.getInvocationContainer();\n+        notifier.getMockSettings();\n+        notifier.voidMethodStubbable(mock(IMethods.class));\n+        notifier.setAnswersForStubbing(new ArrayList<Answer>());\n+\n+        verify(mockHandler).getInvocationContainer();\n+        verify(mockHandler).getMockSettings();\n+        verify(mockHandler).voidMethodStubbable(any());\n+        verify(mockHandler).setAnswersForStubbing(anyList());\n+    }\n+\n+    private static class CustomListener implements InvocationListener {\n+        public void reportInvocation(MethodInvocationReport methodInvocationReport) {\n+            // nop\n+        }\n+    }\n+}\n--- a/test/org/mockito/internal/MockHandlerTest.java\n+++ b/test/org/mockito/internal/MockHandlerTest.java\n package org.mockito.internal;\n \n import org.junit.Test;\n-import org.mockito.Mock;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n import org.mockito.internal.creation.MockSettingsImpl;\n-import org.mockito.internal.invocation.*;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.MatchersBinder;\n import org.mockito.internal.progress.ArgumentMatcherStorage;\n-import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.stubbing.InvocationContainerImpl;\n import org.mockito.internal.stubbing.StubbedInvocationMatcher;\n-import org.mockito.internal.stubbing.answers.DoesNothing;\n-import org.mockito.internal.verification.MockAwareVerificationMode;\n import org.mockito.internal.verification.VerificationModeFactory;\n-import org.mockito.invocation.InvocationListener;\n-import org.mockito.invocation.InvocationOnMock;\n-import org.mockito.invocation.MethodCallReport;\n-import org.mockito.stubbing.Answer;\n-import org.mockito.verification.VerificationMode;\n+import org.mockito.listeners.InvocationListener;\n+import org.mockito.listeners.MethodInvocationReport;\n import org.mockitoutil.TestBase;\n \n-import java.util.ArrayList;\n import java.util.Arrays;\n-import java.util.List;\n \n import static org.mockito.BDDMockito.given;\n import static org.mockito.Matchers.any;\n-import static org.mockito.Mockito.*;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.mock;\n \n @SuppressWarnings({ \"unchecked\", \"serial\" })\n public class MockHandlerTest extends TestBase {\n \n-\tprivate static final OutOfMemoryError SOME_ERROR = new OutOfMemoryError();\n-\tprivate static final RuntimeException SOME_EXCEPTION = new RuntimeException();\n-\tprivate static final String SOME_RETURN_VALUE = \"some return value\";\n-\tprivate static final String SOME_LOCATION = \"some location\";\n-\t@SuppressWarnings(\"rawtypes\")\n-\tprivate static final Answer SOME_ANSWER = mock(Answer.class);\n-\tprivate static final StubbedInvocationMatcher SOME_INVOCATION_MATCHER = mock(StubbedInvocationMatcher.class);\n-\tprivate static final Invocation SOME_INVOCATION = mock(Invocation.class);\n-\t@Mock\n-\tprivate InvocationListener listener1;\n-\t@Mock\n-\tprivate InvocationListener listener2;\n+\tprivate StubbedInvocationMatcher stubbedInvocationMatcher = mock(StubbedInvocationMatcher.class);\n+\tprivate Invocation invocation = mock(Invocation.class);\n+\n \n \t@Test\n \tpublic void shouldRemoveVerificationModeEvenWhenInvalidMatchers() throws Throwable {\n \t\tassertNull(handler.mockingProgress.pullVerificationMode());\n \t}\n \n-\t@Test\n-\tpublic void shouldNotifyInvocationHandlerDuringStubVoid() throws Throwable {\n-\t\t// given\n-\t\tMockHandler<?> handler = createHandlerWithListeners(listener1, listener2);\n-\t\tstubWithInvocationDuringStubVoid(handler);\n-\t\tInvocation invocation = createInvocationWithStubbingLocation(SOME_LOCATION);\n \n-\t\thandler.handle(invocation);\n \n-\t\t// then\n-\t\tverify(listener1).reportInvocation(MethodCallReport.of(invocation, null, SOME_LOCATION));\n-\t\tverify(listener2).reportInvocation(MethodCallReport.of(invocation, null, SOME_LOCATION));\n-\t}\n-\n-\tprivate Invocation createInvocationWithStubbingLocation(String stubbingLocation) {\n-\t\tInvocation invocation = mock(Invocation.class);\n-\n-\t\tStubInfo stubInfo = mock(StubInfo.class);\n-\t\tgiven(invocation.stubInfo()).willReturn(stubInfo);\n-\n-\t\tgiven(stubInfo.stubbedAt()).willReturn(stubbingLocation);\n-\n-\t\treturn invocation;\n-\t}\n-\n-\t@Test\n-\tpublic void shouldNotifyInvocationHandlerDuringVerification() throws Throwable {\n-\t\t// given\n-\t\tMockHandler<?> handler = createHandlerWithListeners(listener1, listener2);\n-\t\tstubProgressWithVerification(handler);\n-\t\tInvocation invocation = createInvocationWithStubbingLocation(SOME_LOCATION);\n-\n-\t\t// when\n-\t\thandler.handle(invocation);\n-\n-\t\t// then\n-\t\tverify(listener1).reportInvocation(MethodCallReport.of(invocation, null, SOME_LOCATION));\n-\t\tverify(listener2).reportInvocation(MethodCallReport.of(invocation, null, SOME_LOCATION));\n-\t}\n-\n-\t@Test\n-\tpublic void shouldNotifyInvocationHandlerDuringOrdinaryInvocationWithGivenReturnValue() throws Throwable {\n-\t\t// given\n-\t\tMockHandler<?> handler = createHandlerWithListeners(listener1, listener2);\n-\t\tstubOrdinaryInvocationWithReturnValue(handler, SOME_RETURN_VALUE);\n-\t\tInvocation invocation = createInvocationWithStubbingLocation(SOME_LOCATION);\n-\n-\t\t// when\n-\t\thandler.handle(invocation);\n-\n-\t\t// then\n-\t\tverify(listener1).reportInvocation(MethodCallReport.of(invocation, SOME_RETURN_VALUE, SOME_LOCATION));\n-\t\tverify(listener2).reportInvocation(MethodCallReport.of(invocation, SOME_RETURN_VALUE, SOME_LOCATION));\n-\t}\n-\n-\t@Test\n-\tpublic void shouldNotifyInvocationHandlerDuringOrdinaryInvocationResultingInException() throws Throwable {\n-\t\t// given\n-\t\tMockHandler<?> handler = createHandlerWithListeners(listener1, listener2);\n-\t\tstubOrdinaryInvocationWithThrowable(handler, SOME_EXCEPTION);\n-\t\tInvocation invocation = createInvocationWithStubbingLocation(SOME_LOCATION);\n-\n-\t\t// when\n-\t\ttry {\n-\t\t\thandler.handle(invocation);\n-\t\t\tfail(\"Exception was not rethrown.\");\n-\t\t} catch (RuntimeException e) {\n-\t\t\t// then\n-\t\t\tverify(listener1).reportInvocation(MethodCallReport.of(invocation, SOME_EXCEPTION, SOME_LOCATION));\n-\t\t\tverify(listener2).reportInvocation(MethodCallReport.of(invocation, SOME_EXCEPTION, SOME_LOCATION));\n-\t\t}\n-\t}\n-\n-\t@Test\n-\tpublic void shouldNotNotifyInvocationHandlerDuringOrdinaryInvocationResultingInError() throws Throwable {\n-\t\t// given\n-\t\tMockHandler<?> handler = createHandlerWithListeners(listener1, listener2);\n-\t\tstubOrdinaryInvocationWithThrowable(handler, SOME_ERROR);\n-\t\tInvocation invocation = createInvocationWithStubbingLocation(SOME_LOCATION);\n-\t\t\n-\t\t// when\n-\t\ttry {\n-\t\t\thandler.handle(invocation);\n-\t\t\tfail(\"Error was not rethrown.\");\n-\t\t} catch (Error e) {\n-\t\t\t// then\n-\t\t\tverifyZeroInteractions(listener1, listener2);\n-\t\t}\n-\t}\n-\t\n-\t@Test\n-\tpublic void shouldNotifyInvocationHandlerDuringOrdinaryInvocationWithDefaultReturnValue() throws Throwable {\n-\t\t// given\n-\t\tMockHandler<?> handler = createHandlerWithListeners(listener1, listener2);\n-\t\tstubOrdinaryInvocationWithDefaultReturnValue(handler);\n-\t\tInvocation invocation = createInvocationWithStubbingLocation(SOME_LOCATION);\n-\n-\t\t// when\n-\t\thandler.handle(invocation);\n-\n-\t\t// then\n-\t\tverify(listener1).reportInvocation(MethodCallReport.of(invocation, null, SOME_LOCATION));\n-\t\tverify(listener2).reportInvocation(MethodCallReport.of(invocation, null, SOME_LOCATION));\n-\t}\n \n \t@Test(expected = MockitoException.class)\n \tpublic void shouldThrowMockitoExceptionWhenInvocationHandlerThrowsAnything() throws Throwable {\n \t\t// given\n \t\tInvocationListener throwingListener = mock(InvocationListener.class);\n-\t\tdoThrow(SOME_EXCEPTION).when(throwingListener).reportInvocation(any(MethodCallReport.class));\n+\t\tdoThrow(new Throwable()).when(throwingListener).reportInvocation(any(MethodInvocationReport.class));\n \t\tMockHandler<?> handler = createCorrectlyStubbedHandler(throwingListener);\n \n \t\t// when\n-\t\thandler.handle(SOME_INVOCATION);\n+\t\thandler.handle(invocation);\n \t}\n+\n+\n \n \tprivate MockHandler<?> createCorrectlyStubbedHandler(InvocationListener throwingListener) {\n \t\tMockHandler<?> handler = createHandlerWithListeners(throwingListener);\n \t}\n \n \tprivate void stubOrdinaryInvocationWithGivenReturnValue(MockHandler<?> handler) {\n-\t\tstubOrdinaryInvocationWithInvocationMatcher(handler, SOME_INVOCATION_MATCHER);\n+\t\tstubOrdinaryInvocationWithInvocationMatcher(handler, stubbedInvocationMatcher);\n \t}\n \n-\tprivate void stubOrdinaryInvocationWithReturnValue(MockHandler<?> handler, Object returnValue) throws Throwable {\n-\t\tStubbedInvocationMatcher matcher = mock(StubbedInvocationMatcher.class);\n-\t\tgiven(matcher.answer(any(InvocationOnMock.class))).willReturn(returnValue);\n-\t\tstubOrdinaryInvocationWithInvocationMatcher(handler, matcher);\n-\t}\n \n-\tprivate void stubOrdinaryInvocationWithThrowable(MockHandler<?> handler, Throwable throwable) throws Throwable {\n-\t\tStubbedInvocationMatcher matcher = mock(StubbedInvocationMatcher.class);\n-\t\tgiven(matcher.answer(any(InvocationOnMock.class))).willThrow(throwable);\n-\t\tstubOrdinaryInvocationWithInvocationMatcher(handler, matcher);\n-\t}\n-\n-\tprivate void stubOrdinaryInvocationWithDefaultReturnValue(MockHandler<?> handler) {\n-\t\tgiven(handler.getMockSettings().getDefaultAnswer()).willReturn(SOME_ANSWER);\n-\t\tstubOrdinaryInvocationWithInvocationMatcher(handler, null);\n-\t}\n \n \tprivate void stubOrdinaryInvocationWithInvocationMatcher(MockHandler<?> handler, StubbedInvocationMatcher value) {\n \t\thandler.invocationContainerImpl = mock(InvocationContainerImpl.class);\n \t\tgiven(handler.invocationContainerImpl.findAnswerFor(any(Invocation.class))).willReturn(value);\n \t}\n \n-\tprivate void stubProgressWithVerification(MockHandler<?> handler) {\n-\t\thandler.mockingProgress = mock(MockingProgress.class);\n \n-\t\t// Needs to be unequal to null.\n-\t\tVerificationMode mode = mock(MockAwareVerificationMode.class);\n-\t\tgiven(handler.mockingProgress.pullVerificationMode()).willReturn(mode);\n-\t}\n \n-\t@SuppressWarnings(\"rawtypes\")\n-\tprivate void stubWithInvocationDuringStubVoid(MockHandler handler) {\n-\t\tstubWithPreviouslySetVoidAnswer(handler);\n-\t\tstubHandlerStateWithPreviousStubVoidInvocation(handler);\n-\t}\n-\n-\tprivate void stubHandlerStateWithPreviousStubVoidInvocation(MockHandler<?> handler) {\n-\t\tStubbedInvocationMatcher invocationContainer = mock(StubbedInvocationMatcher.class);\n-\t\tgiven(handler.matchersBinder.bindMatchers(any(ArgumentMatcherStorage.class), any(Invocation.class)))\n-\t\t\t\t.willReturn(invocationContainer);\n-\n-\t\tInvocation invocation = mock(Invocation.class);\n-\t\tgiven(invocationContainer.getInvocation()).willReturn(invocation);\n-\n-\t\tgiven(invocation.isVoid()).willReturn(true);\n-\t}\n-\n-\t@SuppressWarnings(\"rawtypes\")\n-\tprivate void stubWithPreviouslySetVoidAnswer(MockHandler handler) {\n-\t\tList<Answer> answers = new ArrayList<Answer>();\n-\t\tanswers.add(new DoesNothing());\n-\t\thandler.setAnswersForStubbing(answers);\n-\t}\n \n \tprivate MockHandler<?> createHandlerWithListeners(InvocationListener... listener) {\n \t\t@SuppressWarnings(\"rawtypes\")\n--- a/test/org/mockito/internal/creation/MockSettingsImplTest.java\n+++ b/test/org/mockito/internal/creation/MockSettingsImplTest.java\n import org.mockito.Mock;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.debugging.VerboseMockInvocationLogger;\n-import org.mockito.invocation.InvocationListener;\n+import org.mockito.listeners.InvocationListener;\n import org.mockitoutil.TestBase;\n \n import java.util.LinkedList;\n--- a/test/org/mockito/internal/debugging/VerboseMockInvocationLoggerTest.java\n+++ b/test/org/mockito/internal/debugging/VerboseMockInvocationLoggerTest.java\n  */\n package org.mockito.internal.debugging;\n \n+import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.exceptions.PrintableInvocation;\n-import org.mockito.invocation.MethodCallReport;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.invocation.StubInfo;\n+import org.mockito.internal.listeners.NotifiedMethodInvocationReport;\n \n import java.io.ByteArrayOutputStream;\n import java.io.PrintStream;\n \n import static org.fest.assertions.Assertions.assertThat;\n-import static org.mockito.BDDMockito.given;\n-import static org.mockito.Mockito.mock;\n \n public class VerboseMockInvocationLoggerTest {\n \n     private VerboseMockInvocationLogger listener;\n+\n     private ByteArrayOutputStream output;\n-    private PrintableInvocation invocation;\n+    private Invocation invocation = new InvocationBuilder().toInvocation();\n+    private PrintableInvocation stubbedInvocation = new InvocationBuilder().toInvocation();\n \n-    @Before public void init_Listener() throws Exception {\n+    @Before\n+    public void init_Listener() throws Exception {\n         output = new ByteArrayOutputStream();\n         listener = new VerboseMockInvocationLogger(new PrintStream(output));\n     }\n \n-    @Before public void init_Invocation() {\n-        invocation = mock(PrintableInvocation.class);\n-        given(invocation.getLocation()).willReturn(mock(Location.class));\n+    @After\n+    public void tearDown() throws Exception {\n+        System.out.println(output);\n     }\n \n     @Test\n-\tpublic void shouldPrintToSystemOut() {\n-\t\tassertThat(new VerboseMockInvocationLogger().printStream).isSameAs(System.out);\n-\t}\n+    public void should_print_to_system_out() {\n+        assertThat(new VerboseMockInvocationLogger().printStream).isSameAs(System.out);\n+    }\n \n-\t@Test\n-\tpublic void shouldPrintInvocationWithReturnValueToStream() {\n+    @Test\n+    public void should_print_invocation_with_return_value() {\n         // when\n-\t\tlistener.reportInvocation(MethodCallReport.of(invocation, \"return value\", \"location of stubbing\"));\n+        listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, \"return value\"));\n \n-\t\t// then\n+        // then\n         assertThat(printed())\n                 .contains(invocation.toString())\n                 .contains(invocation.getLocation().toString())\n-                .contains(\"return value\")\n-                .contains(\"location of stubbing\");\n-\t}\n+                .contains(\"return value\");\n+    }\n \n-\t@Test\n-\tpublic void shouldPrintInvocationWithExceptionToStream() {\n-\t\t// when\n-\t\tlistener.reportInvocation(MethodCallReport.of(invocation, new ThirdPartyException(), \"location of stubbing\"));\n+    @Test\n+    public void should_print_invocation_with_exception() {\n+        // when\n+        listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, new ThirdPartyException()));\n \n-\t\t// then\n+        // then\n         assertThat(printed())\n-\t\t\t\t.contains(invocation.toString())\n-\t\t\t\t.contains(invocation.getLocation().toString())\n-\t\t\t\t.contains(ThirdPartyException.class.getName())\n-\t\t\t\t.contains(\"location of stubbing\");\n-\t}\n+                .contains(invocation.toString())\n+                .contains(invocation.getLocation().toString())\n+                .contains(ThirdPartyException.class.getName());\n+    }\n \n-\t@Test\n-\tpublic void shouldLogNumberOfInteractions() {\n-\t\t// when & then\n-        listener.reportInvocation(MethodCallReport.of(invocation, new ThirdPartyException(), \"location of stubbing\"));\n-\t\tassertThat(printed()).contains(\"#1\");\n+    @Test\n+    public void should_print_if_method_has_not_been_stubbed() throws Exception {\n+        listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, \"whatever\"));\n \n-        listener.reportInvocation(MethodCallReport.of(invocation, new ThirdPartyException(), \"other location\"));\n-\t\tassertThat(printed()).contains(\"#2\");\n+        assertThat(printed()).doesNotContain(\"stubbed\");\n+    }\n \n-        listener.reportInvocation(MethodCallReport.of(invocation, new ThirdPartyException(), \"location of stubbing\"));\n-\t\tassertThat(printed()).contains(\"#3\");\n-\t}\n+    @Test\n+    public void should_print_stubbed_info_if_availbable() throws Exception {\n+        invocation.markStubbed(new StubInfo(stubbedInvocation));\n+\n+        listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, \"whatever\"));\n+\n+        assertThat(printed())\n+                .contains(\"stubbed\")\n+                .contains(stubbedInvocation.getLocation().toString());\n+    }\n+\n+    @Test\n+    public void should_log_count_of_interactions() {\n+        // when & then\n+        listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, new ThirdPartyException()));\n+        assertThat(printed()).contains(\"#1\");\n+\n+        listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, new ThirdPartyException()));\n+        assertThat(printed()).contains(\"#2\");\n+\n+        listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, new ThirdPartyException()));\n+        assertThat(printed()).contains(\"#3\");\n+    }\n \n     private String printed() {\n         return output.toString();\n     }\n \n-\tprivate static class ThirdPartyException extends Exception {\n-\t\tprivate static final long serialVersionUID = 3022739107688491354L;\n-\t}\n+    private static class ThirdPartyException extends Exception {\n+        private static final long serialVersionUID = 3022739107688491354L;\n+    }\n }\n--- a/test/org/mockito/internal/invocation/InvocationBuilder.java\n+++ b/test/org/mockito/internal/invocation/InvocationBuilder.java\n  */\n package org.mockito.internal.invocation;\n \n+import org.mockito.Mockito;\n+import org.mockitousage.IMethods;\n+\n import java.lang.reflect.Method;\n import java.util.LinkedList;\n import java.util.List;\n \n-import org.mockito.Mockito;\n-import org.mockitousage.IMethods;\n-\n+/**\n+ * Build an invocation.\n+ */\n @SuppressWarnings(\"unchecked\")\n public class InvocationBuilder {\n \n     private Method method;\n     private boolean verified;\n \n+    /**\n+     * Build the invocation\n+     *\n+     * If the method was not specified, use IMethods methods.\n+     *\n+     * @return invocation\n+     */\n     public Invocation toInvocation() {\n         if (method == null) {\n             List<Class> argTypes = new LinkedList<Class>();\n--- a/test/org/mockito/internal/util/MockUtilTest.java\n+++ b/test/org/mockito/internal/util/MockUtilTest.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.internal.util;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n \n import org.junit.Test;\n import org.mockito.Mockito;\n import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n \n @SuppressWarnings(\"unchecked\")\n public class MockUtilTest extends TestBase {\n         assertFalse(mockUtil.isMock(\"i mock a mock\"));\n         assertTrue(mockUtil.isMock(Mockito.mock(List.class)));\n     }\n-}\n+}\n--- a/test/org/mockitousage/debugging/InvocationListenerCallbackTest.java\n+++ b/test/org/mockitousage/debugging/InvocationListenerCallbackTest.java\n  */\n package org.mockitousage.debugging;\n \n-import org.junit.Ignore;\n import org.junit.Test;\n import org.mockito.InOrder;\n import org.mockito.exceptions.PrintableInvocation;\n-import org.mockito.internal.matchers.Contains;\n-import org.mockito.internal.matchers.Equals;\n-import org.mockito.internal.matchers.InstanceOf;\n-import org.mockito.invocation.InvocationListener;\n-import org.mockito.invocation.MethodCallReport;\n-import org.mockitousage.debugging.VerboseLoggingOfInvocationsOnMockTest.ThirdPartyException;\n-import org.mockitoutil.TestBase;\n+import org.mockito.listeners.InvocationListener;\n+import org.mockito.listeners.MethodInvocationReport;\n \n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.junit.Assert.fail;\n import static org.mockito.BDDMockito.given;\n-import static org.mockito.Matchers.isA;\n+import static org.mockito.BDDMockito.willReturn;\n import static org.mockito.Mockito.*;\n+\n \n /**\n  * Ensures that custom listeners can be registered and will be called every time\n  * a method on a mock is invoked.\n  */\n-public class InvocationListenerCallbackTest extends TestBase {\n+public class InvocationListenerCallbackTest {\n+\n+    // Cannot use a mockito-mock here: during stubbing, the listener1 will be called\n+    // and mockito will confuse the mocks.\n+    private RememberingListener listener1 = new RememberingListener();\n+    private RememberingListener listener2 = new RememberingListener();\n \n     @Test\n-\tpublic void givenInvocationReturningValue_shouldCallSingleListenerWithCorrectCallback() throws Exception {\n-\t\t// given\n-\t\t// Cannot use a mockito-mock here: during stubbing, the listener will be called\n-\t\t// and mockito will confuse the mocks.\n-\t\tRememberingListener listener = new RememberingListener();\n-\t\tFoo foo = mock(Foo.class, withSettings().invocationListeners(listener));\n-\t\tgiven(foo.giveMeSomeString(\"argument\")).willReturn(\"returned\");\n+    public void should_call_single_listener_when_mock_return_normally() throws Exception {\n+        // given\n+        Foo foo = mock(Foo.class, withSettings().invocationListeners(listener1));\n+        willReturn(\"basil\").given(foo).giveMeSomeString(\"herb\");\n \n-\t\t// when\n-\t\tfoo.giveMeSomeString(\"argument\");\n+        // when\n+        foo.giveMeSomeString(\"herb\");\n \n-\t\tassertHasBeenNotified(listener, new InstanceOf(PrintableInvocation.class),\n-\t\t\t\tnew Equals(\"returned\"), new Contains(getClass().getSimpleName()));\n-\t}\n+        // then\n+        assertThatHasBeenNotified(listener1, \"basil\", getClass().getSimpleName());\n+    }\n \n-\t@Test\n-\tpublic void givenInvocationReturningValue_shouldCallMultipleListeners() throws Exception {\n-\t\t// given\n-\t\t// Cannot use a mockito-mock here: during stubbing, the listener will be called\n-\t\t// and mockito will confuse the mocks.\n-\t\tRememberingListener listener1 = new RememberingListener();\n-\t\tRememberingListener listener2 = new RememberingListener();\n-\t\tFoo foo = mock(Foo.class, withSettings().invocationListeners(listener1, listener2));\n-\t\tgiven(foo.giveMeSomeString(\"argument\")).willReturn(\"returned\");\n+    @Test\n+    public void should_call_all_listener_when_mock_return_normally() throws Exception {\n+        // given\n+        Foo foo = mock(Foo.class, withSettings().invocationListeners(listener1, listener2));\n+        given(foo.giveMeSomeString(\"herb\")).willReturn(\"rosemary\");\n \n-\t\t// when\n-\t\tfoo.giveMeSomeString(\"argument\");\n+        // when\n+        foo.giveMeSomeString(\"herb\");\n \n-\t\t// then\n-\t\tassertHasBeenNotified(listener1, new InstanceOf(PrintableInvocation.class),\n-\t\t\t\tnew Equals(\"returned\"), new Contains(getClass().getSimpleName()));\n-\t\tassertHasBeenNotified(listener2, new InstanceOf(PrintableInvocation.class),\n-\t\t\t\tnew Equals(\"returned\"), new Contains(getClass().getSimpleName()));\n-\t}\n+        // then\n+        assertThatHasBeenNotified(listener1, \"rosemary\", getClass().getSimpleName());\n+        assertThatHasBeenNotified(listener2, \"rosemary\", getClass().getSimpleName());\n+    }\n \n-\t@Test\n-    @Ignore(\"not anymore, waiting complete refactoring to be removed\")\n-\tpublic void givenInvocationThrowingException_shouldCallSingleListenerWithCorrectCallback() throws Exception {\n-\t\t// given\n-\t\tInvocationListener listener = mock(InvocationListener.class);\n-\t\tRuntimeException expectedException = new ThirdPartyException();\n-\t\tFoo foo = mock(Foo.class, withSettings().invocationListeners(listener));\n-\t\tdoThrow(expectedException).when(foo).doSomething(\"argument\");\n \n-\t\t// when\n-\t\ttry {\n-\t\t\tfoo.doSomething(\"argument\");\n-\t\t\tfail(\"Exception expected.\");\n-\t\t} catch (ThirdPartyException actualException) {\n-\t\t\t// then\n-\t\t\tassertSame(expectedException, actualException);\n-\t\t\tverify(listener).reportInvocation(isA(MethodCallReport.class));\n-\t\t}\n-\t}\n+    @Test\n+    public void should_call_all_listener_when_mock_throws_exception() throws Exception {\n+        // given\n+        InvocationListener listener1 = mock(InvocationListener.class, \"listener1\");\n+        InvocationListener listener2 = mock(InvocationListener.class, \"listener2\");\n+        Foo foo = mock(Foo.class, withSettings().invocationListeners(listener1, listener2));\n+        doThrow(new OvenNotWorking()).when(foo).doSomething(\"cook\");\n \n-\t@Test\n-\tpublic void givenInvocationThrowingException_shouldCallMultipleListeners() throws Exception {\n-\t\t// given\n-\t\tInvocationListener listener1 = mock(InvocationListener.class, \"listener1\");\n-\t\tInvocationListener listener2 = mock(InvocationListener.class, \"listener2\");\n-\t\tFoo foo = mock(Foo.class, withSettings().invocationListeners(listener1, listener2));\n-\t\tdoThrow(new ThirdPartyException()).when(foo).doSomething(\"argument\");\n+        // when\n+        try {\n+            foo.doSomething(\"cook\");\n+            fail(\"Exception expected.\");\n+        } catch (OvenNotWorking actualException) {\n+            // then\n+            InOrder orderedVerify = inOrder(listener1, listener2);\n+            orderedVerify.verify(listener1).reportInvocation(any(MethodInvocationReport.class));\n+            orderedVerify.verify(listener2).reportInvocation(any(MethodInvocationReport.class));\n+        }\n+    }\n \n-\t\t// when\n-\t\ttry {\n-\t\t\tfoo.doSomething(\"argument\");\n-\t\t\tfail(\"Exception expected.\");\n-\t\t} catch (ThirdPartyException actualException) {\n-\t\t\t// then\n-            InOrder orderedVerify = inOrder(listener1, listener2);\n-            orderedVerify.verify(listener1).reportInvocation(any(MethodCallReport.class));\n-\t\t\torderedVerify.verify(listener2).reportInvocation(any(MethodCallReport.class));\n-\t\t}\n-\t}\n-\t\n-\tprivate void assertHasBeenNotified(RememberingListener listener, InstanceOf m, Equals m2, Contains m3) {\n-\t\tassertThat(listener.invocation, m);\n-\t\tassertThat(listener.returnValue, m2);\n-\t\tassertThat(listener.locationOfStubbing, m3);\n-\t}\n+    static class OvenNotWorking extends RuntimeException { }\n \n-\tstatic class RememberingListener implements InvocationListener {\n-\t\t\n-\t\tPrintableInvocation invocation;\n-\t\tObject returnValue;\n-\t\tString locationOfStubbing;\n+    private void assertThatHasBeenNotified(RememberingListener listener, Object returned, String location) {\n+        assertThat(listener.returnValue).isEqualTo(returned);\n+        assertThat(listener.invocation).isNotNull();\n+        assertThat(listener.locationOfStubbing).contains(getClass().getSimpleName());\n+    }\n \n-\t\tpublic void reportInvocation(MethodCallReport mcr) {\n-\t\t\tthis.invocation = mcr.getInvocation();\n-\t\t\tthis.returnValue = mcr.getReturnedValue();\n-\t\t\tthis.locationOfStubbing = mcr.getLocationOfStubbing();\n-\t\t}\n+    private static class RememberingListener implements InvocationListener {\n+        PrintableInvocation invocation;\n+        Object returnValue;\n+        String locationOfStubbing;\n \n-\t}\n+        public void reportInvocation(MethodInvocationReport mcr) {\n+            this.invocation = mcr.getInvocation();\n+            this.returnValue = mcr.getReturnedValue();\n+            this.locationOfStubbing = mcr.getLocationOfStubbing();\n+        }\n+    }\n }\n--- a/test/org/mockitousage/debugging/VerboseLoggingOfInvocationsOnMockTest.java\n+++ b/test/org/mockitousage/debugging/VerboseLoggingOfInvocationsOnMockTest.java\n import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n+import org.junit.runner.RunWith;\n import org.mockito.Mock;\n import org.mockito.internal.util.MockUtil;\n+import org.mockito.runners.MockitoJUnitRunner;\n \n import java.io.ByteArrayOutputStream;\n import java.io.PrintStream;\n  * in the parallel setting.\n  * Maybe, the test class should be @Ignore'd by default ...\n  */\n+@RunWith(MockitoJUnitRunner.class)\n public class VerboseLoggingOfInvocationsOnMockTest {\n \n     private ByteArrayOutputStream output;\n \n \t@After\n \tpublic void tearDown() {\n-\t\tSystem.setOut(original);\n+        System.setOut(original);\n \t}\n \n \t@Test", "timestamp": 1305474219, "metainfo": ""}