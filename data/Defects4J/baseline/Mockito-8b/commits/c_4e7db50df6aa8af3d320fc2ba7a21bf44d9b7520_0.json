{"sha": "4e7db50df6aa8af3d320fc2ba7a21bf44d9b7520", "log": "Refactored forwardTo() api into a regular answer at the AdditionalAnswers. Brice - stay happy - I decided to change forwardTo into delegatesTo() because we've already talked in the javadocs about 'delegating' in few places. So I wanted to use a consistent language. We haven't yet released so you can still convince me why should we stop talking about 'delegate' in favor of 'forward'. Tweaked some javadocs.", "commit": "\n--- a/src/org/mockito/AdditionalAnswers.java\n+++ b/src/org/mockito/AdditionalAnswers.java\n package org.mockito;\n \n+import org.mockito.internal.stubbing.defaultanswers.ForwardsInvocations;\n import org.mockito.stubbing.Answer;\n import org.mockito.stubbing.answers.ReturnsArgumentAt;\n \n         return (Answer<T>) new ReturnsArgumentAt(position);\n     }\n \n+    /**\n+     * An answer that directly forwards the calls to the delegate.\n+     *\n+     * Makes sense only for spies or partial mocks of objects that are difficult to mock or spy using the usual spy API.\n+     * Possible use cases:\n+     * <ul>\n+     *     <li>Final classes but with an interface</li>\n+     *     <li>Already custom proxied object</li>\n+     *     <li>Special objects with a finalize method, i.e. to avoid executing it 2 times</li>\n+     *     <li>...</li>\n+     * </ul>\n+     * Sets the real implementation to be called when the method is called on a mock object.\n+     * <p>\n+     * <pre class=\"code\"><code class=\"java\">\n+     *   final class DontMessTheCodeOfThisList implements list { ... }\n+     *\n+     *   DontMessTheCodeOfThisList awesomeList = new DontMessTheCodeOfThisList();\n+     *\n+     *   List listWithDelegate = mock(List.class, delegatesTo(awesomeList));\n+     * </code></pre>\n+     *\n+     * <p>\n+     * This features suffer from the same drawback as the spy.\n+     * The mock will call the delegate if you use regular when().then() stubbing style.\n+     * Since the real implementation is called this might have some side effects.\n+     * Therefore you should to use the doReturn|Throw|Answer|CallRealMethod stubbing style. Example:\n+     *\n+     * <pre class=\"code\"><code class=\"java\">\n+     *   List listWithDelegate = mock(List.class, AdditionalAnswers.delegatesTo(awesomeList));\n+     *\n+     *   //Impossible: real method is called so listWithDelegate.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n+     *   when(listWithDelegate.get(0)).thenReturn(\"foo\");\n+     *\n+     *   //You have to use doReturn() for stubbing\n+     *   doReturn(\"foo\").when(listWithDelegate).get(0);\n+     * </code></pre>\n+     *\n+     * @param delegate The delegate to forward calls to.\n+     * @return the answer\n+     *\n+     * @since 1.9.5\n+     */\n+    public static <T> Answer<T> delegatesTo(Object delegate) {\n+        return (Answer<T>) new ForwardsInvocations(delegate);\n+    }\n }\n--- a/src/org/mockito/MockSettings.java\n+++ b/src/org/mockito/MockSettings.java\n      * @return settings instance so that you can fluently specify other settings\n      */\n     MockSettings invocationListeners(InvocationListener... listeners);\n-\n-    /**\n-     * Specifies the delegated instance on which a mock should forward calls.\n-     *\n-     * Makes sense only for spies or partial mocks of objects that are difficult to mock or spy using the usual spy API.\n-     * Possible use cases :\n-     * <ul>\n-     *     <li>Final classes but with an interface</li>\n-     *     <li>Already custom proxied object</li>\n-     *     <li>Special objects with a finalize method, i.e. to avoid executing it 2 times</li>\n-     *     <li>...</li>\n-     * </ul>\n-     * Sets the real implementation to be called when the method is called on a mock object.\n-     * <p>\n-     * As usual you are going to read <b>the partial mock warning</b>:\n-     * Object oriented programming is more or less about tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n-     * How does partial mock fit into this paradigm? Well, it just doesn't...\n-     * Partial mock usually means that the complexity has been moved to a different method on the same object.\n-     * In most cases, this is not the way you want to design your application.\n-     * <p>\n-     * However, there are rare cases when partial mocks come handy:\n-     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n-     * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n-     * <p>\n-     * Enough warnings about partial mocks, see an example how spiedInstance() works:\n-     * <pre class=\"code\"><code class=\"java\">\n-     *   final class DontMessTheCodeOfThisList implements list { ... }\n-     *\n-     *   DontMessTheCodeOfThisList awesomeList = new DontMessTheCodeOfThisList();\n-     *\n-     *   List listWithDelegate = mock(List.class, withSettings().forwardTo(awesomeList));\n-     * </code></pre>\n-     *\n-     * <p>\n-     * This features suffer from the same drawback as the spy. The mock will always call the delegate.\n-     * This mean that you have to use the doReturn|Throw|Answer|CallRealMethod stubbing style. Example:\n-     *\n-     * <pre class=\"code\"><code class=\"java\">\n-     *   List listWithDelegate = mock(List.class, withSettings().forwardTo(awesomeList));\n-     *\n-     *   //Impossible: real method is called so listWithDelegate.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n-     *   when(listWithDelegate.get(0)).thenReturn(\"foo\");\n-     *\n-     *   //You have to use doReturn() for stubbing\n-     *   doReturn(\"foo\").when(listWithDelegate).get(0);\n-     * </code></pre>\n-     *\n-     * @param delegate The delegate to forward calls to.\n-     * @return settings instance so that you can fluently specify other settings\n-     *\n-     * @since 1.9.5\n-     */\n-    MockSettings forwardTo(Object delegate);\n }\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n  *\n  *\n  *\n- * <h3 id=\"27\">27. (**New**) <a class=\"meaningful_link\" href=\"#forwarding_call_to_real_instance\">Forward calls to real instance</a> (Since 1.9.5)</h3>\n- * <p>Now mockito offer a specific way to forward calls to a concrete instance. This is different than than a\n- * spy because the spy creation syntax discard the to be spied instance.\n+ * <h3 id=\"27\">27. (**New**) <a class=\"meaningful_link\" href=\"#delegating_call_to_real_instance\">Delegate calls to real instance</a> (Since 1.9.5)</h3>\n+ * <p>Now mockito offer a specific way to delegate calls to a concrete instance. This is different than the\n+ * spy because the regular spy contains all the state of the spied instance. TODO SF - add more information.\n  *\n  * <p>Note that this feature only makes sense only for spies or partial mocks of objects <strong>that are difficult to\n  * mock or spy</strong> using the usual spy API.\n- * Possible use cases :\n+ * Possible use cases:\n  * <ul>\n  *     <li>Final classes but with an interface</li>\n  *     <li>Already custom proxied object</li>\n  *     <li>...</li>\n  * </ul>\n  *\n- * Possible example with an object interacting with native objects and spy that would not work :\n+ * Possible example with an object interacting with native objects and spy that would not work:\n  * <pre class=\"code\"><code class=\"java\">\n  *   InteractingWithNativeStuff theSpy = spy(interactingWithNativeStuff);\n  *\n  *   // Some time after the GC collect interactingWithNativeStuff as it not anymore used,\n  *   // the finalizer is executed, for example to call a C++ destructor.\n  *\n- *   // Later on, it's finally the psy to be garbage collected, finalize method is called again,\n+ *   // Later on, it's finally the spy to be garbage collected, finalize method is called again,\n  *   // unfortunately the second interaction with the native objects will crash the JVM.\n  * </code></pre>\n  * Now with the forwarding feature in place :\n  * <pre class=\"code\"><code class=\"java\">\n- *   InteractingWithNativeStuff native = mock(InteractingWithNativeStuff.class, withSettings().forwardTo(interactingWithNativeStuff));\n- *\n- *   // OK, the mock keeps a reference to the interactingWithNativeStuff, so the finalize method never kick-in.\n+ *   InteractingWithNativeStuff native = mock(InteractingWithNativeStuff.class, AdditionalAnswers.delegateTo(interactingWithNativeStuff));\n+ *\n+ *   //TODO SF - I don't quite follow this example... spied instance is also something we hold in the MockSettings...\n+ *   // OK, the mock keeps a reference to the interactingWithNativeStuff, so the finalize method never kicks in.\n  * </code></pre>\n  *\n  * <p>Friendly reminder that final Methods cannot be mocked, so if <code>finalize</code> is <code>final</code> the\n  * real code will still be executed.\n  *\n  * <p>\n- * See more information there {@link MockSettings#forwardTo}.\n+ * See more information there {@link AdditionalAnswers#delegatesTo(Object)}.\n  *\n  *\n  *\n--- a/src/org/mockito/internal/creation/MockSettingsImpl.java\n+++ b/src/org/mockito/internal/creation/MockSettingsImpl.java\n     private Set<Class> extraInterfaces = new LinkedHashSet<Class>();\n     private String name;\n     private Object spiedInstance;\n-    private Object delegatedInstance;\n     private Answer<Object> defaultAnswer;\n     private MockName mockName;\n     private boolean serializable;\n \n     public Object getSpiedInstance() {\n         return spiedInstance;\n-    }\n-\n-    public Object getDelegatedInstance() {\n-    \treturn this.delegatedInstance ;\n     }\n \n     public MockSettings name(String name) {\n     public void redefineMockName(String newName) {\n         mockName = new MockNameImpl(newName);\n     }\n-\n-\tpublic MockSettings forwardTo(Object delegatedInstance) {\n-\t\tthis.delegatedInstance = delegatedInstance;\n-\t\treturn defaultAnswer(new ForwardsInvocations(this.delegatedInstance));\n-\t}\n }\n \n--- a/src/org/mockito/internal/util/MockCreationValidator.java\n+++ b/src/org/mockito/internal/util/MockCreationValidator.java\n             new Reporter().mockedTypeIsInconsistentWithDelegatedInstanceType(classToMock, delegatedInstance);\n         }\n     }\n-\n-\tpublic void validateMutualExclusionForSpyOrDelegate(MockSettingsImpl settings) {\n-\t\tif (settings.getDelegatedInstance() != null && settings.getSpiedInstance() != null) {\n-\t\t\tnew Reporter().spyAndDelegateAreMutuallyExclusive() ;\n-\t\t}\n-\n-\t}\n }\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n         creationValidator.validateType(classToMock);\n         creationValidator.validateExtraInterfaces(classToMock, settings.getExtraInterfaces());\n         creationValidator.validateMockedType(classToMock, settings.getSpiedInstance());\n-        creationValidator.validateDelegatedInstance(classToMock, settings.getDelegatedInstance()) ;\n-        creationValidator.validateMutualExclusionForSpyOrDelegate(settings) ;\n+        //TODO SF - add this validation and also add missing coverage\n+//        creationValidator.validateDelegatedInstance(classToMock, settings.getDelegatedInstance()) ;\n \n         settings.initiateMockName(classToMock);\n \n--- a/src/org/mockito/mock/MockSettingsInfo.java\n+++ b/src/org/mockito/mock/MockSettingsInfo.java\n package org.mockito.mock;\n \n import org.mockito.Incubating;\n-import org.mockito.internal.util.MockNameImpl;\n import org.mockito.listeners.InvocationListener;\n import org.mockito.stubbing.Answer;\n \n     Set<Class> getExtraInterfaces();\n \n     Object getSpiedInstance();\n-\n-    //TODO SF - forward needs to be consistently named with delegate\n-    //also figure this thing out.\n-    Object getDelegatedInstance();\n }\n--- a/test/org/mockitousage/stubbing/StubbingWithDelegate.java\n+++ b/test/org/mockitousage/stubbing/StubbingWithDelegate.java\n import static junit.framework.Assert.assertEquals;\n import static org.fest.assertions.Assertions.assertThat;\n import static org.junit.Assert.fail;\n+import static org.mockito.AdditionalAnswers.delegatesTo;\n import static org.mockito.Mockito.doReturn;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.withSettings;\n \t\tList<String> delegatedList = new ArrayList<String>();\n \t\tdelegatedList.add(\"un\") ;\n \n-\t\tList<String> mock = mock(List.class, withSettings().forwardTo(delegatedList)) ;\n+\t\tList<String> mock = mock(List.class, delegatesTo(delegatedList)) ;\n \n \t\tmock.add(\"two\") ;\n \n \tpublic void when_stubbed_the_delegate_should_not_be_called() {\n \t\tList<String> delegatedList = new ArrayList<String>();\n \t\tdelegatedList.add(\"un\") ;\n-\t\tList<String> mock = mock(List.class, withSettings().forwardTo(delegatedList)) ;\n+\t\tList<String> mock = mock(List.class, delegatesTo(delegatedList)) ;\n \n \t\tdoReturn(10).when(mock).size();\n \n \tpublic void delegate_should_not_be_called_when_stubbed2() {\n \t\tList<String> delegatedList = new ArrayList<String>();\n \t\tdelegatedList.add(\"un\") ;\n-\t\tList<String> mockedList = mock(List.class, withSettings().forwardTo(delegatedList)) ;\n+\t\tList<String> mockedList = mock(List.class, delegatesTo(delegatedList)) ;\n \n \t\tdoReturn(false).when(mockedList).add(Mockito.anyString()) ;\n \n \n     @Test\n     public void null_wrapper_dont_throw_exception_from_org_mockito_package() throws Exception {\n-        IMethods methods = mock(IMethods.class, withSettings().forwardTo(new MethodsImpl()));\n+        IMethods methods = mock(IMethods.class, delegatesTo(new MethodsImpl()));\n \n         try {\n             byte b = methods.byteObjectReturningMethod(); // real method returns null", "timestamp": 1333989166, "metainfo": ""}