{"sha": "0d5bb0f740435ddbee2185c0f6a2d28db6d2ec96", "log": "Added/refactored tests for ExperimentalMockitoJUnitRunner added TODO  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401123", "commit": "\n--- a/src/org/mockito/internal/invocation/Invocation.java\n+++ b/src/org/mockito/internal/invocation/Invocation.java\n     protected String toString(List<Matcher> matchers, boolean forceMultiline) {\n         String method = qualifiedMethodName();\n         String invocation = method + getArgumentsLine(matchers);\n+        //TODO make sure you don't break line when no args are given!\n         if (forceMultiline || invocation.length() > MAX_LINE_LENGTH) {\n             return method + getArgumentsBlock(matchers);\n         } else {\n--- a/src/org/mockito/runners/ExperimentalMockitoJUnitRunner.java\n+++ b/src/org/mockito/runners/ExperimentalMockitoJUnitRunner.java\n         return super.withBefores(method, target, statement);\n     }\n     \n-    static interface SimpleRunner {\n+    //this is what is really executed when the test runs\n+    static interface JunitTestBody {\n         void run(RunNotifier notifier);\n     }\n     \n     @Override\n     public void run(RunNotifier notifier) {\n-        this.run(notifier, new SimpleRunner() {\n+        this.run(notifier, new JunitTestBody() {\n             public void run(RunNotifier notifier) {\n                 ExperimentalMockitoJUnitRunner.super.run(notifier);\n             }\n         });\n     }\n     \n-    public void run(RunNotifier notifier, SimpleRunner littleRunner) {\n-        final MockingProgress progress = new ThreadSafeMockingProgress();\n-        final DebuggingInfo debuggingInfo = progress.getDebuggingInfo();\n+    public void run(RunNotifier notifier, JunitTestBody junitTestBody) {\n+        MockingProgress progress = new ThreadSafeMockingProgress();\n+        DebuggingInfo debuggingInfo = progress.getDebuggingInfo();\n         \n+        beforeRun(notifier, debuggingInfo);\n+        \n+        junitTestBody.run(notifier);\n+        \n+        afterRun(debuggingInfo);\n+    }\n+\n+    private void afterRun(final DebuggingInfo debuggingInfo) {\n+        debuggingInfo.clearData();\n+    }\n+\n+    private void beforeRun(RunNotifier notifier, final DebuggingInfo debuggingInfo) {\n         debuggingInfo.collectData();\n \n         RunListener listener = new RunListener() {\n         };\n         \n         notifier.addListener(listener);\n-        littleRunner.run(notifier);\n-        \n-        debuggingInfo.clearData();\n     }\n }\n--- /dev/null\n+++ b/src/org/mockito/runners/ExperimentalMockitoJUnitRunnerPM.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.runners;\n+\n+import org.junit.runner.notification.Failure;\n+import org.junit.runner.notification.RunListener;\n+import org.junit.runner.notification.RunNotifier;\n+import org.junit.runners.BlockJUnit4ClassRunner;\n+import org.junit.runners.model.FrameworkMethod;\n+import org.junit.runners.model.InitializationError;\n+import org.junit.runners.model.Statement;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.internal.debugging.DebuggingInfo;\n+import org.mockito.internal.progress.MockingProgress;\n+import org.mockito.internal.progress.ThreadSafeMockingProgress;\n+import org.mockito.internal.util.MockitoLogger;\n+import org.mockito.internal.util.MockitoLoggerImpl;\n+\n+/**\n+ * Uses <b>JUnit 4.5</b> runner {@link BlockJUnit4ClassRunner}.\n+ * <p>\n+ * JUnit 4.5 runner initializes mocks annotated with {@link Mock},\n+ * so that explicit usage of {@link MockitoAnnotations#initMocks(Object)} is not necessary. \n+ * Mocks are initialized before each test method. \n+ * <p>\n+ * Runner is completely optional - there are other ways you can get &#064;Mock working, for example by writing a base class.\n+ * <p>\n+ * Read more in javadoc for {@link MockitoAnnotations}\n+ * <p>\n+ * Example:\n+ * <pre>\n+ * <b>&#064;RunWith(MockitoJUnit44Runner.class)</b>\n+ * public class ExampleTest {\n+ * \n+ *     &#064;Mock\n+ *     private List list;\n+ * \n+ *     &#064;Test\n+ *     public void shouldDoSomething() {\n+ *         list.add(100);\n+ *     }\n+ * }\n+ * <p>\n+ * \n+ * </pre>\n+ */\n+public class ExperimentalMockitoJUnitRunnerPM extends BlockJUnit4ClassRunner {\n+\n+    static MockitoLogger logger = new MockitoLoggerImpl();\n+    \n+    public ExperimentalMockitoJUnitRunnerPM(Class<?> klass) throws InitializationError {\n+        super(klass);\n+    }\n+\n+    @Override\n+    protected Statement withBefores(FrameworkMethod method, Object target, Statement statement) {\n+        MockitoAnnotations.initMocks(target);\n+        return super.withBefores(method, target, statement);\n+    }\n+    \n+    protected void runTestBody(RunNotifier notifier) {\n+        super.run(notifier);\n+    }\n+    \n+    @Override\n+    public void run(RunNotifier notifier) {\n+        MockingProgress progress = new ThreadSafeMockingProgress();\n+        DebuggingInfo debuggingInfo = progress.getDebuggingInfo();\n+        \n+        beforeRun(notifier, debuggingInfo);\n+        \n+        runTestBody(notifier);\n+\n+        afterRun(debuggingInfo);\n+    }\n+\n+    private void afterRun(final DebuggingInfo debuggingInfo) {\n+        debuggingInfo.clearData();\n+    }\n+\n+    private void beforeRun(RunNotifier notifier, final DebuggingInfo debuggingInfo) {\n+        debuggingInfo.collectData();\n+\n+        RunListener listener = new RunListener() {\n+            @Override public void testFailure(Failure failure) throws Exception {\n+                debuggingInfo.printWarnings(logger);\n+            }\n+        };\n+        \n+        notifier.addListener(listener);\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/runners/ExperimentalMockitoJUnitRunnerPMTest.java\n+package org.mockito.runners;\n+\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runner.notification.RunNotifier;\n+import org.junit.runners.model.InitializationError;\n+import org.mockito.Mock;\n+import org.mockito.internal.debugging.DebuggingInfo;\n+import org.mockito.internal.progress.ThreadSafeMockingProgress;\n+import org.mockito.internal.util.MockitoLoggerImpl;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+@SuppressWarnings(\"serial\")\n+public class ExperimentalMockitoJUnitRunnerPMTest extends TestBase {\n+    \n+    //just to get rid of noisy constructor\n+    class ExperimentalMockitoJUnitRunnerPMStub extends ExperimentalMockitoJUnitRunnerPM {\n+        public ExperimentalMockitoJUnitRunnerPMStub() throws InitializationError {\n+            super(ExperimentalMockitoJUnitRunnerPMTest.class);\n+        }\n+    }\n+    \n+    @Mock private IMethods mock;\n+    private ExperimentalMockitoJUnitRunnerPMStub runner;\n+    private MockitoLoggerStub loggerStub;\n+    private RunNotifier notifier;\n+\n+    @Before\n+    public void setup() throws InitializationError {\n+        runner = new ExperimentalMockitoJUnitRunnerPMStub();\n+        loggerStub = new MockitoLoggerStub();\n+        ExperimentalMockitoJUnitRunnerPM.logger = loggerStub;\n+        notifier = new RunNotifier();\n+    }\n+    \n+    @After\n+    public void restoreLogger() {\n+        ExperimentalMockitoJUnitRunnerPM.logger = new MockitoLoggerImpl();\n+    }\n+\n+    @Test\n+    public void shouldRunTests() throws Exception {\n+        final StringBuilder sb = new StringBuilder();\n+        runner = new ExperimentalMockitoJUnitRunnerPMStub() {\n+            protected void runTestBody(RunNotifier notifier) {\n+                sb.append(\"ran test body\");\n+            }\n+        };\n+        runner.run(notifier);\n+        assertEquals(\"ran test body\", sb.toString());\n+    }\n+    \n+    class TestBodyWasRan extends RuntimeException {};\n+    \n+    @Test(expected=TestBodyWasRan.class)\n+    public void shouldRunTests2() throws Exception {\n+        runner = new ExperimentalMockitoJUnitRunnerPMStub() {\n+            protected void runTestBody(RunNotifier notifier) {\n+                throw new TestBodyWasRan();\n+            }\n+        };\n+        runner.run(notifier);\n+    }\n+    \n+    @Ignore\n+    @Test\n+    public void shouldRunTestsWithHypotheticalPartialMock() throws Exception {\n+        runner = spy(runner);\n+        \n+        //This even might not be needed because runOnParent() might be safe\n+        doNothing().when(runner).runTestBody(notifier);\n+        \n+        runner.run(notifier);\n+        \n+        verify(runner).runTestBody(notifier);\n+    }\n+    \n+    @Test\n+    public void shouldLogUnusedStubbingWarningWhenTestFails() throws Exception {\n+        runner = new ExperimentalMockitoJUnitRunnerPMStub() {\n+            protected void runTestBody(RunNotifier notifier) {\n+                //this is what happens when the test runs:\n+                //first, unused stubbing:\n+                unusedStubbingThatQualifiesForWarning();\n+                //then, let's make the test fail so that warnings are printed\n+                notifier.fireTestFailure(null);\n+                //assert\n+                String loggedInfo = loggerStub.getLoggedInfo();\n+                assertThat(loggedInfo, contains(\"[Mockito] Warning - this stub was not used\"));\n+                assertThat(loggedInfo, contains(\"mock.simpleMethod(123);\"));\n+                assertThat(loggedInfo, contains(\".unusedStubbingThatQualifiesForWarning(\"));\n+            }\n+        };\n+        runner.run(notifier);\n+    }\n+    \n+    @Ignore\n+    @Test\n+    public void shouldLogUnusedStubbingWarningWhenTestFailsWithPartialMock() throws Exception {\n+        runner = spy(runner);\n+        \n+        doAnswer(new Answer<Object>() {\n+            public Object answer(InvocationOnMock invocation) {\n+                RunNotifier notifier = (RunNotifier) invocation.getArguments()[0];\n+                //this is what happens when the test runs:\n+                //first, unused stubbing:\n+                unusedStubbingThatQualifiesForWarning();\n+                //then, let's make the test fail so that warnings are printed\n+                notifier.fireTestFailure(null);\n+                //assert\n+                String loggedInfo = loggerStub.getLoggedInfo();\n+                assertThat(loggedInfo, contains(\"[Mockito] Warning - this stub was not used\"));\n+                assertThat(loggedInfo, contains(\"mock.simpleMethod(123);\"));\n+                assertThat(loggedInfo, contains(\".unusedStubbingThatQualifiesForWarning(\"));\n+                return null;\n+            }\n+        }).when(runner).runTestBody(notifier);\n+\n+        runner.run(notifier);\n+    }\n+\n+    @Test\n+    public void shouldLogUnstubbedMethodWarningWhenTestFails() throws Exception {\n+        runner = new ExperimentalMockitoJUnitRunnerPMStub() {\n+            protected void runTestBody(RunNotifier notifier) {\n+                callUnstubbedMethodThatQualifiesForWarning();\n+                notifier.fireTestFailure(null);\n+\n+                String loggedInfo = loggerStub.getLoggedInfo();\n+                assertThat(loggedInfo, contains(\"[Mockito] Warning - this method was not stubbed\"));\n+                assertThat(loggedInfo, contains(\"mock.simpleMethod(456);\"));\n+                assertThat(loggedInfo, contains(\".callUnstubbedMethodThatQualifiesForWarning(\"));\n+            }\n+        };\n+        runner.run(notifier);\n+    }\n+    \n+    @Test\n+    public void shouldLogStubCalledWithDifferentArgumentsWhenTestFails() throws Exception {\n+        runner = new ExperimentalMockitoJUnitRunnerPMStub() {\n+            protected void runTestBody(RunNotifier notifier) {\n+                someStubbing();\n+                //TODO below should be different test method\n+//                callStubbedMethodCorrectly();\n+                callStubbedMethodWithDifferentArgs();\n+                notifier.fireTestFailure(null);\n+                \n+                String loggedInfo = loggerStub.getLoggedInfo();\n+                assertThat(loggedInfo, contains(\"[Mockito] Warning - stubbed method called with different arguments\"));\n+                assertThat(loggedInfo, contains(\"Stubbed this way:\"));\n+                assertThat(loggedInfo, contains(\"mock.simpleMethod(789);\"));\n+                assertThat(loggedInfo, contains(\".someStubbing(\"));\n+                \n+                assertThat(loggedInfo, contains(\"But called with different arguments:\"));\n+                assertThat(loggedInfo, contains(\"mock.simpleMethod(10);\"));\n+                assertThat(loggedInfo, contains(\".callStubbedMethodWithDifferentArgs(\"));\n+                \n+                assertThat(loggedInfo, notContains(\".callStubbedMethodCorrectly(\"));\n+            }\n+        };\n+        runner.run(notifier);\n+    }\n+    \n+    @Test\n+    public void shouldNotLogUsedStubbingWarningWhenTestFails() throws Exception {\n+        runner = new ExperimentalMockitoJUnitRunnerPMStub() {\n+            protected void runTestBody(RunNotifier notifier) {\n+                when(mock.simpleMethod()).thenReturn(\"foo\");\n+                mock.simpleMethod();\n+                \n+                notifier.fireTestFailure(null);\n+                \n+                String loggedInfo = loggerStub.getLoggedInfo();\n+                assertEquals(\"\", loggedInfo);\n+            }\n+        };\n+        runner.run(notifier);\n+    }\n+    \n+    \n+    public void shouldClearDebuggingDataAfterwards() throws Exception {\n+        final DebuggingInfo debuggingInfo = new ThreadSafeMockingProgress().getDebuggingInfo();\n+        \n+        runner = new ExperimentalMockitoJUnitRunnerPMStub() {\n+            protected void runTestBody(RunNotifier notifier) {\n+                unusedStubbingThatQualifiesForWarning();\n+                notifier.fireTestFailure(null);\n+                assertTrue(debuggingInfo.hasData());\n+            }\n+        };\n+        \n+        runner.run(notifier);\n+        \n+        assertFalse(debuggingInfo.hasData());\n+    }    \n+\n+    private void unusedStubbingThatQualifiesForWarning() {\n+        when(mock.simpleMethod(123)).thenReturn(\"foo\");\n+    }\n+\n+    private void callUnstubbedMethodThatQualifiesForWarning() {\n+        mock.simpleMethod(456);\n+    }\n+    \n+    private void someStubbing() {\n+        when(mock.simpleMethod(789)).thenReturn(\"foo\");\n+    }\n+    \n+    private void callStubbedMethodCorrectly() {\n+        mock.simpleMethod(789);\n+    }\n+\n+    private void callStubbedMethodWithDifferentArgs() {\n+        mock.simpleMethod(10);\n+    }\n+    \n+    public class MockitoLoggerStub extends MockitoLoggerImpl {\n+        \n+        StringBuilder loggedInfo = new StringBuilder();\n+        \n+        public void log(Object what) {\n+//            can be uncommented when debugging this test\n+//            super.log(what);\n+            loggedInfo.append(what);\n+        }\n+\n+        public String getLoggedInfo() {\n+            return loggedInfo.toString();\n+        }\n+    }\n+}\n--- a/test/org/mockito/runners/ExperimentalMockitoJUnitRunnerTest.java\n+++ b/test/org/mockito/runners/ExperimentalMockitoJUnitRunnerTest.java\n import org.mockito.internal.debugging.DebuggingInfo;\n import org.mockito.internal.progress.ThreadSafeMockingProgress;\n import org.mockito.internal.util.MockitoLoggerImpl;\n-import org.mockito.runners.ExperimentalMockitoJUnitRunner.SimpleRunner;\n+import org.mockito.runners.ExperimentalMockitoJUnitRunner.JunitTestBody;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n     \n     @After\n     public void restoreLogger() {\n+        //TODO logger should instance field! \n         ExperimentalMockitoJUnitRunner.logger = new MockitoLoggerImpl();\n     }\n \n     @Test(expected=RunWasCalled.class)\n     public void shouldRunTests() throws Exception {\n-        runner.run(notifier, new SimpleRunner() {\n+        runner.run(notifier, new JunitTestBody() {\n             public void run(RunNotifier notifier) {\n                 throw new RunWasCalled();\n             }\n     \n     @Test\n     public void shouldLogUnusedStubbingWarningWhenTestFails() throws Exception {\n-        runner.run(notifier, new SimpleRunner() {\n+        runner.run(notifier, new JunitTestBody() {\n             public void run(RunNotifier notifier) {\n                 //this is what happens when the test runs:\n                 //first, unused stubbing:\n \n     @Test\n     public void shouldLogUnstubbedMethodWarningWhenTestFails() throws Exception {\n-        runner.run(notifier, new SimpleRunner() {\n+        runner.run(notifier, new JunitTestBody() {\n             public void run(RunNotifier notifier) {\n                 callUnstubbedMethodThatQualifiesForWarning();\n                 notifier.fireTestFailure(null);\n     \n     @Test\n     public void shouldLogStubCalledWithDifferentArgumentsWhenTestFails() throws Exception {\n-        runner.run(notifier, new SimpleRunner() {\n+        runner.run(notifier, new JunitTestBody() {\n             public void run(RunNotifier notifier) {\n                 someStubbing();\n                 //TODO below should be different test method\n     \n     @Test\n     public void shouldNotLogUsedStubbingWarningWhenTestFails() throws Exception {\n-        runner.run(notifier, new SimpleRunner() {\n+        runner.run(notifier, new JunitTestBody() {\n             public void run(RunNotifier notifier) {\n                 when(mock.simpleMethod()).thenReturn(\"foo\");\n                 mock.simpleMethod();\n     public void shouldClearDebuggingDataAfterwards() throws Exception {\n         final DebuggingInfo debuggingInfo = new ThreadSafeMockingProgress().getDebuggingInfo();\n         \n-        runner.run(notifier, new SimpleRunner() {\n+        runner.run(notifier, new JunitTestBody() {\n             public void run(RunNotifier notifier) {\n                 unusedStubbingThatQualifiesForWarning();\n                 notifier.fireTestFailure(null);", "timestamp": 1230912013, "metainfo": ""}