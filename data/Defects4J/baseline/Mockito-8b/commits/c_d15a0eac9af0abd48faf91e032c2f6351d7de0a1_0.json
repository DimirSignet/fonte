{"sha": "d15a0eac9af0abd48faf91e032c2f6351d7de0a1", "log": "some refactorings  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40323", "commit": "\n--- /dev/null\n+++ b/src/org/mockito/exceptions/Printable.java\n+package org.mockito.exceptions;\n+\n+public interface Printable {\n+\n+    String toString();\n+}\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n     public void wantedDiffersFromActual(String wanted, String actual, HasStackTrace actualInvocationStackTrace) {\n         WantedDiffersFromActual cause1 = new WantedDiffersFromActual(join(\n                 \"Actual invocation:\",\n-                actual\n+                actual.toString()\n             ));\n         \n         cause1.setStackTrace(actualInvocationStackTrace.getStackTrace());\n         throw new InvocationDiffersFromActual(join(\n                 \"Invocation differs from actual\",\n                 \"Wanted invocation:\",\n-                wanted\n+                wanted.toString()\n             ), cause);\n     }\n     \n             ), cause);\n     }\n \n-    public void wantedButNotInvoked(Object wanted) {\n+    public void wantedButNotInvoked(Printable wanted) {\n         throw new WantedButNotInvoked(join(\n                     \"Wanted but not invoked:\",\n                     wanted.toString()\n     \n     //TODO do something about those objects (Printable object)\n     //TODO previous and previousStackTrace should be the same object\n-    public void wantedButNotInvokedInOrder(Object wanted, Object previous, HasStackTrace previousStackTrace) {\n+    public void wantedButNotInvokedInOrder(Printable wanted, Object previous, HasStackTrace previousStackTrace) {\n         WantedAnywhereAfterFollowingInteraction cause = new WantedAnywhereAfterFollowingInteraction(join(\n                         \"Wanted anywhere AFTER following interaction:\",\n                         previous.toString()));\n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n import java.util.Collections;\n import java.util.List;\n \n+import org.mockito.exceptions.Printable;\n import org.mockito.internal.matchers.ArgumentMatcher;\n \n @SuppressWarnings(\"unchecked\")\n-public class InvocationMatcher {\n+public class InvocationMatcher implements Printable {\n \n     private final Invocation invocation;\n     private final List<ArgumentMatcher> matchers;\n--- a/src/org/mockito/internal/invocation/InvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/InvocationsFinder.java\n \n     public List<Invocation> findAllMatchingUnverifiedChunks(List<Invocation> invocations, InvocationMatcher wanted) {\n         List<Invocation> unverified = removeVerifiedInOrder(invocations);\n-        List<Invocation> allChunks = new LinkedList<Invocation>();\n-        //TODO use filter\n-        for (Invocation invocation : unverified) {\n-            if (wanted.matches(invocation)) {\n-                allChunks.add(invocation);\n-            }\n-        }\n-        return allChunks;\n+        return ListUtil.filter(unverified, new RemoveNotMatching(wanted));\n     }\n \n-    public List<Invocation> findValidMatchingChunk(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n+    public List<Invocation> findMatchingChunk(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n         List<Invocation> unverified = removeVerifiedInOrder(invocations);\n+        List<Invocation> firstChunk = getFirstMatchingChunk(wanted, unverified);\n+        \n+        if (mode.atLeastOnceMode() || !mode.matchesActualCount(firstChunk.size())) {\n+            return this.findAllMatchingUnverifiedChunks(invocations, wanted);\n+        } else {\n+            return firstChunk;\n+        }\n+    }\n+\n+    private List<Invocation> getFirstMatchingChunk(InvocationMatcher wanted, List<Invocation> unverified) {\n         List<Invocation> firstChunk = new LinkedList<Invocation>();\n         for (Invocation invocation : unverified) {\n             if (wanted.matches(invocation)) {\n                 break;\n             }\n         }\n-        \n-        if (mode.atLeastOnceMode() || !mode.matchesActualCount(firstChunk.size())) {\n-            return this.findAllMatchingUnverifiedChunks(invocations, wanted);\n-        } else {\n-            return firstChunk;\n-        }\n+        return firstChunk;\n     }\n     \n     public Invocation findSimilarInvocation(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n         }\n     }\n     \n+    public Invocation findPreviousInOrder(List<Invocation> invocations, InvocationMatcher wanted) {\n+        LinkedList<Invocation> verifiedOnly = ListUtil.filter(invocations, new RemoveUnverifiedInOrder());\n+        \n+        if (verifiedOnly.isEmpty()) {\n+            return null;\n+        } else {\n+            return verifiedOnly.getLast();\n+        }\n+    }\n+    \n     private List<Invocation> removeVerifiedInOrder(List<Invocation> invocations) {\n         List<Invocation> unverified = new LinkedList<Invocation>();\n         for (Invocation i : invocations) {\n             return !invocation.isVerifiedInOrder();\n         }\n     }\n-    \n-    public Invocation findPreviousInOrder(List<Invocation> invocations, InvocationMatcher wanted) {\n-        LinkedList<Invocation> verifiedOnly = ListUtil.filter(invocations, new RemoveUnverifiedInOrder());\n-        \n-        if (verifiedOnly.isEmpty()) {\n-            return null;\n-        } else {\n-            return verifiedOnly.getLast();\n-        }\n-    }\n }\n--- a/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n+++ b/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n             InvocationsPrinter printer = new InvocationsPrinter(wanted, similar);\n             reporter.wantedDiffersFromActual(printer.printWanted(), printer.printActual(), similar.getStackTrace());\n         } else {\n-            reporter.wantedButNotInvoked(wanted.toString());\n+            reporter.wantedButNotInvoked(wanted);\n         }\n     }\n }\n--- a/src/org/mockito/internal/verification/NumberOfInvocationsInOrderVerifier.java\n+++ b/src/org/mockito/internal/verification/NumberOfInvocationsInOrderVerifier.java\n             return;\n         }\n         \n-        List<Invocation> chunk = finder.findValidMatchingChunk(invocations, wanted, mode);\n+        List<Invocation> chunk = finder.findMatchingChunk(invocations, wanted, mode);\n         \n         boolean noMatchFound = chunk.size() == 0;\n         if (mode.wantedCountIsZero() && noMatchFound) {\n--- a/test/org/mockito/internal/verification/InvocationsFinderStub.java\n+++ b/test/org/mockito/internal/verification/InvocationsFinderStub.java\n     }\n     \n     @Override\n-    public List<Invocation> findValidMatchingChunk(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n+    public List<Invocation> findMatchingChunk(List<Invocation> invocations, InvocationMatcher wanted, VerificationModeImpl mode) {\n         return validMatchingChunkToReturn;\n     }\n \n--- a/test/org/mockito/internal/verification/MissingInvocationInOrderVerifierTest.java\n+++ b/test/org/mockito/internal/verification/MissingInvocationInOrderVerifierTest.java\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.RequiresValidState;\n+import org.mockito.exceptions.Printable;\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.HasStackTrace;\n import org.mockito.internal.invocation.Invocation;\n     }\n     \n     class ReporterStub extends Reporter {\n-        private Object wanted;\n+        private Printable wanted;\n         private Object previous;\n         private HasStackTrace previousStackTrace;\n-\n-        @Override public void wantedButNotInvokedInOrder(Object wanted, Object previous, HasStackTrace previousStackTrace) {\n+        \n+        @Override public void wantedButNotInvokedInOrder(Printable wanted, Object previous, HasStackTrace previousStackTrace) {\n             this.wanted = wanted;\n             this.previous = previous;\n             this.previousStackTrace = previousStackTrace;\n         }\n         \n-        @Override public void wantedButNotInvoked(Object wanted) {\n+        @Override public void wantedButNotInvoked(Printable wanted) {\n             this.wanted = wanted;\n         }\n     }\n--- a/test/org/mockito/internal/verification/MissingInvocationVerifierTest.java\n+++ b/test/org/mockito/internal/verification/MissingInvocationVerifierTest.java\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.RequiresValidState;\n+import org.mockito.exceptions.Printable;\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.HasStackTrace;\n import org.mockito.internal.invocation.Invocation;\n         \n         verifier.verify(invocations, wanted, VerificationModeImpl.atLeastOnce());\n         \n-        assertEquals(wanted.toString(), reporterStub.wanted);\n+        assertEquals(wanted, reporterStub.wanted);\n     }\n     \n     @Test\n         private Object wanted;\n         private String actual;\n         private HasStackTrace actualInvocationStackTrace;\n-        @Override public void wantedButNotInvoked(Object wanted) {\n+        @Override public void wantedButNotInvoked(Printable wanted) {\n             this.wanted = wanted;\n         }\n         @Override public void wantedDiffersFromActual(String wanted, String actual, HasStackTrace actualInvocationStackTrace) {\n--- a/test/org/mockito/internal/verification/NumberOfInvocationsInOrderVerifierTest.java\n+++ b/test/org/mockito/internal/verification/NumberOfInvocationsInOrderVerifierTest.java\n             fail();\n         } catch (VerifcationInOrderFailed e) {\n             assertThat(e, messageContains(\"Wanted 4 times but was 2\"));\n-        };\n+        }\n     }\n     \n     @Test\n             fail();\n         } catch (VerifcationInOrderFailed e) {\n             assertThat(e, messageContains(\"Wanted 1 time but was 2\"));\n-        };\n+        }\n     }\n     \n     @Test\n--- a/test/org/mockitousage/PointingStackTraceToActualInvocationChunkTest.java\n+++ b/test/org/mockitousage/PointingStackTraceToActualInvocationChunkTest.java\n import org.mockito.exceptions.verification.TooLittleActualInvocations;\n import org.mockito.exceptions.verification.TooManyActualInvocations;\n \n-//TODO pmd rule so that all that starts with should have @Test annotation (or all XTest have some annotations on public methods)\n public class PointingStackTraceToActualInvocationChunkTest extends RequiresValidState {\n     \n     private IMethods mock;\n--- a/test/org/mockitousage/binding/IncorectBindingPuzzleFixedTest.java\n+++ b/test/org/mockitousage/binding/IncorectBindingPuzzleFixedTest.java\n import org.mockito.InOrder;\n import org.mockito.RequiresValidState;\n import org.mockito.exceptions.verification.InvocationDiffersFromActual;\n-import org.mockito.exceptions.verification.VerifcationInOrderFailed;\n \n public class IncorectBindingPuzzleFixedTest extends RequiresValidState {\n \n         setMockWithDowncast(sub);\n         say(\"Hello\");\n         InOrder inOrder = inOrder(mock);\n-        try {\n-            inOrder.verify(sub).say(\"Hello\");\n-            fail();\n-        } catch (VerifcationInOrderFailed e) {\n-            assertThat(e, messageContains(\"Sub.say(class java.lang.String)\"));\n-            assertThat(e, causeMessageContains(\"Sub.say(class java.lang.Object)\"));\n-        }\n+        inOrder.verify(sub).say(\"Hello\");\n     }\n \n     @Test", "timestamp": 1201027098, "metainfo": ""}