{"sha": "32755003f012e4369c3bb812a1f6e83b4223bf1d", "log": "Fixed issue 165 Added @Spy annotation Added configurability to @Mock annotation Added @InjectMock feature to inject mocks to tested instance  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401858", "commit": "\n--- /dev/null\n+++ b/src/org/mockito/InjectMock.java\n+package org.mockito;\n+\n+import java.lang.annotation.Documented;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import static java.lang.annotation.ElementType.FIELD;\n+\n+/**\n+ * <ul>\n+ * <li>Allows shorthand mock and spy injection.</li>\n+ * <li>Minimizes repetitive mock and spy injection.</li>\n+ * <li>Makes the test class more readable.</li>\n+ * </ul>\n+ *\n+ * <pre>\n+ *   public class ArticleManagerTest extends SampleBaseTestCase {\n+ *\n+ *       &#064;Mock private ArticleCalculator calculator;\n+ *       &#064;Mock private ArticleDatabase database;\n+ *       &#064;Spy private UserProvider userProvider = new ConsumerUserProvider();\n+ *\n+ *       &#064;InjectMock private ArticleManager manager = new ArticleManager();\n+ *\n+ *       &#064;Test public void shouldDoSomething() {\n+ *           manager.initiateArticle();\n+ *           verify(database).addListener(any(ArticleListener.class));\n+ *       }\n+ *   }\n+ *\n+ *   public class SampleBaseTestCase {\n+ *\n+ *       &#064;Before public void initMocks() {\n+ *           MockitoAnnotations.initMocks(this);\n+ *           MockitoAnnotations.injectMocks(this);\n+ *       }\n+ *   }\n+ * </pre>\n+ *\n+ * <b>The field annotated with &#064;InjectMock must be initialized.</b>\n+ * Mocks and spies must also be initialized with <code>MockitoAnnotations.initMocks(this)</code>.\n+ *\n+ * <b><code>MockitoAnnotations.injectMocks(this)</code></b> method has to called to initialize annotated objects.\n+ * <p>\n+ * In above example, <code>injectMocks()</code> is called in &#064;Before (JUnit4) method of test's base class.\n+ * For JUnit3 <code>injectMocks()</code> can go to <code>setup()</code> method of a base class.\n+ * You can also put injectMocks() in your JUnit runner (&#064;RunWith) or use built-in runners: {@link org.mockito.runners.MockitoJUnitRunner}\n+ */\n+@Documented\n+@Target( { FIELD })\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface InjectMock {\n+    //TODO should also inject spies\n+}\n--- a/src/org/mockito/Mock.java\n+++ b/src/org/mockito/Mock.java\n package org.mockito;\n \n import static java.lang.annotation.ElementType.*;\n+import static org.mockito.internal.stubbing.defaultanswers.Answers.*;\n \n import java.lang.annotation.Documented;\n import java.lang.annotation.Retention;\n import java.lang.annotation.RetentionPolicy;\n import java.lang.annotation.Target;\n \n+import org.mockito.internal.stubbing.defaultanswers.Answers;\n import org.mockito.runners.MockitoJUnitRunner;\n \n /**\n  * <ul>\n- * <li>Allows shorthand mock creation.</li> \n- * <li>Minimizes repetitive mock creation code.</li> \n+ * <li>Allows shorthand mock creation.</li>\n+ * <li>Minimizes repetitive mock creation code.</li>\n  * <li>Makes the test class more readable.</li>\n  * <li>Makes the verification error easier to read because the <b>field name</b> is used to identify the mock.</li>\n  * </ul>\n- * \n+ *\n  * <pre>\n- *   public class ArticleManagerTest extends SampleBaseTestCase { \n- *     \n+ *   public class ArticleManagerTest extends SampleBaseTestCase {\n+ *\n  *       &#064;Mock private ArticleCalculator calculator;\n- *       &#064;Mock private ArticleDatabase database;\n- *       &#064;Mock private UserProvider userProvider;\n- *     \n+ *       &#064;Mock(name = \"dbMock\") private ArticleDatabase database;\n+ *       &#064;Mock(answer = RETURNS_MOCKS) private UserProvider userProvider;\n+ *\n  *       private ArticleManager manager;\n- *     \n+ *\n  *       &#064;Before public void setup() {\n  *           manager = new ArticleManager(userProvider, database, calculator);\n  *       }\n  *   }\n- *   \n+ *\n  *   public class SampleBaseTestCase {\n- *   \n+ *\n  *       &#064;Before public void initMocks() {\n  *           MockitoAnnotations.initMocks(this);\n  *       }\n  *   }\n  * </pre>\n- * \n+ *\n  * <b><code>MockitoAnnotations.initMocks(this)</code></b> method has to called to initialize annotated mocks.\n  * <p>\n- * In above example, <code>initMocks()</code> is called in &#064;Before (JUnit4) method of test's base class. \n+ * In above example, <code>initMocks()</code> is called in &#064;Before (JUnit4) method of test's base class.\n  * For JUnit3 <code>initMocks()</code> can go to <code>setup()</code> method of a base class.\n  * You can also put initMocks() in your JUnit runner (&#064;RunWith) or use built-in runners: {@link MockitoJUnitRunner}\n  */\n @Target( { FIELD })\n @Retention(RetentionPolicy.RUNTIME)\n @Documented\n-public @interface Mock {}\n+public @interface Mock {\n \n+    Answers answer() default RETURNS_DEFAULTS;\n+\n+    String name() default \"\";\n+\n+    Class<?>[] extraInterfaces() default {};\n+}\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n @SuppressWarnings(\"unchecked\")\n public class Mockito extends Matchers {\n     \n-    private static final MockitoCore MOCKITO_CORE = new MockitoCore();\n+    static final MockitoCore MOCKITO_CORE = new MockitoCore();\n     \n     /**\n      * The default Answer of every mock <b>if</b> the mock was not stubbed. \n      * This implementation first tries the global configuration. \n      * If there is no global configuration then it uses {@link ReturnsEmptyValues} (returns zeros, empty collections, nulls, etc.)\n      */\n-    public static final Answer<Object> RETURNS_DEFAULTS = new GloballyConfiguredAnswer();\n+    public static final Answer<Object> RETURNS_DEFAULTS = Answers.RETURNS_DEFAULTS.get();\n     \n     /**\n      * Optional Answer to be used with {@link Mockito#mock(Class, Answer)}\n      *   //Exception's cause links to unstubbed <i>mock.getStuff()</i> - just click on the stack trace.  \n      * </pre>\n      */\n-    public static final Answer<Object> RETURNS_SMART_NULLS = new ReturnsSmartNulls();\n+    public static final Answer<Object> RETURNS_SMART_NULLS = Answers.RETURNS_SMART_NULLS.get();\n     \n     /**\n      * Optional Answer to be used with {@link Mockito#mock(Class, Answer)}\n      * then it tries to return mocks. If the return type cannot be mocked (e.g. is final) then plain null is returned.\n      * <p>\n      */\n-    public static final Answer<Object> RETURNS_MOCKS = new ReturnsMocks();\n+    public static final Answer<Object> RETURNS_MOCKS = Answers.RETURNS_MOCKS.get();\n \n     /**\n      * Optional Answer to be used with {@link Mockito#mock(Class, Answer)}\n      * This feature will not work when any return type of methods included in the chain cannot be mocked\n      * (for example: is a primitive or a final class). This is because of java type system.   \n      */\n-    public static final Answer<Object> RETURNS_DEEP_STUBS = new ReturnsDeepStubs();\n+    public static final Answer<Object> RETURNS_DEEP_STUBS = Answers.RETURNS_DEEP_STUBS.get();\n \n     /**\n      * Optional Answer to be used with {@link Mockito#mock(Class, Answer)}\n      * value = mock.getSomething();\n      * </pre>\n      */\n-    public static final Answer<Object> CALLS_REAL_METHODS = new CallsRealMethods();\n+    public static final Answer<Object> CALLS_REAL_METHODS = Answers.CALLS_REAL_METHODS.get();\n \n     /**\n      * Creates mock object of given class or interface.\n--- a/src/org/mockito/MockitoAnnotations.java\n+++ b/src/org/mockito/MockitoAnnotations.java\n import java.lang.reflect.Field;\n \n import org.mockito.configuration.AnnotationEngine;\n+import org.mockito.configuration.DefaultMockitoConfiguration;\n+import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.configuration.GlobalConfiguration;\n import org.mockito.runners.MockitoJUnitRunner;\n     @Target( { FIELD })\n     @Retention(RetentionPolicy.RUNTIME)\n     @Deprecated\n-    public @interface Mock {}\n+    public @interface Mock {}    \n     \n     /**\n      * Initializes objects annotated with &#064;Mock for given testClass.\n         }\n     }\n \n-    private static void scan(Object testClass, Class<?> clazz) {\n+    static void scan(Object testClass, Class<?> clazz) {\n         AnnotationEngine annotationEngine = new GlobalConfiguration().getAnnotationEngine();\n         Field[] fields = clazz.getDeclaredFields();\n         for (Field field : fields) {\n-            boolean alreadyAssigned = false;\n-            for(Annotation annotation : field.getAnnotations()) {\n-                Object mock = annotationEngine.createMockFor(annotation, field);\n-                if (mock != null) {\n-                    throwIfAlreadyAssigned(field, alreadyAssigned);\n-                    alreadyAssigned = true;\n-                    boolean wasAccessible = field.isAccessible();\n-                    field.setAccessible(true);\n-                    try {\n-                        field.set(testClass, mock);\n-                    } catch (IllegalAccessException e) {\n-                        throw new MockitoException(\"Problems setting field \" + field.getName() + \" annotated with \"\n-                                + annotation, e);\n-                    } finally {\n-                        field.setAccessible(wasAccessible);\n-                    }    \n-                }\n+            if (annotationEngine.getClass() != new DefaultMockitoConfiguration().getAnnotationEngine().getClass()) {\n+                //this means user has his own annotation engine and we have to respect that.\n+                //we will do annotation processing the old way so that we are backwards compatible\n+                processAnnotationDeprecatedWay(annotationEngine, testClass, field);                \n+            } \n+            //act 'the new' way\n+            annotationEngine.process(clazz, testClass);\n+        }\n+    }\n+\n+    static void processAnnotationDeprecatedWay(AnnotationEngine annotationEngine, Object testClass, Field field) {\n+        boolean alreadyAssigned = false;\n+        for(Annotation annotation : field.getAnnotations()) {\n+            Object mock = annotationEngine.createMockFor(annotation, field);\n+            if (mock != null) {\n+                throwIfAlreadyAssigned(field, alreadyAssigned);\n+                alreadyAssigned = true;\n+                boolean wasAccessible = field.isAccessible();\n+                field.setAccessible(true);\n+                try {\n+                    field.set(testClass, mock);\n+                } catch (IllegalAccessException e) {\n+                    throw new MockitoException(\"Problems setting field \" + field.getName() + \" annotated with \"\n+                            + annotation, e);\n+                } finally {\n+                    field.setAccessible(wasAccessible);\n+                }    \n             }\n         }\n     }\n \n-    private static void throwIfAlreadyAssigned(Field field, boolean alreadyAssigned) {\n+    static void throwIfAlreadyAssigned(Field field, boolean alreadyAssigned) {\n         if (alreadyAssigned) {\n-            throw new MockitoException(\"You cannot have more than one Mockito annotation on a field!\\n\" +\n-            \t\t\"The field '\" + field.getName() + \"' has multiple Mockito annotations.\\n\" +\n-            \t\t\"For info how to use annotations see examples in javadoc for MockitoAnnotations class.\");\n+            new Reporter().moreThanOneAnnotationNotAllowed(field.getName());\n         }\n     }\n }\n--- a/src/org/mockito/configuration/AnnotationEngine.java\n+++ b/src/org/mockito/configuration/AnnotationEngine.java\n public interface AnnotationEngine {\n \n     /**\n+     * @Deprecated\n+     * Please use AnnotationProcessor 'execute' method instead that is more robust\n+     * <p>\n      * Creates mock, ArgumentCaptor or wraps field instance in spy object.\n      * Only if of correct annotation type.\n      *\n      * @param field\n      * @return\n      */\n+    @Deprecated\n     Object createMockFor(Annotation annotation, Field field);\n \n+    /**\n+     * Allows extending the interface to perform action on specific fields on the test class\n+     * <p>\n+     * See the implementation of this method to figure out what is it for\n+     * \n+     * @param context\n+     * @param testClass \n+     */\n+    void process(Class<?> context, Object testClass);\n }\n--- a/src/org/mockito/configuration/DefaultMockitoConfiguration.java\n+++ b/src/org/mockito/configuration/DefaultMockitoConfiguration.java\n package org.mockito.configuration;\n \n import org.mockito.ReturnValues;\n-import org.mockito.internal.configuration.DefaultAnnotationEngine;\n+import org.mockito.internal.configuration.InjectingAnnotationEngine;\n import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues;\n import org.mockito.stubbing.Answer;\n \n      * @see org.mockito.IMockitoConfiguration#getAnnotationEngine()\n      */\n     public AnnotationEngine getAnnotationEngine() {\n-        return new DefaultAnnotationEngine();\n+        return new InjectingAnnotationEngine();\n     }\n \n     /* (non-Javadoc)\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n                 \"However, it is possible to stub toString(). Stubbing toString() smells a bit funny but there are rare, legitimate use cases.\"\n         ));\n     }\n+\n+    public void moreThanOneAnnotationNotAllowed(String fieldName) {\n+        throw new MockitoException(\"You cannot have more than one Mockito annotation on a field!\\n\" +\n+                \"The field '\" + fieldName + \"' has multiple Mockito annotations.\\n\" +\n+                \"For info how to use annotations see examples in javadoc for MockitoAnnotations class.\");\n+    }\n+\n+    public void unsupportedCombinationOfAnnotations(String undesiredAnnotationOne, String undesiredAnnotationTwo) {\n+        throw new MockitoException(\"This combination of annotations is not permitted on a single field:\\n\" +\n+                \"@\" + undesiredAnnotationOne + \" and @\" + undesiredAnnotationTwo);   \n+    }\n }\n--- a/src/org/mockito/internal/MockHandlerInterface.java\n+++ b/src/org/mockito/internal/MockHandlerInterface.java\n import org.mockito.stubbing.Answer;\n import org.mockito.stubbing.VoidMethodStubbable;\n \n+@SuppressWarnings(\"unchecked\")\n public interface MockHandlerInterface<T> {\n \n     MockSettingsImpl getMockSettings();\n     void verifyNoMoreInteractions();\n \n     VoidMethodStubbable<T> voidMethodStubbable(T mock);\n-\n+    \n     void setAnswersForStubbing(List<Answer> answers);\n \n     InvocationContainer getInvocationContainer();\n--- a/src/org/mockito/internal/configuration/DefaultAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/DefaultAnnotationEngine.java\n  */\n package org.mockito.internal.configuration;\n \n-import org.mockito.*;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.MockSettings;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n import org.mockito.configuration.AnnotationEngine;\n+import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.MockitoException;\n-\n-import java.lang.annotation.Annotation;\n-import java.lang.reflect.*;\n \n /**\n  * Initializes fields annotated with &#64;{@link org.mockito.Mock} or &#64;{@link org.mockito.Captor}.\n     /* (non-Javadoc)\n     * @see org.mockito.AnnotationEngine#createMockFor(java.lang.annotation.Annotation, java.lang.reflect.Field)\n     */\n-\n     @SuppressWarnings(\"deprecation\")\n     public Object createMockFor(Annotation annotation, Field field) {\n-        if (annotation instanceof Mock || annotation instanceof org.mockito.MockitoAnnotations.Mock) {\n-            return Mockito.mock(field.getType(), field.getName());\n+        if (annotation instanceof Mock) {\n+            return processAnnotationOn((Mock) annotation, field);\n         }\n-\n+        if (annotation instanceof MockitoAnnotations.Mock) {\n+            return processAnnotationOn((MockitoAnnotations.Mock) annotation, field);\n+        }\n         if (annotation instanceof Captor) {\n-            Class<?> type = field.getType();\n-            if (!ArgumentCaptor.class.isAssignableFrom(type)) {\n-                throw new MockitoException(\"@Captor field must be of the type ArgumentCaptor.\\n\" +\n-                \t\t\"Field: '\" + field.getName() + \"' has wrong type\\n\" +\n-                \t\t//TODO add javadocs\n-                \t\t\"For info how to use @Captor annotations see examples in javadoc for MockitoAnnotations class.\");\n-            }\n-\n-            return ArgumentCaptor.forClass(Object.class);\n-        }\n-\n-        if (annotation instanceof Spy) {\n-            throw new IllegalArgumentException(\"@Spy is not yet supported.\");\n-        }\n+            return processAnnotationOn((Captor) annotation, field);\n+        }        \n \n         return null;\n     }\n+    \n+    private Object processAnnotationOn(Mock annotation, Field field) {\n+        MockSettings mockSettings = Mockito.withSettings();\n+        if (annotation.extraInterfaces().length > 0) { // never null\n+            mockSettings.extraInterfaces(annotation.extraInterfaces());\n+        }\n+        if (\"\".equals(annotation.name())) {\n+            mockSettings.name(field.getName());\n+        } else {\n+            mockSettings.name(annotation.name());\n+        }\n+\n+        // see @Mock answer default value\n+        mockSettings.defaultAnswer(annotation.answer().get());\n+        return Mockito.mock(field.getType(), mockSettings);\n+    }\n+\n+    private Object processAnnotationOn(org.mockito.MockitoAnnotations.Mock annotation, Field field) {\n+        return Mockito.mock(field.getType(), field.getName());\n+    }\n+\n+    private Object processAnnotationOn(Captor annotation, Field field) {\n+        Class<?> type = field.getType();\n+        if (!ArgumentCaptor.class.isAssignableFrom(type)) {\n+            throw new MockitoException(\"@Captor field must be of the type ArgumentCaptor.\\n\" + \"Field: '\"\n+                    + field.getName() + \"' has wrong type\\n\"\n+                    + \"For info how to use @Captor annotations see examples in javadoc for MockitoAnnotations class.\");\n+        }\n+        return ArgumentCaptor.forClass(Object.class); // Object.class due to\n+                                                      // erasure\n+    }       \n+\n+    @Override\n+    public void process(Class<?> clazz, Object testClass) {\n+        Field[] fields = clazz.getDeclaredFields();\n+        for (Field field : fields) {\n+            boolean alreadyAssigned = false;\n+            for(Annotation annotation : field.getAnnotations()) {           \n+                Object mock = createMockFor(annotation, field);\n+                if (mock != null) {\n+                    throwIfAlreadyAssigned(field, alreadyAssigned);\n+                    alreadyAssigned = true;\n+                    //TODO this is deprecated all over the place\n+                    boolean wasAccessible = field.isAccessible();\n+                    field.setAccessible(true);\n+                    try {\n+                        field.set(testClass, mock);\n+                    } catch (IllegalAccessException e) {\n+                        throw new MockitoException(\"Problems setting field \" + field.getName() + \" annotated with \"\n+                                + annotation, e);\n+                    } finally {\n+                        field.setAccessible(wasAccessible);\n+                    }    \n+                }        \n+            }\n+        }\n+    }\n+    \n+    void throwIfAlreadyAssigned(Field field, boolean alreadyAssigned) {\n+        if (alreadyAssigned) {\n+            new Reporter().moreThanOneAnnotationNotAllowed(field.getName());\n+        }\n+    }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\n+package org.mockito.internal.configuration;\n+\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.util.MockUtil;\n+\n+/**\n+ * Initializes mock/spies dependencies for fields annotated with &#064;InjectMock\n+ * <p/>\n+ * See {@link org.mockito.MockitoAnnotations}\n+ */\n+public class DefaultInjectionEngine {\n+\t\n+    private final MockUtil mockUtil = new MockUtil();\n+\n+    // for each tested\n+    // - for each field of tested\n+    //   - find mock candidate by type\n+    //   - if more than *one* find mock candidate on name\n+    //   - if one mock candidate then set mock\n+    //   - else don't fail, user will then provide dependencies\n+\tpublic void injectMocksOnFields(Set<Field> testClassFields, Set<Object> mocks, Object testClass) {\n+        for (Field field : testClassFields) {\n+            Object fieldInstance = null;\n+            boolean wasAccessible = field.isAccessible();\n+            field.setAccessible(true);\n+            try {\n+                fieldInstance = field.get(testClass);\n+            } catch (IllegalAccessException e) {\n+                throw new MockitoException(\"Problems injecting dependencies in \" + field.getName(), e);\n+            } finally {\n+                field.setAccessible(wasAccessible);\n+            }\n+\n+            // for each field in the class hierarchy\n+            Class<?> fieldClass = fieldInstance.getClass();\n+            while (fieldClass != Object.class) {\n+                injectMockCandidate(fieldClass, mocks, fieldInstance);\n+                fieldClass = fieldClass.getSuperclass();\n+            }\n+        }\n+    }\n+\n+    private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n+        // TODO refactor using a CoR, maybe configured with config.\n+        for(Field field : awaitingInjectionClazz.getDeclaredFields()) {\n+            List<Object> mockCandidates = selectMockCondidatesOnType(mocks, field.getType());\n+            if(mockCandidates.size() > 1) {\n+                mockCandidates = selectMockCandidateOnName(mockCandidates, field.getName());\n+            }\n+            if(mockCandidates.size() == 1) {\n+                inject(field, fieldInstance, mockCandidates.get(0));\n+            } else {\n+                // don't fail, the user need to provide other dependencies\n+            }\n+        }\n+    }\n+\n+    private void inject(Field field, Object fieldInstance, Object matchingMock) {\n+        boolean wasAccessible = field.isAccessible();\n+        field.setAccessible(true);\n+        try {\n+            field.set(fieldInstance, matchingMock);\n+        } catch (IllegalAccessException e) {\n+            throw new MockitoException(\"Problems injecting dependency in \" + field.getName(), e);\n+        } finally {\n+            field.setAccessible(wasAccessible);\n+        }\n+    }\n+\n+    private List<Object> selectMockCandidateOnName(Collection<Object> mocks, String fieldName) {\n+        List<Object> mockNameMatches = new ArrayList<Object>();\n+        for (Object mock : mocks) {\n+            if(fieldName.equals(mockUtil.getMockName(mock).toString())) {\n+                mockNameMatches.add(mock);\n+            }\n+        }\n+\t\treturn mockNameMatches;\n+    }\n+\n+    private List<Object> selectMockCondidatesOnType(Collection<Object> mocks, Class<?> fieldClass) {\n+        List<Object> mockTypeMatches = new ArrayList<Object>();\n+        for (Object mock : mocks) {\n+            if(fieldClass.isAssignableFrom(mock.getClass())) {\n+                mockTypeMatches.add(mock);\n+            }\n+        }\n+        return mockTypeMatches;\n+    }\n+}\n--- a/src/org/mockito/internal/configuration/GlobalConfiguration.java\n+++ b/src/org/mockito/internal/configuration/GlobalConfiguration.java\n  */\n @SuppressWarnings(\"deprecation\")//supressed until ReturnValues are removed\n public class GlobalConfiguration implements IMockitoConfiguration {\n-    \n+\n     private static ThreadLocal<IMockitoConfiguration> globalConfiguration = new ThreadLocal<IMockitoConfiguration>();\n \n     //back door for testing\n     IMockitoConfiguration getIt() {\n         return globalConfiguration.get();\n     }\n-    \n+\n     public GlobalConfiguration() {\n         //Configuration should be loaded only once but I cannot really test it\n         if (globalConfiguration.get() == null) {\n             globalConfiguration.set(createConfig());\n         }\n     }\n-    \n+\n     private IMockitoConfiguration createConfig() {\n         IMockitoConfiguration defaultConfiguration = new DefaultMockitoConfiguration();\n         IMockitoConfiguration config = new ClassPathLoader().loadConfiguration();\n             return defaultConfiguration;\n         }\n     }\n-    \n+\n     public static void validate() {\n         new GlobalConfiguration();\n     }\n-    \n+\n     public ReturnValues getReturnValues() {\n         return globalConfiguration.get().getReturnValues();\n     }\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/InjectingAnnotationEngine.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.configuration;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.mockito.Captor;\n+import org.mockito.InjectMock;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.Spy;\n+import org.mockito.MockitoAnnotations.Mock;\n+import org.mockito.configuration.AnnotationEngine;\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.base.MockitoException;\n+\n+/**\n+ * See {@link MockitoAnnotations}\n+ */\n+@SuppressWarnings({\"deprecation\", \"unchecked\"})\n+public class InjectingAnnotationEngine implements AnnotationEngine {\n+    \n+    AnnotationEngine delegate = new DefaultAnnotationEngine();\n+    AnnotationEngine spyAnnotationEngine = new SpyAnnotationEngine();\n+    \n+    /* (non-Javadoc)\n+    * @see org.mockito.AnnotationEngine#createMockFor(java.lang.annotation.Annotation, java.lang.reflect.Field)\n+    */    \n+    public Object createMockFor(Annotation annotation, Field field) {\n+        return delegate.createMockFor(annotation, field);\n+    }\n+    \n+    @Override\n+    public void process(Class<?> context, Object testClass) {\n+        //this will create @Mocks, @Captors, etc:\n+        delegate.process(context, testClass);\n+        //this will create @Spies:\n+        spyAnnotationEngine.process(context, testClass);\n+        \n+        //this injects mocks\n+        Field[] fields = context.getDeclaredFields();\n+        for (Field field : fields) {\n+            if (field.isAnnotationPresent(InjectMock.class)) {\n+                assertNoAnnotations(field, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);\n+                injectMocks(testClass);\n+            }\n+        }\n+    } \n+    \n+    void assertNoAnnotations(Field field, Class ... annotations) {\n+        for (Class annotation : annotations) {\n+            if (field.isAnnotationPresent(annotation)) {\n+                new Reporter().unsupportedCombinationOfAnnotations(annotation.getSimpleName(), InjectMock.class.getSimpleName());\n+            }\n+        }        \n+    }\n+\n+    /**\n+     * Initializes mock/spies dependencies for objects annotated with\n+     * &#064;InjectMock for given testClass.\n+     * <p>\n+     * See examples in javadoc for {@link MockitoAnnotations} class.\n+     * \n+     * @param testClass\n+     *            Test class, usually <code>this</code>\n+     */\n+    public void injectMocks(Object testClass) {       \n+        Class<?> clazz = testClass.getClass();\n+        Set<Field> mockDependents = new HashSet<Field>();\n+        Set<Object> mocks = new HashSet<Object>();\n+        \n+        while (clazz != Object.class) {\n+            mockDependents.addAll(scanForInjection(testClass, clazz));\n+            mocks.addAll(scanMocks(testClass, clazz));\n+            clazz = clazz.getSuperclass();\n+        }\n+        \n+        new DefaultInjectionEngine().injectMocksOnFields(mockDependents, mocks, testClass);\n+    }\n+\n+    private static Set<Field> scanForInjection(Object testClass, Class<?> clazz) {\n+        Set<Field> testedFields = new HashSet<Field>();\n+        Field[] fields = clazz.getDeclaredFields();\n+        for (Field field : fields) {\n+            if (null != field.getAnnotation(InjectMock.class)) {\n+                InjectMock injectMockAnnotation = (InjectMock) field.getAnnotation(InjectMock.class);\n+                testedFields.add(field);\n+            }\n+        }\n+\n+        return testedFields;\n+    }\n+\n+    private static Set<Object> scanMocks(Object testClass, Class<?> clazz) {\n+        Set<Object> mocks = new HashSet<Object>();\n+        for (Field field : clazz.getDeclaredFields()) {\n+            // mock or spies only\n+            if (null != field.getAnnotation(Spy.class) || null != field.getAnnotation(org.mockito.Mock.class)\n+                    || null != field.getAnnotation(Mock.class)) {\n+                Object fieldInstance = null;\n+                boolean wasAccessible = field.isAccessible();\n+                field.setAccessible(true);\n+                try {\n+                    fieldInstance = field.get(testClass);\n+                } catch (IllegalAccessException e) {\n+                    throw new MockitoException(\"Problems injecting dependencies in \" + field.getName(), e);\n+                } finally {\n+                    field.setAccessible(wasAccessible);\n+                }\n+                if (fieldInstance != null) {\n+                    mocks.add(fieldInstance);\n+                }\n+            }\n+        }\n+        return mocks;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/SpyAnnotationEngine.java\n+package org.mockito.internal.configuration;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.Spy;\n+import org.mockito.configuration.AnnotationEngine;\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.util.MockUtil;\n+\n+@SuppressWarnings({\"deprecation\", \"unchecked\"})\n+public class SpyAnnotationEngine implements AnnotationEngine {\n+\n+    @Override\n+    public Object createMockFor(Annotation annotation, Field field) {\n+        return null;\n+    }\n+    \n+    @Override\n+    public void process(Class<?> context, Object testClass) {\n+        Field[] fields = context.getDeclaredFields();\n+        for (Field field : fields) {\n+            if (field.isAnnotationPresent(Spy.class)) {\n+                assertNoAnnotations(Spy.class, field, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);\n+                boolean wasAccessible = field.isAccessible();\n+                field.setAccessible(true);\n+                try {\n+                    Object instance = field.get(testClass);\n+                    if (instance == null) {\n+                        throw new MockitoException(\"Cannot create a @Spy for '\" + field.getName() + \"' field because the instance is missing\\n\" +\n+                                  \"Example of correct usage of @Spy:\\n\" +\n+                            \t  \"   @Spy List mock = new LinkedList();\\n\" +\n+                            \t  \"   //also, don't forget about MockitoAnnotations.initMocks();\");\n+\n+                    }\n+                    if (new MockUtil().isMock(instance)) { \n+                        // instance has been spied earlier\n+                        Mockito.reset(instance);\n+                    } else {\n+                        field.set(testClass, Mockito.spy(instance));\n+                    }\n+                } catch (IllegalAccessException e) {\n+                    throw new MockitoException(\"Problems initiating spied field \" + field.getName(), e);\n+                } finally {\n+                    field.setAccessible(wasAccessible);\n+                }\n+            }\n+        }\n+    }\n+    \n+    //TODO duplicated elsewhere\n+    void assertNoAnnotations(Class annotation, Field field, Class ... undesiredAnnotations) {\n+        for (Class u : undesiredAnnotations) {\n+            if (field.isAnnotationPresent(u)) {\n+                new Reporter().unsupportedCombinationOfAnnotations(annotation.getSimpleName(), annotation.getClass().getSimpleName());\n+            }\n+        }        \n+    }    \n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/Answers.java\n+package org.mockito.internal.stubbing.defaultanswers;\n+\n+import org.mockito.internal.stubbing.answers.CallsRealMethods;\n+import org.mockito.stubbing.Answer;\n+\n+/**\n+ * Enumeration of pre-configured mock answers\n+ */\n+//TODO should be AnswersEnum?\n+public enum Answers {\n+\n+    RETURNS_DEFAULTS(new GloballyConfiguredAnswer()),\n+    RETURNS_SMART_NULLS(new ReturnsSmartNulls()),\n+    RETURNS_MOCKS(new ReturnsMocks()),\n+    RETURNS_DEEP_STUBS(new ReturnsDeepStubs()),\n+    CALLS_REAL_METHODS(new CallsRealMethods())\n+\t;\n+\n+    private Answer<Object> implementation;\n+\n+    private Answers(Answer<Object> implementation) {\n+        this.implementation = implementation;\n+    }\n+\n+    public Answer<Object> get() {\n+        return implementation;\n+    }\n+}\n--- a/src/org/mockito/internal/util/junit/JUnitFailureHacker.java\n+++ b/src/org/mockito/internal/util/junit/JUnitFailureHacker.java\n     }\n \n     private boolean isEmpty(String warnings) {\n-        return warnings == null || warnings.isEmpty(); \n+        return warnings == null || \"\".equals(warnings); // isEmpty() is in JDK 6+ \n     }   \n }\n--- a/test/org/mockito/configuration/MockitoConfiguration.java\n+++ b/test/org/mockito/configuration/MockitoConfiguration.java\n import java.lang.reflect.Field;\n \n import org.mockito.Mockito;\n-import org.mockito.internal.configuration.DefaultAnnotationEngine;\n+import org.mockito.internal.configuration.InjectingAnnotationEngine;\n import org.mockito.stubbing.Answer;\n import org.mockitousage.configuration.SmartMock;\n \n \n     private Answer<Object> overriddenDefaultAnswer = null;\n     private boolean cleansStackTrace;\n+    private AnnotationEngine overriddenEngine;\n \n     //for testing purposes, allow to override the configuration\n     public void overrideDefaultAnswer(Answer<Object> defaultAnswer) {\n     //for testing purposes, allow to override the configuration\n     public void overrideCleansStackTrace(boolean cleansStackTrace) {\n         this.cleansStackTrace = cleansStackTrace;\n+    }\n+    \n+    //for testing purposes, allow to override the annotation engine\n+    public void overrideAnnotationEngine(AnnotationEngine engine) {\n+        this.overriddenEngine = engine;\n     }\n \n     @Override\n     \n     @Override\n     public AnnotationEngine getAnnotationEngine() {\n-        return new DefaultAnnotationEngine() {\n+        if (this.overriddenEngine != null) {\n+            return this.overriddenEngine;\n+        }\n+        return new InjectingAnnotationEngine() {\n             @Override\n             public Object createMockFor(Annotation annotation, Field field) {\n                 if (annotation instanceof SmartMock) {\n--- a/test/org/mockitousage/basicapi/AnnotationsTest.java\n+++ b/test/org/mockitousage/basicapi/AnnotationsTest.java\n package org.mockitousage.basicapi;\n \n import static org.mockito.Mockito.*;\n+import static org.mockito.internal.stubbing.defaultanswers.Answers.RETURNS_MOCKS;\n+import static org.mockito.internal.stubbing.defaultanswers.Answers.RETURNS_DEFAULTS;\n \n import java.lang.annotation.Retention;\n import java.lang.annotation.RetentionPolicy;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n+import java.util.*;\n \n import org.junit.Before;\n import org.junit.Test;\n-import org.mockito.Mock;\n-import org.mockito.MockitoAnnotations;\n+import org.mockito.*;\n import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.stubbing.defaultanswers.Answers;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n \n     @Mock List list;\n     @Mock final Map map = new HashMap();\n+        \n     @NotAMock Set notAMock;\n-    \n+\n     @SuppressWarnings(\"deprecation\")\n     @MockitoAnnotations.Mock List listTwo;\n-    \n+\n     @Before\n     public void setup() {\n         MockitoAnnotations.initMocks(this);\n     }\n-    \n+\n     @Test\n     public void shouldInitMocks() throws Exception {\n         list.clear();\n         map.clear();\n         listTwo.clear();\n-        \n+\n         verify(list).clear();\n         verify(map).clear();\n         verify(listTwo).clear();\n     }\n-    \n+\n     @Test\n     public void shouldScreamWhenInitializingMocksForNullClass() throws Exception {\n         try {\n                     e.getMessage());\n         }\n     }\n-    \n+\n     @Test\n     public void shouldLookForAnnotatedMocksInSuperClasses() throws Exception {\n         Sub sub = new Sub();\n         MockitoAnnotations.initMocks(sub);\n-        \n+\n         assertNotNull(sub.getMock());\n         assertNotNull(sub.getBaseMock());\n         assertNotNull(sub.getSuperBaseMock());\n     }\n     \n+    @Mock(answer = RETURNS_MOCKS, name = \"i have a name\") IMethods namedAndReturningMocks;\n+    @Mock(answer = RETURNS_DEFAULTS) IMethods returningDefaults;\n+    @Mock(extraInterfaces = {List.class}) IMethods hasExtraInterfaces;\n+    @Mock() IMethods noExtraConfig;\n+\n+    @Test\n+    public void shouldInitMocksWithGivenSettings() throws Exception {\n+        assertEquals(\"i have a name\", namedAndReturningMocks.toString());\n+        assertNotNull(namedAndReturningMocks.iMethodsReturningMethod());\n+       \n+        assertEquals(\"returningDefaults\", returningDefaults.toString());\n+        assertEquals(0, returningDefaults.intReturningMethod()); \n+        \n+        assertTrue(hasExtraInterfaces instanceof List);\n+        \n+        assertEquals(0, noExtraConfig.intReturningMethod());        \n+    }\n+\n     class SuperBase {\n         @Mock private IMethods mock;\n-        \n+\n         public IMethods getSuperBaseMock() {\n             return mock;\n         }\n     }\n-    \n+\n     class Base extends SuperBase {\n         @Mock private IMethods mock;\n-        \n+\n         public IMethods getBaseMock() {\n             return mock;\n         }\n     }\n-    \n+\n     class Sub extends Base {\n         @Mock private IMethods mock;\n-        \n+\n         public IMethods getMock() {\n             return mock;\n         }\n--- /dev/null\n+++ b/test/org/mockitousage/basicapi/DeprecatedAnnotationEngineApiTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.basicapi;\n+\n+import org.junit.After;\n+import org.junit.Test;\n+import org.mockito.InjectMock;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.configuration.AnnotationEngine;\n+import org.mockito.configuration.DefaultMockitoConfiguration;\n+import org.mockito.internal.configuration.ConfigurationAccess;\n+import org.mockito.internal.configuration.DefaultAnnotationEngine;\n+import org.mockitoutil.TestBase;\n+\n+public class DeprecatedAnnotationEngineApiTest extends TestBase {\n+\n+    @After\n+    public void goBackToDefaultConfiguration() {\n+        ConfigurationAccess.getConfig().overrideAnnotationEngine(null);\n+    }\n+    \n+    class SimpleTest {\n+        @InjectMock Tested tested = new Tested();\n+        @Mock Dependency mock;\n+    }\n+    \n+    class Tested {        \n+        Dependency dependency;\n+        public void setDependency(Dependency dependency) {\n+            this.dependency = dependency;\n+        }        \n+    }\n+    \n+    class Dependency {}\n+    \n+    @Test\n+    public void shouldInjectMocksIfThereIsNoUserDefinedEngine() throws Exception {\n+        //given\n+        AnnotationEngine defaultEngine = new DefaultMockitoConfiguration().getAnnotationEngine();\n+        ConfigurationAccess.getConfig().overrideAnnotationEngine(defaultEngine);\n+        SimpleTest test = new SimpleTest();\n+        \n+        //when\n+        MockitoAnnotations.initMocks(test);\n+        \n+        //then   \n+        assertNotNull(test.mock);\n+        assertNotNull(test.tested.dependency);\n+        assertSame(test.mock, test.tested.dependency);\n+    }\n+    \n+    @Test\n+    public void shouldRespectUsersEngine() throws Exception {\n+        //given\n+        AnnotationEngine customizedEngine = new DefaultAnnotationEngine() { /**/ };\n+        ConfigurationAccess.getConfig().overrideAnnotationEngine(customizedEngine);\n+        SimpleTest test = new SimpleTest();\n+        \n+        //when\n+        MockitoAnnotations.initMocks(test);\n+        \n+        //then   \n+        assertNotNull(test.mock);\n+        assertNull(test.tested.dependency);\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/basicapi/MockInjectionTest.java\n+package org.mockitousage.basicapi;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.InjectMock;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.Spy;\n+import org.mockitoutil.TestBase;\n+\n+import java.util.*;\n+\n+public class MockInjectionTest extends TestBase {\n+\n+\tprivate SuperUnderTest superUnderTestWithoutInjection = new SuperUnderTest();\n+\t@InjectMock private SuperUnderTest superUnderTest = new SuperUnderTest();\n+\t@InjectMock private BaseUnderTest baseUnderTest = new BaseUnderTest();\n+\t@InjectMock private SubUnderTest subUnderTest = new SubUnderTest();\n+\t@InjectMock private OtherBaseUnderTest otherBaseUnderTest = new OtherBaseUnderTest();\n+\t@Mock private Map map;\n+\t@Mock private List list;\n+\t@Mock private Set set;\n+\t@Mock private Set histogram1;\n+\t@Mock private Set histogram2;\n+\t@Spy private TreeSet searchTree = new TreeSet();\n+\n+\t@Before\n+\tpublic void init() {\n+\t\t// initMocks called in TestBase Before method, so instances ar not the same\n+\t\tMockitoAnnotations.initMocks(this);\n+\t}\n+\n+\t@Test\n+\tpublic void shouldInjectMocksIfAnnotated() {\n+\t\tMockitoAnnotations.initMocks(this);\n+\t\tassertSame(list, superUnderTest.getAList());\n+\t}\n+\n+\t@Test\n+\tpublic void shouldNotInjectIfNotAnnotated() {\n+\t\tMockitoAnnotations.initMocks(this);\n+\t\tassertNull(superUnderTestWithoutInjection.getAList());\n+\t}\n+\n+\t@Test\n+\tpublic void shouldInjectMocksForClassHierarchyIfAnnotated() {\n+\t\tMockitoAnnotations.initMocks(this);\n+\t\tassertSame(list, baseUnderTest.getAList());\n+\t\tassertSame(map, baseUnderTest.getAMap());\n+\t}\n+\n+\t@Test\n+\tpublic void shouldInjectMocksByName() {\n+\t\tMockitoAnnotations.initMocks(this);\n+\t\tassertSame(histogram1, subUnderTest.getHistogram1());\n+\t\tassertSame(histogram2, subUnderTest.getHistogram2());\n+\t}\n+\n+\t@Test\n+\tpublic void shouldInjectSpies() {\n+\t\tMockitoAnnotations.initMocks(this);\n+\t\tassertSame(searchTree, otherBaseUnderTest.getSearchTree());\n+\t}\n+\n+\tclass SuperUnderTest {\n+\n+\t\tprivate List aList;\n+\n+\t\tpublic List getAList() {\n+\t\t\treturn aList;\n+\t\t}\n+\t}\n+\n+\tclass BaseUnderTest extends SuperUnderTest {\n+\t\tprivate Map aMap;\n+\n+\t\tpublic Map getAMap() {\n+\t\t\treturn aMap;\n+\t\t}\n+\t}\n+\n+\tclass OtherBaseUnderTest extends SuperUnderTest {\n+\t\tprivate TreeSet searchTree;\n+\n+\t\tpublic TreeSet getSearchTree() {\n+\t\t\treturn searchTree;\n+\t\t}\n+\t}\n+\n+\tclass SubUnderTest extends BaseUnderTest {\n+\t\tprivate Set histogram1;\n+\t\tprivate Set histogram2;\n+\n+\t\tpublic Set getHistogram1() {\n+\t\t\treturn histogram1;\n+\t\t}\n+\n+\t\tpublic Set getHistogram2() {\n+\t\t\treturn histogram2;\n+\t\t}\n+\t}\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/basicapi/SpyAnnotationTest.java\n+package org.mockitousage.basicapi;\n+\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.Test;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.Spy;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockitoutil.TestBase;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class SpyAnnotationTest extends TestBase {\n+    //TODO check if works when base class has initMocks()\n+\t@Spy\n+\tfinal List spiedList = new ArrayList();\n+\n+\t@Test\n+    public void shouldInitSpies() throws Exception {\n+        doReturn(\"foo\").when(spiedList).get(10);\n+\n+        assertEquals(\"foo\", spiedList.get(10));\n+        assertTrue(spiedList.isEmpty());\n+    }\n+\n+    @Test(expected = MockitoException.class)\n+    public void shouldFailIfFieldIsNotInitialized() throws Exception {\n+\t\tclass FailingSpy {\n+\t\t\t@Spy private List mySpy;\n+\n+\t\t\tpublic List getMySpy() {\n+\t\t\t\treturn mySpy;\n+\t\t\t}\n+\t\t}\n+\n+\t\tMockitoAnnotations.initMocks(new FailingSpy());\n+    }\n+\n+\t@Test(expected = IndexOutOfBoundsException.class)\n+    public void shouldResetSpies() throws Exception {\n+        spiedList.get(10); // see shouldInitSpy\n+    }\n+\t\n+\t//TODO unsupported combinations of annotations (spy - captor, spy - mock)\n+\t//TODO unsupported combinations of annotations (captor - mock)\n+}\n--- a/test/org/mockitousage/junitrunner/JUnit44RunnerTest.java\n+++ b/test/org/mockitousage/junitrunner/JUnit44RunnerTest.java\n  */\n package org.mockitousage.junitrunner;\n \n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertEquals;\n import static org.mockito.Mockito.verify;\n import static org.mockitousage.junitrunner.Filters.methodNameContains;\n \n import org.junit.runner.Description;\n import org.junit.runner.RunWith;\n import org.junit.runner.manipulation.Filter;\n+import org.mockito.InjectMock;\n import org.mockito.Mock;\n import org.mockito.runners.MockitoJUnit44Runner;\n import org.mockitoutil.TestBase;\n \n @RunWith(MockitoJUnit44Runner.class)\n @SuppressWarnings( { \"unchecked\", \"deprecation\" })\n-public class JUnit44RunnerTest extends TestBase {\n+public class JUnit44RunnerTest {\n+\n+\t@InjectMock\n+\tprivate ListDependent listDependent = new ListDependent();\n \n \t@Mock\n \tprivate List list;\n \t\tlist.add(\"test\");\n \t\tverify(list).add(\"test\");\n \t}\n-\t\n+\t@Test\n+\tpublic void shouldInjectMocksUsingRunner() {\n+\t\tassertSame(list, listDependent.getList());\n+\t}\n+\n \t@Test\n     public void shouldFilterTestMethodsCorrectly() throws Exception{\n \t\tMockitoJUnit44Runner runner = new MockitoJUnit44Runner(this.getClass());\n-    \t\n+\n     \trunner.filter(methodNameContains(\"shouldInitMocksUsingRunner\"));\n-    \t\n+\n     \tassertEquals(1, runner.testCount());\n     }\n+\n+\tclass ListDependent {\n+\t\tprivate List list;\n+\n+\t\tpublic List getList() {\n+\t\t\treturn list;\n+\t\t}\n+\t}\n }\n--- a/test/org/mockitousage/junitrunner/JUnit45RunnerTest.java\n+++ b/test/org/mockitousage/junitrunner/JUnit45RunnerTest.java\n  */\n package org.mockitousage.junitrunner;\n \n-import static org.mockito.Mockito.verify;\n-import static org.mockitousage.junitrunner.Filters.methodNameContains;\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+import static org.mockitousage.junitrunner.Filters.*;\n \n import java.util.List;\n \n import org.junit.Test;\n import org.junit.runner.RunWith;\n+import org.mockito.InjectMock;\n import org.mockito.Mock;\n import org.mockito.runners.MockitoJUnitRunner;\n-import org.mockitoutil.TestBase;\n \n @RunWith(MockitoJUnitRunner.class)\n @SuppressWarnings(\"unchecked\")\n-public class JUnit45RunnerTest extends TestBase {\n-    \n+public class JUnit45RunnerTest {\n+\n+\t@InjectMock private ListDependent listDependent = new ListDependent();\n     @Mock private List list;\n-    \n+\n     @Test\n     public void shouldInitMocksUsingRunner() {\n         list.add(\"test\");\n         verify(list).add(\"test\");\n     }\n-    \n+\n+    @Test\n+    public void shouldInjectMocksUsingRunner() {\n+        assertNotNull(list);\n+        assertSame(list, listDependent.getList());\n+    }\n+\n     @Test\n     public void shouldFilterTestMethodsCorrectly() throws Exception{\n     \tMockitoJUnitRunner runner = new MockitoJUnitRunner(this.getClass());\n-    \t\n+\n     \trunner.filter(methodNameContains(\"shouldInitMocksUsingRunner\"));\n-    \t\n+\n     \tassertEquals(1, runner.testCount());\n     }\n+\n+\tclass ListDependent {\n+\t\tprivate List list;\n+\n+\t\tpublic List getList() {\n+\t\t\treturn list;\n+\t\t}\n+\t}\n }", "timestamp": 1266695471, "metainfo": ""}