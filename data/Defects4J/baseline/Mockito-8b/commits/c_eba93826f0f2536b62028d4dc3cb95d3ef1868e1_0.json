{"sha": "eba93826f0f2536b62028d4dc3cb95d3ef1868e1", "log": "Fixed issue #30, sequence number was globally unique only in single thread scope. I made verification in order not working properly when multiple threads interact with shared mock.  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401068", "commit": "\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n import org.mockito.internal.progress.DeprecatedOngoingStubbing;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.NewOngoingStubbing;\n+import org.mockito.internal.progress.SequenceNumber;\n import org.mockito.internal.stubbing.DoesNothing;\n import org.mockito.internal.stubbing.MockitoStubber;\n import org.mockito.internal.stubbing.Returns;\n     public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n         if (mockitoStubber.hasAnswersForStubbing()) {\n             //stubbing voids with stubVoid() or doAnswer() style\n-            Invocation invocation = new Invocation(proxy, method, args, mockingProgress.nextSequenceNumber());\n+            Invocation invocation = new Invocation(proxy, method, args, SequenceNumber.next());\n             InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(invocation);\n             mockitoStubber.setMethodForStubbing(invocationMatcher);\n             return null;\n         VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n         mockingProgress.validateState();\n \n-        Invocation invocation = new Invocation(proxy, method, args, mockingProgress.nextSequenceNumber());\n+        Invocation invocation = new Invocation(proxy, method, args, SequenceNumber.next());\n         InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(invocation);\n \n         if (verificationMode != null) {\n--- a/src/org/mockito/internal/progress/MockingProgress.java\n+++ b/src/org/mockito/internal/progress/MockingProgress.java\n \n     void stubbingCompleted();\n     \n-    int nextSequenceNumber();\n-\n     void validateState();\n \n     void reset();\n--- a/src/org/mockito/internal/progress/MockingProgressImpl.java\n+++ b/src/org/mockito/internal/progress/MockingProgressImpl.java\n     \n     private OngoingStubbing ongoingStubbing;\n     private VerificationMode verificationMode;\n-    private int invocationSequenceNumber = 1;\n     private boolean stubbingInProgress = false;\n \n     public void reportOngoingStubbing(OngoingStubbing ongoingStubbing) {\n         VerificationMode temp = verificationMode;\n         verificationMode = null;\n         return temp;\n-    }\n-\n-    public int nextSequenceNumber() {\n-        return invocationSequenceNumber++;\n     }\n \n     public void stubbingStarted() {\n     public String toString() {\n         return  \"ongoingStubbing: \" + ongoingStubbing + \n         \", verificationMode: \" + verificationMode +\n-        \", invocationSequenceNumber: \" + invocationSequenceNumber +\n         \", stubbingInProgress: \" + stubbingInProgress;\n     }\n \n     public void reset() {\n         stubbingInProgress = false;\n         verificationMode = null;\n-        invocationSequenceNumber = 1;\n     }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/progress/SequenceNumber.java\n+package org.mockito.internal.progress;\n+\n+public class SequenceNumber {\n+    \n+    private static int sequenceNumber = 1;\n+\n+    public static synchronized int next() {\n+        return sequenceNumber++;\n+    }\n+}\n--- a/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java\n+++ b/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java\n         return threadSafely().pullVerificationMode();\n     }\n \n-    public int nextSequenceNumber() {\n-        return threadSafely().nextSequenceNumber();\n-    }\n-\n     public void stubbingStarted() {\n         threadSafely().stubbingStarted();\n     }\n--- a/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n+++ b/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n                     StackTrackeChangingTest.class,\n                     ExampleTest.class,\n                     PointingStackTraceToActualInvocationTest.class,\n-                    PointingStackTraceToActualInvocationChunkTest.class\n+                    PointingStackTraceToActualInvocationChunkTest.class,\n+                    VerificationInOrderFromMultipleThreadsTest.class\n                 );\n                 \n                 if (!result.wasSuccessful()) {\n--- /dev/null\n+++ b/test/org/concurrentmockito/VerificationInOrderFromMultipleThreadsTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.concurrentmockito;\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.Test;\n+import org.mockito.InOrder;\n+import org.mockitoutil.TestBase;\n+\n+public class VerificationInOrderFromMultipleThreadsTest extends TestBase {\n+    \n+    @Test\n+    public void shouldVerifyInOrderWhenMultipleThreadsInteractWithMock() throws Exception {\n+        final Foo testInf = mock(Foo.class);\n+        \n+        Thread threadOne = new Thread(new Runnable(){\n+            public void run() {\n+                testInf.methodOne();\n+            }\n+        });\n+        threadOne.start();\n+        threadOne.join();\n+        \n+        Thread threadTwo = new Thread(new Runnable(){\n+            public void run() {\n+                testInf.methodTwo();\n+            }\n+        });\n+        threadTwo.start();\n+        threadTwo.join();\n+        \n+        InOrder inOrder = inOrder(testInf);\n+        inOrder.verify(testInf).methodOne();\n+        inOrder.verify(testInf).methodTwo();\n+    }\n+    \n+    public interface Foo {\n+        void methodOne();\n+        void methodTwo();\n+    }\n+}", "timestamp": 1225543152, "metainfo": ""}