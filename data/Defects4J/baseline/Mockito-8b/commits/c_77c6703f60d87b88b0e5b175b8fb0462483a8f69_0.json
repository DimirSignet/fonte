{"sha": "77c6703f60d87b88b0e5b175b8fb0462483a8f69", "log": "Mock Candidate for @InjectMock selection is now a Chain of Responsability", "commit": "\n--- a/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\n+++ b/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\n \n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.util.MockUtil;\n+import org.mockito.internal.configuration.injection.FinalMockCandidateFilter;\n+import org.mockito.internal.configuration.injection.MockCandidateFilter;\n+import org.mockito.internal.configuration.injection.NameBasedCandidateFilter;\n+import org.mockito.internal.configuration.injection.TypeBasedCandidateFilter;\n import org.mockito.internal.util.reflection.FieldInitializer;\n-import org.mockito.internal.util.reflection.FieldSetter;\n \n import java.lang.reflect.Field;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.List;\n import java.util.Set;\n \n /**\n  */\n public class DefaultInjectionEngine {\n \t\n-    private final MockUtil mockUtil = new MockUtil();\n+    private final MockCandidateFilter mockCandidateFilter = new TypeBasedCandidateFilter(new NameBasedCandidateFilter(new FinalMockCandidateFilter()));\n \n     // for each tested\n     // - for each field of tested\n     }\n \n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n-        // TODO refactor using a CoR, maybe configured with config.\n         for(Field field : awaitingInjectionClazz.getDeclaredFields()) {\n-            List<Object> mockCandidates = selectMockCondidatesOnType(mocks, field.getType());\n-            if(mockCandidates.size() > 1) {\n-                mockCandidates = selectMockCandidateOnName(mockCandidates, field.getName());\n-            }\n-            if(mockCandidates.size() == 1) {\n-                inject(field, fieldInstance, mockCandidates.get(0));\n-            } else {\n-                // don't fail, the user need to provide other dependencies\n-            }\n+            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n         }\n     }\n \n-    private void inject(Field field, Object fieldInstance, Object matchingMock) {\n-        try {\n-            new FieldSetter(fieldInstance, field).set(matchingMock);\n-        } catch (Exception e) {\n-            throw new MockitoException(\"Problems injecting dependency in \" + field.getName(), e);\n-        }\n-    }\n-\n-    private List<Object> selectMockCandidateOnName(Collection<Object> mocks, String fieldName) {\n-        List<Object> mockNameMatches = new ArrayList<Object>();\n-        for (Object mock : mocks) {\n-            if(fieldName.equals(mockUtil.getMockName(mock).toString())) {\n-                mockNameMatches.add(mock);\n-            }\n-        }\n-\t\treturn mockNameMatches;\n-    }\n-\n-    private List<Object> selectMockCondidatesOnType(Collection<Object> mocks, Class<?> fieldClass) {\n-        List<Object> mockTypeMatches = new ArrayList<Object>();\n-        for (Object mock : mocks) {\n-            if(fieldClass.isAssignableFrom(mock.getClass())) {\n-                mockTypeMatches.add(mock);\n-            }\n-        }\n-        return mockTypeMatches;\n-    }\n-\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/injection/FinalMockCandidateFilter.java\n+package org.mockito.internal.configuration.injection;\n+\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.util.reflection.FieldSetter;\n+\n+import java.lang.reflect.Field;\n+import java.util.Collection;\n+\n+/**\n+ * This node returns an actual injecter which will be either :\n+ *\n+ * <ul>\n+ * <li>an {@link Injecter} that do nothing if a candidate couldn't be found</li>\n+ * <li>an {@link Injecter} that do will inject the final candidate to the field</li>\n+ * </ul>\n+ */\n+public class FinalMockCandidateFilter implements MockCandidateFilter {\n+    public Injecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) {\n+        if(mocks.size() == 1) {\n+            final Object matchingMock = mocks.iterator().next();\n+\n+            return new Injecter() {\n+                public boolean thenInject() {\n+                    try {\n+                        new FieldSetter(fieldInstance, field).set(matchingMock);\n+                    } catch (Exception e) {\n+                        throw new MockitoException(\"Problems injecting dependency in \" + field.getName(), e);\n+                    }\n+                    return true;\n+                }\n+            };\n+        }\n+\n+        return new Injecter() {\n+            public boolean thenInject() {\n+                return false;\n+            }\n+        };\n+\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/injection/Injecter.java\n+package org.mockito.internal.configuration.injection;\n+\n+/**\n+ * Created by IntelliJ IDEA.\n+ * User: brice\n+ * Date: 23 oct. 2010\n+ * Time: 18:01:48\n+ * To change this template use File | Settings | File Templates.\n+ */\n+public interface Injecter {\n+\n+    boolean thenInject();\n+\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/injection/MockCandidateFilter.java\n+package org.mockito.internal.configuration.injection;\n+\n+import java.lang.reflect.Field;\n+import java.util.Collection;\n+\n+public interface MockCandidateFilter {\n+\n+    Injecter filterCandidate(\n+            Collection<Object> mocks,\n+            Field fieldToBeInjected,\n+            Object fieldInstance\n+    );\n+\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/injection/NameBasedCandidateFilter.java\n+package org.mockito.internal.configuration.injection;\n+\n+import org.mockito.internal.util.MockUtil;\n+\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+public class NameBasedCandidateFilter implements MockCandidateFilter {\n+    private final MockCandidateFilter next;\n+    private final MockUtil mockUtil = new MockUtil();\n+\n+    public NameBasedCandidateFilter(MockCandidateFilter next) {\n+        this.next = next;\n+    }\n+\n+    public Injecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {\n+        List<Object> mockNameMatches = new ArrayList<Object>();\n+        if(mocks.size() > 1) {\n+            for (Object mock : mocks) {\n+                if (field.getName().equals(mockUtil.getMockName(mock).toString())) {\n+                    mockNameMatches.add(mock);\n+                }\n+            }\n+            return next.filterCandidate(mockNameMatches, field, fieldInstance);\n+        }\n+        return next.filterCandidate(mocks, field, fieldInstance);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/injection/TypeBasedCandidateFilter.java\n+package org.mockito.internal.configuration.injection;\n+\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+public class TypeBasedCandidateFilter implements MockCandidateFilter {\n+\n+    MockCandidateFilter next;\n+\n+    public TypeBasedCandidateFilter(MockCandidateFilter next) {\n+        this.next = next;\n+    }\n+\n+    public Injecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {\n+        List<Object> mockTypeMatches = new ArrayList<Object>();\n+        for (Object mock : mocks) {\n+            if (field.getType().isAssignableFrom(mock.getClass())) {\n+                mockTypeMatches.add(mock);\n+            }\n+        }\n+\n+        return next.filterCandidate(mockTypeMatches, field, fieldInstance);\n+    }\n+}", "timestamp": 1288718028, "metainfo": ""}