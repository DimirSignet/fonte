{"sha": "0acfb6f8bf329c328b4c7b4d9866ea4fd31bf23c", "log": "tiny, tiny refactorings. got rid of one TODO  --HG-- rename : test/org/mockito/usage/MockitoExploitsTest.java => test/org/mockito/usage/InvalidUsageTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%4033", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n //        MockitoState.instance().stubbingStarted();\n         \n         //TODO increment number of stubs\n-        MockitoExpectation controlToStub = MockitoState.instance().removeControlToBeStubbed();\n+        MockitoExpectation controlToStub = MockitoState.instance().pullControlToBeStubbed();\n         if (controlToStub == null) {\n             throw new MissingMethodInvocationException();\n         }\n--- a/src/org/mockito/internal/MockitoControl.java\n+++ b/src/org/mockito/internal/MockitoControl.java\n     }\n \n     public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n-        VerifyingMode verifyingMode = mockitoState.removeVerifyingMode();\n+        VerifyingMode verifyingMode = mockitoState.pullVerifyingMode();\n         \n         Invocation invocation = new Invocation(proxy, method, args);\n         List<IArgumentMatcher> lastMatchers = lastArguments.pullMatchers();\n         \n         behavior.addInvocation(invocationWithMatchers);\n         \n-        if (mockitoState.settingThrowableOnVoidMethodScenario()) {\n-            Throwable throwable = mockitoState.removeThrowableToBeSetOnVoidMethod();\n-        \n+        Throwable throwable = mockitoState.pullThrowableToBeSetOnVoidMethod();\n+        if (throwable != null) {\n             andThrows(throwable);\n             return null;\n         }\n     }\n \n     public MethodSelector<T> toThrow(Throwable throwable) {\n-        //TODO refactor so we don't use static state to keep the throwable\n         mockitoState.reportThrowableToBeSetOnVoidMethod(throwable);\n         return this;\n     }\n--- a/src/org/mockito/internal/MockitoState.java\n+++ b/src/org/mockito/internal/MockitoState.java\n \n import org.mockito.exceptions.UnfinishedVerificationException;\n \n-/**\n- * state. therefore dangerous and may have nasty bugs.\n- * TODO look at every method that changes state and make sure the state is cleared afterwards\n- * \n- * @author sfaber\n- */\n @SuppressWarnings(\"unchecked\")\n public class MockitoState {\n     \n         controlForStubbing.set(mockitoControl);\n     }\n \n-    public synchronized MockitoExpectation removeControlToBeStubbed() {\n+    public synchronized MockitoExpectation pullControlToBeStubbed() {\n         MockitoControl control = controlForStubbing.get();\n         controlForStubbing.set(null);\n         return control;\n         }\n     }\n \n-    public synchronized boolean verificationScenario() {\n-        return verifyingModeLocal.get() != null; \n-    }\n-\n-    public synchronized VerifyingMode removeVerifyingMode() {\n+    public synchronized VerifyingMode pullVerifyingMode() {\n         VerifyingMode verifyingMode = verifyingModeLocal.get();\n         verifyingModeLocal.set(null);\n         return verifyingMode;\n     }\n \n     public synchronized void reportThrowableToBeSetOnVoidMethod(Throwable throwable) {\n+        //TODO refactor so we don't use static state to keep the throwable. we \n+        //can set it directly to mockcontrol or something and keep this pseudo static class thinner\n+        \n         throwableToBeSetOnVoidMethod.set(throwable);\n     }\n \n-    public synchronized Throwable removeThrowableToBeSetOnVoidMethod() {\n+    public synchronized Throwable pullThrowableToBeSetOnVoidMethod() {\n         Throwable throwable = throwableToBeSetOnVoidMethod.get();\n         throwableToBeSetOnVoidMethod.set(null);\n         return throwable;\n-    }\n-\n-    public synchronized boolean settingThrowableOnVoidMethodScenario() {\n-        return throwableToBeSetOnVoidMethod.get() != null; \n     }\n \n //    public void stubbingStarted() {\n--- a/test/org/mockito/MockitoTest.java\n+++ b/test/org/mockito/MockitoTest.java\n         List mock = Mockito.mock(List.class);\n         Mockito.stub(mock.add(\"test\")).andReturn(true);\n         \n-        assertNull(MockitoState.instance().removeControlToBeStubbed());\n+        assertNull(MockitoState.instance().pullControlToBeStubbed());\n     }\n     \n     @Test(expected=NotAMockException.class)\n--- a/test/org/mockito/internal/MockitoControlTest.java\n+++ b/test/org/mockito/internal/MockitoControlTest.java\n     }\n     \n     @Test\n-    public void shouldClearVerificationModeEvenWhenInvalidMatchers() throws Throwable {\n+    public void shouldRemoveVerificationModeEvenWhenInvalidMatchers() throws Throwable {\n         MockitoState state = MockitoState.instance(); \n         LastArguments lastArguments = LastArguments.instance();\n         \n         } catch (InvalidUseOfMatchersException e) {\n         }\n         \n-        assertFalse(state.verificationScenario());\n+        assertNull(state.pullVerifyingMode());\n     }\n }\n--- a/test/org/mockito/internal/MockitoStateTest.java\n+++ b/test/org/mockito/internal/MockitoStateTest.java\n     \n     @Test\n     public void shouldSwitchVerifyingMode() throws Exception {\n-        assertFalse(mockitoState.verificationScenario());\n+        assertNull(mockitoState.pullVerifyingMode());\n         \n         VerifyingMode mode = VerifyingMode.times(19);\n         \n         mockitoState.verifyingStarted(mode);\n         \n-        assertTrue(mockitoState.verificationScenario());\n-        \n-        assertSame(mode, mockitoState.removeVerifyingMode());\n+        assertSame(mode, mockitoState.pullVerifyingMode());\n     }\n     \n     @Test\n--- /dev/null\n+++ b/test/org/mockito/usage/InvalidUsageTest.java\n+package org.mockito.usage;\n+\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.*;\n+\n+import java.util.List;\n+\n+import org.junit.*;\n+import org.mockito.exceptions.*;\n+import org.mockito.internal.StateResetter;\n+\n+/**\n+ * invalid state happens if:\n+ *    -unfinished stubbing\n+ *    -unfinished stubVoid\n+ *    -stubbing without actual method call\n+ *    -verify without actual method call\n+ *    \n+ * we should aim to detect invalid state in following scenarios:\n+ *    -on method call on mock\n+ *    -on verify\n+ *    -on verifyZeroInteractions\n+ *    -on verifyNoMoreInteractions\n+ *    -on stub\n+ *    -on stubVoid\n+ *    \n+ * obviously we should consider if it is really important to cover all those naughty usage\n+ */\n+@SuppressWarnings(\"unchecked\")\n+public class InvalidUsageTest {\n+    \n+    private List mock;\n+\n+    @Before\n+    @After\n+    public void resetState() {\n+        StateResetter.reset();\n+        mock = mock(List.class);\n+    }\n+    \n+    @Test\n+    public void shouldDetectStubbingWithoutMethodCallOnMock() {\n+        try {\n+            stub(\"blah\".contains(\"blah\"));\n+            fail();\n+        } catch (MissingMethodInvocationException e) {\n+            //cool\n+        }\n+    }\n+    \n+    @Ignore\n+    @Test\n+    public void unfinishedStubbingDetectedOnVerify() {\n+        stub(mock.add(\"test\"));\n+        \n+        try {\n+            verifyZeroInteractions(mock);\n+            fail();\n+        } catch (UnfinishedStubbingException e) {}\n+    }\n+    \n+    @Ignore\n+    @Test\n+    public void unfinishedStubbingDetectedWhenAnotherStubbingIsStarted() {\n+        stub(mock.add(\"test\"));\n+        \n+        try {\n+            stub(mock.add(\"test\")).andThrows(new Exception(\"ssdf\"));\n+            fail();\n+        } catch (UnfinishedStubbingException e) {}\n+    }\n+    \n+    @Ignore\n+    @Test\n+    public void unfinishedStubbingDetectedMockCalled() {\n+        stub(mock.add(\"test\"));\n+        \n+        try {\n+            mock.clear();\n+            fail();\n+        } catch (UnfinishedStubbingException e) {}\n+    }\n+    \n+    @Ignore\n+    @Test\n+    public void unfinishedStubbingVoid() {\n+        stubVoid(mock);\n+        \n+        try {\n+            mock.clear();\n+            fail();\n+        } catch (UnfinishedStubbingException e) {}\n+    }\n+}", "timestamp": 1195431738, "metainfo": ""}