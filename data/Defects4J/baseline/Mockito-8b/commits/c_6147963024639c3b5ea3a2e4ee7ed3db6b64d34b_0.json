{"sha": "6147963024639c3b5ea3a2e4ee7ed3db6b64d34b", "log": "issue 353 - @InjectMocks behaved differently between Java 6 and 7. Also tweaked the property/field injection with a second pass to allow injection in some edge cases.", "commit": "\n--- a/src/org/mockito/InjectMocks.java\n+++ b/src/org/mockito/InjectMocks.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito;\n \n import java.lang.annotation.Documented;\n  *\n  *     <li><strong>Property setter injection</strong>; mocks will first be resolved by type,\n  *     then, if there is several property of the same type, by the match of the property name and the mock name.\n- *     <p><u>Note:</u> If &#064;InjectMocks instance wasn't initialized before and have a no-arg constructor,\n+ *     <p><u>Note 1:</u> If you have properties with the same type (or same erasure), it's better to name all &#064;Mock\n+ *     annotated fields with the matching properties, otherwise Mockito might get confused and injection won't happen.</p>\n+ *     <p><u>Note 2:</u> If &#064;InjectMocks instance wasn't initialized before and have a no-arg constructor,\n  *     then it will be initialized with this constructor.</p></li>\n  *\n  *     <li><strong>Field injection</strong>; mocks will first be resolved by type,\n  *     then, if there is several property of the same type, by the match of the field name and the mock name.\n- *     <p><u>Note:</u> If &#064;InjectMocks instance wasn't initialized before and have a no-arg constructor,\n+ *     <p><u>Note 1:</u> If you have fields with the same type (or same erasure), it's better to name all &#064;Mock\n+ *     annotated fields with the matching fields, otherwise Mockito might get confused and injection won't happen.</p>\n+ *     <p><u>Note 2:</u> If &#064;InjectMocks instance wasn't initialized before and have a no-arg constructor,\n  *     then it will be initialized with this constructor.</p></li>\n  * </ol>\n  * </p>\n--- a/src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java\n+++ b/src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java\n  * <u>Algorithm :<br></u>\n  * for each field annotated by @InjectMocks\n  *   <ul>\n- *   <li>copy mocks set\n  *   <li>initialize field annotated by @InjectMocks\n- *   <li>for each field in @InjectMocks type ordered from sub-type to super-type\n+ *   <li>for each fields of a class in @InjectMocks type hierarchy\n  *     <ul>\n- *     <li>find mock candidate by type\n- *     <li>if more than <b>*one*</b> candidate find mock candidate on name\n- *     <li>if one mock candidate then\n- *       <ul>\n- *       <li>set mock by property setter if possible\n- *       <li>else set mock by field injection\n- *       </ul>\n- *     <li>remove mock from mocks copy (mocks are just injected once)\n+ *     <li>make a copy of mock candidates\n+ *     <li>order fields rom sub-type to super-type, then by field name\n+ *     <li>for the list of fields in a class try two passes of :\n+ *         <ul>\n+ *             <li>find mock candidate by type\n+ *             <li>if more than <b>*one*</b> candidate find mock candidate on name\n+ *             <li>if one mock candidate then\n+ *                 <ul>\n+ *                     <li>set mock by property setter if possible\n+ *                     <li>else set mock by field injection\n+ *                 </ul>\n+ *             <li>remove mock from mocks copy (mocks are just injected once in a class)\n+ *             <li>remove injected field from list of class fields\n+ *         </ul>\n  *     <li>else don't fail, user will then provide dependencies\n  *     </ul>\n  *   </ul>\n public class PropertyAndSetterInjection extends MockInjectionStrategy {\n \n     private final MockCandidateFilter mockCandidateFilter = new TypeBasedCandidateFilter(new NameBasedCandidateFilter(new FinalMockCandidateFilter()));\n-    private Comparator<Field> superTypesLast = new Comparator<Field>() {\n-        public int compare(Field field1, Field field2) {\n-            Class<?> field1Type = field1.getType();\n-            Class<?> field2Type = field2.getType();\n-\n-            if(field1Type.isAssignableFrom(field2Type)) {\n-                return 1;\n-            }\n-            if(field2Type.isAssignableFrom(field1Type)) {\n-                return -1;\n-            }\n-            return 0;\n-        }\n-    };\n+    private Comparator<Field> superTypesLast = new FieldTypeAndNameComparator();\n \n     private ListUtil.Filter<Field> notFinalOrStatic = new ListUtil.Filter<Field>() {\n         public boolean isOut(Field object) {\n     };\n \n \n-    public boolean processInjection(Field field, Object fieldOwner, Set<Object> mockCandidates) {\n+    public boolean processInjection(Field injectMocksField, Object injectMocksFieldOwner, Set<Object> mockCandidates) {\n         // Set<Object> mocksToBeInjected = new HashSet<Object>(mockCandidates);\n+        FieldInitializationReport report = initializeInjectMocksField(injectMocksField, injectMocksFieldOwner);\n+\n+        // for each field in the class hierarchy\n+        boolean injectionOccurred = false;\n+        Class<?> fieldClass = report.fieldClass();\n+        Object fieldInstanceNeedingInjection = report.fieldInstance();\n+        while (fieldClass != Object.class) {\n+            injectionOccurred |= injectMockCandidates(fieldClass, newMockSafeHashSet(mockCandidates), fieldInstanceNeedingInjection);\n+            fieldClass = fieldClass.getSuperclass();\n+        }\n+        return injectionOccurred;\n+    }\n+\n+    private FieldInitializationReport initializeInjectMocksField(Field field, Object fieldOwner) {\n         FieldInitializationReport report = null;\n         try {\n             report = new FieldInitializer(fieldOwner, field).initialize();\n             }\n             new Reporter().cannotInitializeForInjectMocksAnnotation(field.getName(), e);\n         }\n+        return report; // never null\n+    }\n \n \n-        // for each field in the class hierarchy\n+    private boolean injectMockCandidates(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object instance) {\n         boolean injectionOccurred = false;\n-        Class<?> fieldClass = report.fieldClass();\n-        Object fieldInstanceNeedingInjection = report.fieldInstance();\n-        while (fieldClass != Object.class) {\n-            injectionOccurred |= injectMockCandidate(fieldClass, newMockSafeHashSet(mockCandidates), fieldInstanceNeedingInjection);\n-            fieldClass = fieldClass.getSuperclass();\n-        }\n+        List<Field> orderedInstanceFields = orderedInstanceFieldsFrom(awaitingInjectionClazz);\n+        // pass 1\n+        injectionOccurred |= injectMockCandidatesOnFields(mocks, instance, injectionOccurred, orderedInstanceFields);\n+        // pass 2\n+        injectionOccurred |= injectMockCandidatesOnFields(mocks, instance, injectionOccurred, orderedInstanceFields);\n         return injectionOccurred;\n     }\n \n-\n-\n-    private boolean injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object instance) {\n-        boolean injectionOccurred = false;\n-        for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n+    private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) {\n+        for (Iterator<Field> it = orderedInstanceFields.iterator(); it.hasNext(); ) {\n+            Field field = it.next();\n             Object injected = mockCandidateFilter.filterCandidate(mocks, field, instance).thenInject();\n-            if(injected != null) {\n+            if (injected != null) {\n                 injectionOccurred |= true;\n                 mocks.remove(injected);\n+                it.remove();\n             }\n         }\n         return injectionOccurred;\n         return declaredFields;\n     }\n \n+    static class FieldTypeAndNameComparator implements Comparator<Field> {\n+        public int compare(Field field1, Field field2) {\n+            Class<?> field1Type = field1.getType();\n+            Class<?> field2Type = field2.getType();\n+\n+            // if same type, compares on field name\n+            if (field1Type == field2Type) {\n+                return field1.getName().compareTo(field2.getName());\n+            }\n+            if(field1Type.isAssignableFrom(field2Type)) {\n+                return 1;\n+            }\n+            if(field2Type.isAssignableFrom(field1Type)) {\n+                return -1;\n+            }\n+            return 0;\n+        }\n+    }\n }\n--- /dev/null\n+++ b/test/org/mockito/internal/configuration/injection/FieldTypeAndNameComparatorTest.java\n+package org.mockito.internal.configuration.injection;\n+\n+import org.junit.Test;\n+\n+import java.lang.reflect.Field;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+\n+@SuppressWarnings(\"unused\")\n+public class FieldTypeAndNameComparatorTest {\n+\n+    private Object objectA;\n+    private Object objectB;\n+\n+    private Number numberA;\n+    private Number numberB;\n+\n+    private Integer integerA;\n+    private Integer integerB;\n+\n+    @Test\n+    public void when_same_type_the_order_is_based_on_field_name() throws Exception {\n+        assertThat(new PropertyAndSetterInjection.FieldTypeAndNameComparator().compare(field(\"objectA\"), field(\"objectB\"))).isEqualTo(-1);\n+        assertThat(new PropertyAndSetterInjection.FieldTypeAndNameComparator().compare(field(\"objectB\"), field(\"objectA\"))).isEqualTo(1);\n+        assertThat(new PropertyAndSetterInjection.FieldTypeAndNameComparator().compare(field(\"objectB\"), field(\"objectB\"))).isEqualTo(0);\n+    }\n+\n+    @Test\n+    public void when_type_is_different_the_supertype_comes_last() throws Exception {\n+        assertThat(new PropertyAndSetterInjection.FieldTypeAndNameComparator().compare(field(\"numberA\"), field(\"objectB\"))).isEqualTo(-1);\n+        assertThat(new PropertyAndSetterInjection.FieldTypeAndNameComparator().compare(field(\"objectB\"), field(\"numberA\"))).isEqualTo(1);\n+    }\n+\n+    @Test\n+    public void using_Collections_dot_sort() throws Exception {\n+        List<Field> unsortedFields = Arrays.asList(\n+                field(\"objectB\"),\n+                field(\"integerB\"),\n+                field(\"numberA\"),\n+                field(\"numberB\"),\n+                field(\"objectA\"),\n+                field(\"integerA\")\n+        );\n+\n+        Collections.sort(unsortedFields, new PropertyAndSetterInjection.FieldTypeAndNameComparator());\n+\n+        assertThat(unsortedFields).containsSequence(\n+                field(\"integerA\"),\n+                field(\"integerB\"),\n+                field(\"numberA\"),\n+                field(\"numberB\"),\n+                field(\"objectA\"),\n+                field(\"objectB\")\n+        );\n+    }\n+\n+\n+    @Test\n+    public void issue_352_order_was_different_between_JDK6_and_JDK7() throws Exception {\n+        List<Field> unsortedFields = Arrays.asList(\n+                field(\"objectB\"),\n+                field(\"objectA\")\n+        );\n+\n+        Collections.sort(unsortedFields, new PropertyAndSetterInjection.FieldTypeAndNameComparator());\n+\n+        assertThat(unsortedFields).containsSequence(\n+                field(\"objectA\"),\n+                field(\"objectB\")\n+        );\n+    }\n+\n+    private Field field(String field) throws NoSuchFieldException {\n+        return getClass().getDeclaredField(field);\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/bugs/Issue353InjectionMightNotHappenInCertainConfigurationTest.java\n+package org.mockitousage.bugs;\n+\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.runners.MockitoJUnitRunner;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.junit.Assert.assertSame;\n+\n+import java.util.*;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class Issue353InjectionMightNotHappenInCertainConfigurationTest {\n+    @Mock Map<String, String> stringString_that_matches_field;\n+    @Mock Map<String, Integer> mockStringInteger_was_not_injected;\n+    @InjectMocks FooService fooService;\n+\n+    @Test\n+    public void when_identical_types_and_the_correct_mock_name_is_greater_than_the_non_matching_name_then_injection_occurs_only_on_the_named_one() {\n+        assertThat(\"stringString_that_matches_field\".compareTo(\"mockStringInteger_was_not_injected\")).isGreaterThanOrEqualTo(1);\n+\n+        assertSame(stringString_that_matches_field, fooService.stringString_that_matches_field);\n+        assertSame(mockStringInteger_was_not_injected, fooService.stringInteger_field);\n+    }\n+\n+    public static class FooService {\n+        Map<String, Integer> stringInteger_field = new HashMap<String, Integer>();\n+        Map<String, String> stringString_that_matches_field = new HashMap<String, String>();\n+    }\n+\n+}", "timestamp": 1341181848, "metainfo": ""}