{"sha": "6d003fa8f57f5091ae10958f5175d1e7bedc2e29", "log": "small refactorings, removed testing exception message strings  --HG-- rename : test/org/mockito/usage/NiceMessagesOnInvalidUsageTest.java => test/org/mockito/usage/InvalidUsageExceptionsTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%4084", "commit": "\n--- a/src/org/mockito/internal/ExpectedInvocation.java\n+++ b/src/org/mockito/internal/ExpectedInvocation.java\n         return true;\n     }\n \n+    //TODO separate unit test?\n     public String toString() {\n-        StringBuffer result = new StringBuffer();\n-        result.append(invocation.getMockAndMethodName());\n-        result.append(\"(\");\n-        for (Iterator<IArgumentMatcher> it = matchers.iterator(); it.hasNext();) {\n-            it.next().appendTo(result);\n-            if (it.hasNext()) {\n-                result.append(\", \");\n-            }\n-        }\n-        result.append(\")\");\n-        return result.toString();\n+        return invocation.toString(matchers);\n     }\n \n     public Method getMethod() {\n--- a/src/org/mockito/internal/Invocation.java\n+++ b/src/org/mockito/internal/Invocation.java\n package org.mockito.internal;\n \n import java.lang.reflect.Method;\n+import java.util.*;\n \n import org.mockito.internal.matchers.*;\n \n         return arguments;\n     }\n \n-    //TODO add test that makes sure sequenceNumber doesnt take part in equals()\n     public boolean equals(Object o) {\n         if (o == null || !o.getClass().equals(this.getClass()))\n             return false;\n     }\n     \n     public String toString() {\n+        List<IArgumentMatcher> matchers = new LinkedList<IArgumentMatcher>();\n+        for (Object arg : this.arguments) {\n+            //TODO lil bit hacky way of using Equals matcher\n+            matchers.add(new Equals(arg));\n+        }\n+        return toString(matchers);\n+    }\n+    \n+    public String toString(List<IArgumentMatcher> matchers) {\n         //TODO separate unit test?\n         StringBuffer result = new StringBuffer();\n         result.append(getMockAndMethodName());\n         result.append(\"(\");\n-        for (Object arg : this.arguments) {\n-            //TODO lil bit hacky way of using Equals matcher\n-            new Equals(arg).appendTo(result);\n+        for (IArgumentMatcher matcher : matchers) {\n+            matcher.appendTo(result);\n             result.append(\", \");\n         }\n         return result.toString().replaceFirst(\", $\", \"\").concat(\")\");\n--- a/test/org/mockito/InvocationTest.java\n+++ b/test/org/mockito/InvocationTest.java\n \n import static org.junit.Assert.*;\n \n-import java.lang.reflect.Method;\n-\n-import org.junit.Before;\n-import org.junit.Test;\n-import org.mockito.internal.Invocation;\n+import org.junit.*;\n+import org.mockito.internal.*;\n \n public class InvocationTest {\n \n     private Invocation call;\n-\n     private Invocation equalCall;\n-\n     private Invocation nonEqualCall;\n-\n-    private Method dummyMethod;\n \n     @Before\n     public void setup() throws SecurityException, NoSuchMethodException {\n-        Object[] arguments1 = new Object[] { \"\" };\n-        Object[] arguments2 = new Object[] { \"\" };\n-        Object[] arguments3 = new Object[] { \"X\" };\n-        dummyMethod = Object.class.getMethod(\"equals\",\n-                new Class[] { Object.class });\n-        Object mock = new Object();\n-        call = new Invocation(mock, dummyMethod, arguments1, 0);\n-        equalCall = new Invocation(mock, dummyMethod, arguments2, 0);\n-        nonEqualCall = new Invocation(mock, dummyMethod, arguments3, 0);\n+        call = new InvocationBuilder().args(\"\").seq(1).toInvocation();\n+        equalCall = new InvocationBuilder().args(\"\").seq(2).toInvocation();\n+        nonEqualCall = new InvocationBuilder().args(\"X\").seq(3).toInvocation();\n     }\n \n     @Test\n         assertTrue(call.equals(equalCall));\n         assertFalse(call.equals(nonEqualCall));\n     }\n+    \n+    @Test\n+    public void shouldEqualToNotConsiderSequenceNumber() {\n+        assertTrue(call.getSequenceNumber() != equalCall.getSequenceNumber());\n+        assertTrue(call.equals(equalCall));\n+    }\n }\n--- a/test/org/mockito/internal/InvocationBuilder.java\n+++ b/test/org/mockito/internal/InvocationBuilder.java\n package org.mockito.internal;\n \n import java.lang.reflect.Method;\n+import java.util.*;\n \n import org.mockito.usage.IMethods;\n \n+@SuppressWarnings(\"unchecked\")\n public class InvocationBuilder {\n \n     private String methodName = \"simpleMethod\";\n     private int sequenceNumber = 0;\n+    private Object[] args = new Object[] {};\n \n     public Invocation toInvocation() {\n         Method method;\n+        List<Class> argTypes = new LinkedList<Class>();\n+        for (Object arg : args) {\n+            argTypes.add(arg.getClass());\n+        }\n+        \n         try {\n-            method = IMethods.class.getMethod(methodName, new Class[] {});\n+            method = IMethods.class.getMethod(methodName, argTypes.toArray(new Class[argTypes.size()]));\n         } catch (Exception e) {\n             throw new RuntimeException(e);\n         }\n-        Invocation i = new Invocation(\"mock\", method, new Object[] {}, sequenceNumber);\n+        Invocation i = new Invocation(\"mock\", method, args, sequenceNumber);\n         return i;\n     }\n \n-    public InvocationBuilder m(String methodName) {\n+    public InvocationBuilder method(String methodName) {\n         this.methodName  = methodName;\n         return this;\n     }\n \n-    public InvocationBuilder s(int sequenceNumber) {\n+    public InvocationBuilder seq(int sequenceNumber) {\n         this.sequenceNumber = sequenceNumber;\n         return this;\n     }\n+\n+    public InvocationBuilder args(Object ... args) {\n+        this.args = args;\n+        return this;\n+    }\n }\n--- a/test/org/mockito/internal/RegisteredInvocationsTest.java\n+++ b/test/org/mockito/internal/RegisteredInvocationsTest.java\n \n     @Before\n     public void setup() throws Exception {\n-        simpleMethodInvocation = new InvocationBuilder().m(\"simpleMethod\").s(1).toInvocation();\n-        simpleMethodInvocationTwo = new InvocationBuilder().m(\"simpleMethod\").s(2).toInvocation();\n-        differentMethodInvocation = new InvocationBuilder().m(\"differentMethod\").s(3).toInvocation();\n-        simpleMethodInvocationThree = new InvocationBuilder().m(\"simpleMethod\").s(4).toInvocation();\n+        simpleMethodInvocation = new InvocationBuilder().method(\"simpleMethod\").seq(1).toInvocation();\n+        simpleMethodInvocationTwo = new InvocationBuilder().method(\"simpleMethod\").seq(2).toInvocation();\n+        differentMethodInvocation = new InvocationBuilder().method(\"differentMethod\").seq(3).toInvocation();\n+        simpleMethodInvocationThree = new InvocationBuilder().method(\"simpleMethod\").seq(4).toInvocation();\n         \n         registered = new RegisteredInvocations(new InvocationsFinder() {\n             public List<Invocation> allInvocationsInOrder(List<Object> mocks) {\n--- /dev/null\n+++ b/test/org/mockito/usage/InvalidUsageExceptionsTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.usage;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import java.util.List;\n+\n+import org.junit.Test;\n+import org.mockito.Strictly;\n+import org.mockito.exceptions.MockitoException;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class InvalidUsageExceptionsTest {\n+    \n+    @Test\n+    public void shouldRequireArgumentsWhenVerifyingNoMoreInteractions() {\n+        try {\n+            verifyNoMoreInteractions();\n+            fail();\n+        }\n+        catch (MockitoException e) {}\n+    }\n+    \n+    @Test\n+    public void shouldRequireArgumentsWhenVerifyingZeroInteractions() {\n+        try {\n+            verifyZeroInteractions();\n+            fail();\n+        }\n+        catch (MockitoException e) {}\n+    }\n+    \n+    @Test\n+    public void shouldNotCreateStrictlyWithoutMocks() {\n+        try {\n+            createStrictOrderVerifier();\n+            fail();\n+        } catch (MockitoException e) {}\n+    }\n+    \n+    @Test\n+    public void shouldNotStrictlyVerifyUnfamilarMocks() {\n+        List mockOne = mock(List.class);\n+        List mockTwo = mock(List.class);\n+        Strictly strictly = createStrictOrderVerifier(mockOne);\n+        try {\n+            strictly.verify(mockTwo).clear();\n+            fail();\n+        } catch (MockitoException e) {}\n+    }\n+}", "timestamp": 1196261938, "metainfo": ""}