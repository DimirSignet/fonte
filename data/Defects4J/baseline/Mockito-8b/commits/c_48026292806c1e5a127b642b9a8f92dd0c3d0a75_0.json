{"sha": "48026292806c1e5a127b642b9a8f92dd0c3d0a75", "log": "first draft of doReturn() API  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40674", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n import org.mockito.internal.progress.ThreadSafeMockingProgress;\n import org.mockito.internal.progress.VerificationMode;\n import org.mockito.internal.progress.VerificationModeImpl;\n+import org.mockito.internal.stubbing.MethodSelector;\n+import org.mockito.internal.stubbing.MethodSelectorImpl;\n import org.mockito.internal.stubbing.VoidMethodStubbable;\n import org.mockito.internal.util.MockUtil;\n import org.mockito.stubbing.Answer;\n         MOCKING_PROGRESS.stubbingStarted();\n         return handler.voidMethodStubbable();\n     }\n+    \n+    public static MethodSelector doReturn(Object toBeReturned) {\n+        MOCKING_PROGRESS.stubbingStarted();\n+        return new MethodSelectorImpl(toBeReturned);\n+    }\n+    \n+    public static MethodSelector doThrow(Throwable toBeThrown) {\n+        MOCKING_PROGRESS.stubbingStarted();\n+        return new MethodSelectorImpl(null);\n+    }\n \n     /**\n      * Creates InOrder object that allows verifying mocks in order.\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n             return this;\n         }\n     }\n+\n+    public void setAnswerForStubbing(Answer<?> answer) {\n+        stubber.addAnswerForVoidMethod(answer);\n+    }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/MethodSelector.java\n+package org.mockito.internal.stubbing;\n+\n+public interface MethodSelector {\n+\n+    <T> T when(T mock);\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/MethodSelectorImpl.java\n+package org.mockito.internal.stubbing;\n+\n+import org.mockito.internal.util.MockUtil;\n+\n+public class MethodSelectorImpl implements MethodSelector {\n+\n+    private final Object toBeReturned;\n+\n+    public MethodSelectorImpl(Object toBeReturned) {\n+        this.toBeReturned = toBeReturned;\n+    }\n+\n+    public <T> T when(T mock) {\n+        MockUtil.getMockHandler(mock).setAnswerForStubbing(new Returns(toBeReturned));\n+        return mock;\n+    }\n+}\n--- a/src/org/mockito/internal/stubbing/Stubber.java\n+++ b/src/org/mockito/internal/stubbing/Stubber.java\n         return null;\n     }\n \n+    //TODO it's not for void method any more\n     public void addAnswerForVoidMethod(Answer answer) {\n         answersForVoidMethod.add(answer);\n     }\n--- a/test/org/mockitousage/misuse/InvalidStateDetectionTest.java\n+++ b/test/org/mockitousage/misuse/InvalidStateDetectionTest.java\n         \n         stub(mock.simpleMethod());\n         detects(new OnVerifyNoMoreInteractions(), UnfinishedStubbingException.class);\n+        \n+        stub(mock.simpleMethod());\n+        detects(new OnDoReturn(), UnfinishedStubbingException.class);\n     }\n     \n     @Test\n         \n         stubVoid(mock);\n         detects(new OnVerifyNoMoreInteractions(), UnfinishedStubbingException.class);\n+        \n+        stubVoid(mock);\n+        detects(new OnDoReturn(), UnfinishedStubbingException.class);\n     }\n     \n     @Test\n         \n         verify(mock);\n         detects(new OnVerifyNoMoreInteractions(), UnfinishedVerificationException.class);\n+        \n+        verify(mock);\n+        detects(new OnDoReturn(), UnfinishedVerificationException.class);\n     }\n     \n     @Test\n         public void detect(IMethods mock) {\n             verifyNoMoreInteractions(mock);\n         }\n-    }    \n+    }   \n+    \n+    //TODO add other doX() methods as well\n+    private static class OnDoReturn implements DetectsInvalidState {\n+        public void detect(IMethods mock) {\n+            doReturn(null);\n+        }\n+    }  \n     \n     private static class OnStub implements DetectsInvalidState {\n         public void detect(IMethods mock) {\n--- /dev/null\n+++ b/test/org/mockitousage/stubbing/StubbingUsingDoReturnTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.stubbing;\n+\n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.*;\n+\n+import java.util.List;\n+\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.mockito.TestBase;\n+import org.mockito.MockitoAnnotations.Mock;\n+import org.mockito.exceptions.verification.ArgumentsAreDifferent;\n+import org.mockito.exceptions.verification.NoInteractionsWanted;\n+import org.mockitousage.IMethods;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class StubbingUsingDoReturnTest extends TestBase {\n+\n+    @Mock private IMethods mock;\n+\n+    @Test\n+    public void shouldStub() throws Exception {\n+        doReturn(\"foo\").when(mock).simpleMethod();\n+        doReturn(\"bar\").when(mock).simpleMethod();\n+        \n+        assertEquals(\"bar\", mock.simpleMethod());\n+    }\n+    \n+    @Test\n+    public void shouldStubWithArgs() throws Exception {\n+        doReturn(\"foo\").when(mock).simpleMethod(\"foo\");\n+        doReturn(\"bar\").when(mock).simpleMethod(eq(\"one\"), anyInt());\n+        \n+        assertEquals(\"foo\", mock.simpleMethod(\"foo\"));\n+        assertEquals(\"bar\", mock.simpleMethod(\"one\", 234));\n+        assertEquals(null, mock.simpleMethod(\"xxx\", 234));\n+    }\n+    \n+    @SuppressWarnings(\"serial\")\n+    class FooException extends RuntimeException {}\n+    \n+    @Ignore\n+    @Test\n+    public void shouldStubWithThrowable() throws Exception {\n+        doThrow(new FooException()).when(mock).voidMethod();\n+        try {\n+            mock.voidMethod();\n+            fail();\n+        } catch (FooException e) {}\n+    }\n+    \n+    @Ignore\n+    @Test\n+    public void shouldScreamWhenReturnSetForVoid() throws Exception {\n+        doReturn(new RuntimeException()).when(mock).voidMethod();\n+        fail();\n+    }\n+    \n+    @Ignore\n+    @Test\n+    public void shouldScreamWhenNotAMockPassed() throws Exception {\n+        try {\n+            doReturn(\"foo\").when(\"foo\").toString();\n+            fail();\n+        } catch (Exception e) {\n+            assertEquals(\"Argument passed to when() method is not a mock\", e.getMessage());\n+        }\n+    }\n+    \n+    //TODO when not a mock passed\n+    \n+    //TODO checked Exceptions\n+    \n+    //TODO chains\n+    \n+    //TODO state validation\n+    \n+    //TODO should verify\n+    \n+    //TODO exception messages with UnfinishedStubbingException\n+    \n+    @Test\n+    public void shouldStubbingBeTreatedAsInteraction() throws Exception {\n+        stub(mock.booleanReturningMethod()).toReturn(true);\n+        \n+        mock.booleanReturningMethod();\n+        \n+        try {\n+            verifyNoMoreInteractions(mock);\n+            fail();\n+        } catch (NoInteractionsWanted e) {}\n+    }\n+    \n+    class Base {}\n+    class Sub extends Base {}\n+\n+    interface Generic {\n+        List<Base> getList();\n+    }\n+    \n+    @Test\n+    public void shouldAllowStubbingWithSubtypes() throws Exception {\n+        Generic mockTwo = mock(Generic.class);\n+        \n+        List<Sub> subs = null;\n+        //can I somehow avoid a cast here:\n+        stub(mockTwo.getList()).toReturn((List) subs);\n+    }\n+    \n+    @Test\n+    public void shouldAllowStubbingToString() throws Exception {\n+        IMethods mockTwo = mock(IMethods.class);\n+        stub(mockTwo.toString()).toReturn(\"test\");\n+        \n+        assertThat(mock.toString(), contains(\"Mock for IMethods\"));\n+        assertEquals(\"test\", mockTwo.toString());\n+    }\n+    \n+    @Test\n+    public void shouldStubbingWithThrowableFailVerification() {\n+        stub(mock.simpleMethod(\"one\")).toThrow(new RuntimeException());\n+        stubVoid(mock).toThrow(new RuntimeException()).on().simpleMethod(\"two\");\n+        \n+        verifyZeroInteractions(mock);\n+        \n+        mock.simpleMethod(\"foo\");\n+        \n+        try {\n+            verify(mock).simpleMethod(\"one\");\n+            fail();\n+        } catch (ArgumentsAreDifferent e) {}\n+        \n+        try {\n+            verify(mock).simpleMethod(\"two\");\n+            fail();\n+        } catch (ArgumentsAreDifferent e) {}\n+        \n+        try {\n+            verifyNoMoreInteractions(mock);\n+            fail();\n+        } catch (NoInteractionsWanted e) {}\n+    }\n+}", "timestamp": 1216160027, "metainfo": ""}