{"sha": "d9642999b781e57ebe389646831a727aeb0dd6e8", "log": "some documentation changes  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40290", "commit": "\n--- a/src/org/mockito/InOrder.java\n+++ b/src/org/mockito/InOrder.java\n package org.mockito;\n \n import org.mockito.internal.progress.VerificationMode;\n-\n-//TODO add pattern for not creating it for all mocks\n \n /**\n  * Allows verification in order. E.g:\n  * inOrder.verify(secondMock).add(\"should be called second\");\n  * </pre>\n  * \n- * See examples {@link Mockito#inOrder(Object...)}\n+ * See examples in javadoc for {@link Mockito}\n  */\n public interface InOrder {\n     /**\n      * inOrder.verify(firstMock).someMethod(\"should be called first\");\n      * inOrder.verify(secondMock).someMethod(\"should be called second\");\n      * </pre>\n-     * <p>\n      * \n-     * See examples {@link Mockito}\n+     * See examples in javadoc for {@link Mockito}\n      * \n      * @param mock to be verified\n      * \n      * inOrder.verify(firstMock, times(2)).someMethod(\"should be called first two times\");\n      * inOrder.verify(secondMock, atLeastOnce()).someMethod(\"should be called second\");\n      * </pre>\n-     * <p>\n      * \n-     * See examples {@link Mockito}\n+     * See examples in javadoc for {@link Mockito}\n      * \n      * @param mock to be verified\n      * @param mode times(x) or atLeastOnce()\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n  * System.out.println(mockedList.get(999));\n  * \n  * //if you want you can still verify stubbed invocation\n- * verify(mockedList.get(0));\n+ * verify(mockedList).get(0);\n  * </pre>\n  * \n  * <p>\n  *   verifyNoMoreInteractions(mockedList);\n  * </pre>\n  * \n+ * It's a good pattern to use this method only if extra invocations can be harmful. \n+ * It's usually not necessary to call verifyNoMoreInteractions() all the time.\n+ * <p>\n  * See more {@link Mockito#verifyNoMoreInteractions}\n  * \n  * <h3>Verification in order</h3>\n  *   List secondMock = mock(List.class);\n  *   \n  *   //using mocks\n- *   firstMock.add(\"one\");\n- *   secondMock.add(\"two\");\n+ *   firstMock.add(\"should be called first\");\n+ *   secondMock.add(\"should be called second\");\n  *   \n  *   //create inOrder object\n  *   InOrder inOrder = inOrder(firstMock, secondMock);\n  *   inOrder.verify(firstMock).add(\"should be called first\");\n  *   inOrder.verify(secondMock).add(\"should be called second\");\n  * </pre>\n- * \n- * <p>\n- * Verification in order is required only in some cases and mostly ordinary verification is enough. \n- * \n+ *\n+ * Verification in order is strict: you cannot leave out interactions from the middle - \n+ * you have to verify interactions one-by-one.\n+ * <p>\n+ * It's a good pattern not to create InOrder object with all mocks.\n+ * Create it only with those mocks that have interactions required to be verified in order.\n+ *  \n  * <h3>Making sure no interactions happened on mock</h3>\n  * \n  * <pre>\n  * <p>\n  * Instead of verifyZeroInteractions() you can call verifyNoMoreInteractions() but \n  * the first one is more explicit and can read better.\n- * \n  */\n public class Mockito extends Matchers {\n \n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n     }\n \n     public void wantedDiffersFromActual(String wanted, String actual, HasStackTrace actualInvocationStackTrace) {\n-        WantedDiffersFromActual cause = createDiscrepancyCause(actual, actualInvocationStackTrace);\n+        WantedDiffersFromActual cause1 = new WantedDiffersFromActual(join(\n+                \"Actual invocation:\",\n+                actual\n+            ));\n+        \n+        cause1.setStackTrace(actualInvocationStackTrace.getStackTrace());\n+        WantedDiffersFromActual cause = cause1;\n \n         throw new InvocationDiffersFromActual(join(\n                 \"Invocation differs from actual\",\n     }\n     \n     public void wantedDiffersFromActualInOrder(String wanted, String actual, HasStackTrace actualInvocationStackTrace) {\n-        WantedDiffersFromActual cause = createDiscrepancyCause(actual, actualInvocationStackTrace);\n+        WantedDiffersFromActual cause1 = new WantedDiffersFromActual(join(\n+                \"Actual invocation in order:\",\n+                actual\n+            ));\n+        \n+        cause1.setStackTrace(actualInvocationStackTrace.getStackTrace());\n+        WantedDiffersFromActual cause = cause1;\n \n         throw new VerifcationInOrderFailed(join(\n                 \"Verification in order failed\",\n             ), cause);\n     }\n \n-    private WantedDiffersFromActual createDiscrepancyCause(String actual, HasStackTrace actualInvocationStackTrace) {\n-        WantedDiffersFromActual cause = new WantedDiffersFromActual(join(\n-                \"Actual invocation:\",\n-                actual\n-            ));\n-\n-        cause.setStackTrace(actualInvocationStackTrace.getStackTrace());\n-        return cause;\n-    }\n-    \n     public void wantedButNotInvoked(String wanted) {\n         throw new WantedButNotInvoked(join(\n                     \"Wanted but not invoked:\",\n--- a/src/org/mockito/internal/progress/ReturnValues.java\n+++ b/src/org/mockito/internal/progress/ReturnValues.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.progress;\n \n public class ReturnValues {\n--- a/test/org/mockito/MockitoTest.java\n+++ b/test/org/mockito/MockitoTest.java\n @SuppressWarnings(\"unchecked\")\n public class MockitoTest extends RequiresValidState {\n \n+    //TODO I want to have ruby script that will collect all java code from examples in javadoc/documentation\n+    // and create a test case that I can manually fix and run and make sure examples are valid\n+    \n     @Test\n     public void shouldRemoveStubbableFromProgressAfterStubbing() {\n         List mock = Mockito.mock(List.class);\n--- a/test/org/mockitousage/sample/MockitoSampleTest.java\n+++ b/test/org/mockitousage/sample/MockitoSampleTest.java\n         \n         verify(mockDatabase).updateNumberOfArticles(\"Guardian\", 12);\n         verify(mockDatabase).updateNumberOfPolishArticles(\"Guardian\", 5);\n-//        verify(mockDatabase).updateNumberOfEnglishArticles(\"Guardianx\", 7);\n         verify(mockDatabase).updateNumberOfEnglishArticles(\"Guardian\", 7);\n         \n         verifyNoMoreInteractions(mockDatabase);\n         verify(mockDatabase).updateNumberOfArticles(\"Guardian\", 0);\n         verify(mockDatabase).updateNumberOfPolishArticles(\"Guardian\", 0);\n         verify(mockDatabase).updateNumberOfEnglishArticles(\"Guardian\", 0);\n-//        verify(mockDatabase).updateNumberOfEnglishArticles(\"Guardian\", 2);\n         \n         verifyNoMoreInteractions(mockDatabase);\n     }\n         \n         inOrder.verify(mockDatabase, atLeastOnce()).getArticlesFor(anyString());\n         inOrder.verify(mockDatabase, atLeastOnce()).save((Article) anyObject());\n-//        inOrder.verify(mockDatabase, atLeastOnce()).save(null);\n-        \n-        //TODO review messages once more and remove commented out code\n     }\n }\n--- a/test/org/mockitousage/verification/DescriptiveMessagesOnVerificationInOrderErrorsTest.java\n+++ b/test/org/mockitousage/verification/DescriptiveMessagesOnVerificationInOrderErrorsTest.java\n             \n             String expectedCause = \n                 \"\\n\" +\n-                \"Actual invocation:\" +\n+                \"Actual invocation in order:\" +\n                 \"\\n\" +\n                 \"IMethods.simpleMethod(11)\";\n             ", "timestamp": 1200318858, "metainfo": ""}