{"sha": "4873b664bd7c29a485ebf390ffec0f54a393225e", "log": "style and description in serialization exceptions, added TODOs, to thrown dedicated Mockito serialization exception", "commit": "\n--- a/src/org/mockito/internal/creation/AcrossJVMSerializationFeature.java\n+++ b/src/org/mockito/internal/creation/AcrossJVMSerializationFeature.java\n import java.io.ObjectStreamClass;\n import java.io.ObjectStreamException;\n import java.io.Serializable;\n+import java.lang.reflect.Field;\n import java.lang.reflect.Method;\n import java.util.Set;\n import java.util.concurrent.locks.Lock;\n \n             return new AcrossJVMMockSerializationProxy(mockitoMock);\n         } catch (IOException ioe) {\n-            throw new NotSerializableException(mockitoMock.getClass().getCanonicalName()); // TODO throw our own serialization exception\n+            // TODO use our own mockito mock serialization exception\n+            throw new NotSerializableException(mockitoMock.getClass().getCanonicalName());\n         } finally {\n             // unmark\n             mockReplacementCompleted();\n \n                 return deserializedMock;\n             } catch (IOException ioe) {\n-                throw new InvalidObjectException(\"For some reason mock cannot be deserialized : \" + ioe.toString() + \"\\n\" + StringJoiner.join(ioe.getStackTrace()));\n+                // TODO use our own mockito mock serialization exception\n+                throw new InvalidObjectException(\"Mockito mock cannot be deserialized due to : \" + ioe.toString() + \"\\n\" + StringJoiner.join(ioe.getStackTrace()));\n             } catch (ClassNotFoundException cce) {\n-                throw new InvalidObjectException(\"For some reason Mockito Mock class cannot be found : \" + cce.toString());\n+                // TODO use our own mockito mock serialization exception\n+                throw new InvalidObjectException(\"Mockito Mock class cannot be found : \" + cce.toString());\n             }\n         }\n     }\n          * <code>java.io.InvalidObjectException</code> is thrown, so this part of the code is hacking through\n          * the given <code>ObjectStreamClass</code> to change the name with the newly created class.\n          *\n-         * @param desc The <code>ObjectStreamClass</code> that will be hacked.\n+         * @param descInstance The <code>ObjectStreamClass</code> that will be hacked.\n          * @param proxyClass The proxy class whose name will be applied.\n          * @throws InvalidObjectException\n          */\n-        private void hackClassNameToMatchNewlyCreatedClass(ObjectStreamClass desc, Class<?> proxyClass) throws InvalidObjectException {\n+        private void hackClassNameToMatchNewlyCreatedClass(ObjectStreamClass descInstance, Class<?> proxyClass) throws InvalidObjectException {\n             try {\n-                new FieldSetter(desc, desc.getClass().getDeclaredField(\"name\")).set(proxyClass.getCanonicalName());\n+              Field classNameField = descInstance.getClass().getDeclaredField(\"name\");\n+              new FieldSetter(descInstance, classNameField).set(proxyClass.getCanonicalName());\n             } catch (NoSuchFieldException e) {\n-                throw new InvalidObjectException(\"Wow, the class 'ObjectStreamClass' in the JDK don't have the field 'name', this is definitely a bug, in our code, please report used JDK, eventually code sample.\\n\" + e.toString());\n+                // TODO use our own mockito mock serialization exception\n+                throw new InvalidObjectException(\"Wow, the class 'ObjectStreamClass' in the JDK don't have the field 'name', \" +\n+                    \"this is definitely a bug in our code, please report used JDK, eventually with a code sample.\\n\" + e.toString());\n             }\n         }\n ", "timestamp": 1357204023, "metainfo": ""}