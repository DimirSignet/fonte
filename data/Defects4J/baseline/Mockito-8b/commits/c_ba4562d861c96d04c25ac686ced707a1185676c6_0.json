{"sha": "ba4562d861c96d04c25ac686ced707a1185676c6", "log": "In order to add some more tests for my sanity & understanding of serialization / deserialization of mocks  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401641", "commit": "\n--- a/test/org/mockitousage/basicapi/MocksSerializationTest.java\n+++ b/test/org/mockitousage/basicapi/MocksSerializationTest.java\n \n public class MocksSerializationTest extends TestBase implements Serializable {\n \n-  private static final long serialVersionUID = 6160482220413048624L;\n-\n-  @Test\n-  public void shouldAllowMockToBeSerializable() throws Exception {\n-    // given\n-    IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n-\n-    // when\n-    ByteArrayOutputStream serialized = serializeMock(mock);\n-\n-    // then\n-    deserializeMock(serialized, IMethods.class);\n-  }\n-\n-  @Test\n-  public void shouldAllowMockAndBooleanValueToSerializable() throws Exception {\n-    // given\n-    IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n-    when(mock.booleanReturningMethod()).thenReturn(true);\n-\n-    // when\n-    ByteArrayOutputStream serialized = serializeMock(mock);\n-\n-    // then\n-    IMethods readObject = deserializeMock(serialized, IMethods.class);\n-    assertTrue(readObject.booleanReturningMethod());\n-  }\n-\n-  @Test\n-  public void shouldAllowMockAndStringValueToBeSerializable() throws Exception {\n-    // given\n-    IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n-    String value = \"value\";\n-    when(mock.stringReturningMethod()).thenReturn(value);\n-\n-    // when\n-    ByteArrayOutputStream serialized = serializeMock(mock);\n-\n-    // then\n-    IMethods readObject = deserializeMock(serialized, IMethods.class);\n-    assertEquals(value, readObject.stringReturningMethod());\n-  }\n-\n-  @Test\n-  public void shouldAllMockAndSerializableValueToBeSerialized() throws Exception {\n-    // given\n-    IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n-    List<?> value = Collections.emptyList();\n-    when(mock.objectReturningMethodNoArgs()).thenReturn(value);\n-\n-    // when\n-    ByteArrayOutputStream serialized = serializeMock(mock);\n-\n-    // then\n-    IMethods readObject = deserializeMock(serialized, IMethods.class);\n-    assertEquals(value, readObject.objectReturningMethodNoArgs());\n-  }\n-\n-  @Test\n-  public void shouldSerializeMethodCallWithParametersThatAreSerializable() throws Exception {\n-    IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n-    List<?> value = Collections.emptyList();\n-    when(mock.objectArgMethod(value)).thenReturn(value);\n-\n-    // when\n-    ByteArrayOutputStream serialized = serializeMock(mock);\n-\n-    // then\n-    IMethods readObject = deserializeMock(serialized, IMethods.class);\n-    assertEquals(value, readObject.objectArgMethod(value));\n-  }\n-\n-  @Test\n-  public void shouldSerializeMethodCallsUsingAnyStringMatcher() throws Exception {\n-    IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n-    List<?> value = Collections.emptyList();\n-    when(mock.objectArgMethod(anyString())).thenReturn(value);\n-\n-    // when\n-    ByteArrayOutputStream serialized = serializeMock(mock);\n-\n-    // then\n-    IMethods readObject = deserializeMock(serialized, IMethods.class);\n-    assertEquals(value, readObject.objectArgMethod(\"\"));\n-  }\n-\n-  @Test\n-  public void shouldVerifyCalledNTimesForSerializedMock() throws Exception {\n-    IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n-    List<?> value = Collections.emptyList();\n-    when(mock.objectArgMethod(anyString())).thenReturn(value);\n-    mock.objectArgMethod(\"\");\n-\n-    // when\n-    ByteArrayOutputStream serialized = serializeMock(mock);\n-\n-    // then\n-    IMethods readObject = deserializeMock(serialized, IMethods.class);\n-    verify(readObject, times(1)).objectArgMethod(\"\");\n-  }\n-\n-  @Test\n-  public void shouldVerifyCallOrderForSerializedMock() throws Exception {\n-    IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n-    IMethods mock2 = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n-    mock.arrayReturningMethod();\n-    mock2.arrayReturningMethod();\n-\n-    // when\n-    ByteArrayOutputStream serialized = serializeMock(mock);\n-    ByteArrayOutputStream serialized2 = serializeMock(mock2);\n-\n-    // then\n-    IMethods readObject = deserializeMock(serialized, IMethods.class);\n-    IMethods readObject2 = deserializeMock(serialized2, IMethods.class);\n-    InOrder inOrder = inOrder(readObject, readObject2);\n-    inOrder.verify(readObject).arrayReturningMethod();\n-    inOrder.verify(readObject2).arrayReturningMethod();\n-  }\n-\n-  @Test\n-  public void shouldRememberInteractionsForSerializedMock() throws Exception {\n-    IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n-    List<?> value = Collections.emptyList();\n-    when(mock.objectArgMethod(anyString())).thenReturn(value);\n-    mock.objectArgMethod(\"happened\");\n-\n-    // when\n-    ByteArrayOutputStream serialized = serializeMock(mock);\n-\n-    // then\n-    IMethods readObject = deserializeMock(serialized, IMethods.class);\n-    verify(readObject, never()).objectArgMethod(\"never happened\");\n-  }\n-\n-  @SuppressWarnings(\"serial\")\n-  @Test\n-  public void shouldSerializeWithStubbingCallback() throws Exception {\n-    \n-    // given\n-    IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n-    final String string = \"return value\";\n-    when(mock.objectArgMethod(anyString())).thenAnswer(new Answer<Object>() {\n-      public Object answer(InvocationOnMock invocation) {\n-        invocation.getArguments();\n-        invocation.getMock();\n-        return string;\n-      }\n-    });\n-\n-    // when\n-    ByteArrayOutputStream serialized = serializeMock(mock);\n-\n-    // then\n-    IMethods readObject = deserializeMock(serialized, IMethods.class);\n-    assertEquals(string, readObject.objectArgMethod(\"\"));\n-  }\n-\n-  @Test\n-  public void shouldSerializeWithRealObjectSpy() throws Exception {\n-\n-    // given\n-    List<Object> list = new ArrayList<Object>();\n-    List<Object> spy = spy(list);\n-    when(spy.size()).thenReturn(100);\n-\n-    // when\n-    ByteArrayOutputStream serialized = serializeMock(spy);\n-\n-    // then\n-    List<?> readObject = deserializeMock(serialized, List.class);\n-    assertEquals(100, readObject.size());\n-  }\n-  \n-  @Test\n-  public void shouldSerializeObjectMock() throws Exception {\n-    // given\n-    Any mock = mock(Any.class);\n-    \n-    // when\n-    ByteArrayOutputStream serialized = serializeMock(mock);\n-    \n-    // then\n-    deserializeMock(serialized, Any.class);\n-  }\n-  \n-  @Test\n-  public void shouldSerializeRealPartialMock() throws Exception {\n-    // given\n-    Any mock = mock(Any.class);\n-    when(mock.matches(anyObject())).thenCallRealMethod();\n-    \n-    // when\n-    ByteArrayOutputStream serialized = serializeMock(mock);\n-    \n-    // then\n-    Any readObject = deserializeMock(serialized, Any.class);\n-    readObject.matches(\"\");\n-  }\n-\n-  private <T> T deserializeMock(ByteArrayOutputStream serialized, Class<T> type) throws IOException,\n-      ClassNotFoundException {\n-    InputStream unserialize = new ByteArrayInputStream(serialized.toByteArray());\n-    Object readObject = new ObjectInputStream(unserialize).readObject();\n-    assertNotNull(readObject);\n-    return type.cast(readObject);\n-  }\n-\n-  private ByteArrayOutputStream serializeMock(Object mock) throws IOException {\n-    ByteArrayOutputStream serialized = new ByteArrayOutputStream();\n-    new ObjectOutputStream(serialized).writeObject(mock);\n-    return serialized;\n-  }\n+    private static final long serialVersionUID = 6160482220413048624L;\n+\n+    @Test\n+    public void shouldAllowMockToBeSerializable() throws Exception {\n+        // given\n+        IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n+\n+        // when\n+        //TODO simplify with serializeAndBack method\n+        ByteArrayOutputStream serialized = serializeMock(mock);\n+\n+        // then\n+        deserializeMock(serialized, IMethods.class);\n+    }\n+\n+    @Test\n+    public void shouldAllowMockAndBooleanValueToSerializable() throws Exception {\n+        // given\n+        IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n+        when(mock.booleanReturningMethod()).thenReturn(true);\n+\n+        // when\n+        ByteArrayOutputStream serialized = serializeMock(mock);\n+\n+        // then\n+        IMethods readObject = deserializeMock(serialized, IMethods.class);\n+        assertTrue(readObject.booleanReturningMethod());\n+    }\n+\n+    @Test\n+    public void shouldAllowMockAndStringValueToBeSerializable() throws Exception {\n+        // given\n+        IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n+        String value = \"value\";\n+        when(mock.stringReturningMethod()).thenReturn(value);\n+\n+        // when\n+        ByteArrayOutputStream serialized = serializeMock(mock);\n+\n+        // then\n+        IMethods readObject = deserializeMock(serialized, IMethods.class);\n+        assertEquals(value, readObject.stringReturningMethod());\n+    }\n+\n+    @Test\n+    public void shouldAllMockAndSerializableValueToBeSerialized() throws Exception {\n+        // given\n+        IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n+        List<?> value = Collections.emptyList();\n+        when(mock.objectReturningMethodNoArgs()).thenReturn(value);\n+\n+        // when\n+        ByteArrayOutputStream serialized = serializeMock(mock);\n+\n+        // then\n+        IMethods readObject = deserializeMock(serialized, IMethods.class);\n+        assertEquals(value, readObject.objectReturningMethodNoArgs());\n+    }\n+\n+    @Test\n+    public void shouldSerializeMethodCallWithParametersThatAreSerializable() throws Exception {\n+        IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n+        List<?> value = Collections.emptyList();\n+        when(mock.objectArgMethod(value)).thenReturn(value);\n+\n+        // when\n+        ByteArrayOutputStream serialized = serializeMock(mock);\n+\n+        // then\n+        IMethods readObject = deserializeMock(serialized, IMethods.class);\n+        assertEquals(value, readObject.objectArgMethod(value));\n+    }\n+\n+    @Test\n+    public void shouldSerializeMethodCallsUsingAnyStringMatcher() throws Exception {\n+        IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n+        List<?> value = Collections.emptyList();\n+        when(mock.objectArgMethod(anyString())).thenReturn(value);\n+\n+        // when\n+        ByteArrayOutputStream serialized = serializeMock(mock);\n+\n+        // then\n+        IMethods readObject = deserializeMock(serialized, IMethods.class);\n+        assertEquals(value, readObject.objectArgMethod(\"\"));\n+    }\n+\n+    @Test\n+    public void shouldVerifyCalledNTimesForSerializedMock() throws Exception {\n+        IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n+        List<?> value = Collections.emptyList();\n+        when(mock.objectArgMethod(anyString())).thenReturn(value);\n+        mock.objectArgMethod(\"\");\n+\n+        // when\n+        ByteArrayOutputStream serialized = serializeMock(mock);\n+\n+        // then\n+        IMethods readObject = deserializeMock(serialized, IMethods.class);\n+        verify(readObject, times(1)).objectArgMethod(\"\");\n+    }\n+\n+    @Test\n+    public void shouldVerifyEvenIfSomeMethodsCalledAfterSerialization() throws Exception {\n+        //given\n+        IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n+\n+        // when\n+        mock.simpleMethod(1);\n+        ByteArrayOutputStream serialized = serializeMock(mock);\n+        IMethods readObject = deserializeMock(serialized, IMethods.class);\n+        readObject.simpleMethod(1);\n+\n+        // then\n+        verify(readObject, times(2)).simpleMethod(1);\n+\n+        //this test is working because it seems that java serialization mechanism replaces all instances\n+        //of serialized object in the object graph (if there are any)\n+    }\n+\n+    class Bar implements Serializable {\n+        Foo foo;\n+    }\n+\n+    class Foo implements Serializable {\n+        Bar bar;\n+        Foo() {\n+            bar = new Bar();\n+            bar.foo = this;\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSerializationWork() throws Exception {\n+        //given\n+        Foo foo = new Foo();\n+        //when\n+        foo = serializeAndBack(foo);\n+        //then\n+        assertSame(foo, foo.bar.foo);\n+    }\n+\n+    @Test\n+    public void shouldStubEvenIfSomeMethodsCalledAfterSerialization() throws Exception {\n+        //given\n+        IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n+\n+        // when\n+        when(mock.simpleMethod(1)).thenReturn(\"foo\");\n+        ByteArrayOutputStream serialized = serializeMock(mock);\n+        IMethods readObject = deserializeMock(serialized, IMethods.class);\n+        when(readObject.simpleMethod(2)).thenReturn(\"bar\");\n+\n+        // then\n+        assertEquals(\"foo\", readObject.simpleMethod(1));\n+        assertEquals(\"bar\", readObject.simpleMethod(2));\n+    }\n+\n+    @Test\n+    public void shouldVerifyCallOrderForSerializedMock() throws Exception {\n+        IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n+        IMethods mock2 = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n+        mock.arrayReturningMethod();\n+        mock2.arrayReturningMethod();\n+\n+        // when\n+        ByteArrayOutputStream serialized = serializeMock(mock);\n+        ByteArrayOutputStream serialized2 = serializeMock(mock2);\n+\n+        // then\n+        IMethods readObject = deserializeMock(serialized, IMethods.class);\n+        IMethods readObject2 = deserializeMock(serialized2, IMethods.class);\n+        InOrder inOrder = inOrder(readObject, readObject2);\n+        inOrder.verify(readObject).arrayReturningMethod();\n+        inOrder.verify(readObject2).arrayReturningMethod();\n+    }\n+\n+    @Test\n+    public void shouldRememberInteractionsForSerializedMock() throws Exception {\n+        IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n+        List<?> value = Collections.emptyList();\n+        when(mock.objectArgMethod(anyString())).thenReturn(value);\n+        mock.objectArgMethod(\"happened\");\n+\n+        // when\n+        ByteArrayOutputStream serialized = serializeMock(mock);\n+\n+        // then\n+        IMethods readObject = deserializeMock(serialized, IMethods.class);\n+        verify(readObject, never()).objectArgMethod(\"never happened\");\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    @Test\n+    public void shouldSerializeWithStubbingCallback() throws Exception {\n+\n+        // given\n+        IMethods mock = mock(IMethods.class, withSettings().extraInterfaces(Serializable.class));\n+        final String string = \"return value\";\n+        when(mock.objectArgMethod(anyString())).thenAnswer(new Answer<Object>() {\n+            public Object answer(InvocationOnMock invocation) {\n+                invocation.getArguments();\n+                invocation.getMock();\n+                return string;\n+            }\n+        });\n+\n+        // when\n+        ByteArrayOutputStream serialized = serializeMock(mock);\n+\n+        // then\n+        IMethods readObject = deserializeMock(serialized, IMethods.class);\n+        assertEquals(string, readObject.objectArgMethod(\"\"));\n+    }\n+\n+    @Test\n+    public void shouldSerializeWithRealObjectSpy() throws Exception {\n+        // given\n+        List<Object> list = new ArrayList<Object>();\n+        List<Object> spy = spy(list);\n+        when(spy.size()).thenReturn(100);\n+\n+        // when\n+        ByteArrayOutputStream serialized = serializeMock(spy);\n+\n+        // then\n+        List<?> readObject = deserializeMock(serialized, List.class);\n+        assertEquals(100, readObject.size());\n+    }\n+\n+    @Test\n+    public void shouldSerializeObjectMock() throws Exception {\n+        // given\n+        Any mock = mock(Any.class);\n+\n+        // when\n+        ByteArrayOutputStream serialized = serializeMock(mock);\n+\n+        // then\n+        deserializeMock(serialized, Any.class);\n+    }\n+\n+    @Test\n+    public void shouldSerializeRealPartialMock() throws Exception {\n+        // given\n+        Any mock = mock(Any.class);\n+        when(mock.matches(anyObject())).thenCallRealMethod();\n+\n+        // when\n+        ByteArrayOutputStream serialized = serializeMock(mock);\n+\n+        // then\n+        Any readObject = deserializeMock(serialized, Any.class);\n+        readObject.matches(\"\");\n+    }\n \n }\n--- a/test/org/mockitoutil/TestBase.java\n+++ b/test/org/mockitoutil/TestBase.java\n import org.mockito.internal.configuration.ConfigurationAccess;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.realmethod.RealMethod;\n+\n+import java.io.*;\n \n /**\n  * the easiest way to make sure that tests clean up invalid state is to require\n     protected static String describe(SelfDescribing m) {\n         return StringDescription.toString(m);\n     }\n+\n+    protected <T> T serializeAndBack(T obj) throws Exception {\n+        ByteArrayOutputStream os = this.serializeMock(obj);\n+        return (T) this.deserializeMock(os, Object.class);\n+    }\n+\n+    protected <T> T deserializeMock(ByteArrayOutputStream serialized, Class<T> type) throws IOException,\n+            ClassNotFoundException {\n+        InputStream unserialize = new ByteArrayInputStream(serialized.toByteArray());\n+        Object readObject = new ObjectInputStream(unserialize).readObject();\n+        assertNotNull(readObject);\n+        return type.cast(readObject);\n+    }\n+\n+    protected ByteArrayOutputStream serializeMock(Object mock) throws IOException {\n+        ByteArrayOutputStream serialized = new ByteArrayOutputStream();\n+        new ObjectOutputStream(serialized).writeObject(mock);\n+        return serialized;\n+    }\n }", "timestamp": 1256943942, "metainfo": ""}