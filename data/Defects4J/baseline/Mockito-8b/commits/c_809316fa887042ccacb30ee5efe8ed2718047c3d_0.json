{"sha": "809316fa887042ccacb30ee5efe8ed2718047c3d", "log": "got rid of some TODOs, removed some useless code, added some tests in areas that weren't very tested  --HG-- rename : src/org/mockito/internal/ClassProxyFactory.java => src/org/mockito/internal/MockFactory.java rename : src/org/mockito/internal/MockitoObjectMethodsFilter.java => src/org/mockito/internal/ObjectMethodsFilter.java rename : test/org/mockito/internal/ClassProxyFactoryTest.java => test/org/mockito/internal/MockFactoryTest.java rename : test/org/mockito/util/JUnitMatchers.java => test/org/mockito/util/ExtraMatchers.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%4032", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n \n     public static <T> T mock(Class<T> classToMock) {\n         try {\n-            ClassProxyFactory<T> proxyFactory = new ClassProxyFactory<T>();\n+            MockFactory<T> proxyFactory = new MockFactory<T>();\n             MockitoControl<T> mockitoControl = new MockitoControl<T>(MockitoState.instance(), LastArguments.instance());\n-            return proxyFactory.createProxy(classToMock, new MockitoObjectMethodsFilter<MockitoControl>(\n+            return proxyFactory.createMock(classToMock, new ObjectMethodsFilter<MockitoControl>(\n                     classToMock, mockitoControl, null));\n         } catch (RuntimeExceptionWrapper e) {\n             throw (RuntimeException) e.getRuntimeException().fillInStackTrace();\n--- a/src/org/mockito/internal/Invocation.java\n+++ b/src/org/mockito/internal/Invocation.java\n \n public class Invocation {\n \n+    private boolean verified;\n     private final Object mock;\n-\n     private final Method method;\n-\n     private final Object[] arguments;\n \n     public Invocation(Object mock, Method method, Object[] args) {\n         }\n         return true;\n     }\n+    \n+    public void markVerified() {\n+        verified = true;\n+    }\n+\n+    public boolean isVerified() {\n+        return verified;\n+    }\n }\n--- a/src/org/mockito/internal/InvocationWithMatchers.java\n+++ b/src/org/mockito/internal/InvocationWithMatchers.java\n package org.mockito.internal;\n \n import java.lang.reflect.Method;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n+import java.util.*;\n \n-import org.mockito.exceptions.InvalidUseOfMatchersException;\n-import org.mockito.internal.matchers.*;\n+import org.mockito.internal.matchers.IArgumentMatcher;\n \n public class InvocationWithMatchers {\n \n     protected final Invocation invocation;\n-\n     private final List<IArgumentMatcher> matchers;\n \n     public InvocationWithMatchers(Invocation invocation, List<IArgumentMatcher> matchers) {\n         return invocation.getMethod();\n     }\n     \n-    public MockitoInvocation getInvocation() {\n-        return (MockitoInvocation) this.invocation;\n+    public Invocation getInvocation() {\n+        return this.invocation;\n     }\n }\n--- a/src/org/mockito/internal/MockAwareInvocationHandler.java\n+++ b/src/org/mockito/internal/MockAwareInvocationHandler.java\n \n import java.lang.reflect.InvocationHandler;\n \n-public interface MockAwareInvocationHandler extends InvocationHandler {\n-    void setMock(Object mock);\n+public interface MockAwareInvocationHandler<T> extends InvocationHandler {\n+    void setMock(T mock);\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/MockFactory.java\n+/*\n+ * Copyright (c) 2003-2006 OFFIS, Henri Tremblay. \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal;\n+\n+import java.lang.reflect.*;\n+import java.lang.reflect.InvocationHandler;\n+import java.util.List;\n+\n+import net.sf.cglib.core.*;\n+import net.sf.cglib.proxy.*;\n+\n+/**\n+ * Factory generating a mock for a class.\n+ * <p>\n+ * Note that this class is stateful\n+ */\n+public class MockFactory<T> {\n+\n+    public static interface MockMethodInterceptor extends MethodInterceptor {\n+        InvocationHandler getHandler();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public T createMock(Class<T> toMock, final MockAwareInvocationHandler handler) {\n+\n+        MethodInterceptor interceptor = new MockMethodInterceptor() {\n+\n+            public Object intercept(Object obj, Method method, Object[] args,\n+                    MethodProxy proxy) throws Throwable {\n+                if (method.isBridge()) {\n+                    return proxy.invokeSuper(obj, args);\n+                }\n+                return handler.invoke(obj, method, args);\n+            }\n+\n+            public InvocationHandler getHandler() {\n+                return handler;\n+            }\n+        };\n+\n+        Enhancer enhancer = new Enhancer() {\n+            /**\n+             * Filter all private constructors but do not check that there are\n+             * some left\n+             */\n+            protected void filterConstructors(Class sc, List constructors) {\n+                CollectionUtils.filter(constructors, new VisibilityPredicate(\n+                        sc, true));\n+            }\n+        };\n+        \n+        if (toMock.isInterface()) {\n+\t\t\tenhancer.setInterfaces(new Class[] { toMock });\n+\t\t} else {\n+\t\t\tenhancer.setSuperclass(toMock);\n+\t\t}\n+        \n+        enhancer.setCallbackType(interceptor.getClass());\n+\n+        Class mockClass = enhancer.createClass();\n+        Enhancer.registerCallbacks(mockClass, new Callback[] { interceptor });\n+\n+        Factory mock;\n+        try {\n+            mock = (Factory) ObjenesisClassInstantiator.newInstance(mockClass);\n+        } catch (InstantiationException e) {\n+            throw new RuntimeException(\"Fail to instantiate mock for \" + toMock\n+                    + \" on \" + System.getProperty(\"java.vm.vendor\") + \" JVM\");\n+        }\n+\n+        // This call is required. Cglib has some \"magic code\" making sure a\n+        // callback is used by only one instance of a given class. So only the\n+        // instance created right after registering the callback will get it.\n+        // However, this is done in the construtor which I'm bypassing to\n+        // allow class instantiation without calling a constructor.\n+        // Fortunatly, the \"magic code\" is also called in getCallback which is\n+        // why I'm calling it here mock.getCallback(0);\n+        \n+        mock.getCallback(0);\n+\n+        handler.setMock(mock);\n+        return (T) mock;\n+    }\n+}\n--- a/src/org/mockito/internal/MockUtil.java\n+++ b/src/org/mockito/internal/MockUtil.java\n import net.sf.cglib.proxy.*;\n \n import org.mockito.exceptions.NotAMockException;\n-import org.mockito.internal.ClassProxyFactory.MockMethodInterceptor;\n+import org.mockito.internal.MockFactory.MockMethodInterceptor;\n \n public class MockUtil {\n     \n             throw new IllegalArgumentException(\"Mock cannot be null\");\n         }\n         \n-        MockitoObjectMethodsFilter<MockitoControl<T>> handler;\n+        ObjectMethodsFilter<MockitoControl<T>> handler;\n \n         try {\n             if (Enhancer.isEnhanced(mock.getClass())) {\n-                handler = (MockitoObjectMethodsFilter) getInterceptor(mock)\n+                handler = (ObjectMethodsFilter) getInterceptor(mock)\n                         .getHandler();\n             } else {\n                 throw new NotAMockException(mock);\n--- a/src/org/mockito/internal/MockitoBehavior.java\n+++ b/src/org/mockito/internal/MockitoBehavior.java\n     private int numberOfActualInvocations(InvocationWithMatchers expectedInvocation) {\n         int verifiedInvocations = 0;\n         for (InvocationWithMatchers registeredInvocation : registeredInvocations) {\n-            MockitoInvocation invocation = registeredInvocation.getInvocation();\n+            Invocation invocation = registeredInvocation.getInvocation();\n             if (expectedInvocation.matches(invocation)) {\n                 verifiedInvocations += 1;\n                 invocation.markVerified();\n         }\n     }\n \n-    public Object resultFor(MockitoInvocation invocation) throws Throwable {\n+    public Object resultFor(Invocation invocation) throws Throwable {\n         for (InvocationWithMatchers invocationWithMatchers : results.keySet()) {\n             if (invocationWithMatchers.matches(invocation)) {\n                 return results.get(invocationWithMatchers).answer();\n         return ToTypeMappings.emptyReturnValueFor(invocation.getMethod().getReturnType());\n     }\n \n-    public MockitoInvocation lastInvocation() {\n+    public Invocation lastInvocation() {\n         return registeredInvocations.get(registeredInvocations.size() - 1).getInvocation();\n     }\n }\n--- a/src/org/mockito/internal/MockitoControl.java\n+++ b/src/org/mockito/internal/MockitoControl.java\n import org.mockito.exceptions.InvalidUseOfMatchersException;\n import org.mockito.internal.matchers.*;\n \n-public class MockitoControl<T> implements MockAwareInvocationHandler, InvocationHandler, MockitoExpectation<T>, VoidMethodExpectation<T>, MethodSelector<T> {\n+public class MockitoControl<T> implements MockAwareInvocationHandler<T>, InvocationHandler, MockitoExpectation<T>, VoidMethodExpectation<T>, MethodSelector<T> {\n \n     private MockitoBehavior behavior = new MockitoBehavior();\n-    private Object mock;\n+    private T mock;\n     private final MockitoState mockitoState;\n     private final LastArguments lastArguments;\n     \n     }\n \n     public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n-        MockitoInvocation invocation = new MockitoInvocation(proxy, method, args);\n+        VerifyingMode verifyingMode = mockitoState.removeVerifyingMode();\n+        \n+        Invocation invocation = new Invocation(proxy, method, args);\n         List<IArgumentMatcher> lastMatchers = lastArguments.pullMatchers();\n+        validateMatchers(invocation, lastMatchers);\n+\n         List<IArgumentMatcher> processedMatchers = createEqualsMatchers(invocation, lastMatchers);\n         InvocationWithMatchers invocationWithMatchers = new InvocationWithMatchers(invocation, processedMatchers);\n         \n-        if (mockitoState.verificationScenario()) {\n-            VerifyingMode verifyingMode = mockitoState.verifyingCompleted();\n-\n-            //have to validate matcher after verifyingMode flag is cleared - a bit smelly\n-            validateMatchers(invocation, lastMatchers);\n-            \n+        if (verifyingMode != null) {\n             behavior.verify(invocationWithMatchers, verifyingMode);\n             return ToTypeMappings.emptyReturnValueFor(method.getReturnType());\n-        } else {\n-            validateMatchers(invocation, lastMatchers);\n         }\n         \n //        else if (mockitoState.mockStubbingScenario()) {\n \n     public void andReturn(T value) {\n //      TODO count number of andReturn vs number of stubbing\n-//      TODO why do we need that in easy_Mock: value = convertNumberClassIfNeccessary(value);\n         behavior.addResult(Result.createReturnResult(value));\n     }\n \n     }\n \n     private boolean isValidCheckedException(Throwable throwable) {\n-        MockitoInvocation lastInvocation = behavior.lastInvocation();\n+        Invocation lastInvocation = behavior.lastInvocation();\n \n         Class<?>[] exceptions = lastInvocation.getMethod().getExceptionTypes();\n         Class<?> throwableClass = throwable.getClass();\n     }\n \n     public T on() {\n-        // TODO check if mock can be of the type T\n         return (T) mock;\n     }\n \n-    public void setMock(Object mock) {\n+    public void setMock(T mock) {\n         this.mock = mock;\n     }\n }\n--- a/src/org/mockito/internal/MockitoState.java\n+++ b/src/org/mockito/internal/MockitoState.java\n         return verifyingModeLocal.get() != null; \n     }\n \n-    public synchronized VerifyingMode verifyingCompleted() {\n+    public synchronized VerifyingMode removeVerifyingMode() {\n         VerifyingMode verifyingMode = verifyingModeLocal.get();\n         verifyingModeLocal.set(null);\n         return verifyingMode;\n         return throwableToBeSetOnVoidMethod.get() != null; \n     }\n \n-    public void validate() {\n-        // TODO Auto-generated method stub\n-    }\n-\n //    public void stubbingStarted() {\n //        stubbingModeLocal.set(new Object());\n //    }\n--- /dev/null\n+++ b/src/org/mockito/internal/ObjectMethodsFilter.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal;\n+\n+import java.lang.reflect.Method;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class ObjectMethodsFilter<T extends MockAwareInvocationHandler> implements MockAwareInvocationHandler {\n+    private final Method equalsMethod;\n+\n+    private final Method hashCodeMethod;\n+\n+    private final Method toStringMethod;\n+\n+    private final T delegate;\n+\n+    private final String name;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public ObjectMethodsFilter(Class toMock, T delegate,\n+            String name) {\n+        if (name != null && !Invocation.isJavaIdentifier(name)) {\n+            throw new IllegalArgumentException(String.format(\"'%s' is not a valid Java identifier.\", name));\n+            \n+        }\n+        try {\n+            if (toMock.isInterface()) {\n+                toMock = Object.class;\n+            }\n+            equalsMethod = toMock.getMethod(\"equals\", new Class[] { Object.class });\n+            hashCodeMethod = toMock.getMethod(\"hashCode\", (Class[]) null);\n+            toStringMethod = toMock.getMethod(\"toString\", (Class[]) null);\n+        } catch (NoSuchMethodException e) {\n+            throw new RuntimeException(\"An Object method could not be found!\");\n+        }\n+        this.delegate = delegate;\n+        this.name = name;\n+    }\n+\n+    public Object invoke(Object proxy, Method method, Object[] args)\n+            throws Throwable {\n+        if (equalsMethod.equals(method)) {\n+            return Boolean.valueOf(proxy == args[0]);\n+        }\n+        if (hashCodeMethod.equals(method)) {\n+            return new Integer(System.identityHashCode(proxy));\n+        }\n+        if (toStringMethod.equals(method)) {\n+            return mockToString(proxy);\n+        }\n+        return delegate.invoke(proxy, method, args);\n+    }\n+\n+    private String mockToString(Object proxy) {\n+        return (name != null) ? name : \"Mock for \" + mockType(proxy);\n+    }\n+\n+    private String mockType(Object proxy) {\n+\t\tif (proxy.getClass().getInterfaces().length == 2) {\n+\t\t\treturn proxy.getClass().getInterfaces()[0].getSimpleName();\n+\t\t} else {\n+\t\t\treturn proxy.getClass().getSuperclass().getSimpleName();\n+\t\t}\n+\t}\n+\n+    public T getDelegate() {\n+        return delegate;\n+    }\n+\n+    public void setMock(Object mock) {\n+        delegate.setMock(mock);\n+    }\n+}\n--- a/test/org/mockito/internal/CglibTest.java\n+++ b/test/org/mockito/internal/CglibTest.java\n \n import java.lang.reflect.Method;\n import java.util.ArrayList;\n+import static org.junit.Assert.*;\n \n-import junit.framework.TestCase;\n import net.sf.cglib.proxy.Callback;\n import net.sf.cglib.proxy.Enhancer;\n import net.sf.cglib.proxy.Factory;\n /**\n  * This test case is used to make sure that the way cglib is used is providing the expected behavior\n  */\n-public class CglibTest extends TestCase {\n+public class CglibTest {\n \n     /**\n      * Check that an interceptor is used by only one instance of a class\n      * @throws Exception\n      */\n-    @Test public void test() throws Exception {\n-\n+    @Test \n+    public void shouldCallbacksBeDifferent() throws Exception {\n         Factory f1 = createMock();\n         Factory f2 = createMock();\n         \n--- /dev/null\n+++ b/test/org/mockito/internal/MockFactoryTest.java\n+package org.mockito.internal;\n+\n+import static org.hamcrest.CoreMatchers.*;\n+import static org.junit.Assert.*;\n+import net.sf.cglib.proxy.Factory;\n+\n+import org.junit.Test;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class MockFactoryTest {\n+\n+    @Test\n+    public void shouldCreateMockFromInterface() throws Exception {\n+        MockFactory<SomeInterface> factory = new MockFactory<SomeInterface>();\n+        SomeInterface proxy = factory.createMock(SomeInterface.class, new MockAwareStub());\n+        \n+        Class superClass = proxy.getClass().getSuperclass();\n+        assertThat(superClass, equalTo(Object.class));\n+    }\n+    \n+    @Test\n+    public void shouldCreateMockFromClass() throws Exception {\n+        MockFactory<ClassWithoutConstructor> factory = new MockFactory<ClassWithoutConstructor>();\n+        ClassWithoutConstructor proxy = factory.createMock(ClassWithoutConstructor.class, new MockAwareStub());\n+        \n+        Class superClass = proxy.getClass().getSuperclass();\n+        assertThat(superClass, equalTo(ClassWithoutConstructor.class));\n+    }\n+    \n+    @Test\n+    public void shouldCreateMockFromClassEvenWhenConstructorIsDodgy() throws Exception {\n+        MockFactory<ClassWithDodgyConstructor> factory = new MockFactory<ClassWithDodgyConstructor>();\n+        ClassWithDodgyConstructor mock = factory.createMock(ClassWithDodgyConstructor.class, new MockAwareStub());\n+        assertThat(mock, notNullValue());\n+    }\n+    \n+    @Test \n+    public void shouldMocksHaveDifferentInterceptors() throws Exception {\n+        MockFactory<SomeClass> factory = new MockFactory<SomeClass>();\n+        SomeClass mockOne = factory.createMock(SomeClass.class, new MockAwareStub());\n+        SomeClass mockTwo = factory.createMock(SomeClass.class, new MockAwareStub());\n+        \n+        Factory cglibFactoryOne = (Factory) mockOne;\n+        Factory cglibFactoryTwo = (Factory) mockTwo;\n+        \n+        assertNotSame(cglibFactoryOne.getCallback(0), cglibFactoryTwo.getCallback(0));\n+    }\n+    \n+    private interface SomeInterface {};\n+\n+    private class SomeClass {};\n+    private class ClassWithoutConstructor {};\n+    \n+    private class ClassWithDodgyConstructor {\n+        public ClassWithDodgyConstructor() {\n+            throw new RuntimeException();\n+        }\n+    };\n+    \n+    private final class MockAwareStub extends ObjectMethodsFilter {\n+        public MockAwareStub() {\n+            super(Object.class, null, null);\n+        }\n+\n+        public void setMock(Object mock) {}\n+    }\n+}\n--- a/test/org/mockito/internal/MockitoStateTest.java\n+++ b/test/org/mockito/internal/MockitoStateTest.java\n         \n         assertTrue(mockitoState.verificationScenario());\n         \n-        assertSame(mode, mockitoState.verifyingCompleted());\n+        assertSame(mode, mockitoState.removeVerifyingMode());\n     }\n     \n     @Test\n--- a/test/org/mockito/usage/ReplacingObjectMethodsTest.java\n+++ b/test/org/mockito/usage/ReplacingObjectMethodsTest.java\n \n public class ReplacingObjectMethodsTest {\n \n-    /**\n-     * Class overwrites object methods but implementation from Mockito will be called anyway.\n-     */\n-    public static class ClassToMockWithOverride {\n-\n-        public boolean equals(Object o) {\n-            return false;\n-        }\n-\n-        public int hashCode() {\n-            return -1;\n-        }\n-\n-        public String toString() {\n-            return \"super\";\n-        }\n-    }\n-    \n-    public static class ClassWithAnotherOverride extends ClassToMockWithOverride {\n-        \n-        public String toString() {\n-            return \"super.super\";\n-        }\n-    }\n-\n-    @Test \n-    public void testShouldReplaceObjectMethods() {\n-        Object mock = Mockito.mock(ClassToMockWithOverride.class);\n-        assertThat(mock, equalTo(mock));\n-        assertThat(mock.hashCode(), not(equalTo(-1)));\n-        assertThat(mock.toString(), not(equalTo(\"super\")));\n-    }\n-    \n-    @Test \n-    public void testShouldReplaceObjectMethodsWhenOverridden() {\n-        Object mock = Mockito.mock(ClassToMockWithOverride.class);\n-        assertThat(mock, equalTo(mock));\n-        assertThat(mock.hashCode(), not(equalTo(-1)));\n-        assertThat(mock.toString(), not(equalTo(\"super\")));\n-        assertThat(mock.toString(), not(equalTo(\"super.super\")));\n-    }\n-    \n     private interface DummyInterface {}\n     private class DummyClass {}\n-\n+    \n     @Test\n     public void shouldProvideMockyImplementationOfToString() {\n         assertEquals(\"Mock for DummyClass\", Mockito.mock(DummyClass.class).toString());\n         assertEquals(\"Mock for DummyInterface\", Mockito.mock(DummyInterface.class).toString());\n     }\n+    \n+    @Test \n+    public void testShouldReplaceObjectMethods() {\n+        Object mock = Mockito.mock(ObjectMethodsOverridden.class);\n+        Object otherMock = Mockito.mock(ObjectMethodsOverridden.class);\n+        \n+        assertThat(mock, equalTo(mock));\n+        assertThat(mock, not(equalTo(otherMock)));\n+        \n+        assertThat(mock.hashCode(), not(equalTo(otherMock.hashCode())));\n+        \n+        assertThat(mock.toString(), equalTo(\"Mock for ObjectMethodsOverridden\"));\n+    }\n+    \n+    @Test \n+    public void testShouldReplaceObjectMethodsWhenOverridden() {\n+        Object mock = Mockito.mock(ObjectMethodsOverriddenSubclass.class);\n+        Object otherMock = Mockito.mock(ObjectMethodsOverriddenSubclass.class);\n+        \n+        assertThat(mock, equalTo(mock));\n+        assertThat(mock, not(equalTo(otherMock)));\n+        \n+        assertThat(mock.hashCode(), not(equalTo(otherMock.hashCode())));\n+        \n+        assertThat(mock.toString(), equalTo(\"Mock for ObjectMethodsOverriddenSubclass\"));\n+    }\n+    \n+    public static class ObjectMethodsOverridden {\n+        public boolean equals(Object o) {\n+            throw new RuntimeException(\"Should not be called. ObjectMethodsFilter provides implementation\");\n+        }\n+        public int hashCode() {\n+            throw new RuntimeException(\"Should not be called. ObjectMethodsFilter provides implementation\");\n+        }\n+        public String toString() {\n+            throw new RuntimeException(\"Should not be called. ObjectMethodsFilter provides implementation\");\n+        }\n+    }\n+    \n+    public static class ObjectMethodsOverriddenSubclass extends ObjectMethodsOverridden {\n+    }\n }\n--- a/test/org/mockito/usage/matchers/BasicStubbingTest.java\n+++ b/test/org/mockito/usage/matchers/BasicStubbingTest.java\n \n import static org.hamcrest.CoreMatchers.equalTo;\n import static org.junit.Assert.*;\n-import static org.mockito.util.JUnitMatchers.contains;\n+import static org.mockito.util.ExtraMatchers.collectionContaining;\n \n import java.util.*;\n \n         \n         Mockito.stub(mock.getList()).andReturn(Arrays.asList(\"elementOne\", \"elementTwo\"));\n         \n-        assertThat(mock.getList(), contains(\"elementOne\", \"elementTwo\"));\n-        assertThat(mock.getList(), contains(\"elementOne\", \"elementTwo\"));\n+        assertThat(mock.getList(), collectionContaining(\"elementOne\", \"elementTwo\"));\n+        assertThat(mock.getList(), collectionContaining(\"elementOne\", \"elementTwo\"));\n         \n         Mockito.stub(mock.getString(10, \"test\")).andReturn(\"test\");\n         \n--- a/test/org/mockito/usage/matchers/ComparableMatchersTest.java\n+++ b/test/org/mockito/usage/matchers/ComparableMatchersTest.java\n import org.junit.Test;\n import org.mockito.internal.matchers.*;\n \n-//TODO do we need matchers like GreaterThan - does it make any sense?\n public class ComparableMatchersTest {\n \n     @Test\n--- a/test/org/mockito/usage/stubbing/BasicStubbingTest.java\n+++ b/test/org/mockito/usage/stubbing/BasicStubbingTest.java\n \n import static org.hamcrest.CoreMatchers.equalTo;\n import static org.junit.Assert.*;\n-import static org.mockito.util.JUnitMatchers.contains;\n+import static org.mockito.util.ExtraMatchers.collectionContaining;\n \n import java.util.*;\n \n         \n         Mockito.stub(mock.getList()).andReturn(Arrays.asList(\"elementOne\", \"elementTwo\"));\n         \n-        assertThat(mock.getList(), contains(\"elementOne\", \"elementTwo\"));\n-        assertThat(mock.getList(), contains(\"elementOne\", \"elementTwo\"));\n+        assertThat(mock.getList(), collectionContaining(\"elementOne\", \"elementTwo\"));\n+        assertThat(mock.getList(), collectionContaining(\"elementOne\", \"elementTwo\"));\n         \n         Mockito.stub(mock.getString(10, \"test\")).andReturn(\"test\");\n         \n--- /dev/null\n+++ b/test/org/mockito/util/ExtraMatchers.java\n+package org.mockito.util;\n+\n+import java.util.*;\n+\n+import org.hamcrest.*;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class ExtraMatchers {\n+\n+    public static <T> Matcher<Collection> collectionContaining(final T ... elements) {\n+        return new BaseMatcher<Collection>() {\n+\n+            public boolean matches(Object collection) {\n+                for (T element : elements) {\n+                    if (((Collection)collection).contains(element) == false) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+\n+            public void describeTo(Description desc) {\n+                desc.appendText(\"collection doesn't containg one of: \" + Arrays.toString(elements));\n+            }\n+        };\n+    }\n+}", "timestamp": 1195430023, "metainfo": ""}