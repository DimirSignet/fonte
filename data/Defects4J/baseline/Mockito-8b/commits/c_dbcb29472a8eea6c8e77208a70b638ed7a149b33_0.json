{"sha": "dbcb29472a8eea6c8e77208a70b638ed7a149b33", "log": "Tweaked the check for serialization, to narrow down serialization issues when there's no zero-arg constructor in types that don't implement Serializable", "commit": "\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n     public void serializableWontWorkForObjectsThatDontImplementSerializable(Class classToMock) {\n         throw new MockitoException(join(\n                 \"You are using the setting 'withSettings().serializable()' however the type you are trying to mock '\" + classToMock.getSimpleName() + \"'\",\n-                \" do not implement Serializable.\",\n+                \"do not implement Serializable AND do not have a no-arg constructor.\",\n                 \"This combination is requested, otherwise you will get an 'java.io.InvalidClassException' when the mock will be serialized\",\n                 \"\",\n                 \"Also note that as requested by the Java serialization specification, the whole hierarchy need to implements Serializable,\",\n--- a/src/org/mockito/internal/util/MockCreationValidator.java\n+++ b/src/org/mockito/internal/util/MockCreationValidator.java\n \n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.creation.jmock.ClassImposterizer;\n+import org.mockito.internal.util.reflection.Constructors;\n \n import java.io.Serializable;\n import java.util.Collection;\n         // We can't catch all the errors with this piece of code\n         // Having a **superclass that do not implements Serializable** might fail as well when serialized\n         // Though it might prevent issues when mockito is mocking a class without superclass.\n-        if(serializable && !classToMock.isInterface() && !(Serializable.class.isAssignableFrom(classToMock))) {\n-//            new Reporter().serializableWontWorkForObjectsThatDontImplementSerializable(classToMock);\n+        if(serializable\n+                && !classToMock.isInterface()\n+                && !(Serializable.class.isAssignableFrom(classToMock))\n+                && Constructors.noArgConstructorOf(classToMock) == null\n+                ) {\n+            new Reporter().serializableWontWorkForObjectsThatDontImplementSerializable(classToMock);\n         }\n     }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/util/reflection/Constructors.java\n+package org.mockito.internal.util.reflection;\n+\n+import java.lang.reflect.Constructor;\n+\n+public abstract class Constructors {\n+\n+    /**\n+     * Returns the no arg constructor of the type if any.\n+     *\n+     * @param classToMock The type to look for a no-arg constructor\n+     * @return The no-arg constructor or null if none is declared.\n+     */\n+    public static Constructor<?> noArgConstructorOf(Class<?> classToMock) {\n+        try {\n+            return classToMock.getDeclaredConstructor();\n+        } catch (NoSuchMethodException e) {\n+            return null;\n+        }\n+    }\n+}\n--- a/src/org/mockito/internal/util/reflection/Fields.java\n+++ b/src/org/mockito/internal/util/reflection/Fields.java\n public abstract class Fields {\n \n     /**\n-     * Instance fields declared in thes class and superclasses of the given instance.\n+     * Instance fields declared in the class and superclasses of the given instance.\n      *\n      * @param instance Instance from which declared fields will be retrieved.\n      * @return InstanceFields of this object instance.\n     }\n \n     /**\n-     * Instance fields declared in the of the given instance.\n+     * Instance fields declared in the class of the given instance.\n      *\n      * @param instance Instance from which declared fields will be retrieved.\n      * @return InstanceFields of this object instance.\n--- a/test/org/mockito/internal/util/MockCreationValidatorTest.java\n+++ b/test/org/mockito/internal/util/MockCreationValidatorTest.java\n import org.mockito.exceptions.base.MockitoException;\n import org.mockitousage.IMethods;\n \n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Observer;\n \n import static java.util.Arrays.asList;\n import static org.fest.assertions.Assertions.assertThat;\n \n     @Test(expected = MockitoException.class)\n     public void should_not_allow_serializable_with_Object_that_dont_implement_Serializable() {\n+        class NonSerializableInnerClassThatHaveAHiddenOneArgConstructor {}\n         boolean serializable = true;\n-        validator.validateSerializable(Observable.class, serializable);\n+        validator.validateSerializable(NonSerializableInnerClassThatHaveAHiddenOneArgConstructor.class, serializable);\n     }\n \n     @Test\n--- a/test/org/mockitousage/basicapi/MocksSerializationForAnnotationTest.java\n+++ b/test/org/mockitousage/basicapi/MocksSerializationForAnnotationTest.java\n package org.mockitousage.basicapi;\n \n import org.fest.assertions.Assertions;\n-import org.junit.Ignore;\n import org.junit.Test;\n import org.mockito.InOrder;\n import org.mockito.Mock;\n                 .isInstanceOf(IMethods.class);\n     }\n \n-    static class NotSerializableParent {\n-        NotSerializableParent(Observable o) { this.o = o; }\n-        private final Observable o;\n-    }\n-    static class NotSerializableToBeMocked extends NotSerializableParent {\n-        NotSerializableToBeMocked(Observable o) { super(o); }\n-    }\n-    \n-    public static class FailTestClass{\n-    \t@Mock(serializable=true) NotSerializableToBeMocked notSerializableToBeMocked;\n-    }\n-    \n-    @Test\n-    @Ignore(\"to be replaced by some MockitoException in AcrossJVMSerializationFeature\")\n-    public void should_fail_when_serializable_used_with_object_that_dont_implements_Serializable() throws Exception {\n+\n+\n+    static class NotSerializableAndNoDefaultConstructor {\n+        NotSerializableAndNoDefaultConstructor(Observable o) { super(); }\n+    }\n+    \n+    public static class FailTestClass {\n+    \t@Mock(serializable=true)\n+        NotSerializableAndNoDefaultConstructor notSerializableAndNoDefaultConstructor;\n+    }\n+    \n+    @Test\n+    public void should_fail_when_serializable_used_with_type_that_dont_implements_Serializable_and_dont_declare_a_no_arg_constructor() throws Exception {\n         try {\n-            MockitoAnnotations.initMocks(new FailTestClass());\n+            FailTestClass testClass = new FailTestClass();\n+            MockitoAnnotations.initMocks(testClass);\n+            serializeAndBack(testClass.notSerializableAndNoDefaultConstructor);\n             fail(\"should have thrown an exception to say the object is not serializable\");\n         } catch (MockitoException e) {\n             Assertions.assertThat(e.getMessage())\n-                    .contains(Observable.class.getSimpleName())\n+                    .contains(NotSerializableAndNoDefaultConstructor.class.getSimpleName())\n                     .contains(\"serializable()\")\n-                    .contains(\"implement Serializable\");\n+                    .contains(\"implement Serializable\")\n+                    .contains(\"no-arg constructor\");\n         }\n     }\n+\n+\n+\n+    static class SerializableAndNoDefaultConstructor implements Serializable {\n+        SerializableAndNoDefaultConstructor(Observable o) { super(); }\n+    }\n+\n+    public static class TestClassThatHoldValidField {\n+        @Mock(serializable=true)\n+        SerializableAndNoDefaultConstructor serializableAndNoDefaultConstructor;\n+    }\n+\n+    @Test\n+    public void should_be_able_to_serialize_type_that_implements_Serializable_but_but_dont_declare_a_no_arg_constructor() throws Exception {\n+        TestClassThatHoldValidField testClass = new TestClassThatHoldValidField();\n+        MockitoAnnotations.initMocks(testClass);\n+\n+        serializeAndBack(testClass.serializableAndNoDefaultConstructor);\n+    }\n }\n--- a/test/org/mockitousage/basicapi/MocksSerializationTest.java\n+++ b/test/org/mockitousage/basicapi/MocksSerializationTest.java\n                 .isInstanceOf(IMethods.class);\n     }\n \n-    @Test\n-    @Ignore(\"to be replaced by some MockitoException in AcrossJVMSerializationFeature\")\n-    public void should_fail_when_serializable_used_with_object_that_dont_implements_Serializable() throws Exception {\n+\n+\n+    static class NotSerializableAndNoDefaultConstructor {\n+        NotSerializableAndNoDefaultConstructor(Observable o) { super(); }\n+    }\n+\n+    @Test\n+    public void should_fail_when_serializable_used_with_type_that_dont_implements_Serializable_and_dont_declare_a_no_arg_constructor() throws Exception {\n         try {\n-            serializeMock(mock(Observable.class, withSettings().serializable()));\n-            fail();\n+            serializeAndBack(mock(NotSerializableAndNoDefaultConstructor.class, withSettings().serializable()));\n+            fail(\"should have thrown an exception to say the object is not serializable\");\n         } catch (MockitoException e) {\n             Assertions.assertThat(e.getMessage())\n-                    .contains(Observable.class.getSimpleName())\n+                    .contains(NotSerializableAndNoDefaultConstructor.class.getSimpleName())\n                     .contains(\"serializable()\")\n-                    .contains(\"implement Serializable\");\n+                    .contains(\"implement Serializable\")\n+                    .contains(\"no-arg constructor\");\n         }\n     }\n \n+\n+\n+    static class SerializableAndNoDefaultConstructor implements Serializable {\n+        SerializableAndNoDefaultConstructor(Observable o) { super(); }\n+    }\n+\n+    @Test\n+    public void should_be_able_to_serialize_type_that_implements_Serializable_but_but_dont_declare_a_no_arg_constructor() throws Exception {\n+        serializeAndBack(mock(SerializableAndNoDefaultConstructor.class));\n+    }\n+\n+\n     @Test\n     @Ignore(\"Bug to fix !!! see issue 399\")\n-    public void try_some_mocks_with_current_answers() throws Exception {\n+    public void BUG_ISSUE_399_try_some_mocks_with_current_answers() throws Exception {\n         IMethods iMethods = mock(IMethods.class, withSettings().serializable().defaultAnswer(RETURNS_DEEP_STUBS));\n \n         when(iMethods.iMethodsReturningMethod().linkedListReturningMethod().contains(anyString())).thenReturn(false);", "timestamp": 1355619876, "metainfo": ""}