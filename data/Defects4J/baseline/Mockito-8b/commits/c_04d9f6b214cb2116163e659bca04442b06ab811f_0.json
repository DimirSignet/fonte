{"sha": "04d9f6b214cb2116163e659bca04442b06ab811f", "log": "Added stubOnly() mock settings - not used in the code yet (transplanted from 5ab5ed723f58695c1252c1892b5f974fee0c6e0a)  --HG-- extra : transplant_source : Z%B5%EDr%3FXi%5C%12R%C1%89%2B_%97O%EE%0Cn%0A", "commit": "\n--- a/src/org/mockito/MockSettings.java\n+++ b/src/org/mockito/MockSettings.java\n  * Copyright (c) 2007 Mockito contributors\n  * This program is made available under the terms of the MIT License.\n  */\n-package org.mockito;\n-\n-import org.mockito.listeners.InvocationListener;\n-import org.mockito.mock.MockCreationSettings;\n-import org.mockito.stubbing.Answer;\n-\n-import java.io.Serializable;\n-\n-/**\n- * Allows mock creation with additional mock settings.\n- * <p/>\n- * Don't use it too often.\n- * Consider writing simple tests that use simple mocks.\n- * Repeat after me: simple tests push simple, KISSy, readable & maintainable code.\n- * If you cannot write a test in a simple way - refactor the code under test.\n- * <p/>\n- * Examples of mock settings:\n- * <pre class=\"code\"><code class=\"java\">\n- *   //Creates mock with different default answer & name\n- *   Foo mock = mock(Foo.class, withSettings()\n- *                                .defaultAnswer(RETURNS_SMART_NULLS)\n- *                                .name(\"cool mockie\")\n- *                                );\n- *\n- *   //Creates mock with different default answer, descriptive name and extra interfaces\n- *   Foo mock = mock(Foo.class, withSettings()\n- *                                .defaultAnswer(RETURNS_SMART_NULLS)\n- *                                .name(\"cool mockie\")\n- *                                .extraInterfaces(Bar.class));\n- * </code></pre>\n- * {@link MockSettings} has been introduced for two reasons.\n- * Firstly, to make it easy to add another mock setting when the demand comes.\n- * Secondly, to enable combining together different mock settings without introducing zillions of overloaded mock() methods.\n- */\n-public interface MockSettings extends Serializable {\n-\n-    /**\n-     * Specifies extra interfaces the mock should implement. Might be useful for legacy code or some corner cases.\n-     * For background, see issue 51 <a href=\"http://code.google.com/p/mockito/issues/detail?id=51\">here</a>\n-     * <p>\n-     * This mysterious feature should be used very occasionally.\n-     * The object under test should know exactly its collaborators & dependencies.\n-     * If you happen to use it often than please make sure you are really producing simple, clean & readable code.\n-     * <p>\n-     * Examples:\n-     * <pre class=\"code\"><code class=\"java\">\n-     *   Foo foo = mock(Foo.class, withSettings().extraInterfaces(Bar.class, Baz.class));\n-     *\n-     *   //now, the mock implements extra interfaces, so following casting is possible:\n-     *   Bar bar = (Bar) foo;\n-     *   Baz baz = (Baz) foo;\n-     * </code></pre>\n-     *\n-     * @param interfaces extra interfaces the should implement.\n-     * @return settings instance so that you can fluently specify other settings\n-     */\n-    MockSettings extraInterfaces(Class<?>... interfaces);\n-\n-    /**\n-     * Specifies mock name. Naming mocks can be helpful for debugging - the name is used in all verification errors.\n-     * <p>\n-     * Beware that naming mocks is not a solution for complex code which uses too many mocks or collaborators.\n-     * <b>If you have too many mocks then refactor the code</b> so that it's easy to test/debug without necessity of naming mocks.\n-     * <p>\n-     * <b>If you use &#064;Mock annotation then you've got naming mocks for free!</b> &#064;Mock uses field name as mock name. {@link Mock Read more.}\n-     * <p>\n-     * Examples:\n-     * <pre class=\"code\"><code class=\"java\">\n-     *   Foo foo = mock(Foo.class, withSettings().name(\"foo\"));\n-     *\n-     *   //Below does exactly the same:\n-     *   Foo foo = mock(Foo.class, \"foo\");\n-     * </code></pre>\n-     * @param name the name of the mock, later used in all verification errors\n-     * @return settings instance so that you can fluently specify other settings\n-     */\n-    MockSettings name(String name);\n-\n-    /**\n-     * Specifies the instance to spy on. Makes sense only for spies/partial mocks.\n-     *\n-     * Sets the instance that will be spied. Actually copies the internal fields of the passed instance to the mock.\n-     * <p>\n-     * As usual you are going to read <b>the partial mock warning</b>:\n-     * Object oriented programming is more or less about tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n-     * How does partial mock fit into this paradigm? Well, it just doesn't...\n-     * Partial mock usually means that the complexity has been moved to a different method on the same object.\n-     * In most cases, this is not the way you want to design your application.\n-     * <p>\n-     * However, there are rare cases when partial mocks come handy:\n-     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n-     * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n-     * <p>\n-     * Enough warnings about partial mocks, see an example how spiedInstance() works:\n-     * <pre class=\"code\"><code class=\"java\">\n-     *   Foo foo = mock(Foo.class, withSettings().spiedInstance(fooInstance));\n-     *\n-     *   //Below does exactly the same:\n-     *   Foo foo = spy(fooInstance);\n-     * </code></pre>\n-     *\n-     * About stubbing for a partial mock, as it is a spy it will always call the real method, unless you use the\n-     * <code>doReturn</code>|<code>Throw</code>|<code>Answer</code>|<code>CallRealMethod</code> stubbing style. Example:\n-     *\n-     * <pre class=\"code\"><code class=\"java\">\n-     *   List list = new LinkedList();\n-     *   List spy = spy(list);\n-     *\n-     *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n-     *   when(spy.get(0)).thenReturn(\"foo\");\n-     *\n-     *   //You have to use doReturn() for stubbing\n-     *   doReturn(\"foo\").when(spy).get(0);\n-     * </code>\n-     *\n-     * @param instance to spy on\n-     * @return settings instance so that you can fluently specify other settings\n-     */\n-    MockSettings spiedInstance(Object instance);\n-\n-    /**\n-     * Specifies default answers to interactions.\n-     * It's quite advanced feature and typically you don't need it to write decent tests.\n-     * However it can be helpful when working with legacy systems.\n-     * <p>\n-     * It is the default answer so it will be used <b>only when you don't</b> stub the method call.\n-     *\n-     * <pre class=\"code\"><code class=\"java\">\n-     *   Foo mock = mock(Foo.class, withSettings().defaultAnswer(RETURNS_SMART_NULLS));\n-     *   Foo mockTwo = mock(Foo.class, withSettings().defaultAnswer(new YourOwnAnswer()));\n-     *\n-     *   //Below does exactly the same:\n-     *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer());\n-     * </code></pre>\n-     *\n-     * @param defaultAnswer default answer to be used by mock when not stubbed\n-     * @return settings instance so that you can fluently specify other settings\n-     */\n-    @SuppressWarnings(\"unchecked\")\n-    MockSettings defaultAnswer(Answer defaultAnswer);\n-\n-    /**\n-     * Configures the mock to be serializable. With this feature you can use a mock in a place that requires dependencies to be serializable.\n-     * <p>\n-     * WARNING: This should be rarely used in unit testing.\n-     * <p>\n-     * The behaviour was implemented for a specific use case of a BDD spec that had an unreliable external dependency.  This\n-     * was in a web environment and the objects from the external dependency were being serialized to pass between layers.\n-     * <p>\n-     * Example:\n-     * <pre class=\"code\"><code class=\"java\">\n-     *   List serializableMock = mock(List.class, withSettings().serializable());\n-     * </code></pre>\n-     *\n-     * @return settings instance so that you can fluently specify other settings\n-     * @since 1.8.1\n-     */\n-    MockSettings serializable();\n-\n-    /**\n-     * Enables real-time logging of method invocations on this mock. Can be used\n-     * during test debugging in order to find wrong interactions with this mock.\n-     * <p>\n-     * Invocations are logged as they happen to the standard output stream.\n-     * <p>\n-     * Calling this method multiple times makes no difference.\n-     * <p>\n-     * Example:\n-     * <pre class=\"code\"><code class=\"java\">\n-     * List mockWithLogger = mock(List.class, withSettings().verboseLogging());\n-     * </code></pre>\n-     *\n-     * @return settings instance so that you can fluently specify other settings\n-     */\n-    MockSettings verboseLogging();\n-\n-    /**\n-     * Registers a listener for method invocations on this mock. The listener is\n-     * notified every time a method on this mock is called.\n-     * <p>\n-     * Multiple listeners may be added, but the same object is only added once.\n-     * The order, in which the listeners are added, is not guaranteed to be the\n-     * order in which the listeners are notified.\n-     *\n-     * Example:\n-     * <pre class=\"code\"><code class=\"java\">\n-     *  List mockWithListener = mock(List.class, withSettings().invocationListeners(new YourInvocationListener()));\n-     * </code></pre>\n-     *\n-     * See the {@link InvocationListener listener interface} for more details.\n-     *\n-     * @param listeners The invocation listeners to add. May not be null.\n-     * @return settings instance so that you can fluently specify other settings\n-     */\n-    MockSettings invocationListeners(InvocationListener... listeners);\n-}\n+package org.mockito;\n+\n+import org.mockito.listeners.InvocationListener;\n+import org.mockito.mock.MockCreationSettings;\n+import org.mockito.stubbing.Answer;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Allows mock creation with additional mock settings.\n+ * <p/>\n+ * Don't use it too often.\n+ * Consider writing simple tests that use simple mocks.\n+ * Repeat after me: simple tests push simple, KISSy, readable & maintainable code.\n+ * If you cannot write a test in a simple way - refactor the code under test.\n+ * <p/>\n+ * Examples of mock settings:\n+ * <pre class=\"code\"><code class=\"java\">\n+ *   //Creates mock with different default answer & name\n+ *   Foo mock = mock(Foo.class, withSettings()\n+ *                                .defaultAnswer(RETURNS_SMART_NULLS)\n+ *                                .name(\"cool mockie\")\n+ *                                );\n+ *\n+ *   //Creates mock with different default answer, descriptive name and extra interfaces\n+ *   Foo mock = mock(Foo.class, withSettings()\n+ *                                .defaultAnswer(RETURNS_SMART_NULLS)\n+ *                                .name(\"cool mockie\")\n+ *                                .extraInterfaces(Bar.class));\n+ * </code></pre>\n+ * {@link MockSettings} has been introduced for two reasons.\n+ * Firstly, to make it easy to add another mock setting when the demand comes.\n+ * Secondly, to enable combining together different mock settings without introducing zillions of overloaded mock() methods.\n+ */\n+public interface MockSettings extends Serializable {\n+\n+    /**\n+     * Specifies extra interfaces the mock should implement. Might be useful for legacy code or some corner cases.\n+     * For background, see issue 51 <a href=\"http://code.google.com/p/mockito/issues/detail?id=51\">here</a>\n+     * <p>\n+     * This mysterious feature should be used very occasionally.\n+     * The object under test should know exactly its collaborators & dependencies.\n+     * If you happen to use it often than please make sure you are really producing simple, clean & readable code.\n+     * <p>\n+     * Examples:\n+     * <pre class=\"code\"><code class=\"java\">\n+     *   Foo foo = mock(Foo.class, withSettings().extraInterfaces(Bar.class, Baz.class));\n+     *\n+     *   //now, the mock implements extra interfaces, so following casting is possible:\n+     *   Bar bar = (Bar) foo;\n+     *   Baz baz = (Baz) foo;\n+     * </code></pre>\n+     *\n+     * @param interfaces extra interfaces the should implement.\n+     * @return settings instance so that you can fluently specify other settings\n+     */\n+    MockSettings extraInterfaces(Class<?>... interfaces);\n+\n+    /**\n+     * Specifies mock name. Naming mocks can be helpful for debugging - the name is used in all verification errors.\n+     * <p>\n+     * Beware that naming mocks is not a solution for complex code which uses too many mocks or collaborators.\n+     * <b>If you have too many mocks then refactor the code</b> so that it's easy to test/debug without necessity of naming mocks.\n+     * <p>\n+     * <b>If you use &#064;Mock annotation then you've got naming mocks for free!</b> &#064;Mock uses field name as mock name. {@link Mock Read more.}\n+     * <p>\n+     * Examples:\n+     * <pre class=\"code\"><code class=\"java\">\n+     *   Foo foo = mock(Foo.class, withSettings().name(\"foo\"));\n+     *\n+     *   //Below does exactly the same:\n+     *   Foo foo = mock(Foo.class, \"foo\");\n+     * </code></pre>\n+     * @param name the name of the mock, later used in all verification errors\n+     * @return settings instance so that you can fluently specify other settings\n+     */\n+    MockSettings name(String name);\n+\n+    /**\n+     * Specifies the instance to spy on. Makes sense only for spies/partial mocks.\n+     *\n+     * Sets the instance that will be spied. Actually copies the internal fields of the passed instance to the mock.\n+     * <p>\n+     * As usual you are going to read <b>the partial mock warning</b>:\n+     * Object oriented programming is more or less about tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n+     * How does partial mock fit into this paradigm? Well, it just doesn't...\n+     * Partial mock usually means that the complexity has been moved to a different method on the same object.\n+     * In most cases, this is not the way you want to design your application.\n+     * <p>\n+     * However, there are rare cases when partial mocks come handy:\n+     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n+     * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n+     * <p>\n+     * Enough warnings about partial mocks, see an example how spiedInstance() works:\n+     * <pre class=\"code\"><code class=\"java\">\n+     *   Foo foo = mock(Foo.class, withSettings().spiedInstance(fooInstance));\n+     *\n+     *   //Below does exactly the same:\n+     *   Foo foo = spy(fooInstance);\n+     * </code></pre>\n+     *\n+     * About stubbing for a partial mock, as it is a spy it will always call the real method, unless you use the\n+     * <code>doReturn</code>|<code>Throw</code>|<code>Answer</code>|<code>CallRealMethod</code> stubbing style. Example:\n+     *\n+     * <pre class=\"code\"><code class=\"java\">\n+     *   List list = new LinkedList();\n+     *   List spy = spy(list);\n+     *\n+     *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n+     *   when(spy.get(0)).thenReturn(\"foo\");\n+     *\n+     *   //You have to use doReturn() for stubbing\n+     *   doReturn(\"foo\").when(spy).get(0);\n+     * </code>\n+     *\n+     * @param instance to spy on\n+     * @return settings instance so that you can fluently specify other settings\n+     */\n+    MockSettings spiedInstance(Object instance);\n+\n+    /**\n+     * Specifies default answers to interactions.\n+     * It's quite advanced feature and typically you don't need it to write decent tests.\n+     * However it can be helpful when working with legacy systems.\n+     * <p>\n+     * It is the default answer so it will be used <b>only when you don't</b> stub the method call.\n+     *\n+     * <pre class=\"code\"><code class=\"java\">\n+     *   Foo mock = mock(Foo.class, withSettings().defaultAnswer(RETURNS_SMART_NULLS));\n+     *   Foo mockTwo = mock(Foo.class, withSettings().defaultAnswer(new YourOwnAnswer()));\n+     *\n+     *   //Below does exactly the same:\n+     *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer());\n+     * </code></pre>\n+     *\n+     * @param defaultAnswer default answer to be used by mock when not stubbed\n+     * @return settings instance so that you can fluently specify other settings\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    MockSettings defaultAnswer(Answer defaultAnswer);\n+\n+    /**\n+     * Configures the mock to be serializable. With this feature you can use a mock in a place that requires dependencies to be serializable.\n+     * <p>\n+     * WARNING: This should be rarely used in unit testing.\n+     * <p>\n+     * The behaviour was implemented for a specific use case of a BDD spec that had an unreliable external dependency.  This\n+     * was in a web environment and the objects from the external dependency were being serialized to pass between layers.\n+     * <p>\n+     * Example:\n+     * <pre class=\"code\"><code class=\"java\">\n+     *   List serializableMock = mock(List.class, withSettings().serializable());\n+     * </code></pre>\n+     *\n+     * @return settings instance so that you can fluently specify other settings\n+     * @since 1.8.1\n+     */\n+    MockSettings serializable();\n+\n+    /**\n+     * Enables real-time logging of method invocations on this mock. Can be used\n+     * during test debugging in order to find wrong interactions with this mock.\n+     * <p>\n+     * Invocations are logged as they happen to the standard output stream.\n+     * <p>\n+     * Calling this method multiple times makes no difference.\n+     * <p>\n+     * Example:\n+     * <pre class=\"code\"><code class=\"java\">\n+     * List mockWithLogger = mock(List.class, withSettings().verboseLogging());\n+     * </code></pre>\n+     *\n+     * @return settings instance so that you can fluently specify other settings\n+     */\n+    MockSettings verboseLogging();\n+\n+    /**\n+     * Registers a listener for method invocations on this mock. The listener is\n+     * notified every time a method on this mock is called.\n+     * <p>\n+     * Multiple listeners may be added, but the same object is only added once.\n+     * The order, in which the listeners are added, is not guaranteed to be the\n+     * order in which the listeners are notified.\n+     *\n+     * Example:\n+     * <pre class=\"code\"><code class=\"java\">\n+     *  List mockWithListener = mock(List.class, withSettings().invocationListeners(new YourInvocationListener()));\n+     * </code></pre>\n+     *\n+     * See the {@link InvocationListener listener interface} for more details.\n+     *\n+     * @param listeners The invocation listeners to add. May not be null.\n+     * @return settings instance so that you can fluently specify other settings\n+     */\n+    MockSettings invocationListeners(InvocationListener... listeners);\n+\n+    /**\n+     * Sets whether this mock should only provide stubbing of methods.\n+     * A stub-only mock does not record method\n+     * invocations, thus saving memory but\n+     * disallowing verification of invocations.\n+     * <p>\n+     * Example:\n+     * <pre class=\"code\"><code class=\"java\">\n+     * List stubOnly = mock(List.class, withSettings().stubOnly());\n+     * </code></pre>\n+     *\n+     * @return settings instance so that you can fluently specify other settings\n+     */\n+    MockSettings stubOnly();}\n--- a/src/org/mockito/internal/creation/MockSettingsImpl.java\n+++ b/src/org/mockito/internal/creation/MockSettingsImpl.java\n import org.mockito.stubbing.Answer;\n \n import java.io.Serializable;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Set;\n+import java.util.*;\n \n import static org.mockito.internal.util.collections.Sets.newSet;\n \n @SuppressWarnings(\"unchecked\")\n public class MockSettingsImpl<T> extends CreationSettings<T> implements MockSettings, MockCreationSettings<T> {\n \n-    private static final long serialVersionUID = 4475297236197939568L;\n+    private static final long serialVersionUID = 4475297236197939569L;\n \n     public MockSettings serializable() {\n         this.serializable = true;\n         return serializable;\n     }\n \n+    public MockSettings stubOnly() {\n+        this.stubOnly = true;\n+        return this;\n+    }\n+\n+    public boolean isStubOnly() {\n+        return this.stubOnly;\n+    }\n+\n     public MockSettings verboseLogging() {\n         if (!invocationListenersContainsType(VerboseMockInvocationLogger.class)) {\n             invocationListeners(new VerboseMockInvocationLogger());\n         //TODO SF - add this validation and also add missing coverage\n //        validator.validateDelegatedInstance(classToMock, settings.getDelegatedInstance());\n \n-        validator.validateSerializable(typeToMock, source.isSerializable());\n-\n         CreationSettings<T> settings = new CreationSettings<T>(source);\n         settings.setMockName(new MockNameImpl(source.getName(), typeToMock));\n         settings.setTypeToMock(typeToMock);\n--- a/src/org/mockito/internal/creation/settings/CreationSettings.java\n+++ b/src/org/mockito/internal/creation/settings/CreationSettings.java\n     protected Answer<Object> defaultAnswer;\n     protected MockName mockName;\n     protected boolean serializable;\n+    protected boolean stubOnly;\n     protected List<InvocationListener> invocationListeners = new ArrayList<InvocationListener>();\n \n     public CreationSettings() {}\n         this.mockName = copy.mockName;\n         this.serializable = copy.serializable;\n         this.invocationListeners = copy.invocationListeners;\n+        this.stubOnly = copy.stubOnly;\n     }\n \n     public Class<T> getTypeToMock() {\n         return serializable;\n     }\n \n+    public boolean isStubOnly() {\n+        return stubOnly;\n+    }\n+\n     public List<InvocationListener> getInvocationListeners() {\n         return invocationListeners;\n     }\n--- a/src/org/mockito/mock/MockCreationSettings.java\n+++ b/src/org/mockito/mock/MockCreationSettings.java\n     boolean isSerializable();\n \n     /**\n+     * Whether the mock is only for stubbing, i.e. does not remember\n+     * parameters on its invocation and therefore cannot\n+     * be used for verification\n+     */\n+    boolean isStubOnly();\n+\n+    /**\n      * the invocation listeners attached to this mock, see {@link org.mockito.MockSettings#invocationListeners}.\n      */\n     List<InvocationListener> getInvocationListeners();", "timestamp": 1346521538, "metainfo": ""}