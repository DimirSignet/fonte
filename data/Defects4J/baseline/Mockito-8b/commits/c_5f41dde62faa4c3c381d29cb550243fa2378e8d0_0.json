{"sha": "5f41dde62faa4c3c381d29cb550243fa2378e8d0", "log": "some refactorings, enabled some ingnored tests  --HG-- rename : src/org/mockito/exceptions/NotAMockMethodException.java => src/org/mockito/exceptions/MissingMethodInvocationException.java rename : src/org/mockito/internal/ExpectedInvocation.java => src/org/mockito/internal/InvocationWithMatchers.java rename : src/org/mockito/internal/MockitoOperations.java => src/org/mockito/internal/MockitoState.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%4030", "commit": "\n--- a/src/org/mockito/CrazyMatchers.java\n+++ b/src/org/mockito/CrazyMatchers.java\n      * @return <code>null</code>.\n      */\n     public static <T extends Comparable<T>> T geq(Comparable<T> value) {\n-        LastArguments.reportMatcher(new GreaterOrEqual<T>(value));\n+        LastArguments.instance().reportMatcher(new GreaterOrEqual<T>(value));\n         return null;\n     }\n     \n      * @return <code>0</code>.\n      */\n     public static byte geq(byte value) {\n-        LastArguments.reportMatcher(new GreaterOrEqual<Byte>(value));\n+        LastArguments.instance().reportMatcher(new GreaterOrEqual<Byte>(value));\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static double geq(double value) {\n-        LastArguments.reportMatcher(new GreaterOrEqual<Double>(value));\n+        LastArguments.instance().reportMatcher(new GreaterOrEqual<Double>(value));\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static float geq(float value) {\n-        LastArguments.reportMatcher(new GreaterOrEqual<Float>(value));\n+        LastArguments.instance().reportMatcher(new GreaterOrEqual<Float>(value));\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static int geq(int value) {\n-        LastArguments.reportMatcher(new GreaterOrEqual<Integer>(value));\n+        LastArguments.instance().reportMatcher(new GreaterOrEqual<Integer>(value));\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static long geq(long value) {\n-        LastArguments.reportMatcher(new GreaterOrEqual<Long>(value));\n+        LastArguments.instance().reportMatcher(new GreaterOrEqual<Long>(value));\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static short geq(short value) {\n-        LastArguments.reportMatcher(new GreaterOrEqual<Short>(value));\n+        LastArguments.instance().reportMatcher(new GreaterOrEqual<Short>(value));\n         return 0;\n     }\n \n      * @return <code>null</code>.\n      */\n     public static <T extends Comparable<T>> T leq(Comparable<T> value) {\n-        LastArguments.reportMatcher(new LessOrEqual<T>(value));\n+        LastArguments.instance().reportMatcher(new LessOrEqual<T>(value));\n         return null;\n     }\n      \n      * @return <code>0</code>.\n      */\n     public static byte leq(byte value) {\n-        LastArguments.reportMatcher(new LessOrEqual<Byte>(value));\n+        LastArguments.instance().reportMatcher(new LessOrEqual<Byte>(value));\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static double leq(double value) {\n-        LastArguments.reportMatcher(new LessOrEqual<Double>(value));\n+        LastArguments.instance().reportMatcher(new LessOrEqual<Double>(value));\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static float leq(float value) {\n-        LastArguments.reportMatcher(new LessOrEqual<Float>(value));\n+        LastArguments.instance().reportMatcher(new LessOrEqual<Float>(value));\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static int leq(int value) {\n-        LastArguments.reportMatcher(new LessOrEqual<Integer>(value));\n+        LastArguments.instance().reportMatcher(new LessOrEqual<Integer>(value));\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static long leq(long value) {\n-        LastArguments.reportMatcher(new LessOrEqual<Long>(value));\n+        LastArguments.instance().reportMatcher(new LessOrEqual<Long>(value));\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static short leq(short value) {\n-        LastArguments.reportMatcher(new LessOrEqual<Short>(value));\n+        LastArguments.instance().reportMatcher(new LessOrEqual<Short>(value));\n         return 0;\n     }\n \n      * @return <code>null</code>.\n      */\n     public static <T extends Comparable<T>> T gt(Comparable<T> value) {\n-        LastArguments.reportMatcher(new GreaterThan<T>(value));\n+        LastArguments.instance().reportMatcher(new GreaterThan<T>(value));\n         return null;\n     }\n     \n      * @return <code>0</code>.\n      */\n     public static byte gt(byte value) {\n-        LastArguments.reportMatcher(new GreaterThan<Byte>(value));\n+        LastArguments.instance().reportMatcher(new GreaterThan<Byte>(value));\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static double gt(double value) {\n-        LastArguments.reportMatcher(new GreaterThan<Double>(value));\n+        LastArguments.instance().reportMatcher(new GreaterThan<Double>(value));\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static float gt(float value) {\n-        LastArguments.reportMatcher(new GreaterThan<Float>(value));\n+        LastArguments.instance().reportMatcher(new GreaterThan<Float>(value));\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static int gt(int value) {\n-        LastArguments.reportMatcher(new GreaterThan<Integer>(value));\n+        LastArguments.instance().reportMatcher(new GreaterThan<Integer>(value));\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static long gt(long value) {\n-        LastArguments.reportMatcher(new GreaterThan<Long>(value));\n+        LastArguments.instance().reportMatcher(new GreaterThan<Long>(value));\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static short gt(short value) {\n-        LastArguments.reportMatcher(new GreaterThan<Short>(value));\n+        LastArguments.instance().reportMatcher(new GreaterThan<Short>(value));\n         return 0;\n     }\n \n      * @return <code>null</code>.\n      */\n     public static <T extends Comparable<T>> T lt(Comparable<T> value) {\n-        LastArguments.reportMatcher(new LessThan<T>(value));\n+        LastArguments.instance().reportMatcher(new LessThan<T>(value));\n         return null;\n     }\n     \n      * @return <code>0</code>.\n      */\n     public static byte lt(byte value) {\n-        LastArguments.reportMatcher(new LessThan<Byte>(value));\n+        LastArguments.instance().reportMatcher(new LessThan<Byte>(value));\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static double lt(double value) {\n-        LastArguments.reportMatcher(new LessThan<Double>(value));\n+        LastArguments.instance().reportMatcher(new LessThan<Double>(value));\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static float lt(float value) {\n-        LastArguments.reportMatcher(new LessThan<Float>(value));\n+        LastArguments.instance().reportMatcher(new LessThan<Float>(value));\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static int lt(int value) {\n-        LastArguments.reportMatcher(new LessThan<Integer>(value));\n+        LastArguments.instance().reportMatcher(new LessThan<Integer>(value));\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static long lt(long value) {\n-        LastArguments.reportMatcher(new LessThan<Long>(value));\n+        LastArguments.instance().reportMatcher(new LessThan<Long>(value));\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static short lt(short value) {\n-        LastArguments.reportMatcher(new LessThan<Short>(value));\n+        LastArguments.instance().reportMatcher(new LessThan<Short>(value));\n         return 0;\n     }\n     \n      * @return <code>null</code>.\n      */\n     public static String contains(String substring) {\n-        LastArguments.reportMatcher(new Contains(substring));\n+        LastArguments.instance().reportMatcher(new Contains(substring));\n         return null;\n     }\n \n      * @return <code>false</code>.\n      */\n     public static boolean and(boolean first, boolean second) {\n-        LastArguments.reportAnd(2);\n+        LastArguments.instance().reportAnd(2);\n         return false;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static byte and(byte first, byte second) {\n-        LastArguments.reportAnd(2);\n+        LastArguments.instance().reportAnd(2);\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static char and(char first, char second) {\n-        LastArguments.reportAnd(2);\n+        LastArguments.instance().reportAnd(2);\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static double and(double first, double second) {\n-        LastArguments.reportAnd(2);\n+        LastArguments.instance().reportAnd(2);\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static float and(float first, float second) {\n-        LastArguments.reportAnd(2);\n+        LastArguments.instance().reportAnd(2);\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static int and(int first, int second) {\n-        LastArguments.reportAnd(2);\n+        LastArguments.instance().reportAnd(2);\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static long and(long first, long second) {\n-        LastArguments.reportAnd(2);\n+        LastArguments.instance().reportAnd(2);\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static short and(short first, short second) {\n-        LastArguments.reportAnd(2);\n+        LastArguments.instance().reportAnd(2);\n         return 0;\n     }\n \n      * @return <code>null</code>.\n      */\n     public static <T> T and(T first, T second) {\n-        LastArguments.reportAnd(2);\n+        LastArguments.instance().reportAnd(2);\n         return null;\n     }\n \n      * @return <code>false</code>.\n      */\n     public static boolean or(boolean first, boolean second) {\n-        LastArguments.reportOr(2);\n+        LastArguments.instance().reportOr(2);\n         return false;\n     }\n \n      * @return <code>null</code>.\n      */\n     public static <T extends Comparable<T>> T cmpEq(Comparable<T> value) {\n-        LastArguments.reportMatcher(new CompareEqual<T>(value));\n+        LastArguments.instance().reportMatcher(new CompareEqual<T>(value));\n         return null;\n     }\n \n      * @return <code>null</code>.\n      */\n     public static <T> T same(T value) {\n-        LastArguments.reportMatcher(new Same(value));\n+        LastArguments.instance().reportMatcher(new Same(value));\n         return null;\n     }\n \n      * @return <code>null</code>.\n      */\n     public static String endsWith(String suffix) {\n-        LastArguments.reportMatcher(new EndsWith(suffix));\n+        LastArguments.instance().reportMatcher(new EndsWith(suffix));\n         return null;\n     }\n \n      * @return <code>null</code>.\n      */\n     public static String startsWith(String prefix) {\n-        LastArguments.reportMatcher(new StartsWith(prefix));\n+        LastArguments.instance().reportMatcher(new StartsWith(prefix));\n         return null;\n     }\n \n      * @return <code>null</code>.\n      */\n     public static String find(String regex) {\n-        LastArguments.reportMatcher(new Find(regex));\n+        LastArguments.instance().reportMatcher(new Find(regex));\n         return null;\n     }\n \n      * @return <code>null</code>.\n      */\n     public static <T> T[] aryEq(T[] value) {\n-        LastArguments.reportMatcher(new ArrayEquals(value));\n+        LastArguments.instance().reportMatcher(new ArrayEquals(value));\n         return null;\n     }\n \n      * @return <code>null</code>.\n      */\n     public static short[] aryEq(short[] value) {\n-        LastArguments.reportMatcher(new ArrayEquals(value));\n+        LastArguments.instance().reportMatcher(new ArrayEquals(value));\n         return null;\n     }\n \n      * @return <code>null</code>.\n      */\n     public static long[] aryEq(long[] value) {\n-        LastArguments.reportMatcher(new ArrayEquals(value));\n+        LastArguments.instance().reportMatcher(new ArrayEquals(value));\n         return null;\n     }\n \n      * @return <code>null</code>.\n      */\n     public static int[] aryEq(int[] value) {\n-        LastArguments.reportMatcher(new ArrayEquals(value));\n+        LastArguments.instance().reportMatcher(new ArrayEquals(value));\n         return null;\n     }\n \n      * @return <code>null</code>.\n      */\n     public static float[] aryEq(float[] value) {\n-        LastArguments.reportMatcher(new ArrayEquals(value));\n+        LastArguments.instance().reportMatcher(new ArrayEquals(value));\n         return null;\n     }\n \n      * @return <code>null</code>.\n      */\n     public static double[] aryEq(double[] value) {\n-        LastArguments.reportMatcher(new ArrayEquals(value));\n+        LastArguments.instance().reportMatcher(new ArrayEquals(value));\n         return null;\n     }\n \n      * @return <code>null</code>.\n      */\n     public static char[] aryEq(char[] value) {\n-        LastArguments.reportMatcher(new ArrayEquals(value));\n+        LastArguments.instance().reportMatcher(new ArrayEquals(value));\n         return null;\n     }\n \n      * @return <code>null</code>.\n      */\n     public static byte[] aryEq(byte[] value) {\n-        LastArguments.reportMatcher(new ArrayEquals(value));\n+        LastArguments.instance().reportMatcher(new ArrayEquals(value));\n         return null;\n     }\n \n      * @return <code>null</code>.\n      */\n     public static boolean[] aryEq(boolean[] value) {\n-        LastArguments.reportMatcher(new ArrayEquals(value));\n+        LastArguments.instance().reportMatcher(new ArrayEquals(value));\n         return null;\n     }\n \n      * @return <code>null</code>.\n      */\n     public static <T> T not(T first) {\n-        LastArguments.reportNot();\n+        LastArguments.instance().reportNot();\n         return null;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static short not(short first) {\n-        LastArguments.reportNot();\n+        LastArguments.instance().reportNot();\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static int not(int first) {\n-        LastArguments.reportNot();\n+        LastArguments.instance().reportNot();\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static long not(long first) {\n-        LastArguments.reportNot();\n+        LastArguments.instance().reportNot();\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static float not(float first) {\n-        LastArguments.reportNot();\n+        LastArguments.instance().reportNot();\n         return first;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static double not(double first) {\n-        LastArguments.reportNot();\n+        LastArguments.instance().reportNot();\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static char not(char first) {\n-        LastArguments.reportNot();\n+        LastArguments.instance().reportNot();\n         return 0;\n     }\n \n      * @return <code>false</code>.\n      */\n     public static boolean not(boolean first) {\n-        LastArguments.reportNot();\n+        LastArguments.instance().reportNot();\n         return false;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static byte not(byte first) {\n-        LastArguments.reportNot();\n+        LastArguments.instance().reportNot();\n         return 0;\n     }\n \n      * @return <code>null</code>.\n      */\n     public static <T> T or(T first, T second) {\n-        LastArguments.reportOr(2);\n+        LastArguments.instance().reportOr(2);\n         return null;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static short or(short first, short second) {\n-        LastArguments.reportOr(2);\n+        LastArguments.instance().reportOr(2);\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static long or(long first, long second) {\n-        LastArguments.reportOr(2);\n+        LastArguments.instance().reportOr(2);\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static int or(int first, int second) {\n-        LastArguments.reportOr(2);\n+        LastArguments.instance().reportOr(2);\n         return first;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static float or(float first, float second) {\n-        LastArguments.reportOr(2);\n+        LastArguments.instance().reportOr(2);\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static double or(double first, double second) {\n-        LastArguments.reportOr(2);\n+        LastArguments.instance().reportOr(2);\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static char or(char first, char second) {\n-        LastArguments.reportOr(2);\n+        LastArguments.instance().reportOr(2);\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static byte or(byte first, byte second) {\n-        LastArguments.reportOr(2);\n+        LastArguments.instance().reportOr(2);\n         return 0;\n     }\n }\n--- a/src/org/mockito/Matchers.java\n+++ b/src/org/mockito/Matchers.java\n      * @return <code>false</code>.\n      */\n     public static boolean anyBoolean() {\n-        LastArguments.reportMatcher(Any.ANY);\n+        LastArguments.instance().reportMatcher(Any.ANY);\n         return false;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static byte anyByte() {\n-        LastArguments.reportMatcher(Any.ANY);\n+        LastArguments.instance().reportMatcher(Any.ANY);\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static char anyChar() {\n-        LastArguments.reportMatcher(Any.ANY);\n+        LastArguments.instance().reportMatcher(Any.ANY);\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static int anyInt() {\n-        LastArguments.reportMatcher(Any.ANY);\n+        LastArguments.instance().reportMatcher(Any.ANY);\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static long anyLong() {\n-        LastArguments.reportMatcher(Any.ANY);\n+        LastArguments.instance().reportMatcher(Any.ANY);\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static float anyFloat() {\n-        LastArguments.reportMatcher(Any.ANY);\n+        LastArguments.instance().reportMatcher(Any.ANY);\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static double anyDouble() {\n-        LastArguments.reportMatcher(Any.ANY);\n+        LastArguments.instance().reportMatcher(Any.ANY);\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static short anyShort() {\n-        LastArguments.reportMatcher(Any.ANY);\n+        LastArguments.instance().reportMatcher(Any.ANY);\n         return 0;\n     }\n \n      * @return <code>null</code>.\n      */\n     public static Object anyObject() {\n-        LastArguments.reportMatcher(Any.ANY);\n+        LastArguments.instance().reportMatcher(Any.ANY);\n+        return null;\n+    }\n+    \n+    public static String anyString() {\n+        isA(String.class);\n         return null;\n     }\n \n      * @return <code>null</code>.\n      */\n     public static <T> T isA(Class<T> clazz) {\n-        LastArguments.reportMatcher(new InstanceOf(clazz));\n+        LastArguments.instance().reportMatcher(new InstanceOf(clazz));\n         return null;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static boolean eq(boolean value) {\n-        LastArguments.reportMatcher(new Equals(value));\n+        LastArguments.instance().reportMatcher(new Equals(value));\n         return false;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static byte eq(byte value) {\n-        LastArguments.reportMatcher(new Equals(value));\n+        LastArguments.instance().reportMatcher(new Equals(value));\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static char eq(char value) {\n-        LastArguments.reportMatcher(new Equals(value));\n+        LastArguments.instance().reportMatcher(new Equals(value));\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static double eq(double value) {\n-        LastArguments.reportMatcher(new Equals(value));\n+        LastArguments.instance().reportMatcher(new Equals(value));\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static float eq(float value) {\n-        LastArguments.reportMatcher(new Equals(value));\n+        LastArguments.instance().reportMatcher(new Equals(value));\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static int eq(int value) {\n-        LastArguments.reportMatcher(new Equals(value));\n+        LastArguments.instance().reportMatcher(new Equals(value));\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static long eq(long value) {\n-        LastArguments.reportMatcher(new Equals(value));\n+        LastArguments.instance().reportMatcher(new Equals(value));\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static short eq(short value) {\n-        LastArguments.reportMatcher(new Equals(value));\n+        LastArguments.instance().reportMatcher(new Equals(value));\n         return 0;\n     }\n \n      * @return <code>null</code>.\n      */\n     public static <T> T eq(T value) {\n-        LastArguments.reportMatcher(new Equals(value));\n+        LastArguments.instance().reportMatcher(new Equals(value));\n         return null;\n     }\n \n      * @return <code>null</code>.\n      */\n     public static Object isNull() {\n-        LastArguments.reportMatcher(Null.NULL);\n+        LastArguments.instance().reportMatcher(Null.NULL);\n         return null;\n     }\n \n      * @return <code>null</code>.\n      */\n     public static Object notNull() {\n-        LastArguments.reportMatcher(NotNull.NOT_NULL);\n+        LastArguments.instance().reportMatcher(NotNull.NOT_NULL);\n         return null;\n     }\n \n      * @return <code>null</code>.\n      */\n     public static String matches(String regex) {\n-        LastArguments.reportMatcher(new Matches(regex));\n+        LastArguments.instance().reportMatcher(new Matches(regex));\n         return null;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static double eq(double value, double delta) {\n-        LastArguments.reportMatcher(new EqualsWithDelta(value, delta));\n+        LastArguments.instance().reportMatcher(new EqualsWithDelta(value, delta));\n         return 0;\n     }\n \n      * @return <code>0</code>.\n      */\n     public static float eq(float value, float delta) {\n-        LastArguments.reportMatcher(new EqualsWithDelta(value, delta));\n+        LastArguments.instance().reportMatcher(new EqualsWithDelta(value, delta));\n         return 0;\n     }\n }\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n package org.mockito;\n \n-import org.mockito.exceptions.NotAMockMethodException;\n+import org.mockito.exceptions.MissingMethodInvocationException;\n import org.mockito.hamcrest.*;\n import org.mockito.internal.*;\n \n     public static <T> T mock(Class<T> classToMock) {\n         try {\n             ClassProxyFactory<T> proxyFactory = new ClassProxyFactory<T>();\n+            MockitoControl<T> mockitoControl = new MockitoControl<T>(MockitoState.instance(), LastArguments.instance());\n             return proxyFactory.createProxy(classToMock, new MockitoObjectMethodsFilter<MockitoControl>(\n-                    classToMock, new MockitoControl<T>(), null));\n+                    classToMock, mockitoControl, null));\n         } catch (RuntimeExceptionWrapper e) {\n             throw (RuntimeException) e.getRuntimeException().fillInStackTrace();\n         }\n     }\n \n     public static <T> MockitoExpectation<T> stub(T methodCallToStub) {\n+//        MockitoState.instance().stubbingStarted();\n+        \n         //TODO increment number of stubs\n-        //TODO stub has to be removed from MockitoOperations.controlToBeStubbed!!!!!!!\n-        MockitoExpectation controlToStub = MockitoOperations.controlToBeStubbed();\n+        //TODO stub has to be removed from MockitoState.instance().controlToBeStubbed!!!!!!!\n+        MockitoExpectation controlToStub = MockitoState.instance().controlToBeStubbed();\n         if (controlToStub == null) {\n-            throw new NotAMockMethodException();\n+            throw new MissingMethodInvocationException();\n         }\n         return controlToStub;\n     }\n     \n     public static <T> T verify(T mock) {\n         MockUtil.validateMock(mock);\n-        MockitoOperations.reportVerifyingMode(VerifyingMode.anyTimes());\n+        MockitoState.instance().verifyingStarted(VerifyingMode.anyTimes());\n         return mock;\n     }\n     \n     public static <T> T verify(T mock, int exactNumberOfInvocations) {\n         //TODO validate mock everywhere\n         //TODO validate if there is unfinished stubbing\n-        MockitoOperations.reportVerifyingMode(VerifyingMode.times(exactNumberOfInvocations));\n+        MockitoState.instance().verifyingStarted(VerifyingMode.times(exactNumberOfInvocations));\n         return mock;\n     }\n \n \n     public static void verifyZeroInteractions(Object ... mocks) {\n          verifyNoMoreInteractions(mocks);   \n+    }\n+    \n+    public static <T> VoidMethodExpectation<T> stubVoid(T mock) {\n+        //TODO validate mock\n+//        MockitoState.instance().reportControlForStubbing(mockitoControl)\n+        return MockUtil.getControl(mock);\n     }\n \n     public static <T> T assertInvoked(T mock) {\n     public static <T> MockitoMatcher<T> zeroInteractions(T mock) {\n         return new HasNoIvocationsMatcher<T>(mock);\n     }\n-\n-    public static <T> VoidMethodExpectation<T> stubVoid(T mock) {\n-        //TODO validate mock\n-//        MockitoOperations.reportControlForStubbing(mockitoControl)\n-        return MockUtil.getControl(mock);\n-    }\n }\n--- a/src/org/mockito/exceptions/InvalidUseOfMatchersException.java\n+++ b/src/org/mockito/exceptions/InvalidUseOfMatchersException.java\n package org.mockito.exceptions;\n \n-public class InvalidUseOfMatchersException extends RuntimeException {\n+public class InvalidUseOfMatchersException extends IllegalStateException {\n \n+    public InvalidUseOfMatchersException(String message) {\n+        super(  \"\\n\" +\n+                \"Read about matchers: http://code.google.com/p/mockito/matchers\" +\n+        \t\t\"\\n\" +\n+                message);\n+    }\n }\n--- /dev/null\n+++ b/src/org/mockito/exceptions/MissingMethodInvocationException.java\n+package org.mockito.exceptions;\n+\n+public class MissingMethodInvocationException extends RuntimeException {\n+\n+    public MissingMethodInvocationException() {\n+        super(\"stub() requires an argument which has to be a proper method call on a mock object\");\n+    }\n+}\n--- a/src/org/mockito/internal/InvocationWithMatchers.java\n+++ b/src/org/mockito/internal/InvocationWithMatchers.java\n+/*\n+ * Copyright (c) 2001-2007 OFFIS, Tammo Freese.\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal;\n \n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n import java.util.List;\n \n-import org.mockito.internal.matchers.IArgumentMatcher;\n+import org.mockito.exceptions.InvalidUseOfMatchersException;\n+import org.mockito.internal.matchers.*;\n \n-public class InvocationWithMatchers extends ExpectedInvocation {\n+public class InvocationWithMatchers {\n+\n+    protected final Invocation invocation;\n+\n+    private final List<IArgumentMatcher> matchers;\n \n     public InvocationWithMatchers(Invocation invocation, List<IArgumentMatcher> matchers) {\n-        super(invocation, matchers);\n+        this.invocation = invocation;\n+        this.matchers = matchers;\n+    }\n+\n+    public boolean equals(Object o) {\n+        if (o == null || !this.getClass().equals(o.getClass()))\n+            return false;\n+\n+        InvocationWithMatchers other = (InvocationWithMatchers) o;\n+        return this.invocation.equals(other.invocation)\n+                && ((this.matchers == null && other.matchers == null) || (this.matchers != null && this.matchers\n+                        .equals(other.matchers)));\n+    }\n+\n+    public int hashCode() {\n+        return 1;\n+    }\n+\n+    public boolean matches(Invocation actual) {\n+        return this.invocation.getMock().equals(\n+                actual.getMock())\n+                && this.invocation.getMethod().equals(actual.getMethod())\n+                && matches(actual.getArguments());\n+    }\n+\n+    private boolean matches(Object[] arguments) {\n+        if (arguments.length != matchers.size()) {\n+            return false;\n+        }\n+        for (int i = 0; i < arguments.length; i++) {\n+            if (!matchers.get(i).matches(arguments[i])) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public String toString() {\n+        StringBuffer result = new StringBuffer();\n+        result.append(invocation.getMockAndMethodName());\n+        result.append(\"(\");\n+        for (Iterator<IArgumentMatcher> it = matchers.iterator(); it.hasNext();) {\n+            it.next().appendTo(result);\n+            if (it.hasNext()) {\n+                result.append(\", \");\n+            }\n+        }\n+        result.append(\")\");\n+        return result.toString();\n+    }\n+\n+    public Method getMethod() {\n+        return invocation.getMethod();\n     }\n     \n     public MockitoInvocation getInvocation() {\n--- a/src/org/mockito/internal/LastArguments.java\n+++ b/src/org/mockito/internal/LastArguments.java\n \n import java.util.*;\n \n+import org.mockito.exceptions.InvalidUseOfMatchersException;\n import org.mockito.internal.matchers.*;\n \n public class LastArguments {\n-    private static final ThreadLocal<Stack<Object[]>> threadToCurrentArguments = new ThreadLocal<Stack<Object[]>>();\n+    \n+    static LastArguments INSTANCE = new LastArguments();\n+    \n+    private final ThreadLocal<Stack<Object[]>> threadToCurrentArguments = new ThreadLocal<Stack<Object[]>>();\n+    private final ThreadLocal<Stack<IArgumentMatcher>> threadToArgumentMatcherStack = new ThreadLocal<Stack<IArgumentMatcher>>();\n \n-    private static final ThreadLocal<Stack<IArgumentMatcher>> threadToArgumentMatcherStack = new ThreadLocal<Stack<IArgumentMatcher>>();\n-\n-    public static synchronized void reportMatcher(IArgumentMatcher matcher) {\n+    public static LastArguments instance() {\n+        return INSTANCE;\n+    }\n+    \n+    public synchronized void reportMatcher(IArgumentMatcher matcher) {\n         Stack<IArgumentMatcher> stack = threadToArgumentMatcherStack.get();\n         if (stack == null) {\n             stack = new Stack<IArgumentMatcher>();\n         stack.push(matcher);\n     }\n \n-    public static synchronized List<IArgumentMatcher> pullMatchers() {\n+    public synchronized List<IArgumentMatcher> pullMatchers() {\n         Stack<IArgumentMatcher> stack = threadToArgumentMatcherStack.get();\n         if (stack == null) {\n             return null;\n         }\n+        \n         threadToArgumentMatcherStack.remove();\n         return new ArrayList<IArgumentMatcher>(stack);\n     }\n \n-    public static synchronized void reportAnd(int count) {\n+    public synchronized void reportAnd(int count) {\n         Stack<IArgumentMatcher> stack = threadToArgumentMatcherStack.get();\n-        assertState(stack != null, \"no matchers found.\");\n+        assertState(stack != null, missingMatchers());\n         stack.push(new And(popLastArgumentMatchers(count)));\n     }\n \n-    public static synchronized void reportNot() {\n+    private String missingMatchers() {\n+        return \"No matchers found.\";\n+    }\n+\n+    public synchronized void reportNot() {\n         Stack<IArgumentMatcher> stack = threadToArgumentMatcherStack.get();\n-        assertState(stack != null, \"no matchers found.\");\n+        assertState(stack != null, missingMatchers());\n         stack.push(new Not(popLastArgumentMatchers(1).get(0)));\n     }\n \n-    private static List<IArgumentMatcher> popLastArgumentMatchers(int count) {\n+    private List<IArgumentMatcher> popLastArgumentMatchers(int count) {\n         Stack<IArgumentMatcher> stack = threadToArgumentMatcherStack.get();\n-        assertState(stack != null, \"no matchers found.\");\n-        assertState(stack.size() >= count, \"\" + count + \" matchers expected, \"\n-                + stack.size() + \" recorded.\");\n+        assertState(stack != null, missingMatchers());\n+        assertState(stack.size() >= count,\n+                \"\" + count + \" matchers expected, \" + stack.size() + \" recorded.\");\n         List<IArgumentMatcher> result = new LinkedList<IArgumentMatcher>();\n         result.addAll(stack.subList(stack.size() - count, stack.size()));\n         for (int i = 0; i < count; i++) {\n         return result;\n     }\n \n-    private static void assertState(boolean toAssert, String message) {\n+    private void assertState(boolean toAssert, String message) {\n         if (!toAssert) {\n             threadToArgumentMatcherStack.remove();\n-            throw new IllegalStateException(message);\n+            throw new InvalidUseOfMatchersException(message);\n         }\n     }\n \n-    public static void reportOr(int count) {\n+    public void reportOr(int count) {\n         Stack<IArgumentMatcher> stack = threadToArgumentMatcherStack.get();\n-        assertState(stack != null, \"no matchers found.\");\n+        assertState(stack != null, missingMatchers());\n         stack.push(new Or(popLastArgumentMatchers(count)));\n     }\n \n-    public static Object[] getCurrentArguments() {\n-        Stack<Object[]> stack = threadToCurrentArguments.get();\n-        if (stack == null || stack.empty()) {\n-            return null;\n-        }\n-        return stack.lastElement();\n-    }\n-\n-    public static void pushCurrentArguments(Object[] args) {\n+    public void pushCurrentArguments(Object[] args) {\n         Stack<Object[]> stack = threadToCurrentArguments.get();\n         if (stack == null) {\n             stack = new Stack<Object[]>();\n         stack.push(args);\n     }\n \n-    public static void popCurrentArguments() {\n+    public void popCurrentArguments() {\n         Stack<Object[]> stack = threadToCurrentArguments.get();\n         stack.pop();\n     }\n--- a/src/org/mockito/internal/MethodSelector.java\n+++ b/src/org/mockito/internal/MethodSelector.java\n     \n     T on();\n     \n-}\n+}\n--- a/src/org/mockito/internal/MockitoBehavior.java\n+++ b/src/org/mockito/internal/MockitoBehavior.java\n     private Map<InvocationWithMatchers, Result> results = new HashMap<InvocationWithMatchers, Result>();\n     \n     public void addInvocation(InvocationWithMatchers invocation) {\n+        validateState();\n         this.registeredInvocations.add(invocation);\n+    }\n+\n+    private void validateState() {\n+        \n     }\n \n     public void addResult(Result result) {\n--- a/src/org/mockito/internal/MockitoControl.java\n+++ b/src/org/mockito/internal/MockitoControl.java\n package org.mockito.internal;\n \n import java.lang.reflect.*;\n-import java.util.List;\n+import java.util.*;\n \n-import org.mockito.internal.matchers.IArgumentMatcher;\n+import org.mockito.exceptions.InvalidUseOfMatchersException;\n+import org.mockito.internal.matchers.*;\n \n public class MockitoControl<T> implements MockAwareInvocationHandler, InvocationHandler, MockitoExpectation<T>, VoidMethodExpectation<T>, MethodSelector<T> {\n \n     private MockitoBehavior behavior = new MockitoBehavior();\n     private Object mock;\n+    private final MockitoState mockitoState;\n+    private final LastArguments lastArguments;\n     \n-    public MockitoControl() {}\n+    public MockitoControl(MockitoState mockitoState, LastArguments lastArguments) {\n+        this.mockitoState = mockitoState;\n+        this.lastArguments = lastArguments;\n+    }\n+    \n+    /**\n+     * if user passed bare arguments, not matchers then create EqualsMatchers for every argument\n+     */\n+    private List<IArgumentMatcher> createEqualsMatchers(Invocation invocation,\n+            List<IArgumentMatcher> matchers) {\n+        if (matchers != null) {\n+            return matchers;\n+        }\n+        List<IArgumentMatcher> result = new ArrayList<IArgumentMatcher>();\n+        for (Object argument : invocation.getArguments()) {\n+            result.add(new Equals(argument));\n+        }\n+        return result;\n+    }\n+\n+    private void validateMatchers(Invocation invocation, List<IArgumentMatcher> matchers) {\n+        if (matchers != null && matchers.size() != invocation.getArguments().length) {\n+            throw new InvalidUseOfMatchersException(\n+                    + invocation.getArguments().length\n+                    + \" matchers expected, \" + matchers.size()\n+                    + \" recorded.\");\n+        }\n+    }\n \n     public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n-        List<IArgumentMatcher> lastMatchers = LastArguments.pullMatchers();\n+        MockitoInvocation invocation = new MockitoInvocation(proxy, method, args);\n+        List<IArgumentMatcher> lastMatchers = lastArguments.pullMatchers();\n+        List<IArgumentMatcher> processedMatchers = createEqualsMatchers(invocation, lastMatchers);\n+        InvocationWithMatchers invocationWithMatchers = new InvocationWithMatchers(invocation, processedMatchers);\n+        \n+        if (mockitoState.mockVerificationScenario()) {\n+            VerifyingMode verifyingMode = mockitoState.verifyingCompleted();\n \n-        MockitoInvocation invocation = new MockitoInvocation(proxy, method, args);\n-        InvocationWithMatchers invocationWithMatchers = new InvocationWithMatchers(invocation, lastMatchers);\n-        \n-        if (MockitoOperations.mockVerificationScenario()) {\n-            VerifyingMode verifyingMode = MockitoOperations.removeVerifyingMode();\n+            //have to validate matcher after verifyingMode flag is cleared - a bit smelly\n+            validateMatchers(invocation, lastMatchers);\n             \n             behavior.verify(invocationWithMatchers, verifyingMode);\n             return ToTypeMappings.emptyReturnValueFor(method.getReturnType());\n+        } else {\n+            validateMatchers(invocation, lastMatchers);\n         }\n         \n-        MockitoOperations.reportLastControlForStubbing(this);\n+//        else if (mockitoState.mockStubbingScenario()) {\n+//            mockitoState.stubbingCompleted();\n+//        }\n+        \n+        mockitoState.reportLastControlForStubbing(this);\n         \n         behavior.addInvocation(invocationWithMatchers);\n         \n-        if (MockitoOperations.settingThrowableOnVoidMethodScenario()) {\n-            Throwable throwable = MockitoOperations.removeThrowableToBeSetOnVoidMethod();\n+        if (mockitoState.settingThrowableOnVoidMethodScenario()) {\n+            Throwable throwable = mockitoState.removeThrowableToBeSetOnVoidMethod();\n         \n             andThrows(throwable);\n             return null;\n \n     public MethodSelector<T> toThrow(Throwable throwable) {\n         //TODO refactor so we don't use static state to keep the throwable\n-        MockitoOperations.reportThrowableToBeSetOnVoidMethod(throwable);\n+        mockitoState.reportThrowableToBeSetOnVoidMethod(throwable);\n         return this;\n     }\n \n--- /dev/null\n+++ b/src/org/mockito/internal/MockitoState.java\n+package org.mockito.internal;\n+\n+/**\n+ * state. therefore dangerous and may have nasty bugs.\n+ * TODO look at every method that changes state and make sure the state is cleared afterwards\n+ * \n+ * @author sfaber\n+ */\n+public class MockitoState {\n+    \n+    static MockitoState INSTANCE = new MockitoState();\n+    \n+    private final ThreadLocal<MockitoControl> controlForStubbing = new ThreadLocal<MockitoControl>();\n+    private final ThreadLocal<VerifyingMode> verifyingModeLocal = new ThreadLocal<VerifyingMode>();\n+    private final ThreadLocal<Throwable> throwableToBeSetOnVoidMethod = new ThreadLocal<Throwable>();\n+    private final ThreadLocal<Object> stubbingModeLocal = new ThreadLocal<Object>();\n+\n+    MockitoState() {}\n+    \n+    public static MockitoState instance() {\n+        return INSTANCE;\n+    }\n+    \n+    public synchronized void reportLastControlForStubbing(MockitoControl mockitoControl) {\n+        controlForStubbing.set(mockitoControl);\n+    }\n+\n+    public synchronized MockitoExpectation controlToBeStubbed() {\n+        return controlForStubbing.get();\n+    }\n+    \n+    public synchronized void verifyingStarted(VerifyingMode verify) {\n+        verifyingModeLocal.set(verify);\n+    }\n+\n+    public synchronized boolean mockVerificationScenario() {\n+        return verifyingModeLocal.get() != null; \n+    }\n+\n+    public synchronized VerifyingMode verifyingCompleted() {\n+        VerifyingMode verifyingMode = verifyingModeLocal.get();\n+        verifyingModeLocal.set(null);\n+        return verifyingMode;\n+    }\n+\n+    public void reportThrowableToBeSetOnVoidMethod(Throwable throwable) {\n+        throwableToBeSetOnVoidMethod.set(throwable);\n+    }\n+\n+    public Throwable removeThrowableToBeSetOnVoidMethod() {\n+        Throwable throwable = throwableToBeSetOnVoidMethod.get();\n+        throwableToBeSetOnVoidMethod.set(null);\n+        return throwable;\n+    }\n+\n+    public boolean settingThrowableOnVoidMethodScenario() {\n+        return throwableToBeSetOnVoidMethod.get() != null; \n+    }\n+\n+//    public void stubbingStarted() {\n+//        stubbingModeLocal.set(new Object());\n+//    }\n+\n+//    public boolean mockStubbingScenario() {\n+//        return stubbingModeLocal.get() != null;\n+//    }\n+\n+//    public void stubbingCompleted() {\n+//        stubbingModeLocal.set(null);\n+//    }\n+}\n--- a/test/org/mockito/internal/ExpectedInvocationTest.java\n+++ b/test/org/mockito/internal/ExpectedInvocationTest.java\n         Object[] args = new Object[] { \"\" };\n         Method m = Object.class.getMethod(\"equals\", new Class[] { Object.class });\n         Invocation invocation = new Invocation(null, m, args);\n-        assertThat(new ExpectedInvocation(invocation, null).hashCode(), equalTo(1));\n+        assertThat(new InvocationWithMatchers(invocation, null).hashCode(), equalTo(1));\n     }\n     \n     @Test\n         Method dummyMethod = Object.class.getMethod(\"equals\",\n                 new Class[] { Object.class });\n \n-        ExpectedInvocation invocationWithOneArg = new ExpectedInvocation(\n-                new Invocation(mock, dummyMethod, new Object[] { \"\" }),\n-                null);\n-        ExpectedInvocation invocationWithTwoArgs = new ExpectedInvocation(\n-                new Invocation(mock, dummyMethod, new Object[] { \"\", \"\" }),\n-                null);\n+        InvocationWithMatchers invocationWithOneArg = new InvocationWithMatchers(\n+                new Invocation(mock, dummyMethod, new Object[] { \"\" }), null);\n+        InvocationWithMatchers invocationWithTwoArgs = new InvocationWithMatchers(\n+                new Invocation(mock, dummyMethod, new Object[] { \"\", \"\" }), null);\n \n         assertFalse(invocationWithOneArg.equals(null));\n         assertFalse(invocationWithOneArg.equals(invocationWithTwoArgs));\n--- /dev/null\n+++ b/test/org/mockito/internal/MockitoControlTest.java\n+package org.mockito.internal;\n+\n+import static org.junit.Assert.*;\n+\n+import org.junit.*;\n+import org.mockito.exceptions.InvalidUseOfMatchersException;\n+import org.mockito.internal.matchers.Equals;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class MockitoControlTest {\n+    \n+    @Before\n+    @After\n+    public void resetState() {\n+        StateResetter.reset();\n+    }\n+    \n+    @Test\n+    public void shouldClearVerificationModeEvenWhenInvalidMatchers() throws Throwable {\n+        MockitoState state = MockitoState.instance(); \n+        LastArguments lastArguments = LastArguments.instance();\n+        \n+        lastArguments.reportMatcher(new Equals(\"test\"));\n+        state.verifyingStarted(VerifyingMode.anyTimes());\n+        \n+        MockitoControl control = new MockitoControl(state, lastArguments);\n+\n+        try {\n+            control.invoke(null, String.class.getDeclaredMethod(\"toString\"), new Object[]{});\n+            fail();\n+        } catch (InvalidUseOfMatchersException e) {\n+        }\n+        \n+        assertFalse(state.mockVerificationScenario());\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/MockitoStateTest.java\n+package org.mockito.internal;\n+\n+import static org.junit.Assert.*;\n+\n+import org.junit.*;\n+import org.mockito.internal.*;\n+\n+public class MockitoStateTest {\n+\n+    private MockitoState mockitoState;\n+\n+    @Before\n+    public void setup() {\n+        mockitoState = new MockitoState();\n+    }\n+    \n+    @Test\n+    public void shouldSwitchVerifyingMode() throws Exception {\n+        mockitoState.verifyingStarted(VerifyingMode.anyTimes());\n+        \n+        assertTrue(mockitoState.mockVerificationScenario());\n+        \n+        mockitoState.verifyingStarted(null);\n+        \n+        assertFalse(mockitoState.mockVerificationScenario());\n+        \n+        mockitoState.verifyingStarted(VerifyingMode.times(100));\n+        \n+        assertTrue(mockitoState.mockVerificationScenario());\n+        \n+        assertEquals(100, mockitoState.verifyingCompleted().getExactNumberOfInvocations());\n+        \n+        assertFalse(mockitoState.mockVerificationScenario());\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/StateResetter.java\n+package org.mockito.internal;\n+\n+public class StateResetter {\n+    \n+    public static void reset() {\n+        MockitoState.INSTANCE = new MockitoState();\n+        LastArguments.INSTANCE = new LastArguments();\n+    }\n+}\n--- a/test/org/mockito/usage/MockitoExploitsTest.java\n+++ b/test/org/mockito/usage/MockitoExploitsTest.java\n \n import static org.junit.Assert.*;\n import static org.mockito.Mockito.*;\n-import static org.hamcrest.CoreMatchers.*;\n \n import java.util.List;\n \n import org.junit.*;\n-import org.mockito.*;\n+import org.mockito.Mockito;\n import org.mockito.exceptions.*;\n-import org.mockito.internal.MockitoOperations;\n+import org.mockito.internal.*;\n \n /**\n  * TODO find out what is important to protect ourselves and what's just too defensive \n @SuppressWarnings(\"unchecked\")\n public class MockitoExploitsTest {\n     \n+    @Before\n+    @After\n+    public void resetState() {\n+        StateResetter.reset();\n+    }\n+    \n     @Test\n-    public void rubbishPassedToStubMethod1() {\n-        MockitoOperations.reportLastControlForStubbing(null);\n+    public void rubbishPassedToStubMethod() {\n         try {\n-            stub(\"blah\".contains(\"blah\")).andReturn(Boolean.TRUE);\n+            stub(\"blah\".contains(\"blah\"));\n             fail();\n-        } catch (NotAMockMethodException e) {\n+        } catch (MissingMethodInvocationException e) {\n             //cool\n         }\n     }\n--- /dev/null\n+++ b/test/org/mockito/usage/matchers/BasicStubbingTest.java\n+package org.mockito.usage.matchers;\n+\n+import static org.hamcrest.CoreMatchers.equalTo;\n+import static org.junit.Assert.*;\n+import static org.mockito.util.JUnitMatchers.contains;\n+\n+import java.util.*;\n+\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class BasicStubbingTest {\n+\n+    private interface DummyInterface {\n+        int getInt(String value);\n+        String getString(int argumentOne, String argumentTwo);\n+        List<String> getList();\n+    }\n+    \n+    @Test\n+    public void shouldStubAllMethodsByDefault() throws Exception {\n+        DummyInterface mock = Mockito.mock(DummyInterface.class);\n+\n+        assertEquals(0, mock.getInt(\"test\"));\n+        assertEquals(0, mock.getInt(\"testTwo\"));\n+        \n+        assertNull(mock.getString(0, null));\n+        assertNull(mock.getString(100, null));\n+        \n+        assertEquals(0, mock.getList().size());\n+        assertEquals(0, mock.getList().size());\n+    }\n+    \n+    @Test\n+    public void shouldStubAndLetBeCalledAnyTimes() throws Exception {\n+        DummyInterface mock = Mockito.mock(DummyInterface.class);\n+        \n+        Mockito.stub(mock.getInt(\"14\")).andReturn(14);\n+        \n+        assertThat(mock.getInt(\"14\"), equalTo(14));\n+        assertThat(mock.getInt(\"14\"), equalTo(14));\n+        \n+        Mockito.stub(mock.getList()).andReturn(Arrays.asList(\"elementOne\", \"elementTwo\"));\n+        \n+        assertThat(mock.getList(), contains(\"elementOne\", \"elementTwo\"));\n+        assertThat(mock.getList(), contains(\"elementOne\", \"elementTwo\"));\n+        \n+        Mockito.stub(mock.getString(10, \"test\")).andReturn(\"test\");\n+        \n+        assertThat(mock.getString(10, \"test\"), equalTo(\"test\"));\n+        assertThat(mock.getString(10, \"test\"), equalTo(\"test\"));\n+    }\n+}\n--- a/test/org/mockito/usage/matchers/InvalidUseOfMatchersTest.java\n+++ b/test/org/mockito/usage/matchers/InvalidUseOfMatchersTest.java\n  */\n package org.mockito.usage.matchers;\n \n-import static org.mockito.Mockito.*;\n import static org.junit.Assert.*;\n+import static org.mockito.Matchers.eq;\n \n import org.junit.*;\n import org.mockito.*;\n import org.mockito.exceptions.InvalidUseOfMatchersException;\n+import org.mockito.internal.MockitoState;\n import org.mockito.usage.IMethods;\n \n @SuppressWarnings(\"unchecked\")\n         mock = Mockito.mock(IMethods.class);\n     }\n \n-    @Ignore\n     @Test\n     public void shouldDetectWrongNumberOfMatchersWhenStubbing() {\n         Mockito.stub(mock.threeArgumentMethod(1, \"2\", \"3\")).andReturn(null);\n         try {\n             Mockito.stub(mock.threeArgumentMethod(1, eq(\"2\"), \"3\")).andReturn(null);\n             fail();\n-        } catch (InvalidUseOfMatchersException e) {\n-        }\n+        } catch (InvalidUseOfMatchersException e) {}\n     }\n     \n-    @Ignore\n     @Test\n     public void shouldDetectStupidUseOfMatchersWhenVerifying() {\n         mock.oneArg(true);\n         try {\n             Mockito.verify(mock).oneArg(true);\n             fail();\n-        } catch (InvalidUseOfMatchersException e) {\n-        }\n+        } catch (InvalidUseOfMatchersException e) {}\n     }\n     \n     @Test\n         try {\n             mock.simpleMethodWithArgument(CrazyMatchers.not(\"jkl\"));\n             fail();\n-        } catch (IllegalStateException e) {\n-            assertEquals(\"no matchers found.\", e.getMessage());\n+        } catch (InvalidUseOfMatchersException e) {\n+            assertEquals(\"\\n\" +\n+                    \"Read about matchers: http://code.google.com/p/mockito/matchers\" +\n+                    \"\\n\" +\n+            \t\t\"No matchers found.\", e.getMessage());\n         }\n         \n         try {\n             mock.simpleMethodWithArgument(CrazyMatchers.or(eq(\"jkl\"), \"asd\"));\n             fail();\n         } catch (IllegalStateException e) {\n-            assertEquals(\"2 matchers expected, 1 recorded.\", e.getMessage());\n+            assertEquals(\"\\n\" +\n+            \t\t\"Read about matchers: http://code.google.com/p/mockito/matchers\" +\n+            \t\t\"\\n\" +\n+            \t\t\"2 matchers expected, 1 recorded.\", e.getMessage());\n         }\n         \n         try {\n             mock.threeArgumentMethod(1, \"asd\", eq(\"asd\"));\n             fail();\n         } catch (IllegalStateException e) {\n-            assertEquals(\"3 matchers expected, 1 recorded.\", e.getMessage());\n+            assertEquals(\"\\n\" +\n+                    \"Read about matchers: http://code.google.com/p/mockito/matchers\" +\n+                    \"\\n\" +\n+                    \"3 matchers expected, 1 recorded.\", e.getMessage());\n         }\n     }\n }\n--- a/test/org/mockito/usage/stubbing/BasicStubbingTest.java\n+++ b/test/org/mockito/usage/stubbing/BasicStubbingTest.java\n \n import java.util.*;\n \n-import org.junit.Test;\n+import org.junit.*;\n import org.mockito.Mockito;\n \n @SuppressWarnings(\"unchecked\")\n public class BasicStubbingTest {\n \n+    private DummyInterface mock;\n+\n+    @Before\n+    public void setup() {\n+        mock = Mockito.mock(DummyInterface.class);\n+    }\n+    \n     private interface DummyInterface {\n         int getInt(String value);\n         String getString(int argumentOne, String argumentTwo);\n     \n     @Test\n     public void shouldStubAllMethodsByDefault() throws Exception {\n-        DummyInterface mock = Mockito.mock(DummyInterface.class);\n-\n         assertEquals(0, mock.getInt(\"test\"));\n         assertEquals(0, mock.getInt(\"testTwo\"));\n         \n     \n     @Test\n     public void shouldStubAndLetBeCalledAnyTimes() throws Exception {\n-        DummyInterface mock = Mockito.mock(DummyInterface.class);\n-        \n         Mockito.stub(mock.getInt(\"14\")).andReturn(14);\n         \n         assertThat(mock.getInt(\"14\"), equalTo(14));\n         assertThat(mock.getString(10, \"test\"), equalTo(\"test\"));\n         assertThat(mock.getString(10, \"test\"), equalTo(\"test\"));\n     }\n-}\n+    \n+    @Test\n+    public void shouldEvaluateLatestStubbingFirst() throws Exception {\n+        Mockito.stub(mock.getInt(Mockito.anyString())).andReturn(100);\n+        Mockito.stub(mock.getInt(\"200 please\")).andReturn(200);\n+        \n+        assertEquals(200, mock.getInt(\"200 please\"));\n+        assertEquals(100, mock.getInt(\"any\"));\n+        assertEquals(\"default behavior should return 0\", 0, mock.getInt(null));\n+    }\n+}", "timestamp": 1195342105, "metainfo": ""}