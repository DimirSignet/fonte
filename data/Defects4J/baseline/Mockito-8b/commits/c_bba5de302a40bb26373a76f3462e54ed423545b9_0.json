{"sha": "bba5de302a40bb26373a76f3462e54ed423545b9", "log": "refactoring...  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40161", "commit": "\n--- a/src/org/mockito/internal/MockControl.java\n+++ b/src/org/mockito/internal/MockControl.java\n \n public class MockControl<T> implements MockAwareInvocationHandler<T>, MockitoExpectation<T>, VoidMethodExpectation<T>, MethodSelector<T> {\n \n-    private final MockitoBehavior<T> behavior = new MockitoBehavior<T>();\n+    private final VerifyingRecorder<T> verifyingRecorder;\n     private final Stubber stubber;\n     private final MatchersBinder matchersBinder;\n     private final MockitoState mockitoState;\n+    \n+    private T mock;\n     \n     public MockControl(MockitoState mockitoState, MatchersBinder matchersBinder) {\n         this.mockitoState = mockitoState;\n         this.matchersBinder = matchersBinder;\n         stubber = new Stubber(mockitoState);\n+        verifyingRecorder = new VerifyingRecorder<T>();\n     }\n \n     public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n         mockitoState.validateState();\n         \n         Invocation invocation = new Invocation(proxy, method, args, mockitoState.nextSequenceNumber());\n-        InvocationMatcher invocationWithMatchers = matchersBinder.bindMatchers(invocation);\n+        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(invocation);\n         \n         if (verifyingMode != null) {\n-            behavior.verify(invocationWithMatchers, verifyingMode);\n+            verifyingRecorder.verify(invocationMatcher, verifyingMode);\n             return EmptyReturnValues.emptyValueFor(method.getReturnType());\n         } \n         \n-        stubber.setInvocationForPotentialStubbing(invocationWithMatchers);\n-        behavior.addInvocation(invocationWithMatchers);\n+        stubber.setInvocationForPotentialStubbing(invocationMatcher);\n+        verifyingRecorder.recordInvocation(invocationMatcher);\n \n         mockitoState.reportControlForStubbing(this);\n         \n-        return stubber.resultFor(invocationWithMatchers.getInvocation());\n+        return stubber.resultFor(invocationMatcher.getInvocation());\n     }\n \n     public void verifyNoMoreInteractions() {\n-        behavior.verifyNoMoreInteractions();\n+        verifyingRecorder.verifyNoMoreInteractions();\n     }\n     \n     public void verifyZeroInteractions() {\n-        behavior.verifyZeroInteractions();\n+        verifyingRecorder.verifyZeroInteractions();\n     }\n \n     public void andReturn(T value) {\n-        behavior.lastInvocationWasStubbed();\n+        verifyingRecorder.eraseLastInvocation();\n         stubber.addReturnValue(value);\n     }\n \n     public void andThrows(Throwable throwable) {\n-        behavior.lastInvocationWasStubbed();\n+        verifyingRecorder.eraseLastInvocation();\n         stubber.addThrowable(throwable);\n     }\n     \n     }\n \n     public T on() {\n-        return (T) behavior.getMock();\n+        return mock;\n     }\n \n     public void setMock(T mock) {\n-        behavior.setMock(mock);\n+        this.mock = mock;\n     }\n \n     public List<Invocation> getRegisteredInvocations() {\n-        return behavior.getRegisteredInvocations();\n+        return verifyingRecorder.getRegisteredInvocations();\n     }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/VerifyingRecorder.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal;\n+\n+import java.util.*;\n+\n+import org.mockito.exceptions.*;\n+import org.mockito.exceptions.parents.HasStackTrace;\n+\n+public class VerifyingRecorder<T> {\n+\n+    private RegisteredInvocations registeredInvocations = new RegisteredInvocations(new AllInvocationsFinder());\n+\n+    public void recordInvocation(InvocationMatcher invocation) {\n+        this.registeredInvocations.add(invocation.getInvocation());\n+    }\n+    \n+    public List<Invocation> getRegisteredInvocations() {\n+        return registeredInvocations.all();\n+    }\n+\n+    public void eraseLastInvocation() {\n+        registeredInvocations.removeLast();\n+    }\n+\n+    public void verify(InvocationMatcher wanted, VerifyingMode mode) {\n+        checkOrderOfInvocations(wanted, mode);\n+        checkForMissingInvocation(wanted, mode);\n+        checkForWrongNumberOfInvocations(wanted, mode);        \n+        registeredInvocations.markInvocationsAsVerified(wanted, mode);\n+    }\n+    \n+    private void checkForMissingInvocation(InvocationMatcher wanted, VerifyingMode mode) {\n+        int actualCount = registeredInvocations.countActual(wanted);\n+        Integer wantedCount = mode.wantedCount();\n+        boolean atLeastOnce = mode.atLeastOnceMode();\n+               \n+        if ((atLeastOnce || wantedCount == 1) && actualCount == 0) {\n+            reportMissingInvocationError(wanted);\n+        }\n+    }\n+\n+    void checkForWrongNumberOfInvocations(InvocationMatcher wanted, VerifyingMode mode) {\n+        if (mode.orderOfInvocationsMatters() || mode.atLeastOnceMode()) {\n+            return;\n+        }\n+        \n+        int actualCount = registeredInvocations.countActual(wanted);\n+        Integer wantedCount = mode.wantedCount();\n+        \n+        if (actualCount < wantedCount) {\n+            HasStackTrace lastInvocation = registeredInvocations.getLastInvocationStackTrace(wanted);\n+            Exceptions.tooLittleActualInvocations(wantedCount, actualCount, wanted.toString(), lastInvocation);\n+        } else if (actualCount > wantedCount) {\n+            HasStackTrace firstUndesired = registeredInvocations.getFirstUndesiredInvocationStackTrace(wanted, mode);\n+            Exceptions.tooManyActualInvocations(wantedCount, actualCount, wanted.toString(), firstUndesired);\n+        }\n+    }\n+\n+    private void reportMissingInvocationError(InvocationMatcher wanted) {\n+        Invocation actual = registeredInvocations.findActualInvocation(wanted);\n+        \n+        if (actual != null) {\n+            reportDiscrepancy(wanted, actual);\n+        } else {\n+            Exceptions.wantedButNotInvoked(wanted.toString());\n+        }\n+    }\n+\n+    private void reportDiscrepancy(InvocationMatcher wantedInvocation, Invocation actualInvocation) {\n+        String wanted = wantedInvocation.toString();\n+        String actual = actualInvocation.toString();\n+        if (wanted.equals(actual)) {\n+            wanted = wantedInvocation.getInvocation().toStringWithArgumentTypes();\n+            actual = actualInvocation.toStringWithArgumentTypes();\n+        }\n+        \n+        Exceptions.wantedInvocationDiffersFromActual(wanted, actual, actualInvocation.getStackTrace());\n+    }\n+    \n+    private void reportStrictOrderDiscrepancy(InvocationMatcher wantedInvocation, Invocation actualInvocation) {\n+        String wanted = wantedInvocation.toString();\n+        String actual = actualInvocation.toString();\n+        boolean sameMocks = wantedInvocation.getInvocation().getMock().equals(actualInvocation.getMock());\n+        boolean sameMethods = wanted.equals(actual);\n+        if (sameMethods && !sameMocks) {\n+            wanted = wantedInvocation.toStringWithSequenceNumber();\n+            actual = actualInvocation.toStringWithSequenceNumber();\n+        } else if (sameMethods) {\n+            wanted = wantedInvocation.getInvocation().toStringWithArgumentTypes();\n+            actual = actualInvocation.toStringWithArgumentTypes();\n+        }\n+        \n+        Exceptions.strictlyWantedInvocationDiffersFromActual(wanted, actual, actualInvocation.getStackTrace());\n+    }\n+\n+    //TODO Cyclomatic Complexity = 10 :|\n+    private void checkOrderOfInvocations(InvocationMatcher wanted, VerifyingMode mode) {\n+        if (!mode.orderOfInvocationsMatters()) {\n+            return;\n+        }\n+        \n+        List<InvocationChunk> chunks = registeredInvocations.unverifiedInvocationChunks(mode);\n+        \n+        if (mode.wantedCountIsZero() && !chunks.isEmpty() && wanted.matches(chunks.get(0).getInvocation())) {\n+            Exceptions.numberOfInvocationsDiffers(0, chunks.get(0).getCount(), wanted.toString());\n+        } else if (mode.wantedCountIsZero()) {\n+            return;\n+        }\n+        \n+        if (chunks.isEmpty()) {\n+            Exceptions.wantedButNotInvoked(wanted.toString());\n+        }\n+        \n+        if (!wanted.matches(chunks.get(0).getInvocation())) {\n+            reportStrictOrderDiscrepancy(wanted, chunks.get(0).getInvocation());\n+        }\n+        \n+        if (!mode.atLeastOnceMode() && chunks.get(0).getCount() != mode.wantedCount()) {\n+            Exceptions.numberOfInvocationsDiffers(mode.wantedCount(), chunks.get(0).getCount(), wanted.toString());\n+        }\n+    }\n+\n+    public void verifyNoMoreInteractions() {\n+        Invocation unverified = registeredInvocations.getFirstUnverified();\n+        if (unverified != null) {\n+            Exceptions.noMoreInteractionsWanted(unverified.toString(), unverified.getStackTrace());\n+        }\n+    }\n+    \n+    public void verifyZeroInteractions() {\n+        Invocation unverified = registeredInvocations.getFirstUnverified();\n+        if (unverified != null) {\n+            Exceptions.zeroInteractionsWanted(unverified.toString(), unverified.getStackTrace());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/VerifyingRecorderTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.Arrays;\n+\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class VerifyingRecorderTest extends RequiresValidState {\n+\n+    @Test\n+    public void shouldNotCheckForWrongNumberOfModificationsWhenVerifyingInOrder() throws Exception {\n+        InvocationMatcher invocation = new InvocationMatcher(new InvocationBuilder().toInvocation());\n+        VerifyingRecorder behavior = new VerifyingRecorder();\n+        \n+        VerifyingMode inOrder = VerifyingMode.inOrder(1, Arrays.asList(new Object()));\n+        assertTrue(inOrder.orderOfInvocationsMatters());\n+        \n+        behavior.checkForWrongNumberOfInvocations(invocation, inOrder);\n+    }\n+    \n+    @Test\n+    public void shouldNotCheckForWrongNumberOfModificationsWhenVerifyingAtLeastOnce() throws Exception {\n+        InvocationMatcher invocation = new InvocationMatcher(new InvocationBuilder().toInvocation());\n+        VerifyingRecorder behavior = new VerifyingRecorder();\n+        \n+        VerifyingMode inOrder = VerifyingMode.atLeastOnce();\n+        \n+        behavior.checkForWrongNumberOfInvocations(invocation, inOrder);\n+    }\n+}\n--- a/test/org/mockitousage/MultiThreadedTest.java\n+++ b/test/org/mockitousage/MultiThreadedTest.java\n                     InvocationMatcherTest.class, \n                     InvocationChunkTest.class, \n                     MockFactoryTest.class, \n-                    MockitoBehaviorTest.class, \n+                    VerifyingRecorderTest.class, \n                     MockitoStateImplTest.class, \n                     RegisteredInvocationsTest.class, \n                     EmptyReturnValuesTest.class, ", "timestamp": 1197333856, "metainfo": ""}