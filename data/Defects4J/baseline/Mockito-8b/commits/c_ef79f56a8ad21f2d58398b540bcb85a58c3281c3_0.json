{"sha": "ef79f56a8ad21f2d58398b540bcb85a58c3281c3", "log": "Merge pull request #59 from marcingrzejszczak/fixVarArgs  Added casts to supress varargs warnings", "commit": "\n--- a/test/org/mockito/internal/creation/MockSettingsImplTest.java\n+++ b/test/org/mockito/internal/creation/MockSettingsImplTest.java\n     \t//then\n     \tAssertions.assertThat(mockSettingsImpl.getInvocationListeners()).hasSize(1);\n     }\n-    \n+\n+    @SuppressWarnings(\"all\")\n     @Test(expected=MockitoException.class)\n     public void shouldNotAllowNullListener() {\n-    \tmockSettingsImpl.invocationListeners(null);\n+    \tmockSettingsImpl.invocationListeners((InvocationListener[])null);\n     }\n \n     @Test\n--- a/test/org/mockitousage/basicapi/UsingVarargsTest.java\n+++ b/test/org/mockitousage/basicapi/UsingVarargsTest.java\n     //See bug #31\n     public void shouldStubCorrectlyWhenMixedVarargsUsed() {\n         MixedVarargs mixedVarargs = mock(MixedVarargs.class);\n-        when(mixedVarargs.doSomething(\"hello\", null)).thenReturn(\"hello\");\n-        when(mixedVarargs.doSomething(\"goodbye\", null)).thenReturn(\"goodbye\");\n+        when(mixedVarargs.doSomething(\"hello\", (String[])null)).thenReturn(\"hello\");\n+        when(mixedVarargs.doSomething(\"goodbye\", (String[])null)).thenReturn(\"goodbye\");\n \n-        String result = mixedVarargs.doSomething(\"hello\", null);\n+        String result = mixedVarargs.doSomething(\"hello\",(String[]) null);\n         assertEquals(\"hello\", result);\n         \n-        verify(mixedVarargs).doSomething(\"hello\", null);\n+        verify(mixedVarargs).doSomething(\"hello\", (String[])null);\n     }\n     \n     @SuppressWarnings(\"all\")\n     @Test\n     public void shouldStubCorrectlyWhenDoubleStringAndMixedVarargsUsed() {\n         MixedVarargs mixedVarargs = mock(MixedVarargs.class);\n-        when(mixedVarargs.doSomething(\"one\", \"two\", null)).thenReturn(\"hello\");\n-        when(mixedVarargs.doSomething(\"1\", \"2\", null)).thenReturn(\"goodbye\");\n+        when(mixedVarargs.doSomething(\"one\", \"two\", (String[])null)).thenReturn(\"hello\");\n+        when(mixedVarargs.doSomething(\"1\", \"2\", (String[])null)).thenReturn(\"goodbye\");\n \n-        String result = mixedVarargs.doSomething(\"one\", \"two\", null);\n+        String result = mixedVarargs.doSomething(\"one\", \"two\", (String[])null);\n         assertEquals(\"hello\", result);\n     }\n     \n--- a/test/org/mockitousage/misuse/DescriptiveMessagesOnMisuseTest.java\n+++ b/test/org/mockitousage/misuse/DescriptiveMessagesOnMisuseTest.java\n     @SuppressWarnings(\"all\")\n     @Test(expected=MockitoException.class)\n     public void shouldScreamWhenNullPassedToVerifyNoMoreInteractions() {\n-        verifyNoMoreInteractions(null);\n+        verifyNoMoreInteractions((Object[])null);\n     }\n }\n--- a/test/org/mockitousage/stubbing/StubbingConsecutiveAnswersTest.java\n+++ b/test/org/mockitousage/stubbing/StubbingConsecutiveAnswersTest.java\n     @SuppressWarnings(\"all\")\n     @Test\n     public void shouldReturnConsecutiveValuesForTwoNulls() throws Exception {\n-        when(mock.simpleMethod()).thenReturn(null, null);\n+        when(mock.simpleMethod()).thenReturn(null, (String[])null);\n         \n         assertNull(mock.simpleMethod());        \n         assertNull(mock.simpleMethod());        \n--- a/test/org/mockitousage/verification/BasicVerificationInOrderTest.java\n+++ b/test/org/mockitousage/verification/BasicVerificationInOrderTest.java\n     @SuppressWarnings(\"all\")\n     @Test(expected = MockitoException.class)\n     public void shouldScreamWhenNullPassed() {\n-        inOrder(null);\n+        inOrder((Object[])null);\n     }\n }\n--- a/test/org/mockitousage/verification/NoMoreInteractionsVerificationTest.java\n+++ b/test/org/mockitousage/verification/NoMoreInteractionsVerificationTest.java\n     @SuppressWarnings(\"all\")\n     @Test(expected=MockitoException.class)\n     public void verifyNoMoreInteractionsShouldScreamWhenNullPassed() throws Exception {\n-        verifyNoMoreInteractions(null);\n+        verifyNoMoreInteractions((Object[])null);\n     }\n }\n--- a/src/org/mockito/AdditionalAnswers.java\n+++ b/src/org/mockito/AdditionalAnswers.java\n      * doAnswer(returnsArgAt(3)).when(person).remember(dream1, dream2, dream3, dream4)</code></pre>\n      *\n      * @param <T> Return type of the invocation.\n-     * @return Answer that will return the second argument of the invocation.\n+     * @param position index of the argument from the list of arguments.\n+     * @return Answer that will return the argument from the given position in the argument's list\n      *\n      * @since 1.9.5\n      */\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n  * <p align=\"left\"><img src=\"logo.jpg\"/></p>\n  * Mockito library enables mocks creation, verification and stubbing.\n  * <p>\n- * This javadoc content is also available on the <a href=\"http://mockito.org\">http://mockito.org</a> web page. \n+ * This javadoc content is also available on the <a href=\"http://mockito.org\">http://mockito.org</a> web page.\n  * All documentation is kept in javadocs because it guarantees consistency between what's on the web and what's in the source code.\n- * Also, it makes possible to access documentation straight from the IDE even if you work offline.   \n- * \n+ * Also, it makes possible to access documentation straight from the IDE even if you work offline.\n+ *\n  * <h1>Contents</h1>\n- * \n- * <b> \n- *      <a href=\"#1\">1. Let's verify some behaviour! </a><br/> \n+ *\n+ * <b>\n+ *      <a href=\"#1\">1. Let's verify some behaviour! </a><br/>\n  *      <a href=\"#2\">2. How about some stubbing? </a><br/>\n  *      <a href=\"#3\">3. Argument matchers </a><br/>\n- *      <a href=\"#4\">4. Verifying exact number of invocations / at least once / never </a><br/> \n- *      <a href=\"#5\">5. Stubbing void methods with exceptions </a><br/> \n- *      <a href=\"#6\">6. Verification in order </a><br/> \n- *      <a href=\"#7\">7. Making sure interaction(s) never happened on mock </a><br/> \n- *      <a href=\"#8\">8. Finding redundant invocations </a><br/> \n+ *      <a href=\"#4\">4. Verifying exact number of invocations / at least once / never </a><br/>\n+ *      <a href=\"#5\">5. Stubbing void methods with exceptions </a><br/>\n+ *      <a href=\"#6\">6. Verification in order </a><br/>\n+ *      <a href=\"#7\">7. Making sure interaction(s) never happened on mock </a><br/>\n+ *      <a href=\"#8\">8. Finding redundant invocations </a><br/>\n  *      <a href=\"#9\">9. Shorthand for mocks creation - <code>&#064;Mock</code> annotation </a><br/>\n- *      <a href=\"#10\">10. Stubbing consecutive calls (iterator-style stubbing) </a><br/> \n+ *      <a href=\"#10\">10. Stubbing consecutive calls (iterator-style stubbing) </a><br/>\n  *      <a href=\"#11\">11. Stubbing with callbacks </a><br/>\n  *      <a href=\"#12\">12. <code>doReturn()</code>|<code>doThrow()</code>|<code>doAnswer()</code>|<code>doNothing()</code>|<code>doCallRealMethod()</code> family of methods</a><br/>\n  *      <a href=\"#13\">13. Spying on real objects </a><br/>\n  *      <a href=\"#28\">28. (**New**) <code>MockMaker</code> API (Since 1.9.5)</a><br/>\n  *      <a href=\"#29\">29. (**New**) BDD style verification (Since 1.9.8)</a><br/>\n  * </b>\n- * \n+ *\n  * <p>\n  * Following examples mock a List, because everyone knows its interface (methods\n  * like <code>add()</code>, <code>get()</code>, <code>clear()</code> will be used). <br>\n  *\n  *\n  * <h3 id=\"1\">1. <a class=\"meaningful_link\" href=\"#verification\">Let's verify some behaviour!</a></h3>\n- * \n+ *\n  * <pre class=\"code\"><code class=\"java\">\n  * //Let's import Mockito statically so that the code looks clearer\n  * import static org.mockito.Mockito.*;\n- * \n+ *\n  * //mock creation\n  * List mockedList = mock(List.class);\n  *\n  * verify(mockedList).add(\"one\");\n  * verify(mockedList).clear();\n  * </code></pre>\n- * \n+ *\n  * <p>\n  * Once created, mock will remember all interactions. Then you can selectively\n  * verify whatever interaction you are interested in.\n  *\n  *\n  * <h3 id=\"2\">2. <a class=\"meaningful_link\" href=\"#stubbing\">How about some stubbing?</a></h3>\n- * \n+ *\n  * <pre class=\"code\"><code class=\"java\">\n  * //You can mock concrete classes, not only interfaces\n  * LinkedList mockedList = mock(LinkedList.class);\n- * \n+ *\n  * //stubbing\n  * when(mockedList.get(0)).thenReturn(\"first\");\n  * when(mockedList.get(1)).thenThrow(new RuntimeException());\n- * \n+ *\n  * //following prints \"first\"\n  * System.out.println(mockedList.get(0));\n- * \n+ *\n  * //following throws runtime exception\n  * System.out.println(mockedList.get(1));\n- * \n+ *\n  * //following prints \"null\" because get(999) was not stubbed\n  * System.out.println(mockedList.get(999));\n- *  \n+ *\n  * //Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>\n  * //If your code cares what get(0) returns then something else breaks (often before even verify() gets executed).\n  * //If your code doesn't care what get(0) returns then it should not be stubbed. Not convinced? See <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.\n  * verify(mockedList).get(0);\n  * </code></pre>\n- * \n+ *\n  * <ul>\n  * <li> By default, for all methods that return value, mock returns null, an\n  * empty collection or appropriate primitive/primitive wrapper value (e.g: 0,\n  * false, ... for int/Integer, boolean/Boolean, ...). </li>\n- * \n+ *\n  * <li> Stubbing can be overridden: for example common stubbing can go to\n  * fixture setup but the test methods can override it.\n  * Please note that overridding stubbing is a potential code smell that points out too much stubbing</li>\n- * \n+ *\n  * <li> Once stubbed, the method will always return stubbed value regardless\n  * of how many times it is called. </li>\n- * \n+ *\n  * <li> Last stubbing is more important - when you stubbed the same method with\n  * the same arguments many times.\n  * Other words: <b>the order of stubbing matters</b> but it is only meaningful rarely,\n  * e.g. when stubbing exactly the same method calls or sometimes when argument matchers are used, etc.</li>\n- * \n+ *\n  * </ul>\n  *\n  *\n  * <h3 id=\"3\">3. <a class=\"meaningful_link\" href=\"#argument_matchers\">Argument matchers</a></h3>\n  *\n  * Mockito verifies argument values in natural java style: by using an <code>equals()</code> method.\n- * Sometimes, when extra flexibility is required then you might use argument matchers:  \n- * \n+ * Sometimes, when extra flexibility is required then you might use argument matchers:\n+ *\n  * <pre class=\"code\"><code class=\"java\">\n  * //stubbing using built-in anyInt() argument matcher\n  * when(mockedList.get(anyInt())).thenReturn(\"element\");\n- * \n+ *\n  * //stubbing using hamcrest (let's say isValid() returns your own hamcrest matcher):\n  * when(mockedList.contains(argThat(isValid()))).thenReturn(\"element\");\n- * \n+ *\n  * //following prints \"element\"\n  * System.out.println(mockedList.get(999));\n- * \n+ *\n  * //<b>you can also verify using an argument matcher</b>\n  * verify(mockedList).get(anyInt());\n  * </code></pre>\n- * \n- * <p>\n- * Argument matchers allow flexible verification or stubbing. \n- * {@link Matchers Click here to see} more built-in matchers \n+ *\n+ * <p>\n+ * Argument matchers allow flexible verification or stubbing.\n+ * {@link Matchers Click here to see} more built-in matchers\n  * and examples of <b>custom argument matchers / hamcrest matchers</b>.\n  * <p>\n  * For information solely on <b>custom argument matchers</b> check out javadoc for {@link ArgumentMatcher} class.\n  * Sometimes it's just better to refactor the code to allow <code>equals()</code> matching or even implement <code>equals()</code> method to help out with testing.\n  * <p>\n  * Also, read <a href=\"#15\">section 15</a> or javadoc for {@link ArgumentCaptor} class.\n- * {@link ArgumentCaptor} is a special implementation of an argument matcher that captures argument values for further assertions.  \n+ * {@link ArgumentCaptor} is a special implementation of an argument matcher that captures argument values for further assertions.\n  * <p>\n  * <b>Warning on argument matchers:</b>\n  * <p>\n  * by matchers.\n  * <p>\n  * E.g: (example shows verification but the same applies to stubbing):\n- * \n+ *\n  * <pre class=\"code\"><code class=\"java\">\n  *   verify(mock).someMethod(anyInt(), anyString(), <b>eq(\"third argument\")</b>);\n  *   //above is correct - eq() is also an argument matcher\n- *   \n+ *\n  *   verify(mock).someMethod(anyInt(), anyString(), <b>\"third argument\"</b>);\n  *   //above is incorrect - exception will be thrown because third argument is given without an argument matcher.\n  * </code></pre>\n- * \n+ *\n  * <p>\n  * Matcher methods like <code>anyObject()</code>, <code>eq()</code> <b>do not</b> return matchers.\n  * Internally, they record a matcher on a stack and return a dummy value (usually null).\n  * <a class=\"meaningful_link\" href=\"#at_least_verification\">at least x</a> / never</h3>\n  *\n  * <pre class=\"code\"><code class=\"java\">\n- * //using mock \n+ * //using mock\n  * mockedList.add(\"once\");\n- * \n+ *\n  * mockedList.add(\"twice\");\n  * mockedList.add(\"twice\");\n- * \n+ *\n  * mockedList.add(\"three times\");\n  * mockedList.add(\"three times\");\n  * mockedList.add(\"three times\");\n- * \n+ *\n  * //following two verifications work exactly the same - times(1) is used by default\n  * verify(mockedList).add(\"once\");\n  * verify(mockedList, times(1)).add(\"once\");\n- * \n+ *\n  * //exact number of invocations verification\n  * verify(mockedList, times(2)).add(\"twice\");\n  * verify(mockedList, times(3)).add(\"three times\");\n- * \n+ *\n  * //verification using never(). never() is an alias to times(0)\n  * verify(mockedList, never()).add(\"never happened\");\n- * \n+ *\n  * //verification using atLeast()/atMost()\n  * verify(mockedList, atLeastOnce()).add(\"three times\");\n  * verify(mockedList, atLeast(2)).add(\"five times\");\n  * verify(mockedList, atMost(5)).add(\"three times\");\n- * \n- * </code></pre>\n- * \n+ *\n+ * </code></pre>\n+ *\n  * <p>\n  * <b>times(1) is the default.</b> Therefore using times(1) explicitly can be\n  * omitted.\n  *\n  *\n  * <h3 id=\"5\">5. <a class=\"meaningful_link\" href=\"#stubbing_with_exceptions\">Stubbing void methods with exceptions</a></h3>\n- * \n+ *\n  * <pre class=\"code\"><code class=\"java\">\n  *   doThrow(new RuntimeException()).when(mockedList).clear();\n- *   \n+ *\n  *   //following throws RuntimeException:\n  *   mockedList.clear();\n  * </code></pre>\n- * \n+ *\n  * Read more about doThrow|doAnswer family of methods in paragraph 12.\n  * <p>\n  * Initially, {@link Mockito#stubVoid(Object)} was used for stubbing voids.\n  * Currently <code>stubVoid()</code> is deprecated in favor of {@link Mockito#doThrow(Throwable)}.\n- * This is because of improved readability and consistency with the family of {@link Mockito#doAnswer(Answer)} methods. \n+ * This is because of improved readability and consistency with the family of {@link Mockito#doAnswer(Answer)} methods.\n  *\n  *\n  *\n  *\n  * <h3 id=\"6\">6. <a class=\"meaningful_link\" href=\"#in_order_verification\">Verification in order</a></h3>\n- * \n+ *\n  * <pre class=\"code\"><code class=\"java\">\n  * // A. Single mock whose methods must be invoked in a particular order\n  * List singleMock = mock(List.class);\n  * // B. Multiple mocks that must be used in a particular order\n  * List firstMock = mock(List.class);\n  * List secondMock = mock(List.class);\n- * \n+ *\n  * //using mocks\n  * firstMock.add(\"was called first\");\n  * secondMock.add(\"was called second\");\n- * \n+ *\n  * //create inOrder object passing any mocks that need to be verified in order\n  * InOrder inOrder = inOrder(firstMock, secondMock);\n- * \n+ *\n  * //following will make sure that firstMock was called before secondMock\n  * inOrder.verify(firstMock).add(\"was called first\");\n  * inOrder.verify(secondMock).add(\"was called second\");\n  *\n  * // Oh, and A + B can be mixed together at will\n  * </code></pre>\n- * \n+ *\n  * Verification in order is flexible - <b>you don't have to verify all\n  * interactions</b> one-by-one but only those that you are interested in\n  * testing in order.\n  *\n  *\n  * <h3 id=\"7\">7. <a class=\"meaningful_link\" href=\"#never_verification\">Making sure interaction(s) never happened on mock</a></h3>\n- * \n+ *\n  * <pre class=\"code\"><code class=\"java\">\n  * //using mocks - only mockOne is interacted\n  * mockOne.add(\"one\");\n- * \n+ *\n  * //ordinary verification\n  * verify(mockOne).add(\"one\");\n- * \n+ *\n  * //verify that method was never called on a mock\n  * verify(mockOne, never()).add(\"two\");\n- * \n+ *\n  * //verify that other mocks were not interacted\n  * verifyZeroInteractions(mockTwo, mockThree);\n- * \n+ *\n  * </code></pre>\n  *\n  *\n  * //using mocks\n  * mockedList.add(\"one\");\n  * mockedList.add(\"two\");\n- * \n+ *\n  * verify(mockedList).add(\"one\");\n- * \n- * //following verification will fail \n+ *\n+ * //following verification will fail\n  * verifyNoMoreInteractions(mockedList);\n  * </code></pre>\n- * \n- * A word of <b>warning</b>: \n+ *\n+ * A word of <b>warning</b>:\n  * Some users who did a lot of classic, expect-run-verify mocking tend to use <code>verifyNoMoreInteractions()</code> very often, even in every test method.\n  * <code>verifyNoMoreInteractions()</code> is not recommended to use in every test method.\n  * <code>verifyNoMoreInteractions()</code> is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.\n  * Abusing it leads to <strong>overspecified</strong>, <strong>less maintainable</strong> tests. You can find further reading\n  * <a href=\"http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/\">here</a>.\n- * \n- * <p>   \n+ *\n+ * <p>\n  * See also {@link Mockito#never()} - it is more explicit and\n  * communicates the intent well.\n  * <p>\n  * <li>Makes the verification error easier to read because the <b>field name</b>\n  * is used to identify the mock.</li>\n  * </ul>\n- * \n- * <pre class=\"code\"><code class=\"java\">\n- *   public class ArticleManagerTest { \n- *     \n+ *\n+ * <pre class=\"code\"><code class=\"java\">\n+ *   public class ArticleManagerTest {\n+ *\n  *       &#064;Mock private ArticleCalculator calculator;\n  *       &#064;Mock private ArticleDatabase database;\n  *       &#064;Mock private UserProvider userProvider;\n- *     \n+ *\n  *       private ArticleManager manager;\n  * </code></pre>\n- * \n+ *\n  * <b>Important!</b> This needs to be somewhere in the base class or a test\n  * runner:\n- * \n+ *\n  * <pre class=\"code\"><code class=\"java\">\n  * MockitoAnnotations.initMocks(testClass);\n  * </code></pre>\n- * \n+ *\n  * You can use built-in runner: {@link MockitoJUnitRunner}.\n  * <p>\n  * Read more here: {@link MockitoAnnotations}\n  *\n  *\n  * <h3 id=\"10\">10. <a class=\"meaningful_link\" href=\"#stubbing_consecutive_calls\">Stubbing consecutive calls</a> (iterator-style stubbing)</h3>\n- * \n+ *\n  * Sometimes we need to stub with different return value/exception for the same\n- * method call. Typical use case could be mocking iterators. \n- * Original version of Mockito did not have this feature to promote simple mocking. \n+ * method call. Typical use case could be mocking iterators.\n+ * Original version of Mockito did not have this feature to promote simple mocking.\n  * For example, instead of iterators one could use {@link Iterable} or simply\n  * collections. Those offer natural ways of stubbing (e.g. using real\n  * collections). In rare scenarios stubbing consecutive calls could be useful,\n  * though:\n  * <p>\n- * \n+ *\n  * <pre class=\"code\"><code class=\"java\">\n  * when(mock.someMethod(\"some arg\"))\n  *   .thenThrow(new RuntimeException())\n  *   .thenReturn(\"foo\");\n- * \n+ *\n  * //First call: throws runtime exception:\n  * mock.someMethod(\"some arg\");\n- * \n+ *\n  * //Second call: prints \"foo\"\n  * System.out.println(mock.someMethod(\"some arg\"));\n- * \n- * //Any consecutive call: prints \"foo\" as well (last stubbing wins). \n+ *\n+ * //Any consecutive call: prints \"foo\" as well (last stubbing wins).\n  * System.out.println(mock.someMethod(\"some arg\"));\n  * </code></pre>\n- * \n+ *\n  * Alternative, shorter version of consecutive stubbing:\n- * \n+ *\n  * <pre class=\"code\"><code class=\"java\">\n  * when(mock.someMethod(\"some arg\"))\n  *   .thenReturn(\"one\", \"two\", \"three\");\n  * originally. We recommend using simple stubbing with <code>thenReturn()</code> or\n  * <code>thenThrow()</code> only. Those two should be <b>just enough</b> to test/test-drive\n  * any clean & simple code.\n- * \n+ *\n  * <pre class=\"code\"><code class=\"java\">\n  * when(mock.someMethod(anyString())).thenAnswer(new Answer() {\n  *     Object answer(InvocationOnMock invocation) {\n  *         return \"called with arguments: \" + args;\n  *     }\n  * });\n- * \n+ *\n  * //Following prints \"called with arguments: foo\"\n  * System.out.println(mock.someMethod(\"foo\"));\n  * </code></pre>\n  * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not\n  * like void methods inside brackets...\n  * <p>\n- * {@link Mockito#doThrow(Throwable)} replaces the {@link Mockito#stubVoid(Object)} method for stubbing voids. \n+ * {@link Mockito#doThrow(Throwable)} replaces the {@link Mockito#stubVoid(Object)} method for stubbing voids.\n  * The main reason is improved readability and consistency with the family of <code>doAnswer()</code> methods.\n  * <p>\n  * Use <code>doThrow()</code> when you want to stub a void method with an exception:\n  * <pre class=\"code\"><code class=\"java\">\n  *   doThrow(new RuntimeException()).when(mockedList).clear();\n- *   \n+ *\n  *   //following throws RuntimeException:\n  *   mockedList.clear();\n  * </code></pre>\n  *\n  *\n  * <h3 id=\"13\">13. <a class=\"meaningful_link\" href=\"#spy\">Spying on real objects</a></h3>\n- * \n+ *\n  * You can create spies of real objects. When you use the spy then the <b>real</b> methods are called\n  * (unless a method was stubbed).\n  * <p>\n  * Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.\n- * \n- * <p>\n- * Spying on real objects can be associated with \"partial mocking\" concept. \n- * <b>Before the release 1.8</b>, Mockito spies were not real partial mocks. \n- * The reason was we thought partial mock is a code smell. \n- * At some point we found legitimate use cases for partial mocks \n+ *\n+ * <p>\n+ * Spying on real objects can be associated with \"partial mocking\" concept.\n+ * <b>Before the release 1.8</b>, Mockito spies were not real partial mocks.\n+ * The reason was we thought partial mock is a code smell.\n+ * At some point we found legitimate use cases for partial mocks\n  * (3rd party interfaces, interim refactoring of legacy code, the full article is <a href=\n  * \"http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring\"\n  * >here</a>)\n  * <pre class=\"code\"><code class=\"java\">\n  *   List list = new LinkedList();\n  *   List spy = spy(list);\n- * \n+ *\n  *   //optionally, you can stub out some methods:\n  *   when(spy.size()).thenReturn(100);\n- * \n+ *\n  *   //using the spy calls <b>*real*</b> methods\n  *   spy.add(\"one\");\n  *   spy.add(\"two\");\n- * \n+ *\n  *   //prints \"one\" - the first element of a list\n  *   System.out.println(spy.get(0));\n- * \n+ *\n  *   //size() method was stubbed - 100 is printed\n  *   System.out.println(spy.size());\n- * \n+ *\n  *   //optionally, you can verify\n  *   verify(spy).add(\"one\");\n  *   verify(spy).add(\"two\");\n  * </code></pre>\n- * \n+ *\n  * <h4>Important gotcha on spying real objects!</h4>\n  * <ol>\n  * <li>Sometimes it's impossible or impractical to use {@link Mockito#when(Object)} for stubbing spies.\n  * However, it can be helpful for working with <b>legacy systems</b>.\n  * <p>\n  * It is the default answer so it will be used <b>only when you don't</b> stub the method call.\n- * \n+ *\n  * <pre class=\"code\"><code class=\"java\">\n  *   Foo mock = mock(Foo.class, Mockito.RETURNS_SMART_NULLS);\n- *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer()); \n- * </code></pre>\n- * \n+ *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer());\n+ * </code></pre>\n+ *\n  * <p>\n  * Read more about this interesting implementation of <i>Answer</i>: {@link Mockito#RETURNS_SMART_NULLS}\n  *\n  *\n  *\n  * <h3 id=\"15\">15. <a class=\"meaningful_link\" href=\"#captors\">Capturing arguments</a> for further assertions (Since 1.8.0)</h3>\n- * \n+ *\n  * Mockito verifies argument values in natural java style: by using an <code>equals()</code> method.\n  * This is also the recommended way of matching arguments because it makes tests clean & simple.\n  * In some situations though, it is helpful to assert on certain arguments after the actual verification.\n  *   verify(mock).doSomething(argument.capture());\n  *   assertEquals(\"John\", argument.getValue().getName());\n  * </code></pre>\n- * \n+ *\n  * <b>Warning:</b> it is recommended to use ArgumentCaptor with verification <b>but not</b> with stubbing.\n  * Using ArgumentCaptor with stubbing may decrease test readability because captor is created outside of assert (aka verify or 'then') block.\n  * Also it may reduce defect localization because if stubbed method was not called then no argument is captured.\n  * <p>\n  * In a way ArgumentCaptor is related to custom argument matchers (see javadoc for {@link ArgumentMatcher} class).\n- * Both techniques can be used for making sure certain arguments where passed to mocks. \n+ * Both techniques can be used for making sure certain arguments where passed to mocks.\n  * However, ArgumentCaptor may be a better fit if:\n- * <ul>  \n+ * <ul>\n  * <li>custom argument matcher is not likely to be reused</li>\n  * <li>you just need it to assert on argument values to complete verification</li>\n  * </ul>\n  *\n  *\n  * <h3 id=\"16\">16. <a class=\"meaningful_link\" href=\"#partial_mocks\">Real partial mocks</a> (Since 1.8.0)</h3>\n- *  \n+ *\n  *  Finally, after many internal debates & discussions on the mailing list, partial mock support was added to Mockito.\n  *  Previously we considered partial mocks as code smells. However, we found a legitimate use case for partial mocks - more reading:\n  *  <a href=\"http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring\">here</a>\n  *  <p>\n  *  <b>Before release 1.8</b> <code>spy()</code> was not producing real partial mocks and it was confusing for some users.\n- *  Read more about spying: <a href=\"#13\">here</a> or in javadoc for {@link Mockito#spy(Object)} method. \n+ *  Read more about spying: <a href=\"#13\">here</a> or in javadoc for {@link Mockito#spy(Object)} method.\n  *  <p>\n  *  <pre class=\"code\"><code class=\"java\">\n- *    //you can create partial mock with spy() method:    \n+ *    //you can create partial mock with spy() method:\n  *    List list = spy(new LinkedList());\n- *    \n+ *\n  *    //you can enable partial mock capabilities selectively on mocks:\n  *    Foo mock = mock(Foo.class);\n  *    //Be sure the real implementation is 'safe'.\n  *    //If real implementation throws exceptions or depends on specific state of the object then you're in trouble.\n  *    when(mock.someMethod()).thenCallRealMethod();\n  *  </code></pre>\n- *  \n+ *\n  * As usual you are going to read <b>the partial mock warning</b>:\n  * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n- * How does partial mock fit into this paradigm? Well, it just doesn't... \n+ * How does partial mock fit into this paradigm? Well, it just doesn't...\n  * Partial mock usually means that the complexity has been moved to a different method on the same object.\n  * In most cases, this is not the way you want to design your application.\n  * <p>\n- * However, there are rare cases when partial mocks come handy: \n+ * However, there are rare cases when partial mocks come handy:\n  * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n  * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n  *\n  *\n  *\n  * <h3 id=\"17\">17. <a class=\"meaningful_link\" href=\"#resetting_mocks\">Resetting mocks</a> (Since 1.8.0)</h3>\n- *  \n+ *\n  * Smart Mockito users hardly use this feature because they know it could be a sign of poor tests.\n- * Normally, you don't need to reset your mocks, just create new mocks for each test method. \n+ * Normally, you don't need to reset your mocks, just create new mocks for each test method.\n  * <p>\n  * Instead of <code>reset()</code> please consider writing simple, small and focused test methods over lengthy, over-specified tests.\n  * <b>First potential code smell is <code>reset()</code> in the middle of the test method.</b> This probably means you're testing too much.\n- * Follow the whisper of your test methods: \"Please keep us small & focused on single behavior\". \n+ * Follow the whisper of your test methods: \"Please keep us small & focused on single behavior\".\n  * There are several threads about it on mockito mailing list.\n  * <p>\n  * The only reason we added <code>reset()</code> method is to\n  *   List mock = mock(List.class);\n  *   when(mock.size()).thenReturn(10);\n  *   mock.add(1);\n- *   \n+ *\n  *   reset(mock);\n  *   //at this point the mock forgot any interactions & stubbing\n  * </code></pre>\n  *\n  * <h3 id=\"18\">18. <a class=\"meaningful_link\" href=\"#framework_validation\">Troubleshooting & validating framework usage</a> (Since 1.8.0)</h3>\n  *\n- * First of all, in case of any trouble, I encourage you to read the Mockito FAQ: \n+ * First of all, in case of any trouble, I encourage you to read the Mockito FAQ:\n  * <a href=\"http://code.google.com/p/mockito/wiki/FAQ\">http://code.google.com/p/mockito/wiki/FAQ</a>\n  * <p>\n- * In case of questions you may also post to mockito mailing list: \n+ * In case of questions you may also post to mockito mailing list:\n  * <a href=\"http://groups.google.com/group/mockito\">http://groups.google.com/group/mockito</a>\n  * <p>\n- * Next, you should know that Mockito validates if you use it correctly <b>all the time</b>. \n+ * Next, you should know that Mockito validates if you use it correctly <b>all the time</b>.\n  * However, there's a gotcha so please read the javadoc for {@link Mockito#validateMockitoUsage()}\n  *\n  *\n  *\n  *\n  * <h3 id=\"19\">19. <a class=\"meaningful_link\" href=\"#bdd_mockito\">Aliases for behavior driven development</a> (Since 1.8.0)</h3>\n- * \n+ *\n  * Behavior Driven Development style of writing tests uses <b>//given //when //then</b> comments as fundamental parts of your test methods.\n  * This is exactly how we write our tests and we warmly encourage you to do so!\n  * <p>\n  * Start learning about BDD here: <a href=\"http://en.wikipedia.org/wiki/Behavior_Driven_Development\">http://en.wikipedia.org/wiki/Behavior_Driven_Development</a>\n  * <p>\n  * The problem is that current stubbing api with canonical role of <b>when</b> word does not integrate nicely with <b>//given //when //then</b> comments.\n- * It's because stubbing belongs to <b>given</b> component of the test and not to the <b>when</b> component of the test. \n- * Hence {@link BDDMockito} class introduces an alias so that you stub method calls with {@link BDDMockito#given(Object)} method. \n- * Now it really nicely integrates with the <b>given</b> component of a BDD style test!  \n- * <p>\n- * Here is how the test might look like: \n+ * It's because stubbing belongs to <b>given</b> component of the test and not to the <b>when</b> component of the test.\n+ * Hence {@link BDDMockito} class introduces an alias so that you stub method calls with {@link BDDMockito#given(Object)} method.\n+ * Now it really nicely integrates with the <b>given</b> component of a BDD style test!\n+ * <p>\n+ * Here is how the test might look like:\n  * <pre class=\"code\"><code class=\"java\">\n  * import static org.mockito.BDDMockito.*;\n- * \n+ *\n  * Seller seller = mock(Seller.class);\n  * Shop shop = new Shop(seller);\n- * \n+ *\n  * public void shouldBuyBread() throws Exception {\n- *   //given  \n+ *   //given\n  *   given(seller.askForBread()).willReturn(new Bread());\n- *   \n+ *\n  *   //when\n  *   Goods goods = shop.buyBread();\n- *   \n+ *\n  *   //then\n  *   assertThat(goods, containBread());\n- * }  \n+ * }\n  * </code></pre>\n  *\n  *\n  *\n  * Mocks can be made serializable. With this feature you can use a mock in a place that requires dependencies to be serializable.\n  * <p>\n- * WARNING: This should be rarely used in unit testing. \n+ * WARNING: This should be rarely used in unit testing.\n  * <p>\n  * The behaviour was implemented for a specific use case of a BDD spec that had an unreliable external dependency.  This\n- * was in a web environment and the objects from the external dependency were being serialized to pass between layers. \n+ * was in a web environment and the objects from the external dependency were being serialized to pass between layers.\n  * <p>\n  * To create serializable mock use {@link MockSettings#serializable()}:\n  * <pre class=\"code\"><code class=\"java\">\n  * The mock can be serialized assuming all the normal <a href='http://java.sun.com/j2se/1.5.0/docs/api/java/io/Serializable.html'>\n  * serialization requirements</a> are met by the class.\n  * <p>\n- * Making a real object spy serializable is a bit more effort as the spy(...) method does not have an overloaded version \n+ * Making a real object spy serializable is a bit more effort as the spy(...) method does not have an overloaded version\n  * which accepts MockSettings. No worries, you will hardly ever use it.\n- * \n+ *\n  * <pre class=\"code\"><code class=\"java\">\n  * List&lt;Object&gt; list = new ArrayList&lt;Object&gt;();\n  * List&lt;Object&gt; spy = mock(ArrayList.class, withSettings()\n  *\n  * <p>\n  * Release 1.8.3 brings new annotations that may be helpful on occasion:\n- * \n+ *\n  * <ul>\n- * <li>&#064;{@link Captor} simplifies creation of {@link ArgumentCaptor} \n+ * <li>&#064;{@link Captor} simplifies creation of {@link ArgumentCaptor}\n  * - useful when the argument to capture is a nasty generic class and you want to avoid compiler warnings\n- * <li>&#064;{@link Spy} - you can use it instead {@link Mockito#spy(Object)}. \n+ * <li>&#064;{@link Spy} - you can use it instead {@link Mockito#spy(Object)}.\n  * <li>&#064;{@link InjectMocks} - injects mock or spy fields into tested object automatically.\n  * </ul>\n  *\n  * Examples:\n  * <p>\n  * <pre class=\"code\"><code class=\"java\">\n- *   //passes when someMethod() is called within given time span \n+ *   //passes when someMethod() is called within given time span\n  *   verify(mock, timeout(100)).someMethod();\n  *   //above is an alias to:\n  *   verify(mock, timeout(100).times(1)).someMethod();\n- *   \n+ *\n  *   //passes when someMethod() is called <b>*exactly*</b> 2 times within given time span\n  *   verify(mock, timeout(100).times(2)).someMethod();\n  *\n  *   //passes when someMethod() is called <b>*at least*</b> 2 times within given time span\n  *   verify(mock, timeout(100).atLeast(2)).someMethod();\n- *   \n+ *\n  *   //verifies someMethod() within given time span using given verification mode\n  *   //useful only if you have your own custom verification modes.\n  *   verify(mock, new Timeout(100, yourOwnVerificationMode)).someMethod();\n  */\n @SuppressWarnings(\"unchecked\")\n public class Mockito extends Matchers {\n-    \n+\n     static final MockitoCore MOCKITO_CORE = new MockitoCore();\n-    \n+\n     /**\n      * The default <code>Answer</code> of every mock <b>if</b> the mock was not stubbed.\n-     * Typically it just returns some empty value. \n-     * <p>\n-     * {@link Answer} can be used to define the return values of unstubbed invocations. \n-     * <p>\n-     * This implementation first tries the global configuration. \n+     * Typically it just returns some empty value.\n+     * <p>\n+     * {@link Answer} can be used to define the return values of unstubbed invocations.\n+     * <p>\n+     * This implementation first tries the global configuration.\n      * If there is no global configuration then it uses {@link ReturnsEmptyValues} (returns zeros, empty collections, nulls, etc.)\n      */\n     public static final Answer<Object> RETURNS_DEFAULTS = Answers.RETURNS_DEFAULTS.get();\n-    \n+\n     /**\n      * Optional <code>Answer</code> to be used with {@link Mockito#mock(Class, Answer)}.\n      * <p>\n      * Example:\n      * <pre class=\"code\"><code class=\"java\">\n      *   Foo mock = (Foo.class, RETURNS_SMART_NULLS);\n-     *   \n+     *\n      *   //calling unstubbed method here:\n      *   Stuff stuff = mock.getStuff();\n-     *   \n+     *\n      *   //using object returned by unstubbed call:\n      *   stuff.doSomething();\n-     *   \n+     *\n      *   //Above doesn't yield NullPointerException this time!\n-     *   //Instead, SmartNullPointerException is thrown. \n-     *   //Exception's cause links to unstubbed <i>mock.getStuff()</i> - just click on the stack trace.  \n+     *   //Instead, SmartNullPointerException is thrown.\n+     *   //Exception's cause links to unstubbed <i>mock.getStuff()</i> - just click on the stack trace.\n      * </code></pre>\n      */\n     public static final Answer<Object> RETURNS_SMART_NULLS = Answers.RETURNS_SMART_NULLS.get();\n-    \n+\n     /**\n      * Optional <code>Answer</code> to be used with {@link Mockito#mock(Class, Answer)}\n      * <p>\n      * {@link Answer} can be used to define the return values of unstubbed invocations.\n      * <p>\n-     * This implementation can be helpful when working with legacy code. \n+     * This implementation can be helpful when working with legacy code.\n      * <p>\n      * ReturnsMocks first tries to return ordinary return values (see {@link ReturnsMoreEmptyValues})\n      * then it tries to return mocks. If the return type cannot be mocked (e.g. is final) then plain null is returned.\n      * <p>\n      * As usual you are going to read <b>the partial mock warning</b>:\n      * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n-     * How does partial mock fit into this paradigm? Well, it just doesn't... \n+     * How does partial mock fit into this paradigm? Well, it just doesn't...\n      * Partial mock usually means that the complexity has been moved to a different method on the same object.\n      * In most cases, this is not the way you want to design your application.\n      * <p>\n-     * However, there are rare cases when partial mocks come handy: \n+     * However, there are rare cases when partial mocks come handy:\n      * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n      * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n      * <p>\n      * Creates mock object of given class or interface.\n      * <p>\n      * See examples in javadoc for {@link Mockito} class\n-     * \n+     *\n      * @param classToMock class or interface to mock\n      * @return mock object\n      */\n     public static <T> T mock(Class<T> classToMock) {\n         return mock(classToMock, withSettings().defaultAnswer(RETURNS_DEFAULTS));\n     }\n-    \n-    /**\n-     * Specifies mock name. Naming mocks can be helpful for debugging - the name is used in all verification errors. \n-     * <p>\n-     * Beware that naming mocks is not a solution for complex code which uses too many mocks or collaborators. \n+\n+    /**\n+     * Specifies mock name. Naming mocks can be helpful for debugging - the name is used in all verification errors.\n+     * <p>\n+     * Beware that naming mocks is not a solution for complex code which uses too many mocks or collaborators.\n      * <b>If you have too many mocks then refactor the code</b> so that it's easy to test/debug without necessity of naming mocks.\n      * <p>\n      * <b>If you use <code>&#064;Mock</code> annotation then you've got naming mocks for free!</b> <code>&#064;Mock</code> uses field name as mock name. {@link Mock Read more.}\n      * <p>\n-     * \n+     *\n      * See examples in javadoc for {@link Mockito} class\n-     * \n+     *\n      * @param classToMock class or interface to mock\n-     * @param name of the mock \n+     * @param name of the mock\n      * @return mock object\n      */\n     public static <T> T mock(Class<T> classToMock, String name) {\n     public static MockingDetails mockingDetails(Object toInspect) {\n         return MOCKITO_CORE.mockingDetails(toInspect);\n     }\n-    \n+\n     /**\n      * <b>Deprecated : Please use mock(Foo.class, defaultAnswer);</b>\n      * <p>\n      * See {@link Mockito#mock(Class, Answer)}\n      * <p>\n      * Why it is deprecated? ReturnValues is being replaced by Answer\n-     * for better consistency & interoperability of the framework. \n+     * for better consistency & interoperability of the framework.\n      * Answer interface has been in Mockito for a while and it has the same responsibility as ReturnValues.\n      * There's no point in mainting exactly the same interfaces.\n      * <p>\n-     * Creates mock with a specified strategy for its return values. \n+     * Creates mock with a specified strategy for its return values.\n      * It's quite advanced feature and typically you don't need it to write decent tests.\n      * However it can be helpful when working with legacy systems.\n      * <p>\n      *\n      * <pre class=\"code\"><code class=\"java\">\n      *   Foo mock = mock(Foo.class, Mockito.RETURNS_SMART_NULLS);\n-     *   Foo mockTwo = mock(Foo.class, new YourOwnReturnValues()); \n-     * </code></pre>\n-     * \n+     *   Foo mockTwo = mock(Foo.class, new YourOwnReturnValues());\n+     * </code></pre>\n+     *\n      * <p>See examples in javadoc for {@link Mockito} class</p>\n-     * \n+     *\n      * @param classToMock class or interface to mock\n      * @param returnValues default return values for unstubbed methods\n      *\n     public static <T> T mock(Class<T> classToMock, ReturnValues returnValues) {\n         return mock(classToMock, withSettings().defaultAnswer(new AnswerReturnValuesAdapter(returnValues)));\n     }\n-    \n-    /**\n-     * Creates mock with a specified strategy for its answers to interactions. \n+\n+    /**\n+     * Creates mock with a specified strategy for its answers to interactions.\n      * It's quite advanced feature and typically you don't need it to write decent tests.\n      * However it can be helpful when working with legacy systems.\n      * <p>\n      *\n      * <pre class=\"code\"><code class=\"java\">\n      *   Foo mock = mock(Foo.class, RETURNS_SMART_NULLS);\n-     *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer()); \n-     * </code></pre>\n-     * \n+     *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer());\n+     * </code></pre>\n+     *\n      * <p>See examples in javadoc for {@link Mockito} class</p>\n-     * \n+     *\n      * @param classToMock class or interface to mock\n      * @param defaultAnswer default answer for unstubbed methods\n      *\n     public static <T> T mock(Class<T> classToMock, Answer defaultAnswer) {\n         return mock(classToMock, withSettings().defaultAnswer(defaultAnswer));\n     }\n-    \n+\n     /**\n      * Creates a mock with some non-standard settings.\n      * <p>\n-     * The number of configuration points for a mock grows \n-     * so we need a fluent way to introduce new configuration without adding more and more overloaded Mockito.mock() methods. \n+     * The number of configuration points for a mock grows\n+     * so we need a fluent way to introduce new configuration without adding more and more overloaded Mockito.mock() methods.\n      * Hence {@link MockSettings}.\n      * <pre class=\"code\"><code class=\"java\">\n      *   Listener mock = mock(Listener.class, withSettings()\n      *     .name(\"firstListner\").defaultBehavior(RETURNS_SMART_NULLS));\n-     *   );  \n-     * </code></pre>\n-     * <b>Use it carefully and occasionally</b>. What might be reason your test needs non-standard mocks? \n-     * Is the code under test so complicated that it requires non-standard mocks? \n+     *   );\n+     * </code></pre>\n+     * <b>Use it carefully and occasionally</b>. What might be reason your test needs non-standard mocks?\n+     * Is the code under test so complicated that it requires non-standard mocks?\n      * Wouldn't you prefer to refactor the code under test so it is testable in a simple way?\n      * <p>\n      * See also {@link Mockito#withSettings()}\n      * <p>\n      * See examples in javadoc for {@link Mockito} class\n-     * \n+     *\n      * @param classToMock class or interface to mock\n      * @param mockSettings additional mock settings\n      * @return mock object\n     public static <T> T mock(Class<T> classToMock, MockSettings mockSettings) {\n         return MOCKITO_CORE.mock(classToMock, mockSettings);\n     }\n-    \n+\n     /**\n      * Creates a spy of the real object. The spy calls <b>real</b> methods unless they are stubbed.\n      * <p>\n      * <p>\n      * As usual you are going to read <b>the partial mock warning</b>:\n      * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n-     * How does partial mock fit into this paradigm? Well, it just doesn't... \n+     * How does partial mock fit into this paradigm? Well, it just doesn't...\n      * Partial mock usually means that the complexity has been moved to a different method on the same object.\n      * In most cases, this is not the way you want to design your application.\n      * <p>\n-     * However, there are rare cases when partial mocks come handy: \n+     * However, there are rare cases when partial mocks come handy:\n      * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n      * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n      * <p>\n      * Example:\n-     * \n+     *\n      * <pre class=\"code\"><code class=\"java\">\n      *   List list = new LinkedList();\n      *   List spy = spy(list);\n-     * \n+     *\n      *   //optionally, you can stub out some methods:\n      *   when(spy.size()).thenReturn(100);\n-     * \n+     *\n      *   //using the spy calls <b>real</b> methods\n      *   spy.add(\"one\");\n      *   spy.add(\"two\");\n-     * \n+     *\n      *   //prints \"one\" - the first element of a list\n      *   System.out.println(spy.get(0));\n-     * \n+     *\n      *   //size() method was stubbed - 100 is printed\n      *   System.out.println(spy.size());\n-     * \n+     *\n      *   //optionally, you can verify\n      *   verify(spy).add(\"one\");\n      *   verify(spy).add(\"two\");\n      * </code></pre>\n-     * \n+     *\n      * <h4>Important gotcha on spying real objects!</h4>\n      * <ol>\n      * <li>Sometimes it's impossible or impractical to use {@link Mockito#when(Object)} for stubbing spies.\n      * </ol>\n      * <p>\n      * See examples in javadoc for {@link Mockito} class\n-     * \n+     *\n+     * <p>Note that the spy won't have any annotations of the spied type, because CGLIB won't rewrite them.\n+     * It may troublesome for code that rely on the spy to have these annotations.</p>\n+     *\n+     *\n      * @param object\n      *            to spy on\n      * @return a spy of the real object\n      * <pre class=\"code\"><code class=\"java\">\n      *   //Instead of:\n      *   stub(mock.count()).toReturn(10);\n-     * \n+     *\n      *   //You can do:\n      *   when(mock.count()).thenReturn(10);\n      * </code></pre>\n      * the same arguments many times.\n      * <p>\n      * Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>.\n-     * Let's say you've stubbed foo.bar(). \n+     * Let's say you've stubbed foo.bar().\n      * If your code cares what foo.bar() returns then something else breaks(often before even verify() gets executed).\n-     * If your code doesn't care what get(0) returns then it should not be stubbed. \n-     * Not convinced? See <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>. \n-     * \n+     * If your code doesn't care what get(0) returns then it should not be stubbed.\n+     * Not convinced? See <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.\n+     *\n      * @param methodCall\n      *            method call\n      * @return DeprecatedOngoingStubbing object to set stubbed value/exception\n     public static <T> DeprecatedOngoingStubbing<T> stub(T methodCall) {\n         return MOCKITO_CORE.stub(methodCall);\n     }\n-    \n-    /**\n-     * Enables stubbing methods. Use it when you want the mock to return particular value when particular method is called. \n+\n+    /**\n+     * Enables stubbing methods. Use it when you want the mock to return particular value when particular method is called.\n      * <p>\n      * Simply put: \"<b>When</b> the x method is called <b>then</b> return y\".\n      * <p>\n      * <b>when() is a successor of deprecated {@link Mockito#stub(Object)}</b>\n      * <p>\n      * Examples:\n-     * \n+     *\n      * <pre class=\"code\"><code class=\"java\">\n      * <b>when</b>(mock.someMethod()).<b>thenReturn</b>(10);\n      *\n      * when(mock.someMethod(\"some arg\"))\n      *  .thenThrow(new RuntimeException())\n      *  .thenReturn(\"foo\");\n-     *  \n+     *\n      * //Alternative, shorter version for consecutive stubbing:\n      * when(mock.someMethod(\"some arg\"))\n      *  .thenReturn(\"one\", \"two\");\n      * //shorter version for consecutive method calls throwing exceptions:\n      * when(mock.someMethod(\"some arg\"))\n      *  .thenThrow(new RuntimeException(), new NullPointerException();\n-     *   \n-     * </code></pre>\n-     * \n+     *\n+     * </code></pre>\n+     *\n      * For stubbing void methods with throwables see: {@link Mockito#doThrow(Throwable)}\n      * <p>\n      * Stubbing can be overridden: for example common stubbing can go to fixture\n      * If your code cares what <code>foo.bar()</code> returns then something else breaks(often before even <code>verify()</code> gets executed).\n      * If your code doesn't care what <code>get(0)</code> returns then it should not be stubbed.\n      * Not convinced? See <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.\n-     * \n+     *\n      * <p>\n      * See examples in javadoc for {@link Mockito} class\n      * @param methodCall method to be stubbed\n      * If your code cares what <code>foo.bar()</code> returns then something else breaks(often before even <code>verify()</code> gets executed).\n      * If your code doesn't care what <code>get(0)</code> returns then it should not be stubbed.\n      * Not convinced? See <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.\n-     * \n+     *\n      * <p>\n      * See examples in javadoc for {@link Mockito} class\n-     * \n+     *\n      * @param mock to be verified\n      * @return mock object itself\n      */\n      * <p>\n      * Stubbed invocations (if called) are also treated as interactions.\n      * <p>\n-     * A word of <b>warning</b>: \n+     * A word of <b>warning</b>:\n      * Some users who did a lot of classic, expect-run-verify mocking tend to use <code>verifyNoMoreInteractions()</code> very often, even in every test method.\n      * <code>verifyNoMoreInteractions()</code> is not recommended to use in every test method.\n      * <code>verifyNoMoreInteractions()</code> is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.\n-     * Abusing it leads to overspecified, less maintainable tests. You can find further reading \n+     * Abusing it leads to overspecified, less maintainable tests. You can find further reading\n      * <a href=\"http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/\">here</a>.\n      * <p>\n      * This method will also detect unverified invocations that occurred before the test method,\n      * for example: in <code>setUp()</code>, <code>&#064;Before</code> method or in constructor.\n      * Consider writing nice code that makes interactions only in test methods.\n-     * \n+     *\n      * <p>\n      * Example:\n-     * \n+     *\n      * <pre class=\"code\"><code class=\"java\">\n      * //interactions\n      * mock.doSomething();\n      * mock.doSomethingUnexpected();\n-     * \n+     *\n      * //verification\n      * verify(mock).doSomething();\n-     * \n+     *\n      * //following will fail because 'doSomethingUnexpected()' is unexpected\n      * verifyNoMoreInteractions(mock);\n-     * \n-     * </code></pre>\n-     * \n+     *\n+     * </code></pre>\n+     *\n      * See examples in javadoc for {@link Mockito} class\n-     * \n+     *\n      * @param mocks to be verified\n      */\n     public static void verifyNoMoreInteractions(Object... mocks) {\n      * <pre class=\"code\"><code class=\"java\">\n      *   verifyZeroInteractions(mockOne, mockTwo);\n      * </code></pre>\n-     * This method will also detect invocations \n+     * This method will also detect invocations\n      * that occurred before the test method, for example: in <code>setUp()</code>, <code>&#064;Before</code> method or in constructor.\n-     * Consider writing nice code that makes interactions only in test methods.  \n+     * Consider writing nice code that makes interactions only in test methods.\n      * <p>\n      * See also {@link Mockito#never()} - it is more explicit and communicates the intent well.\n      * <p>\n      * See examples in javadoc for {@link Mockito} class\n-     * \n+     *\n      * @param mocks to be verified\n      */\n     public static void verifyZeroInteractions(Object... mocks) {\n      * <pre class=\"code\"><code class=\"java\">\n      *   //Instead of:\n      *   stubVoid(mock).toThrow(e).on().someVoidMethod();\n-     * \n+     *\n      *   //Please do:\n      *   doThrow(e).when(mock).someVoidMethod();\n      * </code></pre>\n-     * \n-     * doThrow() replaces stubVoid() because of improved readability and consistency with the family of doAnswer() methods. \n+     *\n+     * doThrow() replaces stubVoid() because of improved readability and consistency with the family of doAnswer() methods.\n      * <p>\n      * Originally, <code>stubVoid()</code> was used for stubbing void methods with exceptions. E.g:\n-     * \n+     *\n      * <pre class=\"code\"><code class=\"java\">\n      * stubVoid(mock).toThrow(new RuntimeException()).on().someMethod();\n-     * \n+     *\n      * //you can stub with different behavior for consecutive calls.\n-     * //Last stubbing (e.g. toReturn()) determines the behavior for further consecutive calls.   \n+     * //Last stubbing (e.g. toReturn()) determines the behavior for further consecutive calls.\n      * stubVoid(mock)\n      *   .toThrow(new RuntimeException())\n      *   .toReturn()\n      *   .on().someMethod();\n      * </code></pre>\n-     * \n+     *\n      * See examples in javadoc for {@link Mockito} class\n-     * \n+     *\n      * @deprecated Use {@link Mockito#doThrow(Throwable)} method for stubbing voids\n-     * \n+     *\n      * @param mock\n      *            to stub\n      * @return stubbable object that allows stubbing with throwable\n     public static <T> VoidMethodStubbable<T> stubVoid(T mock) {\n         return MOCKITO_CORE.stubVoid(mock);\n     }\n-    \n+\n     /**\n      * Use <code>doThrow()</code> when you want to stub the void method with an exception.\n      * <p>\n      * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...\n      * <p>\n      * Example:\n-     * \n+     *\n      * <pre class=\"code\"><code class=\"java\">\n      *   doThrow(new RuntimeException()).when(mock).someVoidMethod();\n      * </code></pre>\n-     * \n+     *\n      * @param toBeThrown to be thrown when the stubbed method is called\n      * @return stubber - to select a method for stubbing\n      */\n      * <p>\n      * As usual you are going to read <b>the partial mock warning</b>:\n      * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n-     * How does partial mock fit into this paradigm? Well, it just doesn't... \n+     * How does partial mock fit into this paradigm? Well, it just doesn't...\n      * Partial mock usually means that the complexity has been moved to a different method on the same object.\n      * In most cases, this is not the way you want to design your application.\n      * <p>\n-     * However, there are rare cases when partial mocks come handy: \n+     * However, there are rare cases when partial mocks come handy:\n      * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n      * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n      * <p>\n-     * See also javadoc {@link Mockito#spy(Object)} to find out more about partial mocks. \n-     * <b>Mockito.spy() is a recommended way of creating partial mocks.</b> \n+     * See also javadoc {@link Mockito#spy(Object)} to find out more about partial mocks.\n+     * <b>Mockito.spy() is a recommended way of creating partial mocks.</b>\n      * The reason is it guarantees real methods are called against correctly constructed object because you're responsible for constructing the object passed to spy() method.\n      * <p>\n      * Example:\n     public static Stubber doCallRealMethod() {\n         return MOCKITO_CORE.doAnswer(new CallsRealMethods());\n     }\n-    \n+\n     /**\n      * Use <code>doAnswer()</code> when you want to stub a void method with generic {@link Answer}.\n      * <p>\n      * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...\n      * <p>\n      * Example:\n-     * \n+     *\n      * <pre class=\"code\"><code class=\"java\">\n      *  doAnswer(new Answer() {\n      *      public Object answer(InvocationOnMock invocation) {\n      * </code></pre>\n      * <p>\n      * See examples in javadoc for {@link Mockito} class\n-     * \n+     *\n      * @param answer to answer when the stubbed method is called\n      * @return stubber - to select a method for stubbing\n      */\n     public static Stubber doAnswer(Answer answer) {\n         return MOCKITO_CORE.doAnswer(answer);\n-    }  \n-    \n+    }\n+\n     /**\n      * Use <code>doNothing()</code> for setting void methods to do nothing. <b>Beware that void methods on mocks do nothing by default!</b>\n-     * However, there are rare situations when doNothing() comes handy:  \n+     * However, there are rare situations when doNothing() comes handy:\n      * <p>\n      * <ol>\n      * <li>Stubbing consecutive calls on a void method:\n      */\n     public static Stubber doNothing() {\n         return MOCKITO_CORE.doAnswer(new DoesNothing());\n-    }    \n-    \n+    }\n+\n     /**\n      * Use <code>doReturn()</code> in those rare occasions when you cannot use {@link Mockito#when(Object)}.\n      * <p>\n-     * <b>Beware that {@link Mockito#when(Object)} is always recommended for stubbing because it is argument type-safe \n-     * and more readable</b> (especially when stubbing consecutive calls). \n+     * <b>Beware that {@link Mockito#when(Object)} is always recommended for stubbing because it is argument type-safe\n+     * and more readable</b> (especially when stubbing consecutive calls).\n      * <p>\n      * Here are those rare occasions when doReturn() comes handy:\n      * <p>\n      * overridding stubbing is a potential code smell that points out too much stubbing.\n      * <p>\n      * See examples in javadoc for {@link Mockito} class\n-     * \n+     *\n      * @param toBeReturned to be returned when the stubbed method is called\n      * @return stubber - to select a method for stubbing\n      */\n     public static Stubber doReturn(Object toBeReturned) {\n         return MOCKITO_CORE.doAnswer(new Returns(toBeReturned));\n     }\n- \n+\n     /**\n      * Creates {@link org.mockito.InOrder} object that allows verifying mocks in order.\n-     * \n+     *\n      * <pre class=\"code\"><code class=\"java\">\n      *   InOrder inOrder = inOrder(firstMock, secondMock);\n-     *   \n+     *\n      *   inOrder.verify(firstMock).add(\"was called first\");\n      *   inOrder.verify(secondMock).add(\"was called second\");\n      * </code></pre>\n-     * \n+     *\n      * Verification in order is flexible - <b>you don't have to verify all interactions</b> one-by-one\n      * but only those that you are interested in testing in order.\n      * <p>\n      * Also, you can create InOrder object passing only mocks that are relevant for in-order verification.\n      * <p>\n      * <code>InOrder</code> verification is 'greedy'. You will hardly every notice it but\n-     * if you want to find out more search for 'greedy' on the Mockito \n-     * <a href=\"http://code.google.com/p/mockito/w/list\">wiki pages</a>.  \n+     * if you want to find out more search for 'greedy' on the Mockito\n+     * <a href=\"http://code.google.com/p/mockito/w/list\">wiki pages</a>.\n      * <p>\n      * As of Mockito 1.8.4 you can verifyNoMoreInvocations() in order-sensitive way. Read more: {@link InOrder#verifyNoMoreInteractions()}\n      * <p>\n      * See examples in javadoc for {@link Mockito} class\n-     * \n+     *\n      * @param mocks to be verified in order\n-     * \n+     *\n      * @return InOrder object to be used to verify in order\n      */\n     public static InOrder inOrder(Object... mocks) {\n      * <pre class=\"code\"><code class=\"java\">\n      *   verify(mock, times(2)).someMethod(\"some arg\");\n      * </code></pre>\n-     * \n+     *\n      * See examples in javadoc for {@link Mockito} class\n-     * \n-     * @param wantedNumberOfInvocations wanted number of invocations \n-     * \n+     *\n+     * @param wantedNumberOfInvocations wanted number of invocations\n+     *\n      * @return verification mode\n      */\n     public static VerificationMode times(int wantedNumberOfInvocations) {\n         return VerificationModeFactory.times(wantedNumberOfInvocations);\n     }\n-    \n+\n     /**\n      * Alias to <code>times(0)</code>, see {@link Mockito#times(int)}\n      * <p>\n      * <pre class=\"code\"><code class=\"java\">\n      *   verify(mock, never()).someMethod();\n      * </code></pre>\n-     * \n-     * <p>\n-     * If you want to verify there were NO interactions with the mock \n+     *\n+     * <p>\n+     * If you want to verify there were NO interactions with the mock\n      * check out {@link Mockito#verifyZeroInteractions(Object...)}\n      * or {@link Mockito#verifyNoMoreInteractions(Object...)}\n      * <p>\n      * See examples in javadoc for {@link Mockito} class\n-     * \n+     *\n      * @return verification mode\n      */\n     public static VerificationMode never() {\n         return times(0);\n     }\n-    \n+\n     /**\n      * Allows at-least-once verification. E.g:\n      * <pre class=\"code\"><code class=\"java\">\n      * Alias to <code>atLeast(1)</code>.\n      * <p>\n      * See examples in javadoc for {@link Mockito} class\n-     * \n+     *\n      * @return verification mode\n      */\n     public static VerificationMode atLeastOnce() {\n      * <pre class=\"code\"><code class=\"java\">\n      *   verify(mock, atLeast(3)).someMethod(\"some arg\");\n      * </code></pre>\n-     * \n+     *\n      * See examples in javadoc for {@link Mockito} class\n-     * \n-     * @param minNumberOfInvocations minimum number of invocations \n-     * \n+     *\n+     * @param minNumberOfInvocations minimum number of invocations\n+     *\n      * @return verification mode\n      */\n     public static VerificationMode atLeast(int minNumberOfInvocations) {\n      * <pre class=\"code\"><code class=\"java\">\n      *   verify(mock, atMost(3)).someMethod(\"some arg\");\n      * </code></pre>\n-     * \n+     *\n      * See examples in javadoc for {@link Mockito} class\n-     * \n-     * @param maxNumberOfInvocations max number of invocations \n-     * \n+     *\n+     * @param maxNumberOfInvocations max number of invocations\n+     *\n      * @return verification mode\n      */\n     public static VerificationMode atMost(int maxNumberOfInvocations) {\n     public static VerificationMode calls( int wantedNumberOfInvocations ){\n         return VerificationModeFactory.calls( wantedNumberOfInvocations );\n     }\n-    \n+\n     /**\n      * Allows checking if given method was the only one invoked. E.g:\n      * <pre class=\"code\"><code class=\"java\">\n      *   verify(mock).someMethod();\n      *   verifyNoMoreInvocations(mock);\n      * </code></pre>\n-     * \n+     *\n      * <p>\n      * See also {@link Mockito#verifyNoMoreInteractions(Object...)}\n      * <p>\n      * See examples in javadoc for {@link Mockito} class\n-     * \n+     *\n      * @return verification mode\n      */\n     public static VerificationMode only() {\n     \treturn VerificationModeFactory.only();\n-    }    \n-    \n+    }\n+\n     /**\n      * Allows verifying with timeout. It causes a verify to wait for a specified period of time for a desired\n      * interaction rather than fails immediately if has not already happened. May be useful for testing in concurrent\n      * <p>\n      * This differs from {@link Mockito#after after()} in that after() will wait the full period, unless\n      * the final test result is known early (e.g. if a never() fails), whereas timeout() will stop early as soon\n-     * as verification passes, producing different behaviour when used with times(2), for example, which can pass \n+     * as verification passes, producing different behaviour when used with times(2), for example, which can pass\n      * and then later fail. In that case, timeout would pass as soon as times(2) passes, whereas after would run until\n      * times(2) failed, and then fail.\n      * <p>\n      * <p>\n      * Not yet implemented to work with InOrder verification.\n      * <pre class=\"code\"><code class=\"java\">\n-     *   //passes when someMethod() is called within given time span \n+     *   //passes when someMethod() is called within given time span\n      *   verify(mock, timeout(100)).someMethod();\n      *   //above is an alias to:\n      *   verify(mock, timeout(100).times(1)).someMethod();\n-     *   \n+     *\n      *   //passes as soon as someMethod() has been called 2 times before the given timeout\n      *   verify(mock, timeout(100).times(2)).someMethod();\n      *\n      *   //equivalent: this also passes as soon as someMethod() has been called 2 times before the given timeout\n      *   verify(mock, timeout(100).atLeast(2)).someMethod();\n-     *   \n+     *\n      *   //verifies someMethod() within given time span using given verification mode\n      *   //useful only if you have your own custom verification modes.\n      *   verify(mock, new Timeout(100, yourOwnVerificationMode)).someMethod();\n      * </code></pre>\n-     * \n+     *\n      * See examples in javadoc for {@link Mockito} class\n-     * \n+     *\n      * @param millis - time span in milliseconds\n-     * \n+     *\n      * @return verification mode\n      */\n     public static VerificationWithTimeout timeout(long millis) {\n         return new Timeout(millis, VerificationModeFactory.times(1));\n     }\n-    \n+\n     /**\n      * Allows verifying over a given period. It causes a verify to wait for a specified period of time for a desired\n      * interaction rather than failing immediately if has not already happened. May be useful for testing in concurrent\n      * conditions.\n      * <p>\n-     * This differs from {@link Mockito#timeout timeout()} in that after() will wait the full period, whereas timeout() \n+     * This differs from {@link Mockito#timeout timeout()} in that after() will wait the full period, whereas timeout()\n      * will stop early as soon as verification passes, producing different behaviour when used with times(2), for example,\n      * which can pass and then later fail. In that case, timeout would pass as soon as times(2) passes, whereas after would\n      * run the full time, which point it will fail, as times(2) has failed.\n      * <p>\n      * Not yet implemented to work with InOrder verification.\n      * <pre class=\"code\"><code class=\"java\">\n-     *   //passes after 100ms, if someMethod() has only been called once at that time. \n+     *   //passes after 100ms, if someMethod() has only been called once at that time.\n      *   verify(mock, after(100)).someMethod();\n      *   //above is an alias to:\n      *   verify(mock, after(100).times(1)).someMethod();\n-     *   \n+     *\n      *   //passes if someMethod() is called <b>*exactly*</b> 2 times after the given timespan\n      *   verify(mock, after(100).times(2)).someMethod();\n      *\n      *   //passes if someMethod() has not been called after the given timespan\n      *   verify(mock, after(100).never()).someMethod();\n-     *   \n+     *\n      *   //verifies someMethod() after a given time span using given verification mode\n      *   //useful only if you have your own custom verification modes.\n      *   verify(mock, new After(100, yourOwnVerificationMode)).someMethod();\n      * </code></pre>\n-     * \n+     *\n      * See examples in javadoc for {@link Mockito} class\n-     * \n+     *\n      * @param millis - time span in milliseconds\n-     * \n+     *\n      * @return verification mode\n      */\n     public static VerificationAfterDelay after(int millis) {\n         return new After(millis, VerificationModeFactory.times(1));\n     }\n-    \n+\n     /**\n      * First of all, in case of any trouble, I encourage you to read the Mockito FAQ: <a href=\"http://code.google.com/p/mockito/wiki/FAQ\">http://code.google.com/p/mockito/wiki/FAQ</a>\n      * <p>\n-     * In case of questions you may also post to mockito mailing list: <a href=\"http://groups.google.com/group/mockito\">http://groups.google.com/group/mockito</a> \n+     * In case of questions you may also post to mockito mailing list: <a href=\"http://groups.google.com/group/mockito\">http://groups.google.com/group/mockito</a>\n      * <p>\n      * <code>validateMockitoUsage()</code> <b>explicitly validates</b> the framework state to detect invalid use of Mockito.\n      * However, this feature is optional <b>because Mockito validates the usage all the time...</b> but there is a gotcha so read on.\n      * <pre class=\"code\"><code class=\"java\">\n      * //Oops, someone forgot thenReturn() part:\n      * when(mock.get());\n-     * \n+     *\n      * //Oops, someone put the verified method call inside verify() where it should be outside:\n      * verify(mock.execute());\n-     * \n+     *\n      * //Oops, someone has used EasyMock for too long and forgot to specify the method to verify:\n      * verify(mock);\n      * </code></pre>\n-     * \n-     * Mockito throws exceptions if you misuse it so that you know if your tests are written correctly. \n-     * The gotcha is that Mockito does the validation <b>next time</b> you use the framework (e.g. next time you verify, stub, call mock etc.). \n-     * But even though the exception might be thrown in the next test, \n-     * the exception <b>message contains a navigable stack trace element</b> with location of the defect. \n+     *\n+     * Mockito throws exceptions if you misuse it so that you know if your tests are written correctly.\n+     * The gotcha is that Mockito does the validation <b>next time</b> you use the framework (e.g. next time you verify, stub, call mock etc.).\n+     * But even though the exception might be thrown in the next test,\n+     * the exception <b>message contains a navigable stack trace element</b> with location of the defect.\n      * Hence you can click and find the place where Mockito was misused.\n      * <p>\n-     * Sometimes though, you might want to validate the framework usage explicitly. \n+     * Sometimes though, you might want to validate the framework usage explicitly.\n      * For example, one of the users wanted to put <code>validateMockitoUsage()</code> in his <code>&#064;After</code> method\n-     * so that he knows immediately when he misused Mockito. \n+     * so that he knows immediately when he misused Mockito.\n      * Without it, he would have known about it not sooner than <b>next time</b> he used the framework.\n      * One more benefit of having <code>validateMockitoUsage()</code> in <code>&#064;After</code> is that jUnit runner will always fail in the test method with defect\n-     * whereas ordinary 'next-time' validation might fail the <b>next</b> test method. \n-     * But even though JUnit might report next test as red, don't worry about it \n-     * and just click at navigable stack trace element in the exception message to instantly locate the place where you misused mockito.   \n+     * whereas ordinary 'next-time' validation might fail the <b>next</b> test method.\n+     * But even though JUnit might report next test as red, don't worry about it\n+     * and just click at navigable stack trace element in the exception message to instantly locate the place where you misused mockito.\n      * <p>\n      * <b>Built-in runner: {@link MockitoJUnitRunner}</b> does validateMockitoUsage() after each test method.\n      * <p>\n     }\n \n     /**\n-     * Allows mock creation with additional mock settings. \n-     * <p>\n-     * Don't use it too often. \n-     * Consider writing simple tests that use simple mocks. \n+     * Allows mock creation with additional mock settings.\n+     * <p>\n+     * Don't use it too often.\n+     * Consider writing simple tests that use simple mocks.\n      * Repeat after me: simple tests push simple, KISSy, readable & maintainable code.\n      * If you cannot write a test in a simple way - refactor the code under test.\n      * <p>\n      *   Foo mock = mock(Foo.class, withSettings()\n      *       .defaultAnswer(RETURNS_SMART_NULLS)\n      *       .name(\"cool mockie\"));\n-     *       \n+     *\n      *   //Creates mock with different default answer, descriptive name and extra interfaces\n      *   Foo mock = mock(Foo.class, withSettings()\n      *       .defaultAnswer(RETURNS_SMART_NULLS)\n      *       .name(\"cool mockie\")\n-     *       .extraInterfaces(Bar.class));    \n-     * </code></pre>\n-     * {@link MockSettings} has been introduced for two reasons. \n+     *       .extraInterfaces(Bar.class));\n+     * </code></pre>\n+     * {@link MockSettings} has been introduced for two reasons.\n      * Firstly, to make it easy to add another mock settings when the demand comes.\n      * Secondly, to enable combining different mock settings without introducing zillions of overloaded mock() methods.\n      * <p>\n      * See javadoc for {@link MockSettings} to learn about possible mock settings.\n      * <p>\n-     * \n+     *\n      * @return mock settings instance with defaults.\n      */\n     public static MockSettings withSettings() {\n--- a/src/org/mockito/Spy.java\n+++ b/src/org/mockito/Spy.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito;\n-\n-import java.lang.annotation.*;\n \n import static java.lang.annotation.ElementType.FIELD;\n import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+import java.lang.annotation.Documented;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.Target;\n \n /**\n  * Allows shorthand wrapping of field instances in an spy object.\n- * \n+ *\n  * <p>\n  * Example:\n- * \n+ *\n  * <pre class=\"code\"><code class=\"java\">\n  * public class Test{\n  *    //Instance for spying is created by calling constructor explicitly:\n  *    &#64;Spy Foo spyOnFoo = new Foo(\"argument\");\n- *    //Instance for spying is created by mockito via reflection (only default constructors supported): \n+ *    //Instance for spying is created by mockito via reflection (only default constructors supported):\n  *    &#64;Spy Bar spyOnBar;\n  *    &#64;Before\n  *    public void init(){\n  * </code></pre>\n  * <p>\n  * Same as doing:\n- * \n+ *\n  * <pre class=\"code\"><code class=\"java\">\n  * Foo spyOnFoo = Mockito.spy(new Foo(\"argument\"));\n  * Bar spyOnFoo = Mockito.spy(new Bar());\n  * {@link org.mockito.runners.MockitoJUnitRunner}.\n  * </p>\n  *\n+ * <p>Note that the spy won't have any annotations of the spied type, because CGLIB won't rewrite them.\n+ * It may troublesome for code that rely on the spy to have these annotations.</p>\n+ *\n  * @see Mockito#spy(Object)\n  * @see Mock\n  * @see InjectMocks", "timestamp": 1404499181, "metainfo": ""}