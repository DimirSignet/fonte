{"sha": "55bfac6da735fbda1711e4a5ba53dd324ffa0f99", "log": "Renamed MockitoGenericMetadata to GenericMetadataSupport  --HG-- branch : issue230 rename : src/org/mockito/internal/util/reflection/MockitoGenericMetadata.java => src/org/mockito/internal/util/reflection/GenericMetadataSupport.java rename : test/org/mockito/internal/util/reflection/MockitoGenericMetadataTest.java => test/org/mockito/internal/util/reflection/GenericMetadataSupportTest.java", "commit": "\n--- a/src/org/mockito/internal/creation/MockSettingsImpl.java\n+++ b/src/org/mockito/internal/creation/MockSettingsImpl.java\n import org.mockito.internal.util.MockCreationValidator;\n import org.mockito.internal.util.MockNameImpl;\n import org.mockito.internal.util.MockitoSpy;\n-import org.mockito.internal.util.reflection.MockitoGenericMetadata;\n+import org.mockito.internal.util.reflection.GenericMetadataSupport;\n import org.mockito.listeners.InvocationListener;\n import org.mockito.mock.MockCreationSettings;\n import org.mockito.mock.MockName;\n         return interfaces;\n     }\n \n-    public MockSettings parameterizedInfo(MockitoGenericMetadata mockitoGenericMetadata) {\n+    public MockSettings parameterizedInfo(GenericMetadataSupport mockitoGenericMetadata) {\n         this.mockitoGenericMetadata = mockitoGenericMetadata;\n         return this;\n     }\n--- a/src/org/mockito/internal/creation/settings/CreationSettings.java\n+++ b/src/org/mockito/internal/creation/settings/CreationSettings.java\n  */\n package org.mockito.internal.creation.settings;\n \n-import org.mockito.internal.util.reflection.MockitoGenericMetadata;\n+import org.mockito.internal.util.reflection.GenericMetadataSupport;\n import org.mockito.listeners.InvocationListener;\n import org.mockito.mock.MockCreationSettings;\n import org.mockito.mock.MockName;\n  * by Szczepan Faber, created at: 4/9/12\n  */\n public class CreationSettings<T> implements MockCreationSettings<T>, Serializable {\n+    private static final long serialVersionUID = -6789800638070123629L;\n \n     protected Class<T> typeToMock;\n     protected Set<Class> extraInterfaces = new LinkedHashSet<Class>();\n     protected MockName mockName;\n     protected boolean serializable;\n     protected List<InvocationListener> invocationListeners = new ArrayList<InvocationListener>();\n-    protected MockitoGenericMetadata mockitoGenericMetadata;\n+    protected GenericMetadataSupport mockitoGenericMetadata;\n \n     public CreationSettings() {}\n \n+    @SuppressWarnings(\"unchecked\")\n     public CreationSettings(CreationSettings copy) {\n         this.typeToMock = copy.typeToMock;\n         this.extraInterfaces = copy.extraInterfaces;\n         return invocationListeners;\n     }\n \n-    public MockitoGenericMetadata getMockitoGenericMetadata() {\n+    public GenericMetadataSupport getMockitoGenericMetadata() {\n         if (mockitoGenericMetadata == null) {\n-            this.mockitoGenericMetadata = MockitoGenericMetadata.from(typeToMock);\n+            this.mockitoGenericMetadata = GenericMetadataSupport.from(typeToMock);\n         }\n         return mockitoGenericMetadata;\n     }\n \n-    public void setMockitoGenericMetadata(MockitoGenericMetadata mockitoGenericMetadata) {\n+    public void setMockitoGenericMetadata(GenericMetadataSupport mockitoGenericMetadata) {\n         this.mockitoGenericMetadata = mockitoGenericMetadata;\n     }\n }\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsGenericDeepStubs.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsGenericDeepStubs.java\n import org.mockito.internal.stubbing.StubbedInvocationMatcher;\n import org.mockito.internal.util.MockCreationValidator;\n import org.mockito.internal.util.MockUtil;\n-import org.mockito.internal.util.reflection.MockitoGenericMetadata;\n+import org.mockito.internal.util.reflection.GenericMetadataSupport;\n import org.mockito.invocation.InvocationOnMock;\n import org.mockito.stubbing.Answer;\n \n  * </code></pre>\n  * </p>\n  *\n- * @see Mockito#RETURNS_DEEP_STUBS\n+ * @see org.mockito.Mockito#RETURNS_DEEP_STUBS\n  * @see org.mockito.Answers#RETURNS_DEEP_STUBS\n  */\n @Incubating\n     private ReturnsEmptyValues delegate = new ReturnsEmptyValues();\n \n     public Object answer(InvocationOnMock invocation) throws Throwable {\n-        MockitoGenericMetadata returnTypeGenericMetadata =\n+        GenericMetadataSupport returnTypeGenericMetadata =\n                 actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());\n \n         Class<?> rawType = returnTypeGenericMetadata.rawType();\n         return getMock(invocation, returnTypeGenericMetadata);\n     }\n \n-    private Object getMock(InvocationOnMock invocation, MockitoGenericMetadata returnTypeGenericMetadata) throws Throwable {\n+    private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {\n     \tInternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\n     \tInvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();\n \n         return mock;\n     }\n \n-    private MockitoGenericMetadata actualParameterizedType(Object mock) {\n+    private GenericMetadataSupport actualParameterizedType(Object mock) {\n         CreationSettings mockSettings = (CreationSettings) new MockUtil().getMockHandler(mock).getMockSettings();\n         return mockSettings.getMockitoGenericMetadata();\n     }\n--- /dev/null\n+++ b/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.util.reflection;\n+\n+\n+import org.mockito.Incubating;\n+import org.mockito.MockSettings;\n+import org.mockito.Mockito;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.creation.MockSettingsImpl;\n+import org.mockito.internal.util.Checks;\n+import org.mockito.stubbing.Answer;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+\n+import static org.mockito.Mockito.withSettings;\n+\n+\n+/**\n+ * This class can retrieve generic meta-data that the compiler stores on classes\n+ * and accessible members.\n+ *\n+ * <p>\n+ *     The main idea of this code is to create a Map that will help to resolve return types.\n+ *     In order to actually work with nested generics, this map will have to be passed along new instances\n+ *     as a type context.\n+ * </p>\n+ *\n+ * <p>\n+ *     Hence :\n+ *     <ul>\n+ *         <li>the metadata is created using the {@link #from(Type)} method from a real\n+ *         Class or from a ParameterizedType, other types are not yet supported.</li>\n+ *\n+ *         <li>Then from this metadata, we can extract meta-data for a generic return type of a method, using\n+ *         {@link #resolveGenericReturnType(Method)}.</li>\n+ *\n+ *         <li>Finally as we want to mock the actual type, but we want to pass along the contextual generics meta-data\n+ *         we need to create the mock ourselves as we know how to create it, depending on the kind of Type (Class,\n+ *         ParameterizedType, TypeVariable), the method {@link #toMock(Answer)} assumes this responsibility.</li>\n+ *     </ul>\n+ * </p>\n+ *\n+ * <p>\n+ * For now this code support the following kind of generic declarations :\n+ * <pre class=\"code\"><code class=\"java\">\n+ * interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; {\n+ *     Set&lt;Number&gt; remove(Object key); // override with fixed ParameterizedType\n+ *     List&lt;? super Integer&gt; returning_wildcard_with_class_lower_bound();\n+ *     List&lt;? super K&gt; returning_wildcard_with_typeVar_lower_bound();\n+ *     List&lt;? extends K&gt; returning_wildcard_with_typeVar_upper_bound();\n+ *     K returningK();\n+ *     &lt;O extends K&gt; List&lt;O&gt; paramType_with_type_params();\n+ *     &lt;S, T extends S&gt; T two_type_params();\n+ *     &lt;O extends K&gt; O typeVar_with_type_params();\n+ *     Number returningNonGeneric();\n+ * }\n+ * </code></pre>\n+ *\n+ * @see #from(Type)\n+ * @see #resolveGenericReturnType(Method)\n+ * @see #toMock(Answer)\n+ * @see org.mockito.internal.stubbing.defaultanswers.ReturnsGenericDeepStubs\n+ */\n+@Incubating\n+public abstract class GenericMetadataSupport {\n+\n+    // public static MockitoLogger logger = new ConsoleMockitoLogger();\n+\n+    /**\n+     * Represents actual type variables resolved for current class.\n+     */\n+    protected Map<TypeVariable, Type> contextualActualTypeParameters = new HashMap<TypeVariable, Type>();\n+\n+\n+    protected void registerTypeVariablesOn(Type classType) {\n+        if (!(classType instanceof ParameterizedType)) {\n+            return;\n+        }\n+        ParameterizedType parameterizedType = (ParameterizedType) classType;\n+        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n+        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n+        for (int i = 0; i < actualTypeArguments.length; i++) {\n+            TypeVariable typeParameter = typeParameters[i];\n+            Type actualTypeArgument = actualTypeArguments[i];\n+\n+            if (actualTypeArgument instanceof WildcardType) {\n+                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n+            } else {\n+                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n+            }\n+            // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n+        }\n+    }\n+\n+    protected void registerTypeParametersOn(TypeVariable[] typeParameters) {\n+        for (TypeVariable typeParameter : typeParameters) {\n+            contextualActualTypeParameters.put(typeParameter, boundsOf(typeParameter));\n+            // logger.log(\"For '\" + typeParameter.getGenericDeclaration() + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + boundsOf(typeParameter) + \"' }\");\n+        }\n+    }\n+\n+    /**\n+     * @param typeParameter The TypeVariable parameter\n+     * @return A {@link BoundedType} for easy bound information, if first bound is a TypeVariable\n+     *         then retrieve BoundedType of this TypeVariable\n+     */\n+    private BoundedType boundsOf(TypeVariable typeParameter) {\n+        if (typeParameter.getBounds()[0] instanceof TypeVariable) {\n+            return boundsOf((TypeVariable) typeParameter.getBounds()[0]);\n+        }\n+        return new TypeVarBoundedType(typeParameter);\n+    }\n+\n+    /**\n+     * @param wildCard The WildCard type\n+     * @return A {@link BoundedType} for easy bound information, if first bound is a TypeVariable\n+     *         then retrieve BoundedType of this TypeVariable\n+     */\n+    private BoundedType boundsOf(WildcardType wildCard) {\n+        /*\n+         *  According to JLS(http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.5.1):\n+         *  - Lower and upper can't coexist: (for instance, this is not allowed: <? extends List<String> & super MyInterface>)\n+         *  - Multiple bounds are not supported (for instance, this is not allowed: <? extends List<String> & MyInterface>)\n+         */\n+\n+        WildCardBoundedType wildCardBoundedType = new WildCardBoundedType(wildCard);\n+        if (wildCardBoundedType.firstBound() instanceof TypeVariable) {\n+            return boundsOf((TypeVariable) wildCardBoundedType.firstBound());\n+        }\n+\n+        return wildCardBoundedType;\n+    }\n+\n+\n+\n+    /**\n+     * @return Raw type of the current instance.\n+     */\n+    public abstract Class<?> rawType();\n+\n+\n+\n+    /**\n+     * @return Returns extra interfaces if relevant, otherwise empty List.\n+     */\n+    public List<Type> extraInterfaces() {\n+        return Collections.emptyList();\n+    }\n+\n+\n+\n+    /**\n+     * @return Actual type arguments matching the type variables of the raw type represented by this {@link GenericMetadataSupport} instance.\n+     */\n+    public Map<TypeVariable, Type> actualTypeArguments() {\n+        TypeVariable[] typeParameters = rawType().getTypeParameters();\n+        LinkedHashMap<TypeVariable, Type> actualTypeArguments = new LinkedHashMap<TypeVariable, Type>();\n+\n+        for (TypeVariable typeParameter : typeParameters) {\n+\n+            Type actualType = getActualTypeArgumentFor(typeParameter);\n+\n+            actualTypeArguments.put(typeParameter, actualType);\n+            // logger.log(\"For '\" + rawType().getCanonicalName() + \"' returning explicit TypeVariable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualType +\"' }\");\n+        }\n+\n+        return actualTypeArguments;\n+    }\n+\n+    protected Type getActualTypeArgumentFor(TypeVariable typeParameter) {\n+        Type type = this.contextualActualTypeParameters.get(typeParameter);\n+        if (type instanceof TypeVariable) {\n+            TypeVariable typeVariable = (TypeVariable) type;\n+            return getActualTypeArgumentFor(typeVariable);\n+        }\n+\n+        return type;\n+    }\n+\n+\n+\n+    /**\n+     * Creates a mock using the Generics Metadata represented by this instance.\n+     *\n+     * @param answer The answer to use in mock settings.\n+     * @return The mock or null if not mockable.\n+     */\n+    public Object toMock(Answer answer) {\n+        return createMock(rawType(), ((MockSettingsImpl) withSettings().defaultAnswer(answer)).parameterizedInfo(this));\n+    }\n+\n+    private Object createMock(Class<?> rawType, MockSettings mockSettings) {\n+        return Mockito.mock(rawType, mockSettings);\n+    }\n+\n+\n+    /**\n+     * Resolve current method generic return type to a {@link GenericMetadataSupport}.\n+     *\n+     * @param method Method to resolve the return type.\n+     * @return {@link GenericMetadataSupport} representing this generic return type.\n+     */\n+    public GenericMetadataSupport resolveGenericReturnType(Method method) {\n+        Type genericReturnType = method.getGenericReturnType();\n+        // logger.log(\"Method '\" + method.toGenericString() + \"' has return type : \" + genericReturnType.getClass().getInterfaces()[0].getSimpleName() + \" : \" + genericReturnType);\n+\n+        if (genericReturnType instanceof Class) {\n+            return new NotGenericReturnTypeSupport(genericReturnType);\n+        }\n+        if (genericReturnType instanceof ParameterizedType) {\n+            return new ParameterizedReturnType(this, method.getTypeParameters(), (ParameterizedType) method.getGenericReturnType());\n+        }\n+        if (genericReturnType instanceof TypeVariable) {\n+            return new TypeVariableReturnType(this, method.getTypeParameters(), (TypeVariable) genericReturnType);\n+        }\n+\n+        throw new MockitoException(\"Ouch, it shouldn't happen, type '\" + genericReturnType.getClass().getCanonicalName() + \"' on method : '\" + method.toGenericString() + \"' is not supported : \" + genericReturnType);\n+    }\n+\n+    /**\n+     * Create an new GenericMetadataSupport from a {@link Type}.\n+     *\n+     * <p>\n+     *     Supports only {@link Class} and {@link ParameterizedType}, otherwise throw a {@link MockitoException}.\n+     * </p>\n+     *\n+     * @param type The class from which the {@link GenericMetadataSupport} should be built.\n+     * @return The new {@link GenericMetadataSupport}.\n+     * @throws MockitoException Raised if type is not a {@link Class} or a {@link ParameterizedType}.\n+     */\n+    public static GenericMetadataSupport from(Type type) {\n+        Checks.checkNotNull(type, \"type\");\n+        if (type instanceof Class) {\n+            return new FromClassGenericMetadataSupport((Class<?>) type);\n+        }\n+        if (type instanceof ParameterizedType) {\n+            return new FromParameterizedTypeGenericMetadataSupport((ParameterizedType) type);\n+        }\n+\n+        throw new MockitoException(\"Type meta-data for this Type (\" + type.getClass().getCanonicalName() + \") is not supported : \" + type);\n+    }\n+\n+\n+    /**\n+     * Metadata for source {@link Class}\n+     */\n+    private static class FromClassGenericMetadataSupport extends GenericMetadataSupport {\n+        private Class<?> clazz;\n+\n+        public FromClassGenericMetadataSupport(Class<?> clazz) {\n+            this.clazz = clazz;\n+            readActualTypeParametersOnDeclaringClass();\n+        }\n+\n+        private void readActualTypeParametersOnDeclaringClass() {\n+            registerTypeParametersOn(clazz.getTypeParameters());\n+            registerTypeVariablesOn(clazz.getGenericSuperclass());\n+            for (Type genericInterface : clazz.getGenericInterfaces()) {\n+                registerTypeVariablesOn(genericInterface);\n+            }\n+        }\n+\n+        @Override\n+        public Class<?> rawType() {\n+            return clazz;\n+        }\n+    }\n+\n+\n+    /**\n+     * Metadata for source {@link ParameterizedType}.\n+     * Don't work with ParameterizedType returned in {@link Method#getGenericReturnType()}.\n+     */\n+    private static class FromParameterizedTypeGenericMetadataSupport extends GenericMetadataSupport {\n+        private ParameterizedType parameterizedType;\n+\n+        public FromParameterizedTypeGenericMetadataSupport(ParameterizedType parameterizedType) {\n+            this.parameterizedType = parameterizedType;\n+            readActualTypeParameters();\n+        }\n+\n+        private void readActualTypeParameters() {\n+            registerTypeVariablesOn(parameterizedType.getRawType());\n+            registerTypeVariablesOn(parameterizedType);\n+        }\n+\n+        @Override\n+        public Class<?> rawType() {\n+            return (Class<?>) parameterizedType.getRawType();\n+        }\n+    }\n+\n+\n+    /**\n+     * Metadata specific to {@link ParameterizedType} generic return types.\n+     */\n+    private static class ParameterizedReturnType extends GenericMetadataSupport {\n+        private final ParameterizedType parameterizedType;\n+        private final TypeVariable[] typeParameters;\n+\n+        public ParameterizedReturnType(GenericMetadataSupport source, TypeVariable[] typeParameters, ParameterizedType parameterizedType) {\n+            this.parameterizedType = parameterizedType;\n+            this.typeParameters = typeParameters;\n+            this.contextualActualTypeParameters = source.contextualActualTypeParameters;\n+\n+            readTypeParameters();\n+            readTypeVariables();\n+        }\n+\n+        private void readTypeParameters() {\n+            registerTypeParametersOn(typeParameters);\n+        }\n+\n+        private void readTypeVariables() {\n+            registerTypeVariablesOn(parameterizedType);\n+        }\n+\n+        @Override\n+        public Class<?> rawType() {\n+            return (Class<?>) parameterizedType.getRawType();\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Metadata specific to {@link TypeVariable} generic return type.\n+     */\n+    private static class TypeVariableReturnType extends GenericMetadataSupport {\n+        private final TypeVariable typeVariable;\n+        private final TypeVariable[] typeParameters;\n+        private Class<?> rawType;\n+\n+\n+\n+        public TypeVariableReturnType(GenericMetadataSupport source, TypeVariable[] typeParameters, TypeVariable typeVariable) {\n+            this.typeParameters = typeParameters;\n+            this.typeVariable = typeVariable;\n+            this.contextualActualTypeParameters = source.contextualActualTypeParameters;\n+\n+            readTypeParameters();\n+            readTypeVariables();\n+        }\n+\n+        private void readTypeParameters() {\n+            registerTypeParametersOn(typeParameters);\n+        }\n+\n+        private void readTypeVariables() {\n+            for (Type type : typeVariable.getBounds()) {\n+                registerTypeVariablesOn(type);\n+            }\n+            registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n+        }\n+\n+        @Override\n+        public Class<?> rawType() {\n+            if (rawType == null) {\n+                rawType = extractRawTypeOf(typeVariable);\n+            }\n+            return rawType;\n+        }\n+\n+        private Class<?> extractRawTypeOf(Type type) {\n+            if (type instanceof Class) {\n+                return (Class<?>) type;\n+            }\n+            if (type instanceof ParameterizedType) {\n+                return (Class<?>) ((ParameterizedType) type).getRawType();\n+            }\n+            if (type instanceof BoundedType) {\n+                return extractRawTypeOf(((BoundedType) type).firstBound());\n+            }\n+            if (type instanceof TypeVariable) {\n+                /*\n+                 * If type is a TypeVariable, then it is needed to gather data elsewhere. Usually TypeVariables are declared\n+                 * on the class definition, such as such as List<E>.\n+                 */\n+                return extractRawTypeOf(contextualActualTypeParameters.get(type));\n+            }\n+            throw new MockitoException(\"Raw extraction not supported for : '\" + type + \"'\");\n+        }\n+\n+        @Override\n+        public List<Type> extraInterfaces() {\n+            Type type = extractActualBoundedTypeOf(typeVariable);\n+            if (type instanceof BoundedType) {\n+                return Arrays.asList(((BoundedType) type).interfaceBounds());\n+            }\n+            if (type instanceof ParameterizedType) {\n+                return Collections.singletonList(type);\n+            }\n+            if (type instanceof Class) {\n+                return Collections.emptyList();\n+            }\n+            throw new MockitoException(\"Cannot extract extra-interfaces from '\" + typeVariable + \"' : '\" + type + \"'\");\n+        }\n+\n+        private Class<?>[] rawExtraInterfaces() {\n+            List<Type> extraInterfaces = extraInterfaces();\n+            List<Class<?>> rawExtraInterfaces = new ArrayList<Class<?>>();\n+            for (Type extraInterface : extraInterfaces) {\n+                Class<?> rawInterface = extractRawTypeOf(extraInterface);\n+                // avoid interface collision with actual raw type (with typevariables, resolution ca be quite aggressive)\n+                if(!rawType().equals(rawInterface)) {\n+                    rawExtraInterfaces.add(rawInterface);\n+                }\n+            }\n+            return rawExtraInterfaces.toArray(new Class[rawExtraInterfaces.size()]);\n+        }\n+\n+        private Type extractActualBoundedTypeOf(Type type) {\n+            if (type instanceof TypeVariable) {\n+                /*\n+                If type is a TypeVariable, then it is needed to gather data elsewhere. Usually TypeVariables are declared\n+                on the class definition, such as such as List<E>.\n+                */\n+                return extractActualBoundedTypeOf(contextualActualTypeParameters.get(type));\n+            }\n+            if (type instanceof BoundedType) {\n+                Type actualFirstBound = extractActualBoundedTypeOf(((BoundedType) type).firstBound());\n+                if (!(actualFirstBound instanceof BoundedType)) {\n+                    return type; // avoid going one step further, ie avoid : O(TypeVar) -> K(TypeVar) -> Some ParamType\n+                }\n+                return actualFirstBound;\n+            }\n+            return type; // irrelevant, we don't manage other types.\n+        }\n+\n+        public Object toMock(Answer answer) {\n+            Class<?>[] rawExtraInterfaces = rawExtraInterfaces();\n+            if (rawExtraInterfaces.length <= 0) {\n+                return super.toMock(answer);\n+            }\n+\n+            return super.createMock(\n+                    rawType(),\n+                    ((MockSettingsImpl) withSettings()\n+                            .defaultAnswer(answer)\n+                            .extraInterfaces(rawExtraInterfaces))\n+                            .parameterizedInfo(this)\n+            );\n+        }\n+    }\n+\n+\n+\n+    /**\n+     * Metadata specific to {@link Class} return type.\n+     */\n+    private static class NotGenericReturnTypeSupport extends GenericMetadataSupport {\n+        private final Class<?> returnType;\n+\n+        public NotGenericReturnTypeSupport(Type genericReturnType) {\n+            returnType = (Class<?>) genericReturnType;\n+        }\n+\n+        @Override\n+        public Class<?> rawType() {\n+            return returnType;\n+        }\n+    }\n+\n+\n+\n+    /**\n+     * Type representing bounds of a type\n+     *\n+     * @see TypeVarBoundedType\n+     * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>\n+     * @see WildCardBoundedType\n+     * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.5.1\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.5.1</a>\n+     */\n+    public static interface BoundedType extends Type {\n+        Type firstBound();\n+\n+        Type[] interfaceBounds();\n+    }\n+\n+    /**\n+     * Type representing bounds of a type variable, allows to keep all bounds information.\n+     *\n+     * <p>It uses the first bound in the array, as this array is never null and always contains at least\n+     * one element (Object is always here if no bounds are declared).</p>\n+     *\n+     * <p>If upper bounds are declared with SomeClass and additional interfaces, then firstBound will be SomeClass and\n+     * interfacesBound will be an array of the additional interfaces.\n+     *\n+     * i.e. <code>SomeClass</code>.\n+     * <pre class=\"code\"><code class=\"java\">\n+     *     interface UpperBoundedTypeWithClass<E extends Comparable<E> & Cloneable> {\n+     *         E get();\n+     *     }\n+     *     // will return Comparable type\n+     * </code></pre>\n+     * </p>\n+     *\n+     * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>\n+     */\n+    public static class TypeVarBoundedType implements BoundedType {\n+        private TypeVariable typeVariable;\n+\n+\n+        public TypeVarBoundedType(TypeVariable typeVariable) {\n+            this.typeVariable = typeVariable;\n+        }\n+\n+        /**\n+         * @return either a class or an interface (parameterized or not), if no bounds declared Object is returned.\n+         */\n+        public Type firstBound() {\n+            return typeVariable.getBounds()[0]; //\n+        }\n+\n+        /**\n+         * On a Type Variable (typeVar extends C_0 & I_1 & I_2 & etc), will return an array\n+         * containing I_1 and I_2.\n+         *\n+         * @return other bounds for this type, these bounds can only be only interfaces as the JLS says,\n+         * empty array if no other bound declared.\n+         */\n+        public Type[] interfaceBounds() {\n+            Type[] interfaceBounds = new Type[typeVariable.getBounds().length - 1];\n+            System.arraycopy(typeVariable.getBounds(), 1, interfaceBounds, 0, typeVariable.getBounds().length - 1);\n+            return interfaceBounds;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+\n+            return typeVariable.equals(((TypeVarBoundedType) o).typeVariable);\n+\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return typeVariable.hashCode();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final StringBuilder sb = new StringBuilder();\n+            sb.append(\"{firstBound=\").append(firstBound());\n+            sb.append(\", interfaceBounds=\").append(Arrays.deepToString(interfaceBounds()));\n+            sb.append('}');\n+            return sb.toString();\n+        }\n+\n+        public TypeVariable typeVariable() {\n+            return typeVariable;\n+        }\n+    }\n+\n+    /**\n+     * Type representing bounds of a wildcard, allows to keep all bounds information.\n+     *\n+     * <p>The JLS says that lower bound and upper bound are mutually exclusive, and that multiple bounds\n+     * are not allowed.\n+     *\n+     * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>\n+     */\n+    public static class WildCardBoundedType implements BoundedType {\n+        private WildcardType wildcard;\n+\n+\n+        public WildCardBoundedType(WildcardType wildcard) {\n+            this.wildcard = wildcard;\n+        }\n+\n+        /**\n+         * @return The first bound, either a type or a reference to a TypeVariable\n+         */\n+        public Type firstBound() {\n+            Type[] lowerBounds = wildcard.getLowerBounds();\n+            Type[] upperBounds = wildcard.getUpperBounds();\n+\n+            return lowerBounds.length != 0 ? lowerBounds[0] : upperBounds[0];\n+        }\n+\n+        /**\n+         * @return An empty array as, wildcard don't support multiple bounds.\n+         */\n+        public Type[] interfaceBounds() {\n+            return new Type[0];\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+\n+            return wildcard.equals(((TypeVarBoundedType) o).typeVariable);\n+\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return wildcard.hashCode();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final StringBuilder sb = new StringBuilder();\n+            sb.append(\"{firstBound=\").append(firstBound());\n+            sb.append(\", interfaceBounds=[]}\");\n+            return sb.toString();\n+        }\n+\n+        public WildcardType wildCard() {\n+            return wildcard;\n+        }\n+    }\n+\n+}\n+\n+\n--- /dev/null\n+++ b/test/org/mockito/internal/util/reflection/GenericMetadataSupportTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.util.reflection;\n+\n+import org.junit.Test;\n+import org.mockito.exceptions.base.MockitoException;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.RETURNS_DEFAULTS;\n+import static org.mockito.internal.util.reflection.GenericMetadataSupport.from;\n+\n+@SuppressWarnings(\"unused\")\n+public class GenericMetadataSupportTest {\n+\n+    interface UpperBoundedTypeWithClass<E extends Number & Comparable<E>> {\n+        E get();\n+    }\n+    interface UpperBoundedTypeWithInterfaces<E extends Comparable<E> & Cloneable> {\n+        E get();\n+    }\n+    interface ListOfNumbers extends List<Number> {}\n+    interface ListOfAnyNumbers<N extends Number & Cloneable> extends List<N> {}\n+\n+    interface GenericsNest<K extends Comparable<K> & Cloneable> extends Map<K, Set<Number>> {\n+        Set<Number> remove(Object key); // override with fixed ParameterizedType\n+        List<? super Integer> returning_wildcard_with_class_lower_bound();\n+        List<? super K> returning_wildcard_with_typeVar_lower_bound();\n+        List<? extends K> returning_wildcard_with_typeVar_upper_bound();\n+        K returningK();\n+        <O extends K> List<O> paramType_with_type_params();\n+        <S, T extends S> T two_type_params();\n+        <O extends K> O typeVar_with_type_params();\n+    }\n+\n+    @Test\n+    public void can_get_raw_type_from_Class() throws Exception {\n+        assertThat(from(ListOfAnyNumbers.class).rawType()).isEqualTo(ListOfAnyNumbers.class);\n+        assertThat(from(ListOfNumbers.class).rawType()).isEqualTo(ListOfNumbers.class);\n+        assertThat(from(GenericsNest.class).rawType()).isEqualTo(GenericsNest.class);\n+    }\n+\n+\n+    @Test\n+    public void can_get_raw_type_from_ParameterizedType() throws Exception {\n+        assertThat(from(ListOfAnyNumbers.class.getGenericInterfaces()[0]).rawType()).isEqualTo(List.class);\n+        assertThat(from(ListOfNumbers.class.getGenericInterfaces()[0]).rawType()).isEqualTo(List.class);\n+        assertThat(from(GenericsNest.class.getGenericInterfaces()[0]).rawType()).isEqualTo(Map.class);\n+    }\n+\n+    @Test\n+    public void can_get_type_variables_from_Class() throws Exception {\n+        assertThat(from(GenericsNest.class).actualTypeArguments().keySet()).hasSize(1).onProperty(\"name\").contains(\"K\");\n+        assertThat(from(ListOfNumbers.class).actualTypeArguments().keySet()).isEmpty();\n+        assertThat(from(ListOfAnyNumbers.class).actualTypeArguments().keySet()).hasSize(1).onProperty(\"name\").contains(\"N\");\n+        assertThat(from(Map.class).actualTypeArguments().keySet()).hasSize(2).onProperty(\"name\").contains(\"K\", \"V\");\n+        assertThat(from(Serializable.class).actualTypeArguments().keySet()).isEmpty();\n+    }\n+\n+    @Test\n+    public void can_get_type_variables_from_ParameterizedType() throws Exception {\n+        assertThat(from(GenericsNest.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(2).onProperty(\"name\").contains(\"K\", \"V\");\n+        assertThat(from(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).onProperty(\"name\").contains(\"E\");\n+        assertThat(from(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).onProperty(\"name\").contains(\"T\");\n+        assertThat(from(StringBuilder.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).isEmpty();\n+    }\n+\n+    @Test\n+    public void typeVariable_return_type_of____get____resolved_to_Set_and_type_argument_to_Number() throws Exception {\n+        GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"get\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(Set.class);\n+        assertThat(genericMetadata.actualTypeArguments().values()).contains(Number.class);\n+    }\n+\n+    @Test\n+    public void bounded_typeVariable_return_type_of____returningK____resolved_to_Comparable_and_with_BoundedType() throws Exception {\n+        GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returningK\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(Comparable.class);\n+        GenericMetadataSupport extraInterface_0 = from(genericMetadata.extraInterfaces().get(0));\n+        assertThat(extraInterface_0.rawType()).isEqualTo(Cloneable.class);\n+    }\n+\n+    @Test\n+    public void fixed_ParamType_return_type_of____remove____resolved_to_Set_and_type_argument_to_Number() throws Exception {\n+        GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"remove\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(Set.class);\n+        assertThat(genericMetadata.actualTypeArguments().values()).contains(Number.class);\n+    }\n+\n+    @Test\n+    public void paramType_return_type_of____values____resolved_to_Collection_and_type_argument_to_Parameterized_Set() throws Exception {\n+        GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"values\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(Collection.class);\n+        GenericMetadataSupport fromTypeVariableE = from(typeVariableValue(genericMetadata.actualTypeArguments(), \"E\"));\n+        assertThat(fromTypeVariableE.rawType()).isEqualTo(Set.class);\n+        assertThat(fromTypeVariableE.actualTypeArguments().values()).contains(Number.class);\n+    }\n+\n+    @Test\n+    public void paramType_with_type_parameters_return_type_of____paramType_with_type_params____resolved_to_Collection_and_type_argument_to_Parameterized_Set() throws Exception {\n+        GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"paramType_with_type_params\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(List.class);\n+        Type firstBoundOfE = ((GenericMetadataSupport.TypeVarBoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), \"E\")).firstBound();\n+        assertThat(from(firstBoundOfE).rawType()).isEqualTo(Comparable.class);\n+    }\n+\n+    @Test\n+    public void typeVariable_with_type_parameters_return_type_of____typeVar_with_type_params____resolved_K_hence_to_Comparable_and_with_BoundedType() throws Exception {\n+        GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"typeVar_with_type_params\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(Comparable.class);\n+        GenericMetadataSupport extraInterface_0 = from(genericMetadata.extraInterfaces().get(0));\n+        assertThat(extraInterface_0.rawType()).isEqualTo(Cloneable.class);\n+    }\n+\n+    @Test\n+    public void class_return_type_of____append____resolved_to_StringBuilder_and_type_arguments() throws Exception {\n+        GenericMetadataSupport genericMetadata = from(StringBuilder.class).resolveGenericReturnType(firstNamedMethod(\"append\", StringBuilder.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(StringBuilder.class);\n+        assertThat(genericMetadata.actualTypeArguments()).isEmpty();\n+    }\n+\n+\n+\n+    @Test\n+    public void paramType_with_wildcard_return_type_of____returning_wildcard_with_class_lower_bound____resolved_to_List_and_type_argument_to_Integer() throws Exception {\n+        GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returning_wildcard_with_class_lower_bound\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(List.class);\n+        GenericMetadataSupport.BoundedType boundedType = (GenericMetadataSupport.BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), \"E\");\n+        assertThat(boundedType.firstBound()).isEqualTo(Integer.class);\n+        assertThat(boundedType.interfaceBounds()).isEmpty();\n+    }\n+\n+    @Test\n+    public void paramType_with_wildcard_return_type_of____returning_wildcard_with_typeVar_lower_bound____resolved_to_List_and_type_argument_to_Integer() throws Exception {\n+        GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returning_wildcard_with_typeVar_lower_bound\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(List.class);\n+        GenericMetadataSupport.BoundedType boundedType = (GenericMetadataSupport.BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), \"E\");\n+\n+        assertThat(from(boundedType.firstBound()).rawType()).isEqualTo(Comparable.class);\n+        assertThat(boundedType.interfaceBounds()).contains(Cloneable.class);    }\n+\n+    @Test\n+    public void paramType_with_wildcard_return_type_of____returning_wildcard_with_typeVar_upper_bound____resolved_to_List_and_type_argument_to_Integer() throws Exception {\n+        GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returning_wildcard_with_typeVar_upper_bound\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(List.class);\n+        GenericMetadataSupport.BoundedType boundedType = (GenericMetadataSupport.BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), \"E\");\n+\n+        assertThat(from(boundedType.firstBound()).rawType()).isEqualTo(Comparable.class);\n+        assertThat(boundedType.interfaceBounds()).contains(Cloneable.class);\n+    }\n+\n+\n+\n+\n+    @Test(expected = MockitoException.class)\n+    public void toMock_propagate_MockitoException_if_type_unmockable() throws Exception {\n+        GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returning_wildcard_with_class_lower_bound\", GenericsNest.class));\n+\n+        GenericMetadataSupport.BoundedType boundedType = (GenericMetadataSupport.BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), \"E\");\n+\n+        from(boundedType.firstBound()).toMock(RETURNS_DEFAULTS);\n+    }\n+\n+    @Test\n+    public void toMock_returns_mock_of_correct_type() throws Exception {\n+        GenericMetadataSupport genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returningK\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.toMock(RETURNS_DEFAULTS)).isInstanceOf(Comparable.class);\n+        assertThat(genericMetadata.toMock(RETURNS_DEFAULTS)).isInstanceOf(Cloneable.class);\n+    }\n+\n+\n+    private Type typeVariableValue(Map<TypeVariable, Type> typeVariables, String typeVariableName) {\n+        for (Map.Entry<TypeVariable, Type> typeVariableTypeEntry : typeVariables.entrySet()) {\n+            if (typeVariableTypeEntry.getKey().getName().equals(typeVariableName)) {\n+                return typeVariableTypeEntry.getValue();\n+            }\n+        }\n+\n+        fail(\"'\" + typeVariableName + \"' was not found in \" + typeVariables);\n+        return null; // unreachable\n+    }\n+\n+    private Method firstNamedMethod(String methodName, Class<?> clazz) {\n+        for (Method method : clazz.getMethods()) {\n+            if (method.getName().contains(methodName)) {\n+                return method;\n+            }\n+        }\n+        throw new IllegalStateException(\"The method : '\" + methodName + \"' do not exist in '\" + clazz.getSimpleName() + \"'\");\n+    }\n+\n+\n+}", "timestamp": 1343833949, "metainfo": ""}