{"sha": "96283c6fbf9f6eb7293e44392e94011973f29842", "log": "Merge pull request #36 from kamilszymanski/inner_classes", "commit": "\n--- a/src/org/mockito/internal/invocation/InvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/InvocationsFinder.java\n         return unverified;\n     }\n     \n-    private class RemoveNotMatching implements Filter<Invocation> {\n+    private static class RemoveNotMatching implements Filter<Invocation> {\n         private final InvocationMatcher wanted;\n \n         private RemoveNotMatching(InvocationMatcher wanted) {\n         }\n     }\n \n-    private class RemoveUnverifiedInOrder implements Filter<Invocation> {\n+    private static class RemoveUnverifiedInOrder implements Filter<Invocation> {\n         private final InOrderContext orderingContext;\n \n         public RemoveUnverifiedInOrder(InOrderContext orderingContext) {\n--- a/src/org/mockito/internal/invocation/finder/AllInvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/finder/AllInvocationsFinder.java\n         return new LinkedList<Invocation>(invocationsInOrder);\n     }\n \n-    private final class SequenceNumberComparator implements Comparator<Invocation> {\n+    private static final class SequenceNumberComparator implements Comparator<Invocation> {\n         public int compare(Invocation o1, Invocation o2) {\n             return Integer.valueOf(o1.getSequenceNumber()).compareTo(o2.getSequenceNumber());\n         }\n--- a/src/org/mockito/internal/invocation/finder/VerifiableInvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/finder/VerifiableInvocationsFinder.java\n package org.mockito.internal.invocation.finder;\n \n import org.mockito.internal.util.collections.ListUtil;\n+import org.mockito.internal.util.collections.ListUtil.Filter;\n import org.mockito.invocation.Invocation;\n \n import java.util.List;\n         return ListUtil.filter(invocations, new RemoveIgnoredForVerification());\n     }\n \n-    static class RemoveIgnoredForVerification implements ListUtil.Filter<Invocation>{\n-        public boolean isOut(Invocation i) {\n-            return i.isIgnoredForVerification();\n+    private static class RemoveIgnoredForVerification implements Filter<Invocation>{\n+        public boolean isOut(Invocation invocation) {\n+            return invocation.isIgnoredForVerification();\n         }\n     }\n }\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n  */\n package org.mockito.internal.stubbing.defaultanswers;\n \n-import static org.mockito.Mockito.*;\n+import static org.mockito.Mockito.withSettings;\n \n+import java.io.IOException;\n import java.io.Serializable;\n-\n import org.mockito.MockSettings;\n+import org.mockito.Mockito;\n import org.mockito.internal.InternalMockHandler;\n import org.mockito.internal.MockitoCore;\n import org.mockito.internal.creation.settings.CreationSettings;\n     \n     private static final long serialVersionUID = -7105341425736035847L;\n \n-    private transient MockitoCore mockitoCore;\n-    private transient ReturnsEmptyValues delegate;\n-\n     public Object answer(InvocationOnMock invocation) throws Throwable {\n         GenericMetadataSupport returnTypeGenericMetadata =\n                 actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());\n \n         Class<?> rawType = returnTypeGenericMetadata.rawType();\n-        instantiateMockitoCoreIfNeeded();\n-        instantiateDelegateIfNeeded();\n-        if (!mockitoCore.isTypeMockable(rawType)) {\n-            return delegate.returnValueFor(rawType);\n+        if (!mockitoCore().isTypeMockable(rawType)) {\n+            return delegate().returnValueFor(rawType);\n         }\n \n-        return getMock(invocation, returnTypeGenericMetadata);\n+        return deepStub(invocation, returnTypeGenericMetadata);\n     }\n \n-    private synchronized void instantiateMockitoCoreIfNeeded() {\n-        if (mockitoCore == null) {\n-            mockitoCore = new MockitoCore();\n-        }\n-    }\n-\n-    private synchronized void instantiateDelegateIfNeeded() {\n-        if (delegate == null) {\n-            delegate = new ReturnsEmptyValues();\n-        }\n-    }\n-\n-    private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {\n+    private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {\n     \tInternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\n     \tInvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();\n \n     \t\t}\n \t\t}\n \n-        // deep stub\n-        return recordDeepStubMock(createNewDeepStubMock(returnTypeGenericMetadata), container);\n+        // record deep stub answer\n+        return recordDeepStubAnswer(newDeepStubMock(returnTypeGenericMetadata), container);\n     }\n \n     /**\n      * @param returnTypeGenericMetadata The metadata to use to create the new mock.\n      * @return The mock\n      */\n-    private Object createNewDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {\n-        return mockitoCore.mock(\n+    private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {\n+        return mockitoCore().mock(\n                 returnTypeGenericMetadata.rawType(),\n                 withSettingsUsing(returnTypeGenericMetadata)\n         );\n     }\n \n     private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {\n-        MockSettings mockSettings =\n-                returnTypeGenericMetadata.rawExtraInterfaces().length > 0 ?\n+        MockSettings mockSettings = returnTypeGenericMetadata.hasRawExtraInterfaces() ?\n                 withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())\n                 : withSettings();\n \n     }\n \n     private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {\n-        return new ReturnsDeepStubs() {\n-            @Override\n-            protected GenericMetadataSupport actualParameterizedType(Object mock) {\n-                return returnTypeGenericMetadata;\n-            }\n-        };\n+        return new ReturnsDeepStubsSerializationFallback(returnTypeGenericMetadata);\n     }\n \n-    private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {\n-\n-        container.addAnswer(new SerializableAnswer() {\n-            public Object answer(InvocationOnMock invocation) throws Throwable {\n-                return mock;\n-            }\n-        }, false);\n-\n+    private Object recordDeepStubAnswer(final Object mock, InvocationContainerImpl container) throws Throwable {\n+        container.addAnswer(new DeeplyStubbedAnswer(mock), false);\n         return mock;\n     }\n-\t\n-\tabstract class SerializableAnswer implements Answer<Object>, Serializable {\n-\t\t\n-\t}\n-\t\n \n     protected GenericMetadataSupport actualParameterizedType(Object mock) {\n         CreationSettings mockSettings = (CreationSettings) new MockUtil().getMockHandler(mock).getMockSettings();\n         return GenericMetadataSupport.inferFrom(mockSettings.getTypeToMock());\n     }\n+\n+\n+    private static class ReturnsDeepStubsSerializationFallback extends ReturnsDeepStubs implements Serializable {\n+        @SuppressWarnings(\"serial\") // not gonna be serialized\n+        private final GenericMetadataSupport returnTypeGenericMetadata;\n+\n+        public ReturnsDeepStubsSerializationFallback(GenericMetadataSupport returnTypeGenericMetadata) {\n+            this.returnTypeGenericMetadata = returnTypeGenericMetadata;\n+        }\n+\n+        @Override\n+        protected GenericMetadataSupport actualParameterizedType(Object mock) {\n+            return returnTypeGenericMetadata;\n+        }\n+        private Object writeReplace() throws IOException {\n+            return Mockito.RETURNS_DEEP_STUBS;\n+        }\n+    }\n+\n+\n+    private static class DeeplyStubbedAnswer implements Answer<Object>, Serializable {\n+        @SuppressWarnings(\"serial\") // serialization will fail with a nice message if mock not serializable\n+        private Object mock;\n+\n+        DeeplyStubbedAnswer(Object mock) {\n+            this.mock = mock;\n+        }\n+        @Override\n+        public Object answer(InvocationOnMock invocation) throws Throwable {\n+            return mock;\n+        }\n+    }\n+\n+\n+    private static MockitoCore mockitoCore() {\n+        return LazyHolder.MOCKITO_CORE;\n+    }\n+\n+    private static ReturnsEmptyValues delegate() {\n+        return LazyHolder.DELEGATE;\n+    }\n+\n+    private static class LazyHolder {\n+        private static final MockitoCore MOCKITO_CORE = new MockitoCore();\n+        private static final ReturnsEmptyValues DELEGATE = new ReturnsEmptyValues();\n+    }\n }\n--- a/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n+++ b/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n package org.mockito.internal.util.reflection;\n \n \n+import java.lang.reflect.Method;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.lang.reflect.WildcardType;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n import org.mockito.Incubating;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.util.Checks;\n-\n-import java.io.Serializable;\n-import java.lang.reflect.*;\n-import java.util.*;\n \n \n /**\n  * @see org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs\n  */\n @Incubating\n-public abstract class GenericMetadataSupport implements Serializable {\n+public abstract class GenericMetadataSupport {\n \n     // public static MockitoLogger logger = new ConsoleMockitoLogger();\n \n     }\n \n     protected void registerTypeParametersOn(TypeVariable[] typeParameters) {\n-        for (TypeVariable typeParameter : typeParameters) {\n-            contextualActualTypeParameters.put(typeParameter, boundsOf(typeParameter));\n-            // logger.log(\"For '\" + typeParameter.getGenericDeclaration() + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + boundsOf(typeParameter) + \"' }\");\n+        for (TypeVariable typeVariable : typeParameters) {\n+            registerTypeVariableIfNotPresent(typeVariable);\n+        }\n+    }\n+\n+    private void registerTypeVariableIfNotPresent(TypeVariable typeVariable) {\n+        if (!contextualActualTypeParameters.containsKey(typeVariable)) {\n+            contextualActualTypeParameters.put(typeVariable, boundsOf(typeVariable));\n+            // logger.log(\"For '\" + typeVariable.getGenericDeclaration() + \"' found type variable : { '\" + typeVariable + \"(\" + System.identityHashCode(typeVariable) + \")\" + \"' : '\" + boundsOf(typeVariable) + \"' }\");\n         }\n     }\n \n         return new Class[0];\n     }\n \n+    /**\n+     * @return Returns true if metadata knows about extra-interfaces {@link #extraInterfaces()} <strong>if relevant</strong>.\n+     */\n+    public boolean hasRawExtraInterfaces() {\n+        return rawExtraInterfaces().length > 0;\n+    }\n+\n \n \n     /**\n      * the class and its ancestors and interfaces.\n      */\n     private static class FromClassGenericMetadataSupport extends GenericMetadataSupport {\n-        private Class<?> clazz;\n+        private final Class<?> clazz;\n \n         public FromClassGenericMetadataSupport(Class<?> clazz) {\n             this.clazz = clazz;\n-            readActualTypeParametersOnDeclaringClass();\n-        }\n-\n-        private void readActualTypeParametersOnDeclaringClass() {\n+\n+            for (Class currentExploredClass = clazz;\n+                 currentExploredClass != null && currentExploredClass != Object.class;\n+                 currentExploredClass = superClassOf(currentExploredClass)\n+                ) {\n+                readActualTypeParametersOnDeclaringClass(currentExploredClass);\n+            }\n+        }\n+\n+        private Class superClassOf(Class currentExploredClass) {\n+            Type genericSuperclass = currentExploredClass.getGenericSuperclass();\n+            if (genericSuperclass instanceof ParameterizedType) {\n+                Type rawType = ((ParameterizedType) genericSuperclass).getRawType();\n+                return (Class) rawType;\n+            }\n+            return (Class) genericSuperclass;\n+        }\n+\n+        private void readActualTypeParametersOnDeclaringClass(Class<?> clazz) {\n             registerTypeParametersOn(clazz.getTypeParameters());\n             registerTypeVariablesOn(clazz.getGenericSuperclass());\n             for (Type genericInterface : clazz.getGenericInterfaces()) {\n      * Instead use {@link ParameterizedReturnType}.\n      */\n     private static class FromParameterizedTypeGenericMetadataSupport extends GenericMetadataSupport {\n-        private ParameterizedType parameterizedType;\n+        private final ParameterizedType parameterizedType;\n \n         public FromParameterizedTypeGenericMetadataSupport(ParameterizedType parameterizedType) {\n             this.parameterizedType = parameterizedType;\n      * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>\n      */\n     public static class TypeVarBoundedType implements BoundedType {\n-        private TypeVariable typeVariable;\n+        private final TypeVariable typeVariable;\n \n \n         public TypeVarBoundedType(TypeVariable typeVariable) {\n \n         @Override\n         public String toString() {\n-            final StringBuilder sb = new StringBuilder();\n-            sb.append(\"{firstBound=\").append(firstBound());\n-            sb.append(\", interfaceBounds=\").append(Arrays.deepToString(interfaceBounds()));\n-            sb.append('}');\n-            return sb.toString();\n+            return \"{firstBound=\" + firstBound() + \", interfaceBounds=\" + Arrays.deepToString(interfaceBounds()) + '}';\n         }\n \n         public TypeVariable typeVariable() {\n      *\n      * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>\n      */\n-    public static class WildCardBoundedType implements BoundedType, Serializable {\n-        private WildcardType wildcard;\n+    public static class WildCardBoundedType implements BoundedType {\n+        private final WildcardType wildcard;\n \n \n         public WildCardBoundedType(WildcardType wildcard) {\n \n         @Override\n         public String toString() {\n-            final StringBuilder sb = new StringBuilder();\n-            sb.append(\"{firstBound=\").append(firstBound());\n-            sb.append(\", interfaceBounds=[]}\");\n-            return sb.toString();\n+            return \"{firstBound=\" + firstBound() + \", interfaceBounds=[]}\";\n         }\n \n         public WildcardType wildCard() {\n--- a/test/org/mockito/internal/util/reflection/GenericMetadataSupportTest.java\n+++ b/test/org/mockito/internal/util/reflection/GenericMetadataSupportTest.java\n import java.lang.reflect.Method;\n import java.lang.reflect.Type;\n import java.lang.reflect.TypeVariable;\n+import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n         <O extends K> O typeVar_with_type_params();\n     }\n \n+    static class StringList extends ArrayList<String> { }\n+\n+\n     @Test\n     public void can_get_raw_type_from_Class() throws Exception {\n         assertThat(inferFrom(ListOfAnyNumbers.class).rawType()).isEqualTo(ListOfAnyNumbers.class);\n         assertThat(inferFrom(ListOfNumbers.class).rawType()).isEqualTo(ListOfNumbers.class);\n         assertThat(inferFrom(GenericsNest.class).rawType()).isEqualTo(GenericsNest.class);\n+        assertThat(inferFrom(StringList.class).rawType()).isEqualTo(StringList.class);\n     }\n \n \n         assertThat(inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).rawType()).isEqualTo(List.class);\n         assertThat(inferFrom(ListOfNumbers.class.getGenericInterfaces()[0]).rawType()).isEqualTo(List.class);\n         assertThat(inferFrom(GenericsNest.class.getGenericInterfaces()[0]).rawType()).isEqualTo(Map.class);\n+        assertThat(inferFrom(StringList.class.getGenericSuperclass()).rawType()).isEqualTo(ArrayList.class);\n     }\n \n     @Test\n         assertThat(inferFrom(ListOfAnyNumbers.class).actualTypeArguments().keySet()).hasSize(1).onProperty(\"name\").contains(\"N\");\n         assertThat(inferFrom(Map.class).actualTypeArguments().keySet()).hasSize(2).onProperty(\"name\").contains(\"K\", \"V\");\n         assertThat(inferFrom(Serializable.class).actualTypeArguments().keySet()).isEmpty();\n+        assertThat(inferFrom(StringList.class).actualTypeArguments().keySet()).isEmpty();\n     }\n \n     @Test\n         assertThat(inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).onProperty(\"name\").contains(\"E\");\n         assertThat(inferFrom(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).onProperty(\"name\").contains(\"T\");\n         assertThat(inferFrom(StringBuilder.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).isEmpty();\n+        assertThat(inferFrom(StringList.class).actualTypeArguments().keySet()).isEmpty();\n+    }\n+\n+    @Test\n+    public void typeVariable_return_type_of____iterator____resolved_to_Iterator_and_type_argument_to_String() throws Exception {\n+        GenericMetadataSupport genericMetadata = inferFrom(StringList.class).resolveGenericReturnType(firstNamedMethod(\"iterator\", StringList.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(Iterator.class);\n+        assertThat(genericMetadata.actualTypeArguments().values()).contains(String.class);\n     }\n \n     @Test\n--- /dev/null\n+++ b/test/org/mockitousage/serialization/DeepStubsSerializableTest.java\n+package org.mockitousage.serialization;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.Mockito.withSettings;\n+import static org.mockitoutil.SimpleSerializationUtil.serializeAndBack;\n+\n+import java.io.Serializable;\n+import java.util.Iterator;\n+import java.util.List;\n+import org.junit.Test;\n+\n+public class DeepStubsSerializableTest {\n+\n+    @Test\n+    public void should_serialize_and_deserialize_mock_created_with_deep_stubs() throws Exception {\n+        // given\n+        SampleClass sampleClass = mock(SampleClass.class, withSettings().defaultAnswer(RETURNS_DEEP_STUBS).serializable());\n+        when(sampleClass.getSample().isFalse()).thenReturn(true);\n+        when(sampleClass.getSample().number()).thenReturn(999);\n+\n+        // when\n+        SampleClass deserializedSample = serializeAndBack(sampleClass);\n+\n+        // then\n+        assertThat(deserializedSample.getSample().isFalse()).isEqualTo(true);\n+        assertThat(deserializedSample.getSample().number()).isEqualTo(999);\n+    }\n+\n+\t@Test\n+\tpublic void should_serialize_and_deserialize_parameterized_class_mocked_with_deep_stubs() throws Exception {\n+\t\t// given\n+\t\tListContainer deep_stubbed = mock(ListContainer.class, withSettings().defaultAnswer(RETURNS_DEEP_STUBS).serializable());\n+\t\twhen(deep_stubbed.iterator().next().add(\"yes\")).thenReturn(true);\n+\n+\t\t// when\n+\t\tListContainer deserialized_deep_stub = serializeAndBack(deep_stubbed);\n+\t\t\n+\t\t// then\n+\t\tassertThat(deserialized_deep_stub.iterator().next().add(\"not stubbed but mock already previously resolved\")).isEqualTo(false);\n+        assertThat(deserialized_deep_stub.iterator().next().add(\"yes\")).isEqualTo(true);\n+\t}\n+\n+\t@Test(expected = ClassCastException.class)\n+\tpublic void should_discard_generics_metadata_when_serialized_then_disabling_deep_stubs_with_generics() throws Exception {\n+\t\t// given\n+\t\tListContainer deep_stubbed = mock(ListContainer.class, withSettings().defaultAnswer(RETURNS_DEEP_STUBS).serializable());\n+\t\twhen(deep_stubbed.iterator().hasNext()).thenReturn(true);\n+\n+\t\tListContainer deserialized_deep_stub = serializeAndBack(deep_stubbed);\n+\n+\t\t// when stubbing on a deserialized mock\n+        when(deserialized_deep_stub.iterator().next().get(42)).thenReturn(\"no\");\n+\n+\t\t// then revert to the default RETURNS_DEEP_STUBS and the code will raise a ClassCastException\n+\t}\n+\n+\n+    static class SampleClass implements Serializable {\n+        SampleClass2 getSample() { return new SampleClass2(); }\n+    }\n+\n+    static class SampleClass2 implements Serializable {\n+        boolean isFalse() { return false; }\n+        int number() { return 100; }\n+    }\n+\n+    static class Container<E> implements Iterable<E>, Serializable {\n+        private E e;\n+        public Container(E e) { this.e = e; }\n+        public E get() { return e; }\n+\n+        @Override\n+        public Iterator<E> iterator() {\n+            return new Iterator<E>() {\n+                @Override public boolean hasNext() { return true; }\n+                @Override public E next() { return e; }\n+                @Override public void remove() { }\n+            };\n+        }\n+    }\n+\n+    static class ListContainer extends Container<List<String>> {\n+        public ListContainer(List<String> list) { super(list); }\n+    }\n+}", "timestamp": 1394497580, "metainfo": ""}