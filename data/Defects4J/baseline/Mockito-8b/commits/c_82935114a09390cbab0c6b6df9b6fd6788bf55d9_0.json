{"sha": "82935114a09390cbab0c6b6df9b6fd6788bf55d9", "log": "Merge pull request #30 from marcingrzejszczak/issue399  Issue 399: Added serialization for mocks returned by deep stubbing", "commit": "\n--- a/src/org/mockito/internal/MockitoCore.java\n+++ b/src/org/mockito/internal/MockitoCore.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal;\n+\n+import java.util.Arrays;\n+import java.util.List;\n \n import org.mockito.InOrder;\n import org.mockito.MockSettings;\n import org.mockito.internal.verification.api.VerificationDataInOrderImpl;\n import org.mockito.invocation.Invocation;\n import org.mockito.mock.MockCreationSettings;\n-import org.mockito.stubbing.*;\n+import org.mockito.stubbing.Answer;\n+import org.mockito.stubbing.DeprecatedOngoingStubbing;\n+import org.mockito.stubbing.OngoingStubbing;\n+import org.mockito.stubbing.Stubber;\n+import org.mockito.stubbing.VoidMethodStubbable;\n import org.mockito.verification.VerificationMode;\n-\n-import java.util.Arrays;\n-import java.util.List;\n \n @SuppressWarnings(\"unchecked\")\n public class MockitoCore {\n     private final Reporter reporter = new Reporter();\n     private final MockUtil mockUtil = new MockUtil();\n     private final MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n-\n-    public boolean isTypeMockable(Class<?> typeToMock) {\n-        return mockUtil.isTypeMockable(typeToMock);\n-    }\n+\n+    public boolean isTypeMockable(Class<?> typeToMock) {\n+        return mockUtil.isTypeMockable(typeToMock);\n+    }\n \n     public <T> T mock(Class<T> typeToMock, MockSettings settings) {\n         if (!MockSettingsImpl.class.isInstance(settings)) {\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.internal.stubbing.defaultanswers;\n+\n+import static org.mockito.Mockito.*;\n+\n+import java.io.Serializable;\n \n import org.mockito.MockSettings;\n import org.mockito.internal.InternalMockHandler;\n import org.mockito.internal.util.reflection.GenericMetadataSupport;\n import org.mockito.invocation.InvocationOnMock;\n import org.mockito.stubbing.Answer;\n-\n-import java.io.Serializable;\n-\n-import static org.mockito.Mockito.withSettings;\n \n /**\n  * Returning deep stub implementation.\n     \n     private static final long serialVersionUID = -7105341425736035847L;\n \n-    private MockitoCore mockitoCore = new MockitoCore();\n-    private ReturnsEmptyValues delegate = new ReturnsEmptyValues();\n+    private transient MockitoCore mockitoCore;\n+    private transient ReturnsEmptyValues delegate;\n \n     public Object answer(InvocationOnMock invocation) throws Throwable {\n         GenericMetadataSupport returnTypeGenericMetadata =\n                 actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());\n \n         Class<?> rawType = returnTypeGenericMetadata.rawType();\n+        instantiateMockitoCoreIfNeeded();\n+        instantiateDelegateIfNeeded();\n         if (!mockitoCore.isTypeMockable(rawType)) {\n             return delegate.returnValueFor(rawType);\n         }\n \n         return getMock(invocation, returnTypeGenericMetadata);\n+    }\n+\n+    private synchronized void instantiateMockitoCoreIfNeeded() {\n+        if (mockitoCore == null) {\n+            mockitoCore = new MockitoCore();\n+        }\n+    }\n+\n+    private synchronized void instantiateDelegateIfNeeded() {\n+        if (delegate == null) {\n+            delegate = new ReturnsEmptyValues();\n+        }\n     }\n \n     private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {\n                 : withSettings();\n \n         return mockSettings\n+\t\t        .serializable()\n                 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));\n     }\n \n \n     private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {\n \n-        container.addAnswer(new Answer<Object>() {\n+        container.addAnswer(new SerializableAnswer() {\n             public Object answer(InvocationOnMock invocation) throws Throwable {\n                 return mock;\n             }\n \n         return mock;\n     }\n+\t\n+\tabstract class SerializableAnswer implements Answer<Object>, Serializable {\n+\t\t\n+\t}\n+\t\n \n     protected GenericMetadataSupport actualParameterizedType(Object mock) {\n         CreationSettings mockSettings = (CreationSettings) new MockUtil().getMockHandler(mock).getMockSettings();\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.internal.util;\n+\n+import java.lang.reflect.Modifier;\n \n import org.mockito.exceptions.misusing.NotAMockException;\n import org.mockito.internal.InternalMockHandler;\n import org.mockito.mock.MockCreationSettings;\n import org.mockito.mock.MockName;\n import org.mockito.plugins.MockMaker;\n-\n-import java.lang.reflect.Modifier;\n \n @SuppressWarnings(\"unchecked\")\n public class MockUtil {\n--- a/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n+++ b/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.util.Checks;\n \n+import java.io.Serializable;\n import java.lang.reflect.*;\n import java.util.*;\n \n  * @see org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs\n  */\n @Incubating\n-public abstract class GenericMetadataSupport {\n+public abstract class GenericMetadataSupport implements Serializable {\n \n     // public static MockitoLogger logger = new ConsoleMockitoLogger();\n \n      *\n      * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>\n      */\n-    public static class WildCardBoundedType implements BoundedType {\n+    public static class WildCardBoundedType implements BoundedType, Serializable {\n         private WildcardType wildcard;\n \n \n--- /dev/null\n+++ b/test/org/mockitousage/stubbing/DeepStubsSerializableTest.java\n+package org.mockitousage.stubbing;\n+\n+import static org.fest.assertions.Assertions.*;\n+import static org.mockito.Mockito.*;\n+\n+import java.io.Serializable;\n+\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockitoutil.SimpleSerializationUtil;\n+\n+public class DeepStubsSerializableTest {\n+\n+    public static final boolean STUBBED_BOOLEAN_VALUE = true;\n+    public static final int STUBBED_INTEGER_VALUE = 999;\n+\n+    @Test\n+    public void should_serialize_and_deserialize_mock_created_by_deep_stubs() throws Exception {\n+        // given\n+        SampleClass sampleClass = mock(SampleClass.class, withSettings().defaultAnswer(Mockito.RETURNS_DEEP_STUBS).serializable());\n+        when(sampleClass.getSample().isSth()).thenReturn(STUBBED_BOOLEAN_VALUE);\n+        when(sampleClass.getSample().getNumber()).thenReturn(STUBBED_INTEGER_VALUE);\n+\n+        // when\n+        Object o = SimpleSerializationUtil.serializeAndBack(sampleClass);\n+\n+        // then\n+        assertThat(o).isInstanceOf(SampleClass.class);\n+        SampleClass deserializedSample = (SampleClass) o;\n+        assertThat(deserializedSample.getSample().isSth()).isEqualTo(STUBBED_BOOLEAN_VALUE);\n+        assertThat(deserializedSample.getSample().getNumber()).isEqualTo(STUBBED_INTEGER_VALUE);\n+    }\n+\n+\n+    class SampleClass implements Serializable {\n+        SampleClass2 getSample() {\n+            return new SampleClass2();\n+        }\n+    }\n+\n+    class SampleClass2 implements Serializable {\n+        boolean isSth() {\n+            return false;\n+        }\n+\t    int getNumber(){\n+\t\t    return 100; \n+\t    }\n+    }\n+\n+}\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\n  *  Returns description of mock for toString() method\n  * </li>\n  * <li>\n- *  Returns non-zero for Comparable#compareTo(T other) method (see issue 184)\n+ *  Returns zero if references are equals otherwise non-zero for Comparable#compareTo(T other) method (see issue 184)\n  * </li>\n  * <li>\n  *  Returns null for everything else\n             }\n         } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n             //see issue 184.\n-            //mocks by default should not return 0 for compareTo because they are not the same. Hence we return 1 (anything but 0 is good).\n+            //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n             //Only for compareTo() method by the Comparable interface\n-            return 1;\n+            return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;\n         }\n         \n         Class<?> returnType = invocation.getMethod().getReturnType();\n--- a/src/org/mockito/internal/util/reflection/FieldInitializer.java\n+++ b/src/org/mockito/internal/util/reflection/FieldInitializer.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util.reflection;\n-\n-import org.mockito.exceptions.base.MockitoException;\n \n import java.lang.reflect.Constructor;\n import java.lang.reflect.Field;\n import java.util.Collections;\n import java.util.Comparator;\n import java.util.List;\n+\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.util.MockUtil;\n \n /**\n  * Initialize a field with type instance if a default constructor can be found.\n         private Object testClass;\n         private Field field;\n         private ConstructorArgumentResolver argResolver;\n+\t    private final MockUtil mockUtil = new MockUtil();\n         private Comparator<Constructor<?>> byParameterNumber = new Comparator<Constructor<?>>() {\n             public int compare(Constructor<?> constructorA, Constructor<?> constructorB) {\n-                return constructorB.getParameterTypes().length - constructorA.getParameterTypes().length;\n-            }\n+\t            int argLengths = constructorB.getParameterTypes().length - constructorA.getParameterTypes().length;\n+\t            if (argLengths == 0) {\n+\t\t            int constructorAMockableParamsSize = countMockableParams(constructorA);\n+\t\t            int constructorBMockableParamsSize = countMockableParams(constructorB);\n+\t\t            return constructorBMockableParamsSize - constructorAMockableParamsSize;\n+\t            }\n+\t            return argLengths;\n+            }\n+\t        \n+\t        private int countMockableParams(Constructor<?> constructor) {\n+\t\t        int constructorMockableParamsSize = 0;\n+\t\t        for (Class<?> aClass : constructor.getParameterTypes()) {\n+\t\t\t        if(mockUtil.isTypeMockable(aClass)){\n+\t\t\t\t        constructorMockableParamsSize++;\n+\t\t\t        }\n+\t\t        }\n+\t\t        return constructorMockableParamsSize;\n+\t        }\n         };\n \n         /**\n         private Constructor<?> biggestConstructor(Class<?> clazz) {\n             final List<Constructor<?>> constructors = Arrays.asList(clazz.getDeclaredConstructors());\n             Collections.sort(constructors, byParameterNumber);\n-\n+\t\t\t\n             Constructor<?> constructor = constructors.get(0);\n             checkParameterized(constructor, field);\n             return constructor;\n--- a/test/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValuesTest.java\n+++ b/test/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValuesTest.java\n         assertTrue(result != (Object) 0);\n     }\n \n+    @Test public void should_return_zero_if_mock_is_compared_to_itself() {\n+        //given\n+        Date d = mock(Date.class);\n+        d.compareTo(d);\n+        Invocation compareTo = this.getLastInvocation();\n+\n+        //when\n+        Object result = values.answer(compareTo);\n+\n+        //then\n+        assertEquals(0, result);\n+    }\n+\n }\n--- /dev/null\n+++ b/test/org/mockitousage/annotation/MockInjectionUsingConstructorIssue421Test.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockitousage.annotation;\n+\n+import static org.fest.assertions.Assertions.*;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.internal.util.MockUtil;\n+import org.mockito.runners.MockitoJUnitRunner;\n+import org.mockitousage.examples.use.ArticleCalculator;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class MockInjectionUsingConstructorIssue421Test {\n+\n+    @Mock private ArticleCalculator calculator;\n+\n+    @InjectMocks private Issue421 issue421;\n+\n+    @Test\n+    public void mockJustWorks() {\n+\t    issue421.checkIfMockIsInjected();\n+    }\n+\n+\tstatic class Issue421 {\n+\n+\t\tprivate ArticleCalculator calculator;\n+\n+\t\tpublic Issue421(int a) {\n+\t\t}\n+\n+\t\tpublic Issue421(ArticleCalculator calculator) {\n+\t\t\tthis.calculator = calculator;\n+\t\t}\n+\n+\t\tpublic void checkIfMockIsInjected(){\n+\t\t\tassertThat(new MockUtil().isMock(calculator)).isTrue();\n+\t\t}\n+\t}\n+\n+}\n--- a/test/org/mockitousage/bugs/ShouldMocksCompareToBeConsistentWithEqualsTest.java\n+++ b/test/org/mockitousage/bugs/ShouldMocksCompareToBeConsistentWithEqualsTest.java\n public class ShouldMocksCompareToBeConsistentWithEqualsTest extends TestBase {\n \n     @Test\n-    public void shouldCompareToBeConsistentWithEquals() {\n+    public void should_compare_to_be_consistent_with_equals() {\n         //given\n         Date today    = mock(Date.class);\n         Date tomorrow = mock(Date.class);\n     }\n \n     @Test\n-    public void shouldAllowStubbingAndVerifyingCompareTo() {\n+    public void should_compare_to_be_consistent_with_equals_when_comparing_the_same_reference() {\n+        //given\n+        Date today    = mock(Date.class);\n+\n+        //when\n+        Set<Date> set = new TreeSet<Date>();\n+        set.add(today);\n+        set.add(today);\n+\n+        //then\n+        assertEquals(1, set.size());\n+    }\n+\n+    @Test\n+    public void should_allow_stubbing_and_verifying_compare_to() {\n         //given\n         Date mock    = mock(Date.class);\n         when(mock.compareTo(any(Date.class))).thenReturn(10);\n     }\n \n     @Test\n-    public void shouldResetNotRemoveDefaultStubbing() {\n+    public void should_reset_not_remove_default_stubbing() {\n         //given\n         Date mock    = mock(Date.class);\n         reset(mock);", "timestamp": 1389893873, "metainfo": ""}