{"sha": "4a3f2df6afa3cc58db73f29c587ee1c5a4216c32", "log": "Merged Looper's fix with some small modifications.", "commit": "\n--- a/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\n+++ b/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\n package org.mockito.internal.verification;\n \n import org.mockito.exceptions.base.MockitoAssertionError;\n+import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent;\n import org.mockito.internal.verification.api.VerificationData;\n import org.mockito.verification.VerificationMode;\n \n      * @throws MockitoAssertionError if the delegate verification mode does not succeed before the timeout\n      */\n     public void verify(VerificationData data) {\n-        MockitoAssertionError error = null;\n+        AssertionError error = null;\n         \n         long startTime = System.currentTimeMillis();\n         while (System.currentTimeMillis() - startTime <= durationMillis) {\n                     error = null;\n                 }\n             } catch (MockitoAssertionError e) {\n-                if (canRecoverFromFailure(delegate)) {\n-                    error = e;\n-                    sleep(pollingPeriodMillis);\n-                } else {\n-                    throw e;\n-                }\n+                error = handleVerifyException(e);\n+            }\n+            catch (ArgumentsAreDifferent e) {\n+                error = handleVerifyException(e);\n             }\n         }\n         \n         if (error != null) {\n             throw error;\n+        }\n+    }\n+\n+    private AssertionError handleVerifyException(AssertionError e) {\n+        if (canRecoverFromFailure(delegate)) {\n+            sleep(pollingPeriodMillis);\n+            return e;\n+        } else {\n+            throw e;\n         }\n     }\n \n--- /dev/null\n+++ b/test/org/mockito/internal/verification/VerificationOverTimeImplTest.java\n+package org.mockito.internal.verification;\n+\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.mockito.Mock;\n+import org.mockito.exceptions.base.MockitoAssertionError;\n+import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent;\n+import org.mockito.verification.VerificationMode;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.MockitoAnnotations.initMocks;\n+\n+public class VerificationOverTimeImplTest {\n+    @Mock\n+    private VerificationMode delegate;\n+    private VerificationOverTimeImpl impl;\n+\n+    @Rule\n+    public ExpectedException exception = ExpectedException.none();\n+\n+    @Before\n+    public void setUp() {\n+        initMocks(this);\n+        impl = new VerificationOverTimeImpl(10, 1000, delegate, true);\n+    }\n+\n+    @Test\n+    public void should_return_on_success() {\n+        impl.verify(null);\n+        verify(delegate).verify(null);\n+    }\n+\n+    @Test\n+    public void should_throw_mockito_assertion_error() {\n+        MockitoAssertionError toBeThrown = new MockitoAssertionError(\"message\");\n+        exception.expect(is(toBeThrown));\n+\n+        doThrow(toBeThrown).when(delegate).verify(null);\n+        impl.verify(null);\n+    }\n+\n+    @Test\n+    public void should_deal_with_junit_assertion_error() {\n+        ArgumentsAreDifferent toBeThrown = new ArgumentsAreDifferent(\"message\", \"wanted\", \"actual\");\n+        exception.expect(is(toBeThrown));\n+        exception.expectMessage(\"message\");\n+\n+        doThrow(toBeThrown).when(delegate).verify(null);\n+        impl.verify(null);\n+    }\n+\n+    @Test\n+    public void should_not_wrap_other_exceptions() {\n+        RuntimeException toBeThrown = new RuntimeException();\n+        exception.expect(is(toBeThrown));\n+\n+        doThrow(toBeThrown).when(delegate).verify(null);\n+        impl.verify(null);\n+    }\n+}\n--- a/test/org/mockitousage/verification/VerificationWithTimeoutTest.java\n+++ b/test/org/mockitousage/verification/VerificationWithTimeoutTest.java\n             fail();\n         } catch (NoInteractionsWanted e) {}\n     }\n-    \n+\n+    /**\n+     * This test is JUnit-specific because the code behaves different if JUnit is used.\n+     */\n+    @Test\n+    public void canIgnoreInvocationsWithJunit() {\n+        //given\n+        Thread t1 = new Thread() {\n+            @Override\n+            public void run() {\n+                mock.add(\"0\");\n+                mock.add(\"1\");\n+                try {\n+                    Thread.sleep(100);\n+                } catch (InterruptedException ignored) {\n+                    // We do not need to handle this.\n+                }\n+                mock.add(\"2\");\n+            }\n+        };\n+\n+        //when\n+        t1.start();\n+\n+        //then\n+        verify(mock, timeout(200)).add(\"1\");\n+        verify(mock, timeout(200)).add(\"2\");\n+    }\n+\n     //TODO not yet implemented\n     @Ignore\n     @Test", "timestamp": 1397314206, "metainfo": ""}