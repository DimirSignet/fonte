{"sha": "c5bf9669378a2aee7de5ee6664312fb3f7f1d62b", "log": "added some experimental reporting (Igor's case)  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%4051", "commit": "\n--- a/src/org/mockito/internal/InvocationWithMatchers.java\n+++ b/src/org/mockito/internal/InvocationWithMatchers.java\n     }\n \n     public boolean matches(Invocation actual) {\n+        boolean methodsAreEqual = areMethodsEqual(actual.getMethod());\n         return this.invocation.getMock().equals(\n                 actual.getMock())\n-                && this.invocation.getMethod().equals(actual.getMethod())\n+                && methodsAreEqual\n                 && matches(actual.getArguments());\n+    }\n+\n+    private boolean areMethodsEqual(Method method) {\n+        Method thisMethod = this.invocation.getMethod();\n+        if (thisMethod.getDeclaringClass() != method.getDeclaringClass()\n+            || thisMethod.getName() != method.getName() \n+            || !thisMethod.getReturnType().equals(method.getReturnType())) { \n+                return false;\n+        }\n+        \n+        Class[] params1 = thisMethod.getParameterTypes();\n+        Class[] params2 = method.getParameterTypes();\n+        if (params1.length == params2.length) {\n+            for (int i = 0; i < params1.length; i++) {\n+            if (params1[i] != params2[i])\n+                return false;\n+            }\n+            return true;\n+        }\n+    \n+        return false;\n+//        return this.invocation.getMethod().equals(actual.getMethod());\n     }\n \n     private boolean matches(Object[] arguments) {\n     public Invocation getInvocation() {\n         return this.invocation;\n     }\n+\n+    public String toStringWithTypes() {\n+        StringBuilder result = new StringBuilder();\n+        result.append(invocation.getMockAndMethodName());\n+        result.append(\"(\");\n+        for (Class paramType : invocation.getMethod().getParameterTypes()) {\n+            result.append(paramType);\n+            result.append(\", \");\n+        }\n+        return result.toString().replaceFirst(\", \", \"\").concat(\")\");\n+    }\n }\n--- a/src/org/mockito/internal/MockitoBehavior.java\n+++ b/src/org/mockito/internal/MockitoBehavior.java\n             } \n         } else {\n             if (actuallyInvoked == 0) {\n-                throw new VerificationAssertionError(\n-                        \"\\n\" +\n-                        \"Not invoked: \" + invocation.toString());\n+                //TODO this stuff is really hacked in, refactor, add more testing\n+                InvocationWithMatchers similarInvocation = findSimilarInvocation(invocation);\n+                String message = \n+                    \"\\n\" +\n+                    \"Failure on verify:\" +\n+                    \"\\n\";\n+                \n+                String expected = invocation.toString();\n+                if (similarInvocation != null) {\n+                    String actual = similarInvocation.toString();\n+                    if (expected.equals(actual)) {\n+                        expected = invocation.toStringWithTypes();\n+                        actual = similarInvocation.toStringWithTypes();\n+                    }\n+                    \n+                    message += \n+                            \"Expected: \" + expected +\n+                            \"\\n\" +\n+                    \t\t\"Actual: \" + actual;\n+                } else {\n+                    message += \"Not invoked: \" + expected;\n+                }\n+                \n+                throw new VerificationAssertionError(message);\n             }\n         }\n+    }\n+\n+    /**\n+     * gets first registered invocation with the same method name\n+     * or just first invocation\n+     */\n+    private InvocationWithMatchers findSimilarInvocation(InvocationWithMatchers expectedInvocation) {\n+        for (InvocationWithMatchers registeredInvocation : registeredInvocations) {\n+            String expectedMethodName = expectedInvocation.getMethod().getName();\n+            String registeredInvocationName = registeredInvocation.getMethod().getName();\n+            if (expectedMethodName.equals(registeredInvocationName)) {\n+                return registeredInvocation;\n+            }\n+        }\n+\n+        return registeredInvocations.size() > 0 ? registeredInvocations.get(0) : null;\n     }\n \n     private int numberOfActualInvocations(InvocationWithMatchers expectedInvocation) {\n--- a/test/org/mockito/usage/StackTrackeFilteringTest.java\n+++ b/test/org/mockito/usage/StackTrackeFilteringTest.java\n     }\n     \n     @Test\n-    public void shouldFilterStacktraceOnUnfinishedVerification() {\n+    public void shouldFilterStacktraceOnMockitoException() {\n         verify(mock);\n         try {\n             verify(mock).oneArg(true); \n             fail();\n         } catch (MockitoException expected) {\n-            assertThat(expected, firstMethodOnStackEqualsTo(\"shouldFilterStacktraceOnUnfinishedVerification\"));\n+            assertThat(expected, firstMethodOnStackEqualsTo(\"shouldFilterStacktraceOnMockitoException\"));\n             \n             StackTraceElement[] unfilteredStackTrace = expected.getUnfilteredStackTrace();\n             assertEquals(\"checkForUnfinishedVerification\", unfilteredStackTrace[0].getMethodName());\n         }\n     }\n-    \n-    //TODO add all other stack filtering stuff\n }\n--- a/test/org/mockito/usage/binding/IncorectBindingPuzzleFixedTest.java\n+++ b/test/org/mockito/usage/binding/IncorectBindingPuzzleFixedTest.java\n \n     private class BaseMessage { \n         public String toString() {\n-            return \"BaseMessage\";\n+            return \"BaseMessageInstance\";\n         }\n     }\n     \n     private class Message extends BaseMessage {\n         public String toString() {\n-            return \"Message\";\n+            return \"MessageInstance\";\n         }\n     }\n \n         mock.print(message);\n     }\n \n-    @Ignore\n     @Test\n     public void overriddenInterfaceMethodNotWorking() throws Exception {\n         DerivedInterface derivedMock = Mockito.mock(DerivedInterface.class);\n         try {\n             Mockito.verify(derivedMock).print(message);\n         } catch (VerificationAssertionError error) {\n-            String expected = \"\\n\" +\n-            \t\t\"Failure on verify:\" +\n-            \t\t\"\\n\" +\n-            \t\t\"Expected: DerivedInterface.print(Message)\" +\n-            \t\t\"\\n\" +\n-            \t\t\"Actual: DerivedInterface.print(BaseMessage)\";\n+            String expected = \n+                \"\\n\" +\n+        \t\t\"Failure on verify:\" +\n+        \t\t\"\\n\" +\n+        \t\t\"Expected: DerivedInterface.print(class org.mockito.usage.binding.IncorectBindingPuzzleFixedTest$Message)\" +\n+        \t\t\"\\n\" +\n+        \t\t\"Actual: DerivedInterface.print(class org.mockito.usage.binding.IncorectBindingPuzzleFixedTest$BaseMessage)\";\n+            \n             assertEquals(expected, error.getMessage());\n         }\n     }\n--- a/test/org/mockito/usage/verification/NiceMessagesWhenVerificationFailsTest.java\n+++ b/test/org/mockito/usage/verification/NiceMessagesWhenVerificationFailsTest.java\n             String actualMessage = expected.getMessage();\n             String expectedMessage = \n                     \"\\n\" +\n+            \t\t\"Failure on verify:\" +\n+            \t\t\"\\n\" +\n             \t\t\"Not invoked: IMethods.simpleMethod()\";\n             assertEquals(expectedMessage, actualMessage);         \n         }\n         } catch (VerificationAssertionError expected) {\n             String actualMessage = expected.getMessage();\n             String expectedMessage = \n+                    \"\\n\" +\n+                    \"Failure on verify:\" +\n                     \"\\n\" +\n             \t\t\"Not invoked: IMethods.threeArgumentMethod(12, SomeClass instance, \\\"some string\\\")\";\n             assertEquals(expectedMessage, actualMessage);         \n--- a/test/org/mockito/usage/verification/VerificationInOrderTest.java\n+++ b/test/org/mockito/usage/verification/VerificationInOrderTest.java\n  */\n package org.mockito.usage.verification;\n \n-import static org.junit.Assert.*;\n-import static org.mockito.CrazyMatchers.*;\n-import static org.mockito.Matchers.isA;\n-import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.mock;\n \n import java.util.*;\n \n import org.junit.*;\n-import org.mockito.*;\n-\n-import static org.mockito.Mockito.*;\n-import org.mockito.exceptions.VerificationAssertionError;\n-import org.mockito.usage.IMethods;\n+import org.mockito.Mockito;\n+import org.mockito.exceptions.*;\n \n @SuppressWarnings(\"unchecked\")  \n public class VerificationInOrderTest {\n         set.add(\"six\");\n     }\n \n-    @Ignore\n     @Test\n     public void shouldVerifyInOrder() {\n         Mockito.verifyInOrder(list).add(\"one\");\n         Mockito.verifyInOrder(set).add(\"six\");\n     } \n \n-    @Ignore\n     @Test\n     public void shouldVerifyInOrderWithExactNumberOfInvocations() {\n         Mockito.verifyInOrder(list, 1).add(\"one\");\n         Mockito.verifyInOrder(map, 1).put(\"five\", \"five\");\n         Mockito.verifyInOrder(set, 1).add(\"six\");\n     }  \n+    \n+    @Ignore\n+    @Test(expected = VerificationAssertionError.class)\n+    public void shouldFailOnOrdinaryVerificationError() {\n+        Mockito.verifyInOrder(list).add(\"xxx\");\n+    }\n+    \n+    @Ignore\n+    @Test(expected = NumberOfInvocationsAssertionError.class)\n+    public void shouldFailOnExactNumberOfInvocations() {\n+        Mockito.verifyInOrder(list, 2).add(\"xxx\");\n+    }\n }", "timestamp": 1195778031, "metainfo": ""}