{"sha": "801c3731158be8592cd838b55f4209a4dfbcdbbd", "log": "enabled another test in an effort to finish implementing relaxed verification in order  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40322", "commit": "\n--- a/test/org/mockito/internal/verification/NumberOfInvocationsInOrderVerifierTest.java\n+++ b/test/org/mockito/internal/verification/NumberOfInvocationsInOrderVerifierTest.java\n package org.mockito.internal.verification;\n \n import static java.util.Arrays.*;\n+import static org.mockito.util.ExtraMatchers.*;\n import static org.junit.Assert.*;\n import static org.mockito.internal.progress.VerificationModeImpl.*;\n \n import org.junit.Test;\n import org.mockito.RequiresValidState;\n import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.verification.VerifcationInOrderFailed;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n         verifier.verify(invocations, wanted, new VerificationModeBuilder().times(1).inOrder());\n     }\n     \n-//    @Test\n-//    public void shouldReportTooLittleInvocations() throws Exception {\n-//        Invocation first = new InvocationBuilder().toInvocation();\n-//        Invocation second = new InvocationBuilder().toInvocation();\n-//        finderStub.allMatchingUnverifiedChunksToReturn.addAll(asList(first, second)); \n-//        \n-//        verifier.verify(invocations, wanted, new VerificationModeBuilder().times(4).inOrder());\n-//        \n-//        assertEquals(4, reporterStub.wantedCount);\n-//        assertEquals(2, reporterStub.actualCount);\n-//        assertSame(second.getStackTrace(), reporterStub.lastActualStackTrace);\n-//        assertEquals(wanted.toString(), reporterStub.wanted);\n-//    }\n-//    \n-//    @Test\n-//    public void shouldReportTooManyInvocations() throws Exception {\n-//        Invocation first = new InvocationBuilder().toInvocation();\n-//        Invocation second = new InvocationBuilder().toInvocation();\n-//        finderStub.allMatchingUnverifiedChunksToReturn.addAll(asList(first, second)); \n-//        \n-//        verifier.verify(invocations, wanted, new VerificationModeBuilder().times(1).inOrder());\n-//        \n-//        assertEquals(1, reporterStub.wantedCount);\n-//        assertEquals(2, reporterStub.actualCount);\n-//        assertSame(second.getStackTrace(), reporterStub.firstUndesired);\n-//        assertEquals(wanted.toString(), reporterStub.wanted);\n-//    }\n-//    \n-//    @Test\n-//    public void shouldMarkInvocationsAsVerified() throws Exception {\n-//        Invocation invocation = new InvocationBuilder().toInvocation();\n-//        finderStub.allMatchingUnverifiedChunksToReturn.add(invocation);\n-//        assertFalse(invocation.isVerifiedInOrder());\n-//        \n-//        verifier.verify(invocations, wanted, new VerificationModeBuilder().times(1).inOrder());\n-//        \n-//        assertTrue(invocation.isVerifiedInOrder());\n-//    }\n-\n-//    class ReporterStub extends Reporter {\n-//        private HasStackTrace lastActualStackTrace;\n-//        private int actualCount;\n-//        private int wantedCount;\n-//        private HasStackTrace firstUndesired;\n-//        private String wanted;\n-//\n-//        @Override public void tooLittleActualInvocationsInOrder(int wantedCount, int actualCount, String wanted, HasStackTrace lastActualStackTrace) {\n-//            this.wantedCount = wantedCount;\n-//            this.actualCount = actualCount;\n-//            this.wanted = wanted;\n-//            this.lastActualStackTrace = lastActualStackTrace;\n-//        }\n-//        \n-//        @Override public void tooManyActualInvocationsInOrder(int wantedCount, int actualCount, String wanted, HasStackTrace firstUndesired) {\n-//            this.wantedCount = wantedCount;\n-//            this.actualCount = actualCount;\n-//            this.wanted = wanted;\n-//            this.firstUndesired = firstUndesired;\n-//        }\n-//    }\n+    @Test\n+    public void shouldReportTooLittleInvocations() throws Exception {\n+        Invocation first = new InvocationBuilder().toInvocation();\n+        Invocation second = new InvocationBuilder().toInvocation();\n+        finderStub.validMatchingChunkToReturn.addAll(asList(first, second)); \n+        \n+        try {\n+            verifier.verify(invocations, wanted, new VerificationModeBuilder().times(4).inOrder());\n+            fail();\n+        } catch (VerifcationInOrderFailed e) {\n+            assertThat(e, messageContains(\"Wanted 4 times but was 2\"));\n+        };\n+    }\n+    \n+    @Test\n+    public void shouldReportTooManyInvocations() throws Exception {\n+        Invocation first = new InvocationBuilder().toInvocation();\n+        Invocation second = new InvocationBuilder().toInvocation();\n+        finderStub.validMatchingChunkToReturn.addAll(asList(first, second)); \n+        \n+        try {\n+            verifier.verify(invocations, wanted, new VerificationModeBuilder().times(1).inOrder());\n+            fail();\n+        } catch (VerifcationInOrderFailed e) {\n+            assertThat(e, messageContains(\"Wanted 1 time but was 2\"));\n+        };\n+    }\n+    \n+    @Test\n+    public void shouldMarkAsVerifiedInOrder() throws Exception {\n+        Invocation invocation = new InvocationBuilder().toInvocation();\n+        assertFalse(invocation.isVerifiedInOrder());\n+        finderStub.validMatchingChunkToReturn.addAll(asList(invocation)); \n+        \n+        verifier.verify(invocations, wanted, new VerificationModeBuilder().times(1).inOrder());\n+        \n+        assertTrue(invocation.isVerifiedInOrder());\n+    }\n }", "timestamp": 1201025468, "metainfo": ""}