{"sha": "530b3f97c0f411b44aa5b2998110dd49bdbdb367", "log": "Merge pull request #24 from mockito/michalborek-master  Michalborek master", "commit": "\n--- a/src/org/mockito/internal/creation/jmock/ClassImposterizer.java\n+++ b/src/org/mockito/internal/creation/jmock/ClassImposterizer.java\n                 // Don't filter\n             }\n         };\n-        enhancer.setClassLoader(SearchingClassLoader.combineLoadersOf(mockedType));\n+        Class<?>[] allMockedTypes = prepend(mockedType, interfaces);\n+\t\tenhancer.setClassLoader(SearchingClassLoader.combineLoadersOf(allMockedTypes));\n         enhancer.setUseFactory(true);\n         if (mockedType.isInterface()) {\n             enhancer.setSuperclass(Object.class);\n-            enhancer.setInterfaces(prepend(mockedType, interfaces));\n+            enhancer.setInterfaces(allMockedTypes);\n         } else {\n             enhancer.setSuperclass(mockedType);\n             enhancer.setInterfaces(interfaces);\n--- a/test/org/mockitousage/basicapi/MockingMultipleInterfacesTest.java\n+++ b/test/org/mockitousage/basicapi/MockingMultipleInterfacesTest.java\n \n package org.mockitousage.basicapi;\n \n-import static org.hamcrest.CoreMatchers.*;\n-import static org.mockito.Mockito.*;\n-\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.withSettings;\n+import static org.mockitoutil.ClassLoaders.isolatedClassLoader;\n import org.junit.Test;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n+// See issue 453\n public class MockingMultipleInterfacesTest extends TestBase {\n \n     class Foo {}\n     interface IBar {}\n     \n     @Test\n-    public void shouldAllowMultipleInterfaces() {\n+    public void should_allow_multiple_interfaces() {\n         //when\n         Foo mock = mock(Foo.class, withSettings().extraInterfaces(IFoo.class, IBar.class));\n         \n     }\n     \n     @Test\n-    public void shouldScreamWhenNullPassedInsteadOfAnInterface() {\n+    public void should_scream_when_null_passed_instead_of_an_interface() {\n         try {\n             //when\n             mock(Foo.class, withSettings().extraInterfaces(IFoo.class, null));\n     }\n     \n     @Test\n-    public void shouldScreamWhenNoArgsPassed() {\n+    public void should_scream_when_no_args_passed() {\n         try {\n             //when\n             mock(Foo.class, withSettings().extraInterfaces());\n     }\n     \n     @Test\n-    public void shouldScreamWhenNullPassedInsteadOfAnArray() {\n+    public void should_scream_when_null_passed_instead_of_an_array() {\n         try {\n             //when\n             mock(Foo.class, withSettings().extraInterfaces((Class[]) null));\n     }\n     \n     @Test\n-    public void shouldScreamWhenNonInterfacePassed() {\n+    public void should_scream_when_non_interface_passed() {\n         try {\n             //when\n             mock(Foo.class, withSettings().extraInterfaces(Foo.class));\n     }\n     \n     @Test\n-    public void shouldScreamWhenTheSameInterfacesPassed() {\n+    public void should_scream_when_the_same_interfaces_passed() {\n         try {\n             //when\n             mock(IMethods.class, withSettings().extraInterfaces(IMethods.class));\n             assertContains(\"You mocked following type: IMethods\", e.getMessage());\n         }\n     }\n+\n+\n+    @Test\n+    public void should_mock_class_with_interfaces_of_different_class_loader_AND_different_classpaths() throws ClassNotFoundException {\n+        // Note : if classes are in the same classpath, SearchingClassLoader can find the class/classes and load them in the first matching classloader\n+        Class<?> interface1 = isolatedClassLoader()\n+                .withCodeSourceUrls(\"test-resources/multiple-classpaths/cp1\")\n+                .withPrivateCopyOf(\"test.TestedClass1\")\n+                .build()\n+                .loadClass(\"test.TestedClass1\");\n+        Class<?> interface2 = isolatedClassLoader()\n+                .withCodeSourceUrls(\"test-resources/multiple-classpaths/cp2\")\n+                .withPrivateCopyOf(\"test.TestedClass2\")\n+                .build()\n+                .loadClass(\"test.TestedClass2\");\n+\n+        try {\n+            Object mocked = mock(interface1, withSettings().extraInterfaces(interface2));\n+            assertTrue(\"mock should be assignable from interface2 type\", interface2.isInstance(mocked));\n+        } catch (MockitoException e) {\n+            fail(\"Couldn't mock interfaces with different class loaders and different classpaths\");\n+        }\n+    }\n }\n--- /dev/null\n+++ b/test/org/mockitoutil/ClassLoaders.java\n+package org.mockitoutil;\n+\n+import static java.util.Arrays.asList;\n+import java.io.File;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class ClassLoaders {\n+    private final ArrayList<String> privateCopyPrefixes = new ArrayList<String>();\n+    private final ArrayList<URL> codeSourceUrls = new ArrayList<URL>();\n+\n+    public static ClassLoaders isolatedClassLoader() {\n+        return new ClassLoaders();\n+    }\n+\n+    public ClassLoaders withPrivateCopyOf(String... privatePrefixes) {\n+        privateCopyPrefixes.addAll(asList(privatePrefixes));\n+        return this;\n+    }\n+\n+    public ClassLoaders withCodeSourceUrls(String... urls) {\n+        codeSourceUrls.addAll(pathsToURLs(urls));\n+        return this;\n+    }\n+\n+    public ClassLoaders withCurrentCodeSourceUrls() {\n+        codeSourceUrls.add(obtainClassPathOF(ClassLoaders.class.getName()));\n+        return this;\n+    }\n+\n+\n+    private static URL obtainClassPathOF(String className) {\n+        String path = className.replace('.', '/') + \".class\";\n+        String url = ClassLoaders.class.getClassLoader().getResource(path).toExternalForm();\n+\n+        try {\n+            return new URL(url.substring(0, url.length() - path.length()));\n+        } catch (MalformedURLException e) {\n+            throw new RuntimeException(\"Classloader couldn't obtain a proper classpath URL\", e);\n+        }\n+    }\n+\n+    public ClassLoader build() {\n+        return new LocalIsolatedURLClassLoader(\n+                codeSourceUrls.toArray(new URL[codeSourceUrls.size()]),\n+                privateCopyPrefixes\n+        );\n+    }\n+\n+    static class LocalIsolatedURLClassLoader extends URLClassLoader {\n+        private final ArrayList<String> privateCopyPrefixes;\n+\n+        public LocalIsolatedURLClassLoader(URL[] urls, ArrayList<String> privateCopyPrefixes) {\n+            super(urls, null);\n+            this.privateCopyPrefixes = privateCopyPrefixes;\n+        }\n+\n+        @Override\n+        public Class<?> findClass(String name) throws ClassNotFoundException {\n+            if(classShouldBePrivate(name)) return super.findClass(name);\n+            throw new ClassNotFoundException(\"Can only load classes with prefix : \" + privateCopyPrefixes);\n+        }\n+\n+        private boolean classShouldBePrivate(String name) {\n+            for (String prefix : privateCopyPrefixes) {\n+                if (name.startsWith(prefix)) return true;\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private List<URL> pathsToURLs(String... codeSourceUrls) {\n+        return pathsToURLs(Arrays.asList(codeSourceUrls));\n+    }\n+    private List<URL> pathsToURLs(List<String> codeSourceUrls) {\n+        ArrayList<URL> urls = new ArrayList<URL>(codeSourceUrls.size());\n+        for (String codeSourceUrl : codeSourceUrls) {\n+            URL url = pathToUrl(codeSourceUrl);\n+            urls.add(url);\n+        }\n+        return urls;\n+    }\n+\n+    private URL pathToUrl(String path) {\n+        try {\n+            return new File(path).getAbsoluteFile().toURI().toURL();\n+        } catch (MalformedURLException e) {\n+            throw new IllegalArgumentException(\"Path is malformed\", e);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitoutil/ClassLoadersTest.java\n+package org.mockitoutil;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.mockitoutil.ClassLoaders.isolatedClassLoader;\n+import org.junit.Test;\n+\n+public class ClassLoadersTest {\n+\n+    @Test(expected = ClassNotFoundException.class)\n+    public void isolated_class_loader_cannot_load_classes_when_no_given_prefix() throws Exception {\n+        // given\n+        ClassLoader cl = isolatedClassLoader().build();\n+\n+        // when\n+        cl.loadClass(\"org.mockito.Mockito\");\n+\n+        // then raises CNFE\n+    }\n+\n+    @Test\n+    public void isolated_class_loader_cannot_load_classes_If_no_code_source_path() throws Exception {\n+        // given\n+        ClassLoader cl = isolatedClassLoader()\n+                .withPrivateCopyOf(\"org.mockitoutil.IsolatedClassLoaderBuilderTest$ClassUsingInterface1\")\n+                .build();\n+\n+        // when\n+        try {\n+            cl.loadClass(\"org.mockitoutil.IsolatedClassLoaderBuilderTest$ClassUsingInterface1\");\n+        } catch (ClassNotFoundException e) {\n+            // then\n+            assertThat(e.getMessage()).contains(\"org.mockitoutil.IsolatedClassLoaderBuilderTest$ClassUsingInterface1\");\n+        }\n+    }\n+\n+    @Test\n+    public void isolated_class_loader_cannot_load_classes_that_require_other_non_declared_classes() throws Exception {\n+        // given\n+        ClassLoader cl = isolatedClassLoader()\n+                .withCurrentCodeSourceUrls()\n+                .withPrivateCopyOf(\"org.mockitoutil.IsolatedClassLoaderBuilderTest$ClassUsingInterface1\")\n+                .build();\n+\n+        // when\n+        try {\n+            cl.loadClass(\"org.mockitoutil.IsolatedClassLoaderBuilderTest$ClassUsingInterface1\");\n+        } catch (NoClassDefFoundError e) {\n+            // then\n+            assertThat(e.getMessage()).contains(\"org/mockitoutil/IsolatedClassLoaderBuilderTest$Interface1\");\n+        }\n+    }\n+\n+    @Test\n+    public void isolated_class_loader_can_load_all_classes_if_all_prefixes_correct() throws Exception {\n+        // given\n+        ClassLoader cl = isolatedClassLoader()\n+                .withCurrentCodeSourceUrls()\n+                .withPrivateCopyOf(\"org.mockitoutil.IsolatedClassLoaderBuilderTest$ClassUsingInterface1\")\n+                .withPrivateCopyOf(\"org.mockitoutil.IsolatedClassLoaderBuilderTest$Interface1\")\n+                .build();\n+\n+        // when\n+        Class<?> aClass = cl.loadClass(\"org.mockitoutil.IsolatedClassLoaderBuilderTest$ClassUsingInterface1\");\n+\n+        // then\n+        assertThat(aClass).isNotNull();\n+        assertThat(aClass.getClassLoader()).isEqualTo(cl);\n+        assertThat(aClass.getInterfaces()[0].getClassLoader()).isEqualTo(cl);\n+    }\n+\n+    @Test\n+    public void isolated_class_loader_has_no_parent() throws Exception {\n+        ClassLoader cl = isolatedClassLoader()\n+                .withCurrentCodeSourceUrls()\n+                .withPrivateCopyOf(\"org.mockitoutil.IsolatedClassLoaderBuilderTest$ClassUsingInterface1\")\n+                .withPrivateCopyOf(\"org.mockitoutil.IsolatedClassLoaderBuilderTest$Interface1\")\n+                .build();\n+\n+        assertThat(cl.getParent()).isNull();\n+    }\n+\n+\n+    static class ClassUsingInterface1 implements Interface1 { }\n+    interface Interface1 { }\n+}", "timestamp": 1386114666, "metainfo": ""}