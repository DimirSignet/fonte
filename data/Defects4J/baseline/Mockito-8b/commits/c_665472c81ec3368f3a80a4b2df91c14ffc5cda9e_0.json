{"sha": "665472c81ec3368f3a80a4b2df91c14ffc5cda9e", "log": "-finished implementing verification in order (in theory :) -minor refactorings  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%4064", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n @SuppressWarnings(\"unchecked\")\n public class Mockito extends Matchers {\n \n-    public final static VerifyingMode anyTimes = VerifyingMode.anyTimes();\n+    public static VerifyingMode atLeastOnce() {\n+        return VerifyingMode.atLeastOnce();\n+    }\n     \n-    public static VerifyingMode anyTimes() {\n-        return anyTimes;\n+    public static VerifyingMode times(int expectedNumerOfTimes) {\n+        return VerifyingMode.atLeastOnce();\n     }\n     \n     public static <T> T mock(Class<T> classToMock) {\n     }\n     \n     public static <T> T verify(T mock) {\n-        return verify(mock, VerifyingMode.anyTimes());\n+        return verify(mock, 1);\n     }\n     \n+    //TODO make the interface consistent, it should be times(4) rather than int\n     public static <T> T verify(T mock, int expectedNumberOfInvocations) {\n         return verify(mock, VerifyingMode.times(expectedNumberOfInvocations));\n     }\n \n \t/**\n \t * <pre>\n-\t * Throws an AssertionError if any of given mocks has any unverified interaction.\n+\t * Throws an AssertionError if any of given mocksToBeVerifiedInOrder has any unverified interaction.\n      * \n-     * Use this method after you verified all your mocks - to make sure that nothing \n-     * else was invoked on your mocks.\n+     * Use this method after you verified all your mocksToBeVerifiedInOrder - to make sure that nothing \n+     * else was invoked on your mocksToBeVerifiedInOrder.\n      * \n      * It's a good pattern not to use this method in every test method.\n      * Sometimes test method focuses on different behavior/interaction \n \t *    </code>\n \t *</pre>\n \t *\n-\t * @param mocks\n+\t * @param mocksToBeVerifiedInOrder\n \t */\n \tpublic static void verifyNoMoreInteractions(Object ... mocks) {\n \t    MockitoState.instance().checkForUnfinishedVerification();\n         return MockUtil.getControl(mock);\n     }\n \n-    public static StrictOrderVerifier strictOrderVerifier(Object ... mocks) {\n+    public static Strictly strictOrderVerifier(Object ... mocks) {\n         StrictOrderVerifier strictOrderVerifier = new StrictOrderVerifier();\n         for (Object mock : mocks) {\n             MockUtil.validateMock(mock);\n-            strictOrderVerifier.addMock(mock);\n+            strictOrderVerifier.addMockToBeVerifiedInOrder(mock);\n         }\n         return strictOrderVerifier;\n     }\n--- /dev/null\n+++ b/src/org/mockito/Strictly.java\n+package org.mockito;\n+\n+public interface Strictly {\n+\n+    <T> T verify(T mock);\n+\n+    //TODO get rid of interface with int\n+    <T> T verify(T mock, int expectedNumberOfInvocations);\n+\n+    void verifyNoMoreInteractions();\n+\n+}\n--- a/src/org/mockito/internal/MockitoBehavior.java\n+++ b/src/org/mockito/internal/MockitoBehavior.java\n \n     public void verify(InvocationWithMatchers invocation, VerifyingMode verifyingMode) {\n         int actuallyInvoked = numberOfActualInvocations(invocation);\n-        int expectedInvoked = verifyingMode.getExpectedNumberOfInvocations();\n+        Integer expectedInvoked = verifyingMode.getExpectedNumberOfInvocations();\n+        boolean atLeasOnce = verifyingMode.invokedAtLeastOnce();\n                \n-        if (expectedInvoked == 1 && actuallyInvoked == 0) {\n+        if ((atLeasOnce || expectedInvoked == 1) && actuallyInvoked == 0) {\n             //TODO this stuff is really hacked in, refactor, add more testing\n             InvocationWithMatchers similarInvocation = findSimilarInvocation(invocation);\n             String message = \n             throw new VerificationAssertionError(message);\n         }\n         \n-        if (actuallyInvoked != expectedInvoked) {\n+        if (!atLeasOnce && actuallyInvoked != expectedInvoked) {\n             throw new NumberOfInvocationsAssertionError(expectedInvoked, actuallyInvoked, invocation);\n         }\n \n--- a/src/org/mockito/internal/StrictOrderVerifier.java\n+++ b/src/org/mockito/internal/StrictOrderVerifier.java\n \n import java.util.*;\n \n-import org.mockito.Mockito;\n+import org.mockito.*;\n \n-public class StrictOrderVerifier {\n+public class StrictOrderVerifier implements Strictly {\n     \n-    List<Object> mocks = new LinkedList<Object>();\n+    List<Object> mocksToBeVerifiedInOrder = new LinkedList<Object>();\n     \n     public <T> T verify(T mock) {\n-        return Mockito.verify(mock, VerifyingMode.inSequence(null, mocks));\n+        return this.verify(mock, 1);\n     }\n     \n+    //TODO get rid of interface with int\n     public <T> T verify(T mock, int expectedNumberOfInvocations) {\n-        return Mockito.verify(mock, VerifyingMode.inSequence(expectedNumberOfInvocations, mocks));\n+        return Mockito.verify(mock, VerifyingMode.inOrder(expectedNumberOfInvocations, mocksToBeVerifiedInOrder));\n     }\n \n     public void verifyNoMoreInteractions() {\n-        MockitoState.instance().checkForUnfinishedVerification();\n+    //MockitoState.instance().checkForUnfinishedVerification();\n+    //TODO not implemented yet\n     }\n \n-    public void addMock(Object mock) {\n-        mocks.add(mock);\n+    public void addMockToBeVerifiedInOrder(Object mock) {\n+        mocksToBeVerifiedInOrder.add(mock);\n     }\n }\n--- a/src/org/mockito/internal/VerifyingMode.java\n+++ b/src/org/mockito/internal/VerifyingMode.java\n         this.mocksToBeVerifiedInSequence = mocksToBeVerifiedInSequence;\n     }\n     \n-    public static VerifyingMode anyTimes() {\n+    public static VerifyingMode atLeastOnce() {\n         return new VerifyingMode(null, Collections.emptyList());\n     }\n \n     public static VerifyingMode times(int expectedNumberOfInvocations) {\n         return new VerifyingMode(expectedNumberOfInvocations, Collections.emptyList());\n     }\n-\n-    public boolean numberOfInvocationsMatters() {\n-        return expectedNumberOfInvocations != null;\n+    \n+    /**\n+     * <pre>\n+     * Don't use VerifyingMode class directly. \n+     * \n+     * Use Mockito.atLeastOnce() and Mockito.times()\n+     * </pre>\n+     */\n+    public static void dont_use_this_class_directly_instead_use_static_methods_on_Mockito() {}\n+    \n+    static VerifyingMode inOrder(Integer expectedNumberOfInvocations, List<Object> mocksToBeVerifiedInOrder) {\n+        return new VerifyingMode(expectedNumberOfInvocations, mocksToBeVerifiedInOrder);\n     }\n \n-    public int getExpectedNumberOfInvocations() {\n-        return (expectedNumberOfInvocations==null)? 1 : expectedNumberOfInvocations;\n+    boolean invokedAtLeastOnce() {\n+        return expectedNumberOfInvocations == null;\n     }\n \n-    public List<Object> getAllMocksToBeVerifiedInSequence() {\n+    Integer getExpectedNumberOfInvocations() {\n+        return expectedNumberOfInvocations;\n+    }\n+\n+    List<Object> getAllMocksToBeVerifiedInSequence() {\n         return mocksToBeVerifiedInSequence;\n     }\n \n-    public static VerifyingMode inSequence(Integer expectedNumberOfInvocations, List<Object> mocks) {\n-        return new VerifyingMode(expectedNumberOfInvocations, mocks);\n-    }\n-\n-    public boolean orderOfInvocationsMatters() {\n+    boolean orderOfInvocationsMatters() {\n         return !mocksToBeVerifiedInSequence.isEmpty();\n     }\n }\n--- a/test/org/mockito/internal/MockControlTest.java\n+++ b/test/org/mockito/internal/MockControlTest.java\n         LastArguments lastArguments = LastArguments.instance();\n         \n         lastArguments.reportMatcher(new Equals(\"test\"));\n-        state.verifyingStarted(VerifyingMode.anyTimes());\n+        state.verifyingStarted(VerifyingMode.atLeastOnce());\n         \n         MockControl control = new MockControl(state, lastArguments);\n \n--- a/test/org/mockito/internal/MockitoStateTest.java\n+++ b/test/org/mockito/internal/MockitoStateTest.java\n     \n     @Test\n     public void shouldCheckIfVerificationWasFinished() throws Exception {\n-        mockitoState.verifyingStarted(VerifyingMode.anyTimes());\n+        mockitoState.verifyingStarted(VerifyingMode.atLeastOnce());\n         try {\n-            mockitoState.verifyingStarted(VerifyingMode.anyTimes());\n+            mockitoState.verifyingStarted(VerifyingMode.atLeastOnce());\n             fail();\n         } catch (MockitoException e) {}\n     }\n--- /dev/null\n+++ b/test/org/mockito/internal/VerifyingModeTest.java\n+package org.mockito.internal;\n+\n+import org.junit.Test;\n+import org.mockito.exceptions.MockitoException;\n+import org.mockito.internal.VerifyingMode;\n+\n+import static org.junit.Assert.*;\n+\n+public class VerifyingModeTest {\n+\n+    @Test\n+    public void shouldKnowIfNumberOfInvocationsMatters() throws Exception {\n+        VerifyingMode mode = VerifyingMode.atLeastOnce();\n+        assertTrue(mode.invokedAtLeastOnce());\n+        \n+        mode = VerifyingMode.times(50);\n+        assertFalse(mode.invokedAtLeastOnce());\n+    }\n+    \n+    @Test\n+    public void shouldNotAllowCreatingModeWithNegativeNumberOfInvocations() throws Exception {\n+        try {\n+            VerifyingMode.times(-50);\n+            fail();\n+        } catch (MockitoException e) {\n+            assertEquals(\"Negative value is not allowed here\", e.getMessage());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/usage/verification/AtLeastOnceVerificationTest.java\n+package org.mockito.usage.verification;\n+\n+import static org.mockito.Mockito.*;\n+\n+import java.util.List;\n+\n+import org.junit.*;\n+import org.mockito.Mockito;\n+import org.mockito.exceptions.VerificationAssertionError;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class AtLeastOnceVerificationTest {\n+\n+    private List mock;\n+    private List mockTwo;\n+    \n+    @Before public void setup() {\n+        mock = Mockito.mock(List.class);\n+        mockTwo = Mockito.mock(List.class);\n+    }\n+\n+    @Test\n+    public void shouldVerifyAtLeastOnce() throws Exception {\n+        mock.clear();\n+        mock.clear();\n+        \n+        mockTwo.add(\"add\");\n+\n+        verify(mock, atLeastOnce()).clear();\n+        verify(mockTwo, atLeastOnce()).add(\"add\");\n+        try {\n+            verify(mockTwo, atLeastOnce()).add(\"foo\");\n+        } catch (VerificationAssertionError e) {}\n+    }\n+    \n+    @Test(expected=VerificationAssertionError.class)\n+    public void shouldFailIfMethodWasNotCalledAtAll() throws Exception {\n+        verify(mock, atLeastOnce()).add(\"foo\");\n+    }\n+}\n--- a/test/org/mockito/usage/verification/BasicVerificationTest.java\n+++ b/test/org/mockito/usage/verification/BasicVerificationTest.java\n         \n         mockTwo.add(\"add\");\n \n-        verify(mock, anyTimes).clear();\n-        verify(mockTwo, anyTimes).add(\"add\");\n+        verify(mock, atLeastOnce()).clear();\n+        verify(mockTwo, atLeastOnce()).add(\"add\");\n         try {\n-            verify(mockTwo, anyTimes).add(\"foo\");\n+            verify(mockTwo, atLeastOnce()).add(\"foo\");\n         } catch (VerificationAssertionError e) {}\n     }\n \n     }\n \n     @Test\n-    public void shouldLetVerifyAnyTimes() throws Exception {\n-        mockTwo.add(\"foo\");\n-        mock.clear();\n-        mock.clear();\n-        \n-        verify(mockTwo, anyTimes).add(\"foo\");\n-\n-        try {\n-            verify(mock).clear();\n-            fail();\n-        } catch (NumberOfInvocationsAssertionError e) {};\n-    }\n-    \n-    @Test\n     public void shouldVerifyStubbedMethods() throws Exception {\n         stub(mock.add(\"test\")).andReturn(Boolean.FALSE);\n         \n--- a/test/org/mockito/usage/verification/NiceMessagesWhenVerificationFailsTest.java\n+++ b/test/org/mockito/usage/verification/NiceMessagesWhenVerificationFailsTest.java\n         }\n     }\n     \n+    @Test\n+    public void shouldPrintMethodNameWhenVerifyingAtLeastOnce() throws Exception {\n+        try {\n+            verify(mock, atLeastOnce()).twoArgumentMethod(1, 2);\n+            fail();\n+        } catch (VerificationAssertionError expected) {\n+            String actualMessage = expected.getMessage();\n+            String expectedMessage = \n+                \"\\n\" +\n+                \"Expected but not invoked:\" +\n+                \"\\n\" +\n+                \"IMethods.twoArgumentMethod(1, 2)\";\n+            assertEquals(expectedMessage, actualMessage);         \n+        }\n+    }\n+    \n     //TODO do we need nice message when expected number of invocations = 0?\n     \n }\n--- a/test/org/mockito/usage/verification/VerificationInOrderMixedWithOrdiraryVerificationTest.java\n+++ b/test/org/mockito/usage/verification/VerificationInOrderMixedWithOrdiraryVerificationTest.java\n import java.util.*;\n \n import org.junit.*;\n-import org.mockito.internal.StrictOrderVerifier;\n+import org.mockito.Strictly;\n \n @SuppressWarnings(\"unchecked\")  \n public class VerificationInOrderMixedWithOrdiraryVerificationTest {\n     private LinkedList list;\n     private HashMap map;\n     private HashSet set;\n-    private StrictOrderVerifier strictly;\n+    private Strictly strictly;\n \n     @Before\n     public void setUp() {\n--- a/test/org/mockito/usage/verification/VerificationInOrderTest.java\n+++ b/test/org/mockito/usage/verification/VerificationInOrderTest.java\n import java.util.*;\n \n import org.junit.*;\n+import org.mockito.Strictly;\n import org.mockito.exceptions.*;\n-import org.mockito.internal.StrictOrderVerifier;\n \n @SuppressWarnings(\"unchecked\")  \n public class VerificationInOrderTest {\n     private LinkedList list;\n     private HashMap map;\n     private HashSet set;\n-    private StrictOrderVerifier strictly;\n+    private Strictly strictly;\n \n     @Before\n     public void setUp() {\n         } catch (StrictVerificationError e) {}\n     }\n     \n-    @Ignore\n     @Test\n-    public void shouldFailOnWrongOrderWhenCheckingExpectedNumberOfInvocations2() {\n+    public void shouldFailWhenPriorVerificationCalledAgain() {\n         strictly.verify(list, 1).add(\"one\");\n         strictly.verify(map).put(\"two\", \"two\");\n-        strictly.verify(list).add(\"three and four\");\n+        strictly.verify(list, 2).add(\"three and four\");\n         try {\n-            strictly.verify(map, 1).put(\"five\", \"five\");\n+            strictly.verify(list, 1).add(\"one\");\n             fail();\n         } catch (StrictVerificationError e) {}\n     }", "timestamp": 1195955351, "metainfo": ""}