{"sha": "3ec1a3b662b5381786e4e2418a75077a3dc1bad9", "log": "In order to have earlier feedback when dev is doing stubbing/verification of restricted object methods  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401824", "commit": "\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n                 \"Example of correct verification:\",\n                 \"    verify(mock).doSomething()\",\n                 \"\",\n-                \"Also, this error might show up because you verify final/private/equals() or hashCode() method.\",\n+                \"Also, this error might show up because you verify final or private methods.\",\n                 \"Those methods *cannot* be stubbed/verified.\",\n                 \"\"\n         ));\n                 \"  when(mockOfConcreteClass.doStuff()).thenCallRealMethod();\"\n         ));\n     }\n+\n+    public void cannotVerifyToString() {\n+        throw new MockitoException(join(\n+                \"Mockito cannot verify toString()\",\n+                \"toString() is too often used behind of scenes  (i.e. during String concatenation, in IDE debugging views). \" +\n+                        \"Verifying it may give inconsistent or hard to understand results. \" +\n+                        \"Not to mention that verifying toString() most likely hints awkward design (hard to explain in a short exception message. Trust me...)\",\n+                \"However, it is possible to stub toString(). Stubbing toString() smells a bit funny but there are rare, legitimate use cases.\"\n+        ));\n+    }\n+\n+    public void cannotVerifyEqualsOrHashCode() {\n+                throw new MockitoException(join(\n+                \"Mockito cannot verify equals() and hashCode()\",\n+                \"Mockito defines and depends upon a specific implementation of these methods. Redefining them might break Mockito. Not to mention that verifying equals() or hashCode() most likely hints awkward design (hard to explain in a short exception message. Trust me...)\"\n+        ));\n+    }\n }\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n         mockingProgress.validateState();\n \n         if (verificationMode != null) {\n-            VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), invocationMatcher);\n+            VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), invocationMatcher);            \n             verificationMode.verify(data);\n             return null;\n         }\n--- a/src/org/mockito/internal/verification/VerificationDataImpl.java\n+++ b/src/org/mockito/internal/verification/VerificationDataImpl.java\n \n import java.util.List;\n \n+import org.mockito.exceptions.Reporter;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.util.ObjectMethodsGuru;\n import org.mockito.internal.verification.api.VerificationData;\n \n public class VerificationDataImpl implements VerificationData {\n     public VerificationDataImpl(List<Invocation> allInvocations, InvocationMatcher wanted) {\n         this.allInvocations = allInvocations;\n         this.wanted = wanted;\n+        this.assertWantedIsVerifiable();\n     }\n \n     public List<Invocation> getAllInvocations() {\n     public InvocationMatcher getWanted() {\n         return wanted;\n     }\n+\n+    void assertWantedIsVerifiable() {\n+        if (wanted == null) {\n+            return;\n+        }\n+        ObjectMethodsGuru o = new ObjectMethodsGuru();\n+        if (o.isToString(wanted.getMethod())) {\n+            new Reporter().cannotVerifyToString();\n+        }\n+        if (o.isEqualsMethod(wanted.getMethod())) {\n+            new Reporter().cannotVerifyEqualsOrHashCode();\n+        }\n+    }\n }\n--- /dev/null\n+++ b/test/org/mockito/internal/verification/VerificationDataImplTest.java\n+package org.mockito.internal.verification;\n+\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockitoutil.TestBase;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+public class VerificationDataImplTest extends TestBase {\n+\n+    @Mock\n+    List mock;\n+\n+    @Test\n+    public void shouldOrdinaryMethodBeVerifiable() throws Exception {\n+        VerificationDataImpl v = new VerificationDataImpl(null, new InvocationBuilder().toInvocationMatcher());\n+        v.assertWantedIsVerifiable();\n+    }\n+\n+    @Test\n+    public void shouldNotBreakWhenWantedIsNull() throws Exception {\n+        VerificationDataImpl v = new VerificationDataImpl(new LinkedList<Invocation>(), null);\n+        v.assertWantedIsVerifiable();\n+    }\n+\n+    @Test\n+    public void shouldToStringBeNotVerifiable() throws Exception {\n+        InvocationMatcher toString = new InvocationBuilder().method(\"toString\").toInvocationMatcher();\n+        try {\n+            new VerificationDataImpl(null, toString);\n+            fail();\n+        } catch (MockitoException e) {}\n+    }\n+\n+    @Test\n+    public void shouldEqualsBeNotVerifiable() throws Exception {\n+        InvocationMatcher equals = new InvocationMatcher(invocationOf(Object.class, \"equals\", new Object()));\n+        try {\n+            new VerificationDataImpl(null, equals);\n+            fail();\n+        } catch (MockitoException e) {}\n+    }\n+}\n--- a/test/org/mockitousage/PlaygroundTest.java\n+++ b/test/org/mockitousage/PlaygroundTest.java\n         public void withLong(long y) {\n             \n         }\n-    }\n-    \n-    @Test\n-    public void should() throws Exception {\n-        Boo boo = mock(Boo.class);\n-\n-        boo.toString();\n-        verify(boo).toString();\n     }\n \n     Foo mock;\n--- a/test/org/mockitousage/misuse/RestrictedObjectMethodsTest.java\n+++ b/test/org/mockitousage/misuse/RestrictedObjectMethodsTest.java\n \n import org.junit.Ignore;\n import org.junit.Test;\n+import org.mockito.InOrder;\n import org.mockito.Mock;\n+import org.mockito.exceptions.base.MockitoException;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n \n     @Mock IMethods mock;\n \n+    @Test(expected= MockitoException.class)\n+    public void shouldNotVerifyToString() {\n+        verify(mock).toString();\n+    }\n+\n     @Ignore\n-    @Test\n-    public void shouldNotAllowVerifyingRestrictedMethods() {\n-        //TODO: after 1.8 exception message should mention those methods are not verifiable\n-        verify(mock).toString();\n+    @Test(expected= MockitoException.class)\n+    public void shouldNotVerifyHashCode() {\n         verify(mock).hashCode();\n-        verify(mock).equals(null);\n+    }\n+\n+    @Ignore\n+    @Test(expected= MockitoException.class)\n+    public void shouldNotVerifyEquals() {\n+        InOrder inOrder = inOrder(mock);\n+        inOrder.verify(mock).equals(null);\n     }\n }\n--- a/test/org/mockitoutil/TestBase.java\n+++ b/test/org/mockitoutil/TestBase.java\n     }\n \n     protected static Invocation invocationOf(Class<?> type, String methodName, Object ... args) throws NoSuchMethodException {\n+        Class[] types = new Class[args.length];\n+        for (int i = 0; i < args.length; i++) {\n+            types[i] = args[i].getClass();\n+        }\n         return new Invocation(new Object(), new SerializableMethod(type.getMethod(methodName,\n-                new Class[0])), args, 1, null);\n+                types)), args, 1, null);\n     }\n \n     protected static Invocation invocationOf(Class<?> type, String methodName, RealMethod realMethod) throws NoSuchMethodException {", "timestamp": 1264024989, "metainfo": ""}