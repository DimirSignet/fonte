{"sha": "290317593ff91b75495669b545327dec6606bde2", "log": "yet another big check-in due to some off-line work -added the logic that resets ongoing stubbing on certain framework operations (mock, verify, doReturn). This is necessary to have better feedback from the framework when something is going wrong. -started adding validation on matchers. Matchers also use thread-local state so they should also take part in state validation  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401091", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n     \n     private static <T> T mock(Class<T> classToMock, String name, T optionalInstance, ReturnValues returnValues) {\n         MOCKING_PROGRESS.validateState();\n+        MOCKING_PROGRESS.resetOngoingStubbing();\n         return MockUtil.createMock(classToMock, MOCKING_PROGRESS, name, optionalInstance, returnValues);\n     }    \n \n      */\n     public static Stubber doAnswer(Answer answer) {\n         MOCKING_PROGRESS.stubbingStarted();\n+        MOCKING_PROGRESS.resetOngoingStubbing();\n         return new StubberImpl().doAnswer(answer);\n     }  \n     \n--- a/src/org/mockito/exceptions/misusing/InvalidUseOfMatchersException.java\n+++ b/src/org/mockito/exceptions/misusing/InvalidUseOfMatchersException.java\n     public InvalidUseOfMatchersException(String message) {\n         super(message);\n     }\n+\n+    public InvalidUseOfMatchersException(String message, MockitoException lastMatcherLocation) {\n+        super(message, lastMatcherLocation);\n+    }\n }\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n         \n         VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n         mockingProgress.validateState();\n-\n+        \n         Invocation invocation = new Invocation(proxy, method, args, SequenceNumber.next());\n         InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(invocation);\n \n--- a/src/org/mockito/internal/progress/LastArguments.java\n+++ b/src/org/mockito/internal/progress/LastArguments.java\n import java.util.Stack;\n \n import org.hamcrest.Matcher;\n+import org.mockito.exceptions.base.MockitoException;\n import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n import org.mockito.internal.matchers.And;\n import org.mockito.internal.matchers.Not;\n     }\n     \n     public EmptyReturnValues reportMatcher(Matcher matcher) {\n+//        matcherStack.push(new LocalizedMatcher(matcher));\n         matcherStack.push(matcher);\n         return new EmptyReturnValues();\n     }\n         matcherStack.push(new Or(popLastArgumentMatchers(2)));\n         return new EmptyReturnValues();\n     }\n+\n+    public void validateState() {\n+//        assertState(matcherStack.isEmpty(), \"Misplaced argument matcher.\");\n+        //TODO test cleanup?\n+        //TODO duplicated\n+        if (!matcherStack.isEmpty()) {\n+            MockitoException lastMatcherLocation = ((LocalizedMatcher) matcherStack.pop()).getLocation();\n+            matcherStack.clear();\n+            throw new InvalidUseOfMatchersException(\"Misplaced argument matcher.\", lastMatcherLocation);\n+        }\n+    }\n+\n+    public void reset() {\n+        matcherStack.clear();\n+    }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/progress/LocalizedMatcher.java\n+package org.mockito.internal.progress;\n+\n+import org.hamcrest.BaseMatcher;\n+import org.hamcrest.Description;\n+import org.hamcrest.Matcher;\n+import org.mockito.exceptions.base.MockitoException;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class LocalizedMatcher extends BaseMatcher {\n+\n+    private final Matcher matcher;\n+    private final MockitoException location;\n+\n+    public LocalizedMatcher(Matcher matcher) {\n+        this.matcher = matcher;\n+        this.location = new MockitoException(\"Argument matcher was used here:\");\n+    }\n+\n+    public MockitoException getLocation() {\n+        return location;\n+    }\n+\n+    public boolean matches(Object item) {\n+        return matcher.matches(item);\n+    }\n+\n+    public void describeTo(Description description) {\n+        matcher.describeTo(description);\n+    }\n+}\n--- a/src/org/mockito/internal/progress/MockingProgress.java\n+++ b/src/org/mockito/internal/progress/MockingProgress.java\n     void validateState();\n \n     void reset();\n+\n+    /**\n+     * Removes ongoing stubbing so that in case the framework is misused\n+     * state validation errors are more accurate\n+     */\n+    void resetOngoingStubbing();\n }\n--- a/src/org/mockito/internal/progress/MockingProgressImpl.java\n+++ b/src/org/mockito/internal/progress/MockingProgressImpl.java\n     \n     private final Reporter reporter = new Reporter();\n     \n-    private OngoingStubbing ongoingStubbing;\n+    OngoingStubbing ongoingStubbing;\n     private VerificationMode verificationMode;\n     private boolean stubbingInProgress = false;\n \n     \n     public void verificationStarted(VerificationMode verify) {\n         validateState();\n+        resetOngoingStubbing();\n         verificationMode = (VerificationMode) verify;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.mockito.internal.progress.MockingProgress#resetOngoingStubbing()\n+     */\n+    public void resetOngoingStubbing() {\n+        ongoingStubbing = null;\n     }\n \n     public VerificationMode pullVerificationMode() {\n             stubbingInProgress = false;\n             reporter.unfinishedStubbing();\n         }\n+      \n+        //TODO LastArguments should be somewhere here...\n+        //LastArguments.instance().validateState();\n     }\n \n     public void stubbingCompleted() {\n     public void reset() {\n         stubbingInProgress = false;\n         verificationMode = null;\n+        //TODO LastArguments should be somewhere here...\n+        LastArguments.instance().reset();\n     }\n }\n--- a/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java\n+++ b/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java\n     public void reset() {\n         threadSafely().reset();\n     }\n+\n+    public void resetOngoingStubbing() {\n+        threadSafely().resetOngoingStubbing();\n+    }\n }\n--- a/src/org/mockito/internal/stubbing/MockitoStubber.java\n+++ b/src/org/mockito/internal/stubbing/MockitoStubber.java\n         }\n         answersForStubbing.clear();\n     }\n+    \n+    @Override\n+    public String toString() {\n+        return \"invocationForStubbing: \" + invocationForStubbing;\n+    }\n }\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.internal.util;\n+\n+import java.lang.reflect.Method;\n \n import net.sf.cglib.proxy.Callback;\n import net.sf.cglib.proxy.Enhancer;\n public class MockUtil {\n     \n     public static <T> T createMock(Class<T> classToMock, MockingProgress progress, String mockName, T optionalInstance, ReturnValues returnValues) {\n+        Method[] methods = classToMock.getMethods();\n         validateType(classToMock);\n         if (mockName == null) {\n             mockName = toInstanceName(classToMock);\n--- a/test/org/mockito/internal/MockHandlerTest.java\n+++ b/test/org/mockito/internal/MockHandlerTest.java\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.MatchersBinder;\n+import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.MockingProgressImpl;\n import org.mockito.internal.verification.VerificationModeFactory;\n import org.mockitoutil.TestBase;\n     \n     @Test\n     public void shouldRemoveVerificationModeEvenWhenInvalidMatchers() throws Throwable {\n-        MockingProgressImpl state = new MockingProgressImpl();\n+        MockingProgress state = new MockingProgressImpl();\n         state.verificationStarted(VerificationModeFactory.atLeastOnce());\n         MockHandler handler = new MockHandler(null, state, new ExceptionThrowingBinder(), null);\n         \n--- a/test/org/mockito/internal/stubbing/MockitoStubberTest.java\n+++ b/test/org/mockito/internal/stubbing/MockitoStubberTest.java\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.MockingProgressImpl;\n import org.mockitoutil.TestBase;\n \n public class MockitoStubberTest extends TestBase{\n \n     private MockitoStubber mockitoStubber;\n-    private MockingProgressImpl state;\n+    private MockingProgress state;\n     private Invocation simpleMethod;\n     \n     @Before\n--- a/test/org/mockitousage/PlaygroundTest.java\n+++ b/test/org/mockitousage/PlaygroundTest.java\n  */\n package org.mockitousage;\n \n-import java.util.LinkedList;\n-import java.util.List;\n+import static org.mockito.Mockito.*;\n \n import org.junit.Test;\n-import org.mockito.Mock;\n import org.mockito.Mockito;\n import org.mockitoutil.TestBase;\n \n @SuppressWarnings(\"unchecked\")\n public class PlaygroundTest extends TestBase {\n \n-    List list = new LinkedList();\n-    List spy = Mockito.spy(list);\n-    @Mock IMethods mock;\n-    \n+    private static class BaseClass {\n+        private final String s;\n+\n+        public BaseClass(String s) {\n+            s.getClass(); //NPE check\n+            this.s = s;\n+        }\n+\n+        public boolean isLarger(int i) {\n+            return s.length() < i;\n+        }\n+    }\n+\n+    /**\n+     * This test succeeds.\n+     */\n     @Test\n-    public void playWithSomething() {\n-        //Here you can play with mockito\n+    public void testSpyOfBaseClass() {\n+        BaseClass ci = spy(new BaseClass(\"test\"));\n+        assertEquals(false, ci.isLarger(2));\n+    }\n+\n+    private static class Subclass extends BaseClass {\n+        public Subclass(String s) {\n+            super(s);\n+        }\n+\n+        public boolean isLarger(int i) {\n+            return super.isLarger(i);\n+        }\n+    }\n+\n+    /**\n+     * This test fails with a NullPointerException.\n+     */\n+    @Test\n+    public void testSpyOfSubclass() {\n+        BaseClass ci = spy(new Subclass(\"test\"));\n+        assertEquals(false, ci.isLarger(2));\n     }\n }\n--- /dev/null\n+++ b/test/org/mockitousage/misuse/CleaningUpPotentialStubbingTest.java\n+package org.mockitousage.misuse;\n+\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.Test;\n+import org.mockito.InOrder;\n+import org.mockito.Mock;\n+import org.mockito.exceptions.misusing.MissingMethodInvocationException;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+public class CleaningUpPotentialStubbingTest extends TestBase {\n+\n+    @Mock private IMethods mock;\n+    \n+    @Test\n+    public void shouldResetOngoingStubbingOnVerify() {\n+        // first test\n+        mock.booleanReturningMethod();\n+        verify(mock).booleanReturningMethod();\n+        \n+        // second test\n+        assertOngoingStubbingIsReset();\n+    }\n+    \n+    @Test\n+    public void shouldResetOngoingStubbingOnMock() {\n+        mock.booleanReturningMethod();\n+        mock(IMethods.class);\n+        assertOngoingStubbingIsReset();\n+    }\n+    \n+    @Test\n+    public void shouldResetOngoingStubbingOnInOrder() {\n+        mock.booleanReturningMethod();\n+        InOrder inOrder = inOrder(mock);\n+        inOrder.verify(mock).booleanReturningMethod();\n+        assertOngoingStubbingIsReset();\n+    }\n+    \n+    @Test\n+    public void shouldResetOngoingStubbingOnDoReturn() {\n+        mock.booleanReturningMethod();\n+        doReturn(false).when(mock).booleanReturningMethod();\n+        assertOngoingStubbingIsReset();\n+    }\n+\n+    private void assertOngoingStubbingIsReset() {\n+        try {\n+            //In real, there might be a call to real object or a final method call\n+            //I'm modelling it with null\n+            when(null).thenReturn(\"anything\");\n+            fail();\n+        } catch (MissingMethodInvocationException e) {}\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/misuse/DetectingFinalMethodsTest.java\n+package org.mockitousage.misuse;\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.exceptions.misusing.MissingMethodInvocationException;\n+import org.mockito.exceptions.misusing.UnfinishedVerificationException;\n+import org.mockito.internal.util.MockUtil;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+public class DetectingFinalMethodsTest extends TestBase {\n+    \n+    class WithFinal {\n+        final int foo() {\n+            return 0;\n+        }\n+    }\n+    \n+    @Mock private WithFinal withFinal;\n+    @Mock private IMethods mock;\n+\n+    @Test\n+    public void shouldFailWithUnfinishedVerification() {\n+        withFinal = mock(WithFinal.class);\n+        verify(withFinal).foo();\n+        try {\n+            verify(withFinal).foo();\n+            fail();\n+        } catch (UnfinishedVerificationException e) {}\n+    }\n+\n+    @Test\n+    public void shouldFailWithUnfinishedStubbing() {\n+        withFinal = mock(WithFinal.class);\n+        MockUtil.getMockHandler(withFinal);\n+        try {\n+            when(withFinal.foo()).thenReturn(null);\n+            fail();\n+        } catch (MissingMethodInvocationException e) {}\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/misuse/DetectingMisusedMatchersTest.java\n+package org.mockitousage.misuse;\n+\n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.StateMaster;\n+import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.ExtraMatchers;\n+import org.mockitoutil.TestBase;\n+\n+public class DetectingMisusedMatchersTest extends TestBase {\n+\n+    class WithFinal {\n+        final Object finalMethod(Object object) {\n+            return null;\n+        }\n+    }\n+\n+    @Mock private WithFinal withFinal;\n+    \n+    @Before\n+    @After\n+    public void resetState() {\n+        StateMaster.reset();\n+    }\n+\n+    private void misplacedArgumentMatcher() {\n+        anyObject();\n+    }\n+\n+    @Ignore\n+    @Test\n+    public void shouldFailFastWhenArgumentMatchersAbused() {\n+        misplacedArgumentMatcher();\n+        try {\n+            mock(IMethods.class);\n+            fail();\n+        } catch (InvalidUseOfMatchersException e) {\n+            assertThat(e, messageContains(\"Misplaced argument matcher\"));\n+            assertThat(e.getCause(), ExtraMatchers.hasFirstMethodInStackTrace(\"misplacedArgumentMatcher\"));\n+        }\n+    }\n+}\n--- a/test/org/mockitousage/misuse/InvalidStateDetectionTest.java\n+++ b/test/org/mockitousage/misuse/InvalidStateDetectionTest.java\n  */\n package org.mockitousage.misuse;\n \n+import static org.mockito.Matchers.*;\n import static org.mockito.Mockito.*;\n \n import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.StateMaster;\n+import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n import org.mockito.exceptions.misusing.UnfinishedStubbingException;\n import org.mockito.exceptions.misusing.UnfinishedVerificationException;\n import org.mockitousage.IMethods;\n+import org.mockitoutil.ExtraMatchers;\n import org.mockitoutil.TestBase;\n \n /**\n         //Make sure state is OK\n         StateMaster.validate();\n     }\n-}\n+}", "timestamp": 1227995647, "metainfo": ""}