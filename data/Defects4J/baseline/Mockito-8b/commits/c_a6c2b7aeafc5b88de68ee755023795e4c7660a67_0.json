{"sha": "a6c2b7aeafc5b88de68ee755023795e4c7660a67", "log": "Merge pull request #39 from alberskib/iss456  [#456] Enable calling real implementation on extensions method from jdk8", "commit": "\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n         ));\n     }\n \n-    public void cannotCallRealMethodOnInterface() {\n-        throw new MockitoException(join(\n-                \"Cannot call real method on java interface. Interface does not have any implementation!\",\n-                \"Calling real methods is only possible when mocking concrete classes.\",\n+    public void cannotCallAbstractRealMethod() {\n+        throw new MockitoException(join(\n+                \"Cannot call abstract real method on java object!\",\n+                \"Calling real methods is only possible when mocking non abstract method.\",\n                 \"  //correct example:\",\n-                \"  when(mockOfConcreteClass.doStuff()).thenCallRealMethod();\"\n+                \"  when(mockOfConcreteClass.nonAbstractMethod()).thenCallRealMethod();\"\n         ));\n     }\n \n--- a/src/org/mockito/internal/creation/DelegatingMethod.java\n+++ b/src/org/mockito/internal/creation/DelegatingMethod.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.creation;\n \n import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n \n import org.mockito.internal.invocation.MockitoMethod;\n \n     public boolean isVarArgs() {\n         return method.isVarArgs();\n     }\n+\n+    @Override\n+    public boolean isAbstract() {\n+        return (method.getModifiers() & Modifier.ABSTRACT) != 0;\n+    }\n     \n     @Override\n     public int hashCode() {\n--- /dev/null\n+++ b/src/org/mockito/internal/invocation/AbstractAwareMethod.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal.invocation;\n+\n+public interface AbstractAwareMethod {\n+    boolean isAbstract();\n+}\n--- a/src/org/mockito/internal/invocation/InvocationImpl.java\n+++ b/src/org/mockito/internal/invocation/InvocationImpl.java\n     }\n \n     public Object callRealMethod() throws Throwable {\n-        if (this.getMethod().getDeclaringClass().isInterface()) {\n-            new Reporter().cannotCallRealMethodOnInterface();\n+        if (method.isAbstract()) {\n+            new Reporter().cannotCallAbstractRealMethod();\n         }\n         return realMethod.invoke(mock, rawArguments);\n     }\n--- a/src/org/mockito/internal/invocation/MockitoMethod.java\n+++ b/src/org/mockito/internal/invocation/MockitoMethod.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.invocation;\n \n import java.lang.reflect.Method;\n \n-public interface MockitoMethod {\n+public interface MockitoMethod extends AbstractAwareMethod {\n \n     public String getName();\n \n--- a/src/org/mockito/internal/invocation/SerializableMethod.java\n+++ b/src/org/mockito/internal/invocation/SerializableMethod.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.invocation;\n \n import java.io.Serializable;\n import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n import java.util.Arrays;\n \n import org.mockito.exceptions.base.MockitoException;\n     private Class<?> returnType;\n     private Class<?>[] exceptionTypes;\n     private boolean isVarArgs;\n+    private boolean isAbstract;\n \n     public SerializableMethod(Method method) {\n         declaringClass = method.getDeclaringClass();\n         returnType = method.getReturnType();\n         exceptionTypes = method.getExceptionTypes();\n         isVarArgs = method.isVarArgs();\n+        isAbstract = (method.getModifiers() & Modifier.ABSTRACT) != 0;\n     }\n \n     public String getName() {\n \n     public boolean isVarArgs() {\n         return isVarArgs;\n-    }  \n+    }\n+\n+    @Override\n+    public boolean isAbstract() {\n+        return isAbstract;\n+    }\n \n     public Method getJavaMethod() {\n         try {\n                             \"Please report this as a defect with an example of how to reproduce it.\", declaringClass, methodName);\n             throw new MockitoException(message, e);\n         }\n-    }    \n+    }\n \n     @Override\n     public int hashCode() {\n--- a/src/org/mockito/internal/stubbing/answers/AnswersValidator.java\n+++ b/src/org/mockito/internal/stubbing/answers/AnswersValidator.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.stubbing.answers;\n \n import org.mockito.exceptions.Reporter;\n     }\n \n     private void validateMockingConcreteClass(CallsRealMethods answer, MethodInfo methodInfo) {\n-        if (methodInfo.isDeclaredOnInterface()) {\n-            reporter.cannotCallRealMethodOnInterface();\n+        if (methodInfo.isAbstract()) {\n+            reporter.cannotCallAbstractRealMethod();\n         }\n     }\n \n--- a/src/org/mockito/internal/stubbing/answers/MethodInfo.java\n+++ b/src/org/mockito/internal/stubbing/answers/MethodInfo.java\n  */\n package org.mockito.internal.stubbing.answers;\n \n+import org.mockito.internal.invocation.AbstractAwareMethod;\n import org.mockito.internal.util.Primitives;\n import org.mockito.invocation.Invocation;\n \n import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n \n /**\n  * by Szczepan Faber, created at: 3/31/12\n  */\n-public class MethodInfo {\n+public class MethodInfo implements AbstractAwareMethod {\n \n     private Method method;\n \n     public boolean isDeclaredOnInterface() {\n         return method.getDeclaringClass().isInterface();\n     }\n+\n+    @Override\n+    public boolean isAbstract() {\n+        return (method.getModifiers() & Modifier.ABSTRACT) != 0;\n+    }\n }\n--- a/src/org/mockito/BDDMockito.java\n+++ b/src/org/mockito/BDDMockito.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito;\n \n import org.mockito.stubbing.Answer;\n import org.mockito.stubbing.OngoingStubbing;\n import org.mockito.stubbing.Stubber;\n+import org.mockito.verification.VerificationMode;\n \n /**\n  * Behavior Driven Development style of writing tests uses <b>//given //when //then</b> comments as fundamental parts of your test methods.\n  *   assertEquals(failure, result);\n  * </code></pre>\n  * <p>\n+ * For BDD style mock verification take a look at {@link Then} in action:\n+ * <pre class=\"code\"><code class=\"java\">\n+ * Bike bike = new Bike();\n+ * Person person = mock(Person.class);\n+ *\n+ * public void shouldRideBikeTwice() {\n+ *\n+ *     person.ride(bike);\n+ *     person.ride(bike);\n+ *\n+ *     then(person).should(times(2)).ride(bike);\n+ * }\n+ * </code></pre>\n+ *\n+ * Syntax alternative to the last example:\n+ * <pre class=\"code\"><code class=\"java\">\n+ * public void shouldRideBikeTwice() {\n+ *\n+ *     person.ride(bike);\n+ *     person.ride(bike);\n+ *\n+ *     then(person).verify(times(2)).ride(bike);\n+ * }\n+ * </code></pre>\n+ *\n  * One of the purposes of BDDMockito is also to show how to tailor the mocking syntax to a different programming style.\n  *\n  * @since 1.8.0\n      * See original {@link OngoingStubbing}\n      * @since 1.8.0\n      */\n-    public static interface BDDMyOngoingStubbing<T> {\n+    public interface BDDMyOngoingStubbing<T> {\n         \n         /**\n          * See original {@link OngoingStubbing#thenAnswer(Answer)}\n     public static <T> BDDMyOngoingStubbing<T> given(T methodCall) {\n         return new BDDOngoingStubbingImpl<T>(Mockito.when(methodCall));\n     }\n+\n+    /**\n+     * Bdd style verification of mock behavior.\n+     *\n+     * @see #verify(Object)\n+     * @see #verify(Object, VerificationMode)\n+     */\n+    public static <T> Then<T> then(T mock) {\n+        return new Then<T>(mock);\n+    }\n+\n+    /**\n+     * Provides fluent way of mock verification.\n+     *\n+     * @author Lovro Pandzic\n+     * @param <T> type of the mock\n+     */\n+    public final static class Then<T> {\n+\n+        private final T mock;\n+\n+        public Then(T mock) {\n+\n+            this.mock = mock;\n+        }\n+\n+        /**\n+         * @see #verify(Object)\n+         */\n+        public T should() {\n+            return Mockito.verify(mock);\n+        }\n+\n+        /**\n+         * @see #verify(Object, VerificationMode)\n+         */\n+        public T should(VerificationMode mode) {\n+            return Mockito.verify(mock, mode);\n+        }\n+\n+        /**\n+         * @see #verify(Object)\n+         */\n+        public T verify() {\n+            return Mockito.verify(mock);\n+        }\n+\n+        /**\n+         * @see #verify(Object, VerificationMode)\n+         */\n+        public T verify(VerificationMode mode) {\n+            return Mockito.verify(mock, mode);\n+        }\n+    }\n     \n     /**\n      * See original {@link Stubber}\n      * @since 1.8.0\n      */\n-    public static interface BDDStubber {\n+    public interface BDDStubber {\n         /**\n          * See original {@link Stubber#doAnswer(Answer)}\n          * @since 1.8.0\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n  *      <a href=\"#26\">26. (**New**) Mocking details (Since 1.9.5)</a><br/>\n  *      <a href=\"#27\">27. (**New**) Delegate calls to real instance (Since 1.9.5)</a><br/>\n  *      <a href=\"#28\">28. (**New**) <code>MockMaker</code> API (Since 1.9.5)</a><br/>\n+ *      <a href=\"#29\">29. (**New**) BDD style verification (Since 1.9.8)</a><br/>\n  * </b>\n  * \n  * <p>\n  * <p>For more details, motivations and examples please refer to\n  * the docs for {@link org.mockito.plugins.MockMaker}.\n  *\n+ *\n+ *\n+ *\n+ * <h3 id=\"29\">29. (**New**) <a class=\"meaningful_link\" href=\"#BDD_behavior_verification\">BDD style verification</a> (Since 1.9.8)</h3>\n+ *\n+ * Enables Behavior Driven Development (BDD) style verification by starting verification with the BDD <b>then</b> keyword.\n+ *\n+ * For more information and an example see {@link BDDMockito}.\n  */\n @SuppressWarnings(\"unchecked\")\n public class Mockito extends Matchers {\n--- a/src/org/mockito/internal/creation/AcrossJVMSerializationFeature.java\n+++ b/src/org/mockito/internal/creation/AcrossJVMSerializationFeature.java\n      *\n      * @see #enableSerializationAcrossJVM(org.mockito.mock.MockCreationSettings)\n      */\n-    public static interface AcrossJVMMockitoMockSerializable {\n+    public interface AcrossJVMMockitoMockSerializable {\n         public Object writeReplace() throws java.io.ObjectStreamException;\n     }\n }\n--- a/src/org/mockito/internal/invocation/InvocationImpl.java\n+++ b/src/org/mockito/internal/invocation/InvocationImpl.java\n \n     public Object[] getArguments() {\n         return arguments;\n+    }\n+    \n+    @Override\n+    public <T> T getArgumentAt(int index, Class<T> clazz) {\n+        return (T) arguments[index];\n     }\n \n     public boolean isVerified() {\n--- a/src/org/mockito/internal/invocation/InvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/InvocationsFinder.java\n         return unverified;\n     }\n     \n-    private class RemoveNotMatching implements Filter<Invocation> {\n+    private static class RemoveNotMatching implements Filter<Invocation> {\n         private final InvocationMatcher wanted;\n \n         private RemoveNotMatching(InvocationMatcher wanted) {\n         }\n     }\n \n-    private class RemoveUnverifiedInOrder implements Filter<Invocation> {\n+    private static class RemoveUnverifiedInOrder implements Filter<Invocation> {\n         private final InOrderContext orderingContext;\n \n         public RemoveUnverifiedInOrder(InOrderContext orderingContext) {\n--- a/src/org/mockito/internal/invocation/finder/AllInvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/finder/AllInvocationsFinder.java\n         return new LinkedList<Invocation>(invocationsInOrder);\n     }\n \n-    private final class SequenceNumberComparator implements Comparator<Invocation> {\n+    private static final class SequenceNumberComparator implements Comparator<Invocation> {\n         public int compare(Invocation o1, Invocation o2) {\n             return Integer.valueOf(o1.getSequenceNumber()).compareTo(o2.getSequenceNumber());\n         }\n--- a/src/org/mockito/internal/invocation/finder/VerifiableInvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/finder/VerifiableInvocationsFinder.java\n package org.mockito.internal.invocation.finder;\n \n import org.mockito.internal.util.collections.ListUtil;\n+import org.mockito.internal.util.collections.ListUtil.Filter;\n import org.mockito.invocation.Invocation;\n \n import java.util.List;\n         return ListUtil.filter(invocations, new RemoveIgnoredForVerification());\n     }\n \n-    static class RemoveIgnoredForVerification implements ListUtil.Filter<Invocation>{\n-        public boolean isOut(Invocation i) {\n-            return i.isIgnoredForVerification();\n+    private static class RemoveIgnoredForVerification implements Filter<Invocation>{\n+        public boolean isOut(Invocation invocation) {\n+            return invocation.isIgnoredForVerification();\n         }\n     }\n }\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n  */\n package org.mockito.internal.stubbing.defaultanswers;\n \n-import static org.mockito.Mockito.*;\n+import static org.mockito.Mockito.withSettings;\n \n+import java.io.IOException;\n import java.io.Serializable;\n-\n import org.mockito.MockSettings;\n+import org.mockito.Mockito;\n import org.mockito.internal.InternalMockHandler;\n import org.mockito.internal.MockitoCore;\n import org.mockito.internal.creation.settings.CreationSettings;\n     \n     private static final long serialVersionUID = -7105341425736035847L;\n \n-    private transient MockitoCore mockitoCore;\n-    private transient ReturnsEmptyValues delegate;\n-\n     public Object answer(InvocationOnMock invocation) throws Throwable {\n         GenericMetadataSupport returnTypeGenericMetadata =\n                 actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());\n \n         Class<?> rawType = returnTypeGenericMetadata.rawType();\n-        instantiateMockitoCoreIfNeeded();\n-        instantiateDelegateIfNeeded();\n-        if (!mockitoCore.isTypeMockable(rawType)) {\n-            return delegate.returnValueFor(rawType);\n+        if (!mockitoCore().isTypeMockable(rawType)) {\n+            return delegate().returnValueFor(rawType);\n         }\n \n-        return getMock(invocation, returnTypeGenericMetadata);\n+        return deepStub(invocation, returnTypeGenericMetadata);\n     }\n \n-    private synchronized void instantiateMockitoCoreIfNeeded() {\n-        if (mockitoCore == null) {\n-            mockitoCore = new MockitoCore();\n-        }\n-    }\n-\n-    private synchronized void instantiateDelegateIfNeeded() {\n-        if (delegate == null) {\n-            delegate = new ReturnsEmptyValues();\n-        }\n-    }\n-\n-    private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {\n+    private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {\n     \tInternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\n     \tInvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();\n \n     \t\t}\n \t\t}\n \n-        // deep stub\n-        return recordDeepStubMock(createNewDeepStubMock(returnTypeGenericMetadata), container);\n+        // record deep stub answer\n+        return recordDeepStubAnswer(newDeepStubMock(returnTypeGenericMetadata), container);\n     }\n \n     /**\n      * @param returnTypeGenericMetadata The metadata to use to create the new mock.\n      * @return The mock\n      */\n-    private Object createNewDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {\n-        return mockitoCore.mock(\n+    private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {\n+        return mockitoCore().mock(\n                 returnTypeGenericMetadata.rawType(),\n                 withSettingsUsing(returnTypeGenericMetadata)\n         );\n     }\n \n     private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {\n-        MockSettings mockSettings =\n-                returnTypeGenericMetadata.rawExtraInterfaces().length > 0 ?\n+        MockSettings mockSettings = returnTypeGenericMetadata.hasRawExtraInterfaces() ?\n                 withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())\n                 : withSettings();\n \n     }\n \n     private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {\n-        return new ReturnsDeepStubs() {\n-            @Override\n-            protected GenericMetadataSupport actualParameterizedType(Object mock) {\n-                return returnTypeGenericMetadata;\n-            }\n-        };\n+        return new ReturnsDeepStubsSerializationFallback(returnTypeGenericMetadata);\n     }\n \n-    private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {\n-\n-        container.addAnswer(new SerializableAnswer() {\n-            public Object answer(InvocationOnMock invocation) throws Throwable {\n-                return mock;\n-            }\n-        }, false);\n-\n+    private Object recordDeepStubAnswer(final Object mock, InvocationContainerImpl container) throws Throwable {\n+        container.addAnswer(new DeeplyStubbedAnswer(mock), false);\n         return mock;\n     }\n-\t\n-\tabstract class SerializableAnswer implements Answer<Object>, Serializable {\n-\t\t\n-\t}\n-\t\n \n     protected GenericMetadataSupport actualParameterizedType(Object mock) {\n         CreationSettings mockSettings = (CreationSettings) new MockUtil().getMockHandler(mock).getMockSettings();\n         return GenericMetadataSupport.inferFrom(mockSettings.getTypeToMock());\n     }\n+\n+\n+    private static class ReturnsDeepStubsSerializationFallback extends ReturnsDeepStubs implements Serializable {\n+        @SuppressWarnings(\"serial\") // not gonna be serialized\n+        private final GenericMetadataSupport returnTypeGenericMetadata;\n+\n+        public ReturnsDeepStubsSerializationFallback(GenericMetadataSupport returnTypeGenericMetadata) {\n+            this.returnTypeGenericMetadata = returnTypeGenericMetadata;\n+        }\n+\n+        @Override\n+        protected GenericMetadataSupport actualParameterizedType(Object mock) {\n+            return returnTypeGenericMetadata;\n+        }\n+        private Object writeReplace() throws IOException {\n+            return Mockito.RETURNS_DEEP_STUBS;\n+        }\n+    }\n+\n+\n+    private static class DeeplyStubbedAnswer implements Answer<Object>, Serializable {\n+        @SuppressWarnings(\"serial\") // serialization will fail with a nice message if mock not serializable\n+        private Object mock;\n+\n+        DeeplyStubbedAnswer(Object mock) {\n+            this.mock = mock;\n+        }\n+        @Override\n+        public Object answer(InvocationOnMock invocation) throws Throwable {\n+            return mock;\n+        }\n+    }\n+\n+\n+    private static MockitoCore mockitoCore() {\n+        return LazyHolder.MOCKITO_CORE;\n+    }\n+\n+    private static ReturnsEmptyValues delegate() {\n+        return LazyHolder.DELEGATE;\n+    }\n+\n+    private static class LazyHolder {\n+        private static final MockitoCore MOCKITO_CORE = new MockitoCore();\n+        private static final ReturnsEmptyValues DELEGATE = new ReturnsEmptyValues();\n+    }\n }\n--- a/src/org/mockito/internal/util/collections/ListUtil.java\n+++ b/src/org/mockito/internal/util/collections/ListUtil.java\n         return filtered;\n     }\n     \n-    public static interface Filter<T> {\n+    public interface Filter<T> {\n         boolean isOut(T object);\n     }\n }\n--- a/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n+++ b/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n package org.mockito.internal.util.reflection;\n \n \n+import java.lang.reflect.Method;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.lang.reflect.WildcardType;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n import org.mockito.Incubating;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.util.Checks;\n-\n-import java.io.Serializable;\n-import java.lang.reflect.*;\n-import java.util.*;\n \n \n /**\n  * @see org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs\n  */\n @Incubating\n-public abstract class GenericMetadataSupport implements Serializable {\n+public abstract class GenericMetadataSupport {\n \n     // public static MockitoLogger logger = new ConsoleMockitoLogger();\n \n     }\n \n     protected void registerTypeParametersOn(TypeVariable[] typeParameters) {\n-        for (TypeVariable typeParameter : typeParameters) {\n-            contextualActualTypeParameters.put(typeParameter, boundsOf(typeParameter));\n-            // logger.log(\"For '\" + typeParameter.getGenericDeclaration() + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + boundsOf(typeParameter) + \"' }\");\n+        for (TypeVariable typeVariable : typeParameters) {\n+            registerTypeVariableIfNotPresent(typeVariable);\n+        }\n+    }\n+\n+    private void registerTypeVariableIfNotPresent(TypeVariable typeVariable) {\n+        if (!contextualActualTypeParameters.containsKey(typeVariable)) {\n+            contextualActualTypeParameters.put(typeVariable, boundsOf(typeVariable));\n+            // logger.log(\"For '\" + typeVariable.getGenericDeclaration() + \"' found type variable : { '\" + typeVariable + \"(\" + System.identityHashCode(typeVariable) + \")\" + \"' : '\" + boundsOf(typeVariable) + \"' }\");\n         }\n     }\n \n         return new Class[0];\n     }\n \n+    /**\n+     * @return Returns true if metadata knows about extra-interfaces {@link #extraInterfaces()} <strong>if relevant</strong>.\n+     */\n+    public boolean hasRawExtraInterfaces() {\n+        return rawExtraInterfaces().length > 0;\n+    }\n+\n \n \n     /**\n      * the class and its ancestors and interfaces.\n      */\n     private static class FromClassGenericMetadataSupport extends GenericMetadataSupport {\n-        private Class<?> clazz;\n+        private final Class<?> clazz;\n \n         public FromClassGenericMetadataSupport(Class<?> clazz) {\n             this.clazz = clazz;\n-            readActualTypeParametersOnDeclaringClass();\n-        }\n-\n-        private void readActualTypeParametersOnDeclaringClass() {\n+\n+            for (Class currentExploredClass = clazz;\n+                 currentExploredClass != null && currentExploredClass != Object.class;\n+                 currentExploredClass = superClassOf(currentExploredClass)\n+                ) {\n+                readActualTypeParametersOnDeclaringClass(currentExploredClass);\n+            }\n+        }\n+\n+        private Class superClassOf(Class currentExploredClass) {\n+            Type genericSuperclass = currentExploredClass.getGenericSuperclass();\n+            if (genericSuperclass instanceof ParameterizedType) {\n+                Type rawType = ((ParameterizedType) genericSuperclass).getRawType();\n+                return (Class) rawType;\n+            }\n+            return (Class) genericSuperclass;\n+        }\n+\n+        private void readActualTypeParametersOnDeclaringClass(Class<?> clazz) {\n             registerTypeParametersOn(clazz.getTypeParameters());\n             registerTypeVariablesOn(clazz.getGenericSuperclass());\n             for (Type genericInterface : clazz.getGenericInterfaces()) {\n      * Instead use {@link ParameterizedReturnType}.\n      */\n     private static class FromParameterizedTypeGenericMetadataSupport extends GenericMetadataSupport {\n-        private ParameterizedType parameterizedType;\n+        private final ParameterizedType parameterizedType;\n \n         public FromParameterizedTypeGenericMetadataSupport(ParameterizedType parameterizedType) {\n             this.parameterizedType = parameterizedType;\n      * @see WildCardBoundedType\n      * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.5.1\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.5.1</a>\n      */\n-    public static interface BoundedType extends Type {\n+    public interface BoundedType extends Type {\n         Type firstBound();\n \n         Type[] interfaceBounds();\n      * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>\n      */\n     public static class TypeVarBoundedType implements BoundedType {\n-        private TypeVariable typeVariable;\n+        private final TypeVariable typeVariable;\n \n \n         public TypeVarBoundedType(TypeVariable typeVariable) {\n \n         @Override\n         public String toString() {\n-            final StringBuilder sb = new StringBuilder();\n-            sb.append(\"{firstBound=\").append(firstBound());\n-            sb.append(\", interfaceBounds=\").append(Arrays.deepToString(interfaceBounds()));\n-            sb.append('}');\n-            return sb.toString();\n+            return \"{firstBound=\" + firstBound() + \", interfaceBounds=\" + Arrays.deepToString(interfaceBounds()) + '}';\n         }\n \n         public TypeVariable typeVariable() {\n      *\n      * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>\n      */\n-    public static class WildCardBoundedType implements BoundedType, Serializable {\n-        private WildcardType wildcard;\n+    public static class WildCardBoundedType implements BoundedType {\n+        private final WildcardType wildcard;\n \n \n         public WildCardBoundedType(WildcardType wildcard) {\n \n         @Override\n         public String toString() {\n-            final StringBuilder sb = new StringBuilder();\n-            sb.append(\"{firstBound=\").append(firstBound());\n-            sb.append(\", interfaceBounds=[]}\");\n-            return sb.toString();\n+            return \"{firstBound=\" + firstBound() + \", interfaceBounds=[]}\";\n         }\n \n         public WildcardType wildCard() {\n--- a/src/org/mockito/invocation/InvocationOnMock.java\n+++ b/src/org/mockito/invocation/InvocationOnMock.java\n      * @return arguments\n      */\n     Object[] getArguments();\n+    \n+    /**\n+    * Returns casted argument using position\n+    * @param index argument position\n+    * @param clazz argument type\n+    * @return casted argument on position\n+    */\n+    <T extends Object> T getArgumentAt(int index, Class<T> clazz);\n+\n \n     /**\n      * calls real method\n--- a/test/org/mockito/internal/InvalidStateDetectionTest.java\n+++ b/test/org/mockito/internal/InvalidStateDetectionTest.java\n         verify(mock).simpleMethod();\n     }\n     \n-    private static interface DetectsInvalidState {\n+    private interface DetectsInvalidState {\n         void detect(IMethods mock);\n     }\n     \n--- a/test/org/mockito/internal/invocation/InvocationImplTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationImplTest.java\n             fail();\n         } catch(MockitoException e) {}\n     }\n+    \n+    @Test\n+    public void shouldReturnCastedArgumentAt(){\n+        //given\n+        int argument = 42;\n+        Invocation invocationOnInterface = new InvocationBuilder().method(\"twoArgumentMethod\").\n+            argTypes(int.class, int.class).args(1, argument).toInvocation();\n+\n+        //when\n+        int secondArgument = invocationOnInterface.getArgumentAt(1, int.class);\n+\n+        //then\n+        assertTrue(secondArgument == argument);\n+    }\n }\n--- a/test/org/mockito/internal/stubbing/answers/ReturnsArgumentAtTest.java\n+++ b/test/org/mockito/internal/stubbing/answers/ReturnsArgumentAtTest.java\n package org.mockito.internal.stubbing.answers;\n \n import org.junit.Test;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.invocation.InvocationImpl;\n import org.mockito.internal.stubbing.answers.ReturnsArgumentAt;\n import org.mockito.invocation.InvocationOnMock;\n import org.mockitousage.IMethods;\n         }\n     }\n \n-\tprivate static InvocationOnMock invocationWith(final String... parameters) {\n-        return new InvocationOnMock() {\n-\n-            public Object getMock() {\n-                return null;\n-            }\n-\n-            public Method getMethod() {\n-                try {\n-                    return IMethods.class.getDeclaredMethod(\"varargsReturningString\", Object[].class);\n-                } catch (NoSuchMethodException e) {\n-                    throw new RuntimeException(e);\n-                }\n-            }\n-\n-            public Object[] getArguments() {\n-                return parameters;\n-            }\n-\n-            public Object callRealMethod() throws Throwable {\n-                return null;\n-            }\n-        };\n-    }\n+\tprivate static InvocationOnMock invocationWith(Object... parameters) {\n+\t\treturn new InvocationBuilder().method(\"varargsReturningString\").argTypes(Object[].class)\n+ \t\t\t.args(parameters).toInvocation();\n+\t}\n \n }\n--- a/test/org/mockito/internal/util/reflection/FieldInitializerTest.java\n+++ b/test/org/mockito/internal/util/reflection/FieldInitializerTest.java\n         public AbstractStaticClass() {}\n     }\n \n-    static interface Interface {\n+    interface Interface {\n \n     }\n \n--- a/test/org/mockito/internal/util/reflection/GenericMetadataSupportTest.java\n+++ b/test/org/mockito/internal/util/reflection/GenericMetadataSupportTest.java\n import java.lang.reflect.Method;\n import java.lang.reflect.Type;\n import java.lang.reflect.TypeVariable;\n+import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n         <O extends K> O typeVar_with_type_params();\n     }\n \n+    static class StringList extends ArrayList<String> { }\n+\n+\n     @Test\n     public void can_get_raw_type_from_Class() throws Exception {\n         assertThat(inferFrom(ListOfAnyNumbers.class).rawType()).isEqualTo(ListOfAnyNumbers.class);\n         assertThat(inferFrom(ListOfNumbers.class).rawType()).isEqualTo(ListOfNumbers.class);\n         assertThat(inferFrom(GenericsNest.class).rawType()).isEqualTo(GenericsNest.class);\n+        assertThat(inferFrom(StringList.class).rawType()).isEqualTo(StringList.class);\n     }\n \n \n         assertThat(inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).rawType()).isEqualTo(List.class);\n         assertThat(inferFrom(ListOfNumbers.class.getGenericInterfaces()[0]).rawType()).isEqualTo(List.class);\n         assertThat(inferFrom(GenericsNest.class.getGenericInterfaces()[0]).rawType()).isEqualTo(Map.class);\n+        assertThat(inferFrom(StringList.class.getGenericSuperclass()).rawType()).isEqualTo(ArrayList.class);\n     }\n \n     @Test\n         assertThat(inferFrom(ListOfAnyNumbers.class).actualTypeArguments().keySet()).hasSize(1).onProperty(\"name\").contains(\"N\");\n         assertThat(inferFrom(Map.class).actualTypeArguments().keySet()).hasSize(2).onProperty(\"name\").contains(\"K\", \"V\");\n         assertThat(inferFrom(Serializable.class).actualTypeArguments().keySet()).isEmpty();\n+        assertThat(inferFrom(StringList.class).actualTypeArguments().keySet()).isEmpty();\n     }\n \n     @Test\n         assertThat(inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).onProperty(\"name\").contains(\"E\");\n         assertThat(inferFrom(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).onProperty(\"name\").contains(\"T\");\n         assertThat(inferFrom(StringBuilder.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).isEmpty();\n+        assertThat(inferFrom(StringList.class).actualTypeArguments().keySet()).isEmpty();\n+    }\n+\n+    @Test\n+    public void typeVariable_return_type_of____iterator____resolved_to_Iterator_and_type_argument_to_String() throws Exception {\n+        GenericMetadataSupport genericMetadata = inferFrom(StringList.class).resolveGenericReturnType(firstNamedMethod(\"iterator\", StringList.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(Iterator.class);\n+        assertThat(genericMetadata.actualTypeArguments().values()).contains(String.class);\n     }\n \n     @Test\n--- a/test/org/mockitousage/bugs/ConcurrentModificationExceptionOnMultiThreadedVerificationTest.java\n+++ b/test/org/mockitousage/bugs/ConcurrentModificationExceptionOnMultiThreadedVerificationTest.java\n \t\t\n \t}\n \t\n-\tpublic static interface ITarget {\n+\tpublic interface ITarget {\n \n \t\tpublic String targetMethod(String arg);\n \t}\n--- a/test/org/mockitousage/bugs/CovariantOverrideTest.java\n+++ b/test/org/mockitousage/bugs/CovariantOverrideTest.java\n //see issue 101\n public class CovariantOverrideTest extends TestBase {\n    \n-    public static interface ReturnsObject {\n+    public interface ReturnsObject {\n         Object callMe();\n     }\n \n-    public static interface ReturnsString extends ReturnsObject {\n+    public interface ReturnsString extends ReturnsObject {\n         // Java 5 covariant override of method from parent interface\n         String callMe();\n     }\n--- a/test/org/mockitousage/bugs/ShouldNotDeadlockAnswerExecutionTest.java\n+++ b/test/org/mockitousage/bugs/ShouldNotDeadlockAnswerExecutionTest.java\n \n     }\n \n-    static interface Service {\n+    interface Service {\n \n         String verySlowMethod();\n \n--- a/test/org/mockitousage/customization/BDDMockitoTest.java\n+++ b/test/org/mockitousage/customization/BDDMockitoTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage.customization;\n \n import org.junit.Test;\n import org.mockito.Mock;\n+import org.mockito.exceptions.misusing.NotAMockException;\n+import org.mockito.exceptions.verification.WantedButNotInvoked;\n import org.mockito.invocation.InvocationOnMock;\n import org.mockito.stubbing.Answer;\n import org.mockitousage.IMethods;\n import static org.mockito.BDDMockito.*;\n \n public class BDDMockitoTest extends TestBase {\n-    \n+\n     @Mock IMethods mock;\n-    \n+\n     @Test\n     public void shouldStub() throws Exception {\n         given(mock.simpleMethod(\"foo\")).willReturn(\"bar\");\n-        \n+\n         assertEquals(\"bar\", mock.simpleMethod(\"foo\"));\n         assertEquals(null, mock.simpleMethod(\"whatever\"));\n     }\n-    \n+\n     @Test\n     public void shouldStubWithThrowable() throws Exception {\n         given(mock.simpleMethod(\"foo\")).willThrow(new RuntimeException());\n             fail();\n         } catch(RuntimeException e) {}\n     }\n-    \n+\n     @Test\n     public void shouldStubWithAnswer() throws Exception {\n         given(mock.simpleMethod(anyString())).willAnswer(new Answer<String>() {\n             public String answer(InvocationOnMock invocation) throws Throwable {\n                 return (String) invocation.getArguments()[0];\n             }});\n-        \n+\n         assertEquals(\"foo\", mock.simpleMethod(\"foo\"));\n     }\n \n        given(mock.simpleMethod(anyString()))\n            .willReturn(\"foo\")\n            .willReturn(\"bar\");\n-       \n+\n        assertEquals(\"foo\", mock.simpleMethod(\"whatever\"));\n        assertEquals(\"bar\", mock.simpleMethod(\"whatever\"));\n     }\n        assertEquals(\"foo\", mock.simpleMethod());\n        assertEquals(null, mock.simpleMethod());\n     }\n-    \n+\n     @Test\n     public void shouldStubVoid() throws Exception {\n         willThrow(new RuntimeException()).given(mock).voidMethod();\n-        \n+\n         try {\n             mock.voidMethod();\n             fail();\n         willDoNothing()\n         .willThrow(new RuntimeException())\n         .given(mock).voidMethod();\n-        \n+\n         mock.voidMethod();\n         try {\n             mock.voidMethod();\n             fail();\n         } catch(IllegalArgumentException e) {}\n     }\n-    \n+\n     @Test\n     public void shouldStubUsingDoReturnStyle() throws Exception {\n         willReturn(\"foo\").given(mock).simpleMethod(\"bar\");\n-        \n+\n         assertEquals(null, mock.simpleMethod(\"boooo\"));\n         assertEquals(\"foo\", mock.simpleMethod(\"bar\"));\n     }\n-    \n+\n     @Test\n     public void shouldStubUsingDoAnswerStyle() throws Exception {\n         willAnswer(new Answer<String>() {\n                 return (String) invocation.getArguments()[0];\n             }})\n         .given(mock).simpleMethod(anyString());\n-        \n+\n         assertEquals(\"foo\", mock.simpleMethod(\"foo\"));\n     }\n-    \n+\n     class Dog {\n         public String bark() {\n             return \"woof\";\n         //then\n         assertEquals(\"woof\", dog.bark());\n     }\n-    \n+\n     @Test\n     public void shouldStubByDelegatingToRealMethodUsingTypicalStubbingSyntax() throws Exception {\n         //given\n \n         assertEquals(expectedMock, returnedMock);\n     }\n+\n+    @Test(expected = NotAMockException.class)\n+    public void shouldValidateMockWhenVerifying() {\n+\n+        then(\"notMock\").should();\n+    }\n+\n+    @Test(expected = NotAMockException.class)\n+    public void shouldValidateMockWhenVerifyingWithExpectedNumberOfInvocations() {\n+\n+        then(\"notMock\").should(times(19));\n+    }\n+\n+    @Test(expected = NotAMockException.class)\n+    public void shouldValidateMockWhenVerifyingNoMoreInteractions() {\n+\n+        then(\"notMock\").should();\n+    }\n+\n+    @Test(expected = WantedButNotInvoked.class)\n+    public void shouldFailForExpectedBehaviorThatDidNotHappen() {\n+\n+        then(mock).should().booleanObjectReturningMethod();\n+    }\n+\n+    @Test\n+    public void shouldPassForExpectedBehaviorThatHappened() {\n+\n+        mock.booleanObjectReturningMethod();\n+\n+        then(mock).should().booleanObjectReturningMethod();\n+    }\n+\n+    @Test(expected = WantedButNotInvoked.class)\n+    public void shouldFailForExpectedBehaviorThatDidNotHappenWithVerify() {\n+\n+        then(mock).verify().booleanObjectReturningMethod();\n+    }\n+\n+    @Test\n+    public void shouldPassForExpectedBehaviorThatHappenedWithVerify() {\n+\n+        mock.booleanObjectReturningMethod();\n+\n+        then(mock).verify().booleanObjectReturningMethod();\n+    }\n+\n+    @Test\n+    public void shouldPassFluentBddScenario() {\n+\n+        Bike bike = new Bike();\n+        Person person = mock(Person.class);\n+\n+        person.ride(bike);\n+        person.ride(bike);\n+\n+        then(person).should(times(2)).ride(bike);\n+    }\n+\n+    @Test\n+    public void shouldPassFluentBddScenarioWithVerify() {\n+\n+        Bike bike = new Bike();\n+        Person person = mock(Person.class);\n+\n+        person.ride(bike);\n+        person.ride(bike);\n+\n+        then(person).verify(times(2)).ride(bike);\n+    }\n+\n+    static class Person {\n+\n+        void ride(Bike bike) {}\n+    }\n+\n+    static class Bike {\n+\n+    }\n }\n--- /dev/null\n+++ b/test/org/mockitousage/serialization/DeepStubsSerializableTest.java\n+package org.mockitousage.serialization;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.Mockito.withSettings;\n+import static org.mockitoutil.SimpleSerializationUtil.serializeAndBack;\n+\n+import java.io.Serializable;\n+import java.util.Iterator;\n+import java.util.List;\n+import org.junit.Test;\n+\n+public class DeepStubsSerializableTest {\n+\n+    @Test\n+    public void should_serialize_and_deserialize_mock_created_with_deep_stubs() throws Exception {\n+        // given\n+        SampleClass sampleClass = mock(SampleClass.class, withSettings().defaultAnswer(RETURNS_DEEP_STUBS).serializable());\n+        when(sampleClass.getSample().isFalse()).thenReturn(true);\n+        when(sampleClass.getSample().number()).thenReturn(999);\n+\n+        // when\n+        SampleClass deserializedSample = serializeAndBack(sampleClass);\n+\n+        // then\n+        assertThat(deserializedSample.getSample().isFalse()).isEqualTo(true);\n+        assertThat(deserializedSample.getSample().number()).isEqualTo(999);\n+    }\n+\n+\t@Test\n+\tpublic void should_serialize_and_deserialize_parameterized_class_mocked_with_deep_stubs() throws Exception {\n+\t\t// given\n+\t\tListContainer deep_stubbed = mock(ListContainer.class, withSettings().defaultAnswer(RETURNS_DEEP_STUBS).serializable());\n+\t\twhen(deep_stubbed.iterator().next().add(\"yes\")).thenReturn(true);\n+\n+\t\t// when\n+\t\tListContainer deserialized_deep_stub = serializeAndBack(deep_stubbed);\n+\t\t\n+\t\t// then\n+\t\tassertThat(deserialized_deep_stub.iterator().next().add(\"not stubbed but mock already previously resolved\")).isEqualTo(false);\n+        assertThat(deserialized_deep_stub.iterator().next().add(\"yes\")).isEqualTo(true);\n+\t}\n+\n+\t@Test(expected = ClassCastException.class)\n+\tpublic void should_discard_generics_metadata_when_serialized_then_disabling_deep_stubs_with_generics() throws Exception {\n+\t\t// given\n+\t\tListContainer deep_stubbed = mock(ListContainer.class, withSettings().defaultAnswer(RETURNS_DEEP_STUBS).serializable());\n+\t\twhen(deep_stubbed.iterator().hasNext()).thenReturn(true);\n+\n+\t\tListContainer deserialized_deep_stub = serializeAndBack(deep_stubbed);\n+\n+\t\t// when stubbing on a deserialized mock\n+        when(deserialized_deep_stub.iterator().next().get(42)).thenReturn(\"no\");\n+\n+\t\t// then revert to the default RETURNS_DEEP_STUBS and the code will raise a ClassCastException\n+\t}\n+\n+\n+    static class SampleClass implements Serializable {\n+        SampleClass2 getSample() { return new SampleClass2(); }\n+    }\n+\n+    static class SampleClass2 implements Serializable {\n+        boolean isFalse() { return false; }\n+        int number() { return 100; }\n+    }\n+\n+    static class Container<E> implements Iterable<E>, Serializable {\n+        private E e;\n+        public Container(E e) { this.e = e; }\n+        public E get() { return e; }\n+\n+        @Override\n+        public Iterator<E> iterator() {\n+            return new Iterator<E>() {\n+                @Override public boolean hasNext() { return true; }\n+                @Override public E next() { return e; }\n+                @Override public void remove() { }\n+            };\n+        }\n+    }\n+\n+    static class ListContainer extends Container<List<String>> {\n+        public ListContainer(List<String> list) { super(list); }\n+    }\n+}\n--- a/test/org/mockitoutil/SimplePerRealmReloadingClassLoader.java\n+++ b/test/org/mockitoutil/SimplePerRealmReloadingClassLoader.java\n     }\n \n \n-    public static interface ReloadClassPredicate {\n+    public interface ReloadClassPredicate {\n         boolean acceptReloadOf(String qualifiedName);\n     }\n }", "timestamp": 1395864787, "metainfo": ""}