{"sha": "98d682f40c5eb6700a7f52aea651b46309db076e", "log": "changes around mock Factory  --HG-- rename : src/org/mockito/internal/creation/ObjectMethodsFilter.java => src/org/mockito/internal/creation/MethodInterceptorFilter.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40219", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.MockHandler;\n import org.mockito.internal.MockUtil;\n-import org.mockito.internal.creation.MockFactory;\n-import org.mockito.internal.creation.ObjectMethodsFilter;\n-import org.mockito.internal.invocation.MatchersBinder;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.OngoingStubbing;\n import org.mockito.internal.progress.ThreadSafeMockingProgress;\n     static final MockingProgress MOCKING_PROGRESS = new ThreadSafeMockingProgress();\n \n     public static <T> T mock(Class<T> classToMock) {\n-        MockFactory<T> proxyFactory = new MockFactory<T>();\n-        MockHandler<T> mockHandler = new MockHandler<T>(MOCKING_PROGRESS, new MatchersBinder());\n-        return proxyFactory.createMock(classToMock, new ObjectMethodsFilter<MockHandler>(\n-                classToMock, mockHandler));\n+        return MockUtil.createMock(classToMock, MOCKING_PROGRESS);\n     }\n \n     public static <T> OngoingStubbing<T> stub(T methodCallToStub) {\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n import java.util.Arrays;\n import java.util.List;\n \n-import org.mockito.internal.creation.MockAwareInvocationHandler;\n+import net.sf.cglib.proxy.MethodProxy;\n+\n+import org.mockito.internal.creation.MockAwareInterceptor;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsChunker;\n  *\n  * @param <T> type of mock object to handle\n  */\n-public class MockHandler<T> implements MockAwareInvocationHandler<T>, OngoingStubbing<T>, VoidMethodStubable<T>, StubbedMethodSelector<T> {\n+public class MockHandler<T> implements MockAwareInterceptor<T>, OngoingStubbing<T>, VoidMethodStubable<T>, StubbedMethodSelector<T> {\n \n     private final VerifyingRecorder verifyingRecorder;\n     private final Stubber stubber;\n         return new VerifyingRecorder(chunker, marker, verifiers);\n     }\n \n-    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n         if (stubber.hasThrowableForVoidMethod()) {\n             Invocation invocation = new Invocation(proxy, method, args, mockingProgress.nextSequenceNumber());\n             InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(invocation);\n--- a/src/org/mockito/internal/MockUtil.java\n+++ b/src/org/mockito/internal/MockUtil.java\n \n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.exceptions.misusing.NotAMockException;\n-import org.mockito.internal.creation.ObjectMethodsFilter;\n-import org.mockito.internal.creation.MockFactory.MockMethodInterceptor;\n+import org.mockito.internal.creation.MethodInterceptorFilter;\n+import org.mockito.internal.creation.MockFactory;\n+import org.mockito.internal.invocation.MatchersBinder;\n+import org.mockito.internal.progress.MockingProgress;\n \n public class MockUtil {\n     \n-    private static MockMethodInterceptor getInterceptor(Object mock) {\n-        Factory factory = (Factory) mock;\n-        return (MockMethodInterceptor) factory.getCallback(0);\n+    public static <T> T createMock(Class<T> classToMock, MockingProgress progress) {\n+        MockFactory<T> proxyFactory = new MockFactory<T>();\n+        MockHandler<T> mockHandler = new MockHandler<T>(progress, new MatchersBinder());\n+        MethodInterceptorFilter<MockHandler<T>> filter = new MethodInterceptorFilter<MockHandler<T>>(classToMock, mockHandler);\n+        return proxyFactory.createMock(classToMock, filter);\n     }\n     \n-    @SuppressWarnings(\"unchecked\")\n     public static <T> MockHandler<T> getMockHandler(T mock) {\n         if (mock == null) {\n             throw new MockitoException(\"Mock cannot be null\");\n         }\n         \n-        ObjectMethodsFilter<MockHandler<T>> handler;\n-\n         try {\n             if (Enhancer.isEnhanced(mock.getClass())) {\n-                handler = (ObjectMethodsFilter) getInterceptor(mock)\n-                        .getHandler();\n+                return ((MethodInterceptorFilter<MockHandler<T>>) getInterceptor(mock)).getDelegate();\n             } else {\n                 throw new NotAMockException(mock);\n             }\n-            \n-            return handler.getDelegate();\n         } catch (ClassCastException e) {\n             throw new NotAMockException(mock);\n         }\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    private static <T> MethodInterceptorFilter<MockHandler<T>> getInterceptor(T mock) {\n+        Factory factory = (Factory) mock;\n+        return (MethodInterceptorFilter) factory.getCallback(0);\n     }\n     \n     public static void validateMock(Object mock) {\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/MethodInterceptorFilter.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation;\n+\n+import java.lang.reflect.Method;\n+\n+import net.sf.cglib.proxy.MethodProxy;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class MethodInterceptorFilter<T extends MockAwareInterceptor> implements MockAwareInterceptor {\n+    \n+    private final Method equalsMethod;\n+    private final Method hashCodeMethod;\n+    private final Method toStringMethod;\n+\n+    private final T delegate;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public MethodInterceptorFilter(Class toMock, T delegate) {\n+        try {\n+            if (toMock.isInterface()) {\n+                toMock = Object.class;\n+            }\n+            equalsMethod = toMock.getMethod(\"equals\", new Class[] { Object.class });\n+            hashCodeMethod = toMock.getMethod(\"hashCode\", (Class[]) null);\n+            toStringMethod = toMock.getMethod(\"toString\", (Class[]) null);\n+        } catch (NoSuchMethodException e) {\n+            throw new RuntimeException(\"An Object method could not be found!\");\n+        }\n+        this.delegate = delegate;\n+    }\n+\n+    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy)\n+            throws Throwable {\n+        if (method.isBridge()) {\n+            return methodProxy.invokeSuper(proxy, args);\n+        }\n+        \n+        if (equalsMethod.equals(method)) {\n+            return Boolean.valueOf(proxy == args[0]);\n+        } else if (hashCodeMethod.equals(method)) {\n+            return new Integer(System.identityHashCode(proxy));\n+        } else if (toStringMethod.equals(method)) {\n+            return mockToString(proxy);\n+        }\n+        \n+        return delegate.intercept(proxy, method, args, null);\n+    }\n+\n+    private String mockToString(Object mock) {\n+        return \"Mock for \" + MockNamer.nameForMock(mock);\n+    }\n+\n+    public T getDelegate() {\n+        return delegate;\n+    }\n+\n+    public void setMock(Object mock) {\n+        delegate.setMock(mock);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/creation/MockAwareInterceptor.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.creation;\n+\n+import java.lang.reflect.Method;\n+\n+import net.sf.cglib.proxy.MethodInterceptor;\n+import net.sf.cglib.proxy.MethodProxy;\n+\n+public interface MockAwareInterceptor<T> extends MethodInterceptor {\n+  \n+    Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable;\n+    \n+    void setMock(T mock);\n+    \n+}\n--- a/src/org/mockito/internal/creation/MockFactory.java\n+++ b/src/org/mockito/internal/creation/MockFactory.java\n  */\n package org.mockito.internal.creation;\n \n-import java.lang.reflect.InvocationHandler;\n-import java.lang.reflect.Method;\n import java.util.List;\n-\n \n import net.sf.cglib.core.CollectionUtils;\n import net.sf.cglib.core.VisibilityPredicate;\n import net.sf.cglib.proxy.Callback;\n import net.sf.cglib.proxy.Enhancer;\n import net.sf.cglib.proxy.Factory;\n-import net.sf.cglib.proxy.MethodInterceptor;\n-import net.sf.cglib.proxy.MethodProxy;\n \n /**\n  * Factory generating a mock for a class.\n  */\n public class MockFactory<T> {\n \n-    public static interface MockMethodInterceptor extends MethodInterceptor {\n-        InvocationHandler getHandler();\n+    @SuppressWarnings(\"unchecked\")\n+    public T createMock(Class<T> toMock, final MethodInterceptorFilter filter) {\n+        Enhancer enhancer = createEnhancer(toMock);\n+        enhancer.setCallbackType(filter.getClass());\n+\n+        Class mockClass = enhancer.createClass();\n+        Enhancer.registerCallbacks(mockClass, new Callback[] { filter });\n+\n+        Factory mock = createMock(mockClass);\n+\n+        filter.setMock(mock);\n+        return (T) mock;\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n-    public T createMock(Class<T> toMock, final MockAwareInvocationHandler handler) {\n-\n-        MethodInterceptor interceptor = new MockMethodInterceptor() {\n-\n-            public Object intercept(Object obj, Method method, Object[] args,\n-                    MethodProxy proxy) throws Throwable {\n-                if (method.isBridge()) {\n-                    return proxy.invokeSuper(obj, args);\n-                }\n-                return handler.invoke(obj, method, args);\n-            }\n-\n-            public InvocationHandler getHandler() {\n-                return handler;\n-            }\n-        };\n-\n+    private Enhancer createEnhancer(Class<T> toMock) {\n         Enhancer enhancer = new Enhancer() {\n-            /**\n-             * Filter all private constructors but do not check that there are\n-             * some left\n-             */\n+            @SuppressWarnings(\"unchecked\")\n+            //Filter all private constructors but do not check that there are some left\n             protected void filterConstructors(Class sc, List constructors) {\n                 CollectionUtils.filter(constructors, new VisibilityPredicate(\n                         sc, true));\n         } else {\n             enhancer.setSuperclass(toMock);\n         }\n+        return enhancer;\n+    }\n \n-        enhancer.setCallbackType(interceptor.getClass());\n-\n-        Class mockClass = enhancer.createClass();\n-        Enhancer.registerCallbacks(mockClass, new Callback[] { interceptor });\n-\n+    private Factory createMock(Class<?> mockClass) {\n         Factory mock;\n         try {\n             mock = (Factory) ObjenesisClassInstantiator.newInstance(mockClass);\n         } catch (InstantiationException e) {\n-            throw new RuntimeException(\"Fail to instantiate mock for \" + toMock\n+            throw new RuntimeException(\"Fail to instantiate mock for \" + mockClass\n                     + \" on \" + System.getProperty(\"java.vm.vendor\") + \" JVM\");\n         }\n \n         // why I'm calling it here mock.getCallback(0);\n \n         mock.getCallback(0);\n-\n-        handler.setMock(mock);\n-        return (T) mock;\n+        return mock;\n     }\n }\n--- a/src/org/mockito/internal/progress/MockingProgress.java\n+++ b/src/org/mockito/internal/progress/MockingProgress.java\n \n     void reportStubable(OngoingStubbing ongoingStubbing);\n \n-    //TODO stubabble\n     OngoingStubbing pullStubable();\n \n     void verificationStarted(VerificationMode verificationMode);\n--- a/test/org/mockito/MockUtilTest.java\n+++ b/test/org/mockito/MockUtilTest.java\n \n import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.fail;\n-import static org.mockito.internal.MockUtil.getMockHandler;\n-import static org.mockito.internal.MockUtil.validateMock;\n+import static org.mockito.internal.MockUtil.*;\n \n import java.util.ArrayList;\n import java.util.List;\n--- a/test/org/mockito/internal/MockHandlerTest.java\n+++ b/test/org/mockito/internal/MockHandlerTest.java\n         MockHandler handler = new MockHandler(state, new ExceptionThrowingBinder());\n         \n         try {\n-            handler.invoke(null, String.class.getDeclaredMethod(\"toString\"), new Object[]{});\n+            handler.intercept(null, String.class.getDeclaredMethod(\"toString\"), new Object[]{}, null);\n             fail();\n         } catch (InvalidUseOfMatchersException e) {}\n         \n--- a/test/org/mockito/internal/creation/MockFactoryTest.java\n+++ b/test/org/mockito/internal/creation/MockFactoryTest.java\n         }\n     };\n     \n-    private final class MockAwareStub extends ObjectMethodsFilter {\n+    private final class MockAwareStub extends MethodInterceptorFilter {\n         public MockAwareStub() {\n             super(Object.class, null);\n         }\n--- a/test/org/mockitousage/ReplacingObjectMethodsTest.java\n+++ b/test/org/mockitousage/ReplacingObjectMethodsTest.java\n     \n     public static class ObjectMethodsOverridden {\n         public boolean equals(Object o) {\n-            throw new RuntimeException(\"Should not be called. ObjectMethodsFilter provides implementation\");\n+            throw new RuntimeException(\"Should not be called. MethodInterceptorFilter provides implementation\");\n         }\n         public int hashCode() {\n-            throw new RuntimeException(\"Should not be called. ObjectMethodsFilter provides implementation\");\n+            throw new RuntimeException(\"Should not be called. MethodInterceptorFilter provides implementation\");\n         }\n         public String toString() {\n-            throw new RuntimeException(\"Should not be called. ObjectMethodsFilter provides implementation\");\n+            throw new RuntimeException(\"Should not be called. MethodInterceptorFilter provides implementation\");\n         }\n     }\n     ", "timestamp": 1197826994, "metainfo": ""}