{"sha": "8ff3c9a97c2800f66df5676b6e1b769629e87787", "log": "renamed InvocationWithMatchers -> ExpectedInvocation  --HG-- rename : src/org/mockito/internal/InvocationWithMatchers.java => src/org/mockito/internal/ExpectedInvocation.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%4072", "commit": "\n--- a/src/org/mockito/exceptions/NumberOfInvocationsAssertionError.java\n+++ b/src/org/mockito/exceptions/NumberOfInvocationsAssertionError.java\n  */\n package org.mockito.exceptions;\n \n-import org.mockito.internal.InvocationWithMatchers;\n+import org.mockito.internal.ExpectedInvocation;\n \n public class NumberOfInvocationsAssertionError extends MockitoAssertionError {\n \n     private static final long serialVersionUID = 1L;\n \n-    public NumberOfInvocationsAssertionError(int expectedInvoked, int actuallyInvoked, InvocationWithMatchers invocation) {\n+    public NumberOfInvocationsAssertionError(int expectedInvoked, int actuallyInvoked, ExpectedInvocation invocation) {\n         super(  \"\\n\" +\n                 invocation.toString() +\n         \t\t\"\\n\" +\n--- /dev/null\n+++ b/src/org/mockito/internal/ExpectedInvocation.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal;\n+\n+import java.lang.reflect.Method;\n+import java.util.*;\n+\n+import org.mockito.internal.matchers.IArgumentMatcher;\n+\n+public class ExpectedInvocation {\n+\n+    protected final Invocation invocation;\n+    private final List<IArgumentMatcher> matchers;\n+\n+    public ExpectedInvocation(Invocation invocation, List<IArgumentMatcher> matchers) {\n+        this.invocation = invocation;\n+        this.matchers = matchers;\n+    }\n+    \n+    //TODO add test that makes sure sequenceNumber doesnt take part in equals()\n+    public boolean equals(Object o) {\n+        if (o == null || !this.getClass().equals(o.getClass()))\n+            return false;\n+\n+        ExpectedInvocation other = (ExpectedInvocation) o;\n+        return this.invocation.equals(other.invocation)\n+                && ((this.matchers == null && other.matchers == null) || (this.matchers != null && this.matchers\n+                        .equals(other.matchers)));\n+    }\n+\n+    public int hashCode() {\n+        return 1;\n+    }\n+\n+    public boolean matches(Invocation actual) {\n+        return this.invocation.getMock().equals(\n+                actual.getMock())\n+                && this.invocation.getMethod().equals(actual.getMethod())\n+                && matches(actual.getArguments());\n+    }\n+\n+    private boolean matches(Object[] arguments) {\n+        if (arguments.length != matchers.size()) {\n+            return false;\n+        }\n+        for (int i = 0; i < arguments.length; i++) {\n+            if (!matchers.get(i).matches(arguments[i])) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public String toString() {\n+        StringBuffer result = new StringBuffer();\n+        result.append(invocation.getMockAndMethodName());\n+        result.append(\"(\");\n+        for (Iterator<IArgumentMatcher> it = matchers.iterator(); it.hasNext();) {\n+            it.next().appendTo(result);\n+            if (it.hasNext()) {\n+                result.append(\", \");\n+            }\n+        }\n+        result.append(\")\");\n+        return result.toString();\n+    }\n+\n+    public Method getMethod() {\n+        return invocation.getMethod();\n+    }\n+    \n+    public Invocation getInvocation() {\n+        return this.invocation;\n+    }\n+}\n--- a/src/org/mockito/internal/MockControl.java\n+++ b/src/org/mockito/internal/MockControl.java\n \n         List<IArgumentMatcher> processedMatchers = createEqualsMatchers(invocation, lastMatchers);\n         \n-        InvocationWithMatchers invocationWithMatchers = new InvocationWithMatchers(invocation, processedMatchers);\n+        ExpectedInvocation expectedInvocation = new ExpectedInvocation(invocation, processedMatchers);\n         \n         if (verifyingMode != null) {\n             //TODO shouldn't verify take only invocationWithMatchers.getInvocation(); ?\n-            behavior.verify(invocationWithMatchers, verifyingMode);\n+            behavior.verify(expectedInvocation, verifyingMode);\n             return ToTypeMappings.emptyReturnValueFor(method.getReturnType());\n         }\n         \n         \n         invocation.setSequenceNumber(mockitoState.nextSequenceNumber());\n         \n-        behavior.addInvocation(invocationWithMatchers);\n+        behavior.addInvocation(expectedInvocation);\n         \n         if (throwableToBeSetOnVoidMethod != null) {\n             andThrows(throwableToBeSetOnVoidMethod);\n--- a/src/org/mockito/internal/MockitoBehavior.java\n+++ b/src/org/mockito/internal/MockitoBehavior.java\n     private T mock;\n     \n     private List<Invocation> registeredInvocations = new LinkedList<Invocation>();\n-    private Map<InvocationWithMatchers, Result> results = new HashMap<InvocationWithMatchers, Result>();\n-\n-    private InvocationWithMatchers invocationForStubbing;\n-    \n-    public void addInvocation(InvocationWithMatchers invocation) {\n+    private Map<ExpectedInvocation, Result> results = new HashMap<ExpectedInvocation, Result>();\n+\n+    private ExpectedInvocation invocationForStubbing;\n+    \n+    public void addInvocation(ExpectedInvocation invocation) {\n         this.registeredInvocations.add(invocation.getInvocation());\n         this.invocationForStubbing = invocation;\n     }\n         this.results.put(invocationForStubbing, result);\n     }\n \n-    public void verify(InvocationWithMatchers expected, VerifyingMode verifyingMode) {\n+    public void verify(ExpectedInvocation expected, VerifyingMode verifyingMode) {\n         checkForMissingInvocation(expected, verifyingMode);\n         checkOrderOfInvocations(expected, verifyingMode);\n         checkForWrongNumberOfInvocations(expected, verifyingMode);        \n         markInvocationsAsVerified(expected, verifyingMode);\n     }\n     \n-    void markInvocationsAsVerified(InvocationWithMatchers expected, VerifyingMode verifyingMode) {\n+    void markInvocationsAsVerified(ExpectedInvocation expected, VerifyingMode verifyingMode) {\n         int verifiedSoFar = 0;        \n         for (Invocation invocation : registeredInvocations) {\n             boolean shouldMarkAsVerified = \n         }\n     }\n \n-    private void checkForMissingInvocation(InvocationWithMatchers expected, VerifyingMode verifyingMode) {\n+    private void checkForMissingInvocation(ExpectedInvocation expected, VerifyingMode verifyingMode) {\n         int actuallyInvoked = numberOfActualInvocations(expected);\n         Integer expectedInvoked = verifyingMode.getExpectedNumberOfInvocations();\n         boolean atLeastOnce = verifyingMode.atLeastOnceMode();\n         }\n     }\n \n-    private void checkForWrongNumberOfInvocations(InvocationWithMatchers expected, VerifyingMode verifyingMode) throws NumberOfInvocationsAssertionError {\n+    private void checkForWrongNumberOfInvocations(ExpectedInvocation expected, VerifyingMode verifyingMode) throws NumberOfInvocationsAssertionError {\n         int actuallyInvoked = numberOfActualInvocations(expected);\n         Integer expectedInvoked = verifyingMode.getExpectedNumberOfInvocations();\n         boolean atLeastOnce = verifyingMode.atLeastOnceMode();\n         }\n     }\n \n-    private void reportMissingInvocationError(InvocationWithMatchers invocation) throws VerificationAssertionError {\n+    private void reportMissingInvocationError(ExpectedInvocation invocation) throws VerificationAssertionError {\n         //TODO refactor message building somewhere else...\n         Invocation similarInvocation = findSimilarInvocation(invocation);\n         String message = \n         throw new VerificationAssertionError(message);\n     }\n \n-    private void checkOrderOfInvocations(InvocationWithMatchers expected, VerifyingMode verifyingMode) {\n+    private void checkOrderOfInvocations(ExpectedInvocation expected, VerifyingMode verifyingMode) {\n         if (!verifyingMode.orderOfInvocationsMatters()) {\n             return;\n         }\n      * gets first registered invocation with the same method name\n      * or just first invocation\n      */\n-    private Invocation findSimilarInvocation(InvocationWithMatchers expectedInvocation) {\n+    private Invocation findSimilarInvocation(ExpectedInvocation expectedInvocation) {\n         for (Invocation registeredInvocation : registeredInvocations) {\n             String expectedMethodName = expectedInvocation.getMethod().getName();\n             String registeredInvocationName = registeredInvocation.getMethod().getName();\n         return null;\n     }\n \n-    private int numberOfActualInvocations(InvocationWithMatchers expectedInvocation) {\n+    private int numberOfActualInvocations(ExpectedInvocation expectedInvocation) {\n         int verifiedInvocations = 0;\n         for (Invocation registeredInvocation : registeredInvocations) {\n             if (expectedInvocation.matches(registeredInvocation)) {\n     }\n \n     public Object resultFor(Invocation invocation) throws Throwable {\n-        for (InvocationWithMatchers invocationWithMatchers : results.keySet()) {\n-            if (invocationWithMatchers.matches(invocation)) {\n-                return results.get(invocationWithMatchers).answer();\n+        for (ExpectedInvocation expectedInvocation : results.keySet()) {\n+            if (expectedInvocation.matches(invocation)) {\n+                return results.get(expectedInvocation).answer();\n             }\n         }\n \n         return registeredInvocations;\n     }\n \n-    public InvocationWithMatchers getInvocationForStubbing() {\n+    public ExpectedInvocation getInvocationForStubbing() {\n         return invocationForStubbing;\n     }\n }\n--- a/test/org/mockito/internal/ExpectedInvocationTest.java\n+++ b/test/org/mockito/internal/ExpectedInvocationTest.java\n         Object[] args = new Object[] { \"\" };\n         Method m = Object.class.getMethod(\"equals\", new Class[] { Object.class });\n         Invocation invocation = new Invocation(null, m, args);\n-        assertThat(new InvocationWithMatchers(invocation, null).hashCode(), equalTo(1));\n+        assertThat(new ExpectedInvocation(invocation, null).hashCode(), equalTo(1));\n     }\n     \n     @Test\n         Method dummyMethod = Object.class.getMethod(\"equals\",\n                 new Class[] { Object.class });\n \n-        InvocationWithMatchers invocationWithOneArg = new InvocationWithMatchers(\n+        ExpectedInvocation invocationWithOneArg = new ExpectedInvocation(\n                 new Invocation(mock, dummyMethod, new Object[] { \"\" }), null);\n-        InvocationWithMatchers invocationWithTwoArgs = new InvocationWithMatchers(\n+        ExpectedInvocation invocationWithTwoArgs = new ExpectedInvocation(\n                 new Invocation(mock, dummyMethod, new Object[] { \"\", \"\" }), null);\n \n         assertFalse(invocationWithOneArg.equals(null));\n--- a/test/org/mockito/internal/MockitoBehaviorTest.java\n+++ b/test/org/mockito/internal/MockitoBehaviorTest.java\n     @Ignore\n     @Test\n     public void shouldMarkVerifiedOnlyOneExecutionChunk() throws Exception {\n-        InvocationWithMatchers toLowerCaseInvocation = new InvocationWithMatchers(new Invocation(\"mock\", toLowerCase , new Object[] {}), Collections.EMPTY_LIST);\n-        InvocationWithMatchers toUpperCaseInvocation = new InvocationWithMatchers(new Invocation(\"mock\", toUpperCase , new Object[] {}), Collections.EMPTY_LIST);\n+        ExpectedInvocation toLowerCaseInvocation = new ExpectedInvocation(new Invocation(\"mock\", toLowerCase , new Object[] {}), Collections.EMPTY_LIST);\n+        ExpectedInvocation toUpperCaseInvocation = new ExpectedInvocation(new Invocation(\"mock\", toUpperCase , new Object[] {}), Collections.EMPTY_LIST);\n         \n         behavior.addInvocation(toLowerCaseInvocation);\n         behavior.addInvocation(toLowerCaseInvocation);\n         \n         behavior.markInvocationsAsVerified(toLowerCaseInvocation, VerifyingMode.inOrder(2, Arrays.asList(new Object())));\n         \n-        List<InvocationWithMatchers> invocations = behavior.getRegisteredInvocations();\n+        List<ExpectedInvocation> invocations = behavior.getRegisteredInvocations();\n         assertEquals(true, invocations.get(0).getInvocation().isVerified());\n         assertEquals(true, invocations.get(1).getInvocation().isVerified());\n         assertEquals(false, invocations.get(2).getInvocation().isVerified());", "timestamp": 1196101255, "metainfo": ""}