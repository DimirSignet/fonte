{"sha": "437523c2f7ea5337b389263876b8ee499f95bd0f", "log": "externalized isolating classloader", "commit": "\n--- a/src/org/mockito/internal/creation/jmock/SerializableNoOp.java\n+++ b/src/org/mockito/internal/creation/jmock/SerializableNoOp.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.creation.jmock;\n-\n-import java.io.Serializable;\n \n import org.mockito.cglib.proxy.Callback;\n import org.mockito.cglib.proxy.NoOp;\n \n+import java.io.Serializable;\n+\n+/**\n+ * Offer a Serializable implementation of the NoOp CGLIB callback.\n+ */\n public class SerializableNoOp implements NoOp, Serializable {\n \n   private static final long serialVersionUID = 7434976328690189159L;\n--- a/test/org/mockitousage/configuration/ClassCacheVersusClassReloadingTest.java\n+++ b/test/org/mockitousage/configuration/ClassCacheVersusClassReloadingTest.java\n import org.junit.Test;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.configuration.ConfigurationAccess;\n+import org.mockitoutil.SimplePerRealmReloadingClassLoader;\n \n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.net.URLClassLoader;\n import java.util.concurrent.Callable;\n \n import static org.fest.assertions.Assertions.assertThat;\n \n     private static SimplePerRealmReloadingClassLoader.ReloadClassPredicate reloadScope() {\n         return new SimplePerRealmReloadingClassLoader.ReloadClassPredicate() {\n-            public boolean needReload(String qualifiedName) {\n+            public boolean acceptReloadOf(String qualifiedName) {\n                 return \"org.mockitousage.configuration.ClassCacheVersusClassReloadingTest$DoTheMocking\".equals(qualifiedName)\n                     || \"org.mockitousage.configuration.ClassToBeMocked\".equals(qualifiedName);\n             }\n \n     private static SimplePerRealmReloadingClassLoader.ReloadClassPredicate reloadMockito() {\n         return new SimplePerRealmReloadingClassLoader.ReloadClassPredicate() {\n-            public boolean needReload(String qualifiedName) {\n+            public boolean acceptReloadOf(String qualifiedName) {\n                 return (!qualifiedName.contains(\"org.mockito.cglib\") && qualifiedName.contains(\"org.mockito\"));\n             }\n         };\n     }\n \n-    /**\n-     * Custom classloader to load classes in hierarchic realm.\n-     *\n-     * Each class can be reloaded in the realm if the LoadClassPredicate says so.\n-     */\n-    private static class SimplePerRealmReloadingClassLoader extends URLClassLoader {\n-\n-        private ReloadClassPredicate reloadClassPredicate;\n-\n-        public SimplePerRealmReloadingClassLoader(ReloadClassPredicate reloadClassPredicate) {\n-            super(new URL[]{obtainClassPath(), obtainClassPath(\"org.mockito.Mockito\")});\n-            this.reloadClassPredicate = reloadClassPredicate;\n-        }\n-\n-        public SimplePerRealmReloadingClassLoader(ClassLoader parentClassLoader, ReloadClassPredicate reloadClassPredicate) {\n-            super(new URL[]{\n-                    obtainClassPath(),\n-                    obtainClassPath(\"org.mockito.Mockito\"),\n-            }, parentClassLoader);\n-            this.reloadClassPredicate = reloadClassPredicate;\n-        }\n-\n-        private static URL obtainClassPath() {\n-            String className = SimplePerRealmReloadingClassLoader.class.getName();\n-            return obtainClassPath(className);\n-        }\n-\n-        private static URL obtainClassPath(String className) {\n-            String path = className.replace('.', '/') + \".class\";\n-            String url = SimplePerRealmReloadingClassLoader.class.getClassLoader().getResource(path).toExternalForm();\n-\n-            try {\n-                return new URL(url.substring(0, url.length() - path.length()));\n-            } catch (MalformedURLException e) {\n-                throw new RuntimeException(\"Classloader couldn't obtain a proper classpath URL\", e);\n-            }\n-        }\n-\n-        @Override\n-        public Class<?> loadClass(String qualifiedName) throws ClassNotFoundException {\n-            if(reloadClassPredicate.needReload(qualifiedName)) {\n-                // return customLoadClass(qualifiedName);\n-                Class<?> foundClass = findClass(qualifiedName);\n-                return foundClass;\n-            }\n-            return super.loadClass(qualifiedName);\n-        }\n-\n-        public Object doInRealm(String callableCalledInClassLoaderRealm) throws Exception {\n-            Callable<?> callableInRealm = (Callable<?>) this.loadClass(callableCalledInClassLoaderRealm).newInstance();\n-            return callableInRealm.call();\n-        }\n-\n-        public static interface ReloadClassPredicate {\n-            boolean needReload(String qualifiedName);\n-        }\n-    }\n }\n--- /dev/null\n+++ b/test/org/mockitoutil/SimplePerRealmReloadingClassLoader.java\n+package org.mockitoutil;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+\n+/**\n+ * Custom classloader to load classes in hierarchic realm.\n+ *\n+ * Each class can be reloaded in the realm if the LoadClassPredicate says so.\n+ */\n+public class SimplePerRealmReloadingClassLoader extends URLClassLoader {\n+\n+    private final Map<String,Class> classHashMap = new HashMap<String, Class>();\n+    private ReloadClassPredicate reloadClassPredicate;\n+\n+    public SimplePerRealmReloadingClassLoader(ReloadClassPredicate reloadClassPredicate) {\n+        super(getPossibleClassPathsUrls());\n+        this.reloadClassPredicate = reloadClassPredicate;\n+    }\n+\n+    public SimplePerRealmReloadingClassLoader(ClassLoader parentClassLoader, ReloadClassPredicate reloadClassPredicate) {\n+        super(getPossibleClassPathsUrls(), parentClassLoader);\n+        this.reloadClassPredicate = reloadClassPredicate;\n+    }\n+\n+    private static URL[] getPossibleClassPathsUrls() {\n+        return new URL[]{\n+                obtainClassPath(),\n+                obtainClassPath(\"org.mockito.Mockito\"),\n+                obtainClassPath(\"org.mockito.cglib.proxy.Enhancer\"),\n+        };\n+    }\n+\n+    private static URL obtainClassPath() {\n+        String className = SimplePerRealmReloadingClassLoader.class.getName();\n+        return obtainClassPath(className);\n+    }\n+\n+    private static URL obtainClassPath(String className) {\n+        String path = className.replace('.', '/') + \".class\";\n+        String url = SimplePerRealmReloadingClassLoader.class.getClassLoader().getResource(path).toExternalForm();\n+\n+        try {\n+            return new URL(url.substring(0, url.length() - path.length()));\n+        } catch (MalformedURLException e) {\n+            throw new RuntimeException(\"Classloader couldn't obtain a proper classpath URL\", e);\n+        }\n+    }\n+\n+\n+\n+    @Override\n+    public Class<?> loadClass(String qualifiedClassName) throws ClassNotFoundException {\n+        if(reloadClassPredicate.acceptReloadOf(qualifiedClassName)) {\n+            // return customLoadClass(qualifiedClassName);\n+//            Class<?> loadedClass = findLoadedClass(qualifiedClassName);\n+            if(!classHashMap.containsKey(qualifiedClassName)) {\n+                Class<?> foundClass = findClass(qualifiedClassName);\n+                saveFoundClass(qualifiedClassName, foundClass);\n+                return foundClass;\n+            }\n+\n+            return classHashMap.get(qualifiedClassName);\n+        }\n+        return useParentClassLoaderFor(qualifiedClassName);\n+    }\n+\n+    private void saveFoundClass(String qualifiedClassName, Class<?> foundClass) {\n+        classHashMap.put(qualifiedClassName, foundClass);\n+    }\n+\n+\n+    private Class<?> useParentClassLoaderFor(String qualifiedName) throws ClassNotFoundException {\n+        return super.loadClass(qualifiedName);\n+    }\n+\n+\n+    public Object doInRealm(String callableCalledInClassLoaderRealm) throws Exception {\n+        Object instance = this.loadClass(callableCalledInClassLoaderRealm).getConstructor().newInstance();\n+        if (instance instanceof Callable) {\n+            Callable<?> callableInRealm = (Callable<?>) instance;\n+            return callableInRealm.call();\n+        }\n+        throw new IllegalArgumentException(\"qualified name '\" + callableCalledInClassLoaderRealm + \"' should represent a class implementing Callable\");\n+    }\n+\n+\n+    public Object doInRealm(String callableCalledInClassLoaderRealm, Class[] argTypes, Object[] args) throws Exception {\n+        ClassLoader current = Thread.currentThread().getContextClassLoader();\n+        try {\n+            Thread.currentThread().setContextClassLoader(this);\n+            Object instance = this.loadClass(callableCalledInClassLoaderRealm).getConstructor(argTypes).newInstance(args);\n+            if (instance instanceof Callable) {\n+                Callable<?> callableInRealm = (Callable<?>) instance;\n+                return callableInRealm.call();\n+            }\n+        } finally {\n+            Thread.currentThread().setContextClassLoader(current);\n+        }\n+\n+        throw new IllegalArgumentException(\"qualified name '\" + callableCalledInClassLoaderRealm + \"' should represent a class implementing Callable\");\n+    }\n+\n+\n+    public static interface ReloadClassPredicate {\n+        boolean acceptReloadOf(String qualifiedName);\n+    }\n+}", "timestamp": 1354134150, "metainfo": ""}