{"sha": "81a380951402d2a158af115ed616ab36e94793b8", "log": "Fix for issue 211", "commit": "\n--- a/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\n+++ b/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\n  * See {@link org.mockito.MockitoAnnotations}\n  */\n public class DefaultInjectionEngine {\n-\t\n+\n     private final MockCandidateFilter mockCandidateFilter = new TypeBasedCandidateFilter(new NameBasedCandidateFilter(new FinalMockCandidateFilter()));\n \n     // for each tested\n     //   - if more than *one* find mock candidate on name\n     //   - if one mock candidate then set mock\n     //   - else don't fail, user will then provide dependencies\n-\tpublic void injectMocksOnFields(Set<Field> testClassFields, Set<Object> mocks, Object testClass) {\n+    public void injectMocksOnFields(Set<Field> testClassFields, Set<Object> mocks, Object testClass) {\n         for (Field field : testClassFields) {\n             Object fieldInstance = null;\n             try {\n         }\n     }\n \n-}\n+}\n--- a/src/org/mockito/internal/configuration/injection/FinalMockCandidateFilter.java\n+++ b/src/org/mockito/internal/configuration/injection/FinalMockCandidateFilter.java\n package org.mockito.internal.configuration.injection;\n \n import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.util.reflection.BeanPropertySetter;\n import org.mockito.internal.util.reflection.FieldSetter;\n \n import java.lang.reflect.Field;\n  * This node returns an actual injecter which will be either :\n  *\n  * <ul>\n- * <li>an {@link Injecter} that do nothing if a candidate couldn't be found</li>\n- * <li>an {@link Injecter} that do will inject the final candidate to the field</li>\n+ * <li>an {@link OngoingInjecter} that do nothing if a candidate couldn't be found</li>\n+ * <li>an {@link OngoingInjecter} that will try to inject the candidate trying first the property setter then if not possible try the field access</li>\n  * </ul>\n  */\n public class FinalMockCandidateFilter implements MockCandidateFilter {\n-    public Injecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) {\n+    public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) {\n         if(mocks.size() == 1) {\n             final Object matchingMock = mocks.iterator().next();\n \n-            return new Injecter() {\n+            return new OngoingInjecter() {\n                 public boolean thenInject() {\n                     try {\n-                        new FieldSetter(fieldInstance, field).set(matchingMock);\n+                        if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) {\n+                            new FieldSetter(fieldInstance, field).set(matchingMock);\n+                        }\n                     } catch (Exception e) {\n                         throw new MockitoException(\"Problems injecting dependency in \" + field.getName(), e);\n                     }\n             };\n         }\n \n-        return new Injecter() {\n+        return new OngoingInjecter() {\n             public boolean thenInject() {\n                 return false;\n             }\n         };\n \n     }\n-}\n+}\n--- a/src/org/mockito/internal/configuration/injection/MockCandidateFilter.java\n+++ b/src/org/mockito/internal/configuration/injection/MockCandidateFilter.java\n \n public interface MockCandidateFilter {\n \n-    Injecter filterCandidate(\n+    OngoingInjecter filterCandidate(\n             Collection<Object> mocks,\n             Field fieldToBeInjected,\n             Object fieldInstance\n--- a/src/org/mockito/internal/configuration/injection/NameBasedCandidateFilter.java\n+++ b/src/org/mockito/internal/configuration/injection/NameBasedCandidateFilter.java\n         this.next = next;\n     }\n \n-    public Injecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {\n+    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {\n         List<Object> mockNameMatches = new ArrayList<Object>();\n         if(mocks.size() > 1) {\n             for (Object mock : mocks) {\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/injection/OngoingInjecter.java\n+package org.mockito.internal.configuration.injection;\n+\n+/**\n+ * Allow the ongoing injection of a mock candidate.\n+ */\n+public interface OngoingInjecter {\n+\n+    /**\n+     * Inject the mock.\n+     *\n+     * <p>\n+     * Please check the actual implementation.\n+     * </p>\n+     *\n+     * @return <code>true</code> if injected, <code>false</code> otherwise.\n+     */\n+    boolean thenInject();\n+\n+}\n--- a/src/org/mockito/internal/configuration/injection/TypeBasedCandidateFilter.java\n+++ b/src/org/mockito/internal/configuration/injection/TypeBasedCandidateFilter.java\n         this.next = next;\n     }\n \n-    public Injecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {\n+    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {\n         List<Object> mockTypeMatches = new ArrayList<Object>();\n         for (Object mock : mocks) {\n             if (field.getType().isAssignableFrom(mock.getClass())) {\n--- /dev/null\n+++ b/src/org/mockito/internal/util/reflection/BeanPropertySetter.java\n+package org.mockito.internal.util.reflection;\n+\n+import java.beans.BeanInfo;\n+import java.beans.IntrospectionException;\n+import java.beans.Introspector;\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+/**\n+ * This utility class will call the setter of the property to inject a new value.\n+ */\n+public class BeanPropertySetter {\n+\n+    private final Object target;\n+    private boolean reportNoSetterFound;\n+    private final Field field;\n+\n+    /**\n+     * New BeanPropertySetter\n+     * @param target The target on which the setter must be invoked\n+     * @param propertyField The field that should be accessed with the setter\n+     * @param reportNoSetterFound Allow the set method to raise an Exception if the setter cannot be found\n+     */\n+    public BeanPropertySetter(final Object target, final Field propertyField, boolean reportNoSetterFound) {\n+        this.field = propertyField;\n+        this.target = target;\n+        this.reportNoSetterFound = reportNoSetterFound;\n+    }\n+\n+    /**\n+     * New BeanPropertySetter that don't report failure\n+     * @param target The target on which the setter must be invoked\n+     * @param propertyField The propertyField that must be accessed through a setter\n+     */\n+    public BeanPropertySetter(final Object target, final Field propertyField) {\n+        this(target, propertyField, false);\n+    }\n+\n+    /**\n+     * Set the value to the property represented by this {@link BeanPropertySetter}\n+     * @param value the new value to pass to the property setter\n+     * @return <code>true</code> if the value has been injected, <code>false</code> otherwise\n+     * @throws RuntimeException Can be thrown if the setter threw an exception, if the setter is not accessible\n+     *          or, if <code>reportNoSetterFound</code> and setter could not be found.\n+     */\n+    public boolean set(final Object value) {\n+\n+        AccessibilityChanger changer = new AccessibilityChanger();\n+        Method writeMethod = null;\n+        try {\n+            BeanInfo targetInfo = Introspector.getBeanInfo(target.getClass());\n+            PropertyDescriptor[] propertyDescriptors = targetInfo.getPropertyDescriptors();\n+\n+            for (PropertyDescriptor propertyDescriptor : propertyDescriptors) {\n+                if(propertyNameMatchFieldName(propertyDescriptor)\n+                        && propertyTypeMatchFieldType(propertyDescriptor)) {\n+                    writeMethod = propertyDescriptor.getWriteMethod();\n+                    if(writeMethod != null) {\n+                        changer.enableAccess(writeMethod);\n+                        writeMethod.invoke(target, value);\n+                        return true;\n+                    }\n+                }\n+            }\n+        } catch (InvocationTargetException e) {\n+            throw new RuntimeException(\"Problems setting value:[\" + value + \"] on object: [\" + target + \"] the setter of property [\" + field.getName() + \"] threw an exception\", e.getTargetException());\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(\"Problems setting value:[\" + value + \"] on object: [\" + target + \"] the setter of property [\" + field.getName() + \"] is not accessible\", e);\n+        } catch (IntrospectionException e) {\n+            throw new RuntimeException(\"Problems setting value: [\" + value + \"] on object: [\" + target + \"] for property : [\" + field.getName() + \"], cannot introspect \" + target.getClass(), e);\n+        } finally {\n+            if(writeMethod != null) {\n+                changer.safelyDisableAccess(writeMethod);\n+            }\n+        }\n+\n+        reportNoSetterFound();\n+        return false;\n+    }\n+\n+    private void reportNoSetterFound() {\n+        if(reportNoSetterFound) {\n+            throw new RuntimeException(\"Problems setting value on object: [\" + target + \"] for property : [\" + field.getName() + \"], setter not found\");\n+        }\n+    }\n+\n+    private boolean propertyTypeMatchFieldType(PropertyDescriptor pd) {\n+        return field.getType().equals(pd.getPropertyType());\n+    }\n+\n+    private boolean propertyNameMatchFieldName(PropertyDescriptor pd) {\n+        return field.getName().equals(pd.getName());\n+    }\n+\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/util/reflection/BeanPropertySetterTest.java\n+package org.mockito.internal.util.reflection;\n+\n+import org.fest.assertions.Assertions;\n+import org.junit.Test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.lang.reflect.Field;\n+\n+import static org.junit.Assert.*;\n+\n+\n+public class BeanPropertySetterTest {\n+\n+    @Test\n+    public void shouldUseTheSetterOnTheTargetWithTheFieldType() throws Exception {\n+        SomeBean someBean = new SomeBean();\n+        Field theField = someBean.getClass().getDeclaredField(\"theField\");\n+\n+        File valueToInject = new File(\"path\");\n+\n+        boolean injected = new BeanPropertySetter(someBean, theField, true).set(valueToInject);\n+\n+        assertTrue(injected);\n+        assertTrue(someBean.setTheFieldWasUsed);\n+        assertSame(valueToInject, someBean.getTheField());\n+    }\n+\n+    @Test\n+    public void shouldNotFailIfBeanHasOnlyASetter() throws Exception {\n+        SomeBeanWithJustASetter someBean = new SomeBeanWithJustASetter();\n+        Field theField = someBean.getClass().getDeclaredField(\"theField\");\n+\n+        File valueToInject = new File(\"path\");\n+\n+        boolean injected = new BeanPropertySetter(someBean, theField, true).set(valueToInject);\n+\n+        assertTrue(injected);\n+        assertTrue(someBean.setTheFieldWasUsed);\n+    }\n+\n+    @Test\n+    public void shouldFailIfMatchingSetterCannotBeFoundAndIfReportFailureTrue() throws Exception {\n+        SomeBeanWithNoSetterMatchingFieldType bean = new SomeBeanWithNoSetterMatchingFieldType();\n+        Field theField = bean.getClass().getDeclaredField(\"theField\");\n+\n+        File valueToInject = new File(\"path\");\n+\n+        try {\n+            new BeanPropertySetter(bean, theField, true).set(valueToInject);\n+            fail();\n+        } catch (Exception e) {\n+            Assertions.assertThat(e.getMessage()).contains(\"setter not found\");\n+        }\n+    }\n+\n+    @Test\n+    public void shouldReturnFalseIfNoSetterFound() throws Exception {\n+        SomeBeanWithJustAGetter bean = new SomeBeanWithJustAGetter();\n+        Field theField = bean.getClass().getDeclaredField(\"theField\");\n+\n+        File valueToInject = new File(\"path\");\n+\n+        boolean injected = new BeanPropertySetter(bean, theField).set(valueToInject);\n+\n+        assertFalse(injected);\n+    }\n+\n+    @Test\n+    public void shouldReturnFalseIfNoSetterWasFoundAndIfReportFailureFalse() throws Exception {\n+        SomeBeanWithNoSetterMatchingFieldType bean = new SomeBeanWithNoSetterMatchingFieldType();\n+        Field theField = bean.getClass().getDeclaredField(\"theField\");\n+\n+        File valueToInject = new File(\"path\");\n+\n+        boolean injected = new BeanPropertySetter(bean, theField, false).set(valueToInject);\n+\n+        assertFalse(injected);\n+    }\n+\n+    static class SomeBean {\n+        private File theField;\n+        boolean setTheFieldWasUsed;\n+\n+        public void setTheField(final File theField) {\n+            setTheFieldWasUsed = true;\n+            this.theField = theField;\n+        }\n+\n+        public File getTheField() {\n+            return theField;\n+        }\n+    }\n+\n+    static class SomeBeanWithJustASetter {\n+        private File theField;\n+        boolean setTheFieldWasUsed;\n+\n+        public void setTheField(final File theField) {\n+            this.theField = theField;\n+            setTheFieldWasUsed = true;\n+        }\n+    }\n+    static class SomeBeanWithJustAGetter {\n+        private File theField;\n+\n+        public File getTheField() {\n+            return theField;\n+        }\n+    }\n+\n+    static class SomeBeanWithNoSetterMatchingFieldType {\n+        private File theField;\n+        boolean setTheFieldWasUsed;\n+\n+        public void setTheField(final FileOutputStream somethingElse) {\n+            setTheFieldWasUsed = true;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/bugs/InjectMocksShouldTryPropertySettersFirstBeforeFieldAccessTest.java\n+package org.mockitousage.bugs;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.runners.MockitoJUnitRunner;\n+\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Issue 211 : @InjectMocks should carry out their work by the method (and not by field) if available \n+ */\n+@RunWith(MockitoJUnitRunner.class)\n+public class InjectMocksShouldTryPropertySettersFirstBeforeFieldAccessTest {\n+    @Mock List<?> fieldAccess;\n+    @Mock List<?> propertySetterAccess;\n+    @InjectMocks BeanAwaitingInjection awaitingInjection;\n+\n+    @Test\n+    public void shouldInjectUsingPropertySetterIfAvailable() {\n+        assertTrue(awaitingInjection.propertySetterUsed);\n+    }\n+\n+    @Test\n+    public void shouldInjectFieldIfNoSetter() {\n+        assertEquals(fieldAccess, awaitingInjection.fieldAccess);\n+    }\n+\n+    static class BeanAwaitingInjection {\n+        List<?> fieldAccess;\n+        List<?> propertySetterAccess;\n+        boolean propertySetterUsed;\n+\n+        public void setPropertySetterAccess(List<?> propertySetterAccess) {\n+            // don't care if field is set, the setter can do whatever it want.\n+            propertySetterUsed = true;\n+        }\n+    }\n+\n+}", "timestamp": 1288784201, "metainfo": ""}