{"sha": "3665f119090e5e9b6b095e4da04e5148679a2bf3", "log": "relaxed checkstyle a bit (visibility modifiers rubbish) added initial fixes to making spying real partial mocking  --HG-- rename : test/org/mockitousage/SpyingOnRealObjectsTest.java => test/org/mockitousage/spies/SpyingOnRealObjectsTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401405", "commit": "\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n         MethodInterceptorFilter<MockHandler<T>> filter = new MethodInterceptorFilter<MockHandler<T>>(classToMock, mockHandler);\n \n         T mock = ClassImposterizer.INSTANCE.imposterise(filter, classToMock);\n+        \n+        if (optionalInstance != null) {\n+            try {\n+                new ShallowCopyTool().copy(optionalInstance, mock);\n+            } catch (UnableToCopyFieldValue e) {\n+                //Ignore - spying should be used only occasionally and if some field cannot be copied then let's be it\n+            }\n+        }\n+        \n+        //TODO: does it make sense to set instance?\n         filter.setInstance(optionalInstance != null ? optionalInstance : mock);\n         return mock;\n     }\n--- /dev/null\n+++ b/src/org/mockito/internal/util/ShallowCopyTool.java\n+package org.mockito.internal.util;\n+\n+import java.lang.reflect.Field;\n+\n+public class ShallowCopyTool {\n+\n+    public <T> void copy(T from, T to) throws UnableToCopyFieldValue {\n+        Field[] fieldsFrom = from.getClass().getDeclaredFields();\n+        Field[] fieldsTo = to.getClass().getDeclaredFields();\n+        assert fieldsFrom.length == fieldsTo.length : \"Objects should be of the same type\";\n+\n+        for (int i = 0; i < fieldsFrom.length; i++) {\n+            try {\n+                fieldsFrom[i].setAccessible(true);\n+                fieldsTo[i].setAccessible(true);\n+                Object value = fieldsFrom[i].get(from);\n+                fieldsTo[i].set(to, value);\n+            } catch (Throwable t) {\n+                throw new UnableToCopyFieldValue(\n+                        \"Unable to copy value from field: \" + fieldsFrom[i] + \n+                        \" to field: \" + fieldsTo[i], t); \n+            } \n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/util/UnableToCopyFieldValue.java\n+package org.mockito.internal.util;\n+\n+class UnableToCopyFieldValue extends Exception {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public UnableToCopyFieldValue(String message, Throwable t) {\n+        super(message, t);\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/util/ShallowCopyToolTest.java\n+package org.mockito.internal.util;\n+\n+import static org.junit.Assert.*;\n+\n+import org.junit.Test;\n+import org.mockitoutil.TestBase;\n+\n+\n+public class ShallowCopyToolTest extends TestBase {\n+\n+    private ShallowCopyTool tool = new ShallowCopyTool();\n+    \n+    //TODO: inherited fields\n+    class SomeObject {\n+        private int fieldOne = 1;\n+        String fieldTwo = \"2\";\n+        protected Object fieldThree = new Object();\n+        public SomeOtherObject fieldFour = new SomeOtherObject();\n+        final int fieldFive;\n+        public SomeObject(int fieldFiveValue) {\n+            this.fieldFive = fieldFiveValue;\n+        }\n+    }\n+    \n+    class SomeOtherObject {}\n+\n+    @Test\n+    public void shouldShallowCopy() throws Exception {\n+        //given\n+        SomeObject first = new SomeObject(100);\n+        SomeObject second = new SomeObject(200);\n+        assertEquals(200, second.fieldFive);\n+        \n+        //when\n+        tool.copy(first, second);\n+        \n+        //then\n+        assertEquals(100, second.fieldFive);\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/spies/PartialMockingWithSpiesTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.spies;\n+\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockitoutil.TestBase;\n+\n+@Ignore\n+@SuppressWarnings(\"unchecked\")\n+public class PartialMockingWithSpiesTest extends TestBase {\n+\n+    class Person {\n+        private final String defaultName = \"Default name\";\n+\n+        public String getName() {\n+            return guessName();\n+        }\n+\n+        protected String guessName() {\n+            return defaultName;\n+        }\n+    }\n+\n+    @Mock\n+    Person mock;\n+\n+    @Test\n+    public void shouldCallRealMethdsEvenDelegatedToOtherSelfMethod() {\n+        // when\n+        String name = mock.getName();\n+\n+        // then\n+        assertEquals(\"Default name\", name);\n+    }\n+\n+    @Test\n+    public void shouldVerify() {\n+        // when\n+        mock.getName();\n+\n+        // then\n+        verify(mock).guessName();\n+    }\n+\n+    @Test\n+    public void shouldStub() {\n+        // given\n+        when(mock.guessName()).thenReturn(\"John\");\n+        // when\n+        String name = mock.getName();\n+        // then\n+        assertEquals(\"John\", name);\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/spies/SpyingOnRealObjectsTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.spies;\n+\n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.*;\n+\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.junit.Test;\n+import org.mockito.InOrder;\n+import org.mockito.Mockito;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.exceptions.verification.NoInteractionsWanted;\n+import org.mockito.exceptions.verification.TooLittleActualInvocations;\n+import org.mockito.exceptions.verification.VerificationInOrderFailure;\n+import org.mockitoutil.TestBase;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class SpyingOnRealObjectsTest extends TestBase {\n+\n+    List list = new LinkedList();\n+    List spy = Mockito.spy(list);\n+    \n+    @Test\n+    public void shouldVerify() {\n+        spy.add(\"one\");\n+        spy.add(\"two\");\n+        \n+        assertEquals(\"one\", spy.get(0));\n+        assertEquals(\"two\", spy.get(1));\n+        \n+        verify(spy).add(\"one\");\n+        verify(spy).add(\"two\");\n+    }\n+    \n+    @Test\n+    public void shouldStub() {\n+        spy.add(\"one\");\n+        when(spy.get(0))\n+            .thenReturn(\"1\")\n+            .thenReturn(\"1 again\");\n+               \n+        assertEquals(\"1\", spy.get(0));\n+        assertEquals(\"1 again\", spy.get(0));\n+        assertEquals(\"one\", spy.iterator().next());\n+        \n+        assertEquals(1, spy.size());\n+    }\n+    \n+    @Test\n+    public void shouldAllowOverridingStubs() {\n+        when(spy.contains(anyObject())).thenReturn(true);\n+        when(spy.contains(\"foo\")).thenReturn(false);\n+        \n+        assertTrue(spy.contains(\"bar\"));\n+        assertFalse(spy.contains(\"foo\"));\n+    }\n+    \n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    public void shouldStubVoid() {\n+        stubVoid(spy)\n+            .toReturn()\n+            .toThrow(new RuntimeException())\n+            .on().clear();\n+\n+        spy.add(\"one\");\n+        spy.clear();\n+        try {\n+            spy.clear();\n+            fail();\n+        } catch (RuntimeException e) {}\n+            \n+        assertEquals(1, spy.size());\n+    }\n+    \n+    @Test\n+    public void shouldStubWithDoReturnAndVerify() {\n+        doReturn(\"foo\")\n+        .doReturn(\"bar\")\n+        .when(spy).get(0);\n+        \n+        assertEquals(\"foo\", spy.get(0));\n+        assertEquals(\"bar\", spy.get(0));\n+        \n+        verify(spy, times(2)).get(0);\n+        verifyNoMoreInteractions(spy);\n+    }\n+    \n+    @Test\n+    public void shouldVerifyInOrder() {\n+        spy.add(\"one\");\n+        spy.add(\"two\");\n+        \n+        InOrder inOrder = inOrder(spy);\n+        inOrder.verify(spy).add(\"one\");\n+        inOrder.verify(spy).add(\"two\");\n+        \n+        verifyNoMoreInteractions(spy);\n+    }\n+    \n+    @Test\n+    public void shouldVerifyInOrderAndFail() {\n+        spy.add(\"one\");\n+        spy.add(\"two\");\n+        \n+        InOrder inOrder = inOrder(spy);\n+        inOrder.verify(spy).add(\"two\");\n+        try {\n+            inOrder.verify(spy).add(\"one\");\n+            fail();\n+        } catch (VerificationInOrderFailure f) {}\n+    }\n+    \n+    @Test\n+    public void shouldVerifyNumberOfTimes() {\n+        spy.add(\"one\");\n+        spy.add(\"one\");\n+        \n+        verify(spy, times(2)).add(\"one\");\n+        verifyNoMoreInteractions(spy);\n+    }\n+    \n+    @Test\n+    public void shouldVerifyNumberOfTimesAndFail() {\n+        spy.add(\"one\");\n+        spy.add(\"one\");\n+        \n+        try {\n+            verify(spy, times(3)).add(\"one\");\n+            fail();\n+        } catch (TooLittleActualInvocations e) {}\n+    }\n+    \n+    @Test\n+    public void shouldVerifyNoMoreInteractionsAndFail() {\n+        spy.add(\"one\");\n+        spy.add(\"two\");\n+        \n+        verify(spy).add(\"one\");\n+        try {\n+            verifyNoMoreInteractions(spy);\n+            fail();\n+        } catch (NoInteractionsWanted e) {}\n+    }\n+    \n+    @Test\n+    public void shouldToString() {\n+        spy.add(\"foo\");\n+        assertEquals(\"[foo]\" , spy.toString());\n+    }\n+    \n+    interface Foo {}\n+    \n+    @Test\n+    public void shouldDealWithAnonymousClasses() {\n+        try {\n+            spy(new Foo() {});\n+            fail();\n+        } catch (MockitoException e) {\n+            assertContains(\"cannot mock\", e.getMessage());\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldSayNiceMessageWhenSpyingOnPrivateClass() throws Exception {\n+        List real = Arrays.asList(new String[] {\"first\", \"second\"});\n+        try {\n+            spy(real);\n+            fail();\n+        } catch (MockitoException e) {\n+            assertContains(\"Most likely it is a private class that is not visible by Mockito\", e.getMessage());\n+        }\n+    }\n+}", "timestamp": 1241378572, "metainfo": ""}