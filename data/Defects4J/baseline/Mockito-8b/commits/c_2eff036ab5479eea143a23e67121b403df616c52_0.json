{"sha": "2eff036ab5479eea143a23e67121b403df616c52", "log": "mean check-in (worked in train). Changed the way errors are reported to be more readable and natural  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40477", "commit": "\n--- a/src/org/mockito/Decamelizer.java\n+++ b/src/org/mockito/Decamelizer.java\n         String decamelized = decamelizeClassName(className);\n         \n         if (decamelized.length() == 0) {\n-            return className;\n+            return \"<\" + className + \">\";\n         }\n         \n-        return decamelized.toString();\n+        return \"<\" + decamelized + \">\";\n     }\n \n     private static String decamelizeClassName(String className) {\n--- a/src/org/mockito/exceptions/PrintableInvocation.java\n+++ b/src/org/mockito/exceptions/PrintableInvocation.java\n package org.mockito.exceptions;\n \n public interface PrintableInvocation {\n-\n     String toString();\n-\n-    String getArgs();\n-\n-    String getMethodName();\n }\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n  */\n public class Reporter {\n \n+\t//TODO for every case when wanted and actual are shown, the arg list has to be consistently printed\n     private String pluralize(int number) {\n         return number == 1 ? \"1 time\" : number + \" times\";\n     }\n \n     public void argumentsAreDifferent(PrintableInvocation wanted, PrintableInvocation actual, HasStackTrace actualStackTrace) {\n         ActualArgumentsAreDifferent cause = new ActualArgumentsAreDifferent(join(\n-                \"All actual arguments:\",\n-                actual.getArgs()\n+                \"Actual invocation has different arguments:\",\n+                actual.toString()\n             ));\n         \n         cause.setStackTrace(actualStackTrace.getStackTrace());\n         \n         throw new ArgumentsAreDifferent(join(\n-                \"Argument(s) are different!\",\n-                \"    \" + wanted.getMethodName(),\n-                \"All wanted arguments:\",\n-                wanted.getArgs()\n+                \"Argument(s) are different! Wanted:\",\n+                wanted.toString()\n             ), cause);\n     }\n     \n--- a/src/org/mockito/internal/invocation/Invocation.java\n+++ b/src/org/mockito/internal/invocation/Invocation.java\n @SuppressWarnings(\"unchecked\")\n public class Invocation implements PrintableInvocation {\n \n-    private static final String TAB = \"    \";\n+    private static final int MAX_LINE_LENGTH = 35;\n+\tprivate static final String TAB = \"    \";\n     private final int sequenceNumber;\n     private final Object mock;\n     private final Method method;\n         return qualifiedMethodName() + getArgumentsString(matchers);\n     }\n \n-    public String getMethodName() {\n-        return qualifiedMethodName() + \"(...)\";\n-    }\n-\n-    public String getArgs() {\n-        return getArgs(argumentsToMatchers());\n-    }\n-\n-    protected String getArgs(List<Matcher> matchers) {\n-        if (matchers.isEmpty()) {\n-            return TAB + \"<NO ARGUMENTS>\"; \n-        }\n-        \n-        Description d = new StringDescription();\n-        \n-        for(int i = 0; i<matchers.size(); i++) {\n-            d.appendText(TAB);\n-            String argNumber = argNumber(i);\n-            d.appendText(argNumber);\n-            d.appendDescriptionOf(matchers.get(i));\n-            if (i != matchers.size()-1) {\n-                d.appendText(\"\\n\");\n-            }\n-        }\n-\n-        return d.toString();\n-    }\n-    \n-\n     private String qualifiedMethodName() {\n         return MockNamer.nameForMock(mock) + \".\" + method.getName();\n     }\n \n     private String getArgumentsString(List<Matcher> matchers) {\n         Description result = new StringDescription();\n-        result.appendList(\"(\", \", \", \")\", matchers);\n-        return result.toString();\n+        result.appendList(\"(\", \", \", \");\", matchers);\n+        String args = result.toString();\n+        //TODO max line lenght should consider lengthy classes/methods names\n+        if (args.length() < MAX_LINE_LENGTH) {\n+        \treturn args;\n+        }\n+        \n+        result = new StringDescription();\n+        result.appendList(\"(\\n    \", \",\\n    \", \"\\n  );\", matchers);\n+\t\treturn result.toString();\n     }\n     \n     protected List<Matcher> argumentsToMatchers() {\n         }\n         return matchers;\n     }\n-\n-    private String argNumber(int zeroBasedIndex) {\n-        String no = String.valueOf(zeroBasedIndex+1);\n-        if (no.endsWith(\"1\")) {\n-            return no.concat(\"st: \");\n-        } else if (no.endsWith(\"2\")) {\n-            return no.concat(\"nd: \");\n-        } else if (no.endsWith(\"3\")) {\n-            return no.concat(\"rd: \");\n-        }\n-        \n-        return no.concat(\"th: \");\n-    }\n }\n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n     public String toString() {\n         return invocation.toString(matchers);\n     }\n-    \n-    public String getMethodName() {\n-        return invocation.getMethodName();\n-    }\n-    \n-    public String getArgs() {\n-        return invocation.getArgs(matchers);\n-    }\n \n     public boolean matches(Invocation actual) {\n         return invocation.getMock().equals(actual.getMock())\n--- a/test/org/mockito/DecamelizerTest.java\n+++ b/test/org/mockito/DecamelizerTest.java\n     \n     @Test\n     public void shouldProduceDecentDescription() throws Exception {\n-        assertEquals(\"Sentence with strong language\", decamelizeMatcher(\"SentenceWithStrongLanguage\"));\n-        assertEquals(\"W e i r d o 1\", decamelizeMatcher(\"WEIRDO1\"));\n-        assertEquals(\"_\", decamelizeMatcher(\"_\"));\n-        assertEquals(\"Has exactly 3 elements\", decamelizeMatcher(\"HasExactly3Elements\"));\n+        assertEquals(\"<Sentence with strong language>\", decamelizeMatcher(\"SentenceWithStrongLanguage\"));\n+        assertEquals(\"<W e i r d o 1>\", decamelizeMatcher(\"WEIRDO1\"));\n+        assertEquals(\"<_>\", decamelizeMatcher(\"_\"));\n+        assertEquals(\"<Has exactly 3 elements>\", decamelizeMatcher(\"HasExactly3Elements\"));\n         assertEquals(\"<custom argument matcher>\", decamelizeMatcher(\"\"));\n     }\n }\n--- a/test/org/mockito/TestBase.java\n+++ b/test/org/mockito/TestBase.java\n \t\torg.junit.Assert.assertThat(message, actual, m);\n \t}\n \t\n-    public static <T> Assertor<Throwable> messageContains(final String text) {\n+    protected void assertContains(String expectedSubstring, String target) {\n+\t\tassertTrue(\"This substring:\\n\" + expectedSubstring\n+\t\t\t\t+ \"\\nshould exist somewhere here:\\n\" + target, \n+\t\t\t\ttarget.contains(expectedSubstring));\n+\t}\n+\n+\tpublic static <T> Assertor<Throwable> messageContains(final String text) {\n         return new Assertor<Throwable>() {\n         \tpublic void assertValue(Throwable value) {\n-        \t\tassertTrue(\"String: \" + value.getMessage() + \" should contain: \" + text\n+        \t\tassertTrue(\"This substring: \\n\" + text + \n+        \t\t\t\t\"\\nshould occur in this exception message:\" + value.getMessage()\n         \t\t\t\t, ((Throwable) value).getMessage().contains(text));\n         \t}\n         };\n--- a/test/org/mockito/internal/invocation/InvocationMatcherTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationMatcherTest.java\n         Matcher mTwo = new Equals('x');\n         InvocationMatcher equals = new InvocationMatcher(new InvocationBuilder().toInvocation(), asList(mTwo));\n \n-        assertEquals(\"Object.simpleMethod(notNull())\", notNull.toString());\n-        assertEquals(\"Object.simpleMethod('x')\", equals.toString());\n+        assertContains(\"Object.simpleMethod(notNull())\", notNull.toString());\n+        assertContains(\"Object.simpleMethod('x')\", equals.toString());\n     }\n     \n     @Test\n--- a/test/org/mockito/internal/invocation/InvocationTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationTest.java\n     @Test\n     public void shouldPrintMethodName() {\n         invocation = new InvocationBuilder().toInvocation();\n-        assertEquals(\"Object.simpleMethod()\", invocation.toString());\n+        assertEquals(\"Object.simpleMethod();\", invocation.toString());\n     }\n     \n     @Test\n     public void shouldPrintMethodArgs() {\n         invocation = new InvocationBuilder().args(\"foo\").toInvocation();\n-        assertEquals(\"Object.simpleMethod(\\\"foo\\\")\", invocation.toString());\n+        assertEquals(\"Object.simpleMethod(\\\"foo\\\");\", invocation.toString());\n     }\n     \n     @Test\n     public void shouldPrintMethodIntegerArgAndString() {\n         invocation = new InvocationBuilder().args(\"foo\", 1).toInvocation();\n-        assertEquals(\"Object.simpleMethod(\\\"foo\\\", 1)\", invocation.toString());\n+        assertEquals(\"Object.simpleMethod(\\\"foo\\\", 1);\", invocation.toString());\n     }\n     \n     @Test\n     public void shouldPrintNull() {\n         invocation = new InvocationBuilder().args((String) null).toInvocation();\n-        assertEquals(\"Object.simpleMethod(null)\", invocation.toString());\n+        assertEquals(\"Object.simpleMethod(null);\", invocation.toString());\n     }\n     \n     @Test\n     public void shouldPrintArray() {\n         invocation = new InvocationBuilder().method(\"oneArray\").args(new int[] { 1, 2, 3 }).toInvocation();\n-        assertEquals(\"Object.oneArray([1, 2, 3])\", invocation.toString());\n+        assertEquals(\"Object.oneArray([1, 2, 3]);\", invocation.toString());\n     }\n     \n     @Test\n     public void shouldPrintNullIfArrayIsNull() throws Exception {\n         Method m = IMethods.class.getMethod(\"oneArray\", Object[].class);\n         invocation = new InvocationBuilder().method(m).args((Object) null).toInvocation();\n-        assertEquals(\"Object.oneArray(null)\", invocation.toString());\n+        assertEquals(\"Object.oneArray(null);\", invocation.toString());\n     }\n     \n     @Test\n     }\n     \n     @Test\n-    public void shouldPrintAllArguments() throws Exception {\n-        Invocation i = new InvocationBuilder().args(new Object[] {\"1\", 2, 3, 4, 5}).toInvocation();\n-        String expected = \n-            \"    1st: \\\"1\\\"\\n\" +\n-            \"    2nd: 2\\n\" +\n-            \"    3rd: 3\\n\" +\n-            \"    4th: 4\\n\" +\n-            \"    5th: 5\";\n-        \n-        assertEquals(expected, i.getArgs());\n-    }\n-    \n-    @Test\n-    public void shouldPrintNoArguments() throws Exception {\n-        Invocation i = new InvocationBuilder().toInvocation();\n-        assertEquals(\"    <NO ARGUMENTS>\", i.getArgs());\n-    }\n-    \n-    @Test\n     public void shouldTransformArgumentsToMatchers() throws Exception {\n         Invocation i = new InvocationBuilder().args(\"foo\", new String[] {\"bar\"}).toInvocation();\n         List matchers = i.argumentsToMatchers();\n--- a/test/org/mockitousage/matchers/CustomMatchersTest.java\n+++ b/test/org/mockitousage/matchers/CustomMatchersTest.java\n             verify(mock).simpleMethod(containsTest());\n             fail();\n         } catch (ArgumentsAreDifferent e) {\n-            assertThat(e, messageContains(\"1st: String that contains xxx\"));\n-            assertThat(e, causeMessageContains(\"1st: \\\"foo\\\"\"));\n+            assertThat(e, messageContains(\"simpleMethod(<String that contains xxx>);\"));\n         }\n     }\n \n                 }}));\n             fail();\n         } catch (ArgumentsAreDifferent e) {\n-            assertThat(e, messageContains(\"1st: <custom argument matcher>\"));\n-            assertThat(e, causeMessageContains(\"1st: \\\"foo\\\"\"));\n+            assertThat(e, messageContains(\"simpleMethod(<custom argument matcher>);\"));\n+            assertThat(e, causeMessageContains(\"foo\"));\n         }\n     }\n }\n--- a/test/org/mockitousage/matchers/HamcrestMatchersTest.java\n+++ b/test/org/mockitousage/matchers/HamcrestMatchersTest.java\n package org.mockitousage.matchers;\n \n import static org.junit.Assert.*;\n-import static org.mockito.util.ExtraMatchers.*;\n import static org.mockito.Matchers.*;\n import static org.mockito.Mockito.*;\n+import static org.mockito.util.ExtraMatchers.*;\n \n import java.util.Arrays;\n \n--- a/test/org/mockitousage/matchers/MatchersTest.java\n+++ b/test/org/mockitousage/matchers/MatchersTest.java\n             verify(mock).oneArray(aryEq(nullArray));\n             fail();\n         } catch (WantedButNotInvoked e) {\n-            String expected = \"\\n\" +\n-                    \"Wanted but not invoked:\" +\n-                    \"\\n\" +\n-                    \"IMethods.oneArray(null)\";\n-            assertEquals(expected, e.getMessage());\n+        \tassertThat(e, messageContains(\"oneArray(null)\"));\n         }\n     }\n \n--- a/test/org/mockitousage/sample/MockitoSampleTest.java\n+++ b/test/org/mockitousage/sample/MockitoSampleTest.java\n     \n     @Mock private ArticleCalculator mockCalculator;\n     @Mock private ArticleDatabase mockDatabase;\n-    \n     \n     private ArticleManager articleManager;\n     \n--- a/test/org/mockitousage/verification/DescriptiveMessagesOnVerificationInOrderErrorsTest.java\n+++ b/test/org/mockitousage/verification/DescriptiveMessagesOnVerificationInOrderErrorsTest.java\n                     \"\\n\" +\n                     \"Wanted but not invoked:\" +\n                     \"\\n\" +\n-                    \"IMethods.simpleMethod(11)\"; \n+                    \"IMethods.simpleMethod(11);\"; \n             \n             assertEquals(expected, e.getMessage());\n             \n                 \"\\n\" +\n                 \"Wanted anywhere AFTER following interaction:\" +\n                 \"\\n\" +\n-                \"IMethods.simpleMethod(2)\";\n+                \"IMethods.simpleMethod(2);\";\n             \n             assertEquals(expectedCause, e.getCause().getMessage());\n         }\n                     \"\\n\" +\n                     \"Wanted but not invoked:\" +\n                     \"\\n\" +\n-                    \"IMethods.differentMethod()\"; \n+                    \"IMethods.differentMethod();\"; \n             \n             assertEquals(expected, e.getMessage());\n             \n                     \"\\n\" +\n                     \"Arguments are different!\" +\n                     \"\\n\" +\n-                    \"IMethods.simpleMethod(999)\"; \n+                    \"IMethods.simpleMethod(999);\"; \n             \n             assertEquals(expected, e.getMessage());\n             \n                     \"\\n\" +\n                     \"Wanted but not invoked:\" +\n                     \"\\n\" +\n-                    \"IMethods.simpleMethod(999)\"; \n+                    \"IMethods.simpleMethod(999);\"; \n             assertEquals(expectedMessage, actualMessage);     \n         }\n     }   \n                     \"\\n\" +\n                     \"Verification in order failure\" +\n                     \"\\n\" +\n-                    \"IMethods.simpleMethod(2)\" +\n+                    \"IMethods.simpleMethod(2);\" +\n                     \"\\n\" +\n                     \"Wanted 1 time but was 2\"; \n             assertEquals(expectedMessage, actualMessage);      \n                     \"\\n\" +\n                     \"Verification in order failure\" +\n                     \"\\n\" +\n-                    \"IMethods.simpleMethod(2)\" +\n+                    \"IMethods.simpleMethod(2);\" +\n                     \"\\n\" +\n                     \"Wanted 2 times but was 1\";\n             assertEquals(expectedMessage, actualMessage);\n--- a/test/org/mockitousage/verification/DescriptiveMessagesWhenTimesXVerificationFailsTest.java\n+++ b/test/org/mockitousage/verification/DescriptiveMessagesWhenTimesXVerificationFailsTest.java\n         } catch (TooLittleActualInvocations e) {\n             String expected =\n                 \"\\n\" +\n-                \"LinkedList.clear()\" +\n+                \"LinkedList.clear();\" +\n                 \"\\n\" +\n                 \"Wanted 100 times but was 3\";\n             assertEquals(expected, e.getMessage());\n         } catch (TooManyActualInvocations e) {\n             String expected =\n                 \"\\n\" +\n-                \"LinkedList.clear()\" +\n+                \"LinkedList.clear();\" +\n                 \"\\n\" +\n                 \"Wanted 1 time but was 4\";\n             assertEquals(expected, e.getMessage());\n--- a/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java\n+++ b/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java\n                     \"\\n\" +\n                     \"Wanted but not invoked:\" +\n                     \"\\n\" +\n-                    \"IMethods.simpleMethod()\";\n+                    \"IMethods.simpleMethod();\";\n             assertEquals(expectedMessage, actualMessage);\n         }\n     }\n     }\n \n     @Test\n-    public void shouldPrintActualAndWantedWhenTheDifferenceIsAboutArguments() {\n-        mock.oneArg(true);\n-        mock.twoArgumentMethod(1, 2);\n-\n-        verify(mock).oneArg(true);\n-        try {\n-            verify(mock).twoArgumentMethod(1, 1000);\n+    public void shouldPrintActualAndWantedInLine() {\n+        mock.varargs(1, 2);\n+\n+        try {\n+            verify(mock).varargs(1, 1000);\n             fail();\n         } catch (ArgumentsAreDifferent e) {\n             String expected =\n                     \"\\n\" +\n-                    \"Argument(s) are different!\" +\n-                    \"\\n\" +\n-                    \"    IMethods.twoArgumentMethod(...)\" +\n-                    \"\\n\" +\n-                    \"All wanted arguments:\" +\n-                    \"\\n\" +\n-                    \"    1st: 1\" +\n-                    \"\\n\" +\n-                    \"    2nd: 1000\";\n+                    \"Argument(s) are different! Wanted:\" +\n+                    \"\\n\" +\n+                    \"IMethods.varargs(1, 1000);\";\n \n             assertEquals(expected, e.getMessage());\n \n \n             String expectedCause =\n                     \"\\n\" +\n-                    \"All actual arguments:\" +\n-                    \"\\n\" +\n-                    \"    1st: 1\" +\n-                    \"\\n\" +\n-                    \"    2nd: 2\";\n+                    \"Actual invocation has different arguments:\" +\n+                    \"\\n\" +\n+                    \"IMethods.varargs(1, 2);\";\n+\n+            assertEquals(expectedCause, e.getCause().getMessage());\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPrintActualAndWantedInMultipleLines() {\n+        mock.varargs(\"this is very long string\", \"this is another very long string\");\n+\n+        try {\n+        \tverify(mock).varargs(\"this is very long string\", \"this is another very long string\", \"this is yet another very long string\");\n+            fail();\n+        } catch (ArgumentsAreDifferent e) {\n+            String expected =\n+                    \"\\n\" +\n+                    \"Argument(s) are different! Wanted:\" +\n+                    \"\\n\" +\n+                    \"IMethods.varargs(\" +\n+                    \"\\n\" +\n+                    \"    \\\"this is very long string\\\",\" +\n+                    \"\\n\" +\n+                    \"    \\\"this is another very long string\\\",\" +\n+                    \"\\n\" +\n+                    \"    \\\"this is yet another very long string\\\"\" +\n+                    \"\\n\" +\n+                    \"  );\";\n+\n+            assertEquals(expected, e.getMessage());\n+\n+            assertEquals(e.getCause().getClass(), ActualArgumentsAreDifferent.class);\n+\n+            String expectedCause =\n+                    \"\\n\" +\n+                    \"Actual invocation has different arguments:\" +\n+                    \"\\n\" +\n+                    \"IMethods.varargs(\" +\n+                    \"\\n\" +\n+                    \"    \\\"this is very long string\\\",\" +\n+                    \"\\n\" +\n+                    \"    \\\"this is another very long string\\\"\" +\n+                    \"\\n\" +\n+                    \"  );\";\n \n             assertEquals(expectedCause, e.getCause().getMessage());\n         }\n         mock.simpleMethod();\n \n         try {\n-            verify(mock).simpleMethod(\"test\");\n-            fail();\n-        } catch (ArgumentsAreDifferent e) {\n-            assertThat(e, messageContains(\"    1st: \\\"test\\\"\"));\n-            assertThat(e, causeMessageContains(\"    <NO ARGUMENTS>\"));\n+            verify(mock).simpleMethod(10);\n+            fail();\n+        } catch (ArgumentsAreDifferent e) {\n+            assertThat(e, messageContains(\"simpleMethod(10)\"));\n+            assertThat(e, causeMessageContains(\"simpleMethod()\"));\n         }\n     }\n \n     public void shouldPrintActualAndUnverifiedWantedWhenTheDifferenceIsAboutArguments() {\n         mock.twoArgumentMethod(1, 1);\n         mock.twoArgumentMethod(2, 2);\n-        mock.twoArgumentMethod(3, 3);\n \n         verify(mock).twoArgumentMethod(1, 1);\n-        verify(mock).twoArgumentMethod(2, 2);\n-        try {\n-            verify(mock).twoArgumentMethod(3, 1000);\n-            fail();\n-        } catch (ArgumentsAreDifferent e) {\n-            assertThat(e, messageContains(\"1st: 3\"));\n-            assertThat(e, messageContains(\"2nd: 1000\"));\n-            assertThat(e, causeMessageContains(\"1st: 3\"));\n-            assertThat(e, causeMessageContains(\"2nd: 3\"));\n+        try {\n+            verify(mock).twoArgumentMethod(2, 1000);\n+            fail();\n+        } catch (ArgumentsAreDifferent e) {\n+            assertThat(e, messageContains(\"(2, 1000)\"));\n+            assertThat(e, causeMessageContains(\"(2, 2)\"));\n         }\n     }\n \n                     \"\\n\" +\n                     \"Undesired invocation:\" +\n                     \"\\n\" +\n-                    \"IMethods.oneArg(false)\";\n+                    \"IMethods.oneArg(false);\";\n             assertEquals(expectedCause, e.getCause().getMessage());\n         }\n     }\n                 \"\\n\" +\n                 \"Undesired invocation:\" +\n                 \"\\n\" +\n-                \"IMethods.twoArgumentMethod(1, 2)\";\n+                \"IMethods.twoArgumentMethod(1, 2);\";\n \n             assertEquals(e.getCause().getMessage(), expectedCause);\n         }\n                 \"\\n\" +\n                 \"Wanted but not invoked:\" +\n                 \"\\n\" +\n-                \"IMethods.twoArgumentMethod(<any>, 100)\";\n+                \"IMethods.twoArgumentMethod(<any>, 100);\";\n             assertEquals(expectedMessage, actualMessage);\n         }\n     }\n             verify(mock).varargsString(10, \"two\", \"one\", \"three\");\n             fail();\n         } catch (ArgumentsAreDifferent e) {\n-            assertThat(e, messageContains(\"1st: 10\"));\n-            assertThat(e, messageContains(\"2nd: \\\"two\\\"\"));\n-            assertThat(e, messageContains(\"3rd: \\\"one\\\"\"));\n-            assertThat(e, messageContains(\"4th: \\\"three\\\"\"));\n-            \n-            assertThat(e, causeMessageContains(\"1st: 10\"));\n-            assertThat(e, causeMessageContains(\"2nd: \\\"one\\\"\"));\n-            assertThat(e, causeMessageContains(\"3rd: \\\"two\\\"\"));\n-            assertThat(e, causeMessageContains(\"4th: \\\"three\\\"\"));\n+            assertThat(e, messageContains(\"(10, \\\"two\\\"\"));\n+            assertThat(e, causeMessageContains(\"(10, \\\"one\\\"\"));\n         }\n     }\n \n             verify(mock).simpleMethod(\"test\");\n             fail();\n         } catch (ArgumentsAreDifferent e) {\n-            assertThat(e, causeMessageContains(\"1st: null\"));\n-            assertThat(e, causeMessageContains(\"2nd: null\"));\n+            assertThat(e, causeMessageContains(\"simpleMethod(null, null);\"));\n         }\n     }\n     ", "timestamp": 1206040907, "metainfo": ""}