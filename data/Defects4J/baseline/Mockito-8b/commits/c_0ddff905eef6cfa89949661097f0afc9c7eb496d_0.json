{"sha": "0ddff905eef6cfa89949661097f0afc9c7eb496d", "log": "First step of some longer rename job. MockHandler->MockHandlerImpl  --HG-- rename : src/org/mockito/internal/MockHandler.java => src/org/mockito/internal/MockHandlerImpl.java rename : test/org/mockito/internal/MockHandlerTest.java => test/org/mockito/internal/MockHandlerImplTest.java", "commit": "\n--- a/src/org/mockito/internal/InvocationNotifierHandler.java\n+++ b/src/org/mockito/internal/InvocationNotifierHandler.java\n  * Handler, that call all listeners wanted for this mock, before delegating it\n  * to the parameterized handler.\n  *\n- * Also imposterize MockHandler, delegate all call of MockHandlerInterface to the real mockHandler\n+ * Also imposterize MockHandlerImpl, delegate all call of MockHandlerInterface to the real mockHandler\n  */\n public class InvocationNotifierHandler<T> implements MockitoInvocationHandler, MockHandlerInterface<T>  {\n \n     private List<InvocationListener> invocationListeners;\n-    private MockHandler<T> mockHandler;\n+    private MockHandlerImpl<T> mockHandler;\n \n-    public InvocationNotifierHandler(MockHandler<T> mockHandler, MockCreationSettings settings) {\n+    public InvocationNotifierHandler(MockHandlerImpl<T> mockHandler, MockCreationSettings settings) {\n         this.mockHandler = mockHandler;\n         this.invocationListeners = settings.getInvocationListeners();\n     }\n--- /dev/null\n+++ b/src/org/mockito/internal/MockHandlerImpl.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal;\n+\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.MatchersBinder;\n+import org.mockito.internal.progress.MockingProgress;\n+import org.mockito.internal.progress.ThreadSafeMockingProgress;\n+import org.mockito.internal.stubbing.*;\n+import org.mockito.internal.verification.MockAwareVerificationMode;\n+import org.mockito.internal.verification.VerificationDataImpl;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.mock.MockCreationSettings;\n+import org.mockito.stubbing.Answer;\n+import org.mockito.stubbing.VoidMethodStubbable;\n+import org.mockito.verification.VerificationMode;\n+\n+import java.util.List;\n+\n+/**\n+ * Invocation handler set on mock objects.\n+ * \n+ * @param <T>\n+ *            type of mock object to handle\n+ */\n+public class MockHandlerImpl<T> implements MockHandlerInterface<T> {\n+\n+    private static final long serialVersionUID = -2917871070982574165L;\n+\n+    InvocationContainerImpl invocationContainerImpl;\n+    MatchersBinder matchersBinder = new MatchersBinder();\n+    MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n+\n+    private final MockCreationSettings mockSettings;\n+\n+    public MockHandlerImpl(MockCreationSettings mockSettings) {\n+        this.mockSettings = mockSettings;\n+        this.mockingProgress = new ThreadSafeMockingProgress();\n+        this.matchersBinder = new MatchersBinder();\n+        this.invocationContainerImpl = new InvocationContainerImpl(mockingProgress);\n+    }\n+\n+    public Object handle(Invocation invocation) throws Throwable {\n+\t\tif (invocationContainerImpl.hasAnswersForStubbing()) {\n+            // stubbing voids with stubVoid() or doAnswer() style\n+            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(\n+                    mockingProgress.getArgumentMatcherStorage(),\n+                    invocation\n+            );\n+            invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n+            return null;\n+        }\n+        VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n+\n+        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(\n+                mockingProgress.getArgumentMatcherStorage(),\n+                invocation\n+        );\n+\n+        mockingProgress.validateState();\n+\n+        // if verificationMode is not null then someone is doing verify()\n+        if (verificationMode != null) {\n+            // We need to check if verification was started on the correct mock\n+            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n+            // TODO: can I avoid this cast here?\n+            if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {\n+                VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);\n+                verificationMode.verify(data);\n+                return null;\n+            } else {\n+                // this means there is an invocation on a different mock. Re-adding verification mode\n+                // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n+                mockingProgress.verificationStarted(verificationMode);\n+            }\n+        }\n+\n+        // prepare invocation for stubbing\n+        invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n+        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n+        mockingProgress.reportOngoingStubbing(ongoingStubbing);\n+\n+        // look for existing answer for this invocation\n+        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n+\n+        if (stubbedInvocation != null) {\n+            stubbedInvocation.captureArgumentsFrom(invocation);\n+            return stubbedInvocation.answer(invocation);\n+        } else {\n+            Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n+\n+            // redo setting invocation for potential stubbing in case of partial\n+            // mocks / spies.\n+            // Without it, the real method inside 'when' might have delegated\n+            // to other self method and overwrite the intended stubbed method\n+            // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n+            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n+            return ret;\n+        }\n+\t}\n+\n+    public VoidMethodStubbable<T> voidMethodStubbable(T mock) {\n+        return new VoidMethodStubbableImpl<T>(mock, invocationContainerImpl);\n+    }\n+\n+    public MockCreationSettings getMockSettings() {\n+        return mockSettings;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void setAnswersForStubbing(List<Answer> answers) {\n+        invocationContainerImpl.setAnswersForStubbing(answers);\n+    }\n+\n+    public InvocationContainer getInvocationContainer() {\n+        return invocationContainerImpl;\n+    }\n+}\n+\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n \n import org.mockito.exceptions.misusing.NotAMockException;\n import org.mockito.internal.InvocationNotifierHandler;\n-import org.mockito.internal.MockHandler;\n+import org.mockito.internal.MockHandlerImpl;\n import org.mockito.internal.MockHandlerInterface;\n import org.mockito.internal.configuration.ClassPathLoader;\n-import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.creation.settings.CreationSettings;\n import org.mockito.internal.util.reflection.LenientCopyTool;\n import org.mockito.mock.MockCreationSettings;\n import org.mockito.mock.MockName;\n import org.mockito.plugins.MockMaker;\n-\n-import java.io.Serializable;\n-import java.util.HashSet;\n-import java.util.Set;\n \n @SuppressWarnings(\"unchecked\")\n public class MockUtil {\n \n     public <T> T createMock(MockCreationSettings<T> settings) {\n         InvocationNotifierHandler<T> mockHandler = new InvocationNotifierHandler<T>(\n-                new MockHandler<T>(settings), settings);\n+                new MockHandlerImpl<T>(settings), settings);\n         T mock = mockMaker.createMock(settings, mockHandler);\n \n         Object spiedInstance = settings.getSpiedInstance();\n         InvocationNotifierHandler oldHandler = (InvocationNotifierHandler) getMockHandler(mock);\n         MockCreationSettings settings = oldHandler.getMockSettings();\n         InvocationNotifierHandler<T> newHandler = new InvocationNotifierHandler<T>(\n-                new MockHandler<T>(settings), settings);\n+                new MockHandlerImpl<T>(settings), settings);\n         mockMaker.resetMock(mock, newHandler, settings);\n     }\n \n--- a/src/org/mockito/plugins/MockMaker.java\n+++ b/src/org/mockito/plugins/MockMaker.java\n      *     <li>Create a proxy object that implements {@code settings.typeToMock} and potentially also {@code settings.extraInterfaces}.</li>\n      *     <li>You may use the information from {@code settings} to create/configure your proxy object.</li>\n      *     <li>Your proxy object should carry the {@code hander} with it. For example, if you generate byte code\n-     *     to create the proxy you could generate an extra field to keep the {@code hanlder} with the generated object.\n-     *     Your implementation of {@code MockHandler} is required to provide this instance of {@code handler} when\n+     *     to create the proxy you could generate an extra field to keep the {@code handler} with the generated object.\n+     *     Your implementation of {@code MockMaker} is required to provide this instance of {@code handler} when\n      *     {@link #getHandler(Object)} is called.\n      *     </li>\n      * </ul>\n--- a/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n+++ b/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n import org.mockito.exceptions.base.MockitoExceptionTest;\n import org.mockito.internal.AllInvocationsFinderTest;\n import org.mockito.internal.InvalidStateDetectionTest;\n-import org.mockito.internal.MockHandlerTest;\n+import org.mockito.internal.MockHandlerImplTest;\n import org.mockito.internal.creation.jmock.ClassImposterizerTest;\n import org.mockito.internal.invocation.InvocationImplTest;\n import org.mockito.internal.invocation.InvocationMatcherTest;\n                     ListUtilTest.class,\n                     MockingProgressImplTest.class,\n                     TimesTest.class,\n-                    MockHandlerTest.class,\n+                    MockHandlerImplTest.class,\n                     AllInvocationsFinderTest.class,\n                     ReturnsEmptyValuesTest.class,\n                     NumberOfInvocationsCheckerTest.class,\n--- a/test/org/mockito/internal/InvocationNotifierHandlerTest.java\n+++ b/test/org/mockito/internal/InvocationNotifierHandlerTest.java\n     @Spy private CustomListener customListener;\n \n     @Mock private Invocation invocation;\n-    @Mock private MockHandler mockHandler;\n+    @Mock private MockHandlerImpl mockHandler;\n \n     private InvocationNotifierHandler notifier;\n \n--- /dev/null\n+++ b/test/org/mockito/internal/MockHandlerImplTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal;\n+\n+import org.junit.Test;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n+import org.mockito.internal.creation.MockSettingsImpl;\n+import org.mockito.internal.invocation.InvocationImpl;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.MatchersBinder;\n+import org.mockito.internal.progress.ArgumentMatcherStorage;\n+import org.mockito.internal.stubbing.InvocationContainerImpl;\n+import org.mockito.internal.stubbing.StubbedInvocationMatcher;\n+import org.mockito.internal.verification.VerificationModeFactory;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.listeners.InvocationListener;\n+import org.mockito.listeners.MethodInvocationReport;\n+import org.mockitoutil.TestBase;\n+\n+import java.util.Arrays;\n+\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.mock;\n+\n+@SuppressWarnings({ \"unchecked\", \"serial\" })\n+public class MockHandlerImplTest extends TestBase {\n+\n+\tprivate StubbedInvocationMatcher stubbedInvocationMatcher = mock(StubbedInvocationMatcher.class);\n+\tprivate Invocation invocation = mock(InvocationImpl.class);\n+\n+\n+\t@Test\n+\tpublic void shouldRemoveVerificationModeEvenWhenInvalidMatchers() throws Throwable {\n+\t\t// given\n+\t\tInvocation invocation = new InvocationBuilder().toInvocation();\n+\t\t@SuppressWarnings(\"rawtypes\")\n+        MockHandlerImpl<?> handler = new MockHandlerImpl(new MockSettingsImpl());\n+\t\thandler.mockingProgress.verificationStarted(VerificationModeFactory.atLeastOnce());\n+\t\thandler.matchersBinder = new MatchersBinder() {\n+\t\t\tpublic InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {\n+\t\t\t\tthrow new InvalidUseOfMatchersException();\n+\t\t\t}\n+\t\t};\n+\n+\t\ttry {\n+\t\t\t// when\n+\t\t\thandler.handle(invocation);\n+\n+\t\t\t// then\n+\t\t\tfail();\n+\t\t} catch (InvalidUseOfMatchersException e) {\n+\t\t}\n+\n+\t\tassertNull(handler.mockingProgress.pullVerificationMode());\n+\t}\n+\n+\n+\n+\n+\t@Test(expected = MockitoException.class)\n+\tpublic void shouldThrowMockitoExceptionWhenInvocationHandlerThrowsAnything() throws Throwable {\n+\t\t// given\n+\t\tInvocationListener throwingListener = mock(InvocationListener.class);\n+\t\tdoThrow(new Throwable()).when(throwingListener).reportInvocation(any(MethodInvocationReport.class));\n+\t\tMockHandlerImpl<?> handler = createCorrectlyStubbedHandler(throwingListener);\n+\n+\t\t// when\n+\t\thandler.handle(invocation);\n+\t}\n+\n+\n+\n+\tprivate MockHandlerImpl<?> createCorrectlyStubbedHandler(InvocationListener throwingListener) {\n+\t\tMockHandlerImpl<?> handler = createHandlerWithListeners(throwingListener);\n+\t\tstubOrdinaryInvocationWithGivenReturnValue(handler);\n+\t\treturn handler;\n+\t}\n+\n+\tprivate void stubOrdinaryInvocationWithGivenReturnValue(MockHandlerImpl<?> handler) {\n+\t\tstubOrdinaryInvocationWithInvocationMatcher(handler, stubbedInvocationMatcher);\n+\t}\n+\n+\n+\n+\tprivate void stubOrdinaryInvocationWithInvocationMatcher(MockHandlerImpl<?> handler, StubbedInvocationMatcher value) {\n+\t\thandler.invocationContainerImpl = mock(InvocationContainerImpl.class);\n+\t\tgiven(handler.invocationContainerImpl.findAnswerFor(any(InvocationImpl.class))).willReturn(value);\n+\t}\n+\n+\n+\n+\n+\tprivate MockHandlerImpl<?> createHandlerWithListeners(InvocationListener... listener) {\n+\t\t@SuppressWarnings(\"rawtypes\")\n+        MockHandlerImpl<?> handler = new MockHandlerImpl(mock(MockSettingsImpl.class));\n+\t\thandler.matchersBinder = mock(MatchersBinder.class);\n+\t\tgiven(handler.getMockSettings().getInvocationListeners()).willReturn(Arrays.asList(listener));\n+\t\treturn handler;\n+\t}\n+}", "timestamp": 1334523893, "metainfo": ""}