{"sha": "e011fc733c93718415622c4da5ef4aadd97154d7", "log": "fixed bug in MockitoBehavior  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%4073", "commit": "\n--- a/src/org/mockito/internal/MockitoBehavior.java\n+++ b/src/org/mockito/internal/MockitoBehavior.java\n         int verifiedSoFar = 0;        \n         for (Invocation invocation : registeredInvocations) {\n             boolean shouldMarkAsVerified = \n-                verifyingMode.atLeastOnceMode() || verifyingMode.getExpectedNumberOfInvocations() >= verifiedSoFar;\n+                verifyingMode.atLeastOnceMode() || \n+                verifyingMode.getExpectedNumberOfInvocations() > verifiedSoFar;\n             if (expected.matches(invocation) && shouldMarkAsVerified) {\n                 invocation.markVerified();\n                 verifiedSoFar++;\n--- a/src/org/mockito/internal/VerifyingMode.java\n+++ b/src/org/mockito/internal/VerifyingMode.java\n     }\n     \n     /**\n-     * <pre>\n      * Don't use VerifyingMode class directly. \n-     * \n+     * <p>\n      * Use Mockito.atLeastOnce() and Mockito.times()\n-     * </pre>\n      */\n     public static void dont_use_this_class_directly_instead_use_static_methods_on_Mockito() {}\n     \n--- a/test/org/mockito/internal/MockitoBehaviorTest.java\n+++ b/test/org/mockito/internal/MockitoBehaviorTest.java\n @SuppressWarnings(\"unchecked\")\n public class MockitoBehaviorTest {\n \n-    private Method toLowerCase;\n-    private Method toUpperCase;\n     private MockitoBehavior behavior;\n+    private ExpectedInvocation toLowerCaseInvocation;\n+    private ExpectedInvocation toUpperCaseInvocation;\n+    private ExpectedInvocation toLowerCaseInvocationTwo;\n+    private ExpectedInvocation toLowerCaseInvocationThree;\n \n     @Before\n     public void setup() throws Exception {\n-        toLowerCase = String.class.getMethod(\"toLowerCase\", new Class[] {});\n-        toUpperCase = String.class.getMethod(\"toUpperCase\", new Class[] {});\n+        Method toLowerCase = String.class.getMethod(\"toLowerCase\", new Class[] {});\n+        Method toUpperCase = String.class.getMethod(\"toUpperCase\", new Class[] {});\n+        \n+        toLowerCaseInvocation = new ExpectedInvocation(new Invocation(\"mock\", toLowerCase , new Object[] {}), Collections.EMPTY_LIST);\n+        toLowerCaseInvocationTwo = new ExpectedInvocation(new Invocation(\"mock\", toLowerCase , new Object[] {}), Collections.EMPTY_LIST);\n+        toLowerCaseInvocationThree = new ExpectedInvocation(new Invocation(\"mock\", toLowerCase , new Object[] {}), Collections.EMPTY_LIST);\n+        toUpperCaseInvocation = new ExpectedInvocation(new Invocation(\"mock\", toUpperCase , new Object[] {}), Collections.EMPTY_LIST);\n+        \n         behavior = new MockitoBehavior();\n+        \n+        behavior.addInvocation(toLowerCaseInvocation);\n+        behavior.addInvocation(toLowerCaseInvocationTwo);\n+        \n+        behavior.addInvocation(toUpperCaseInvocation);\n+        \n+        behavior.addInvocation(toLowerCaseInvocationThree);\n     }\n     \n-    @Ignore\n     @Test\n-    public void shouldMarkVerifiedOnlyOneExecutionChunk() throws Exception {\n-        ExpectedInvocation toLowerCaseInvocation = new ExpectedInvocation(new Invocation(\"mock\", toLowerCase , new Object[] {}), Collections.EMPTY_LIST);\n-        ExpectedInvocation toUpperCaseInvocation = new ExpectedInvocation(new Invocation(\"mock\", toUpperCase , new Object[] {}), Collections.EMPTY_LIST);\n+    public void shouldMarkTwoInvocationsAsVerified() throws Exception {\n+        behavior.markInvocationsAsVerified(toLowerCaseInvocation, VerifyingMode.times(2));\n         \n-        behavior.addInvocation(toLowerCaseInvocation);\n-        behavior.addInvocation(toLowerCaseInvocation);\n+        List<Invocation> invocations = behavior.getRegisteredInvocations();\n+        assertEquals(true, invocations.get(0).isVerified());\n+        assertEquals(true, invocations.get(1).isVerified());\n+        assertEquals(false, invocations.get(2).isVerified());\n+        assertEquals(false, invocations.get(3).isVerified());\n+    }\n+    \n+    @Test\n+    public void shouldMarkAllThreeInvocationsAsVerified() throws Exception {\n+        behavior.markInvocationsAsVerified(toLowerCaseInvocation, VerifyingMode.times(3));\n         \n-        behavior.addInvocation(toUpperCaseInvocation);\n-        behavior.addInvocation(toLowerCaseInvocation);\n+        List<Invocation> invocations = behavior.getRegisteredInvocations();\n+        assertEquals(true, invocations.get(0).isVerified());\n+        assertEquals(true, invocations.get(1).isVerified());\n+        assertEquals(false, invocations.get(2).isVerified());\n+        assertEquals(true, invocations.get(3).isVerified());\n+    }\n+    \n+    @Test\n+    public void shouldMarkAllInvocationsAsVerifiedWhenAtLeastOnceIsUsed() throws Exception {\n+        behavior.markInvocationsAsVerified(toLowerCaseInvocation, VerifyingMode.atLeastOnce());\n         \n-        behavior.markInvocationsAsVerified(toLowerCaseInvocation, VerifyingMode.inOrder(2, Arrays.asList(new Object())));\n-        \n-        List<ExpectedInvocation> invocations = behavior.getRegisteredInvocations();\n-        assertEquals(true, invocations.get(0).getInvocation().isVerified());\n-        assertEquals(true, invocations.get(1).getInvocation().isVerified());\n-        assertEquals(false, invocations.get(2).getInvocation().isVerified());\n-        assertEquals(false, invocations.get(3).getInvocation().isVerified());\n+        List<Invocation> invocations = behavior.getRegisteredInvocations();\n+        assertEquals(true, invocations.get(0).isVerified());\n+        assertEquals(true, invocations.get(1).isVerified());\n+        assertEquals(false, invocations.get(2).isVerified());\n+        assertEquals(true, invocations.get(3).isVerified());\n     }\n }", "timestamp": 1196103750, "metainfo": ""}