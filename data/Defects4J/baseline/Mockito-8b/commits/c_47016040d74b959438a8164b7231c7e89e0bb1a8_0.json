{"sha": "47016040d74b959438a8164b7231c7e89e0bb1a8", "log": "more and more refactorings around verification  --HG-- rename : src/org/mockito/internal/verification/VerificationModeImpl.java => src/org/mockito/internal/verification/MockitoVerificationMode.java rename : test/org/mockito/internal/progress/VerificationModeImplTest.java => test/org/mockito/internal/progress/MockitoVerificationModeTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40938", "commit": "\n--- a/src/org/mockito/AdditionalMatchers.java\n+++ b/src/org/mockito/AdditionalMatchers.java\n import org.mockito.internal.matchers.GreaterThan;\n import org.mockito.internal.matchers.LessOrEqual;\n import org.mockito.internal.matchers.LessThan;\n+import org.mockito.internal.progress.EmptyReturnValues;\n import org.mockito.internal.progress.LastArguments;\n-import org.mockito.internal.progress.EmptyReturnValues;\n \n /**\n  * See {@link Matchers} for general info about matchers.\n--- a/src/org/mockito/InOrderVerifier.java\n+++ b/src/org/mockito/InOrderVerifier.java\n \n import org.mockito.exceptions.Reporter;\n import org.mockito.internal.verification.VerificationMode;\n-import org.mockito.internal.verification.VerificationModeImpl;\n+import org.mockito.internal.verification.VerificationModeFactory;\n \n /**\n  * Allows verifying in order. This class should not be exposed, hence default access.\n     }\n \n     public <T> T verify(T mock) {\n-        return this.verify(mock, VerificationModeImpl.times(1));\n+        return this.verify(mock, VerificationModeFactory.times(1));\n     }\n     \n     public <T> T verify(T mock, VerificationMode mode) {\n--- a/src/org/mockito/Mock.java\n+++ b/src/org/mockito/Mock.java\n  */\n package org.mockito;\n \n-import static java.lang.annotation.ElementType.FIELD;\n+import static java.lang.annotation.ElementType.*;\n \n import java.lang.annotation.Retention;\n import java.lang.annotation.RetentionPolicy;\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n import org.mockito.internal.stubbing.VoidMethodStubbable;\n import org.mockito.internal.util.MockUtil;\n import org.mockito.internal.verification.VerificationMode;\n-import org.mockito.internal.verification.VerificationModeImpl;\n+import org.mockito.internal.verification.VerificationModeFactory;\n import org.mockito.runners.MockitoJUnit44Runner;\n import org.mockito.runners.MockitoJUnitRunner;\n import org.mockito.stubbing.Answer;\n      * @return verification mode\n      */\n     public static VerificationMode times(int wantedNumberOfInvocations) {\n-        return VerificationModeImpl.times(wantedNumberOfInvocations);\n+        return VerificationModeFactory.times(wantedNumberOfInvocations);\n     }\n     \n     /**\n      * @return verification mode\n      */\n     public static VerificationMode atLeastOnce() {\n-        return VerificationModeImpl.atLeastOnce();\n+        return VerificationModeFactory.atLeastOnce();\n     }\n \n     /**\n      * @return verification mode\n      */\n     public static VerificationMode atLeast(int minNumberOfInvocations) {\n-        return VerificationModeImpl.atLeast(minNumberOfInvocations);\n+        return VerificationModeFactory.atLeast(minNumberOfInvocations);\n     }\n }\n--- a/src/org/mockito/configuration/experimental/ConfigurationSupport.java\n+++ b/src/org/mockito/configuration/experimental/ConfigurationSupport.java\n \n import java.lang.reflect.Modifier;\n \n+import org.mockito.internal.configuration.Configuration;\n import org.mockito.internal.configuration.MockitoConfiguration;\n-import org.mockito.internal.configuration.Configuration;\n import org.mockito.internal.configuration.MockitoProperties;\n import org.mockito.invocation.InvocationOnMock;\n \n--- a/src/org/mockito/exceptions/verification/junit/ArgumentsAreDifferent.java\n+++ b/src/org/mockito/exceptions/verification/junit/ArgumentsAreDifferent.java\n import java.util.Arrays;\n \n import junit.framework.ComparisonFailure;\n+\n import org.mockito.exceptions.base.CommonStackTraceRemover;\n import org.mockito.exceptions.base.HasStackTrace;\n import org.mockito.exceptions.base.StackTraceFilter;\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n import org.mockito.internal.stubbing.VoidMethodStubbable;\n import org.mockito.internal.util.MockUtil;\n import org.mockito.internal.verification.VerificationMode;\n-import org.mockito.internal.verification.VerificationModeImpl;\n+import org.mockito.internal.verification.VerificationModeFactory;\n import org.mockito.internal.verification.VerifyingRecorder;\n import org.mockito.stubbing.Answer;\n \n     }\n \n     public void verifyNoMoreInteractions() {\n-        verifyingRecorder.verify(VerificationModeImpl.noMoreInteractions());\n+        verifyingRecorder.verify(VerificationModeFactory.noMoreInteractions());\n     }\n \n     public VoidMethodStubbable<T> voidMethodStubbable(T mock) {\n--- a/src/org/mockito/internal/invocation/InvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/InvocationsFinder.java\n import org.mockito.exceptions.base.HasStackTrace;\n import org.mockito.internal.util.ListUtil;\n import org.mockito.internal.util.ListUtil.Filter;\n+import org.mockito.internal.verification.MockitoVerificationMode;\n import org.mockito.internal.verification.VerificationMode;\n import org.mockito.internal.verification.VerificationModeDecoder;\n \n      * if wanted is 1 and mode is times(x), where x != 2 then returns\n      * 1,1,1\n      */\n-    public List<Invocation> findMatchingChunk(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode) {\n+    public List<Invocation> findMatchingChunk(List<Invocation> invocations, InvocationMatcher wanted, MockitoVerificationMode mode) {\n         List<Invocation> unverified = removeVerifiedInOrder(invocations);\n         List<Invocation> firstChunk = getFirstMatchingChunk(wanted, unverified);\n         \n--- /dev/null\n+++ b/src/org/mockito/internal/verification/MockitoVerificationMode.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.invocation.AllInvocationsFinder;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+\n+/**\n+ * Holds additional information regarding verification.\n+ * <p> \n+ * Implements marking interface which hides details from Mockito users. \n+ */\n+public class MockitoVerificationMode implements VerificationMode {\n+    \n+    public enum Verification { EXPLICIT, NO_MORE_WANTED, AT_LEAST };\n+    \n+    final int wantedInvocationCount;\n+    final Verification verification;\n+    \n+    List<? extends Object> mocksToBeVerifiedInOrder = new LinkedList<Object>();\n+    \n+    public MockitoVerificationMode(int wantedNumberOfInvocations, Verification verification) {\n+        if (verification != Verification.AT_LEAST && wantedNumberOfInvocations < 0) {\n+            throw new MockitoException(\"Negative value is not allowed here\");\n+        }\n+        if (verification == Verification.AT_LEAST && wantedNumberOfInvocations < 1) {\n+            throw new MockitoException(\"Negative value or zero are not allowed here\");\n+        }\n+        this.wantedInvocationCount = wantedNumberOfInvocations;\n+        this.verification = verification;\n+    }\n+    \n+    public void verify(List<Invocation> invocations, InvocationMatcher wanted) {\n+        //TODO null-check or isEmpty?\n+        if (mocksToBeVerifiedInOrder.isEmpty()) {\n+            doBasicVerification(invocations, wanted);\n+        } else {            \n+            doInOrderVerification(wanted);\n+        }\n+    }\n+\n+    private void doInOrderVerification(InvocationMatcher wanted) {\n+        List<Invocation> invocations;\n+        invocations = new AllInvocationsFinder().getAllInvocations(mocksToBeVerifiedInOrder);\n+\n+        MissingInvocationInOrderVerifier missingInvocation = new MissingInvocationInOrderVerifier();\n+        NumberOfInvocationsInOrderVerifier numberOfCalls = new NumberOfInvocationsInOrderVerifier();\n+        \n+        if (wantedInvocationCount > 0 || (verification == Verification.AT_LEAST && wantedInvocationCount == 1)) {\n+            missingInvocation.verify(invocations, wanted, this);\n+        }\n+\n+        numberOfCalls.verify(invocations, wanted, this);\n+    }\n+\n+    private void doBasicVerification(List<Invocation> invocations, InvocationMatcher wanted) {\n+        MissingInvocationVerifier missingInvocation = new MissingInvocationVerifier();\n+        NumberOfInvocationsVerifier numberOfInvocations = new NumberOfInvocationsVerifier();\n+        \n+        //TODO duplicated\n+        if (wantedInvocationCount > 0 || (verification == Verification.AT_LEAST && wantedInvocationCount == 1)) {\n+            missingInvocation.verify(invocations, wanted, this);\n+        }\n+        numberOfInvocations.verify(invocations, wanted, this);\n+    }\n+\n+    public void setMocksToBeVerifiedInOrder(List<Object> mocks) {\n+        this.mocksToBeVerifiedInOrder = mocks;\n+    }\n+    public int wantedCount() {\n+        return wantedInvocationCount;\n+    }\n+    \n+    public Verification getVerification() {\n+        return verification;\n+    }\n+    \n+    @Override\n+    public String toString() {\n+        return \"Wanted invocations count: \" + wantedInvocationCount + \", Mocks to verify in order: \" + mocksToBeVerifiedInOrder;\n+    }\n+}\n--- a/src/org/mockito/internal/verification/NoMoreInteractionsMode.java\n+++ b/src/org/mockito/internal/verification/NoMoreInteractionsMode.java\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsFinder;\n \n-public class NoMoreInteractionsMode extends VerificationModeImpl implements VerificationMode {\n+public class NoMoreInteractionsMode implements VerificationMode {\n \n-    protected NoMoreInteractionsMode(int wantedNumberOfInvocations, List<? extends Object> mocksToBeVerifiedInOrder,\n-            Verification verification) {\n-        super(wantedNumberOfInvocations, mocksToBeVerifiedInOrder, verification);\n-    }\n-    \n     public void verify(List<Invocation> invocations, InvocationMatcher wanted) {\n         Invocation unverified = new InvocationsFinder().findFirstUnverified(invocations);\n         \n             new Reporter().noMoreInteractionsWanted(unverified, unverified.getStackTrace());\n         }\n     }\n+\n+    @Override\n+    public void setMocksToBeVerifiedInOrder(List<Object> mocks) {\n+        //do nothing\n+    }\n }\n--- a/src/org/mockito/internal/verification/NumberOfInvocationsInOrderVerifier.java\n+++ b/src/org/mockito/internal/verification/NumberOfInvocationsInOrderVerifier.java\n         this.reporter = reporter;\n     }\n     \n-    public void verify(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode) {\n+    public void verify(List<Invocation> invocations, InvocationMatcher wanted, MockitoVerificationMode mode) {\n         VerificationModeDecoder decoder = new VerificationModeDecoder(mode);\n         List<Invocation> chunk = finder.findMatchingChunk(invocations, wanted, mode);\n         \n--- a/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n+++ b/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n         this.finder = finder;\n     }\n     \n-    public void verify(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode) {\n+    public void verify(List<Invocation> invocations, InvocationMatcher wanted, MockitoVerificationMode mode) {\n         VerificationModeDecoder decoder = new VerificationModeDecoder(mode);\n         List<Invocation> actualInvocations = finder.findInvocations(invocations, wanted, mode);\n         \n--- a/src/org/mockito/internal/verification/VerificationMode.java\n+++ b/src/org/mockito/internal/verification/VerificationMode.java\n import org.mockito.Mockito;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.verification.VerificationModeImpl.Verification;\n \n /**\n  * Allows verifying that certain behavior happened at least once / exact number\n  */\n public interface VerificationMode {\n \n-    Integer wantedCount();\n-\n-    List<? extends Object> getMocksToBeVerifiedInOrder();\n-\n-    Verification getVerification();\n-    \n     void verify(List<Invocation> invocations, InvocationMatcher wanted);\n \n     void setMocksToBeVerifiedInOrder(List<Object> mocks);\n--- a/src/org/mockito/internal/verification/VerificationModeDecoder.java\n+++ b/src/org/mockito/internal/verification/VerificationModeDecoder.java\n package org.mockito.internal.verification;\n \n-import org.mockito.internal.verification.VerificationModeImpl.Verification;\n+import org.mockito.internal.verification.MockitoVerificationMode.Verification;\n \n public class VerificationModeDecoder {\n \n-    private final VerificationMode mode;\n+    private final MockitoVerificationMode mode;\n \n-    public VerificationModeDecoder(VerificationMode mode) {\n+    public VerificationModeDecoder(MockitoVerificationMode mode) {\n         this.mode = mode;\n     }\n \n--- a/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n+++ b/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n import org.mockito.internal.invocation.InvocationsFinderTest;\n import org.mockito.internal.matchers.EqualsTest;\n import org.mockito.internal.progress.MockingProgressImplTest;\n-import org.mockito.internal.progress.VerificationModeImplTest;\n+import org.mockito.internal.progress.MockitoVerificationModeTest;\n import org.mockito.internal.util.ListUtilTest;\n import org.mockito.internal.util.MockUtilTest;\n import org.mockito.internal.verification.MissingInvocationInOrderVerifierTest;\n                     EqualsTest.class,\n                     ListUtilTest.class,\n                     MockingProgressImplTest.class,\n-                    VerificationModeImplTest.class,\n+                    MockitoVerificationModeTest.class,\n                     MockHandlerTest.class,\n                     AllInvocationsFinderTest.class,\n                     DefaultReturnValuesTest.class,\n--- a/test/org/mockito/internal/MockHandlerTest.java\n+++ b/test/org/mockito/internal/MockHandlerTest.java\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.MatchersBinder;\n import org.mockito.internal.progress.MockingProgressImpl;\n-import org.mockito.internal.verification.VerificationModeImpl;\n+import org.mockito.internal.verification.VerificationModeFactory;\n import org.mockitoutil.TestBase;\n \n @SuppressWarnings(\"unchecked\")\n     @Test\n     public void shouldRemoveVerificationModeEvenWhenInvalidMatchers() throws Throwable {\n         MockingProgressImpl state = new MockingProgressImpl();\n-        state.verificationStarted(VerificationModeImpl.atLeastOnce());\n+        state.verificationStarted(VerificationModeFactory.atLeastOnce());\n         MockHandler handler = new MockHandler(null, state, new ExceptionThrowingBinder());\n         \n         try {\n--- a/test/org/mockito/internal/invocation/InvocationsFinderTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationsFinderTest.java\n  */\n package org.mockito.internal.invocation;\n \n-import static org.mockito.internal.verification.VerificationModeImpl.*;\n import static org.mockitoutil.ExtraMatchers.*;\n \n import java.util.Arrays;\n import org.mockito.Mock;\n import org.mockito.exceptions.base.HasStackTrace;\n import org.mockito.internal.progress.VerificationModeBuilder;\n-import org.mockito.internal.verification.VerificationMode;\n+import org.mockito.internal.verification.MockitoVerificationMode;\n+import org.mockito.internal.verification.VerificationModeFactory;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n \n     @Test\n     public void shouldFindActualInvocations() throws Exception {\n-        List<Invocation> actual = finder.findInvocations(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnce());\n+        List<Invocation> actual = finder.findInvocations(invocations, new InvocationMatcher(simpleMethodInvocation), VerificationModeFactory.atLeastOnce());\n         assertThat(actual, hasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo));\n         \n-        actual = finder.findInvocations(invocations, new InvocationMatcher(differentMethodInvocation), atLeastOnce());\n+        actual = finder.findInvocations(invocations, new InvocationMatcher(differentMethodInvocation), VerificationModeFactory.atLeastOnce());\n         assertThat(actual, hasExactlyInOrder(differentMethodInvocation));\n     }\n     \n     public void shouldFindFirstSimilarInvocationByName() throws Exception {\n         Invocation overloadedSimpleMethod = new InvocationBuilder().mock(mock).simpleMethod().arg(\"test\").toInvocation();\n         \n-        Invocation found = finder.findSimilarInvocation(invocations, new InvocationMatcher(overloadedSimpleMethod), atLeastOnce());\n+        Invocation found = finder.findSimilarInvocation(invocations, new InvocationMatcher(overloadedSimpleMethod), VerificationModeFactory.atLeastOnce());\n         assertSame(found, simpleMethodInvocation);\n     }\n     \n         \n         invocations.add(overloadedDifferentMethod);\n         \n-        Invocation found = finder.findSimilarInvocation(invocations, new InvocationMatcher(overloadedDifferentMethod), atLeastOnce());\n+        Invocation found = finder.findSimilarInvocation(invocations, new InvocationMatcher(overloadedDifferentMethod), VerificationModeFactory.atLeastOnce());\n         assertSame(found, overloadedDifferentMethod);\n     }\n     \n     \n     @Test\n     public void shouldFindMatchingChunk() throws Exception {\n-        VerificationMode inOrderMode = new VerificationModeBuilder().times(2).inOrder();\n+        MockitoVerificationMode inOrderMode = new VerificationModeBuilder().times(2).inOrder();\n         List<Invocation> chunk = finder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), inOrderMode);\n         assertThat(chunk, hasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo));\n     }\n         Invocation simpleMethodInvocationThree = new InvocationBuilder().mock(mock).toInvocation();\n         invocations.add(simpleMethodInvocationThree);\n         \n-        VerificationMode atLeastOnceInOrder = new VerificationModeBuilder().inOrder();\n+        MockitoVerificationMode atLeastOnceInOrder = new VerificationModeBuilder().inOrder();\n         List<Invocation> chunk = finder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnceInOrder);\n         assertThat(chunk, hasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo, simpleMethodInvocationThree));\n     }\n         Invocation simpleMethodInvocationThree = new InvocationBuilder().mock(mock).toInvocation();\n         invocations.add(simpleMethodInvocationThree);\n         \n-        VerificationMode atLeastOnceInOrder = new VerificationModeBuilder().times(100).inOrder();\n+        MockitoVerificationMode atLeastOnceInOrder = new VerificationModeBuilder().times(100).inOrder();\n         List<Invocation> chunk = finder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnceInOrder);\n         assertThat(chunk, hasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo, simpleMethodInvocationThree));\n     }\n--- a/test/org/mockito/internal/progress/MockingProgressImplTest.java\n+++ b/test/org/mockito/internal/progress/MockingProgressImplTest.java\n import org.junit.Test;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.verification.VerificationMode;\n-import org.mockito.internal.verification.VerificationModeImpl;\n+import org.mockito.internal.verification.VerificationModeFactory;\n import org.mockitoutil.TestBase;\n \n public class MockingProgressImplTest extends TestBase {\n     public void shouldStartVerificationAndPullVerificationMode() throws Exception {\n         assertNull(mockingProgress.pullVerificationMode());\n         \n-        VerificationMode mode = VerificationModeImpl.times(19);\n+        VerificationMode mode = VerificationModeFactory.times(19);\n         \n         mockingProgress.verificationStarted(mode);\n         \n     \n     @Test\n     public void shouldCheckIfVerificationWasFinished() throws Exception {\n-        mockingProgress.verificationStarted(VerificationModeImpl.atLeastOnce());\n+        mockingProgress.verificationStarted(VerificationModeFactory.atLeastOnce());\n         try {\n-            mockingProgress.verificationStarted(VerificationModeImpl.atLeastOnce());\n+            mockingProgress.verificationStarted(VerificationModeFactory.atLeastOnce());\n             fail();\n         } catch (MockitoException e) {}\n     }\n--- /dev/null\n+++ b/test/org/mockito/internal/progress/MockitoVerificationModeTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.progress;\n+\n+import org.junit.Test;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.verification.VerificationModeFactory;\n+import org.mockitoutil.TestBase;\n+\n+public class MockitoVerificationModeTest extends TestBase {\n+\n+    @Test\n+    public void shouldNotAllowNegativeNumberOfInvocations() throws Exception {\n+        try {\n+            VerificationModeFactory.times(-50);\n+            fail();\n+        } catch (MockitoException e) {\n+            assertEquals(\"Negative value is not allowed here\", e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldNotAllowNegativeNumberOfMinimumInvocations() throws Exception {\n+        try {\n+            VerificationModeFactory.atLeast(-50);\n+            fail();\n+        } catch (MockitoException e) {\n+            assertEquals(\"Negative value or zero are not allowed here\", e.getMessage());\n+        }\n+    }\n+}\n--- a/test/org/mockito/internal/progress/VerificationModeBuilder.java\n+++ b/test/org/mockito/internal/progress/VerificationModeBuilder.java\n  */\n package org.mockito.internal.progress;\n \n-import java.util.Arrays;\n \n-import org.mockito.internal.verification.BasicVerificationMode;\n-import org.mockito.internal.verification.VerificationMode;\n-import org.mockito.internal.verification.VerificationModeImpl.Verification;\n+import org.mockito.internal.verification.MockitoVerificationMode;\n+import org.mockito.internal.verification.MockitoVerificationMode.Verification;\n \n public class VerificationModeBuilder {\n \n     private Integer times = 1;\n \n-    public VerificationMode inOrder() {\n+    public MockitoVerificationMode inOrder() {\n         //TODO move to factory\n-        return new BasicVerificationMode(times, Arrays.asList(new Object()), Verification.EXPLICIT);\n+        return new MockitoVerificationMode(times, Verification.EXPLICIT);\n     }\n \n     public VerificationModeBuilder times(int times) {\n--- a/test/org/mockito/internal/verification/InvocationsFinderStub.java\n+++ b/test/org/mockito/internal/verification/InvocationsFinderStub.java\n     }\n     \n     @Override\n-    public List<Invocation> findMatchingChunk(List<Invocation> invocations, InvocationMatcher wanted, VerificationMode mode) {\n+    public List<Invocation> findMatchingChunk(List<Invocation> invocations, InvocationMatcher wanted, MockitoVerificationMode mode) {\n         return validMatchingChunkToReturn;\n     }\n \n--- a/test/org/mockito/internal/verification/MissingInvocationVerifierTest.java\n+++ b/test/org/mockito/internal/verification/MissingInvocationVerifierTest.java\n package org.mockito.internal.verification;\n \n import static java.util.Arrays.*;\n-import static org.mockito.internal.verification.VerificationModeImpl.*;\n \n import java.util.List;\n \n     @Test\n     public void shouldAskFinderForActualInvocations() {\n         finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());\n-        VerificationMode mode = atLeastOnce();\n+        VerificationMode mode = VerificationModeFactory.atLeastOnce();\n         verifier.verify(invocations, wanted, mode);\n         \n         assertSame(invocations, finderStub.invocations);\n     @Test\n     public void shouldPassBecauseActualInvocationFound() {\n         finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());\n-        verifier.verify(invocations, wanted, atLeastOnce());\n+        verifier.verify(invocations, wanted, VerificationModeFactory.atLeastOnce());\n     }\n     \n     @Test\n     public void shouldAskAnalyzerForSimilarInvocation() {\n-        verifier.verify(invocations, wanted, VerificationModeImpl.atLeastOnce());\n+        verifier.verify(invocations, wanted, VerificationModeFactory.atLeastOnce());\n         \n         assertSame(invocations, finderStub.invocations);\n     }\n         assertTrue(finderStub.actualToReturn.isEmpty());\n         finderStub.similarToReturn = null;\n         \n-        verifier.verify(invocations, wanted, VerificationModeImpl.atLeastOnce());\n+        verifier.verify(invocations, wanted, VerificationModeFactory.atLeastOnce());\n         \n         assertEquals(wanted, reporterStub.wanted);\n         assertNull(reporterStub.actualInvocationStackTrace);\n         Invocation actualInvocation = new InvocationBuilder().toInvocation();\n         finderStub.similarToReturn = actualInvocation;\n         \n-        verifier.verify(invocations, wanted, VerificationModeImpl.atLeastOnce());\n+        verifier.verify(invocations, wanted, VerificationModeFactory.atLeastOnce());\n         \n         assertNotNull(reporterStub.wanted);\n         assertNotNull(reporterStub.actual);\n--- a/test/org/mockito/internal/verification/NoMoreInvocationsVerifierTest.java\n+++ b/test/org/mockito/internal/verification/NoMoreInvocationsVerifierTest.java\n //    @Test\n //    public void shouldPassVerification() throws Exception {\n //        finder.firstUnverifiedToReturn = null;\n-//        verifier.verify(null, null, VerificationModeImpl.noMoreInteractions());\n+//        verifier.verify(null, null, MockitoVerificationMode.noMoreInteractions());\n //    }\n //    \n //    @Test\n //        finder.firstUnverifiedToReturn = firstUnverified;\n //        List<Invocation> invocations = asList(new InvocationBuilder().toInvocation());\n //        \n-//        verifier.verify(invocations, null, VerificationModeImpl.noMoreInteractions());\n+//        verifier.verify(invocations, null, MockitoVerificationMode.noMoreInteractions());\n //        \n //        assertSame(invocations, finder.invocations);\n //        \n--- a/test/org/mockito/internal/verification/NumberOfInvocationsVerifierTest.java\n+++ b/test/org/mockito/internal/verification/NumberOfInvocationsVerifierTest.java\n package org.mockito.internal.verification;\n \n import static java.util.Arrays.*;\n-import static org.mockito.internal.verification.VerificationModeImpl.*;\n \n import java.util.LinkedList;\n \n \n     @Test\n     public void shouldReportTooLittleActual() throws Exception {\n-        VerificationMode mode = times(100);\n+        MockitoVerificationMode mode = VerificationModeFactory.times(100);\n         finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());\n         \n         verifier.verify(invocations, wanted, mode);\n \n     @Test\n     public void shouldReportWithLastInvocationStackTrace() throws Exception {\n-        VerificationMode mode = times(100);\n+        MockitoVerificationMode mode = VerificationModeFactory.times(100);\n         Invocation first = new InvocationBuilder().toInvocation();\n         Invocation second = new InvocationBuilder().toInvocation();\n         \n     \n     @Test\n     public void shouldNotReportWithLastInvocationStackTraceIfNoInvocationsFound() throws Exception {\n-        VerificationMode mode = times(100);\n+        MockitoVerificationMode mode = VerificationModeFactory.times(100);\n         \n         assertTrue(finderStub.actualToReturn.isEmpty());\n         \n     \n     @Test\n     public void shouldReportWithFirstUndesiredInvocationStackTrace() throws Exception {\n-        VerificationMode mode = times(2);\n+        MockitoVerificationMode mode = VerificationModeFactory.times(2);\n \n         Invocation first = new InvocationBuilder().toInvocation();\n         Invocation second = new InvocationBuilder().toInvocation();\n     \n     @Test\n     public void shouldReportTooManyActual() throws Exception {\n-        VerificationMode mode = times(1);\n+        MockitoVerificationMode mode = VerificationModeFactory.times(1);\n         finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());\n         finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());\n         \n     \n     @Test\n     public void shouldReportNeverWantedButInvoked() throws Exception {\n-        VerificationMode mode = times(0);\n+        MockitoVerificationMode mode = VerificationModeFactory.times(0);\n         Invocation invocation = new InvocationBuilder().toInvocation();\n         finderStub.actualToReturn.add(invocation);\n         \n         finderStub.actualToReturn.add(invocation);\n         assertFalse(invocation.isVerified());\n         \n-        verifier.verify(invocations, wanted, atLeastOnce());\n+        verifier.verify(invocations, wanted, VerificationModeFactory.atLeastOnce());\n         \n         assertTrue(invocation.isVerified());\n     }\n--- a/test/org/mockito/internal/verification/VerificationModeDecoderTest.java\n+++ b/test/org/mockito/internal/verification/VerificationModeDecoderTest.java\n package org.mockito.internal.verification;\n-\n-import static org.mockito.internal.verification.VerificationModeImpl.*;\n \n import org.junit.Test;\n import org.mockitoutil.TestBase;\n \n public class VerificationModeDecoderTest extends TestBase {\n     \n-    private VerificationModeDecoder decode(VerificationMode mode) {\n+    private VerificationModeDecoder decode(MockitoVerificationMode mode) {\n         return new VerificationModeDecoder(mode);\n     }\n     \n     @Test\n     public void shouldKnowIfIsMissingMethodMode() throws Exception {\n-        assertTrue(decode(atLeastOnce()).missingMethodMode());\n-        assertTrue(decode(times(1)).missingMethodMode());\n-        assertTrue(decode(times(10)).missingMethodMode());\n+        assertTrue(decode(VerificationModeFactory.atLeastOnce()).missingMethodMode());\n+        assertTrue(decode(VerificationModeFactory.times(1)).missingMethodMode());\n+        assertTrue(decode(VerificationModeFactory.times(10)).missingMethodMode());\n         \n-        assertFalse(decode(atLeast(2)).missingMethodMode());\n-        assertFalse(decode(noMoreInteractions()).missingMethodMode());\n-        assertFalse(decode(times(0)).missingMethodMode());\n+        assertFalse(decode(VerificationModeFactory.atLeast(2)).missingMethodMode());\n+        assertFalse(decode(VerificationModeFactory.times(0)).missingMethodMode());\n     }\n     \n     @Test\n     public void shouldKnowIfNumberOfInvocationsMatters() throws Exception {\n-        VerificationMode mode = atLeastOnce();\n+        MockitoVerificationMode mode = VerificationModeFactory.atLeastOnce();\n         assertTrue(decode(mode).atLeastMode());\n         \n-        mode = times(50);\n+        mode = VerificationModeFactory.times(50);\n         assertFalse(decode(mode).atLeastMode());\n     }\n     \n     @Test\n     public void shouldKnowIfIsAtLeastMode() throws Exception {\n-        assertTrue(decode(atLeastOnce()).atLeastMode());\n-        assertTrue(decode(atLeast(10)).atLeastMode());\n+        assertTrue(decode(VerificationModeFactory.atLeastOnce()).atLeastMode());\n+        assertTrue(decode(VerificationModeFactory.atLeast(10)).atLeastMode());\n         \n-        assertFalse(decode(times(0)).atLeastMode());\n-        assertFalse(decode(times(10)).atLeastMode());\n-        assertFalse(decode(noMoreInteractions()).atLeastMode());\n+        assertFalse(decode(VerificationModeFactory.times(0)).atLeastMode());\n+        assertFalse(decode(VerificationModeFactory.times(10)).atLeastMode());\n     }\n     \n     @Test\n     public void shouldKnowIfMatchesActualInvocationCount() throws Exception {\n-        assertFalse(decode(times(1)).matchesActualCount(0));\n-        assertFalse(decode(times(1)).matchesActualCount(2));\n-        assertFalse(decode(times(10)).matchesActualCount(20));\n+        assertFalse(decode(VerificationModeFactory.times(1)).matchesActualCount(0));\n+        assertFalse(decode(VerificationModeFactory.times(1)).matchesActualCount(2));\n+        assertFalse(decode(VerificationModeFactory.times(10)).matchesActualCount(20));\n         \n-        assertTrue(decode(times(1)).matchesActualCount(1));\n-        assertTrue(decode(times(10)).matchesActualCount(10));\n+        assertTrue(decode(VerificationModeFactory.times(1)).matchesActualCount(1));\n+        assertTrue(decode(VerificationModeFactory.times(10)).matchesActualCount(10));\n     }\n     \n     @Test\n     public void shouldKnowIfMatchesActualInvocationCountWhenAtLeastOnceMode() throws Exception {\n-        assertFalse(decode(atLeastOnce()).matchesActualCount(0));\n+        assertFalse(decode(VerificationModeFactory.atLeastOnce()).matchesActualCount(0));\n         \n-        assertTrue(decode(atLeastOnce()).matchesActualCount(1));\n-        assertTrue(decode(atLeastOnce()).matchesActualCount(100));\n+        assertTrue(decode(VerificationModeFactory.atLeastOnce()).matchesActualCount(1));\n+        assertTrue(decode(VerificationModeFactory.atLeastOnce()).matchesActualCount(100));\n     }\n     \n     @Test\n     public void shouldKnowIfMatchesActualInvocationCountWhenAtLeastMode() throws Exception {\n-        assertFalse(decode(atLeast(10)).matchesActualCount(5));\n-        assertFalse(decode(atLeast(2)).matchesActualCount(1));\n+        assertFalse(decode(VerificationModeFactory.atLeast(10)).matchesActualCount(5));\n+        assertFalse(decode(VerificationModeFactory.atLeast(2)).matchesActualCount(1));\n         \n-        assertTrue(decode(atLeast(10)).matchesActualCount(10));\n-        assertTrue(decode(atLeast(10)).matchesActualCount(15));\n+        assertTrue(decode(VerificationModeFactory.atLeast(10)).matchesActualCount(10));\n+        assertTrue(decode(VerificationModeFactory.atLeast(10)).matchesActualCount(15));\n     }\n     \n     @Test\n     public void shouldKnowIfTooLittleActualInvocations() throws Exception {\n-        assertTrue(decode(times(1)).tooLittleActualInvocations(0));\n-        assertTrue(decode(times(10)).tooLittleActualInvocations(9));\n+        assertTrue(decode(VerificationModeFactory.times(1)).tooLittleActualInvocations(0));\n+        assertTrue(decode(VerificationModeFactory.times(10)).tooLittleActualInvocations(9));\n         \n-        assertFalse(decode(times(0)).tooLittleActualInvocations(0));\n-        assertFalse(decode(times(1)).tooLittleActualInvocations(1));\n-        assertFalse(decode(times(1)).tooLittleActualInvocations(2));\n+        assertFalse(decode(VerificationModeFactory.times(0)).tooLittleActualInvocations(0));\n+        assertFalse(decode(VerificationModeFactory.times(1)).tooLittleActualInvocations(1));\n+        assertFalse(decode(VerificationModeFactory.times(1)).tooLittleActualInvocations(2));\n     }\n     \n     @Test\n     public void shouldAtLeastModeIgnoreTooLittleActualInvocations() throws Exception {\n-        assertFalse(decode(atLeast(10)).tooLittleActualInvocations(5));        \n-        assertFalse(decode(atLeast(10)).tooLittleActualInvocations(15));        \n-        assertFalse(decode(atLeastOnce()).tooLittleActualInvocations(10));        \n+        assertFalse(decode(VerificationModeFactory.atLeast(10)).tooLittleActualInvocations(5));        \n+        assertFalse(decode(VerificationModeFactory.atLeast(10)).tooLittleActualInvocations(15));        \n+        assertFalse(decode(VerificationModeFactory.atLeastOnce()).tooLittleActualInvocations(10));        \n     }\n \n     @Test\n     public void shouldKnowIfTooLittleActualInvocationsInAtLeastMode() throws Exception {\n-        assertTrue(decode(atLeast(3)).tooLittleActualInvocationsInAtLeastMode(2));\n-        assertTrue(decode(atLeast(3)).tooLittleActualInvocationsInAtLeastMode(1));\n-        assertTrue(decode(atLeast(3)).tooLittleActualInvocationsInAtLeastMode(0));\n+        assertTrue(decode(VerificationModeFactory.atLeast(3)).tooLittleActualInvocationsInAtLeastMode(2));\n+        assertTrue(decode(VerificationModeFactory.atLeast(3)).tooLittleActualInvocationsInAtLeastMode(1));\n+        assertTrue(decode(VerificationModeFactory.atLeast(3)).tooLittleActualInvocationsInAtLeastMode(0));\n         \n-        assertFalse(decode(atLeast(1)).tooLittleActualInvocationsInAtLeastMode(1));\n-        assertFalse(decode(atLeast(1)).tooLittleActualInvocationsInAtLeastMode(2));\n+        assertFalse(decode(VerificationModeFactory.atLeast(1)).tooLittleActualInvocationsInAtLeastMode(1));\n+        assertFalse(decode(VerificationModeFactory.atLeast(1)).tooLittleActualInvocationsInAtLeastMode(2));\n     }\n \n     @Test\n     public void shouldTooLittleActualInvocationsInAtLeastModeIgnoreOtherModes() throws Exception {\n-        assertFalse(decode(times(10)).tooLittleActualInvocationsInAtLeastMode(5));        \n-        assertFalse(decode(times(10)).tooLittleActualInvocationsInAtLeastMode(15));        \n+        assertFalse(decode(VerificationModeFactory.times(10)).tooLittleActualInvocationsInAtLeastMode(5));        \n+        assertFalse(decode(VerificationModeFactory.times(10)).tooLittleActualInvocationsInAtLeastMode(15));        \n     }\n     \n     @Test\n     public void shouldKnowIfTooManyActualInvocations() throws Exception {\n-        assertTrue(decode(times(0)).tooManyActualInvocations(1));\n-        assertTrue(decode(times(10)).tooManyActualInvocations(11));\n+        assertTrue(decode(VerificationModeFactory.times(0)).tooManyActualInvocations(1));\n+        assertTrue(decode(VerificationModeFactory.times(10)).tooManyActualInvocations(11));\n         \n-        assertFalse(decode(times(0)).tooManyActualInvocations(0));\n-        assertFalse(decode(times(1)).tooManyActualInvocations(1));\n-        assertFalse(decode(times(2)).tooManyActualInvocations(1));\n+        assertFalse(decode(VerificationModeFactory.times(0)).tooManyActualInvocations(0));\n+        assertFalse(decode(VerificationModeFactory.times(1)).tooManyActualInvocations(1));\n+        assertFalse(decode(VerificationModeFactory.times(2)).tooManyActualInvocations(1));\n     }\n     \n     @Test\n     public void shouldKnowIfWantedCountIsZero() throws Exception {\n-        assertTrue(decode(times(0)).neverWanted());\n+        assertTrue(decode(VerificationModeFactory.times(0)).neverWanted());\n         \n-        assertFalse(decode(times(1)).neverWanted());\n-        assertFalse(decode(times(10)).neverWanted());\n-        assertFalse(decode(atLeastOnce()).neverWanted());\n+        assertFalse(decode(VerificationModeFactory.times(1)).neverWanted());\n+        assertFalse(decode(VerificationModeFactory.times(10)).neverWanted());\n+        assertFalse(decode(VerificationModeFactory.atLeastOnce()).neverWanted());\n     }\n     \n     @Test\n     public void shouldKnowIfNeverWantedButInvoked() throws Exception {\n-        assertFalse(decode(times(1)).neverWantedButInvoked(0));\n-        assertFalse(decode(times(10)).neverWantedButInvoked(20));\n-        assertFalse(decode(times(0)).neverWantedButInvoked(0));\n+        assertFalse(decode(VerificationModeFactory.times(1)).neverWantedButInvoked(0));\n+        assertFalse(decode(VerificationModeFactory.times(10)).neverWantedButInvoked(20));\n+        assertFalse(decode(VerificationModeFactory.times(0)).neverWantedButInvoked(0));\n         \n-        assertFalse(decode(atLeastOnce()).neverWantedButInvoked(0));\n-        assertFalse(decode(atLeastOnce()).neverWantedButInvoked(1));\n+        assertFalse(decode(VerificationModeFactory.atLeastOnce()).neverWantedButInvoked(0));\n+        assertFalse(decode(VerificationModeFactory.atLeastOnce()).neverWantedButInvoked(1));\n         \n-        assertTrue(decode(times(0)).neverWantedButInvoked(1));\n-        assertTrue(decode(times(0)).neverWantedButInvoked(10));\n+        assertTrue(decode(VerificationModeFactory.times(0)).neverWantedButInvoked(1));\n+        assertTrue(decode(VerificationModeFactory.times(0)).neverWantedButInvoked(10));\n     }\n }\n--- a/test/org/mockitousage/AnnotationsTest.java\n+++ b/test/org/mockitousage/AnnotationsTest.java\n \n import org.junit.Before;\n import org.junit.Test;\n+import org.mockito.Mock;\n import org.mockito.MockitoAnnotations;\n-import org.mockito.Mock;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockitoutil.TestBase;\n \n--- a/test/org/mockitousage/SpyingOnRealObjectsTest.java\n+++ b/test/org/mockitousage/SpyingOnRealObjectsTest.java\n  */\n package org.mockitousage;\n \n+import static org.mockito.Matchers.*;\n import static org.mockito.Mockito.*;\n \n import java.util.LinkedList;\n--- a/test/org/mockitousage/UsingVarargsTest.java\n+++ b/test/org/mockitousage/UsingVarargsTest.java\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.Mockito;\n+import org.mockito.exceptions.verification.NoInteractionsWanted;\n import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent;\n-import org.mockito.exceptions.verification.NoInteractionsWanted;\n import org.mockitoutil.TestBase;\n \n public class UsingVarargsTest extends TestBase {\n--- a/test/org/mockitousage/junitrunner/JUnitRunnerTestCase.java\n+++ b/test/org/mockitousage/junitrunner/JUnitRunnerTestCase.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockitousage.junitrunner;\n+import static org.mockito.Mockito.*;\n+\n import java.util.List;\n-import static org.mockito.Mockito.*;\n import java.util.Map;\n \n import org.junit.Test;\n--- a/test/org/mockitousage/packageprotected/MockingPackageProtectedTest.java\n+++ b/test/org/mockitousage/packageprotected/MockingPackageProtectedTest.java\n  */\n package org.mockitousage.packageprotected;\n \n+import static org.mockito.Mockito.*;\n+\n import org.junit.Test;\n import org.mockitoutil.TestBase;\n-\n-import static org.mockito.Mockito.*;\n \n public class MockingPackageProtectedTest extends TestBase {\n \n--- a/test/org/mockitousage/stubbing/ReturningDefaultValuesTest.java\n+++ b/test/org/mockitousage/stubbing/ReturningDefaultValuesTest.java\n import java.util.Map;\n \n import org.junit.Test;\n+import org.mockito.Mock;\n import org.mockito.Mockito;\n-import org.mockito.Mock;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n--- a/test/org/mockitousage/stubbing/StubbingWithCustomAnswerTest.java\n+++ b/test/org/mockitousage/stubbing/StubbingWithCustomAnswerTest.java\n  */\n package org.mockitousage.stubbing;\n \n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.*;\n+\n import org.junit.Test;\n-import static org.mockito.Mockito.*;\n import org.mockito.Mock;\n import org.mockito.invocation.InvocationOnMock;\n import org.mockito.stubbing.Answer;\n--- a/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java\n+++ b/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java\n \n import org.junit.Before;\n import org.junit.Test;\n+import org.mockito.Mock;\n import org.mockito.Mockito;\n-import org.mockito.Mock;\n import org.mockito.exceptions.cause.ActualArgumentsAreDifferent;\n import org.mockito.exceptions.cause.UndesiredInvocation;\n-import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent;\n import org.mockito.exceptions.verification.NeverWantedButInvoked;\n import org.mockito.exceptions.verification.NoInteractionsWanted;\n import org.mockito.exceptions.verification.WantedButNotInvoked;\n+import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n--- a/test/org/mockitousage/verification/VerificationUsingMatchersTest.java\n+++ b/test/org/mockitousage/verification/VerificationUsingMatchersTest.java\n import org.junit.Test;\n import org.mockito.Matchers;\n import org.mockito.Mockito;\n+import org.mockito.exceptions.verification.WantedButNotInvoked;\n import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent;\n-import org.mockito.exceptions.verification.WantedButNotInvoked;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n ", "timestamp": 1223658206, "metainfo": ""}