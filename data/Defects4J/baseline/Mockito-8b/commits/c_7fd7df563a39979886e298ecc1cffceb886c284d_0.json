{"sha": "7fd7df563a39979886e298ecc1cffceb886c284d", "log": "fixed concurrent mockito issue #14 did some refactorings around newly added feature: stubbing with callbacks  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40663", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n import org.mockito.internal.progress.ThreadSafeMockingProgress;\n import org.mockito.internal.progress.VerificationMode;\n import org.mockito.internal.progress.VerificationModeImpl;\n+import org.mockito.internal.stubbing.Answer;\n import org.mockito.internal.stubbing.VoidMethodStubbable;\n import org.mockito.internal.util.MockUtil;\n \n  *   <br/> 8. Finding redundant invocations\n  *   <br/> 9. Shorthand for mocks creation - &#064;Mock annotation\n  *   <br/> 10. (**New**) Stubbing consecutive calls (iterator-style stubbing)\n+ *   <br/> 11. (**New**) Stubbing with callbacks\n  * </b>\n  * \n  * <p>\n  *   //Any consecutive call: prints \"foo\" as well (last stubbing wins). \n  *   System.out.println(mock.someMethod(\"some arg\"));\n  * </pre>\n+ * \n+ * <h3> 11. (**New**) Stubbing with callbacks</h3>\n+ * \n+ * Yet another controversial feature which was not included in Mockito originally. \n+ * We strongly recommend using simple stubbing (toReturn() or toThrow() only).\n+ * Those two should be <b>just enough</b> to test/test-drive any decent (clean & simple) code. \n+ * \n+ * Allows stubbing with generic {@link Answer} interface\n+ * \n+ * <p>\n+ * <pre>\n+ *   stub(mock.someMethod(anyString()))\n+ *     .toAnswer(new Answer() {\n+ *       Object answer(InvocationOnMock invocation) {\n+ *         Object[] args = invocation.getArguments();\n+ *         Object mock = invocation.getMock();\n+ *         return \"called with arguments: \" + args;\n+ *       }\n+ *     });\n+ *    \n+ *   //Following prints \"called with arguments: foo\"\n+ *   System.out.println(mock.someMethod(\"foo\"));\n+ * </pre>\n  */\n public class Mockito extends Matchers {\n     \n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n import org.mockito.internal.progress.OngoingStubbing;\n import org.mockito.internal.progress.VerificationModeImpl;\n import org.mockito.internal.stubbing.Answer;\n-import org.mockito.internal.stubbing.DontThrow;\n import org.mockito.internal.stubbing.Stubber;\n+import org.mockito.internal.stubbing.Returns;\n import org.mockito.internal.stubbing.VoidMethodStubbable;\n+import org.mockito.internal.stubbing.ThrowsException;\n import org.mockito.internal.verification.MissingInvocationInOrderVerifier;\n import org.mockito.internal.verification.MissingInvocationVerifier;\n import org.mockito.internal.verification.NoMoreInvocationsVerifier;\n     }\n \n     public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n-        if (stubber.hasThrowableForVoidMethod()) {\n+        if (stubber.hasAnswerForVoidMethod()) {\n             Invocation invocation = new Invocation(proxy, method, args, mockingProgress.nextSequenceNumber());\n             InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(invocation);\n-            stubber.addVoidMethodForThrowable(invocationMatcher);\n+            stubber.addVoidMethodForStubbing(invocationMatcher);\n             return null;\n         }\n \n \n     private final class VoidMethodStubbableImpl implements VoidMethodStubbable<T> {\n         public VoidMethodStubbable<T> toThrow(Throwable throwable) {\n-            stubber.addThrowableForVoidMethod(throwable);\n+            stubber.addAnswerForVoidMethod(new ThrowsException(throwable));\n             return this;\n         }\n \n         public VoidMethodStubbable<T> toReturn() {\n-            stubber.addThrowableForVoidMethod(DontThrow.DONT_THROW);\n+            stubber.addAnswerForVoidMethod(new Returns());\n             return this;\n         }\n \n-        @SuppressWarnings(\"unchecked\")\n-        public VoidMethodStubbable<T> toAnswer(Answer answer) {\n-            stubber.addThrowableForVoidMethod(new DontThrow(answer));\n+        public VoidMethodStubbable<T> toAnswer(Answer<?> answer) {\n+            stubber.addAnswerForVoidMethod(answer);\n             return this;\n         }\n \n     private class OngoingStubbingImpl implements OngoingStubbing<T> {\n         public OngoingStubbing<T> toReturn(Object value) {\n             verifyingRecorder.eraseLastInvocation();\n-            stubber.addReturnValue(value);\n+            stubber.addAnswer(new Returns(value));\n             return new ConsecutiveStubbing();\n         }\n \n         public OngoingStubbing<T> toThrow(Throwable throwable) {\n             verifyingRecorder.eraseLastInvocation();\n-            stubber.addThrowable(throwable);\n+            stubber.addAnswer(new ThrowsException(throwable));\n             return new ConsecutiveStubbing();\n         }\n \n-        public OngoingStubbing<T> toAnswer(Answer<T> answer) {\n+        public OngoingStubbing<T> toAnswer(Answer<?> answer) {\n             verifyingRecorder.eraseLastInvocation();\n             stubber.addAnswer(answer);\n             return new ConsecutiveStubbing();\n \n     private class ConsecutiveStubbing implements OngoingStubbing<T> {\n         public OngoingStubbing<T> toReturn(Object value) {\n-            stubber.addConsecutiveReturnValue(value);\n+            stubber.addConsecutiveAnswer(new Returns(value));\n             return this;\n         }\n \n         public OngoingStubbing<T> toThrow(Throwable throwable) {\n-            stubber.addConsecutiveThrowable(throwable);\n+            stubber.addConsecutiveAnswer(new ThrowsException(throwable));\n             return this;\n         }\n \n-        public OngoingStubbing<T> toAnswer(Answer<T> answer) {\n+        public OngoingStubbing<T> toAnswer(Answer<?> answer) {\n             stubber.addConsecutiveAnswer(answer);\n             return this;\n         }\n--- a/src/org/mockito/internal/progress/OngoingStubbing.java\n+++ b/src/org/mockito/internal/progress/OngoingStubbing.java\n      *\n      * @return ongoingStubbing object that allows stubbing consecutive calls\n      */\n-    OngoingStubbing<T> toAnswer(Answer<T> answer);\n+    OngoingStubbing<T> toAnswer(Answer<?> answer);\n }\n--- a/src/org/mockito/internal/stubbing/Answer.java\n+++ b/src/org/mockito/internal/stubbing/Answer.java\n  * @param <T> the type to return.\n  */\n public interface Answer<T> {\n+//TODO move to org.mockito.stubbing    \n \n     /**\n      * @param invocation the invocation on the mock.\n      * @throws Throwable the throwable to be thrown\n      */\n     T answer(InvocationOnMock invocation) throws Throwable;\n-}\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/ExceptionsValidator.java\n+package org.mockito.internal.stubbing;\n+\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.invocation.Invocation;\n+\n+public class ExceptionsValidator {\n+\n+    private Reporter reporter = new Reporter();\n+    \n+    public void validate(Throwable throwable, Invocation invocation) {\n+        if (throwable == null) {\n+            reporter.cannotStubWithNullThrowable();\n+        }\n+\n+        if (throwable instanceof RuntimeException || throwable instanceof Error) {\n+            return;\n+        }\n+\n+        if (!invocation.isValidException(throwable)) {\n+            reporter.checkedExceptionInvalid(throwable);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/Returns.java\n+package org.mockito.internal.stubbing;\n+\n+import org.mockito.invocation.InvocationOnMock;\n+\n+public class Returns implements Answer<Object> {\n+\n+    private final Object value;\n+\n+    public Returns(Object value) {\n+        this.value = value;\n+    }\n+\n+    public Returns() {\n+        this(null);\n+    }\n+\n+    @Override\n+    public Object answer(InvocationOnMock invocation) throws Throwable {\n+        return value;\n+    }\n+}\n--- a/src/org/mockito/internal/stubbing/StubbedInvocationMatcher.java\n+++ b/src/org/mockito/internal/stubbing/StubbedInvocationMatcher.java\n  */\n package org.mockito.internal.stubbing;\n \n-import java.util.LinkedList;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n \n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n @SuppressWarnings(\"unchecked\")\n public class StubbedInvocationMatcher extends InvocationMatcher {\n \n-    private final LinkedList<Answer> answers = new LinkedList<Answer>();\n+    private final Queue<Answer> answers = new ConcurrentLinkedQueue<Answer>();\n \n     public StubbedInvocationMatcher(InvocationMatcher invocation, Answer answer) {\n         super(invocation.getInvocation(), invocation.getMatchers());\n     }\n \n     public Object answer(Invocation invocation) throws Throwable {\n-        return answers.size() == 1 ? answers.getFirst().answer(invocation) : answers.removeFirst().answer(invocation);\n+        synchronized(answers) {\n+            return answers.size() == 1 ? answers.peek().answer(invocation) : answers.poll().answer(invocation);\n+        }\n     }\n \n     public void addAnswer(Answer answer) {\n--- a/src/org/mockito/internal/stubbing/Stubber.java\n+++ b/src/org/mockito/internal/stubbing/Stubber.java\n import java.util.LinkedList;\n import java.util.List;\n \n-import org.mockito.exceptions.base.StackTraceFilter;\n import org.mockito.internal.configuration.Configuration;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n \n     private final LinkedList<StubbedInvocationMatcher> stubbed = new LinkedList<StubbedInvocationMatcher>();\n     private final MockingProgress mockingProgress;\n-    private final List<Throwable> throwablesForVoidMethod = new ArrayList<Throwable>();\n-    private final AnswerFactory answerFactory = new AnswerFactory(new StackTraceFilter());\n+    private final List<Answer> answersForVoidMethod = new ArrayList<Answer>();\n \n     private InvocationMatcher invocationForStubbing;\n \n         this.invocationForStubbing = invocation;\n     }\n \n-    public void addReturnValue(Object value) {\n-        mockingProgress.stubbingCompleted();\n-        Answer answer = answerFactory.createReturningAnswer(value);\n-        stubbed.addFirst(new StubbedInvocationMatcher(invocationForStubbing, answer));\n-    }\n-\n-    public void addThrowable(Throwable throwable) {\n-        mockingProgress.stubbingCompleted();\n-        Answer answer = answerFactory.createThrowingAnswer(throwable, invocationForStubbing.getInvocation());\n-        stubbed.addFirst(new StubbedInvocationMatcher(invocationForStubbing, answer));\n-    }\n-\n     public void addAnswer(Answer answer) {\n-        mockingProgress.stubbingCompleted();\n-        stubbed.addFirst(new StubbedInvocationMatcher(invocationForStubbing, answer));\n-    }\n-\n-    public void addConsecutiveReturnValue(Object value) {\n-        stubbed.getFirst().addAnswer(answerFactory.createReturningAnswer(value));\n-    }\n-\n-    public void addConsecutiveThrowable(Throwable throwable) {\n-        stubbed.getFirst()\n-                .addAnswer(answerFactory.createThrowingAnswer(throwable, invocationForStubbing.getInvocation()));\n+        addAnswer(answer, false);\n     }\n \n     public void addConsecutiveAnswer(Answer answer) {\n-        stubbed.getFirst().addAnswer(answer);\n+        addAnswer(answer, true);\n     }\n+    \n+    private void addAnswer(Answer answer, boolean isConsecutive) {\n+        mockingProgress.stubbingCompleted();\n+        if (answer instanceof ThrowsException) {\n+            new ExceptionsValidator().validate(((ThrowsException) answer).getThrowable(), invocationForStubbing.getInvocation());\n+        }\n+        \n+        if (isConsecutive) {\n+            stubbed.getFirst().addAnswer(answer);\n+        } else {\n+            stubbed.addFirst(new StubbedInvocationMatcher(invocationForStubbing, answer));\n+        }\n+    }    \n \n     public Object resultFor(Invocation invocation) throws Throwable {\n         for (StubbedInvocationMatcher s : stubbed) {\n         return Configuration.instance().getReturnValues().valueFor(invocation);\n     }\n \n-    public void addThrowableForVoidMethod(Throwable throwable) {\n-        throwablesForVoidMethod.add(throwable);\n+    public void addAnswerForVoidMethod(Answer answer) {\n+        answersForVoidMethod.add(answer);\n     }\n \n-    public boolean hasThrowableForVoidMethod() {\n-        return !throwablesForVoidMethod.isEmpty();\n+    public boolean hasAnswerForVoidMethod() {\n+        return !answersForVoidMethod.isEmpty();\n     }\n \n-    public void addVoidMethodForThrowable(InvocationMatcher voidMethodInvocationMatcher) {\n+    public void addVoidMethodForStubbing(InvocationMatcher voidMethodInvocationMatcher) {\n         invocationForStubbing = voidMethodInvocationMatcher;\n-        assert hasThrowableForVoidMethod();\n-        for (int i = 0; i < throwablesForVoidMethod.size(); i++) {\n-            Throwable throwable = throwablesForVoidMethod.get(i);\n-            if (i == 0) {\n-                addThrowable(throwable);\n-            } else {\n-                addConsecutiveThrowable(throwable);\n-            }\n+        assert hasAnswerForVoidMethod();\n+        for (int i = 0; i < answersForVoidMethod.size(); i++) {\n+            addAnswer(answersForVoidMethod.get(i), i != 0);\n         }\n-        throwablesForVoidMethod.clear();\n+        answersForVoidMethod.clear();\n     }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/ThrowsException.java\n+package org.mockito.internal.stubbing;\n+\n+import org.mockito.exceptions.base.HasStackTraceThrowableWrapper;\n+import org.mockito.exceptions.base.StackTraceFilter;\n+import org.mockito.invocation.InvocationOnMock;\n+\n+public class ThrowsException implements Answer<Object> {\n+\n+    private final Throwable throwable;\n+    private final StackTraceFilter filter = new StackTraceFilter();\n+\n+    public ThrowsException(Throwable throwable) {\n+        this.throwable = throwable;\n+    }\n+\n+    @Override\n+    public Object answer(InvocationOnMock invocation) throws Throwable {\n+        Throwable filtered = throwable.fillInStackTrace();\n+        filter.filterStackTrace(new HasStackTraceThrowableWrapper(filtered));\n+        throw filtered;\n+    }\n+\n+    public Throwable getThrowable() {\n+        return throwable;\n+    }\n+}\n--- a/src/org/mockito/internal/stubbing/VoidMethodStubbable.java\n+++ b/src/org/mockito/internal/stubbing/VoidMethodStubbable.java\n      *\n      * @return VoidMethodStubbable - typically to choose void method and finish stubbing\n      */\n-    VoidMethodStubbable<T> toAnswer(Answer<T> answer);\n+    VoidMethodStubbable<T> toAnswer(Answer<?> answer);\n \n     /**\n      * Choose void method for stubbing. E.g:\n--- /dev/null\n+++ b/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.concurrentmockito;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.junit.Test;\n+import org.junit.runner.JUnitCore;\n+import org.junit.runner.Result;\n+import org.junit.runner.notification.Failure;\n+import org.mockito.MockitoTest;\n+import org.mockito.TestBase;\n+import org.mockito.exceptions.ReporterTest;\n+import org.mockito.exceptions.base.MockitoAssertionErrorTest;\n+import org.mockito.exceptions.base.MockitoExceptionTest;\n+import org.mockito.exceptions.base.StackTraceRemoverTest;\n+import org.mockito.internal.AllInvocationsFinderTest;\n+import org.mockito.internal.MockHandlerTest;\n+import org.mockito.internal.configuration.DefaultReturnValuesTest;\n+import org.mockito.internal.creation.CglibTest;\n+import org.mockito.internal.creation.MockFactoryTest;\n+import org.mockito.internal.invocation.InvocationMatcherTest;\n+import org.mockito.internal.invocation.InvocationTest;\n+import org.mockito.internal.invocation.InvocationsFinderTest;\n+import org.mockito.internal.matchers.EqualsTest;\n+import org.mockito.internal.progress.MockingProgressImplTest;\n+import org.mockito.internal.progress.VerificationModeImplTest;\n+import org.mockito.internal.stubbing.StubberTest;\n+import org.mockito.internal.util.ListUtilTest;\n+import org.mockito.internal.util.MockUtilTest;\n+import org.mockito.internal.verification.MissingInvocationInOrderVerifierTest;\n+import org.mockito.internal.verification.MissingInvocationVerifierTest;\n+import org.mockito.internal.verification.NoMoreInvocationsVerifierTest;\n+import org.mockito.internal.verification.NumberOfInvocationsInOrderVerifierTest;\n+import org.mockito.internal.verification.NumberOfInvocationsVerifierTest;\n+import org.mockito.internal.verification.VerifyingRecorderTest;\n+import org.mockitousage.ReplacingObjectMethodsTest;\n+import org.mockitousage.UsingVarargsTest;\n+import org.mockitousage.binding.BridgeMethodPuzzleTest;\n+import org.mockitousage.binding.OverloadingPuzzleTest;\n+import org.mockitousage.examples.configure.withbaseclass.ConfiguringDefaultReturnValuesUsingBaseClassTest;\n+import org.mockitousage.examples.configure.withrunner.ConfiguringDefaultReturnValuesUsingRunnerTest;\n+import org.mockitousage.examples.configure.withstaticutility.ConfiguringSelectedMocksToReturnFakesTest;\n+import org.mockitousage.examples.use.ExampleTest;\n+import org.mockitousage.matchers.ComparableMatchersTest;\n+import org.mockitousage.matchers.CustomMatchersTest;\n+import org.mockitousage.matchers.InvalidUseOfMatchersTest;\n+import org.mockitousage.matchers.MatchersTest;\n+import org.mockitousage.matchers.MatchersToStringTest;\n+import org.mockitousage.matchers.VerificationAndStubbingUsingMatchersTest;\n+import org.mockitousage.misuse.InvalidStateDetectionTest;\n+import org.mockitousage.misuse.InvalidUsageTest;\n+import org.mockitousage.stacktrace.PointingStackTraceToActualInvocationChunkTest;\n+import org.mockitousage.stacktrace.PointingStackTraceToActualInvocationTest;\n+import org.mockitousage.stacktrace.StackTraceFilteringTest;\n+import org.mockitousage.stacktrace.StackTrackeChangingTest;\n+import org.mockitousage.stubbing.BasicStubbingTest;\n+import org.mockitousage.stubbing.ReturningDefaultValuesTest;\n+import org.mockitousage.stubbing.StubbingWithThrowablesTest;\n+import org.mockitousage.verification.AtLeastOnceVerificationTest;\n+import org.mockitousage.verification.BasicVerificationInOrderTest;\n+import org.mockitousage.verification.BasicVerificationTest;\n+import org.mockitousage.verification.DescriptiveMessagesOnVerificationInOrderErrorsTest;\n+import org.mockitousage.verification.DescriptiveMessagesWhenTimesXVerificationFailsTest;\n+import org.mockitousage.verification.DescriptiveMessagesWhenVerificationFailsTest;\n+import org.mockitousage.verification.ExactNumberOfTimesVerificationTest;\n+import org.mockitousage.verification.NoMoreInteractionsVerificationTest;\n+import org.mockitousage.verification.RelaxedVerificationInOrderTest;\n+import org.mockitousage.verification.SelectedMocksInOrderVerificationTest;\n+import org.mockitousage.verification.VerificationInOrderMixedWithOrdiraryVerificationTest;\n+import org.mockitousage.verification.VerificationInOrderTest;\n+import org.mockitousage.verification.VerificationOnMultipleMocksUsingMatchersTest;\n+import org.mockitousage.verification.VerificationUsingMatchersTest;\n+\n+public class ThreadsRunAllTestsHalfManualTest extends TestBase {\n+    \n+    private static class AllTestsRunner extends Thread {\n+        \n+        private boolean failed;\n+\n+        public void run() {\n+            Result result = JUnitCore.runClasses(\n+                    ConfiguringDefaultReturnValuesUsingBaseClassTest.class,\n+                    ConfiguringDefaultReturnValuesUsingRunnerTest.class,\n+                    ConfiguringSelectedMocksToReturnFakesTest.class,\n+                    EqualsTest.class,\n+                    ListUtilTest.class,\n+                    MockingProgressImplTest.class,\n+                    VerificationModeImplTest.class,\n+                    MockHandlerTest.class,\n+                    AllInvocationsFinderTest.class,\n+                    DefaultReturnValuesTest.class,\n+                    StubberTest.class,\n+                    NumberOfInvocationsVerifierTest.class,\n+                    VerifyingRecorderTest.class,\n+                    MissingInvocationVerifierTest.class,\n+                    NoMoreInvocationsVerifierTest.class,\n+                    NumberOfInvocationsInOrderVerifierTest.class,\n+                    MissingInvocationInOrderVerifierTest.class,\n+                    MockFactoryTest.class,\n+                    CglibTest.class,\n+                    InvocationMatcherTest.class,\n+                    InvocationsFinderTest.class,\n+                    InvocationTest.class,\n+                    MockitoTest.class,\n+                    MockUtilTest.class,\n+                    ReporterTest.class,\n+                    MockitoAssertionErrorTest.class,\n+                    StackTraceRemoverTest.class,\n+                    MockitoExceptionTest.class,\n+                    StackTraceFilteringTest.class,\n+                    BridgeMethodPuzzleTest.class,\n+                    OverloadingPuzzleTest.class,\n+                    InvalidUsageTest.class,\n+                    UsingVarargsTest.class,\n+                    CustomMatchersTest.class,\n+                    ComparableMatchersTest.class,\n+                    InvalidUseOfMatchersTest.class,\n+                    MatchersTest.class,\n+                    MatchersToStringTest.class,\n+                    VerificationAndStubbingUsingMatchersTest.class,\n+                    BasicStubbingTest.class,\n+                    ReturningDefaultValuesTest.class,\n+                    StubbingWithThrowablesTest.class,\n+                    AtLeastOnceVerificationTest.class,\n+                    BasicVerificationTest.class,\n+                    ExactNumberOfTimesVerificationTest.class,\n+                    VerificationInOrderTest.class,\n+                    NoMoreInteractionsVerificationTest.class,\n+                    SelectedMocksInOrderVerificationTest.class,\n+                    VerificationOnMultipleMocksUsingMatchersTest.class,\n+                    VerificationUsingMatchersTest.class,\n+                    RelaxedVerificationInOrderTest.class,\n+                    DescriptiveMessagesWhenVerificationFailsTest.class,\n+                    DescriptiveMessagesWhenTimesXVerificationFailsTest.class,\n+                    BasicVerificationInOrderTest.class,\n+                    VerificationInOrderMixedWithOrdiraryVerificationTest.class,\n+                    DescriptiveMessagesOnVerificationInOrderErrorsTest.class,\n+                    InvalidStateDetectionTest.class,\n+                    ReplacingObjectMethodsTest.class,\n+                    StackTrackeChangingTest.class,\n+                    ExampleTest.class,\n+                    PointingStackTraceToActualInvocationTest.class,\n+                    PointingStackTraceToActualInvocationChunkTest.class\n+                );\n+                \n+                if (!result.wasSuccessful()) {\n+                    System.err.println(\"Thread[\" + Thread.currentThread().getId() + \"]: error!\");\n+                    List<Failure> failures = result.getFailures();\n+                    System.err.println(failures.size());\n+                    for (Failure failure : failures) {\n+                        System.err.println(failure.getTrace());\n+                        failed = true;\n+                    }\n+                }\n+        }\n+\n+        public boolean isFailed() {\n+            return failed;\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldRunInMultipleThreads() throws Exception {\n+        //this test ALWAYS fails if there is a single failing unit\n+        assertFalse(\"Run in multiple thread failed\", runInMultipleThreads(4));\n+    }\n+    \n+    public static boolean runInMultipleThreads(int numberOfThreads) throws Exception {\n+        List<AllTestsRunner> threads = new LinkedList<AllTestsRunner>();\n+        for (int i = 1; i <= numberOfThreads; i++) {\n+            threads.add(new AllTestsRunner());\n+        }\n+\n+        for (Thread t : threads) {\n+            t.start();\n+        }\n+\n+        boolean failed = false;\n+        for (AllTestsRunner t : threads) {\n+            t.join();\n+            failed = failed ? true : t.isFailed();\n+        }\n+        \n+        return failed;\n+    }\n+    \n+    public static void main(String[] args) throws Exception {\n+        int numberOfThreads = 20; \n+        long before = System.currentTimeMillis();\n+        runInMultipleThreads(numberOfThreads);\n+        long after = System.currentTimeMillis();\n+        long executionTime = (after-before)/1000;\n+        System.out.println(\"Finished tests in \" + numberOfThreads + \" threads in \" + executionTime + \" seconds.\");\n+    }\n+}\n--- a/test/org/concurrentmockito/ThreadsShareAMockTest.java\n+++ b/test/org/concurrentmockito/ThreadsShareAMockTest.java\n import org.mockito.TestBase;\n import org.mockitousage.IMethods;\n \n+//this test exposes the problem at least once in 10 runs\n public class ThreadsShareAMockTest extends TestBase {\n \n     private IMethods mock;\n--- /dev/null\n+++ b/test/org/concurrentmockito/ThreadsShareGenerouslyStubbedMockTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.concurrentmockito;\n+\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.Test;\n+import org.mockito.TestBase;\n+import org.mockitousage.IMethods;\n+\n+//this test always passes but please keep looking sys err\n+//this test should be run multiple times, manually\n+public class ThreadsShareGenerouslyStubbedMockTest extends TestBase {\n+\n+    private IMethods mock;\n+\n+    @Test\n+    public void testShouldAllowVerifyingInThreads() throws Exception {\n+        for(int i = 0; i < 50; i++) {\n+            performTest();\n+        }\n+    }\n+\n+    private void performTest() throws InterruptedException {\n+        mock = mock(IMethods.class);\n+        \n+        stub(mock.simpleMethod(\"foo\"))\n+            .toReturn(\"foo\")\n+            .toReturn(\"bar\")\n+            .toReturn(\"baz\")\n+            .toReturn(\"foo\")\n+            .toReturn(\"bar\")\n+            .toReturn(\"baz\");\n+        \n+        final Thread[] listeners = new Thread[100];\n+        for (int i = 0; i < listeners.length; i++) {\n+            listeners[i] = new Thread() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        mock.simpleMethod(\"foo\");\n+                        mock.simpleMethod(\"foo\");\n+                        mock.simpleMethod(\"foo\");\n+                        mock.simpleMethod(\"foo\");\n+                        mock.simpleMethod(\"foo\");\n+                        mock.simpleMethod(\"foo\");\n+                    } catch (Exception e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                }\n+            };\n+            listeners[i].start();\n+        }\n+        for (int i = 0; i < listeners.length; i++) {\n+            listeners[i].join();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/concurrentmockito/ThreadsStubSharedMockTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.concurrentmockito;\n+\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.mockito.TestBase;\n+import org.mockitousage.IMethods;\n+\n+public class ThreadsStubSharedMockTest extends TestBase {\n+\n+    private IMethods mock;\n+\n+    @Ignore(\"stubbing from multiple threads is not supported\")\n+    @Test\n+    public void testShouldStubFineConcurrently() throws Exception {\n+        for(int i = 0; i < 100; i++) {\n+            performTest();\n+        }\n+    }\n+\n+    private void performTest() throws InterruptedException {\n+        mock = mock(IMethods.class);\n+        final Thread[] listeners = new Thread[3];\n+        for (int i = 0; i < listeners.length; i++) {\n+            listeners[i] = new Thread() {\n+                @Override\n+                public void run() {\n+                    stub(mock.simpleMethod(getId()))\n+                        .toReturn(getId() + \"\")\n+                        .toReturn(\"foo\")\n+                        .toReturn(\"bar\");\n+                        \n+                    stubVoid(mock)\n+                        .toThrow(new RuntimeException(getId() + \"\"))\n+                        .toReturn()\n+                        .toThrow(new RuntimeException())\n+                        .on().differentMethod();\n+                }\n+            };\n+            listeners[i].start();\n+        }\n+        for (int i = 0; i < listeners.length; i++) {\n+            listeners[i].join();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/stubbing/ExceptionsValidatorTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.stubbing;\n+\n+import java.io.IOException;\n+import java.nio.charset.CharacterCodingException;\n+\n+import org.junit.Test;\n+import org.mockito.TestBase;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+\n+public class ExceptionsValidatorTest extends TestBase {\n+\n+    private ExceptionsValidator validator = new ExceptionsValidator();\n+    private Invocation invocation = new InvocationBuilder().method(\"canThrowException\").toInvocation();\n+\n+    @Test\n+    public void shouldValidateNullThrowable() throws Throwable {\n+        try {\n+            validator.validate(null, null);\n+            fail();\n+        } catch (MockitoException e) {\n+        }\n+    }\n+\n+    @Test\n+    public void shouldPassProperCheckedException() throws Throwable {\n+        validator.validate(new CharacterCodingException(), invocation);\n+    }\n+\n+    @Test(expected = MockitoException.class)\n+    public void shouldFailInvalidCheckedException() throws Throwable {\n+        validator.validate(new IOException(), invocation);\n+    }\n+    \n+    @Test\n+    public void shouldPassRuntimeExceptions() throws Throwable {\n+        validator.validate(new Error(), invocation);\n+        validator.validate(new RuntimeException(), invocation);\n+    }\n+}\n--- a/test/org/mockito/internal/stubbing/StubberTest.java\n+++ b/test/org/mockito/internal/stubbing/StubberTest.java\n     public void shouldFinishStubbingWhenWrongThrowableIsSet() throws Exception {\n         state.stubbingStarted();\n         try {\n-            stubber.addThrowable(new Exception());\n+            stubber.addAnswer(new ThrowsException(new Exception()));\n             fail();\n         } catch (MockitoException e) {\n             state.validateState();\n     @Test\n     public void shouldFinishStubbingOnAddingReturnValue() throws Exception {\n         state.stubbingStarted();\n-        stubber.addReturnValue(\"test\");\n+        stubber.addAnswer(new Returns(\"test\"));\n         state.validateState();\n     }\n     \n     @Test\n     public void shouldGetResultsForMethods() throws Throwable {\n         stubber.setInvocationForPotentialStubbing(new InvocationMatcher(simpleMethod));\n-        stubber.addReturnValue(\"simpleMethod\");\n+        stubber.addAnswer(new Returns(\"simpleMethod\"));\n         \n         Invocation differentMethod = new InvocationBuilder().differentMethod().toInvocation();\n         stubber.setInvocationForPotentialStubbing(new InvocationMatcher(differentMethod));\n-        stubber.addThrowable(new MyException());\n+        stubber.addAnswer(new ThrowsException(new MyException()));\n         \n         assertEquals(\"simpleMethod\", stubber.resultFor(simpleMethod));\n         \n     @Test\n     public void shouldGetEmptyResultIfMethodsDontMatch() throws Throwable {\n         stubber.setInvocationForPotentialStubbing(new InvocationMatcher(simpleMethod));\n-        stubber.addReturnValue(\"simpleMethod\");\n+        stubber.addAnswer(new Returns(\"simpleMethod\"));\n         \n         Invocation differentMethod = new InvocationBuilder().differentMethod().toInvocation();\n         \n     \n     @Test\n     public void shouldAddThrowableForVoidMethod() throws Throwable {\n-        stubber.addThrowableForVoidMethod(new MyException());\n-        stubber.addVoidMethodForThrowable(new InvocationMatcher(simpleMethod));\n+        stubber.addAnswerForVoidMethod(new ThrowsException(new MyException()));\n+        stubber.addVoidMethodForStubbing(new InvocationMatcher(simpleMethod));\n         \n         try {\n             stubber.resultFor(simpleMethod);\n     \n     @Test\n     public void shouldValidateThrowableForVoidMethod() throws Throwable {\n-        stubber.addThrowableForVoidMethod(new Exception());\n+        stubber.addAnswerForVoidMethod(new ThrowsException(new Exception()));\n         \n         try {\n-            stubber.addVoidMethodForThrowable(new InvocationMatcher(simpleMethod));\n+            stubber.addVoidMethodForStubbing(new InvocationMatcher(simpleMethod));\n             fail();\n         } catch (MockitoException e) {}\n     }\n     @Test\n     public void shouldValidateThrowable() throws Throwable {\n         try {\n-            stubber.addThrowable(null);\n+            stubber.addAnswer(new ThrowsException(null));\n             fail();\n         } catch (MockitoException e) {}\n     }\n--- /dev/null\n+++ b/test/org/mockitousage/MocksCreationTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage;\n+\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockito.TestBase;\n+\n+public class MocksCreationTest extends TestBase {\n+\n+    private class HasPrivateConstructor {};\n+    \n+    @Test\n+    public void shouldCreateMockWhenConstructorIsPrivate() {\n+        assertNotNull(Mockito.mock(HasPrivateConstructor.class));\n+    }\n+}", "timestamp": 1214781015, "metainfo": ""}