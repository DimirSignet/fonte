{"sha": "4fa2c69284504f4aeca6aaf1db9b94857a62e23d", "log": "raise Mockito exceptions instead of java standard classes (still it extends ObjectStreamException)", "commit": "\n--- a/src/org/mockito/exceptions/base/MockitoException.java\n+++ b/src/org/mockito/exceptions/base/MockitoException.java\n import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;\n \n \n+/**\n+ * Raised by mockito to emit an error either due to Mockito, or due to the User.\n+ *\n+ * <p>\n+ *     The stack trace is filtered from mockito calls if you are using {@link #getStackTrace()}.\n+ *     For debugging purpose though you can still access the full stacktrace using {@link #getUnfilteredStackTrace()}.\n+ *     However note that other calls related to the stackTrace will refer to the filter stacktrace.\n+ * </p>\n+ *\n+ */\n public class MockitoException extends RuntimeException {\n \n     private static final long serialVersionUID = 1L;\n \n     private StackTraceElement[] unfilteredStackTrace;\n-    \n+\n+    // TODO lazy filtered stacktrace initialization\n     public MockitoException(String message, Throwable t) {\n         super(message, t);\n         filterStackTrace();\n--- /dev/null\n+++ b/src/org/mockito/exceptions/base/MockitoSerializationIssue.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.exceptions.base;\n+\n+import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;\n+\n+import java.io.ObjectStreamException;\n+\n+/**\n+ * Raised by mockito to emit an error either due to Mockito, or due to the User.\n+ *\n+ * <p>\n+ *     The stack trace is filtered from mockito calls if you are using {@link #getStackTrace()}.\n+ *     For debugging purpose though you can still access the full stacktrace using {@link #getUnfilteredStackTrace()}.\n+ *     However note that other calls related to the stackTrace will refer to the filter stacktrace.\n+ * </p>\n+ *\n+ * @since 1.9.6\n+ */\n+public class MockitoSerializationIssue extends ObjectStreamException {\n+\n+    private StackTraceElement[] unfilteredStackTrace;\n+\n+    public MockitoSerializationIssue(String message, Exception cause) {\n+        super(message);\n+        initCause(cause);\n+        filterStackTrace();\n+    }\n+\n+    @Override\n+    public StackTraceElement[] getStackTrace() {\n+        filterStackTrace();\n+        return super.getStackTrace();\n+    }\n+\n+    private void filterStackTrace() {\n+        unfilteredStackTrace = super.getStackTrace();\n+\n+        ConditionalStackTraceFilter filter = new ConditionalStackTraceFilter();\n+        filter.filter(this);\n+    }\n+\n+    public StackTraceElement[] getUnfilteredStackTrace() {\n+        return unfilteredStackTrace;\n+    }\n+}\n--- a/src/org/mockito/internal/creation/AcrossJVMSerializationFeature.java\n+++ b/src/org/mockito/internal/creation/AcrossJVMSerializationFeature.java\n  * Copyright (c) 2007 Mockito contributors\n  * This program is made available under the terms of the MIT License.\n  */\n+\n package org.mockito.internal.creation;\n \n import org.mockito.Incubating;\n+import org.mockito.exceptions.base.MockitoSerializationIssue;\n import org.mockito.internal.creation.jmock.ClassImposterizer;\n import org.mockito.internal.util.MockUtil;\n-import org.mockito.internal.util.StringJoiner;\n import org.mockito.internal.util.reflection.FieldSetter;\n import org.mockito.mock.MockCreationSettings;\n-\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.InvalidObjectException;\n-import java.io.NotSerializableException;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutputStream;\n-import java.io.ObjectStreamClass;\n-import java.io.ObjectStreamException;\n-import java.io.Serializable;\n+import org.mockito.mock.MockName;\n+\n+import java.io.*;\n import java.lang.reflect.Field;\n import java.lang.reflect.Method;\n import java.util.Set;\n import java.util.concurrent.locks.Lock;\n import java.util.concurrent.locks.ReentrantLock;\n+\n+import static org.mockito.internal.util.StringJoiner.join;\n \n /**\n  * This is responsible for serializing a mock, it is enabled if the mock is implementing\n  *\n  * <p><strong>Only one instance per mock! See {@link MethodInterceptorFilter}</strong></p>\n  *\n- * TODO Use proper MockitoException\n+ * TODO use a proper way to add the interface\n  * TODO offer a way to disable completely this behavior, or maybe enable this behavior only with a specific setting\n  * TODO check the class is mockable in the deserialization side\n  *\n public class AcrossJVMSerializationFeature implements Serializable {\n     private static final long serialVersionUID = 7411152578314420778L;\n     private static final String MOCKITO_PROXY_MARKER = \"MockitoProxyMarker\";\n+    private final MockUtil mockUtil = new MockUtil();\n     private boolean instanceLocalCurrentlySerializingFlag = false;\n     private Lock mutex = new ReentrantLock();\n \n \n             return new AcrossJVMMockSerializationProxy(mockitoMock);\n         } catch (IOException ioe) {\n-            // TODO use our own mockito mock serialization exception\n-            throw new NotSerializableException(mockitoMock.getClass().getCanonicalName());\n+            MockName mockName = mockUtil.getMockName(mockitoMock);\n+            String mockedType = mockUtil.getMockSettings(mockitoMock).getTypeToMock().getCanonicalName();\n+            throw new MockitoSerializationIssue(join(\n+                    \"The mock '\" + mockName + \"' of type '\" + mockedType + \"'\",\n+                    \"The Java Standard Serialization reported an '\" + ioe.getClass().getSimpleName() + \"' saying : \" + ioe.getMessage()\n+            ), ioe);\n         } finally {\n             // unmark\n             mockReplacementCompleted();\n         }\n     }\n \n+\n     private void mockReplacementCompleted() {\n         instanceLocalCurrentlySerializingFlag = false;\n     }\n \n+\n     private void mockReplacementStarted() {\n         instanceLocalCurrentlySerializingFlag = true;\n     }\n \n+\n     private boolean mockIsCurrentlyBeingReplaced() {\n         return instanceLocalCurrentlySerializingFlag;\n     }\n+\n \n     /**\n      * Enable serialization serialization that will work across classloaders / and JVM.\n      * the custom {@link MockitoMockObjectInputStream} that will be in charge of creating the mock class.</p>\n      */\n     public static class AcrossJVMMockSerializationProxy implements Serializable {\n+\n+\n         private static final long serialVersionUID = -7600267929109286514L;\n         private byte[] serializedMock;\n         private Class typeToMock;\n         private Set<Class> extraInterfaces;\n-\n         /**\n          * Creates the wrapper that be used in the serialization stream.\n          *\n             this.extraInterfaces = mockSettings.getExtraInterfaces();\n         }\n \n-\n         /**\n          * Resolves the proxy to a new deserialized instance of the Mockito mock.\n          *\n \n                 return deserializedMock;\n             } catch (IOException ioe) {\n-                // TODO use our own mockito mock serialization exception\n-                throw new InvalidObjectException(\"Mockito mock cannot be deserialized due to : \" + ioe.toString() + \"\\n\" + StringJoiner.join(ioe.getStackTrace()));\n+                throw new MockitoSerializationIssue(join(\n+                        \"Mockito mock cannot be deserialized to a mock of '\" + typeToMock.getCanonicalName() + \"'.\",\n+                        \"If you are unsure what is the reason of this exception, feel free to contact us on the mailing list.\"\n+                ), ioe);\n             } catch (ClassNotFoundException cce) {\n-                // TODO use our own mockito mock serialization exception\n-                throw new InvalidObjectException(\"Mockito Mock class cannot be found : \" + cce.toString());\n+                throw new MockitoSerializationIssue(join(\n+                        \"A class couldn't be found while deserializing a Mockito mock, you should check your classpath.\",\n+                        \"If you are still unsure what is the reason of this exception, feel free to contact us on the mailing list.\"\n+                ), cce);\n             }\n         }\n     }\n          * @param proxyClass The proxy class whose name will be applied.\n          * @throws InvalidObjectException\n          */\n-        private void hackClassNameToMatchNewlyCreatedClass(ObjectStreamClass descInstance, Class<?> proxyClass) throws InvalidObjectException {\n+        private void hackClassNameToMatchNewlyCreatedClass(ObjectStreamClass descInstance, Class<?> proxyClass) throws ObjectStreamException {\n             try {\n               Field classNameField = descInstance.getClass().getDeclaredField(\"name\");\n               new FieldSetter(descInstance, classNameField).set(proxyClass.getCanonicalName());\n             } catch (NoSuchFieldException e) {\n                 // TODO use our own mockito mock serialization exception\n-                throw new InvalidObjectException(\"Wow, the class 'ObjectStreamClass' in the JDK don't have the field 'name', \" +\n-                    \"this is definitely a bug in our code, please report used JDK, eventually with a code sample.\\n\" + e.toString());\n+                throw new MockitoSerializationIssue(join(\n+                        \"Wow, the class 'ObjectStreamClass' in the JDK don't have the field 'name',\",\n+                        \"this is definitely a bug in our code as it means the JDK team changed a few internal things.\",\n+                        \"\",\n+                        \"Please report an issue with the JDK used, a code sample and a link to download the JDK would be welcome.\"\n+                ), e);\n             }\n         }\n \n         }\n     }\n \n+\n     /**\n      * Simple interface that hold a correct <code>writeReplace</code> signature that can be seen by an\n      * <code>ObjectOutputStream</code>.\n--- a/test/org/mockitousage/serialization/AcrossClassLoaderSerializationTest.java\n+++ b/test/org/mockitousage/serialization/AcrossClassLoaderSerializationTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n package org.mockitousage.serialization;\n \n import org.junit.Before;\n--- a/test/org/mockitousage/serialization/DeserializeMockFromFile.java\n+++ b/test/org/mockitousage/serialization/DeserializeMockFromFile.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n package org.mockitousage.serialization;\n \n import org.mockito.Mockito;\n--- a/test/org/mockitousage/serialization/ParallelSerializationTest.java\n+++ b/test/org/mockitousage/serialization/ParallelSerializationTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n package org.mockitousage.serialization;\n \n import org.junit.Test;\n--- a/test/org/mockitousage/serialization/SerializeMockToFile.java\n+++ b/test/org/mockitousage/serialization/SerializeMockToFile.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n package org.mockitousage.serialization;\n \n import org.mockito.Mockito;", "timestamp": 1357320327, "metainfo": ""}