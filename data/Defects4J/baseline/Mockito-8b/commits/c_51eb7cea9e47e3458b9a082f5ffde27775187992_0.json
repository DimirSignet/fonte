{"sha": "51eb7cea9e47e3458b9a082f5ffde27775187992", "log": "Renaming LocationTest and InvocationTest to match their tested concrete types  --HG-- rename : test/org/mockito/internal/invocation/InvocationTest.java => test/org/mockito/internal/invocation/InvocationImplTest.java rename : test/org/mockitousage/internal/debugging/LocationTest.java => test/org/mockitousage/internal/debugging/LocationImplTest.java", "commit": "\n--- a/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n+++ b/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n import org.mockito.internal.InvalidStateDetectionTest;\n import org.mockito.internal.MockHandlerTest;\n import org.mockito.internal.creation.jmock.ClassImposterizerTest;\n+import org.mockito.internal.invocation.InvocationImplTest;\n import org.mockito.internal.invocation.InvocationMatcherTest;\n-import org.mockito.internal.invocation.InvocationTest;\n import org.mockito.internal.invocation.InvocationsFinderTest;\n import org.mockito.internal.matchers.ComparableMatchersTest;\n import org.mockito.internal.matchers.EqualsTest;\n                     ClassImposterizerTest.class,\n                     InvocationMatcherTest.class,\n                     InvocationsFinderTest.class,\n-                    InvocationTest.class,\n+                    InvocationImplTest.class,\n                     MockitoTest.class,\n                     MockUtilTest.class,\n                     ReporterTest.class,\n--- /dev/null\n+++ b/test/org/mockito/internal/invocation/InvocationImplTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockito.internal.invocation;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.invocation.realmethod.RealMethod;\n+import org.mockito.internal.matchers.ArrayEquals;\n+import org.mockito.internal.matchers.Equals;\n+import org.mockito.invocation.Invocation;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+@SuppressWarnings({\"unchecked\"})\n+public class InvocationImplTest extends TestBase {\n+\n+    private Invocation invocation;\n+\n+    @Before\n+    public void setup() throws Exception {\n+        invocation = new InvocationBuilder().args(\" \").mock(\"mock\").toInvocation();\n+    }\n+\n+    @Test\n+    public void shouldKnowIfIsEqualTo() {\n+        Invocation equal =                  new InvocationBuilder().args(\" \").mock(\"mock\").toInvocation();\n+        Invocation nonEqual =               new InvocationBuilder().args(\"X\").mock(\"mock\").toInvocation();\n+        Invocation withNewStringInstance =  new InvocationBuilder().args(new String(\" \")).mock(\"mock\").toInvocation();\n+\n+        assertFalse(invocation.equals(null));\n+        assertFalse(invocation.equals(\"\"));\n+        assertTrue(invocation.equals(equal));\n+        assertFalse(invocation.equals(nonEqual));\n+        assertTrue(invocation.equals(withNewStringInstance));\n+    }\n+    \n+    @Test\n+    public void shouldEqualToNotConsiderSequenceNumber() {\n+        Invocation equal = new InvocationBuilder().args(\" \").mock(\"mock\").seq(2).toInvocation();\n+        \n+        assertTrue(invocation.equals(equal));\n+        assertTrue(invocation.getSequenceNumber() != equal.getSequenceNumber());\n+    }\n+    \n+    @Test\n+    public void shouldBeACitizenOfHashes() {\n+        Map map = new HashMap();\n+        map.put(invocation, \"one\");\n+        assertEquals(\"one\", map.get(invocation));\n+    }\n+    \n+    @Test\n+    public void shouldPrintMethodName() {\n+        invocation = new InvocationBuilder().toInvocation();\n+        assertEquals(\"iMethods.simpleMethod();\", invocation.toString());\n+    }\n+    \n+    @Test\n+    public void shouldPrintMethodArgs() {\n+        invocation = new InvocationBuilder().args(\"foo\").toInvocation();\n+        assertThat(invocation.toString(), endsWith(\"simpleMethod(\\\"foo\\\");\"));\n+    }\n+    \n+    @Test\n+    public void shouldPrintMethodIntegerArgAndString() {\n+        invocation = new InvocationBuilder().args(\"foo\", 1).toInvocation();\n+        assertThat(invocation.toString(), endsWith(\"simpleMethod(\\\"foo\\\", 1);\"));\n+    }\n+    \n+    @Test\n+    public void shouldPrintNull() {\n+        invocation = new InvocationBuilder().args((String) null).toInvocation();\n+        assertThat(invocation.toString(), endsWith(\"simpleMethod(null);\"));\n+    }\n+    \n+    @Test\n+    public void shouldPrintArray() {\n+        invocation = new InvocationBuilder().method(\"oneArray\").args(new int[] { 1, 2, 3 }).toInvocation();\n+        assertThat(invocation.toString(), endsWith(\"oneArray([1, 2, 3]);\"));\n+    }\n+    \n+    @Test\n+    public void shouldPrintNullIfArrayIsNull() throws Exception {\n+        Method m = IMethods.class.getMethod(\"oneArray\", Object[].class);\n+        invocation = new InvocationBuilder().method(m).args((Object) null).toInvocation();\n+        assertThat(invocation.toString(), endsWith(\"oneArray(null);\"));\n+    }\n+    \n+    @Test\n+    public void shouldPrintArgumentsInMultilinesWhenGetsTooBig() {\n+        invocation = new InvocationBuilder().args(\"veeeeery long string that makes it ugly in one line\", 1).toInvocation();\n+        assertThat(invocation.toString(), endsWith(\n+                \"simpleMethod(\" +\n+                        \"\\n\" +\n+                        \"    \\\"veeeeery long string that makes it ugly in one line\\\",\" +\n+                        \"\\n\" +\n+                        \"    1\" +\n+                        \"\\n\" +\n+                        \");\"));\n+    }\n+    \n+    @Test\n+    public void shouldTransformArgumentsToMatchers() throws Exception {\n+        Invocation i = new InvocationBuilder().args(\"foo\", new String[]{\"bar\"}).toInvocation();\n+        List matchers = ArgumentsProcessor.argumentsToMatchers(i.getArguments());\n+\n+        assertEquals(2, matchers.size());\n+        assertEquals(Equals.class, matchers.get(0).getClass());\n+        assertEquals(ArrayEquals.class, matchers.get(1).getClass());\n+    }\n+    \n+    class Foo {\n+        public String bark() {\n+            return \"woof\";\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldBeAbleToCallRealMethod() throws Throwable {\n+        //when\n+        Invocation invocation = invocationOf(Foo.class, \"bark\", new RealMethod() {\n+            public Object invoke(Object target, Object[] arguments) throws Throwable {\n+                return new Foo().bark();\n+            }});\n+        //then\n+        assertEquals(\"woof\", invocation.callRealMethod());\n+    }\n+    \n+    @Test\n+    public void shouldScreamWhenCallingRealMethodOnInterface() throws Throwable {\n+        //given\n+        Invocation invocationOnInterface = new InvocationBuilder().toInvocation();\n+\n+        try {\n+            //when\n+            invocationOnInterface.callRealMethod();\n+            //then\n+            fail();\n+        } catch(MockitoException e) {}\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/internal/debugging/LocationImplTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.internal.debugging;\n+\n+import org.junit.Test;\n+import org.mockito.internal.debugging.LocationImpl;\n+import org.mockito.internal.exceptions.base.StackTraceFilter;\n+import org.mockitoutil.TestBase;\n+\n+@SuppressWarnings(\"serial\")\n+public class LocationImplTest extends TestBase {\n+\n+    @Test\n+    public void shouldLocationNotContainGetStackTraceMethod() {\n+        assertContains(\"shouldLocationNotContainGetStackTraceMethod\", new LocationImpl().toString());\n+    }\n+\n+    @Test\n+    public void shouldBeSafeInCaseForSomeReasonFilteredStackTraceIsEmpty() {\n+        //given\n+        StackTraceFilter filterReturningEmptyArray = new StackTraceFilter() {\n+            @Override\n+            public StackTraceElement[] filter(StackTraceElement[] target, boolean keepTop) {\n+                return new StackTraceElement[0];\n+            }\n+        };\n+\n+        //when\n+        String loc = new LocationImpl(filterReturningEmptyArray).toString();\n+\n+        //then\n+        assertEquals(\"-> at <<unknown line>>\", loc);\n+    }\n+}", "timestamp": 1333555385, "metainfo": ""}