{"sha": "70d40c3c2e2e33ca7009d95359ca9cdb4f5d0a69", "log": "almost got rid of easymock from tests  --HG-- rename : test/org/easymock/classextension/CglibTest.java => test/org/mockito/internal/CglibTest.java rename : test/org/easymock/classextension/internal/ClassProxyFactoryTest.java => test/org/mockito/internal/ClassProxyFactoryTest.java rename : test/org/easymock/internal/ExpectedInvocationTest.java => test/org/mockito/internal/ExpectedInvocationTest.java rename : test/org/easymock/internal/ToTypeMappingsTest.java => test/org/mockito/internal/ToTypeMappingsTest.java rename : test/org/easymock/internal/matchers/EqualsTest.java => test/org/mockito/internal/matchers/EqualsTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%4022", "commit": "\n--- /dev/null\n+++ b/test/org/mockito/internal/CglibTest.java\n+/*\n+ * Copyright (c) 2003-2006 OFFIS, Henri Tremblay. \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+\n+import junit.framework.TestCase;\n+import net.sf.cglib.proxy.Callback;\n+import net.sf.cglib.proxy.Enhancer;\n+import net.sf.cglib.proxy.Factory;\n+import net.sf.cglib.proxy.MethodInterceptor;\n+import net.sf.cglib.proxy.MethodProxy;\n+\n+import org.easymock.ObjenesisClassInstantiator;\n+import org.junit.Test;\n+\n+/**\n+ * This test case is used to make sure that the way cglib is used is providing the expected behavior\n+ */\n+public class CglibTest extends TestCase {\n+\n+    /**\n+     * Check that an interceptor is used by only one instance of a class\n+     * @throws Exception\n+     */\n+    @Test public void test() throws Exception {\n+\n+        Factory f1 = createMock();\n+        Factory f2 = createMock();\n+        \n+        assertNotSame(f1.getCallback(0), f2.getCallback(0));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Factory createMock() throws Exception {\n+        MethodInterceptor interceptor = new MethodInterceptor() {\n+            public Object intercept(Object obj, Method method, Object[] args,\n+                    MethodProxy proxy) throws Throwable {\n+                return proxy.invokeSuper(obj, args);\n+            }\n+        };\n+\n+        Enhancer enhancer = new Enhancer();\n+        enhancer.setSuperclass(ArrayList.class);\n+        enhancer.setCallbackType(MethodInterceptor.class);\n+        \n+        Class mockClass = enhancer.createClass();\n+        \n+        Enhancer.registerCallbacks(mockClass, new Callback[] { interceptor });\n+                \n+        Factory f = (Factory) ObjenesisClassInstantiator.newInstance(mockClass);\n+        \n+        f.getCallback(0);\n+        \n+        return f;\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/ClassProxyFactoryTest.java\n+package org.mockito.internal;\n+\n+import static org.junit.Assert.*;\n+import static org.hamcrest.CoreMatchers.*;\n+\n+import java.lang.reflect.Method;\n+\n+import org.easymock.internal.ClassProxyFactory;\n+import org.junit.*;\n+import org.mockito.MockAwareInvocationHandler;\n+\n+public class ClassProxyFactoryTest {\n+\n+\t@Test public void shouldNotRewriteObjectMethodsForInterface() throws Exception {\n+\t\tClassProxyFactory<SomeInterface> factory = new ClassProxyFactory<SomeInterface>();\n+\t\tSomeInterface proxy = null;\n+\t\ttry {\n+\t\t\tproxy = factory.createProxy(SomeInterface.class, new MockAwareInvocationHandler() {\n+                public void setMock(Object mock) {}\n+                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+                    return null;\n+                }});\n+\t\t} catch (RuntimeException e) {\n+\t\t\tfail(\"should not lookup Object methods since they are not available on interfaces\");\n+\t\t}\n+\t\t\n+\t\tassertThat(proxy, notNullValue());\n+\t}\n+\t\n+\tprivate interface SomeInterface {};\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/ExpectedInvocationTest.java\n+package org.mockito.internal;\n+\n+import static org.hamcrest.CoreMatchers.equalTo;\n+import static org.junit.Assert.*;\n+\n+import java.lang.reflect.Method;\n+\n+import org.easymock.internal.*;\n+import org.junit.Test;\n+\n+public class ExpectedInvocationTest {\n+\n+    @Test\n+    public void shouldImplementHashcodeToBeHashMapsCitizen() throws Exception {\n+        Object[] args = new Object[] { \"\" };\n+        Method m = Object.class.getMethod(\"equals\", new Class[] { Object.class });\n+        Invocation invocation = new Invocation(null, m, args);\n+        assertThat(new ExpectedInvocation(invocation, null).hashCode(), equalTo(1));\n+    }\n+    \n+    @Test\n+    public void shouldNotEqualIfNumberOfArgumentsDiffer() throws SecurityException, NoSuchMethodException {\n+        Object mock = new Object();\n+\n+        Method dummyMethod = Object.class.getMethod(\"equals\",\n+                new Class[] { Object.class });\n+\n+        ExpectedInvocation invocationWithOneArg = new ExpectedInvocation(\n+                new Invocation(mock, dummyMethod, new Object[] { \"\" }),\n+                null);\n+        ExpectedInvocation invocationWithTwoArgs = new ExpectedInvocation(\n+                new Invocation(mock, dummyMethod, new Object[] { \"\", \"\" }),\n+                null);\n+\n+        assertFalse(invocationWithOneArg.equals(null));\n+        assertFalse(invocationWithOneArg.equals(invocationWithTwoArgs));\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/ToTypeMappingsTest.java\n+package org.mockito.internal;\n+\n+import static org.junit.Assert.*;\n+\n+import java.util.*;\n+\n+import org.easymock.internal.ToTypeMappings;\n+import org.junit.Test;\n+\n+public class ToTypeMappingsTest {\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    @Test public void shouldReturnEmptyCollectionsOrNullForNonCollections() {\n+        assertTrue(((Collection)ToTypeMappings.emptyReturnValueFor(Collection.class)).isEmpty());\n+        \n+        assertTrue(((Set)ToTypeMappings.emptyReturnValueFor(Set.class)).isEmpty());\n+        assertTrue(((SortedSet)ToTypeMappings.emptyReturnValueFor(SortedSet.class)).isEmpty());\n+        assertTrue(((HashSet)ToTypeMappings.emptyReturnValueFor(HashSet.class)).isEmpty());\n+        assertTrue(((TreeSet)ToTypeMappings.emptyReturnValueFor(TreeSet.class)).isEmpty());\n+        assertTrue(((LinkedHashSet)ToTypeMappings.emptyReturnValueFor(LinkedHashSet.class)).isEmpty());        \n+\n+        assertTrue(((List)ToTypeMappings.emptyReturnValueFor(List.class)).isEmpty());\n+        assertTrue(((ArrayList)ToTypeMappings.emptyReturnValueFor(ArrayList.class)).isEmpty());\n+        assertTrue(((LinkedList)ToTypeMappings.emptyReturnValueFor(LinkedList.class)).isEmpty());\n+        \n+        assertTrue(((Map)ToTypeMappings.emptyReturnValueFor(Map.class)).isEmpty());\n+        assertTrue(((SortedMap)ToTypeMappings.emptyReturnValueFor(SortedMap.class)).isEmpty());\n+        assertTrue(((HashMap)ToTypeMappings.emptyReturnValueFor(HashMap.class)).isEmpty());\n+        assertTrue(((TreeMap)ToTypeMappings.emptyReturnValueFor(TreeMap.class)).isEmpty());\n+        assertTrue(((LinkedHashMap)ToTypeMappings.emptyReturnValueFor(LinkedHashMap.class)).isEmpty());\n+        \n+        assertNull(ToTypeMappings.emptyReturnValueFor(String.class));\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/matchers/EqualsTest.java\n+package org.mockito.internal.matchers;\n+\n+import static org.junit.Assert.*;\n+\n+import org.easymock.internal.matchers.Equals;\n+import org.junit.Test;\n+\n+\n+public class EqualsTest {\n+    \n+    @Test\n+    public void shouldBeEqual() {\n+        assertEquals(new Equals(null), new Equals(null));\n+        assertEquals(new Equals(new Integer(2)), new Equals(new Integer(2)));\n+        assertFalse(new Equals(null).equals(null));\n+        assertFalse(new Equals(null).equals(\"Test\"));\n+        try {\n+            new Equals(null).hashCode();\n+            fail();\n+        } catch (UnsupportedOperationException expected) {\n+        }\n+    }\n+}", "timestamp": 1195315107, "metainfo": ""}