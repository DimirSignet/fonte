{"sha": "4578731fa64ddf868c66b2e04d8d56893018b9db", "log": "Merge pull request #63 from philipa/master  Improve NoInteractionsWanted report to include the name of the mock.", "commit": "\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n         throw new NoInteractionsWanted(join(\n                 \"No interactions wanted here:\",\n                 new LocationImpl(),\n-                \"But found this interaction:\",\n+                \"But found this interaction on mock '\" + undesired.getMock() + \"':\",\n                 undesired.getLocation(),\n                 scenario\n         ));\n         throw new VerificationInOrderFailure(join(\n                 \"No interactions wanted here:\",\n                 new LocationImpl(),\n-                \"But found this interaction:\",\n-                undesired.getLocation(),\n-                \"\"\n+                \"But found this interaction on mock '\" + undesired.getMock() + \"':\",\n+                undesired.getLocation()\n         ));\n     }\n \n--- a/test/org/mockito/internal/verification/NoMoreInteractionsTest.java\n+++ b/test/org/mockito/internal/verification/NoMoreInteractionsTest.java\n package org.mockito.internal.verification;\n \n import static java.util.Arrays.*;\n-\n+\n+import org.fest.assertions.Assertions;\n import org.junit.Test;\n+import org.mockito.exceptions.verification.NoInteractionsWanted;\n import org.mockito.exceptions.verification.VerificationInOrderFailure;\n+import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.progress.ThreadSafeMockingProgress;\n+import org.mockito.internal.stubbing.InvocationContainerImpl;\n import org.mockito.internal.verification.api.VerificationDataInOrderImpl;\n import org.mockito.invocation.Invocation;\n import org.mockitoutil.TestBase;\n \n         //when\n         context.markVerified(i2);\n-        \n+\n         //then no exception is thrown\n         n.verifyInOrder(new VerificationDataInOrderImpl(context, asList(i, i2), null));\n     }\n-    \n+\n     @Test\n     public void shouldVerifyInOrderMultipleInvoctionsAndThrow() {\n         //given\n         NoMoreInteractions n = new NoMoreInteractions();\n         Invocation i = new InvocationBuilder().seq(1).toInvocation();\n         Invocation i2 = new InvocationBuilder().seq(2).toInvocation();\n-        \n+\n         try {\n-            //when     \n+            //when\n             n.verifyInOrder(new VerificationDataInOrderImpl(context, asList(i, i2), null));\n             fail();\n         } catch (VerificationInOrderFailure e) {}\n+    }\n+\n+    @Test\n+    public void noMoreInteractionsExceptionMessageShouldDescribeMock() {\n+        //given\n+        NoMoreInteractions n = new NoMoreInteractions();\n+        String mock = \"a mock\";\n+        InvocationMatcher i = new InvocationBuilder().mock(mock).toInvocationMatcher();\n+\n+        InvocationContainerImpl invocations =\n+            new InvocationContainerImpl(new ThreadSafeMockingProgress(), new MockSettingsImpl());\n+        invocations.setInvocationForPotentialStubbing(i);\n+\n+        try {\n+            //when\n+            n.verify(new VerificationDataImpl(invocations, null));\n+            //then\n+            fail();\n+        } catch (NoInteractionsWanted e) {\n+            Assertions.assertThat(e.toString()).contains(mock.toString());\n+        }\n+    }\n+\n+    @Test\n+    public void noMoreInteractionsInOrderExceptionMessageShouldDescribeMock() {\n+        //given\n+        NoMoreInteractions n = new NoMoreInteractions();\n+        String mock = \"a mock\";\n+        Invocation i = new InvocationBuilder().mock(mock).toInvocation();\n+\n+        try {\n+            //when\n+            n.verifyInOrder(new VerificationDataInOrderImpl(context, asList(i), null));\n+            //then\n+            fail();\n+        } catch (VerificationInOrderFailure e) {\n+            Assertions.assertThat(e.toString()).contains(mock.toString());\n+        }\n     }\n }\n--- a/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java\n+++ b/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java\n \n             String expectedCause =\n                     \"\\n\" +\n-                    \"But found this interaction:\" +\n+                    \"But found this interaction on mock '\" + mock + \"':\" +\n                     \"\\n\" +\n                     \"-> at\";\n             assertContains(expectedCause, e.getMessage());\n \n             String expectedCause =\n                 \"\\n\" +\n-                \"But found this interaction:\" +\n+                \"But found this interaction on mock '\" + mock + \"':\" +\n                 \"\\n\" +\n                 \"-> at\";\n \n--- a/src/org/mockito/InjectMocks.java\n+++ b/src/org/mockito/InjectMocks.java\n  * i.e. you will have to provide dependencies yourself.\n  * <ol>\n  *     <li><strong>Constructor injection</strong>; the biggest constructor is chosen,\n- *     then arguments are resolved with mocks declared in the test only.\n+ *     then arguments are resolved with mocks declared in the test only. If the object is successfully created\n+ *     with the constructor, then <strong>Mockito won't try the other strategies</strong>. Mockito has decided to no\n+ *     corrupt an object if it has a parametered constructor.\n  *     <p><u>Note:</u> If arguments can not be found, then null is passed.\n  *     If non-mockable types are wanted, then constructor injection won't happen.\n  *     In these cases, you will have to satisfy dependencies yourself.</p></li>\n  *\n- *     <li><strong>Property setter injection</strong>; mocks will first be resolved by type,\n+ *     <li><strong>Property setter injection</strong>; mocks will first be resolved by type (if a single type match\n+ *     injection will happen regardless of the name),\n  *     then, if there is several property of the same type, by the match of the property name and the mock name.\n  *     <p><u>Note 1:</u> If you have properties with the same type (or same erasure), it's better to name all &#064;Mock\n  *     annotated fields with the matching properties, otherwise Mockito might get confused and injection won't happen.</p>\n  *     <p><u>Note 2:</u> If &#064;InjectMocks instance wasn't initialized before and have a no-arg constructor,\n  *     then it will be initialized with this constructor.</p></li>\n  *\n- *     <li><strong>Field injection</strong>; mocks will first be resolved by type,\n+ *     <li><strong>Field injection</strong>; mocks will first be resolved by type (if a single type match\n+ *     injection will happen regardless of the name),\n  *     then, if there is several property of the same type, by the match of the field name and the mock name.\n  *     <p><u>Note 1:</u> If you have fields with the same type (or same erasure), it's better to name all &#064;Mock\n  *     annotated fields with the matching fields, otherwise Mockito might get confused and injection won't happen.</p>\n  * </p>\n  *\n  * <p>\n- * In the above example the field ArticleManager annotated with &#064;InjectMocks can have\n+ * In the above example the field <code>ArticleManager</code> annotated with <code>&#064;InjectMocks</code> can have\n  * a parameterized constructor only or a no-arg constructor only, or both.\n  * All these constructors can be package protected, protected or private, however\n  * <u>Mockito cannot instantiate inner classes, local classes, abstract classes and of course interfaces.</u>\n  * {@link org.mockito.runners.MockitoJUnitRunner}.\n  * </p>\n  *\n+ * <p>\n+ * Mockito is not an dependency injection framework, don't expect this shorthand utility to inject a complex graph of objects\n+ * be it mocks/spies or real objects.\n+ * </p>\n+ *\n  * @see Mock\n  * @see Spy\n  * @see MockitoAnnotations#initMocks(Object)\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n  * </ul>\n  *\n  * <p>\n- * Note that &#064;{@link InjectMocks} can only be used in combination with the &#064;{@link Spy} annotation, it means\n- * that Mockito will inject mocks in a partial mock under testing. As a remainder, please read point 16 about partial mocks.\n+ * Note that &#064;{@link InjectMocks} can also be used in combination with the &#064;{@link Spy} annotation, it means\n+ * that Mockito will inject mocks into the partial mock under test. This complexity is another good reason why you\n+ * should only use partial mocks as a last resort. See point 16 about partial mocks.\n  *\n  * <p>\n  * All new annotations are <b>*only*</b> processed on {@link MockitoAnnotations#initMocks(Object)}.\n--- a/src/org/mockito/internal/creation/AcrossJVMSerializationFeature.java\n+++ b/src/org/mockito/internal/creation/AcrossJVMSerializationFeature.java\n  *\n  * <p>\n  *     The way it works is to enable serialization via the {@link #enableSerializationAcrossJVM(MockCreationSettings)},\n- *     if the mock settings is set to be serializable it will add the {@link org.mockito.internal.creation.AcrossJVMSerializationFeature.AcrossJVMMockitoMockSerializable} interface.\n- *     This interface defines a the {@link org.mockito.internal.creation.AcrossJVMSerializationFeature.AcrossJVMMockitoMockSerializable#writeReplace()}\n+ *     if the mock settings is set to be serializable it will add the {@link AcrossJVMSerializationFeature.AcrossJVMMockitoMockSerializable}\n+ *     interface.\n+ *     This interface defines a the {@link AcrossJVMSerializationFeature.AcrossJVMMockitoMockSerializable#writeReplace()}\n  *     whose signature match the one that is looked by the standard Java serialization.\n  * </p>\n  *\n      * </code></pre>\n      *         So, {@link ObjectOutputStream} will track the <code>writeReplace</code> method in the instance and\n      *         execute it, which is wanted to replace the mock by another type that will encapsulate the actual mock.\n-     *         At this point, the code will return an {@link AcrossJVMMockSerializationProxy}.</p>\n+     *         At this point, the code will return an\n+     *         {@link org.mockito.internal.creation.AcrossJVMSerializationFeature.AcrossJVMMockSerializationProxy}.</p>\n      *     </li>\n      *     <li>\n-     *         <p>Now, in the constructor {@link AcrossJVMMockSerializationProxy#AcrossJVMMockSerializationProxy(Object)}\n-     *         the mock is being serialized in a custom way (using {@link MockitoMockObjectOutputStream}) to a\n+     *         <p>Now, in the constructor\n+     *         {@link org.mockito.internal.creation.AcrossJVMSerializationFeature.AcrossJVMMockSerializationProxy#AcrossJVMMockSerializationProxy(Object)}\n+     *         the mock is being serialized in a custom way (using\n+     *         {@link org.mockito.internal.creation.AcrossJVMSerializationFeature.MockitoMockObjectOutputStream}) to a\n      *         byte array. So basically it means the code is performing double nested serialization of the passed\n      *         <code>mockitoMock</code>.</p>\n      *\n      * This is the serialization proxy that will encapsulate the real mock data as a byte array.\n      *\n      * <p>When called in the constructor it will serialize the mock in a byte array using a\n-     * custom {@link MockitoMockObjectOutputStream} that will annotate the mock class in the stream.\n-     * other information are used in this class in order to facilitate deserialization.\n+     * custom {@link org.mockito.internal.creation.AcrossJVMSerializationFeature.MockitoMockObjectOutputStream} that\n+     * will annotate the mock class in the stream.\n+     * Other information are used in this class in order to facilitate deserialization.\n      * </p>\n      *\n      * <p>Deserialization of the mock will be performed by the {@link #readResolve()} method via\n         /**\n          * Creates the wrapper that be used in the serialization stream.\n          *\n-         * <p>Immediately serializes the Mockito mock using specifically crafted {@link MockitoMockObjectOutputStream},\n+         * <p>Immediately serializes the Mockito mock using specifically crafted\n+         * {@link org.mockito.internal.creation.AcrossJVMSerializationFeature.MockitoMockObjectOutputStream},\n          * in a byte array.</p>\n          *\n          * @param mockitoMock The Mockito mock to serialize.\n      *     class. It is doing so via the {@link #resolveClass(java.io.ObjectStreamClass)} which looks in the stream\n      *     for a Mockito marker. If this marker is found it will try to resolve the mockito class otherwise it\n      *     delegates class resolution to the default super behavior.\n-     *     The mirror method used for serializing the mock is {@link MockitoMockObjectOutputStream#annotateClass(Class)}.\n+     *     The mirror method used for serializing the mock is\n+     *     {@link org.mockito.internal.creation.AcrossJVMSerializationFeature.MockitoMockObjectOutputStream#annotateClass(Class)}.\n      * </p>\n      *\n      * <p>", "timestamp": 1406714811, "metainfo": ""}