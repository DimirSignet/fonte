{"sha": "16afe74fa13517ea904aca6680511ced41734e7f", "log": "refactoring to allow strictly be... more relaxed  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40228", "commit": "\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n      *   \n      *   stub(mock.countElements()).andThrow(new RuntimeException());\n      * </pre>\n+     * <p>\n+     * Trying to stub void method? Look here: {@link Mockito#stubVoid}\n      * \n      * See examples in javadoc for{@link Mockito#stub}\n      * \n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n  */\n package org.mockito.exceptions;\n \n-import static org.mockito.exceptions.StringJoiner.join;\n+import static org.mockito.exceptions.StringJoiner.*;\n \n import org.mockito.exceptions.base.HasStackTrace;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.exceptions.verification.TooLittleActualInvocationsError;\n import org.mockito.exceptions.verification.TooManyActualInvocationsError;\n import org.mockito.exceptions.verification.VerificationError;\n+import org.mockito.exceptions.verification.WrongOrderVerificationError;\n \n /**\n  * Reports verification and misusing errors.\n                 \"Should be something like that: verify(mock).doSomething()\"\n         ));\n     }\n+\n+    public void wrongOrderOfInvocations(HasStackTrace actual) {\n+        RuntimeException cause = new RuntimeException();\n+        cause.setStackTrace(actual.getStackTrace());\n+        \n+        throw new WrongOrderVerificationError(join(\n+                \"Wrong order.\"\n+        ), cause);\n+    }\n }\n--- /dev/null\n+++ b/src/org/mockito/exceptions/verification/WrongOrderVerificationError.java\n+package org.mockito.exceptions.verification;\n+\n+import org.mockito.exceptions.base.MockitoAssertionError;\n+\n+public class WrongOrderVerificationError extends MockitoAssertionError {\n+\n+    private static final long serialVersionUID = 1L;\n+    \n+    public WrongOrderVerificationError(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+}\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n import org.mockito.internal.verification.NumberOfInvocationsVerifier;\n import org.mockito.internal.verification.Verifier;\n import org.mockito.internal.verification.VerifyingRecorder;\n+import org.mockito.internal.verification.WrongOrderOfInvocationsVerifier;\n \n /**\n  * Invocation handler set on mock objects.\n         stubber = new Stubber(mockingProgress);\n         \n         verifyingRecorder = createRecorder(); \n-    }\n-\n-    private VerifyingRecorder createRecorder() {\n-        InvocationsChunker chunker = new InvocationsChunker(new AllInvocationsFinder());\n-        InvocationsMarker marker = new InvocationsMarker();\n-        List<Verifier> verifiers = Arrays.asList(\n-                new MissingInvocationVerifier(), \n-                new NumberOfInvocationsVerifier(),\n-                new NoMoreInvocationsVerifier());\n-        return new VerifyingRecorder(chunker, marker, verifiers);\n     }\n \n     public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n     public List<Invocation> getRegisteredInvocations() {\n         return verifyingRecorder.getRegisteredInvocations();\n     }\n+    \n+    private VerifyingRecorder createRecorder() {\n+        InvocationsChunker chunker = new InvocationsChunker(new AllInvocationsFinder());\n+        InvocationsMarker marker = new InvocationsMarker();\n+        List<Verifier> verifiers = Arrays.asList(\n+                new MissingInvocationVerifier(),\n+                new WrongOrderOfInvocationsVerifier(),\n+                new NumberOfInvocationsVerifier(),\n+                new NoMoreInvocationsVerifier());\n+        return new VerifyingRecorder(chunker, marker, verifiers);\n+    }\n }\n--- a/src/org/mockito/internal/invocation/InvocationsAnalyzer.java\n+++ b/src/org/mockito/internal/invocation/InvocationsAnalyzer.java\n  */\n package org.mockito.internal.invocation;\n \n+import java.util.LinkedList;\n import java.util.List;\n \n import org.mockito.exceptions.base.HasStackTrace;\n         }\n         throw new IllegalArgumentException(\"There are no undesired invocations!\");\n     }\n+\n+    public List<Invocation> findFirstMatchingChunk(List<Invocation> invocations, InvocationMatcher wanted) {\n+        List<Invocation> chunk = new LinkedList<Invocation>();\n+        \n+        for (Invocation i : invocations) {\n+            if (wanted.matches(i)) {\n+                chunk.add(i);\n+            } else if (!chunk.isEmpty()) {\n+                break;\n+            }\n+        }\n+        \n+        return chunk;\n+    }\n }\n--- a/src/org/mockito/internal/invocation/InvocationsChunker.java\n+++ b/src/org/mockito/internal/invocation/InvocationsChunker.java\n \n     public InvocationsChunker(InvocationsFinder invocationsFinder) {\n         this.finder = invocationsFinder;\n+    }\n+    \n+    public List<Invocation> getAllUnverifiedInvocations(List<Object> mocks) {\n+        Set<Invocation> allInvocationsInOrder = new TreeSet<Invocation>(new SequenceNumberComparator());\n+        \n+        List<Invocation> allInvocations = finder.allInvocationsInOrder(mocks);\n+        allInvocationsInOrder.addAll(allInvocations);\n+        \n+        LinkedList<Invocation> chunk = new LinkedList<Invocation>();\n+        for (Invocation i : allInvocationsInOrder) {\n+            if (i.isVerifiedStrictly()) {\n+                chunk.clear();\n+                continue;\n+            }\n+            \n+            chunk.add(i);\n+        } \n+\n+        return chunk;\n     }\n \n     /**\n--- a/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n+++ b/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n             return;\n         }\n         \n+        //get list of actual invocations\n+        //if list is empty report\n+        //if not mark as verified\n+        \n         int actualCount = analyzer.countActual(invocations, wanted);\n         if (actualCount == 0) {\n             reportMissingInvocationError(invocations, wanted);\n--- a/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n+++ b/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n             return;\n         }\n         \n+        //get list of actual invocations (first matching chunk if strictly)\n+        //if list size differs report\n+        //if not mark as verified\n+        \n         int actualCount = analyzer.countActual(invocations, wanted);\n         int wantedCount = mode.wantedCount();\n         \n--- a/src/org/mockito/internal/verification/VerifyingRecorder.java\n+++ b/src/org/mockito/internal/verification/VerifyingRecorder.java\n \n public class VerifyingRecorder {\n \n-    private final LinkedList<Invocation> registeredInvocations = new LinkedList<Invocation>();\n+    private LinkedList<Invocation> registeredInvocations = new LinkedList<Invocation>();\n     \n     private final InvocationsMarker marker;\n     private final List<Verifier> verifiers;", "timestamp": 1198182545, "metainfo": ""}