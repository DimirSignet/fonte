{"sha": "76d7bfba4818d46017b06ec0f11d343ccd1fbd04", "log": "issue 262 : well, static fields and final fields in class annotated by @InjectMocks were candidate to be injected with mocks  --HG-- extra : transplant_source : QC%94%E2Y%28%1F%0EQB%7Em%81%01r_%1Ey%B2%60", "commit": "\n--- a/src/org/mockito/InjectMocks.java\n+++ b/src/org/mockito/InjectMocks.java\n  * <u>Mockito cannot instantiate inner classes, local classes, abstract classes and of course interfaces.</u>\n  *\n  * <p>The same stands for setters or fields, they can be declared with private\n- * visibility, Mockito will see them through reflection.</p>\n+ * visibility, Mockito will see them through reflection.\n+ * However fields that are static or final will be ignored.</p>\n  *\n  * <p>So on the field that needs injection, for example constructor injection will happen here :</p>\n  * <pre>\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n import org.mockito.internal.exceptions.VerificationAwareInvocation;\n import org.mockito.internal.exceptions.util.ScenarioPrinter;\n import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.util.MockUtil;\n import org.mockito.internal.util.StringJoiner;\n import org.mockito.listeners.InvocationListener;\n \n                 \"threw an exception : \" + listenerThrowable.getClass().getName() + listenerThrowable.getMessage()), listenerThrowable);\n     }\n \n+    public void cannotInjectDependency(Field field, Object matchingMock, Exception details) {\n+        throw new MockitoException(join(\n+                \"Mockito couldn't inject mock dependency '\" + new MockUtil().getMockName(matchingMock) + \"' on field \",\n+                \"'\" + field + \"'\",\n+                \"whose type '\" + field.getDeclaringClass().getCanonicalName() + \"' was annotated by @InjectMocks in your test.\",\n+                \"Also I failed because: \" + details.getCause().getMessage(),\n+                \"\"\n+        ), details);\n+    }\n }\n--- a/src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java\n+++ b/src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java\n \n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.configuration.injection.filter.FinalMockCandidateFilter;\n-import org.mockito.internal.configuration.injection.filter.MockCandidateFilter;\n-import org.mockito.internal.configuration.injection.filter.NameBasedCandidateFilter;\n-import org.mockito.internal.configuration.injection.filter.TypeBasedCandidateFilter;\n+import org.mockito.internal.configuration.injection.filter.*;\n+import org.mockito.internal.util.ListUtil;\n import org.mockito.internal.util.reflection.FieldInitializationReport;\n import org.mockito.internal.util.reflection.FieldInitializer;\n \n import java.lang.reflect.Field;\n import java.lang.reflect.InvocationTargetException;\n-import java.util.Arrays;\n-import java.util.Comparator;\n-import java.util.HashSet;\n-import java.util.Set;\n+import java.lang.reflect.Modifier;\n+import java.util.*;\n \n /**\n  * Inject mocks using first setters then fields, if no setters available.\n public class PropertyAndSetterInjection extends MockInjectionStrategy {\n \n     private final MockCandidateFilter mockCandidateFilter = new TypeBasedCandidateFilter(new NameBasedCandidateFilter(new FinalMockCandidateFilter()));\n-    private Comparator<Field> supertypesLast = new Comparator<Field>() {\n+    private Comparator<Field> superTypesLast = new Comparator<Field>() {\n         public int compare(Field field1, Field field2) {\n             Class<?> field1Type = field1.getType();\n             Class<?> field2Type = field2.getType();\n                 return -1;\n             }\n             return 0;\n+        }\n+    };\n+\n+    private ListUtil.Filter<Field> notFinalOrStatic = new ListUtil.Filter<Field>() {\n+        public boolean isOut(Field object) {\n+            return Modifier.isFinal(object.getModifiers()) || Modifier.isStatic(object.getModifiers());\n         }\n     };\n \n         return injectionOccurred;\n     }\n \n-    private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n-        Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n-        Arrays.sort(declaredFields, supertypesLast);\n+    private List<Field> orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n+        List<Field> declaredFields = Arrays.asList(awaitingInjectionClazz.getDeclaredFields());\n+        declaredFields = ListUtil.filter(declaredFields, notFinalOrStatic);\n+\n+        Collections.sort(declaredFields, superTypesLast);\n+\n         return declaredFields;\n     }\n \n--- a/src/org/mockito/internal/configuration/injection/filter/FinalMockCandidateFilter.java\n+++ b/src/org/mockito/internal/configuration/injection/filter/FinalMockCandidateFilter.java\n package org.mockito.internal.configuration.injection.filter;\n \n-import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.exceptions.Reporter;\n import org.mockito.internal.util.reflection.BeanPropertySetter;\n import org.mockito.internal.util.reflection.FieldSetter;\n \n                         if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) {\n                             new FieldSetter(fieldInstance, field).set(matchingMock);\n                         }\n-                    } catch (Exception e) {\n-                        throw new MockitoException(\"Problems injecting dependency in \" + field.getName(), e);\n+                    } catch (RuntimeException e) {\n+                        new Reporter().cannotInjectDependency(field, matchingMock, e);\n                     }\n                     return matchingMock;\n                 }\n--- a/src/org/mockito/internal/util/reflection/BeanPropertySetter.java\n+++ b/src/org/mockito/internal/util/reflection/BeanPropertySetter.java\n                 }\n             }\n         } catch (InvocationTargetException e) {\n-            throw new RuntimeException(\"Problems setting value:[\" + value + \"] on object: [\" + target + \"] the setter of property [\" + field.getName() + \"] threw an exception\", e.getTargetException());\n+            throw new RuntimeException(\"Setter '\" + writeMethod + \"' of '\" + target + \"' with value '\" + value + \"' threw exception : '\" + e.getTargetException() + \"'\", e);\n         } catch (IllegalAccessException e) {\n-            throw new RuntimeException(\"Problems setting value:[\" + value + \"] on object: [\" + target + \"] the setter of property [\" + field.getName() + \"] is not accessible\", e);\n+            throw new RuntimeException(\"Access not authorized on field '\" + field + \"' of object '\" + target + \"' with value: '\" + value + \"'\", e);\n         } catch (IntrospectionException e) {\n-            throw new RuntimeException(\"Problems setting value: [\" + value + \"] on object: [\" + target + \"] for property : [\" + field.getName() + \"], cannot introspect \" + target.getClass(), e);\n+            throw new RuntimeException(\"Something went wrong when trying to infer by introspection the setter of property '\" + field.getName() + \"' on type '\" + target.getClass() + \"'\" + target.getClass(), e);\n         } finally {\n             if(writeMethod != null) {\n                 changer.safelyDisableAccess(writeMethod);\n--- a/src/org/mockito/internal/util/reflection/FieldSetter.java\n+++ b/src/org/mockito/internal/util/reflection/FieldSetter.java\n         changer.enableAccess(field);\n         try {\n             field.set(target, value);\n-        } catch (Exception e) {\n-            throw new RuntimeException(\"Problems setting value: [\" + value + \"] on object: [\" + target + \"] at field: [\" + field + \"]\");\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(\"Access not authorized on field '\" + field + \"' of object '\" + target + \"' with value: '\" + value + \"'\", e);\n+        } catch (IllegalArgumentException e) {\n+            throw new RuntimeException(\"Wrong argument on field '\" + field + \"' of object '\" + target + \"' with value: '\" + value + \"', \\n\" +\n+                    \"reason : \" + e.getMessage(), e);\n         }\n         changer.safelyDisableAccess(field);\n     }\n--- /dev/null\n+++ b/test/org/mockitousage/bugs/ShouldNotTryToInjectInFinalOrStaticFieldsTest.java\n+package org.mockitousage.bugs;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.runners.MockitoJUnitRunner;\n+\n+import java.util.*;\n+\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNotSame;\n+import static org.junit.Assert.assertThat;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+// issue 262\n+@RunWith(MockitoJUnitRunner.class)\n+public class ShouldNotTryToInjectInFinalOrStaticFieldsTest {\n+\n+    public static class ExampleService {\n+        public static final List<String> CONSTANTS = Arrays.asList(\"c1\", \"c1\");\n+        public final Set<String> aSet = new HashSet<String>();\n+    }\n+\n+    @Spy private List<String> unrelatedList = new ArrayList<String>();\n+    @Mock private Set<String> unrelatedSet;\n+\n+    @InjectMocks private ExampleService exampleService = new ExampleService();\n+\n+    @Test\n+    public void dont_fail_with_CONSTANTS() throws Exception {\n+    }\n+\n+    @Test\n+    public void dont_inject_in_final() {\n+        assertNotSame(unrelatedSet, exampleService.aSet);\n+    }\n+\n+}", "timestamp": 1305760711, "metainfo": ""}