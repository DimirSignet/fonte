{"sha": "6de1ebdbf82ffa261a3ec5d703c7ee46c81340d5", "log": "This test didn't pass when run with all the other test. This is due to objenesis cache not resetted, it uses an instantiation strategy that creates a mock that belongs to another classloader, hence a classcast was thrown in the ClassImposterizer. And all of this because IMethods was already used. This commit makes use of some class only loaded in the classloader being used here (so objenesis only sees that class in this test)", "commit": "\n--- a/test/org/mockitousage/serialization/AcrossClassLoaderSerializationTest.java\n+++ b/test/org/mockitousage/serialization/AcrossClassLoaderSerializationTest.java\n package org.mockitousage.serialization;\n \n+import org.junit.Before;\n import org.junit.Test;\n import org.mockito.Mockito;\n import org.mockitousage.IMethods;\n import org.mockitoutil.SimpleSerializationUtil;\n \n import java.io.ByteArrayInputStream;\n+import java.util.Collections;\n+import java.util.List;\n import java.util.concurrent.Callable;\n \n \n public class AcrossClassLoaderSerializationTest {\n+\n+    public IMethods mock;\n+\n+    @Before\n+    public void reproduce_CCE_by_creating_a_mock_with_IMethods_before() throws Exception {\n+        mock = Mockito.mock(IMethods.class);\n+    }\n \n     @Test\n     public void check_that_mock_can_be_serialized_in_a_classloader_and_deserialized_in_another() throws Exception {\n         return new SimplePerRealmReloadingClassLoader.ReloadClassPredicate() {\n             public boolean acceptReloadOf(String qualifiedName) {\n                 return qualifiedName.contains(\"org.mockitousage\")\n-                        || qualifiedName.contains(\"org.mockitoutil\");\n+                        || qualifiedName.contains(\"org.mockitoutil\")\n+                        ;\n             }\n         };\n     }\n     // see create_mock_and_serialize_it_in_class_loader_A\n     public static class CreateMockAndSerializeIt implements Callable<byte[]> {\n         public byte[] call() throws Exception {\n-            IMethods mock = Mockito.mock(IMethods.class, Mockito.withSettings().serializable());\n+            AClassToBeMockedInThisTestOnlyAndInCallablesOnly mock = Mockito.mock(\n+                    AClassToBeMockedInThisTestOnlyAndInCallablesOnly.class,\n+                    Mockito.withSettings().serializable()\n+            );\n             // use MethodProxy before\n-            mock.linkedListReturningMethod();\n+            mock.returningSomething();\n \n             return SimpleSerializationUtil.serializeMock(mock).toByteArray();\n         }\n         }\n \n         public Object call() throws Exception {\n-            ByteArrayInputStream unserialize = new ByteArrayInputStream(bytes);\n-            return SimpleSerializationUtil.deserializeMock(unserialize, IMethods.class);\n+            ByteArrayInputStream to_unserialize = new ByteArrayInputStream(bytes);\n+            return SimpleSerializationUtil.deserializeMock(\n+                    to_unserialize,\n+                    AClassToBeMockedInThisTestOnlyAndInCallablesOnly.class\n+            );\n         }\n     }\n \n \n-\n+    public static class AClassToBeMockedInThisTestOnlyAndInCallablesOnly {\n+        List returningSomething() { return Collections.emptyList(); }\n+    }\n }", "timestamp": 1355616646, "metainfo": ""}