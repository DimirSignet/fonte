{"sha": "b155c0059611936cb848a9b64be01e2daaf0d3de", "log": "moved usage package outside of mockito because: 1. usage means real use and real use will never be inside org.mockito package (e.g: cannot access default-scoped methods) 2. I can test stack trace filtering properly 3. org.mockito should have only unit tests  --HG-- rename : test/org/mockito/usage/IMethods.java => test/org/mockitousage/IMethods.java rename : test/org/mockito/usage/InvalidStateDetectionTest.java => test/org/mockitousage/InvalidStateDetectionTest.java rename : test/org/mockito/usage/InvalidUsageTest.java => test/org/mockitousage/InvalidUsageTest.java rename : test/org/mockito/usage/MockitoSyntaxExperiments.java => test/org/mockitousage/MockitoSyntaxExperiments.java rename : test/org/mockito/usage/ReplacingObjectMethodsTest.java => test/org/mockitousage/ReplacingObjectMethodsTest.java rename : test/org/mockito/usage/StackTrackeFilteringTest.java => test/org/mockitousage/StackTrackeFilteringTest.java rename : test/org/mockito/usage/UsingVarargsTest.java => test/org/mockitousage/UsingVarargsTest.java rename : test/org/mockito/usage/binding/BridgeMethodPuzzleTest.java => test/org/mockitousage/binding/BridgeMethodPuzzleTest.java rename : test/org/mockito/usage/binding/IncorectBindingPuzzleFixedTest.java => test/org/mockitousage/binding/IncorectBindingPuzzleFixedTest.java rename : test/org/mockito/usage/matchers/BasicStubbingTest.java => test/org/mockitousage/matchers/BasicStubbingTest.java rename : test/org/mockito/usage/matchers/ComparableMatchersTest.java => test/org/mockitousage/matchers/ComparableMatchersTest.java rename : test/org/mockito/usage/matchers/InvalidUseOfMatchersTest.java => test/org/mockitousage/matchers/InvalidUseOfMatchersTest.java rename : test/org/mockito/usage/matchers/MatchersTest.java => test/org/mockitousage/matchers/MatchersTest.java rename : test/org/mockito/usage/matchers/MatchersToStringTest.java => test/org/mockitousage/matchers/MatchersToStringTest.java rename : test/org/mockito/usage/stubbing/BasicStubbingTest.java => test/org/mockitousage/stubbing/BasicStubbingTest.java rename : test/org/mockito/usage/stubbing/ReturningDefaultValuesTest.java => test/org/mockitousage/stubbing/ReturningDefaultValuesTest.java rename : test/org/mockito/usage/stubbing/StubbingWithThrowablesTest.java => test/org/mockitousage/stubbing/StubbingWithThrowablesTest.java rename : test/org/mockito/usage/verification/AtLeastOnceVerificationTest.java => test/org/mockitousage/verification/AtLeastOnceVerificationTest.java rename : test/org/mockito/usage/verification/BasicVerificationTest.java => test/org/mockitousage/verification/BasicVerificationTest.java rename : test/org/mockito/usage/verification/ExactNumberOfTimesVerificationTest.java => test/org/mockitousage/verification/ExactNumberOfTimesVerificationTest.java rename : test/org/mockito/usage/verification/NiceMessagesOnStrictOrderErrorsTest.java => test/org/mockitousage/verification/NiceMessagesOnStrictOrderErrorsTest.java rename : test/org/mockito/usage/verification/NiceMessagesWhenVerificationFailsTest.java => test/org/mockitousage/verification/NiceMessagesWhenVerificationFailsTest.java rename : test/org/mockito/usage/verification/NoMoreInteractionsVerificationTest.java => test/org/mockitousage/verification/NoMoreInteractionsVerificationTest.java rename : test/org/mockito/usage/verification/VerificationInOrderMixedWithOrdiraryVerificationTest.java => test/org/mockitousage/verification/VerificationInOrderMixedWithOrdiraryVerificationTest.java rename : test/org/mockito/usage/verification/VerificationInOrderTest.java => test/org/mockitousage/verification/VerificationInOrderTest.java rename : test/org/mockito/usage/verification/VerificationOnMultipleMocksUsingMatchersTest.java => test/org/mockitousage/verification/VerificationOnMultipleMocksUsingMatchersTest.java rename : test/org/mockito/usage/verification/VerificationUsingMatchersTest.java => test/org/mockitousage/verification/VerificationUsingMatchersTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40115", "commit": "\n--- a/test/org/mockito/internal/InvocationBuilder.java\n+++ b/test/org/mockito/internal/InvocationBuilder.java\n import java.lang.reflect.Method;\n import java.util.*;\n \n-import org.mockito.usage.*;\n+import org.mockitousage.IMethods;\n \n @SuppressWarnings(\"unchecked\")\n public class InvocationBuilder {\n--- /dev/null\n+++ b/test/org/mockitousage/IMethods.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+public interface IMethods {\n+\n+    boolean booleanReturningMethod(int index);\n+\n+    byte byteReturningMethod(int index);\n+\n+    short shortReturningMethod(int index);\n+\n+    char charReturningMethod(int index);\n+\n+    int intReturningMethod(int index);\n+\n+    long longReturningMethod(int index);\n+\n+    float floatReturningMethod(int index);\n+\n+    double doubleReturningMethod(int index);\n+\n+    Object objectReturningMethod(int index);\n+\n+    String oneArg(boolean value);\n+\n+    String oneArg(byte value);\n+\n+    String oneArg(short value);\n+\n+    String oneArg(char value);\n+\n+    String oneArg(int value);\n+\n+    String oneArg(long value);\n+\n+    String oneArg(float value);\n+\n+    String oneArg(double value);\n+\n+    String oneArg(Object value);\n+\n+    String oneArg(String value);\n+\n+    public String throwsNothing(boolean value);\n+\n+    public String throwsIOException(int count) throws IOException;\n+\n+    public String throwsError(int count) throws Error;\n+\n+    boolean simpleMethod();\n+    \n+    void differentMethod();\n+\n+    void simpleMethod(String argument);\n+    \n+    void simpleMethod(int argument);\n+    \n+    void simpleMethod(String argOne, Integer argTwo);\n+\n+    Object threeArgumentMethod(int valueOne, Object valueTwo, String valueThree);\n+\n+    void twoArgumentMethod(int one, int two);\n+\n+    void arrayMethod(String[] strings);\n+\n+    String oneArray(boolean[] array);\n+\n+    String oneArray(byte[] array);\n+\n+    String oneArray(char[] array);\n+\n+    String oneArray(double[] array);\n+\n+    String oneArray(float[] array);\n+\n+    String oneArray(int[] array);\n+\n+    String oneArray(long[] array);\n+\n+    String oneArray(short[] array);\n+\n+    String oneArray(Object[] array);\n+\n+    String oneArray(String[] array);\n+\n+    void varargsString(int i, String... string);\n+\n+    void varargsObject(int i, Object... object);\n+\n+    List<String> listReturningMethod(Object ... objects);\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/InvalidStateDetectionTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.*;\n+import org.mockito.exceptions.*;\n+import org.mockito.internal.StateResetter;\n+\n+/**\n+ * invalid state happens if:\n+ * \n+ *    -unfinished stubbing\n+ *    -unfinished stubVoid\n+ *    -stubbing without actual method call\n+ *    -verify without actual method call\n+ *    \n+ * we should aim to detect invalid state in following scenarios:\n+ * \n+ *    -on method call on mock\n+ *    -on verify\n+ *    -on verifyZeroInteractions\n+ *    -on verifyNoMoreInteractions\n+ *    -on verify on strictly\n+ *    -on stub\n+ *    -on stubVoid\n+ */\n+@SuppressWarnings(\"unchecked\")\n+public class InvalidStateDetectionTest {\n+\n+    private IMethods mock;\n+\n+    @Before\n+    @After\n+    public void resetState() {\n+        StateResetter.reset();\n+        mock = mock(IMethods.class);\n+    }\n+    \n+    @Test\n+    public void shouldDetectUnfinishedStubbing() {\n+        stub(mock.simpleMethod());\n+        \n+        detects(new OnMethodCallOnMock(), mock, UnfinishedStubbingException.class);\n+        detects(new OnStub(), mock, UnfinishedStubbingException.class);\n+        detects(new OnStubVoid(), mock, UnfinishedStubbingException.class);\n+        detects(new OnVerify(), mock, UnfinishedStubbingException.class);\n+        detects(new OnStrictVerify(), mock, UnfinishedStubbingException.class);\n+        detects(new OnVerifyZeroInteractions(), mock, UnfinishedStubbingException.class);\n+        detects(new OnVerifyNoMoreInteractions(), mock, UnfinishedStubbingException.class);\n+    }\n+    \n+    @Test\n+    public void shouldDetectUnfinishedStubbingVoid() {\n+        stubVoid(mock);\n+        detects(new OnMethodCallOnMock(), mock, UnfinishedStubbingException.class);\n+        detects(new OnStub(), mock, UnfinishedStubbingException.class);\n+        detects(new OnStubVoid(), mock, UnfinishedStubbingException.class);\n+        detects(new OnVerify(), mock, UnfinishedStubbingException.class);\n+        detects(new OnStrictVerify(), mock, UnfinishedStubbingException.class);\n+        detects(new OnVerifyZeroInteractions(), mock, UnfinishedStubbingException.class);\n+        detects(new OnVerifyNoMoreInteractions(), mock, UnfinishedStubbingException.class);\n+    }\n+    \n+    @Test\n+    public void shouldDetectUnfinishedVerification() {\n+        verify(mock);\n+        detects(new OnStub(), mock, UnfinishedVerificationException.class);\n+        detects(new OnStubVoid(), mock, UnfinishedVerificationException.class);\n+        detects(new OnVerify(), mock, UnfinishedVerificationException.class);\n+        detects(new OnStrictVerify(), mock, UnfinishedVerificationException.class);\n+        detects(new OnVerifyZeroInteractions(), mock, UnfinishedVerificationException.class);\n+        detects(new OnVerifyNoMoreInteractions(), mock, UnfinishedVerificationException.class);\n+    }\n+    \n+    private static interface DetectsInvalidState {\n+        void detect(IMethods mock);\n+    }\n+    \n+    private static class OnVerify implements DetectsInvalidState {\n+        public void detect(IMethods mock) {\n+            verify(mock);\n+        }\n+    }\n+    \n+    private static class OnStrictVerify implements DetectsInvalidState {\n+        public void detect(IMethods mock) {\n+            createStrictOrderVerifier(mock).verify(mock);\n+        }\n+    }\n+    \n+    private static class OnVerifyZeroInteractions implements DetectsInvalidState {\n+        public void detect(IMethods mock) {\n+            verifyZeroInteractions(mock);\n+        }\n+    }\n+    \n+    private static class OnVerifyNoMoreInteractions implements DetectsInvalidState {\n+        public void detect(IMethods mock) {\n+            verifyNoMoreInteractions(mock);\n+        }\n+    }    \n+    \n+    private static class OnStub implements DetectsInvalidState {\n+        public void detect(IMethods mock) {\n+            stub(mock.toString());\n+        }\n+    }\n+    \n+    private static class OnStubVoid implements DetectsInvalidState {\n+        public void detect(IMethods mock) {\n+            stubVoid(mock);\n+        }\n+    }\n+    \n+    private static class OnMethodCallOnMock implements DetectsInvalidState {\n+        public void detect(IMethods mock) {\n+            mock.simpleMethod();\n+        }\n+    }\n+    \n+    private void detects(DetectsInvalidState detector, IMethods mock, Class expected) {\n+        try {\n+            detector.detect(mock);\n+            fail(\"Should throw an exception\");\n+        } catch (Exception e) {\n+            assertEquals(expected, e.getClass());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/InvalidUsageTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage;\n+\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.*;\n+import org.mockito.Strictly;\n+import org.mockito.exceptions.*;\n+import org.mockito.internal.StateResetter;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class InvalidUsageTest {\n+\n+    private IMethods mock;\n+    private IMethods mockTwo;\n+\n+    @Before\n+    @After\n+    public void resetState() {\n+        StateResetter.reset();\n+        mock = mock(IMethods.class);\n+        mockTwo = mock(IMethods.class);\n+    }\n+    \n+    @Test(expected=MockitoException.class)\n+    public void shouldRequireArgumentsWhenVerifyingNoMoreInteractions() {\n+        verifyNoMoreInteractions();\n+    }\n+    \n+    @Test(expected=MockitoException.class)\n+    public void shouldRequireArgumentsWhenVerifyingZeroInteractions() {\n+        verifyZeroInteractions();\n+    }\n+    \n+    @Test(expected=MockitoException.class)\n+    public void shouldNotCreateStrictlyWithoutMocks() {\n+        createStrictOrderVerifier();\n+    }\n+    \n+    @Test(expected=MockitoException.class)\n+    public void shouldNotStrictlyVerifyUnfamilarMocks() {\n+        Strictly strictly = createStrictOrderVerifier(mock);\n+        strictly.verify(mockTwo).simpleMethod();\n+    }\n+    \n+    @Test(expected=MissingMethodInvocationException.class)\n+    public void shouldReportMissingMethodInvocationWhenStubbing() {\n+        stub(\"\".toString()).andReturn(\"x\");\n+    }\n+    \n+    @Test(expected=MockitoException.class)\n+    public void shouldNotAllowSettingInvalidCheckedException() throws Exception {\n+        stub(mock.simpleMethod()).andThrows(new Exception());\n+    }\n+    \n+    @Test(expected=MockitoException.class)\n+    public void shouldNotAllowSettingNullThrowable() throws Exception {\n+        stub(mock.simpleMethod()).andThrows(null);\n+    }    \n+}\n--- /dev/null\n+++ b/test/org/mockitousage/MockitoSyntaxExperiments.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage;\n+\n+import java.util.List;\n+import static org.mockito.MockitoExperimental.*;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class MockitoSyntaxExperiments {\n+    \n+    public void goodOldEasyMockVerifySyntax() {\n+        List mock = mock(List.class);\n+        \n+        //stub it\n+        stub(mock.add(\"test\")).andReturn(true);\n+        \n+        //use it\n+        mock.add(2, \"test2\");\n+\n+        verify(mock).add(2, \"test2\");\n+        verify(mock, 5).add(2, \"test2\");\n+            //or\n+//            verify(mock).times(5).add(2, \"test2\");\n+        verifyNoMoreInteractions(mock);\n+        verifyZeroInteractions(mock);\n+    }\n+    \n+    public void oldSchoolAssertSyntax() {\n+        List mock = mock(List.class);\n+        \n+        //stub it\n+        stub(mock.add(\"test\")).andReturn(true);\n+        \n+        //use it\n+        mock.add(2, \"test2\");\n+\n+        //Second for old style assertions\n+        assertInvoked(mock).add(2, \"test2\");\n+        assertInvoked(mock, 5).add(2, \"test2\");\n+            //or\n+//            assertInvoked(mock).times(5).add(2, \"test2\");\n+        assertNoMoreInteractions(mock);\n+        assertZeroInteractions(mock);\n+    }\n+    \n+    public void shinyNewAssertThatSyntax() {\n+        List mock = mock(List.class);\n+        \n+        //stub it\n+        stub(mock.add(\"test\")).andReturn(true);\n+        \n+        //use it\n+        mock.add(2, \"test2\");\n+        \n+        assertThat(wasInvoked(mock)).add(2, \"test2\");\n+        assertThat(wasInvoked(mock, 5)).add(2, \"test2\");\n+        assertThat(noMoreInteractions(mock));\n+        assertThat(zeroInteractions(mock));\n+    }\n+    \n+    public void verifiesMocksInOrder() {\n+//        verifyInOrder(new Ordering() { void sequence() {\n+//            verify(mock).clear();\n+//            verify(mock2).clear();\n+//        }};);\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/ReplacingObjectMethodsTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage;\n+\n+import static org.hamcrest.CoreMatchers.*;\n+import static org.junit.Assert.*;\n+\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+public class ReplacingObjectMethodsTest {\n+\n+    private interface DummyInterface {}\n+    private class DummyClass {}\n+    \n+    @Test\n+    public void shouldProvideMockyImplementationOfToString() {\n+        assertEquals(\"Mock for DummyClass\", Mockito.mock(DummyClass.class).toString());\n+        assertEquals(\"Mock for DummyInterface\", Mockito.mock(DummyInterface.class).toString());\n+    }\n+    \n+    @Test \n+    public void testShouldReplaceObjectMethods() {\n+        Object mock = Mockito.mock(ObjectMethodsOverridden.class);\n+        Object otherMock = Mockito.mock(ObjectMethodsOverridden.class);\n+        \n+        assertThat(mock, equalTo(mock));\n+        assertThat(mock, not(equalTo(otherMock)));\n+        \n+        assertThat(mock.hashCode(), not(equalTo(otherMock.hashCode())));\n+        \n+        assertThat(mock.toString(), equalTo(\"Mock for ObjectMethodsOverridden\"));\n+    }\n+    \n+    @Test \n+    public void testShouldReplaceObjectMethodsWhenOverridden() {\n+        Object mock = Mockito.mock(ObjectMethodsOverriddenSubclass.class);\n+        Object otherMock = Mockito.mock(ObjectMethodsOverriddenSubclass.class);\n+        \n+        assertThat(mock, equalTo(mock));\n+        assertThat(mock, not(equalTo(otherMock)));\n+        \n+        assertThat(mock.hashCode(), not(equalTo(otherMock.hashCode())));\n+        \n+        assertThat(mock.toString(), equalTo(\"Mock for ObjectMethodsOverriddenSubclass\"));\n+    }\n+    \n+    public static class ObjectMethodsOverridden {\n+        public boolean equals(Object o) {\n+            throw new RuntimeException(\"Should not be called. ObjectMethodsFilter provides implementation\");\n+        }\n+        public int hashCode() {\n+            throw new RuntimeException(\"Should not be called. ObjectMethodsFilter provides implementation\");\n+        }\n+        public String toString() {\n+            throw new RuntimeException(\"Should not be called. ObjectMethodsFilter provides implementation\");\n+        }\n+    }\n+    \n+    public static class ObjectMethodsOverriddenSubclass extends ObjectMethodsOverridden {\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/StackTrackeFilteringTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.*;\n+import org.mockito.*;\n+import org.mockito.exceptions.*;\n+import org.mockito.internal.StateResetter;\n+\n+import static org.mockito.util.ExtraMatchers.*;\n+\n+public class StackTrackeFilteringTest {\n+    \n+    private IMethods mock;\n+\n+    @After\n+    public void resetState() {\n+        StateResetter.reset();\n+    }\n+    \n+    @Before\n+    public void setup() {\n+        resetState();\n+        mock = Mockito.mock(IMethods.class);\n+    }\n+    \n+    @Test\n+    public void shouldFilterStackTraceOnVerify() {\n+        try {\n+            verify(mock).simpleMethod();\n+            fail();\n+        } catch (VerificationError expected) {\n+            assertThat(expected, firstMethodOnStackEqualsTo(\"shouldFilterStackTraceOnVerify\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldFilterStackTraceOnVerifyNoMoreInteractions() {\n+        mock.oneArg(true);\n+        try {\n+            verifyNoMoreInteractions(mock);\n+            fail();\n+        } catch (VerificationError expected) {\n+            assertThat(expected, firstMethodOnStackEqualsTo(\"shouldFilterStackTraceOnVerifyNoMoreInteractions\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldFilterStackTraceOnVerifyZeroInteractions() {\n+        mock.oneArg(true);\n+        try {\n+            verifyZeroInteractions(mock);\n+            fail();\n+        } catch (VerificationError expected) {\n+            assertThat(expected, firstMethodOnStackEqualsTo(\"shouldFilterStackTraceOnVerifyZeroInteractions\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldFilterStacktraceOnMockitoException() {\n+        verify(mock);\n+        try {\n+            verify(mock).oneArg(true); \n+            fail();\n+        } catch (MockitoException expected) {\n+            assertThat(expected, firstMethodOnStackEqualsTo(\"shouldFilterStacktraceOnMockitoException\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldFilterStacktraceWhenStrictlyVerifying() {\n+        Strictly strictly = createStrictOrderVerifier(mock);\n+        mock.oneArg(true);\n+        mock.oneArg(false);\n+        try {\n+            strictly.verify(mock).oneArg(false); \n+            fail();\n+        } catch (VerificationError expected) {\n+            assertThat(expected, firstMethodOnStackEqualsTo(\"shouldFilterStacktraceWhenStrictlyVerifying\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldFilterStacktraceWhenStrictlyThrowsMockitoException() {\n+        try {\n+            createStrictOrderVerifier();\n+            fail();\n+        } catch (MockitoException expected) {\n+            assertThat(expected, firstMethodOnStackEqualsTo(\"shouldFilterStacktraceWhenStrictlyThrowsMockitoException\"));\n+        }\n+    }\n+    \n+    @Ignore\n+    @Test\n+    public void shouldFilterStacktraceWhenStrictlyVerifies() {\n+        try {\n+            Strictly strictly = createStrictOrderVerifier(mock);\n+            strictly.verify(null);\n+            fail();\n+        } catch (MockitoException expected) {\n+            assertThat(expected, firstMethodOnStackEqualsTo(\"shouldFilterStacktraceWhenStrictlyVerifies\"));\n+        }\n+    }\n+    \n+    @Ignore\n+    @Test\n+    public void shouldFilterStackTraceWhenThrowingExceptionFromControl() {\n+        try {\n+            stub(mock.oneArg(true)).andThrows(new Exception());\n+            fail();\n+        } catch (MockitoException expected) {\n+            assertThat(expected, firstMethodOnStackEqualsTo(\"shouldFilterStackTraceOnThrowingExceptionFromControl\"));\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/UsingVarargsTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage;\n+\n+import static org.mockito.Mockito.*;\n+import static org.junit.Assert.*;\n+\n+import java.util.ArrayList;\n+\n+import org.junit.*;\n+import org.mockito.Mockito;\n+import org.mockito.exceptions.VerificationError;\n+\n+public class UsingVarargsTest {\n+\n+    private interface IVarArgs {\n+        public void withStringVarargs(int value, String... s);\n+        public String withStringVarargsReturningString(int value, String... s);\n+        public void withObjectVarargs(int value, Object... o);\n+        public boolean withBooleanVarargs(int value, boolean... b);\n+    }\n+    \n+    IVarArgs mock;\n+\n+    @Before\n+    public void setup() {\n+        mock = Mockito.mock(IVarArgs.class);\n+    }\n+    \n+    @Test\n+    public void shouldStubStringVarargs() {\n+        stub(mock.withStringVarargsReturningString(1)).andReturn(\"1\");\n+        stub(mock.withStringVarargsReturningString(2, \"1\", \"2\", \"3\")).andReturn(\"2\");\n+        \n+        RuntimeException expected = new RuntimeException();\n+        stubVoid(mock).toThrow(expected).on().withStringVarargs(3, \"1\", \"2\", \"3\", \"4\");\n+\n+        assertEquals(\"1\", mock.withStringVarargsReturningString(1));\n+        assertEquals(null, mock.withStringVarargsReturningString(2));\n+        \n+        assertEquals(\"2\", mock.withStringVarargsReturningString(2, \"1\", \"2\", \"3\"));\n+        assertEquals(null, mock.withStringVarargsReturningString(2, \"1\", \"2\"));\n+        assertEquals(null, mock.withStringVarargsReturningString(2, \"1\", \"2\", \"3\", \"4\"));\n+        assertEquals(null, mock.withStringVarargsReturningString(2, \"1\", \"2\", \"9999\"));\n+        \n+        mock.withStringVarargs(3, \"1\", \"2\", \"3\", \"9999\");\n+        mock.withStringVarargs(9999, \"1\", \"2\", \"3\", \"4\");\n+        \n+        try {\n+            mock.withStringVarargs(3, \"1\", \"2\", \"3\", \"4\");\n+            fail();\n+        } catch (Exception e) {\n+            assertEquals(expected, e);\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldStubBooleanVarargs() {\n+        stub(mock.withBooleanVarargs(1)).andReturn(true);\n+        stub(mock.withBooleanVarargs(1, true, false)).andReturn(true);\n+        \n+        assertEquals(true, mock.withBooleanVarargs(1));\n+        assertEquals(false, mock.withBooleanVarargs(9999));\n+        \n+        assertEquals(true, mock.withBooleanVarargs(1, true, false));\n+        assertEquals(false, mock.withBooleanVarargs(1, true, false, true));\n+        assertEquals(false, mock.withBooleanVarargs(2, true, false));\n+        assertEquals(false, mock.withBooleanVarargs(1, true));\n+        assertEquals(false, mock.withBooleanVarargs(1, false, false));\n+    }\n+    \n+    @Test\n+    public void shouldVerifyStringVarargs() {\n+        mock.withStringVarargs(1);\n+        mock.withStringVarargs(2, \"1\", \"2\", \"3\");\n+        mock.withStringVarargs(3, \"1\", \"2\", \"3\", \"4\");\n+\n+        verify(mock).withStringVarargs(1);\n+        verify(mock).withStringVarargs(2, \"1\", \"2\", \"3\");\n+        try {\n+            verify(mock).withStringVarargs(2, \"1\", \"2\", \"79\", \"4\");\n+            fail();\n+        } catch (VerificationError e) {}\n+    }\n+\n+    @Test\n+    public void shouldVerifyObjectVarargs() {\n+        mock.withObjectVarargs(1);\n+        mock.withObjectVarargs(2, \"1\", new ArrayList<Object>(), new Integer(1));\n+        mock.withObjectVarargs(3, new Integer(1));\n+\n+        verify(mock).withObjectVarargs(1);\n+        verify(mock).withObjectVarargs(2, \"1\", new ArrayList<Object>(), new Integer(1));\n+        try {\n+            verifyNoMoreInteractions(mock);\n+            fail();\n+        } catch (VerificationError e) {}\n+    }\n+\n+    @Test\n+    public void shouldVerifyBooleanVarargs() {\n+        mock.withBooleanVarargs(1);\n+        mock.withBooleanVarargs(2, true, false, true);\n+        mock.withBooleanVarargs(3, true, true, true);\n+\n+        verify(mock).withBooleanVarargs(1);\n+        verify(mock).withBooleanVarargs(2, true, false, true);\n+        try {\n+            verify(mock).withBooleanVarargs(3, true, true, true, true);\n+            fail();\n+        } catch (VerificationError e) {}\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/binding/BridgeMethodPuzzleTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.binding;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+import static org.mockito.util.ExtraMatchers.hasBridgeMethod;\n+\n+import org.junit.Test;\n+\n+/**\n+ * Bridge method is generated by compiler when erasure in parent class is\n+ * different. When is different then it means that in runtime we will have\n+ * overloading rather than overridding Therefore the compiler generates bridge\n+ * method in Subclass so that erasures are the same, signatures of methods match\n+ * and overridding is ON.\n+ */\n+@SuppressWarnings(\"unchecked\")\n+public class BridgeMethodPuzzleTest {\n+    \n+    private class Super<T> {\n+        public String say(T t) {\n+            return \"Super says: \" + t;\n+        }\n+    }\n+    \n+    private class Sub extends Super<String> {\n+        @Override\n+        public String say(String t)  {\n+            return \"Sub says: \" + t;\n+        }\n+    }\n+\n+    Super mock;\n+    \n+    private void setMockWithDownCast(Super mock) {\n+        this.mock = mock;\n+    }\n+    \n+    private void say(String string) {\n+        mock.say(string);\n+    }\n+    \n+    @Test\n+    public void shouldHaveBridgeMethod() throws Exception {\n+        Super s = new Sub();\n+        \n+        assertEquals(\"Sub says: Hello\", s.say(\"Hello\"));\n+        \n+        assertThat(Sub.class, hasBridgeMethod(\"say\"));\n+        assertThat(s, hasBridgeMethod(\"say\"));\n+    }\n+    \n+    @Test\n+    public void shouldVerifyCorrectlyWhenBridgeMethodCalled() throws Exception {\n+        //Super has following erasure: say(Object) which differs from Sub.say(String)\n+        //mock has to detect it and do the super.say()\n+        //see MockFactory.java\n+        Sub s = mock(Sub.class);\n+        setMockWithDownCast(s);\n+        say(\"Hello\");\n+        \n+        verify(s).say(\"Hello\");\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/binding/IncorectBindingPuzzleFixedTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.binding;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.Test;\n+import org.mockito.Strictly;\n+import org.mockito.exceptions.VerificationError;\n+\n+public class IncorectBindingPuzzleFixedTest {\n+\n+    private Super mock;\n+    \n+    private void setMockWithDowncast(Super mock) {\n+        this.mock = mock;\n+    }\n+\n+    private interface Super {\n+        public void say(Object message);\n+    }\n+\n+    private interface Sub extends Super {\n+        public void say(String message);\n+    }\n+\n+    private void say(Object message) {\n+        mock.say(message);\n+    }\n+\n+    @Test\n+    public void shouldUseArgumentTypeWhenOverloadingPuzzleDetected() throws Exception {\n+        Sub sub = mock(Sub.class);\n+        setMockWithDowncast(sub);\n+        say(\"Hello\");\n+        try {\n+            verify(sub).say(\"Hello\");\n+            fail();\n+        } catch (VerificationError error) {\n+            String expected = \n+                \"\\n\" +\n+        \t\t\"Invocation differs from actual\" +\n+        \t\t\"\\n\" +\n+                \"Wanted: Sub.say(class java.lang.String)\" +\n+                \"\\n\" +\n+                \"Actual: Sub.say(class java.lang.Object)\";\n+            \n+            assertEquals(expected, error.getMessage());\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldUseArgumentTypeWhenOverloadingPuzzleDetectedByStrictly() throws Exception {\n+        Sub sub = mock(Sub.class);\n+        setMockWithDowncast(sub);\n+        say(\"Hello\");\n+        Strictly strictly = createStrictOrderVerifier(mock);\n+        try {\n+            strictly.verify(sub).say(\"Hello\");\n+            fail();\n+        } catch (VerificationError error) {\n+            String expected = \n+                \"\\n\" +\n+                \"Strict order verification failed\" +\n+                \"\\n\" +\n+                \"Wanted: Sub.say(class java.lang.String)\" +\n+                \"\\n\" +\n+                \"Actual: Sub.say(class java.lang.Object)\";\n+            \n+            assertEquals(expected, error.getMessage());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/matchers/BasicStubbingTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.matchers;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+import static org.mockito.util.ExtraMatchers.collectionContaining;\n+\n+import java.util.Arrays;\n+\n+import org.junit.*;\n+import org.mockito.Mockito;\n+import org.mockito.exceptions.VerificationError;\n+import org.mockitousage.IMethods;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class BasicStubbingTest {\n+\n+    private IMethods mock;\n+\n+    @Before\n+    public void setup() {\n+        mock = Mockito.mock(IMethods.class);\n+    }\n+    \n+    @Test\n+    public void shouldStubAllMethodsByDefault() throws Exception {\n+        assertEquals(0, mock.intReturningMethod(1));\n+        assertEquals(0, mock.intReturningMethod(2));\n+        \n+        assertNull(mock.objectReturningMethod(1));\n+        assertNull(mock.objectReturningMethod(2));\n+        \n+        assertEquals(0, mock.listReturningMethod().size());\n+        assertEquals(0, mock.listReturningMethod().size());\n+    }\n+    \n+    @Test\n+    public void shouldStubAndLetBeCalledAnyTimes() throws Exception {\n+        stub(mock.intReturningMethod(14)).andReturn(14);\n+        \n+        assertEquals(14, mock.intReturningMethod(14));\n+        assertEquals(14, mock.intReturningMethod(14));\n+        \n+        stub(mock.listReturningMethod(\"x\")).andReturn(Arrays.asList(\"elementOne\", \"elementTwo\"));\n+        \n+        assertThat(mock.listReturningMethod(\"x\"), collectionContaining(\"elementOne\", \"elementTwo\"));\n+        assertThat(mock.listReturningMethod(\"x\"), collectionContaining(\"elementOne\", \"elementTwo\"));\n+        \n+        stub(mock.objectReturningMethod(100)).andReturn(\"hundred\");\n+        \n+        assertEquals(\"hundred\", mock.objectReturningMethod(100));\n+        assertEquals(\"hundred\", mock.objectReturningMethod(100));\n+    }\n+    \n+    @Test\n+    public void shouldStubbingBeTreatedAsInteraction() throws Exception {\n+        stub(mock.booleanReturningMethod(1)).andReturn(true);\n+        \n+        mock.booleanReturningMethod(1);\n+        \n+        try {\n+            verifyNoMoreInteractions(mock);\n+            fail();\n+        } catch (VerificationError e) {}\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/matchers/ComparableMatchersTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.matchers;\n+\n+import static org.junit.Assert.*;\n+\n+import java.math.BigDecimal;\n+\n+import org.junit.Test;\n+import org.mockito.internal.matchers.*;\n+\n+public class ComparableMatchersTest {\n+\n+    @Test\n+    public void testNotComparable() {\n+        CompareTo<Long> cmpTo = new CompareTo<Long>(5L) {\n+\n+            @Override\n+            protected String getName() {\n+                return null;\n+            }\n+\n+            @Override\n+            protected boolean matchResult(int result) {\n+                fail(\"Shouldn't be called since the passed argument is not Comparable\");\n+                return true;\n+            }\n+            \n+        };\n+        \n+        assertFalse(cmpTo.matches(new Object()));\n+    }\n+    @Test\n+    public void testLessThan() {\n+        test(new LessThan<String>(\"b\"), true, false, false, \"lt\");\n+    }\n+\n+    @Test\n+    public void testGreateThan() {\n+        test(new GreaterThan<String>(\"b\"), false, true, false, \"gt\");\n+    }\n+\n+    @Test\n+    public void testLessOrEqual() {\n+        test(new LessOrEqual<String>(\"b\"), true, false, true, \"leq\");\n+    }\n+\n+    @Test\n+    public void testGreateOrEqual() {\n+        test(new GreaterOrEqual<String>(\"b\"), false, true, true, \"geq\");\n+    }\n+\n+    @Test\n+    public void testCompareEqual() {\n+        test(new CompareEqual<String>(\"b\"), false, false, true, \"cmpEq\");\n+\n+        // Make sure it works when equals provide a different result than\n+        // compare\n+        CompareEqual<BigDecimal> cmpEq = new CompareEqual<BigDecimal>(\n+                new BigDecimal(\"5.00\"));\n+        assertTrue(cmpEq.matches(new BigDecimal(\"5\")));\n+    }\n+\n+    private void test(CompareTo<String> compareTo, boolean lower, boolean higher,\n+            boolean equals, String name) {\n+\n+        assertEquals(lower, compareTo.matches(\"a\"));\n+        assertEquals(equals, compareTo.matches(\"b\"));\n+        assertEquals(higher, compareTo.matches(\"c\"));\n+\n+        StringBuffer sb = new StringBuffer();\n+        compareTo.appendTo(sb);\n+        assertEquals(name + \"(b)\", sb.toString());\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/matchers/InvalidUseOfMatchersTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.matchers;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Matchers.eq;\n+\n+import org.junit.*;\n+import org.mockito.*;\n+import org.mockito.exceptions.InvalidUseOfMatchersException;\n+import org.mockito.internal.*;\n+import org.mockitousage.IMethods;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class InvalidUseOfMatchersTest {\n+    \n+    private IMethods mock;\n+    \n+    @Before\n+    public void setUp() {\n+        StateResetter.reset();\n+        mock = Mockito.mock(IMethods.class);\n+    }\n+    \n+    @After\n+    public void resetState() {\n+        StateResetter.reset();\n+    }\n+\n+    @Test\n+    public void shouldDetectWrongNumberOfMatchersWhenStubbing() {\n+        Mockito.stub(mock.threeArgumentMethod(1, \"2\", \"3\")).andReturn(null);\n+        try {\n+            Mockito.stub(mock.threeArgumentMethod(1, eq(\"2\"), \"3\")).andReturn(null);\n+            fail();\n+        } catch (InvalidUseOfMatchersException e) {}\n+    }\n+    \n+    @Test\n+    public void shouldDetectStupidUseOfMatchersWhenVerifying() {\n+        mock.oneArg(true);\n+        eq(\"that's the stupid way\");\n+        eq(\"of using matchers\");\n+        try {\n+            Mockito.verify(mock).oneArg(true);\n+            fail();\n+        } catch (InvalidUseOfMatchersException e) {}\n+    }\n+    \n+    @Test\n+    public void shouldScreamWhenMatchersAreInvalid() {\n+        mock.simpleMethod(CrazyMatchers.not(eq(\"asd\")));\n+        try {\n+            mock.simpleMethod(CrazyMatchers.not(\"jkl\"));\n+            fail();\n+        } catch (InvalidUseOfMatchersException e) {\n+            assertEquals(\n+                    \"\\n\" +\n+            \t\t\"No matchers found.\" +\n+            \t\t\"\\n\" +\n+                    \"Read more: http://code.google.com/p/mockito/matchers\"\n+            \t\t, e.getMessage());\n+        }\n+        \n+        try {\n+            mock.simpleMethod(CrazyMatchers.or(eq(\"jkl\"), \"asd\"));\n+            fail();\n+        } catch (InvalidUseOfMatchersException e) {\n+            assertEquals(\n+                    \"\\n\" +\n+            \t\t\"2 matchers expected, 1 recorded.\" +\n+                    \"\\n\" +\n+                    \"Read more: http://code.google.com/p/mockito/matchers\"\n+                    , e.getMessage());\n+        }\n+        \n+        try {\n+            mock.threeArgumentMethod(1, \"asd\", eq(\"asd\"));\n+            fail();\n+        } catch (InvalidUseOfMatchersException e) {\n+            assertEquals(\n+                    \"\\n\" +\n+                    \"3 matchers expected, 1 recorded.\" +\n+                    \"\\n\" +\n+                    \"Read more: http://code.google.com/p/mockito/matchers\"\n+                    , e.getMessage());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/matchers/MatchersTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.matchers;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.CrazyMatchers.*;\n+import static org.mockito.Matchers.*;\n+import static org.mockito.Mockito.stub;\n+\n+import java.math.BigDecimal;\n+import java.util.HashMap;\n+\n+import org.junit.*;\n+import org.mockito.*;\n+import org.mockitousage.IMethods;\n+\n+@SuppressWarnings(\"unchecked\")  \n+public class MatchersTest {\n+    private IMethods mock;\n+\n+    @Before\n+    public void setUp() {\n+        mock = Mockito.mock(IMethods.class);\n+    }\n+    \n+    @Test\n+    public void andOverloaded() {\n+        stub(mock.oneArg(and(eq(false), eq(false)))).andReturn(\"0\");\n+        stub(mock.oneArg(and(eq((byte) 1), eq((byte) 1)))).andReturn(\"1\");\n+        stub(mock.oneArg(and(eq('a'), eq('a')))).andReturn(\"2\");\n+        stub(mock.oneArg(and(eq((double) 1), eq((double) 1)))).andReturn(\"3\");\n+        stub(mock.oneArg(and(eq((float) 1), eq((float) 1)))).andReturn(\"4\");\n+        stub(mock.oneArg(and(eq((int) 1), eq((int) 1)))).andReturn(\"5\");\n+        stub(mock.oneArg(and(eq((long) 1), eq((long) 1)))).andReturn(\"6\");\n+        stub(mock.oneArg(and(eq((short) 1), eq((short) 1)))).andReturn(\"7\");\n+        stub(mock.oneArg(and(contains(\"a\"), contains(\"d\")))).andReturn(\"8\");\n+        stub(mock.oneArg(and(isA(Class.class), eq(Object.class)))).andReturn(\"9\");\n+\n+        assertEquals(\"0\", mock.oneArg(false));\n+        assertEquals(null, mock.oneArg(true));\n+        \n+        assertEquals(\"1\", mock.oneArg((byte) 1));\n+        assertEquals(\"2\", mock.oneArg('a'));\n+        assertEquals(\"3\", mock.oneArg((double) 1));\n+        assertEquals(\"4\", mock.oneArg((float) 1));\n+        assertEquals(\"5\", mock.oneArg((int) 1));\n+        assertEquals(\"6\", mock.oneArg((long) 1));\n+        assertEquals(\"7\", mock.oneArg((short) 1));\n+        \n+        assertEquals(\"8\", mock.oneArg(\"abcde\"));\n+        assertEquals(null, mock.oneArg(\"aaaaa\"));\n+        \n+        assertEquals(\"9\", mock.oneArg(Object.class));\n+        \n+    }\n+\n+    @Test\n+    public void orOverloaded() {\n+        stub(mock.oneArg(or(eq(false), eq(true)))).andReturn(\"0\");\n+        stub(mock.oneArg(CrazyMatchers.or(eq((byte) 1), eq((byte) 2)))).andReturn(\"1\");\n+        stub(mock.oneArg(CrazyMatchers.or(eq((char) 1), eq((char) 2)))).andReturn(\"2\");\n+        stub(mock.oneArg(CrazyMatchers.or(eq((double) 1), eq((double) 2)))).andReturn(\"3\");\n+        stub(mock.oneArg(CrazyMatchers.or(eq((float) 1), eq((float) 2)))).andReturn(\"4\");\n+        stub(mock.oneArg(CrazyMatchers.or(eq((int) 1), eq((int) 2)))).andReturn(\"5\");\n+        stub(mock.oneArg(CrazyMatchers.or(eq((long) 1), eq((long) 2)))).andReturn(\"6\");\n+        stub(mock.oneArg(CrazyMatchers.or(eq((short) 1), eq((short) 2)))).andReturn(\"7\");\n+        stub(mock.oneArg(CrazyMatchers.or(eq(\"asd\"), eq(\"jkl\")))).andReturn(\"8\");\n+        stub(mock.oneArg(CrazyMatchers.or(eq(this.getClass()), eq(Object.class)))).andReturn(\"9\");\n+\n+        assertEquals(\"0\", mock.oneArg(true));\n+        assertEquals(\"0\", mock.oneArg(false));\n+        \n+        assertEquals(\"1\", mock.oneArg((byte) 2));\n+        assertEquals(\"2\", mock.oneArg((char) 1));\n+        assertEquals(\"3\", mock.oneArg((double) 2));\n+        assertEquals(\"4\", mock.oneArg((float) 1));\n+        assertEquals(\"5\", mock.oneArg((int) 2));\n+        assertEquals(\"6\", mock.oneArg((long) 1));\n+        assertEquals(\"7\", mock.oneArg((short) 1));\n+        \n+        assertEquals(\"8\", mock.oneArg(\"jkl\"));\n+        assertEquals(\"8\", mock.oneArg(\"asd\"));\n+        assertEquals(null, mock.oneArg(\"asdjkl\"));\n+        \n+        assertEquals(\"9\", mock.oneArg(Object.class));\n+        assertEquals(null, mock.oneArg(String.class));\n+    }\n+\n+    @Test\n+    public void notOverloaded() {\n+        stub(mock.oneArg(CrazyMatchers.not(eq(false)))).andReturn(\"0\");\n+        stub(mock.oneArg(CrazyMatchers.not(eq((byte) 1)))).andReturn(\"1\");\n+        stub(mock.oneArg(CrazyMatchers.not(eq('a')))).andReturn(\"2\");\n+        stub(mock.oneArg(CrazyMatchers.not(eq((double) 1)))).andReturn(\"3\");\n+        stub(mock.oneArg(CrazyMatchers.not(eq((float) 1)))).andReturn(\"4\");\n+        stub(mock.oneArg(CrazyMatchers.not(eq((int) 1)))).andReturn(\"5\");\n+        stub(mock.oneArg(CrazyMatchers.not(eq((long) 1)))).andReturn(\"6\");\n+        stub(mock.oneArg(CrazyMatchers.not(eq((short) 1)))).andReturn(\"7\");\n+        stub(mock.oneArg(CrazyMatchers.not(contains(\"a\")))).andReturn(\"8\");\n+        stub(mock.oneArg(CrazyMatchers.not(isA(Class.class)))).andReturn(\"9\");\n+\n+        assertEquals(\"0\", mock.oneArg(true));\n+        assertEquals(null, mock.oneArg(false));\n+        \n+        assertEquals(\"1\", mock.oneArg((byte) 2));\n+        assertEquals(\"2\", mock.oneArg('b'));\n+        assertEquals(\"3\", mock.oneArg((double) 2));\n+        assertEquals(\"4\", mock.oneArg((float) 2));\n+        assertEquals(\"5\", mock.oneArg((int) 2));\n+        assertEquals(\"6\", mock.oneArg((long) 2));\n+        assertEquals(\"7\", mock.oneArg((short) 2));\n+        assertEquals(\"8\", mock.oneArg(\"bcde\"));\n+        \n+        assertEquals(\"9\", mock.oneArg(new Object()));\n+        assertEquals(null, mock.oneArg(Class.class));\n+    }\n+\n+    @Test\n+    public void lessOrEqualOverloaded() {\n+        stub(mock.oneArg(leq((byte) 1))).andReturn(\"1\");\n+        stub(mock.oneArg(leq((double) 1))).andReturn(\"3\");\n+        stub(mock.oneArg(leq((float) 1))).andReturn(\"4\");\n+        stub(mock.oneArg(leq((int) 1))).andReturn(\"5\");\n+        stub(mock.oneArg(leq((long) 1))).andReturn(\"6\");\n+        stub(mock.oneArg(leq((short) 1))).andReturn(\"7\");\n+        stub(mock.oneArg(leq(new BigDecimal(\"1\")))).andReturn(\"8\");\n+\n+        assertEquals(\"1\", mock.oneArg((byte) 1));\n+        assertEquals(null, mock.oneArg((byte) 2));\n+        \n+        assertEquals(\"3\", mock.oneArg((double) 1));\n+        assertEquals(\"7\", mock.oneArg((short) 0));\n+        assertEquals(\"4\", mock.oneArg((float) -5));\n+        assertEquals(\"5\", mock.oneArg((int) -2));\n+        assertEquals(\"6\", mock.oneArg((long) -3));\n+        \n+        assertEquals(\"8\", mock.oneArg(new BigDecimal(\"0.5\")));\n+        assertEquals(null, mock.oneArg(new BigDecimal(\"1.1\")));\n+    }\n+\n+    @Test\n+    public void lessThanOverloaded() {\n+        stub(mock.oneArg(lt((byte) 1))).andReturn(\"1\");\n+        stub(mock.oneArg(lt((double) 1))).andReturn(\"3\");\n+        stub(mock.oneArg(lt((float) 1))).andReturn(\"4\");\n+        stub(mock.oneArg(lt((int) 1))).andReturn(\"5\");\n+        stub(mock.oneArg(lt((long) 1))).andReturn(\"6\");\n+        stub(mock.oneArg(lt((short) 1))).andReturn(\"7\");\n+        stub(mock.oneArg(lt(new BigDecimal(\"1\")))).andReturn(\"8\");\n+\n+        assertEquals(\"1\", mock.oneArg((byte) 0));\n+        assertEquals(null, mock.oneArg((byte) 1));\n+        \n+        assertEquals(\"3\", mock.oneArg((double) 0));\n+        assertEquals(\"7\", mock.oneArg((short) 0));\n+        assertEquals(\"4\", mock.oneArg((float) -4));\n+        assertEquals(\"5\", mock.oneArg((int) -34));\n+        assertEquals(\"6\", mock.oneArg((long) -6));\n+        \n+        assertEquals(\"8\", mock.oneArg(new BigDecimal(\"0.5\")));\n+        assertEquals(null, mock.oneArg(new BigDecimal(\"23\")));\n+    }\n+\n+    @Test\n+    public void greaterOrEqualMatcherOverloaded() {\n+        stub(mock.oneArg(geq((byte) 1))).andReturn(\"1\");\n+        stub(mock.oneArg(geq((double) 1))).andReturn(\"3\");\n+        stub(mock.oneArg(geq((float) 1))).andReturn(\"4\");\n+        stub(mock.oneArg(geq((int) 1))).andReturn(\"5\");\n+        stub(mock.oneArg(geq((long) 1))).andReturn(\"6\");\n+        stub(mock.oneArg(geq((short) 1))).andReturn(\"7\");\n+        stub(mock.oneArg(geq(new BigDecimal(\"1\")))).andReturn(\"8\");\n+\n+        assertEquals(\"1\", mock.oneArg((byte) 2));\n+        assertEquals(null, mock.oneArg((byte) 0));\n+        \n+        assertEquals(\"3\", mock.oneArg((double) 1));\n+        assertEquals(\"7\", mock.oneArg((short) 2));\n+        assertEquals(\"4\", mock.oneArg((float) 3));\n+        assertEquals(\"5\", mock.oneArg((int) 4));\n+        assertEquals(\"6\", mock.oneArg((long) 5));\n+        \n+        assertEquals(\"8\", mock.oneArg(new BigDecimal(\"1.00\")));\n+        assertEquals(null, mock.oneArg(new BigDecimal(\"0.9\")));\n+    }\n+\n+    @Test\n+    public void greaterThanMatcherOverloaded() {\n+        stub(mock.oneArg(gt((byte) 1))).andReturn(\"1\");\n+        stub(mock.oneArg(gt((double) 1))).andReturn(\"3\");\n+        stub(mock.oneArg(gt((float) 1))).andReturn(\"4\");\n+        stub(mock.oneArg(gt((int) 1))).andReturn(\"5\");\n+        stub(mock.oneArg(gt((long) 1))).andReturn(\"6\");\n+        stub(mock.oneArg(gt((short) 1))).andReturn(\"7\");\n+        stub(mock.oneArg(gt(new BigDecimal(\"1\")))).andReturn(\"8\");\n+\n+        assertEquals(\"1\", mock.oneArg((byte) 2));\n+        assertEquals(null, mock.oneArg((byte) 1));\n+        \n+        assertEquals(\"3\", mock.oneArg((double) 2));\n+        assertEquals(\"7\", mock.oneArg((short) 2));\n+        assertEquals(\"4\", mock.oneArg((float) 3));\n+        assertEquals(\"5\", mock.oneArg((int) 2));\n+        assertEquals(\"6\", mock.oneArg((long) 5));\n+        \n+        assertEquals(\"8\", mock.oneArg(new BigDecimal(\"1.5\")));\n+        assertEquals(null, mock.oneArg(new BigDecimal(\"0.9\")));\n+    }\n+\n+    @Test\n+    public void compareToMatcher() {\n+        stub(mock.oneArg(CrazyMatchers.cmpEq(new BigDecimal(\"1.5\")))).andReturn(\"0\");\n+\n+        assertEquals(\"0\", mock.oneArg(new BigDecimal(\"1.50\")));\n+        assertEquals(null, mock.oneArg(new BigDecimal(\"1.51\")));\n+    }\n+\n+    @Test\n+    public void anyMatcher() {\n+        stub(mock.oneArg(anyBoolean())).andReturn(\"0\");\n+        stub(mock.oneArg(anyByte())).andReturn(\"1\");\n+        stub(mock.oneArg(anyChar())).andReturn(\"2\");\n+        stub(mock.oneArg(anyDouble())).andReturn(\"3\");\n+        stub(mock.oneArg(anyFloat())).andReturn(\"4\");\n+        stub(mock.oneArg(anyInt())).andReturn(\"5\");\n+        stub(mock.oneArg(anyLong())).andReturn(\"6\");\n+        stub(mock.oneArg(anyShort())).andReturn(\"7\");\n+        stub(mock.oneArg((String) anyObject())).andReturn(\"8\");\n+        stub(mock.oneArg(anyObject())).andReturn(\"9\");\n+\n+        assertEquals(\"0\", mock.oneArg(true));\n+        assertEquals(\"0\", mock.oneArg(false));\n+        \n+        assertEquals(\"1\", mock.oneArg((byte) 1));\n+        assertEquals(\"2\", mock.oneArg((char) 1));\n+        assertEquals(\"3\", mock.oneArg((double) 1));\n+        assertEquals(\"4\", mock.oneArg((float) 889));\n+        assertEquals(\"5\", mock.oneArg((int) 1));\n+        assertEquals(\"6\", mock.oneArg((long) 1));\n+        assertEquals(\"7\", mock.oneArg((short) 1));\n+        assertEquals(\"8\", mock.oneArg(\"Test\"));\n+        \n+        assertEquals(\"9\", mock.oneArg(new Object()));\n+        assertEquals(\"9\", mock.oneArg(new HashMap()));\n+    }\n+\n+    @Test\n+    public void arrayEqualsMatcher() {\n+        stub(mock.oneArray(CrazyMatchers.aryEq(new boolean[] { true, false, false }))).andReturn(\"0\");\n+        stub(mock.oneArray(CrazyMatchers.aryEq(new byte[] { 1 }))).andReturn(\"1\");\n+        stub(mock.oneArray(CrazyMatchers.aryEq(new char[] { 1 }))).andReturn(\"2\");\n+        stub(mock.oneArray(CrazyMatchers.aryEq(new double[] { 1 }))).andReturn(\"3\");\n+        stub(mock.oneArray(CrazyMatchers.aryEq(new float[] { 1 }))).andReturn(\"4\");\n+        stub(mock.oneArray(CrazyMatchers.aryEq(new int[] { 1 }))).andReturn(\"5\");\n+        stub(mock.oneArray(CrazyMatchers.aryEq(new long[] { 1 }))).andReturn(\"6\");\n+        stub(mock.oneArray(CrazyMatchers.aryEq(new short[] { 1 }))).andReturn(\"7\");\n+        stub(mock.oneArray(CrazyMatchers.aryEq(new String[] { \"Test\" }))).andReturn(\"8\");\n+        stub(mock.oneArray(CrazyMatchers.aryEq(new Object[] { \"Test\", new Integer(4) }))).andReturn(\"9\");\n+\n+        assertEquals(\"0\", mock.oneArray(new boolean[] { true, false, false }));\n+        assertEquals(\"1\", mock.oneArray(new byte[] { 1 }));\n+        assertEquals(\"2\", mock.oneArray(new char[] { 1 }));\n+        assertEquals(\"3\", mock.oneArray(new double[] { 1 }));\n+        assertEquals(\"4\", mock.oneArray(new float[] { 1 }));\n+        assertEquals(\"5\", mock.oneArray(new int[] { 1 }));\n+        assertEquals(\"6\", mock.oneArray(new long[] { 1 }));\n+        assertEquals(\"7\", mock.oneArray(new short[] { 1 }));\n+        assertEquals(\"8\", mock.oneArray(new String[] { \"Test\" }));\n+        assertEquals(\"9\", mock.oneArray(new Object[] { \"Test\", new Integer(4) }));\n+        \n+        assertEquals(null, mock.oneArray(new Object[] { \"Test\", new Integer(999) }));\n+        assertEquals(null, mock.oneArray(new Object[] { \"Test\", new Integer(4), \"x\" }));\n+        \n+        assertEquals(null, mock.oneArray(new boolean[] { true, false }));\n+        assertEquals(null, mock.oneArray(new boolean[] { true, true, false }));\n+    }\n+\n+    @Test\n+    public void greaterOrEqualMatcher() {\n+        stub(mock.oneArg(geq(7))).andReturn(\">= 7\");\n+        stub(mock.oneArg(lt(7))).andReturn(\"< 7\");\n+\n+        assertEquals(\">= 7\", mock.oneArg(7));\n+        assertEquals(\">= 7\", mock.oneArg(8));\n+        assertEquals(\">= 7\", mock.oneArg(9));\n+\n+        assertEquals(\"< 7\", mock.oneArg(6));\n+        assertEquals(\"< 7\", mock.oneArg(6));\n+    }\n+\n+    @Test\n+    public void greaterThanMatcher() {\n+        stub(mock.oneArg(gt(7))).andReturn(\"> 7\");\n+        stub(mock.oneArg(leq(7))).andReturn(\"<= 7\");\n+\n+        assertEquals(\"> 7\", mock.oneArg(8));\n+        assertEquals(\"> 7\", mock.oneArg(9));\n+        assertEquals(\"> 7\", mock.oneArg(10));\n+\n+        assertEquals(\"<= 7\", mock.oneArg(7));\n+        assertEquals(\"<= 7\", mock.oneArg(6));\n+    }\n+\n+    @Test\n+    public void lessOrEqualMatcher() {\n+        stub(mock.oneArg(leq(7))).andReturn(\"<= 7\");\n+        stub(mock.oneArg(gt(7))).andReturn(\"> 7\");\n+\n+        assertEquals(\"<= 7\", mock.oneArg(7));\n+        assertEquals(\"<= 7\", mock.oneArg(6));\n+        assertEquals(\"<= 7\", mock.oneArg(5));\n+\n+        assertEquals(\"> 7\", mock.oneArg(8));\n+        assertEquals(\"> 7\", mock.oneArg(9));\n+    }\n+\n+    @Test\n+    public void lessThanMatcher() {\n+        stub(mock.oneArg(lt(7))).andReturn(\"< 7\");\n+        stub(mock.oneArg(geq(7))).andReturn(\">= 7\");\n+\n+        assertEquals(\"< 7\", mock.oneArg(5));\n+        assertEquals(\"< 7\", mock.oneArg(6));\n+        assertEquals(\"< 7\", mock.oneArg(4));\n+\n+        assertEquals(\">= 7\", mock.oneArg(7));\n+        assertEquals(\">= 7\", mock.oneArg(8));\n+    }\n+\n+    @Test\n+    public void orMatcher() {\n+        stub(mock.oneArg(anyInt())).andReturn(\"other\");\n+        stub(mock.oneArg(CrazyMatchers.or(eq(7), eq(9)))).andReturn(\"7 or 9\");\n+\n+        assertEquals(\"other\", mock.oneArg(10));\n+        assertEquals(\"7 or 9\", mock.oneArg(7));\n+        assertEquals(\"7 or 9\", mock.oneArg(9));\n+    }\n+\n+    @Test\n+    public void nullMatcher() {\n+        stub(mock.threeArgumentMethod(eq(1), isNull(), eq(\"\"))).andReturn(\"1\");\n+        stub(mock.threeArgumentMethod(eq(1), CrazyMatchers.not(isNull()), eq(\"\"))).andReturn(\"2\");\n+\n+        assertEquals(\"1\", mock.threeArgumentMethod(1, null, \"\"));\n+        assertEquals(\"2\", mock.threeArgumentMethod(1, new Object(), \"\"));\n+    }\n+\n+    @Test\n+    public void notNullMatcher() {\n+        stub(mock.threeArgumentMethod(eq(1), notNull(), eq(\"\"))).andReturn(\"1\");\n+        stub(mock.threeArgumentMethod(eq(1), CrazyMatchers.not(notNull()), eq(\"\"))).andReturn(\"2\");\n+\n+        assertEquals(\"1\", mock.threeArgumentMethod(1, new Object(), \"\"));\n+        assertEquals(\"2\", mock.threeArgumentMethod(1, null, \"\"));\n+    }\n+\n+    @Test\n+    public void findMatcher() {\n+        stub(mock.oneArg(CrazyMatchers.find(\"([a-z]+)\\\\d\"))).andReturn(\"1\");\n+\n+        assertEquals(\"1\", mock.oneArg(\"ab12\"));\n+        assertEquals(null, mock.oneArg(\"12345\"));\n+    }\n+    \n+    @Test\n+    public void matchesMatcher() {\n+        stub(mock.oneArg(matches(\"[a-z]+\\\\d\\\\d\"))).andReturn(\"1\");\n+        stub(mock.oneArg(matches(\"\\\\d\\\\d\\\\d\"))).andReturn(\"2\");\n+\n+        assertEquals(\"1\", mock.oneArg(\"a12\"));\n+        assertEquals(\"2\", mock.oneArg(\"131\"));\n+        assertEquals(null, mock.oneArg(\"blah\"));\n+    }\n+\n+    @Test\n+    public void containsMatcher() {\n+        stub(mock.oneArg(contains(\"ell\"))).andReturn(\"1\");\n+        stub(mock.oneArg(contains(\"ld\"))).andReturn(\"2\");\n+\n+        assertEquals(\"1\", mock.oneArg(\"hello\"));\n+        assertEquals(\"2\", mock.oneArg(\"world\"));\n+        assertEquals(null, mock.oneArg(\"xlx\"));\n+    }\n+\n+    @Test\n+    public void startsWithMatcher() {\n+        stub(mock.oneArg(CrazyMatchers.startsWith(\"ab\"))).andReturn(\"1\");\n+        stub(mock.oneArg(CrazyMatchers.startsWith(\"bc\"))).andReturn(\"2\");\n+\n+        assertEquals(\"1\", mock.oneArg(\"ab quake\"));\n+        assertEquals(\"2\", mock.oneArg(\"bc quake\"));\n+        assertEquals(null, mock.oneArg(\"ba quake\"));\n+    }\n+\n+    @Test\n+    public void endsWithMatcher() {\n+        stub(mock.oneArg(CrazyMatchers.endsWith(\"ab\"))).andReturn(\"1\");\n+        stub(mock.oneArg(CrazyMatchers.endsWith(\"bc\"))).andReturn(\"2\");\n+\n+        assertEquals(\"1\", mock.oneArg(\"xab\"));\n+        assertEquals(\"2\", mock.oneArg(\"xbc\"));\n+        assertEquals(null, mock.oneArg(\"ac\"));\n+    }\n+\n+    @Test\n+    public void deltaMatcher() {\n+        stub(mock.oneArg(eq(1.0D, 0.1D))).andReturn(\"1\");\n+        stub(mock.oneArg(eq(2.0D, 0.1D))).andReturn(\"2\");\n+        stub(mock.oneArg(eq(1.0F, 0.1F))).andReturn(\"3\");\n+        stub(mock.oneArg(eq(2.0F, 0.1F))).andReturn(\"4\");\n+        stub(mock.oneArg(eq(2.0F, 0.1F))).andReturn(\"4\");\n+\n+        assertEquals(\"1\", mock.oneArg(1.0));\n+        assertEquals(\"1\", mock.oneArg(0.91));\n+        assertEquals(\"1\", mock.oneArg(1.09));\n+        assertEquals(\"2\", mock.oneArg(2.0));\n+\n+        assertEquals(\"3\", mock.oneArg(1.0F));\n+        assertEquals(\"3\", mock.oneArg(0.91F));\n+        assertEquals(\"3\", mock.oneArg(1.09F));\n+        assertEquals(\"4\", mock.oneArg(2.1F));\n+        \n+        assertEquals(null, mock.oneArg(2.2F));\n+    }\n+\n+    @Test\n+    public void sameMatcher() {\n+        Object one = new String(\"1243\");\n+        Object two = new String(\"1243\");\n+        Object three = new String(\"1243\");\n+\n+        assertNotSame(one, two);\n+        assertEquals(one, two);\n+        assertEquals(two, three);\n+\n+        stub(mock.oneArg(CrazyMatchers.same(one))).andReturn(\"1\");\n+        stub(mock.oneArg(CrazyMatchers.same(two))).andReturn(\"2\");\n+\n+        assertEquals(\"1\", mock.oneArg(one));\n+        assertEquals(\"2\", mock.oneArg(two));\n+        assertEquals(null, mock.oneArg(three));\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/matchers/MatchersToStringTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.matchers;\n+\n+import static org.junit.Assert.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.internal.matchers.*;\n+\n+public class MatchersToStringTest {\n+    private StringBuffer buffer;\n+\n+    @Before\n+    public void setup() {\n+        buffer = new StringBuffer();\n+    }\n+\n+    @Test\n+    public void sameToStringWithString() {\n+        new Same(\"X\").appendTo(buffer);\n+        assertEquals(\"same(\\\"X\\\")\", buffer.toString());\n+\n+    }\n+\n+    @Test\n+    public void nullToString() {\n+        Null.NULL.appendTo(buffer);\n+        assertEquals(\"isNull()\", buffer.toString());\n+    }\n+\n+    @Test\n+    public void notNullToString() {\n+        NotNull.NOT_NULL.appendTo(buffer);\n+        assertEquals(\"notNull()\", buffer.toString());\n+    }\n+\n+    @Test\n+    public void anyToString() {\n+        Any.ANY.appendTo(buffer);\n+        assertEquals(\"<any>\", buffer.toString());\n+    }\n+\n+    @Test\n+    public void sameToStringWithChar() {\n+        new Same('x').appendTo(buffer);\n+        assertEquals(\"same('x')\", buffer.toString());\n+    }\n+\n+    @Test\n+    public void sameToStringWithObject() {\n+        Object o = new Object() {\n+            @Override\n+            public String toString() {\n+                return \"X\";\n+            }\n+        };\n+        new Same(o).appendTo(buffer);\n+        assertEquals(\"same(X)\", buffer.toString());\n+    }\n+\n+    @Test\n+    public void equalsToStringWithString() {\n+        new Equals(\"X\").appendTo(buffer);\n+        assertEquals(\"\\\"X\\\"\", buffer.toString());\n+\n+    }\n+\n+    @Test\n+    public void equalsToStringWithChar() {\n+        new Equals('x').appendTo(buffer);\n+        assertEquals(\"'x'\", buffer.toString());\n+    }\n+\n+    @Test\n+    public void equalsToStringWithObject() {\n+        Object o = new Object() {\n+            @Override\n+            public String toString() {\n+                return \"X\";\n+            }\n+        };\n+        new Equals(o).appendTo(buffer);\n+        assertEquals(\"X\", buffer.toString());\n+    }\n+\n+    @Test\n+    public void orToString() {\n+        List<IArgumentMatcher> matchers = new ArrayList<IArgumentMatcher>();\n+        matchers.add(new Equals(1));\n+        matchers.add(new Equals(2));\n+        new Or(matchers).appendTo(buffer);\n+        assertEquals(\"or(1, 2)\", buffer.toString());\n+    }\n+\n+    @Test\n+    public void notToString() {\n+        new Not(new Equals(1)).appendTo(buffer);\n+        assertEquals(\"not(1)\", buffer.toString());\n+    }\n+\n+    @Test\n+    public void andToString() {\n+        List<IArgumentMatcher> matchers = new ArrayList<IArgumentMatcher>();\n+        matchers.add(new Equals(1));\n+        matchers.add(new Equals(2));\n+        new And(matchers).appendTo(buffer);\n+        assertEquals(\"and(1, 2)\", buffer.toString());\n+    }\n+\n+    @Test\n+    public void startsWithToString() {\n+        new StartsWith(\"AB\").appendTo(buffer);\n+        assertEquals(\"startsWith(\\\"AB\\\")\", buffer.toString());\n+    }\n+\n+    @Test\n+    public void endsWithToString() {\n+        new EndsWith(\"AB\").appendTo(buffer);\n+        assertEquals(\"endsWith(\\\"AB\\\")\", buffer.toString());\n+    }\n+\n+    @Test\n+    public void containsToString() {\n+        new Contains(\"AB\").appendTo(buffer);\n+        assertEquals(\"contains(\\\"AB\\\")\", buffer.toString());\n+    }\n+\n+    @Test\n+    public void findToString() {\n+        new Find(\"\\\\s+\").appendTo(buffer);\n+        assertEquals(\"find(\\\"\\\\\\\\s+\\\")\", buffer.toString());\n+    }\n+\n+    @Test\n+    public void matchesToString() {\n+        new Matches(\"\\\\s+\").appendTo(buffer);\n+        assertEquals(\"matches(\\\"\\\\\\\\s+\\\")\", buffer.toString());\n+    }\n+\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/stubbing/BasicStubbingTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.stubbing;\n+\n+import static org.hamcrest.CoreMatchers.equalTo;\n+import static org.junit.Assert.*;\n+import static org.mockito.util.ExtraMatchers.collectionContaining;\n+\n+import java.util.*;\n+\n+import org.junit.*;\n+import org.mockito.Mockito;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class BasicStubbingTest {\n+\n+    private DummyInterface mock;\n+\n+    @Before\n+    public void setup() {\n+        mock = Mockito.mock(DummyInterface.class);\n+    }\n+    \n+    private interface DummyInterface {\n+        int getInt(String value);\n+        String getString(int argumentOne, String argumentTwo);\n+        List<String> getList();\n+    }\n+    \n+    @Test\n+    public void shouldStubAllMethodsByDefault() throws Exception {\n+        assertEquals(0, mock.getInt(\"test\"));\n+        assertEquals(0, mock.getInt(\"testTwo\"));\n+        \n+        assertNull(mock.getString(0, null));\n+        assertNull(mock.getString(100, null));\n+        \n+        assertEquals(0, mock.getList().size());\n+        assertEquals(0, mock.getList().size());\n+    }\n+    \n+    @Test\n+    public void shouldStubAndLetBeCalledAnyTimes() throws Exception {\n+        Mockito.stub(mock.getInt(\"14\")).andReturn(14);\n+        \n+        assertThat(mock.getInt(\"14\"), equalTo(14));\n+        assertThat(mock.getInt(\"14\"), equalTo(14));\n+        \n+        Mockito.stub(mock.getList()).andReturn(Arrays.asList(\"elementOne\", \"elementTwo\"));\n+        \n+        assertThat(mock.getList(), collectionContaining(\"elementOne\", \"elementTwo\"));\n+        assertThat(mock.getList(), collectionContaining(\"elementOne\", \"elementTwo\"));\n+        \n+        Mockito.stub(mock.getString(10, \"test\")).andReturn(\"test\");\n+        \n+        assertThat(mock.getString(10, \"test\"), equalTo(\"test\"));\n+        assertThat(mock.getString(10, \"test\"), equalTo(\"test\"));\n+    }\n+    \n+    @Test\n+    public void shouldEvaluateLatestStubbingFirst() throws Exception {\n+        Mockito.stub(mock.getInt(Mockito.anyString())).andReturn(100);\n+        Mockito.stub(mock.getInt(\"200 please\")).andReturn(200);\n+        \n+        assertEquals(200, mock.getInt(\"200 please\"));\n+        assertEquals(100, mock.getInt(\"any\"));\n+        assertEquals(\"default behavior should return 0\", 0, mock.getInt(null));\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/stubbing/ReturningDefaultValuesTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.stubbing;\n+\n+import static org.junit.Assert.*;\n+\n+import java.util.*;\n+\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.mockitousage.IMethods;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class ReturningDefaultValuesTest {\n+\n+    @Test\n+    public void shouldReturnAllKindsOfPrimitives() throws Exception {\n+        IMethods mock = Mockito.mock(IMethods.class);\n+\n+        //this is mainly to prove that cglib-enchanted-thing works properly \n+        //and returns primitive value rather than throw NullPointerException\n+        //If we used java.lang.reflect.Proxy NullPointerException will bang\n+        assertEquals((byte)0, mock.byteReturningMethod(12));\n+        assertEquals((short)0, mock.shortReturningMethod(12));\n+        assertEquals(0, mock.intReturningMethod(12));\n+        assertEquals(0L, mock.intReturningMethod(12));\n+        assertEquals(0.0F, mock.floatReturningMethod(12), 0.0F);\n+        assertEquals(0.0D, mock.doubleReturningMethod(12), 0.0D);\n+        assertEquals('\\u0000', mock.charReturningMethod(12));\n+        assertEquals(false, mock.booleanReturningMethod(12));\n+        assertEquals(null, mock.objectReturningMethod(12));\n+    }\n+    \n+    @Test \n+    public void shouldReturnEmptyCollections() {\n+        CollectionsServer mock = Mockito.mock(CollectionsServer.class);\n+        \n+        assertTrue(mock.list().isEmpty());\n+        assertTrue(mock.linkedList().isEmpty());\n+        assertTrue(mock.map().isEmpty());\n+        assertTrue(mock.hashSet().isEmpty());\n+    }\n+\n+    private class CollectionsServer {\n+        List list() {\n+            return null;\n+        }\n+\n+        LinkedList linkedList() {\n+            return null;\n+        }\n+\n+        Map map() {\n+            return null;\n+        }\n+\n+        java.util.HashSet hashSet() {\n+            return null;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/stubbing/StubbingWithThrowablesTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.stubbing;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+import static org.mockito.util.ExtraMatchers.firstMethodOnStackEqualsTo;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import org.junit.*;\n+import org.mockito.exceptions.MockitoException;\n+\n+@SuppressWarnings({\"serial\", \"unchecked\"})\n+public class StubbingWithThrowablesTest {\n+\n+    private LinkedList mock;\n+    private Map mockTwo;\n+\n+    @Before \n+    public void setup() {\n+        mock = mock(LinkedList.class);\n+        mockTwo = mock(HashMap.class);\n+    }\n+    \n+    @Test\n+    public void shouldStubWithThrowable() throws Exception {\n+        IllegalArgumentException expected = new IllegalArgumentException(\"thrown by mock\");\n+        stub(mock.add(\"throw\")).andThrows(expected);\n+        \n+        try {\n+            mock.add(\"throw\");\n+            fail();\n+        } catch (IllegalArgumentException e) {\n+            assertEquals(expected, e);\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldSetThrowableToVoidMethod() throws Exception {\n+        IllegalArgumentException expected = new IllegalArgumentException(\"thrown by mock\");\n+        \n+        stubVoid(mock).toThrow(expected).on().clear();\n+        try {\n+            mock.clear();\n+            fail();\n+        } catch (Exception e) {\n+            assertEquals(expected, e);\n+        }\n+    } \n+    \n+    @Test\n+    public void shouldLastStubbingVoidBeImportant() throws Exception {\n+        stubVoid(mock).toThrow(new ExceptionOne()).on().clear();\n+        stubVoid(mock).toThrow(new ExceptionTwo()).on().clear();\n+        \n+        try {\n+            mock.clear();\n+            fail();\n+        } catch (ExceptionTwo e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailStubbingThrowableOnTheSameInvocationDueToAcceptableLimitation() throws Exception {\n+        stub(mock.get(1)).andThrows(new ExceptionOne());\n+        \n+        try {\n+            stub(mock.get(1)).andThrows(new ExceptionTwo());\n+            fail();\n+        } catch (ExceptionOne e) {}\n+    }   \n+    \n+    @Test\n+    public void shouldAllowSettingCheckedException() throws Exception {\n+        Reader reader = mock(Reader.class);\n+        IOException ioException = new IOException();\n+        \n+        stub(reader.read()).andThrows(ioException);\n+        \n+        try {\n+            reader.read();\n+            fail();\n+        } catch (Exception e) {\n+            assertEquals(ioException, e);\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldAllowSettingError() throws Exception {\n+        Error error = new Error();\n+        \n+        stub(mock.add(\"quake\")).andThrows(error);\n+        \n+        try {\n+            mock.add(\"quake\");\n+            fail();\n+        } catch (Error e) {\n+            assertEquals(error, e);\n+        }\n+    }    \n+    \n+    @Test(expected=MockitoException.class)\n+    public void shouldNotAllowSettingInvalidCheckedException() throws Exception {\n+        stub(mock.add(\"monkey island\")).andThrows(new Exception());\n+    }\n+    \n+    @Test(expected=MockitoException.class)\n+    public void shouldNotAllowSettingNullThrowable() throws Exception {\n+        stub(mock.add(\"monkey island\")).andThrows(null);\n+    }    \n+    \n+    @Test\n+    public void shouldMixThrowablesAndReturnValuesOnDifferentMocks() throws Exception {\n+        stub(mock.add(\"ExceptionOne\")).andThrows(new ExceptionOne());\n+        stub(mock.getLast()).andReturn(\"last\");\n+        stubVoid(mock).toThrow(new ExceptionTwo()).on().clear();\n+        \n+        stubVoid(mockTwo).toThrow(new ExceptionThree()).on().clear();\n+        stub(mockTwo.containsValue(\"ExceptionFour\")).andThrows(new ExceptionFour());\n+        stub(mockTwo.get(\"Are you there?\")).andReturn(\"Yes!\");\n+\n+        assertNull(mockTwo.get(\"foo\"));\n+        assertTrue(mockTwo.keySet().isEmpty());\n+        assertEquals(\"Yes!\", mockTwo.get(\"Are you there?\"));\n+        try {\n+            mockTwo.clear();\n+        } catch (ExceptionThree e) {}\n+        try {\n+            mockTwo.containsKey(\"ExceptionFour\");\n+        } catch (ExceptionFour e) {}\n+        \n+        assertNull(mock.getFirst());\n+        assertEquals(\"last\", mock.getLast());\n+        try {\n+            mock.add(\"ExceptionOne\");\n+        } catch (ExceptionOne e) {}\n+        try {\n+            mock.clear();\n+        } catch (ExceptionTwo e) {}\n+    }\n+    \n+    @Ignore\n+    @Test\n+    public void shouldDoTheStackTraceProperly() throws Exception {\n+        stub(mock.add(\"ExceptionOne\")).andThrows(new ExceptionOne());\n+\n+        try {\n+            addObjectToMockedList(\"ExceptionOne\");\n+            fail();\n+        } catch (ExceptionOne e) {\n+            assertThat(e, firstMethodOnStackEqualsTo(\"addObjectToMockedList\"));\n+        }\n+    }\n+    \n+    private void addObjectToMockedList(String string) {\n+        mock.add(\"ExceptionOne\");\n+    }\n+\n+    @Ignore\n+    @Test\n+    public void shouldVerifyWhenStubbedWithThrowable() throws Exception {\n+        \n+    }\n+    \n+    private class ExceptionOne extends RuntimeException {};\n+    private class ExceptionTwo extends RuntimeException {};\n+    private class ExceptionThree extends RuntimeException {};\n+    private class ExceptionFour extends RuntimeException {};\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/verification/AtLeastOnceVerificationTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.verification;\n+\n+import static org.mockito.Mockito.*;\n+import static org.junit.Assert.*;\n+\n+import java.util.List;\n+\n+import org.junit.*;\n+import org.mockito.Mockito;\n+import org.mockito.exceptions.VerificationError;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class AtLeastOnceVerificationTest {\n+\n+    private List mock;\n+    private List mockTwo;\n+    \n+    @Before public void setup() {\n+        mock = Mockito.mock(List.class);\n+        mockTwo = Mockito.mock(List.class);\n+    }\n+\n+    @Test\n+    public void shouldVerifyAtLeastOnce() throws Exception {\n+        mock.clear();\n+        mock.clear();\n+        \n+        mockTwo.add(\"add\");\n+\n+        verify(mock, atLeastOnce()).clear();\n+        verify(mockTwo, atLeastOnce()).add(\"add\");\n+        try {\n+            verify(mockTwo, atLeastOnce()).add(\"foo\");\n+            fail();\n+        } catch (VerificationError e) {}\n+    }\n+    \n+    @Test(expected=VerificationError.class)\n+    public void shouldFailIfMethodWasNotCalledAtAll() throws Exception {\n+        verify(mock, atLeastOnce()).add(\"foo\");\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/verification/BasicVerificationTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.verification;\n+\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.*;\n+\n+import java.util.*;\n+\n+import org.junit.*;\n+import org.mockito.Mockito;\n+import org.mockito.exceptions.*;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class BasicVerificationTest {\n+\n+    private List mock;\n+    private List mockTwo;\n+    \n+    @Before \n+    public void setup() {\n+        mock = Mockito.mock(List.class);\n+        mockTwo = Mockito.mock(List.class);\n+    }\n+\n+    @Test\n+    public void shouldVerify() throws Exception {\n+        mock.clear();\n+        verify(mock).clear();\n+\n+        mock.add(\"test\");\n+        verify(mock).add(\"test\");\n+\n+        verifyNoMoreInteractions(mock);\n+    }\n+\n+    @Test(expected=VerificationError.class)\n+    public void shouldFailVerification() throws Exception {\n+        verify(mock).clear();\n+    }\n+\n+    @Test\n+    public void shouldFailVerificationOnMethodArgument() throws Exception {\n+        mock.clear();\n+        mock.add(\"foo\");\n+\n+        verify(mock).clear();\n+        try {\n+            verify(mock).add(\"bar\");\n+            fail();\n+        } catch (VerificationError expected) {};\n+    }\n+\n+    @Test\n+    public void shouldFailOnWrongMethod() throws Exception {\n+        mock.clear();\n+        mock.clear();\n+        \n+        mockTwo.add(\"add\");\n+\n+        verify(mock, atLeastOnce()).clear();\n+        verify(mockTwo, atLeastOnce()).add(\"add\");\n+        try {\n+            verify(mockTwo, atLeastOnce()).add(\"foo\");\n+            fail();\n+        } catch (VerificationError e) {}\n+    }\n+\n+    @Test\n+    public void shouldDetectRedundantInvocation() throws Exception {\n+        mock.clear();\n+        mock.add(\"foo\");\n+        mock.add(\"bar\");\n+\n+        verify(mock).clear();\n+        verify(mock).add(\"foo\");\n+\n+        try {\n+            verifyNoMoreInteractions(mock);\n+            fail();\n+        } catch (VerificationError expected) {};\n+    }\n+    \n+    @Test\n+    public void shouldDetectWhenInvokedMoreThanOnce() throws Exception {\n+        mock.add(\"foo\");\n+        mock.clear();\n+        mock.clear();\n+        \n+        verify(mock).add(\"foo\");\n+\n+        try {\n+            verify(mock).clear();\n+            fail();\n+        } catch (NumberOfInvocationsError e) {};\n+    }\n+\n+    @Test\n+    public void shouldVerifyStubbedMethods() throws Exception {\n+        stub(mock.add(\"test\")).andReturn(Boolean.FALSE);\n+        \n+        mock.add(\"test\");\n+        \n+        verify(mock).add(\"test\");\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/verification/ExactNumberOfTimesVerificationTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.verification;\n+\n+import static org.junit.Assert.*;\n+\n+import java.util.LinkedList;\n+\n+import org.junit.*;\n+import org.mockito.Mockito;\n+import org.mockito.exceptions.NumberOfInvocationsError;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class ExactNumberOfTimesVerificationTest {\n+\n+    private LinkedList mock;\n+    \n+    @Before\n+    public void setup() {\n+        mock = Mockito.mock(LinkedList.class); \n+    }\n+    \n+    @Test\n+    public void shouldVerifyActualNumberOfInvocationsSmallerThanWanted() throws Exception {\n+        mock.clear();\n+        mock.clear();\n+        mock.clear();\n+\n+        Mockito.verify(mock, 3).clear();\n+        try {\n+            Mockito.verify(mock, 100).clear();\n+            fail();\n+        } catch (NumberOfInvocationsError e) {\n+            String expected = \n+                \"\\n\" +\n+                \"LinkedList.clear()\" +\n+        \t\t\"\\n\" +\n+        \t\t\"Wanted 100 times but was 3\";\n+            assertEquals(expected, e.getMessage());\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldVerifyActualNumberOfInvocationsLargerThanWanted() throws Exception {\n+        mock.clear();\n+        mock.clear();\n+        mock.clear();\n+\n+        Mockito.verify(mock, 3).clear();\n+        try {\n+            Mockito.verify(mock, 1).clear();\n+            fail();\n+        } catch (NumberOfInvocationsError e) {\n+            String expected = \n+                \"\\n\" +\n+                \"LinkedList.clear()\" +\n+                \"\\n\" +\n+                \"Wanted 1 time but was 3\";\n+            assertEquals(expected, e.getMessage());\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldVerifyProperlyIfMethodWasNotInvoked() throws Exception {\n+        Mockito.verify(mock, 0).clear();\n+        try {\n+            Mockito.verify(mock, 15).clear();\n+            fail();\n+        } catch (NumberOfInvocationsError e) {\n+            assertTrue(e.getMessage().endsWith(\"Wanted 15 times but was 0\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldVerifyProperlyIfMethodWasInvokedOnce() throws Exception {\n+        mock.clear();\n+        \n+        Mockito.verify(mock, 1).clear();\n+        try {\n+            Mockito.verify(mock, 15).clear();\n+            fail();\n+        } catch (NumberOfInvocationsError e) {\n+            assertTrue(e.getMessage().endsWith(\"Wanted 15 times but was 1\"));\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldFailWhenWantedNumberOfInvocationIsZero() throws Exception {\n+        mock.clear();\n+        \n+        try {\n+            Mockito.verify(mock, 0).clear();\n+            fail();\n+        } catch (NumberOfInvocationsError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldVerifyWhenWantedNumberOfInvocationIsZero() throws Exception {\n+        Mockito.verify(mock, 0).clear();\n+    }\n+    \n+    @Test\n+    public void shouldNotCountInStubbedInvocations() throws Exception {\n+        Mockito.stub(mock.add(\"test\")).andReturn(false);\n+        Mockito.stub(mock.add(\"test\")).andReturn(true);\n+        \n+        mock.add(\"test\");\n+        mock.add(\"test\");\n+        \n+        Mockito.verify(mock, 2).add(\"test\");\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/verification/NiceMessagesOnStrictOrderErrorsTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.verification;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.*;\n+import org.mockito.*;\n+import org.mockito.exceptions.*;\n+import org.mockito.internal.StateResetter;\n+import org.mockitousage.IMethods;\n+\n+public class NiceMessagesOnStrictOrderErrorsTest {\n+    \n+    private IMethods one;\n+    private IMethods two;\n+    private IMethods three;\n+    private Strictly strictly;\n+\n+    @Before\n+    public void setup() {\n+        one = Mockito.mock(IMethods.class);\n+        two = Mockito.mock(IMethods.class);\n+        three = Mockito.mock(IMethods.class);\n+        \n+        one.simpleMethod(1);\n+        one.simpleMethod(11);\n+        two.simpleMethod(2);\n+        two.simpleMethod(2);\n+        three.simpleMethod();\n+        \n+        strictly = createStrictOrderVerifier(one, two, three);\n+    }\n+    \n+    @Test\n+    public void shouldPrintStrictVerificationError() {\n+        try {\n+            strictly.verify(one).simpleMethod(999);\n+            fail();\n+        } catch (VerificationError expected) {\n+            String actualMessage = expected.getMessage();\n+            String expectedMessage = \n+                    \"\\n\" +\n+                    \"Strict order verification failed\" +\n+                    \"\\n\" +\n+                    \"Wanted: IMethods.simpleMethod(999)\" + \n+            \t\t\"\\n\" +\n+            \t\t\"Actual: IMethods.simpleMethod(1)\";\n+            assertEquals(expectedMessage, actualMessage);         \n+        }\n+    }  \n+    \n+    @Test\n+    public void shouldPrintWantedMethodWhenEverythingElseIsVerified() {\n+        strictly.verify(one).simpleMethod(1);\n+        strictly.verify(one).simpleMethod(11);\n+        strictly.verify(two, 2).simpleMethod(2);\n+        strictly.verify(three).simpleMethod();\n+        try {\n+            strictly.verify(three).simpleMethod(999);\n+            fail();\n+        } catch (VerificationError expected) {\n+            String actualMessage = expected.getMessage();\n+            String expectedMessage = \n+                    \"\\n\" +\n+                    \"Wanted but not invoked:\" +\n+                    \"\\n\" +\n+                    \"IMethods.simpleMethod(999)\"; \n+            assertEquals(expectedMessage, actualMessage);         \n+        }\n+    }   \n+    \n+    @Test\n+    public void shouldPrintWrongNumberOfInvocations() {\n+        strictly.verify(one).simpleMethod(1);\n+        strictly.verify(one).simpleMethod(11);\n+        try {\n+            strictly.verify(two, 1).simpleMethod(2);\n+            fail();\n+        } catch (NumberOfInvocationsError expected) {\n+            String actualMessage = expected.getMessage();\n+            String expectedMessage = \n+                    \"\\n\" +\n+                    \"IMethods.simpleMethod(2)\" +\n+                    \"\\n\" +\n+                    \"Wanted 1 time but was 2\"; \n+            assertEquals(expectedMessage, actualMessage);         \n+        }\n+    }  \n+    \n+    @Test\n+    public void shouldPrintSequenceNumberWhenMocksAndMethodsAreTheSame() {\n+        StateResetter.reset();\n+        one = mock(IMethods.class);\n+        two = mock(IMethods.class);\n+        \n+        one.simpleMethod();\n+        two.simpleMethod();\n+        \n+        strictly = createStrictOrderVerifier(one, two);\n+        \n+        try {\n+            strictly.verify(two).simpleMethod();\n+            fail();\n+        } catch (VerificationError expected) {\n+            String actualMessage = expected.getMessage();\n+            String expectedMessage = \n+                    \"\\n\" +    \n+                    \"Strict order verification failed\" +\n+                    \"\\n\" +\n+                    \"Wanted: IMethods#3.simpleMethod()\" +\n+                    \"\\n\" +\n+                    \"Actual: IMethods#1.simpleMethod()\"; \n+            assertEquals(expectedMessage, actualMessage);         \n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/verification/NiceMessagesWhenVerificationFailsTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.verification;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.*;\n+import org.mockito.Mockito;\n+import org.mockito.exceptions.VerificationError;\n+import org.mockitousage.IMethods;\n+\n+public class NiceMessagesWhenVerificationFailsTest {\n+    \n+    private IMethods mock;\n+\n+    @Before\n+    public void setup() {\n+        mock = Mockito.mock(IMethods.class);\n+    }\n+    \n+    @Test\n+    public void shouldPrintMethodName() {\n+        try {\n+            verify(mock).simpleMethod();\n+            fail();\n+        } catch (VerificationError expected) {\n+            String actualMessage = expected.getMessage();\n+            String expectedMessage = \n+                    \"\\n\" +\n+            \t\t\"Wanted but not invoked:\" +\n+            \t\t\"\\n\" +\n+            \t\t\"IMethods.simpleMethod()\";\n+            assertEquals(expectedMessage, actualMessage);         \n+        }\n+    }\n+    \n+    private class SomeClass {\n+        public String toString() {\n+            return \"SomeClass instance\";\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPrintMethodNameAndArguments() {\n+        try {\n+            verify(mock).threeArgumentMethod(12, new SomeClass(), \"some string\");\n+            fail();\n+        } catch (VerificationError expected) {\n+            String actualMessage = expected.getMessage();\n+            String expectedMessage = \n+                    \"\\n\" +\n+                    \"Wanted but not invoked:\" +\n+                    \"\\n\" +\n+            \t\t\"IMethods.threeArgumentMethod(12, SomeClass instance, \\\"some string\\\")\";\n+            assertEquals(expectedMessage, actualMessage);         \n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPrintLastUnverifiedAsActualInvocation() {\n+        mock.oneArg(true);\n+        mock.simpleMethod();\n+        \n+        verify(mock).oneArg(true);\n+        try {\n+            verify(mock).twoArgumentMethod(1,2);\n+            fail();\n+        } catch (VerificationError expected) {\n+            String actualMessage = expected.getMessage();\n+            String expectedMessage = \n+                    \"\\n\" +\n+                    \"Wanted but not invoked:\" +\n+                    \"\\n\" +\n+                    \"IMethods.twoArgumentMethod(1, 2)\";\n+            \n+            assertEquals(expectedMessage, actualMessage);         \n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPrintActualAndWantedWhenTheDifferenceIsAboutArguments() {\n+        mock.oneArg(true);\n+        mock.twoArgumentMethod(1, 2);\n+        \n+        verify(mock).oneArg(true);\n+        try {\n+            verify(mock).twoArgumentMethod(1, 1000);\n+            fail();\n+        } catch (VerificationError expected) {\n+            String actualMessage = expected.getMessage();\n+            String expectedMessage = \n+                    \"\\n\" +\n+                    \"Invocation differs from actual\" +\n+                    \"\\n\" +\n+                    \"Wanted: IMethods.twoArgumentMethod(1, 1000)\" +\n+                    \"\\n\" +\n+                    \"Actual: IMethods.twoArgumentMethod(1, 2)\";\n+            \n+            assertEquals(expectedMessage, actualMessage);         \n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPrintActualAndWantedWhenActualMethodNameAndWantedMethodNameAreTheSame() {\n+        mock.simpleMethod();\n+        \n+        try {\n+            verify(mock).simpleMethod(\"test\");\n+            fail();\n+        } catch (VerificationError expected) {\n+            String actualMessage = expected.getMessage();\n+            String expectedMessage = \n+                    \"\\n\" +\n+                    \"Invocation differs from actual\" +\n+                    \"\\n\" +\n+                    \"Wanted: IMethods.simpleMethod(\\\"test\\\")\" +\n+                    \"\\n\" +\n+                    \"Actual: IMethods.simpleMethod()\";\n+            \n+            assertEquals(expectedMessage, actualMessage);         \n+        }\n+    }    \n+    \n+    @Test\n+    public void shouldPrintActualAndUnverifiedWantedWhenTheDifferenceIsAboutArguments() {\n+        mock.twoArgumentMethod(1, 1);\n+        mock.twoArgumentMethod(2, 2);\n+        mock.twoArgumentMethod(3, 3);\n+        \n+        verify(mock).twoArgumentMethod(1, 1);\n+        verify(mock).twoArgumentMethod(2, 2);\n+        try {\n+            verify(mock).twoArgumentMethod(3, 1000);\n+            fail();\n+        } catch (VerificationError expected) {\n+            String actualMessage = expected.getMessage();\n+            String expectedMessage = \n+                    \"\\n\" +\n+                    \"Invocation differs from actual\" +\n+                    \"\\n\" +\n+                    \"Wanted: IMethods.twoArgumentMethod(3, 1000)\" +\n+                    \"\\n\" +\n+                    \"Actual: IMethods.twoArgumentMethod(3, 3)\";\n+            \n+            assertEquals(expectedMessage, actualMessage);         \n+        }\n+    }  \n+    \n+    @Test\n+    public void shouldPrintFirstUnexpectedInvocation() {\n+        mock.oneArg(true);\n+        mock.oneArg(false);\n+        mock.threeArgumentMethod(1, \"2\", \"3\");\n+        \n+        verify(mock).oneArg(true);\n+        try {\n+            verifyNoMoreInteractions(mock);\n+            fail();\n+        } catch (VerificationError expected) {\n+            String actualMessage = expected.getMessage();\n+            String expectedMessage = \n+                    \"\\n\" +\n+            \t\t\"No more interactions wanted\" +\n+            \t\t\"\\n\" +\n+            \t\t\"Unexpected: IMethods.oneArg(false)\";\n+            assertEquals(expectedMessage, actualMessage);         \n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPrintFirstUnexpectedInvocationWhenVerifyingZeroInteractions() {\n+        mock.twoArgumentMethod(1, 2);\n+        mock.threeArgumentMethod(1, \"2\", \"3\");\n+        \n+        try {\n+            verifyZeroInteractions(mock);\n+            fail();\n+        } catch (VerificationError expected) {\n+            String actualMessage = expected.getMessage();\n+            String expectedMessage = \n+                    \"\\n\" +\n+                    \"Zero interactions wanted\" +\n+                    \"\\n\" +\n+                    \"Unexpected: IMethods.twoArgumentMethod(1, 2)\";\n+            assertEquals(expectedMessage, actualMessage);         \n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPrintMethodNameWhenVerifyingAtLeastOnce() throws Exception {\n+        try {\n+            verify(mock, atLeastOnce()).twoArgumentMethod(1, 2);\n+            fail();\n+        } catch (VerificationError expected) {\n+            String actualMessage = expected.getMessage();\n+            String expectedMessage = \n+                \"\\n\" +\n+                \"Wanted but not invoked:\" +\n+                \"\\n\" +\n+                \"IMethods.twoArgumentMethod(1, 2)\";\n+            assertEquals(expectedMessage, actualMessage);         \n+        }\n+    }\n+    \n+    @Test\n+    public void shouldPrintMethodNicelyWhenMatcherUsed() throws Exception {\n+        try {\n+            verify(mock, atLeastOnce()).twoArgumentMethod(anyInt(), eq(100));\n+            fail();\n+        } catch (VerificationError expected) {\n+            String actualMessage = expected.getMessage();\n+            String expectedMessage = \n+                \"\\n\" +\n+                \"Wanted but not invoked:\" +\n+                \"\\n\" +\n+                \"IMethods.twoArgumentMethod(<any>, 100)\";\n+            assertEquals(expectedMessage, actualMessage);         \n+        }\n+    }\n+    \n+    //TODO do we need nice message when wanted number of invocations = 0?\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/verification/NoMoreInteractionsVerificationTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.verification;\n+\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.*;\n+\n+import java.util.*;\n+\n+import org.junit.Test;\n+import org.mockito.exceptions.VerificationError;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class NoMoreInteractionsVerificationTest {\n+\n+    @Test\n+    public void shouldStubbingNotRegisterRedundantInteractions() throws Exception {\n+        List mock = mock(List.class);\n+        stub(mock.add(\"one\")).andReturn(true);\n+        stub(mock.add(\"two\")).andReturn(true);\n+\n+        mock.add(\"one\");\n+        \n+        verify(mock).add(\"one\");\n+        verifyNoMoreInteractions(mock);\n+    }\n+    \n+    @Test\n+    public void shouldVerifyWhenWantedNumberOfInvocationsUsed() throws Exception {\n+        List mock = mock(List.class);\n+\n+        mock.add(\"one\");\n+        mock.add(\"one\");\n+        mock.add(\"one\");\n+        \n+        verify(mock, 3).add(\"one\");\n+        \n+        verifyNoMoreInteractions(mock);\n+    }\n+    \n+    @Test\n+    public void shouldVerifyNoInteractionsAsManyTimesAsYouWant() throws Exception {\n+        List mock = mock(List.class);\n+\n+        verifyNoMoreInteractions(mock);\n+        verifyNoMoreInteractions(mock);\n+        \n+        verifyZeroInteractions(mock);\n+        verifyZeroInteractions(mock);\n+    }\n+    \n+    @Test\n+    public void shouldFailZeroInteractionsVerification() throws Exception {\n+        List mock = mock(List.class);\n+\n+        mock.clear();\n+        \n+        try {\n+            verifyZeroInteractions(mock);\n+            fail();\n+        } catch (VerificationError e) {\n+            //cool\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldFailNoMoreInteractionsVerification() throws Exception {\n+        List mock = mock(List.class);\n+\n+        mock.clear();\n+        \n+        try {\n+            verifyNoMoreInteractions(mock);\n+            fail();\n+        } catch (VerificationError e) {\n+            //cool\n+        }\n+    }\n+    \n+    @Test\n+    public void shouldVerifyOneMockButFailOnOther() throws Exception {\n+        List list = mock(List.class);\n+        Map map = mock(Map.class);\n+\n+        list.add(\"one\");\n+        list.add(\"one\");\n+        \n+        map.put(\"one\", 1);\n+        \n+        verify(list, 2).add(\"one\");\n+        \n+        verifyNoMoreInteractions(list);\n+        try {\n+            verifyZeroInteractions(map);\n+            fail();\n+        } catch (VerificationError e) {\n+            //cool\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/verification/VerificationInOrderMixedWithOrdiraryVerificationTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.verification;\n+\n+import static org.mockito.Mockito.*;\n+\n+import static org.junit.Assert.*;\n+import org.junit.*;\n+import org.mockito.Strictly;\n+import org.mockito.exceptions.*;\n+import org.mockitousage.IMethods;\n+\n+@SuppressWarnings(\"unchecked\")  \n+public class VerificationInOrderMixedWithOrdiraryVerificationTest {\n+    \n+    private IMethods mockOne;\n+    private IMethods mockTwo;\n+    private IMethods mockThree;\n+    private Strictly strictly;\n+\n+    @Before\n+    public void setUp() {\n+        mockOne = mock(IMethods.class);\n+        mockTwo = mock(IMethods.class);\n+        mockThree = mock(IMethods.class);\n+\n+        mockOne.simpleMethod(1);\n+        mockOne.simpleMethod(1);\n+        mockTwo.simpleMethod(2);\n+        mockThree.simpleMethod(3);\n+        mockThree.simpleMethod(4);\n+\n+        strictly = createStrictOrderVerifier(mockOne, mockThree);\n+    }\n+    \n+    @Test\n+    public void shouldMixVerifyingInOrderAndNormalVerification() {\n+        strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockThree).simpleMethod(4);\n+        verify(mockTwo).simpleMethod(2);\n+        \n+        verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+    }\n+    \n+    @Test\n+    public void shouldAllowOrdinarilyVerifyingStrictlyControlledMock() {\n+        strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+\n+        verify(mockThree).simpleMethod(3);\n+        verify(mockThree).simpleMethod(4);\n+        verify(mockTwo).simpleMethod(2);\n+        \n+        verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+    }\n+    \n+    @Test\n+    public void shouldAllowRedundantVerifications() {\n+        verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        verify(mockTwo).simpleMethod(2);\n+        verify(mockThree).simpleMethod(3);\n+        verify(mockThree).simpleMethod(4);\n+        \n+        strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockThree).simpleMethod(4);\n+        \n+        verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+    }\n+    \n+    @Test\n+    public void shouldFailOnNoMoreInteractions() {\n+        strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockThree).simpleMethod(4);\n+        \n+        try {\n+            verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+            fail();\n+        } catch (VerificationError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnNoMoreInteractionsOnStrictlyControlledMock() {\n+        strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        verify(mockTwo).simpleMethod(2);\n+        \n+        try {\n+            verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+            fail();\n+        } catch (VerificationError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnWrongOrder() {\n+        verify(mockTwo).simpleMethod(2);\n+        verify(mockOne, atLeastOnce()).simpleMethod(1);\n+\n+        try {\n+            strictly.verify(mockThree).simpleMethod(3);\n+            fail();\n+        } catch (VerificationError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnWrongOrderForLastInvocationIsTooEarly() {\n+        strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        verify(mockTwo).simpleMethod(2);\n+        \n+        try {\n+            strictly.verify(mockThree).simpleMethod(4);\n+            fail();\n+        } catch (VerificationError e) {}\n+    }\n+    \n+    @Test(expected=MockitoException.class)\n+    public void shouldScreamWhenNotStrictMockPassedToStrictly() {\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(1);\n+    } \n+}\n--- /dev/null\n+++ b/test/org/mockitousage/verification/VerificationInOrderTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.verification;\n+\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.*;\n+import org.mockito.Strictly;\n+import org.mockito.exceptions.*;\n+import org.mockitousage.IMethods;\n+\n+@SuppressWarnings(\"unchecked\")  \n+public class VerificationInOrderTest {\n+    \n+    private IMethods mockOne;\n+    private IMethods mockTwo;\n+    private IMethods mockThree;\n+    private Strictly strictly;\n+\n+    @Before\n+    public void setUp() {\n+        mockOne = mock(IMethods.class);\n+        mockTwo = mock(IMethods.class);\n+        mockThree = mock(IMethods.class);\n+        \n+        strictly = createStrictOrderVerifier(mockOne, mockTwo, mockThree);\n+\n+        mockOne.simpleMethod(1);\n+        mockTwo.simpleMethod(2);\n+        mockTwo.simpleMethod(2);\n+        mockThree.simpleMethod(3);\n+        mockTwo.simpleMethod(2);\n+        mockOne.simpleMethod(4);\n+    }\n+    \n+    @Test\n+    public void shouldVerifyInOrder() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockTwo, 2).simpleMethod(2);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockTwo).simpleMethod(2);\n+        strictly.verify(mockOne).simpleMethod(4);\n+        verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+    } \n+    \n+    @Test\n+    public void shouldVerifyInOrderUsingAtLeastOnce() {\n+        strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockTwo).simpleMethod(2);\n+        strictly.verify(mockOne, atLeastOnce()).simpleMethod(4);\n+        verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+    } \n+    \n+    @Test\n+    public void shouldVerifyInOrderWhenExpectingSomeInvocationsToBeCalledZeroTimes() {\n+        strictly.verify(mockOne, 0).oneArg(false);\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockTwo, 2).simpleMethod(2);\n+        strictly.verify(mockTwo, 0).simpleMethod(22);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockTwo).simpleMethod(2);\n+        strictly.verify(mockOne).simpleMethod(4);\n+        strictly.verify(mockThree, 0).oneArg(false);\n+        verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+    } \n+    \n+    @Test\n+    public void shouldFailWhenFirstMockCalledTwice() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        try {\n+            strictly.verify(mockOne).simpleMethod(1);\n+            fail();\n+        } catch (VerificationError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailWhenLastMockCalledTwice() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockTwo, 2).simpleMethod(2);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockTwo).simpleMethod(2);\n+        strictly.verify(mockOne).simpleMethod(4);\n+        try {\n+            strictly.verify(mockOne).simpleMethod(4);\n+            fail();\n+        } catch (VerificationError e) {}\n+    }\n+    \n+    @Test(expected=NumberOfInvocationsError.class)\n+    public void shouldFailOnFirstMethodBecauseOneInvocationWanted() {\n+        strictly.verify(mockOne, 0).simpleMethod(1);\n+    }\n+    \n+    @Test(expected=NumberOfInvocationsError.class)\n+    public void shouldFailOnFirstMethodBecauseOneInvocationWantedAgain() {\n+        strictly.verify(mockOne, 2).simpleMethod(1);\n+    }\n+    \n+    @Test\n+    public void shouldFailOnSecondMethodBecauseTwoInvocationsWanted() {\n+        strictly.verify(mockOne, 1).simpleMethod(1);\n+        try {\n+            strictly.verify(mockTwo, 3).simpleMethod(2);\n+            fail();\n+        } catch (NumberOfInvocationsError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnSecondMethodBecauseTwoInvocationsWantedAgain() {\n+        strictly.verify(mockOne, 1).simpleMethod(1);\n+        try {\n+            strictly.verify(mockTwo, 0).simpleMethod(2);\n+            fail();\n+        } catch (NumberOfInvocationsError e) {}\n+    }    \n+    \n+    @Test\n+    public void shouldFailOnLastMethodBecauseOneInvocationWanted() {\n+        strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        strictly.verify(mockThree, atLeastOnce()).simpleMethod(3);\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        try {\n+            strictly.verify(mockOne, 0).simpleMethod(4);\n+            fail();\n+        } catch (NumberOfInvocationsError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnLastMethodBecauseOneInvocationWantedAgain() {\n+        strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        strictly.verify(mockThree, atLeastOnce()).simpleMethod(3);\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        try {\n+            strictly.verify(mockOne, 2).simpleMethod(4);\n+            fail();\n+        } catch (NumberOfInvocationsError e) {}\n+    }    \n+    \n+    /* ------------- */\n+    \n+    @Test(expected=VerificationError.class)\n+    public void shouldFailOnFirstMethodBecauseDifferentArgsWanted() {\n+        strictly.verify(mockOne).simpleMethod(100);\n+    }\n+    \n+    @Test(expected=VerificationError.class)\n+    public void shouldFailOnFirstMethodBecauseDifferentMethodWanted() {\n+        strictly.verify(mockOne).oneArg(true);\n+    }\n+    \n+    @Test\n+    public void shouldFailOnSecondMethodBecauseDifferentArgsWanted() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        try {\n+            strictly.verify(mockTwo, 2).simpleMethod(-999);\n+            fail();\n+        } catch (VerificationError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnSecondMethodBecauseDifferentMethodWanted() {\n+        strictly.verify(mockOne, 1).simpleMethod(1);\n+        try {\n+            strictly.verify(mockTwo, 2).oneArg(true);\n+            fail();\n+        } catch (VerificationError e) {}\n+    }    \n+    \n+    @Test\n+    public void shouldFailOnLastMethodBecauseDifferentArgsWanted() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockTwo).simpleMethod(2);\n+        try {\n+            strictly.verify(mockOne).simpleMethod(-666);\n+            fail();\n+        } catch (VerificationError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnLastMethodBecauseDifferentMethodWanted() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockTwo).simpleMethod(2);\n+        try {\n+            strictly.verify(mockOne).oneArg(false);\n+            fail();\n+        } catch (VerificationError e) {}\n+    }    \n+    \n+    /* -------------- */\n+    \n+    @Test(expected = VerificationError.class)\n+    public void shouldFailWhenLastMethodCalledFirst() {\n+        strictly.verify(mockOne).simpleMethod(4);\n+    }\n+    \n+    @Test(expected = VerificationError.class)\n+    public void shouldFailWhenSecondMethodCalledFirst() {\n+        strictly.verify(mockTwo, 2).simpleMethod(2);\n+    }\n+    \n+    @Test\n+    public void shouldFailWhenLastMethodCalledToEarly() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockTwo, 2).simpleMethod(2);\n+        try {\n+            strictly.verify(mockOne).simpleMethod(4);\n+            fail();\n+        } catch (VerificationError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailWhenMockTwoIsToEarly() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockTwo, 2).simpleMethod(2);\n+        try {\n+            strictly.verify(mockTwo, 1).simpleMethod(2);\n+            fail();\n+        } catch (VerificationError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailWhenLastMockIsToEarly() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        try {\n+            strictly.verify(mockOne).simpleMethod(4);\n+            fail();\n+        } catch (VerificationError e) {}\n+    }\n+    \n+    @Test\n+    public void shouldFailOnVerifyNoMoreInteractions() {\n+        strictly.verify(mockOne).simpleMethod(1);\n+        strictly.verify(mockTwo, atLeastOnce()).simpleMethod(2);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockTwo).simpleMethod(2);\n+        \n+        try {\n+            verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+            fail();\n+        } catch (VerificationError e) {}\n+    } \n+    \n+    @Test(expected=VerificationError.class)\n+    public void shouldFailOnVerifyZeroInteractions() {\n+        verifyZeroInteractions(mockOne);\n+    }\n+    \n+    @Test\n+    public void shouldVerifySingleMockStrictly() {\n+        mockOne = mock(IMethods.class);\n+        strictly = createStrictOrderVerifier(mockOne);\n+        \n+        mockOne.simpleMethod(1);\n+        mockOne.simpleMethod(2);\n+        \n+        verify(mockOne).simpleMethod(2);\n+        verify(mockOne).simpleMethod(1);\n+        \n+        try {\n+            strictly.verify(mockOne).simpleMethod(2);\n+            fail();\n+        } catch (VerificationError e) {}\n+    } \n+}\n--- /dev/null\n+++ b/test/org/mockitousage/verification/VerificationOnMultipleMocksUsingMatchersTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.verification;\n+\n+import static org.mockito.Mockito.*;\n+\n+import java.util.*;\n+\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class VerificationOnMultipleMocksUsingMatchersTest {\n+\n+    @Test\n+    public void shouldVerifyUsingMatchers() throws Exception {\n+        List list = Mockito.mock(List.class);\n+        HashMap map = Mockito.mock(HashMap.class);\n+        \n+        list.add(\"test\");\n+        list.add(1, \"test two\");\n+        \n+        map.put(\"test\", 100);\n+        map.put(\"test two\", 200);\n+        \n+        verify(list).add(anyObject());\n+        verify(list).add(anyInt(), eq(\"test two\"));\n+        \n+        verify(map, 2).put(anyObject(), anyObject());\n+        verify(map).put(eq(\"test two\"), eq(200));\n+        \n+        verifyNoMoreInteractions(list, map);\n+    }\n+    \n+    @Test\n+    public void shouldVerifyMultipleMocks() throws Exception {\n+        List list = mock(List.class);\n+        Map map = mock(Map.class);\n+        Set set = mock(Set.class);\n+\n+        list.add(\"one\");\n+        list.add(\"one\");\n+        list.add(\"two\");\n+        \n+        map.put(\"one\", 1);\n+        map.put(\"one\", 1);\n+        \n+        verify(list, 2).add(\"one\");\n+        verify(list, 1).add(\"two\");\n+        verify(list, 0).add(\"three\");\n+        \n+        verify(map, 2).put(anyObject(), anyInt());\n+        \n+        verifyNoMoreInteractions(list, map);\n+        verifyZeroInteractions(set);\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/verification/VerificationUsingMatchersTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.verification;\n+\n+import static org.mockito.CrazyMatchers.*;\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.*;\n+import org.mockito.*;\n+import org.mockito.exceptions.VerificationError;\n+import org.mockitousage.IMethods;\n+\n+@SuppressWarnings(\"unchecked\")  \n+public class VerificationUsingMatchersTest {\n+    private IMethods mock;\n+\n+    @Before\n+    public void setUp() {\n+        mock = Mockito.mock(IMethods.class);\n+    }\n+\n+    @Test\n+    public void shouldVerifyUsingSameMatcher() {\n+        Object one = new String(\"1243\");\n+        Object two = new String(\"1243\");\n+        Object three = new String(\"1243\");\n+\n+        assertNotSame(one, two);\n+        assertEquals(one, two);\n+        assertEquals(two, three);\n+\n+        mock.oneArg(one);\n+        mock.oneArg(two);\n+        \n+        verify(mock).oneArg(CrazyMatchers.same(one));\n+        verify(mock, 2).oneArg(two);\n+        \n+        try {\n+            verify(mock).oneArg(CrazyMatchers.same(three));\n+            fail();\n+        } catch (VerificationError e) {}\n+    }  \n+    \n+    @Test\n+    public void shouldVerifyUsingMixedMatchers() {\n+        mock.threeArgumentMethod(11, \"\", \"01234\");\n+\n+        try {\n+            verify(mock).threeArgumentMethod(and(geq(7), leq(10)), isA(String.class), contains(\"123\"));\n+            fail();\n+        } catch (VerificationError e) {}\n+\n+        mock.threeArgumentMethod(8, new Object(), \"01234\");\n+        \n+        try {\n+            verify(mock).threeArgumentMethod(and(geq(7), leq(10)), isA(String.class), contains(\"123\"));\n+            fail();\n+        } catch (VerificationError e) {}\n+        \n+        mock.threeArgumentMethod(8, \"\", \"no match\");\n+\n+        try {\n+            verify(mock).threeArgumentMethod(and(geq(7), leq(10)), isA(String.class), contains(\"123\"));\n+            fail();\n+        } catch (VerificationError e) {}\n+        \n+        mock.threeArgumentMethod(8, \"\", \"123\");\n+        \n+        verify(mock).threeArgumentMethod(and(geq(7), leq(10)), isA(String.class), contains(\"123\"));\n+    }\n+}", "timestamp": 1196532103, "metainfo": ""}