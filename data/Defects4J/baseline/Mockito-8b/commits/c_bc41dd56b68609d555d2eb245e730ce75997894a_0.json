{"sha": "bc41dd56b68609d555d2eb245e730ce75997894a", "log": "Added missing tests. Moved classes around.  --HG-- rename : test/org/mockitousage/basicapi/AnnotationsTest.java => test/org/mockitousage/annotation/AnnotationsTest.java rename : test/org/mockitousage/basicapi/CaptorAnnotationBasicTest.java => test/org/mockitousage/annotation/CaptorAnnotationBasicTest.java rename : test/org/mockitousage/basicapi/CaptorAnnotationTest.java => test/org/mockitousage/annotation/CaptorAnnotationTest.java rename : test/org/mockitousage/basicapi/CaptorAnnotationUnhappyPathTest.java => test/org/mockitousage/annotation/CaptorAnnotationUnhappyPathTest.java rename : test/org/mockitousage/basicapi/DeprecatedAnnotationEngineApiTest.java => test/org/mockitousage/annotation/DeprecatedAnnotationEngineApiTest.java rename : test/org/mockitousage/basicapi/SpyAnnotationTest.java => test/org/mockitousage/annotation/SpyAnnotationTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401870", "commit": "\n--- /dev/null\n+++ b/test/org/mockitousage/annotation/AnnotationsTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.annotation;\n+\n+import static org.mockito.Mockito.*;\n+import static org.mockito.internal.stubbing.defaultanswers.Answers.RETURNS_MOCKS;\n+import static org.mockito.internal.stubbing.defaultanswers.Answers.RETURNS_DEFAULTS;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.util.*;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.*;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class AnnotationsTest extends TestBase {\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface NotAMock {}\n+\n+    @Mock List list;\n+    @Mock final Map map = new HashMap();\n+        \n+    @NotAMock Set notAMock;\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @MockitoAnnotations.Mock List listTwo;\n+\n+    @Before\n+    public void setup() {\n+        MockitoAnnotations.initMocks(this);\n+    }\n+\n+    @Test\n+    public void shouldInitMocks() throws Exception {\n+        list.clear();\n+        map.clear();\n+        listTwo.clear();\n+\n+        verify(list).clear();\n+        verify(map).clear();\n+        verify(listTwo).clear();\n+    }\n+\n+    @Test\n+    public void shouldScreamWhenInitializingMocksForNullClass() throws Exception {\n+        try {\n+            MockitoAnnotations.initMocks(null);\n+            fail();\n+        } catch (MockitoException e) {\n+            assertEquals(\"testClass cannot be null. For info how to use @Mock annotations see examples in javadoc for MockitoAnnotations class\",\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldLookForAnnotatedMocksInSuperClasses() throws Exception {\n+        Sub sub = new Sub();\n+        MockitoAnnotations.initMocks(sub);\n+\n+        assertNotNull(sub.getMock());\n+        assertNotNull(sub.getBaseMock());\n+        assertNotNull(sub.getSuperBaseMock());\n+    }\n+    \n+    @Mock(answer = RETURNS_MOCKS, name = \"i have a name\") IMethods namedAndReturningMocks;\n+    @Mock(answer = RETURNS_DEFAULTS) IMethods returningDefaults;\n+    @Mock(extraInterfaces = {List.class}) IMethods hasExtraInterfaces;\n+    @Mock() IMethods noExtraConfig;\n+\n+    @Test\n+    public void shouldInitMocksWithGivenSettings() throws Exception {\n+        assertEquals(\"i have a name\", namedAndReturningMocks.toString());\n+        assertNotNull(namedAndReturningMocks.iMethodsReturningMethod());\n+       \n+        assertEquals(\"returningDefaults\", returningDefaults.toString());\n+        assertEquals(0, returningDefaults.intReturningMethod()); \n+        \n+        assertTrue(hasExtraInterfaces instanceof List);\n+        \n+        assertEquals(0, noExtraConfig.intReturningMethod());        \n+    }\n+\n+    class SuperBase {\n+        @Mock private IMethods mock;\n+\n+        public IMethods getSuperBaseMock() {\n+            return mock;\n+        }\n+    }\n+\n+    class Base extends SuperBase {\n+        @Mock private IMethods mock;\n+\n+        public IMethods getBaseMock() {\n+            return mock;\n+        }\n+    }\n+\n+    class Sub extends Base {\n+        @Mock private IMethods mock;\n+\n+        public IMethods getMock() {\n+            return mock;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/annotation/CaptorAnnotationBasicTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.annotation;\n+\n+import static org.mockito.Mockito.*;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class CaptorAnnotationBasicTest extends TestBase {\n+\n+    public class Person {\n+        private final String name;\n+        private final String surname;\n+\n+        public Person(String name, String surname) {\n+            this.name = name;\n+            this.surname = surname;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+        \n+        public String getSurname() {\n+            return surname;\n+        }\n+    }\n+\n+    public interface PeopleRepository {\n+        public void save(Person capture);\n+    }\n+    \n+    @Mock PeopleRepository peopleRepository;           \n+    \n+    private void createPerson(String name, String surname) {\n+        peopleRepository.save(new Person(name, surname));\n+    }      \n+    \n+    @Test\n+    public void shouldUseCaptorInOrdinaryWay() {\n+        //when\n+        createPerson(\"Wes\", \"Williams\");\n+        \n+        //then\n+        ArgumentCaptor<Person> captor = ArgumentCaptor.forClass(Person.class);\n+        verify(peopleRepository).save(captor.capture());\n+        assertEquals(\"Wes\", captor.getValue().getName());\n+        assertEquals(\"Williams\", captor.getValue().getSurname());\n+    }\n+    \n+    @Captor ArgumentCaptor<Person> captor;\n+    \n+    @Test\n+    public void shouldUseAnnotatedCaptor() {\n+        //when\n+        createPerson(\"Wes\", \"Williams\");\n+        \n+        //then\n+        verify(peopleRepository).save(captor.capture());\n+        assertEquals(\"Wes\", captor.getValue().getName());\n+        assertEquals(\"Williams\", captor.getValue().getSurname());\n+    }\n+        \n+    @Captor ArgumentCaptor genericLessCaptor;\n+    \n+    @Test\n+    public void shouldUseGenericlessAnnotatedCaptor() {\n+        //when\n+        createPerson(\"Wes\", \"Williams\");\n+        \n+        //then\n+        verify(peopleRepository).save((Person) genericLessCaptor.capture());\n+        assertEquals(\"Wes\", ((Person) genericLessCaptor.getValue()).getName());\n+        assertEquals(\"Williams\", ((Person) genericLessCaptor.getValue()).getSurname());\n+    }  \n+    \n+    @Captor ArgumentCaptor<List<String>> genericListCaptor;\n+    @Mock IMethods mock;\n+    \n+    @Test\n+    public void shouldCaptureGenericList() {\n+        //given\n+        List<String> list = new LinkedList<String>();\n+        mock.listArgMethod(list);\n+                \n+        //when\n+        verify(mock).listArgMethod(genericListCaptor.capture());\n+        \n+        //then\n+        assertSame(list, genericListCaptor.getValue());\n+    } \n+}\n--- /dev/null\n+++ b/test/org/mockitousage/annotation/CaptorAnnotationTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.annotation;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class CaptorAnnotationTest extends TestBase {\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface NotAMock {\n+    }\n+\n+    @Captor\n+    final ArgumentCaptor<String> finalCaptor = ArgumentCaptor.forClass(String.class);\n+\n+    @Captor\n+    ArgumentCaptor<List<List<String>>> genericsCaptor;\n+\n+    @Captor\n+    ArgumentCaptor nonGenericCaptorIsAllowed;\n+\n+    @Mock\n+    MockInterface mockInterface;\n+\n+    @NotAMock\n+    Set notAMock;\n+\n+    public interface MockInterface {\n+        void testMe(String simple, List<List<String>> genericList);\n+    }\n+\n+    @Test\n+    public void testNormalUsage() {\n+\n+        MockitoAnnotations.initMocks(this);\n+\n+        // check if assigned correctly\n+        assertNotNull(finalCaptor);\n+        assertNotNull(genericsCaptor);\n+        assertNotNull(nonGenericCaptorIsAllowed);\n+        assertNull(notAMock);\n+\n+        // use captors in the field to be sure they are cool\n+        String argForFinalCaptor = \"Hello\";\n+        ArrayList<List<String>> argForGenericsCaptor = new ArrayList<List<String>>();\n+\n+        mockInterface.testMe(argForFinalCaptor, argForGenericsCaptor);\n+\n+        Mockito.verify(mockInterface).testMe(finalCaptor.capture(), genericsCaptor.capture());\n+\n+        assertEquals(argForFinalCaptor, finalCaptor.getValue());\n+        assertEquals(argForGenericsCaptor, genericsCaptor.getValue());\n+\n+    }\n+\n+    public static class WrongType {\n+        @Captor\n+        List wrongType;\n+    }\n+\n+    @Test\n+    public void shouldScreamWhenWrongTypeForCaptor() {\n+        try {\n+            MockitoAnnotations.initMocks(new WrongType());\n+            fail();\n+        } catch (MockitoException e) {}\n+    }\n+\n+//TODO: do we need this? Asked the author of the patch if he doesn't come back we will delete it (17-02-2010)    \n+//    public static class WrongWildcardGenerics {\n+//        @Captor\n+//        ArgumentCaptor<? extends List> wrongType;\n+//    }\n+//\n+//    @Test\n+//    public void shouldScreamWhenWildCardGenericsAreUsedWrong() {\n+//        MockitoAnnotations.initMocks(new WrongWildcardGenerics());        \n+//    }\n+\n+    public static class ToManyAnnotations {\n+        @Captor\n+        @Mock\n+        ArgumentCaptor<List> missingGenericsField;\n+    }\n+\n+    @Test\n+    public void shouldScreamWhenMoreThanOneMockitoAnnotaton() {\n+        try {\n+            MockitoAnnotations.initMocks(new ToManyAnnotations());\n+            fail();\n+        } catch (MockitoException e) {\n+            assertContains(\"missingGenericsField\", e.getMessage());\n+            assertContains(\"multiple Mockito annotations\", e.getMessage());            \n+        }\n+    }\n+\n+    @Test\n+    public void shouldScreamWhenInitializingCaptorsForNullClass() throws Exception {\n+        try {\n+            MockitoAnnotations.initMocks(null);\n+            fail();\n+        } catch (MockitoException e) {\n+        }\n+    }\n+\n+    @Test\n+    public void shouldLookForAnnotatedCaptorsInSuperClasses() throws Exception {\n+        Sub sub = new Sub();\n+        MockitoAnnotations.initMocks(sub);\n+\n+        assertNotNull(sub.getCaptor());\n+        assertNotNull(sub.getBaseCaptor());\n+        assertNotNull(sub.getSuperBaseCaptor());\n+    }\n+\n+    class SuperBase {\n+        @Captor\n+        private ArgumentCaptor<IMethods> mock;\n+\n+        public ArgumentCaptor<IMethods> getSuperBaseCaptor() {\n+            return mock;\n+        }\n+    }\n+\n+    class Base extends SuperBase {\n+        @Captor\n+        private ArgumentCaptor<IMethods> mock;\n+\n+        public ArgumentCaptor<IMethods> getBaseCaptor() {\n+            return mock;\n+        }\n+    }\n+\n+    class Sub extends Base {\n+        @Captor\n+        private ArgumentCaptor<IMethods> mock;\n+\n+        public ArgumentCaptor<IMethods> getCaptor() {\n+            return mock;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/annotation/CaptorAnnotationUnhappyPathTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.annotation;\n+\n+import java.util.List;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Captor;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockitoutil.TestBase;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class CaptorAnnotationUnhappyPathTest extends TestBase {\n+    \n+    @Captor List notACaptorField;\n+\n+    @Before\n+    @Override\n+    public void init() {\n+        //we need to get rid of parent implementation this time\n+    }\n+    \n+    @Test\n+    public void shouldFailIfCaptorHasWrongType() throws Exception {\n+        try {\n+            //when\n+            MockitoAnnotations.initMocks(this);\n+            fail();\n+        } catch (MockitoException e) {\n+            //then\n+            assertContains(\"notACaptorField\", e.getMessage());\n+            assertContains(\"wrong type\", e.getMessage());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/annotation/DeprecatedAnnotationEngineApiTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.annotation;\n+\n+import org.junit.After;\n+import org.junit.Test;\n+import org.mockito.InjectMock;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.configuration.AnnotationEngine;\n+import org.mockito.configuration.DefaultMockitoConfiguration;\n+import org.mockito.internal.configuration.ConfigurationAccess;\n+import org.mockito.internal.configuration.DefaultAnnotationEngine;\n+import org.mockitoutil.TestBase;\n+\n+public class DeprecatedAnnotationEngineApiTest extends TestBase {\n+\n+    @After\n+    public void goBackToDefaultConfiguration() {\n+        ConfigurationAccess.getConfig().overrideAnnotationEngine(null);\n+    }\n+    \n+    class SimpleTestCase {\n+        @InjectMock Tested tested = new Tested();\n+        @Mock Dependency mock;\n+    }\n+    \n+    class Tested {        \n+        Dependency dependency;\n+        public void setDependency(Dependency dependency) {\n+            this.dependency = dependency;\n+        }        \n+    }\n+    \n+    class Dependency {}\n+    \n+    @Test\n+    public void shouldInjectMocksIfThereIsNoUserDefinedEngine() throws Exception {\n+        //given\n+        AnnotationEngine defaultEngine = new DefaultMockitoConfiguration().getAnnotationEngine();\n+        ConfigurationAccess.getConfig().overrideAnnotationEngine(defaultEngine);\n+        SimpleTestCase test = new SimpleTestCase();\n+        \n+        //when\n+        MockitoAnnotations.initMocks(test);\n+        \n+        //then   \n+        assertNotNull(test.mock);\n+        assertNotNull(test.tested.dependency);\n+        assertSame(test.mock, test.tested.dependency);\n+    }\n+    \n+    @Test\n+    public void shouldRespectUsersEngine() throws Exception {\n+        //given\n+        AnnotationEngine customizedEngine = new DefaultAnnotationEngine() { /**/ };\n+        ConfigurationAccess.getConfig().overrideAnnotationEngine(customizedEngine);\n+        SimpleTestCase test = new SimpleTestCase();\n+        \n+        //when\n+        MockitoAnnotations.initMocks(test);\n+        \n+        //then   \n+        assertNotNull(test.mock);\n+        assertNull(test.tested.dependency);\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/annotation/SpyAnnotationInitializedInBaseClassTest.java\n+package org.mockitousage.annotation;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.Spy;\n+import org.mockitoutil.TestBase;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class SpyAnnotationInitializedInBaseClassTest extends TestBase {\n+\t\n+    class BaseClass {\n+        @Spy List list = new LinkedList();\n+    }\n+    \n+    class SubClass extends BaseClass {}\n+    \n+    @Test\n+    public void shouldInitSpiesInBaseClass() throws Exception {\n+        //given\n+        SubClass subClass = new SubClass();\n+        //when\n+        MockitoAnnotations.initMocks(subClass);\n+        //then\n+        assertTrue(isMock(subClass.list));\n+    }\n+    \n+    @Before\n+    @Override\n+    public void init() {\n+        //we need to get rid of parent implementation this time\n+    }    \n+    \n+    @Before\n+    public void before() {\n+        MockitoAnnotations.initMocks(this);\n+    }\n+    \n+    @Spy List spyInBaseclass = new LinkedList();\n+    \n+    public static class SubTest extends SpyAnnotationInitializedInBaseClassTest {\n+        \n+        @Spy List spyInSubclass = new LinkedList();\n+        \n+        @Test\n+        public void shouldInitSpiesInHierarchy() throws Exception {\n+            assertTrue(isMock(spyInSubclass));\n+            assertTrue(isMock(spyInBaseclass));            \n+        }   \n+    }       \n+}\n--- /dev/null\n+++ b/test/org/mockitousage/annotation/SpyAnnotationTest.java\n+package org.mockitousage.annotation;\n+\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.Test;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.Spy;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockitoutil.TestBase;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class SpyAnnotationTest extends TestBase {\n+\t\n+    @Spy\n+\tfinal List spiedList = new ArrayList();\n+\n+\t@Test\n+    public void shouldInitSpies() throws Exception {\n+        doReturn(\"foo\").when(spiedList).get(10);\n+\n+        assertEquals(\"foo\", spiedList.get(10));\n+        assertTrue(spiedList.isEmpty());\n+    }\n+\n+    @Test(expected = MockitoException.class)\n+    public void shouldFailIfFieldIsNotInitialized() throws Exception {\n+\t\tclass FailingSpy {\n+\t\t\t@Spy private List mySpy;\n+\n+\t\t\t@SuppressWarnings(\"unused\")\n+            public List getMySpy() {\n+\t\t\t\treturn mySpy;\n+\t\t\t}\n+\t\t}\n+\n+\t\tMockitoAnnotations.initMocks(new FailingSpy());\n+    }\n+\n+\t@Test(expected = IndexOutOfBoundsException.class)\n+    public void shouldResetSpies() throws Exception {\n+        spiedList.get(10); // see shouldInitSpy\n+    }\n+\t\n+\t//TODO unsupported combinations of annotations (spy - captor, spy - mock)\n+\t//TODO unsupported combinations of annotations (captor - mock)\n+}", "timestamp": 1267127387, "metainfo": ""}