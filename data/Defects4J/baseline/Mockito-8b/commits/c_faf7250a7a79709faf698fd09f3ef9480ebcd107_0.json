{"sha": "faf7250a7a79709faf698fd09f3ef9480ebcd107", "log": "Thinning up the Invocation implementation. Moved out some more implementation.", "commit": "\n--- a/src/org/mockito/internal/invocation/Invocation.java\n+++ b/src/org/mockito/internal/invocation/Invocation.java\n import org.mockito.internal.invocation.realmethod.RealMethod;\n import org.mockito.internal.matchers.ArrayEquals;\n import org.mockito.internal.matchers.Equals;\n-import org.mockito.internal.matchers.MatchersPrinter;\n import org.mockito.internal.reporting.PrintSettings;\n-import org.mockito.internal.reporting.PrintingFriendlyInvocation;\n-import org.mockito.internal.util.MockUtil;\n import org.mockito.invocation.InvocationOnMock;\n import org.mockito.invocation.PublicInvocation;\n \n  * Contains stack trace of invocation\n  */\n @SuppressWarnings(\"unchecked\")\n-public class Invocation implements PublicInvocation, PrintableInvocation, InvocationOnMock, PrintingFriendlyInvocation, VerificationAwareInvocation {\n+public class Invocation implements PublicInvocation, PrintableInvocation, InvocationOnMock, VerificationAwareInvocation {\n \n     private static final long serialVersionUID = 8240069639250980199L;\n-    private static final int MAX_LINE_LENGTH = 45;\n+    public static final int MAX_LINE_LENGTH = 45;\n     private final int sequenceNumber;\n     private final Object mock;\n     private final MockitoMethod method;\n     }\n \n     public String toString() {\n-        return toString(argumentsToMatchers(), new PrintSettings());\n+        return new PrintSettings().print(argumentsToMatchers(getArguments()), this);\n     }\n \n-    protected String toString(List<Matcher> matchers, PrintSettings printSettings) {\n-        MatchersPrinter matchersPrinter = new MatchersPrinter();\n-        String method = qualifiedMethodName();\n-        String invocation = method + matchersPrinter.getArgumentsLine(matchers, printSettings);\n-        if (printSettings.isMultiline() || (!matchers.isEmpty() && invocation.length() > MAX_LINE_LENGTH)) {\n-            return method + matchersPrinter.getArgumentsBlock(matchers, printSettings);\n-        } else {\n-            return invocation;\n-        }\n-    }\n-\n-    private String qualifiedMethodName() {\n-        return new MockUtil().getMockName(mock) + \".\" + method.getName();\n-    }\n-\n-    protected List<Matcher> argumentsToMatchers() {\n+    public static List<Matcher> argumentsToMatchers(Object[] arguments) {\n         List<Matcher> matchers = new ArrayList<Matcher>(arguments.length);\n         for (Object arg : arguments) {\n             if (arg != null && arg.getClass().isArray()) {\n         return realMethod.invoke(mock, rawArguments);\n     }\n \n-    public String toString(PrintSettings printSettings) {\n-        return toString(argumentsToMatchers(), printSettings);\n-    }\n-\n     public void markVerified() {\n         this.verified = true;\n     }\n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n import org.mockito.internal.debugging.Location;\n import org.mockito.internal.matchers.CapturesArguments;\n import org.mockito.internal.reporting.PrintSettings;\n-import org.mockito.internal.reporting.PrintingFriendlyInvocation;\n \n @SuppressWarnings(\"unchecked\")\n-public class InvocationMatcher implements PrintableInvocation, PrintingFriendlyInvocation, CapturesArgumensFromInvocation, Serializable {\n+public class InvocationMatcher implements PrintableInvocation, CapturesArgumensFromInvocation, Serializable {\n \n     private static final long serialVersionUID = -3047126096857467610L;\n     private final Invocation invocation;\n     public InvocationMatcher(Invocation invocation, List<Matcher> matchers) {\n         this.invocation = invocation;\n         if (matchers.isEmpty()) {\n-            this.matchers = invocation.argumentsToMatchers();\n+            this.matchers = Invocation.argumentsToMatchers(invocation.getArguments());\n         } else {\n             this.matchers = matchers;\n         }\n     }\n     \n     public String toString() {\n-        return invocation.toString(matchers, new PrintSettings());\n+        return new PrintSettings().print(matchers, invocation);\n     }\n \n     public boolean matches(Invocation actual) {\n         return invocation.getLocation();\n     }\n \n-    public String toString(PrintSettings printSettings) {\n-        return invocation.toString(matchers, printSettings);\n-    }\n-\n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n--- a/src/org/mockito/internal/reporting/PrintSettings.java\n+++ b/src/org/mockito/internal/reporting/PrintSettings.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.reporting;\n+\n+import org.hamcrest.Matcher;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.matchers.MatchersPrinter;\n+import org.mockito.internal.util.MockUtil;\n \n import java.util.Arrays;\n import java.util.LinkedList;\n     public void setMatchersToBeDescribedWithExtraTypeInfo(Integer[] indexesOfMatchers) {\n         this.withTypeInfo = Arrays.asList(indexesOfMatchers);\n     }\n+\n+    public String print(List<Matcher> matchers, Invocation invocation) {\n+        MatchersPrinter matchersPrinter = new MatchersPrinter();\n+        String qualifiedName = new MockUtil().getMockName(invocation.getMock()) + \".\" + invocation.getMethod().getName();\n+        String invocationString = qualifiedName + matchersPrinter.getArgumentsLine(matchers, this);\n+        if (isMultiline() || (!matchers.isEmpty() && invocationString.length() > Invocation.MAX_LINE_LENGTH)) {\n+            return qualifiedName + matchersPrinter.getArgumentsBlock(matchers, this);\n+        } else {\n+            return invocationString;\n+        }\n+    }\n+\n+    public String print(Invocation invocation) {\n+        return print(Invocation.argumentsToMatchers(invocation.getArguments()), invocation);\n+    }\n+\n+    public String print(InvocationMatcher invocationMatcher) {\n+        return print(invocationMatcher.getMatchers(), invocationMatcher.getInvocation());\n+    }\n }\n--- a/src/org/mockito/internal/reporting/SmartPrinter.java\n+++ b/src/org/mockito/internal/reporting/SmartPrinter.java\n         printSettings.setMultiline(wanted.toString().contains(\"\\n\") || actual.toString().contains(\"\\n\"));\n         printSettings.setMatchersToBeDescribedWithExtraTypeInfo(indexesOfMatchersToBeDescribedWithExtraTypeInfo);\n         \n-        this.wanted = wanted.toString(printSettings);\n-        this.actual = actual.toString(printSettings);\n+        this.wanted = printSettings.print(wanted);\n+        this.actual = printSettings.print(actual);\n     }\n \n     public String getWanted() {\n--- a/test/org/mockito/internal/invocation/InvocationMatcherTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationMatcherTest.java\n import org.mockito.internal.matchers.Equals;\n import org.mockito.internal.matchers.LocalizedMatcher;\n import org.mockito.internal.matchers.NotNull;\n-import org.mockito.internal.reporting.PrintingFriendlyInvocation;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n     \n     @Test\n     public void shouldNotEqualIfNumberOfArgumentsDiffer() throws Exception {\n-        PrintingFriendlyInvocation withOneArg = new InvocationMatcher(new InvocationBuilder().args(\"test\").toInvocation());\n-        PrintingFriendlyInvocation withTwoArgs = new InvocationMatcher(new InvocationBuilder().args(\"test\", 100).toInvocation());\n+        InvocationMatcher withOneArg = new InvocationMatcher(new InvocationBuilder().args(\"test\").toInvocation());\n+        InvocationMatcher withTwoArgs = new InvocationMatcher(new InvocationBuilder().args(\"test\", 100).toInvocation());\n \n         assertFalse(withOneArg.equals(null));\n         assertFalse(withOneArg.equals(withTwoArgs));\n--- a/test/org/mockito/internal/invocation/InvocationTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationTest.java\n     @Test\n     public void shouldTransformArgumentsToMatchers() throws Exception {\n         Invocation i = new InvocationBuilder().args(\"foo\", new String[] {\"bar\"}).toInvocation();\n-        List matchers = i.argumentsToMatchers();\n+        List matchers = Invocation.argumentsToMatchers(i.getArguments());\n \n         assertEquals(2, matchers.size());\n         assertEquals(Equals.class, matchers.get(0).getClass());\n--- a/test/org/mockito/internal/verification/SmartPrinterTest.java\n+++ b/test/org/mockito/internal/verification/SmartPrinterTest.java\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.Mock;\n-import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.reporting.PrintingFriendlyInvocation;\n import org.mockito.internal.reporting.SmartPrinter;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;", "timestamp": 1333230926, "metainfo": ""}