{"sha": "2b92eb882e46b07d36cfbf6f7ba85509b34be5e4", "log": "Fixed way to fire threads in test at the same time (transplanted from 5ce5a37379e1d6b2570798855b6ae7a230887395)  --HG-- extra : transplant_source : %5C%E5%A3sy%E1%D6%B2W%07%98%85%5Bj%E7%A20%88s%95", "commit": "\n--- a/test/org/mockito/internal/stubbing/InvocationContainerImplTest.java\n+++ b/test/org/mockito/internal/stubbing/InvocationContainerImplTest.java\n  * Copyright (c) 2007 Mockito contributors\n  * This program is made available under the terms of the MIT License.\n  */\n-package org.mockito.internal.stubbing;\n-\n-import org.junit.Test;\n-import org.mockito.internal.invocation.InvocationBuilder;\n-import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.progress.ThreadSafeMockingProgress;\n-import org.mockito.internal.stubbing.answers.Returns;\n-import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues;\n-import org.mockito.invocation.Invocation;\n-\n-import java.util.LinkedList;\n-\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertTrue;\n-\n-/**\n- * Author: Szczepan Faber\n- */\n-public class InvocationContainerImplTest {\n-\n-    InvocationContainerImpl container = new InvocationContainerImpl(new ThreadSafeMockingProgress());\n-    Invocation invocation = new InvocationBuilder().toInvocation();\n-    LinkedList<Throwable> exceptions = new LinkedList<Throwable>();\n-\n-    @Test\n-    //works 50% of the time\n-    public void shouldBeThreadSafe() throws Throwable {\n-        //given\n-        Thread[] t = new Thread[200];\n-        for (int i = 0; i < t.length; i++ ) {\n-            t[i] = new Thread() {\n-                public void run() {\n-                    try {\n-                        Thread.sleep(10); //NOPMD\n-                    } catch (InterruptedException e) {\n-                        throw new RuntimeException(e);\n-                    }\n-                    container.setInvocationForPotentialStubbing(new InvocationMatcher(invocation));\n-                    container.addAnswer(new Returns(\"foo\"));\n-                    container.findAnswerFor(invocation);\n-                }\n-            };\n-            t[i].setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {\n-                public void uncaughtException(Thread t, Throwable e) {\n-                    exceptions.add(e);\n-                }\n-            });\n-            t[i].start();\n-        }\n-\n-        //when\n-        for (Thread aT : t) {\n-            aT.join();\n-        }\n-\n-        //then\n-        if (exceptions.size() != 0) {\n-            throw exceptions.getFirst();\n-        }\n-    }\n-\n-    @Test\n-    public void shouldReturnInvokedMock() throws Exception {\n-        container.setInvocationForPotentialStubbing(new InvocationMatcher(invocation));\n-\n-        assertEquals(invocation.getMock(), container.invokedMock());\n-    }\n-\n-    @Test\n-    public void should_tell_if_has_invocation_for_potential_stubbing() throws Exception {\n-        container.setInvocationForPotentialStubbing(new InvocationBuilder().toInvocationMatcher());\n-        assertTrue(container.hasInvocationForPotentialStubbing());\n-\n-        container.addAnswer(new ReturnsEmptyValues());\n-        assertFalse(container.hasInvocationForPotentialStubbing());\n-    }\n-}\n+package org.mockito.internal.stubbing;\n+\n+import org.junit.Test;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.progress.ThreadSafeMockingProgress;\n+import org.mockito.internal.stubbing.answers.Returns;\n+import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues;\n+import org.mockito.invocation.Invocation;\n+\n+import java.util.LinkedList;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Author: Szczepan Faber\n+ */\n+public class InvocationContainerImplTest {\n+\n+    InvocationContainerImpl container = new InvocationContainerImpl(new ThreadSafeMockingProgress());\n+    Invocation invocation = new InvocationBuilder().toInvocation();\n+    LinkedList<Throwable> exceptions = new LinkedList<Throwable>();\n+\n+    @Test\n+    //works 50% of the time\n+    public void shouldBeThreadSafe() throws Throwable {\n+        //given\n+        Thread[] t = new Thread[200];\n+        final CountDownLatch starter = new CountDownLatch(200);\n+        for (int i = 0; i < t.length; i++ ) {\n+            t[i] = new Thread() {\n+                public void run() {\n+                    try {\n+                        starter.await();\n+                    } catch (InterruptedException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                    container.setInvocationForPotentialStubbing(new InvocationMatcher(invocation));\n+                    container.addAnswer(new Returns(\"foo\"));\n+                    container.findAnswerFor(invocation);\n+                }\n+            };\n+            t[i].setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {\n+                public void uncaughtException(Thread t, Throwable e) {\n+                    exceptions.add(e);\n+                }\n+            });\n+            t[i].start();\n+\n+            starter.countDown();\n+        }\n+\n+        //when\n+        for (Thread aT : t) {\n+            aT.join();\n+        }\n+\n+        //then\n+        if (exceptions.size() != 0) {\n+            throw exceptions.getFirst();\n+        }\n+    }\n+\n+    @Test\n+    public void shouldReturnInvokedMock() throws Exception {\n+        container.setInvocationForPotentialStubbing(new InvocationMatcher(invocation));\n+\n+        assertEquals(invocation.getMock(), container.invokedMock());\n+    }\n+\n+    @Test\n+    public void should_tell_if_has_invocation_for_potential_stubbing() throws Exception {\n+        container.setInvocationForPotentialStubbing(new InvocationBuilder().toInvocationMatcher());\n+        assertTrue(container.hasInvocationForPotentialStubbing());\n+\n+        container.addAnswer(new ReturnsEmptyValues());\n+        assertFalse(container.hasInvocationForPotentialStubbing());\n+    }\n+}", "timestamp": 1346519792, "metainfo": ""}