{"sha": "0cc49b4407ca564a68187410c772df41ec1e3541", "log": "Fixed issue 74 In order to have earlier & better feedback when someone verifies toString()  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401825", "commit": "\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n                 \"For example:\",\n                 \"    when(mock.getArticles()).thenReturn(articles);\",\n                 \"\",\n-                \"Also, this error might show up because you stub final/private/equals() or hashCode() method.\",\n+                \"Also, this error might show up because you stub either of: final/private/equals()/hashCode() methods.\",\n                 \"Those methods *cannot* be stubbed/verified.\",\n                 \"\"\n         ));\n                 \"Example of correct verification:\",\n                 \"    verify(mock).doSomething()\",\n                 \"\",\n-                \"Also, this error might show up because you verify final or private methods.\",\n+                \"Also, this error might show up because you verify either of: final/private/equals()/hashCode() methods.\",\n                 \"Those methods *cannot* be stubbed/verified.\",\n                 \"\"\n         ));\n                 \"    verify(mock).someMethod(contains(\\\"foo\\\"))\",\n                 \"\",\n                 \"Also, this error might show up because you use argument matchers with methods that cannot be mocked.\",\n-                \"Following methods *cannot* be stubbed/verified: final/private/equals()/hashCode() methods.\",                \n+                \"Following methods *cannot* be stubbed/verified: final/private/equals()/hashCode().\",\n                 \"\"\n                 ));\n     }\n                 \"However, it is possible to stub toString(). Stubbing toString() smells a bit funny but there are rare, legitimate use cases.\"\n         ));\n     }\n-\n-    public void cannotVerifyEqualsOrHashCode() {\n-                throw new MockitoException(join(\n-                \"Mockito cannot verify equals() and hashCode()\",\n-                \"Mockito defines and depends upon a specific implementation of these methods. Redefining them might break Mockito. Not to mention that verifying equals() or hashCode() most likely hints awkward design (hard to explain in a short exception message. Trust me...)\"\n-        ));\n-    }\n }\n--- a/src/org/mockito/internal/verification/VerificationDataImpl.java\n+++ b/src/org/mockito/internal/verification/VerificationDataImpl.java\n         if (o.isToString(wanted.getMethod())) {\n             new Reporter().cannotVerifyToString();\n         }\n-        if (o.isEqualsMethod(wanted.getMethod())) {\n-            new Reporter().cannotVerifyEqualsOrHashCode();\n-        }\n     }\n }\n--- /dev/null\n+++ b/test/org/mockito/internal/progress/ThreadSafeMockingProgressTest.java\n+package org.mockito.internal.progress;\n+\n+import org.junit.After;\n+import org.junit.Test;\n+import org.mockito.internal.verification.DummyVerificationMode;\n+import org.mockitoutil.TestBase;\n+\n+import java.util.List;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+\n+public class ThreadSafeMockingProgressTest extends TestBase {\n+\n+    @After\n+    public void after() {\n+        this.resetState();\n+    }\n+\n+    @Test\n+    public void shouldShareState() throws Exception {\n+        //given\n+        ThreadSafeMockingProgress p = new ThreadSafeMockingProgress();\n+        p.verificationStarted(new DummyVerificationMode());\n+\n+        //then\n+        p = new ThreadSafeMockingProgress();\n+        assertNotNull(p.pullVerificationMode());\n+    }\n+\n+    @Test\n+    public void shouldKnowWhenVerificationHasStarted() throws Exception {\n+        //given\n+        verify(mock(List.class));\n+        ThreadSafeMockingProgress p = new ThreadSafeMockingProgress();\n+\n+        //then\n+        assertNotNull(p.pullVerificationMode());\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/verification/DummyVerificationMode.java\n+package org.mockito.internal.verification;\n+\n+import org.mockito.internal.verification.api.VerificationData;\n+import org.mockito.internal.verification.api.VerificationMode;\n+\n+public class DummyVerificationMode implements VerificationMode {\n+    public void verify(VerificationData data) {\n+    }\n+}\n--- a/test/org/mockito/internal/verification/VerificationDataImplTest.java\n+++ b/test/org/mockito/internal/verification/VerificationDataImplTest.java\n \n public class VerificationDataImplTest extends TestBase {\n \n-    @Mock\n-    List mock;\n-\n-    @Test\n-    public void shouldOrdinaryMethodBeVerifiable() throws Exception {\n-        VerificationDataImpl v = new VerificationDataImpl(null, new InvocationBuilder().toInvocationMatcher());\n-        v.assertWantedIsVerifiable();\n-    }\n-\n-    @Test\n-    public void shouldNotBreakWhenWantedIsNull() throws Exception {\n-        VerificationDataImpl v = new VerificationDataImpl(new LinkedList<Invocation>(), null);\n-        v.assertWantedIsVerifiable();\n-    }\n-\n     @Test\n     public void shouldToStringBeNotVerifiable() throws Exception {\n         InvocationMatcher toString = new InvocationBuilder().method(\"toString\").toInvocationMatcher();\n             fail();\n         } catch (MockitoException e) {}\n     }\n-\n-    @Test\n-    public void shouldEqualsBeNotVerifiable() throws Exception {\n-        InvocationMatcher equals = new InvocationMatcher(invocationOf(Object.class, \"equals\", new Object()));\n-        try {\n-            new VerificationDataImpl(null, equals);\n-            fail();\n-        } catch (MockitoException e) {}\n-    }\n }\n--- a/test/org/mockitousage/misuse/RestrictedObjectMethodsTest.java\n+++ b/test/org/mockitousage/misuse/RestrictedObjectMethodsTest.java\n \n import static org.mockito.Mockito.*;\n \n+import org.junit.After;\n import org.junit.Ignore;\n import org.junit.Test;\n import org.mockito.InOrder;\n import org.mockito.Mock;\n import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.progress.ThreadSafeMockingProgress;\n+import org.mockito.internal.verification.DummyVerificationMode;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n+import java.util.List;\n+\n public class RestrictedObjectMethodsTest extends TestBase {\n \n-    @Mock IMethods mock;\n+    @Mock List mock;\n \n-    @Test(expected= MockitoException.class)\n-    public void shouldNotVerifyToString() {\n-        verify(mock).toString();\n+    @After\n+    public void after() {\n+        this.resetState();\n     }\n \n-    @Ignore\n-    @Test(expected= MockitoException.class)\n-    public void shouldNotVerifyHashCode() {\n+    @Test\n+    public void shouldScreamWhenVerifyToString() {\n+        try {\n+            verify(mock).toString();\n+            fail();\n+        } catch (MockitoException e) {\n+            assertContains(\"cannot verify\", e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldBeSilentWhenVerifyHashCode() {\n+        //because it leads to really wierd behavior sometimes\n+        //it's because cglib & my code can occasionelly call those methods\n+        // and when user has verification started at that time there will be a mess\n         verify(mock).hashCode();\n     }\n \n-    @Ignore\n-    @Test(expected= MockitoException.class)\n-    public void shouldNotVerifyEquals() {\n+    @Test\n+    public void shouldBeSilentWhenVerifyEquals() {\n+        //because it leads to really wierd behavior sometimes\n+        //it's because cglib & my code can occasionelly call those methods\n+        // and when user has verification started at that time there will be a mess\n+        verify(mock).equals(null);\n+    }\n+\n+    @Test\n+    public void shouldBeSilentWhenVerifyEqualsInOrder() {\n+        //because it leads to really wierd behavior sometimes\n+        //it's because cglib & my code can occasionelly call those methods\n+        // and when user has verification started at that time there will be a mess\n         InOrder inOrder = inOrder(mock);\n         inOrder.verify(mock).equals(null);\n-    }\n+    }       \n }", "timestamp": 1264025001, "metainfo": ""}