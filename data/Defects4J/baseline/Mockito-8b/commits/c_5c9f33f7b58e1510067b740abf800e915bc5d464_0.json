{"sha": "5c9f33f7b58e1510067b740abf800e915bc5d464", "log": "Fixed issue 375 : warn when .serializable() used with objects that don't implement Serializable", "commit": "\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n \n import org.mockito.exceptions.base.MockitoAssertionError;\n import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.exceptions.misusing.FriendlyReminderException;\n-import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n-import org.mockito.exceptions.misusing.MissingMethodInvocationException;\n-import org.mockito.exceptions.misusing.NotAMockException;\n-import org.mockito.exceptions.misusing.NullInsteadOfMockException;\n-import org.mockito.exceptions.misusing.UnfinishedStubbingException;\n-import org.mockito.exceptions.misusing.UnfinishedVerificationException;\n-import org.mockito.exceptions.misusing.WrongTypeOfReturnValue;\n-import org.mockito.exceptions.verification.ArgumentsAreDifferent;\n-import org.mockito.exceptions.verification.NeverWantedButInvoked;\n-import org.mockito.exceptions.verification.NoInteractionsWanted;\n-import org.mockito.exceptions.verification.SmartNullPointerException;\n-import org.mockito.exceptions.verification.TooLittleActualInvocations;\n-import org.mockito.exceptions.verification.TooManyActualInvocations;\n-import org.mockito.exceptions.verification.VerificationInOrderFailure;\n-import org.mockito.exceptions.verification.WantedButNotInvoked;\n+import org.mockito.exceptions.misusing.*;\n+import org.mockito.exceptions.verification.*;\n import org.mockito.internal.debugging.LocationImpl;\n import org.mockito.internal.exceptions.VerificationAwareInvocation;\n import org.mockito.internal.exceptions.util.ScenarioPrinter;\n         throw new MockitoException(join(\n                 \"Checked exception is invalid for this method!\",\n                 \"Invalid: \" + t\n-                ));\n+        ));\n     }\n \n     public void cannotStubWithNullThrowable() {\n         throw new MockitoException(join(\n                 \"Cannot stub with null throwable!\"\n-                ));\n+        ));\n \n     }\n \n                 \"    verifyNoMoreInteractions(mockOne, mockTwo);\",\n                 \"    verifyZeroInteractions(mockOne, mockTwo);\",\n                 \"\"\n-                ));\n+        ));\n     }\n \n     public void notAMockPassedToVerifyNoMoreInteractions() {\n         throw new NotAMockException(join(\n-            \"Argument(s) passed is not a mock!\",\n-            \"Examples of correct verifications:\",\n-            \"    verifyNoMoreInteractions(mockOne, mockTwo);\",\n-            \"    verifyZeroInteractions(mockOne, mockTwo);\",\n-            \"\"\n+                \"Argument(s) passed is not a mock!\",\n+                \"Examples of correct verifications:\",\n+                \"    verifyNoMoreInteractions(mockOne, mockTwo);\",\n+                \"    verifyZeroInteractions(mockOne, mockTwo);\",\n+                \"\"\n         ));\n     }\n \n                 \"Pass mocks that require verification in order.\",\n                 \"For example:\",\n                 \"    InOrder inOrder = inOrder(mockOne, mockTwo);\"\n-                ));\n+        ));\n     }\n \n     public void nullPassedWhenCreatingInOrder() {\n                 \"Pass mocks that require verification in order.\",\n                 \"For example:\",\n                 \"    InOrder inOrder = inOrder(mockOne, mockTwo);\"\n-                ));\n+        ));\n     }\n \n     public void mocksHaveToBePassedWhenCreatingInOrder() {\n                 \"Pass mocks that require verification in order.\",\n                 \"For example:\",\n                 \"    InOrder inOrder = inOrder(mockOne, mockTwo);\"\n-                ));\n+        ));\n     }\n \n     public void inOrderRequiresFamiliarMock() {\n                 \"For example:\",\n                 \"    InOrder inOrder = inOrder(mockOne);\",\n                 \"    inOrder.verify(mockOne).doStuff();\"\n-                ));\n+        ));\n     }\n \n     public void invalidUseOfMatchers(int expectedMatchersCount, List<LocalizedMatcher> recordedMatchers) {\n         throw new InvalidUseOfMatchersException(join(\n                 \"Invalid use of argument matchers!\",\n                 expectedMatchersCount + \" matchers expected, \" + recordedMatchers.size()+ \" recorded:\" +\n-                locationsOf(recordedMatchers),\n+                        locationsOf(recordedMatchers),\n                 \"\",\n                 \"This exception may occur if matchers are combined with raw values:\",\n                 \"    //incorrect:\",\n     private Object locationsOf(Collection<LocalizedMatcher> matchers) {\n         List<String> description = new ArrayList<String>();\n         for (LocalizedMatcher matcher : matchers)\n-\t\t\tdescription.add(matcher.getLocation().toString());\n+            description.add(matcher.getLocation().toString());\n         return join(description.toArray());\n     }\n \n                 actual,\n                 actualLocation,\n                 \"\"\n-                );\n+        );\n \n         if (JUnitTool.hasJUnit()) {\n             throw JUnitTool.createArgumentsAreDifferentException(message, wanted, actual);\n         } else {\n             StringBuilder sb = new StringBuilder(\"\\nHowever, there were other interactions with this mock:\\n\");\n             for (DescribedInvocation i : invocations) {\n-                 sb.append(i.getLocation());\n-                 sb.append(\"\\n\");\n+                sb.append(i.getLocation());\n+                sb.append(\"\\n\");\n             }\n             allInvocations = sb.toString();\n         }\n \n     public void wantedButNotInvokedInOrder(DescribedInvocation wanted, DescribedInvocation previous) {\n         throw new VerificationInOrderFailure(join(\n-                    \"Verification in order failure\",\n-                    \"Wanted but not invoked:\",\n-                    wanted.toString(),\n-                    new LocationImpl(),\n-                    \"Wanted anywhere AFTER following interaction:\",\n-                    previous.toString(),\n-                    previous.getLocation(),\n-                    \"\"\n+                \"Verification in order failure\",\n+                \"Wanted but not invoked:\",\n+                wanted.toString(),\n+                new LocationImpl(),\n+                \"Wanted anywhere AFTER following interaction:\",\n+                previous.toString(),\n+                previous.getLocation(),\n+                \"\"\n         ));\n     }\n \n     }\n \n     private String createTooManyInvocationsMessage(int wantedCount, int actualCount, DescribedInvocation wanted,\n-            Location firstUndesired) {\n+                                                   Location firstUndesired) {\n         return join(\n                 wanted.toString(),\n                 \"Wanted \" + pluralize(wantedCount) + \":\",\n         String message = createTooManyInvocationsMessage(wantedCount, actualCount, wanted, firstUndesired);\n         throw new VerificationInOrderFailure(join(\n                 \"Verification in order failure:\" + message\n-                ));\n+        ));\n     }\n \n     private String createTooLittleInvocationsMessage(org.mockito.internal.reporting.Discrepancy discrepancy, DescribedInvocation wanted,\n-            Location lastActualInvocation) {\n+                                                     Location lastActualInvocation) {\n         String ending =\n-            (lastActualInvocation != null)? lastActualInvocation + \"\\n\" : \"\\n\";\n-\n-            String message = join(\n-                    wanted.toString(),\n-                    \"Wanted \" + discrepancy.getPluralizedWantedCount() + \":\",\n-                    new LocationImpl(),\n-                    \"But was \" + discrepancy.getPluralizedActualCount() + \":\",\n-                    ending\n-            );\n-            return message;\n+                (lastActualInvocation != null)? lastActualInvocation + \"\\n\" : \"\\n\";\n+\n+        String message = join(\n+                wanted.toString(),\n+                \"Wanted \" + discrepancy.getPluralizedWantedCount() + \":\",\n+                new LocationImpl(),\n+                \"But was \" + discrepancy.getPluralizedActualCount() + \":\",\n+                ending\n+        );\n+        return message;\n     }\n \n     public void tooLittleActualInvocations(org.mockito.internal.reporting.Discrepancy discrepancy, DescribedInvocation wanted, Location lastActualLocation) {\n \n         throw new VerificationInOrderFailure(join(\n                 \"Verification in order failure:\" + message\n-                ));\n+        ));\n     }\n \n     public void noMoreInteractionsWanted(Invocation undesired, List<VerificationAwareInvocation> invocations) {\n                 \"But found this interaction:\",\n                 undesired.getLocation(),\n                 \"\"\n-                ));\n+        ));\n     }\n \n     public void cannotMockFinalClass(Class<?> clazz) {\n                 \"3. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - \",\n                 \"   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.\",\n                 \"\"\n-             ));\n+        ));\n     }\n \n     public void onlyVoidMethodsCanBeSetToDoNothing() {\n                 \"    .when(mock).someVoidMethod();\",\n                 \"Above means:\",\n                 \"someVoidMethod() does nothing the 1st time but throws an exception the 2nd time is called\"\n-             ));\n+        ));\n     }\n \n     public void wrongTypeOfReturnValue(String expectedType, String actualType, String methodName) {\n                 \"2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - \",\n                 \"   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.\",\n                 \"\"\n-                ));\n+        ));\n     }\n \n     public void wantedAtMostX(int maxNumberOfInvocations, int foundSize) {\n                 \"Also, this error might show up because you use argument matchers with methods that cannot be mocked.\",\n                 \"Following methods *cannot* be stubbed/verified: final/private/equals()/hashCode().\",\n                 \"\"\n-                ));\n+        ));\n     }\n \n     public void smartNullPointerException(String invocation, Location location) {\n                 location,\n                 invocation,\n                 \"\"\n-                ));\n+        ));\n     }\n \n     public void noArgumentValueWasCaptured() {\n                 \"    verify(mock).doSomething(argument.capture());\",\n                 \"    assertEquals(\\\"John\\\", argument.getValue().getName());\",\n                 \"\"\n-                ));\n+        ));\n     }\n \n     public void extraInterfacesDoesNotAcceptNullParameters() {\n         throw new MockitoException(join(\n                 \"extraInterfaces() does not accept null parameters.\"\n-                ));\n+        ));\n     }\n \n     public void extraInterfacesAcceptsOnlyInterfaces(Class<?> wrongType) {\n \n     public void cannotInitializeForSpyAnnotation(String fieldName, Exception details) {\n         throw new MockitoException(join(\"Cannot instantiate a @Spy for '\" + fieldName + \"' field.\",\n-            \"You haven't provided the instance for spying at field declaration so I tried to construct the instance.\",\n-            \"However, I failed because: \" + details.getMessage(),\n-            \"Examples of correct usage of @Spy:\",\n-            \"   @Spy List mock = new LinkedList();\",\n-            \"   @Spy Foo foo; //only if Foo has parameterless constructor\",\n-            \"   //also, don't forget about MockitoAnnotations.initMocks();\",\n+                \"You haven't provided the instance for spying at field declaration so I tried to construct the instance.\",\n+                \"However, I failed because: \" + details.getMessage(),\n+                \"Examples of correct usage of @Spy:\",\n+                \"   @Spy List mock = new LinkedList();\",\n+                \"   @Spy Foo foo; //only if Foo has parameterless constructor\",\n+                \"   //also, don't forget about MockitoAnnotations.initMocks();\",\n                 \"\"), details);\n     }\n \n     public void cannotInitializeForInjectMocksAnnotation(String fieldName, Exception details) {\n         throw new MockitoException(join(\"Cannot instantiate @InjectMocks field named '\" + fieldName + \"'.\",\n-            \"You haven't provided the instance at field declaration so I tried to construct the instance.\",\n-            \"However, I failed because: \" + details.getMessage(),\n-            \"Examples of correct usage of @InjectMocks:\",\n-            \"   @InjectMocks Service service = new Service();\",\n-            \"   @InjectMocks Service service;\",\n-            \"   //also, don't forget about MockitoAnnotations.initMocks();\",\n-            \"   //and... don't forget about some @Mocks for injection :)\",\n+                \"You haven't provided the instance at field declaration so I tried to construct the instance.\",\n+                \"However, I failed because: \" + details.getMessage(),\n+                \"Examples of correct usage of @InjectMocks:\",\n+                \"   @InjectMocks Service service = new Service();\",\n+                \"   @InjectMocks Service service;\",\n+                \"   //also, don't forget about MockitoAnnotations.initMocks();\",\n+                \"   //and... don't forget about some @Mocks for injection :)\",\n                 \"\"), details);\n     }\n \n         ), details);\n     }\n \n-\tpublic void mockedTypeIsInconsistentWithDelegatedInstanceType(Class mockedType, Object delegatedInstance) {\n-\t\tthrow new MockitoException(join(\n+    public void mockedTypeIsInconsistentWithDelegatedInstanceType(Class mockedType, Object delegatedInstance) {\n+        throw new MockitoException(join(\n                 \"Mocked type must be the same as the type of your delegated instance.\",\n                 \"Mocked type must be: \" + delegatedInstance.getClass().getSimpleName() + \", but is: \" + mockedType.getSimpleName(),\n                 \"  //correct delegate:\",\n                 \"  //incorrect - types don't match:\",\n                 \"  spy = mock( ->List.class<- , withSettings().delegatedInstance( ->new HashSet()<- );\"\n         ));\n-\t}\n-\n-\tpublic void spyAndDelegateAreMutuallyExclusive() {\n-\t\tthrow new MockitoException(join(\n-\t\t\t\t\"Settings should not define a spy instance and a delegated instance at the same time.\"\n-\t\t\t\t)) ;\n-\t}\n+    }\n+\n+    public void spyAndDelegateAreMutuallyExclusive() {\n+        throw new MockitoException(join(\n+                \"Settings should not define a spy instance and a delegated instance at the same time.\"\n+        )) ;\n+    }\n \n     public void invalidArgumentRangeAtIdentityAnswerCreationTime() {\n         throw new MockitoException(join(\"Invalid argument index.\",\n-                                        \"The index need to be a positive number that indicates the position of the argument to return.\",\n-                                        \"However it is possible to use the -1 value to indicates that the last argument should be\",\n-                                        \"returned.\"));\n+                \"The index need to be a positive number that indicates the position of the argument to return.\",\n+                \"However it is possible to use the -1 value to indicates that the last argument should be\",\n+                \"returned.\"));\n     }\n \n     public int invalidArgumentPositionRangeAtInvocationTime(InvocationOnMock invocation, boolean willReturnLastParameter, int argumentIndex) {\n         throw new MockitoException(\n                 join(\"Invalid argument index for the current invocation of method : \",\n-                     \" -> \" + new MockUtil().getMockName(invocation.getMock()) + \".\" + invocation.getMethod().getName() + \"()\",\n-                     \"\",\n-                     (willReturnLastParameter ?\n-                             \"Last parameter wanted\" :\n-                             \"Wanted parameter at position \" + argumentIndex) + \" but \" + possibleArgumentTypesOf(invocation),\n-                     \"The index need to be a positive number that indicates a valid position of the argument in the invocation.\",\n-                     \"However it is possible to use the -1 value to indicates that the last argument should be returned.\",\n-                     \"\"));\n+                        \" -> \" + new MockUtil().getMockName(invocation.getMock()) + \".\" + invocation.getMethod().getName() + \"()\",\n+                        \"\",\n+                        (willReturnLastParameter ?\n+                                \"Last parameter wanted\" :\n+                                \"Wanted parameter at position \" + argumentIndex) + \" but \" + possibleArgumentTypesOf(invocation),\n+                        \"The index need to be a positive number that indicates a valid position of the argument in the invocation.\",\n+                        \"However it is possible to use the -1 value to indicates that the last argument should be returned.\",\n+                        \"\"));\n     }\n \n     private StringBuilder possibleArgumentTypesOf(InvocationOnMock invocation) {\n                 \"\"\n         ));\n     }\n+\n+    public void serializableWontWorkForObjectsThatDontImplementSerializable(Class classToMock) {\n+        throw new MockitoException(join(\n+                \"You are using the setting 'withSettings().serializable()' however the type you are trying to mock '\" + classToMock.getSimpleName() + \"'\",\n+                \" do not implement Serializable.\",\n+                \"This combination is requested, otherwise you will get an 'java.io.InvalidClassException' when the mock will be serialized\",\n+                \"\",\n+                \"Also note that as requested by the Java serialization specification, the whole hierarchy need to implements Serializable,\",\n+                \"i.e. the top-most superclass has to implements Serializable.\",\n+                \"\"\n+        ));\n+    }\n }\n--- a/src/org/mockito/internal/creation/MockSettingsImpl.java\n+++ b/src/org/mockito/internal/creation/MockSettingsImpl.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.creation;\n \n import org.mockito.MockSettings;\n         return serializable;\n     }\n \n-\tpublic MockSettings verboseLogging() {\n+    public MockSettings verboseLogging() {\n         if (!invocationListenersContainsType(VerboseMockInvocationLogger.class)) {\n             invocationListeners(new VerboseMockInvocationLogger());\n         }\n         return this;\n-\t}\n+    }\n \n     public MockSettings invocationListeners(InvocationListener... listeners) {\n         if (listeners == null || listeners.length == 0) {\n             }\n             this.invocationListeners.add(listener);\n         }\n-\t\treturn this;\n-\t}\n+        return this;\n+    }\n \n-\tprivate boolean invocationListenersContainsType(Class<?> clazz) {\n-\t\tfor (InvocationListener listener : invocationListeners) {\n-\t\t\tif (listener.getClass().equals(clazz)) {\n-\t\t\t\treturn true;\n-\t\t\t}\n-\t\t}\n-\t\treturn false;\n-\t}\n+    private boolean invocationListenersContainsType(Class<?> clazz) {\n+        for (InvocationListener listener : invocationListeners) {\n+            if (listener.getClass().equals(clazz)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n \n     public List<InvocationListener> getInvocationListeners() {\n         return this.invocationListeners;\n         //TODO SF - add this validation and also add missing coverage\n //        validator.validateDelegatedInstance(classToMock, settings.getDelegatedInstance());\n \n+        validator.validateSerializable(typeToMock, source.isSerializable());\n+\n         CreationSettings<T> settings = new CreationSettings<T>(source);\n         settings.setMockName(new MockNameImpl(source.getName(), typeToMock));\n         settings.setTypeToMock(typeToMock);\n--- a/src/org/mockito/internal/util/MockCreationValidator.java\n+++ b/src/org/mockito/internal/util/MockCreationValidator.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util;\n \n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.creation.jmock.ClassImposterizer;\n \n+import java.io.Serializable;\n import java.util.Collection;\n \n @SuppressWarnings(\"unchecked\")\n     }\n \n     public void validateDelegatedInstance(Class classToMock, Object delegatedInstance) {\n-    \tif (classToMock == null || delegatedInstance == null) {\n+        if (classToMock == null || delegatedInstance == null) {\n             return;\n         }\n-    \tif (delegatedInstance.getClass().isAssignableFrom(classToMock)) {\n+        if (delegatedInstance.getClass().isAssignableFrom(classToMock)) {\n             new Reporter().mockedTypeIsInconsistentWithDelegatedInstanceType(classToMock, delegatedInstance);\n         }\n     }\n+\n+    public void validateSerializable(Class classToMock, boolean serializable) {\n+        // We can't catch all the errors with this piece of code\n+        // Having a **superclass that do not implements Serializable** might fail as well when serialized\n+        // Though it might prevent issues when mockito is mocking a class without superclass.\n+        if(serializable && !classToMock.isInterface() && !(Serializable.class.isAssignableFrom(classToMock))) {\n+            new Reporter().serializableWontWorkForObjectsThatDontImplementSerializable(classToMock);\n+        }\n+    }\n }\n--- a/test/org/mockito/internal/util/MockCreationValidatorTest.java\n+++ b/test/org/mockito/internal/util/MockCreationValidatorTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util;\n-\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.List;\n \n import org.junit.Test;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockitousage.IMethods;\n-import org.mockitoutil.TestBase;\n+\n+import java.util.*;\n \n import static java.util.Arrays.asList;\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.junit.Assert.fail;\n \n @SuppressWarnings(\"unchecked\")\n-public class MockCreationValidatorTest extends TestBase {\n+public class MockCreationValidatorTest {\n \n     final class FinalClass {}\n     MockCreationValidator validator = new MockCreationValidator();\n-    \n+\n     @Test\n-    public void shouldNotAllowExtraInterfaceThatIsTheSameAsTheMockedType() throws Exception {\n+    public void should_not_allow_extra_interface_that_is_the_same_as_the_mocked_type() throws Exception {\n         try {\n             //when\n             validator.validateExtraInterfaces(IMethods.class, (Collection) asList(IMethods.class));\n             fail();\n         } catch (MockitoException e) {\n             //then\n-            assertContains(\"You mocked following type: IMethods\", e.getMessage());\n+            assertThat(e.getMessage()).contains(\"You mocked following type: IMethods\");\n         }\n     }\n-        \n+\n+    @Test(expected = MockitoException.class)\n+    public void should_not_allow_inconsistent_types() throws Exception {\n+        //when\n+        validator.validateMockedType(List.class, new ArrayList());\n+        //then\n+    }\n+\n     @Test\n-    public void shouldNotAllowsInconsistentTypes() throws Exception {\n-        try {\n-            //when\n-            validator.validateMockedType(List.class, new ArrayList());\n-            fail();\n-            //then\n-        } catch(MockitoException e) {}\n-    }\n-    \n-    @Test\n-    public void shouldAllowOnlyConsistentTypes() throws Exception {\n+    public void should_allow_only_consistent_types() throws Exception {\n         //when\n         validator.validateMockedType(ArrayList.class, new ArrayList());\n         //then no exception is thrown\n     }\n-    \n+\n     @Test\n-    public void shouldValidationBeSafeWhenNullsPassed() throws Exception {\n+    public void should_validation_be_safe_when_nulls_passed() throws Exception {\n         //when\n         validator.validateMockedType(null, new ArrayList());\n         //or\n         validator.validateMockedType(ArrayList.class, null);\n         //then no exception is thrown\n     }\n+\n+    @Test(expected = MockitoException.class)\n+    public void should_not_allow_serializable_with_Object_that_dont_implement_Serializable() {\n+        boolean serializable = true;\n+        validator.validateSerializable(Observable.class, serializable);\n+    }\n+\n+    @Test\n+    public void should_allow_serializable_with_interfaces_or_Serializable_objects() {\n+        boolean serializable = true;\n+        validator.validateSerializable(Observer.class, serializable);\n+        validator.validateSerializable(Integer.class, serializable);\n+    }\n }\n--- a/test/org/mockitousage/basicapi/MocksSerializationTest.java\n+++ b/test/org/mockitousage/basicapi/MocksSerializationTest.java\n \n package org.mockitousage.basicapi;\n \n-import static org.mockito.Mockito.*;\n-\n-import java.io.*;\n-import java.util.*;\n-\n+import org.fest.assertions.Assertions;\n import org.junit.Test;\n import org.mockito.InOrder;\n+import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.matchers.Any;\n import org.mockito.internal.stubbing.answers.ThrowsException;\n import org.mockito.invocation.InvocationOnMock;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n \n+import java.io.ByteArrayOutputStream;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Observable;\n+\n+import static org.mockito.Mockito.*;\n+\n @SuppressWarnings({\"unchecked\", \"serial\"})\n public class MocksSerializationTest extends TestBase implements Serializable {\n \n     private static final long serialVersionUID = 6160482220413048624L;\n \n     @Test\n-    public void shouldAllowThrowsExceptionToBeSerializable() throws Exception {\n+    public void should_allow_throws_exception_to_be_serializable() throws Exception {\n         // given\n         Bar mock = mock(Bar.class, new ThrowsException(new RuntimeException()));\n         // when-serialize then-deserialize\n     }\n \n     @Test\n-    public void shouldAllowMethodDelegation() throws Exception {\n+    public void should_allow_method_delegation() throws Exception {\n         // given\n         Bar barMock = mock(Bar.class, withSettings().serializable());\n         Foo fooMock = mock(Foo.class);\n         //when-serialize then-deserialize\n         serializeAndBack(barMock);\n     }\n-    \n-    @Test\n-    public void shouldAllowMockToBeSerializable() throws Exception {\n+\n+    @Test\n+    public void should_allow_mock_to_be_serializable() throws Exception {\n         // given\n         IMethods mock = mock(IMethods.class, withSettings().serializable());\n \n     }\n \n     @Test\n-    public void shouldAllowMockAndBooleanValueToSerializable() throws Exception {\n+    public void should_allow_mock_and_boolean_value_to_serializable() throws Exception {\n         // given\n         IMethods mock = mock(IMethods.class, withSettings().serializable());\n         when(mock.booleanReturningMethod()).thenReturn(true);\n     }\n \n     @Test\n-    public void shouldAllowMockAndStringValueToBeSerializable() throws Exception {\n+    public void should_allow_mock_and_string_value_to_be_serializable() throws Exception {\n         // given\n         IMethods mock = mock(IMethods.class, withSettings().serializable());\n         String value = \"value\";\n     }\n \n     @Test\n-    public void shouldAllMockAndSerializableValueToBeSerialized() throws Exception {\n+    public void should_all_mock_and_serializable_value_to_be_serialized() throws Exception {\n         // given\n         IMethods mock = mock(IMethods.class, withSettings().serializable());\n         List<?> value = Collections.emptyList();\n     }\n \n     @Test\n-    public void shouldSerializeMethodCallWithParametersThatAreSerializable() throws Exception {\n+    public void should_serialize_method_call_with_parameters_that_are_serializable() throws Exception {\n         IMethods mock = mock(IMethods.class, withSettings().serializable());\n         List<?> value = Collections.emptyList();\n         when(mock.objectArgMethod(value)).thenReturn(value);\n     }\n \n     @Test\n-    public void shouldSerializeMethodCallsUsingAnyStringMatcher() throws Exception {\n+    public void should_serialize_method_calls_using_any_string_matcher() throws Exception {\n         IMethods mock = mock(IMethods.class, withSettings().serializable());\n         List<?> value = Collections.emptyList();\n         when(mock.objectArgMethod(anyString())).thenReturn(value);\n     }\n \n     @Test\n-    public void shouldVerifyCalledNTimesForSerializedMock() throws Exception {\n+    public void should_verify_called_n_times_for_serialized_mock() throws Exception {\n         IMethods mock = mock(IMethods.class, withSettings().serializable());\n         List<?> value = Collections.emptyList();\n         when(mock.objectArgMethod(anyString())).thenReturn(value);\n     }\n \n     @Test\n-    public void shouldVerifyEvenIfSomeMethodsCalledAfterSerialization() throws Exception {\n+    public void should_verify_even_if_some_methods_called_after_serialization() throws Exception {\n         //given\n         IMethods mock = mock(IMethods.class, withSettings().serializable());\n \n     }\n \n     @Test\n-    public void shouldSerializationWork() throws Exception {\n+    public void should_serialization_work() throws Exception {\n         //given\n         Foo foo = new Foo();\n         //when\n     }\n \n     @Test\n-    public void shouldStubEvenIfSomeMethodsCalledAfterSerialization() throws Exception {\n+    public void should_stub_even_if_some_methods_called_after_serialization() throws Exception {\n         //given\n         IMethods mock = mock(IMethods.class, withSettings().serializable());\n \n     }\n \n     @Test\n-    public void shouldVerifyCallOrderForSerializedMock() throws Exception {\n+    public void should_verify_call_order_for_serialized_mock() throws Exception {\n         IMethods mock = mock(IMethods.class, withSettings().serializable());\n         IMethods mock2 = mock(IMethods.class, withSettings().serializable());\n         mock.arrayReturningMethod();\n     }\n \n     @Test\n-    public void shouldRememberInteractionsForSerializedMock() throws Exception {\n+    public void should_remember_interactions_for_serialized_mock() throws Exception {\n         IMethods mock = mock(IMethods.class, withSettings().serializable());\n         List<?> value = Collections.emptyList();\n         when(mock.objectArgMethod(anyString())).thenReturn(value);\n     }\n \n     @Test\n-    public void shouldSerializeWithStubbingCallback() throws Exception {\n-\n-        // given\n-        IMethods mock = mock(IMethods.class, withSettings().serializable());\n-        CustomAnswersMustImplementSerializableForSerializationToWork answer = \n-            new CustomAnswersMustImplementSerializableForSerializationToWork();\n+    public void should_serialize_with_stubbing_callback() throws Exception {\n+\n+        // given\n+        IMethods mock = mock(IMethods.class, withSettings().serializable());\n+        CustomAnswersMustImplementSerializableForSerializationToWork answer =\n+                new CustomAnswersMustImplementSerializableForSerializationToWork();\n         answer.string = \"return value\";\n         when(mock.objectArgMethod(anyString())).thenAnswer(answer);\n \n         assertEquals(answer.string, readObject.objectArgMethod(\"\"));\n     }\n \n-    class CustomAnswersMustImplementSerializableForSerializationToWork \n-        implements Answer<Object>, Serializable {\n+    class CustomAnswersMustImplementSerializableForSerializationToWork\n+            implements Answer<Object>, Serializable {\n         private String string;\n         public Object answer(InvocationOnMock invocation) throws Throwable {\n             invocation.getArguments();\n             return string;\n         }\n     }\n-  \n-    @Test\n-    public void shouldSerializeWithRealObjectSpy() throws Exception {\n+\n+    @Test\n+    public void should_serialize_with_real_object_spy() throws Exception {\n         // given\n         List<Object> list = new ArrayList<Object>();\n         List<Object> spy = mock(ArrayList.class, withSettings()\n-                        .spiedInstance(list)\n-                        .defaultAnswer(CALLS_REAL_METHODS)\n-                        .serializable());\n+                .spiedInstance(list)\n+                .defaultAnswer(CALLS_REAL_METHODS)\n+                .serializable());\n         when(spy.size()).thenReturn(100);\n \n         // when\n     }\n \n     @Test\n-    public void shouldSerializeObjectMock() throws Exception {\n+    public void should_serialize_object_mock() throws Exception {\n         // given\n         Any mock = mock(Any.class);\n \n     }\n \n     @Test\n-    public void shouldSerializeRealPartialMock() throws Exception {\n+    public void should_serialize_real_partial_mock() throws Exception {\n         // given\n         Any mock = mock(Any.class, withSettings().serializable());\n         when(mock.matches(anyObject())).thenCallRealMethod();\n     class AlreadySerializable implements Serializable {}\n \n     @Test\n-    public void shouldSerializeAlreadySerializableClass() throws Exception {\n+    public void should_serialize_already_serializable_class() throws Exception {\n         // given\n         AlreadySerializable mock = mock(AlreadySerializable.class, withSettings().serializable());\n         when(mock.toString()).thenReturn(\"foo\");\n     }\n \n     @Test\n-    public void shouldBeSerializeAndHaveExtraInterfaces() throws Exception {\n+    public void should_be_serialize_and_have_extra_interfaces() throws Exception {\n         //when\n         IMethods mock = mock(IMethods.class, withSettings().serializable().extraInterfaces(List.class));\n         IMethods mockTwo = mock(IMethods.class, withSettings().extraInterfaces(List.class).serializable());\n         serializeAndBack((List) mock);\n         serializeAndBack((List) mockTwo);\n     }\n+\n+    @Test\n+    public void should_fail_when_serializable_used_with_object_that_dont_implements_Serializable() throws Exception {\n+        try {\n+            serializeMock(mock(Observable.class, withSettings().serializable()));\n+            fail();\n+        } catch (MockitoException e) {\n+            Assertions.assertThat(e.getMessage()).contains(Observable.class.getSimpleName()).contains(\"serializable()\").contains(\"implement Serializable\");\n+        }\n+    }\n }", "timestamp": 1346952994, "metainfo": ""}