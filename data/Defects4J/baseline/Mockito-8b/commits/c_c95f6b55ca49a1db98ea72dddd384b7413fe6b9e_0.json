{"sha": "c95f6b55ca49a1db98ea72dddd384b7413fe6b9e", "log": "correct merge of branch issue 238 on constructor injection", "commit": "\n--- a/src/org/mockito/InjectMocks.java\n+++ b/src/org/mockito/InjectMocks.java\n  * <li>Minimizes repetitive mock and spy injection.</li>\n  * </ul>\n  * <p>\n- * Currently it injects fields via reflection. If you prefer constructor/setter injection - please contribute a patch.\n- * </p>\n+ * Mockito will try to inject mocks only either by constructor injection,\n+ * setter injection, or property injection in order and as described below.\n+ * If any of the following strategy fail, then Mockito <strong>won't report failure</strong>;\n+ * i.e. you will have to provide dependencies yourself.\n+ * <ol>\n+ *     <li><strong>Constructor injection</strong>; the biggest constructor is chosen,\n+ *     then arguments are resolved with mocks declared in the test only.\n+ *     <p><u>Note:</u> If arguments can not be found, then null is passed.\n+ *     If non-mockable types are wanted, then constructor injection won't happen.\n+ *     In these cases, you will have to satisfy dependencies yourself.</p></li>\n  *\n- * <p>\n- * Mockito tries to inject by type (using name in case types are the same). \n- * Mockito does not throw anything when injection fails - you will have to satisfy the dependencies manually.\n+ *     <li><strong>Property setter injection</strong>; mocks will first be resolved by type,\n+ *     then (using name if there is several property of the same type).\n+ *     <p><u>Note:</u> If type wasn't initialized before and have a no-arg constructor,\n+ *     then it will be initialized with this constructor.</p></li>\n+ *\n+ *     <li><strong>Field injection</strong>; mocks will first be resolved by type,\n+ *     then (using name if there is several property of the same type).\n+ *     <p><u>Note:</u> If type wasn't initialized before and have a no-arg constructor,\n+ *     then it will be initialized with this constructor.</p></li>\n+ * </ol>\n  * </p>\n  *\n  * <p>\n  *       &#064;Mock private ArticleDatabase database;\n  *       &#064;Spy private UserProvider userProvider = new ConsumerUserProvider();\n  *\n- *       &#064;InjectMocks private ArticleManager manager = new ArticleManager();\n+ *       &#064;InjectMocks private ArticleManager manager;\n  *\n  *       &#064;Test public void shouldDoSomething() {\n  *           manager.initiateArticle();\n  *       }\n  *   }\n  * </pre>\n- *\n- * <b>The field annotated with &#064;InjectMocks can be initiatialized explicitly (just like in the example).\n- * Alternatively, if you don't provide the instance Mockito will try to find zero argument constructor (even private) and create an instance for you.\n- * <u>But Mockito cannot instantiate inner classes, local classes, abstract classes and interfaces.</u></b>\n- *\n- * For example this class can be instantiated by Mockito :\n- * <pre>public class Bar {\n- *    private Bar() {}\n- *    public Bar(String publicConstructorWithOneArg) {}\n- * }</pre>\n- * </p>\n- *\n  * </p>\n  *\n  * <p>\n- * Note that &#064;InjectMocks will only inject mocks/spies created using the &#64;Spy or &#64;Mock annotation.\n+ * In the above example the field ArticleManager annotated with &#064;InjectMocks can have\n+ * a parameterized constructor only or a no-arg constructor only, or both.\n+ * All these constructors can be package protected, protected or private, however\n+ * <u>Mockito cannot instantiate inner classes, local classes, abstract classes and of course interfaces.</u>\n+ *\n+ * <p>The same stands for setters or fields, they can be declared with private\n+ * visibility, Mockito will see them through reflection.</p>\n+ *\n+ * <p>So on the field that needs injection, for example constructor injection will happen here :</p>\n+ * <pre>\n+ *   public class ArticleManager {\n+ *       ArticleManager(ArticleCalculator calculator, ArticleDatabase database) {\n+ *           // parameterized constructor\n+ *       }\n+ *   }\n+ * </pre>\n+ *\n+ * <p>Property setter injection will happen here :</p>\n+ * <pre>\n+ *   public class ArticleManager {\n+ *       ArticleManager() {\n+ *           // no-arg constructor\n+ *       }\n+ *\n+ *       void setDatabase(ArticleDatabase database) {\n+ *           // setter\n+ *       }\n+ *   }\n+ * </pre>\n+ *\n+ * <p>Field injection will be used here :</p>\n+ * <pre>\n+ *   public class ArticleManager {\n+ *       private ArticleDatabase database;\n+ *       private ArticleCalculator calculator;\n+ *   }\n+ * </pre>\n+ * </p>\n+ *\n+ * <p>And finally, no injection will happen on the type in this case:</p>\n+ * <pre>\n+ *   public class ArticleManager {\n+ *       private ArticleDatabase database;\n+ *       private ArticleCalculator calculator;\n+ *\n+ *       ArticleManager(ArticleObserver observer, boolean flag) {\n+ *           // observer is not declared in the test above.\n+ *           // flag is not mockable anyway\n+ *       }\n+ *   }\n+ * </pre>\n+ * </p>\n+ *\n+ *\n+ * <p>\n+ * Again, note that &#064;InjectMocks will only inject mocks/spies created using the &#64;Spy or &#64;Mock annotation.\n  * </p>\n  *\n  * <p>\n  * <b><code>MockitoAnnotations.injectMocks(this)</code></b> method has to called to initialize annotated objects.\n+ * A <code>MockitoJUnitRunner</code> can also be used to initialize mocks instead of the &#64;Before approach.\n  * <p>\n  *\n  * <p>\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n  *\n  * <h3 id=\"23\">23. (**New**) Automatic instantiation of &#064;Spy, &#064;InjectMocks fields (Since 1.9)</h3>\n  * <p>\n- * Mockito will now try to instantiate &#064;{@link Spy} and &#064;{@link InjectMocks} fields if you haven't provided instance at declaration\n- * *and* if the type has a zero-arg argument (even private).\n+ * Mockito will now try to instantiate &#064;{@link Spy} and will instantiate &#064;{@link InjectMocks} fields\n+ * using constructor injection, setter injection, or field injection.\n  * <p>\n  * To take advantage of this feature you need to use {@link MockitoAnnotations#initMocks(Object)} or {@link MockitoJUnitRunner}.\n  * <p>\n- * Read more about available {@link MockitoAnnotations}\n+ * Read more about available tricks {@link InjectMocks}\n  * <pre>\n  * //instead:\n  * &#064;Spy BeerDrinker drinker = new BeerDrinker();\n--- a/src/org/mockito/MockitoAnnotations.java\n+++ b/src/org/mockito/MockitoAnnotations.java\n         AnnotationEngine annotationEngine = new GlobalConfiguration().getAnnotationEngine();\n         Class<?> clazz = testClass.getClass();\n \n-        //below can be removed later, when we get rid of deprecated stuff\n+        //below can be removed later, when we get read rid of deprecated stuff\n         if (annotationEngine.getClass() != new DefaultMockitoConfiguration().getAnnotationEngine().getClass()) {\n             //this means user has his own annotation engine and we have to respect that.\n             //we will do annotation processing the old way so that we are backwards compatible\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n  */\n package org.mockito.exceptions;\n \n-import static org.mockito.exceptions.Pluralizer.pluralize;\n-import static org.mockito.internal.util.StringJoiner.join;\n-\n-import java.util.List;\n-\n import org.mockito.exceptions.base.MockitoAssertionError;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.exceptions.misusing.*;\n-import org.mockito.exceptions.verification.ArgumentsAreDifferent;\n-import org.mockito.exceptions.verification.NeverWantedButInvoked;\n-import org.mockito.exceptions.verification.NoInteractionsWanted;\n-import org.mockito.exceptions.verification.SmartNullPointerException;\n-import org.mockito.exceptions.verification.TooLittleActualInvocations;\n-import org.mockito.exceptions.verification.TooManyActualInvocations;\n-import org.mockito.exceptions.verification.VerificationInOrderFailure;\n-import org.mockito.exceptions.verification.WantedButNotInvoked;\n+import org.mockito.exceptions.verification.*;\n import org.mockito.exceptions.verification.junit.JUnitTool;\n import org.mockito.internal.debugging.Location;\n import org.mockito.internal.exceptions.VerificationAwareInvocation;\n import org.mockito.internal.exceptions.util.ScenarioPrinter;\n import org.mockito.internal.invocation.Invocation;\n+\n+import java.lang.reflect.Field;\n+import java.util.List;\n+\n+import static org.mockito.exceptions.Pluralizer.pluralize;\n+import static org.mockito.internal.util.StringJoiner.join;\n \n /**\n  * Reports verification and misusing errors.\n     }\n \n     public void cannotInitializeForSpyAnnotation(String fieldName, Exception details) {\n-        throw new MockitoException(join(\"Cannot instianate a @Spy for '\" + fieldName + \"' field.\",\n+        throw new MockitoException(join(\"Cannot instantiate a @Spy for '\" + fieldName + \"' field.\",\n             \"You haven't provided the instance for spying at field declaration so I tried to construct the instance.\",\n             \"However, I failed because: \" + details.getMessage(),\n             \"Examples of correct usage of @Spy:\",\n     }\n \n     public void cannotInitializeForInjectMocksAnnotation(String fieldName, Exception details) {\n-        throw new MockitoException(join(\"Cannot instianate @InjectMocks field named '\" + fieldName + \"'.\",\n-            \"You haven't provided the instance for spying at field declaration so I tried to construct the instance.\",\n+        throw new MockitoException(join(\"Cannot instantiate @InjectMocks field named '\" + fieldName + \"'.\",\n+            \"You haven't provided the instance at field declaration so I tried to construct the instance.\",\n             \"However, I failed because: \" + details.getMessage(),\n             \"Examples of correct usage of @InjectMocks:\",\n             \"   @InjectMocks Service service = new Service();\",\n-            \"   @InjectMocks Service service; //only if Service has parameterless constructor\",\n+            \"   @InjectMocks Service service;\",\n             \"   //also, don't forget about MockitoAnnotations.initMocks();\",\n             \"   //and... don't forget about some @Mocks for injection :)\",\n                 \"\"), details);\n                 \"If you want to find out more please refer to issue 235\",\n                 \"\"));\n     }\n-}\n+\n+    public void fieldInitialisationThrewException(Field field, Throwable details) {\n+        throw new MockitoException(join(\n+                \"Cannot instantiate @InjectMocks field named '\" + field.getName() + \"' of type '\" + field.getType() +  \"'.\",\n+                \"You haven't provided the instance at field declaration so I tried to construct the instance.\",\n+                \"However the constructor or the initialization block threw an exception : \" + details.getMessage(),\n+                \"\"), details);\n+\n+    }\n+}\n--- a/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\n+++ b/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\n  */\n package org.mockito.internal.configuration;\n \n-import org.mockito.exceptions.Reporter;\n-import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.configuration.injection.FinalMockCandidateFilter;\n-import org.mockito.internal.configuration.injection.MockCandidateFilter;\n-import org.mockito.internal.configuration.injection.NameBasedCandidateFilter;\n-import org.mockito.internal.configuration.injection.TypeBasedCandidateFilter;\n-import org.mockito.internal.util.reflection.FieldInitializer;\n+import org.mockito.internal.configuration.injection.MockInjection;\n \n import java.lang.reflect.Field;\n-import java.util.Arrays;\n-import java.util.Comparator;\n-import java.util.HashSet;\n import java.util.Set;\n \n /**\n- * Initializes mock/spies dependencies for fields annotated with &#064;InjectMocks\n+ * Inject mock/spies dependencies for fields annotated with &#064;InjectMocks\n  * <p/>\n  * See {@link org.mockito.MockitoAnnotations}\n  */\n public class DefaultInjectionEngine {\n \n-    private final MockCandidateFilter mockCandidateFilter = new TypeBasedCandidateFilter(new NameBasedCandidateFilter(new FinalMockCandidateFilter()));\n-    private Comparator<Field> supertypesLast = new Comparator<Field>() {\n-        public int compare(Field field1, Field field2) {\n-            Class<?> field1Type = field1.getType();\n-            Class<?> field2Type = field2.getType();\n-\n-            if(field1Type.isAssignableFrom(field2Type)) {\n-                return 1;\n-            }\n-            if(field2Type.isAssignableFrom(field1Type)) {\n-                return -1;\n-            }\n-            return 0;\n-        }\n-    };\n-\n-    /**\n-     * Inject mocks in injectMocksFields, and initialize them if needed.\n-     *\n-     * <p>\n-     * <u>Algorithm :<br></u>\n-     * for each field annotated by @InjectMocks\n-     *   <ul>\n-     *   <li>copy mocks set\n-     *   <li>initialize field annotated by @InjectMocks\n-     *   <li>for each field in @InjectMocks type ordered from sub-type to super-type\n-     *     <ul>\n-     *     <li>find mock candidate by type\n-     *     <li>if more than *one* candidate find mock candidate on name\n-     *     <li>if one mock candidate then\n-     *       <ul>\n-     *       <li>set mock by property setter if possible\n-     *       <li>else set mock by field injection\n-     *       </ul>\n-     *     <li>remove mock from mocks copy (mocks are just injected once)\n-     *     <li>else don't fail, user will then provide dependencies\n-     *     </ul>\n-     *   </ul>\n-     * </p>\n-     *\n-     * @param injectMocksFields Fields annotated by @InjectMocks\n-     * @param mocks Mocks\n-     * @param testClassInstance The test class instance\n-     */\n-    public void injectMocksOnFields(Set<Field> injectMocksFields, Set<Object> mocks, Object testClassInstance) {\n-        for (Field field : injectMocksFields) {\n-            Set<Object> mocksToBeInjected = new HashSet<Object>(mocks);\n-            Object injectMocksFieldInstance = null;\n-            try {\n-                injectMocksFieldInstance = new FieldInitializer(testClassInstance, field).initialize();\n-            } catch (MockitoException e) {\n-                new Reporter().cannotInitializeForInjectMocksAnnotation(field.getName(), e);\n-            }\n-\n-            // for each field in the class hierarchy\n-            Class<?> fieldClass = injectMocksFieldInstance.getClass();\n-            while (fieldClass != Object.class) {\n-                injectMockCandidate(fieldClass, mocksToBeInjected, injectMocksFieldInstance);\n-                fieldClass = fieldClass.getSuperclass();\n-            }\n-        }\n-    }\n-\n-    private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n-        for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            Object injected = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n-            mocks.remove(injected);\n-        }\n-    }\n-\n-    private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n-        Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n-        Arrays.sort(declaredFields, supertypesLast);\n-        return declaredFields;\n+    public void injectMocksOnFields(Set<Field> needingInjection, Set<Object> mocks, Object testClassInstance) {\n+        MockInjection.onFields(needingInjection, testClassInstance)\n+                .withMocks(mocks)\n+                .tryConstructorInjection()\n+                .tryPropertyOrFieldInjection()\n+                .handleSpyAnnotation()\n+                .apply();\n     }\n \n }\n--- a/src/org/mockito/internal/configuration/InjectingAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/InjectingAnnotationEngine.java\n     private void processInjectMocks(final Class<?> clazz, final Object testInstance) {\n         Class<?> classContext = clazz;\n         while (classContext != Object.class) {\n-            //this injects mocks\n-            Field[] fields = classContext.getDeclaredFields();\n-            for (Field field : fields) {\n-                if (field.isAnnotationPresent(InjectMocks.class)) {\n-                    assertNoAnnotations(field, Mock.class, MockitoAnnotations.Mock.class, Captor.class);\n-                    injectMocks(testInstance);\n-                }\n-            }\n+            injectMocks(testInstance);\n             classContext = classContext.getSuperclass();\n         }\n     }\n      */\n     public void injectMocks(final Object testClass) {\n         Class<?> clazz = testClass.getClass();\n-        Set<Field> mockDependents = new HashSet<Field>();\n+        Set<Field> mockDependentFields = new HashSet<Field>();\n         Set<Object> mocks = new HashSet<Object>();\n         \n         while (clazz != Object.class) {\n-            mockDependents.addAll(scanForInjection(testClass, clazz));\n+            mockDependentFields.addAll(scanForInjection(testClass, clazz));\n             mocks.addAll(scanMocks(testClass, clazz));\n             clazz = clazz.getSuperclass();\n         }\n         \n-        new DefaultInjectionEngine().injectMocksOnFields(mockDependents, mocks, testClass);\n+        new DefaultInjectionEngine().injectMocksOnFields(mockDependentFields, mocks, testClass);\n     }\n \n     /**\n      * @param clazz\n      * @return\n      */\n-    private static Set<Field> scanForInjection(final Object testClass, final Class<?> clazz) {\n-        Set<Field> testedFields = new HashSet<Field>();\n+    private Set<Field> scanForInjection(final Object testClass, final Class<?> clazz) {\n+        Set<Field> mockDependentFields = new HashSet<Field>();\n         Field[] fields = clazz.getDeclaredFields();\n         for (Field field : fields) {\n             if (null != field.getAnnotation(InjectMocks.class)) {\n-                testedFields.add(field);\n+                assertNoAnnotations(field, Mock.class, MockitoAnnotations.Mock.class, Captor.class);\n+                mockDependentFields.add(field);\n             }\n         }\n \n-        return testedFields;\n+        return mockDependentFields;\n     }\n \n-    private static Set<Object> scanMocks(final Object testClass, final Class<?> clazz) {\n+    private Set<Object> scanMocks(final Object testClass, final Class<?> clazz) {\n         Set<Object> mocks = new HashSet<Object>();\n         for (Field field : clazz.getDeclaredFields()) {\n             // mock or spies only\n                 try {\n                     fieldInstance = field.get(testClass);\n                 } catch (IllegalAccessException e) {\n-                    throw new MockitoException(\"Problems injecting dependencies in \" + field.getName(), e);\n+                    throw new MockitoException(\"Problems reading this field dependency \" + field.getName() + \" for injection\", e);\n                 } finally {\n                     field.setAccessible(wasAccessible);\n                 }\n--- a/src/org/mockito/internal/configuration/SpyAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/SpyAnnotationEngine.java\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.util.MockUtil;\n+import org.mockito.internal.util.reflection.FieldInitializationReport;\n import org.mockito.internal.util.reflection.FieldInitializer;\n \n import java.lang.annotation.Annotation;\n \n import static org.mockito.Mockito.withSettings;\n \n+/**\n+ * Process fields annotated with &#64;Spy.\n+ *\n+ * <p>\n+ * Will try transform the field in a spy as with <code>Mockito.spy()</code>.\n+ * </p>\n+ *\n+ * <p>\n+ * If the field is not initialized, will try to initialize it, with a no-arg constructor.\n+ * </p>\n+ *\n+ * <p>\n+ * If the field is also annotated with the <strong>compatible</strong> &#64;InjectMocks then the field will be ignored,\n+ * The injection engine will handle this specific case.\n+ * </p>\n+ *\n+ * <p>This engine will fail, if the field is also annotated with incompatible Mockito annotations.\n+ */\n @SuppressWarnings({\"unchecked\"})\n public class SpyAnnotationEngine implements AnnotationEngine {\n \n     public Object createMockFor(Annotation annotation, Field field) {\n         return null;\n     }\n-    \n-    @SuppressWarnings(\"deprecation\")\n+\n+    @SuppressWarnings(\"deprecation\") // for MockitoAnnotations.Mock\n     public void process(Class<?> context, Object testInstance) {\n         Field[] fields = context.getDeclaredFields();\n         for (Field field : fields) {\n-            if (field.isAnnotationPresent(Spy.class)) {\n-                assertNoAnnotations(Spy.class, field, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);\n+            if (field.isAnnotationPresent(Spy.class) && !field.isAnnotationPresent(InjectMocks.class)) {\n+                assertNoIncompatibleAnnotations(Spy.class, field, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);\n                 Object instance = null;\n                 try {\n-                    instance = new FieldInitializer(testInstance, field).initialize();\n+                    FieldInitializationReport report = new FieldInitializer(testInstance, field).initialize();\n+                    instance = report.fieldInstance();\n                 } catch (MockitoException e) {\n                     new Reporter().cannotInitializeForSpyAnnotation(field.getName(), e);\n                 }\n                 try {\n                     if (new MockUtil().isMock(instance)) {\n                         // instance has been spied earlier\n+                        // for example happens when MockitoAnnotations.initMocks is called two times.\n                         Mockito.reset(instance);\n                     } else {\n                         field.setAccessible(true);\n     }\n     \n     //TODO duplicated elsewhere\n-    void assertNoAnnotations(Class annotation, Field field, Class ... undesiredAnnotations) {\n+    void assertNoIncompatibleAnnotations(Class annotation, Field field, Class... undesiredAnnotations) {\n         for (Class u : undesiredAnnotations) {\n             if (field.isAnnotationPresent(u)) {\n                 new Reporter().unsupportedCombinationOfAnnotations(annotation.getSimpleName(), annotation.getClass().getSimpleName());\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/injection/ConstructorInjection.java\n+package org.mockito.internal.configuration.injection;\n+\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.util.reflection.FieldInitializationReport;\n+import org.mockito.internal.util.reflection.FieldInitializer;\n+import org.mockito.internal.util.reflection.FieldInitializer.ConstructorArgumentResolver;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * Injection strategy based on constructor.\n+ *\n+ * <p>\n+ * The strategy will search for the constructor with most parameters\n+ * and try to resolve mocks by type.\n+ * </p>\n+ *\n+ * <blockquote>\n+ * TODO on missing mock type, shall it abandon or create \"noname\" mocks.\n+ * TODO and what if the arg type is not mockable.\n+ * </blockquote>\n+ *\n+ * <p>\n+ * For now the algorithm tries to create anonymous mocks if an argument type is missing.\n+ * If not possible the algorithm abandon resolution.\n+ * </p>\n+ */\n+public class ConstructorInjection extends MockInjectionStrategy {\n+\n+    private ConstructorArgumentResolver argResolver;\n+\n+    public ConstructorInjection() { }\n+\n+    // visible for testing\n+    ConstructorInjection(ConstructorArgumentResolver argResolver) {\n+        this.argResolver = argResolver;\n+    }\n+\n+    public boolean processInjection(Field field, Object fieldOwner, Set<Object> mockCandidates) {\n+        try {\n+            SimpleArgumentResolver simpleArgumentResolver = new SimpleArgumentResolver(mockCandidates);\n+            FieldInitializationReport report = new FieldInitializer(fieldOwner, field, simpleArgumentResolver).initialize();\n+\n+            return report.fieldWasInitialized();\n+        } catch (MockitoException e) {\n+            if(e.getCause() instanceof InvocationTargetException) {\n+                Throwable realCause = e.getCause().getCause();\n+                new Reporter().fieldInitialisationThrewException(field, realCause);\n+            }\n+            return false;\n+        }\n+\n+    }\n+\n+    /**\n+     * Returns mocks that match the argument type, if not possible assigns null.\n+     */\n+    static class SimpleArgumentResolver implements ConstructorArgumentResolver {\n+        final Set<Object> objects;\n+\n+        public SimpleArgumentResolver(Set<Object> objects) {\n+            this.objects = objects;\n+        }\n+\n+        public Object[] resolveTypeInstances(Class<?>... argTypes) {\n+            List<Object> argumentInstances = new ArrayList<Object>(argTypes.length);\n+            for (Class<?> argType : argTypes) {\n+                argumentInstances.add(objectThatIsAssignableFrom(argType));\n+            }\n+            return argumentInstances.toArray();\n+        }\n+\n+        private Object objectThatIsAssignableFrom(Class<?> argType) {\n+            for (Object object : objects) {\n+                if(argType.isAssignableFrom(object.getClass())) return object;\n+            }\n+            return null;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/injection/MockInjection.java\n+package org.mockito.internal.configuration.injection;\n+\n+import java.lang.reflect.Field;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static org.mockito.internal.util.Checks.checkItemsNotNull;\n+import static org.mockito.internal.util.Checks.checkNotNull;\n+\n+/**\n+ * Internal injection configuration utility.\n+ *\n+ * <p>\n+ * Allow the user of this class to configure the way the injection of mocks will happen.\n+ * </p>\n+ *\n+ */\n+public class MockInjection {\n+\n+    /**\n+     * Create a new configuration setup for a field\n+     *\n+     *\n+     * @param field Field needing mock injection\n+     * @param ofInstance Instance owning the <code>field</code>\n+     * @return New configuration builder\n+     */\n+    public static OngoingMockInjection onField(Field field, Object ofInstance) {\n+        return new OngoingMockInjection(field, ofInstance);\n+    }\n+\n+    /**\n+     * Create a new configuration setup for fields\n+     *\n+     *\n+     * @param fields Fields needing mock injection\n+     * @param ofInstance Instance owning the <code>field</code>\n+     * @return New configuration builder\n+     */\n+    public static OngoingMockInjection onFields(Set<Field> fields, Object ofInstance) {\n+        return new OngoingMockInjection(fields, ofInstance);\n+    }\n+\n+    /**\n+     * Ongoing configuration of the mock injector.\n+     */\n+    public static class OngoingMockInjection {\n+        private Set<Field> fields = new HashSet<Field>();\n+        private Set<Object> mocks = new HashSet<Object>();\n+        private Object fieldOwner;\n+        private MockInjectionStrategy injectionStrategies = MockInjectionStrategy.nop();\n+        private MockInjectionStrategy postInjectionStrategies = MockInjectionStrategy.nop();\n+\n+        private OngoingMockInjection(Field field, Object fieldOwner) {\n+            this(Collections.singleton(field), fieldOwner);\n+        }\n+\n+        private OngoingMockInjection(Set<Field> fields, Object fieldOwner) {\n+            this.fieldOwner = checkNotNull(fieldOwner, \"fieldOwner\");\n+            this.fields.addAll(checkItemsNotNull(fields, \"fields\"));\n+        }\n+\n+        public OngoingMockInjection withMocks(Set<Object> mocks) {\n+            this.mocks.addAll(checkNotNull(mocks, \"mocks\"));\n+            return this;\n+        }\n+\n+        public OngoingMockInjection tryConstructorInjection() {\n+            injectionStrategies.thenTry(new ConstructorInjection());\n+            return this;\n+        }\n+\n+        public OngoingMockInjection tryPropertyOrFieldInjection() {\n+            injectionStrategies.thenTry(new PropertyAndSetterInjection());\n+            return this;\n+        }\n+\n+        public OngoingMockInjection handleSpyAnnotation() {\n+            postInjectionStrategies.thenTry(new SpyOnInjectedFieldsHandler());\n+            return this;\n+        }\n+\n+        public void apply() {\n+            for (Field field : fields) {\n+                injectionStrategies.process(field, fieldOwner, mocks);\n+                postInjectionStrategies.process(field, fieldOwner, mocks);\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/injection/MockInjectionStrategy.java\n+package org.mockito.internal.configuration.injection;\n+\n+import java.lang.reflect.Field;\n+import java.util.Set;\n+\n+/**\n+ * Injector strategy contract\n+ */\n+public abstract class MockInjectionStrategy {\n+\n+    /**\n+     * NOP Strategy that will always try the next strategy.\n+     */\n+    public static final MockInjectionStrategy nop() {\n+        return new MockInjectionStrategy() {\n+            protected boolean processInjection(Field field, Object fieldOwner, Set<Object> mockCandidates) {\n+                return false;\n+            }\n+        };\n+    }\n+\n+\n+    private MockInjectionStrategy nextStrategy;\n+\n+    /**\n+     * Enqueue next injection strategy.\n+     *\n+     * <p>\n+     * The implementation should take care of the actual calling if required.\n+     * </p>\n+     *\n+     * @param strategy Queued strategy.\n+     * @return The passed strategy instance to allow chaining.\n+     */\n+    public MockInjectionStrategy thenTry(MockInjectionStrategy strategy) {\n+        if(nextStrategy != null) {\n+            nextStrategy.thenTry(strategy);\n+        } else {\n+            nextStrategy = strategy;\n+        }\n+        return strategy;\n+    }\n+\n+    /**\n+     * Actually inject mockCandidates on field.\n+     *\n+     * <p>\n+     * Actual algorithm is defined in the implementations of {@link #processInjection(Field, Object, Set)}.\n+     * However if injection occurred successfully, the process should return <code>true</code>,\n+     * and <code>false</code> otherwise.\n+     * </p>\n+     *\n+     * <p>\n+     * The code takes care of calling the next strategy if available and if of course if required\n+     * </p>\n+     *\n+     * @param onField Field needing injection.\n+     * @param fieldOwnedBy The owning instance of the field.\n+     * @param mockCandidates A set of mock candidate, that might be injected.\n+     * @return <code>true</code> if successful, <code>false</code> otherwise.\n+     */\n+    public boolean process(Field onField, Object fieldOwnedBy, Set<Object> mockCandidates) {\n+        if(processInjection(onField, fieldOwnedBy, mockCandidates)) {\n+            return true;\n+        }\n+        return relayProcessToNextStrategy(onField, fieldOwnedBy, mockCandidates);\n+    }\n+\n+    /**\n+     * Process actual injection.\n+     *\n+     * <p>\n+     * Don't call this method directly, instead call {@link #process(Field, Object, Set)}\n+     * </p>\n+     *\n+     * @param field Field needing injection\n+     * @param fieldOwner Field owner instance.\n+     * @param mockCandidates Pool of mocks to inject.\n+     * @return <code>true</code> if injection occurred, <code>false</code> otherwise\n+     */\n+    protected abstract boolean processInjection(Field field, Object fieldOwner, Set<Object> mockCandidates);\n+\n+    private boolean relayProcessToNextStrategy(Field field, Object fieldOwner, Set<Object> mockCandidates) {\n+        return nextStrategy != null && nextStrategy.process(field, fieldOwner, mockCandidates);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java\n+package org.mockito.internal.configuration.injection;\n+\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.configuration.injection.filter.FinalMockCandidateFilter;\n+import org.mockito.internal.configuration.injection.filter.MockCandidateFilter;\n+import org.mockito.internal.configuration.injection.filter.NameBasedCandidateFilter;\n+import org.mockito.internal.configuration.injection.filter.TypeBasedCandidateFilter;\n+import org.mockito.internal.util.reflection.FieldInitializationReport;\n+import org.mockito.internal.util.reflection.FieldInitializer;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * Inject mocks using first setters then fields, if no setters available.\n+ *\n+ * <p>\n+ * <u>Algorithm :<br></u>\n+ * for each field annotated by @InjectMocks\n+ *   <ul>\n+ *   <li>copy mocks set\n+ *   <li>initialize field annotated by @InjectMocks\n+ *   <li>for each field in @InjectMocks type ordered from sub-type to super-type\n+ *     <ul>\n+ *     <li>find mock candidate by type\n+ *     <li>if more than *one* candidate find mock candidate on name\n+ *     <li>if one mock candidate then\n+ *       <ul>\n+ *       <li>set mock by property setter if possible\n+ *       <li>else set mock by field injection\n+ *       </ul>\n+ *     <li>remove mock from mocks copy (mocks are just injected once)\n+ *     <li>else don't fail, user will then provide dependencies\n+ *     </ul>\n+ *   </ul>\n+ * </p>\n+ *\n+ * <p>\n+ * <u>Note:</u> If the field needing injection is not initialized, the strategy tries\n+ * to create one using a no-arg constructor of the field type.\n+ * </p>\n+ */\n+public class PropertyAndSetterInjection extends MockInjectionStrategy {\n+\n+    private final MockCandidateFilter mockCandidateFilter = new TypeBasedCandidateFilter(new NameBasedCandidateFilter(new FinalMockCandidateFilter()));\n+    private Comparator<Field> supertypesLast = new Comparator<Field>() {\n+        public int compare(Field field1, Field field2) {\n+            Class<?> field1Type = field1.getType();\n+            Class<?> field2Type = field2.getType();\n+\n+            if(field1Type.isAssignableFrom(field2Type)) {\n+                return 1;\n+            }\n+            if(field2Type.isAssignableFrom(field1Type)) {\n+                return -1;\n+            }\n+            return 0;\n+        }\n+    };\n+\n+\n+    public boolean processInjection(Field field, Object fieldOwner, Set<Object> mockCandidates) {\n+        Set<Object> mocksToBeInjected = new HashSet<Object>(mockCandidates);\n+        FieldInitializationReport report = null;\n+        try {\n+            report = new FieldInitializer(fieldOwner, field).initialize();\n+        } catch (MockitoException e) {\n+            if(e.getCause() instanceof InvocationTargetException) {\n+                Throwable realCause = e.getCause().getCause();\n+                new Reporter().fieldInitialisationThrewException(field, realCause);\n+            }\n+            new Reporter().cannotInitializeForInjectMocksAnnotation(field.getName(), e);\n+        }\n+\n+\n+        // for each field in the class hierarchy\n+        boolean injectionOccurred = false;\n+        Class<?> fieldClass = report.fieldClass();\n+        Object fieldInstanceNeedingInjection = report.fieldInstance();\n+        while (fieldClass != Object.class) {\n+            injectionOccurred |= injectMockCandidate(fieldClass, mocksToBeInjected, fieldInstanceNeedingInjection);\n+            fieldClass = fieldClass.getSuperclass();\n+        }\n+        return injectionOccurred;\n+    }\n+\n+\n+    private boolean injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object instance) {\n+        boolean injectionOccurred = false;\n+        for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n+            Object injected = mockCandidateFilter.filterCandidate(mocks, field, instance).thenInject();\n+            if(injected != null) {\n+                injectionOccurred |= true;\n+                mocks.remove(injected);\n+            }\n+        }\n+        return injectionOccurred;\n+    }\n+\n+    private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n+        Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n+        Arrays.sort(declaredFields, supertypesLast);\n+        return declaredFields;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/injection/SpyOnInjectedFieldsHandler.java\n+package org.mockito.internal.configuration.injection;\n+\n+import org.mockito.Mockito;\n+import org.mockito.Spy;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.util.MockUtil;\n+import org.mockito.internal.util.reflection.FieldReader;\n+import org.mockito.internal.util.reflection.FieldSetter;\n+\n+import java.lang.reflect.Field;\n+import java.util.Set;\n+\n+import static org.mockito.Mockito.withSettings;\n+\n+/**\n+ * Handler for field annotated with &#64;InjectMocks and &#64;Spy.\n+ *\n+ * <p>\n+ * The handler assumes that field initialization AND injection already happened.\n+ * So if the field is still null, then nothing will happen there.\n+ * </p>\n+ */\n+public class SpyOnInjectedFieldsHandler extends MockInjectionStrategy {\n+\n+    @Override\n+    protected boolean processInjection(Field field, Object fieldOwner, Set<Object> mockCandidates) {\n+        FieldReader fieldReader = new FieldReader(fieldOwner, field);\n+\n+        // TODO refoctor : code duplicated in SpyAnnotationEngine\n+        if(!fieldReader.isNull() && field.isAnnotationPresent(Spy.class)) {\n+            try {\n+                Object instance = fieldReader.read();\n+                if (new MockUtil().isMock(instance)) {\n+                    // A. instance has been spied earlier\n+                    // B. protect against multiple use of MockitoAnnotations.initMocks()\n+                    Mockito.reset(instance);\n+                } else {\n+                    new FieldSetter(fieldOwner, field).set(\n+                        Mockito.mock(instance.getClass(), withSettings()\n+                            .spiedInstance(instance)\n+                            .defaultAnswer(Mockito.CALLS_REAL_METHODS)\n+                            .name(field.getName()))\n+                    );\n+                }\n+            } catch (Exception e) {\n+                throw new MockitoException(\"Problems initiating spied field \" + field.getName(), e);\n+            }\n+        }\n+\n+        return false;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/injection/filter/FinalMockCandidateFilter.java\n+package org.mockito.internal.configuration.injection.filter;\n+\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.util.reflection.BeanPropertySetter;\n+import org.mockito.internal.util.reflection.FieldSetter;\n+\n+import java.lang.reflect.Field;\n+import java.util.Collection;\n+\n+/**\n+ * This node returns an actual injecter which will be either :\n+ *\n+ * <ul>\n+ * <li>an {@link OngoingInjecter} that do nothing if a candidate couldn't be found</li>\n+ * <li>an {@link OngoingInjecter} that will try to inject the candidate trying first the property setter then if not possible try the field access</li>\n+ * </ul>\n+ */\n+public class FinalMockCandidateFilter implements MockCandidateFilter {\n+    public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) {\n+        if(mocks.size() == 1) {\n+            final Object matchingMock = mocks.iterator().next();\n+\n+            return new OngoingInjecter() {\n+                public Object thenInject() {\n+                    try {\n+                        if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) {\n+                            new FieldSetter(fieldInstance, field).set(matchingMock);\n+                        }\n+                    } catch (Exception e) {\n+                        throw new MockitoException(\"Problems injecting dependency in \" + field.getName(), e);\n+                    }\n+                    return matchingMock;\n+                }\n+            };\n+        }\n+\n+        return new OngoingInjecter() {\n+            public Object thenInject() {\n+                return null;\n+            }\n+        };\n+\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/injection/filter/MockCandidateFilter.java\n+package org.mockito.internal.configuration.injection.filter;\n+\n+import java.lang.reflect.Field;\n+import java.util.Collection;\n+\n+public interface MockCandidateFilter {\n+\n+    OngoingInjecter filterCandidate(\n+            Collection<Object> mocks,\n+            Field fieldToBeInjected,\n+            Object fieldInstance\n+    );\n+\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/injection/filter/NameBasedCandidateFilter.java\n+package org.mockito.internal.configuration.injection.filter;\n+\n+import org.mockito.internal.util.MockUtil;\n+\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+public class NameBasedCandidateFilter implements MockCandidateFilter {\n+    private final MockCandidateFilter next;\n+    private final MockUtil mockUtil = new MockUtil();\n+\n+    public NameBasedCandidateFilter(MockCandidateFilter next) {\n+        this.next = next;\n+    }\n+\n+    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {\n+        List<Object> mockNameMatches = new ArrayList<Object>();\n+        if(mocks.size() > 1) {\n+            for (Object mock : mocks) {\n+                if (field.getName().equals(mockUtil.getMockName(mock).toString())) {\n+                    mockNameMatches.add(mock);\n+                }\n+            }\n+            return next.filterCandidate(mockNameMatches, field, fieldInstance);\n+        }\n+        return next.filterCandidate(mocks, field, fieldInstance);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/injection/filter/OngoingInjecter.java\n+package org.mockito.internal.configuration.injection.filter;\n+\n+/**\n+ * Allow the ongoing injection of a mock candidate.\n+ */\n+public interface OngoingInjecter {\n+\n+    /**\n+     * Inject the mock.\n+     *\n+     * <p>\n+     * Please check the actual implementation.\n+     * </p>\n+     *\n+     * @return the mock that was injected, <code>null</code> otherwise.\n+     */\n+    Object thenInject();\n+\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/configuration/injection/filter/TypeBasedCandidateFilter.java\n+package org.mockito.internal.configuration.injection.filter;\n+\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+public class TypeBasedCandidateFilter implements MockCandidateFilter {\n+\n+    MockCandidateFilter next;\n+\n+    public TypeBasedCandidateFilter(MockCandidateFilter next) {\n+        this.next = next;\n+    }\n+\n+    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {\n+        List<Object> mockTypeMatches = new ArrayList<Object>();\n+        for (Object mock : mocks) {\n+            if (field.getType().isAssignableFrom(mock.getClass())) {\n+                mockTypeMatches.add(mock);\n+            }\n+        }\n+\n+        return next.filterCandidate(mockTypeMatches, field, fieldInstance);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/util/Checks.java\n+package org.mockito.internal.util;\n+\n+/**\n+ * Pre-made preconditions\n+ */\n+public class Checks {\n+\n+    public static <T> T checkNotNull(T value, String checkedValue) {\n+        if(value == null) {\n+            throw new NullPointerException(checkedValue + \" should not be null\");\n+        }\n+        return value;\n+    }\n+\n+    public static <T extends Iterable> T checkItemsNotNull(T iterable, String checkedIterable) {\n+        checkNotNull(iterable, checkedIterable);\n+        for (Object item : iterable) {\n+            checkNotNull(item, \"item in \" + checkedIterable);\n+        }\n+        return iterable;\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/util/reflection/FieldInitializationReport.java\n+package org.mockito.internal.util.reflection;\n+\n+public class FieldInitializationReport {\n+    private Object fieldInstance;\n+    private boolean wasInitialized;\n+\n+    public FieldInitializationReport(Object fieldInstance, boolean wasInitialized) {\n+        this.fieldInstance = fieldInstance;\n+        this.wasInitialized = wasInitialized;\n+    }\n+\n+    public Object fieldInstance() {\n+        return fieldInstance;\n+    }\n+\n+    public boolean fieldWasInitialized() {\n+        return wasInitialized;\n+    }\n+\n+    public Class<?> fieldClass() {\n+        return fieldInstance != null ? fieldInstance.getClass() : null;\n+    }\n+}\n+\n--- a/src/org/mockito/internal/util/reflection/FieldInitializer.java\n+++ b/src/org/mockito/internal/util/reflection/FieldInitializer.java\n import java.lang.reflect.Field;\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n \n /**\n  * Initialize a field with type instance if a default constructor can be found.\n  *\n  * <p>\n- * If the given field is already initialize\n+ * If the given field is already initialized, then <strong>the actual instance is returned</strong>.\n  * This initializer doesn't work with inner classes, local classes, interfaces or abstract types.\n  * </p>\n  *\n  */\n public class FieldInitializer {\n \n-    private Object testClass;\n+    private Object fieldOwner;\n     private Field field;\n-\n-\n-    /**\n-     * Initialize the given field on the given instance.\n+    private ConstructorInstantiator instantiator;\n+\n+\n+    /**\n+     * Prepare initializer with the given field on the given instance.\n      *\n      * <p>\n      * This constructor fail fast if the field type cannot be handled.\n      * </p>\n      *\n-     * @param testClass Instance of the test.\n+     * @param fieldOwner Instance of the test.\n      * @param field Field to be initialize.\n      */\n-    public FieldInitializer(Object testClass, Field field) {\n-        if(new FieldReader(testClass, field).isNull()) {\n+    public FieldInitializer(Object fieldOwner, Field field) {\n+        this(fieldOwner, field, new NoArgConstructorInstantiator(fieldOwner, field));\n+    }\n+\n+    /**\n+     * Prepare initializer with the given field on the given instance.\n+     *\n+     * <p>\n+     * This constructor fail fast if the field type cannot be handled.\n+     * </p>\n+     *\n+     * @param fieldOwner Instance of the test.\n+     * @param field Field to be initialize.\n+     */\n+    public FieldInitializer(Object fieldOwner, Field field, ConstructorArgumentResolver argResolver) {\n+        this(fieldOwner, field, new ParameterizedConstructorInstantiator(fieldOwner, field, argResolver));\n+    }\n+\n+    private FieldInitializer(Object fieldOwner, Field field, ConstructorInstantiator instantiator) {\n+        if(new FieldReader(fieldOwner, field).isNull()) {\n             checkNotLocal(field);\n             checkNotInner(field);\n             checkNotInterface(field);\n             checkNotAbstract(field);\n         }\n-        this.testClass = testClass;\n+        this.fieldOwner = fieldOwner;\n         this.field = field;\n-    }\n-\n-    public Object initialize() {\n+        this.instantiator = instantiator;\n+    }\n+\n+    /**\n+     * Initialize field if no initialized and return the actual instance.\n+     *\n+     * @return Actual field instance.\n+     */\n+    public FieldInitializationReport initialize() {\n         final AccessibilityChanger changer = new AccessibilityChanger();\n         changer.enableAccess(field);\n \n         try {\n-            return acquireFieldInstance(testClass, field);\n+            return acquireFieldInstance();\n         } catch(IllegalAccessException e) {\n-            throw new MockitoException(\"Problems injecting dependencies in \" + field.getName(), e);\n+            throw new MockitoException(\"Problems initializing field '\" + field.getName() + \"' of type '\" + field.getType().getSimpleName() + \"'\", e);\n         } finally {\n             changer.safelyDisableAccess(field);\n-        }\n-    }\n-\n-    private void initializeField(Object testClass, Field field) {\n-        final AccessibilityChanger changer = new AccessibilityChanger();\n-        Constructor<?> constructor = null;\n-        try {\n-            constructor = field.getType().getDeclaredConstructor();\n-            changer.enableAccess(constructor);\n-\n-            final Object[] noArg = new Object[0];\n-            Object newFieldInstance = constructor.newInstance(noArg);\n-            new FieldSetter(testClass, field).set(newFieldInstance);\n-        } catch (NoSuchMethodException e) {\n-            throw new MockitoException(\"the type '\" + field.getType().getSimpleName() + \"' has no default constructor\", e);\n-        } catch (InvocationTargetException e) {\n-            throw new MockitoException(\"the default constructor of type '\" + field.getType().getSimpleName() + \"' has raised an exception (see the stack trace for cause): \" + e.getTargetException().toString(), e);\n-        } catch (InstantiationException e) {\n-            throw new MockitoException(\"InstantiationException (see the stack trace for cause): \" + e.toString(), e);\n-        } catch (IllegalAccessException e) {\n-            throw new MockitoException(\"IllegalAccessException (see the stack trace for cause): \" + e.toString(), e);\n-        } finally {\n-            if(constructor != null) {\n-                changer.safelyDisableAccess(constructor);\n-            }\n         }\n     }\n \n         }\n     }\n \n-    private Object acquireFieldInstance(Object testClass, Field field) throws IllegalAccessException {\n-        Object fieldInstance = field.get(testClass);\n+    private FieldInitializationReport acquireFieldInstance() throws IllegalAccessException {\n+        Object fieldInstance = field.get(fieldOwner);\n         if(fieldInstance != null) {\n-            return fieldInstance;\n-        }\n-\n-        initializeField(testClass, field);\n-        return field.get(testClass);\n+            return new FieldInitializationReport(fieldInstance, false);\n+        }\n+\n+        instantiator.instantiate();\n+        return new FieldInitializationReport(field.get(fieldOwner), true);\n+    }\n+\n+    /**\n+     * Represents the strategy used to resolve actual instances\n+     * to be given to a constructor given the argument types.\n+     */\n+    public interface ConstructorArgumentResolver {\n+\n+        /**\n+         * Try to resolve instances from types.\n+         *\n+         * <p>\n+         * Checks on the real argument type or on the correct argument number\n+         * will happen during the field initialization {@link FieldInitializer#initialize()}.\n+         * I.e the only responsibility of this method, is to provide instances <strong>if possible</strong>.\n+         * </p>\n+         *\n+         * @param argTypes Constructor argument types, should not be null.\n+         * @return The argument instances to be given to the constructor, should not be null.\n+         */\n+        Object[] resolveTypeInstances(Class<?>... argTypes);\n+    }\n+\n+    private interface ConstructorInstantiator {\n+        Object instantiate();\n+    }\n+\n+    /**\n+     * Constructor instantiating strategy for no-arg constructor.\n+     *\n+     * <p>\n+     * If a no-arg constructor can be found then the instance is created using\n+     * this constructor.\n+     * Otherwise a technical MockitoException is thrown.\n+     * </p>\n+     */\n+    static class NoArgConstructorInstantiator implements ConstructorInstantiator {\n+        private Object testClass;\n+        private Field field;\n+\n+        /**\n+         * Internal, checks are done by FieldInitializer.\n+         * Fields are assumed to be accessible.\n+         */\n+        NoArgConstructorInstantiator(Object testClass, Field field) {\n+            this.testClass = testClass;\n+            this.field = field;\n+        }\n+\n+        public Object instantiate() {\n+            final AccessibilityChanger changer = new AccessibilityChanger();\n+            Constructor<?> constructor = null;\n+            try {\n+                constructor = field.getType().getDeclaredConstructor();\n+                changer.enableAccess(constructor);\n+\n+                final Object[] noArg = new Object[0];\n+                Object newFieldInstance = constructor.newInstance(noArg);\n+                new FieldSetter(testClass, field).set(newFieldInstance);\n+\n+                return field.get(testClass);\n+            } catch (NoSuchMethodException e) {\n+                throw new MockitoException(\"the type '\" + field.getType().getSimpleName() + \"' has no default constructor\", e);\n+            } catch (InvocationTargetException e) {\n+                throw new MockitoException(\"the default constructor of type '\" + field.getType().getSimpleName() + \"' has raised an exception (see the stack trace for cause): \" + e.getTargetException().toString(), e);\n+            } catch (InstantiationException e) {\n+                throw new MockitoException(\"InstantiationException (see the stack trace for cause): \" + e.toString(), e);\n+            } catch (IllegalAccessException e) {\n+                throw new MockitoException(\"IllegalAccessException (see the stack trace for cause): \" + e.toString(), e);\n+            } finally {\n+                if(constructor != null) {\n+                    changer.safelyDisableAccess(constructor);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Constructor instantiating strategy for parameterized constructors.\n+     *\n+     * <p>\n+     * Choose the constructor with the highest number of parameters, then\n+     * call the ConstructorArgResolver to get actual argument instances.\n+     * If the argResolver fail, then a technical MockitoException is thrown is thrown.\n+     * Otherwise the instance is created with the resolved arguments.\n+     * </p>\n+     */\n+    static class ParameterizedConstructorInstantiator implements ConstructorInstantiator {\n+        private Object testClass;\n+        private Field field;\n+        private ConstructorArgumentResolver argResolver;\n+        private Comparator<Constructor<?>> byParameterNumber = new Comparator<Constructor<?>>() {\n+            public int compare(Constructor<?> constructorA, Constructor<?> constructorB) {\n+                return constructorB.getParameterTypes().length - constructorA.getParameterTypes().length;\n+            }\n+        };\n+\n+        /**\n+         * Internal, checks are done by FieldInitializer.\n+         * Fields are assumed to be accessible.\n+         */\n+        ParameterizedConstructorInstantiator(Object testClass, Field field, ConstructorArgumentResolver argumentResolver) {\n+            this.testClass = testClass;\n+            this.field = field;\n+            this.argResolver = argumentResolver;\n+        }\n+\n+        public Object instantiate() {\n+            final AccessibilityChanger changer = new AccessibilityChanger();\n+            Constructor<?> constructor = null;\n+            try {\n+                constructor = biggestConstructor(field.getType());\n+                checkParameterized(constructor, field);\n+                changer.enableAccess(constructor);\n+\n+                final Object[] args = argResolver.resolveTypeInstances(constructor.getParameterTypes());\n+                Object newFieldInstance = constructor.newInstance(args);\n+                new FieldSetter(testClass, field).set(newFieldInstance);\n+\n+                return field.get(testClass);\n+            } catch (IllegalArgumentException e) {\n+                throw new MockitoException(\"internal error : argResolver provided incorrect types for constructor \" + constructor + \" of type \" + field.getType().getSimpleName(), e);\n+            } catch (InvocationTargetException e) {\n+                throw new MockitoException(\"the constructor of type '\" + field.getType().getSimpleName() + \"' has raised an exception (see the stack trace for cause): \" + e.getTargetException().toString(), e);\n+            } catch (InstantiationException e) {\n+                throw new MockitoException(\"InstantiationException (see the stack trace for cause): \" + e.toString(), e);\n+            } catch (IllegalAccessException e) {\n+                throw new MockitoException(\"IllegalAccessException (see the stack trace for cause): \" + e.toString(), e);\n+            } finally {\n+                if(constructor != null) {\n+                    changer.safelyDisableAccess(constructor);\n+                }\n+            }\n+        }\n+\n+        private void checkParameterized(Constructor<?> constructor, Field field) {\n+            if(constructor.getParameterTypes().length == 0) {\n+                throw new MockitoException(\"the field \" + field.getName() + \" of type \" + field.getType() + \" has no parameterized constructor\");\n+            }\n+        }\n+\n+        private Constructor<?> biggestConstructor(Class<?> clazz) {\n+            final List<Constructor<?>> constructors = Arrays.asList(clazz.getDeclaredConstructors());\n+            Collections.sort(constructors, byParameterNumber);\n+            return constructors.get(0);\n+        }\n     }\n }\n--- a/src/org/mockito/internal/util/reflection/FieldReader.java\n+++ b/src/org/mockito/internal/util/reflection/FieldReader.java\n  */\n package org.mockito.internal.util.reflection;\n \n+import org.mockito.exceptions.base.MockitoException;\n+\n import java.lang.reflect.Field;\n-\n-import org.mockito.exceptions.base.MockitoException;\n \n public class FieldReader {\n \n     }\n \n     public boolean isNull() {\n+            return read() == null;\n+    }\n+\n+    public Object read() {\n         try {\n-            return field.get(target) == null;\n+            return field.get(target);\n         } catch (Exception e) {\n             throw new MockitoException(\"Cannot read state from field: \" + field + \", on instance: \" + target);\n         }\n--- /dev/null\n+++ b/test/org/mockito/internal/configuration/MockInjectionTest.java\n+package org.mockito.internal.configuration;\n+\n+import org.junit.After;\n+import org.junit.Test;\n+import org.mockito.internal.configuration.injection.MockInjection;\n+\n+import java.lang.reflect.Field;\n+import java.util.Collections;\n+import java.util.Observer;\n+import java.util.Set;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class MockInjectionTest {\n+\n+    private AnObjectWithConstructor withConstructor;\n+    private AnObjectWithoutConstructor withoutConstructor;\n+\n+    @After\n+    public void reset() throws Exception {\n+        withConstructor = null;\n+        withoutConstructor = null;\n+    }\n+\n+    @Test(expected = NullPointerException.class)\n+    public void should_not_allow_null_on_field() {\n+        MockInjection.onField((Field) null, this);\n+    }\n+\n+    @Test(expected = NullPointerException.class)\n+    public void should_not_allow_null_on_fields() {\n+        MockInjection.onFields((Set<Field>) null, this);\n+    }\n+\n+    @Test(expected = NullPointerException.class)\n+    public void should_not_allow_null_on_instance_owning_the_field() throws Exception {\n+        MockInjection.onField(field(\"withConstructor\"), null);\n+    }\n+\n+    @Test(expected = NullPointerException.class)\n+    public void should_not_allow_null_on_mocks() throws Exception {\n+        MockInjection.onField(field(\"withConstructor\"), this).withMocks(null);\n+    }\n+\n+\n+    @Test\n+    public void can_try_constructor_injection() throws Exception {\n+        MockInjection.onField(field(\"withConstructor\"), this).withMocks(oneSetMock()).tryConstructorInjection().apply();\n+\n+        assertThat(withConstructor.initializedWithConstructor).isEqualTo(true);\n+    }\n+\n+    @Test\n+    public void should_not_fail_if_constructor_injection_is_not_possible() throws Exception {\n+        MockInjection.onField(field(\"withoutConstructor\"), this).withMocks(otherKindOfMocks()).tryConstructorInjection().apply();\n+\n+        assertThat(withoutConstructor).isNull();\n+    }\n+\n+    @Test\n+    public void can_try_property_or_setter_injection() throws Exception {\n+        MockInjection.onField(field(\"withoutConstructor\"), this).withMocks(oneSetMock()).tryPropertyOrFieldInjection().apply();\n+\n+        assertThat(withoutConstructor.theSet).isNotNull();\n+    }\n+\n+    @Test\n+    public void should_not_fail_if_property_or_field_injection_is_not_possible() throws Exception {\n+        MockInjection.onField(field(\"withoutConstructor\"), this).withMocks(otherKindOfMocks()).tryPropertyOrFieldInjection().apply();\n+\n+        assertThat(withoutConstructor.theSet).isNull();\n+    }\n+\n+    private Set oneSetMock() {\n+        return Collections.singleton(mock(Set.class));\n+    }\n+\n+    private Set otherKindOfMocks() {\n+        return Collections.singleton(mock(Observer.class));\n+    }\n+\n+    private Field field(String field) throws NoSuchFieldException {\n+        return getClass().getDeclaredField(field);\n+    }\n+\n+\n+    public static class AnObjectWithConstructor {\n+        public boolean initializedWithConstructor = false;\n+        public AnObjectWithConstructor(Set<String> strings) {\n+            initializedWithConstructor = true;\n+        }\n+    }\n+\n+    public static class AnObjectWithoutConstructor {\n+        private Set theSet;\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/configuration/injection/ConstructorInjectionTest.java\n+package org.mockito.internal.configuration.injection;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Matchers;\n+import org.mockito.Mock;\n+import org.mockito.internal.util.reflection.FieldInitializer.ConstructorArgumentResolver;\n+import org.mockito.runners.MockitoJUnitRunner;\n+\n+import java.lang.reflect.Field;\n+import java.util.HashSet;\n+import java.util.Observer;\n+import java.util.Set;\n+\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.BDDMockito.given;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class ConstructorInjectionTest {\n+\n+    @Mock private Observer observer;\n+    private ArgConstructor whatever;\n+\n+    @Mock private ConstructorArgumentResolver resolver;\n+    private ConstructorInjection underTest;\n+\n+    @Before\n+    public void initialize_dependencies() {\n+        underTest = new ConstructorInjection(resolver);\n+    }\n+\n+    @Test\n+    public void should_do_the_trick_of_instantiating() throws Exception {\n+        given(resolver.resolveTypeInstances(Matchers.<Class<?>[]>anyVararg())).willReturn(new Object[] { observer });\n+\n+        boolean result = underTest.process(field(\"whatever\"), this, newSetOf(observer));\n+\n+        assertTrue(result);\n+        assertNotNull(whatever);\n+    }\n+\n+    private Set<Object> newSetOf(Object item) {\n+        HashSet<Object> mocks = new HashSet<Object>();\n+        mocks.add(item);\n+        return mocks;\n+    }\n+\n+    private Field field(String fieldName) throws NoSuchFieldException {\n+        return this.getClass().getDeclaredField(fieldName);\n+    }\n+\n+    private static class ArgConstructor {\n+        ArgConstructor(Observer observer) {}\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/configuration/injection/SimpleArgumentResolverTest.java\n+package org.mockito.internal.configuration.injection;\n+\n+import org.junit.Test;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.OutputStream;\n+import java.util.*;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+public class SimpleArgumentResolverTest {\n+\n+    @Test\n+    public void should_return_object_matching_given_types() throws Exception {\n+        ConstructorInjection.SimpleArgumentResolver resolver =\n+                new ConstructorInjection.SimpleArgumentResolver(newSetOf(new HashSet(), new ByteArrayOutputStream(), new HashMap()));\n+\n+        Object[] resolvedInstance = resolver.resolveTypeInstances(Set.class, Map.class, OutputStream.class);\n+\n+        assertEquals(3, resolvedInstance.length);\n+        assertTrue(resolvedInstance[0] instanceof Set);\n+        assertTrue(resolvedInstance[1] instanceof Map);\n+        assertTrue(resolvedInstance[2] instanceof OutputStream);\n+    }\n+\n+    @Test\n+    public void should_return_null_when_match_is_not_possible_on_given_types() throws Exception {\n+        ConstructorInjection.SimpleArgumentResolver resolver =\n+                new ConstructorInjection.SimpleArgumentResolver(newSetOf(new HashSet(), new ByteArrayOutputStream()));\n+\n+        Object[] resolvedInstance = resolver.resolveTypeInstances(Set.class, Map.class, OutputStream.class);\n+\n+        assertEquals(3, resolvedInstance.length);\n+        assertTrue(resolvedInstance[0] instanceof Set);\n+        assertNull(resolvedInstance[1]);\n+        assertTrue(resolvedInstance[2] instanceof OutputStream);\n+    }\n+\n+    @Test\n+    public void should_return_null_when_types_are_primitives() throws Exception {\n+        ConstructorInjection.SimpleArgumentResolver resolver =\n+                new ConstructorInjection.SimpleArgumentResolver(newSetOf(new HashMap(), new TreeSet()));\n+\n+        Object[] resolvedInstance = resolver.resolveTypeInstances(Set.class, Map.class, Boolean.class);\n+\n+        assertEquals(3, resolvedInstance.length);\n+        assertTrue(resolvedInstance[0] instanceof Set);\n+        assertTrue(resolvedInstance[1] instanceof Map);\n+        assertNull(resolvedInstance[2]);\n+    }\n+\n+    private Set<Object> newSetOf(Object... objects) {\n+        return new HashSet<Object>(Arrays.asList(objects));\n+    }\n+\n+\n+}\n--- a/test/org/mockito/internal/util/reflection/FieldInitializerTest.java\n+++ b/test/org/mockito/internal/util/reflection/FieldInitializerTest.java\n import org.junit.Test;\n import org.mockito.InjectMocks;\n import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.util.reflection.FieldInitializer.ConstructorArgumentResolver;\n \n+import java.lang.reflect.Field;\n import java.lang.reflect.InvocationTargetException;\n \n import static org.junit.Assert.*;\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.mock;\n+\n+\n \n public class FieldInitializerTest {\n \n     private InnerClassType instantiatedInnerClassType = new InnerClassType();\n \n     @Test\n-    public void shouldKeepSameInstanceIfFieldInitialized() throws Exception {\n+    public void should_keep_same_instance_if_field_initialized() throws Exception {\n         final StaticClass backupInstance = alreadyInstantiated;\n-        FieldInitializer fieldInitializer = new FieldInitializer(this, this.getClass().getDeclaredField(\"alreadyInstantiated\"));\n-        assertSame(backupInstance, fieldInitializer.initialize());\n+        FieldInitializer fieldInitializer = new FieldInitializer(this, field(\"alreadyInstantiated\"));\n+        FieldInitializationReport report = fieldInitializer.initialize();\n+\n+        assertSame(backupInstance, report.fieldInstance());\n+        assertFalse(report.fieldWasInitialized());\n     }\n \n     @Test\n-    public void shouldInstantiateFieldWhenTypeHasNoConstructor() throws Exception {\n-        FieldInitializer fieldInitializer = new FieldInitializer(this, this.getClass().getDeclaredField(\"noConstructor\"));\n-        assertNotNull(fieldInitializer.initialize());\n+    public void should_instantiate_field_when_type_has_no_constructor() throws Exception {\n+        FieldInitializer fieldInitializer = new FieldInitializer(this, field(\"noConstructor\"));\n+        FieldInitializationReport report = fieldInitializer.initialize();\n+\n+        assertNotNull(report.fieldInstance());\n+        assertTrue(report.fieldWasInitialized());\n     }\n \n     @Test\n-    public void shouldInstantiateFieldWithDefaultConstructor() throws Exception {\n-        FieldInitializer fieldInitializer = new FieldInitializer(this, this.getClass().getDeclaredField(\"defaultConstructor\"));\n-        assertNotNull(fieldInitializer.initialize());\n+    public void should_instantiate_field_with_default_constructor() throws Exception {\n+        FieldInitializer fieldInitializer = new FieldInitializer(this, field(\"defaultConstructor\"));\n+        FieldInitializationReport report = fieldInitializer.initialize();\n+\n+        assertNotNull(report.fieldInstance());\n+        assertTrue(report.fieldWasInitialized());\n     }\n \n     @Test\n-    public void shouldInstantiateFieldWithPrivateDefaultConstructor() throws Exception {\n-        FieldInitializer fieldInitializer = new FieldInitializer(this, this.getClass().getDeclaredField(\"privateDefaultConstructor\"));\n-        assertNotNull(fieldInitializer.initialize());\n+    public void should_instantiate_field_with_private_default_constructor() throws Exception {\n+        FieldInitializer fieldInitializer = new FieldInitializer(this, field(\"privateDefaultConstructor\"));\n+        FieldInitializationReport report = fieldInitializer.initialize();\n+\n+        assertNotNull(report.fieldInstance());\n+        assertTrue(report.fieldWasInitialized());\n     }\n \n     @Test(expected = MockitoException.class)\n-    public void shouldFailToInstantiateFieldIfNoDefaultConstructor() throws Exception {\n-        FieldInitializer fieldInitializer = new FieldInitializer(this, this.getClass().getDeclaredField(\"noDefaultConstructor\"));\n+    public void should_fail_to_instantiate_field_if_no_default_constructor() throws Exception {\n+        FieldInitializer fieldInitializer = new FieldInitializer(this, field(\"noDefaultConstructor\"));\n         fieldInitializer.initialize();\n     }\n \n     @Test\n-    public void shouldFailToInstantiateFieldIfDefaultConstructorThrowsException() throws Exception {\n-        FieldInitializer fieldInitializer = new FieldInitializer(this, this.getClass().getDeclaredField(\"throwingExDefaultConstructor\"));\n+    public void should_fail_to_instantiate_field_if_default_constructor_throws_exception() throws Exception {\n+        FieldInitializer fieldInitializer = new FieldInitializer(this, field(\"throwingExDefaultConstructor\"));\n         try {\n             fieldInitializer.initialize();\n             fail();\n     }\n \n     @Test(expected = MockitoException.class)\n-    public void shouldFailForAbstractField() throws Exception {\n-        new FieldInitializer(this, this.getClass().getDeclaredField(\"abstractType\"));\n+    public void should_fail_for_abstract_field() throws Exception {\n+        new FieldInitializer(this, field(\"abstractType\"));\n     }\n \n-    public void shouldNotFailIfAbstractFieldIsInstantiated() throws Exception {\n-        new FieldInitializer(this, this.getClass().getDeclaredField(\"instantiatedAbstractType\"));\n+    @Test\n+    public void should_not_fail_if_abstract_field_is_instantiated() throws Exception {\n+        new FieldInitializer(this, field(\"instantiatedAbstractType\"));\n     }\n \n     @Test(expected = MockitoException.class)\n-    public void shouldFailForInterfaceField() throws Exception {\n-        new FieldInitializer(this, this.getClass().getDeclaredField(\"interfaceType\"));\n+    public void should_fail_for_interface_field() throws Exception {\n+        new FieldInitializer(this, field(\"interfaceType\"));\n     }\n \n-    public void shouldNotFailIfInterfaceFieldIsInstantiated() throws Exception {\n-        new FieldInitializer(this, this.getClass().getDeclaredField(\"instantiatedInterfaceType\"));\n+    @Test\n+    public void should_not_fail_if_interface_field_is_instantiated() throws Exception {\n+        new FieldInitializer(this, field(\"instantiatedInterfaceType\"));\n     }\n \n     @Test(expected = MockitoException.class)\n-    public void shouldFailForLocalTypeField() throws Exception {\n+    public void should_fail_for_local_type_field() throws Exception {\n         // when\n-        class LocalType { };\n+        class LocalType { }\n \n         class TheTestWithLocalType {\n             @InjectMocks LocalType field;\n         new FieldInitializer(testWithLocalType, testWithLocalType.getClass().getDeclaredField(\"field\"));\n     }\n \n-    public void shouldNotFailIfLocalTypeFieldIsInstantiated() throws Exception {\n+    @Test\n+    public void should_not_fail_if_local_type_field_is_instantiated() throws Exception {\n         // when\n-        class LocalType { };\n+        class LocalType { }\n \n         class TheTestWithLocalType {\n             @InjectMocks LocalType field = new LocalType();\n     }\n \n     @Test(expected = MockitoException.class)\n-    public void shouldFailForInnerClassField() throws Exception {\n-        new FieldInitializer(this, this.getClass().getDeclaredField(\"innerClassType\"));\n+    public void should_fail_for_inner_class_field() throws Exception {\n+        new FieldInitializer(this, field(\"innerClassType\"));\n     }\n \n-    public void shouldNotFailIfInnerClassFieldIsInstantiated() throws Exception {\n-        new FieldInitializer(this, this.getClass().getDeclaredField(\"instantiatedInnerClassType\"));\n+    @Test\n+    public void should_not_fail_if_inner_class_field_is_instantiated() throws Exception {\n+        new FieldInitializer(this, field(\"instantiatedInnerClassType\"));\n+    }\n+\n+    @Test\n+    public void can_instantiate_class_with_parameterized_constructor() throws Exception {\n+        ConstructorArgumentResolver resolver = given(mock(ConstructorArgumentResolver.class).resolveTypeInstances(any(Class[].class)))\n+                        .willReturn(new Object[]{null}).getMock();\n+\n+        new FieldInitializer(this, field(\"noDefaultConstructor\"), resolver).initialize();\n+\n+        assertNotNull(noDefaultConstructor);\n+    }\n+\n+    private Field field(String fieldName) throws NoSuchFieldException {\n+        return this.getClass().getDeclaredField(fieldName);\n     }\n \n     static class StaticClass {\n--- /dev/null\n+++ b/test/org/mockito/internal/util/reflection/ParameterizedConstructorInstantiatorTest.java\n+package org.mockito.internal.util.reflection;\n+\n+\n+import org.junit.After;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Matchers;\n+import org.mockito.Mock;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.util.reflection.FieldInitializer.ConstructorArgumentResolver;\n+import org.mockito.internal.util.reflection.FieldInitializer.ParameterizedConstructorInstantiator;\n+import org.mockito.runners.MockitoJUnitRunner;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.util.Map;\n+import java.util.Observer;\n+import java.util.Set;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.fail;\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Mockito.mock;\n+\n+\n+@SuppressWarnings(\"unchecked\")\n+@RunWith(MockitoJUnitRunner.class)\n+public class ParameterizedConstructorInstantiatorTest {\n+\n+    private Set whateverForNow;\n+    private OneConstructor withOneConstructor;\n+    private MultipleConstructor withMultipleConstructor;\n+    private NoArgConstructor withNoArgConstructor;\n+    private ThrowingConstructor withThrowingConstructor;\n+    private VarargConstructor withVarargConstructor;\n+\n+    @After\n+    public void ensure_instances_to_create_are_null() {\n+        withMultipleConstructor = null;\n+        withOneConstructor = null;\n+        withNoArgConstructor = null;\n+        withThrowingConstructor = null;\n+        withVarargConstructor = null;\n+    }\n+\n+    @Mock private ConstructorArgumentResolver resolver;\n+\n+    @Test\n+    public void should_be_created_with_an_argument_resolver() throws Exception {\n+        new ParameterizedConstructorInstantiator(this, field(\"whateverForNow\"), resolver);\n+    }\n+\n+    @Test\n+    public void should_fail_if_no_parameterized_constructor_found___excluding_inner_and_others_kind_of_types() throws Exception {\n+        try {\n+            new ParameterizedConstructorInstantiator(this, field(\"withNoArgConstructor\"), resolver).instantiate();\n+            fail();\n+        } catch (MockitoException me) {\n+            assertThat(me.getMessage()).contains(\"no parameterized constructor\").contains(\"withNoArgConstructor\").contains(\"NoArgConstructor\");\n+        }\n+    }\n+\n+    @Test\n+    public void should_instantiate_type_if_resolver_provide_matching_types() throws Exception {\n+        Observer observer = mock(Observer.class);\n+        Map map = mock(Map.class);\n+        given(resolver.resolveTypeInstances(Matchers.<Class<?>[]>anyVararg())).willReturn(new Object[]{ observer, map });\n+\n+        new ParameterizedConstructorInstantiator(this, field(\"withMultipleConstructor\"), resolver).instantiate();\n+\n+        assertNotNull(withMultipleConstructor);\n+        assertNotNull(withMultipleConstructor.observer);\n+        assertNotNull(withMultipleConstructor.map);\n+    }\n+\n+    @Test\n+    public void should_fail_if_an_argument_instance_type_do_not_match_wanted_type() throws Exception {\n+        Observer observer = mock(Observer.class);\n+        Set wrongArg = mock(Set.class);\n+        given(resolver.resolveTypeInstances(Matchers.<Class<?>[]>anyVararg())).willReturn(new Object[]{ observer, wrongArg });\n+\n+        try {\n+            new ParameterizedConstructorInstantiator(this, field(\"withMultipleConstructor\"), resolver).instantiate();\n+            fail();\n+        } catch (MockitoException e) {\n+            assertThat(e.getMessage()).contains(\"argResolver\").contains(\"incorrect types\");\n+        }\n+    }\n+\n+    @Test\n+    public void should_report_failure_if_constructor_throws_exception() throws Exception {\n+        given(resolver.resolveTypeInstances(Matchers.<Class<?>[]>anyVararg())).willReturn(new Object[]{ null });\n+\n+        try {\n+            new ParameterizedConstructorInstantiator(this, field(\"withThrowingConstructor\"), resolver).instantiate();\n+            fail();\n+        } catch (MockitoException e) {\n+            assertThat(e.getMessage()).contains(\"constructor\").contains(\"raised an exception\");\n+        }\n+    }\n+\n+    @Test\n+    public void should_instantiate_type_with_vararg_constructor() throws Exception {\n+        Observer[] vararg = new Observer[] {  };\n+        given(resolver.resolveTypeInstances(Matchers.<Class<?>[]>anyVararg())).willReturn(new Object[]{ \"\", vararg});\n+\n+        new ParameterizedConstructorInstantiator(this, field(\"withVarargConstructor\"), resolver).instantiate();\n+\n+        assertNotNull(withVarargConstructor);\n+    }\n+\n+    private Field field(String fieldName) throws NoSuchFieldException {\n+        Field field = this.getClass().getDeclaredField(fieldName);\n+        field.setAccessible(true);\n+        return field;\n+    }\n+\n+    private static class NoArgConstructor {\n+        NoArgConstructor() { }\n+    }\n+\n+    private static class OneConstructor {\n+        public OneConstructor(Observer observer) { }\n+    }\n+\n+    private static class ThrowingConstructor {\n+        public ThrowingConstructor(Observer observer) throws IOException { throw new IOException(); }\n+    }\n+\n+    private static class MultipleConstructor extends OneConstructor {\n+        Observer observer;\n+        Map map;\n+\n+        public MultipleConstructor(Observer observer) { this(observer, null); }\n+        public MultipleConstructor(Observer observer, Map map) {\n+            super(observer);\n+            this.observer = observer;\n+            this.map = map;\n+        }\n+    }\n+\n+    private static class VarargConstructor {\n+        VarargConstructor(String whatever, Observer... observers) { }\n+    }\n+}\n--- a/test/org/mockitousage/annotation/DeprecatedAnnotationEngineApiTest.java\n+++ b/test/org/mockitousage/annotation/DeprecatedAnnotationEngineApiTest.java\n         assertNotNull(test.mock);\n         assertNull(test.tested.dependency);\n     }\n-}\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/annotation/MockInjectionUsingConstructorTest.java\n+package org.mockitousage.annotation;\n+\n+import org.fest.assertions.Assertions;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.Spy;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.util.MockUtil;\n+import org.mockito.runners.MockitoJUnitRunner;\n+import org.mockitousage.examples.use.ArticleCalculator;\n+import org.mockitousage.examples.use.ArticleDatabase;\n+import org.mockitousage.examples.use.ArticleManager;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.when;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class MockInjectionUsingConstructorTest {\n+    private MockUtil mockUtil = new MockUtil();\n+\n+    @Mock private ArticleCalculator calculator;\n+    @Mock private ArticleDatabase database;\n+\n+    @InjectMocks private ArticleManager articleManager;\n+    @Spy @InjectMocks private ArticleManager spiedArticleManager;\n+\n+\n+    @InjectMocks private ArticleVisitor should_be_initialized_several_times;\n+\n+    @Test\n+    public void shouldNotFailWhenNotInitialized() {\n+        assertNotNull(articleManager);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void innerMockShouldRaiseAnExceptionThatChangesOuterMockBehavior() {\n+        when(calculator.countArticles(\"new\")).thenThrow(new IllegalArgumentException());\n+\n+        articleManager.updateArticleCounters(\"new\");\n+    }\n+\n+    @Test\n+    public void mockJustWorks() {\n+        articleManager.updateArticleCounters(\"new\");\n+    }\n+\n+    @Test\n+    public void constructor_is_called_for_each_test() throws Exception {\n+        int number_of_test_before_including_this_one = 4;\n+        assertEquals(number_of_test_before_including_this_one, articleVisitorInstantiationCount);\n+        assertEquals(number_of_test_before_including_this_one, articleVisitorMockInjectedInstances.size());\n+    }\n+\n+    @Test\n+    public void objects_created_with_constructor_initialization_can_be_spied() throws Exception {\n+        assertFalse(mockUtil.isMock(articleManager));\n+        assertTrue(mockUtil.isMock(spiedArticleManager));\n+    }\n+\n+    @Test\n+    public void should_report_failure_only_when_object_initialization_throws_exception() throws Exception {\n+        class ATest {\n+            @Mock Set set;\n+            @InjectMocks FailingConstructor failingConstructor;\n+        }\n+\n+        try {\n+            MockitoAnnotations.initMocks(new ATest());\n+        } catch (MockitoException e) {\n+            Assertions.assertThat(e.getMessage()).contains(\"failingConstructor\").contains(\"constructor\").contains(\"threw an exception\");\n+            Assertions.assertThat(e.getCause()).isInstanceOf(IllegalStateException.class);\n+        }\n+    }\n+\n+    private static int articleVisitorInstantiationCount = 0;\n+    private static Set<Object> articleVisitorMockInjectedInstances = new HashSet<Object>();\n+\n+    private static class ArticleVisitor {\n+        public ArticleVisitor(ArticleCalculator calculator) {\n+            articleVisitorInstantiationCount++;\n+            articleVisitorMockInjectedInstances.add(calculator);\n+        }\n+    }\n+\n+    private static class FailingConstructor {\n+        FailingConstructor(Set set) {\n+            throw new IllegalStateException(\"always fail\");\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/test/org/mockitousage/annotation/MockInjectionUsingSetterOrPropertyTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockitousage.annotation;\n+\n+import org.fest.assertions.Assertions;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.Spy;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.util.MockUtil;\n+import org.mockitoutil.TestBase;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+@SuppressWarnings({\"unchecked\", \"unused\"})\n+public class MockInjectionUsingSetterOrPropertyTest extends TestBase {\n+\n+\tprivate SuperUnderTesting superUnderTestWithoutInjection = new SuperUnderTesting();\n+\t@InjectMocks private SuperUnderTesting superUnderTest = new SuperUnderTesting();\n+\t@InjectMocks private BaseUnderTesting baseUnderTest = new BaseUnderTesting();\n+\t@InjectMocks private SubUnderTesting subUnderTest = new SubUnderTesting();\n+\t@InjectMocks private OtherBaseUnderTesting otherBaseUnderTest = new OtherBaseUnderTesting();\n+\n+    private BaseUnderTesting baseUnderTestingInstance = new BaseUnderTesting();\n+    @InjectMocks private BaseUnderTesting initializedBase = baseUnderTestingInstance;\n+    @InjectMocks private BaseUnderTesting notInitializedBase;\n+\n+    @Spy @InjectMocks private SuperUnderTesting initializedSpy = new SuperUnderTesting();\n+    @Spy @InjectMocks private SuperUnderTesting notInitializedSpy;\n+\n+    @Mock private Map map;\n+    @Mock private List list;\n+\t@Mock private Set histogram1;\n+\t@Mock private Set histogram2;\n+\t@Spy private TreeSet searchTree = new TreeSet();\n+    private MockUtil mockUtil = new MockUtil();\n+\n+    @Before\n+\tpublic void init() {\n+\t\t// initMocks called in TestBase Before method, so instances ar not the same\n+\t\tMockitoAnnotations.initMocks(this);\n+\t}\n+\n+    @Test\n+    public void shouldKeepSameInstanceIfFieldInitialized() {\n+        assertSame(baseUnderTestingInstance, initializedBase);\n+    }\n+\n+    @Test\n+    public void shouldInitializeAnnotatedFieldIfNull() {\n+        assertNotNull(notInitializedBase);\n+    }                                          \n+\n+    @Test\n+    public void shouldIInjectMocksInSpy() {\n+        assertNotNull(initializedSpy.getAList());\n+        assertTrue(mockUtil.isMock(initializedSpy));\n+    }\n+    @Test\n+    public void shouldInitializeSpyIfNullAndInjectMocks() {\n+        assertNotNull(notInitializedSpy);\n+        assertNotNull(notInitializedSpy.getAList());\n+        assertTrue(mockUtil.isMock(notInitializedSpy));\n+    }\n+\n+\t@Test\n+\tpublic void shouldInjectMocksIfAnnotated() {\n+\t\tMockitoAnnotations.initMocks(this);\n+\t\tassertSame(list, superUnderTest.getAList());\n+\t}\n+\n+\t@Test\n+\tpublic void shouldNotInjectIfNotAnnotated() {\n+\t\tMockitoAnnotations.initMocks(this);\n+\t\tassertNull(superUnderTestWithoutInjection.getAList());\n+\t}\n+\n+\t@Test\n+\tpublic void shouldInjectMocksForClassHierarchyIfAnnotated() {\n+\t\tMockitoAnnotations.initMocks(this);\n+\t\tassertSame(list, baseUnderTest.getAList());\n+\t\tassertSame(map, baseUnderTest.getAMap());\n+\t}\n+\n+\t@Test\n+\tpublic void shouldInjectMocksByName() {\n+\t\tMockitoAnnotations.initMocks(this);\n+\t\tassertSame(histogram1, subUnderTest.getHistogram1());\n+\t\tassertSame(histogram2, subUnderTest.getHistogram2());\n+\t}\n+\n+\t@Test\n+\tpublic void shouldInjectSpies() {\n+\t\tMockitoAnnotations.initMocks(this);\n+\t\tassertSame(searchTree, otherBaseUnderTest.getSearchTree());\n+\t}\n+\t\n+    @Test\n+    public void shouldInstantiateInjectMockFieldIfPossible() throws Exception {\n+        assertNotNull(notInitializedBase);\n+    }\n+\n+    @Test\n+    public void shouldKeepInstanceOnInjectMockFieldIfPresent() throws Exception {\n+        assertSame(baseUnderTestingInstance, initializedBase);\n+    }\n+\n+    @Test\n+    public void shouldReportNicely() throws Exception {\n+        Object failing = new Object() {\n+            @InjectMocks ThrowingConstructor failingConstructor;\n+        };\n+        try {\n+            MockitoAnnotations.initMocks(failing);\n+            fail();\n+        } catch (MockitoException e) {\n+            Assertions.assertThat(e.getMessage()).contains(\"failingConstructor\").contains(\"constructor\").contains(\"threw an exception\");\n+            Assertions.assertThat(e.getCause()).isInstanceOf(RuntimeException.class);\n+        }\n+    }\n+\n+    static class ThrowingConstructor {\n+        ThrowingConstructor() { throw new RuntimeException(\"aha\"); };\n+    }\n+\n+    static class SuperUnderTesting {\n+\n+\t\tprivate List aList;\n+\n+\t\tpublic List getAList() {\n+\t\t\treturn aList;\n+\t\t}\n+\t}\n+\n+\tstatic class BaseUnderTesting extends SuperUnderTesting {\n+\t\tprivate Map aMap;\n+\n+\t\tpublic Map getAMap() {\n+\t\t\treturn aMap;\n+\t\t}\n+\t}\n+\n+\tstatic class OtherBaseUnderTesting extends SuperUnderTesting {\n+\t\tprivate TreeSet searchTree;\n+\n+\t\tpublic TreeSet getSearchTree() {\n+\t\t\treturn searchTree;\n+\t\t}\n+\t}\n+\n+\tstatic class SubUnderTesting extends BaseUnderTesting {\n+\t\tprivate Set histogram1;\n+\t\tprivate Set histogram2;\n+\n+\t\tpublic Set getHistogram1() {\n+\t\t\treturn histogram1;\n+\t\t}\n+\n+\t\tpublic Set getHistogram2() {\n+\t\t\treturn histogram2;\n+\t\t}\n+\t}\n+}\n--- a/test/org/mockitousage/bugs/ParentTestMockInjectionTest.java\n+++ b/test/org/mockitousage/bugs/ParentTestMockInjectionTest.java\n         @Mock protected DaoA daoFromParent;\n     }\n \n-    @Ignore(\"JUnit : don't this test!\")\n+    @Ignore(\"JUnit test under test : don't test this!\")\n     public static class ImplicitTest extends BaseTest {\n         @InjectMocks private TestedSystem sut = new TestedSystem();\n ", "timestamp": 1301357914, "metainfo": ""}