{"sha": "3b9bd5f85a44887e48b50b0d7a99135199e4d6f5", "log": "Added some missing tests & refactorings  --HG-- rename : src/org/mockito/internal/util/ShallowCopyTool.java => src/org/mockito/internal/util/copy/LenientCopyTool.java rename : test/org/mockito/internal/util/ShallowCopyToolTest.java => test/org/mockito/internal/util/copy/LenientCopyToolTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401411", "commit": "\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n import org.mockito.internal.creation.jmock.ClassImposterizer;\n import org.mockito.internal.invocation.MatchersBinder;\n import org.mockito.internal.progress.MockingProgress;\n+import org.mockito.internal.util.copy.LenientCopyTool;\n \n public class MockUtil {\n \n         T mock = ClassImposterizer.INSTANCE.imposterise(filter, classToMock);\n         \n         if (optionalInstance != null) {\n-            try {\n-                new ShallowCopyTool().copyToMock(optionalInstance, mock);\n-            } catch (UnableToCopyFieldValue e) {\n-                //Ignore - spying should be used only occasionally and if some field cannot be copied then let's be it\n-            }\n+            new LenientCopyTool().copyToMock(optionalInstance, mock);\n         }\n         \n         //TODO: does it make sense to set instance?\n--- /dev/null\n+++ b/src/org/mockito/internal/util/copy/AccessibilityChanger.java\n+package org.mockito.internal.util.copy;\n+\n+import java.lang.reflect.Field;\n+\n+public class AccessibilityChanger {\n+    \n+    private Boolean wasAccessible = null;\n+\n+    /**\n+     * safely disables access\n+     */\n+    public void safelyDisableAccess(Field field) {\n+        assert wasAccessible != null;\n+        try {\n+            field.setAccessible(wasAccessible);\n+        } catch (Throwable t) {\n+            //ignore\n+        }\n+    }\n+\n+    /**\n+     * changes the field accessibility and returns true if accessibility was changed\n+     */\n+    public void enableAccess(Field field) {\n+        wasAccessible = field.isAccessible();\n+        field.setAccessible(true);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/util/copy/FieldCopier.java\n+package org.mockito.internal.util.copy;\n+\n+import java.lang.reflect.Field;\n+\n+public class FieldCopier {\n+\n+    public <T> void copyValue(T from, T to, Field field) throws IllegalAccessException {\n+        Object value = field.get(from);\n+        field.set(to, value);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/util/copy/LenientCopyTool.java\n+package org.mockito.internal.util.copy;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class LenientCopyTool {\n+\n+    FieldCopier fieldCopier = new FieldCopier();\n+\n+    public <T> void copyToMock(T from, T mock) {\n+        Class clazz = from.getClass();\n+        Class mockSuperClass = mock.getClass().getSuperclass();\n+        assert mockSuperClass == clazz \n+            : \"Classes must have the same type: class of the object from: \" + clazz + \", mock super class: \" + mockSuperClass;\n+\n+        while (clazz != Object.class) {\n+            copyValues(from, mock, clazz);\n+            clazz = clazz.getSuperclass();\n+        }\n+    }\n+\n+    private <T> void copyValues(T from, T mock, Class classFrom) {\n+        Field[] fields = classFrom.getDeclaredFields();\n+\n+        for (int i = 0; i < fields.length; i++) {\n+            // ignore static fields\n+            Field field = fields[i];\n+            if (Modifier.isStatic(field.getModifiers())) {\n+                continue;\n+            }\n+            AccessibilityChanger accessibilityChanger = new AccessibilityChanger();\n+            try {\n+                accessibilityChanger.enableAccess(field);\n+                fieldCopier.copyValue(from, mock, field);\n+            } catch (Throwable t) {\n+                //Ignore - be lenient - if some field cannot be copied then let's be it\n+            } finally {\n+                accessibilityChanger.safelyDisableAccess(field);\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/util/copy/LenientCopyToolTest.java\n+package org.mockito.internal.util.copy;\n+\n+import static org.mockito.Mockito.*;\n+\n+import java.lang.reflect.Field;\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.Queue;\n+\n+import org.junit.Test;\n+import org.mockitoutil.TestBase;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class LenientCopyToolTest extends TestBase {\n+\n+    private LenientCopyTool tool = new LenientCopyTool();\n+\n+    static class InheritMe {\n+        protected String protectedInherited = \"protected\";\n+        private String privateInherited = \"private\";\n+    }\n+    \n+    static class SomeObject extends InheritMe {\n+        @SuppressWarnings(\"unused\") \n+        // required because static fields needs to be excluded from copying \n+        private static int staticField = -100;\n+        private int privateField = -100;\n+        private transient int privateTransientField = -100;\n+        String defaultField = \"-100\";\n+        protected Object protectedField = new Object();\n+        public SomeOtherObject instancePublicField = new SomeOtherObject();\n+        final int finalField;\n+\n+        public SomeObject(int finalField) {\n+            this.finalField = finalField;\n+        }\n+    }\n+\n+    static class SomeOtherObject {\n+    }\n+\n+    private SomeObject from = new SomeObject(100);\n+    private SomeObject to = mock(SomeObject.class);\n+\n+    @Test\n+    public void shouldShallowCopyBasicFinalField() throws Exception {\n+        // given\n+        assertEquals(100, from.finalField);\n+        assertNotEquals(100, to.finalField);\n+\n+        // when\n+        tool.copyToMock(from, to);\n+\n+        // then\n+        assertEquals(100, to.finalField);\n+    }\n+\n+    @Test\n+    public void shouldShallowCopyTransientPrivateFields() throws Exception {\n+        // given\n+        from.privateTransientField = 1000;\n+        assertNotEquals(1000, to.privateTransientField);\n+\n+        // when\n+        tool.copyToMock(from, to);\n+\n+        // then\n+        assertEquals(1000, to.privateTransientField);\n+    }\n+\n+    @Test\n+    public void shouldShallowCopyLinkedListIntoMock() throws Exception {\n+        // given\n+        LinkedList fromList = new LinkedList();\n+        LinkedList toList = mock(LinkedList.class);\n+\n+        // when\n+        tool.copyToMock(fromList, toList);\n+\n+        // then no exception is thrown\n+    }\n+\n+    @Test\n+    public void shouldShallowCopyFieldValuesIntoMock() throws Exception {\n+        // given\n+        from.defaultField = \"foo\";\n+        from.instancePublicField = new SomeOtherObject();\n+        from.privateField = 1;\n+        from.privateTransientField = 2;\n+        from.protectedField = 3;\n+        \n+        assertNotEquals(from.defaultField, to.defaultField);\n+        assertNotEquals(from.instancePublicField, to.instancePublicField);\n+        assertNotEquals(from.privateField, to.privateField);\n+        assertNotEquals(from.privateTransientField, to.privateTransientField);\n+        assertNotEquals(from.protectedField, to.protectedField);\n+\n+        // when\n+        tool.copyToMock(from, to);\n+\n+        // then\n+        assertEquals(from.defaultField, to.defaultField);\n+        assertEquals(from.instancePublicField, to.instancePublicField);\n+        assertEquals(from.privateField, to.privateField);\n+        assertEquals(from.privateTransientField, to.privateTransientField);\n+        assertEquals(from.protectedField, to.protectedField);\n+    }\n+    \n+    @Test\n+    public void shouldCopyValuesOfInheritedFields() throws Exception {\n+        //given\n+        ((InheritMe) from).privateInherited = \"foo\";\n+        ((InheritMe) from).protectedInherited = \"bar\";\n+    \n+        assertNotEquals(((InheritMe) from).privateInherited, ((InheritMe) to).privateInherited);\n+        assertNotEquals(((InheritMe) from).privateInherited, ((InheritMe) to).privateInherited);\n+        \n+        //when\n+        tool.copyToMock(from, to);\n+        \n+        //then\n+        assertEquals(((InheritMe) from).privateInherited, ((InheritMe) to).privateInherited);\n+        assertEquals(((InheritMe) from).privateInherited, ((InheritMe) to).privateInherited);\n+    }\n+    \n+    @Test\n+    public void shouldEnableAndThenDisableAccessibility() throws Exception {\n+        //given\n+        Field privateField = SomeObject.class.getDeclaredField(\"privateField\");\n+        assertFalse(privateField.isAccessible());\n+        \n+        //when\n+        tool.copyToMock(from, to);\n+        \n+        //then\n+        privateField = SomeObject.class.getDeclaredField(\"privateField\");\n+        assertFalse(privateField.isAccessible());\n+    }\n+    \n+    @Test\n+    public void shouldContinueEvenIfThereAreProblemsCopyingSingleFieldValue() throws Exception {\n+        //given\n+        final Queue<Boolean> sequence = new LinkedList<Boolean>(Arrays.asList(true, true, false, true));\n+        tool.fieldCopier = new FieldCopier() {\n+            public <T> void copyValue(T from, T to, Field field) throws IllegalAccessException {\n+                if(!sequence.isEmpty() && !sequence.poll()) {\n+                    throw new IllegalAccessException();\n+                }\n+            }\n+        };\n+        \n+        //when\n+        tool.copyToMock(from, to);\n+        \n+        //then\n+        assertTrue(sequence.isEmpty());\n+    }\n+}", "timestamp": 1241474907, "metainfo": ""}