{"sha": "6e97858d79d08b455cb3690b811120965ee1975a", "log": "For now keep the old ReturnsDeepStubs and created a specific ReturnsGenericDeepStubs  --HG-- branch : issue230 rename : test/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubsTest.java => test/org/mockito/internal/stubbing/defaultanswers/ReturnsGenericDeepStubsTest.java", "commit": "\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n \n import org.mockito.Mockito;\n import org.mockito.internal.InternalMockHandler;\n-import org.mockito.internal.creation.settings.CreationSettings;\n import org.mockito.internal.stubbing.InvocationContainerImpl;\n import org.mockito.internal.stubbing.StubbedInvocationMatcher;\n-import org.mockito.internal.util.ConsoleMockitoLogger;\n import org.mockito.internal.util.MockCreationValidator;\n import org.mockito.internal.util.MockUtil;\n-import org.mockito.internal.util.MockitoLogger;\n-import org.mockito.internal.util.reflection.MockitoGenericMetadata;\n import org.mockito.invocation.InvocationOnMock;\n import org.mockito.stubbing.Answer;\n \n import java.io.Serializable;\n-import java.lang.reflect.Type;\n-\n-import static org.mockito.Mockito.mock;\n \n /**\n  * Returning deep stub implementation.\n     \n     private static final long serialVersionUID = -6926328908792880098L;\n     \n-    private ReturnsEmptyValues delegate = new ReturnsEmptyValues();\n-\n-    private MockitoLogger logger = new ConsoleMockitoLogger();\n+    private Answer<Object> delegate = new ReturnsEmptyValues();\n \n     public Object answer(InvocationOnMock invocation) throws Throwable {\n         Class<?> clz = invocation.getMethod().getReturnType();\n         return recordDeepStubMock(invocation, container);\n     }\n \n-    private Object recordDeepStubMock(InvocationOnMock invocation, InvocationContainerImpl container) throws Throwable {\n-        final Object mock = createGenericsAwareMock(invocation);\n+    private Object recordDeepStubMock(InvocationOnMock invocation, InvocationContainerImpl container) {\n+        Class<?> clz = invocation.getMethod().getReturnType();\n+        final Object mock = Mockito.mock(clz, this);\n \n         container.addAnswer(new Answer<Object>() {\n             public Object answer(InvocationOnMock invocation) throws Throwable {\n \n         return mock;\n     }\n-\n-    private Object createGenericsAwareMock(InvocationOnMock invocation) throws Throwable {\n-        Type genericReturnType = invocation.getMethod().getGenericReturnType();\n-\n-        if (genericReturnType instanceof Class) {\n-            return mock((Class<?>) genericReturnType, this);\n-        }\n-\n-        MockitoGenericMetadata returnTypeGenericMetadata =\n-                actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());\n-\n-        Object mock = returnTypeGenericMetadata.toMock(this);\n-        if (mock == null) {\n-            return delegate.returnValueFor(returnTypeGenericMetadata.rawType());\n-        }\n-        return mock;\n-    }\n-\n-    private MockitoGenericMetadata actualParameterizedType(Object mock) {\n-        CreationSettings mockSettings = (CreationSettings) new MockUtil().getMockHandler(mock).getMockSettings();\n-        return mockSettings.getMockitoGenericMetadata();\n-    }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsGenericDeepStubs.java\n+package org.mockito.internal.stubbing.defaultanswers;\n+\n+import org.mockito.Incubating;\n+import org.mockito.internal.InternalMockHandler;\n+import org.mockito.internal.creation.settings.CreationSettings;\n+import org.mockito.internal.stubbing.InvocationContainerImpl;\n+import org.mockito.internal.stubbing.StubbedInvocationMatcher;\n+import org.mockito.internal.util.MockCreationValidator;\n+import org.mockito.internal.util.MockUtil;\n+import org.mockito.internal.util.reflection.MockitoGenericMetadata;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Returning generic deep stub implementation.\n+ *\n+ * Will return previously created mock if the invocation matches.\n+ *\n+ *\n+ * <p>Supports nested generic information, with this answer you can write code like this :\n+ *\n+ * <pre class=\"code\"><code class=\"java\">\n+ *     interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; {}\n+ *\n+ *     GenericsNest&lt;?&gt; mock = mock(GenericsNest.class, new ReturnsGenericDeepStubs());\n+ *     Number number = mock.entrySet().iterator().next().getValue().iterator().next();\n+ * </code></pre>\n+ * </p>\n+ *\n+ * @see Mockito#RETURNS_DEEP_STUBS\n+ * @see org.mockito.Answers#RETURNS_DEEP_STUBS\n+ */\n+@Incubating\n+public class ReturnsGenericDeepStubs extends ReturnsDeepStubs implements Answer<Object>, Serializable {\n+\n+    private static final long serialVersionUID = -7105341425736035847L;\n+\n+    private ReturnsEmptyValues delegate = new ReturnsEmptyValues();\n+\n+    public Object answer(InvocationOnMock invocation) throws Throwable {\n+        MockitoGenericMetadata returnTypeGenericMetadata =\n+                actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());\n+\n+        Class<?> rawType = returnTypeGenericMetadata.rawType();\n+        if (!new MockCreationValidator().isTypeMockable(rawType)) {\n+            return delegate.returnValueFor(rawType);\n+        }\n+\n+        return getMock(invocation, returnTypeGenericMetadata);\n+    }\n+\n+    private Object getMock(InvocationOnMock invocation, MockitoGenericMetadata returnTypeGenericMetadata) throws Throwable {\n+    \tInternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\n+    \tInvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();\n+\n+        // matches invocation for verification\n+        for (StubbedInvocationMatcher stubbedInvocationMatcher : container.getStubbedInvocations()) {\n+    \t\tif(container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) {\n+    \t\t\treturn stubbedInvocationMatcher.answer(invocation);\n+    \t\t}\n+\t\t}\n+\n+        // deep stub\n+        return recordDeepStubMock(returnTypeGenericMetadata.toMock(this), container);\n+    }\n+\n+    private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {\n+\n+        container.addAnswer(new Answer<Object>() {\n+            public Object answer(InvocationOnMock invocation) throws Throwable {\n+                return mock;\n+            }\n+        }, false);\n+\n+        return mock;\n+    }\n+\n+    private MockitoGenericMetadata actualParameterizedType(Object mock) {\n+        CreationSettings mockSettings = (CreationSettings) new MockUtil().getMockHandler(mock).getMockSettings();\n+        return mockSettings.getMockitoGenericMetadata();\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/stubbing/defaultanswers/ReturnsGenericDeepStubsTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.stubbing.defaultanswers;\n+\n+import org.junit.Test;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+\n+@SuppressWarnings(\"unused\")\n+public class ReturnsGenericDeepStubsTest {\n+    interface ListOfInteger extends List<Integer> {}\n+\n+    interface GenericsNest<K extends Comparable<K> & Cloneable> extends Map<K, Set<Number>> {\n+        Set<Number> remove(Object key); // override with fixed ParameterizedType\n+        List<? super Number> returningWildcard();\n+        Map<String, K> returningNonMockableNestedGeneric();\n+        K returningK();\n+        <O extends K> List<O> paramTypeWithTypeParams();\n+        <S extends Appendable, T extends S> T twoTypeParams(S s);\n+        <O extends K> O typeVarWithTypeParams();\n+        Number returnsNormalType();\n+    }\n+\n+    @Test\n+    public void returning_deep_stubs_1() throws Exception {\n+        GenericsNest<?> mock = mock(GenericsNest.class, new ReturnsGenericDeepStubs());\n+\n+        Set<? extends Map.Entry<? extends Cloneable, Set<Number>>> entries = mock.entrySet();\n+        Iterator<? extends Map.Entry<? extends Cloneable,Set<Number>>> entriesIterator = mock.entrySet().iterator();\n+        Map.Entry<? extends Cloneable, Set<Number>> nextEntry = mock.entrySet().iterator().next();\n+\n+        Cloneable cloneableKey = mock.entrySet().iterator().next().getKey();\n+        Comparable<?> comparableKey = mock.entrySet().iterator().next().getKey();\n+\n+        Set<Number> value = mock.entrySet().iterator().next().getValue();\n+        Iterator<Number> numbersIterator = mock.entrySet().iterator().next().getValue().iterator();\n+        Number number = mock.entrySet().iterator().next().getValue().iterator().next();\n+    }\n+\n+    @Test\n+    public void returning_deep_stubs_2() throws Exception {\n+        GenericsNest<?> mock = mock(GenericsNest.class, new ReturnsGenericDeepStubs());\n+\n+        Cloneable cloneable1 = mock.paramTypeWithTypeParams().get(0);\n+        Comparable<?> comparable1 = mock.paramTypeWithTypeParams().get(0);\n+        Cloneable cloneable2 = mock.returningK();\n+        Comparable<?> comparable2 = mock.returningK();\n+        Cloneable cloneable3 = (Cloneable) mock.typeVarWithTypeParams();\n+    }\n+\n+    @Test\n+    public void returning_deep_stubs_3() throws Exception {\n+        GenericsNest<?> mock = mock(GenericsNest.class, new ReturnsGenericDeepStubs());\n+\n+        List<? super Integer> objects = mock.returningWildcard();\n+        Number n = (Number) mock.returningWildcard().get(45);\n+        n.floatValue();\n+    }\n+\n+    @Test\n+    public void returning_deep_stubs_4() throws Exception {\n+        GenericsNest<?> mock = mock(GenericsNest.class, new ReturnsGenericDeepStubs());\n+\n+        Number n = mock.returnsNormalType();\n+        n.floatValue();\n+    }\n+\n+    @Test\n+    public void return_default_value_on_non_mockable_nested_generic() throws Exception {\n+        GenericsNest<?> genericsNest = mock(GenericsNest.class, new ReturnsGenericDeepStubs());\n+        ListOfInteger listOfInteger = mock(ListOfInteger.class, new ReturnsGenericDeepStubs());\n+\n+        assertThat(genericsNest.returningNonMockableNestedGeneric().keySet().iterator().next()).isNull();\n+        assertThat(listOfInteger.get(25)).isEqualTo(0);\n+    }\n+\n+    @Test(expected = ClassCastException.class)\n+    public void returning_deep_stub_dont_work_because_StringBuilder_is_subject_to_erasure() throws Exception {\n+        GenericsNest<?> mock = mock(GenericsNest.class, new ReturnsGenericDeepStubs());\n+\n+        StringBuilder stringBuilder = mock.twoTypeParams(new StringBuilder()).append(2).append(3); // ClassCastException\n+    }\n+}", "timestamp": 1343833641, "metainfo": ""}