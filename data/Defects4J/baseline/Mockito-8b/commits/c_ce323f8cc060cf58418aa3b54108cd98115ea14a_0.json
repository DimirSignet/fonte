{"sha": "ce323f8cc060cf58418aa3b54108cd98115ea14a", "log": "Cleaned up the code around Mockito warnings  --HG-- rename : src/org/mockito/exceptions/StringJoiner.java => src/org/mockito/internal/util/StringJoiner.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401119", "commit": "\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n  */\n package org.mockito.exceptions;\n \n-import static org.mockito.exceptions.StringJoiner.*;\n+import static org.mockito.internal.util.StringJoiner.*;\n \n import org.mockito.exceptions.base.HasStackTrace;\n import org.mockito.exceptions.base.MockitoAssertionError;\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n         Answer<?> answer = mockitoStubber.findAnswerFor(invocation);\n         if (!invocation.isVoid() && answer == null) {\n             //it is a return-value interaction but not stubbed. This *might* be a problem\n-            mockingProgress.getDebuggingHelper().addPotentiallyUnstubbed(invocationMatcher);\n+            mockingProgress.getDebuggingInfo().addPotentiallyUnstubbed(invocationMatcher);\n         }\n             \n         if (answer != null) {\n--- a/src/org/mockito/internal/debugging/DebuggingInfo.java\n+++ b/src/org/mockito/internal/debugging/DebuggingInfo.java\n \n public class DebuggingInfo {\n \n-    private final List<Invocation> unusedStubs = new LinkedList<Invocation>();\n-    private List<InvocationMatcher> unstubbedInvocations = new LinkedList<InvocationMatcher>();\n-    \n-    //I don't know if this is needed yet\n-    @SuppressWarnings(\"unused\")\n-    private final String testName;\n+    private final List<Invocation> stubbedInvocations = new LinkedList<Invocation>();\n+    private final List<InvocationMatcher> unstubbedInvocations = new LinkedList<InvocationMatcher>();\n \n-    public DebuggingInfo(String testName) {\n-        this.testName = testName;\n+    public void addStubbedInvocation(Invocation invocation) {\n+        //TODO test \n+        //this is required because we don't know if unstubbedInvocation was really stubbed later...\n+        Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations.iterator();\n+        while(unstubbedIterator.hasNext()) {\n+            InvocationMatcher unstubbed = unstubbedIterator.next();\n+            if (unstubbed.getInvocation().equals(invocation)) {\n+                unstubbedIterator.remove();\n+            }\n+        }\n+        unstubbedInvocations.remove(invocation);\n+        stubbedInvocations.add(invocation);\n     }\n \n-    public void addUnusedStub(Invocation invocation) {\n-        this.unusedStubs.add(invocation);\n+    public void addPotentiallyUnstubbed(InvocationMatcher invocationMatcher) {\n+        unstubbedInvocations.add(invocationMatcher);\n     }\n \n-    public void printInfo(MockitoLogger logger) {\n-        if (!shouldPrint()) {\n-            return;\n-        }\n-        \n-//        print(\"Mockito detected some of your stubs were not called. This *might* be the reason your test failed.\");\n-//        print(\"Test:\");\n-//        print(test);\n-        \n-        Iterator<Invocation> unusedIterator = unusedStubs.iterator();\n-        while(unusedIterator.hasNext()) {\n-            Invocation unused = unusedIterator.next();\n-            Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations.iterator();\n-            while(unstubbedIterator.hasNext()) {\n-                InvocationMatcher unstubbed = unstubbedIterator.next();\n-                if(unstubbed.hasSimilarMethod(unused)) { \n-                    logger.print(\"Warning - stubbed method called with different arguments.\");\n-                    logger.print(\"Stubbed this way:\");\n-                    logger.print(unused);\n-                    logger.print(unused.getStackTrace().getStackTrace()[0]);\n-                    logger.print(\"But called with different arguments:\");\n-                    logger.print(unstubbed.getInvocation());\n-                    logger.print(unstubbed.getInvocation().getStackTrace().getStackTrace()[0]);\n-                    logger.print();\n-                    \n-                    unusedIterator.remove();\n-                    unstubbedIterator.remove();\n-                }\n-            }\n-        }\n-        \n-        for (Invocation i : unusedStubs) {\n-            logger.print(\"Warning - this stub was not used:\");\n-            logger.print(i);\n-            logger.print(i.getStackTrace().getStackTrace()[0]);\n-            logger.print();\n-        }\n-        \n-        for (InvocationMatcher i : unstubbedInvocations) {\n-            logger.print(\"Warning - this method was not stubbed:\");\n-            logger.print(i.getInvocation());\n-            logger.print(i.getInvocation().getStackTrace().getStackTrace()[0]);\n-            logger.print();\n-        }\n+    public List<Invocation> pullStubbedInvocations() {\n+        List<Invocation> ret = new LinkedList<Invocation>(stubbedInvocations);\n+        stubbedInvocations.clear();\n+        return ret;\n     }\n \n-    private boolean shouldPrint() {\n-        //TODO test, include unstubbedInvocations...\n-        return !unusedStubs.isEmpty() || !unstubbedInvocations.isEmpty();\n+    public List<InvocationMatcher> pullUnstubbedInvocations() {\n+        List<InvocationMatcher> ret = new LinkedList<InvocationMatcher>(unstubbedInvocations);\n+        unstubbedInvocations.clear();\n+        return ret;\n     }\n \n-    public void addUnstubbedInvocation(InvocationMatcher invocation) {\n-        unstubbedInvocations.add(invocation);\n+    public void collectData() {\n+        // TODO Auto-generated method stub\n+    }\n+\n+    public void clearData() {\n+        // TODO Auto-generated method stub\n+    }\n+\n+    public void printWarnings(MockitoLogger logger) {\n+        WarningsPrinter warningsPrinter = new WarningsPrinter(stubbedInvocations, unstubbedInvocations);\n+        warningsPrinter.print(logger);\n     }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/debugging/WarningsPrinter.java\n+package org.mockito.internal.debugging;\n+\n+import static org.mockito.internal.util.StringJoiner.*;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.util.MockitoLogger;\n+\n+public class WarningsPrinter {\n+\n+    private final List<Invocation> unusedStubs;\n+    private final List<InvocationMatcher> unstubbedInvocations;\n+\n+    public WarningsPrinter(List<Invocation> unusedStubs, List<InvocationMatcher> unstubbedInvocations) {\n+        this.unusedStubs = unusedStubs;\n+        this.unstubbedInvocations = unstubbedInvocations;\n+    }\n+\n+    public void print(MockitoLogger logger) {\n+        if (!shouldPrint()) {\n+            return;\n+        }\n+        \n+        //TODO it should be visible that this method changes the state\n+        warnAboutStubsUsedWithDifferentArgs(logger);\n+        warnAboutUnusedStubs(logger);\n+        warnAboutUnstubbedInvocations(logger);\n+    }\n+\n+    private void warnAboutUnstubbedInvocations(MockitoLogger logger) {\n+        for (InvocationMatcher i : unstubbedInvocations) {\n+            logger.println(join(\n+                \"[Mockito] Warning - this method was not stubbed:\",\n+                i,\n+                \"Here:\",\n+                i.getInvocation().getStackTrace().getStackTrace()[0],\n+                \"\"));\n+        }\n+    }\n+\n+    private void warnAboutUnusedStubs(MockitoLogger logger) {\n+        for (Invocation i : unusedStubs) {\n+            logger.println(join(\n+                \"[Mockito] Warning - this stub was not used:\",\n+                i,\n+                \"Here:\",\n+                i.getStackTrace().getStackTrace()[0],\n+                \"\"));\n+        }\n+    }\n+\n+    private void warnAboutStubsUsedWithDifferentArgs(MockitoLogger logger) {\n+        Iterator<Invocation> unusedIterator = unusedStubs.iterator();\n+        while(unusedIterator.hasNext()) {\n+            Invocation unused = unusedIterator.next();\n+            Iterator<InvocationMatcher> unstubbedIterator = unstubbedInvocations.iterator();\n+            while(unstubbedIterator.hasNext()) {\n+                InvocationMatcher unstubbed = unstubbedIterator.next();\n+                if(unstubbed.hasSimilarMethod(unused)) { \n+                    logger.println(join(\n+                            \"[Mockito] Warning - stubbed method called with different arguments.\",\n+                            \"Stubbed this way:\",\n+                            unused,\n+                            \"Here:\",\n+                            unused.getStackTrace().getStackTrace()[0],\n+                            \"\",\n+                            \"But called with different arguments:\",\n+                            unstubbed.getInvocation(),\n+                            \"Here:\",\n+                            unstubbed.getInvocation().getStackTrace().getStackTrace()[0],\n+                            \"\"));\n+                    \n+                    unusedIterator.remove();\n+                    unstubbedIterator.remove();\n+                }\n+            }\n+        }\n+    }\n+\n+    private boolean shouldPrint() {\n+        //TODO test, include unstubbedInvocations...\n+        return !unusedStubs.isEmpty() || !unstubbedInvocations.isEmpty();\n+    }\n+}\n--- a/src/org/mockito/internal/progress/MockingProgress.java\n+++ b/src/org/mockito/internal/progress/MockingProgress.java\n  */\n package org.mockito.internal.progress;\n \n+import org.mockito.internal.debugging.DebuggingInfo;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.verification.api.VerificationMode;\n \n \n     ArgumentMatcherStorage getArgumentMatcherStorage();\n \n-    DebuggingHelper getDebuggingHelper();\n+    DebuggingInfo getDebuggingInfo();\n }\n--- a/src/org/mockito/internal/progress/MockingProgressImpl.java\n+++ b/src/org/mockito/internal/progress/MockingProgressImpl.java\n package org.mockito.internal.progress;\n \n import org.mockito.exceptions.Reporter;\n+import org.mockito.internal.debugging.DebuggingInfo;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.verification.api.VerificationMode;\n \n     private final Reporter reporter = new Reporter();\n     private final ArgumentMatcherStorage argumentMatcherStorage = new ArgumentMatcherStorageImpl();\n     \n-    private final DebuggingHelper debuggingHelper = new DebuggingHelper();\n+    private final DebuggingInfo debuggingInfo = new DebuggingInfo();\n \n     OngoingStubbing ongoingStubbing;\n     private VerificationMode verificationMode;\n     }\n \n     public void stubbingCompleted(Invocation invocation) {\n-        debuggingHelper.addStubbedInvocation(invocation);        \n+        debuggingInfo.addStubbedInvocation(invocation);        \n         stubbingInProgress = false;\n     }\n     \n         return argumentMatcherStorage;\n     }\n \n-    public DebuggingHelper getDebuggingHelper() {\n-        return debuggingHelper;\n+    public DebuggingInfo getDebuggingInfo() {\n+        return debuggingInfo;\n     }\n }\n--- a/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java\n+++ b/src/org/mockito/internal/progress/ThreadSafeMockingProgress.java\n  */\n package org.mockito.internal.progress;\n \n+import org.mockito.internal.debugging.DebuggingInfo;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.verification.api.VerificationMode;\n \n         return threadSafely().getArgumentMatcherStorage();\n     }\n \n-    public DebuggingHelper getDebuggingHelper() {\n-        return threadSafely().getDebuggingHelper();\n+    public DebuggingInfo getDebuggingInfo() {\n+        return threadSafely().getDebuggingInfo();\n     }\n }\n--- a/src/org/mockito/internal/util/MockitoLogger.java\n+++ b/src/org/mockito/internal/util/MockitoLogger.java\n \n public interface MockitoLogger {\n \n-    void print(Object what);\n+    void println(Object what);\n \n-    void print();\n+    void println();\n \n }\n--- a/src/org/mockito/internal/util/MockitoLoggerImpl.java\n+++ b/src/org/mockito/internal/util/MockitoLoggerImpl.java\n     /* (non-Javadoc)\n      * @see org.mockito.internal.util.Logger#print(java.lang.Object)\n      */\n-    public void print(Object what) {\n-        System.out.println(\"[Mockito] \" + what.toString());\n+    public void println(Object what) {\n+        System.out.println(what.toString());\n     }\n \n-    public void print() {\n+    /* (non-Javadoc)\n+     * @see org.mockito.internal.util.MockitoLogger#println()\n+     */\n+    public void println() {\n         System.out.println();\n     }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/util/StringJoiner.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.util;\n+\n+public class StringJoiner {\n+\n+    public static String join(Object ... linesToBreak) {\n+        StringBuilder out = new StringBuilder(\"\\n\");\n+        for (Object line : linesToBreak) {\n+            out.append(line.toString()).append(\"\\n\");\n+        }\n+        int lastBreak = out.lastIndexOf(\"\\n\");\n+        return out.replace(lastBreak, lastBreak+1, \"\").toString();\n+    }\n+}\n--- a/src/org/mockito/runners/ExperimentalMockitoJUnitRunner.java\n+++ b/src/org/mockito/runners/ExperimentalMockitoJUnitRunner.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.runners;\n-\n-import java.util.List;\n \n import org.junit.runner.notification.Failure;\n import org.junit.runner.notification.RunListener;\n import org.mockito.Mock;\n import org.mockito.MockitoAnnotations;\n import org.mockito.internal.debugging.DebuggingInfo;\n-import org.mockito.internal.invocation.Invocation;\n-import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.progress.DebuggingHelper;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.ThreadSafeMockingProgress;\n import org.mockito.internal.util.MockitoLogger;\n  */\n public class ExperimentalMockitoJUnitRunner extends BlockJUnit4ClassRunner {\n \n-    MockitoLogger logger; \n+    private final MockitoLogger logger;\n     \n     public ExperimentalMockitoJUnitRunner(Class<?> klass) throws InitializationError {\n         super(klass);\n         return super.withBefores(method, target, statement);\n     }\n     \n-    class MockitoListener extends RunListener {\n-        \n-        private final DebuggingHelper debuggingHelper;\n-\n-        public MockitoListener(DebuggingHelper debuggingHelper) {\n-            this.debuggingHelper = debuggingHelper;\n-        }\n-\n-        @Override\n-        public void testFailure(Failure failure) throws Exception {\n-            //TODO DebuggingInfo should be produced by DebuggingHelper\n-            DebuggingInfo debuggingInfo = new DebuggingInfo(failure.getTestHeader());\n-            \n-            List<Invocation> stubbedInvocations = debuggingHelper.pullStubbedInvocations();\n-            for (Invocation invocation : stubbedInvocations) {\n-                if (!invocation.isVerified()) {\n-                    //TODO this requires some refactoring, it's just a dummy implementation\n-                    debuggingInfo.addUnusedStub(invocation);\n-                    break;\n-                }\n-            }\n-            \n-            List<InvocationMatcher> unstubbedInvocations = debuggingHelper.pullUnstubbedInvocations();\n-            for (InvocationMatcher invocation : unstubbedInvocations) {\n-                debuggingInfo.addUnstubbedInvocation(invocation);\n-            }\n-            \n-            debuggingInfo.printInfo(logger);\n-            super.testFailure(failure);\n-        }\n-    }\n-    \n     @Override\n     public void run(RunNotifier notifier) {\n-        MockingProgress progress = new ThreadSafeMockingProgress();\n-        DebuggingHelper debuggingHelper = progress.getDebuggingHelper();\n-        debuggingHelper.collectData();\n+        final MockingProgress progress = new ThreadSafeMockingProgress();\n+        final DebuggingInfo debuggingInfo = progress.getDebuggingInfo();\n         \n-        MockitoListener listener = new MockitoListener(debuggingHelper);\n+        debuggingInfo.collectData();\n+        \n+        RunListener listener = new RunListener() {\n+            @Override\n+            public void testFailure(Failure failure) throws Exception {\n+                debuggingInfo.printWarnings(logger);\n+                super.testFailure(failure);\n+            }\n+        };\n         notifier.addListener(listener);\n         super.run(notifier);\n         \n-        debuggingHelper.clearData();\n+        debuggingInfo.clearData();\n     }\n }", "timestamp": 1230739158, "metainfo": ""}