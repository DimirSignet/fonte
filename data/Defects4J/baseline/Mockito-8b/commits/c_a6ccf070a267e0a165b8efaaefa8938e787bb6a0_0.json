{"sha": "a6ccf070a267e0a165b8efaaefa8938e787bb6a0", "log": "Merge branch 'issue230'", "commit": "\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n         ));\n     }\n \n+    public void defaultAnswerDoesNotAcceptNullParameter() {\n+        throw new MockitoException(\"defaultAnswer() does not accept null parameter\");\n+    }\n+\n     public void serializableWontWorkForObjectsThatDontImplementSerializable(Class classToMock) {\n         throw new MockitoException(join(\n                 \"You are using the setting 'withSettings().serializable()' however the type you are trying to mock '\" + classToMock.getSimpleName() + \"'\",\n--- a/src/org/mockito/internal/creation/MockSettingsImpl.java\n+++ b/src/org/mockito/internal/creation/MockSettingsImpl.java\n \n     public MockSettings defaultAnswer(Answer defaultAnswer) {\n         this.defaultAnswer = defaultAnswer;\n+        if (defaultAnswer == null) {\n+            new Reporter().defaultAnswerDoesNotAcceptNullParameter();\n+        }\n         return this;\n     }\n \n         }\n         return interfaces;\n     }\n+\n }\n \n--- a/src/org/mockito/internal/creation/settings/CreationSettings.java\n+++ b/src/org/mockito/internal/creation/settings/CreationSettings.java\n  * by Szczepan Faber, created at: 4/9/12\n  */\n public class CreationSettings<T> implements MockCreationSettings<T>, Serializable {\n+    private static final long serialVersionUID = -6789800638070123629L;\n \n     protected Class<T> typeToMock;\n     protected Set<Class> extraInterfaces = new LinkedHashSet<Class>();\n     protected Answer<Object> defaultAnswer;\n     protected MockName mockName;\n     protected boolean serializable;\n+    protected List<InvocationListener> invocationListeners = new ArrayList<InvocationListener>();\n     protected boolean stubOnly;\n-    protected List<InvocationListener> invocationListeners = new ArrayList<InvocationListener>();\n \n     public CreationSettings() {}\n \n+    @SuppressWarnings(\"unchecked\")\n     public CreationSettings(CreationSettings copy) {\n         this.typeToMock = copy.typeToMock;\n         this.extraInterfaces = copy.extraInterfaces;\n         return serializable;\n     }\n \n+    public List<InvocationListener> getInvocationListeners() {\n+        return invocationListeners;\n+    }\n+\n     public boolean isStubOnly() {\n         return stubOnly;\n     }\n \n-    public List<InvocationListener> getInvocationListeners() {\n-        return invocationListeners;\n-    }\n }\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.stubbing.defaultanswers;\n \n-import org.mockito.Mockito;\n+import org.mockito.MockSettings;\n import org.mockito.internal.InternalMockHandler;\n+import org.mockito.internal.creation.settings.CreationSettings;\n import org.mockito.internal.stubbing.InvocationContainerImpl;\n import org.mockito.internal.stubbing.StubbedInvocationMatcher;\n import org.mockito.internal.util.MockCreationValidator;\n import org.mockito.internal.util.MockUtil;\n+import org.mockito.internal.util.reflection.GenericMetadataSupport;\n import org.mockito.invocation.InvocationOnMock;\n import org.mockito.stubbing.Answer;\n \n import java.io.Serializable;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.withSettings;\n \n /**\n  * Returning deep stub implementation.\n  *\n  * Will return previously created mock if the invocation matches.\n  *\n- * @see Mockito#RETURNS_DEEP_STUBS\n+ * <p>Supports nested generic information, with this answer you can write code like this :\n+ *\n+ * <pre class=\"code\"><code class=\"java\">\n+ *     interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; {}\n+ *\n+ *     GenericsNest&lt;?&gt; mock = mock(GenericsNest.class, new ReturnsGenericDeepStubs());\n+ *     Number number = mock.entrySet().iterator().next().getValue().iterator().next();\n+ * </code></pre>\n+ * </p>\n+ *\n+ * @see org.mockito.Mockito#RETURNS_DEEP_STUBS\n  * @see org.mockito.Answers#RETURNS_DEEP_STUBS\n  */\n public class ReturnsDeepStubs implements Answer<Object>, Serializable {\n     \n-    private static final long serialVersionUID = -6926328908792880098L;\n-    \n-    private Answer<Object> delegate = new ReturnsEmptyValues();\n+    private static final long serialVersionUID = -7105341425736035847L;\n+\n+    private ReturnsEmptyValues delegate = new ReturnsEmptyValues();\n \n     public Object answer(InvocationOnMock invocation) throws Throwable {\n-        Class<?> clz = invocation.getMethod().getReturnType();\n+        GenericMetadataSupport returnTypeGenericMetadata =\n+                actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());\n \n-        if (!new MockCreationValidator().isTypeMockable(clz)) {\n-            return delegate.answer(invocation);\n+        Class<?> rawType = returnTypeGenericMetadata.rawType();\n+        if (!new MockCreationValidator().isTypeMockable(rawType)) {\n+            return delegate.returnValueFor(rawType);\n         }\n \n-        return getMock(invocation);\n+        return getMock(invocation, returnTypeGenericMetadata);\n     }\n \n-    private Object getMock(InvocationOnMock invocation) throws Throwable {\n+    private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {\n     \tInternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\n     \tInvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();\n \n \t\t}\n \n         // deep stub\n-        return recordDeepStubMock(invocation, container);\n+        return recordDeepStubMock(createNewDeepStubMock(returnTypeGenericMetadata), container);\n     }\n \n-    private Object recordDeepStubMock(InvocationOnMock invocation, InvocationContainerImpl container) {\n-        Class<?> clz = invocation.getMethod().getReturnType();\n-        final Object mock = Mockito.mock(clz, this);\n+    /**\n+     * Creates a mock using the Generics Metadata.\n+     *\n+     * @param returnTypeGenericMetadata The metadata to use to create the new mock.\n+     * @return The mock\n+     */\n+    private Object createNewDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {\n+        return mock(\n+                returnTypeGenericMetadata.rawType(),\n+                withSettingsUsing(returnTypeGenericMetadata)\n+        );\n+    }\n+\n+    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {\n+        MockSettings mockSettings =\n+                returnTypeGenericMetadata.rawExtraInterfaces().length > 0 ?\n+                withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())\n+                : withSettings();\n+\n+        return mockSettings\n+                .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));\n+    }\n+\n+    private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {\n+        return new ReturnsDeepStubs() {\n+            @Override\n+            protected GenericMetadataSupport actualParameterizedType(Object mock) {\n+                return returnTypeGenericMetadata;\n+            }\n+        };\n+    }\n+\n+    private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {\n \n         container.addAnswer(new Answer<Object>() {\n             public Object answer(InvocationOnMock invocation) throws Throwable {\n \n         return mock;\n     }\n+\n+    protected GenericMetadataSupport actualParameterizedType(Object mock) {\n+        CreationSettings mockSettings = (CreationSettings) new MockUtil().getMockHandler(mock).getMockSettings();\n+        return GenericMetadataSupport.inferFrom(mockSettings.getTypeToMock());\n+    }\n }\n--- a/src/org/mockito/internal/util/ConsoleMockitoLogger.java\n+++ b/src/org/mockito/internal/util/ConsoleMockitoLogger.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util;\n \n public class ConsoleMockitoLogger implements MockitoLogger {\n      * @see org.mockito.internal.util.Logger#print(java.lang.Object)\n      */\n     public void log(Object what) {\n-        System.out.print(what);\n+        System.out.println(what);\n     }\n }\n--- a/src/org/mockito/internal/util/reflection/GenericMaster.java\n+++ b/src/org/mockito/internal/util/reflection/GenericMaster.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util.reflection;\n \n import java.lang.reflect.Field;\n         \n         return Object.class;\n     }\n+\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.util.reflection;\n+\n+\n+import org.mockito.Incubating;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.util.Checks;\n+import org.mockito.stubbing.Answer;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+\n+\n+/**\n+ * This class can retrieve generic meta-data that the compiler stores on classes\n+ * and accessible members.\n+ *\n+ * <p>\n+ *     The main idea of this code is to create a Map that will help to resolve return types.\n+ *     In order to actually work with nested generics, this map will have to be passed along new instances\n+ *     as a type context.\n+ * </p>\n+ *\n+ * <p>\n+ *     Hence :\n+ *     <ul>\n+ *         <li>the metadata is created using the {@link #inferFrom(Type)} method from a real\n+ *         Class or from a ParameterizedType, other types are not yet supported.</li>\n+ *\n+ *         <li>Then from this metadata, we can extract meta-data for a generic return type of a method, using\n+ *         {@link #resolveGenericReturnType(Method)}.</li>\n+ *\n+ *         <li>Finally as we want to mock the actual type, but we want to pass along the contextual generics meta-data\n+ *         we need to create the mock ourselves as we know how to create it, depending on the kind of Type (Class,\n+ *         ParameterizedType, TypeVariable), the method {@link #toMock(Answer)} assumes this responsibility.</li>\n+ *     </ul>\n+ * </p>\n+ *\n+ * <p>\n+ * For now this code support the following kind of generic declarations :\n+ * <pre class=\"code\"><code class=\"java\">\n+ * interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; {\n+ *     Set&lt;Number&gt; remove(Object key); // override with fixed ParameterizedType\n+ *     List&lt;? super Integer&gt; returning_wildcard_with_class_lower_bound();\n+ *     List&lt;? super K&gt; returning_wildcard_with_typeVar_lower_bound();\n+ *     List&lt;? extends K&gt; returning_wildcard_with_typeVar_upper_bound();\n+ *     K returningK();\n+ *     &lt;O extends K&gt; List&lt;O&gt; paramType_with_type_params();\n+ *     &lt;S, T extends S&gt; T two_type_params();\n+ *     &lt;O extends K&gt; O typeVar_with_type_params();\n+ *     Number returningNonGeneric();\n+ * }\n+ * </code></pre>\n+ *\n+ * @see #inferFrom(Type)\n+ * @see #resolveGenericReturnType(Method)\n+ * @see #toMock(Answer)\n+ * @see org.mockito.internal.stubbing.defaultanswers.ReturnsGenericDeepStubs\n+ */\n+@Incubating\n+public abstract class GenericMetadataSupport {\n+\n+    // public static MockitoLogger logger = new ConsoleMockitoLogger();\n+\n+    /**\n+     * Represents actual type variables resolved for current class.\n+     */\n+    protected Map<TypeVariable, Type> contextualActualTypeParameters = new HashMap<TypeVariable, Type>();\n+\n+\n+    protected void registerTypeVariablesOn(Type classType) {\n+        if (!(classType instanceof ParameterizedType)) {\n+            return;\n+        }\n+        ParameterizedType parameterizedType = (ParameterizedType) classType;\n+        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n+        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n+        for (int i = 0; i < actualTypeArguments.length; i++) {\n+            TypeVariable typeParameter = typeParameters[i];\n+            Type actualTypeArgument = actualTypeArguments[i];\n+\n+            if (actualTypeArgument instanceof WildcardType) {\n+                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n+            } else {\n+                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n+            }\n+            // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n+        }\n+    }\n+\n+    protected void registerTypeParametersOn(TypeVariable[] typeParameters) {\n+        for (TypeVariable typeParameter : typeParameters) {\n+            contextualActualTypeParameters.put(typeParameter, boundsOf(typeParameter));\n+            // logger.log(\"For '\" + typeParameter.getGenericDeclaration() + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + boundsOf(typeParameter) + \"' }\");\n+        }\n+    }\n+\n+    /**\n+     * @param typeParameter The TypeVariable parameter\n+     * @return A {@link BoundedType} for easy bound information, if first bound is a TypeVariable\n+     *         then retrieve BoundedType of this TypeVariable\n+     */\n+    private BoundedType boundsOf(TypeVariable typeParameter) {\n+        if (typeParameter.getBounds()[0] instanceof TypeVariable) {\n+            return boundsOf((TypeVariable) typeParameter.getBounds()[0]);\n+        }\n+        return new TypeVarBoundedType(typeParameter);\n+    }\n+\n+    /**\n+     * @param wildCard The WildCard type\n+     * @return A {@link BoundedType} for easy bound information, if first bound is a TypeVariable\n+     *         then retrieve BoundedType of this TypeVariable\n+     */\n+    private BoundedType boundsOf(WildcardType wildCard) {\n+        /*\n+         *  According to JLS(http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.5.1):\n+         *  - Lower and upper can't coexist: (for instance, this is not allowed: <? extends List<String> & super MyInterface>)\n+         *  - Multiple bounds are not supported (for instance, this is not allowed: <? extends List<String> & MyInterface>)\n+         */\n+\n+        WildCardBoundedType wildCardBoundedType = new WildCardBoundedType(wildCard);\n+        if (wildCardBoundedType.firstBound() instanceof TypeVariable) {\n+            return boundsOf((TypeVariable) wildCardBoundedType.firstBound());\n+        }\n+\n+        return wildCardBoundedType;\n+    }\n+\n+\n+\n+    /**\n+     * @return Raw type of the current instance.\n+     */\n+    public abstract Class<?> rawType();\n+\n+\n+\n+    /**\n+     * @return Returns extra interfaces <strong>if relevant</strong>, otherwise empty List.\n+     */\n+    public List<Type> extraInterfaces() {\n+        return Collections.emptyList();\n+    }\n+\n+    /**\n+     * @return Returns an array with the raw types of {@link #extraInterfaces()} <strong>if relevant</strong>.\n+     */\n+    public Class<?>[] rawExtraInterfaces() {\n+        return new Class[0];\n+    }\n+\n+\n+\n+    /**\n+     * @return Actual type arguments matching the type variables of the raw type represented by this {@link GenericMetadataSupport} instance.\n+     */\n+    public Map<TypeVariable, Type> actualTypeArguments() {\n+        TypeVariable[] typeParameters = rawType().getTypeParameters();\n+        LinkedHashMap<TypeVariable, Type> actualTypeArguments = new LinkedHashMap<TypeVariable, Type>();\n+\n+        for (TypeVariable typeParameter : typeParameters) {\n+\n+            Type actualType = getActualTypeArgumentFor(typeParameter);\n+\n+            actualTypeArguments.put(typeParameter, actualType);\n+            // logger.log(\"For '\" + rawType().getCanonicalName() + \"' returning explicit TypeVariable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualType +\"' }\");\n+        }\n+\n+        return actualTypeArguments;\n+    }\n+\n+    protected Type getActualTypeArgumentFor(TypeVariable typeParameter) {\n+        Type type = this.contextualActualTypeParameters.get(typeParameter);\n+        if (type instanceof TypeVariable) {\n+            TypeVariable typeVariable = (TypeVariable) type;\n+            return getActualTypeArgumentFor(typeVariable);\n+        }\n+\n+        return type;\n+    }\n+\n+\n+\n+    /**\n+     * Resolve current method generic return type to a {@link GenericMetadataSupport}.\n+     *\n+     * @param method Method to resolve the return type.\n+     * @return {@link GenericMetadataSupport} representing this generic return type.\n+     */\n+    public GenericMetadataSupport resolveGenericReturnType(Method method) {\n+        Type genericReturnType = method.getGenericReturnType();\n+        // logger.log(\"Method '\" + method.toGenericString() + \"' has return type : \" + genericReturnType.getClass().getInterfaces()[0].getSimpleName() + \" : \" + genericReturnType);\n+\n+        if (genericReturnType instanceof Class) {\n+            return new NotGenericReturnTypeSupport(genericReturnType);\n+        }\n+        if (genericReturnType instanceof ParameterizedType) {\n+            return new ParameterizedReturnType(this, method.getTypeParameters(), (ParameterizedType) method.getGenericReturnType());\n+        }\n+        if (genericReturnType instanceof TypeVariable) {\n+            return new TypeVariableReturnType(this, method.getTypeParameters(), (TypeVariable) genericReturnType);\n+        }\n+\n+        throw new MockitoException(\"Ouch, it shouldn't happen, type '\" + genericReturnType.getClass().getCanonicalName() + \"' on method : '\" + method.toGenericString() + \"' is not supported : \" + genericReturnType);\n+    }\n+\n+    /**\n+     * Create an new instance of {@link GenericMetadataSupport} inferred from a {@link Type}.\n+     *\n+     * <p>\n+     *     At the moment <code>type</code> can only be a {@link Class} or a {@link ParameterizedType}, otherwise\n+     *     it'll throw a {@link MockitoException}.\n+     * </p>\n+     *\n+     * @param type The class from which the {@link GenericMetadataSupport} should be built.\n+     * @return The new {@link GenericMetadataSupport}.\n+     * @throws MockitoException Raised if type is not a {@link Class} or a {@link ParameterizedType}.\n+     */\n+    public static GenericMetadataSupport inferFrom(Type type) {\n+        Checks.checkNotNull(type, \"type\");\n+        if (type instanceof Class) {\n+            return new FromClassGenericMetadataSupport((Class<?>) type);\n+        }\n+        if (type instanceof ParameterizedType) {\n+            return new FromParameterizedTypeGenericMetadataSupport((ParameterizedType) type);\n+        }\n+\n+        throw new MockitoException(\"Type meta-data for this Type (\" + type.getClass().getCanonicalName() + \") is not supported : \" + type);\n+    }\n+\n+\n+    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+    //// Below are specializations of GenericMetadataSupport that could handle retrieval of possible Types\n+    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+    /**\n+     * Generic metadata implementation for {@link Class}.\n+     *\n+     * Offer support to retrieve generic metadata on a {@link Class} by reading type parameters and type variables on\n+     * the class and its ancestors and interfaces.\n+     */\n+    private static class FromClassGenericMetadataSupport extends GenericMetadataSupport {\n+        private Class<?> clazz;\n+\n+        public FromClassGenericMetadataSupport(Class<?> clazz) {\n+            this.clazz = clazz;\n+            readActualTypeParametersOnDeclaringClass();\n+        }\n+\n+        private void readActualTypeParametersOnDeclaringClass() {\n+            registerTypeParametersOn(clazz.getTypeParameters());\n+            registerTypeVariablesOn(clazz.getGenericSuperclass());\n+            for (Type genericInterface : clazz.getGenericInterfaces()) {\n+                registerTypeVariablesOn(genericInterface);\n+            }\n+        }\n+\n+        @Override\n+        public Class<?> rawType() {\n+            return clazz;\n+        }\n+    }\n+\n+\n+    /**\n+     * Generic metadata implementation for \"standalone\" {@link ParameterizedType}.\n+     *\n+     * Offer support to retrieve generic metadata on a {@link ParameterizedType} by reading type variables of\n+     * the related raw type and declared type variable of this parameterized type.\n+     *\n+     * This class is not designed to work on ParameterizedType returned by {@link Method#getGenericReturnType()}, as\n+     * the ParameterizedType instance return in these cases could have Type Variables that refer to type declaration(s).\n+     * That's what meant the \"standalone\" word at the beginning of the Javadoc.\n+     * Instead use {@link ParameterizedReturnType}.\n+     */\n+    private static class FromParameterizedTypeGenericMetadataSupport extends GenericMetadataSupport {\n+        private ParameterizedType parameterizedType;\n+\n+        public FromParameterizedTypeGenericMetadataSupport(ParameterizedType parameterizedType) {\n+            this.parameterizedType = parameterizedType;\n+            readActualTypeParameters();\n+        }\n+\n+        private void readActualTypeParameters() {\n+            registerTypeVariablesOn(parameterizedType.getRawType());\n+            registerTypeVariablesOn(parameterizedType);\n+        }\n+\n+        @Override\n+        public Class<?> rawType() {\n+            return (Class<?>) parameterizedType.getRawType();\n+        }\n+    }\n+\n+\n+    /**\n+     * Generic metadata specific to {@link ParameterizedType} returned via {@link Method#getGenericReturnType()}.\n+     */\n+    private static class ParameterizedReturnType extends GenericMetadataSupport {\n+        private final ParameterizedType parameterizedType;\n+        private final TypeVariable[] typeParameters;\n+\n+        public ParameterizedReturnType(GenericMetadataSupport source, TypeVariable[] typeParameters, ParameterizedType parameterizedType) {\n+            this.parameterizedType = parameterizedType;\n+            this.typeParameters = typeParameters;\n+            this.contextualActualTypeParameters = source.contextualActualTypeParameters;\n+\n+            readTypeParameters();\n+            readTypeVariables();\n+        }\n+\n+        private void readTypeParameters() {\n+            registerTypeParametersOn(typeParameters);\n+        }\n+\n+        private void readTypeVariables() {\n+            registerTypeVariablesOn(parameterizedType);\n+        }\n+\n+        @Override\n+        public Class<?> rawType() {\n+            return (Class<?>) parameterizedType.getRawType();\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Generic metadata for {@link TypeVariable} returned via {@link Method#getGenericReturnType()}.\n+     */\n+    private static class TypeVariableReturnType extends GenericMetadataSupport {\n+        private final TypeVariable typeVariable;\n+        private final TypeVariable[] typeParameters;\n+        private Class<?> rawType;\n+\n+\n+\n+        public TypeVariableReturnType(GenericMetadataSupport source, TypeVariable[] typeParameters, TypeVariable typeVariable) {\n+            this.typeParameters = typeParameters;\n+            this.typeVariable = typeVariable;\n+            this.contextualActualTypeParameters = source.contextualActualTypeParameters;\n+\n+            readTypeParameters();\n+            readTypeVariables();\n+        }\n+\n+        private void readTypeParameters() {\n+            registerTypeParametersOn(typeParameters);\n+        }\n+\n+        private void readTypeVariables() {\n+            for (Type type : typeVariable.getBounds()) {\n+                registerTypeVariablesOn(type);\n+            }\n+            registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n+        }\n+\n+        @Override\n+        public Class<?> rawType() {\n+            if (rawType == null) {\n+                rawType = extractRawTypeOf(typeVariable);\n+            }\n+            return rawType;\n+        }\n+\n+        private Class<?> extractRawTypeOf(Type type) {\n+            if (type instanceof Class) {\n+                return (Class<?>) type;\n+            }\n+            if (type instanceof ParameterizedType) {\n+                return (Class<?>) ((ParameterizedType) type).getRawType();\n+            }\n+            if (type instanceof BoundedType) {\n+                return extractRawTypeOf(((BoundedType) type).firstBound());\n+            }\n+            if (type instanceof TypeVariable) {\n+                /*\n+                 * If type is a TypeVariable, then it is needed to gather data elsewhere. Usually TypeVariables are declared\n+                 * on the class definition, such as such as List<E>.\n+                 */\n+                return extractRawTypeOf(contextualActualTypeParameters.get(type));\n+            }\n+            throw new MockitoException(\"Raw extraction not supported for : '\" + type + \"'\");\n+        }\n+\n+        @Override\n+        public List<Type> extraInterfaces() {\n+            Type type = extractActualBoundedTypeOf(typeVariable);\n+            if (type instanceof BoundedType) {\n+                return Arrays.asList(((BoundedType) type).interfaceBounds());\n+            }\n+            if (type instanceof ParameterizedType) {\n+                return Collections.singletonList(type);\n+            }\n+            if (type instanceof Class) {\n+                return Collections.emptyList();\n+            }\n+            throw new MockitoException(\"Cannot extract extra-interfaces from '\" + typeVariable + \"' : '\" + type + \"'\");\n+        }\n+\n+        /**\n+         * @return Returns an array with the extracted raw types of {@link #extraInterfaces()}.\n+         * @see #extractRawTypeOf(java.lang.reflect.Type)\n+         */\n+        public Class<?>[] rawExtraInterfaces() {\n+            List<Type> extraInterfaces = extraInterfaces();\n+            List<Class<?>> rawExtraInterfaces = new ArrayList<Class<?>>();\n+            for (Type extraInterface : extraInterfaces) {\n+                Class<?> rawInterface = extractRawTypeOf(extraInterface);\n+                // avoid interface collision with actual raw type (with typevariables, resolution ca be quite aggressive)\n+                if(!rawType().equals(rawInterface)) {\n+                    rawExtraInterfaces.add(rawInterface);\n+                }\n+            }\n+            return rawExtraInterfaces.toArray(new Class[rawExtraInterfaces.size()]);\n+        }\n+\n+        private Type extractActualBoundedTypeOf(Type type) {\n+            if (type instanceof TypeVariable) {\n+                /*\n+                If type is a TypeVariable, then it is needed to gather data elsewhere. Usually TypeVariables are declared\n+                on the class definition, such as such as List<E>.\n+                */\n+                return extractActualBoundedTypeOf(contextualActualTypeParameters.get(type));\n+            }\n+            if (type instanceof BoundedType) {\n+                Type actualFirstBound = extractActualBoundedTypeOf(((BoundedType) type).firstBound());\n+                if (!(actualFirstBound instanceof BoundedType)) {\n+                    return type; // avoid going one step further, ie avoid : O(TypeVar) -> K(TypeVar) -> Some ParamType\n+                }\n+                return actualFirstBound;\n+            }\n+            return type; // irrelevant, we don't manage other types as they are not bounded.\n+        }\n+    }\n+\n+\n+\n+    /**\n+     * Non-Generic metadata for {@link Class} returned via {@link Method#getGenericReturnType()}.\n+     */\n+    private static class NotGenericReturnTypeSupport extends GenericMetadataSupport {\n+        private final Class<?> returnType;\n+\n+        public NotGenericReturnTypeSupport(Type genericReturnType) {\n+            returnType = (Class<?>) genericReturnType;\n+        }\n+\n+        @Override\n+        public Class<?> rawType() {\n+            return returnType;\n+        }\n+    }\n+\n+\n+\n+    /**\n+     * Type representing bounds of a type\n+     *\n+     * @see TypeVarBoundedType\n+     * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>\n+     * @see WildCardBoundedType\n+     * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.5.1\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.5.1</a>\n+     */\n+    public static interface BoundedType extends Type {\n+        Type firstBound();\n+\n+        Type[] interfaceBounds();\n+    }\n+\n+    /**\n+     * Type representing bounds of a type variable, allows to keep all bounds information.\n+     *\n+     * <p>It uses the first bound in the array, as this array is never null and always contains at least\n+     * one element (Object is always here if no bounds are declared).</p>\n+     *\n+     * <p>If upper bounds are declared with SomeClass and additional interfaces, then firstBound will be SomeClass and\n+     * interfacesBound will be an array of the additional interfaces.\n+     *\n+     * i.e. <code>SomeClass</code>.\n+     * <pre class=\"code\"><code class=\"java\">\n+     *     interface UpperBoundedTypeWithClass<E extends Comparable<E> & Cloneable> {\n+     *         E get();\n+     *     }\n+     *     // will return Comparable type\n+     * </code></pre>\n+     * </p>\n+     *\n+     * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>\n+     */\n+    public static class TypeVarBoundedType implements BoundedType {\n+        private TypeVariable typeVariable;\n+\n+\n+        public TypeVarBoundedType(TypeVariable typeVariable) {\n+            this.typeVariable = typeVariable;\n+        }\n+\n+        /**\n+         * @return either a class or an interface (parameterized or not), if no bounds declared Object is returned.\n+         */\n+        public Type firstBound() {\n+            return typeVariable.getBounds()[0]; //\n+        }\n+\n+        /**\n+         * On a Type Variable (typeVar extends C_0 & I_1 & I_2 & etc), will return an array\n+         * containing I_1 and I_2.\n+         *\n+         * @return other bounds for this type, these bounds can only be only interfaces as the JLS says,\n+         * empty array if no other bound declared.\n+         */\n+        public Type[] interfaceBounds() {\n+            Type[] interfaceBounds = new Type[typeVariable.getBounds().length - 1];\n+            System.arraycopy(typeVariable.getBounds(), 1, interfaceBounds, 0, typeVariable.getBounds().length - 1);\n+            return interfaceBounds;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+\n+            return typeVariable.equals(((TypeVarBoundedType) o).typeVariable);\n+\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return typeVariable.hashCode();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final StringBuilder sb = new StringBuilder();\n+            sb.append(\"{firstBound=\").append(firstBound());\n+            sb.append(\", interfaceBounds=\").append(Arrays.deepToString(interfaceBounds()));\n+            sb.append('}');\n+            return sb.toString();\n+        }\n+\n+        public TypeVariable typeVariable() {\n+            return typeVariable;\n+        }\n+    }\n+\n+    /**\n+     * Type representing bounds of a wildcard, allows to keep all bounds information.\n+     *\n+     * <p>The JLS says that lower bound and upper bound are mutually exclusive, and that multiple bounds\n+     * are not allowed.\n+     *\n+     * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>\n+     */\n+    public static class WildCardBoundedType implements BoundedType {\n+        private WildcardType wildcard;\n+\n+\n+        public WildCardBoundedType(WildcardType wildcard) {\n+            this.wildcard = wildcard;\n+        }\n+\n+        /**\n+         * @return The first bound, either a type or a reference to a TypeVariable\n+         */\n+        public Type firstBound() {\n+            Type[] lowerBounds = wildcard.getLowerBounds();\n+            Type[] upperBounds = wildcard.getUpperBounds();\n+\n+            return lowerBounds.length != 0 ? lowerBounds[0] : upperBounds[0];\n+        }\n+\n+        /**\n+         * @return An empty array as, wildcard don't support multiple bounds.\n+         */\n+        public Type[] interfaceBounds() {\n+            return new Type[0];\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+\n+            return wildcard.equals(((TypeVarBoundedType) o).typeVariable);\n+\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return wildcard.hashCode();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final StringBuilder sb = new StringBuilder();\n+            sb.append(\"{firstBound=\").append(firstBound());\n+            sb.append(\", interfaceBounds=[]}\");\n+            return sb.toString();\n+        }\n+\n+        public WildcardType wildCard() {\n+            return wildcard;\n+        }\n+    }\n+\n+}\n+\n+\n--- a/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n+++ b/test/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java\n import org.mockito.internal.progress.MockingProgressImplTest;\n import org.mockito.internal.progress.TimesTest;\n import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValuesTest;\n+import org.mockito.internal.stubbing.defaultanswers.ReturnsGenericDeepStubsTest;\n import org.mockito.internal.util.MockUtilTest;\n import org.mockito.internal.util.collections.ListUtilTest;\n import org.mockito.internal.verification.DefaultRegisteredInvocationsTest;\n                     ExampleTest.class,\n                     PointingStackTraceToActualInvocationTest.class,\n                     VerificationInOrderFromMultipleThreadsTest.class,\n-                    ResetTest.class\n+                    ResetTest.class,\n+                    ReturnsGenericDeepStubsTest.class\n                 );\n                 \n                 if (!result.wasSuccessful()) {\n--- /dev/null\n+++ b/test/org/mockito/internal/stubbing/defaultanswers/ReturnsGenericDeepStubsTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.stubbing.defaultanswers;\n+\n+import org.junit.Test;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.mock;\n+\n+@SuppressWarnings(\"unused\")\n+public class ReturnsGenericDeepStubsTest {\n+    interface ListOfInteger extends List<Integer> {}\n+\n+    interface GenericsNest<K extends Comparable<K> & Cloneable> extends Map<K, Set<Number>> {\n+        Set<Number> remove(Object key); // override with fixed ParameterizedType\n+        List<? super Number> returningWildcard();\n+        Map<String, K> returningNonMockableNestedGeneric();\n+        K returningK();\n+        <O extends K> List<O> paramTypeWithTypeParams();\n+        <S extends Appendable, T extends S> T twoTypeParams(S s);\n+        <O extends K> O typeVarWithTypeParams();\n+        Number returnsNormalType();\n+    }\n+\n+    @Test\n+    public void generic_deep_mock_frenzy__look_at_these_chained_calls() throws Exception {\n+        GenericsNest<?> mock = mock(GenericsNest.class, RETURNS_DEEP_STUBS);\n+\n+        Set<? extends Map.Entry<? extends Cloneable, Set<Number>>> entries = mock.entrySet();\n+        Iterator<? extends Map.Entry<? extends Cloneable,Set<Number>>> entriesIterator = mock.entrySet().iterator();\n+        Map.Entry<? extends Cloneable, Set<Number>> nextEntry = mock.entrySet().iterator().next();\n+\n+        Cloneable cloneableKey = mock.entrySet().iterator().next().getKey();\n+        Comparable<?> comparableKey = mock.entrySet().iterator().next().getKey();\n+\n+        Set<Number> value = mock.entrySet().iterator().next().getValue();\n+        Iterator<Number> numbersIterator = mock.entrySet().iterator().next().getValue().iterator();\n+        Number number = mock.entrySet().iterator().next().getValue().iterator().next();\n+    }\n+\n+    @Test\n+    public void can_create_mock_from_multiple_type_variable_bounds_when_return_type_of_parameterized_method_is_a_parameterizedtype_that_is_referencing_a_typevar_on_class() throws Exception {\n+        GenericsNest<?> mock = mock(GenericsNest.class, RETURNS_DEEP_STUBS);\n+\n+        Cloneable cloneable_bound_that_is_declared_on_typevar_K_in_the_class_which_is_referenced_by_typevar_O_declared_on_the_method =\n+                mock.paramTypeWithTypeParams().get(0);\n+        Comparable<?> comparable_bound_that_is_declared_on_typevar_K_in_the_class_which_is_referenced_by_typevar_O_declared_on_the_method =\n+                mock.paramTypeWithTypeParams().get(0);\n+    }\n+\n+    @Test\n+    public void can_create_mock_from_multiple_type_variable_bounds_when_method_return_type_is_referencing_a_typevar_on_class() throws Exception {\n+        GenericsNest<?> mock = mock(GenericsNest.class, RETURNS_DEEP_STUBS);\n+\n+        Cloneable cloneable_bound_of_typevar_K = mock.returningK();\n+        Comparable<?> comparable_bound_of_typevar_K = mock.returningK();\n+    }\n+\n+    @Test\n+    public void can_create_mock_from_multiple_type_variable_bounds_when_return_type_of_parameterized_method_is_a_typevar_that_is_referencing_a_typevar_on_class() throws Exception {\n+        GenericsNest<?> mock = mock(GenericsNest.class, RETURNS_DEEP_STUBS);\n+\n+        Cloneable cloneable_bound_of_typevar_K_referenced_by_typevar_O = (Cloneable) mock.typeVarWithTypeParams();\n+        Comparable<?> comparable_bound_of_typevar_K_referenced_by_typevar_O = (Comparable) mock.typeVarWithTypeParams();\n+    }\n+\n+    @Test\n+    public void can_create_mock_from_return_types_declared_with_a_bounded_wildcard() throws Exception {\n+        GenericsNest<?> mock = mock(GenericsNest.class, RETURNS_DEEP_STUBS);\n+\n+        List<? super Integer> objects = mock.returningWildcard();\n+        Number type_that_is_the_upper_bound_of_the_wildcard = (Number) mock.returningWildcard().get(45);\n+        type_that_is_the_upper_bound_of_the_wildcard.floatValue();\n+    }\n+\n+    @Test\n+    public void can_still_work_with_raw_type_in_the_return_type() throws Exception {\n+        GenericsNest<?> mock = mock(GenericsNest.class, RETURNS_DEEP_STUBS);\n+\n+        Number the_raw_type_that_should_be_returned = mock.returnsNormalType();\n+        the_raw_type_that_should_be_returned.floatValue();\n+    }\n+\n+    @Test\n+    public void will_return_default_value_on_non_mockable_nested_generic() throws Exception {\n+        GenericsNest<?> genericsNest = mock(GenericsNest.class, RETURNS_DEEP_STUBS);\n+        ListOfInteger listOfInteger = mock(ListOfInteger.class, RETURNS_DEEP_STUBS);\n+\n+        assertThat(genericsNest.returningNonMockableNestedGeneric().keySet().iterator().next()).isNull();\n+        assertThat(listOfInteger.get(25)).isEqualTo(0);\n+    }\n+\n+    @Test(expected = ClassCastException.class)\n+    public void as_expected_fail_with_a_CCE_on_callsite_when_erasure_takes_place_for_example___StringBuilder_is_subject_to_erasure() throws Exception {\n+        GenericsNest<?> mock = mock(GenericsNest.class, RETURNS_DEEP_STUBS);\n+\n+        // following assignment needed to create a ClassCastException on the call site (i.e. : here)\n+        StringBuilder stringBuilder_assignment_that_should_throw_a_CCE =\n+                mock.twoTypeParams(new StringBuilder()).append(2).append(3);\n+    }\n+}\n--- a/test/org/mockito/internal/util/reflection/GenericMasterTest.java\n+++ b/test/org/mockito/internal/util/reflection/GenericMasterTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util.reflection;\n \n-import static org.junit.Assert.*;\n+import org.junit.Test;\n \n import java.lang.reflect.Field;\n-import java.util.Collection;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n+import java.lang.reflect.Type;\n+import java.util.*;\n \n-import org.junit.Test;\n+import static org.junit.Assert.assertEquals;\n \n public class GenericMasterTest {\n     \n     String nonGeneric;\n     List<Set<String>> nested;\n     List<Set<Collection<String>>> multiNested;\n-    \n+\n+    public interface ListSet extends List<Set> {}\n+    public interface MapNumberString extends Map<Number, String> {}\n+    public class HashMapNumberString<K extends Number> extends HashMap<K, String> {}\n+\n+    public List<Number> numberList() { return null; }\n+    public Comparable<Number> numberComparable() { return null; }\n+    public List rawList() { return null; }\n+    public List<? extends Type> typeList() { return null; }\n+\n+\n+\n     @Test\n-    public void shouldFindGenericClass() throws Exception {\n+    public void should_find_generic_class() throws Exception {\n         assertEquals(String.class, m.getGenericType(field(\"one\")));\n         assertEquals(Integer.class, m.getGenericType(field(\"two\")));\n         assertEquals(Double.class, m.getGenericType(field(\"map\")));\n     }\n     \n     @Test\n-    public void shouldGetObjectForNonGeneric() throws Exception {\n+    public void should_get_object_for_non_generic() throws Exception {\n         assertEquals(Object.class, m.getGenericType(field(\"nonGeneric\")));\n     }\n     \n     @Test\n-    public void shouldDealWithNestedGenerics() throws Exception {\n+    public void should_deal_with_nested_generics() throws Exception {\n         assertEquals(Set.class, m.getGenericType(field(\"nested\")));\n         assertEquals(Set.class, m.getGenericType(field(\"multiNested\")));\n     }\n     private Field field(String fieldName) throws SecurityException, NoSuchFieldException {\n         return this.getClass().getDeclaredField(fieldName);\n     }\n+\n }\n--- /dev/null\n+++ b/test/org/mockito/internal/util/reflection/GenericMetadataSupportTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.util.reflection;\n+\n+import org.junit.Test;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.internal.util.reflection.GenericMetadataSupport.inferFrom;\n+\n+@SuppressWarnings(\"unused\")\n+public class GenericMetadataSupportTest {\n+\n+    interface UpperBoundedTypeWithClass<E extends Number & Comparable<E>> {\n+        E get();\n+    }\n+    interface UpperBoundedTypeWithInterfaces<E extends Comparable<E> & Cloneable> {\n+        E get();\n+    }\n+    interface ListOfNumbers extends List<Number> {}\n+    interface ListOfAnyNumbers<N extends Number & Cloneable> extends List<N> {}\n+\n+    interface GenericsNest<K extends Comparable<K> & Cloneable> extends Map<K, Set<Number>> {\n+        Set<Number> remove(Object key); // override with fixed ParameterizedType\n+        List<? super Integer> returning_wildcard_with_class_lower_bound();\n+        List<? super K> returning_wildcard_with_typeVar_lower_bound();\n+        List<? extends K> returning_wildcard_with_typeVar_upper_bound();\n+        K returningK();\n+        <O extends K> List<O> paramType_with_type_params();\n+        <S, T extends S> T two_type_params();\n+        <O extends K> O typeVar_with_type_params();\n+    }\n+\n+    @Test\n+    public void can_get_raw_type_from_Class() throws Exception {\n+        assertThat(inferFrom(ListOfAnyNumbers.class).rawType()).isEqualTo(ListOfAnyNumbers.class);\n+        assertThat(inferFrom(ListOfNumbers.class).rawType()).isEqualTo(ListOfNumbers.class);\n+        assertThat(inferFrom(GenericsNest.class).rawType()).isEqualTo(GenericsNest.class);\n+    }\n+\n+\n+    @Test\n+    public void can_get_raw_type_from_ParameterizedType() throws Exception {\n+        assertThat(inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).rawType()).isEqualTo(List.class);\n+        assertThat(inferFrom(ListOfNumbers.class.getGenericInterfaces()[0]).rawType()).isEqualTo(List.class);\n+        assertThat(inferFrom(GenericsNest.class.getGenericInterfaces()[0]).rawType()).isEqualTo(Map.class);\n+    }\n+\n+    @Test\n+    public void can_get_type_variables_from_Class() throws Exception {\n+        assertThat(inferFrom(GenericsNest.class).actualTypeArguments().keySet()).hasSize(1).onProperty(\"name\").contains(\"K\");\n+        assertThat(inferFrom(ListOfNumbers.class).actualTypeArguments().keySet()).isEmpty();\n+        assertThat(inferFrom(ListOfAnyNumbers.class).actualTypeArguments().keySet()).hasSize(1).onProperty(\"name\").contains(\"N\");\n+        assertThat(inferFrom(Map.class).actualTypeArguments().keySet()).hasSize(2).onProperty(\"name\").contains(\"K\", \"V\");\n+        assertThat(inferFrom(Serializable.class).actualTypeArguments().keySet()).isEmpty();\n+    }\n+\n+    @Test\n+    public void can_get_type_variables_from_ParameterizedType() throws Exception {\n+        assertThat(inferFrom(GenericsNest.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(2).onProperty(\"name\").contains(\"K\", \"V\");\n+        assertThat(inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).onProperty(\"name\").contains(\"E\");\n+        assertThat(inferFrom(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).onProperty(\"name\").contains(\"T\");\n+        assertThat(inferFrom(StringBuilder.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).isEmpty();\n+    }\n+\n+    @Test\n+    public void typeVariable_return_type_of____get____resolved_to_Set_and_type_argument_to_Number() throws Exception {\n+        GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"get\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(Set.class);\n+        assertThat(genericMetadata.actualTypeArguments().values()).contains(Number.class);\n+    }\n+\n+    @Test\n+    public void bounded_typeVariable_return_type_of____returningK____resolved_to_Comparable_and_with_BoundedType() throws Exception {\n+        GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returningK\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(Comparable.class);\n+        GenericMetadataSupport extraInterface_0 = inferFrom(genericMetadata.extraInterfaces().get(0));\n+        assertThat(extraInterface_0.rawType()).isEqualTo(Cloneable.class);\n+    }\n+\n+    @Test\n+    public void fixed_ParamType_return_type_of____remove____resolved_to_Set_and_type_argument_to_Number() throws Exception {\n+        GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"remove\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(Set.class);\n+        assertThat(genericMetadata.actualTypeArguments().values()).contains(Number.class);\n+    }\n+\n+    @Test\n+    public void paramType_return_type_of____values____resolved_to_Collection_and_type_argument_to_Parameterized_Set() throws Exception {\n+        GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"values\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(Collection.class);\n+        GenericMetadataSupport fromTypeVariableE = inferFrom(typeVariableValue(genericMetadata.actualTypeArguments(), \"E\"));\n+        assertThat(fromTypeVariableE.rawType()).isEqualTo(Set.class);\n+        assertThat(fromTypeVariableE.actualTypeArguments().values()).contains(Number.class);\n+    }\n+\n+    @Test\n+    public void paramType_with_type_parameters_return_type_of____paramType_with_type_params____resolved_to_Collection_and_type_argument_to_Parameterized_Set() throws Exception {\n+        GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"paramType_with_type_params\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(List.class);\n+        Type firstBoundOfE = ((GenericMetadataSupport.TypeVarBoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), \"E\")).firstBound();\n+        assertThat(inferFrom(firstBoundOfE).rawType()).isEqualTo(Comparable.class);\n+    }\n+\n+    @Test\n+    public void typeVariable_with_type_parameters_return_type_of____typeVar_with_type_params____resolved_K_hence_to_Comparable_and_with_BoundedType() throws Exception {\n+        GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"typeVar_with_type_params\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(Comparable.class);\n+        GenericMetadataSupport extraInterface_0 = inferFrom(genericMetadata.extraInterfaces().get(0));\n+        assertThat(extraInterface_0.rawType()).isEqualTo(Cloneable.class);\n+    }\n+\n+    @Test\n+    public void class_return_type_of____append____resolved_to_StringBuilder_and_type_arguments() throws Exception {\n+        GenericMetadataSupport genericMetadata = inferFrom(StringBuilder.class).resolveGenericReturnType(firstNamedMethod(\"append\", StringBuilder.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(StringBuilder.class);\n+        assertThat(genericMetadata.actualTypeArguments()).isEmpty();\n+    }\n+\n+\n+\n+    @Test\n+    public void paramType_with_wildcard_return_type_of____returning_wildcard_with_class_lower_bound____resolved_to_List_and_type_argument_to_Integer() throws Exception {\n+        GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returning_wildcard_with_class_lower_bound\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(List.class);\n+        GenericMetadataSupport.BoundedType boundedType = (GenericMetadataSupport.BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), \"E\");\n+        assertThat(boundedType.firstBound()).isEqualTo(Integer.class);\n+        assertThat(boundedType.interfaceBounds()).isEmpty();\n+    }\n+\n+    @Test\n+    public void paramType_with_wildcard_return_type_of____returning_wildcard_with_typeVar_lower_bound____resolved_to_List_and_type_argument_to_Integer() throws Exception {\n+        GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returning_wildcard_with_typeVar_lower_bound\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(List.class);\n+        GenericMetadataSupport.BoundedType boundedType = (GenericMetadataSupport.BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), \"E\");\n+\n+        assertThat(inferFrom(boundedType.firstBound()).rawType()).isEqualTo(Comparable.class);\n+        assertThat(boundedType.interfaceBounds()).contains(Cloneable.class);    }\n+\n+    @Test\n+    public void paramType_with_wildcard_return_type_of____returning_wildcard_with_typeVar_upper_bound____resolved_to_List_and_type_argument_to_Integer() throws Exception {\n+        GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returning_wildcard_with_typeVar_upper_bound\", GenericsNest.class));\n+\n+        assertThat(genericMetadata.rawType()).isEqualTo(List.class);\n+        GenericMetadataSupport.BoundedType boundedType = (GenericMetadataSupport.BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), \"E\");\n+\n+        assertThat(inferFrom(boundedType.firstBound()).rawType()).isEqualTo(Comparable.class);\n+        assertThat(boundedType.interfaceBounds()).contains(Cloneable.class);\n+    }\n+\n+\n+\n+    private Type typeVariableValue(Map<TypeVariable, Type> typeVariables, String typeVariableName) {\n+        for (Map.Entry<TypeVariable, Type> typeVariableTypeEntry : typeVariables.entrySet()) {\n+            if (typeVariableTypeEntry.getKey().getName().equals(typeVariableName)) {\n+                return typeVariableTypeEntry.getValue();\n+            }\n+        }\n+\n+        fail(\"'\" + typeVariableName + \"' was not found in \" + typeVariables);\n+        return null; // unreachable\n+    }\n+\n+    private Method firstNamedMethod(String methodName, Class<?> clazz) {\n+        for (Method method : clazz.getMethods()) {\n+            if (method.getName().contains(methodName)) {\n+                return method;\n+            }\n+        }\n+        throw new IllegalStateException(\"The method : '\" + methodName + \"' do not exist in '\" + clazz.getSimpleName() + \"'\");\n+    }\n+\n+\n+}\n--- a/src/org/mockito/ArgumentCaptor.java\n+++ b/src/org/mockito/ArgumentCaptor.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito;\n \n import org.mockito.internal.matchers.CapturingMatcher;\n+import org.mockito.internal.matchers.VarargCapturingMatcher;\n import org.mockito.internal.progress.HandyReturnValues;\n \n import java.util.List;\n     HandyReturnValues handyReturnValues = new HandyReturnValues();\n \n     private final CapturingMatcher<T> capturingMatcher = new CapturingMatcher<T>();\n+    private final VarargCapturingMatcher<T> varargCapturingMatcher = new VarargCapturingMatcher<T>();\n     private final Class<T> clazz;\n \n     /**\n      * <p>\n      * See examples in javadoc for {@link ArgumentCaptor} class.\n      * \n-     * @return null\n+     * @return null or default values\n      */\n     public T capture() {\n         Mockito.argThat(capturingMatcher);\n     }\n \n     /**\n+     * Use it to capture the variable arguments. This method <b>must be used inside of verification</b>.\n+     * <p>\n+     * Internally, this method registers a special implementation of an {@link ArgumentMatcher}.\n+     * This argument matcher stores the variable arguments values so that you can use it later to perform assertions.\n+     * <p>\n+     * See examples in javadoc for {@link ArgumentCaptor} class.\n+     *\n+     * @return null or default values\n+     */\n+    public T captureVararg() {\n+        Mockito.argThat(varargCapturingMatcher);\n+        return handyReturnValues.returnFor(clazz);\n+    }\n+\n+\n+    /**\n      * Returns the captured value of the argument.\n      * <p>\n-     * If the method was called multiple times then it returns the latest captured value\n+     * If the method was called multiple times then it returns the latest captured value.\n      * <p>\n      * See examples in javadoc for {@link ArgumentCaptor} class.\n      * \n      */\n     public T getValue() {\n         return this.capturingMatcher.getLastValue();\n+    }\n+\n+    /**\n+     * Returns the captured value of the variable arguments.\n+     * <p>\n+     * If the method was called multiple times then it returns the latest captured variable arguments.\n+     * <p>\n+     * See examples in javadoc for {@link ArgumentCaptor} class.\n+     *\n+     * @return captured varargs\n+     */\n+    public List<T> getVarargsValues() {\n+        return this.varargCapturingMatcher.getLastVarargs();\n     }\n \n     /**\n     }\n \n     /**\n+     * Returns all captured variable arguments. Use it in case the verified method was called multiple times.\n+     * <p>\n+     * Example:\n+     * <pre class=\"code\"><code class=\"java\">\n+     *   ArgumentCaptor&lt;Person&gt; peopleFornamesCaptor = ArgumentCaptor.forClass(String.class);\n+     *   verify(mock, times(2)).doSomething(peopleFornamesCaptor.captureVarargs());\n+     *\n+     *   List&lt;String&gt; peopleFornames = peopleFornamesCaptor.getAllVarargs();\n+     *   assertThat(peopleFornames.get(0)).contains(\"John\", \"Carl\");\n+     *   assertThat(peopleFornames.get(1)).contains(\"Janes\", \"Eloise\", \"Lois\");\n+     * </code></pre>\n+     * See more examples in javadoc for {@link ArgumentCaptor} class.\n+     *\n+     * @return all captured varargs\n+     */\n+    public List<List<T>> getAllVarargsValues() {\n+        return this.varargCapturingMatcher.getAllVarargs();\n+    }\n+\n+    /**\n      * Build a new <code>ArgumentCaptor</code>.\n      * <p>\n      * Note that an <code>ArgumentCaptor</code> <b>*don't do any type checks*</b>, it is only there to avoid casting\n--- a/src/org/mockito/Mock.java\n+++ b/src/org/mockito/Mock.java\n \n     String name() default \"\";\n \n-    Class<?>[] extraInterfaces() default {};\n+    Class<?>[] extraInterfaces() default {};\n+    \n+    boolean serializable() default false;\n }\n--- a/src/org/mockito/internal/configuration/MockAnnotationProcessor.java\n+++ b/src/org/mockito/internal/configuration/MockAnnotationProcessor.java\n         } else {\n             mockSettings.name(annotation.name());\n         }\n+        if(annotation.serializable()){\n+        \tmockSettings.serializable();\n+        }\n \n         // see @Mock answer default value\n         mockSettings.defaultAnswer(annotation.answer().get());\n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n \n import org.hamcrest.Matcher;\n import org.mockito.internal.matchers.CapturesArguments;\n+import org.mockito.internal.matchers.MatcherDecorator;\n+import org.mockito.internal.matchers.VarargMatcher;\n import org.mockito.internal.reporting.PrintSettings;\n import org.mockito.invocation.DescribedInvocation;\n import org.mockito.invocation.Invocation;\n         return invocation.getLocation();\n     }\n \n-    public void captureArgumentsFrom(Invocation i) {\n-        int k = 0;\n-        for (Matcher m : matchers) {\n-            if (m instanceof CapturesArguments && i.getArguments().length > k) {\n-                ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n+    public void captureArgumentsFrom(Invocation invocation) {\n+        for (int position = 0; position < matchers.size(); position++) {\n+            Matcher m = matchers.get(position);\n+            if (m instanceof CapturesArguments && invocation.getArguments().length > position) {\n+                if(isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n+                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);\n+                } else {\n+                    ((CapturesArguments) m).captureFrom(invocation.getArguments()[position]);\n+                }\n             }\n-            k++;\n         }\n+    }\n+\n+    private boolean isVarargMatcher(Matcher matcher) {\n+        Matcher actualMatcher = matcher;\n+        if (actualMatcher instanceof MatcherDecorator) {\n+            actualMatcher = ((MatcherDecorator) actualMatcher).getActualMatcher();\n+        }\n+        return actualMatcher instanceof VarargMatcher;\n+    }\n+\n+    private boolean isVariableArgument(Invocation invocation, int position) {\n+        return invocation.getRawArguments().length - 1 == position\n+                && invocation.getRawArguments()[position] != null\n+                && invocation.getRawArguments()[position].getClass().isArray()\n+                && invocation.getMethod().isVarArgs();\n     }\n \n     public static List<InvocationMatcher> createFrom(List<Invocation> invocations) {\n--- /dev/null\n+++ b/src/org/mockito/internal/matchers/VarargCapturingMatcher.java\n+package org.mockito.internal.matchers;\n+\n+import org.hamcrest.Description;\n+import org.mockito.ArgumentMatcher;\n+import org.mockito.exceptions.Reporter;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+\n+@SuppressWarnings(\"unchecked\")\n+public class VarargCapturingMatcher<T> extends ArgumentMatcher<T> implements CapturesArguments, VarargMatcher, Serializable {\n+    private static final long serialVersionUID = 4057053345838026645L;\n+    private LinkedList<List<T>> arguments = new LinkedList<List<T>>();\n+\n+    public boolean matches(Object argument) {\n+        return true;\n+    }\n+\n+    public void describeTo(Description description) {\n+        description.appendText(\"<Capturing variable argument>\");\n+    }\n+\n+    public List<T> getLastVarargs() {\n+        if (arguments.isEmpty()) {\n+            new Reporter().noArgumentValueWasCaptured();\n+            return null;\n+        } else {\n+            return arguments.getLast();\n+        }\n+    }\n+\n+    public List<List<T>> getAllVarargs() {\n+        return arguments;\n+    }\n+\n+    public void captureFrom(Object varArgArray) {\n+        List<T> vararg = unpackAsList(varArgArray);\n+        this.arguments.add(vararg);\n+    }\n+\n+    private List<T> unpackAsList(Object varArgArray) {\n+        if (varArgArray instanceof Object[]) {\n+            return Arrays.asList((T[]) varArgArray);\n+        } else if (varArgArray.getClass().isArray()) {\n+            Object[] primitiveArray = new Object[Array.getLength(varArgArray)];\n+            for (int i = 0; i < primitiveArray.length; i++) {\n+                primitiveArray[i] = Array.get(varArgArray, i);\n+            }\n+            return Arrays.asList((T[]) primitiveArray);\n+        } else {\n+            return Collections.singletonList((T) varArgArray);\n+        }\n+    }\n+}\n--- a/subprojects/testng/src/main/java/org/mockito/testng/MockitoAfterTestNGMethod.java\n+++ b/subprojects/testng/src/main/java/org/mockito/testng/MockitoAfterTestNGMethod.java\n         Mockito.reset(instanceMocksOf(instance).toArray());\n     }\n \n+    @SuppressWarnings({\"deprecation\", \"unchecked\"})\n     private Collection<Object> instanceMocksOf(Object instance) {\n         return Fields.allDeclaredFieldsOf(instance)\n                                             .filter(annotatedBy(Mock.class,\n--- a/subprojects/testng/src/test/java/org/mockitousage/testng/InitializeChildTestWhenParentHasListenerTest.java\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/InitializeChildTestWhenParentHasListenerTest.java\n import java.util.Map;\n \n import static org.fest.assertions.Assertions.assertThat;\n+import static org.testng.Assert.fail;\n \n public class InitializeChildTestWhenParentHasListenerTest extends ParentTest {\n \n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/failuretests/FailingOnPurposeBecauseIncorrectAnnotationUsage.java\n+package org.mockitousage.testng.failuretests;\n+\n+import org.mockito.Spy;\n+import org.mockito.testng.MockitoTestNGListener;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+\n+import java.util.Map;\n+\n+/**\n+ * Should fail.\n+ *\n+ * @see TestNGShouldFailWhenMockitoListenerFailsTest\n+ */\n+@Listeners(MockitoTestNGListener.class)\n+@Test(description = \"Always failing, shouldn't be listed in 'mockito-testng.xml'\")\n+public class FailingOnPurposeBecauseIncorrectAnnotationUsage {\n+    @Spy Map spy_cant_initialize_interface_fields;\n+    @Test public void dummy_test_method() throws Exception { }\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/failuretests/FailingOnPurposeBecauseIncorrectStubbingSyntax.java\n+package org.mockitousage.testng.failuretests;\n+\n+import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;\n+import org.mockito.testng.MockitoTestNGListener;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+\n+import java.io.PrintStream;\n+\n+import static org.mockito.Matchers.anySet;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Mockito.mock;\n+\n+/**\n+ * Should fail.\n+ *\n+ * @see TestNGShouldFailWhenMockitoListenerFailsTest\n+ */\n+@Listeners(MockitoTestNGListener.class)\n+@Test(description = \"Always failing, shouldn't be listed in 'mockito-testng.xml'\")\n+public class FailingOnPurposeBecauseIncorrectStubbingSyntax {\n+\n+    @Test(expectedExceptions = InvalidUseOfMatchersException.class)\n+    public void incorrect_stubbing_syntax_in_test() throws Exception {\n+        mock(PrintStream.class);\n+        anyString();\n+        anySet();\n+    }\n+\n+}\n--- /dev/null\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/failuretests/FailingOnPurposeBecauseWrongStubbingSyntaxInConfigurationMethod.java\n+package org.mockitousage.testng.failuretests;\n+\n+import org.mockito.Mock;\n+import org.mockito.testng.MockitoTestNGListener;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+\n+import static org.mockito.Matchers.anyString;\n+\n+/**\n+ * Should fail.\n+ *\n+ * @see TestNGShouldFailWhenMockitoListenerFailsTest\n+ */\n+@Listeners(MockitoTestNGListener.class)\n+@Test(description = \"Always failing, shouldn't be listed in 'mockito-testng.xml'\")\n+public class FailingOnPurposeBecauseWrongStubbingSyntaxInConfigurationMethod {\n+\n+    @Mock List list;\n+\n+    // should fail\n+    @BeforeMethod public void some_wrong_stubs() {\n+        anyString();\n+    }\n+\n+\n+    @Test\n+    public void here_to_execute_the_config_method() throws Exception {\n+    }\n+\n+}\n--- a/subprojects/testng/src/test/java/org/mockitousage/testng/failuretests/TestNGShouldFailWhenMockitoListenerFailsTest.java\n+++ b/subprojects/testng/src/test/java/org/mockitousage/testng/failuretests/TestNGShouldFailWhenMockitoListenerFailsTest.java\n     private final FailureRecordingListener failureRecorder = new FailureRecordingListener();\n \n     public void report_failure_on_incorrect_annotation_usage() throws Throwable {\n-        TestNG testNG = new_TestNG_with_failure_recorder_for(FailingBecauseIncorrectAnnotationUsage.class);\n+        TestNG testNG = new_TestNG_with_failure_recorder_for(FailingOnPurposeBecauseIncorrectAnnotationUsage.class);\n \n         testNG.run();\n \n \n     @Test\n     public void report_failure_on_incorrect_stubbing_syntax_with_matchers_in_test_methods() throws Exception {\n-        TestNG testNG = new_TestNG_with_failure_recorder_for(FailingBecauseIncorrectStubbingSyntax.class);\n+        TestNG testNG = new_TestNG_with_failure_recorder_for(FailingOnPurposeBecauseIncorrectStubbingSyntax.class);\n \n         testNG.run();\n \n \n     @Test\n     public void report_failure_on_incorrect_stubbing_syntax_with_matchers_in_configuration_methods() throws Exception {\n-        TestNG testNG = new_TestNG_with_failure_recorder_for(FailingBecauseWrongStubbingSyntaxInConfigurationMethod.class);\n+        TestNG testNG = new_TestNG_with_failure_recorder_for(FailingOnPurposeBecauseWrongStubbingSyntaxInConfigurationMethod.class);\n \n         testNG.run();\n \n--- a/test/org/mockito/ArgumentCaptorTest.java\n+++ b/test/org/mockito/ArgumentCaptorTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito;\n \n import org.junit.After;\n public class ArgumentCaptorTest extends TestBase {\n     \n     @Test\n-    public void tellHandyReturnValuesToReturnValueFor() throws Exception {\n+    public void tell_handy_return_values_to_return_value_for() throws Exception {\n         //given\n         final Object expected = new Object(); \n         ArgumentCaptor<Object> argumentCaptor = ArgumentCaptor.forClass(Object.class);\n-        argumentCaptor.handyReturnValues = new HandyReturnValues() {\n+        argumentCaptor.handyReturnValues = will_return(expected);\n+        \n+        //when\n+        Object returned = argumentCaptor.capture();\n+        Object returned_for_vararg = argumentCaptor.captureVararg();\n+\n+        //then\n+        assertEquals(expected, returned);\n+        assertEquals(expected, returned_for_vararg);\n+    }\n+\n+    private HandyReturnValues will_return(final Object expected) {\n+        return new HandyReturnValues() {\n             @Override\n             public <T> T returnFor(Class<T> clazz) {\n                 return (T) expected;\n             }\n         };\n-        \n-        //when\n-        Object returned = argumentCaptor.capture();\n-        \n-        //then\n-        assertEquals(expected, returned);\n     }\n-    \n+\n     @After\n-    public void yesIKnowSomeMatchersAreMisplaced() {\n+    public void yes_I_know_some_matchers_are_misplaced() {\n         resetState();\n     }\n }\n--- a/test/org/mockito/internal/invocation/InvocationMatcherTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationMatcherTest.java\n import java.util.List;\n import java.util.Map;\n \n+import org.fest.assertions.Assertions;\n import org.hamcrest.Matcher;\n import org.junit.Before;\n import org.junit.Test;\n import org.mockito.Mock;\n-import org.mockito.internal.matchers.AnyVararg;\n-import org.mockito.internal.matchers.CapturingMatcher;\n-import org.mockito.internal.matchers.Equals;\n-import org.mockito.internal.matchers.LocalizedMatcher;\n-import org.mockito.internal.matchers.NotNull;\n+import org.mockito.internal.matchers.*;\n import org.mockito.invocation.Invocation;\n import org.mockitousage.IMethods;\n import org.mockitoutil.TestBase;\n public class InvocationMatcherTest extends TestBase {\n \n     private InvocationMatcher simpleMethod;\n-    @Mock private IMethods mock; \n-    \n+    @Mock private IMethods mock;\n+\n     @Before\n     public void setup() {\n         simpleMethod = new InvocationBuilder().mock(mock).simpleMethod().toInvocationMatcher();\n     }\n \n     @Test\n-    public void shouldBeACitizenOfHashes() throws Exception {\n+    public void should_be_a_citizen_of_hashes() throws Exception {\n         Invocation invocation = new InvocationBuilder().toInvocation();\n         Invocation invocationTwo = new InvocationBuilder().args(\"blah\").toInvocation();\n-        \n+\n         Map map = new HashMap();\n         map.put(new InvocationMatcher(invocation), \"one\");\n         map.put(new InvocationMatcher(invocationTwo), \"two\");\n-        \n+\n         assertEquals(2, map.size());\n     }\n-    \n+\n     @Test\n-    public void shouldNotEqualIfNumberOfArgumentsDiffer() throws Exception {\n+    public void should_not_equal_if_number_of_arguments_differ() throws Exception {\n         InvocationMatcher withOneArg = new InvocationMatcher(new InvocationBuilder().args(\"test\").toInvocation());\n         InvocationMatcher withTwoArgs = new InvocationMatcher(new InvocationBuilder().args(\"test\", 100).toInvocation());\n \n         assertFalse(withOneArg.equals(null));\n         assertFalse(withOneArg.equals(withTwoArgs));\n     }\n-    \n+\n     @Test\n-    public void shouldToStringWithMatchers() throws Exception {\n+    public void should_to_string_with_matchers() throws Exception {\n         Matcher m = NotNull.NOT_NULL;\n         InvocationMatcher notNull = new InvocationMatcher(new InvocationBuilder().toInvocation(), asList(m));\n         Matcher mTwo = new Equals('x');\n         assertContains(\"simpleMethod(notNull())\", notNull.toString());\n         assertContains(\"simpleMethod('x')\", equals.toString());\n     }\n-    \n+\n     @Test\n-    public void shouldKnowIfIsSimilarTo() throws Exception {\n+    public void should_know_if_is_similar_to() throws Exception {\n         Invocation same = new InvocationBuilder().mock(mock).simpleMethod().toInvocation();\n         assertTrue(simpleMethod.hasSimilarMethod(same));\n-        \n+\n         Invocation different = new InvocationBuilder().mock(mock).differentMethod().toInvocation();\n         assertFalse(simpleMethod.hasSimilarMethod(different));\n     }\n-    \n+\n     @Test\n-    public void shouldNotBeSimilarToVerifiedInvocation() throws Exception {\n+    public void should_not_be_similar_to_verified_invocation() throws Exception {\n         Invocation verified = new InvocationBuilder().simpleMethod().verified().toInvocation();\n         assertFalse(simpleMethod.hasSimilarMethod(verified));\n     }\n-       \n+\n     @Test\n-    public void shouldNotBeSimilarIfMocksAreDifferent() throws Exception {\n+    public void should_not_be_similar_if_mocks_are_different() throws Exception {\n         Invocation onDifferentMock = new InvocationBuilder().simpleMethod().mock(\"different mock\").toInvocation();\n         assertFalse(simpleMethod.hasSimilarMethod(onDifferentMock));\n-    }    \n-    \n+    }\n+\n     @Test\n-    public void shouldNotBeSimilarIfIsOverloadedButUsedWithTheSameArg() throws Exception {\n+    public void should_not_be_similar_if_is_overloaded_but_used_with_the_same_arg() throws Exception {\n         Method method = IMethods.class.getMethod(\"simpleMethod\", String.class);\n         Method overloadedMethod = IMethods.class.getMethod(\"simpleMethod\", Object.class);\n-        \n+\n         String sameArg = \"test\";\n-        \n+\n         InvocationMatcher invocation = new InvocationBuilder().method(method).arg(sameArg).toInvocationMatcher();\n         Invocation overloadedInvocation = new InvocationBuilder().method(overloadedMethod).arg(sameArg).toInvocation();\n-        \n+\n         assertFalse(invocation.hasSimilarMethod(overloadedInvocation));\n-    } \n-    \n+    }\n+\n     @Test\n-    public void shouldBeSimilarIfIsOverloadedButUsedWithDifferentArg() throws Exception {\n+    public void should_be_similar_if_is_overloaded_but_used_with_different_arg() throws Exception {\n         Method method = IMethods.class.getMethod(\"simpleMethod\", String.class);\n         Method overloadedMethod = IMethods.class.getMethod(\"simpleMethod\", Object.class);\n-        \n+\n         InvocationMatcher invocation = new InvocationBuilder().mock(mock).method(method).arg(\"foo\").toInvocationMatcher();\n         Invocation overloadedInvocation = new InvocationBuilder().mock(mock).method(overloadedMethod).arg(\"bar\").toInvocation();\n-        \n+\n         assertTrue(invocation.hasSimilarMethod(overloadedInvocation));\n     }\n-    \n+\n     @Test\n-    public void shouldCaptureArgumentsFromInvocation() throws Exception {\n+    public void should_capture_arguments_from_invocation() throws Exception {\n         //given\n         Invocation invocation = new InvocationBuilder().args(\"1\", 100).toInvocation();\n         CapturingMatcher capturingMatcher = new CapturingMatcher();\n         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(\"1\"), capturingMatcher));\n-        \n+\n         //when\n         invocationMatcher.captureArgumentsFrom(invocation);\n-        \n+\n         //then\n         assertEquals(1, capturingMatcher.getAllValues().size());\n         assertEquals(100, capturingMatcher.getLastValue());\n     }\n \n     @Test\n-    public void shouldMatchVarargsUsingAnyVarargs() throws Exception {\n+    public void should_match_varargs_using_any_varargs() throws Exception {\n         //given\n         mock.varargs(\"1\", \"2\");\n         Invocation invocation = getLastInvocation();\n     }\n \n     @Test\n-    public void shouldMatchCaptureArgumentsWhenArgsCountDoesNOTMatch() throws Exception {\n+    public void should_capture_varargs_as_vararg() throws Exception {\n+        //given\n+        mock.mixedVarargs(1, \"a\", \"b\");\n+        Invocation invocation = getLastInvocation();\n+        VarargCapturingMatcher varargCapturingMatcher = new VarargCapturingMatcher();\n+        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(1), new LocalizedMatcher(varargCapturingMatcher)));\n+\n+        //when\n+        invocationMatcher.captureArgumentsFrom(invocation);\n+\n+        //then\n+        Assertions.assertThat(varargCapturingMatcher.getLastVarargs()).containsExactly(\"a\", \"b\");\n+    }\n+\n+    @Test  // like using several time the captor in the vararg\n+    public void should_capture_arguments_when_args_count_does_NOT_match() throws Exception {\n         //given\n         mock.varargs();\n         Invocation invocation = getLastInvocation();\n     }\n \n     @Test\n-    public void shouldCreateFromInvocations() throws Exception {\n+    public void should_create_from_invocations() throws Exception {\n         //given\n         Invocation i = new InvocationBuilder().toInvocation();\n         //when\n--- a/test/org/mockito/internal/matchers/CapturingMatcherTest.java\n+++ b/test/org/mockito/internal/matchers/CapturingMatcherTest.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.matchers;\n \n import org.fest.assertions.Assertions;\n public class CapturingMatcherTest extends TestBase {\n \n     @Test\n-    public void shouldCaptureArguments() throws Exception {\n+    public void should_capture_arguments() throws Exception {\n         //given\n         CapturingMatcher m = new CapturingMatcher();\n         \n     }\n     \n     @Test\n-    public void shouldKnowLastCapturedValue() throws Exception {\n+    public void should_know_last_captured_value() throws Exception {\n         //given\n         CapturingMatcher m = new CapturingMatcher();\n         \n     }\n     \n     @Test\n-    public void shouldScreamWhenNothingYetCaptured() throws Exception {\n+    public void should_scream_when_nothing_yet_captured() throws Exception {\n         //given\n         CapturingMatcher m = new CapturingMatcher();\n \n--- /dev/null\n+++ b/test/org/mockito/internal/matchers/VarargCapturingMatcherTest.java\n+package org.mockito.internal.matchers;\n+\n+\n+import org.junit.Test;\n+import org.mockito.exceptions.base.MockitoException;\n+\n+import static java.util.Arrays.asList;\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.junit.Assert.fail;\n+\n+public class VarargCapturingMatcherTest {\n+    @Test\n+    public void should_capture_simple_arguments() throws Exception {\n+        //given\n+        VarargCapturingMatcher m = new VarargCapturingMatcher();\n+\n+        //when\n+        m.captureFrom(\"foo\");\n+        m.captureFrom(\"bar\");\n+\n+        //then\n+        assertThat(m.getAllVarargs()).containsSequence(asList(\"foo\"), asList(\"bar\"));\n+    }\n+\n+    @Test\n+    public void should_know_last_captured_vararg() throws Exception {\n+        //given\n+        VarargCapturingMatcher m = new VarargCapturingMatcher();\n+\n+        //when\n+        m.captureFrom(new Object[] { \"foo\", \"bar\" });\n+        m.captureFrom(new Object[] { \"fool\", \"bard\" });\n+\n+        //then\n+        assertThat(m.getLastVarargs()).containsSequence(\"fool\", \"bard\");\n+    }\n+\n+    @Test\n+    public void can_capture_primitive_varargs() throws Exception {\n+        //given\n+        VarargCapturingMatcher m = new VarargCapturingMatcher();\n+\n+        //when\n+        m.captureFrom(new int[] { 1, 2, 3 });\n+\n+        //then\n+        assertThat(m.getLastVarargs()).containsSequence(1, 2, 3);\n+    }\n+\n+    @Test\n+    public void should_scream_when_nothing_yet_captured() throws Exception {\n+        //given\n+        VarargCapturingMatcher m = new VarargCapturingMatcher();\n+\n+        try {\n+            //when\n+            m.getLastVarargs();\n+            //then\n+            fail();\n+        } catch (MockitoException e) {}\n+    }\n+}\n--- a/test/org/mockitousage/IMethods.java\n+++ b/test/org/mockitousage/IMethods.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage;\n \n import java.io.IOException;\n     void varargsString(int i, String... string);\n \n     Object varargsObject(int i, Object... object);\n-    \n+\n+    void varargsbyte(byte... bytes);\n+\n     int varargs(Object ... object);\n \n     String varargsReturningString(Object ... object);\n     void mixedVarargs(Object i, String ... string);\n \n     List<String> listReturningMethod(Object ... objects);\n-    \n+\n     LinkedList<String> linkedListReturningMethod();\n-    \n+\n     String toString();\n-    \n+\n     String toString(String foo);\n \n     void voidMethod();\n \n     String forList(List<String> list);\n-    \n+\n     String forSet(Set<String> anySet);\n \n     String forMap(Map<String, String> map);\n-    \n+\n     String forCollection(Collection<String> collection);\n \n     Object[] arrayReturningMethod();\n     Object objectArgMethod(Object str);\n \n     Object listArgMethod(List<String> list);\n-    \n+\n     Object collectionArgMethod(Collection<String> collection);\n \n     Object setArgMethod(Set<String> set);\n--- a/test/org/mockitousage/MethodsImpl.java\n+++ b/test/org/mockitousage/MethodsImpl.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockitousage;\n \n import java.io.IOException;\n     public void mixedVarargs(Object i, String... string) {\n     }\n \n+    public void varargsbyte(byte... bytes) {\n+    }\n+\n     public List<String> listReturningMethod(Object... objects) {\n         return null;\n     }\n--- a/test/org/mockitousage/annotation/MockInjectionUsingConstructorTest.java\n+++ b/test/org/mockitousage/annotation/MockInjectionUsingConstructorTest.java\n \n package org.mockitousage.annotation;\n \n-import org.fest.assertions.Assertions;\n import org.junit.Ignore;\n import org.junit.Test;\n+import org.junit.internal.TextListener;\n+import org.junit.runner.JUnitCore;\n import org.junit.runner.RunWith;\n import org.mockito.InjectMocks;\n import org.mockito.Mock;\n import org.mockitousage.examples.use.ArticleDatabase;\n import org.mockitousage.examples.use.ArticleManager;\n \n-import java.util.HashSet;\n+import java.util.List;\n import java.util.Set;\n \n+import static org.fest.assertions.Assertions.assertThat;\n import static org.junit.Assert.*;\n import static org.mockito.Mockito.when;\n \n     @Spy @InjectMocks private ArticleManager spiedArticleManager;\n \n \n-    @InjectMocks private ArticleVisitor should_be_initialized_several_times;\n+//    @InjectMocks private ArticleVisitor should_be_initialized_3_times;\n \n     @Test\n     public void shouldNotFailWhenNotInitialized() {\n     }\n \n     @Test\n-    public void constructor_is_called_for_each_test() throws Exception {\n-        int minimum_number_of_test_before = 3;\n-        Assertions.assertThat(articleVisitorInstantiationCount).isGreaterThan(minimum_number_of_test_before);\n-        Assertions.assertThat(articleVisitorMockInjectedInstances.size()).isGreaterThan(minimum_number_of_test_before);\n+    public void constructor_is_called_for_each_test_in_test_class() throws Exception {\n+        // given\n+        JUnitCore jUnitCore = new JUnitCore();\n+        jUnitCore.addListener(new TextListener(System.out));\n+\n+        // when\n+        jUnitCore.run(junit_test_with_3_tests_methods.class);\n+\n+        // then\n+        assertThat(junit_test_with_3_tests_methods.constructor_instantiation).isEqualTo(3);\n     }\n \n     @Test\n             MockitoAnnotations.initMocks(new ATest());\n             fail();\n         } catch (MockitoException e) {\n-            Assertions.assertThat(e.getMessage()).contains(\"failingConstructor\").contains(\"constructor\").contains(\"threw an exception\");\n-            Assertions.assertThat(e.getCause()).isInstanceOf(IllegalStateException.class);\n+            assertThat(e.getMessage()).contains(\"failingConstructor\").contains(\"constructor\").contains(\"threw an exception\");\n+            assertThat(e.getCause()).isInstanceOf(IllegalStateException.class);\n         }\n     }\n \n-    private static int articleVisitorInstantiationCount = 0;\n-    private static Set<Object> articleVisitorMockInjectedInstances = new HashSet<Object>();\n \n-    private static class ArticleVisitor {\n-        public ArticleVisitor(ArticleCalculator calculator) {\n-            articleVisitorInstantiationCount++;\n-            articleVisitorMockInjectedInstances.add(calculator);\n+    @RunWith(MockitoJUnitRunner.class)\n+    public static class junit_test_with_3_tests_methods {\n+        private static int constructor_instantiation = 0;\n+\n+        @Mock List some_collaborator;\n+        @InjectMocks some_class_with_parametered_constructor should_be_initialized_3_times;\n+\n+        @Test public void test_1() { }\n+        @Test public void test_2() { }\n+        @Test public void test_3() { }\n+\n+        private static class some_class_with_parametered_constructor {\n+            public some_class_with_parametered_constructor(List collaborator) {\n+                constructor_instantiation++;\n+            }\n         }\n     }\n \n--- /dev/null\n+++ b/test/org/mockitousage/basicapi/MocksSerializationForAnnotationTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+\n+package org.mockitousage.basicapi;\n+\n+import static org.mockito.Matchers.anyObject;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+import static org.mockito.Mockito.inOrder;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.Mockito.withSettings;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Observable;\n+\n+import org.fest.assertions.Assertions;\n+import org.junit.Test;\n+import org.mockito.InOrder;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.matchers.Any;\n+import org.mockito.internal.stubbing.answers.ThrowsException;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+@SuppressWarnings({\"unchecked\", \"serial\"})\n+public class MocksSerializationForAnnotationTest extends TestBase implements Serializable {\n+\n+    private static final long serialVersionUID = 6160482220413048624L;\n+\n+    @Mock Any any;\n+    @Mock(serializable=true) Bar barMock;\n+    @Mock(serializable=true) IMethods imethodsMock;\n+    @Mock(serializable=true) IMethods imethodsMock2;\n+    @Mock(serializable=true) Any anyMock;\n+    @Mock(serializable=true) AlreadySerializable alreadySerializableMock;\n+    @Mock(extraInterfaces={List.class},serializable=true) IMethods imethodsWithExtraInterfacesMock;\n+    \n+    @Test\n+    public void should_allow_throws_exception_to_be_serializable() throws Exception {\n+        // given\n+        when(barMock.doSomething()).thenAnswer(new ThrowsException(new RuntimeException()));\n+\n+        //when-serialize then-deserialize\n+        serializeAndBack(barMock);\n+    }\n+    \n+    @Test\n+    public void should_allow_mock_to_be_serializable() throws Exception {\n+        // when-serialize then-deserialize\n+        serializeAndBack(imethodsMock);\n+    }\n+\n+    @Test\n+    public void should_allow_mock_and_boolean_value_to_serializable() throws Exception {\n+        // given\n+        when(imethodsMock.booleanReturningMethod()).thenReturn(true);\n+\n+        // when\n+        ByteArrayOutputStream serialized = serializeMock(imethodsMock);\n+\n+        // then\n+        IMethods readObject = deserializeMock(serialized, IMethods.class);\n+        assertTrue(readObject.booleanReturningMethod());\n+    }\n+\n+    @Test\n+    public void should_allow_mock_and_string_value_to_be_serializable() throws Exception {\n+        // given\n+        String value = \"value\";\n+        when(imethodsMock.stringReturningMethod()).thenReturn(value);\n+\n+        // when\n+        ByteArrayOutputStream serialized = serializeMock(imethodsMock);\n+\n+        // then\n+        IMethods readObject = deserializeMock(serialized, IMethods.class);\n+        assertEquals(value, readObject.stringReturningMethod());\n+    }\n+\n+    @Test\n+    public void should_all_mock_and_serializable_value_to_be_serialized() throws Exception {\n+        // given\n+        List<?> value = Collections.emptyList();\n+        when(imethodsMock.objectReturningMethodNoArgs()).thenReturn(value);\n+\n+        // when\n+        ByteArrayOutputStream serialized = serializeMock(imethodsMock);\n+\n+        // then\n+        IMethods readObject = deserializeMock(serialized, IMethods.class);\n+        assertEquals(value, readObject.objectReturningMethodNoArgs());\n+    }\n+\n+    @Test\n+    public void should_serialize_method_call_with_parameters_that_are_serializable() throws Exception {\n+        List<?> value = Collections.emptyList();\n+        when(imethodsMock.objectArgMethod(value)).thenReturn(value);\n+\n+        // when\n+        ByteArrayOutputStream serialized = serializeMock(imethodsMock);\n+\n+        // then\n+        IMethods readObject = deserializeMock(serialized, IMethods.class);\n+        assertEquals(value, readObject.objectArgMethod(value));\n+    }\n+\n+    @Test\n+    public void should_serialize_method_calls_using_any_string_matcher() throws Exception {\n+        List<?> value = Collections.emptyList();\n+        when(imethodsMock.objectArgMethod(anyString())).thenReturn(value);\n+\n+        // when\n+        ByteArrayOutputStream serialized = serializeMock(imethodsMock);\n+\n+        // then\n+        IMethods readObject = deserializeMock(serialized, IMethods.class);\n+        assertEquals(value, readObject.objectArgMethod(\"\"));\n+    }\n+\n+    @Test\n+    public void should_verify_called_n_times_for_serialized_mock() throws Exception {\n+        List<?> value = Collections.emptyList();\n+        when(imethodsMock.objectArgMethod(anyString())).thenReturn(value);\n+        imethodsMock.objectArgMethod(\"\");\n+\n+        // when\n+        ByteArrayOutputStream serialized = serializeMock(imethodsMock);\n+\n+        // then\n+        IMethods readObject = deserializeMock(serialized, IMethods.class);\n+        verify(readObject, times(1)).objectArgMethod(\"\");\n+    }\n+\n+    @Test\n+    public void should_verify_even_if_some_methods_called_after_serialization() throws Exception {\n+\n+        // when\n+    \timethodsMock.simpleMethod(1);\n+        ByteArrayOutputStream serialized = serializeMock(imethodsMock);\n+        IMethods readObject = deserializeMock(serialized, IMethods.class);\n+        readObject.simpleMethod(1);\n+\n+        // then\n+        verify(readObject, times(2)).simpleMethod(1);\n+\n+        //this test is working because it seems that java serialization mechanism replaces all instances\n+        //of serialized object in the object graph (if there are any)\n+    }\n+\n+    class Bar implements Serializable {\n+        Foo foo;\n+\n+        public Foo doSomething() {\n+            return foo;\n+        }\n+    }\n+\n+    class Foo implements Serializable {\n+        Bar bar;\n+        Foo() {\n+            bar = new Bar();\n+            bar.foo = this;\n+        }\n+    }\n+\n+    @Test\n+    public void should_serialization_work() throws Exception {\n+        //given\n+        Foo foo = new Foo();\n+        //when\n+        foo = serializeAndBack(foo);\n+        //then\n+        assertSame(foo, foo.bar.foo);\n+    }\n+\n+    @Test\n+    public void should_stub_even_if_some_methods_called_after_serialization() throws Exception {\n+        //given\n+        // when\n+        when(imethodsMock.simpleMethod(1)).thenReturn(\"foo\");\n+        ByteArrayOutputStream serialized = serializeMock(imethodsMock);\n+        IMethods readObject = deserializeMock(serialized, IMethods.class);\n+        when(readObject.simpleMethod(2)).thenReturn(\"bar\");\n+\n+        // then\n+        assertEquals(\"foo\", readObject.simpleMethod(1));\n+        assertEquals(\"bar\", readObject.simpleMethod(2));\n+    }\n+\n+    @Test\n+    public void should_verify_call_order_for_serialized_mock() throws Exception {\n+        imethodsMock.arrayReturningMethod();\n+        imethodsMock2.arrayReturningMethod();\n+\n+        // when\n+        ByteArrayOutputStream serialized = serializeMock(imethodsMock);\n+        ByteArrayOutputStream serialized2 = serializeMock(imethodsMock2);\n+\n+        // then\n+        IMethods readObject = deserializeMock(serialized, IMethods.class);\n+        IMethods readObject2 = deserializeMock(serialized2, IMethods.class);\n+        InOrder inOrder = inOrder(readObject, readObject2);\n+        inOrder.verify(readObject).arrayReturningMethod();\n+        inOrder.verify(readObject2).arrayReturningMethod();\n+    }\n+\n+    @Test\n+    public void should_remember_interactions_for_serialized_mock() throws Exception {\n+        List<?> value = Collections.emptyList();\n+        when(imethodsMock.objectArgMethod(anyString())).thenReturn(value);\n+        imethodsMock.objectArgMethod(\"happened\");\n+\n+        // when\n+        ByteArrayOutputStream serialized = serializeMock(imethodsMock);\n+\n+        // then\n+        IMethods readObject = deserializeMock(serialized, IMethods.class);\n+        verify(readObject, never()).objectArgMethod(\"never happened\");\n+    }\n+\n+    @Test\n+    public void should_serialize_with_stubbing_callback() throws Exception {\n+\n+        // given\n+        CustomAnswersMustImplementSerializableForSerializationToWork answer = \n+            new CustomAnswersMustImplementSerializableForSerializationToWork();\n+        answer.string = \"return value\";\n+        when(imethodsMock.objectArgMethod(anyString())).thenAnswer(answer);\n+\n+        // when\n+        ByteArrayOutputStream serialized = serializeMock(imethodsMock);\n+\n+        // then\n+        IMethods readObject = deserializeMock(serialized, IMethods.class);\n+        assertEquals(answer.string, readObject.objectArgMethod(\"\"));\n+    }\n+\n+    class CustomAnswersMustImplementSerializableForSerializationToWork \n+        implements Answer<Object>, Serializable {\n+        private String string;\n+        public Object answer(InvocationOnMock invocation) throws Throwable {\n+            invocation.getArguments();\n+            invocation.getMock();\n+            return string;\n+        }\n+    }\n+    \n+    public void should_serialize_with_real_object_spy() throws Exception {\n+        // given\n+        List<Object> list = new ArrayList<Object>();\n+        List<Object> spy = mock(ArrayList.class, withSettings()\n+                        .spiedInstance(list)\n+                        .defaultAnswer(CALLS_REAL_METHODS)\n+                        .serializable());\n+        when(spy.size()).thenReturn(100);\n+\n+        // when\n+        ByteArrayOutputStream serialized = serializeMock(spy);\n+\n+        // then\n+        List<?> readObject = deserializeMock(serialized, List.class);\n+        assertEquals(100, readObject.size());\n+    }\n+\n+    @Test\n+    public void should_serialize_object_mock() throws Exception {\n+        // when\n+        ByteArrayOutputStream serialized = serializeMock(any);\n+\n+        // then\n+        deserializeMock(serialized, Any.class);\n+    }\n+    \n+    @Test\n+    public void should_serialize_real_partial_mock() throws Exception {\n+        // given\n+        when(anyMock.matches(anyObject())).thenCallRealMethod();\n+\n+        // when\n+        ByteArrayOutputStream serialized = serializeMock(anyMock);\n+\n+        // then\n+        Any readObject = deserializeMock(serialized, Any.class);\n+        readObject.matches(\"\");\n+    }\n+\n+    class AlreadySerializable implements Serializable {}\n+\n+    @Test\n+    public void should_serialize_already_serializable_class() throws Exception {\n+        // given\n+        when(alreadySerializableMock.toString()).thenReturn(\"foo\");\n+\n+        // when\n+        alreadySerializableMock = serializeAndBack(alreadySerializableMock);\n+\n+        // then\n+        assertEquals(\"foo\", alreadySerializableMock.toString());\n+    }\n+    \n+    @Test\n+    public void should_be_serialize_and_have_extra_interfaces() throws Exception {\n+        //then\n+        serializeAndBack((List) imethodsWithExtraInterfacesMock);\n+    }\n+    \n+    public static class FailTestClass{\n+    \t@Mock(serializable=true) Observable observable;\n+    }\n+    \n+    @Test\n+    public void should_fail_when_serializable_used_with_object_that_dont_implements_Serializable() throws Exception {\n+        try {\n+        \tMockitoAnnotations.initMocks(new FailTestClass());\n+            fail();\n+        } catch (MockitoException e) {\n+            Assertions.assertThat(e.getMessage()).contains(Observable.class.getSimpleName()).contains(\"serializable()\").contains(\"implement Serializable\");\n+        }\n+    }\n+}\n--- a/test/org/mockitousage/matchers/CapturingArgumentsTest.java\n+++ b/test/org/mockitousage/matchers/CapturingArgumentsTest.java\n \n     @SuppressWarnings(\"deprecation\")\n     @Test\n-    public void shouldAllowAssertionsOnCapturedArgument() {\n+    public void should_allow_assertions_on_captured_argument() {\n         //when\n         emailer.email(12);\n         \n     }\n     \n     @Test\n-    public void shouldAllowAssertionsOnAllCapturedArguments() {\n+    public void should_allow_assertions_on_all_captured_arguments() {\n         //when\n         emailer.email(11, 12);\n         \n     }\n     \n     @Test\n-    public void shouldAllowAssertionsOnLastArgument() {\n+    public void should_allow_assertions_on_last_argument() {\n         //when\n         emailer.email(11, 12, 13);\n         \n     }\n     \n     @Test\n-    public void shouldPrintCaptorMatcher() {\n+    public void should_print_captor_matcher() {\n         //given\n         ArgumentCaptor<Person> person = ArgumentCaptor.forClass(Person.class);\n         \n     }\n     \n     @Test\n-    public void shouldAllowAssertionsOnCapturedNull() {\n+    public void should_allow_assertions_on_captured_null() {\n         //when\n         emailService.sendEmailTo(null);\n         \n     }\n     \n     @Test\n-    public void shouldAllowCapturingForStubbing() {\n+    public void should_allow_capturing_for_stubbing() {\n         //given\n         ArgumentCaptor<Person> argument = ArgumentCaptor.forClass(Person.class);\n         when(emailService.sendEmailTo(argument.capture())).thenReturn(false);\n     }\n     \n     @Test\n-    public void shouldCaptureWhenStubbingOnlyWhenEntireInvocationMatches() {\n+    public void should_capture_when_stubbing_only_when_entire_invocation_matches() {\n         //given\n         ArgumentCaptor<String> argument = ArgumentCaptor.forClass(String.class);\n         when(mock.simpleMethod(argument.capture(), eq(2))).thenReturn(\"blah\");\n     }\n     \n     @Test\n-    public void shouldSaySomethingSmartWhenMisused() {\n+    public void should_say_something_smart_when_misused() {\n         ArgumentCaptor<Person> argument = ArgumentCaptor.forClass(Person.class);\n         try {\n             argument.getValue();\n     }\n     \n     @Test\n-    public void shouldCaptureWhenFullArgListMatches() throws Exception {\n+    public void should_capture_when_full_arg_list_matches() throws Exception {\n         //given\n         mock.simpleMethod(\"foo\", 1);\n         mock.simpleMethod(\"bar\", 2);\n     }\n     \n     @Test\n-    public void shouldCaptureIntByCreatingCaptorWithPrimitiveWrapper() {\n+    public void should_capture_int_by_creating_captor_with_primitive_wrapper() {\n         //given\n         IMethods mock = mock(IMethods.class);\n         ArgumentCaptor<Integer> argument = ArgumentCaptor.forClass(Integer.class);\n     }\n \n     @Test\n-    public void shouldCaptureIntByCreatingCaptorWithPrimitive() throws Exception {\n+    public void should_capture_int_by_creating_captor_with_primitive() throws Exception {\n         //given\n         IMethods mock = mock(IMethods.class);\n         ArgumentCaptor<Integer> argument = ArgumentCaptor.forClass(int.class);\n         verify(mock).intArgumentMethod(argument.capture());\n         assertEquals(10, (int) argument.getValue());\n     }\n+\n+    @Test\n+    public void should_capture_byte_vararg_by_creating_captor_with_primitive() throws Exception {\n+        // given\n+        IMethods mock = mock(IMethods.class);\n+        ArgumentCaptor<Byte> argumentCaptor = ArgumentCaptor.forClass(byte.class);\n+\n+        // when\n+        mock.varargsbyte((byte) 1, (byte) 2);\n+\n+        // then\n+        verify(mock).varargsbyte(argumentCaptor.captureVararg());\n+        Assertions.assertThat(argumentCaptor.getVarargsValues()).containsExactly((byte) 1, (byte) 2);\n+    }\n+\n+    @Test\n+    public void should_capture_byte_vararg_by_creating_captor_with_primitive_wrapper() throws Exception {\n+        // given\n+        IMethods mock = mock(IMethods.class);\n+        ArgumentCaptor<Byte> argumentCaptor = ArgumentCaptor.forClass(Byte.class);\n+\n+        // when\n+        mock.varargsbyte((byte) 1, (byte) 2);\n+\n+        // then\n+        verify(mock).varargsbyte(argumentCaptor.captureVararg());\n+        Assertions.assertThat(argumentCaptor.getVarargsValues()).containsExactly((byte) 1, (byte) 2);\n+    }\n+\n+    @Test\n+    public void should_capture_vararg() throws Exception {\n+        // given\n+        IMethods mock = mock(IMethods.class);\n+        ArgumentCaptor<String> argumentCaptor = ArgumentCaptor.forClass(String.class);\n+\n+        // when\n+        mock.mixedVarargs(42, \"a\", \"b\", \"c\");\n+\n+        // then\n+        verify(mock).mixedVarargs(any(), argumentCaptor.captureVararg());\n+        Assertions.assertThat(argumentCaptor.getVarargsValues()).containsExactly(\"a\", \"b\", \"c\");\n+    }\n+\n+    @Test\n+    public void should_capture_all_vararg() throws Exception {\n+        // given\n+        IMethods mock = mock(IMethods.class);\n+        ArgumentCaptor<String> argumentCaptor = ArgumentCaptor.forClass(String.class);\n+\n+        // when\n+        mock.mixedVarargs(42, \"a\", \"b\", \"c\");\n+        mock.mixedVarargs(42, \"again ?!\");\n+\n+        // then\n+        verify(mock, times(2)).mixedVarargs(any(), argumentCaptor.captureVararg());\n+        List<List<String>> allVarargsValues = argumentCaptor.getAllVarargsValues();\n+        Assertions.assertThat(allVarargsValues.get(0)).containsExactly(\"a\", \"b\", \"c\");\n+        Assertions.assertThat(allVarargsValues.get(1)).containsExactly(\"again ?!\");\n+    }\n+\n+    @Test\n+    public void should_capture_one_arg_even_when_using_vararg_captor_on_nonvararg_method() throws Exception {\n+        // given\n+        IMethods mock = mock(IMethods.class);\n+        ArgumentCaptor<String> argumentCaptor = ArgumentCaptor.forClass(String.class);\n+\n+        // when\n+        mock.simpleMethod(\"a\", 2);\n+\n+        // then\n+        verify(mock).simpleMethod(argumentCaptor.captureVararg(), eq(2));\n+        Assertions.assertThat(argumentCaptor.getVarargsValues()).containsExactly(\"a\");\n+    }\n+\n+\n+    @Test\n+    public void can_capture_vararg_using_standard_capturing_API() throws Exception {\n+        // given\n+        IMethods mock = mock(IMethods.class);\n+        ArgumentCaptor<String> argumentCaptor = ArgumentCaptor.forClass(String.class);\n+\n+        // when\n+        mock.mixedVarargs(42, \"a\", \"b\", \"c\");\n+\n+        // then\n+        verify(mock).mixedVarargs(any(), argumentCaptor.capture(), argumentCaptor.capture(), argumentCaptor.capture());\n+        Assertions.assertThat(argumentCaptor.getAllValues()).containsExactly(\"a\", \"b\", \"c\");\n+    }\n }", "timestamp": 1351194598, "metainfo": ""}