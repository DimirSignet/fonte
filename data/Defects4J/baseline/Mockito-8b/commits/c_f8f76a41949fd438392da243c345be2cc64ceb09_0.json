{"sha": "f8f76a41949fd438392da243c345be2cc64ceb09", "log": "Fix for Issue 229 : Changed the way the MockitoAnnotations and InjectingAnnotationEngine work, might need some polish regarding support", "commit": "\n--- a/src/org/mockito/MockitoAnnotations.java\n+++ b/src/org/mockito/MockitoAnnotations.java\n         if (testClass == null) {\n             throw new MockitoException(\"testClass cannot be null. For info how to use @Mock annotations see examples in javadoc for MockitoAnnotations class\");\n         }\n-        \n+\n+        AnnotationEngine annotationEngine = new GlobalConfiguration().getAnnotationEngine();\n         Class<?> clazz = testClass.getClass();\n-        while (clazz != Object.class) {\n-            scan(testClass, clazz);\n-            clazz = clazz.getSuperclass();\n+\n+        //below can be removed later, when we get rid of deprecated stuff\n+        if (annotationEngine.getClass() != new DefaultMockitoConfiguration().getAnnotationEngine().getClass()) {\n+            //this means user has his own annotation engine and we have to respect that.\n+            //we will do annotation processing the old way so that we are backwards compatible\n+            while (clazz != Object.class) {\n+                scanDeprecatedWay(annotationEngine, testClass, clazz);\n+                clazz = clazz.getSuperclass();\n+            }\n         }\n+\n+        //anyway act 'the new' way\n+        annotationEngine.process(testClass.getClass(), testClass);\n     }\n \n-    static void scan(Object testClass, Class<?> clazz) {\n-        AnnotationEngine annotationEngine = new GlobalConfiguration().getAnnotationEngine();\n+    static void scanDeprecatedWay(AnnotationEngine annotationEngine, Object testClass, Class<?> clazz) {\n         Field[] fields = clazz.getDeclaredFields();\n+\n         for (Field field : fields) {\n-            //below can be removed later, when we get rid of deprecated stuff\n-            if (annotationEngine.getClass() != new DefaultMockitoConfiguration().getAnnotationEngine().getClass()) {\n-                //this means user has his own annotation engine and we have to respect that.\n-                //we will do annotation processing the old way so that we are backwards compatible\n-                processAnnotationDeprecatedWay(annotationEngine, testClass, field);                \n-            } \n+            processAnnotationDeprecatedWay(annotationEngine, testClass, field);\n         }\n-        //act 'the new' way\n-        annotationEngine.process(clazz, testClass);\n     }\n \n     @SuppressWarnings(\"deprecation\")\n--- a/src/org/mockito/configuration/AnnotationEngine.java\n+++ b/src/org/mockito/configuration/AnnotationEngine.java\n  */\n package org.mockito.configuration;\n \n+import org.mockito.MockitoAnnotations;\n+\n import java.lang.annotation.Annotation;\n import java.lang.reflect.Field;\n-\n-import org.mockito.MockitoAnnotations;\n \n /**\n  * Configures mock creation logic behind &#064;Mock, &#064;Captor and &#064;Spy annotations\n \n     /**\n      * @deprecated\n-     * Please use AnnotationProcessor 'execute' method instead that is more robust\n+     * Please use {@link AnnotationEngine#process(Class, Object)} method instead that is more robust\n      * <p>\n      * Creates mock, ArgumentCaptor or wraps field instance in spy object.\n      * Only if of correct annotation type.\n      *\n-     * @param annotation\n-     * @param field\n+     * @param annotation Annotation\n+     * @param field Field details\n      */\n     @Deprecated\n     Object createMockFor(Annotation annotation, Field field);\n \n     /**\n-     * Allows extending the interface to perform action on specific fields on the test class\n+     * Allows extending the interface to perform action on specific fields on the test class.\n      * <p>\n-     * See the implementation of this method to figure out what is it for\n+     * See the implementation of this method to figure out what is it for.\n      * \n-     * @param context\n-     * @param testClass \n+     * @param clazz Class where to extract field information, check implementation for details\n+     * @param testInstance Test instance\n      */\n-    void process(Class<?> context, Object testClass);\n+    void process(Class<?> clazz, Object testInstance);\n }\n--- a/src/org/mockito/internal/configuration/DefaultAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/DefaultAnnotationEngine.java\n  */\n package org.mockito.internal.configuration;\n \n-import java.lang.annotation.Annotation;\n-import java.lang.reflect.Field;\n-\n-import org.mockito.ArgumentCaptor;\n-import org.mockito.Captor;\n-import org.mockito.Mock;\n-import org.mockito.MockSettings;\n-import org.mockito.Mockito;\n-import org.mockito.MockitoAnnotations;\n+import org.mockito.*;\n import org.mockito.configuration.AnnotationEngine;\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.util.reflection.FieldSetter;\n import org.mockito.internal.util.reflection.GenericMaster;\n \n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+\n /**\n  * Initializes fields annotated with &#64;{@link org.mockito.Mock} or &#64;{@link org.mockito.Captor}.\n- * <p/>\n- * See {@link MockitoAnnotations}\n+ *\n+ * <p>\n+ * The {@link #process(Class, Object)} method implementation <strong>does not</strong> process super classes!\n+ *\n+ * @see {@link MockitoAnnotations}\n  */\n @SuppressWarnings(\"unchecked\")\n public class DefaultAnnotationEngine implements AnnotationEngine {\n         return ArgumentCaptor.forClass(cls);    \n     }           \n \n-    public void process(Class<?> clazz, Object testClass) {\n+    public void process(Class<?> clazz, Object testInstance) {\n         Field[] fields = clazz.getDeclaredFields();\n         for (Field field : fields) {\n             boolean alreadyAssigned = false;\n                     throwIfAlreadyAssigned(field, alreadyAssigned);                    \n                     alreadyAssigned = true;                    \n                     try {\n-                        new FieldSetter(testClass, field).set(mock);\n+                        new FieldSetter(testInstance, field).set(mock);\n                     } catch (Exception e) {\n                         throw new MockitoException(\"Problems setting field \" + field.getName() + \" annotated with \"\n                                 + annotation, e);\n--- a/src/org/mockito/internal/configuration/InjectingAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/InjectingAnnotationEngine.java\n     \n     AnnotationEngine delegate = new DefaultAnnotationEngine();\n     AnnotationEngine spyAnnotationEngine = new SpyAnnotationEngine();\n-    \n-    /* (non-Javadoc)\n-    * @see org.mockito.AnnotationEngine#createMockFor(java.lang.annotation.Annotation, java.lang.reflect.Field)\n-    */    \n+\n+    /***\n+     * Create a mock using {@link DefaultAnnotationEngine}\n+     *\n+     * @see org.mockito.internal.configuration.DefaultAnnotationEngine\n+     * @see org.mockito.configuration.AnnotationEngine#createMockFor(java.lang.annotation.Annotation, java.lang.reflect.Field)\n+     */\n+    @Deprecated\n     public Object createMockFor(Annotation annotation, Field field) {\n         return delegate.createMockFor(annotation, field);\n     }\n-    \n-    public void process(Class<?> context, Object testClass) {\n-        //this will create @Mocks, @Captors, etc:\n-        delegate.process(context, testClass);\n-        //this will create @Spies:\n-        spyAnnotationEngine.process(context, testClass);\n-        \n-        //this injects mocks\n-        Field[] fields = context.getDeclaredFields();\n-        for (Field field : fields) {\n-            if (field.isAnnotationPresent(InjectMocks.class)) {\n-                assertNoAnnotations(field, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);\n-                injectMocks(testClass);\n+\n+    /**\n+     * Process the fields of the test instance and create Mocks, Spies, Captors and inject them on fields\n+     * annotated &#64;InjectMocks.\n+     *\n+     * <p>\n+     * This code process the test class and the super classes.\n+     * <ol>\n+     * <li>First create Mocks, Spies, Captors.</li>\n+     * <li>Then try to inject them.</li>\n+     * </ol>\n+     *\n+     * @param clazz Not used\n+     * @param testInstance The instance of the test, should not be null.\n+     *\n+     * @see org.mockito.configuration.AnnotationEngine#process(Class, Object)\n+     */\n+    public void process(Class<?> clazz, Object testInstance) {\n+        processIndependentAnnotations(testInstance.getClass(), testInstance);\n+        processInjectMocks(testInstance.getClass(), testInstance);\n+    }\n+\n+    private void processInjectMocks(final Class<?> clazz, final Object testInstance) {\n+        Class<?> classContext = clazz;\n+        while (classContext != Object.class) {\n+            //this injects mocks\n+            Field[] fields = classContext.getDeclaredFields();\n+            for (Field field : fields) {\n+                if (field.isAnnotationPresent(InjectMocks.class)) {\n+                    assertNoAnnotations(field, Mock.class, MockitoAnnotations.Mock.class, Captor.class);\n+                    injectMocks(testInstance);\n+                }\n             }\n+            classContext = classContext.getSuperclass();\n         }\n-    } \n-    \n-    void assertNoAnnotations(Field field, Class ... annotations) {\n+    }\n+\n+    private void processIndependentAnnotations(final Class<?> clazz, final Object testInstance) {\n+        Class<?> classContext = clazz;\n+        while (classContext != Object.class) {\n+            //this will create @Mocks, @Captors, etc:\n+            delegate.process(classContext, testInstance);\n+            //this will create @Spies:\n+            spyAnnotationEngine.process(classContext, testInstance);\n+\n+            classContext = classContext.getSuperclass();\n+        }\n+    }\n+\n+    void assertNoAnnotations(final Field field, final Class ... annotations) {\n         for (Class annotation : annotations) {\n             if (field.isAnnotationPresent(annotation)) {\n                 new Reporter().unsupportedCombinationOfAnnotations(annotation.getSimpleName(), InjectMocks.class.getSimpleName());\n      * @param testClass\n      *            Test class, usually <code>this</code>\n      */\n-    public void injectMocks(Object testClass) {       \n+    public void injectMocks(final Object testClass) {\n         Class<?> clazz = testClass.getClass();\n         Set<Field> mockDependents = new HashSet<Field>();\n         Set<Object> mocks = new HashSet<Object>();\n      * @param clazz\n      * @return\n      */\n-    private static Set<Field> scanForInjection(Object testClass, Class<?> clazz) {\n+    private static Set<Field> scanForInjection(final Object testClass, final Class<?> clazz) {\n         Set<Field> testedFields = new HashSet<Field>();\n         Field[] fields = clazz.getDeclaredFields();\n         for (Field field : fields) {\n         return testedFields;\n     }\n \n-    private static Set<Object> scanMocks(Object testClass, Class<?> clazz) {\n+    private static Set<Object> scanMocks(final Object testClass, final Class<?> clazz) {\n         Set<Object> mocks = new HashSet<Object>();\n         for (Field field : clazz.getDeclaredFields()) {\n             // mock or spies only\n--- a/src/org/mockito/internal/configuration/SpyAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/SpyAnnotationEngine.java\n     }\n     \n     @SuppressWarnings(\"deprecation\")\n-    public void process(Class<?> context, Object testClass) {\n+    public void process(Class<?> context, Object testInstance) {\n         Field[] fields = context.getDeclaredFields();\n         for (Field field : fields) {\n             if (field.isAnnotationPresent(Spy.class)) {\n                 assertNoAnnotations(Spy.class, field, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);\n                 Object instance = null;\n                 try {\n-                    instance = new FieldInitializer(testClass, field).initialize();\n+                    instance = new FieldInitializer(testInstance, field).initialize();\n                 } catch (MockitoException e) {\n                     new Reporter().cannotInitializeForSpyAnnotation(field.getName(), e);\n                 }\n                         Mockito.reset(instance);\n                     } else {\n                         field.setAccessible(true);\n-                        field.set(testClass, Mockito.mock(instance.getClass(), withSettings()\n+                        field.set(testInstance, Mockito.mock(instance.getClass(), withSettings()\n                                 .spiedInstance(instance)\n                                 .defaultAnswer(Mockito.CALLS_REAL_METHODS)\n                                 .name(field.getName())));\n--- /dev/null\n+++ b/test/org/mockitousage/bugs/ParentTestMockInjectionTest.java\n+package org.mockitousage.bugs;\n+\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+import static org.junit.Assert.assertNotNull;\n+\n+// issue 229 : @Mock fields in super test class are not injected on @InjectMocks fields\n+public class ParentTestMockInjectionTest {\n+\n+    @Test\n+    public void injectMocksShouldInjectMocksFromTestSuperClasses() {\n+        ImplicitTest it = new ImplicitTest();\n+        MockitoAnnotations.initMocks(it);\n+\n+        assertNotNull(it.daoFromParent);\n+        assertNotNull(it.daoFromSub);\n+        assertNotNull(it.sut.daoFromParent);\n+        assertNotNull(it.sut.daoFromSub);\n+    }\n+\n+\n+    @Ignore\n+    public abstract class BaseTest {\n+        @Mock protected DaoA daoFromParent;\n+    }\n+\n+    public class ImplicitTest extends BaseTest {\n+        @InjectMocks private SystemUnderTest sut = new SystemUnderTest();\n+\n+        @Mock private DaoB daoFromSub;\n+\n+        @Before\n+        public void setup() {\n+            MockitoAnnotations.initMocks(this);\n+        }\n+\n+        @Test\n+        public void noNullPointerException() {\n+            sut.businessMethod();\n+        }\n+    }\n+\n+    public class SystemUnderTest {\n+        private DaoA daoFromParent;\n+        private DaoB daoFromSub;\n+\n+        public void businessMethod() {\n+            daoFromParent.doQuery();\n+            daoFromSub.doQuery();\n+        }\n+    }\n+\n+\n+    public class DaoA {\n+        public void doQuery() { }\n+    }\n+\n+    public class DaoB {\n+        public void doQuery() { }\n+    }\n+\n+}", "timestamp": 1289398360, "metainfo": ""}