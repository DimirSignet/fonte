{"sha": "581d8f80b010636f38bc7c9f6a593167441f082b", "log": "Laying out better ground for generic type resolver  --HG-- branch : issue230", "commit": "\n--- a/src/org/mockito/internal/util/ConsoleMockitoLogger.java\n+++ b/src/org/mockito/internal/util/ConsoleMockitoLogger.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal.util;\n \n public class ConsoleMockitoLogger implements MockitoLogger {\n      * @see org.mockito.internal.util.Logger#print(java.lang.Object)\n      */\n     public void log(Object what) {\n-        System.out.print(what);\n+        System.out.println(what);\n     }\n }\n--- a/src/org/mockito/internal/util/reflection/GenericMaster.java\n+++ b/src/org/mockito/internal/util/reflection/GenericMaster.java\n package org.mockito.internal.util.reflection;\n \n import java.lang.reflect.*;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n \n @SuppressWarnings(\"unchecked\")\n public class GenericMaster {\n         return Object.class;\n     }\n \n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    /////////////////////////////\n+    /////////////////////////////\n+    ////////// O  L  D //////////\n+    /////////////////////////////\n+    /////////////////////////////\n+\n+\n+\n+\n+    /**\n+     * Identify the returned generic type value of the given method from the given class.\n+     *\n+     * @param method Method whose generic part of the returned type must be identified.\n+     * @param onClass Owner class from which the resolution of generic type value must be identified.\n+     * @return Generic type value if found, <code>null</code> otherwise.\n+     */\n     public Class<?> identifyGenericReturnType(Method method, Class<?> onClass) {\n         Type genericReturnType = method.getGenericReturnType();\n \n+        // if method has return type like List<Number>\n         if (genericReturnType instanceof ParameterizedType) {\n             ParameterizedType parameterizedType = (ParameterizedType) genericReturnType;\n \n-            if (parameterizedType.getActualTypeArguments().length > 0) {\n-                Type type = parameterizedType.getActualTypeArguments()[0];\n+            // number of type argument of List for example\n+            if (parameterizedType.getActualTypeArguments().length <= 0) {\n+                return null; // not supported yet, see #getActualTypeArguments javadoc\n+            }\n+            Type type = parameterizedType.getActualTypeArguments()[0];\n \n-                if (type instanceof Class) {\n-                    return (Class) type;\n-                }\n-                if (type instanceof TypeVariable) {\n-                    return identifyReturnTypeFromClass((TypeVariable) type, onClass);\n-                }\n+            // if type argument is a simple class, for example Number in List<Number>\n+            if (type instanceof Class) {\n+                return (Class) type;\n             }\n+            if (type instanceof TypeVariable) {\n+                throw new IllegalStateException();\n+//                return identifyReturnTypeFromClass((TypeVariable) type, onClass);\n+            }\n+            if (type instanceof ParameterizedType) {\n+                throw new IllegalStateException();\n+//                ParameterizedType subParameterizedType = (ParameterizedType) type;\n+//                return (Class<?>) subParameterizedType.getRawType();\n+            }\n+            return null;\n+        }\n \n-        }\n+//        if (genericReturnType instanceof TypeVariable) {\n+//            TypeVariable typeVariable = (TypeVariable) genericReturnType;\n+//            return identifyReturnTypeFromClass(typeVariable, onClass);\n+//        }\n \n         return null;\n     }\n \n     private Class<?> identifyReturnTypeFromClass(TypeVariable typeVariable, Class<?> onClass) {\n-        Type[] genericInterfaces = onClass.getGenericInterfaces();\n+        List<Type> genericInterfaces = new ArrayList<Type>(Arrays.asList(onClass.getGenericInterfaces()));\n+        genericInterfaces.add(onClass.getGenericSuperclass());\n \n         for (Type genericInterface : genericInterfaces) {\n \n                             if (typeVariableValue instanceof Class) {\n                                 return (Class) typeVariableValue;\n                             }\n+\n+                            if (typeVariableValue instanceof TypeVariable) {\n+                                TypeVariable variableValue = (TypeVariable) typeVariableValue;\n+\n+                                throw new IllegalStateException(\"type var :\" + variableValue);\n+                            }\n+\n+//                            if (typeVariableValue instanceof ParameterizedType) {\n+//                                return (Class<?>) ((ParameterizedType) typeVariableValue).getRawType();\n+//                            }\n                         }\n                     }\n                 }\n--- /dev/null\n+++ b/src/org/mockito/internal/util/reflection/GenericTypeInfo.java\n+package org.mockito.internal.util.reflection;\n+\n+import org.mockito.Incubating;\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.util.Checks;\n+import org.mockito.internal.util.ConsoleMockitoLogger;\n+import org.mockito.internal.util.MockitoLogger;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Allow easy access to generic type information\n+ *\n+ * TODO refactor with polymorphism in mind?\n+ */\n+@Incubating\n+public class GenericTypeInfo {\n+\n+    public static MockitoLogger logger = new ConsoleMockitoLogger();\n+\n+    /**\n+     * This is the type that we wish to get more generic information.\n+     */\n+    private final Type typeToSolve;\n+\n+    /**\n+     * The source class from which the generic info information should be retrieved.\n+     */\n+    private final Class<?> onClass;\n+\n+    /**\n+     * Represents resolved type variables on class.\n+     */\n+    private Map<TypeVariable, Type> typeVariables = new HashMap<TypeVariable, Type>();\n+\n+\n+    private GenericTypeInfo(Type typeToSolve, Class<?> onClass, Map<TypeVariable, Type> typeVariables) {\n+        this.typeToSolve = typeToSolve;\n+        this.onClass = onClass;\n+        this.typeVariables = typeVariables;\n+        readActualTypeParametersOnDeclaringClass();\n+    }\n+\n+    /**\n+     * Returns actual type as a raw type.\n+     * @return Raw type\n+     */\n+    public Class<?> asRawType() {\n+        return extractRawTypeOf(typeToSolve);\n+    }\n+\n+    private Class<?> extractRawTypeOf(Type type) {\n+        if (type instanceof Class) {\n+            return (Class<?>) type;\n+        }\n+        if (type instanceof ParameterizedType) {\n+            return (Class<?>) ((ParameterizedType) type).getRawType();\n+        }\n+        if (type instanceof TypeVariableUpperBounds) {\n+            return extractRawTypeOf(((TypeVariableUpperBounds) type).firstBound());\n+        }\n+        if (type instanceof TypeVariable) {\n+            /*\n+            If type is a TypeVariable, then it is needed to gather data elsewhere. Usually TypeVariables are declared\n+            on the class definition, such as such as List<E>.\n+            */\n+            return extractRawTypeOf(typeVariables.get(type));\n+        }\n+        throw new MockitoException(\"Raw extraction not managed for : '\" + type + \"'\");\n+    }\n+\n+    /**\n+     * Return the type of the type to solve.\n+     *\n+     * <p>Different than raw type extraction as it can extract actual type instead of TypeVariable</p>.\n+     *\n+     * TODO Eventually create our own ParameterizedType, with resolved TypeVariables\n+     *\n+     * @return The actual type\n+     */\n+    private Type actualType() {\n+        return extractActualTypeOf(typeToSolve);\n+    }\n+\n+    private Type extractActualTypeOf(Type type) {\n+        if (type instanceof TypeVariableUpperBounds) {\n+            return extractActualTypeOf(((TypeVariableUpperBounds) type).firstBound());\n+        }\n+        if (type instanceof TypeVariable) {\n+            /*\n+            If type is a TypeVariable, then it is needed to gather data elsewhere. Usually TypeVariables are declared\n+            on the class definition, such as such as List<E>.\n+            */\n+            return extractActualTypeOf(typeVariables.get(type));\n+        }\n+        return type; // irrelevant, we don't manage other types.\n+    }\n+\n+    private void readActualTypeParametersOnDeclaringClass() {\n+        registerTypeVariablesOn(onClass);\n+        registerTypeVariablesOn(onClass.getGenericSuperclass());\n+        for (Type genericInterface : onClass.getGenericInterfaces()) {\n+            registerTypeVariablesOn(genericInterface);\n+        }\n+    }\n+\n+    private void registerTypeVariablesOn(Type classType) {\n+        if (!(classType instanceof ParameterizedType)) {\n+            return;\n+        }\n+        ParameterizedType parameterizedType = (ParameterizedType) classType;\n+        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n+        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n+        for (int i = 0; i < actualTypeArguments.length; i++) {\n+            Type actualTypeArgument = actualTypeArguments[i];\n+            TypeVariable typeParameter = typeParameters[i];\n+\n+            typeVariables.put(typeParameter, actualTypeArgument);\n+            logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(in '\" + typeParameter.getGenericDeclaration() + \"')\" + \"' : '\" + actualTypeArgument + \"' }\");\n+        }\n+    }\n+\n+    private void registerTypeVariablesOn(Class<?> clazz) {\n+        TypeVariable[] typeParameters = clazz.getTypeParameters();\n+        for (TypeVariable typeParameter : typeParameters) {\n+            typeVariables.put(typeParameter, boundsOf(typeParameter));\n+            logger.log(\"For '\" + clazz.getCanonicalName() + \"' found type variable : { '\" + typeParameter + \"(in '\" + typeParameter.getGenericDeclaration() + \"')\" + \"' : '\" + boundsOf(typeParameter) + \"' }\");\n+        }\n+    }\n+\n+    private Type boundsOf(TypeVariable typeParameter) {\n+        return new TypeVariableUpperBounds(typeParameter.getBounds());\n+    }\n+\n+\n+    @Override\n+    public String toString() {\n+        final StringBuilder sb = new StringBuilder();\n+        sb.append(actualType());\n+        sb.append(' ').append(typeVariables);\n+        return sb.toString();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+\n+        GenericTypeInfo that = (GenericTypeInfo) o;\n+\n+        return !(onClass != null ? !onClass.equals(that.onClass) : that.onClass != null) && typeToSolve.equals(that.typeToSolve);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result = typeToSolve.hashCode();\n+        result = 31 * result + (onClass != null ? onClass.hashCode() : 0);\n+        return result;\n+    }\n+\n+\n+    /**\n+     * Type representing bounds of a type variable, allows to keep all bounds information.\n+     *\n+     * <p>It uses the first bound in the array, as this array is never null and always contains at least\n+     * one element (Object is always here if no bounds are declared).</p>\n+     *\n+     * <p>If upper bounds are declared with SomeClass and additional interfaces, then firstBound will be SomeClass and\n+     * interfacesBound will be an array of the additional interfaces.\n+     *\n+     * i.e. <code>SomeClass</code>.\n+     * <pre class=\"code\"><code class=\"java\">\n+     *     interface UpperBoundedTypeWithClass<E extends Comparable<E> & Cloneable> {\n+     *         E get();\n+     *     }\n+     *     // will return Comparable type\n+     * </code></pre>\n+     * </p>\n+     */\n+    public static class TypeVariableUpperBounds implements Type {\n+        private final Type firstBound;\n+        private final Type[] interfaceBounds;\n+\n+\n+        public TypeVariableUpperBounds(Type[] bounds) {\n+            this.firstBound = bounds[0]; // either a class or an interface, always present\n+            this.interfaceBounds = new Type[bounds.length - 1]; // JLS says only interfaces from here\n+            System.arraycopy(bounds, 1, interfaceBounds, 0, bounds.length - 1);\n+        }\n+\n+        public Type firstBound() {\n+            return firstBound;\n+        }\n+\n+        public Type[] interfaceBounds() {\n+            return interfaceBounds;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final StringBuilder sb = new StringBuilder();\n+            sb.append(\"{firstBound=\").append(firstBound);\n+            sb.append(\", interfaceBounds=\").append(Arrays.deepToString(interfaceBounds));\n+            sb.append('}');\n+            return sb.toString();\n+        }\n+    }\n+\n+\n+\n+    @Incubating\n+    public static Builder on(Class<?> clazz) {\n+        Checks.checkNotNull(clazz, \"clazz\");\n+        return new Builder().onClass(clazz);\n+    }\n+\n+    @Incubating\n+    public static Builder on(GenericTypeInfo genericTypeInfo) {\n+        Checks.checkNotNull(genericTypeInfo, \"genericTypeInfo\");\n+        return new Builder().onClass(genericTypeInfo.asRawType())\n+                .withTypeVariables(genericTypeInfo.typeVariables);\n+    }\n+\n+\n+\n+\n+    @Incubating\n+    public static class Builder {\n+\n+        private Class<?> clazz;\n+        private Method method;\n+        private Map<TypeVariable, Type> typeVariables = new HashMap<TypeVariable, Type>();\n+\n+\n+        public Builder onClass(Class<?> clazz) {\n+            this.clazz = clazz;\n+            return this;\n+        }\n+\n+        public Builder method(Method method) {\n+            Checks.checkNotNull(method, \"method\");\n+            this.method = method;\n+            return this;\n+        }\n+\n+        public Builder methodName(String methodName) {\n+            Checks.checkNotNull(methodName, \"methodName\");\n+            this.method = pickFirstMatchingMethod(methodName, clazz);\n+            return this;\n+        }\n+\n+        private Method pickFirstMatchingMethod(String methodName, Class<?> clazz) {\n+            for (Method method : clazz.getMethods()) {\n+                if (method.getName().contains(methodName)) {\n+                    return method;\n+                }\n+            }\n+            throw new IllegalStateException(\"The method : '\" + methodName + \"' do not exist in '\" + clazz.getSimpleName() + \"'\");\n+        }\n+\n+        private Builder withTypeVariables(Map<TypeVariable, Type> typeVariables) {\n+            this.typeVariables = typeVariables;\n+            return this;\n+        }\n+\n+        public GenericTypeInfo genericReturnTypeInfo() {\n+            Type genericReturnType = method.getGenericReturnType();\n+            return new GenericTypeInfo(genericReturnType, clazz, typeVariables);\n+        }\n+    }\n+\n+\n+}\n--- a/test/org/mockito/internal/util/reflection/GenericMasterTest.java\n+++ b/test/org/mockito/internal/util/reflection/GenericMasterTest.java\n  */\n package org.mockito.internal.util.reflection;\n \n-import static org.junit.Assert.*;\n+import org.junit.Ignore;\n+import org.junit.Test;\n \n import java.lang.reflect.Field;\n import java.lang.reflect.Method;\n-import java.util.Collection;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n+import java.lang.reflect.Type;\n+import java.util.*;\n \n-import org.junit.Test;\n+import static org.junit.Assert.assertEquals;\n \n public class GenericMasterTest {\n     \n     List<Set<Collection<String>>> multiNested;\n \n     public interface ListSet extends List<Set> {}\n+    public interface MapNumberString extends Map<Number, String> {}\n+    public class HashMapNumberString<K extends Number> extends HashMap<K, String> {}\n \n     public List<Number> numberList() { return null; }\n     public Comparable<Number> numberComparable() { return null; }\n     public List rawList() { return null; }\n+    public List<? extends Type> typeList() { return null; }\n \n \n \n     }\n \n     @Test\n-    public void can_identify_generic_type_of_returned_type_when_owner_forces_generic_type() throws Exception {\n+    public void can_identify_generic_type_of_returned_type_when_owner_type_forces_generic_type() throws Exception {\n         assertEquals(Set.class, m.identifyGenericReturnType(method(ListSet.class, \"iterator\"), ListSet.class));\n+        assertEquals(Number.class, m.identifyGenericReturnType(method(MapNumberString.class, \"keySet\"), MapNumberString.class));\n+        assertEquals(String.class, m.identifyGenericReturnType(method(MapNumberString.class, \"values\"), MapNumberString.class));\n+        assertEquals(String.class, m.identifyGenericReturnType(method(MapNumberString.class, \"remove\"), MapNumberString.class));\n+        assertEquals(Map.Entry.class, m.identifyGenericReturnType(method(MapNumberString.class, \"entrySet\"), MapNumberString.class));\n+    }\n+\n+    @Test\n+    public void can_identify_type_variable_upper_bound() throws Exception {\n+        assertEquals(Number.class, m.identifyGenericReturnType(method(HashMapNumberString.class, \"keySet\"), HashMapNumberString.class));\n+        assertEquals(Type.class, m.identifyGenericReturnType(method(\"typeList\"), this.getClass()));\n+    }\n+\n+    @Test\n+    @Ignore(\"Internal API not ready for nested generics, doesn't work\")\n+    public void can_identify_nested_generic_type_of_returned_type_when_owner_forces_generic_type() throws Exception {\n     }\n \n     @Test\n     }\n \n     private Method method(Class<?> clazz, String noArgMethod) throws NoSuchMethodException {\n-        return clazz.getMethod(noArgMethod);\n+        for (Method method : clazz.getMethods()) {\n+            if (method.getName().contains(noArgMethod)) {\n+                return method;\n+            }\n+        }\n+        throw new NoSuchMethodException(\"method \" + noArgMethod + \" do not exist in \" + clazz.getSimpleName());\n     }\n \n     private Field field(String fieldName) throws SecurityException, NoSuchFieldException {\n--- /dev/null\n+++ b/test/org/mockito/internal/util/reflection/GenericTypeInfoTest.java\n+package org.mockito.internal.util.reflection;\n+\n+import org.junit.Test;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import static org.mockito.internal.util.reflection.GenericTypeInfo.on;\n+\n+public class GenericTypeInfoTest {\n+\n+    interface UpperBoundedTypeWithClass<E extends Number & Comparable<E>> {\n+        E get();\n+    }\n+    interface UpperBoundedTypeWithInterfaces<E extends Comparable<E> & Cloneable> {\n+        E get();\n+    }\n+    interface ListOfNumbers extends List<Number> {}\n+    interface ListOfAnyNumbers<N extends Number & Cloneable> extends List<N> {}\n+\n+    @Test\n+    public void can_get_raw_type_on_simple_return_type() throws Exception {\n+        assertThat(on(List.class).methodName(\"iterator\").genericReturnTypeInfo().asRawType()).isEqualTo(Iterator.class);\n+        assertThat(on(List.class).methodName(\"size\").genericReturnTypeInfo().asRawType()).isEqualTo(int.class);\n+        assertThat(on(Number.class).methodName(\"toString\").genericReturnTypeInfo().asRawType()).isEqualTo(String.class);\n+    }\n+\n+    @Test\n+    public void can_get_raw_type_of_parameterized_return_type() throws Exception {\n+        assertThat(on(List.class).methodName(\"get\").genericReturnTypeInfo().asRawType()).isEqualTo(Object.class);\n+    }\n+\n+    @Test\n+    public void can_get_raw_type_of_parameterized_return_type_with_upper_bounded_type_variable() throws Exception {\n+        assertThat(on(UpperBoundedTypeWithInterfaces.class).methodName(\"get\").genericReturnTypeInfo().asRawType()).isEqualTo(Comparable.class);\n+        assertThat(on(UpperBoundedTypeWithClass.class).methodName(\"get\").genericReturnTypeInfo().asRawType()).isEqualTo(Number.class);\n+    }\n+\n+    @Test\n+    public void can_get_raw_type_of_parameterized_return_type_with_fixed_type_argument() throws Exception {\n+        assertThat(on(ListOfNumbers.class).methodName(\"get\").genericReturnTypeInfo().asRawType()).isEqualTo(Number.class);\n+    }\n+\n+    @Test\n+    public void can_get_raw_type_of_parameterized_return_type_with_bounded_type_parameter() throws Exception {\n+        assertThat(on(ListOfAnyNumbers.class).methodName(\"get\").genericReturnTypeInfo().asRawType()).isEqualTo(Number.class);\n+    }\n+\n+    interface MapWithNestedGenerics<K extends Comparable<K> & Cloneable & Set<Number>> extends Map<K, Set<Number>> {}\n+\n+\n+    @Test\n+    public void test() throws Exception {\n+        GenericTypeInfo entrySetGenericTypeInfo = on(MapWithNestedGenerics.class).methodName(\"entrySet\").genericReturnTypeInfo();\n+        System.out.println(entrySetGenericTypeInfo); // Set<Entry<K extends Comparable<K>, Set<Number>>\n+//        entrySetGenericTypeInfo.asRawType(); // Set\n+//        entrySetGenericTypeInfo.getTypeVariables(); // { 'K' : 'K extends Comparable<K>' , 'V' : 'Set<Number' }\n+        System.out.println(\"======================================================\");\n+\n+        GenericTypeInfo iteratorGenericTypeInfo = on(entrySetGenericTypeInfo).methodName(\"iterator\").genericReturnTypeInfo();\n+        System.out.println(iteratorGenericTypeInfo);\n+    }\n+\n+}", "timestamp": 1342794561, "metainfo": ""}