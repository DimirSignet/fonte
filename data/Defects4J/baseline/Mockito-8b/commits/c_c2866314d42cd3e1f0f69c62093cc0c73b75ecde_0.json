{"sha": "c2866314d42cd3e1f0f69c62093cc0c73b75ecde", "log": "Added method to handle thrown exceptions in invocation. Added stubbing location and return value / exception to the listener methods signature.  --HG-- branch : issue148 extra : transplant_source : RbY%AD%B0%CAy%87%BF%BD%11%BD%40%EDO%05%DA%87%FD.", "commit": "\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n     }\n \n     public Object handle(Invocation invocation) throws Throwable {\n-    \tnotifyAllInvocationListener(invocation);\n-    \t\n-        if (invocationContainerImpl.hasAnswersForStubbing()) {\n+    \ttry {\n+    \t\tObject returnValue = handleAllTypesOfInvocations(invocation);\n+    \t\tnotifyAllListenerOfInvocationWithReturnValue(invocation, returnValue);\n+    \t\treturn returnValue;\n+    \t} catch(Exception e) {\n+    \t\tnotifyAllListenerOfInvocationWithException(invocation, e);\n+    \t\tthrow e;\n+    \t}\n+    }\n+\n+\tprivate Object handleAllTypesOfInvocations(Invocation invocation)\n+\t\t\tthrows Throwable {\n+\t\tif (invocationContainerImpl.hasAnswersForStubbing()) {\n             // stubbing voids with stubVoid() or doAnswer() style\n             InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                             .getArgumentMatcherStorage(), invocation);\n             invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n             return ret;\n         }\n-    }\n+\t}\n \n     public VoidMethodStubbable<T> voidMethodStubbable(T mock) {\n         return new VoidMethodStubbableImpl<T>(mock, invocationContainerImpl);\n         return invocationContainerImpl;\n     }\n     \n-\tprivate void notifyAllInvocationListener(Invocation invocation) {\n+\tprivate void notifyAllListenerOfInvocationWithReturnValue(Invocation invocation, Object returnValue) {\n \t\tfor (InvocationListener listener : mockSettings.getInvocationListener()) {\n-\t\t\tnotifyInvocationListener(invocation, listener);\n+\t\t\tnotifyListenerOfInvocationWithReturnValue(invocation, returnValue, listener);\n     \t} \n \t}\n \n-\tprivate void notifyInvocationListener(Invocation invocation, InvocationListener listener) {\n+\tprivate void notifyAllListenerOfInvocationWithException(Invocation invocation, Exception exception) {\n+\t\tfor (InvocationListener listener : mockSettings.getInvocationListener()) {\n+\t\t\tnotifyListenerOfInvocationWithException(invocation, exception, listener);\n+\t\t} \n+\t}\n+\t\n+\tprivate void notifyListenerOfInvocationWithReturnValue(Invocation invocation, Object returnValue, InvocationListener listener) {\n \t\ttry {\n-\t\tlistener.invoking(invocation);\n+\t\t\tlistener.invokingWithReturnValue(invocation, returnValue, getStubbingLocationOrNull(invocation));\n \t\t} catch(RuntimeException e) {\n \t\t\tthrow new MockitoException(StringJoiner.join(\"An invocation listener threw an exception.\",\n-\t\t\t\t\t\"The listener has the class \" + listener.getClass().getName()),e);\n+\t\t\t\t\t\"The listener has the class \" + listener.getClass().getName()), e);\n \t\t}\n \t}\n+\t\n+\tprivate void notifyListenerOfInvocationWithException(Invocation invocation, Exception exception, InvocationListener listener) {\n+\t\ttry {\n+\t\t\tlistener.invokingWithException(invocation, exception, getStubbingLocationOrNull(invocation));\n+\t\t} catch(RuntimeException e) {\n+\t\t\tthrow new MockitoException(StringJoiner.join(\"An invocation listener threw an exception.\",\n+\t\t\t\t\t\"The listener has the class \" + listener.getClass().getName()), e);\n+\t\t}\n+\t}\n+\n+\tprivate String getStubbingLocationOrNull(Invocation invocation) {\n+\t\treturn (invocation.stubInfo() == null) ? null : invocation.stubInfo().stubbedAt();\n+\t}\n }\n--- a/src/org/mockito/internal/debugging/LogInvocationsToStdOutListener.java\n+++ b/src/org/mockito/internal/debugging/LogInvocationsToStdOutListener.java\n \n import java.io.PrintStream;\n \n+import org.mockito.exceptions.PrintableInvocation;\n import org.mockito.invocation.InvocationListener;\n-import org.mockito.invocation.InvocationOnMock;\n \n /**\n  * Logs all invocations to standard output.\n public class LogInvocationsToStdOutListener implements InvocationListener {\n \n \tPrintStream printStream = System.out;\n+\tint ctrOfInteractions = 0;\n \t\n-\tpublic void invoking(InvocationOnMock invocation) {\n+\tpublic void invokingWithReturnValue(PrintableInvocation invocation, Object returnValue, String locationOfStubbing) {\n+\t\tprintHeader();\n+\t\tprintCommonInfos(invocation);\n+\t\tprintlnIndented(\"Will return: >\" + returnValue + \"<\" + ((returnValue == null) ? \"\" : \" (\" + returnValue.getClass().getName() + \")\"));\n+\t\tif (locationOfStubbing == null) {\n+\t\t\tprintMethodHasNotBeenStubbed();\n+\t\t} else {\n+\t\t\tprintMethodHasBeenStubbed(locationOfStubbing);\n+\t\t}\n+\t\tprintFooter();\n+\t}\n+\n+\tpublic void invokingWithException(PrintableInvocation invocation, Exception exception, String locationOfStubbing) {\n+\t\tprintHeader();\n+\t\tprintCommonInfos(invocation);\n+\t\tprintlnIndented(\"Will throw: \" + exception);\n+\t\tif (locationOfStubbing == null) {\n+\t\t\tprintMethodHasNotBeenStubbed();\n+\t\t} else {\n+\t\t\tprintMethodHasBeenStubbed(locationOfStubbing);\n+\t\t}\n+\t\tprintFooter();\n+\t}\n+\n+\tprivate void printHeader() {\n+\t\tctrOfInteractions++;\n+\t\tprintStream.println(\"############ Logging method invocation #\" + ctrOfInteractions + \" on mock/spy ########\");\n+\t}\n+\t\n+\tprivate void printMethodHasNotBeenStubbed() {\n+\t\tprintlnIndented(\"Method has not been stubbed.\");\n+\t}\n+\n+\tprivate void printMethodHasBeenStubbed(String locationOfStubbing) {\n+\t\tprintlnIndented(\"Method has been stubbed.\");\n+\t\tprintlnIndented(locationOfStubbing);\n+\t}\n+\n+\tprivate void printCommonInfos(PrintableInvocation invocation) {\n \t\tprintStream.println(invocation.toString());\n+//\t\tprintStream.println(\"Handling method call on a mock/spy.\");\n+\t\tprintlnIndented(invocation.getLocation().toString());\n \t}\n+\n+\tprivate void printFooter() {\n+\t\tprintStream.println(\"###########################################################\");\n+\t}\n+\t\n+\tprivate void printlnIndented(String message) {\n+\t\tprintStream.println(\"   \" + message);\n+\t}\n+\t\n }\n--- a/src/org/mockito/invocation/InvocationListener.java\n+++ b/src/org/mockito/invocation/InvocationListener.java\n package org.mockito.invocation;\n \n import org.mockito.MockSettings;\n+import org.mockito.exceptions.PrintableInvocation;\n \n /**\n  * This listener can be notified of method invocations on a mock.\n \t * \n \t * Exceptions during this callback are treated as fatal errors. \n \t * \n+\t * TODO update documentation to parameters\n+\t * \n \t * @param invocation information on the happening method call, never {@code null}.\n \t * @throws RuntimeException on fatal errors\n \t */\n-\tvoid invoking(InvocationOnMock invocation);\n+\tvoid invokingWithReturnValue(PrintableInvocation invocation, Object returnValue, String locationOfStubbing);\n+\t\n+\tvoid invokingWithException(PrintableInvocation invocation, Exception exception, String locationOfStubbing);\n+\n }\n--- a/test/org/mockito/internal/MockHandlerTest.java\n+++ b/test/org/mockito/internal/MockHandlerTest.java\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.MatchersBinder;\n+import org.mockito.internal.invocation.StubInfo;\n import org.mockito.internal.progress.ArgumentMatcherStorage;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.stubbing.InvocationContainerImpl;\n import org.mockito.internal.verification.MockAwareVerificationMode;\n import org.mockito.internal.verification.VerificationModeFactory;\n import org.mockito.invocation.InvocationListener;\n+import org.mockito.invocation.InvocationOnMock;\n import org.mockito.stubbing.Answer;\n import org.mockito.verification.VerificationMode;\n import org.mockitoutil.TestBase;\n @SuppressWarnings({\"unchecked\",\"serial\"})\n public class MockHandlerTest extends TestBase {\n     \n+\tprivate static final String SOME_RETURN_VALUE = \"some return value\";\n+\tprivate static final String SOME_LOCATION = \"some location\";\n \t@SuppressWarnings(\"rawtypes\")\n \tprivate static final Answer SOME_ANSWER = mock(Answer.class);\n-\tprivate static final StubbedInvocationMatcher SOME_RETURN_VALUE = mock(StubbedInvocationMatcher.class);\n+\tprivate static final StubbedInvocationMatcher SOME_INVOCATION_MATCHER = mock(StubbedInvocationMatcher.class);\n \tprivate static final Invocation SOME_INVOCATION = mock(Invocation.class);\n \t@Mock private InvocationListener listener1;\n \t@Mock private InvocationListener listener2;\n         \n         assertNull(handler.mockingProgress.pullVerificationMode());\n     }\n+\t\n+\t// TODO test exception\n+\t// TODO listener are not notified of error \n     \n     @Test\n     public void shouldNotifyInvocationHandlerDuringStubVoid() throws Throwable {\n     \t// given\n     \tMockHandler<?> handler = createHandlerWithListeners(listener1, listener2);\n     \tstubWithInvocationDuringStubVoid(handler);\n-    \t\n-    \t\n-    \thandler.handle(SOME_INVOCATION);\n+    \tInvocation invocation = createInvocationWithStubbingLocation(SOME_LOCATION);\n+    \t\n+    \t\n+\t\thandler.handle(invocation);\n     \t\n     \t// then\n-    \tverify(listener1).invoking(SOME_INVOCATION);\n-    \tverify(listener2).invoking(SOME_INVOCATION);\n-    }\n+    \tverify(listener1).invokingWithReturnValue(invocation, null, SOME_LOCATION);\n+    \tverify(listener2).invokingWithReturnValue(invocation, null, SOME_LOCATION);\n+    }\n+\n+\tprivate Invocation createInvocationWithStubbingLocation(String stubbingLocation) {\n+\t\tInvocation invocation = mock(Invocation.class);\n+\t\t\n+\t\tStubInfo stubInfo = mock(StubInfo.class);\n+\t\tgiven(invocation.stubInfo()).willReturn(stubInfo);\n+\t\t\n+\t\tgiven(stubInfo.stubbedAt()).willReturn(stubbingLocation);\n+\t\t\n+\t\treturn invocation;\n+\t}\n \n \t@Test\n     public void shouldNotifyInvocationHandlerDuringVerification() throws Throwable {\n     \t// given\n     \tMockHandler<?> handler = createHandlerWithListeners(listener1, listener2);\n     \tstubProgressWithVerification(handler);\n+    \tInvocation invocation = createInvocationWithStubbingLocation(SOME_LOCATION);\n     \t\n     \t// when\n-\t\thandler.handle(SOME_INVOCATION);\n+\t\thandler.handle(invocation);\n     \t\n     \t// then\n-    \tverify(listener1).invoking(SOME_INVOCATION);\n-    \tverify(listener2).invoking(SOME_INVOCATION);\n+    \tverify(listener1).invokingWithReturnValue(invocation, null, SOME_LOCATION);\n+    \tverify(listener2).invokingWithReturnValue(invocation, null, SOME_LOCATION);\n     }\n     \n \t@Test\n     public void shouldNotifyInvocationHandlerDuringOrdinaryInvocationWithGivenReturnValue() throws Throwable {\n     \t// given\n     \tMockHandler<?> handler = createHandlerWithListeners(listener1, listener2);\n-    \tstubOrdinaryInvocationWithGivenReturnValue(handler);\n+    \tstubOrdinaryInvocationWithReturnValue(handler, SOME_RETURN_VALUE);\n+    \tInvocation invocation = createInvocationWithStubbingLocation(SOME_LOCATION);\n     \t\n     \t// when\n-\t\thandler.handle(SOME_INVOCATION);\n+\t\thandler.handle(invocation);\n     \t\n     \t// then\n-    \tverify(listener1).invoking(SOME_INVOCATION);\n-    \tverify(listener2).invoking(SOME_INVOCATION);\n+    \tverify(listener1).invokingWithReturnValue(invocation, SOME_RETURN_VALUE, SOME_LOCATION);\n+    \tverify(listener2).invokingWithReturnValue(invocation, SOME_RETURN_VALUE, SOME_LOCATION);\n     }\n \n \t@Test\n \t\t// given\n \t\tMockHandler<?> handler = createHandlerWithListeners(listener1, listener2);\n \t\tstubOrdinaryInvocationWithDefaultReturnValue(handler);\n+    \tInvocation invocation = createInvocationWithStubbingLocation(SOME_LOCATION);\n \t\t\n \t\t// when\n-\t\thandler.handle(SOME_INVOCATION);\n+\t\thandler.handle(invocation);\n \t\t\n \t\t// then\n-\t\tverify(listener1).invoking(SOME_INVOCATION);\n-\t\tverify(listener2).invoking(SOME_INVOCATION);\n+\t\tverify(listener1).invokingWithReturnValue(invocation, null, SOME_LOCATION);\n+\t\tverify(listener2).invokingWithReturnValue(invocation, null, SOME_LOCATION);\n \t}\n \t\n \t@Test(expected=MockitoException.class)\n     public void shouldThrowMockitoExceptionWhenInvocationHandlerThrowsAnything() throws Throwable {\n     \t// given\n \t\tInvocationListener throwingListener = mock(InvocationListener.class);\n-\t\tdoThrow(new RuntimeException()).when(throwingListener).invoking(SOME_INVOCATION);\n+\t\tdoThrow(new RuntimeException()).when(throwingListener).invokingWithReturnValue(any(Invocation.class), any(String.class), any(String.class));\n     \tMockHandler<?> handler = createCorrectlyStubbedHandler(throwingListener);\n     \t\n     \t// when\n \t}\n \n \tprivate void stubOrdinaryInvocationWithGivenReturnValue(MockHandler<?> handler) {\n-\t\tstubOrdinaryInvocationWithReturnValue(handler, SOME_RETURN_VALUE);\n+\t\tstubOrdinaryInvocationWithInvocationMatcher(handler, SOME_INVOCATION_MATCHER);\n+\t}\n+\t\n+\tprivate void stubOrdinaryInvocationWithReturnValue(MockHandler<?> handler, Object returnValue) throws Throwable {\n+\t\tStubbedInvocationMatcher matcher = mock(StubbedInvocationMatcher.class);\n+\t\tgiven(matcher.answer(any(InvocationOnMock.class))).willReturn(returnValue);\n+\t\tstubOrdinaryInvocationWithInvocationMatcher(handler, matcher);\n \t}\n \t\n \tprivate void stubOrdinaryInvocationWithDefaultReturnValue(MockHandler<?> handler) {\n \t\tgiven(handler.getMockSettings().getDefaultAnswer()).willReturn(SOME_ANSWER);\n-\t\tstubOrdinaryInvocationWithReturnValue(handler, null);\n-\t}\n-\n-\tprivate void stubOrdinaryInvocationWithReturnValue(MockHandler<?> handler,\n+\t\tstubOrdinaryInvocationWithInvocationMatcher(handler, null);\n+\t}\n+\n+\tprivate void stubOrdinaryInvocationWithInvocationMatcher(MockHandler<?> handler,\n \t\t\tStubbedInvocationMatcher value) {\n \t\thandler.invocationContainerImpl = mock(InvocationContainerImpl.class);\n \t\tgiven(handler.invocationContainerImpl.findAnswerFor(any(Invocation.class))).willReturn(value);\n--- a/test/org/mockito/internal/debugging/LogInvocationsToStdOutListenerTest.java\n+++ b/test/org/mockito/internal/debugging/LogInvocationsToStdOutListenerTest.java\n  */\n package org.mockito.internal.debugging;\n \n-import static org.mockito.Mockito.*;\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Mockito.atLeastOnce;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n \n-import java.io.*;\n+import java.io.PrintStream;\n \n-import org.junit.*;\n-import org.mockito.invocation.*;\n-import org.mockitoutil.*;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.exceptions.PrintableInvocation;\n+import org.mockitoutil.TestBase;\n \n public class LogInvocationsToStdOutListenerTest extends TestBase {\n \n-    private static final InvocationOnMock SOME_INVOCATION = mock(InvocationOnMock.class);\n+\tprivate static final String OTHER_LOCATION = \"other location\";\n+\tprivate static final String LOCATION_OF_STUBBING = \"location of stubbing\";\n+\tprivate static final String SOME_RETURN_VALUE = \"some return value\";\n+\tprivate static final Exception SOME_EXCEPTION = new ThirdPartyException();\n \n \t@Test\n-    public void presetStreamIsStdOut() {\n-    \tassertSame(System.out, new LogInvocationsToStdOutListener().printStream);\n-    }\n-    \n+\tpublic void shouldPrintToStdOut() {\n+\t\tassertSame(System.out, new LogInvocationsToStdOutListener().printStream);\n+\t}\n+\n \t@Test\n-\tpublic void shouldPrintInvocationToStream() {\n-\t\t//given\n+\tpublic void shouldPrintInvocationWithReturnValueToStream() {\n+\t\t// given\n+\t\tLogInvocationsToStdOutListener listener = createListenerWithMockedStream();\n+\t\tPrintableInvocation invocation = createInvocationWithLocation();\n+\n+\t\t// when\n+\t\tlistener.invokingWithReturnValue(invocation, SOME_RETURN_VALUE,\n+\t\t\t\tLOCATION_OF_STUBBING);\n+\n+\t\t// then\n+\t\tassertIsPrinted(invocation.toString(), listener);\n+\t\tassertIsPrinted(invocation.getLocation().toString(), listener);\n+\t\tassertIsPrinted(SOME_RETURN_VALUE, listener);\n+\t\tassertIsPrinted(LOCATION_OF_STUBBING, listener);\n+\t}\n+\n+\t@Test\n+\tpublic void shouldPrintInvocationWithExceptionToStream() {\n+\t\t// given\n+\t\tLogInvocationsToStdOutListener listener = createListenerWithMockedStream();\n+\t\tPrintableInvocation invocation = createInvocationWithLocation();\n+\n+\t\t// when\n+\t\tlistener.invokingWithException(invocation, SOME_EXCEPTION,\n+\t\t\t\tLOCATION_OF_STUBBING);\n+\n+\t\t// then\n+\t\tassertIsPrinted(invocation.toString(), listener);\n+\t\tassertIsPrinted(invocation.getLocation().toString(), listener);\n+\t\tassertIsPrinted(SOME_EXCEPTION.getClass().getName(), listener);\n+\t\tassertIsPrinted(LOCATION_OF_STUBBING, listener);\n+\t}\n+\n+\t@Test\n+\tpublic void shouldLogNumberOfInteractions() {\n+\t\t// given\n+\t\tLogInvocationsToStdOutListener listener = createListenerWithMockedStream();\n+\t\t// when & then\n+\t\tlistener.invokingWithException(createInvocationWithLocation(), SOME_EXCEPTION, LOCATION_OF_STUBBING);\n+\t\tassertIsPrinted(\"#1\", listener);\n+\t\t\n+\t\tlistener.invokingWithException(createInvocationWithLocation(), SOME_EXCEPTION, OTHER_LOCATION);\n+\t\tassertIsPrinted(\"#2\", listener);\n+\t\t\n+\t\tlistener.invokingWithException(createInvocationWithLocation(), SOME_EXCEPTION, LOCATION_OF_STUBBING);\n+\t\tassertIsPrinted(\"#3\", listener);\n+\t}\n+\t\n+\tprivate PrintableInvocation createInvocationWithLocation() {\n+\t\tPrintableInvocation invocation = mock(PrintableInvocation.class);\n+\t\tLocation location = mock(Location.class);\n+\t\tgiven(invocation.getLocation()).willReturn(location);\n+\t\treturn invocation;\n+\t}\n+\n+\tprivate void assertIsPrinted(String printedString,\n+\t\t\tLogInvocationsToStdOutListener listener) {\n+\t\tassertContains(printedString, getEverythingThatWasPrinted(listener));\n+\t}\n+\n+\tprivate String getEverythingThatWasPrinted(\n+\t\t\tLogInvocationsToStdOutListener listener) {\n+\t\tArgumentCaptor<String> captor = ArgumentCaptor.forClass(String.class);\n+\t\tverify(listener.printStream, atLeastOnce()).println(captor.capture());\n+\t\tStringBuffer concatenatedArgs = new StringBuffer();\n+\t\tfor (String arg : captor.getAllValues()) {\n+\t\t\tconcatenatedArgs.append(arg).append(\"\\n\");\n+\t\t}\n+\t\treturn concatenatedArgs.toString();\n+\t}\n+\n+\tprivate LogInvocationsToStdOutListener createListenerWithMockedStream() {\n \t\tLogInvocationsToStdOutListener listener = new LogInvocationsToStdOutListener();\n \t\tlistener.printStream = mock(PrintStream.class);\n-\t\t\n-\t\t//when\n-\t\tlistener.invoking(SOME_INVOCATION);\n-\t\n-\t    //then\n-\t\tverify(listener.printStream).println(SOME_INVOCATION.toString());\n+\t\treturn listener;\n \t}\n-    \n-    \n+\n+\tprivate static class ThirdPartyException extends Exception {\n+\t\tprivate static final long serialVersionUID = 3022739107688491354L;\n+\t}\n }\n--- a/test/org/mockitousage/debugging/InvocationListenerCallbackTest.java\n+++ b/test/org/mockitousage/debugging/InvocationListenerCallbackTest.java\n  */\n package org.mockitousage.debugging;\n \n-import static org.mockito.Matchers.*;\n-import static org.mockito.Mockito.*;\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Matchers.contains;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Matchers.isA;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.withSettings;\n \n-import org.junit.*;\n-import org.mockito.*;\n-import org.mockito.internal.invocation.*;\n-import org.mockito.invocation.*;\n-import org.mockitoutil.*;\n+import org.junit.Test;\n+import org.mockito.exceptions.PrintableInvocation;\n+import org.mockito.invocation.InvocationListener;\n+import org.mockitousage.debugging.VerboseLoggingOfInvocationsOnMockTest.ThirdPartyException;\n+import org.mockitoutil.TestBase;\n \n /**\n- * Ensures that custom listeners can be registered and will be called every\n- * time a method on a mock is invoked.\n+ * Ensures that custom listeners can be registered and will be called every time\n+ * a method on a mock is invoked.\n  */\n public class InvocationListenerCallbackTest extends TestBase {\n \n-    private static final String SOME_STRING_ARGUMENT = \"some string argument\";\n+\tprivate static final String SOME_RETURN_VALUE = \"some return value\";\n+\tprivate static final String SOME_STRING_ARGUMENT = \"some string argument\";\n \n \t@Test\n-    public void shouldCallListenerWithCorrectCallback() throws Exception {\n-    \t// given\n-    \tInvocationListener listener = mock(InvocationListener.class);\n+\tpublic void givenInvocationReturningValue_shouldCallSingleListenerWithCorrectCallback() throws Exception {\n+\t\t// given\n+\t\tInvocationListener listener = mock(InvocationListener.class);\n \t\tFoo foo = mock(Foo.class, withSettings().callback(listener));\n-    \t\n-    \t// when\n-\t\tfoo.doSomething(SOME_STRING_ARGUMENT);\n-    \t\n-    \t// then\n-\t\tArgumentCaptor<InvocationOnMock> captor = ArgumentCaptor.forClass(InvocationOnMock.class);\n-\t\tverify(listener).invoking(captor.capture());\n-\t\tassertSame(foo, captor.getValue().getMock());\n-\t\tassertEquals(Foo.class.getMethod(\"doSomething\", String.class), captor.getValue().getMethod());\n-    }\n-\t\n+\t\tgiven(foo.giveMeSomeString(SOME_STRING_ARGUMENT)).willReturn(SOME_RETURN_VALUE);\n+\n+\t\t// when\n+\t\tfoo.giveMeSomeString(SOME_STRING_ARGUMENT);\n+\n+\t\t// then\n+\t\tverify(listener).invokingWithReturnValue(isA(PrintableInvocation.class), eq(SOME_RETURN_VALUE),\n+\t\t\t\tcontains(getClass().getSimpleName().toString()));\n+\t}\n+\n \t@Test\n-\tpublic void shouldCallMultipleListeners() throws Exception {\n+\tpublic void givenInvocationReturningValue_shouldCallMultipleListeners() throws Exception {\n \t\t// given\n \t\tInvocationListener listener1 = mock(InvocationListener.class);\n \t\tInvocationListener listener2 = mock(InvocationListener.class);\n \t\tFoo foo = mock(Foo.class, withSettings().callback(listener1).callback(listener2));\n-\t\t\n+\t\tgiven(foo.giveMeSomeString(SOME_STRING_ARGUMENT)).willReturn(SOME_RETURN_VALUE);\n+\n \t\t// when\n-\t\tfoo.doSomething(SOME_STRING_ARGUMENT);\n-\t\t\n+\t\tfoo.giveMeSomeString(SOME_STRING_ARGUMENT);\n+\n \t\t// then\n-\t\tverify(listener1).invoking(any(Invocation.class));\n-\t\tverify(listener2).invoking(any(Invocation.class));\n+\t\tverify(listener1).invokingWithReturnValue(isA(PrintableInvocation.class), eq(SOME_RETURN_VALUE),\n+\t\t\t\tisA(String.class));\n+\t\tverify(listener2).invokingWithReturnValue(isA(PrintableInvocation.class), eq(SOME_RETURN_VALUE),\n+\t\t\t\tisA(String.class));\n+\t}\n+\n+\t@Test\n+\tpublic void givenInvocationThrowingException_shouldCallSingleListenerWithCorrectCallback() throws Exception {\n+\t\t// given\n+\t\tInvocationListener listener = mock(InvocationListener.class);\n+\t\tRuntimeException expectedException = new ThirdPartyException();\n+\t\tFoo foo = mock(Foo.class, withSettings().callback(listener));\n+\t\tdoThrow(expectedException).when(foo).doSomething(SOME_STRING_ARGUMENT);\n+\n+\t\t// when\n+\t\ttry {\n+\t\t\tfoo.doSomething(SOME_STRING_ARGUMENT);\n+\t\t\tfail(\"Exception expected.\");\n+\t\t} catch (ThirdPartyException actualException) {\n+\t\t\t// then\n+\t\t\tassertSame(expectedException, actualException);\n+\t\t\tverify(listener).invokingWithException(isA(PrintableInvocation.class), eq(actualException),\n+\t\t\t\t\tisA(String.class));\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void givenInvocationThrowingException_shouldCallMultipleListeners() throws Exception {\n+\t\t// given\n+\t\tInvocationListener listener1 = mock(InvocationListener.class);\n+\t\tInvocationListener listener2 = mock(InvocationListener.class);\n+\t\tFoo foo = mock(Foo.class, withSettings().callback(listener1).callback(listener2));\n+\t\tdoThrow(new ThirdPartyException()).when(foo).doSomething(SOME_STRING_ARGUMENT);\n+\n+\t\t// when\n+\t\ttry {\n+\t\t\tfoo.doSomething(SOME_STRING_ARGUMENT);\n+\t\t\tfail(\"Exception expected.\");\n+\t\t} catch (ThirdPartyException actualException) {\n+\t\t\t// then\n+\t\t\tverify(listener1).invokingWithException(isA(PrintableInvocation.class), isA(RuntimeException.class),\n+\t\t\t\t\tisA(String.class));\n+\t\t\tverify(listener2).invokingWithException(isA(PrintableInvocation.class), isA(RuntimeException.class),\n+\t\t\t\t\tisA(String.class));\n+\t\t}\n \t}\n }\n--- a/test/org/mockitousage/debugging/VerboseLoggingOfInvocationsOnMockTest.java\n+++ b/test/org/mockitousage/debugging/VerboseLoggingOfInvocationsOnMockTest.java\n  */\n package org.mockitousage.debugging;\n \n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Mockito.doCallRealMethod;\n+import static org.mockito.Mockito.doThrow;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.withSettings;\n \n import java.io.ByteArrayOutputStream;\n import java.io.PrintStream;\n \n+import org.junit.After;\n+import org.junit.Before;\n import org.junit.Test;\n import org.mockito.Mock;\n import org.mockito.internal.util.MockUtil;\n /**\n  * Tests the verbose logging of invocation on mock methods.\n  * \n- * BEWARE: These tests rely on mocking the standard output.\n- * While in a single-threaded environment the finally-blocks\n- * should ensure, that the original stream is restored, there\n- * is no guarantee for this in the parallel setting. Maybe, the\n- * test class should be @Ignore'd by default ...\n+ * BEWARE: These tests rely on mocking the standard output. While in a\n+ * single-threaded environment the Before/After-contract ensures, that the\n+ * original output stream is restored, there is no guarantee for this\n+ * in the parallel setting.\n+ * Maybe, the test class should be @Ignore'd by default ...\n  */\n public class VerboseLoggingOfInvocationsOnMockTest extends TestBase {\n \n+\tprivate static final String SOME_RETURN_VALUE = \"some return value\";\n \tprivate static final String ANOTHER_STRING_VALUE = \"another string value\";\n \tprivate static final String OTHER_STRING_VALUE = \"other string value\";\n \tprivate static final String SOME_STRING_VALUE = \"some string value\";\n-\t\n+\n+\tprivate PrintStream original;\n+\n \t@Mock\n \tUnrelatedClass unrelatedMock;\n \t\n+\t@Before\n+\tpublic void setUp() {\n+\t\toriginal = System.out;\n+\t}\n+\n+\t@After\n+\tpublic void tearDown() {\n+\t\tSystem.setOut(original);\n+\t}\n+\n+\t@Test\n+\tpublic void shouldNotPrintInvocationOnMockWithoutSetting() {\n+\t\tByteArrayOutputStream baos = setUpStreamAsStdOut();\n+\t\t// given\n+\t\tFoo foo = mock(Foo.class, withSettings().verboseLogging());\n+\n+\t\t// when\n+\t\tfoo.giveMeSomeString(SOME_STRING_VALUE);\n+\t\tunrelatedMock.unrelatedMethod(ANOTHER_STRING_VALUE);\n+\n+\t\t// then\n+\t\tassertStreamDoesNotContainMockName(unrelatedMock, baos);\n+\t\tassertNotContains(\"unrelatedMethod\", baos.toString());\n+\t\tassertNotContains(ANOTHER_STRING_VALUE, baos.toString());\n+\t}\n+\n+\t@Test\n+\tpublic void shouldPrintUnstubbedInvocationOnMockToStdOut() {\n+\t\tByteArrayOutputStream baos = setUpStreamAsStdOut();\n+\t\t// given\n+\t\tFoo foo = mock(Foo.class, withSettings().verboseLogging());\n+\n+\t\t// when\n+\t\tfoo.doSomething(SOME_STRING_VALUE);\n+\n+\t\t// then\n+\t\tassertStreamContainsClassName(getClass(), baos);\n+\t\tassertStreamContainsMockName(foo, baos);\n+\t\tassertContains(\"doSomething\", baos.toString());\n+\t\tassertContains(SOME_STRING_VALUE, baos.toString());\n+\t}\n+\n+\t@Test\n+\tpublic void shouldPrintStubbedInvocationOnMockToStdOut() {\n+\t\tByteArrayOutputStream baos = setUpStreamAsStdOut();\n+\t\t// given\n+\t\tFoo foo = mock(Foo.class, withSettings().verboseLogging());\n+\t\tgiven(foo.giveMeSomeString(SOME_STRING_VALUE)).willReturn(\n+\t\t\t\tSOME_RETURN_VALUE);\n+\n+\t\t// when\n+\t\tfoo.giveMeSomeString(SOME_STRING_VALUE);\n+\n+\t\t// then\n+\t\tassertStreamContainsClassName(getClass(), baos);\n+\t\tassertStreamContainsMockName(foo, baos);\n+\t\tassertContains(\"giveMeSomeString\", baos.toString());\n+\t\tassertContains(SOME_STRING_VALUE, baos.toString());\n+\t\tassertContains(SOME_RETURN_VALUE, baos.toString());\n+\t}\n+\n+\t@Test\n+\tpublic void shouldPrintThrowingInvocationOnMockToStdOut() {\n+\t\tByteArrayOutputStream baos = setUpStreamAsStdOut();\n+\t\t// given\n+\t\tFoo foo = mock(Foo.class, withSettings().verboseLogging());\n+\t\tdoThrow(new ThirdPartyException()).when(foo).doSomething(\n+\t\t\t\tSOME_STRING_VALUE);\n+\n+\t\ttry {\n+\t\t\t// when\n+\t\t\tfoo.doSomething(SOME_STRING_VALUE);\n+\t\t\tfail(\"Exception erwartet.\");\n+\t\t} catch (ThirdPartyException e) {\n+\t\t\t// then\n+\t\t\tassertStreamContainsClassName(getClass(), baos);\n+\t\t\tassertStreamContainsMockName(foo, baos);\n+\t\t\tassertContains(\"doSomething\", baos.toString());\n+\t\t\tassertContains(SOME_STRING_VALUE, baos.toString());\n+\t\t\tassertStreamContainsClassName(ThirdPartyException.class, baos);\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void shouldPrintRealInvocationOnSpyToStdOut() {\n+\t\tByteArrayOutputStream baos = setUpStreamAsStdOut();\n+\t\t// given\n+\t\tFooImpl fooSpy = mock(FooImpl.class,\n+\t\t\t\twithSettings().spiedInstance(new FooImpl()).verboseLogging());\n+\t\tdoCallRealMethod().when(fooSpy).doSomething(SOME_STRING_VALUE);\n+\t\t\n+\t\t// when\n+\t\tfooSpy.doSomething(SOME_STRING_VALUE);\n+\t\t\n+\t\t// then\n+\t\tassertStreamContainsClassName(getClass(), baos);\n+\t\tassertStreamContainsMockName(fooSpy, baos);\n+\t\tassertContains(\"doSomething\", baos.toString());\n+\t\tassertContains(SOME_STRING_VALUE, baos.toString());\n+\t}\n+\n \t@Test\n \tpublic void usage() {\n-\t\t//given\n-\t\tFoo foo = mock(Foo.class, withSettings().verboseLogging());\n-    \t\n-        //when\n-    \tfoo.doSomething(SOME_STRING_VALUE);\n-    \tfoo.giveMeSomeString(OTHER_STRING_VALUE);\n-    \tfoo.giveMeSomeString(ANOTHER_STRING_VALUE);\n-\t}\n-\t\n-    @Test\n-    public void shouldPrintInvocationOnMockToStdOut() {\n-    \tPrintStream original = System.out;\n-    \t// FIXME cannot convince checkstyle to accept this code\n-//    \ttry {\n-    \t\tByteArrayOutputStream baos = setUpStreamAsStdOut();\n-    \t\tshouldPrintInvocationOnMockToStdOut_withMockedStdout(baos);\n-//    \t} finally {\n-//    \t\tSystem.setOut(original);\n-//    \t}\n-    }\n-\n-    @Test\n-    public void shouldNotPrintInvocationOnMockWithoutSetting() {\n-    \tPrintStream original = System.out;\n-    \t// FIXME cannot convince checkstyle to accept this code\n-//    \ttry {\n-    \t\tByteArrayOutputStream baos = setUpStreamAsStdOut();\n-    \t\tshouldNotPrintInvocationOnMockWithoutSetting_withMockedStdout(baos);\n-//    \t} finally {\n-//    \t\tSystem.setOut(original);\n-//    \t}\n-    }\n-\n-\tprivate void shouldPrintInvocationOnMockToStdOut_withMockedStdout(ByteArrayOutputStream baos) {\n-\t\t//given\n-\t\tFoo foo = mock(Foo.class, withSettings().verboseLogging());\n-    \t\n-        //when\n-    \tfoo.doSomething(SOME_STRING_VALUE);\n-\n-        //then\n-    \tassertStreamContainsMockName(foo, baos);\n-        assertContains(\"doSomething\", baos.toString());\n-        assertContains(SOME_STRING_VALUE, baos.toString());\n-\t}\n-\n-    private void shouldNotPrintInvocationOnMockWithoutSetting_withMockedStdout(ByteArrayOutputStream baos) {\n-    \t//given\n-    \tFoo foo = mock(Foo.class, withSettings().verboseLogging());\n-    \t\n-    \t//when\n-    \tfoo.giveMeSomeString(SOME_STRING_VALUE);\n-    \tunrelatedMock.unrelatedMethod(ANOTHER_STRING_VALUE);\n-    \t\n-    \t//then\n-    \tassertStreamDoesNotContainMockName(unrelatedMock, baos);\n-    \tassertNotContains(\"unrelatedMethod\", baos.toString());\n-    \tassertNotContains(ANOTHER_STRING_VALUE, baos.toString());\n-    }\n-    \n+\t\t// given\n+\t\tFoo foo = mock(Foo.class, withSettings().verboseLogging());\n+\t\tgiven(foo.giveMeSomeString(ANOTHER_STRING_VALUE)).willReturn(\n+\t\t\t\tSOME_RETURN_VALUE);\n+\n+\t\t// when\n+\t\tfoo.giveMeSomeString(OTHER_STRING_VALUE);\n+\t\tfoo.giveMeSomeString(ANOTHER_STRING_VALUE);\n+\t\tfoo.doSomething(SOME_STRING_VALUE);\n+\t}\n+\n+\tprivate void assertStreamContainsClassName(Class<?> clazz,\n+\t\t\tByteArrayOutputStream baos) {\n+\t\tassertContains(clazz.getName().toString(), baos.toString());\n+\t}\n+\n \tprivate ByteArrayOutputStream setUpStreamAsStdOut() {\n \t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n \t\tSystem.setOut(new PrintStream(baos));\n \t\treturn baos;\n \t}\n \n-\tprivate void assertStreamContainsMockName(Object mock, ByteArrayOutputStream baos) {\n-\t\tassertContains(new MockUtil().getMockName(mock).toString(), baos.toString());\n-\t}\n-\t\n-\tprivate void assertStreamDoesNotContainMockName(Object mock, ByteArrayOutputStream baos) {\n-\t\tassertNotContains(new MockUtil().getMockName(mock).toString(), baos.toString());\n-\t}\n-\t\n-\t\n+\tprivate void assertStreamContainsMockName(Object mock,\n+\t\t\tByteArrayOutputStream baos) {\n+\t\tassertContains(new MockUtil().getMockName(mock).toString(),\n+\t\t\t\tbaos.toString());\n+\t}\n+\n+\tprivate void assertStreamDoesNotContainMockName(Object mock,\n+\t\t\tByteArrayOutputStream baos) {\n+\t\tassertNotContains(new MockUtil().getMockName(mock).toString(),\n+\t\t\t\tbaos.toString());\n+\t}\n+\n \tprivate static class UnrelatedClass {\n \t\tvoid unrelatedMethod(String anotherStringValue) {\n-\t\t\t\n-\t\t}\n+\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * An exception that isn't defined by Mockito or the JDK and therefore does\n+\t * not appear in the logging result by chance alone.\n+\t */\n+\tstatic class ThirdPartyException extends RuntimeException {\n+\t\tprivate static final long serialVersionUID = 2160445705646210847L;\n+\t}\n+\n+\tstatic class FooImpl implements Foo {\n+\n+\t\tpublic String giveMeSomeString(String param) {\n+\t\t\t// TODO Auto-generated method stub\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tpublic void doSomething(String param) {\n+\t\t\t// TODO Auto-generated method stub\n+\n+\t\t}\n+\n \t}\n }", "timestamp": 1298321235, "metainfo": ""}