{"sha": "aeef47f0be9498aaa721457c5597ebdbcb3f2933", "log": "Refactored some code to simplify some stuff  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401320", "commit": "\n--- a/src/org/mockito/exceptions/PrintableInvocation.java\n+++ b/src/org/mockito/exceptions/PrintableInvocation.java\n  */\n package org.mockito.exceptions;\n \n+import org.mockito.internal.debugging.Location;\n+\n public interface PrintableInvocation {\n+    \n     String toString();\n+    \n+    Location getLocation();\n+    \n }\n--- a/src/org/mockito/exceptions/Reporter.java\n+++ b/src/org/mockito/exceptions/Reporter.java\n         ));\n     }    \n \n-    public void argumentsAreDifferent(PrintableInvocation wanted, PrintableInvocation actual, Location actualLocation) {\n+    public void argumentsAreDifferent(String wanted, String actual, Location actualLocation) {\n         String message = join(\"Argument(s) are different! Wanted:\", \n-                wanted.toString(),\n+                wanted,\n                 \"-> at \" + new Location(),\n                 \"Actual invocation has different arguments:\",\n-                actual.toString(),\n+                actual,\n                 \"-> at \" + actualLocation,\n                 \"\"\n                 );\n         \n         if (JUnitTool.hasJUnit()) {\n-            throw JUnitTool.createArgumentsAreDifferentException(message, wanted.toString(), actual.toString());\n+            throw JUnitTool.createArgumentsAreDifferentException(message, wanted, actual);\n         } else {\n             throw new ArgumentsAreDifferent(message);\n         }\n         ));\n     }\n     \n-    //TODO merge location into PrintableInvocation?\n-    public void wantedButNotInvokedInOrder(PrintableInvocation wanted, PrintableInvocation previous, Location previousLocation) {\n+    public void wantedButNotInvokedInOrder(PrintableInvocation wanted, PrintableInvocation previous) {\n         throw new VerificationInOrderFailure(join(\n                     \"Verification in order failure\",\n                     \"Wanted but not invoked:\",\n                     \"-> at \" + new Location(),\n                     \"Wanted anywhere AFTER following interaction:\",\n                     previous.toString(),\n-                    \"-> at \" + previousLocation,\n+                    \"-> at \" + previous.getLocation(),\n                     \"\"\n         ));\n     }\n                 ));\n     }\n     \n-    public void noMoreInteractionsWanted(PrintableInvocation undesired, Location actualLocation) {\n+    public void noMoreInteractionsWanted(PrintableInvocation undesired) {\n         throw new NoInteractionsWanted(join(\n                 \"No interactions wanted here:\",\n                 \"-> at \" + new Location(),\n                 \"But found this interaction:\",\n-                \"-> at \" + actualLocation,\n+                \"-> at \" + undesired.getLocation(),\n                 \"\"\n                 ));\n     }\n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n \n import org.hamcrest.Matcher;\n import org.mockito.exceptions.PrintableInvocation;\n+import org.mockito.internal.debugging.Location;\n \n @SuppressWarnings(\"unchecked\")\n public class InvocationMatcher implements PrintableInvocation, CanPrintInMultilines {\n     public boolean hasSameMethod(Invocation candidate) {\n         return invocation.getMethod().equals(candidate.getMethod());\n     }\n+    \n+    public Location getLocation() {\n+        return invocation.getLocation();\n+    }\n }\n--- a/src/org/mockito/internal/verification/NoMoreInteractions.java\n+++ b/src/org/mockito/internal/verification/NoMoreInteractions.java\n         Invocation unverified = new InvocationsFinder().findFirstUnverified(data.getAllInvocations());\n         \n         if (unverified != null) {\n-            new Reporter().noMoreInteractionsWanted(unverified, unverified.getLocation());\n+            new Reporter().noMoreInteractionsWanted(unverified);\n         }\n     }\n }\n--- a/src/org/mockito/internal/verification/SyncingPrinter.java\n+++ b/src/org/mockito/internal/verification/SyncingPrinter.java\n  */\n package org.mockito.internal.verification;\n \n-import org.mockito.exceptions.PrintableInvocation;\n import org.mockito.internal.invocation.CanPrintInMultilines;\n \n public class SyncingPrinter {\n             this.actual = actual.toString();\n         }\n     }\n-    \n-    public PrintableInvocation getWanted() {\n-        return new PrintableInvocation() {\n-            public String toString() {\n-                return wanted;\n-            }\n-        };\n+\n+    public String getWanted() {\n+        return wanted;\n     }\n-    \n-    public PrintableInvocation getActual() {\n-        return new PrintableInvocation() {\n-            public String toString() {\n-                return actual;\n-            }\n-        };\n+\n+    public String getActual() {\n+        return actual;\n     }\n-}\n+}\n--- a/src/org/mockito/internal/verification/checkers/MissingInvocationInOrderChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/MissingInvocationInOrderChecker.java\n         if (previousInOrder == null) {\n             reporter.wantedButNotInvoked(wanted);\n         } else {\n-            reporter.wantedButNotInvokedInOrder(wanted, previousInOrder, previousInOrder.getLocation());\n+            reporter.wantedButNotInvokedInOrder(wanted, previousInOrder);\n         }\n     }\n }\n--- a/test/org/mockito/internal/verification/checkers/MissingInvocationCheckerTest.java\n+++ b/test/org/mockito/internal/verification/checkers/MissingInvocationCheckerTest.java\n     }\n     \n     class ReporterStub extends Reporter {\n-        private PrintableInvocation wanted;\n-        private PrintableInvocation actual;\n+        private Object wanted;\n+        private String actual;\n         private Location actualLocation;\n         @Override public void wantedButNotInvoked(PrintableInvocation wanted) {\n             this.wanted = wanted;\n         }\n         \n-        @Override public void argumentsAreDifferent(PrintableInvocation wanted, PrintableInvocation actual, Location actualLocation) {\n+        @Override public void argumentsAreDifferent(String wanted, String actual, Location actualLocation) {\n                     this.wanted = wanted;\n                     this.actual = actual;\n                     this.actualLocation = actualLocation;\n--- a/test/org/mockito/internal/verification/checkers/MissingInvocationInOrderCheckerTest.java\n+++ b/test/org/mockito/internal/verification/checkers/MissingInvocationInOrderCheckerTest.java\n import org.junit.Test;\n import org.mockito.exceptions.PrintableInvocation;\n import org.mockito.exceptions.Reporter;\n-import org.mockito.internal.debugging.Location;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationBuilder;\n import org.mockito.internal.invocation.InvocationMatcher;\n         \n         assertEquals(wanted, reporterStub.wanted);\n         assertEquals(previous, reporterStub.previous);\n-        assertSame(previous.getLocation(), reporterStub.previousLocation);\n     }\n     \n     class ReporterStub extends Reporter {\n         private PrintableInvocation wanted;\n         private PrintableInvocation previous;\n-        private Location previousLocation;\n         \n-        @Override public void wantedButNotInvokedInOrder(PrintableInvocation wanted, PrintableInvocation previous, Location previousStackTrace) {\n+        @Override public void wantedButNotInvokedInOrder(PrintableInvocation wanted, PrintableInvocation previous) {\n             this.wanted = wanted;\n             this.previous = previous;\n-            this.previousLocation = previousStackTrace;\n         }\n         \n         @Override public void wantedButNotInvoked(PrintableInvocation wanted) {", "timestamp": 1239796579, "metainfo": ""}