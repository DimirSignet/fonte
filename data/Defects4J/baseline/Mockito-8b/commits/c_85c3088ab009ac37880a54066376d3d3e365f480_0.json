{"sha": "85c3088ab009ac37880a54066376d3d3e365f480", "log": "loads of refactorings (no internet so I couldn't check in) around verification  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40166", "commit": "\n--- a/src/org/mockito/StrictOrderVerifier.java\n+++ b/src/org/mockito/StrictOrderVerifier.java\n     public <T> T verify(T mock) {\n         return this.verify(mock, 1);\n     }\n+    //TODO OngoingVerifyingMode should be interfaced so that 'ongoing' bit is hidden\n     //TODO get rid of interface with int\n     public <T> T verify(T mock, int wantedNumberOfInvocations) {\n         return this.verify(mock, OngoingVerifyingMode.inOrder(wantedNumberOfInvocations, mocksToBeVerifiedInOrder));\n--- a/src/org/mockito/exceptions/Exceptions.java\n+++ b/src/org/mockito/exceptions/Exceptions.java\n     }\n     \n     public static void wantedInvocationDiffersFromActual(String wanted, String actual, HasStackTrace actualInvocationStackTrace) {\n-        wantedDiffersFromActual(\"Invocation differs from actual\", wanted, actual, actualInvocationStackTrace);\n-    }\n-    \n-    public static void strictlyWantedInvocationDiffersFromActual(String wanted, String actual, HasStackTrace actualInvocationStackTrace) {\n-        wantedDiffersFromActual(\"Strict order verification failed\", wanted, actual, actualInvocationStackTrace);\n-    }\n-\n-    private static void wantedDiffersFromActual(String messageTopic, String wanted, String actual, HasStackTrace actualInvocationStackTrace)\n-            throws VerificationError {\n         WantedDiffersFromActual cause = new WantedDiffersFromActual(join(\n                 \"Actual invocation:\",\n                 actual\n         cause.setStackTrace(actualInvocationStackTrace.getStackTrace());\n         \n         throw new VerificationError(join(\n-                messageTopic,\n+                \"Invocation differs from actual\",\n                 \"Wanted invocation:\",\n                 wanted\n             ), cause);\n     }\n-\n+    \n     public static void wantedButNotInvoked(String wanted) {\n         throw new VerificationError(join(\n                     \"Wanted but not invoked:\",\n--- a/src/org/mockito/internal/AllInvocationsFinder.java\n+++ b/src/org/mockito/internal/AllInvocationsFinder.java\n \n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationsFinder;\n+import org.mockito.internal.progress.OngoingVerifyingMode;\n \n public class AllInvocationsFinder implements InvocationsFinder {\n+    \n+    private final OngoingVerifyingMode mode;\n \n-    public List<Invocation> allInvocationsInOrder(List<Object> mocks) {\n+    //TODO name of invocations finder\n+    public AllInvocationsFinder(OngoingVerifyingMode mode) {\n+        this.mode = mode;\n+    }\n+\n+    public List<Invocation> allInvocationsInOrder() {\n+        List<Object> mocks = mode.getAllMocksToBeVerifiedInSequence();\n         List<Invocation> allInvocations = new LinkedList<Invocation>();\n         for (Object mock : mocks) {\n             List<Invocation> invocationsOfSingleMock = MockUtil.getControl(mock).getRegisteredInvocations();\n--- a/src/org/mockito/internal/MockControl.java\n+++ b/src/org/mockito/internal/MockControl.java\n         this.mockingProgress = mockingProgress;\n         this.matchersBinder = matchersBinder;\n         stubber = new Stubber(mockingProgress);\n-        verifyingRecorder = new VerifyingRecorder<T>(new AllInvocationsFinder());\n+        verifyingRecorder = new VerifyingRecorder<T>();\n     }\n \n     public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n         } \n         \n         stubber.setInvocationForPotentialStubbing(invocationMatcher);\n-        verifyingRecorder.recordInvocation(invocationMatcher);\n+        verifyingRecorder.recordInvocation(invocationMatcher.getInvocation());\n \n         mockingProgress.reportStubable(this);\n         \n--- a/src/org/mockito/internal/invocation/Invocation.java\n+++ b/src/org/mockito/internal/invocation/Invocation.java\n     }\n \n     public void markVerifiedInOrder() {\n+        this.markVerified();\n         this.verifiedInOrder = true;\n-        \n     }\n \n     public boolean isVerifiedInOrder() {\n--- /dev/null\n+++ b/src/org/mockito/internal/invocation/InvocationsCalculator.java\n+package org.mockito.internal.invocation;\n+\n+import org.mockito.exceptions.parents.HasStackTrace;\n+import org.mockito.internal.progress.OngoingVerifyingMode;\n+\n+//TODO do I need an interface here? fix the name!\n+public interface InvocationsCalculator {\n+\n+    int countActual(InvocationMatcher wanted);\n+\n+    Invocation findActualInvocation(InvocationMatcher wanted);\n+\n+    HasStackTrace getLastInvocationStackTrace(InvocationMatcher wanted);\n+\n+    HasStackTrace getFirstUndesiredInvocationStackTrace(InvocationMatcher wanted, OngoingVerifyingMode mode);\n+\n+    Invocation getFirstUnverified();\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/invocation/InvocationsCalculatorImpl.java\n+package org.mockito.internal.invocation;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.mockito.exceptions.parents.HasStackTrace;\n+import org.mockito.internal.progress.OngoingVerifyingMode;\n+\n+public class InvocationsCalculatorImpl implements InvocationsCalculator {\n+\n+    private List<Invocation> invocations = new LinkedList<Invocation>();\n+\n+    public InvocationsCalculatorImpl(List<Invocation> invocations) {\n+        this.invocations.addAll(invocations);\n+    }\n+\n+    public int countActual(InvocationMatcher wanted) {\n+        int actual = 0;\n+        for (Invocation registeredInvocation : invocations) {\n+            if (wanted.matches(registeredInvocation)) {\n+                actual++;\n+            }\n+        }\n+\n+        return actual;\n+    }\n+\n+    public Invocation findActualInvocation(InvocationMatcher wanted) {\n+        Invocation actualbyName = null;\n+        for (Invocation registered : invocations) {\n+            String wantedMethodName = wanted.getMethod().getName();\n+            String registeredInvocationName = registered.getMethod().getName();\n+            if (wantedMethodName.equals(registeredInvocationName) && !registered.isVerified()) {\n+                actualbyName = registered;\n+            }\n+        }\n+        \n+        return actualbyName != null ? actualbyName : getFirstUnverified();\n+    }\n+    \n+    public Invocation getFirstUnverified() {\n+        for (Invocation i : invocations) {\n+            if (!i.isVerified()) {\n+                return i;\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    public HasStackTrace getLastInvocationStackTrace(InvocationMatcher wanted) {\n+        Invocation lastMatching = null;\n+        for (Invocation registered : invocations) {\n+            if (wanted.matches(registered)) {\n+                lastMatching = registered;\n+            }\n+        }\n+        return lastMatching != null ? lastMatching.getStackTrace() : null;\n+    }\n+\n+    public HasStackTrace getFirstUndesiredInvocationStackTrace(InvocationMatcher wanted, OngoingVerifyingMode mode) {\n+        int counter = 0;\n+        for (Invocation registered : invocations) {\n+            if (wanted.matches(registered)) {\n+                counter++;\n+                if (counter > mode.wantedCount()) {\n+                    return registered.getStackTrace();\n+                }\n+            }\n+        }\n+        throw new IllegalArgumentException(\"There are no undesired invocations!\");\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/internal/invocation/InvocationsChunker.java\n+package org.mockito.internal.invocation;\n+\n+import java.util.Comparator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+\n+public class InvocationsChunker {\n+\n+    private final InvocationsFinder finder;\n+\n+    public InvocationsChunker(InvocationsFinder invocationsFinder) {\n+        this.finder = invocationsFinder;\n+    }\n+\n+    public List<Invocation> getFirstUnverifiedInvocationChunk() {\n+        Set<Invocation> allInvocationsInOrder = new TreeSet<Invocation>(\n+                new Comparator<Invocation>() {\n+                    public int compare(Invocation o1, Invocation o2) {\n+                        int comparison = o1.getSequenceNumber().compareTo(o2.getSequenceNumber());\n+                        assert comparison != 0;\n+                        return comparison;\n+                    }});\n+        \n+        List<Invocation> allInvocations = finder.allInvocationsInOrder();\n+        allInvocationsInOrder.addAll(allInvocations);\n+        \n+        LinkedList<Invocation> chunk = new LinkedList<Invocation>();\n+        for (Invocation i : allInvocationsInOrder) {\n+            if (i.isVerifiedInOrder()) {\n+                continue;\n+            }\n+            \n+            if (chunk.isEmpty()) {\n+                chunk.add(i);\n+            } else if (chunk.getLast().equals(i)) {\n+                chunk.add(i);\n+            } else {\n+                break;\n+            }\n+        } \n+\n+        return chunk;\n+    }\n+}\n--- a/src/org/mockito/internal/invocation/InvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/InvocationsFinder.java\n \n public interface InvocationsFinder {\n \n-    List<Invocation> allInvocationsInOrder(List<Object> mocks);\n+    List<Invocation> allInvocationsInOrder();\n \n }\n--- /dev/null\n+++ b/src/org/mockito/internal/invocation/InvocationsMarker.java\n+package org.mockito.internal.invocation;\n+\n+import java.util.List;\n+\n+import org.mockito.internal.progress.OngoingVerifyingMode;\n+\n+//TODO name\n+public class InvocationsMarker {\n+\n+    public void markInvocationsAsVerified(List<Invocation> invocations,\n+            InvocationMatcher wanted, OngoingVerifyingMode mode) {\n+        if (mode.wantedCountIsZero()) {\n+            return;\n+        }\n+\n+        if (mode.orderOfInvocationsMatters()) {\n+            markVerifiedInOrder(invocations);\n+        } else {\n+            markVerified(wanted, invocations);\n+        }\n+    }\n+\n+    private void markVerified(InvocationMatcher expected, List<Invocation> invocations) {\n+        for (Invocation i : invocations) {\n+            if (expected.matches(i)) {\n+                i.markVerified();\n+            }\n+        }\n+    }\n+\n+    private void markVerifiedInOrder(List<Invocation> invocations) {\n+        for (Invocation i : invocations) {\n+            i.markVerifiedInOrder();\n+        }\n+    }\n+\n+}\n--- a/src/org/mockito/internal/progress/OngoingVerifyingMode.java\n+++ b/src/org/mockito/internal/progress/OngoingVerifyingMode.java\n         return mocksToBeVerifiedInSequence;\n     }\n \n+//TODO name    \n     public boolean orderOfInvocationsMatters() {\n         return !mocksToBeVerifiedInSequence.isEmpty();\n     }\n     public boolean wantedCountIsZero() {\n         return wantedInvocationCount != null && wantedInvocationCount == 0;\n     }\n+    \n+    @Override\n+    public String toString() {\n+        return \"Wanted invocations count: \" + wantedInvocationCount + \", Mocks to verify in order: \" + mocksToBeVerifiedInSequence;\n+    }\n }\n--- a/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n+++ b/src/org/mockito/internal/verification/MissingInvocationVerifier.java\n import org.mockito.exceptions.Exceptions;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.InvocationsCalculator;\n import org.mockito.internal.progress.OngoingVerifyingMode;\n \n public class MissingInvocationVerifier implements Verifier {\n \n-    public void verify(RegisteredInvocations registeredInvocations, InvocationMatcher wanted, OngoingVerifyingMode mode) {\n-        int actualCount = registeredInvocations.countActual(wanted);\n+    public void verify(InvocationsCalculator calculator, InvocationMatcher wanted, OngoingVerifyingMode mode) {\n+        int actualCount = calculator.countActual(wanted);\n         Integer wantedCount = mode.wantedCount();\n         boolean atLeastOnce = mode.atLeastOnceMode();\n                \n         if ((atLeastOnce || wantedCount == 1) && actualCount == 0) {\n-            reportMissingInvocationError(registeredInvocations, wanted);\n+            reportMissingInvocationError(calculator, wanted);\n         }\n     }\n     \n-    private void reportMissingInvocationError(RegisteredInvocations registeredInvocations, InvocationMatcher wanted) {\n-        Invocation actual = registeredInvocations.findActualInvocation(wanted);\n+    private void reportMissingInvocationError(InvocationsCalculator calculator, InvocationMatcher wanted) {\n+        Invocation actual = calculator.findActualInvocation(wanted);\n         \n         if (actual != null) {\n             reportDiscrepancy(wanted, actual);\n     private void reportDiscrepancy(InvocationMatcher wantedInvocation, Invocation actualInvocation) {\n         String wanted = wantedInvocation.toString();\n         String actual = actualInvocation.toString();\n+        //TODO this dummy string equal logic doesnt work when matchers come into play\n         if (wanted.equals(actual)) {\n             wanted = wantedInvocation.getInvocation().toStringWithArgumentTypes();\n             actual = actualInvocation.toStringWithArgumentTypes();\n+        }\n+        if (wanted.equals(actual)) {\n+            wanted = wantedInvocation.toStringWithSequenceNumber();\n+            actual = actualInvocation.toStringWithSequenceNumber();\n         }\n         \n         Exceptions.wantedInvocationDiffersFromActual(wanted, actual, actualInvocation.getStackTrace());\n--- a/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n+++ b/src/org/mockito/internal/verification/NumberOfInvocationsVerifier.java\n import org.mockito.exceptions.Exceptions;\n import org.mockito.exceptions.parents.HasStackTrace;\n import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.InvocationsCalculator;\n import org.mockito.internal.progress.OngoingVerifyingMode;\n \n public class NumberOfInvocationsVerifier implements Verifier {\n \n-    public void verify(RegisteredInvocations registeredInvocations, InvocationMatcher wanted, OngoingVerifyingMode mode) {\n-        if (mode.orderOfInvocationsMatters() || mode.atLeastOnceMode()) {\n+    public void verify(InvocationsCalculator calculator, InvocationMatcher wanted, OngoingVerifyingMode mode) {\n+        if (mode.atLeastOnceMode()) {\n             return;\n         }\n         \n-        int actualCount = registeredInvocations.countActual(wanted);\n+        int actualCount = calculator.countActual(wanted);\n         Integer wantedCount = mode.wantedCount();\n         \n         if (actualCount < wantedCount) {\n-            HasStackTrace lastInvocation = registeredInvocations.getLastInvocationStackTrace(wanted);\n+            HasStackTrace lastInvocation = calculator.getLastInvocationStackTrace(wanted);\n             Exceptions.tooLittleActualInvocations(wantedCount, actualCount, wanted.toString(), lastInvocation);\n         } else if (actualCount > wantedCount) {\n-            HasStackTrace firstUndesired = registeredInvocations.getFirstUndesiredInvocationStackTrace(wanted, mode);\n+            HasStackTrace firstUndesired = calculator.getFirstUndesiredInvocationStackTrace(wanted, mode);\n             Exceptions.tooManyActualInvocations(wantedCount, actualCount, wanted.toString(), firstUndesired);\n         }\n     }\n--- a/src/org/mockito/internal/verification/Verifier.java\n+++ b/src/org/mockito/internal/verification/Verifier.java\n package org.mockito.internal.verification;\n \n import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.InvocationsCalculator;\n import org.mockito.internal.progress.OngoingVerifyingMode;\n \n \n public interface Verifier {\n \n-    void verify(RegisteredInvocations registeredInvocations, InvocationMatcher wanted, OngoingVerifyingMode mode);\n+    void verify(InvocationsCalculator calculator, InvocationMatcher wanted, OngoingVerifyingMode mode);\n     \n }\n--- a/src/org/mockito/internal/verification/VerifyingRecorder.java\n+++ b/src/org/mockito/internal/verification/VerifyingRecorder.java\n  */\n package org.mockito.internal.verification;\n \n+import java.util.Arrays;\n+import java.util.LinkedList;\n import java.util.List;\n \n import org.mockito.exceptions.Exceptions;\n+import org.mockito.internal.AllInvocationsFinder;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n-import org.mockito.internal.invocation.InvocationsFinder;\n+import org.mockito.internal.invocation.InvocationsCalculator;\n+import org.mockito.internal.invocation.InvocationsCalculatorImpl;\n+import org.mockito.internal.invocation.InvocationsChunker;\n+import org.mockito.internal.invocation.InvocationsMarker;\n import org.mockito.internal.progress.OngoingVerifyingMode;\n \n public class VerifyingRecorder<T> {\n \n-    private final RegisteredInvocations registeredInvocations;\n+    private final LinkedList<Invocation> registeredInvocations = new LinkedList<Invocation>();\n+    private InvocationsMarker marker;\n+    private List<Verifier> verifiers;\n     \n-    //TODO change name of invocationsFinder\n-    public VerifyingRecorder(InvocationsFinder invocationsFinder) {\n-        this.registeredInvocations = new RegisteredInvocations(invocationsFinder);\n+    public VerifyingRecorder() {\n+        this(new InvocationsMarker(), Arrays.asList(new MissingInvocationVerifier(), new NumberOfInvocationsVerifier()));\n     }\n     \n-    public void recordInvocation(InvocationMatcher invocation) {\n-        this.registeredInvocations.add(invocation.getInvocation());\n+    VerifyingRecorder(InvocationsMarker marker, List<Verifier> verifiers) {\n+        this.marker = marker;  \n+        this.verifiers = verifiers;\n+    }\n+    \n+    public void recordInvocation(Invocation invocation) {\n+        this.registeredInvocations.add(invocation);\n     }\n     \n     public void eraseLastInvocation() {\n     }\n \n     public List<Invocation> getRegisteredInvocations() {\n-        return registeredInvocations.all();\n+        return registeredInvocations;\n     }\n \n     public void verify(InvocationMatcher wanted, OngoingVerifyingMode mode) {\n-        //get unverified invocation chunk and run following verifiers:\n+        List<Invocation> invocations = getInvocationsForEvaluation(mode);\n+        InvocationsCalculator calculator = new InvocationsCalculatorImpl(invocations);\n         \n-        // chunks can be empty, can have invocations from different mocks or\n-        // have invocations only from one mock (not strict verification\n-        // scenario)\n+        for (Verifier verifier : verifiers) {\n+            verifier.verify(calculator, wanted, mode);\n+        }\n         \n-        // new MissingInvocationVerifier(), \n-        // new NumberOfInvocationsVerifier()\n-        \n-        new OrderOfInvocationsVerifier().verify(registeredInvocations, wanted, mode); \n-        new MissingInvocationVerifier().verify(registeredInvocations, wanted, mode); \n-        new NumberOfInvocationsVerifier().verify(registeredInvocations, wanted, mode);\n-        \n-        registeredInvocations.markInvocationsAsVerified(wanted, mode);\n+        marker.markInvocationsAsVerified(invocations, wanted, mode);\n+    }\n+    \n+    private List<Invocation> getInvocationsForEvaluation(OngoingVerifyingMode mode) {\n+        List<Invocation> invocations;        \n+        if (mode.orderOfInvocationsMatters()) {\n+            InvocationsChunker chunker = new InvocationsChunker(new AllInvocationsFinder(mode));\n+            invocations = chunker.getFirstUnverifiedInvocationChunk();\n+        } else {\n+            invocations = registeredInvocations;\n+        }\n+        return invocations;\n     }\n     \n     public void verifyNoMoreInteractions() {\n-        Invocation unverified = registeredInvocations.getFirstUnverified();\n+        //TODO refactor to have single verify method\n+        //TODO OngoingVerifyingMode.times(0) should be explicit\n+        InvocationsCalculator calculator1 = new InvocationsCalculatorImpl(getInvocationsForEvaluation(OngoingVerifyingMode.times(0)));\n+        InvocationsCalculator calculator = calculator1;\n+        Invocation unverified = calculator.getFirstUnverified();\n         if (unverified != null) {\n             Exceptions.noMoreInteractionsWanted(unverified.toString(), unverified.getStackTrace());\n         }\n     }\n     \n     public void verifyZeroInteractions() {\n-        Invocation unverified = registeredInvocations.getFirstUnverified();\n+        //TODO OngoingVerifyingMode.times(0) should be explicit\n+        InvocationsCalculator calculator1 = new InvocationsCalculatorImpl(getInvocationsForEvaluation(OngoingVerifyingMode.times(0)));\n+        InvocationsCalculator calculator = calculator1;\n+        Invocation unverified = calculator.getFirstUnverified();\n         if (unverified != null) {\n             Exceptions.zeroInteractionsWanted(unverified.toString(), unverified.getStackTrace());\n         }\n--- a/test/org/mockito/exceptions/parents/StackTraceRemoverTest.java\n+++ b/test/org/mockito/exceptions/parents/StackTraceRemoverTest.java\n package org.mockito.exceptions.parents;\n \n import static org.junit.Assert.assertThat;\n-import static org.mockito.util.ExtraMatchers.collectionIsExactlyInOrder;\n+import static org.mockito.util.ExtraMatchers.collectionHasExactlyInOrder;\n \n import java.util.*;\n \n         setStackTrace(\"methodOne\", \"methodTwo\", \"methodThree\", \"commonMethodOne\", \"commonMethodTwo\");\n         setCauseStackTrace(\"actualOne\", \"actualTwo\", \"commonMethodOne\", \"commonMethodTwo\");\n         remove();\n-        assertThat(methodsOnTraceAfterRemoving, collectionIsExactlyInOrder(\n+        assertThat(methodsOnTraceAfterRemoving, collectionHasExactlyInOrder(\n                 \"methodOne\",\n                 \"methodTwo\",\n                 \"methodThree\"\n         setStackTrace(\"methodOne\", \"commonMethodOne\", \"commonMethodTwo\", \"commonMethodOne\", \"commonMethodTwo\");\n         setCauseStackTrace(\"actualOne\", \"commonMethodOne\", \"commonMethodTwo\");\n         remove();\n-        assertThat(methodsOnTraceAfterRemoving, collectionIsExactlyInOrder(\n+        assertThat(methodsOnTraceAfterRemoving, collectionHasExactlyInOrder(\n                 \"methodOne\",\n                 \"commonMethodOne\",\n                 \"commonMethodTwo\"\n         setStackTrace(\"methodOne\", \"commonMethodOne\");\n         setCauseStackTrace(\"actualOne\", \"commonMethodOne\", \"actualOne\", \"commonMethodOne\");\n         remove();\n-        assertThat(methodsOnTraceAfterRemoving, collectionIsExactlyInOrder(\n+        assertThat(methodsOnTraceAfterRemoving, collectionHasExactlyInOrder(\n                 \"methodOne\"\n         ));\n     }\n         setStackTrace(\"commonOne\");\n         setCauseStackTrace(\"commonOne\");\n         remove();\n-        assertThat(methodsOnTraceAfterRemoving, collectionIsExactlyInOrder());\n+        assertThat(methodsOnTraceAfterRemoving, collectionHasExactlyInOrder());\n     }\n     \n     @Test\n         setStackTrace(\"one\", \"commonOne\");\n         setCauseStackTrace(\"two\", \"commonOne\");\n         remove();\n-        assertThat(methodsOnTraceAfterRemoving, collectionIsExactlyInOrder(\n+        assertThat(methodsOnTraceAfterRemoving, collectionHasExactlyInOrder(\n                 \"one\"\n         ));\n     }\n--- a/test/org/mockito/internal/invocation/InvocationTest.java\n+++ b/test/org/mockito/internal/invocation/InvocationTest.java\n         invocation = new InvocationBuilder().method(m).args((Object)null).toInvocation();\n         assertEquals(\"Object.oneArray(null)\", invocation.toString());\n     }\n+    \n+    @Test\n+    public void shouldMarkVerifiedWhenMarkedVerifiedInOrder() throws Exception {\n+        assertFalse(invocation.isVerified());\n+        assertFalse(invocation.isVerifiedInOrder());\n+        \n+        invocation.markVerifiedInOrder();\n+        \n+        assertTrue(invocation.isVerified());\n+        assertTrue(invocation.isVerifiedInOrder());\n+    }\n }\n--- /dev/null\n+++ b/test/org/mockito/internal/invocation/InvocationsChunkerTest.java\n+package org.mockito.internal.invocation;\n+\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.util.ExtraMatchers.collectionHasExactlyInOrder;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class InvocationsChunkerTest {\n+\n+    private InvocationsChunker chunker;\n+    private Invocation simpleMethodInvocation;\n+    private Invocation simpleMethodInvocationTwo;\n+    private Invocation differentMethodInvocation;\n+    private Invocation simpleMethodInvocationThree;\n+\n+    @Before\n+    public void setup() throws Exception {\n+        simpleMethodInvocation = new InvocationBuilder().method(\"simpleMethod\").seq(1).toInvocation();\n+        simpleMethodInvocationTwo = new InvocationBuilder().method(\"simpleMethod\").seq(2).toInvocation();\n+        differentMethodInvocation = new InvocationBuilder().method(\"differentMethod\").seq(3).toInvocation();\n+        simpleMethodInvocationThree = new InvocationBuilder().method(\"simpleMethod\").seq(4).toInvocation();\n+        \n+        chunker = new InvocationsChunker(new InvocationsFinder() {\n+            public List<Invocation> allInvocationsInOrder() {\n+                return Arrays.asList(simpleMethodInvocation, simpleMethodInvocationTwo, differentMethodInvocation, simpleMethodInvocationThree);\n+            }});\n+    }\n+\n+    @Test\n+    public void shouldGetFirstUnverifiedInvocationChunk() throws Exception {\n+        List<Invocation> chunk = chunker.getFirstUnverifiedInvocationChunk();\n+        assertThat(chunk, collectionHasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo));\n+    }\n+    \n+    @Test\n+    public void shouldGetSecondUnverifiedInvocationChunk() throws Exception {\n+        simpleMethodInvocation.markVerifiedInOrder();\n+        simpleMethodInvocationTwo.markVerifiedInOrder();\n+        \n+        List<Invocation> chunk = chunker.getFirstUnverifiedInvocationChunk();\n+        \n+        assertThat(chunk, collectionHasExactlyInOrder(differentMethodInvocation));\n+    }\n+    \n+    @Test\n+    public void shouldGetThirdUnverifiedInvocationChunk() throws Exception {\n+        simpleMethodInvocation.markVerifiedInOrder();\n+        simpleMethodInvocationTwo.markVerifiedInOrder();\n+        differentMethodInvocation.markVerifiedInOrder();\n+        \n+        List<Invocation> chunk = chunker.getFirstUnverifiedInvocationChunk();\n+        \n+        assertThat(chunk, collectionHasExactlyInOrder(simpleMethodInvocationThree));\n+    }\n+    \n+    @Test\n+    public void shouldNotGetInvocationsChunk() throws Exception {\n+        simpleMethodInvocation.markVerifiedInOrder();\n+        simpleMethodInvocationTwo.markVerifiedInOrder();\n+        differentMethodInvocation.markVerifiedInOrder();\n+        simpleMethodInvocationThree.markVerifiedInOrder();\n+        \n+        List<Invocation> chunk = chunker.getFirstUnverifiedInvocationChunk();\n+        \n+        assertTrue(chunk.isEmpty());\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/invocation/InvocationsMarkerTest.java\n+package org.mockito.internal.invocation;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.internal.progress.OngoingVerifyingMode.atLeastOnce;\n+import static org.mockito.internal.progress.OngoingVerifyingMode.inOrder;\n+import static org.mockito.internal.progress.OngoingVerifyingMode.times;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.internal.progress.OngoingVerifyingMode;\n+\n+public class InvocationsMarkerTest {\n+\n+    private InvocationsMarker marker;\n+    private Invocation simpleMethodInvocation;\n+    private Invocation simpleMethodInvocationTwo;\n+    private Invocation differentMethodInvocation;\n+    private Invocation simpleMethodInvocationThree;\n+    private List<Invocation> invocations;\n+\n+    @Before\n+    public void setup() throws Exception {\n+        simpleMethodInvocation = new InvocationBuilder().method(\"simpleMethod\").seq(1).toInvocation();\n+        simpleMethodInvocationTwo = new InvocationBuilder().method(\"simpleMethod\").seq(2).toInvocation();\n+        differentMethodInvocation = new InvocationBuilder().method(\"differentMethod\").seq(3).toInvocation();\n+        simpleMethodInvocationThree = new InvocationBuilder().method(\"simpleMethod\").seq(4).toInvocation();\n+        \n+        invocations = Arrays.asList(simpleMethodInvocation, simpleMethodInvocationTwo, differentMethodInvocation, simpleMethodInvocationThree);\n+        \n+        marker = new InvocationsMarker();\n+    }\n+\n+    @Test\n+    public void shouldMarkAllSimpleMethodsAsVerified() throws Exception {\n+        marker.markInvocationsAsVerified(invocations, new InvocationMatcher(simpleMethodInvocation), times(2));\n+        \n+        assertEquals(true, simpleMethodInvocation.isVerified());\n+        assertEquals(true, simpleMethodInvocationTwo.isVerified());\n+        assertEquals(false, differentMethodInvocation.isVerified());\n+        assertEquals(true, simpleMethodInvocationThree.isVerified());\n+    }\n+    \n+    @Test\n+    public void shouldMarkAllsimpleMethodAsVerifiedWhenAtLeastOnceIsUsed() throws Exception {\n+        marker.markInvocationsAsVerified(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnce());\n+        \n+        assertEquals(true, simpleMethodInvocation.isVerified());\n+        assertEquals(true, simpleMethodInvocationTwo.isVerified());\n+        assertEquals(false, differentMethodInvocation.isVerified());\n+        assertEquals(true, simpleMethodInvocationThree.isVerified());\n+    }\n+    \n+    @Test\n+    public void shouldMarkAsVerifiedInOrderWhenVerificationIsNotInOrder() throws Exception {\n+        marker.markInvocationsAsVerified(invocations, new InvocationMatcher(simpleMethodInvocation), atLeastOnce());\n+        assertEquals(false, simpleMethodInvocation.isVerifiedInOrder());\n+    }\n+    \n+    @Test\n+    public void shouldNeverMarkInvocationsAsVerifiedIfExpectedCountIsZero() throws Exception {\n+        marker.markInvocationsAsVerified(invocations, new InvocationMatcher(simpleMethodInvocation), times(0));\n+        \n+        assertEquals(false, simpleMethodInvocation.isVerified());\n+        assertEquals(false, simpleMethodInvocationTwo.isVerified());\n+        assertEquals(false, differentMethodInvocation.isVerified());\n+        assertEquals(false, simpleMethodInvocationThree.isVerified());\n+    }\n+    \n+    @Test\n+    public void shouldMarkAsVerifedInOrderAllInvocationsFromChunk() throws Exception {\n+        OngoingVerifyingMode mode = inOrder(null, Arrays.asList(new Object()));\n+        Invocation doesntMatter = null;\n+        marker.markInvocationsAsVerified(invocations, new InvocationMatcher(doesntMatter), mode);\n+        \n+        assertEquals(true, simpleMethodInvocation.isVerifiedInOrder());\n+        assertEquals(true, simpleMethodInvocationTwo.isVerifiedInOrder());\n+        assertEquals(true, differentMethodInvocation.isVerifiedInOrder());\n+        assertEquals(true, simpleMethodInvocationThree.isVerifiedInOrder());\n+    }\n+    \n+    @Test\n+    public void shouldMarkAsVerifedAllInvocationsFromThirdChunk() throws Exception {\n+        OngoingVerifyingMode mode = inOrder(null, Arrays.asList(new Object()));\n+        \n+        Invocation doesntMatter = null;\n+        marker.markInvocationsAsVerified(invocations, new InvocationMatcher(doesntMatter), mode);\n+        marker.markInvocationsAsVerified(invocations, new InvocationMatcher(doesntMatter), mode);\n+        marker.markInvocationsAsVerified(invocations, new InvocationMatcher(doesntMatter), mode);\n+        \n+        assertEquals(true, simpleMethodInvocationThree.isVerifiedInOrder());\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/verification/InvocationsCalculatorImplTest.java\n+package org.mockito.internal.verification;\n+\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+\n+import java.util.Arrays;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.exceptions.parents.HasStackTrace;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.InvocationsCalculatorImpl;\n+import org.mockito.internal.progress.OngoingVerifyingMode;\n+\n+\n+public class InvocationsCalculatorImplTest {\n+    \n+    private InvocationsCalculatorImpl calculator;\n+    private Invocation simpleMethodInvocation;\n+    private Invocation simpleMethodInvocationTwo;\n+    private Invocation differentMethodInvocation;\n+\n+    @Before\n+    public void setup() throws Exception {\n+        simpleMethodInvocation = new InvocationBuilder().method(\"simpleMethod\").seq(1).toInvocation();\n+        simpleMethodInvocationTwo = new InvocationBuilder().method(\"simpleMethod\").seq(2).toInvocation();\n+        differentMethodInvocation = new InvocationBuilder().method(\"differentMethod\").seq(3).toInvocation();\n+        calculator = new InvocationsCalculatorImpl(Arrays.asList(simpleMethodInvocation, simpleMethodInvocationTwo, differentMethodInvocation));\n+    }\n+    \n+    @Test\n+    public void shouldGetFirstUnverifiedInvocation() throws Exception {\n+        assertSame(simpleMethodInvocation, calculator.getFirstUnverified());\n+        \n+        simpleMethodInvocationTwo.markVerified();\n+        simpleMethodInvocation.markVerified();\n+        \n+        assertSame(differentMethodInvocation, calculator.getFirstUnverified());\n+        \n+        differentMethodInvocation.markVerified();\n+        assertNull(calculator.getFirstUnverified());\n+    }\n+    \n+    @Test\n+    public void shouldGetFirstUndesiredWhenWantedNumberOfTimesIsZero() throws Exception {\n+        HasStackTrace firstUndesired = calculator.getFirstUndesiredInvocationStackTrace(new InvocationMatcher(simpleMethodInvocation), OngoingVerifyingMode.times(0));\n+        HasStackTrace expected = simpleMethodInvocation.getStackTrace();\n+        assertSame(firstUndesired, expected);\n+    }\n+    \n+    @Test\n+    public void shouldGetFirstUndesiredWhenWantedNumberOfTimesIsOne() throws Exception {\n+        HasStackTrace firstUndesired = calculator.getFirstUndesiredInvocationStackTrace(new InvocationMatcher(simpleMethodInvocation), OngoingVerifyingMode.times(1));\n+        HasStackTrace expected = simpleMethodInvocationTwo.getStackTrace();\n+        assertSame(firstUndesired, expected);\n+    }\n+    \n+    @Test(expected=IllegalArgumentException.class)\n+    public void shouldBreakWhenThereAreNoUndesiredInvocations() throws Exception {\n+        calculator.getFirstUndesiredInvocationStackTrace(new InvocationMatcher(simpleMethodInvocation), OngoingVerifyingMode.times(2));\n+    }\n+    \n+    @Test(expected=IllegalArgumentException.class)\n+    public void shouldBreakWhenWantedInvocationsFigureIsBigger() throws Exception {\n+        calculator.getFirstUndesiredInvocationStackTrace(new InvocationMatcher(simpleMethodInvocation), OngoingVerifyingMode.times(100));\n+    }\n+}\n--- a/test/org/mockito/internal/verification/NumberOfInvocationsVerifierTest.java\n+++ b/test/org/mockito/internal/verification/NumberOfInvocationsVerifierTest.java\n  */\n package org.mockito.internal.verification;\n \n-import static org.junit.Assert.assertTrue;\n-\n-import java.util.Arrays;\n-\n-import org.junit.*;\n+import org.junit.Before;\n+import org.junit.Test;\n import org.mockito.RequiresValidState;\n import org.mockito.internal.progress.OngoingVerifyingMode;\n-import org.mockito.internal.verification.NumberOfInvocationsVerifier;\n \n @SuppressWarnings(\"unchecked\")\n public class NumberOfInvocationsVerifierTest extends RequiresValidState {\n     }\n \n     @Test\n-    public void shouldNotCheckForWrongNumberOfModificationsWhenVerifyingInOrder() throws Exception {\n-        OngoingVerifyingMode inOrder = OngoingVerifyingMode.inOrder(1, Arrays.asList(new Object()));\n-        assertTrue(inOrder.orderOfInvocationsMatters());\n-        \n-        verifier.verify(null, null, inOrder);\n-    }\n-    \n-    @Test\n     public void shouldNotCheckForWrongNumberOfModificationsWhenVerifyingAtLeastOnce() throws Exception {\n         OngoingVerifyingMode inOrder = OngoingVerifyingMode.atLeastOnce();\n         \n--- /dev/null\n+++ b/test/org/mockito/internal/verification/VerifyingRecorderTest.java\n+/*\n+ * Copyright (c) 2007, Szczepan Faber. \n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.junit.Test;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.InvocationBuilder;\n+import org.mockito.internal.invocation.InvocationMatcher;\n+import org.mockito.internal.invocation.InvocationsMarker;\n+import org.mockito.internal.progress.OngoingVerifyingMode;\n+\n+import static org.mockito.util.ExtraMatchers.*;\n+import static org.junit.Assert.*;\n+\n+public class VerifyingRecorderTest {\n+    \n+    private List<Invocation> invocationsMarkedAsVerified;\n+    \n+    class InvocationsMarkerExtension extends InvocationsMarker {\n+        @Override\n+        public void markInvocationsAsVerified(List<Invocation> invocations, InvocationMatcher wanted,\n+                OngoingVerifyingMode mode) {\n+            invocationsMarkedAsVerified = invocations;\n+        }\n+    }\n+\n+    @Test\n+    public void shouldMarkInvocationsAsVerified() {\n+        VerifyingRecorder<Object> recorder = new VerifyingRecorder<Object>(new InvocationsMarkerExtension(), Collections.<Verifier>emptyList());\n+        Invocation recorded = new InvocationBuilder().method(\"simpleMethod\").toInvocation();\n+        recorder.recordInvocation(recorded);\n+        \n+        InvocationMatcher wanted = new InvocationBuilder().method(\"differentMethod\").toInvocationMatcher();\n+        recorder.verify(wanted, OngoingVerifyingMode.atLeastOnce());\n+        \n+        assertThat(invocationsMarkedAsVerified, collectionHasExactlyInOrder(recorded));\n+    }\n+}\n--- a/test/org/mockito/util/ExtraMatchers.java\n+++ b/test/org/mockito/util/ExtraMatchers.java\n \n             public void describeTo(Description desc) {\n                 desc.appendText(\"Method of index: \" + stackTraceIndex + \" expected to be: \" + method + \" but is: \" + actualMethodAtIndex);\n-            }\n-        };\n-    }\n-    \n-    public static <T> Matcher<Collection> collectionContaining(final T ... elements) {\n-        return new BaseMatcher<Collection>() {\n-\n-            public boolean matches(Object collection) {\n-                for (T element : elements) {\n-                    if (((Collection)collection).contains(element) == false) {\n-                        return false;\n-                    }\n-                }\n-                return true;\n-            }\n-\n-            public void describeTo(Description desc) {\n-                desc.appendText(\"collection doesn't containg one of: \" + Arrays.toString(elements));\n             }\n         };\n     }\n         };\n     }\n     \n-    public static <T> Matcher<Collection> collectionIsExactlyInOrder(final T ... elements) {\n+    public static <T> Matcher<Collection> collectionHas(final T ... elements) {\n+        return new BaseMatcher<Collection>() {\n+\n+            public boolean matches(Object collection) {\n+                for (T element : elements) {\n+                    if (((Collection)collection).contains(element) == false) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+\n+            public void describeTo(Description desc) {\n+                desc.appendText(\"collection doesn't containg one of: \" + Arrays.toString(elements));\n+            }\n+        };\n+    }\n+    \n+    public static <T> Matcher<Collection> collectionHasExactlyInOrder(final T ... elements) {\n         return new BaseMatcher<Collection>() {\n \n             public boolean matches(Object collection) {\n--- a/test/org/mockitousage/MultiThreadedTest.java\n+++ b/test/org/mockitousage/MultiThreadedTest.java\n import org.mockito.internal.MockControlTest;\n import org.mockito.internal.creation.CglibTest;\n import org.mockito.internal.creation.MockFactoryTest;\n-import org.mockito.internal.invocation.InvocationChunkTest;\n import org.mockito.internal.invocation.InvocationMatcherTest;\n import org.mockito.internal.invocation.InvocationTest;\n import org.mockito.internal.matchers.EqualsTest;\n import org.mockito.internal.progress.OngoingVerifyingModeTest;\n import org.mockito.internal.stubbing.EmptyReturnValuesTest;\n import org.mockito.internal.verification.NumberOfInvocationsVerifierTest;\n-import org.mockito.internal.verification.RegisteredInvocationsTest;\n import org.mockitousage.binding.BridgeMethodPuzzleTest;\n import org.mockitousage.binding.IncorectBindingPuzzleFixedTest;\n import org.mockitousage.matchers.ComparableMatchersTest;\n                     EqualsTest.class, \n                     CglibTest.class, \n                     InvocationMatcherTest.class, \n-                    InvocationChunkTest.class, \n                     MockFactoryTest.class, \n                     NumberOfInvocationsVerifierTest.class, \n                     MockingProgressImplTest.class, \n-                    RegisteredInvocationsTest.class, \n                     EmptyReturnValuesTest.class, \n                     OngoingVerifyingModeTest.class, \n                     InvocationTest.class, \n--- a/test/org/mockitousage/verification/DescriptiveMessagesOnStrictOrderErrorsTest.java\n+++ b/test/org/mockitousage/verification/DescriptiveMessagesOnStrictOrderErrorsTest.java\n         } catch (VerificationError e) {\n             String expected = \n                     \"\\n\" +\n-                    \"Strict order verification failed\" +\n+                    \"Invocation differs from actual\" +\n                     \"\\n\" +\n                     \"Wanted invocation:\" +\n                     \"\\n\" +\n         try {\n             strictly.verify(two, 1).simpleMethod(2);\n             fail();\n-        } catch (NumberOfInvocationsError expected) {\n-            String actualMessage = expected.getMessage();\n+        } catch (TooManyActualInvocationsError e) {\n+            String actualMessage = e.getMessage();\n             String expectedMessage = \n                     \"\\n\" +\n                     \"IMethods.simpleMethod(2)\" +\n             assertThat(expected, causeMessageContains(\"IMethods#1.simpleMethod()\"));\n         }\n     }\n+    \n+    @Ignore\n+    @Test\n+    public void shouldPrintSequenceNumberAndMatchersWhenMocksAndMethodsAreTheSame() {\n+        StateResetter.reset();\n+        one = mock(IMethods.class);\n+        two = mock(IMethods.class);\n+        \n+        one.simpleMethod(1);\n+        two.simpleMethod(1);\n+        \n+        strictly = createStrictOrderVerifier(one, two);\n+        \n+        try {\n+            strictly.verify(two).simpleMethod(Mockito.anyInt());\n+            fail();\n+        } catch (VerificationError expected) {\n+            assertThat(expected, messageContains(\"IMethods#3.simpleMethod(<any>)\"));\n+            assertThat(expected, causeMessageContains(\"IMethods#1.simpleMethod(1)\"));\n+        }\n+    }\n }\n--- a/test/org/mockitousage/verification/VerificationInOrderTest.java\n+++ b/test/org/mockitousage/verification/VerificationInOrderTest.java\n package org.mockitousage.verification;\n \n import static org.junit.Assert.fail;\n-import static org.mockito.Mockito.*;\n-\n-import org.junit.*;\n-import org.mockito.*;\n-import org.mockito.exceptions.verification.*;\n+import static org.mockito.Mockito.atLeastOnce;\n+import static org.mockito.Mockito.createStrictOrderVerifier;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.verifyZeroInteractions;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.RequiresValidState;\n+import org.mockito.Strictly;\n+import org.mockito.exceptions.verification.TooLittleActualInvocationsError;\n+import org.mockito.exceptions.verification.TooManyActualInvocationsError;\n+import org.mockito.exceptions.verification.VerificationError;\n import org.mockitousage.IMethods;\n \n @SuppressWarnings(\"unchecked\")  \n         } catch (VerificationError e) {}\n     }\n     \n-    @Test(expected=NumberOfInvocationsError.class)\n+    @Test(expected=TooManyActualInvocationsError.class)\n     public void shouldFailOnFirstMethodBecauseOneInvocationWanted() {\n         strictly.verify(mockOne, 0).simpleMethod(1);\n     }\n     \n-    @Test(expected=NumberOfInvocationsError.class)\n+    @Test(expected=TooLittleActualInvocationsError.class)\n     public void shouldFailOnFirstMethodBecauseOneInvocationWantedAgain() {\n         strictly.verify(mockOne, 2).simpleMethod(1);\n     }\n         try {\n             strictly.verify(mockTwo, 3).simpleMethod(2);\n             fail();\n-        } catch (NumberOfInvocationsError e) {}\n+        } catch (TooLittleActualInvocationsError e) {}\n     }\n     \n     @Test\n         try {\n             strictly.verify(mockTwo, 0).simpleMethod(2);\n             fail();\n-        } catch (NumberOfInvocationsError e) {}\n+        } catch (TooManyActualInvocationsError e) {}\n     }    \n     \n     @Test\n         try {\n             strictly.verify(mockOne, 0).simpleMethod(4);\n             fail();\n-        } catch (NumberOfInvocationsError e) {}\n+        } catch (TooManyActualInvocationsError e) {}\n     }\n     \n     @Test\n         try {\n             strictly.verify(mockOne, 2).simpleMethod(4);\n             fail();\n-        } catch (NumberOfInvocationsError e) {}\n+        } catch (TooLittleActualInvocationsError e) {}\n     }    \n     \n     /* ------------- */\n         try {\n             strictly.verify(mockTwo, 2).simpleMethod(-999);\n             fail();\n-        } catch (VerificationError e) {}\n+        } catch (TooLittleActualInvocationsError e) {}\n     }\n     \n     @Test\n         try {\n             strictly.verify(mockTwo, 2).oneArg(true);\n             fail();\n-        } catch (VerificationError e) {}\n+        } catch (TooLittleActualInvocationsError e) {}\n     }    \n     \n     @Test\n         strictly.verify(mockOne).simpleMethod(4);\n     }\n     \n-    @Test(expected = VerificationError.class)\n+    @Test(expected = TooLittleActualInvocationsError.class)\n     public void shouldFailWhenSecondMethodCalledFirst() {\n         strictly.verify(mockTwo, 2).simpleMethod(2);\n     }", "timestamp": 1197563090, "metainfo": ""}