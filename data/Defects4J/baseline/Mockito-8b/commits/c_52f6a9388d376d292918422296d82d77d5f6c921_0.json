{"sha": "52f6a9388d376d292918422296d82d77d5f6c921", "log": "Generic deep stubs now operational! Wildcard types are not yet in the party.  --HG-- branch : issue230", "commit": "\n--- a/src/org/mockito/internal/creation/MockSettingsImpl.java\n+++ b/src/org/mockito/internal/creation/MockSettingsImpl.java\n         return interfaces;\n     }\n \n-    public MockSettings withParameterizedInfo(MockitoGenericMetadata mockitoGenericMetadata) {\n+    public MockSettings parameterizedInfo(MockitoGenericMetadata mockitoGenericMetadata) {\n         this.mockitoGenericMetadata = mockitoGenericMetadata;\n         return this;\n     }\n--- a/src/org/mockito/internal/creation/settings/CreationSettings.java\n+++ b/src/org/mockito/internal/creation/settings/CreationSettings.java\n  */\n package org.mockito.internal.creation.settings;\n \n+import org.mockito.internal.util.reflection.MockitoGenericMetadata;\n import org.mockito.listeners.InvocationListener;\n import org.mockito.mock.MockCreationSettings;\n import org.mockito.mock.MockName;\n     protected MockName mockName;\n     protected boolean serializable;\n     protected List<InvocationListener> invocationListeners = new ArrayList<InvocationListener>();\n+    protected MockitoGenericMetadata mockitoGenericMetadata;\n \n     public CreationSettings() {}\n \n         this.mockName = copy.mockName;\n         this.serializable = copy.serializable;\n         this.invocationListeners = copy.invocationListeners;\n+        this.mockitoGenericMetadata = copy.mockitoGenericMetadata;\n     }\n \n     public Class<T> getTypeToMock() {\n     public List<InvocationListener> getInvocationListeners() {\n         return invocationListeners;\n     }\n+\n+    public MockitoGenericMetadata getMockitoGenericMetadata() {\n+        if (mockitoGenericMetadata == null) {\n+            this.mockitoGenericMetadata = MockitoGenericMetadata.from(typeToMock);\n+        }\n+        return mockitoGenericMetadata;\n+    }\n+\n+    public void setMockitoGenericMetadata(MockitoGenericMetadata mockitoGenericMetadata) {\n+        this.mockitoGenericMetadata = mockitoGenericMetadata;\n+    }\n }\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n \n import org.mockito.Mockito;\n import org.mockito.internal.InternalMockHandler;\n-import org.mockito.internal.creation.MockSettingsImpl;\n import org.mockito.internal.creation.settings.CreationSettings;\n import org.mockito.internal.stubbing.InvocationContainerImpl;\n import org.mockito.internal.stubbing.StubbedInvocationMatcher;\n import java.lang.reflect.Type;\n \n import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.withSettings;\n \n /**\n  * Returning deep stub implementation.\n         }\n \n         MockitoGenericMetadata mockitoGenericMetadata =\n-                actualParameterizedType(invocation.getMock()).resolveParameterizedType(genericReturnType);\n+                actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());\n \n-        return mock(\n-                mockitoGenericMetadata.rawType(),\n-                ((MockSettingsImpl) withSettings().defaultAnswer(this))\n-                        .withParameterizedInfo(mockitoGenericMetadata)\n-        );\n+        return mockitoGenericMetadata.toMock(this);\n+\n         // throw new MockitoException(\"[Work In Progress] Can't mock the return type : \" + genericReturnType);\n     }\n \n--- a/src/org/mockito/internal/util/reflection/MockitoGenericMetadata.java\n+++ b/src/org/mockito/internal/util/reflection/MockitoGenericMetadata.java\n \n \n import org.mockito.Incubating;\n+import org.mockito.Mockito;\n import org.mockito.exceptions.base.MockitoException;\n-\n-import java.lang.reflect.*;\n+import org.mockito.internal.creation.MockSettingsImpl;\n+import org.mockito.internal.util.Checks;\n+import org.mockito.internal.util.ConsoleMockitoLogger;\n+import org.mockito.internal.util.MockitoLogger;\n+import org.mockito.stubbing.Answer;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n import java.util.*;\n+\n+import static org.mockito.Mockito.withSettings;\n \n @Incubating\n public abstract class MockitoGenericMetadata {\n \n+    public static MockitoLogger logger = new ConsoleMockitoLogger();\n+\n     /**\n      * Represents actual type variables resolved for current class.\n      */\n     protected Map<TypeVariable, Type> contextualActualTypeParameters = new HashMap<TypeVariable, Type>();\n-\n-    private MockitoGenericMetadata() {\n-    }\n \n \n     protected void registerTypeVariablesOn(Type classType) {\n             Type actualTypeArgument = actualTypeArguments[i];\n \n             contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n-            GenericTypeInfo.logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n+            logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n         }\n     }\n \n     protected void registerTypeParametersOn(TypeVariable[] typeParameters) {\n         for (TypeVariable typeParameter : typeParameters) {\n             contextualActualTypeParameters.put(typeParameter, boundsOf(typeParameter));\n-            GenericTypeInfo.logger.log(\"For '\" + typeParameter.getGenericDeclaration() + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + boundsOf(typeParameter) + \"' }\");\n+            logger.log(\"For '\" + typeParameter.getGenericDeclaration() + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + boundsOf(typeParameter) + \"' }\");\n         }\n     }\n \n     private Type boundsOf(TypeVariable typeParameter) {\n+        if (typeParameter.getBounds()[0] instanceof TypeVariable) {\n+            return boundsOf((TypeVariable) typeParameter.getBounds()[0]);\n+        }\n         return new BoundedType(typeParameter);\n     }\n \n+\n+\n     /**\n      * @return Raw type of the current instance.\n      */\n     public abstract Class<?> rawType();\n+\n \n \n     /**\n             Type actualType = getActualTypeArgumentFor(typeParameter);\n \n             actualTypeArguments.put(typeParameter, actualType);\n-            GenericTypeInfo.logger.log(\"For '\" + rawType().getCanonicalName() + \"' returning explicit TypeVariable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualType +\"' }\");\n+            logger.log(\"For '\" + rawType().getCanonicalName() + \"' returning explicit TypeVariable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualType +\"' }\");\n         }\n \n         return actualTypeArguments;\n         return type;\n     }\n \n-    public MockitoGenericMetadata resolveParameterizedType(Type genericReturnType) {\n-        throw new UnsupportedOperationException(\"not implemented yet\");\n-    }\n+\n+\n+    /**\n+     * Creates a mock using the Generics Metadata represented by this instance.\n+     *\n+     * @param answer The answer to use in mock settings.\n+     * @return The mock.\n+     */\n+    public Object toMock(Answer answer) {\n+        return Mockito.mock(\n+                rawType(),\n+                ((MockSettingsImpl) withSettings().defaultAnswer(answer)).parameterizedInfo(this)\n+        );\n+    }\n+\n+\n \n     /**\n      * Resolve current method generic return type to a {@link MockitoGenericMetadata}.\n      */\n     public MockitoGenericMetadata resolveGenericReturnType(Method method) {\n         Type genericReturnType = method.getGenericReturnType();\n-        System.out.println(\"Method '\" + method.toGenericString() + \"' has return type : \" + genericReturnType.getClass().getInterfaces()[0].getSimpleName() + \" : \" + genericReturnType);\n+        logger.log(\"Method '\" + method.toGenericString() + \"' has return type : \" + genericReturnType.getClass().getInterfaces()[0].getSimpleName() + \" : \" + genericReturnType);\n \n         if (genericReturnType instanceof Class) {\n             return new NotGenericReturnType(genericReturnType);\n         if (genericReturnType instanceof TypeVariable) {\n             return new TypeVariableReturnType(this, method.getTypeParameters(), (TypeVariable) genericReturnType);\n         }\n+        if (genericReturnType instanceof BoundedType) {\n+            return new TypeVariableReturnType(this, method.getTypeParameters(), ((BoundedType) genericReturnType).typeVariable());\n+        }\n \n         throw new IllegalStateException(\"ouch\");\n     }\n \n     /**\n      * Create an new MockitoGenericMetadata from a {@link Type}.\n+     *\n+     * <p>\n+     *     Supports only {@link Class} and {@link ParameterizedType}, otherwise throw a {@link MockitoException}.\n+     * </p>\n      *\n      * @param type The class from which the {@link MockitoGenericMetadata} should be built.\n      * @return The new {@link MockitoGenericMetadata}.\n+     * @throws MockitoException Raised if type is not a {@link Class} or a {@link ParameterizedType}.\n      */\n     public static MockitoGenericMetadata from(Type type) {\n+        Checks.checkNotNull(type, \"type\");\n         if (type instanceof Class) {\n             return new FromClassMockitoGenericMetadata((Class<?>) type);\n         }\n         if (type instanceof ParameterizedType) {\n             return new FromParameterizedTypeMockitoGenericMetadata((ParameterizedType) type);\n         }\n+\n         throw new MockitoException(\"Type meta-data for this Type (\" + type.getClass().getCanonicalName() + \") is not supported : \" + type);\n     }\n \n \n+    /**\n+     * Metadata for source {@link Class}\n+     */\n     private static class FromClassMockitoGenericMetadata extends MockitoGenericMetadata {\n         private Class<?> clazz;\n \n     }\n \n \n-\n+    /**\n+     * Metadata for source {@link ParameterizedType}.\n+     * Don't work with ParameterizedType returned in {@link Method#getGenericReturnType()}.\n+     */\n     private static class FromParameterizedTypeMockitoGenericMetadata extends MockitoGenericMetadata {\n         private ParameterizedType parameterizedType;\n \n     }\n \n \n-\n+    /**\n+     * Metadata specific to {@link ParameterizedType} generic return types.\n+     */\n     private static class ParameterizedReturnType extends MockitoGenericMetadata {\n         private final ParameterizedType parameterizedType;\n         private final TypeVariable[] typeParameters;\n             this.typeParameters = typeParameters;\n             this.contextualActualTypeParameters = source.contextualActualTypeParameters;\n \n+            readTypeParameters();\n             readTypeVariables();\n+        }\n+\n+        private void readTypeParameters() {\n+            registerTypeParametersOn(typeParameters);\n         }\n \n         private void readTypeVariables() {\n         public Class<?> rawType() {\n             return (Class<?>) parameterizedType.getRawType();\n         }\n-    }\n-\n-\n-\n+\n+    }\n+\n+\n+    /**\n+     * Metadata specific to {@link TypeVariable} generic return type.\n+     */\n     private static class TypeVariableReturnType extends MockitoGenericMetadata {\n         private final TypeVariable typeVariable;\n         private final TypeVariable[] typeParameters;\n+        private Class<?> rawType;\n+\n \n \n         public TypeVariableReturnType(MockitoGenericMetadata source, TypeVariable[] typeParameters, TypeVariable typeVariable) {\n \n         @Override\n         public Class<?> rawType() {\n-            return extractRawTypeOf(typeVariable);\n+            if (rawType == null) {\n+                rawType = extractRawTypeOf(typeVariable);\n+            }\n+            return rawType;\n         }\n \n         private Class<?> extractRawTypeOf(Type type) {\n                 */\n                 return extractRawTypeOf(contextualActualTypeParameters.get(type));\n             }\n-            throw new MockitoException(\"Raw extraction not managed for : '\" + type + \"'\");\n+            throw new MockitoException(\"Raw extraction not supported for : '\" + type + \"'\");\n         }\n \n         @Override\n             if (type instanceof BoundedType) {\n                 return Arrays.asList(((BoundedType) type).interfaceBounds());\n             }\n+            if (type instanceof ParameterizedType) {\n+                return Collections.singletonList(type);\n+            }\n+            if (type instanceof Class) {\n+                return Collections.emptyList();\n+            }\n             throw new MockitoException(\"Cannot extract extra-interfaces from '\" + typeVariable + \"' : '\" + type + \"'\");\n+        }\n+\n+        private Class<?>[] rawExtraInterfaces() {\n+            List<Type> extraInterfaces = extraInterfaces();\n+            List<Class<?>> rawExtraInterfaces = new ArrayList<Class<?>>();\n+            for (Type extraInterface : extraInterfaces) {\n+                Class<?> rawInterface = extractRawTypeOf(extraInterface);\n+                // avoid interface collision with actual raw type (with typevariables, resolution ca be quite aggressive)\n+                if(!rawType().equals(rawInterface)) {\n+                    rawExtraInterfaces.add(rawInterface);\n+                }\n+            }\n+            return rawExtraInterfaces.toArray(new Class[rawExtraInterfaces.size()]);\n         }\n \n         private Type extractActualBoundedTypeOf(Type type) {\n             }\n             return type; // irrelevant, we don't manage other types.\n         }\n-    }\n-\n-\n-\n-    private static class MethodGenericReturnTypeMockitoGenericMetadata extends MockitoGenericMetadata {\n-\n-        private final TypeVariable<Method>[] typeParameters;\n-\n-        private final Type genericReturnType;\n-\n-        public MethodGenericReturnTypeMockitoGenericMetadata(MockitoGenericMetadata source, Method method) {\n-            genericReturnType = method.getGenericReturnType();\n-            typeParameters = method.getTypeParameters();\n-            this.contextualActualTypeParameters = source.contextualActualTypeParameters;\n-\n-            resolveActualMethodTypeParameter();\n-        }\n-\n-        private void resolveActualMethodTypeParameter() {\n-            if (genericReturnType instanceof TypeVariable) {\n-                TypeVariable typeVariable = (TypeVariable) genericReturnType;\n-                for (Type type : typeVariable.getBounds()) {\n-                    registerTypeVariablesOn(type);\n-                }\n-                registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n-            }\n-            if (genericReturnType instanceof ParameterizedType) {\n-                registerTypeVariablesOn(genericReturnType);\n-            }\n-\n-            // throw new MockitoException(\"genericReturnType is a '\" + genericReturnType.getClass() + \"' : \" + genericReturnType);\n-        }\n-\n-        @Override\n-        public Class<?> rawType() {\n-            if (genericReturnType instanceof TypeVariable) {\n-                Type actualTypeArgument = getActualTypeArgumentFor((TypeVariable) genericReturnType);\n-                return extractRawTypeOf(actualTypeArgument);\n-            }\n-            return extractRawTypeOf(genericReturnType);\n-        }\n-\n-        private Class<?> extractRawTypeOf(Type type) {\n-            if (type instanceof Class) {\n-                return (Class<?>) type;\n-            }\n-            if (type instanceof ParameterizedType) {\n-                return (Class<?>) ((ParameterizedType) type).getRawType();\n-            }\n-            if (type instanceof BoundedType) {\n-                return extractRawTypeOf(((BoundedType) type).firstBound());\n-            }\n-            throw new MockitoException(\"Raw extraction not managed for : '\" + type + \"'\");\n-        }\n-\n-\n-\n-    }\n-\n-\n-\n+\n+        public Object toMock(Answer answer) {\n+            Class<?>[] rawExtraInterfaces = rawExtraInterfaces();\n+            if (rawExtraInterfaces.length <= 0) {\n+                return super.toMock(answer);\n+            }\n+\n+            return Mockito.mock(\n+                    rawType(),\n+                    ((MockSettingsImpl) withSettings()\n+                            .defaultAnswer(answer)\n+                            .extraInterfaces(rawExtraInterfaces))\n+                            .parameterizedInfo(this)\n+            );\n+        }\n+    }\n+\n+\n+\n+    /**\n+     * Metadata specific to {@link Class} return type.\n+     */\n     private static class NotGenericReturnType extends MockitoGenericMetadata {\n-\n         private final Class<?> returnType;\n \n         public NotGenericReturnType(Type genericReturnType) {\n             returnType = (Class<?>) genericReturnType;\n         }\n+\n         @Override\n         public Class<?> rawType() {\n             return returnType;\n         }\n-\n+    }\n+\n+    /**\n+     * Type representing bounds of a type variable, allows to keep all bounds information.\n+     *\n+     * <p>It uses the first bound in the array, as this array is never null and always contains at least\n+     * one element (Object is always here if no bounds are declared).</p>\n+     *\n+     * <p>If upper bounds are declared with SomeClass and additional interfaces, then firstBound will be SomeClass and\n+     * interfacesBound will be an array of the additional interfaces.\n+     *\n+     * i.e. <code>SomeClass</code>.\n+     * <pre class=\"code\"><code class=\"java\">\n+     *     interface UpperBoundedTypeWithClass<E extends Comparable<E> & Cloneable> {\n+     *         E get();\n+     *     }\n+     *     // will return Comparable type\n+     * </code></pre>\n+     * </p>\n+     */\n+    public static class BoundedType implements Type {\n+        private TypeVariable typeVariable;\n+\n+\n+        public BoundedType(TypeVariable typeVariable) {\n+            this.typeVariable = typeVariable;\n+        }\n+\n+        /**\n+         * @return either a class or an interface (parameterized or not), if no bounds declared Object is returned.\n+         */\n+        public Type firstBound() {\n+            return typeVariable.getBounds()[0]; //\n+        }\n+\n+        /**\n+         * On a Type Variable (typeVar extends AClass_0 & I_1 & I_2 & etc), will return an array\n+         * containing I_1 and I_2.\n+         *\n+         * @return other bounds for this type, these bounds can only be only interfaces as the JLS says,\n+         * empty array if no other bound declared.\n+         */\n+        public Type[] interfaceBounds() {\n+            Type[] interfaceBounds = new Type[typeVariable.getBounds().length - 1];\n+            System.arraycopy(typeVariable.getBounds(), 1, interfaceBounds, 0, typeVariable.getBounds().length - 1);\n+            return interfaceBounds;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+\n+            return typeVariable.equals(((BoundedType) o).typeVariable);\n+\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return typeVariable.hashCode();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final StringBuilder sb = new StringBuilder();\n+            sb.append(\"{firstBound=\").append(firstBound());\n+            sb.append(\", interfaceBounds=\").append(Arrays.deepToString(interfaceBounds()));\n+            sb.append('}');\n+            return sb.toString();\n+        }\n+\n+        public TypeVariable typeVariable() {\n+            return typeVariable;\n+        }\n     }\n }\n+\n+\n--- a/test/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubsTest.java\n+++ b/test/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubsTest.java\n package org.mockito.internal.stubbing.defaultanswers;\n \n+import org.junit.Ignore;\n import org.junit.Test;\n \n import java.util.Iterator;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n import static org.mockito.Mockito.mock;\n \n+@SuppressWarnings(\"unused\")\n public class ReturnsDeepStubsTest {\n+    interface UpperBoundedTypeWithClass<E extends Number & Comparable<E>> {\n+        E get();\n+    }\n+    interface UpperBoundedTypeWithInterfaces<E extends Comparable<E> & Cloneable> {\n+        E get();\n+    }\n+    interface ListOfNumbers extends List<Number> {}\n+    interface ListOfAnyNumbers<N extends Number & Cloneable> extends List<N> {}\n \n-    interface MapWithNestedGenerics<K extends Comparable<K> & Cloneable> extends Map<K, Set<Number>> {}\n-\n+    interface GenericsNest<K extends Comparable<K> & Cloneable> extends Map<K, Set<Number>> {\n+        Set<Number> remove(Object key); // override with fixed ParameterizedType\n+        List<? super Number> returningWildcard();\n+        K returningK();\n+        <O extends K> List<O> paramTypeWithTypeParams();\n+        <S extends Appendable, T extends S> T twoTypeParams(S s);\n+        <O extends K> O typeVarWithTypeParams();\n+    }\n \n     @Test\n-    public void testName() throws Exception {\n-        MapWithNestedGenerics<?> mock = mock(MapWithNestedGenerics.class, RETURNS_DEEP_STUBS);\n+    public void returning_deep_stubs_1() throws Exception {\n+        GenericsNest<?> mock = mock(GenericsNest.class, RETURNS_DEEP_STUBS);\n \n         Set<? extends Map.Entry<? extends Cloneable, Set<Number>>> entries = mock.entrySet();\n         Iterator<? extends Map.Entry<? extends Cloneable,Set<Number>>> entriesIterator = mock.entrySet().iterator();\n         Number number = mock.entrySet().iterator().next().getValue().iterator().next();\n     }\n \n+    @Test\n+    public void returning_deep_stubs_2() throws Exception {\n+        GenericsNest<?> mock = mock(GenericsNest.class, RETURNS_DEEP_STUBS);\n \n+        Cloneable cloneable1 = mock.paramTypeWithTypeParams().get(0);\n+        Comparable<?> comparable1 = mock.paramTypeWithTypeParams().get(0);\n+        Cloneable cloneable2 = mock.returningK();\n+        Comparable<?> comparable2 = mock.returningK();\n+        Cloneable cloneable3 = (Cloneable) mock.typeVarWithTypeParams();\n+    }\n \n+    @Test\n+    @Ignore(\"TODO WildCard\")\n+    public void returning_deep_stubs_3() throws Exception {\n+        GenericsNest<?> mock = mock(GenericsNest.class, RETURNS_DEEP_STUBS);\n+\n+        List<? super Integer> objects = mock.returningWildcard();\n+        Number n = (Number) mock.returningWildcard().get(45);\n+    }\n+\n+    @Test(expected = ClassCastException.class)\n+    public void returning_deep_stub_dont_work_because_StringBuilder_is_subject_to_erasure() throws Exception {\n+        GenericsNest<?> mock = mock(GenericsNest.class, RETURNS_DEEP_STUBS);\n+\n+        StringBuilder stringBuilder = mock.twoTypeParams(new StringBuilder()).append(2).append(3); // ClassCastException\n+    }\n }\n--- a/test/org/mockito/internal/util/reflection/MockitoGenericMetadataTest.java\n+++ b/test/org/mockito/internal/util/reflection/MockitoGenericMetadataTest.java\n import java.lang.reflect.Method;\n import java.lang.reflect.Type;\n import java.lang.reflect.TypeVariable;\n-import java.util.*;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n \n import static org.fest.assertions.Assertions.assertThat;\n import static org.junit.Assert.fail;\n-import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n-import static org.mockito.Mockito.mock;\n import static org.mockito.internal.util.reflection.MockitoGenericMetadata.from;\n \n+@SuppressWarnings(\"unused\")\n public class MockitoGenericMetadataTest {\n \n     interface UpperBoundedTypeWithClass<E extends Number & Comparable<E>> {\n         List<? super Integer> returningWildcard();\n         K returningK();\n         <O extends K> List<O> paramTypeWithTypeParams();\n+        <S, T extends S> T twoTypeParams();\n         <O extends K> O typeVarWithTypeParams();\n     }\n \n         assertThat(from(ListOfAnyNumbers.class.getGenericInterfaces()[0]).rawType()).isEqualTo(List.class);\n         assertThat(from(ListOfNumbers.class.getGenericInterfaces()[0]).rawType()).isEqualTo(List.class);\n         assertThat(from(GenericsNest.class.getGenericInterfaces()[0]).rawType()).isEqualTo(Map.class);\n-    }\n-\n-    @Test\n-    @Ignore(\"not the right unit test\")\n-    public void returning_deep_stubs() throws Exception {\n-        GenericsNest<?> mock = mock(GenericsNest.class, RETURNS_DEEP_STUBS);\n-\n-        Set<? extends Map.Entry<? extends Cloneable, Set<Number>>> entries = mock.entrySet();\n-        Iterator<? extends Map.Entry<? extends Cloneable,Set<Number>>> entriesIterator = mock.entrySet().iterator();\n-        Map.Entry<? extends Cloneable, Set<Number>> nextEntry = mock.entrySet().iterator().next();\n-\n-        Cloneable cloneableKey = mock.entrySet().iterator().next().getKey();\n-        Comparable<?> comparableKey = mock.entrySet().iterator().next().getKey();\n-\n-        Set<Number> value = mock.entrySet().iterator().next().getValue();\n-        Iterator<Number> numbersIterator = mock.entrySet().iterator().next().getValue().iterator();\n-        Number number = mock.entrySet().iterator().next().getValue().iterator().next();\n     }\n \n     @Test\n         MockitoGenericMetadata genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returningK\", GenericsNest.class));\n \n         assertThat(genericMetadata.rawType()).isEqualTo(Comparable.class);\n-        MockitoGenericMetadata extraInterface1 = from(genericMetadata.extraInterfaces().get(0));\n-        assertThat(extraInterface1.rawType()).isEqualTo(Cloneable.class);\n+        MockitoGenericMetadata extraInterface_0 = from(genericMetadata.extraInterfaces().get(0));\n+        assertThat(extraInterface_0.rawType()).isEqualTo(Cloneable.class);\n     }\n \n     @Test\n     }\n \n     @Test\n-    public void paramType_with_wildcard_return_type_of___returningWildcard___resolved_to_List_and_type_argument_to_Integer() throws Exception {\n-        MockitoGenericMetadata genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returningWildcard\", GenericsNest.class));\n-\n-        fail(\"TODO\");\n-    }\n-\n-    @Test\n     public void paramType_with_type_parameters_return_type_of___paramTypeWithTypeParams___resolved_to_Collection_and_type_argument_to_Parameterized_Set() throws Exception {\n         MockitoGenericMetadata genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"paramTypeWithTypeParams\", GenericsNest.class));\n \n-        fail(\"TODO\");\n+        assertThat(genericMetadata.rawType()).isEqualTo(List.class);\n+        Type firstBoundOfE = ((MockitoGenericMetadata.BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), \"E\")).firstBound();\n+        assertThat(from(firstBoundOfE).rawType()).isEqualTo(Comparable.class);\n     }\n \n     @Test\n         assertThat(extraInterface_0.rawType()).isEqualTo(Cloneable.class);\n     }\n \n-\n     @Test\n     public void class_return_type_of___append___resolved_to_StringBuilder_and_type_arguments() throws Exception {\n         MockitoGenericMetadata genericMetadata = from(StringBuilder.class).resolveGenericReturnType(firstNamedMethod(\"append\", StringBuilder.class));\n \n         assertThat(genericMetadata.rawType()).isEqualTo(StringBuilder.class);\n         assertThat(genericMetadata.actualTypeArguments()).isEmpty();\n+    }\n+\n+    @Test\n+    @Ignore(\"TODO WildCard\")\n+    public void paramType_with_wildcard_return_type_of___returningWildcard___resolved_to_List_and_type_argument_to_Integer() throws Exception {\n+        MockitoGenericMetadata genericMetadata = from(GenericsNest.class).resolveGenericReturnType(firstNamedMethod(\"returningWildcard\", GenericsNest.class));\n+\n+        fail(\"TODO\");\n     }\n \n ", "timestamp": 1343148721, "metainfo": ""}