{"sha": "233dbd09317148177c7b3a56883a0e19c9e5b020", "log": "Renamed to be more precise  --HG-- rename : test/org/mockito/internal/verification/SyncingPrinterTest.java => test/org/mockito/internal/verification/SmartPrinterTest.java extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401465", "commit": "\n--- /dev/null\n+++ b/src/org/mockito/internal/verification/SmartPrinter.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification;\n+\n+import org.mockito.internal.invocation.PrintSettings;\n+import org.mockito.internal.invocation.PrintingFriendlyInocation;\n+\n+/**\n+ * Makes sure both wanted and actual are printed consistently (single line or multiline)\n+ * <p>\n+ * Makes arguments printed with types if necessary\n+ */\n+public class SmartPrinter {\n+\n+    private final String wanted;\n+    private final String actual;\n+\n+    public SmartPrinter(PrintingFriendlyInocation wanted, PrintingFriendlyInocation actual) {\n+        PrintSettings printSettings = new PrintSettings();\n+        printSettings.setMultiline(wanted.toString().contains(\"\\n\") || actual.toString().contains(\"\\n\"));\n+        printSettings.setVerboseArguments(wanted.toString().equals(actual.toString()));\n+        \n+        this.wanted = wanted.toString(printSettings);\n+        this.actual = actual.toString(printSettings);\n+    }\n+\n+    public String getWanted() {\n+        return wanted;\n+    }\n+\n+    public String getActual() {\n+        return actual;\n+    }\n+}\n--- a/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java\n+++ b/src/org/mockito/internal/verification/checkers/MissingInvocationChecker.java\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.invocation.InvocationsFinder;\n-import org.mockito.internal.verification.SyncingPrinter;\n+import org.mockito.internal.verification.SmartPrinter;\n \n public class MissingInvocationChecker {\n     \n         if (actualInvocations.isEmpty()) {\n             Invocation similar = finder.findSimilarInvocation(invocations, wanted);\n             if (similar != null) {\n-                SyncingPrinter syncingPrinter = new SyncingPrinter(wanted, similar);\n-                reporter.argumentsAreDifferent(syncingPrinter.getWanted(), syncingPrinter.getActual(), similar.getLocation());\n+                SmartPrinter smartPrinter = new SmartPrinter(wanted, similar);\n+                reporter.argumentsAreDifferent(smartPrinter.getWanted(), smartPrinter.getActual(), similar.getLocation());\n             } else {\n                 reporter.wantedButNotInvoked(wanted, invocations);\n             }\n--- /dev/null\n+++ b/test/org/mockito/internal/verification/SmartPrinterTest.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito.internal.verification;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.invocation.PrintingFriendlyInocation;\n+import org.mockitousage.IMethods;\n+import org.mockitoutil.TestBase;\n+\n+public class SmartPrinterTest extends TestBase {\n+\n+    private PrintingFriendlyInocation multi;\n+    private PrintingFriendlyInocation shortie;\n+    @Mock private IMethods mock;\n+\n+    @Before\n+    public void setup() throws Exception {\n+        mock.varargs(\"first very long argument\", \"second very long argument\", \"another very long argument\");\n+        multi = getLastInvocation();\n+        multi.toString();\n+        \n+        mock.varargs(\"short arg\");\n+        shortie = getLastInvocation();\n+    }\n+\n+    @Test\n+    public void shouldPrintBothInMultilinesWhenFirstIsMulti() {\n+        //when\n+        SmartPrinter printer = new SmartPrinter(multi, shortie);\n+        \n+        //then\n+        assertContains(\"\\n\", printer.getWanted().toString());\n+        assertContains(\"\\n\", printer.getActual().toString());\n+    }\n+\n+    @Test\n+    public void shouldPrintBothInMultilinesWhenSecondIsMulti() {\n+        //when\n+        SmartPrinter printer = new SmartPrinter(shortie, multi);\n+        \n+        //then\n+        assertContains(\"\\n\", printer.getWanted().toString());\n+        assertContains(\"\\n\", printer.getActual().toString());\n+    }\n+\n+    @Test\n+    public void shouldPrintBothInMultilinesWhenBothAreMulti() {\n+        //when\n+        SmartPrinter printer = new SmartPrinter(multi, multi);\n+        \n+        //then\n+        assertContains(\"\\n\", printer.getWanted().toString());\n+        assertContains(\"\\n\", printer.getActual().toString());\n+    }\n+\n+    @Test\n+    public void shouldPrintBothInSingleLineWhenBothAreShort() {\n+        //when\n+        SmartPrinter printer = new SmartPrinter(shortie, shortie);\n+        \n+        //then\n+        assertNotContains(\"\\n\", printer.getWanted().toString());\n+        assertNotContains(\"\\n\", printer.getActual().toString());\n+    }\n+    \n+    @Test\n+    public void shouldPrintVerboseArgumentsWhenStringOutputIsTheSame() {\n+        //given\n+        mock.longArg(1);\n+        Invocation withLongArg = getLastInvocation();\n+        \n+        mock.longArg(1);\n+        Invocation withIntArg = getLastInvocation();\n+        \n+        //when\n+        SmartPrinter printer = new SmartPrinter(withLongArg, withIntArg);\n+        \n+        //then\n+        assertContains(\"longArg((Long) 1)\", printer.getWanted().toString());\n+        assertContains(\"longArg((Long) 1)\", printer.getActual().toString());\n+    }\n+}", "timestamp": 1244232605, "metainfo": ""}