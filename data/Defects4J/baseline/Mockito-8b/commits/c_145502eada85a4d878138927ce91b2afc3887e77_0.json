{"sha": "145502eada85a4d878138927ce91b2afc3887e77", "log": "Trying an approach with a cutom ParamterizedType, with type parameters resolved (work in progress)  --HG-- branch : issue230", "commit": "\n--- /dev/null\n+++ b/src/org/mockito/internal/util/reflection/ClassEnhancedToParameterizedType.java\n+package org.mockito.internal.util.reflection;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+* Represents a class augmented to a Parameterized Type\n+*/\n+class ClassEnhancedToParameterizedType implements ParameterizedType {\n+    private Class<?> clazz;\n+\n+    /**\n+     * Represents actual type variables resolved for current class.\n+     */\n+    private Map<TypeVariable, Type> allActualTypeParameters = new HashMap<TypeVariable, Type>();\n+\n+    ClassEnhancedToParameterizedType(Class<?> clazz) {\n+        this.clazz = clazz;\n+        readActualTypeParametersOnDeclaringClass();\n+    }\n+\n+    private void readActualTypeParametersOnDeclaringClass() {\n+        registerTypeVariablesOn(clazz);\n+        registerTypeVariablesOn(clazz.getGenericSuperclass());\n+        for (Type genericInterface : clazz.getGenericInterfaces()) {\n+            registerTypeVariablesOn(genericInterface);\n+        }\n+    }\n+\n+    private void registerTypeVariablesOn(Type classType) {\n+        if (!(classType instanceof ParameterizedType)) {\n+            return;\n+        }\n+        ParameterizedType parameterizedType = (ParameterizedType) classType;\n+        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n+        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n+        for (int i = 0; i < actualTypeArguments.length; i++) {\n+            Type actualTypeArgument = actualTypeArguments[i];\n+            TypeVariable typeParameter = typeParameters[i];\n+\n+            allActualTypeParameters.put(typeParameter, actualTypeArgument);\n+            GenericTypeInfo.logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(in '\" + typeParameter.getGenericDeclaration() + \"')\" + \"' : '\" + actualTypeArgument + \"' }\");\n+        }\n+    }\n+\n+    private void registerTypeVariablesOn(Class<?> clazz) {\n+        TypeVariable[] typeParameters = clazz.getTypeParameters();\n+        for (TypeVariable typeParameter : typeParameters) {\n+            allActualTypeParameters.put(typeParameter, boundsOf(typeParameter));\n+            GenericTypeInfo.logger.log(\"For '\" + clazz.getCanonicalName() + \"' found type variable : { '\" + typeParameter + \"(in '\" + typeParameter.getGenericDeclaration() + \"')\" + \"' : '\" + boundsOf(typeParameter) + \"' }\");\n+        }\n+    }\n+\n+    private Type boundsOf(TypeVariable typeParameter) {\n+        return new GenericTypeInfo.TypeVariableUpperBounds(typeParameter);\n+    }\n+\n+\n+\n+    public Type[] getActualTypeArguments() {\n+\n+\n+        return new Type[0];  //To change body of implemented methods use File | Settings | File Templates.\n+    }\n+\n+    public Type getRawType() {\n+        return clazz;\n+    }\n+\n+    public Type getOwnerType() {\n+        // TODO\n+        return null;\n+    }\n+}\n--- a/src/org/mockito/internal/util/reflection/GenericTypeInfo.java\n+++ b/src/org/mockito/internal/util/reflection/GenericTypeInfo.java\n     /**\n      * The source class from which the generic info information should be retrieved.\n      */\n-    private final Class<?> onClass;\n+    private final Type clazz;\n \n     /**\n      * Represents resolved type variables on class.\n     private Map<TypeVariable, Type> typeVariables = new HashMap<TypeVariable, Type>();\n \n \n-    private GenericTypeInfo(Type typeToSolve, Class<?> onClass, Map<TypeVariable, Type> typeVariables) {\n+    private GenericTypeInfo(Type typeToSolve, Class<?> sourceType, Map<TypeVariable, Type> typeVariables) {\n         this.typeToSolve = typeToSolve;\n-        this.onClass = onClass;\n+        this.clazz = sourceType;\n         this.typeVariables = typeVariables;\n-        readActualTypeParametersOnDeclaringClass();\n+        throw new UnsupportedOperationException(\"code under (re)factoring\");\n     }\n \n     /**\n         return type; // irrelevant, we don't manage other types.\n     }\n \n-    private void readActualTypeParametersOnDeclaringClass() {\n-        registerTypeVariablesOn(onClass);\n-        registerTypeVariablesOn(onClass.getGenericSuperclass());\n-        for (Type genericInterface : onClass.getGenericInterfaces()) {\n-            registerTypeVariablesOn(genericInterface);\n-        }\n-    }\n-\n-    private void registerTypeVariablesOn(Type classType) {\n-        if (!(classType instanceof ParameterizedType)) {\n-            return;\n-        }\n-        ParameterizedType parameterizedType = (ParameterizedType) classType;\n-        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n-        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n-        for (int i = 0; i < actualTypeArguments.length; i++) {\n-            Type actualTypeArgument = actualTypeArguments[i];\n-            TypeVariable typeParameter = typeParameters[i];\n-\n-            typeVariables.put(typeParameter, actualTypeArgument);\n-            logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(in '\" + typeParameter.getGenericDeclaration() + \"')\" + \"' : '\" + actualTypeArgument + \"' }\");\n-        }\n-    }\n-\n-    private void registerTypeVariablesOn(Class<?> clazz) {\n-        TypeVariable[] typeParameters = clazz.getTypeParameters();\n-        for (TypeVariable typeParameter : typeParameters) {\n-            typeVariables.put(typeParameter, boundsOf(typeParameter));\n-            logger.log(\"For '\" + clazz.getCanonicalName() + \"' found type variable : { '\" + typeParameter + \"(in '\" + typeParameter.getGenericDeclaration() + \"')\" + \"' : '\" + boundsOf(typeParameter) + \"' }\");\n-        }\n-    }\n-\n-    private Type boundsOf(TypeVariable typeParameter) {\n-        return new TypeVariableUpperBounds(typeParameter.getBounds());\n-    }\n-\n \n     @Override\n     public String toString() {\n \n         GenericTypeInfo that = (GenericTypeInfo) o;\n \n-        return !(onClass != null ? !onClass.equals(that.onClass) : that.onClass != null) && typeToSolve.equals(that.typeToSolve);\n+        return !(clazz != null ? !clazz.equals(that.clazz) : that.clazz != null) && typeToSolve.equals(that.typeToSolve);\n     }\n \n     @Override\n     public int hashCode() {\n         int result = typeToSolve.hashCode();\n-        result = 31 * result + (onClass != null ? onClass.hashCode() : 0);\n+        result = 31 * result + (clazz != null ? clazz.hashCode() : 0);\n         return result;\n     }\n \n      * </p>\n      */\n     public static class TypeVariableUpperBounds implements Type {\n-        private final Type firstBound;\n-        private final Type[] interfaceBounds;\n-\n-\n-        public TypeVariableUpperBounds(Type[] bounds) {\n-            this.firstBound = bounds[0]; // either a class or an interface, always present\n-            this.interfaceBounds = new Type[bounds.length - 1]; // JLS says only interfaces from here\n-            System.arraycopy(bounds, 1, interfaceBounds, 0, bounds.length - 1);\n+        private TypeVariable typeVariable;\n+\n+\n+        public TypeVariableUpperBounds(TypeVariable typeVariable) {\n+            this.typeVariable = typeVariable;\n         }\n \n         public Type firstBound() {\n-            return firstBound;\n+            return typeVariable.getBounds()[0]; // either a class or an interface, always present\n         }\n \n         public Type[] interfaceBounds() {\n+            // JLS says only interfaces from here (typeVar extends AClass_0 & I_1 & I_2 & etc)\n+            Type[] interfaceBounds = new Type[typeVariable.getBounds().length - 1];\n+            System.arraycopy(typeVariable.getBounds(), 1, interfaceBounds, 0, typeVariable.getBounds().length - 1);\n             return interfaceBounds;\n         }\n \n         @Override\n         public String toString() {\n             final StringBuilder sb = new StringBuilder();\n-            sb.append(\"{firstBound=\").append(firstBound);\n-            sb.append(\", interfaceBounds=\").append(Arrays.deepToString(interfaceBounds));\n+            sb.append(\"{firstBound=\").append(firstBound());\n+            sb.append(\", interfaceBounds=\").append(Arrays.deepToString(interfaceBounds()));\n             sb.append('}');\n             return sb.toString();\n         }\n     }\n \n \n+    public static ParameterizedType asParameterizedType(Class<?> clazz) {\n+        return new ClassEnhancedToParameterizedType(clazz);\n+    }\n \n     @Incubating\n     public static Builder on(Class<?> clazz) {\n             return new GenericTypeInfo(genericReturnType, clazz, typeVariables);\n         }\n     }\n-\n-\n }\n--- /dev/null\n+++ b/test/org/mockito/internal/util/reflection/ClassEnhancedToParameterizedTypeTest.java\n+package org.mockito.internal.util.reflection;\n+\n+import org.junit.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+\n+public class ClassEnhancedToParameterizedTypeTest {\n+\n+    interface UpperBoundedTypeWithClass<E extends Number & Comparable<E>> {\n+        E get();\n+    }\n+    interface UpperBoundedTypeWithInterfaces<E extends Comparable<E> & Cloneable> {\n+        E get();\n+    }\n+    interface ListOfNumbers extends List<Number> {}\n+    interface ListOfAnyNumbers<N extends Number & Cloneable> extends List<N> {}\n+\n+    interface MapWithNestedGenerics<K extends Comparable<K> & Cloneable> extends Map<K, Set<Number>> {}\n+\n+    @Test\n+    public void can_get_raw_type() throws Exception {\n+        assertThat(new ClassEnhancedToParameterizedType(ListOfAnyNumbers.class).getRawType()).isEqualTo(ListOfAnyNumbers.class);\n+        assertThat(new ClassEnhancedToParameterizedType(ListOfNumbers.class).getRawType()).isEqualTo(ListOfNumbers.class);\n+        assertThat(new ClassEnhancedToParameterizedType(MapWithNestedGenerics.class).getRawType()).isEqualTo(MapWithNestedGenerics.class);\n+    }\n+\n+    @Test\n+    public void can_read_actual_type_parameters() throws Exception {\n+        // interface MapWithNestedGenerics<K extends Comparable<K> & Cloneable> extends Map<K, Set<Number>> {}\n+        // => [0] K = Comparable<K> & Cloneable\n+        // => [1] V = Set<Number>\n+\n+\n+\n+    }\n+}", "timestamp": 1342800029, "metainfo": ""}