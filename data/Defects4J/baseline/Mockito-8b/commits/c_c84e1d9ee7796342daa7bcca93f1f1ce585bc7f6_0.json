{"sha": "c84e1d9ee7796342daa7bcca93f1f1ce585bc7f6", "log": "enabled stubbing toString() - can be used for debugging purposes. externalized empty return values a bit - first step in refactoring towards more configurability  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%40488", "commit": "\n--- /dev/null\n+++ b/src/org/mockito/EmptyValuesProvider.java\n+package org.mockito;\n+\n+import org.mockito.internal.creation.MockNamer;\n+import org.mockito.internal.invocation.Invocation;\n+import org.mockito.internal.stubbing.EmptyReturnValues;\n+\n+public class EmptyValuesProvider {\n+    \n+    public <T> Object valueFor(Invocation invocation) {\n+        if (invocation.isToString()) {\n+            Object mock = invocation.getMock();\n+            String mockDescription = \"Mock for \" + MockNamer.nameForMock(mock) + \", hashCode: \" + mock.hashCode();\n+            return mockDescription;\n+        }\n+        \n+        Class<?> returnType = invocation.getMethod().getReturnType();\n+        return EmptyReturnValues.emptyValueFor(returnType);\n+    }\n+}\n--- /dev/null\n+++ b/src/org/mockito/MockitoConfiguration.java\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n+package org.mockito;\n+\n+public class MockitoConfiguration {\n+    \n+    private static EmptyValuesProvider emptyValuesProvider = new EmptyValuesProvider();\n+\n+    public static EmptyValuesProvider emptyValues() {\n+        return emptyValuesProvider;\n+    }\n+}\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n \n import net.sf.cglib.proxy.MethodProxy;\n \n+import org.mockito.MockitoConfiguration;\n import org.mockito.internal.creation.MockAwareInterceptor;\n import org.mockito.internal.invocation.Invocation;\n import org.mockito.internal.invocation.InvocationMatcher;\n import org.mockito.internal.progress.MockingProgress;\n import org.mockito.internal.progress.OngoingStubbing;\n import org.mockito.internal.progress.VerificationModeImpl;\n-import org.mockito.internal.stubbing.EmptyReturnValues;\n import org.mockito.internal.stubbing.StubbedMethodSelector;\n import org.mockito.internal.stubbing.Stubber;\n import org.mockito.internal.stubbing.VoidMethodStubbable;\n+import org.mockito.internal.verification.MissingInvocationInOrderVerifier;\n import org.mockito.internal.verification.MissingInvocationVerifier;\n import org.mockito.internal.verification.NoMoreInvocationsVerifier;\n+import org.mockito.internal.verification.NumberOfInvocationsInOrderVerifier;\n import org.mockito.internal.verification.NumberOfInvocationsVerifier;\n-import org.mockito.internal.verification.MissingInvocationInOrderVerifier;\n-import org.mockito.internal.verification.NumberOfInvocationsInOrderVerifier;\n import org.mockito.internal.verification.Verifier;\n import org.mockito.internal.verification.VerifyingRecorder;\n \n         \n         if (verificationMode != null) {\n             verifyingRecorder.verify(invocationMatcher, verificationMode);\n-            return EmptyReturnValues.emptyValueFor(method.getReturnType());\n-        } \n+            return MockitoConfiguration.emptyValues().valueFor(invocationMatcher.getInvocation());\n+        }\n         \n         stubber.setInvocationForPotentialStubbing(invocationMatcher);\n         verifyingRecorder.recordInvocation(invocationMatcher.getInvocation());\n--- a/src/org/mockito/internal/creation/MethodInterceptorFilter.java\n+++ b/src/org/mockito/internal/creation/MethodInterceptorFilter.java\n     \n     private final Method equalsMethod;\n     private final Method hashCodeMethod;\n-    private final Method toStringMethod;\n \n     private final T delegate;\n \n             }\n             equalsMethod = toMock.getMethod(\"equals\", new Class[] { Object.class });\n             hashCodeMethod = toMock.getMethod(\"hashCode\", (Class[]) null);\n-            toStringMethod = toMock.getMethod(\"toString\", (Class[]) null);\n         } catch (NoSuchMethodException e) {\n             throw new RuntimeException(\"An Object method could not be found!\");\n         }\n             return Boolean.valueOf(proxy == args[0]);\n         } else if (hashCodeMethod.equals(method)) {\n             return hashCodeForMock(proxy);\n-        } else if (toStringMethod.equals(method)) {\n-            return stringForMock(proxy);\n         }\n         \n         return delegate.intercept(proxy, method, args, null);\n \n     private int hashCodeForMock(Object mock) {\n         return new Integer(System.identityHashCode(mock));\n-    }\n-\n-    private String stringForMock(Object mock) {\n-        return \"Mock for \" + MockNamer.nameForMock(mock) + \", hashCode: \" + hashCodeForMock(mock);\n     }\n \n     public T getDelegate() {\n--- a/src/org/mockito/internal/invocation/Invocation.java\n+++ b/src/org/mockito/internal/invocation/Invocation.java\n         }\n         return matchers;\n     }\n+\n+    public boolean isToString() {\n+        return method.getReturnType() == String.class && method.getParameterTypes().length == 0 && method.getName().equals(\"toString\");\n+    }\n }\n--- a/src/org/mockito/internal/stubbing/Stubber.java\n+++ b/src/org/mockito/internal/stubbing/Stubber.java\n \n import java.util.LinkedList;\n \n+import org.mockito.MockitoConfiguration;\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.StackTraceFilter;\n import org.mockito.internal.invocation.Invocation;\n         stubbed.addFirst(new StubbedInvocationMatcher(invocationForStubbing, result));\n     }\n \n-    public Object resultFor(Invocation wanted) throws Throwable {\n+    public Object resultFor(Invocation invocation) throws Throwable {\n         for (StubbedInvocationMatcher s : stubbed) {\n-            if (s.matches(wanted)) {\n+            if (s.matches(invocation)) {\n                 return s.answer();\n             }\n         }\n-\n-        return EmptyReturnValues.emptyValueFor(wanted.getMethod().getReturnType());\n+        return MockitoConfiguration.emptyValues().valueFor(invocation);\n     }\n \n     public void addThrowableForVoidMethod(Throwable throwable) {\n--- a/src/org/mockito/internal/verification/VerifyingRecorder.java\n+++ b/src/org/mockito/internal/verification/VerifyingRecorder.java\n     }\n \n     public void recordInvocation(Invocation invocation) {\n-        this.registeredInvocations.add(invocation);\n+        //TODO\n+        if (!invocation.isToString()) {\n+            this.registeredInvocations.add(invocation);\n+        }\n     }\n \n     public void eraseLastInvocation() {\n--- a/test/org/mockitousage/InvalidStateDetectionTest.java\n+++ b/test/org/mockitousage/InvalidStateDetectionTest.java\n     \n     private static class OnStub implements DetectsInvalidState {\n         public void detect(IMethods mock) {\n-            stub(mock.toString());\n+            stub(mock);\n         }\n     }\n     ", "timestamp": 1206231789, "metainfo": ""}