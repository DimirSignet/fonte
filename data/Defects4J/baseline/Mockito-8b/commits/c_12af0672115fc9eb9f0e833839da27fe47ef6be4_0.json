{"sha": "12af0672115fc9eb9f0e833839da27fe47ef6be4", "log": "refactored some stuff, added feature of mixing strict verifying and ordinary verifying  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%4079", "commit": "\n--- a/src/org/mockito/internal/Invocation.java\n+++ b/src/org/mockito/internal/Invocation.java\n     private final Object mock;\n     private final Method method;\n     private final Object[] arguments;\n+\n+    private boolean verifiedInOrder;\n \n     public Invocation(Object mock, Method method, Object[] args, int sequenceNumber) {\n         this.mock = mock;\n     public Integer getSequenceNumber() {\n         return sequenceNumber;\n     }\n+\n+    public void markVerifiedInOrder() {\n+        this.verifiedInOrder = true;\n+        \n+    }\n+\n+    public boolean isVerifiedInOrder() {\n+        return verifiedInOrder;\n+    }\n }\n--- a/src/org/mockito/internal/InvocationChunk.java\n+++ b/src/org/mockito/internal/InvocationChunk.java\n \n     public void markAllInvocationsAsVerified() {\n         for (Invocation invocation : invocations) {\n+            invocation.markVerifiedInOrder();\n             invocation.markVerified();\n         }\n     }\n--- a/src/org/mockito/internal/MockitoBehavior.java\n+++ b/src/org/mockito/internal/MockitoBehavior.java\n     private void reportMissingInvocationError(ExpectedInvocation invocation) throws VerificationAssertionError {\n         //TODO refactor message building somewhere else...\n         Invocation similarInvocation = registeredInvocations.findSimilarInvocation(invocation);\n-        String message = \n-            \"\\n\" +\n-            \"Invocation differs from actual\" +\n-            \"\\n\";\n         \n+        String message = null;\n         String expected = invocation.toString();\n         if (similarInvocation != null) {\n             String actual = similarInvocation.toString();\n                 actual = similarInvocation.toStringWithArgumentTypes();\n             }\n             \n-            message += \n+            message = \n+                    \"\\n\" +\n+                    \"Invocation differs from actual\" +\n+                    \"\\n\" +\n                     \"Expected: \" + expected +\n                     \"\\n\" +\n             \t\t\"Actual:   \" + actual;\n     }\n     \n     private void verifyNoMoreInteractions(String verificationErrorMessage) {\n-        for (Invocation registeredInvocation : registeredInvocations.all()) {\n-            if (!registeredInvocation.isVerified()) {\n-                String mockName = Namer.nameForMock(mock);\n-                throw new VerificationAssertionError(\n-                        \"\\n\" +\n-                        verificationErrorMessage + \" on \" + mockName +\n-                        \"\\n\" +\n-                        \"Unexpected: \" + registeredInvocation.toString());\n-            }\n+        Invocation unverified = registeredInvocations.getFirstUnverified();\n+        if (unverified != null) {\n+            String mockName = Namer.nameForMock(mock);\n+            throw new VerificationAssertionError(\n+                    \"\\n\" +\n+                    verificationErrorMessage + \" on \" + mockName +\n+                    \"\\n\" +\n+                    \"Unexpected: \" + unverified.toString());\n         }\n     }\n \n--- a/src/org/mockito/internal/RegisteredInvocations.java\n+++ b/src/org/mockito/internal/RegisteredInvocations.java\n         \n         List<InvocationChunk> chunks = new LinkedList<InvocationChunk>();\n         for (Invocation i : allInvocationsInOrder) {\n-            if (i.isVerified()) {\n+            if (i.isVerifiedInOrder()) {\n                 continue;\n             }\n             if (!chunks.isEmpty() \n         return chunks;\n     }\n     \n-    /**\n-     * gets first registered invocation with the same method name\n-     * or just first invocation\n-     */\n     public Invocation findSimilarInvocation(ExpectedInvocation expectedInvocation) {\n         for (Invocation registered : registeredInvocations) {\n             String expectedMethodName = expectedInvocation.getMethod().getName();\n     public List<Invocation> all() {\n         return registeredInvocations;\n     }\n+\n+    public Invocation getFirstUnverified() {\n+        for (Invocation registered : registeredInvocations) {\n+            if (!registered.isVerified()) {\n+                return registered;\n+            }\n+        }\n+        return null;\n+    }\n }\n--- /dev/null\n+++ b/test/org/mockito/internal/InvocationBuilder.java\n+package org.mockito.internal;\n+\n+import java.lang.reflect.Method;\n+\n+import org.mockito.usage.IMethods;\n+\n+public class InvocationBuilder {\n+\n+    private String methodName = \"simpleMethod\";\n+    private int sequenceNumber = 0;\n+\n+    public Invocation toInvocation() {\n+        Method method;\n+        try {\n+            method = IMethods.class.getMethod(methodName, new Class[] {});\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+        Invocation i = new Invocation(\"mock\", method, new Object[] {}, sequenceNumber);\n+        return i;\n+    }\n+\n+    public InvocationBuilder m(String methodName) {\n+        this.methodName  = methodName;\n+        return this;\n+    }\n+\n+    public InvocationBuilder s(int sequenceNumber) {\n+        this.sequenceNumber = sequenceNumber;\n+        return this;\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/InvocationChunkTest.java\n+package org.mockito.internal;\n+\n+import org.junit.Test;\n+import static org.junit.Assert.*;\n+\n+public class InvocationChunkTest {\n+\n+    @Test\n+    public void shouldMarkAllAsVerified() throws Exception {\n+        Invocation i = new InvocationBuilder().toInvocation();\n+        Invocation i2 = new InvocationBuilder().toInvocation();\n+        \n+        InvocationChunk chunk = new InvocationChunk(i);\n+        chunk.add(i2);\n+        \n+        chunk.markAllInvocationsAsVerified();\n+        \n+        assertTrue(i.isVerified());\n+        assertTrue(i.isVerifiedInOrder());\n+        \n+        assertTrue(i2.isVerified());\n+        assertTrue(i2.isVerifiedInOrder());\n+    }\n+}\n--- a/test/org/mockito/internal/RegisteredInvocationsTest.java\n+++ b/test/org/mockito/internal/RegisteredInvocationsTest.java\n  */\n package org.mockito.internal;\n \n+import static java.util.Arrays.asList;\n+import static java.util.Collections.EMPTY_LIST;\n import static org.junit.Assert.*;\n \n-import java.lang.reflect.Method;\n import java.util.*;\n-\n-import static java.util.Collections.*;\n-import static java.util.Arrays.*;\n \n import org.junit.*;\n \n public class RegisteredInvocationsTest {\n \n     private RegisteredInvocations registered;\n-    private Invocation toLowerCaseInvocation;\n-    private Invocation toUpperCaseInvocation;\n-    private Invocation toLowerCaseInvocationTwo;\n-    private Invocation toLowerCaseInvocationThree;\n+    private Invocation simpleMethodInvocation;\n+    private Invocation simpleMethodInvocationTwo;\n+    private Invocation differentMethodInvocation;\n+    private Invocation simpleMethodInvocationThree;\n \n     @Before\n     public void setup() throws Exception {\n-        Method toLowerCase = String.class.getMethod(\"toLowerCase\", new Class[] {});\n-        Method toUpperCase = String.class.getMethod(\"toUpperCase\", new Class[] {});\n-        \n-        toLowerCaseInvocation = new Invocation(\"mock\", toLowerCase , new Object[] {}, 1);\n-        toLowerCaseInvocationTwo = new Invocation(\"mock\", toLowerCase , new Object[] {}, 2);\n-        toUpperCaseInvocation = new Invocation(\"mock\", toUpperCase , new Object[] {}, 3);\n-        toLowerCaseInvocationThree = new Invocation(\"mock\", toLowerCase , new Object[] {}, 4);\n+        simpleMethodInvocation = new InvocationBuilder().m(\"simpleMethod\").s(1).toInvocation();\n+        simpleMethodInvocationTwo = new InvocationBuilder().m(\"simpleMethod\").s(2).toInvocation();\n+        differentMethodInvocation = new InvocationBuilder().m(\"differentMethod\").s(3).toInvocation();\n+        simpleMethodInvocationThree = new InvocationBuilder().m(\"simpleMethod\").s(4).toInvocation();\n         \n         registered = new RegisteredInvocations(new InvocationsFinder() {\n             public List<Invocation> allInvocationsInOrder(List<Object> mocks) {\n-                return Arrays.asList(toLowerCaseInvocation, toLowerCaseInvocationTwo, toUpperCaseInvocation, toLowerCaseInvocationThree) ;\n+                return Arrays.asList(simpleMethodInvocation, simpleMethodInvocationTwo, differentMethodInvocation, simpleMethodInvocationThree) ;\n             }});\n         \n-        registered.add(toLowerCaseInvocation);\n-        registered.add(toLowerCaseInvocationTwo);\n-        registered.add(toUpperCaseInvocation);\n-        registered.add(toLowerCaseInvocationThree);\n+        registered.add(simpleMethodInvocation);\n+        registered.add(simpleMethodInvocationTwo);\n+        registered.add(differentMethodInvocation);\n+        registered.add(simpleMethodInvocationThree);\n     }\n \n     @Test\n         \n         InvocationChunk firstChunk = chunks.get(0);\n         assertEquals(2, firstChunk.getCount());\n-        assertEquals(toLowerCaseInvocation, firstChunk.getInvocation());\n-        assertEquals(toLowerCaseInvocationTwo, firstChunk.getInvocation());\n+        assertEquals(simpleMethodInvocation, firstChunk.getInvocation());\n+        assertEquals(simpleMethodInvocationTwo, firstChunk.getInvocation());\n         \n         InvocationChunk secondChunk = chunks.get(1);\n         assertEquals(1, secondChunk.getCount());\n-        assertEquals(toUpperCaseInvocation, secondChunk.getInvocation());\n+        assertEquals(differentMethodInvocation, secondChunk.getInvocation());\n         \n         InvocationChunk thirdChunk = chunks.get(2);\n         assertEquals(1, thirdChunk.getCount());\n-        assertEquals(toLowerCaseInvocationThree, thirdChunk.getInvocation());\n+        assertEquals(simpleMethodInvocationThree, thirdChunk.getInvocation());\n     }\n     \n     @Test\n     public void shouldGetTwoUnverifiedInvocationChunks() throws Exception {\n         Object mock = new Object();\n         \n-        registered.markInvocationsAsVerified(new ExpectedInvocation(toLowerCaseInvocation, EMPTY_LIST), VerifyingMode.inOrder(null, asList(mock)));\n+        registered.markInvocationsAsVerified(new ExpectedInvocation(simpleMethodInvocation, EMPTY_LIST), VerifyingMode.inOrder(null, asList(mock)));\n         \n         List<InvocationChunk> chunks = registered.unverifiedInvocationChunks(VerifyingMode.inOrder(null, asList(mock)));\n         \n         \n         InvocationChunk firstChunk = chunks.get(0);\n         assertEquals(1, firstChunk.getCount());\n-        assertEquals(toUpperCaseInvocation, firstChunk.getInvocation());\n+        assertEquals(differentMethodInvocation, firstChunk.getInvocation());\n         \n         InvocationChunk secondChunk = chunks.get(1);\n         assertEquals(1, secondChunk.getCount());\n-        assertEquals(toLowerCaseInvocationThree, secondChunk.getInvocation());\n+        assertEquals(simpleMethodInvocationThree, secondChunk.getInvocation());\n     }\n     \n     @Test\n     public void shouldGetOneUnverifiedInvocationChunk() throws Exception {\n         Object mock = new Object();\n         \n-        registered.markInvocationsAsVerified(new ExpectedInvocation(toLowerCaseInvocation, EMPTY_LIST), VerifyingMode.inOrder(null, asList(mock)));\n-        registered.markInvocationsAsVerified(new ExpectedInvocation(toUpperCaseInvocation, EMPTY_LIST), VerifyingMode.inOrder(null, asList(mock)));\n+        registered.markInvocationsAsVerified(new ExpectedInvocation(simpleMethodInvocation, EMPTY_LIST), VerifyingMode.inOrder(null, asList(mock)));\n+        registered.markInvocationsAsVerified(new ExpectedInvocation(differentMethodInvocation, EMPTY_LIST), VerifyingMode.inOrder(null, asList(mock)));\n         \n         List<InvocationChunk> chunks = registered.unverifiedInvocationChunks(VerifyingMode.inOrder(null, asList(mock)));\n         \n         \n         InvocationChunk firstChunk = chunks.get(0);\n         assertEquals(1, firstChunk.getCount());\n-        assertEquals(toLowerCaseInvocationThree, firstChunk.getInvocation());\n+        assertEquals(simpleMethodInvocationThree, firstChunk.getInvocation());\n     }\n     \n     @Test\n     public void shouldNotGetAnyInvocationChunks() throws Exception {\n         Object mock = new Object();\n         \n-        registered.markInvocationsAsVerified(new ExpectedInvocation(toLowerCaseInvocation, EMPTY_LIST), VerifyingMode.inOrder(null, asList(mock)));\n-        registered.markInvocationsAsVerified(new ExpectedInvocation(toUpperCaseInvocation, EMPTY_LIST), VerifyingMode.inOrder(null, asList(mock)));\n-        registered.markInvocationsAsVerified(new ExpectedInvocation(toLowerCaseInvocation, EMPTY_LIST), VerifyingMode.inOrder(null, asList(mock)));\n+        registered.markInvocationsAsVerified(new ExpectedInvocation(simpleMethodInvocation, EMPTY_LIST), VerifyingMode.inOrder(null, asList(mock)));\n+        registered.markInvocationsAsVerified(new ExpectedInvocation(differentMethodInvocation, EMPTY_LIST), VerifyingMode.inOrder(null, asList(mock)));\n+        registered.markInvocationsAsVerified(new ExpectedInvocation(simpleMethodInvocation, EMPTY_LIST), VerifyingMode.inOrder(null, asList(mock)));\n         \n         List<InvocationChunk> chunks = registered.unverifiedInvocationChunks(VerifyingMode.inOrder(null, asList(mock)));\n         \n     }\n     \n     @Test\n-    public void shouldMarkAllToLowerCaseAsVerified() throws Exception {\n-        registered.markInvocationsAsVerified(new ExpectedInvocation(toLowerCaseInvocation, EMPTY_LIST),VerifyingMode.times(2));\n+    public void shouldMarkAllsimpleMethodAsVerified() throws Exception {\n+        registered.markInvocationsAsVerified(new ExpectedInvocation(simpleMethodInvocation, EMPTY_LIST),VerifyingMode.times(2));\n         \n         List<Invocation> invocations = registered.all();\n         assertEquals(true, invocations.get(0).isVerified());\n     }\n     \n     @Test\n-    public void shouldMarkAllToLowerCaseAsVerifiedWhenAtLeastOnceIsUsed() throws Exception {\n-        registered.markInvocationsAsVerified(new ExpectedInvocation(toLowerCaseInvocation, EMPTY_LIST), VerifyingMode.atLeastOnce());\n+    public void shouldMarkAllsimpleMethodAsVerifiedWhenAtLeastOnceIsUsed() throws Exception {\n+        registered.markInvocationsAsVerified(new ExpectedInvocation(simpleMethodInvocation, EMPTY_LIST), VerifyingMode.atLeastOnce());\n         \n         List<Invocation> invocations = registered.all();\n         assertEquals(true, invocations.get(0).isVerified());\n     \n     @Test\n     public void shouldNeverMarkInvocationsAsVerifiedIfExpectedCountIsZero() throws Exception {\n-        registered.markInvocationsAsVerified(new ExpectedInvocation(toLowerCaseInvocation, EMPTY_LIST), VerifyingMode.times(0));\n+        registered.markInvocationsAsVerified(new ExpectedInvocation(simpleMethodInvocation, EMPTY_LIST), VerifyingMode.times(0));\n         \n         List<Invocation> invocations = registered.all();\n         assertEquals(false, invocations.get(0).isVerified());\n         \n         List<Invocation> invocations = registered.all();\n         assertEquals(true, invocations.get(0).isVerified());\n+        assertEquals(true, invocations.get(0).isVerifiedInOrder());\n         assertEquals(true, invocations.get(1).isVerified());\n+        assertEquals(true, invocations.get(1).isVerifiedInOrder());\n+        \n         assertEquals(false, invocations.get(2).isVerified());\n         assertEquals(false, invocations.get(3).isVerified());\n     }\n         \n         List<Invocation> invocations = registered.all();\n         assertEquals(true, invocations.get(2).isVerified());\n+        assertEquals(true, invocations.get(2).isVerifiedInOrder());\n+        \n         assertEquals(false, invocations.get(3).isVerified());\n     }\n     \n         \n         List<Invocation> invocations = registered.all();\n         assertEquals(true, invocations.get(3).isVerified());\n+        assertEquals(true, invocations.get(3).isVerifiedInOrder());\n     }\n     \n     @Test\n         registered.removeLast();\n         assertEquals(3, registered.all().size());\n     }\n+    \n+    @Test\n+    public void shouldGetFirstUnverifiedInvocation() throws Exception {\n+        assertSame(simpleMethodInvocation, registered.getFirstUnverified());\n+        \n+        registered.markInvocationsAsVerified(new ExpectedInvocation(simpleMethodInvocation, EMPTY_LIST), VerifyingMode.atLeastOnce());\n+        assertSame(differentMethodInvocation, registered.getFirstUnverified());\n+        \n+        registered.markInvocationsAsVerified(new ExpectedInvocation(differentMethodInvocation, EMPTY_LIST), VerifyingMode.atLeastOnce());\n+        assertNull(registered.getFirstUnverified());\n+    }\n }\n--- a/test/org/mockito/usage/IMethods.java\n+++ b/test/org/mockito/usage/IMethods.java\n     public String throwsError(int count) throws Error;\n \n     void simpleMethod();\n+    \n+    void differentMethod();\n \n     void simpleMethod(String argument);\n     \n--- a/test/org/mockito/usage/verification/VerificationInOrderMixedWithOrdiraryVerificationTest.java\n+++ b/test/org/mockito/usage/verification/VerificationInOrderMixedWithOrdiraryVerificationTest.java\n  */\n package org.mockito.usage.verification;\n \n-import static org.mockito.Mockito.mock;\n-\n-import java.util.*;\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n \n import org.junit.*;\n+import org.mockito.Strictly;\n+import org.mockito.exceptions.MockitoException;\n+import org.mockito.usage.IMethods;\n \n @SuppressWarnings(\"unchecked\")  \n public class VerificationInOrderMixedWithOrdiraryVerificationTest {\n     \n-    private LinkedList list;\n-    private HashMap map;\n-    private HashSet set;\n-//    private Strictly strictly;\n+    private IMethods mockOne;\n+    private IMethods mockTwo;\n+    private IMethods mockThree;\n+    private Strictly strictly;\n \n     @Before\n     public void setUp() {\n-        list = mock(LinkedList.class);\n-        map = mock(HashMap.class);\n-        set = mock(HashSet.class);\n+        mockOne = mock(IMethods.class);\n+        mockTwo = mock(IMethods.class);\n+        mockThree = mock(IMethods.class);\n \n-        list.add(\"one\");\n-        map.put(\"two\", \"two\");\n-        list.add(\"three and four\");\n-        list.add(\"three and four\");\n-        map.put(\"five\", \"five\");\n-        set.add(\"six\");\n-        \n-//        strictly = strictOrderVerifier(list, map, set);\n+        mockOne.simpleMethod(1);\n+        mockOne.simpleMethod(1);\n+        mockTwo.simpleMethod(2);\n+        mockThree.simpleMethod(3);\n+        mockThree.simpleMethod(4);\n+\n+        strictly = strictOrderVerifier(mockOne, mockThree);\n     }\n     \n     @Test\n-    public void shouldVerifyInOrder() {\n-\n+    public void shouldMixVerifyingInOrderAndNormalVerification() {\n+        verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        verify(mockTwo).simpleMethod(2);\n+        verify(mockThree).simpleMethod(3);\n+        verify(mockThree).simpleMethod(4);\n+        \n+        strictly.verify(mockOne, atLeastOnce()).simpleMethod(1);\n+        strictly.verify(mockThree).simpleMethod(3);\n+        strictly.verify(mockThree).simpleMethod(4);\n+        \n+        verifyNoMoreInteractions(mockOne, mockTwo, mockThree);\n+    }\n+    \n+    @Ignore\n+    @Test\n+    public void shouldScreamWhenNotStrictMockPassedToStrictly() {\n+        //TODO move to some nice messages exceptions test?\n+        try {\n+            strictly.verify(mockTwo, atLeastOnce()).simpleMethod(1);\n+            fail();\n+        } catch(MockitoException e) {\n+            String expected = \"some meaningful message\";\n+            assertEquals(expected, e.getMessage());\n+        }\n     } \n-    \n-    //TODO add some more testing about it... what about a case when verifier gets different mock (not strict)?\n-    \n }", "timestamp": 1196186466, "metainfo": ""}