{"sha": "93863606a5b4d3f496467cb9e62016cef354bb56", "log": "issue209 : @InjectMocks and @Spy annotated field initialization", "commit": "\n--- a/src/org/mockito/InjectMocks.java\n+++ b/src/org/mockito/InjectMocks.java\n  * <li>Minimizes repetitive mock and spy injection.</li>\n  * </ul>\n  * <p>\n- * Currently it only supports setter injection. If you prefer constructor injection - please contribute a patch.\n+ * Currently it only supports field injection. If you prefer constructor injection - please contribute a patch.\n+ * </p>\n+ *\n  * <p>\n  * Mockito tries to inject by type (using name in case types are the same). \n- * Mockito does not throw anything when injection fails - you will have to satisfy the dependencies manually.  \n+ * Mockito does not throw anything when injection fails - you will have to satisfy the dependencies manually.\n+ * </p>\n+ *\n  * <p>\n  * Example:\n  * <pre>\n  *   }\n  * </pre>\n  *\n- * <b>The field annotated with &#064;InjectMocks must be initialized.</b>\n+ * <b>The field annotated with &#064;InjectMocks can be initialized by Mockito if a zero argument constructor\n+ * can be found in the type (even private). <u>But Mockito cannot instantiate inner classes, local classes, \n+ * abstract classes and interfaces.</u></b>\n+ *\n+ * For example this class can be instantiated by Mockito :\n+ * <pre>public class Bar {\n+ *    private Bar() {}\n+ *    public Bar(String publicConstructorWithOneArg) {}\n+ * }</pre>\n+ * </p>\n+ *\n+ * </p>\n+ *\n+ * <p>\n+ * Note that &#064;InjectMocks is compatible with spies created using the &#64;Spy annotation.\n+ * </p>\n+ *\n  * <p>\n  * <b><code>MockitoAnnotations.injectMocks(this)</code></b> method has to called to initialize annotated objects.\n+ * <p>\n+ *\n  * <p>\n  * In above example, <code>injectMocks()</code> is called in &#064;Before (JUnit4) method of test's base class.\n  * For JUnit3 <code>injectMocks()</code> can go to <code>setup()</code> method of a base class.\n  * You can also put injectMocks() in your JUnit runner (&#064;RunWith) or use built-in runners: {@link org.mockito.runners.MockitoJUnitRunner}\n+ * </p>\n  */\n @Documented\n @Target( { FIELD })\n--- a/src/org/mockito/MockitoAnnotations.java\n+++ b/src/org/mockito/MockitoAnnotations.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito;\n-\n-import static java.lang.annotation.ElementType.*;\n-\n-import java.lang.annotation.Annotation;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n-import java.lang.reflect.Field;\n \n import org.mockito.configuration.AnnotationEngine;\n import org.mockito.configuration.DefaultMockitoConfiguration;\n import org.mockito.internal.configuration.GlobalConfiguration;\n import org.mockito.internal.util.reflection.FieldSetter;\n import org.mockito.runners.MockitoJUnitRunner;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.lang.reflect.Field;\n+\n+import static java.lang.annotation.ElementType.FIELD;\n \n /**\n  * MockitoAnnotations.initMocks(this); initializes fields annotated with Mockito annotations.\n             new Reporter().moreThanOneAnnotationNotAllowed(field.getName());\n         }\n     }\n-}\n+}\n--- a/src/org/mockito/Spy.java\n+++ b/src/org/mockito/Spy.java\n  * \n  * <pre>\n  * public class Test{\n- *    &#64;Spy Foo spyOnFoo = new Foo();\n+ *    &#64;Spy Foo spyOnFoo = new Foo(\"argument\");\n+ *    &#64;Spy Bar spyOnBar;\n  *    &#64;Before\n  *    public void init(){\n  *       MockitoAnnotations.initMocks(this);\n  * Same as doing:\n  * \n  * <pre>\n- * Foo spyOnFoo = Mockito.spy(new Foo());\n+ * Foo spyOnFoo = Mockito.spy(new Foo(\"argument\"));\n+ * Bar spyOnFoo = Mockito.spy(new Bar());\n  * </pre>\n+ *\n+ * <b>The field annotated with &#064;Spy can be initialized by Mockito if a zero argument constructor\n+ * can be found in the type (even private). <u>But Mockito cannot instantiate inner classes, local classes,\n+ * abstract classes and interfaces.</u></b>\n+ *\n+ * For example this class can be instantiated by Mockito :\n+ * <pre>public class Bar {\n+ *    private Bar() {}\n+ *    public Bar(String publicConstructorWithOneArg) {}\n+ * }</pre>\n+ * </p>\n  * \n+ * <p>\n  * <b>Warning</b> if you call <code>MockitoAnnotations.initMocks(this)</code> in a\n  * super class <b>constructor</b> then this will not work. It is because fields\n  * in subclass are only instantiated after super class constructor has returned.\n  * It's better to use &#64;Before.\n+ * </p>\n  */\n @Retention(RetentionPolicy.RUNTIME)\n @Target(ElementType.FIELD)\n--- a/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\n+++ b/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\n  */\n package org.mockito.internal.configuration;\n \n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.internal.util.MockUtil;\n+import org.mockito.internal.util.reflection.FieldInitializer;\n+import org.mockito.internal.util.reflection.FieldSetter;\n+\n import java.lang.reflect.Field;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.List;\n import java.util.Set;\n-\n-import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.util.MockUtil;\n-import org.mockito.internal.util.reflection.FieldSetter;\n \n /**\n  * Initializes mock/spies dependencies for fields annotated with &#064;InjectMocks\n     //   - else don't fail, user will then provide dependencies\n \tpublic void injectMocksOnFields(Set<Field> testClassFields, Set<Object> mocks, Object testClass) {\n         for (Field field : testClassFields) {\n-            Object fieldInstance = null;\n-            boolean wasAccessible = field.isAccessible();\n-            field.setAccessible(true);\n-            try {\n-                fieldInstance = field.get(testClass);\n-            } catch (IllegalAccessException e) {\n-                throw new MockitoException(\"Problems injecting dependencies in \" + field.getName(), e);\n-            } finally {\n-                field.setAccessible(wasAccessible);\n-            }\n+            Object fieldInstance = new FieldInitializer(testClass, field).initialize();\n \n             // for each field in the class hierarchy\n             Class<?> fieldClass = fieldInstance.getClass();\n         }\n     }\n \n-    private void inject(Field field, Object fieldInstance, Object matchingMock) {        \n+    private void inject(Field field, Object fieldInstance, Object matchingMock) {\n         try {\n-            new FieldSetter(fieldInstance, field).set(matchingMock);            \n+            new FieldSetter(fieldInstance, field).set(matchingMock);\n         } catch (Exception e) {\n             throw new MockitoException(\"Problems injecting dependency in \" + field.getName(), e);\n         }\n         }\n         return mockTypeMatches;\n     }\n+\n }\n--- a/src/org/mockito/internal/configuration/InjectingAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/InjectingAnnotationEngine.java\n  */\n package org.mockito.internal.configuration;\n \n+import org.mockito.*;\n+import org.mockito.configuration.AnnotationEngine;\n+import org.mockito.exceptions.Reporter;\n+import org.mockito.exceptions.base.MockitoException;\n+\n import java.lang.annotation.Annotation;\n import java.lang.reflect.Field;\n import java.util.HashSet;\n import java.util.Set;\n-\n-import org.mockito.Captor;\n-import org.mockito.InjectMocks;\n-import org.mockito.Mock;\n-import org.mockito.MockitoAnnotations;\n-import org.mockito.Spy;\n-import org.mockito.configuration.AnnotationEngine;\n-import org.mockito.exceptions.Reporter;\n-import org.mockito.exceptions.base.MockitoException;\n-import org.mockito.internal.util.reflection.FieldReader;\n \n /**\n  * See {@link MockitoAnnotations}\n         Field[] fields = clazz.getDeclaredFields();\n         for (Field field : fields) {\n             if (null != field.getAnnotation(InjectMocks.class)) {\n-                if(new FieldReader(testClass, field).isNull()) {\n+                /*if(new FieldReader(testClass, field).isNull()) {\n                     new Reporter().injectMockAnnotationFieldIsNull(field.getName());\n-                }\n+                }*/\n                 testedFields.add(field);\n             }\n         }\n         }\n         return mocks;\n     }\n-}\n+}\n--- a/src/org/mockito/internal/configuration/SpyAnnotationEngine.java\n+++ b/src/org/mockito/internal/configuration/SpyAnnotationEngine.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.internal.configuration;\n-\n-import java.lang.annotation.Annotation;\n-import java.lang.reflect.Field;\n \n import org.mockito.Captor;\n import org.mockito.Mock;\n import org.mockito.exceptions.Reporter;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.util.MockUtil;\n+import org.mockito.internal.util.reflection.FieldInitializer;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n \n import static org.mockito.Mockito.withSettings;\n \n                 boolean wasAccessible = field.isAccessible();\n                 field.setAccessible(true);\n                 try {\n-                    Object instance = field.get(testClass);\n+                    Object instance = new FieldInitializer(testClass, field).initialize();\n                     if (instance == null) {\n                         throw new MockitoException(\"Cannot create a @Spy for '\" + field.getName() + \"' field because the *instance* is missing\\n\" +\n                         \t\t  \"The instance must be created *before* initMocks();\\n\" +\n--- a/src/org/mockito/internal/util/reflection/AccessibilityChanger.java\n+++ b/src/org/mockito/internal/util/reflection/AccessibilityChanger.java\n  */\n package org.mockito.internal.util.reflection;\n \n-import java.lang.reflect.Field;\n+import java.lang.reflect.AccessibleObject;\n \n public class AccessibilityChanger {\n     \n     /**\n      * safely disables access\n      */\n-    public void safelyDisableAccess(Field field) {\n+    public void safelyDisableAccess(AccessibleObject accessibleObject) {\n         assert wasAccessible != null;\n         try {\n-            field.setAccessible(wasAccessible);\n+            accessibleObject.setAccessible(wasAccessible);\n         } catch (Throwable t) {\n             //ignore\n         }\n     }\n \n     /**\n-     * changes the field accessibility and returns true if accessibility was changed\n+     * changes the accessibleObject accessibility and returns true if accessibility was changed\n      */\n-    public void enableAccess(Field field) {\n-        wasAccessible = field.isAccessible();\n-        field.setAccessible(true);\n+    public void enableAccess(AccessibleObject accessibleObject) {\n+        wasAccessible = accessibleObject.isAccessible();\n+        accessibleObject.setAccessible(true);\n     }\n }\n--- /dev/null\n+++ b/src/org/mockito/internal/util/reflection/FieldInitializer.java\n+package org.mockito.internal.util.reflection;\n+\n+import org.mockito.exceptions.base.MockitoException;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Modifier;\n+\n+/**\n+ * Initialize a field with type instance if a default constructor can be found.\n+ *\n+ * <p>\n+ * If the given field is already initialize\n+ * This initializer doesn't work with inner classes, local classes, interfaces or abstract types.\n+ * </p>\n+ *\n+ */\n+public class FieldInitializer {\n+\n+    private Object testClass;\n+    private Field field;\n+\n+\n+    /**\n+     * Initialize the given field on the given instance.\n+     *\n+     * <p>\n+     * This constructor fail fast if the field type cannot be handled.\n+     * </p>\n+     *\n+     * @param testClass Instance of the test.\n+     * @param field Field to be initialize.\n+     */\n+    public FieldInitializer(Object testClass, Field field) {\n+        if(new FieldReader(testClass, field).isNull()) {\n+            checkNotLocal(field);\n+            checkNotInner(field);\n+            checkNotInterface(field);\n+            checkNotAbstract(field);\n+        }\n+        this.testClass = testClass;\n+        this.field = field;\n+    }\n+\n+    public Object initialize() {\n+        final AccessibilityChanger changer = new AccessibilityChanger();\n+        changer.enableAccess(field);\n+\n+        try {\n+            return acquireFieldInstance(testClass, field);\n+        } catch(IllegalAccessException e) {\n+            throw new MockitoException(\"Problems injecting dependencies in \" + field.getName(), e);\n+        } finally {\n+            changer.safelyDisableAccess(field);\n+        }\n+    }\n+\n+    private void initializeField(Object testClass, Field field) {\n+        final AccessibilityChanger changer = new AccessibilityChanger();\n+        Constructor<?> constructor = null;\n+        try {\n+            constructor = field.getType().getDeclaredConstructor();\n+            changer.enableAccess(constructor);\n+\n+            final Object[] noArg = new Object[0];\n+            Object newFieldInstance = constructor.newInstance(noArg);\n+            new FieldSetter(testClass, field).set(newFieldInstance);\n+        } catch (NoSuchMethodException e) {\n+            throw new MockitoException(\"Cannot instantiate field \\\"\" + field.getName() + \"\\\", the type \" + field.getType() + \" has no default constructor\", e);\n+        } catch (InvocationTargetException e) {\n+            throw new MockitoException(\"Cannot instantiate field \\\"\" + field.getName() + \"\\\", the default constructor of type \" + field.getType() + \" has raised an exception : \" + e.getTargetException().toString(), e);\n+        } catch (InstantiationException e) {\n+            throw new MockitoException(\"Unexpected InstantiationException for field : \\\"\" + field.getName() + \"\\\"\", e);\n+        } catch (IllegalAccessException e) {\n+            throw new MockitoException(\"Unexpected IllegalAccessException for field : \\\"\" + field.getName() + \"\\\"\", e);\n+        } finally {\n+            if(constructor != null) {\n+                changer.safelyDisableAccess(constructor);\n+            }\n+        }\n+    }\n+\n+    private void checkNotLocal(Field field) {\n+        if(field.getType().isLocalClass()) {\n+            throw new MockitoException(\"Cannot instantiate field \\\"\" + field.getName() + \"\\\", the type \" + field.getType() + \" is a local class\");\n+        }\n+    }\n+\n+    private void checkNotInner(Field field) {\n+        if(field.getType().isMemberClass() && !Modifier.isStatic(field.getType().getModifiers())) {\n+            throw new MockitoException(\"Cannot instantiate field \\\"\" + field.getName() + \"\\\", the type \" + field.getType() + \" is an inner class\");\n+        }\n+    }\n+\n+    private void checkNotInterface(Field field) {\n+        if(field.getType().isInterface()) {\n+            throw new MockitoException(\"Cannot instantiate field \\\"\" + field.getName() + \"\\\", the type \" + field.getType() + \" is an interface\");\n+        }\n+    }\n+\n+    private void checkNotAbstract(Field field) {\n+        if(Modifier.isAbstract(field.getType().getModifiers())) {\n+            throw new MockitoException(\"Cannot instantiate field \\\"\" + field.getName() + \"\\\", the type \" + field.getType() + \" is an inner class\");\n+        }\n+    }\n+\n+    private Object acquireFieldInstance(Object testClass, Field field) throws IllegalAccessException {\n+        Object fieldInstance = field.get(testClass);\n+        if(fieldInstance != null) {\n+            return fieldInstance;\n+        }\n+\n+        initializeField(testClass, field);\n+        return field.get(testClass);\n+    }\n+}\n--- /dev/null\n+++ b/test/org/mockito/internal/util/reflection/FieldInitializerTest.java\n+package org.mockito.internal.util.reflection;\n+\n+import org.junit.Test;\n+import org.mockito.InjectMocks;\n+import org.mockito.exceptions.base.MockitoException;\n+\n+import java.lang.reflect.InvocationTargetException;\n+\n+import static org.junit.Assert.*;\n+\n+public class FieldInitializerTest {\n+\n+    private StaticClass alreadyInstantiated = new StaticClass();\n+    private StaticClass noConstructor;\n+    private StaticClassWithDefaultConstructor defaultConstructor;\n+    private StaticClassWithPrivateDefaultConstructor privateDefaultConstructor;\n+    private StaticClassWithoutDefaultConstructor noDefaultConstructor;\n+    private StaticClassThrowingExceptionDefaultConstructor throwingExDefaultConstructor;\n+    private AbstractStaticClass abstractType;\n+    private Interface interfaceType;\n+    private InnerClassType innerClassType;\n+    private AbstractStaticClass instantiatedAbstractType = new ConcreteStaticClass();\n+    private Interface instantiatedInterfaceType =  new ConcreteStaticClass();\n+    private InnerClassType instantiatedInnerClassType = new InnerClassType();\n+\n+    @Test\n+    public void shouldKeepSameInstanceIfFieldInitialized() throws Exception {\n+        final StaticClass backupInstance = alreadyInstantiated;\n+        FieldInitializer fieldInitializer = new FieldInitializer(this, this.getClass().getDeclaredField(\"alreadyInstantiated\"));\n+        assertSame(backupInstance, fieldInitializer.initialize());\n+    }\n+\n+    @Test\n+    public void shouldInstantiateFieldWhenTypeHasNoConstructor() throws Exception {\n+        FieldInitializer fieldInitializer = new FieldInitializer(this, this.getClass().getDeclaredField(\"noConstructor\"));\n+        assertNotNull(fieldInitializer.initialize());\n+    }\n+\n+    @Test\n+    public void shouldInstantiateFieldWithDefaultConstructor() throws Exception {\n+        FieldInitializer fieldInitializer = new FieldInitializer(this, this.getClass().getDeclaredField(\"defaultConstructor\"));\n+        assertNotNull(fieldInitializer.initialize());\n+    }\n+\n+    @Test\n+    public void shouldInstantiateFieldWithPrivateDefaultConstructor() throws Exception {\n+        FieldInitializer fieldInitializer = new FieldInitializer(this, this.getClass().getDeclaredField(\"privateDefaultConstructor\"));\n+        assertNotNull(fieldInitializer.initialize());\n+    }\n+\n+    @Test(expected = MockitoException.class)\n+    public void shouldFailToInstantiateFieldIfNoDefaultConstructor() throws Exception {\n+        FieldInitializer fieldInitializer = new FieldInitializer(this, this.getClass().getDeclaredField(\"noDefaultConstructor\"));\n+        fieldInitializer.initialize();\n+    }\n+\n+    @Test\n+    public void shouldFailToInstantiateFieldIfDefaultConstructorThrowsException() throws Exception {\n+        FieldInitializer fieldInitializer = new FieldInitializer(this, this.getClass().getDeclaredField(\"throwingExDefaultConstructor\"));\n+        try {\n+            fieldInitializer.initialize();\n+            fail();\n+        } catch (MockitoException e) {\n+            InvocationTargetException ite = (InvocationTargetException) e.getCause();\n+            assertTrue(ite.getTargetException() instanceof NullPointerException);\n+            assertEquals(\"business logic failed\", ite.getTargetException().getMessage());\n+        }\n+    }\n+\n+    @Test(expected = MockitoException.class)\n+    public void shouldFailForAbstractField() throws Exception {\n+        new FieldInitializer(this, this.getClass().getDeclaredField(\"abstractType\"));\n+    }\n+\n+    public void shouldNotFailIfAbstractFieldIsInstantiated() throws Exception {\n+        new FieldInitializer(this, this.getClass().getDeclaredField(\"instantiatedAbstractType\"));\n+    }\n+\n+    @Test(expected = MockitoException.class)\n+    public void shouldFailForInterfaceField() throws Exception {\n+        new FieldInitializer(this, this.getClass().getDeclaredField(\"interfaceType\"));\n+    }\n+\n+    public void shouldNotFailIfInterfaceFieldIsInstantiated() throws Exception {\n+        new FieldInitializer(this, this.getClass().getDeclaredField(\"instantiatedInterfaceType\"));\n+    }\n+\n+    @Test(expected = MockitoException.class)\n+    public void shouldFailForLocalTypeField() throws Exception {\n+        // when\n+        class LocalType { };\n+\n+        class TheTestWithLocalType {\n+            @InjectMocks LocalType field;\n+        }\n+\n+        TheTestWithLocalType testWithLocalType = new TheTestWithLocalType();\n+\n+        // when\n+        new FieldInitializer(testWithLocalType, testWithLocalType.getClass().getDeclaredField(\"field\"));\n+    }\n+\n+    public void shouldNotFailIfLocalTypeFieldIsInstantiated() throws Exception {\n+        // when\n+        class LocalType { };\n+\n+        class TheTestWithLocalType {\n+            @InjectMocks LocalType field = new LocalType();\n+        }\n+\n+        TheTestWithLocalType testWithLocalType = new TheTestWithLocalType();\n+\n+        // when\n+        new FieldInitializer(testWithLocalType, testWithLocalType.getClass().getDeclaredField(\"field\"));\n+    }\n+\n+    @Test(expected = MockitoException.class)\n+    public void shouldFailForInnerClassField() throws Exception {\n+        new FieldInitializer(this, this.getClass().getDeclaredField(\"innerClassType\"));\n+    }\n+\n+    public void shouldNotFailIfInnerClassFieldIsInstantiated() throws Exception {\n+        new FieldInitializer(this, this.getClass().getDeclaredField(\"instantiatedInnerClassType\"));\n+    }\n+\n+    static class StaticClass {\n+    }\n+\n+    static class StaticClassWithDefaultConstructor {\n+        StaticClassWithDefaultConstructor() { }\n+    }\n+\n+    static class StaticClassWithPrivateDefaultConstructor {\n+        private StaticClassWithPrivateDefaultConstructor() { }\n+    }\n+\n+    static class StaticClassWithoutDefaultConstructor {\n+        private StaticClassWithoutDefaultConstructor(String param) { }\n+    }\n+\n+    static class StaticClassThrowingExceptionDefaultConstructor {\n+        StaticClassThrowingExceptionDefaultConstructor() throws Exception {\n+            throw new NullPointerException(\"business logic failed\");\n+        }\n+    }\n+    \n+    static abstract class AbstractStaticClass {\n+        public AbstractStaticClass() {}\n+    }\n+\n+    static interface Interface {\n+\n+    }\n+\n+    static class ConcreteStaticClass extends AbstractStaticClass implements Interface {\n+    }\n+\n+    class InnerClassType {\n+        InnerClassType() { }\n+    }\n+\n+}\n--- a/test/org/mockitousage/annotation/MockInjectionTest.java\n+++ b/test/org/mockitousage/annotation/MockInjectionTest.java\n import org.mockito.Mock;\n import org.mockito.MockitoAnnotations;\n import org.mockito.Spy;\n-import org.mockito.exceptions.base.MockitoException;\n import org.mockitoutil.TestBase;\n \n-import java.util.*;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n \n @SuppressWarnings({\"unchecked\", \"unused\"})\n public class MockInjectionTest extends TestBase {\n \t@InjectMocks private BaseUnderTesting baseUnderTest = new BaseUnderTesting();\n \t@InjectMocks private SubUnderTesting subUnderTest = new SubUnderTesting();\n \t@InjectMocks private OtherBaseUnderTesting otherBaseUnderTest = new OtherBaseUnderTesting();\n-\t@Mock private Map map;\t\n+\n+    private BaseUnderTesting baseUnderTestingInstance = new BaseUnderTesting();\n+    @InjectMocks private BaseUnderTesting initializedBase = baseUnderTestingInstance;\n+    @InjectMocks private BaseUnderTesting notInitializedBase;\n+\n+    @Spy @InjectMocks private SuperUnderTesting initializedSpy = new SuperUnderTesting();\n+    @Spy @InjectMocks private SuperUnderTesting notInitializedSpy;\n+\n+    @Mock private Map map;\n     @Mock private List list;\n \t@Mock private Set histogram1;\n \t@Mock private Set histogram2;\n \t\t// initMocks called in TestBase Before method, so instances ar not the same\n \t\tMockitoAnnotations.initMocks(this);\n \t}\n+\n+    @Test\n+    public void shouldKeepSameInstanceIfFieldInitialized() {\n+        assertSame(baseUnderTestingInstance, initializedBase);\n+    }\n+\n+    @Test\n+    public void shouldInitializeAnnotatedFieldIfNull() {\n+        assertNotNull(notInitializedBase);\n+    }                                          \n+\n+    @Test\n+    public void shouldIInjectMocksInSpy() {\n+        assertNotNull(initializedSpy.getAList());\n+    }\n+    @Test\n+    public void shouldInitializeSpyIfNullAndInjectMocks() {\n+        assertNotNull(notInitializedSpy);\n+        assertNotNull(notInitializedSpy.getAList());\n+    }\n \n \t@Test\n \tpublic void shouldInjectMocksIfAnnotated() {\n \t\tassertSame(searchTree, otherBaseUnderTest.getSearchTree());\n \t}\n \t\n-    @Test(expected=MockitoException.class)\n-    public void shouldProvideDecentExceptionWhenInjectMockInstanceIsNull() throws Exception {\n-        MockitoAnnotations.initMocks(new Object() {\n-           @InjectMocks Object iAmNull = null; \n-        });\n+    @Test\n+    public void shouldInstantiateInjectMockFieldIfPossible() throws Exception {\n+        assertNotNull(notInitializedBase);\n     }\n \n-\tclass SuperUnderTesting {\n+    @Test\n+    public void shouldKeepInstanceOnInjectMockFieldIfPresent() throws Exception {\n+        assertSame(baseUnderTestingInstance, initializedBase);\n+    }\n+\n+    static class SuperUnderTesting {\n \n \t\tprivate List aList;\n \n \t\t}\n \t}\n \n-\tclass BaseUnderTesting extends SuperUnderTesting {\n+\tstatic class BaseUnderTesting extends SuperUnderTesting {\n \t\tprivate Map aMap;\n \n \t\tpublic Map getAMap() {\n \t\t}\n \t}\n \n-\tclass OtherBaseUnderTesting extends SuperUnderTesting {\n+\tstatic class OtherBaseUnderTesting extends SuperUnderTesting {\n \t\tprivate TreeSet searchTree;\n \n \t\tpublic TreeSet getSearchTree() {\n \t\t}\n \t}\n \n-\tclass SubUnderTesting extends BaseUnderTesting {\n+\tstatic class SubUnderTesting extends BaseUnderTesting {\n \t\tprivate Set histogram1;\n \t\tprivate Set histogram2;\n \n--- a/test/org/mockitousage/annotation/SpyAnnotationTest.java\n+++ b/test/org/mockitousage/annotation/SpyAnnotationTest.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockitousage.annotation;\n-\n-import static org.mockito.Mockito.*;\n \n import org.junit.Test;\n import org.mockito.MockitoAnnotations;\n import org.mockito.exceptions.base.MockitoException;\n import org.mockitoutil.TestBase;\n \n+import java.util.AbstractList;\n import java.util.ArrayList;\n import java.util.List;\n \n+import static org.mockito.Mockito.doReturn;\n+\n @SuppressWarnings({\"unchecked\", \"unused\"})\n public class SpyAnnotationTest extends TestBase {\n-\t\n+\n     @Spy\n-\tfinal List spiedList = new ArrayList();\n+    final List spiedList = new ArrayList();\n+\n+    @Spy\n+    NestedClassWithNoArgConstructor staticTypeWithNoArgConstructor;\n+\n+    @Spy\n+    NestedClassWithoutDefinedConstructor staticTypeWithoutDefinedConstructor;\n \n \t@Test\n     public void shouldInitSpies() throws Exception {\n         assertTrue(spiedList.isEmpty());\n     }\n \n+    @Test\n+    public void shouldInitSpyIfNestedStaticClass() throws Exception {\n+\t\tassertNotNull(staticTypeWithNoArgConstructor);\n+\t\tassertNotNull(staticTypeWithoutDefinedConstructor);\n+    }\n+\n     @Test(expected = MockitoException.class)\n-    public void shouldFailIfFieldIsNotInitialized() throws Exception {\n+    public void shouldFailIfTypeIsAnInterface() throws Exception {\n \t\tclass FailingSpy {\n-\t\t\t@Spy private List mySpy;\n+\t\t\t@Spy private List spyTypeIsInterface;\n+\t\t}\n \n-            public List getMySpy() {\n-\t\t\t\treturn mySpy;\n-\t\t\t}\n+\t\tMockitoAnnotations.initMocks(new FailingSpy());\n+    }\n+\n+    @Test(expected = MockitoException.class)\n+    public void shouldFailIfTypeIsAbstract() throws Exception {\n+\t\tclass FailingSpy {\n+\t\t\t@Spy private AbstractList spyTypeIsAbstract;\n+\t\t}\n+\n+\t\tMockitoAnnotations.initMocks(new FailingSpy());\n+    }\n+\n+    @Test(expected = MockitoException.class)\n+    public void shouldFailIfTypeIsInnerClass() throws Exception {\n+\t\tclass FailingSpy {\n+\t\t\t@Spy private List spyTypeIsInner;\n+            class TheInnerClass { }\n \t\t}\n \n \t\tMockitoAnnotations.initMocks(new FailingSpy());\n     public void shouldResetSpies() throws Exception {\n         spiedList.get(10); // see shouldInitSpy\n     }\n-\t\n-\t@Test(expected=MockitoException.class)\n-    public void shouldProvideDecentExceptionWhenSpyInstanceIsNull() throws Exception {\n-        MockitoAnnotations.initMocks(new Object() {\n-            @Spy String spy = null;\n-        });\n+\n+    static class NestedClassWithoutDefinedConstructor { }\n+\n+    static class NestedClassWithNoArgConstructor {\n+        NestedClassWithNoArgConstructor() { }\n+        NestedClassWithNoArgConstructor(String _1arg) { }\n     }\n }", "timestamp": 1287418505, "metainfo": ""}