{"sha": "afac748f7c52c7165d8103266fd6f0ace5eaaa37", "log": "Issue 399: Added serialization for mocks returned by deep stubbing", "commit": "\n--- a/src/org/mockito/internal/MockitoCore.java\n+++ b/src/org/mockito/internal/MockitoCore.java\n-/*\n- * Copyright (c) 2007 Mockito contributors\n- * This program is made available under the terms of the MIT License.\n- */\n+/*\n+ * Copyright (c) 2007 Mockito contributors\n+ * This program is made available under the terms of the MIT License.\n+ */\n package org.mockito.internal;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.List;\n \n import org.mockito.InOrder;\n import org.mockito.MockSettings;\n import org.mockito.internal.verification.api.VerificationDataInOrderImpl;\n import org.mockito.invocation.Invocation;\n import org.mockito.mock.MockCreationSettings;\n-import org.mockito.stubbing.*;\n+import org.mockito.stubbing.Answer;\n+import org.mockito.stubbing.DeprecatedOngoingStubbing;\n+import org.mockito.stubbing.OngoingStubbing;\n+import org.mockito.stubbing.Stubber;\n+import org.mockito.stubbing.VoidMethodStubbable;\n import org.mockito.verification.VerificationMode;\n \n-import java.util.Arrays;\n-import java.util.List;\n+@SuppressWarnings(\"unchecked\")\n+public class MockitoCore implements Serializable {\n \n-@SuppressWarnings(\"unchecked\")\n-public class MockitoCore {\n+    private final transient Reporter reporter = new Reporter();\n+    private final transient MockUtil mockUtil = new MockUtil();\n+    private final transient MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n \n-    private final Reporter reporter = new Reporter();\n-    private final MockUtil mockUtil = new MockUtil();\n-    private final MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n-\n-    public boolean isTypeMockable(Class<?> typeToMock) {\n-        return mockUtil.isTypeMockable(typeToMock);\n-    }\n+    public boolean isTypeMockable(Class<?> typeToMock) {\n+        return mockUtil.isTypeMockable(typeToMock);\n+    }\n \n     public <T> T mock(Class<T> typeToMock, MockSettings settings) {\n         if (!MockSettingsImpl.class.isInstance(settings)) {\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.internal.stubbing.defaultanswers;\n+\n+import static org.mockito.Mockito.*;\n+\n+import java.io.Serializable;\n \n import org.mockito.MockSettings;\n import org.mockito.internal.InternalMockHandler;\n import org.mockito.internal.util.reflection.GenericMetadataSupport;\n import org.mockito.invocation.InvocationOnMock;\n import org.mockito.stubbing.Answer;\n-\n-import java.io.Serializable;\n-\n-import static org.mockito.Mockito.withSettings;\n \n /**\n  * Returning deep stub implementation.\n                 : withSettings();\n \n         return mockSettings\n+\t\t        .serializable()\n                 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));\n     }\n \n \n     private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {\n \n-        container.addAnswer(new Answer<Object>() {\n+        container.addAnswer(new SerializableAnswer() {\n             public Object answer(InvocationOnMock invocation) throws Throwable {\n                 return mock;\n             }\n \n         return mock;\n     }\n+\t\n+\tabstract class SerializableAnswer implements Answer<Object>, Serializable {\n+\t\t\n+\t}\n+\t\n \n     protected GenericMetadataSupport actualParameterizedType(Object mock) {\n         CreationSettings mockSettings = (CreationSettings) new MockUtil().getMockHandler(mock).getMockSettings();\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n  * This program is made available under the terms of the MIT License.\n  */\n package org.mockito.internal.util;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Modifier;\n \n import org.mockito.exceptions.misusing.NotAMockException;\n import org.mockito.internal.InternalMockHandler;\n import org.mockito.mock.MockName;\n import org.mockito.plugins.MockMaker;\n \n-import java.lang.reflect.Modifier;\n-\n @SuppressWarnings(\"unchecked\")\n-public class MockUtil {\n+public class MockUtil implements Serializable {\n \n     private static final MockMaker mockMaker = ClassPathLoader.getMockMaker();\n \n--- a/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n+++ b/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n import org.mockito.exceptions.base.MockitoException;\n import org.mockito.internal.util.Checks;\n \n+import java.io.Serializable;\n import java.lang.reflect.*;\n import java.util.*;\n \n  * @see org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs\n  */\n @Incubating\n-public abstract class GenericMetadataSupport {\n+public abstract class GenericMetadataSupport implements Serializable {\n \n     // public static MockitoLogger logger = new ConsoleMockitoLogger();\n \n      * Offer support to retrieve generic metadata on a {@link Class} by reading type parameters and type variables on\n      * the class and its ancestors and interfaces.\n      */\n-    private static class FromClassGenericMetadataSupport extends GenericMetadataSupport {\n+    private static class FromClassGenericMetadataSupport extends GenericMetadataSupport implements Serializable {\n         private Class<?> clazz;\n \n         public FromClassGenericMetadataSupport(Class<?> clazz) {\n      * That's what meant the \"standalone\" word at the beginning of the Javadoc.\n      * Instead use {@link ParameterizedReturnType}.\n      */\n-    private static class FromParameterizedTypeGenericMetadataSupport extends GenericMetadataSupport {\n+    private static class FromParameterizedTypeGenericMetadataSupport extends GenericMetadataSupport implements Serializable {\n         private ParameterizedType parameterizedType;\n \n         public FromParameterizedTypeGenericMetadataSupport(ParameterizedType parameterizedType) {\n     /**\n      * Generic metadata specific to {@link ParameterizedType} returned via {@link Method#getGenericReturnType()}.\n      */\n-    private static class ParameterizedReturnType extends GenericMetadataSupport {\n+    private static class ParameterizedReturnType extends GenericMetadataSupport implements Serializable {\n         private final ParameterizedType parameterizedType;\n         private final TypeVariable[] typeParameters;\n \n     /**\n      * Generic metadata for {@link TypeVariable} returned via {@link Method#getGenericReturnType()}.\n      */\n-    private static class TypeVariableReturnType extends GenericMetadataSupport {\n+    private static class TypeVariableReturnType extends GenericMetadataSupport implements Serializable {\n         private final TypeVariable typeVariable;\n         private final TypeVariable[] typeParameters;\n         private Class<?> rawType;\n      *\n      * @see <a href=\"http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4\">http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.4</a>\n      */\n-    public static class WildCardBoundedType implements BoundedType {\n+    public static class WildCardBoundedType implements BoundedType, Serializable {\n         private WildcardType wildcard;\n \n \n--- /dev/null\n+++ b/test/org/mockitousage/stubbing/DeepStubsSerializableTest.java\n+package org.mockitousage.stubbing;\n+\n+import static org.fest.assertions.Assertions.*;\n+import static org.mockito.Mockito.*;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+public class DeepStubsSerializableTest {\n+\n+\tpublic static final boolean STUBBED_VALUE = true;\n+\n+\t@Test\n+\tpublic void should_serialize_and_deserialize_mock_created_by_deep_stubs() throws Exception {\n+\t\t// given\n+\t\tSampleClass sampleClass = Mockito.mock(SampleClass.class, withSettings().defaultAnswer(Mockito.RETURNS_DEEP_STUBS).serializable());\n+\t\tMockito.when(sampleClass.getSample().isSth()).thenReturn(STUBBED_VALUE);\n+\n+\t\t// when\n+\t\tByteArrayOutputStream serializationStream = serialize(sampleClass);\n+\n+\t\t// then\n+\t\tObject o = deserialize(serializationStream);\n+\t\tassertThat(o).isInstanceOf(SampleClass.class);\n+\t\tSampleClass deserializedSample = (SampleClass) o;\n+\t\tassertThat(deserializedSample.getSample().isSth()).isEqualTo(STUBBED_VALUE);\n+\t}\n+\n+\tprivate ByteArrayOutputStream serialize(SampleClass sampleClass) throws IOException {\n+\t\tByteArrayOutputStream serializationStream = new ByteArrayOutputStream();\n+\t\tObjectOutputStream objectOutputStream = new ObjectOutputStream(serializationStream);\n+\t\tobjectOutputStream.writeObject(sampleClass);\n+\t\tobjectOutputStream.close();\n+\t\treturn serializationStream;\n+\t}\n+\n+\tprivate Object deserialize(ByteArrayOutputStream serializationStream) throws IOException, ClassNotFoundException {\n+\t\tByteArrayInputStream deserializationStream = new ByteArrayInputStream(serializationStream.toByteArray());\n+\t\tObjectInputStream is = new ObjectInputStream(deserializationStream);\n+\t\treturn is.readObject();\n+\t}\n+\n+\tclass SampleClass implements Serializable {\n+\t\tSampleClass2 getSample(){\n+\t\t\treturn new SampleClass2();\n+\t\t}\n+\t}\n+\n+\tclass SampleClass2 implements Serializable {\n+\t\tboolean isSth(){\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\t\n+}", "timestamp": 1388104473, "metainfo": ""}