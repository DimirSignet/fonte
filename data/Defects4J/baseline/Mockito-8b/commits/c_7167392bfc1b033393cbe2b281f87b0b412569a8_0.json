{"sha": "7167392bfc1b033393cbe2b281f87b0b412569a8", "log": "Made MockUtil proper instance class It make code cleaner plus multithreaded tests should work fine now  --HG-- extra : convert_revision : svn%3Aaa2aecf3-ea3e-0410-9d70-716747e7c967/trunk%401419", "commit": "\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n         if (answer != null) {\n             mockingProgress.getDebuggingInfo().reportUsedStub(invocationMatcher);\n             return answer.answer(invocation);\n-        } else if (MockUtil.isMock(instance)) {\n+        } else if (new MockUtil().isMock(instance)) {\n             return returnValues.valueFor(invocation);\n         } else {\n             Object ret = methodProxy.invokeSuper(proxy, args);\n--- a/src/org/mockito/internal/MockitoCore.java\n+++ b/src/org/mockito/internal/MockitoCore.java\n public class MockitoCore {\n \n     private final Reporter reporter = new Reporter();\n+    private final MockUtil mockUtil = new MockUtil();\n     private final MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n     \n     public <T> T mock(Class<T> classToMock, MockSettings mockSettings) {\n         mockingProgress.validateState();\n         mockingProgress.resetOngoingStubbing();\n-        return MockUtil.createMock(classToMock, mockingProgress, (MockSettingsImpl) mockSettings);\n+        return mockUtil.createMock(classToMock, mockingProgress, (MockSettingsImpl) mockSettings);\n     }\n     \n     public AncillaryTypes implementing(Class<?>...ancillaryTypes) {\n     public <T> T verify(T mock, VerificationMode mode) {\n         if (mock == null) {\n             reporter.nullPassedToVerify();\n-        } else if (!MockUtil.isMock(mock)) {\n+        } else if (!mockUtil.isMock(mock)) {\n             reporter.notAMockPassedToVerify();\n         }\n         mockingProgress.verificationStarted(mode);\n         mockingProgress.resetOngoingStubbing();\n         \n         for (T m : mocks) {\n-            MockUtil.resetMock(m, mockingProgress);\n+            mockUtil.resetMock(m, mockingProgress);\n         }\n     }\n     \n                 if (mock == null) {\n                     reporter.nullPassedToVerifyNoMoreInteractions();\n                 }\n-                MockUtil.getMockHandler(mock).verifyNoMoreInteractions();\n+                mockUtil.getMockHandler(mock).verifyNoMoreInteractions();\n             } catch (NotAMockException e) {\n                 reporter.notAMockPassedToVerifyNoMoreInteractions();\n             }\n         for (Object mock : mocks) {\n             if (mock == null) {\n                 reporter.nullPassedWhenCreatingInOrder();\n-            } else if (!MockUtil.isMock(mock)) {\n+            } else if (!mockUtil.isMock(mock)) {\n                 reporter.notAMockPassedWhenCreatingInOrder();\n             }\n         }\n     }\n     \n     public <T> VoidMethodStubbable<T> stubVoid(T mock) {\n-        MockHandler<T> handler = MockUtil.getMockHandler(mock);\n+        MockHandler<T> handler = mockUtil.getMockHandler(mock);\n         mockingProgress.stubbingStarted();\n         return handler.voidMethodStubbable(mock);\n     }\n--- a/src/org/mockito/internal/invocation/AllInvocationsFinder.java\n+++ b/src/org/mockito/internal/invocation/AllInvocationsFinder.java\n     public List<Invocation> getAllInvocations(List<? extends Object> mocks) {\n         Set<Invocation> invocationsInOrder = new TreeSet<Invocation>(new SequenceNumberComparator());\n         for (Object mock : mocks) {\n-            List<Invocation> fromSingleMock = MockUtil.getMockHandler(mock).getRegisteredInvocations();\n+            List<Invocation> fromSingleMock = new MockUtil().getMockHandler(mock).getRegisteredInvocations();\n             invocationsInOrder.addAll(fromSingleMock);\n         }\n         \n--- a/src/org/mockito/internal/invocation/Invocation.java\n+++ b/src/org/mockito/internal/invocation/Invocation.java\n     }\n \n     private String qualifiedMethodName() {\n-        return MockUtil.getMockName(mock) + \".\" + method.getName();\n+        return new MockUtil().getMockName(mock) + \".\" + method.getName();\n     }\n \n     private String getArgumentsLine(List<Matcher> matchers) {\n--- a/src/org/mockito/internal/returnvalues/EmptyReturnValues.java\n+++ b/src/org/mockito/internal/returnvalues/EmptyReturnValues.java\n     public Object valueFor(InvocationOnMock invocation) {\n         if (Invocation.isToString(invocation)) {\n             Object mock = invocation.getMock();\n-            MockName name = MockUtil.getMockName(mock);\n+            MockName name = new MockUtil().getMockName(mock);\n             if (name.isSurrogate()) {\n                 return \"Mock for \" + ClassNameFinder.classNameForMock(mock) + \", hashCode: \" + mock.hashCode();\n             } else {\n--- a/src/org/mockito/internal/stubbing/StubberImpl.java\n+++ b/src/org/mockito/internal/stubbing/StubberImpl.java\n     private final Reporter reporter = new Reporter();\n \n     public <T> T when(T mock) {\n+        MockUtil mockUtil = new MockUtil();\n+        \n         if (mock == null) {\n             reporter.nullPassedToWhenMethod();\n-        } else if (!MockUtil.isMock(mock)) {\n-            reporter.notAMockPassedToWhenMethod();\n+        } else {\n+            if (!mockUtil.isMock(mock)) {\n+                reporter.notAMockPassedToWhenMethod();\n+            }\n         }\n         \n-        MockUtil.getMockHandler(mock).setAnswersForStubbing(answers);\n+        mockUtil.getMockHandler(mock).setAnswersForStubbing(answers);\n         return mock;\n     }\n \n--- a/src/org/mockito/internal/stubbing/answers/ThrowsException.java\n+++ b/src/org/mockito/internal/stubbing/answers/ThrowsException.java\n     }\n \n     public Object answer(InvocationOnMock invocation) throws Throwable {\n-        if (MockUtil.isMock(throwable)) {\n+        if (new MockUtil().isMock(throwable)) {\n             throw throwable;\n         }\n         Throwable t = throwable.fillInStackTrace();\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n \n public class MockUtil {\n     \n-    public static CreationValidator creationValidator = new CreationValidator();\n+    private final CreationValidator creationValidator;\n \n-    public static <T> T createMock(Class<T> classToMock, MockingProgress progress, MockSettingsImpl settings) {\n+    public MockUtil(CreationValidator creationValidator) {\n+        this.creationValidator = creationValidator;\n+    }\n+    \n+    public MockUtil() {\n+        this(new CreationValidator());\n+    }\n+\n+    public <T> T createMock(Class<T> classToMock, MockingProgress progress, MockSettingsImpl settings) {\n         creationValidator.validateType(classToMock);\n         creationValidator.validateExtraInterfaces(classToMock, settings.getExtraInterfaces());\n         \n         return mock;\n     }\n \n-    public static <T> void resetMock(T mock, MockingProgress progress) {\n+    public <T> void resetMock(T mock, MockingProgress progress) {\n         MockHandler<T> oldMockHandler = (MockHandler<T>) getMockHandler(mock);\n         MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler.getMockName(), progress, new MatchersBinder(), oldMockHandler.getReturnValues());\n         MethodInterceptorFilter<MockHandler<T>> newFilter = new MethodInterceptorFilter<MockHandler<T>>(Object.class, newMockHandler);\n         ((Factory) mock).setCallback(0, newFilter);\n     }\n \n-    public static <T> MockHandler<T> getMockHandler(T mock) {\n+    public <T> MockHandler<T> getMockHandler(T mock) {\n         if (mock == null) {\n             throw new NotAMockException(\"Argument should be a mock, but is null!\");\n         }\n         }\n     }\n \n-    private static <T> boolean isMockitoMock(T mock) {\n+    private <T> boolean isMockitoMock(T mock) {\n         return Enhancer.isEnhanced(mock.getClass()) && getInterceptor(mock) != null;\n     }\n \n-    public static boolean isMock(Object mock) {\n+    public boolean isMock(Object mock) {\n         return mock != null && isMockitoMock(mock);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    private static <T> MethodInterceptorFilter<MockHandler<T>> getInterceptor(T mock) {\n+    private <T> MethodInterceptorFilter<MockHandler<T>> getInterceptor(T mock) {\n         Factory factory = (Factory) mock;\n         Callback callback = factory.getCallback(0);\n         if (callback instanceof MethodInterceptorFilter) {\n         return null;\n     }\n \n-    public static MockName getMockName(Object mock) {\n+    public MockName getMockName(Object mock) {\n         return getMockHandler(mock).getMockName();\n     }\n }\n--- a/test/org/mockito/internal/returnvalues/MockReturnValuesTest.java\n+++ b/test/org/mockito/internal/returnvalues/MockReturnValuesTest.java\n     }\n \n     final class Baz {\n-\n     }\n \n     @Test\n     // FIXME split into separate\n     public void shouldReturnMockValueForInterface() throws Exception {\n         Object interfaceMock = values.returnValueFor(FooInterface.class);\n-        assertTrue(MockUtil.isMock(interfaceMock));\n+        assertTrue(new MockUtil().isMock(interfaceMock));\n     }\n \n     public void shouldReturnMockValueForClass() throws Exception {\n         Object classMock = values.returnValueFor(BarClass.class);\n-        assertTrue(MockUtil.isMock(classMock));\n+        assertTrue(new MockUtil().isMock(classMock));\n     }\n \n     @Test\n     public void shouldReturnEmptyString() throws Throwable {\n         assertEquals(\"\", values.valueFor(invocationOf(StringMethods.class, \"stringMethod\")));\n     }\n-}\n+}\n--- a/test/org/mockito/internal/util/MockUtilTest.java\n+++ b/test/org/mockito/internal/util/MockUtilTest.java\n import net.sf.cglib.proxy.Enhancer;\n import net.sf.cglib.proxy.NoOp;\n \n-import org.junit.After;\n-import org.junit.Before;\n import org.junit.Test;\n import org.mockito.Mockito;\n import org.mockito.exceptions.base.MockitoException;\n         }\n     }\n \n-    @Before\n-    public void setUp() {\n-        MockUtil.creationValidator = new CreationValidatorStub();\n-    }\n-    \n-    @After\n-    public void restoreValidator() {\n-        MockUtil.creationValidator = new CreationValidator();\n-    }\n-    \n+    private CreationValidatorStub creationValidator = new CreationValidatorStub();\n+    private MockUtil mockUtil = new MockUtil(creationValidator);\n+\n     @Test \n     public void shouldValidate() {\n         //given\n-        assertFalse(((CreationValidatorStub) MockUtil.creationValidator).extraInterfacesValidated);\n-        assertFalse(((CreationValidatorStub) MockUtil.creationValidator).typeValidated);\n+        assertFalse(creationValidator.extraInterfacesValidated);\n+        assertFalse(creationValidator.typeValidated);\n \n         //when\n-        MockUtil.createMock(IMethods.class, new ThreadSafeMockingProgress(), new MockSettingsImpl());\n+        mockUtil.createMock(IMethods.class, new ThreadSafeMockingProgress(), new MockSettingsImpl());\n         \n         //then\n-        assertTrue(((CreationValidatorStub) MockUtil.creationValidator).extraInterfacesValidated);\n-        assertTrue(((CreationValidatorStub) MockUtil.creationValidator).typeValidated);\n+        assertTrue(creationValidator.extraInterfacesValidated);\n+        assertTrue(creationValidator.typeValidated);\n     }\n \n     @Test \n     public void shouldGetHandler() {\n         List mock = Mockito.mock(List.class);\n-        assertNotNull(MockUtil.getMockHandler(mock));\n+        assertNotNull(mockUtil.getMockHandler(mock));\n     }\n \n     @Test \n     public void shouldScreamWhenEnhancedButNotAMockPassed() {\n         Object o = Enhancer.create(ArrayList.class, NoOp.INSTANCE);\n         try {\n-            MockUtil.getMockHandler(o);\n+            mockUtil.getMockHandler(o);\n             fail();\n         } catch (NotAMockException e) {}\n     }\n \n     @Test (expected=NotAMockException.class)\n     public void shouldScreamWhenNotAMockPassed() {\n-        MockUtil.getMockHandler(\"\");\n+        mockUtil.getMockHandler(\"\");\n     }\n     \n     @Test (expected=MockitoException.class)\n     public void shouldScreamWhenNullPassed() {\n-        MockUtil.getMockHandler(null);\n+        mockUtil.getMockHandler(null);\n     }\n     \n     @Test\n     public void shouldValidateMock() {\n-        assertFalse(MockUtil.isMock(\"i mock a mock\"));\n-        assertTrue(MockUtil.isMock(Mockito.mock(List.class)));\n+        assertFalse(mockUtil.isMock(\"i mock a mock\"));\n+        assertTrue(mockUtil.isMock(Mockito.mock(List.class)));\n     }\n }\n--- a/test/org/mockitousage/misuse/DetectingFinalMethodsTest.java\n+++ b/test/org/mockitousage/misuse/DetectingFinalMethodsTest.java\n     @Test\n     public void shouldFailWithUnfinishedStubbing() {\n         withFinal = mock(WithFinal.class);\n-        MockUtil.getMockHandler(withFinal);\n+        new MockUtil().getMockHandler(withFinal);\n         try {\n             when(withFinal.foo()).thenReturn(null);\n             fail();", "timestamp": 1242076659, "metainfo": ""}