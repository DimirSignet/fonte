{"sha": "f4f17245a28a82450725257c6c433dfc721af15b", "log": "Tweaks InjectMocks javadoc", "commit": "\n--- a/src/org/mockito/InjectMocks.java\n+++ b/src/org/mockito/InjectMocks.java\n  * i.e. you will have to provide dependencies yourself.\n  * <ol>\n  *     <li><strong>Constructor injection</strong>; the biggest constructor is chosen,\n- *     then arguments are resolved with mocks declared in the test only.\n+ *     then arguments are resolved with mocks declared in the test only. If the object is successfully created\n+ *     with the constructor, then <strong>Mockito won't try the other strategies</strong>. Mockito has decided to no\n+ *     corrupt an object if it has a parametered constructor.\n  *     <p><u>Note:</u> If arguments can not be found, then null is passed.\n  *     If non-mockable types are wanted, then constructor injection won't happen.\n  *     In these cases, you will have to satisfy dependencies yourself.</p></li>\n  *\n- *     <li><strong>Property setter injection</strong>; mocks will first be resolved by type,\n+ *     <li><strong>Property setter injection</strong>; mocks will first be resolved by type (if a single type match\n+ *     injection will happen regardless of the name),\n  *     then, if there is several property of the same type, by the match of the property name and the mock name.\n  *     <p><u>Note 1:</u> If you have properties with the same type (or same erasure), it's better to name all &#064;Mock\n  *     annotated fields with the matching properties, otherwise Mockito might get confused and injection won't happen.</p>\n  *     <p><u>Note 2:</u> If &#064;InjectMocks instance wasn't initialized before and have a no-arg constructor,\n  *     then it will be initialized with this constructor.</p></li>\n  *\n- *     <li><strong>Field injection</strong>; mocks will first be resolved by type,\n+ *     <li><strong>Field injection</strong>; mocks will first be resolved by type (if a single type match\n+ *     injection will happen regardless of the name),\n  *     then, if there is several property of the same type, by the match of the field name and the mock name.\n  *     <p><u>Note 1:</u> If you have fields with the same type (or same erasure), it's better to name all &#064;Mock\n  *     annotated fields with the matching fields, otherwise Mockito might get confused and injection won't happen.</p>\n  * </p>\n  *\n  * <p>\n- * In the above example the field ArticleManager annotated with &#064;InjectMocks can have\n+ * In the above example the field <code>ArticleManager</code> annotated with <code>&#064;InjectMocks</code> can have\n  * a parameterized constructor only or a no-arg constructor only, or both.\n  * All these constructors can be package protected, protected or private, however\n  * <u>Mockito cannot instantiate inner classes, local classes, abstract classes and of course interfaces.</u>\n  * {@link org.mockito.runners.MockitoJUnitRunner}.\n  * </p>\n  *\n+ * <p>\n+ * Mockito is not an dependency injection framework, don't expect this shorthand utility to inject a complex graph of objects\n+ * be it mocks/spies or real objects.\n+ * </p>\n+ *\n  * @see Mock\n  * @see Spy\n  * @see MockitoAnnotations#initMocks(Object)\n--- a/src/org/mockito/Mockito.java\n+++ b/src/org/mockito/Mockito.java\n  * </ul>\n  *\n  * <p>\n- * Note that &#064;{@link InjectMocks} can only be used in combination with the &#064;{@link Spy} annotation, it means\n- * that Mockito will inject mocks in a partial mock under testing. As a remainder, please read point 16 about partial mocks.\n+ * Note that &#064;{@link InjectMocks} can also be used in combination with the &#064;{@link Spy} annotation, it means\n+ * that Mockito will inject mocks into the partial mock under test. This complexity is another good reason why you\n+ * should only use partial mocks as a last resort. See point 16 about partial mocks.\n  *\n  * <p>\n  * All new annotations are <b>*only*</b> processed on {@link MockitoAnnotations#initMocks(Object)}.", "timestamp": 1406228752, "metainfo": ""}